/* bypass certain compile time usage checks */
#define JUCE_AMALGAMATED_INCLUDE 1

#include "AppConfig.h"


/*** Start of inlined file: juce_audio_formats.cpp ***/
#if defined (__JUCE_AUDIO_FORMATS_JUCEHEADER__) && ! JUCE_AMALGAMATED_INCLUDE
 /* When you add this cpp file to your project, you mustn't include it in a file where you've
	already included any other headers - just put it inside a file on its own, possibly with your config
	flags preceding it, but don't include anything else. That also includes avoiding any automatic prefix
	header files that the compiler may be using.
 */
 #error "Incorrect use of JUCE cpp file"
#endif

// Your project must contain an AppConfig.h file with your project-specific settings in it,
// and your header search path must make it accessible to the module's files.
#include "AppConfig.h"


/*** Start of inlined file: juce_BasicNativeHeaders.h ***/
#ifndef __JUCE_BASICNATIVEHEADERS_JUCEHEADER__
#define __JUCE_BASICNATIVEHEADERS_JUCEHEADER__


/*** Start of inlined file: juce_TargetPlatform.h ***/
#ifndef __JUCE_TARGETPLATFORM_JUCEHEADER__
#define __JUCE_TARGETPLATFORM_JUCEHEADER__

/*  This file figures out which platform is being built, and defines some macros
	that the rest of the code can use for OS-specific compilation.

	Macros that will be set here are:

	- One of JUCE_WINDOWS, JUCE_MAC JUCE_LINUX, JUCE_IOS, JUCE_ANDROID, etc.
	- Either JUCE_32BIT or JUCE_64BIT, depending on the architecture.
	- Either JUCE_LITTLE_ENDIAN or JUCE_BIG_ENDIAN.
	- Either JUCE_INTEL or JUCE_PPC
	- Either JUCE_GCC or JUCE_MSVC
*/

/* This line is here as a sanity-check to catch syntax errors caused by mistakes in 3rd-party
   header files that have been included before this one. If you hit an error at this line, there
   must be some kind of syntax problem in whatever code immediately precedes this header.

   It also causes an error if you attempt to build using a C or obj-C compiler rather than a C++ one.
*/
namespace JuceDummyNamespace {}

#if (defined (_WIN32) || defined (_WIN64))
  #define       JUCE_WIN32 1
  #define       JUCE_WINDOWS 1
#elif defined (JUCE_ANDROID)
  #undef        JUCE_ANDROID
  #define       JUCE_ANDROID 1
#elif defined (LINUX) || defined (__linux__)
  #define     JUCE_LINUX 1
#elif defined (__APPLE_CPP__) || defined(__APPLE_CC__)
  #define Point CarbonDummyPointName // (workaround to avoid definition of "Point" by old Carbon headers)
  #define Component CarbonDummyCompName
  #include <CoreFoundation/CoreFoundation.h> // (needed to find out what platform we're using)
  #undef Point
  #undef Component

  #if TARGET_OS_IPHONE || TARGET_IPHONE_SIMULATOR
	#define     JUCE_IPHONE 1
	#define     JUCE_IOS 1
  #else
	#define     JUCE_MAC 1
  #endif
#else
  #error "Unknown platform!"
#endif

#if JUCE_WINDOWS
  #ifdef _MSC_VER
	#ifdef _WIN64
	  #define JUCE_64BIT 1
	#else
	  #define JUCE_32BIT 1
	#endif
  #endif

  #ifdef _DEBUG
	#define JUCE_DEBUG 1
  #endif

  #ifdef __MINGW32__
	#define JUCE_MINGW 1
  #endif

  /** If defined, this indicates that the processor is little-endian. */
  #define JUCE_LITTLE_ENDIAN 1

  #define JUCE_INTEL 1
#endif

#if JUCE_MAC || JUCE_IOS

  #if defined (DEBUG) || defined (_DEBUG) || ! (defined (NDEBUG) || defined (_NDEBUG))
	#define JUCE_DEBUG 1
  #endif

  #if ! (defined (DEBUG) || defined (_DEBUG) || defined (NDEBUG) || defined (_NDEBUG))
	#warning "Neither NDEBUG or DEBUG has been defined - you should set one of these to make it clear whether this is a release build,"
  #endif

  #ifdef __LITTLE_ENDIAN__
	#define JUCE_LITTLE_ENDIAN 1
  #else
	#define JUCE_BIG_ENDIAN 1
  #endif
#endif

#if JUCE_MAC

  #if defined (__ppc__) || defined (__ppc64__)
	#define JUCE_PPC 1
  #else
	#define JUCE_INTEL 1
  #endif

  #ifdef __LP64__
	#define JUCE_64BIT 1
  #else
	#define JUCE_32BIT 1
  #endif

  #if MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_4
	#error "Building for OSX 10.3 is no longer supported!"
  #endif

  #ifndef MAC_OS_X_VERSION_10_5
	#error "To build with 10.4 compatibility, use a 10.5 or 10.6 SDK and set the deployment target to 10.4"
  #endif

#endif

#if JUCE_LINUX || JUCE_ANDROID

  #ifdef _DEBUG
	#define JUCE_DEBUG 1
  #endif

  // Allow override for big-endian Linux platforms
  #if defined (__LITTLE_ENDIAN__) || ! defined (JUCE_BIG_ENDIAN)
	#define JUCE_LITTLE_ENDIAN 1
	#undef JUCE_BIG_ENDIAN
  #else
	#undef JUCE_LITTLE_ENDIAN
	#define JUCE_BIG_ENDIAN 1
  #endif

  #if defined (__LP64__) || defined (_LP64)
	#define JUCE_64BIT 1
  #else
	#define JUCE_32BIT 1
  #endif

  #if __MMX__ || __SSE__ || __amd64__
	#define JUCE_INTEL 1
  #endif
#endif

// Compiler type macros.

#ifdef __GNUC__
  #define JUCE_GCC 1
#elif defined (_MSC_VER)
  #define JUCE_MSVC 1

  #if _MSC_VER < 1500
	#define JUCE_VC8_OR_EARLIER 1

	#if _MSC_VER < 1400
	  #define JUCE_VC7_OR_EARLIER 1

	  #if _MSC_VER < 1300
		#warning "MSVC 6.0 is no longer supported!"
	  #endif
	#endif
  #endif

  #if JUCE_64BIT || ! JUCE_VC7_OR_EARLIER
	#define JUCE_USE_INTRINSICS 1
  #endif
#else
  #error unknown compiler
#endif

#endif   // __JUCE_TARGETPLATFORM_JUCEHEADER__

/*** End of inlined file: juce_TargetPlatform.h ***/

#undef T

#if JUCE_MAC || JUCE_IOS

 #if JUCE_IOS
  #import <Foundation/Foundation.h>
  #import <UIKit/UIKit.h>
  #import <CoreData/CoreData.h>
  #import <MobileCoreServices/MobileCoreServices.h>
  #include <sys/fcntl.h>
 #else
  #define Point CarbonDummyPointName
  #define Component CarbonDummyCompName
  #import <Cocoa/Cocoa.h>
  #import <CoreAudio/HostTime.h>
  #undef Point
  #undef Component
  #include <sys/dir.h>
 #endif

 #include <sys/socket.h>
 #include <sys/sysctl.h>
 #include <sys/stat.h>
 #include <sys/param.h>
 #include <sys/mount.h>
 #include <sys/utsname.h>
 #include <sys/mman.h>
 #include <fnmatch.h>
 #include <utime.h>
 #include <dlfcn.h>
 #include <ifaddrs.h>
 #include <net/if_dl.h>
 #include <mach/mach_time.h>
 #include <mach-o/dyld.h>

#elif JUCE_WINDOWS
 #if JUCE_MSVC
  #ifndef _CPPRTTI
   #error "You're compiling without RTTI enabled! This is needed for a lot of JUCE classes, please update your compiler settings!"
  #endif

  #ifndef _CPPUNWIND
   #error "You're compiling without exceptions enabled! This is needed for a lot of JUCE classes, please update your compiler settings!"
  #endif

  #pragma warning (push)
  #pragma warning (disable : 4100 4201 4514 4312 4995)
 #endif

 #define STRICT 1
 #define WIN32_LEAN_AND_MEAN 1
 #define _WIN32_WINNT 0x0600
 #define _UNICODE 1
 #define UNICODE 1
 #ifndef _WIN32_IE
  #define _WIN32_IE 0x0400
 #endif

 #include <windows.h>
 #include <shellapi.h>
 #include <tchar.h>
 #include <stddef.h>
 #include <ctime>
 #include <wininet.h>
 #include <nb30.h>
 #include <iphlpapi.h>
 #include <mapi.h>
 #include <float.h>
 #include <process.h>
 #include <shlobj.h>
 #include <shlwapi.h>
 #include <mmsystem.h>

 #if ! JUCE_MINGW
  #include <crtdbg.h>
  #include <comutil.h>
 #endif

 #undef PACKED

 #if JUCE_MSVC
  #pragma warning (pop)
  #pragma warning (4: 4511 4512 4100 /*4365*/)  // (enable some warnings that are turned off in VC8)
 #endif

 #if JUCE_MSVC && ! JUCE_DONT_AUTOLINK_TO_WIN32_LIBRARIES
  #pragma comment (lib, "kernel32.lib")
  #pragma comment (lib, "user32.lib")
  #pragma comment (lib, "shell32.lib")
  #pragma comment (lib, "wininet.lib")
  #pragma comment (lib, "advapi32.lib")
  #pragma comment (lib, "ws2_32.lib")
  #pragma comment (lib, "version.lib")
  #pragma comment (lib, "shlwapi.lib")
  #pragma comment (lib, "winmm.lib")

  #ifdef _NATIVE_WCHAR_T_DEFINED
   #ifdef _DEBUG
	#pragma comment (lib, "comsuppwd.lib")
   #else
	#pragma comment (lib, "comsuppw.lib")
   #endif
  #else
   #ifdef _DEBUG
	#pragma comment (lib, "comsuppd.lib")
   #else
	#pragma comment (lib, "comsupp.lib")
   #endif
  #endif
 #endif

 /* Used with DynamicLibrary to simplify importing functions

	functionName: function to import
	localFunctionName: name you want to use to actually call it (must be different)
	returnType: the return type
	object: the DynamicLibrary to use
	params: list of params (bracketed)
 */
 #define JUCE_DLL_FUNCTION(functionName, localFunctionName, returnType, object, params) \
	typedef returnType (WINAPI *type##localFunctionName) params; \
	type##localFunctionName localFunctionName = (type##localFunctionName)object.getFunction (#functionName);

#elif JUCE_LINUX
 #include <sched.h>
 #include <pthread.h>
 #include <sys/time.h>
 #include <errno.h>
 #include <sys/stat.h>
 #include <sys/dir.h>
 #include <sys/ptrace.h>
 #include <sys/vfs.h>
 #include <sys/wait.h>
 #include <sys/mman.h>
 #include <fnmatch.h>
 #include <utime.h>
 #include <pwd.h>
 #include <fcntl.h>
 #include <dlfcn.h>
 #include <netdb.h>
 #include <arpa/inet.h>
 #include <netinet/in.h>
 #include <sys/types.h>
 #include <sys/ioctl.h>
 #include <sys/socket.h>
 #include <net/if.h>
 #include <sys/sysinfo.h>
 #include <sys/file.h>
 #include <sys/prctl.h>
 #include <signal.h>

#elif JUCE_ANDROID
 #include <jni.h>
 #include <pthread.h>
 #include <sched.h>
 #include <sys/time.h>
 #include <utime.h>
 #include <errno.h>
 #include <fcntl.h>
 #include <dlfcn.h>
 #include <sys/stat.h>
 #include <sys/statfs.h>
 #include <sys/ptrace.h>
 #include <sys/sysinfo.h>
 #include <sys/mman.h>
 #include <pwd.h>
 #include <dirent.h>
 #include <fnmatch.h>
 #include <sys/wait.h>
#endif

// Need to clear various moronic redefinitions made by system headers..
#undef max
#undef min
#undef direct
#undef check

#endif   // __JUCE_BASICNATIVEHEADERS_JUCEHEADER__

/*** End of inlined file: juce_BasicNativeHeaders.h ***/


/*** Start of inlined file: juce_audio_formats.h ***/
#ifndef __JUCE_AUDIO_FORMATS_JUCEHEADER__
#define __JUCE_AUDIO_FORMATS_JUCEHEADER__


/*** Start of inlined file: juce_audio_basics.h ***/
#ifndef __JUCE_AUDIO_BASICS_JUCEHEADER__
#define __JUCE_AUDIO_BASICS_JUCEHEADER__


/*** Start of inlined file: juce_core.h ***/
#ifndef __JUCE_CORE_JUCEHEADER__
#define __JUCE_CORE_JUCEHEADER__

/** Config: JUCE_FORCE_DEBUG

	Normally, JUCE_DEBUG is set to 1 or 0 based on compiler and project settings,
	but if you define this value, you can override this to force it to be true or false.
*/
#ifndef JUCE_FORCE_DEBUG
 //#define JUCE_FORCE_DEBUG 0
#endif

/** Config: JUCE_LOG_ASSERTIONS

	If this flag is enabled, the the jassert and jassertfalse macros will always use Logger::writeToLog()
	to write a message when an assertion happens.

	Enabling it will also leave this turned on in release builds. When it's disabled,
	however, the jassert and jassertfalse macros will not be compiled in a
	release build.

	@see jassert, jassertfalse, Logger
*/
#ifndef JUCE_LOG_ASSERTIONS
 #define JUCE_LOG_ASSERTIONS 0
#endif

/** Config: JUCE_CHECK_MEMORY_LEAKS

	Enables a memory-leak check for certain objects when the app terminates. See the LeakedObjectDetector
	class and the JUCE_LEAK_DETECTOR macro for more details about enabling leak checking for specific classes.
*/
#if JUCE_DEBUG && ! defined (JUCE_CHECK_MEMORY_LEAKS)
 #define JUCE_CHECK_MEMORY_LEAKS 1
#endif

/** Config: JUCE_DONT_AUTOLINK_TO_WIN32_LIBRARIES

	In a Visual C++  build, this can be used to stop the required system libs being
	automatically added to the link stage.
*/
#ifndef JUCE_DONT_AUTOLINK_TO_WIN32_LIBRARIES
 #define JUCE_DONT_AUTOLINK_TO_WIN32_LIBRARIES 0
#endif

/*  Config: JUCE_INCLUDE_ZLIB_CODE
	This can be used to disable Juce's embedded 3rd-party zlib code.
	You might need to tweak this if you're linking to an external zlib library in your app,
	but for normal apps, this option should be left alone.

	If you disable this, you might also want to set a value for JUCE_ZLIB_INCLUDE_PATH, to
	specify the path where your zlib headers live.
*/
#ifndef JUCE_INCLUDE_ZLIB_CODE
 #define JUCE_INCLUDE_ZLIB_CODE 1
#endif

#ifndef JUCE_ZLIB_INCLUDE_PATH
 #define JUCE_ZLIB_INCLUDE_PATH <zlib.h>
#endif

/*  Config: JUCE_CATCH_UNHANDLED_EXCEPTIONS
	If enabled, this will add some exception-catching code to forward unhandled exceptions
	to your JUCEApplication::unhandledException() callback.
*/
#ifndef JUCE_CATCH_UNHANDLED_EXCEPTIONS
 //#define JUCE_CATCH_UNHANDLED_EXCEPTIONS 1
#endif

#if JUCE_MSVC
 #pragma warning (disable: 4251) // (DLL build warning, must be disabled before pushing the warning state)

 #pragma pack (push, 8) // this is set explicitly in case the app is using a different packing size.
 #pragma warning (push)
 #pragma warning (disable: 4786) // (long class name warning)
 #ifdef __INTEL_COMPILER
  #pragma warning (disable: 1125)
 #endif
#endif


/*** Start of inlined file: juce_StandardHeader.h ***/
#ifndef __JUCE_STANDARDHEADER_JUCEHEADER__
#define __JUCE_STANDARDHEADER_JUCEHEADER__

/** Current JUCE version number.

	See also SystemStats::getJUCEVersion() for a string version.
*/
#define JUCE_MAJOR_VERSION      2
#define JUCE_MINOR_VERSION      0
#define JUCE_BUILDNUMBER        18

/** Current Juce version number.

	Bits 16 to 32 = major version.
	Bits 8 to 16 = minor version.
	Bits 0 to 8 = point release.

	See also SystemStats::getJUCEVersion() for a string version.
*/
#define JUCE_VERSION            ((JUCE_MAJOR_VERSION << 16) + (JUCE_MINOR_VERSION << 8) + JUCE_BUILDNUMBER)

#ifndef DOXYGEN
 // These are old macros that are now deprecated: you should just use the juce namespace directly.
 #define JUCE_NAMESPACE juce
 #define BEGIN_JUCE_NAMESPACE    namespace juce {
 #define END_JUCE_NAMESPACE      }
#endif


/*** Start of inlined file: juce_PlatformDefs.h ***/
#ifndef __JUCE_PLATFORMDEFS_JUCEHEADER__
#define __JUCE_PLATFORMDEFS_JUCEHEADER__

/*  This file defines miscellaneous macros for debugging, assertions, etc.
*/

#ifdef JUCE_FORCE_DEBUG
 #undef JUCE_DEBUG

 #if JUCE_FORCE_DEBUG
  #define JUCE_DEBUG 1
 #endif
#endif

/** This macro defines the C calling convention used as the standard for Juce calls. */
#if JUCE_MSVC
 #define JUCE_CALLTYPE   __stdcall
 #define JUCE_CDECL      __cdecl
#else
 #define JUCE_CALLTYPE
 #define JUCE_CDECL
#endif

// Debugging and assertion macros

#if JUCE_LOG_ASSERTIONS
 #define juce_LogCurrentAssertion    juce_LogAssertion (__FILE__, __LINE__);
#elif JUCE_DEBUG
 #define juce_LogCurrentAssertion    std::cerr << "JUCE Assertion failure in " << __FILE__ << ", line " << __LINE__ << std::endl;
#else
 #define juce_LogCurrentAssertion
#endif

#if JUCE_MAC || JUCE_IOS || JUCE_LINUX || JUCE_ANDROID
  /** This will try to break into the debugger if the app is currently being debugged.
	  If called by an app that's not being debugged, the behaiour isn't defined - it may crash or not, depending
	  on the platform.
	  @see jassert()
  */
  #define juce_breakDebugger        { ::kill (0, SIGTRAP); }
#elif JUCE_USE_INTRINSICS
  #ifndef __INTEL_COMPILER
	#pragma intrinsic (__debugbreak)
  #endif
  #define juce_breakDebugger        { __debugbreak(); }
#elif JUCE_GCC
  #define juce_breakDebugger        { asm("int $3"); }
#else
  #define juce_breakDebugger        { __asm int 3 }
#endif

#if JUCE_DEBUG || DOXYGEN
  /** Writes a string to the standard error stream.
	  This is only compiled in a debug build.
	  @see Logger::outputDebugString
  */
  #define DBG(dbgtext)              { juce::String tempDbgBuf; tempDbgBuf << dbgtext; juce::Logger::outputDebugString (tempDbgBuf); }

  /** This will always cause an assertion failure.
	  It is only compiled in a debug build, (unless JUCE_LOG_ASSERTIONS is enabled for your build).
	  @see jassert
  */
  #define jassertfalse              { juce_LogCurrentAssertion; if (juce::juce_isRunningUnderDebugger()) juce_breakDebugger; }

  /** Platform-independent assertion macro.

	  This macro gets turned into a no-op when you're building with debugging turned off, so be
	  careful that the expression you pass to it doesn't perform any actions that are vital for the
	  correct behaviour of your program!
	  @see jassertfalse
  */
  #define jassert(expression)       { if (! (expression)) jassertfalse; }

#else

  // If debugging is disabled, these dummy debug and assertion macros are used..

  #define DBG(dbgtext)
  #define jassertfalse              { juce_LogCurrentAssertion }

  #if JUCE_LOG_ASSERTIONS
   #define jassert(expression)      { if (! (expression)) jassertfalse; }
  #else
   #define jassert(a)               {}
  #endif

#endif

#ifndef DOXYGEN
namespace juce
{
	template <bool b> struct JuceStaticAssert;
	template <> struct JuceStaticAssert <true> { static void dummy() {} };
}
#endif

/** A compile-time assertion macro.
	If the expression parameter is false, the macro will cause a compile error. (The actual error
	message that the compiler generates may be completely bizarre and seem to have no relation to
	the place where you put the static_assert though!)
*/
#define static_jassert(expression)      juce::JuceStaticAssert<expression>::dummy();

/** This is a shorthand macro for declaring stubs for a class's copy constructor and operator=.

	For example, instead of
	@code
	class MyClass
	{
		etc..

	private:
		MyClass (const MyClass&);
		MyClass& operator= (const MyClass&);
	};@endcode

	..you can just write:

	@code
	class MyClass
	{
		etc..

	private:
		JUCE_DECLARE_NON_COPYABLE (MyClass);
	};@endcode
*/
#define JUCE_DECLARE_NON_COPYABLE(className) \
	className (const className&);\
	className& operator= (const className&)

/** This is a shorthand way of writing both a JUCE_DECLARE_NON_COPYABLE and
	JUCE_LEAK_DETECTOR macro for a class.
*/
#define JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(className) \
	JUCE_DECLARE_NON_COPYABLE(className);\
	JUCE_LEAK_DETECTOR(className)

/** This macro can be added to class definitions to disable the use of new/delete to
	allocate the object on the heap, forcing it to only be used as a stack or member variable.
*/
#define JUCE_PREVENT_HEAP_ALLOCATION \
   private: \
	static void* operator new (size_t); \
	static void operator delete (void*);

#if ! DOXYGEN
 #define JUCE_JOIN_MACRO_HELPER(a, b) a ## b
 #define JUCE_STRINGIFY_MACRO_HELPER(a) #a
#endif

/** A good old-fashioned C macro concatenation helper.
	This combines two items (which may themselves be macros) into a single string,
	avoiding the pitfalls of the ## macro operator.
*/
#define JUCE_JOIN_MACRO(item1, item2)  JUCE_JOIN_MACRO_HELPER (item1, item2)

/** A handy C macro for stringifying any symbol, rather than just a macro parameter.
*/
#define JUCE_STRINGIFY(item)  JUCE_STRINGIFY_MACRO_HELPER (item)

#if JUCE_CATCH_UNHANDLED_EXCEPTIONS

  #define JUCE_TRY try

  #define JUCE_CATCH_ALL            catch (...) {}
  #define JUCE_CATCH_ALL_ASSERT     catch (...) { jassertfalse; }

  #if ! JUCE_MODULE_AVAILABLE_juce_gui_basics
	#define JUCE_CATCH_EXCEPTION    JUCE_CATCH_ALL
  #else
	/** Used in try-catch blocks, this macro will send exceptions to the JUCEApplication
		object so they can be logged by the application if it wants to.
	*/
	#define JUCE_CATCH_EXCEPTION \
	  catch (const std::exception& e)  \
	  { \
		  JUCEApplication::sendUnhandledException (&e, __FILE__, __LINE__); \
	  } \
	  catch (...) \
	  { \
		  JUCEApplication::sendUnhandledException (nullptr, __FILE__, __LINE__); \
	  }
  #endif

#else

  #define JUCE_TRY
  #define JUCE_CATCH_EXCEPTION
  #define JUCE_CATCH_ALL
  #define JUCE_CATCH_ALL_ASSERT

#endif

#if JUCE_DEBUG || DOXYGEN
  /** A platform-independent way of forcing an inline function.
	  Use the syntax: @code
	  forcedinline void myfunction (int x)
	  @endcode
  */
  #define forcedinline  inline
#else
  #if JUCE_MSVC
   #define forcedinline       __forceinline
  #else
   #define forcedinline       inline __attribute__((always_inline))
  #endif
#endif

#if JUCE_MSVC || DOXYGEN
  /** This can be placed before a stack or member variable declaration to tell the compiler
	  to align it to the specified number of bytes. */
  #define JUCE_ALIGN(bytes)   __declspec (align (bytes))
#else
  #define JUCE_ALIGN(bytes)   __attribute__ ((aligned (bytes)))
#endif

// Cross-compiler deprecation macros..
#if DOXYGEN || (JUCE_MSVC && ! JUCE_NO_DEPRECATION_WARNINGS)
 /** This can be used to wrap a function which has been deprecated. */
 #define JUCE_DEPRECATED(functionDef)     __declspec(deprecated) functionDef
#elif JUCE_GCC  && ! JUCE_NO_DEPRECATION_WARNINGS
 #define JUCE_DEPRECATED(functionDef)     functionDef __attribute__ ((deprecated))
#else
 #define JUCE_DEPRECATED(functionDef)     functionDef
#endif

#if JUCE_ANDROID && ! DOXYGEN
 #define JUCE_MODAL_LOOPS_PERMITTED 0
#else
 /** Some operating environments don't provide a modal loop mechanism, so this flag can be
	 used to disable any functions that try to run a modal loop. */
 #define JUCE_MODAL_LOOPS_PERMITTED 1
#endif

// Here, we'll check for C++11 compiler support, and if it's not available, define
// a few workarounds, so that we can still use some of the newer language features.
#if defined (__GXX_EXPERIMENTAL_CXX0X__) && defined (__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5))
 #define JUCE_COMPILER_SUPPORTS_NOEXCEPT 1
 #define JUCE_COMPILER_SUPPORTS_NULLPTR 1
 #define JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS 1
#endif

#if defined (__clang__) && defined (__has_feature)
 #if __has_feature (cxx_nullptr)
  #define JUCE_COMPILER_SUPPORTS_NULLPTR 1
 #endif

 #if __has_feature (cxx_noexcept)
  #define JUCE_COMPILER_SUPPORTS_NOEXCEPT 1
 #endif

 #if __has_feature (cxx_rvalue_references)
  #define JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS 1
 #endif
#endif

#if defined (_MSC_VER) && _MSC_VER >= 1600
 #define JUCE_COMPILER_SUPPORTS_NOEXCEPT 0
 #define JUCE_COMPILER_SUPPORTS_NULLPTR 1
 #define JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS 1
#endif

// Declare some fake versions of nullptr and noexcept, for older compilers:
#if ! (DOXYGEN || JUCE_COMPILER_SUPPORTS_NOEXCEPT)
 #define noexcept  throw()
#endif

#if ! (DOXYGEN || JUCE_COMPILER_SUPPORTS_NULLPTR)
 #define nullptr (0)
#endif

#endif   // __JUCE_PLATFORMDEFS_JUCEHEADER__

/*** End of inlined file: juce_PlatformDefs.h ***/

// Now we'll include any OS headers we need.. (at this point we are outside the Juce namespace).
#if JUCE_MSVC
 #pragma warning (push)
 #pragma warning (disable: 4514 4245 4100)
#endif

#include <cstdlib>
#include <cstdarg>
#include <climits>
#include <limits>
#include <cmath>
#include <cwchar>
#include <stdexcept>
#include <typeinfo>
#include <cstring>
#include <cstdio>
#include <iostream>
#include <vector>

#if JUCE_USE_INTRINSICS
 #include <intrin.h>
#endif

#if JUCE_MAC || JUCE_IOS
 #include <libkern/OSAtomic.h>
#endif

#if JUCE_LINUX
 #include <signal.h>

 #if __INTEL_COMPILER
  #if __ia64__
   #include <ia64intrin.h>
  #else
   #include <ia32intrin.h>
  #endif
 #endif
#endif

#if JUCE_MSVC && JUCE_DEBUG
 #include <crtdbg.h>
#endif

#if JUCE_MSVC
 #include <malloc.h>
 #pragma warning (pop)
#endif

#if JUCE_ANDROID
 #include <sys/atomics.h>
 #include <byteswap.h>
#endif

// DLL building settings on Windows
#if JUCE_MSVC
 #ifdef JUCE_DLL_BUILD
  #define JUCE_API __declspec (dllexport)
  #pragma warning (disable: 4251)
 #elif defined (JUCE_DLL)
  #define JUCE_API __declspec (dllimport)
  #pragma warning (disable: 4251)
 #endif
 #ifdef __INTEL_COMPILER
  #pragma warning (disable: 1125) // (virtual override warning)
 #endif
#elif defined (__GNUC__) && ((__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
 #ifdef JUCE_DLL_BUILD
  #define JUCE_API __attribute__ ((visibility("default")))
 #endif
#endif

#ifndef JUCE_API
 /** This macro is added to all juce public class declarations. */
 #define JUCE_API
#endif

/** This macro is added to all juce public function declarations. */
#define JUCE_PUBLIC_FUNCTION        JUCE_API JUCE_CALLTYPE

/** This turns on some non-essential bits of code that should prevent old code from compiling
	in cases where method signatures have changed, etc.
*/
#if (! defined (JUCE_CATCH_DEPRECATED_CODE_MISUSE)) && JUCE_DEBUG && ! DOXYGEN
 #define JUCE_CATCH_DEPRECATED_CODE_MISUSE 1
#endif

// Now include some basics that are needed by most of the Juce classes...
BEGIN_JUCE_NAMESPACE

extern JUCE_API bool JUCE_CALLTYPE juce_isRunningUnderDebugger();

#if JUCE_LOG_ASSERTIONS
 extern JUCE_API void juce_LogAssertion (const char* filename, int lineNum) noexcept;
#endif


/*** Start of inlined file: juce_Memory.h ***/
#ifndef __JUCE_MEMORY_JUCEHEADER__
#define __JUCE_MEMORY_JUCEHEADER__

#if JUCE_MSVC || DOXYGEN
 /** This is a compiler-independent way of declaring a variable as being thread-local.

	 E.g.
	 @code
	 juce_ThreadLocal int myVariable;
	 @endcode
 */
 #define juce_ThreadLocal    __declspec(thread)
#else
 #define juce_ThreadLocal    __thread
#endif

#if JUCE_MINGW
 /** This allocator is not defined in mingw gcc. */
 #define alloca              __builtin_alloca
#endif

/** Fills a block of memory with zeros. */
inline void zeromem (void* memory, size_t numBytes) noexcept        { memset (memory, 0, numBytes); }

/** Overwrites a structure or object with zeros. */
template <typename Type>
inline void zerostruct (Type& structure) noexcept                   { memset (&structure, 0, sizeof (structure)); }

/** Delete an object pointer, and sets the pointer to null.

	Remember that it's not good c++ practice to use delete directly - always try to use a ScopedPointer
	or other automatic lieftime-management system rather than resorting to deleting raw pointers!
*/
template <typename Type>
inline void deleteAndZero (Type& pointer)                           { delete pointer; pointer = nullptr; }

/** A handy function which adds a number of bytes to any type of pointer and returns the result.
	This can be useful to avoid casting pointers to a char* and back when you want to move them by
	a specific number of bytes,
*/
template <typename Type>
inline Type* addBytesToPointer (Type* pointer, int bytes) noexcept  { return (Type*) (((char*) pointer) + bytes); }

/** A handy function which returns the difference between any two pointers, in bytes.
	The address of the second pointer is subtracted from the first, and the difference in bytes is returned.
*/
template <typename Type1, typename Type2>
inline int getAddressDifference (Type1* pointer1, Type2* pointer2) noexcept  { return (int) (((const char*) pointer1) - (const char*) pointer2); }

/** If a pointer is non-null, this returns a new copy of the object that it points to, or safely returns
	nullptr if the pointer is null.
*/
template <class Type>
inline Type* createCopyIfNotNull (Type* pointer)     { return pointer != nullptr ? new Type (*pointer) : nullptr; }

/* In a Windows DLL build, we'll expose some malloc/free functions that live inside the DLL, and use these for
   allocating all the objects - that way all juce objects in the DLL and in the host will live in the same heap,
   avoiding problems when an object is created in one module and passed across to another where it is deleted.
   By piggy-backing on the JUCE_LEAK_DETECTOR macro, these allocators can be injected into most juce classes.
*/
#if JUCE_MSVC && defined (JUCE_DLL) && ! DOXYGEN
 extern JUCE_API void* juceDLL_malloc (size_t);
 extern JUCE_API void  juceDLL_free (void*);

 #define JUCE_LEAK_DETECTOR(OwnerClass)  public:\
			  static void* operator new (size_t sz)           { return juce::juceDLL_malloc ((int) sz); } \
			  static void* operator new (size_t, void* p)     { return p; } \
			  static void operator delete (void* p)           { juce::juceDLL_free (p); } \
			  static void operator delete (void*, void*)      {}
#endif

/** (Deprecated) This was a Windows-specific way of checking for object leaks - now please
	use the JUCE_LEAK_DETECTOR instead.
*/
#ifndef juce_UseDebuggingNewOperator
 #define juce_UseDebuggingNewOperator
#endif

#endif   // __JUCE_MEMORY_JUCEHEADER__

/*** End of inlined file: juce_Memory.h ***/


/*** Start of inlined file: juce_MathsFunctions.h ***/
#ifndef __JUCE_MATHSFUNCTIONS_JUCEHEADER__
#define __JUCE_MATHSFUNCTIONS_JUCEHEADER__

/*
	This file sets up some handy mathematical typdefs and functions.
*/

// Definitions for the int8, int16, int32, int64 and pointer_sized_int types.

/** A platform-independent 8-bit signed integer type. */
typedef signed char                 int8;
/** A platform-independent 8-bit unsigned integer type. */
typedef unsigned char               uint8;
/** A platform-independent 16-bit signed integer type. */
typedef signed short                int16;
/** A platform-independent 16-bit unsigned integer type. */
typedef unsigned short              uint16;
/** A platform-independent 32-bit signed integer type. */
typedef signed int                  int32;
/** A platform-independent 32-bit unsigned integer type. */
typedef unsigned int                uint32;

#if JUCE_MSVC
  /** A platform-independent 64-bit integer type. */
  typedef __int64                   int64;
  /** A platform-independent 64-bit unsigned integer type. */
  typedef unsigned __int64          uint64;
  /** A platform-independent macro for writing 64-bit literals, needed because
	  different compilers have different syntaxes for this.

	  E.g. writing literal64bit (0x1000000000) will translate to 0x1000000000LL for
	  GCC, or 0x1000000000 for MSVC.
  */
  #define literal64bit(longLiteral)     ((__int64) longLiteral)
#else
  /** A platform-independent 64-bit integer type. */
  typedef long long                 int64;
  /** A platform-independent 64-bit unsigned integer type. */
  typedef unsigned long long        uint64;
  /** A platform-independent macro for writing 64-bit literals, needed because
	  different compilers have different syntaxes for this.

	  E.g. writing literal64bit (0x1000000000) will translate to 0x1000000000LL for
	  GCC, or 0x1000000000 for MSVC.
  */
  #define literal64bit(longLiteral)     (longLiteral##LL)
#endif

#if JUCE_64BIT
  /** A signed integer type that's guaranteed to be large enough to hold a pointer without truncating it. */
  typedef int64                     pointer_sized_int;
  /** An unsigned integer type that's guaranteed to be large enough to hold a pointer without truncating it. */
  typedef uint64                    pointer_sized_uint;
#elif JUCE_MSVC
  /** A signed integer type that's guaranteed to be large enough to hold a pointer without truncating it. */
  typedef _W64 int                  pointer_sized_int;
  /** An unsigned integer type that's guaranteed to be large enough to hold a pointer without truncating it. */
  typedef _W64 unsigned int         pointer_sized_uint;
#else
  /** A signed integer type that's guaranteed to be large enough to hold a pointer without truncating it. */
  typedef int                       pointer_sized_int;
  /** An unsigned integer type that's guaranteed to be large enough to hold a pointer without truncating it. */
  typedef unsigned int              pointer_sized_uint;
#endif

#if JUCE_MSVC
  typedef pointer_sized_int ssize_t;
#endif

// Some indispensible min/max functions

/** Returns the larger of two values. */
template <typename Type>
inline Type jmax (const Type a, const Type b)                                               { return (a < b) ? b : a; }

/** Returns the larger of three values. */
template <typename Type>
inline Type jmax (const Type a, const Type b, const Type c)                                 { return (a < b) ? ((b < c) ? c : b) : ((a < c) ? c : a); }

/** Returns the larger of four values. */
template <typename Type>
inline Type jmax (const Type a, const Type b, const Type c, const Type d)                   { return jmax (a, jmax (b, c, d)); }

/** Returns the smaller of two values. */
template <typename Type>
inline Type jmin (const Type a, const Type b)                                               { return (b < a) ? b : a; }

/** Returns the smaller of three values. */
template <typename Type>
inline Type jmin (const Type a, const Type b, const Type c)                                 { return (b < a) ? ((c < b) ? c : b) : ((c < a) ? c : a); }

/** Returns the smaller of four values. */
template <typename Type>
inline Type jmin (const Type a, const Type b, const Type c, const Type d)                   { return jmin (a, jmin (b, c, d)); }

/** Scans an array of values, returning the minimum value that it contains. */
template <typename Type>
const Type findMinimum (const Type* data, int numValues)
{
	if (numValues <= 0)
		return Type();

	Type result (*data++);

	while (--numValues > 0) // (> 0 rather than >= 0 because we've already taken the first sample)
	{
		const Type& v = *data++;
		if (v < result)  result = v;
	}

	return result;
}

/** Scans an array of values, returning the maximum value that it contains. */
template <typename Type>
const Type findMaximum (const Type* values, int numValues)
{
	if (numValues <= 0)
		return Type();

	Type result (*values++);

	while (--numValues > 0) // (> 0 rather than >= 0 because we've already taken the first sample)
	{
		const Type& v = *values++;
		if (result < v)  result = v;
	}

	return result;
}

/** Scans an array of values, returning the minimum and maximum values that it contains. */
template <typename Type>
void findMinAndMax (const Type* values, int numValues, Type& lowest, Type& highest)
{
	if (numValues <= 0)
	{
		lowest = Type();
		highest = Type();
	}
	else
	{
		Type mn (*values++);
		Type mx (mn);

		while (--numValues > 0) // (> 0 rather than >= 0 because we've already taken the first sample)
		{
			const Type& v = *values++;

			if (mx < v)  mx = v;
			if (v < mn)  mn = v;
		}

		lowest = mn;
		highest = mx;
	}
}

/** Constrains a value to keep it within a given range.

	This will check that the specified value lies between the lower and upper bounds
	specified, and if not, will return the nearest value that would be in-range. Effectively,
	it's like calling jmax (lowerLimit, jmin (upperLimit, value)).

	Note that it expects that lowerLimit <= upperLimit. If this isn't true,
	the results will be unpredictable.

	@param lowerLimit           the minimum value to return
	@param upperLimit           the maximum value to return
	@param valueToConstrain     the value to try to return
	@returns    the closest value to valueToConstrain which lies between lowerLimit
				and upperLimit (inclusive)
	@see jlimit0To, jmin, jmax
*/
template <typename Type>
inline Type jlimit (const Type lowerLimit,
					const Type upperLimit,
					const Type valueToConstrain) noexcept
{
	jassert (lowerLimit <= upperLimit); // if these are in the wrong order, results are unpredictable..

	return (valueToConstrain < lowerLimit) ? lowerLimit
										   : ((upperLimit < valueToConstrain) ? upperLimit
																			  : valueToConstrain);
}

/** Returns true if a value is at least zero, and also below a specified upper limit.
	This is basically a quicker way to write:
	@code valueToTest >= 0 && valueToTest < upperLimit
	@endcode
*/
template <typename Type>
inline bool isPositiveAndBelow (Type valueToTest, Type upperLimit) noexcept
{
	jassert (Type() <= upperLimit); // makes no sense to call this if the upper limit is itself below zero..
	return Type() <= valueToTest && valueToTest < upperLimit;
}

template <>
inline bool isPositiveAndBelow (const int valueToTest, const int upperLimit) noexcept
{
	jassert (upperLimit >= 0); // makes no sense to call this if the upper limit is itself below zero..
	return static_cast <unsigned int> (valueToTest) < static_cast <unsigned int> (upperLimit);
}

/** Returns true if a value is at least zero, and also less than or equal to a specified upper limit.
	This is basically a quicker way to write:
	@code valueToTest >= 0 && valueToTest <= upperLimit
	@endcode
*/
template <typename Type>
inline bool isPositiveAndNotGreaterThan (Type valueToTest, Type upperLimit) noexcept
{
	jassert (Type() <= upperLimit); // makes no sense to call this if the upper limit is itself below zero..
	return Type() <= valueToTest && valueToTest <= upperLimit;
}

template <>
inline bool isPositiveAndNotGreaterThan (const int valueToTest, const int upperLimit) noexcept
{
	jassert (upperLimit >= 0); // makes no sense to call this if the upper limit is itself below zero..
	return static_cast <unsigned int> (valueToTest) <= static_cast <unsigned int> (upperLimit);
}

/** Handy function to swap two values. */
template <typename Type>
inline void swapVariables (Type& variable1, Type& variable2)
{
	std::swap (variable1, variable2);
}

/** Handy function for getting the number of elements in a simple const C array.
	E.g.
	@code
	static int myArray[] = { 1, 2, 3 };

	int numElements = numElementsInArray (myArray) // returns 3
	@endcode
*/
template <typename Type, int N>
inline int numElementsInArray (Type (&array)[N])
{
	(void) array; // (required to avoid a spurious warning in MS compilers)
	(void) sizeof (0[array]); // This line should cause an error if you pass an object with a user-defined subscript operator
	return N;
}

// Some useful maths functions that aren't always present with all compilers and build settings.

/** Using juce_hypot is easier than dealing with the different types of hypot function
	that are provided by the various platforms and compilers. */
template <typename Type>
inline Type juce_hypot (Type a, Type b) noexcept
{
   #if JUCE_WINDOWS
	return static_cast <Type> (_hypot (a, b));
   #else
	return static_cast <Type> (hypot (a, b));
   #endif
}

/** 64-bit abs function. */
inline int64 abs64 (const int64 n) noexcept
{
	return (n >= 0) ? n : -n;
}

/** This templated negate function will negate pointers as well as integers */
template <typename Type>
inline Type juce_negate (Type n) noexcept
{
	return sizeof (Type) == 1 ? (Type) -(signed char) n
		: (sizeof (Type) == 2 ? (Type) -(short) n
		: (sizeof (Type) == 4 ? (Type) -(int) n
		: ((Type) -(int64) n)));
}

/** This templated negate function will negate pointers as well as integers */
template <typename Type>
inline Type* juce_negate (Type* n) noexcept
{
	return (Type*) -(pointer_sized_int) n;
}

/** A predefined value for Pi, at double-precision.

	@see float_Pi
*/
const double  double_Pi  = 3.1415926535897932384626433832795;

/** A predefined value for Pi, at sngle-precision.

	@see double_Pi
*/
const float   float_Pi   = 3.14159265358979323846f;

/** The isfinite() method seems to vary between platforms, so this is a
	platform-independent function for it.
*/
template <typename FloatingPointType>
inline bool juce_isfinite (FloatingPointType value)
{
   #if JUCE_WINDOWS
	return _finite (value);
   #elif JUCE_ANDROID
	return isfinite (value);
   #else
	return std::isfinite (value);
   #endif
}

#if JUCE_MSVC
 #pragma optimize ("t", off)
 #pragma float_control (precise, on, push)
#endif

/** Fast floating-point-to-integer conversion.

	This is faster than using the normal c++ cast to convert a float to an int, and
	it will round the value to the nearest integer, rather than rounding it down
	like the normal cast does.

	Note that this routine gets its speed at the expense of some accuracy, and when
	rounding values whose floating point component is exactly 0.5, odd numbers and
	even numbers will be rounded up or down differently.
*/
template <typename FloatType>
inline int roundToInt (const FloatType value) noexcept
{
	union { int asInt[2]; double asDouble; } n;
	n.asDouble = ((double) value) + 6755399441055744.0;

   #if JUCE_BIG_ENDIAN
	return n.asInt [1];
   #else
	return n.asInt [0];
   #endif
}

#if JUCE_MSVC
 #pragma float_control (pop)
 #pragma optimize ("", on)  // resets optimisations to the project defaults
#endif

/** Fast floating-point-to-integer conversion.

	This is a slightly slower and slightly more accurate version of roundDoubleToInt(). It works
	fine for values above zero, but negative numbers are rounded the wrong way.
*/
inline int roundToIntAccurate (const double value) noexcept
{
	return roundToInt (value + 1.5e-8);
}

/** Fast floating-point-to-integer conversion.

	This is faster than using the normal c++ cast to convert a double to an int, and
	it will round the value to the nearest integer, rather than rounding it down
	like the normal cast does.

	Note that this routine gets its speed at the expense of some accuracy, and when
	rounding values whose floating point component is exactly 0.5, odd numbers and
	even numbers will be rounded up or down differently. For a more accurate conversion,
	see roundDoubleToIntAccurate().
*/
inline int roundDoubleToInt (const double value) noexcept
{
	return roundToInt (value);
}

/** Fast floating-point-to-integer conversion.

	This is faster than using the normal c++ cast to convert a float to an int, and
	it will round the value to the nearest integer, rather than rounding it down
	like the normal cast does.

	Note that this routine gets its speed at the expense of some accuracy, and when
	rounding values whose floating point component is exactly 0.5, odd numbers and
	even numbers will be rounded up or down differently.
*/
inline int roundFloatToInt (const float value) noexcept
{
	return roundToInt (value);
}

/** Returns true if the specified integer is a power-of-two.
*/
template <typename IntegerType>
bool isPowerOfTwo (IntegerType value)
{
   return (value & (value - 1)) == 0;
}

/** Returns the next power-of-two which is equal to or greater than the given integer.
*/
inline int nextPowerOfTwo (int n)
{
	--n;
	n |= (n >> 1);
	n |= (n >> 2);
	n |= (n >> 4);
	n |= (n >> 8);
	n |= (n >> 16);
	return n + 1;
}

/** Performs a modulo operation, but can cope with the dividend being negative.
	The divisor must be greater than zero.
*/
template <typename IntegerType>
int negativeAwareModulo (IntegerType dividend, const IntegerType divisor) noexcept
{
	jassert (divisor > 0);
	dividend %= divisor;
	return (dividend < 0) ? (dividend + divisor) : dividend;
}

#if (JUCE_INTEL && JUCE_32BIT) || defined (DOXYGEN)
 /** This macro can be applied to a float variable to check whether it contains a denormalised
	 value, and to normalise it if necessary.
	 On CPUs that aren't vulnerable to denormalisation problems, this will have no effect.
 */
 #define JUCE_UNDENORMALISE(x)   x += 1.0f; x -= 1.0f;
#else
 #define JUCE_UNDENORMALISE(x)
#endif

/** This namespace contains a few template classes for helping work out class type variations.
*/
namespace TypeHelpers
{
   #if JUCE_VC8_OR_EARLIER
	#define PARAMETER_TYPE(type) const type&
   #else
	/** The ParameterType struct is used to find the best type to use when passing some kind
		of object as a parameter.

		Of course, this is only likely to be useful in certain esoteric template situations.

		Because "typename TypeHelpers::ParameterType<SomeClass>::type" is a bit of a mouthful, there's
		a PARAMETER_TYPE(SomeClass) macro that you can use to get the same effect.

		E.g. "myFunction (PARAMETER_TYPE (int), PARAMETER_TYPE (MyObject))"
		would evaluate to "myfunction (int, const MyObject&)", keeping any primitive types as
		pass-by-value, but passing objects as a const reference, to avoid copying.
	*/
	template <typename Type> struct ParameterType                   { typedef const Type& type; };

   #if ! DOXYGEN
	template <typename Type> struct ParameterType <Type&>           { typedef Type& type; };
	template <typename Type> struct ParameterType <Type*>           { typedef Type* type; };
	template <>              struct ParameterType <char>            { typedef char type; };
	template <>              struct ParameterType <unsigned char>   { typedef unsigned char type; };
	template <>              struct ParameterType <short>           { typedef short type; };
	template <>              struct ParameterType <unsigned short>  { typedef unsigned short type; };
	template <>              struct ParameterType <int>             { typedef int type; };
	template <>              struct ParameterType <unsigned int>    { typedef unsigned int type; };
	template <>              struct ParameterType <long>            { typedef long type; };
	template <>              struct ParameterType <unsigned long>   { typedef unsigned long type; };
	template <>              struct ParameterType <int64>           { typedef int64 type; };
	template <>              struct ParameterType <uint64>          { typedef uint64 type; };
	template <>              struct ParameterType <bool>            { typedef bool type; };
	template <>              struct ParameterType <float>           { typedef float type; };
	template <>              struct ParameterType <double>          { typedef double type; };
   #endif

	/** A helpful macro to simplify the use of the ParameterType template.
		@see ParameterType
	*/
	#define PARAMETER_TYPE(a)    typename TypeHelpers::ParameterType<a>::type
   #endif

	/** These templates are designed to take a type, and if it's a double, they return a double
		type; for anything else, they return a float type.
	*/
	template <typename Type> struct SmallestFloatType             { typedef float  type; };
	template <>              struct SmallestFloatType <double>    { typedef double type; };
}

#endif   // __JUCE_MATHSFUNCTIONS_JUCEHEADER__

/*** End of inlined file: juce_MathsFunctions.h ***/


/*** Start of inlined file: juce_ByteOrder.h ***/
#ifndef __JUCE_BYTEORDER_JUCEHEADER__
#define __JUCE_BYTEORDER_JUCEHEADER__

/** Contains static methods for converting the byte order between different
	endiannesses.
*/
class JUCE_API  ByteOrder
{
public:

	/** Swaps the upper and lower bytes of a 16-bit integer. */
	static uint16 swap (uint16 value);

	/** Reverses the order of the 4 bytes in a 32-bit integer. */
	static uint32 swap (uint32 value);

	/** Reverses the order of the 8 bytes in a 64-bit integer. */
	static uint64 swap (uint64 value);

	/** Swaps the byte order of a 16-bit int if the CPU is big-endian */
	static uint16 swapIfBigEndian (uint16 value);

	/** Swaps the byte order of a 32-bit int if the CPU is big-endian */
	static uint32 swapIfBigEndian (uint32 value);

	/** Swaps the byte order of a 64-bit int if the CPU is big-endian */
	static uint64 swapIfBigEndian (uint64 value);

	/** Swaps the byte order of a 16-bit int if the CPU is little-endian */
	static uint16 swapIfLittleEndian (uint16 value);

	/** Swaps the byte order of a 32-bit int if the CPU is little-endian */
	static uint32 swapIfLittleEndian (uint32 value);

	/** Swaps the byte order of a 64-bit int if the CPU is little-endian */
	static uint64 swapIfLittleEndian (uint64 value);

	/** Turns 4 bytes into a little-endian integer. */
	static uint32 littleEndianInt (const void* bytes);

	/** Turns 2 bytes into a little-endian integer. */
	static uint16 littleEndianShort (const void* bytes);

	/** Turns 4 bytes into a big-endian integer. */
	static uint32 bigEndianInt (const void* bytes);

	/** Turns 2 bytes into a big-endian integer. */
	static uint16 bigEndianShort (const void* bytes);

	/** Converts 3 little-endian bytes into a signed 24-bit value (which is sign-extended to 32 bits). */
	static int littleEndian24Bit (const char* bytes);

	/** Converts 3 big-endian bytes into a signed 24-bit value (which is sign-extended to 32 bits). */
	static int bigEndian24Bit (const char* bytes);

	/** Copies a 24-bit number to 3 little-endian bytes. */
	static void littleEndian24BitToChars (int value, char* destBytes);

	/** Copies a 24-bit number to 3 big-endian bytes. */
	static void bigEndian24BitToChars (int value, char* destBytes);

	/** Returns true if the current CPU is big-endian. */
	static bool isBigEndian();

private:
	ByteOrder();

	JUCE_DECLARE_NON_COPYABLE (ByteOrder);
};

#if JUCE_USE_INTRINSICS && ! defined (__INTEL_COMPILER)
 #pragma intrinsic (_byteswap_ulong)
#endif

inline uint16 ByteOrder::swap (uint16 n)
{
   #if JUCE_USE_INTRINSICSxxx // agh - the MS compiler has an internal error when you try to use this intrinsic!
	return static_cast <uint16> (_byteswap_ushort (n));
   #else
	return static_cast <uint16> ((n << 8) | (n >> 8));
   #endif
}

inline uint32 ByteOrder::swap (uint32 n)
{
   #if JUCE_MAC || JUCE_IOS
	return OSSwapInt32 (n);
   #elif JUCE_GCC && JUCE_INTEL
	asm("bswap %%eax" : "=a"(n) : "a"(n));
	return n;
   #elif JUCE_USE_INTRINSICS
	return _byteswap_ulong (n);
   #elif JUCE_MSVC
	__asm {
		mov eax, n
		bswap eax
		mov n, eax
	}
	return n;
   #elif JUCE_ANDROID
	return bswap_32 (n);
   #else
	return (n << 24) | (n >> 24) | ((n & 0xff00) << 8) | ((n & 0xff0000) >> 8);
   #endif
}

inline uint64 ByteOrder::swap (uint64 value)
{
   #if JUCE_MAC || JUCE_IOS
	return OSSwapInt64 (value);
   #elif JUCE_USE_INTRINSICS
	return _byteswap_uint64 (value);
   #else
	return (((int64) swap ((uint32) value)) << 32) | swap ((uint32) (value >> 32));
   #endif
}

#if JUCE_LITTLE_ENDIAN
 inline uint16 ByteOrder::swapIfBigEndian (const uint16 v)                                  { return v; }
 inline uint32 ByteOrder::swapIfBigEndian (const uint32 v)                                  { return v; }
 inline uint64 ByteOrder::swapIfBigEndian (const uint64 v)                                  { return v; }
 inline uint16 ByteOrder::swapIfLittleEndian (const uint16 v)                               { return swap (v); }
 inline uint32 ByteOrder::swapIfLittleEndian (const uint32 v)                               { return swap (v); }
 inline uint64 ByteOrder::swapIfLittleEndian (const uint64 v)                               { return swap (v); }
 inline uint32 ByteOrder::littleEndianInt (const void* const bytes)                         { return *static_cast <const uint32*> (bytes); }
 inline uint16 ByteOrder::littleEndianShort (const void* const bytes)                       { return *static_cast <const uint16*> (bytes); }
 inline uint32 ByteOrder::bigEndianInt (const void* const bytes)                            { return swap (*static_cast <const uint32*> (bytes)); }
 inline uint16 ByteOrder::bigEndianShort (const void* const bytes)                          { return swap (*static_cast <const uint16*> (bytes)); }
 inline bool ByteOrder::isBigEndian()                                                       { return false; }
#else
 inline uint16 ByteOrder::swapIfBigEndian (const uint16 v)                                  { return swap (v); }
 inline uint32 ByteOrder::swapIfBigEndian (const uint32 v)                                  { return swap (v); }
 inline uint64 ByteOrder::swapIfBigEndian (const uint64 v)                                  { return swap (v); }
 inline uint16 ByteOrder::swapIfLittleEndian (const uint16 v)                               { return v; }
 inline uint32 ByteOrder::swapIfLittleEndian (const uint32 v)                               { return v; }
 inline uint64 ByteOrder::swapIfLittleEndian (const uint64 v)                               { return v; }
 inline uint32 ByteOrder::littleEndianInt (const void* const bytes)                         { return swap (*static_cast <const uint32*> (bytes)); }
 inline uint16 ByteOrder::littleEndianShort (const void* const bytes)                       { return swap (*static_cast <const uint16*> (bytes)); }
 inline uint32 ByteOrder::bigEndianInt (const void* const bytes)                            { return *static_cast <const uint32*> (bytes); }
 inline uint16 ByteOrder::bigEndianShort (const void* const bytes)                          { return *static_cast <const uint16*> (bytes); }
 inline bool ByteOrder::isBigEndian()                                                       { return true; }
#endif

inline int  ByteOrder::littleEndian24Bit (const char* const bytes)                          { return (((int) bytes[2]) << 16) | (((int) (uint8) bytes[1]) << 8) | ((int) (uint8) bytes[0]); }
inline int  ByteOrder::bigEndian24Bit (const char* const bytes)                             { return (((int) bytes[0]) << 16) | (((int) (uint8) bytes[1]) << 8) | ((int) (uint8) bytes[2]); }
inline void ByteOrder::littleEndian24BitToChars (const int value, char* const destBytes)    { destBytes[0] = (char)(value & 0xff); destBytes[1] = (char)((value >> 8) & 0xff); destBytes[2] = (char)((value >> 16) & 0xff); }
inline void ByteOrder::bigEndian24BitToChars (const int value, char* const destBytes)       { destBytes[0] = (char)((value >> 16) & 0xff); destBytes[1] = (char)((value >> 8) & 0xff); destBytes[2] = (char)(value & 0xff); }

#endif   // __JUCE_BYTEORDER_JUCEHEADER__

/*** End of inlined file: juce_ByteOrder.h ***/


/*** Start of inlined file: juce_Logger.h ***/
#ifndef __JUCE_LOGGER_JUCEHEADER__
#define __JUCE_LOGGER_JUCEHEADER__


/*** Start of inlined file: juce_String.h ***/
#ifndef __JUCE_STRING_JUCEHEADER__
#define __JUCE_STRING_JUCEHEADER__


/*** Start of inlined file: juce_CharacterFunctions.h ***/
#ifndef __JUCE_CHARACTERFUNCTIONS_JUCEHEADER__
#define __JUCE_CHARACTERFUNCTIONS_JUCEHEADER__

#if JUCE_WINDOWS && ! DOXYGEN
 #define JUCE_NATIVE_WCHAR_IS_UTF8      0
 #define JUCE_NATIVE_WCHAR_IS_UTF16     1
 #define JUCE_NATIVE_WCHAR_IS_UTF32     0
#else
 /** This macro will be set to 1 if the compiler's native wchar_t is an 8-bit type. */
 #define JUCE_NATIVE_WCHAR_IS_UTF8      0
 /** This macro will be set to 1 if the compiler's native wchar_t is a 16-bit type. */
 #define JUCE_NATIVE_WCHAR_IS_UTF16     0
 /** This macro will be set to 1 if the compiler's native wchar_t is a 32-bit type. */
 #define JUCE_NATIVE_WCHAR_IS_UTF32     1
#endif

#if JUCE_NATIVE_WCHAR_IS_UTF32 || DOXYGEN
 /** A platform-independent 32-bit unicode character type. */
 typedef wchar_t        juce_wchar;
#else
 typedef uint32         juce_wchar;
#endif

/** This macro is deprecated, but preserved for compatibility with old code. */
#define JUCE_T(stringLiteral)   (L##stringLiteral)

#if JUCE_DEFINE_T_MACRO
 /** The 'T' macro is an alternative for using the "L" prefix in front of a string literal.

	 This macro is deprecated, but available for compatibility with old code if you set
	 JUCE_DEFINE_T_MACRO = 1. The fastest, most portable and best way to write your string
	 literals is as standard char strings, using escaped utf-8 character sequences for extended
	 characters, rather than trying to store them as wide-char strings.
 */
 #define T(stringLiteral)   JUCE_T(stringLiteral)
#endif

#undef max
#undef min

/**
	A set of methods for manipulating characters and character strings.

	These are defined as wrappers around the basic C string handlers, to provide
	a clean, cross-platform layer, (because various platforms differ in the
	range of C library calls that they provide).

	@see String
*/
class JUCE_API  CharacterFunctions
{
public:

	static juce_wchar toUpperCase (juce_wchar character) noexcept;
	static juce_wchar toLowerCase (juce_wchar character) noexcept;

	static bool isUpperCase (juce_wchar character) noexcept;
	static bool isLowerCase (juce_wchar character) noexcept;

	static bool isWhitespace (char character) noexcept;
	static bool isWhitespace (juce_wchar character) noexcept;

	static bool isDigit (char character) noexcept;
	static bool isDigit (juce_wchar character) noexcept;

	static bool isLetter (char character) noexcept;
	static bool isLetter (juce_wchar character) noexcept;

	static bool isLetterOrDigit (char character) noexcept;
	static bool isLetterOrDigit (juce_wchar character) noexcept;

	/** Returns 0 to 16 for '0' to 'F", or -1 for characters that aren't a legal hex digit. */
	static int getHexDigitValue (juce_wchar digit) noexcept;

	template <typename CharPointerType>
	static double readDoubleValue (CharPointerType& text) noexcept
	{
		double result[3] = { 0 }, accumulator[2] = { 0 };
		int exponentAdjustment[2] = { 0 }, exponentAccumulator[2] = { -1, -1 };
		int exponent = 0, decPointIndex = 0, digit = 0;
		int lastDigit = 0, numSignificantDigits = 0;
		bool isNegative = false, digitsFound = false;
		const int maxSignificantDigits = 15 + 2;

		text = text.findEndOfWhitespace();
		juce_wchar c = *text;

		switch (c)
		{
			case '-':   isNegative = true; // fall-through..
			case '+':   c = *++text;
		}

		switch (c)
		{
			case 'n':
			case 'N':
				if ((text[1] == 'a' || text[1] == 'A') && (text[2] == 'n' || text[2] == 'N'))
					return std::numeric_limits<double>::quiet_NaN();
				break;

			case 'i':
			case 'I':
				if ((text[1] == 'n' || text[1] == 'N') && (text[2] == 'f' || text[2] == 'F'))
					return std::numeric_limits<double>::infinity();
				break;
		}

		for (;;)
		{
			if (text.isDigit())
			{
				lastDigit = digit;
				digit = (int) text.getAndAdvance() - '0';
				digitsFound = true;

				if (decPointIndex != 0)
					exponentAdjustment[1]++;

				if (numSignificantDigits == 0 && digit == 0)
					continue;

				if (++numSignificantDigits > maxSignificantDigits)
				{
					if (digit > 5)
						++accumulator [decPointIndex];
					else if (digit == 5 && (lastDigit & 1) != 0)
						++accumulator [decPointIndex];

					if (decPointIndex > 0)
						exponentAdjustment[1]--;
					else
						exponentAdjustment[0]++;

					while (text.isDigit())
					{
						++text;
						if (decPointIndex == 0)
							exponentAdjustment[0]++;
					}
				}
				else
				{
					const double maxAccumulatorValue = (double) ((std::numeric_limits<unsigned int>::max() - 9) / 10);
					if (accumulator [decPointIndex] > maxAccumulatorValue)
					{
						result [decPointIndex] = mulexp10 (result [decPointIndex], exponentAccumulator [decPointIndex])
													+ accumulator [decPointIndex];
						accumulator [decPointIndex] = 0;
						exponentAccumulator [decPointIndex] = 0;
					}

					accumulator [decPointIndex] = accumulator[decPointIndex] * 10 + digit;
					exponentAccumulator [decPointIndex]++;
				}
			}
			else if (decPointIndex == 0 && *text == '.')
			{
				++text;
				decPointIndex = 1;

				if (numSignificantDigits > maxSignificantDigits)
				{
					while (text.isDigit())
						++text;
					break;
				}
			}
			else
			{
				break;
			}
		}

		result[0] = mulexp10 (result[0], exponentAccumulator[0]) + accumulator[0];

		if (decPointIndex != 0)
			result[1] = mulexp10 (result[1], exponentAccumulator[1]) + accumulator[1];

		c = *text;
		if ((c == 'e' || c == 'E') && digitsFound)
		{
			bool negativeExponent = false;

			switch (*++text)
			{
				case '-':   negativeExponent = true; // fall-through..
				case '+':   ++text;
			}

			while (text.isDigit())
				exponent = (exponent * 10) + ((int) text.getAndAdvance() - '0');

			if (negativeExponent)
				exponent = -exponent;
		}

		double r = mulexp10 (result[0], exponent + exponentAdjustment[0]);
		if (decPointIndex != 0)
			r += mulexp10 (result[1], exponent - exponentAdjustment[1]);

		return isNegative ? -r : r;
	}

	template <typename CharPointerType>
	static double getDoubleValue (const CharPointerType& text) noexcept
	{
		CharPointerType t (text);
		return readDoubleValue (t);
	}

	template <typename IntType, typename CharPointerType>
	static IntType getIntValue (const CharPointerType& text) noexcept
	{
		IntType v = 0;
		CharPointerType s (text.findEndOfWhitespace());

		const bool isNeg = *s == '-';
		if (isNeg)
			++s;

		for (;;)
		{
			const juce_wchar c = s.getAndAdvance();

			if (c >= '0' && c <= '9')
				v = v * 10 + (IntType) (c - '0');
			else
				break;
		}

		return isNeg ? -v : v;
	}

	template <typename CharPointerType>
	static size_t lengthUpTo (CharPointerType text, const size_t maxCharsToCount) noexcept
	{
		size_t len = 0;

		while (len < maxCharsToCount && text.getAndAdvance() != 0)
			++len;

		return len;
	}

	template <typename CharPointerType>
	static size_t lengthUpTo (CharPointerType start, const CharPointerType& end) noexcept
	{
		size_t len = 0;

		while (start < end && start.getAndAdvance() != 0)
			++len;

		return len;
	}

	template <typename DestCharPointerType, typename SrcCharPointerType>
	static void copyAll (DestCharPointerType& dest, SrcCharPointerType src) noexcept
	{
		for (;;)
		{
			const juce_wchar c = src.getAndAdvance();

			if (c == 0)
				break;

			dest.write (c);
		}

		dest.writeNull();
	}

	template <typename DestCharPointerType, typename SrcCharPointerType>
	static int copyWithDestByteLimit (DestCharPointerType& dest, SrcCharPointerType src, int maxBytes) noexcept
	{
		typename DestCharPointerType::CharType const* const startAddress = dest.getAddress();
		maxBytes -= sizeof (typename DestCharPointerType::CharType); // (allow for a terminating null)

		for (;;)
		{
			const juce_wchar c = src.getAndAdvance();
			const int bytesNeeded = (int) DestCharPointerType::getBytesRequiredFor (c);

			maxBytes -= bytesNeeded;
			if (c == 0 || maxBytes < 0)
				break;

			dest.write (c);
		}

		dest.writeNull();

		return (int) (getAddressDifference (dest.getAddress(), startAddress) + sizeof (typename DestCharPointerType::CharType));
	}

	template <typename DestCharPointerType, typename SrcCharPointerType>
	static void copyWithCharLimit (DestCharPointerType& dest, SrcCharPointerType src, int maxChars) noexcept
	{
		while (--maxChars > 0)
		{
			const juce_wchar c = src.getAndAdvance();
			if (c == 0)
				break;

			dest.write (c);
		}

		dest.writeNull();
	}

	template <typename CharPointerType1, typename CharPointerType2>
	static int compare (CharPointerType1 s1, CharPointerType2 s2) noexcept
	{
		for (;;)
		{
			const int c1 = (int) s1.getAndAdvance();
			const int c2 = (int) s2.getAndAdvance();

			const int diff = c1 - c2;
			if (diff != 0)
				return diff < 0 ? -1 : 1;
			else if (c1 == 0)
				break;
		}

		return 0;
	}

	template <typename CharPointerType1, typename CharPointerType2>
	static int compareUpTo (CharPointerType1 s1, CharPointerType2 s2, int maxChars) noexcept
	{
		while (--maxChars >= 0)
		{
			const int c1 = (int) s1.getAndAdvance();
			const int c2 = (int) s2.getAndAdvance();

			const int diff = c1 - c2;
			if (diff != 0)
				return diff < 0 ? -1 : 1;
			else if (c1 == 0)
				break;
		}

		return 0;
	}

	template <typename CharPointerType1, typename CharPointerType2>
	static int compareIgnoreCase (CharPointerType1 s1, CharPointerType2 s2) noexcept
	{
		for (;;)
		{
			int c1 = (int) s1.toUpperCase();
			int c2 = (int) s2.toUpperCase();
			++s1;
			++s2;

			const int diff = c1 - c2;
			if (diff != 0)
				return diff < 0 ? -1 : 1;
			else if (c1 == 0)
				break;
		}

		return 0;
	}

	template <typename CharPointerType1, typename CharPointerType2>
	static int compareIgnoreCaseUpTo (CharPointerType1 s1, CharPointerType2 s2, int maxChars) noexcept
	{
		while (--maxChars >= 0)
		{
			int c1 = s1.toUpperCase();
			int c2 = s2.toUpperCase();
			++s1;
			++s2;

			const int diff = c1 - c2;
			if (diff != 0)
				return diff < 0 ? -1 : 1;
			else if (c1 == 0)
				break;
		}

		return 0;
	}

	template <typename CharPointerType1, typename CharPointerType2>
	static int indexOf (CharPointerType1 haystack, const CharPointerType2& needle) noexcept
	{
		int index = 0;
		const int needleLength = (int) needle.length();

		for (;;)
		{
			if (haystack.compareUpTo (needle, needleLength) == 0)
				return index;

			if (haystack.getAndAdvance() == 0)
				return -1;

			++index;
		}
	}

	template <typename CharPointerType1, typename CharPointerType2>
	static int indexOfIgnoreCase (CharPointerType1 haystack, const CharPointerType2& needle) noexcept
	{
		int index = 0;
		const int needleLength = (int) needle.length();

		for (;;)
		{
			if (haystack.compareIgnoreCaseUpTo (needle, needleLength) == 0)
				return index;

			if (haystack.getAndAdvance() == 0)
				return -1;

			++index;
		}
	}

	template <typename Type>
	static int indexOfChar (Type text, const juce_wchar charToFind) noexcept
	{
		int i = 0;

		while (! text.isEmpty())
		{
			if (text.getAndAdvance() == charToFind)
				return i;

			++i;
		}

		return -1;
	}

	template <typename Type>
	static int indexOfCharIgnoreCase (Type text, juce_wchar charToFind) noexcept
	{
		charToFind = CharacterFunctions::toLowerCase (charToFind);
		int i = 0;

		while (! text.isEmpty())
		{
			if (text.toLowerCase() == charToFind)
				return i;

			++text;
			++i;
		}

		return -1;
	}

	template <typename Type>
	static Type findEndOfWhitespace (const Type& text) noexcept
	{
		Type p (text);

		while (p.isWhitespace())
			++p;

		return p;
	}

	template <typename Type>
	static Type findEndOfToken (const Type& text, const Type& breakCharacters, const Type& quoteCharacters)
	{
		Type t (text);
		juce_wchar currentQuoteChar = 0;

		while (! t.isEmpty())
		{
			const juce_wchar c = t.getAndAdvance();

			if (currentQuoteChar == 0 && breakCharacters.indexOf (c) >= 0)
			{
				--t;
				break;
			}

			if (quoteCharacters.indexOf (c) >= 0)
			{
				if (currentQuoteChar == 0)
					currentQuoteChar = c;
				else if (currentQuoteChar == c)
					currentQuoteChar = 0;
			}
		}

		return t;
	}

private:
	static double mulexp10 (const double value, int exponent) noexcept;
};

#endif   // __JUCE_CHARACTERFUNCTIONS_JUCEHEADER__

/*** End of inlined file: juce_CharacterFunctions.h ***/

#ifndef JUCE_STRING_UTF_TYPE
 #define JUCE_STRING_UTF_TYPE 8
#endif

#if JUCE_MSVC
 #pragma warning (push)
 #pragma warning (disable: 4514 4996)
#endif


/*** Start of inlined file: juce_Atomic.h ***/
#ifndef __JUCE_ATOMIC_JUCEHEADER__
#define __JUCE_ATOMIC_JUCEHEADER__

/**
	Simple class to hold a primitive value and perform atomic operations on it.

	The type used must be a 32 or 64 bit primitive, like an int, pointer, etc.
	There are methods to perform most of the basic atomic operations.
*/
template <typename Type>
class Atomic
{
public:
	/** Creates a new value, initialised to zero. */
	inline Atomic() noexcept
		: value (0)
	{
	}

	/** Creates a new value, with a given initial value. */
	inline Atomic (const Type initialValue) noexcept
		: value (initialValue)
	{
	}

	/** Copies another value (atomically). */
	inline Atomic (const Atomic& other) noexcept
		: value (other.get())
	{
	}

	/** Destructor. */
	inline ~Atomic() noexcept
	{
		// This class can only be used for types which are 32 or 64 bits in size.
		static_jassert (sizeof (Type) == 4 || sizeof (Type) == 8);
	}

	/** Atomically reads and returns the current value. */
	Type get() const noexcept;

	/** Copies another value onto this one (atomically). */
	inline Atomic& operator= (const Atomic& other) noexcept         { exchange (other.get()); return *this; }

	/** Copies another value onto this one (atomically). */
	inline Atomic& operator= (const Type newValue) noexcept         { exchange (newValue); return *this; }

	/** Atomically sets the current value. */
	void set (Type newValue) noexcept                               { exchange (newValue); }

	/** Atomically sets the current value, returning the value that was replaced. */
	Type exchange (Type value) noexcept;

	/** Atomically adds a number to this value, returning the new value. */
	Type operator+= (Type amountToAdd) noexcept;

	/** Atomically subtracts a number from this value, returning the new value. */
	Type operator-= (Type amountToSubtract) noexcept;

	/** Atomically increments this value, returning the new value. */
	Type operator++() noexcept;

	/** Atomically decrements this value, returning the new value. */
	Type operator--() noexcept;

	/** Atomically compares this value with a target value, and if it is equal, sets
		this to be equal to a new value.

		This operation is the atomic equivalent of doing this:
		@code
		bool compareAndSetBool (Type newValue, Type valueToCompare)
		{
			if (get() == valueToCompare)
			{
				set (newValue);
				return true;
			}

			return false;
		}
		@endcode

		@returns true if the comparison was true and the value was replaced; false if
				 the comparison failed and the value was left unchanged.
		@see compareAndSetValue
	*/
	bool compareAndSetBool (Type newValue, Type valueToCompare) noexcept;

	/** Atomically compares this value with a target value, and if it is equal, sets
		this to be equal to a new value.

		This operation is the atomic equivalent of doing this:
		@code
		Type compareAndSetValue (Type newValue, Type valueToCompare)
		{
			Type oldValue = get();
			if (oldValue == valueToCompare)
				set (newValue);

			return oldValue;
		}
		@endcode

		@returns the old value before it was changed.
		@see compareAndSetBool
	*/
	Type compareAndSetValue (Type newValue, Type valueToCompare) noexcept;

	/** Implements a memory read/write barrier. */
	static void memoryBarrier() noexcept;

   #if JUCE_64BIT
	JUCE_ALIGN (8)
   #else
	JUCE_ALIGN (4)
   #endif

	/** The raw value that this class operates on.
		This is exposed publically in case you need to manipulate it directly
		for performance reasons.
	*/
	volatile Type value;

private:
	static inline Type castFrom32Bit (int32 value) noexcept   { return *(Type*) &value; }
	static inline Type castFrom64Bit (int64 value) noexcept   { return *(Type*) &value; }
	static inline int32 castTo32Bit (Type value) noexcept     { return *(int32*) &value; }
	static inline int64 castTo64Bit (Type value) noexcept     { return *(int64*) &value; }

	Type operator++ (int); // better to just use pre-increment with atomics..
	Type operator-- (int);
};

/*
	The following code is in the header so that the atomics can be inlined where possible...
*/
#if JUCE_IOS || (JUCE_MAC && (JUCE_PPC || defined (__clang__) || __GNUC__ < 4 || (__GNUC__ == 4 && __GNUC_MINOR__ < 2)))
  #define JUCE_ATOMICS_MAC 1        // Older OSX builds using gcc4.1 or earlier

  #if MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_5
	#define JUCE_MAC_ATOMICS_VOLATILE
  #else
	#define JUCE_MAC_ATOMICS_VOLATILE volatile
  #endif

  #if JUCE_PPC || JUCE_IOS
	// None of these atomics are available for PPC or for iPhoneOS 3.1 or earlier!!
	template <typename Type> static Type OSAtomicAdd64Barrier (Type b, JUCE_MAC_ATOMICS_VOLATILE Type* a) noexcept  { jassertfalse; return *a += b; }
	template <typename Type> static Type OSAtomicIncrement64Barrier (JUCE_MAC_ATOMICS_VOLATILE Type* a) noexcept    { jassertfalse; return ++*a; }
	template <typename Type> static Type OSAtomicDecrement64Barrier (JUCE_MAC_ATOMICS_VOLATILE Type* a) noexcept    { jassertfalse; return --*a; }
	template <typename Type> static bool OSAtomicCompareAndSwap64Barrier (Type old, Type newValue, JUCE_MAC_ATOMICS_VOLATILE Type* value) noexcept
		{ jassertfalse; if (old == *value) { *value = newValue; return true; } return false; }
	#define JUCE_64BIT_ATOMICS_UNAVAILABLE 1
  #endif

#elif JUCE_GCC
  #define JUCE_ATOMICS_GCC 1        // GCC with intrinsics

  #if JUCE_IOS || JUCE_ANDROID // (64-bit ops will compile but not link on these mobile OSes)
	#define JUCE_64BIT_ATOMICS_UNAVAILABLE 1
  #endif

#else
  #define JUCE_ATOMICS_WINDOWS 1    // Windows with intrinsics

  #if JUCE_USE_INTRINSICS
	#ifndef __INTEL_COMPILER
	 #pragma intrinsic (_InterlockedExchange, _InterlockedIncrement, _InterlockedDecrement, _InterlockedCompareExchange, \
						_InterlockedCompareExchange64, _InterlockedExchangeAdd, _ReadWriteBarrier)
	#endif
	#define juce_InterlockedExchange(a, b)              _InterlockedExchange(a, b)
	#define juce_InterlockedIncrement(a)                _InterlockedIncrement(a)
	#define juce_InterlockedDecrement(a)                _InterlockedDecrement(a)
	#define juce_InterlockedExchangeAdd(a, b)           _InterlockedExchangeAdd(a, b)
	#define juce_InterlockedCompareExchange(a, b, c)    _InterlockedCompareExchange(a, b, c)
	#define juce_InterlockedCompareExchange64(a, b, c)  _InterlockedCompareExchange64(a, b, c)
	#define juce_MemoryBarrier _ReadWriteBarrier
  #else
	long juce_InterlockedExchange (volatile long* a, long b) noexcept;
	long juce_InterlockedIncrement (volatile long* a) noexcept;
	long juce_InterlockedDecrement (volatile long* a) noexcept;
	long juce_InterlockedExchangeAdd (volatile long* a, long b) noexcept;
	long juce_InterlockedCompareExchange (volatile long* a, long b, long c) noexcept;
	__int64 juce_InterlockedCompareExchange64 (volatile __int64* a, __int64 b, __int64 c) noexcept;
	inline void juce_MemoryBarrier() noexcept  { long x = 0; juce_InterlockedIncrement (&x); }
  #endif

  #if JUCE_64BIT
	#ifndef __INTEL_COMPILER
	 #pragma intrinsic (_InterlockedExchangeAdd64, _InterlockedExchange64, _InterlockedIncrement64, _InterlockedDecrement64)
	#endif
	#define juce_InterlockedExchangeAdd64(a, b)     _InterlockedExchangeAdd64(a, b)
	#define juce_InterlockedExchange64(a, b)        _InterlockedExchange64(a, b)
	#define juce_InterlockedIncrement64(a)          _InterlockedIncrement64(a)
	#define juce_InterlockedDecrement64(a)          _InterlockedDecrement64(a)
  #else
	// None of these atomics are available in a 32-bit Windows build!!
	template <typename Type> static Type juce_InterlockedExchangeAdd64 (volatile Type* a, Type b) noexcept  { jassertfalse; Type old = *a; *a += b; return old; }
	template <typename Type> static Type juce_InterlockedExchange64 (volatile Type* a, Type b) noexcept     { jassertfalse; Type old = *a; *a = b; return old; }
	template <typename Type> static Type juce_InterlockedIncrement64 (volatile Type* a) noexcept            { jassertfalse; return ++*a; }
	template <typename Type> static Type juce_InterlockedDecrement64 (volatile Type* a) noexcept            { jassertfalse; return --*a; }
	#define JUCE_64BIT_ATOMICS_UNAVAILABLE 1
  #endif
#endif

#if JUCE_MSVC
  #pragma warning (push)
  #pragma warning (disable: 4311)  // (truncation warning)
#endif

template <typename Type>
inline Type Atomic<Type>::get() const noexcept
{
  #if JUCE_ATOMICS_MAC
	return sizeof (Type) == 4 ? castFrom32Bit ((int32) OSAtomicAdd32Barrier ((int32_t) 0, (JUCE_MAC_ATOMICS_VOLATILE int32_t*) &value))
							  : castFrom64Bit ((int64) OSAtomicAdd64Barrier ((int64_t) 0, (JUCE_MAC_ATOMICS_VOLATILE int64_t*) &value));
  #elif JUCE_ATOMICS_WINDOWS
	return sizeof (Type) == 4 ? castFrom32Bit ((int32) juce_InterlockedExchangeAdd ((volatile long*) &value, (long) 0))
							  : castFrom64Bit ((int64) juce_InterlockedExchangeAdd64 ((volatile __int64*) &value, (__int64) 0));
  #elif JUCE_ATOMICS_GCC
	return sizeof (Type) == 4 ? castFrom32Bit ((int32) __sync_add_and_fetch ((volatile int32*) &value, 0))
							  : castFrom64Bit ((int64) __sync_add_and_fetch ((volatile int64*) &value, 0));
  #endif
}

template <typename Type>
inline Type Atomic<Type>::exchange (const Type newValue) noexcept
{
  #if JUCE_ATOMICS_MAC || JUCE_ATOMICS_GCC
	Type currentVal = value;
	while (! compareAndSetBool (newValue, currentVal)) { currentVal = value; }
	return currentVal;
  #elif JUCE_ATOMICS_WINDOWS
	return sizeof (Type) == 4 ? castFrom32Bit ((int32) juce_InterlockedExchange ((volatile long*) &value, (long) castTo32Bit (newValue)))
							  : castFrom64Bit ((int64) juce_InterlockedExchange64 ((volatile __int64*) &value, (__int64) castTo64Bit (newValue)));
  #endif
}

template <typename Type>
inline Type Atomic<Type>::operator+= (const Type amountToAdd) noexcept
{
  #if JUCE_ATOMICS_MAC
	return sizeof (Type) == 4 ? (Type) OSAtomicAdd32Barrier ((int32_t) castTo32Bit (amountToAdd), (JUCE_MAC_ATOMICS_VOLATILE int32_t*) &value)
							  : (Type) OSAtomicAdd64Barrier ((int64_t) amountToAdd, (JUCE_MAC_ATOMICS_VOLATILE int64_t*) &value);
  #elif JUCE_ATOMICS_WINDOWS
	return sizeof (Type) == 4 ? (Type) (juce_InterlockedExchangeAdd ((volatile long*) &value, (long) amountToAdd) + (long) amountToAdd)
							  : (Type) (juce_InterlockedExchangeAdd64 ((volatile __int64*) &value, (__int64) amountToAdd) + (__int64) amountToAdd);
  #elif JUCE_ATOMICS_GCC
	return (Type) __sync_add_and_fetch (&value, amountToAdd);
  #endif
}

template <typename Type>
inline Type Atomic<Type>::operator-= (const Type amountToSubtract) noexcept
{
	return operator+= (juce_negate (amountToSubtract));
}

template <typename Type>
inline Type Atomic<Type>::operator++() noexcept
{
  #if JUCE_ATOMICS_MAC
	return sizeof (Type) == 4 ? (Type) OSAtomicIncrement32Barrier ((JUCE_MAC_ATOMICS_VOLATILE int32_t*) &value)
							  : (Type) OSAtomicIncrement64Barrier ((JUCE_MAC_ATOMICS_VOLATILE int64_t*) &value);
  #elif JUCE_ATOMICS_WINDOWS
	return sizeof (Type) == 4 ? (Type) juce_InterlockedIncrement ((volatile long*) &value)
							  : (Type) juce_InterlockedIncrement64 ((volatile __int64*) &value);
  #elif JUCE_ATOMICS_GCC
	return (Type) __sync_add_and_fetch (&value, 1);
  #endif
}

template <typename Type>
inline Type Atomic<Type>::operator--() noexcept
{
  #if JUCE_ATOMICS_MAC
	return sizeof (Type) == 4 ? (Type) OSAtomicDecrement32Barrier ((JUCE_MAC_ATOMICS_VOLATILE int32_t*) &value)
							  : (Type) OSAtomicDecrement64Barrier ((JUCE_MAC_ATOMICS_VOLATILE int64_t*) &value);
  #elif JUCE_ATOMICS_WINDOWS
	return sizeof (Type) == 4 ? (Type) juce_InterlockedDecrement ((volatile long*) &value)
							  : (Type) juce_InterlockedDecrement64 ((volatile __int64*) &value);
  #elif JUCE_ATOMICS_GCC
	return (Type) __sync_add_and_fetch (&value, -1);
  #endif
}

template <typename Type>
inline bool Atomic<Type>::compareAndSetBool (const Type newValue, const Type valueToCompare) noexcept
{
  #if JUCE_ATOMICS_MAC
	return sizeof (Type) == 4 ? OSAtomicCompareAndSwap32Barrier ((int32_t) castTo32Bit (valueToCompare), (int32_t) castTo32Bit (newValue), (JUCE_MAC_ATOMICS_VOLATILE int32_t*) &value)
							  : OSAtomicCompareAndSwap64Barrier ((int64_t) castTo64Bit (valueToCompare), (int64_t) castTo64Bit (newValue), (JUCE_MAC_ATOMICS_VOLATILE int64_t*) &value);
  #elif JUCE_ATOMICS_WINDOWS
	return compareAndSetValue (newValue, valueToCompare) == valueToCompare;
  #elif JUCE_ATOMICS_GCC
	return sizeof (Type) == 4 ? __sync_bool_compare_and_swap ((volatile int32*) &value, castTo32Bit (valueToCompare), castTo32Bit (newValue))
							  : __sync_bool_compare_and_swap ((volatile int64*) &value, castTo64Bit (valueToCompare), castTo64Bit (newValue));
  #endif
}

template <typename Type>
inline Type Atomic<Type>::compareAndSetValue (const Type newValue, const Type valueToCompare) noexcept
{
  #if JUCE_ATOMICS_MAC
	for (;;) // Annoying workaround for only having a bool CAS operation..
	{
		if (compareAndSetBool (newValue, valueToCompare))
			return valueToCompare;

		const Type result = value;
		if (result != valueToCompare)
			return result;
	}

  #elif JUCE_ATOMICS_WINDOWS
	return sizeof (Type) == 4 ? castFrom32Bit ((int32) juce_InterlockedCompareExchange ((volatile long*) &value, (long) castTo32Bit (newValue), (long) castTo32Bit (valueToCompare)))
							  : castFrom64Bit ((int64) juce_InterlockedCompareExchange64 ((volatile __int64*) &value, (__int64) castTo64Bit (newValue), (__int64) castTo64Bit (valueToCompare)));
  #elif JUCE_ATOMICS_GCC
	return sizeof (Type) == 4 ? castFrom32Bit ((int32) __sync_val_compare_and_swap ((volatile int32*) &value, castTo32Bit (valueToCompare), castTo32Bit (newValue)))
							  : castFrom64Bit ((int64) __sync_val_compare_and_swap ((volatile int64*) &value, castTo64Bit (valueToCompare), castTo64Bit (newValue)));
  #endif
}

template <typename Type>
inline void Atomic<Type>::memoryBarrier() noexcept
{
  #if JUCE_ATOMICS_MAC
	OSMemoryBarrier();
  #elif JUCE_ATOMICS_GCC
	__sync_synchronize();
  #elif JUCE_ATOMICS_WINDOWS
	juce_MemoryBarrier();
  #endif
}

#if JUCE_MSVC
  #pragma warning (pop)
#endif

#endif   // __JUCE_ATOMIC_JUCEHEADER__

/*** End of inlined file: juce_Atomic.h ***/


/*** Start of inlined file: juce_CharPointer_UTF8.h ***/
#ifndef __JUCE_CHARPOINTER_UTF8_JUCEHEADER__
#define __JUCE_CHARPOINTER_UTF8_JUCEHEADER__

/**
	Wraps a pointer to a null-terminated UTF-8 character string, and provides
	various methods to operate on the data.
	@see CharPointer_UTF16, CharPointer_UTF32
*/
class CharPointer_UTF8
{
public:
	typedef char CharType;

	inline explicit CharPointer_UTF8 (const CharType* const rawPointer) noexcept
		: data (const_cast <CharType*> (rawPointer))
	{
	}

	inline CharPointer_UTF8 (const CharPointer_UTF8& other) noexcept
		: data (other.data)
	{
	}

	inline CharPointer_UTF8& operator= (const CharPointer_UTF8& other) noexcept
	{
		data = other.data;
		return *this;
	}

	inline CharPointer_UTF8& operator= (const CharType* text) noexcept
	{
		data = const_cast <CharType*> (text);
		return *this;
	}

	/** This is a pointer comparison, it doesn't compare the actual text. */
	inline bool operator== (const CharPointer_UTF8& other) const noexcept { return data == other.data; }
	inline bool operator!= (const CharPointer_UTF8& other) const noexcept { return data != other.data; }
	inline bool operator<= (const CharPointer_UTF8& other) const noexcept { return data <= other.data; }
	inline bool operator<  (const CharPointer_UTF8& other) const noexcept { return data <  other.data; }
	inline bool operator>= (const CharPointer_UTF8& other) const noexcept { return data >= other.data; }
	inline bool operator>  (const CharPointer_UTF8& other) const noexcept { return data >  other.data; }

	/** Returns the address that this pointer is pointing to. */
	inline CharType* getAddress() const noexcept        { return data; }

	/** Returns the address that this pointer is pointing to. */
	inline operator const CharType*() const noexcept    { return data; }

	/** Returns true if this pointer is pointing to a null character. */
	inline bool isEmpty() const noexcept                { return *data == 0; }

	/** Returns the unicode character that this pointer is pointing to. */
	juce_wchar operator*() const noexcept
	{
		const signed char byte = (signed char) *data;

		if (byte >= 0)
			return (juce_wchar) (uint8) byte;

		uint32 n = (uint32) (uint8) byte;
		uint32 mask = 0x7f;
		uint32 bit = 0x40;
		size_t numExtraValues = 0;

		while ((n & bit) != 0 && bit > 0x10)
		{
			mask >>= 1;
			++numExtraValues;
			bit >>= 1;
		}

		n &= mask;

		for (size_t i = 1; i <= numExtraValues; ++i)
		{
			const uint8 nextByte = (uint8) data [i];

			if ((nextByte & 0xc0) != 0x80)
				break;

			n <<= 6;
			n |= (nextByte & 0x3f);
		}

		return (juce_wchar) n;
	}

	/** Moves this pointer along to the next character in the string. */
	CharPointer_UTF8& operator++() noexcept
	{
		const signed char n = (signed char) *data++;

		if (n < 0)
		{
			juce_wchar bit = 0x40;

			while ((n & bit) != 0 && bit > 0x8)
			{
				++data;
				bit >>= 1;
			}
		}

		return *this;
	}

	/** Moves this pointer back to the previous character in the string. */
	CharPointer_UTF8& operator--() noexcept
	{
		const char n = *--data;

		if ((n & 0xc0) == 0xc0)
		{
			int count = 3;

			do
			{
				--data;
			}
			while ((*data & 0xc0) == 0xc0 && --count >= 0);
		}

		return *this;
	}

	/** Returns the character that this pointer is currently pointing to, and then
		advances the pointer to point to the next character. */
	juce_wchar getAndAdvance() noexcept
	{
		const signed char byte = (signed char) *data++;

		if (byte >= 0)
			return (juce_wchar) (uint8) byte;

		uint32 n = (uint32) (uint8) byte;
		uint32 mask = 0x7f;
		uint32 bit = 0x40;
		int numExtraValues = 0;

		while ((n & bit) != 0 && bit > 0x8)
		{
			mask >>= 1;
			++numExtraValues;
			bit >>= 1;
		}

		n &= mask;

		while (--numExtraValues >= 0)
		{
			const uint32 nextByte = (uint32) (uint8) *data++;

			if ((nextByte & 0xc0) != 0x80)
				break;

			n <<= 6;
			n |= (nextByte & 0x3f);
		}

		return (juce_wchar) n;
	}

	/** Moves this pointer along to the next character in the string. */
	CharPointer_UTF8 operator++ (int) noexcept
	{
		CharPointer_UTF8 temp (*this);
		++*this;
		return temp;
	}

	/** Moves this pointer forwards by the specified number of characters. */
	void operator+= (int numToSkip) noexcept
	{
		if (numToSkip < 0)
		{
			while (++numToSkip <= 0)
				--*this;
		}
		else
		{
			while (--numToSkip >= 0)
				++*this;
		}
	}

	/** Moves this pointer backwards by the specified number of characters. */
	void operator-= (int numToSkip) noexcept
	{
		operator+= (-numToSkip);
	}

	/** Returns the character at a given character index from the start of the string. */
	juce_wchar operator[] (int characterIndex) const noexcept
	{
		CharPointer_UTF8 p (*this);
		p += characterIndex;
		return *p;
	}

	/** Returns a pointer which is moved forwards from this one by the specified number of characters. */
	CharPointer_UTF8 operator+ (int numToSkip) const noexcept
	{
		CharPointer_UTF8 p (*this);
		p += numToSkip;
		return p;
	}

	/** Returns a pointer which is moved backwards from this one by the specified number of characters. */
	CharPointer_UTF8 operator- (int numToSkip) const noexcept
	{
		CharPointer_UTF8 p (*this);
		p += -numToSkip;
		return p;
	}

	/** Returns the number of characters in this string. */
	size_t length() const noexcept
	{
		const CharType* d = data;
		size_t count = 0;

		for (;;)
		{
			const uint32 n = (uint32) (uint8) *d++;

			if ((n & 0x80) != 0)
			{
				uint32 bit = 0x40;

				while ((n & bit) != 0)
				{
					++d;
					bit >>= 1;

					if (bit == 0)
						break; // illegal utf-8 sequence
				}
			}
			else if (n == 0)
				break;

			++count;
		}

		return count;
	}

	/** Returns the number of characters in this string, or the given value, whichever is lower. */
	size_t lengthUpTo (const size_t maxCharsToCount) const noexcept
	{
		return CharacterFunctions::lengthUpTo (*this, maxCharsToCount);
	}

	/** Returns the number of characters in this string, or up to the given end pointer, whichever is lower. */
	size_t lengthUpTo (const CharPointer_UTF8& end) const noexcept
	{
		return CharacterFunctions::lengthUpTo (*this, end);
	}

	/** Returns the number of bytes that are used to represent this string.
		This includes the terminating null character.
	*/
	size_t sizeInBytes() const noexcept
	{
		jassert (data != nullptr);
		return strlen (data) + 1;
	}

	/** Returns the number of bytes that would be needed to represent the given
		unicode character in this encoding format.
	*/
	static size_t getBytesRequiredFor (const juce_wchar charToWrite) noexcept
	{
		size_t num = 1;
		const uint32 c = (uint32) charToWrite;

		if (c >= 0x80)
		{
			++num;
			if (c >= 0x800)
			{
				++num;
				if (c >= 0x10000)
					++num;
			}
		}

		return num;
	}

	/** Returns the number of bytes that would be needed to represent the given
		string in this encoding format.
		The value returned does NOT include the terminating null character.
	*/
	template <class CharPointer>
	static size_t getBytesRequiredFor (CharPointer text) noexcept
	{
		size_t count = 0;
		juce_wchar n;

		while ((n = text.getAndAdvance()) != 0)
			count += getBytesRequiredFor (n);

		return count;
	}

	/** Returns a pointer to the null character that terminates this string. */
	CharPointer_UTF8 findTerminatingNull() const noexcept
	{
		return CharPointer_UTF8 (data + strlen (data));
	}

	/** Writes a unicode character to this string, and advances this pointer to point to the next position. */
	void write (const juce_wchar charToWrite) noexcept
	{
		const uint32 c = (uint32) charToWrite;

		if (c >= 0x80)
		{
			int numExtraBytes = 1;
			if (c >= 0x800)
			{
				++numExtraBytes;
				if (c >= 0x10000)
					++numExtraBytes;
			}

			*data++ = (CharType) ((0xff << (7 - numExtraBytes)) | (c >> (numExtraBytes * 6)));

			while (--numExtraBytes >= 0)
				*data++ = (CharType) (0x80 | (0x3f & (c >> (numExtraBytes * 6))));
		}
		else
		{
			*data++ = (CharType) c;
		}
	}

	/** Writes a null character to this string (leaving the pointer's position unchanged). */
	inline void writeNull() const noexcept
	{
		*data = 0;
	}

	/** Copies a source string to this pointer, advancing this pointer as it goes. */
	template <typename CharPointer>
	void writeAll (const CharPointer& src) noexcept
	{
		CharacterFunctions::copyAll (*this, src);
	}

	/** Copies a source string to this pointer, advancing this pointer as it goes. */
	void writeAll (const CharPointer_UTF8& src) noexcept
	{
		const CharType* s = src.data;

		while ((*data = *s) != 0)
		{
			++data;
			++s;
		}
	}

	/** Copies a source string to this pointer, advancing this pointer as it goes.
		The maxDestBytes parameter specifies the maximum number of bytes that can be written
		to the destination buffer before stopping.
	*/
	template <typename CharPointer>
	int writeWithDestByteLimit (const CharPointer& src, const int maxDestBytes) noexcept
	{
		return CharacterFunctions::copyWithDestByteLimit (*this, src, maxDestBytes);
	}

	/** Copies a source string to this pointer, advancing this pointer as it goes.
		The maxChars parameter specifies the maximum number of characters that can be
		written to the destination buffer before stopping (including the terminating null).
	*/
	template <typename CharPointer>
	void writeWithCharLimit (const CharPointer& src, const int maxChars) noexcept
	{
		CharacterFunctions::copyWithCharLimit (*this, src, maxChars);
	}

	/** Compares this string with another one. */
	template <typename CharPointer>
	int compare (const CharPointer& other) const noexcept
	{
		return CharacterFunctions::compare (*this, other);
	}

	/** Compares this string with another one, up to a specified number of characters. */
	template <typename CharPointer>
	int compareUpTo (const CharPointer& other, const int maxChars) const noexcept
	{
		return CharacterFunctions::compareUpTo (*this, other, maxChars);
	}

	/** Compares this string with another one. */
	template <typename CharPointer>
	int compareIgnoreCase (const CharPointer& other) const noexcept
	{
		return CharacterFunctions::compareIgnoreCase (*this, other);
	}

	/** Compares this string with another one. */
	int compareIgnoreCase (const CharPointer_UTF8& other) const noexcept
	{
	   #if JUCE_WINDOWS
		return stricmp (data, other.data);
	   #else
		return strcasecmp (data, other.data);
	   #endif
	}

	/** Compares this string with another one, up to a specified number of characters. */
	template <typename CharPointer>
	int compareIgnoreCaseUpTo (const CharPointer& other, const int maxChars) const noexcept
	{
		return CharacterFunctions::compareIgnoreCaseUpTo (*this, other, maxChars);
	}

	/** Returns the character index of a substring, or -1 if it isn't found. */
	template <typename CharPointer>
	int indexOf (const CharPointer& stringToFind) const noexcept
	{
		return CharacterFunctions::indexOf (*this, stringToFind);
	}

	/** Returns the character index of a unicode character, or -1 if it isn't found. */
	int indexOf (const juce_wchar charToFind) const noexcept
	{
		return CharacterFunctions::indexOfChar (*this, charToFind);
	}

	/** Returns the character index of a unicode character, or -1 if it isn't found. */
	int indexOf (const juce_wchar charToFind, const bool ignoreCase) const noexcept
	{
		return ignoreCase ? CharacterFunctions::indexOfCharIgnoreCase (*this, charToFind)
						  : CharacterFunctions::indexOfChar (*this, charToFind);
	}

	/** Returns true if the first character of this string is whitespace. */
	bool isWhitespace() const noexcept      { return *data == ' ' || (*data <= 13 && *data >= 9); }
	/** Returns true if the first character of this string is a digit. */
	bool isDigit() const noexcept           { return *data >= '0' && *data <= '9'; }
	/** Returns true if the first character of this string is a letter. */
	bool isLetter() const noexcept          { return CharacterFunctions::isLetter (operator*()) != 0; }
	/** Returns true if the first character of this string is a letter or digit. */
	bool isLetterOrDigit() const noexcept   { return CharacterFunctions::isLetterOrDigit (operator*()) != 0; }
	/** Returns true if the first character of this string is upper-case. */
	bool isUpperCase() const noexcept       { return CharacterFunctions::isUpperCase (operator*()) != 0; }
	/** Returns true if the first character of this string is lower-case. */
	bool isLowerCase() const noexcept       { return CharacterFunctions::isLowerCase (operator*()) != 0; }

	/** Returns an upper-case version of the first character of this string. */
	juce_wchar toUpperCase() const noexcept { return CharacterFunctions::toUpperCase (operator*()); }
	/** Returns a lower-case version of the first character of this string. */
	juce_wchar toLowerCase() const noexcept { return CharacterFunctions::toLowerCase (operator*()); }

	/** Parses this string as a 32-bit integer. */
	int getIntValue32() const noexcept      { return atoi (data); }

	/** Parses this string as a 64-bit integer. */
	int64 getIntValue64() const noexcept
	{
	   #if JUCE_LINUX || JUCE_ANDROID
		return atoll (data);
	   #elif JUCE_WINDOWS
		return _atoi64 (data);
	   #else
		return CharacterFunctions::getIntValue <int64, CharPointer_UTF8> (*this);
	   #endif
	}

	/** Parses this string as a floating point double. */
	double getDoubleValue() const noexcept  { return CharacterFunctions::getDoubleValue (*this); }

	/** Returns the first non-whitespace character in the string. */
	CharPointer_UTF8 findEndOfWhitespace() const noexcept   { return CharacterFunctions::findEndOfWhitespace (*this); }

	/** Returns true if the given unicode character can be represented in this encoding. */
	static bool canRepresent (juce_wchar character) noexcept
	{
		return ((unsigned int) character) < (unsigned int) 0x10ffff;
	}

	/** Returns true if this data contains a valid string in this encoding. */
	static bool isValidString (const CharType* dataToTest, int maxBytesToRead)
	{
		while (--maxBytesToRead >= 0 && *dataToTest != 0)
		{
			const signed char byte = (signed char) *dataToTest;

			if (byte < 0)
			{
				uint32 n = (uint32) (uint8) byte;
				uint32 mask = 0x7f;
				uint32 bit = 0x40;
				int numExtraValues = 0;

				while ((n & bit) != 0)
				{
					if (bit <= 0x10)
						return false;

					mask >>= 1;
					++numExtraValues;
					bit >>= 1;
				}

				n &= mask;

				while (--numExtraValues >= 0)
				{
					const uint32 nextByte = (uint32) (uint8) *dataToTest++;

					if ((nextByte & 0xc0) != 0x80)
						return false;
				}
			}
		}

		return true;
	}

	/** Atomically swaps this pointer for a new value, returning the previous value. */
	CharPointer_UTF8 atomicSwap (const CharPointer_UTF8& newValue)
	{
		return CharPointer_UTF8 (reinterpret_cast <Atomic<CharType*>&> (data).exchange (newValue.data));
	}

	/** These values are the byte-order-mark (BOM) values for a UTF-8 stream. */
	enum
	{
		byteOrderMark1 = 0xef,
		byteOrderMark2 = 0xbb,
		byteOrderMark3 = 0xbf
	};

private:
	CharType* data;
};

#endif   // __JUCE_CHARPOINTER_UTF8_JUCEHEADER__

/*** End of inlined file: juce_CharPointer_UTF8.h ***/


/*** Start of inlined file: juce_CharPointer_UTF16.h ***/
#ifndef __JUCE_CHARPOINTER_UTF16_JUCEHEADER__
#define __JUCE_CHARPOINTER_UTF16_JUCEHEADER__

/**
	Wraps a pointer to a null-terminated UTF-16 character string, and provides
	various methods to operate on the data.
	@see CharPointer_UTF8, CharPointer_UTF32
*/
class CharPointer_UTF16
{
public:
   #if JUCE_NATIVE_WCHAR_IS_UTF16
	typedef wchar_t CharType;
   #else
	typedef int16 CharType;
   #endif

	inline explicit CharPointer_UTF16 (const CharType* const rawPointer) noexcept
		: data (const_cast <CharType*> (rawPointer))
	{
	}

	inline CharPointer_UTF16 (const CharPointer_UTF16& other) noexcept
		: data (other.data)
	{
	}

	inline CharPointer_UTF16& operator= (const CharPointer_UTF16& other) noexcept
	{
		data = other.data;
		return *this;
	}

	inline CharPointer_UTF16& operator= (const CharType* text) noexcept
	{
		data = const_cast <CharType*> (text);
		return *this;
	}

	/** This is a pointer comparison, it doesn't compare the actual text. */
	inline bool operator== (const CharPointer_UTF16& other) const noexcept { return data == other.data; }
	inline bool operator!= (const CharPointer_UTF16& other) const noexcept { return data != other.data; }
	inline bool operator<= (const CharPointer_UTF16& other) const noexcept { return data <= other.data; }
	inline bool operator<  (const CharPointer_UTF16& other) const noexcept { return data <  other.data; }
	inline bool operator>= (const CharPointer_UTF16& other) const noexcept { return data >= other.data; }
	inline bool operator>  (const CharPointer_UTF16& other) const noexcept { return data >  other.data; }

	/** Returns the address that this pointer is pointing to. */
	inline CharType* getAddress() const noexcept        { return data; }

	/** Returns the address that this pointer is pointing to. */
	inline operator const CharType*() const noexcept    { return data; }

	/** Returns true if this pointer is pointing to a null character. */
	inline bool isEmpty() const noexcept                { return *data == 0; }

	/** Returns the unicode character that this pointer is pointing to. */
	juce_wchar operator*() const noexcept
	{
		uint32 n = (uint32) (uint16) *data;

		if (n >= 0xd800 && n <= 0xdfff && ((uint32) (uint16) data[1]) >= 0xdc00)
			n = 0x10000 + (((n - 0xd800) << 10) | (((uint32) (uint16) data[1]) - 0xdc00));

		return (juce_wchar) n;
	}

	/** Moves this pointer along to the next character in the string. */
	CharPointer_UTF16& operator++() noexcept
	{
		const juce_wchar n = *data++;

		if (n >= 0xd800 && n <= 0xdfff && ((uint32) (uint16) *data) >= 0xdc00)
			++data;

		return *this;
	}

	/** Moves this pointer back to the previous character in the string. */
	CharPointer_UTF16& operator--() noexcept
	{
		const juce_wchar n = *--data;

		if (n >= 0xdc00 && n <= 0xdfff)
			--data;

		return *this;
	}

	/** Returns the character that this pointer is currently pointing to, and then
		advances the pointer to point to the next character. */
	juce_wchar getAndAdvance() noexcept
	{
		uint32 n = (uint32) (uint16) *data++;

		if (n >= 0xd800 && n <= 0xdfff && ((uint32) (uint16) *data) >= 0xdc00)
			n = 0x10000 + ((((n - 0xd800) << 10) | (((uint32) (uint16) *data++) - 0xdc00)));

		return (juce_wchar) n;
	}

	/** Moves this pointer along to the next character in the string. */
	CharPointer_UTF16 operator++ (int) noexcept
	{
		CharPointer_UTF16 temp (*this);
		++*this;
		return temp;
	}

	/** Moves this pointer forwards by the specified number of characters. */
	void operator+= (int numToSkip) noexcept
	{
		if (numToSkip < 0)
		{
			while (++numToSkip <= 0)
				--*this;
		}
		else
		{
			while (--numToSkip >= 0)
				++*this;
		}
	}

	/** Moves this pointer backwards by the specified number of characters. */
	void operator-= (int numToSkip) noexcept
	{
		operator+= (-numToSkip);
	}

	/** Returns the character at a given character index from the start of the string. */
	juce_wchar operator[] (const int characterIndex) const noexcept
	{
		CharPointer_UTF16 p (*this);
		p += characterIndex;
		return *p;
	}

	/** Returns a pointer which is moved forwards from this one by the specified number of characters. */
	CharPointer_UTF16 operator+ (const int numToSkip) const noexcept
	{
		CharPointer_UTF16 p (*this);
		p += numToSkip;
		return p;
	}

	/** Returns a pointer which is moved backwards from this one by the specified number of characters. */
	CharPointer_UTF16 operator- (const int numToSkip) const noexcept
	{
		CharPointer_UTF16 p (*this);
		p += -numToSkip;
		return p;
	}

	/** Writes a unicode character to this string, and advances this pointer to point to the next position. */
	void write (juce_wchar charToWrite) noexcept
	{
		if (charToWrite >= 0x10000)
		{
			charToWrite -= 0x10000;
			*data++ = (CharType) (0xd800 + (charToWrite >> 10));
			*data++ = (CharType) (0xdc00 + (charToWrite & 0x3ff));
		}
		else
		{
			*data++ = (CharType) charToWrite;
		}
	}

	/** Writes a null character to this string (leaving the pointer's position unchanged). */
	inline void writeNull() const noexcept
	{
		*data = 0;
	}

	/** Returns the number of characters in this string. */
	size_t length() const noexcept
	{
		const CharType* d = data;
		size_t count = 0;

		for (;;)
		{
			const int n = *d++;

			if (n >= 0xd800 && n <= 0xdfff)
			{
				if (*d++ == 0)
					break;
			}
			else if (n == 0)
				break;

			++count;
		}

		return count;
	}

	/** Returns the number of characters in this string, or the given value, whichever is lower. */
	size_t lengthUpTo (const size_t maxCharsToCount) const noexcept
	{
		return CharacterFunctions::lengthUpTo (*this, maxCharsToCount);
	}

	/** Returns the number of characters in this string, or up to the given end pointer, whichever is lower. */
	size_t lengthUpTo (const CharPointer_UTF16& end) const noexcept
	{
		return CharacterFunctions::lengthUpTo (*this, end);
	}

	/** Returns the number of bytes that are used to represent this string.
		This includes the terminating null character.
	*/
	size_t sizeInBytes() const noexcept
	{
		return sizeof (CharType) * (findNullIndex (data) + 1);
	}

	/** Returns the number of bytes that would be needed to represent the given
		unicode character in this encoding format.
	*/
	static size_t getBytesRequiredFor (const juce_wchar charToWrite) noexcept
	{
		return (charToWrite >= 0x10000) ? (sizeof (CharType) * 2) : sizeof (CharType);
	}

	/** Returns the number of bytes that would be needed to represent the given
		string in this encoding format.
		The value returned does NOT include the terminating null character.
	*/
	template <class CharPointer>
	static size_t getBytesRequiredFor (CharPointer text) noexcept
	{
		size_t count = 0;
		juce_wchar n;

		while ((n = text.getAndAdvance()) != 0)
			count += getBytesRequiredFor (n);

		return count;
	}

	/** Returns a pointer to the null character that terminates this string. */
	CharPointer_UTF16 findTerminatingNull() const noexcept
	{
		const CharType* t = data;

		while (*t != 0)
			++t;

		return CharPointer_UTF16 (t);
	}

	/** Copies a source string to this pointer, advancing this pointer as it goes. */
	template <typename CharPointer>
	void writeAll (const CharPointer& src) noexcept
	{
		CharacterFunctions::copyAll (*this, src);
	}

	/** Copies a source string to this pointer, advancing this pointer as it goes. */
	void writeAll (const CharPointer_UTF16& src) noexcept
	{
		const CharType* s = src.data;

		while ((*data = *s) != 0)
		{
			++data;
			++s;
		}
	}

	/** Copies a source string to this pointer, advancing this pointer as it goes.
		The maxDestBytes parameter specifies the maximum number of bytes that can be written
		to the destination buffer before stopping.
	*/
	template <typename CharPointer>
	int writeWithDestByteLimit (const CharPointer& src, const int maxDestBytes) noexcept
	{
		return CharacterFunctions::copyWithDestByteLimit (*this, src, maxDestBytes);
	}

	/** Copies a source string to this pointer, advancing this pointer as it goes.
		The maxChars parameter specifies the maximum number of characters that can be
		written to the destination buffer before stopping (including the terminating null).
	*/
	template <typename CharPointer>
	void writeWithCharLimit (const CharPointer& src, const int maxChars) noexcept
	{
		CharacterFunctions::copyWithCharLimit (*this, src, maxChars);
	}

	/** Compares this string with another one. */
	template <typename CharPointer>
	int compare (const CharPointer& other) const noexcept
	{
		return CharacterFunctions::compare (*this, other);
	}

	/** Compares this string with another one, up to a specified number of characters. */
	template <typename CharPointer>
	int compareUpTo (const CharPointer& other, const int maxChars) const noexcept
	{
		return CharacterFunctions::compareUpTo (*this, other, maxChars);
	}

	/** Compares this string with another one. */
	template <typename CharPointer>
	int compareIgnoreCase (const CharPointer& other) const noexcept
	{
		return CharacterFunctions::compareIgnoreCase (*this, other);
	}

	/** Compares this string with another one, up to a specified number of characters. */
	template <typename CharPointer>
	int compareIgnoreCaseUpTo (const CharPointer& other, const int maxChars) const noexcept
	{
		return CharacterFunctions::compareIgnoreCaseUpTo (*this, other, maxChars);
	}

   #if JUCE_WINDOWS && ! DOXYGEN
	int compareIgnoreCase (const CharPointer_UTF16& other) const noexcept
	{
		return _wcsicmp (data, other.data);
	}

	int compareIgnoreCaseUpTo (const CharPointer_UTF16& other, int maxChars) const noexcept
	{
		return _wcsnicmp (data, other.data, (size_t) maxChars);
	}

	int indexOf (const CharPointer_UTF16& stringToFind) const noexcept
	{
		const CharType* const t = wcsstr (data, stringToFind.getAddress());
		return t == nullptr ? -1 : (int) (t - data);
	}
   #endif

	/** Returns the character index of a substring, or -1 if it isn't found. */
	template <typename CharPointer>
	int indexOf (const CharPointer& stringToFind) const noexcept
	{
		return CharacterFunctions::indexOf (*this, stringToFind);
	}

	/** Returns the character index of a unicode character, or -1 if it isn't found. */
	int indexOf (const juce_wchar charToFind) const noexcept
	{
		return CharacterFunctions::indexOfChar (*this, charToFind);
	}

	/** Returns the character index of a unicode character, or -1 if it isn't found. */
	int indexOf (const juce_wchar charToFind, const bool ignoreCase) const noexcept
	{
		return ignoreCase ? CharacterFunctions::indexOfCharIgnoreCase (*this, charToFind)
						  : CharacterFunctions::indexOfChar (*this, charToFind);
	}

	/** Returns true if the first character of this string is whitespace. */
	bool isWhitespace() const noexcept      { return CharacterFunctions::isWhitespace (operator*()) != 0; }
	/** Returns true if the first character of this string is a digit. */
	bool isDigit() const noexcept           { return CharacterFunctions::isDigit (operator*()) != 0; }
	/** Returns true if the first character of this string is a letter. */
	bool isLetter() const noexcept          { return CharacterFunctions::isLetter (operator*()) != 0; }
	/** Returns true if the first character of this string is a letter or digit. */
	bool isLetterOrDigit() const noexcept   { return CharacterFunctions::isLetterOrDigit (operator*()) != 0; }
	/** Returns true if the first character of this string is upper-case. */
	bool isUpperCase() const noexcept       { return CharacterFunctions::isUpperCase (operator*()) != 0; }
	/** Returns true if the first character of this string is lower-case. */
	bool isLowerCase() const noexcept       { return CharacterFunctions::isLowerCase (operator*()) != 0; }

	/** Returns an upper-case version of the first character of this string. */
	juce_wchar toUpperCase() const noexcept { return CharacterFunctions::toUpperCase (operator*()); }
	/** Returns a lower-case version of the first character of this string. */
	juce_wchar toLowerCase() const noexcept { return CharacterFunctions::toLowerCase (operator*()); }

	/** Parses this string as a 32-bit integer. */
	int getIntValue32() const noexcept
	{
	   #if JUCE_WINDOWS
		return _wtoi (data);
	   #else
		return CharacterFunctions::getIntValue <int, CharPointer_UTF16> (*this);
	   #endif
	}

	/** Parses this string as a 64-bit integer. */
	int64 getIntValue64() const noexcept
	{
	   #if JUCE_WINDOWS
		return _wtoi64 (data);
	   #else
		return CharacterFunctions::getIntValue <int64, CharPointer_UTF16> (*this);
	   #endif
	}

	/** Parses this string as a floating point double. */
	double getDoubleValue() const noexcept  { return CharacterFunctions::getDoubleValue (*this); }

	/** Returns the first non-whitespace character in the string. */
	CharPointer_UTF16 findEndOfWhitespace() const noexcept   { return CharacterFunctions::findEndOfWhitespace (*this); }

	/** Returns true if the given unicode character can be represented in this encoding. */
	static bool canRepresent (juce_wchar character) noexcept
	{
		return ((unsigned int) character) < (unsigned int) 0x10ffff
				 && (((unsigned int) character) < 0xd800 || ((unsigned int) character) > 0xdfff);
	}

	/** Returns true if this data contains a valid string in this encoding. */
	static bool isValidString (const CharType* dataToTest, int maxBytesToRead)
	{
		maxBytesToRead /= sizeof (CharType);

		while (--maxBytesToRead >= 0 && *dataToTest != 0)
		{
			const uint32 n = (uint32) (uint16) *dataToTest++;

			if (n >= 0xd800)
			{
				if (n > 0x10ffff)
					return false;

				if (n <= 0xdfff)
				{
					if (n > 0xdc00)
						return false;

					const uint32 nextChar = (uint32) (uint16) *dataToTest++;

					if (nextChar < 0xdc00 || nextChar > 0xdfff)
						return false;
				}
			}
		}

		return true;
	}

	/** Atomically swaps this pointer for a new value, returning the previous value. */
	CharPointer_UTF16 atomicSwap (const CharPointer_UTF16& newValue)
	{
		return CharPointer_UTF16 (reinterpret_cast <Atomic<CharType*>&> (data).exchange (newValue.data));
	}

	/** These values are the byte-order-mark (BOM) values for a UTF-16 stream. */
	enum
	{
		byteOrderMarkBE1 = 0xfe,
		byteOrderMarkBE2 = 0xff,
		byteOrderMarkLE1 = 0xff,
		byteOrderMarkLE2 = 0xfe
	};

private:
	CharType* data;

	static int findNullIndex (const CharType* const t) noexcept
	{
		int n = 0;

		while (t[n] != 0)
			++n;

		return n;
	}
};

#endif   // __JUCE_CHARPOINTER_UTF16_JUCEHEADER__

/*** End of inlined file: juce_CharPointer_UTF16.h ***/


/*** Start of inlined file: juce_CharPointer_UTF32.h ***/
#ifndef __JUCE_CHARPOINTER_UTF32_JUCEHEADER__
#define __JUCE_CHARPOINTER_UTF32_JUCEHEADER__

/**
	Wraps a pointer to a null-terminated UTF-32 character string, and provides
	various methods to operate on the data.
	@see CharPointer_UTF8, CharPointer_UTF16
*/
class CharPointer_UTF32
{
public:
	typedef juce_wchar CharType;

	inline explicit CharPointer_UTF32 (const CharType* const rawPointer) noexcept
		: data (const_cast <CharType*> (rawPointer))
	{
	}

	inline CharPointer_UTF32 (const CharPointer_UTF32& other) noexcept
		: data (other.data)
	{
	}

	inline CharPointer_UTF32& operator= (const CharPointer_UTF32& other) noexcept
	{
		data = other.data;
		return *this;
	}

	inline CharPointer_UTF32& operator= (const CharType* text) noexcept
	{
		data = const_cast <CharType*> (text);
		return *this;
	}

	/** This is a pointer comparison, it doesn't compare the actual text. */
	inline bool operator== (const CharPointer_UTF32& other) const noexcept { return data == other.data; }
	inline bool operator!= (const CharPointer_UTF32& other) const noexcept { return data != other.data; }
	inline bool operator<= (const CharPointer_UTF32& other) const noexcept { return data <= other.data; }
	inline bool operator<  (const CharPointer_UTF32& other) const noexcept { return data <  other.data; }
	inline bool operator>= (const CharPointer_UTF32& other) const noexcept { return data >= other.data; }
	inline bool operator>  (const CharPointer_UTF32& other) const noexcept { return data >  other.data; }

	/** Returns the address that this pointer is pointing to. */
	inline CharType* getAddress() const noexcept        { return data; }

	/** Returns the address that this pointer is pointing to. */
	inline operator const CharType*() const noexcept    { return data; }

	/** Returns true if this pointer is pointing to a null character. */
	inline bool isEmpty() const noexcept                { return *data == 0; }

	/** Returns the unicode character that this pointer is pointing to. */
	inline juce_wchar operator*() const noexcept        { return *data; }

	/** Moves this pointer along to the next character in the string. */
	inline CharPointer_UTF32& operator++() noexcept
	{
		++data;
		return *this;
	}

	/** Moves this pointer to the previous character in the string. */
	inline CharPointer_UTF32& operator--() noexcept
	{
		--data;
		return *this;
	}

	/** Returns the character that this pointer is currently pointing to, and then
		advances the pointer to point to the next character. */
	inline juce_wchar getAndAdvance() noexcept  { return *data++; }

	/** Moves this pointer along to the next character in the string. */
	CharPointer_UTF32 operator++ (int) noexcept
	{
		CharPointer_UTF32 temp (*this);
		++data;
		return temp;
	}

	/** Moves this pointer forwards by the specified number of characters. */
	inline void operator+= (const int numToSkip) noexcept
	{
		data += numToSkip;
	}

	inline void operator-= (const int numToSkip) noexcept
	{
		data -= numToSkip;
	}

	/** Returns the character at a given character index from the start of the string. */
	inline juce_wchar& operator[] (const int characterIndex) const noexcept
	{
		return data [characterIndex];
	}

	/** Returns a pointer which is moved forwards from this one by the specified number of characters. */
	CharPointer_UTF32 operator+ (const int numToSkip) const noexcept
	{
		return CharPointer_UTF32 (data + numToSkip);
	}

	/** Returns a pointer which is moved backwards from this one by the specified number of characters. */
	CharPointer_UTF32 operator- (const int numToSkip) const noexcept
	{
		return CharPointer_UTF32 (data - numToSkip);
	}

	/** Writes a unicode character to this string, and advances this pointer to point to the next position. */
	inline void write (const juce_wchar charToWrite) noexcept
	{
		*data++ = charToWrite;
	}

	inline void replaceChar (const juce_wchar newChar) noexcept
	{
		*data = newChar;
	}

	/** Writes a null character to this string (leaving the pointer's position unchanged). */
	inline void writeNull() const noexcept
	{
		*data = 0;
	}

	/** Returns the number of characters in this string. */
	size_t length() const noexcept
	{
	   #if JUCE_NATIVE_WCHAR_IS_UTF32 && ! JUCE_ANDROID
		return wcslen (data);
	   #else
		size_t n = 0;
		while (data[n] != 0)
			++n;
		return n;
	   #endif
	}

	/** Returns the number of characters in this string, or the given value, whichever is lower. */
	size_t lengthUpTo (const size_t maxCharsToCount) const noexcept
	{
		return CharacterFunctions::lengthUpTo (*this, maxCharsToCount);
	}

	/** Returns the number of characters in this string, or up to the given end pointer, whichever is lower. */
	size_t lengthUpTo (const CharPointer_UTF32& end) const noexcept
	{
		return CharacterFunctions::lengthUpTo (*this, end);
	}

	/** Returns the number of bytes that are used to represent this string.
		This includes the terminating null character.
	*/
	size_t sizeInBytes() const noexcept
	{
		return sizeof (CharType) * (length() + 1);
	}

	/** Returns the number of bytes that would be needed to represent the given
		unicode character in this encoding format.
	*/
	static inline size_t getBytesRequiredFor (const juce_wchar) noexcept
	{
		return sizeof (CharType);
	}

	/** Returns the number of bytes that would be needed to represent the given
		string in this encoding format.
		The value returned does NOT include the terminating null character.
	*/
	template <class CharPointer>
	static size_t getBytesRequiredFor (const CharPointer& text) noexcept
	{
		return sizeof (CharType) * text.length();
	}

	/** Returns a pointer to the null character that terminates this string. */
	CharPointer_UTF32 findTerminatingNull() const noexcept
	{
		return CharPointer_UTF32 (data + length());
	}

	/** Copies a source string to this pointer, advancing this pointer as it goes. */
	template <typename CharPointer>
	void writeAll (const CharPointer& src) noexcept
	{
		CharacterFunctions::copyAll (*this, src);
	}

	/** Copies a source string to this pointer, advancing this pointer as it goes. */
	void writeAll (const CharPointer_UTF32& src) noexcept
	{
		const CharType* s = src.data;

		while ((*data = *s) != 0)
		{
			++data;
			++s;
		}
	}

	/** Copies a source string to this pointer, advancing this pointer as it goes.
		The maxDestBytes parameter specifies the maximum number of bytes that can be written
		to the destination buffer before stopping.
	*/
	template <typename CharPointer>
	int writeWithDestByteLimit (const CharPointer& src, const int maxDestBytes) noexcept
	{
		return CharacterFunctions::copyWithDestByteLimit (*this, src, maxDestBytes);
	}

	/** Copies a source string to this pointer, advancing this pointer as it goes.
		The maxChars parameter specifies the maximum number of characters that can be
		written to the destination buffer before stopping (including the terminating null).
	*/
	template <typename CharPointer>
	void writeWithCharLimit (const CharPointer& src, const int maxChars) noexcept
	{
		CharacterFunctions::copyWithCharLimit (*this, src, maxChars);
	}

	/** Compares this string with another one. */
	template <typename CharPointer>
	int compare (const CharPointer& other) const noexcept
	{
		return CharacterFunctions::compare (*this, other);
	}

   #if JUCE_NATIVE_WCHAR_IS_UTF32 && ! JUCE_ANDROID
	/** Compares this string with another one. */
	int compare (const CharPointer_UTF32& other) const noexcept
	{
		return wcscmp (data, other.data);
	}
   #endif

	/** Compares this string with another one, up to a specified number of characters. */
	template <typename CharPointer>
	int compareUpTo (const CharPointer& other, const int maxChars) const noexcept
	{
		return CharacterFunctions::compareUpTo (*this, other, maxChars);
	}

	/** Compares this string with another one. */
	template <typename CharPointer>
	int compareIgnoreCase (const CharPointer& other) const
	{
		return CharacterFunctions::compareIgnoreCase (*this, other);
	}

	/** Compares this string with another one, up to a specified number of characters. */
	template <typename CharPointer>
	int compareIgnoreCaseUpTo (const CharPointer& other, const int maxChars) const noexcept
	{
		return CharacterFunctions::compareIgnoreCaseUpTo (*this, other, maxChars);
	}

	/** Returns the character index of a substring, or -1 if it isn't found. */
	template <typename CharPointer>
	int indexOf (const CharPointer& stringToFind) const noexcept
	{
		return CharacterFunctions::indexOf (*this, stringToFind);
	}

	/** Returns the character index of a unicode character, or -1 if it isn't found. */
	int indexOf (const juce_wchar charToFind) const noexcept
	{
		int i = 0;

		while (data[i] != 0)
		{
			if (data[i] == charToFind)
				return i;

			++i;
		}

		return -1;
	}

	/** Returns the character index of a unicode character, or -1 if it isn't found. */
	int indexOf (const juce_wchar charToFind, const bool ignoreCase) const noexcept
	{
		return ignoreCase ? CharacterFunctions::indexOfCharIgnoreCase (*this, charToFind)
						  : CharacterFunctions::indexOfChar (*this, charToFind);
	}

	/** Returns true if the first character of this string is whitespace. */
	bool isWhitespace() const               { return CharacterFunctions::isWhitespace (*data) != 0; }
	/** Returns true if the first character of this string is a digit. */
	bool isDigit() const                    { return CharacterFunctions::isDigit (*data) != 0; }
	/** Returns true if the first character of this string is a letter. */
	bool isLetter() const                   { return CharacterFunctions::isLetter (*data) != 0; }
	/** Returns true if the first character of this string is a letter or digit. */
	bool isLetterOrDigit() const            { return CharacterFunctions::isLetterOrDigit (*data) != 0; }
	/** Returns true if the first character of this string is upper-case. */
	bool isUpperCase() const                { return CharacterFunctions::isUpperCase (*data) != 0; }
	/** Returns true if the first character of this string is lower-case. */
	bool isLowerCase() const                { return CharacterFunctions::isLowerCase (*data) != 0; }

	/** Returns an upper-case version of the first character of this string. */
	juce_wchar toUpperCase() const noexcept { return CharacterFunctions::toUpperCase (*data); }
	/** Returns a lower-case version of the first character of this string. */
	juce_wchar toLowerCase() const noexcept { return CharacterFunctions::toLowerCase (*data); }

	/** Parses this string as a 32-bit integer. */
	int getIntValue32() const noexcept      { return CharacterFunctions::getIntValue <int, CharPointer_UTF32> (*this); }
	/** Parses this string as a 64-bit integer. */
	int64 getIntValue64() const noexcept    { return CharacterFunctions::getIntValue <int64, CharPointer_UTF32> (*this); }

	/** Parses this string as a floating point double. */
	double getDoubleValue() const noexcept  { return CharacterFunctions::getDoubleValue (*this); }

	/** Returns the first non-whitespace character in the string. */
	CharPointer_UTF32 findEndOfWhitespace() const noexcept   { return CharacterFunctions::findEndOfWhitespace (*this); }

	/** Returns true if the given unicode character can be represented in this encoding. */
	static bool canRepresent (juce_wchar character) noexcept
	{
		return ((unsigned int) character) < (unsigned int) 0x10ffff;
	}

	/** Returns true if this data contains a valid string in this encoding. */
	static bool isValidString (const CharType* dataToTest, int maxBytesToRead)
	{
		maxBytesToRead /= sizeof (CharType);

		while (--maxBytesToRead >= 0 && *dataToTest != 0)
			if (! canRepresent (*dataToTest++))
				return false;

		return true;
	}

	/** Atomically swaps this pointer for a new value, returning the previous value. */
	CharPointer_UTF32 atomicSwap (const CharPointer_UTF32& newValue)
	{
		return CharPointer_UTF32 (reinterpret_cast <Atomic<CharType*>&> (data).exchange (newValue.data));
	}

private:
	CharType* data;
};

#endif   // __JUCE_CHARPOINTER_UTF32_JUCEHEADER__

/*** End of inlined file: juce_CharPointer_UTF32.h ***/


/*** Start of inlined file: juce_CharPointer_ASCII.h ***/
#ifndef __JUCE_CHARPOINTER_ASCII_JUCEHEADER__
#define __JUCE_CHARPOINTER_ASCII_JUCEHEADER__

/**
	Wraps a pointer to a null-terminated ASCII character string, and provides
	various methods to operate on the data.

	A valid ASCII string is assumed to not contain any characters above 127.

	@see CharPointer_UTF8, CharPointer_UTF16, CharPointer_UTF32
*/
class CharPointer_ASCII
{
public:
	typedef char CharType;

	inline explicit CharPointer_ASCII (const CharType* const rawPointer) noexcept
		: data (const_cast <CharType*> (rawPointer))
	{
	}

	inline CharPointer_ASCII (const CharPointer_ASCII& other) noexcept
		: data (other.data)
	{
	}

	inline CharPointer_ASCII& operator= (const CharPointer_ASCII& other) noexcept
	{
		data = other.data;
		return *this;
	}

	inline CharPointer_ASCII& operator= (const CharType* text) noexcept
	{
		data = const_cast <CharType*> (text);
		return *this;
	}

	/** This is a pointer comparison, it doesn't compare the actual text. */
	inline bool operator== (const CharPointer_ASCII& other) const noexcept { return data == other.data; }
	inline bool operator!= (const CharPointer_ASCII& other) const noexcept { return data != other.data; }
	inline bool operator<= (const CharPointer_ASCII& other) const noexcept { return data <= other.data; }
	inline bool operator<  (const CharPointer_ASCII& other) const noexcept { return data <  other.data; }
	inline bool operator>= (const CharPointer_ASCII& other) const noexcept { return data >= other.data; }
	inline bool operator>  (const CharPointer_ASCII& other) const noexcept { return data >  other.data; }

	/** Returns the address that this pointer is pointing to. */
	inline CharType* getAddress() const noexcept        { return data; }

	/** Returns the address that this pointer is pointing to. */
	inline operator const CharType*() const noexcept    { return data; }

	/** Returns true if this pointer is pointing to a null character. */
	inline bool isEmpty() const noexcept                { return *data == 0; }

	/** Returns the unicode character that this pointer is pointing to. */
	inline juce_wchar operator*() const noexcept        { return (juce_wchar) (uint8) *data; }

	/** Moves this pointer along to the next character in the string. */
	inline CharPointer_ASCII& operator++() noexcept
	{
		++data;
		return *this;
	}

	/** Moves this pointer to the previous character in the string. */
	inline CharPointer_ASCII& operator--() noexcept
	{
		--data;
		return *this;
	}

	/** Returns the character that this pointer is currently pointing to, and then
		advances the pointer to point to the next character. */
	inline juce_wchar getAndAdvance() noexcept  { return (juce_wchar) (uint8) *data++; }

	/** Moves this pointer along to the next character in the string. */
	CharPointer_ASCII operator++ (int) noexcept
	{
		CharPointer_ASCII temp (*this);
		++data;
		return temp;
	}

	/** Moves this pointer forwards by the specified number of characters. */
	inline void operator+= (const int numToSkip) noexcept
	{
		data += numToSkip;
	}

	inline void operator-= (const int numToSkip) noexcept
	{
		data -= numToSkip;
	}

	/** Returns the character at a given character index from the start of the string. */
	inline juce_wchar operator[] (const int characterIndex) const noexcept
	{
		return (juce_wchar) (unsigned char) data [characterIndex];
	}

	/** Returns a pointer which is moved forwards from this one by the specified number of characters. */
	CharPointer_ASCII operator+ (const int numToSkip) const noexcept
	{
		return CharPointer_ASCII (data + numToSkip);
	}

	/** Returns a pointer which is moved backwards from this one by the specified number of characters. */
	CharPointer_ASCII operator- (const int numToSkip) const noexcept
	{
		return CharPointer_ASCII (data - numToSkip);
	}

	/** Writes a unicode character to this string, and advances this pointer to point to the next position. */
	inline void write (const juce_wchar charToWrite) noexcept
	{
		*data++ = (char) charToWrite;
	}

	inline void replaceChar (const juce_wchar newChar) noexcept
	{
		*data = (char) newChar;
	}

	/** Writes a null character to this string (leaving the pointer's position unchanged). */
	inline void writeNull() const noexcept
	{
		*data = 0;
	}

	/** Returns the number of characters in this string. */
	size_t length() const noexcept
	{
		return (size_t) strlen (data);
	}

	/** Returns the number of characters in this string, or the given value, whichever is lower. */
	size_t lengthUpTo (const size_t maxCharsToCount) const noexcept
	{
		return CharacterFunctions::lengthUpTo (*this, maxCharsToCount);
	}

	/** Returns the number of characters in this string, or up to the given end pointer, whichever is lower. */
	size_t lengthUpTo (const CharPointer_ASCII& end) const noexcept
	{
		return CharacterFunctions::lengthUpTo (*this, end);
	}

	/** Returns the number of bytes that are used to represent this string.
		This includes the terminating null character.
	*/
	size_t sizeInBytes() const noexcept
	{
		return length() + 1;
	}

	/** Returns the number of bytes that would be needed to represent the given
		unicode character in this encoding format.
	*/
	static inline size_t getBytesRequiredFor (const juce_wchar) noexcept
	{
		return 1;
	}

	/** Returns the number of bytes that would be needed to represent the given
		string in this encoding format.
		The value returned does NOT include the terminating null character.
	*/
	template <class CharPointer>
	static size_t getBytesRequiredFor (const CharPointer& text) noexcept
	{
		return text.length();
	}

	/** Returns a pointer to the null character that terminates this string. */
	CharPointer_ASCII findTerminatingNull() const noexcept
	{
		return CharPointer_ASCII (data + length());
	}

	/** Copies a source string to this pointer, advancing this pointer as it goes. */
	template <typename CharPointer>
	void writeAll (const CharPointer& src) noexcept
	{
		CharacterFunctions::copyAll (*this, src);
	}

	/** Copies a source string to this pointer, advancing this pointer as it goes. */
	void writeAll (const CharPointer_ASCII& src) noexcept
	{
		strcpy (data, src.data);
	}

	/** Copies a source string to this pointer, advancing this pointer as it goes.
		The maxDestBytes parameter specifies the maximum number of bytes that can be written
		to the destination buffer before stopping.
	*/
	template <typename CharPointer>
	int writeWithDestByteLimit (const CharPointer& src, const int maxDestBytes) noexcept
	{
		return CharacterFunctions::copyWithDestByteLimit (*this, src, maxDestBytes);
	}

	/** Copies a source string to this pointer, advancing this pointer as it goes.
		The maxChars parameter specifies the maximum number of characters that can be
		written to the destination buffer before stopping (including the terminating null).
	*/
	template <typename CharPointer>
	void writeWithCharLimit (const CharPointer& src, const int maxChars) noexcept
	{
		CharacterFunctions::copyWithCharLimit (*this, src, maxChars);
	}

	/** Compares this string with another one. */
	template <typename CharPointer>
	int compare (const CharPointer& other) const noexcept
	{
		return CharacterFunctions::compare (*this, other);
	}

	/** Compares this string with another one. */
	int compare (const CharPointer_ASCII& other) const noexcept
	{
		return strcmp (data, other.data);
	}

	/** Compares this string with another one, up to a specified number of characters. */
	template <typename CharPointer>
	int compareUpTo (const CharPointer& other, const int maxChars) const noexcept
	{
		return CharacterFunctions::compareUpTo (*this, other, maxChars);
	}

	/** Compares this string with another one, up to a specified number of characters. */
	int compareUpTo (const CharPointer_ASCII& other, const int maxChars) const noexcept
	{
		return strncmp (data, other.data, (size_t) maxChars);
	}

	/** Compares this string with another one. */
	template <typename CharPointer>
	int compareIgnoreCase (const CharPointer& other) const
	{
		return CharacterFunctions::compareIgnoreCase (*this, other);
	}

	int compareIgnoreCase (const CharPointer_ASCII& other) const
	{
	   #if JUCE_WINDOWS
		return stricmp (data, other.data);
	   #else
		return strcasecmp (data, other.data);
	   #endif
	}

	/** Compares this string with another one, up to a specified number of characters. */
	template <typename CharPointer>
	int compareIgnoreCaseUpTo (const CharPointer& other, const int maxChars) const noexcept
	{
		return CharacterFunctions::compareIgnoreCaseUpTo (*this, other, maxChars);
	}

	/** Returns the character index of a substring, or -1 if it isn't found. */
	template <typename CharPointer>
	int indexOf (const CharPointer& stringToFind) const noexcept
	{
		return CharacterFunctions::indexOf (*this, stringToFind);
	}

	/** Returns the character index of a unicode character, or -1 if it isn't found. */
	int indexOf (const juce_wchar charToFind) const noexcept
	{
		int i = 0;

		while (data[i] != 0)
		{
			if (data[i] == (char) charToFind)
				return i;

			++i;
		}

		return -1;
	}

	/** Returns the character index of a unicode character, or -1 if it isn't found. */
	int indexOf (const juce_wchar charToFind, const bool ignoreCase) const noexcept
	{
		return ignoreCase ? CharacterFunctions::indexOfCharIgnoreCase (*this, charToFind)
						  : CharacterFunctions::indexOfChar (*this, charToFind);
	}

	/** Returns true if the first character of this string is whitespace. */
	bool isWhitespace() const               { return CharacterFunctions::isWhitespace (*data) != 0; }
	/** Returns true if the first character of this string is a digit. */
	bool isDigit() const                    { return CharacterFunctions::isDigit (*data) != 0; }
	/** Returns true if the first character of this string is a letter. */
	bool isLetter() const                   { return CharacterFunctions::isLetter (*data) != 0; }
	/** Returns true if the first character of this string is a letter or digit. */
	bool isLetterOrDigit() const            { return CharacterFunctions::isLetterOrDigit (*data) != 0; }
	/** Returns true if the first character of this string is upper-case. */
	bool isUpperCase() const                { return CharacterFunctions::isUpperCase ((juce_wchar) (uint8) *data) != 0; }
	/** Returns true if the first character of this string is lower-case. */
	bool isLowerCase() const                { return CharacterFunctions::isLowerCase ((juce_wchar) (uint8) *data) != 0; }

	/** Returns an upper-case version of the first character of this string. */
	juce_wchar toUpperCase() const noexcept { return CharacterFunctions::toUpperCase ((juce_wchar) (uint8) *data); }
	/** Returns a lower-case version of the first character of this string. */
	juce_wchar toLowerCase() const noexcept { return CharacterFunctions::toLowerCase ((juce_wchar) (uint8) *data); }

	/** Parses this string as a 32-bit integer. */
	int getIntValue32() const noexcept      { return atoi (data); }

	/** Parses this string as a 64-bit integer. */
	int64 getIntValue64() const noexcept
	{
	   #if JUCE_LINUX || JUCE_ANDROID
		return atoll (data);
	   #elif JUCE_WINDOWS
		return _atoi64 (data);
	   #else
		return CharacterFunctions::getIntValue <int64, CharPointer_ASCII> (*this);
	   #endif
	}

	/** Parses this string as a floating point double. */
	double getDoubleValue() const noexcept  { return CharacterFunctions::getDoubleValue (*this); }

	/** Returns the first non-whitespace character in the string. */
	CharPointer_ASCII findEndOfWhitespace() const noexcept   { return CharacterFunctions::findEndOfWhitespace (*this); }

	/** Returns true if the given unicode character can be represented in this encoding. */
	static bool canRepresent (juce_wchar character) noexcept
	{
		return ((unsigned int) character) < (unsigned int) 128;
	}

	/** Returns true if this data contains a valid string in this encoding. */
	static bool isValidString (const CharType* dataToTest, int maxBytesToRead)
	{
		while (--maxBytesToRead >= 0)
		{
			if (((signed char) *dataToTest) <= 0)
				return *dataToTest == 0;

			++dataToTest;
		}

		return true;
	}

private:
	CharType* data;
};

#endif   // __JUCE_CHARPOINTER_ASCII_JUCEHEADER__

/*** End of inlined file: juce_CharPointer_ASCII.h ***/

#if JUCE_MSVC
 #pragma warning (pop)
#endif

class OutputStream;

/**
	The JUCE String class!

	Using a reference-counted internal representation, these strings are fast
	and efficient, and there are methods to do just about any operation you'll ever
	dream of.

	@see StringArray, StringPairArray
*/
class JUCE_API  String
{
public:

	/** Creates an empty string.
		@see empty
	*/
	String() noexcept;

	/** Creates a copy of another string. */
	String (const String& other) noexcept;

   #if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
	String (String&& other) noexcept;
   #endif

	/** Creates a string from a zero-terminated ascii text string.

		The string passed-in must not contain any characters with a value above 127, because
		these can't be converted to unicode without knowing the original encoding that was
		used to create the string. If you attempt to pass-in values above 127, you'll get an
		assertion.

		To create strings with extended characters from UTF-8, you should explicitly call
		String (CharPointer_UTF8 ("my utf8 string..")). It's *highly* recommended that you
		use UTF-8 with escape characters in your source code to represent extended characters,
		because there's no other way to represent unicode strings in a way that isn't dependent
		on the compiler, source code editor and platform.
	*/
	String (const char* text);

	/** Creates a string from a string of 8-bit ascii characters.

		The string passed-in must not contain any characters with a value above 127, because
		these can't be converted to unicode without knowing the original encoding that was
		used to create the string. If you attempt to pass-in values above 127, you'll get an
		assertion.

		To create strings with extended characters from UTF-8, you should explicitly call
		String (CharPointer_UTF8 ("my utf8 string..")). It's *highly* recommended that you
		use UTF-8 with escape characters in your source code to represent extended characters,
		because there's no other way to represent unicode strings in a way that isn't dependent
		on the compiler, source code editor and platform.

		This will use up the the first maxChars characters of the string (or less if the string
		is actually shorter).
	*/
	String (const char* text, size_t maxChars);

	/** Creates a string from a whcar_t character string.
		Depending on the platform, this may be treated as either UTF-32 or UTF-16.
	*/
	String (const wchar_t* text);

	/** Creates a string from a whcar_t character string.
		Depending on the platform, this may be treated as either UTF-32 or UTF-16.
	*/
	String (const wchar_t* text, size_t maxChars);

	/** Creates a string from a UTF-8 character string */
	String (const CharPointer_UTF8& text);

	/** Creates a string from a UTF-8 character string */
	String (const CharPointer_UTF8& text, size_t maxChars);

	/** Creates a string from a UTF-8 character string */
	String (const CharPointer_UTF8& start, const CharPointer_UTF8& end);

	/** Creates a string from a UTF-16 character string */
	String (const CharPointer_UTF16& text);

	/** Creates a string from a UTF-16 character string */
	String (const CharPointer_UTF16& text, size_t maxChars);

	/** Creates a string from a UTF-16 character string */
	String (const CharPointer_UTF16& start, const CharPointer_UTF16& end);

	/** Creates a string from a UTF-32 character string */
	String (const CharPointer_UTF32& text);

	/** Creates a string from a UTF-32 character string */
	String (const CharPointer_UTF32& text, size_t maxChars);

	/** Creates a string from a UTF-32 character string */
	String (const CharPointer_UTF32& start, const CharPointer_UTF32& end);

	/** Creates a string from an ASCII character string */
	String (const CharPointer_ASCII& text);

	/** Creates a string from a single character. */
	static String charToString (juce_wchar character);

	/** Destructor. */
	~String() noexcept;

	/** This is an empty string that can be used whenever one is needed.

		It's better to use this than String() because it explains what's going on
		and is more efficient.
	*/
	static const String empty;

	/** This is the character encoding type used internally to store the string.

		By setting the value of JUCE_STRING_UTF_TYPE to 8, 16, or 32, you can change the
		internal storage format of the String class. UTF-8 uses the least space (if your strings
		contain few extended characters), but call operator[] involves iterating the string to find
		the required index. UTF-32 provides instant random access to its characters, but uses 4 bytes
		per character to store them. UTF-16 uses more space than UTF-8 and is also slow to index,
		but is the native wchar_t format used in Windows.

		It doesn't matter too much which format you pick, because the toUTF8(), toUTF16() and
		toUTF32() methods let you access the string's content in any of the other formats.
	*/
   #if (JUCE_STRING_UTF_TYPE == 32)
	typedef CharPointer_UTF32 CharPointerType;
   #elif (JUCE_STRING_UTF_TYPE == 16)
	typedef CharPointer_UTF16 CharPointerType;
   #elif (JUCE_STRING_UTF_TYPE == 8)
	typedef CharPointer_UTF8  CharPointerType;
   #else
	#error "You must set the value of JUCE_STRING_UTF_TYPE to be either 8, 16, or 32!"
   #endif

	/** Generates a probably-unique 32-bit hashcode from this string. */
	int hashCode() const noexcept;

	/** Generates a probably-unique 64-bit hashcode from this string. */
	int64 hashCode64() const noexcept;

	/** Returns the number of characters in the string. */
	int length() const noexcept;

	// Assignment and concatenation operators..

	/** Replaces this string's contents with another string. */
	String& operator= (const String& other) noexcept;

   #if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
	String& operator= (String&& other) noexcept;
   #endif

	/** Appends another string at the end of this one. */
	String& operator+= (const String& stringToAppend);
	/** Appends another string at the end of this one. */
	String& operator+= (const char* textToAppend);
	/** Appends another string at the end of this one. */
	String& operator+= (const wchar_t* textToAppend);
	/** Appends a decimal number at the end of this string. */
	String& operator+= (int numberToAppend);
	/** Appends a character at the end of this string. */
	String& operator+= (char characterToAppend);
	/** Appends a character at the end of this string. */
	String& operator+= (wchar_t characterToAppend);
   #if ! JUCE_NATIVE_WCHAR_IS_UTF32
	/** Appends a character at the end of this string. */
	String& operator+= (juce_wchar characterToAppend);
   #endif

	/** Appends a string to the end of this one.

		@param textToAppend     the string to add
		@param maxCharsToTake   the maximum number of characters to take from the string passed in
	*/
	void append (const String& textToAppend, size_t maxCharsToTake);

	/** Appends a string to the end of this one.

		@param textToAppend     the string to add
		@param maxCharsToTake   the maximum number of characters to take from the string passed in
	*/
	template <class CharPointer>
	void appendCharPointer (const CharPointer& textToAppend, size_t maxCharsToTake)
	{
		if (textToAppend.getAddress() != nullptr)
		{
			size_t extraBytesNeeded = 0;
			size_t numChars = 0;

			for (CharPointer t (textToAppend); numChars < maxCharsToTake && ! t.isEmpty();)
			{
				extraBytesNeeded += CharPointerType::getBytesRequiredFor (t.getAndAdvance());
				++numChars;
			}

			if (numChars > 0)
			{
				const size_t byteOffsetOfNull = getByteOffsetOfEnd();

				preallocateBytes (byteOffsetOfNull + extraBytesNeeded);
				CharPointerType (addBytesToPointer (text.getAddress(), (int) byteOffsetOfNull)).writeWithCharLimit (textToAppend, (int) (numChars + 1));
			}
		}
	}

	/** Appends a string to the end of this one. */
	template <class CharPointer>
	void appendCharPointer (const CharPointer& textToAppend)
	{
		if (textToAppend.getAddress() != nullptr)
		{
			size_t extraBytesNeeded = 0;

			for (CharPointer t (textToAppend); ! t.isEmpty();)
				extraBytesNeeded += CharPointerType::getBytesRequiredFor (t.getAndAdvance());

			if (extraBytesNeeded > 0)
			{
				const size_t byteOffsetOfNull = getByteOffsetOfEnd();

				preallocateBytes (byteOffsetOfNull + extraBytesNeeded);
				CharPointerType (addBytesToPointer (text.getAddress(), (int) byteOffsetOfNull)).writeAll (textToAppend);
			}
		}
	}

	// Comparison methods..

	/** Returns true if the string contains no characters.
		Note that there's also an isNotEmpty() method to help write readable code.
		@see containsNonWhitespaceChars()
	*/
	inline bool isEmpty() const noexcept                    { return text[0] == 0; }

	/** Returns true if the string contains at least one character.
		Note that there's also an isEmpty() method to help write readable code.
		@see containsNonWhitespaceChars()
	*/
	inline bool isNotEmpty() const noexcept                 { return text[0] != 0; }

	/** Case-insensitive comparison with another string. */
	bool equalsIgnoreCase (const String& other) const noexcept;

	/** Case-insensitive comparison with another string. */
	bool equalsIgnoreCase (const wchar_t* other) const noexcept;

	/** Case-insensitive comparison with another string. */
	bool equalsIgnoreCase (const char* other) const noexcept;

	/** Case-sensitive comparison with another string.
		@returns     0 if the two strings are identical; negative if this string comes before
					 the other one alphabetically, or positive if it comes after it.
	*/
	int compare (const String& other) const noexcept;

	/** Case-sensitive comparison with another string.
		@returns     0 if the two strings are identical; negative if this string comes before
					 the other one alphabetically, or positive if it comes after it.
	*/
	int compare (const char* other) const noexcept;

	/** Case-sensitive comparison with another string.
		@returns     0 if the two strings are identical; negative if this string comes before
					 the other one alphabetically, or positive if it comes after it.
	*/
	int compare (const wchar_t* other) const noexcept;

	/** Case-insensitive comparison with another string.
		@returns     0 if the two strings are identical; negative if this string comes before
					 the other one alphabetically, or positive if it comes after it.
	*/
	int compareIgnoreCase (const String& other) const noexcept;

	/** Lexicographic comparison with another string.

		The comparison used here is case-insensitive and ignores leading non-alphanumeric
		characters, making it good for sorting human-readable strings.

		@returns     0 if the two strings are identical; negative if this string comes before
					 the other one alphabetically, or positive if it comes after it.
	*/
	int compareLexicographically (const String& other) const noexcept;

	/** Tests whether the string begins with another string.
		If the parameter is an empty string, this will always return true.
		Uses a case-sensitive comparison.
	*/
	bool startsWith (const String& text) const noexcept;

	/** Tests whether the string begins with a particular character.
		If the character is 0, this will always return false.
		Uses a case-sensitive comparison.
	*/
	bool startsWithChar (juce_wchar character) const noexcept;

	/** Tests whether the string begins with another string.
		If the parameter is an empty string, this will always return true.
		Uses a case-insensitive comparison.
	*/
	bool startsWithIgnoreCase (const String& text) const noexcept;

	/** Tests whether the string ends with another string.
		If the parameter is an empty string, this will always return true.
		Uses a case-sensitive comparison.
	*/
	bool endsWith (const String& text) const noexcept;

	/** Tests whether the string ends with a particular character.
		If the character is 0, this will always return false.
		Uses a case-sensitive comparison.
	*/
	bool endsWithChar (juce_wchar character) const noexcept;

	/** Tests whether the string ends with another string.
		If the parameter is an empty string, this will always return true.
		Uses a case-insensitive comparison.
	*/
	bool endsWithIgnoreCase (const String& text) const noexcept;

	/** Tests whether the string contains another substring.
		If the parameter is an empty string, this will always return true.
		Uses a case-sensitive comparison.
	*/
	bool contains (const String& text) const noexcept;

	/** Tests whether the string contains a particular character.
		Uses a case-sensitive comparison.
	*/
	bool containsChar (juce_wchar character) const noexcept;

	/** Tests whether the string contains another substring.
		Uses a case-insensitive comparison.
	*/
	bool containsIgnoreCase (const String& text) const noexcept;

	/** Tests whether the string contains another substring as a distict word.

		@returns    true if the string contains this word, surrounded by
					non-alphanumeric characters
		@see indexOfWholeWord, containsWholeWordIgnoreCase
	*/
	bool containsWholeWord (const String& wordToLookFor) const noexcept;

	/** Tests whether the string contains another substring as a distict word.

		@returns    true if the string contains this word, surrounded by
					non-alphanumeric characters
		@see indexOfWholeWordIgnoreCase, containsWholeWord
	*/
	bool containsWholeWordIgnoreCase (const String& wordToLookFor) const noexcept;

	/** Finds an instance of another substring if it exists as a distict word.

		@returns    if the string contains this word, surrounded by non-alphanumeric characters,
					then this will return the index of the start of the substring. If it isn't
					found, then it will return -1
		@see indexOfWholeWordIgnoreCase, containsWholeWord
	*/
	int indexOfWholeWord (const String& wordToLookFor) const noexcept;

	/** Finds an instance of another substring if it exists as a distict word.

		@returns    if the string contains this word, surrounded by non-alphanumeric characters,
					then this will return the index of the start of the substring. If it isn't
					found, then it will return -1
		@see indexOfWholeWord, containsWholeWordIgnoreCase
	*/
	int indexOfWholeWordIgnoreCase (const String& wordToLookFor) const noexcept;

	/** Looks for any of a set of characters in the string.
		Uses a case-sensitive comparison.

		@returns    true if the string contains any of the characters from
					the string that is passed in.
	*/
	bool containsAnyOf (const String& charactersItMightContain) const noexcept;

	/** Looks for a set of characters in the string.
		Uses a case-sensitive comparison.

		@returns    Returns false if any of the characters in this string do not occur in
					the parameter string. If this string is empty, the return value will
					always be true.
	*/
	bool containsOnly (const String& charactersItMightContain) const noexcept;

	/** Returns true if this string contains any non-whitespace characters.

		This will return false if the string contains only whitespace characters, or
		if it's empty.

		It is equivalent to calling "myString.trim().isNotEmpty()".
	*/
	bool containsNonWhitespaceChars() const noexcept;

	/** Returns true if the string matches this simple wildcard expression.

		So for example String ("abcdef").matchesWildcard ("*DEF", true) would return true.

		This isn't a full-blown regex though! The only wildcard characters supported
		are "*" and "?". It's mainly intended for filename pattern matching.
	*/
	bool matchesWildcard (const String& wildcard, bool ignoreCase) const noexcept;

	// Substring location methods..

	/** Searches for a character inside this string.
		Uses a case-sensitive comparison.
		@returns    the index of the first occurrence of the character in this
					string, or -1 if it's not found.
	*/
	int indexOfChar (juce_wchar characterToLookFor) const noexcept;

	/** Searches for a character inside this string.
		Uses a case-sensitive comparison.
		@param startIndex           the index from which the search should proceed
		@param characterToLookFor   the character to look for
		@returns            the index of the first occurrence of the character in this
							string, or -1 if it's not found.
	*/
	int indexOfChar (int startIndex, juce_wchar characterToLookFor) const noexcept;

	/** Returns the index of the first character that matches one of the characters
		passed-in to this method.

		This scans the string, beginning from the startIndex supplied, and if it finds
		a character that appears in the string charactersToLookFor, it returns its index.

		If none of these characters are found, it returns -1.

		If ignoreCase is true, the comparison will be case-insensitive.

		@see indexOfChar, lastIndexOfAnyOf
	*/
	int indexOfAnyOf (const String& charactersToLookFor,
					  int startIndex = 0,
					  bool ignoreCase = false) const noexcept;

	/** Searches for a substring within this string.
		Uses a case-sensitive comparison.
		@returns    the index of the first occurrence of this substring, or -1 if it's not found.
					If textToLookFor is an empty string, this will always return 0.
	*/
	int indexOf (const String& textToLookFor) const noexcept;

	/** Searches for a substring within this string.
		Uses a case-sensitive comparison.
		@param startIndex       the index from which the search should proceed
		@param textToLookFor    the string to search for
		@returns                the index of the first occurrence of this substring, or -1 if it's not found.
								If textToLookFor is an empty string, this will always return -1.
	*/
	int indexOf (int startIndex, const String& textToLookFor) const noexcept;

	/** Searches for a substring within this string.
		Uses a case-insensitive comparison.
		@returns    the index of the first occurrence of this substring, or -1 if it's not found.
					If textToLookFor is an empty string, this will always return 0.
	*/
	int indexOfIgnoreCase (const String& textToLookFor) const noexcept;

	/** Searches for a substring within this string.
		Uses a case-insensitive comparison.
		@param startIndex       the index from which the search should proceed
		@param textToLookFor    the string to search for
		@returns                the index of the first occurrence of this substring, or -1 if it's not found.
								If textToLookFor is an empty string, this will always return -1.
	*/
	int indexOfIgnoreCase (int startIndex, const String& textToLookFor) const noexcept;

	/** Searches for a character inside this string (working backwards from the end of the string).
		Uses a case-sensitive comparison.
		@returns    the index of the last occurrence of the character in this string, or -1 if it's not found.
	*/
	int lastIndexOfChar (juce_wchar character) const noexcept;

	/** Searches for a substring inside this string (working backwards from the end of the string).
		Uses a case-sensitive comparison.
		@returns    the index of the start of the last occurrence of the substring within this string,
					or -1 if it's not found. If textToLookFor is an empty string, this will always return -1.
	*/
	int lastIndexOf (const String& textToLookFor) const noexcept;

	/** Searches for a substring inside this string (working backwards from the end of the string).
		Uses a case-insensitive comparison.
		@returns    the index of the start of the last occurrence of the substring within this string, or -1
					if it's not found. If textToLookFor is an empty string, this will always return -1.
	*/
	int lastIndexOfIgnoreCase (const String& textToLookFor) const noexcept;

	/** Returns the index of the last character in this string that matches one of the
		characters passed-in to this method.

		This scans the string backwards, starting from its end, and if it finds
		a character that appears in the string charactersToLookFor, it returns its index.

		If none of these characters are found, it returns -1.

		If ignoreCase is true, the comparison will be case-insensitive.

		@see lastIndexOf, indexOfAnyOf
	*/
	int lastIndexOfAnyOf (const String& charactersToLookFor,
						  bool ignoreCase = false) const noexcept;

	// Substring extraction and manipulation methods..

	/** Returns the character at this index in the string.
		In a release build, no checks are made to see if the index is within a valid range, so be
		careful! In a debug build, the index is checked and an assertion fires if it's out-of-range.

		Also beware that depending on the encoding format that the string is using internally, this
		method may execute in either O(1) or O(n) time, so be careful when using it in your algorithms.
		If you're scanning through a string to inspect its characters, you should never use this operator
		for random access, it's far more efficient to call getCharPointer() to return a pointer, and
		then to use that to iterate the string.
		@see getCharPointer
	*/
	const juce_wchar operator[] (int index) const noexcept;

	/** Returns the final character of the string.
		If the string is empty this will return 0.
	*/
	juce_wchar getLastCharacter() const noexcept;

	/** Returns a subsection of the string.

		If the range specified is beyond the limits of the string, as much as
		possible is returned.

		@param startIndex   the index of the start of the substring needed
		@param endIndex     all characters from startIndex up to (but not including)
							this index are returned
		@see fromFirstOccurrenceOf, dropLastCharacters, getLastCharacters, upToFirstOccurrenceOf
	*/
	String substring (int startIndex, int endIndex) const;

	/** Returns a section of the string, starting from a given position.

		@param startIndex   the first character to include. If this is beyond the end
							of the string, an empty string is returned. If it is zero or
							less, the whole string is returned.
		@returns            the substring from startIndex up to the end of the string
		@see dropLastCharacters, getLastCharacters, fromFirstOccurrenceOf, upToFirstOccurrenceOf, fromLastOccurrenceOf
	*/
	String substring (int startIndex) const;

	/** Returns a version of this string with a number of characters removed
		from the end.

		@param numberToDrop     the number of characters to drop from the end of the
								string. If this is greater than the length of the string,
								an empty string will be returned. If zero or less, the
								original string will be returned.
		@see substring, fromFirstOccurrenceOf, upToFirstOccurrenceOf, fromLastOccurrenceOf, getLastCharacter
	*/
	String dropLastCharacters (int numberToDrop) const;

	/** Returns a number of characters from the end of the string.

		This returns the last numCharacters characters from the end of the string. If the
		string is shorter than numCharacters, the whole string is returned.

		@see substring, dropLastCharacters, getLastCharacter
	*/
	String getLastCharacters (int numCharacters) const;

	/** Returns a section of the string starting from a given substring.

		This will search for the first occurrence of the given substring, and
		return the section of the string starting from the point where this is
		found (optionally not including the substring itself).

		e.g. for the string "123456", fromFirstOccurrenceOf ("34", true) would return "3456", and
									  fromFirstOccurrenceOf ("34", false) would return "56".

		If the substring isn't found, the method will return an empty string.

		If ignoreCase is true, the comparison will be case-insensitive.

		@see upToFirstOccurrenceOf, fromLastOccurrenceOf
	*/
	String fromFirstOccurrenceOf (const String& substringToStartFrom,
								  bool includeSubStringInResult,
										bool ignoreCase) const;

	/** Returns a section of the string starting from the last occurrence of a given substring.

		Similar to fromFirstOccurrenceOf(), but using the last occurrence of the substring, and
		unlike fromFirstOccurrenceOf(), if the substring isn't found, this method will
		return the whole of the original string.

		@see fromFirstOccurrenceOf, upToLastOccurrenceOf
	*/
	String fromLastOccurrenceOf (const String& substringToFind,
								 bool includeSubStringInResult,
								 bool ignoreCase) const;

	/** Returns the start of this string, up to the first occurrence of a substring.

		This will search for the first occurrence of a given substring, and then
		return a copy of the string, up to the position of this substring,
		optionally including or excluding the substring itself in the result.

		e.g. for the string "123456", upTo ("34", false) would return "12", and
									  upTo ("34", true) would return "1234".

		If the substring isn't found, this will return the whole of the original string.

		@see upToLastOccurrenceOf, fromFirstOccurrenceOf
	*/
	String upToFirstOccurrenceOf (const String& substringToEndWith,
								  bool includeSubStringInResult,
								  bool ignoreCase) const;

	/** Returns the start of this string, up to the last occurrence of a substring.

		Similar to upToFirstOccurrenceOf(), but this finds the last occurrence rather than the first.
		If the substring isn't found, this will return the whole of the original string.

		@see upToFirstOccurrenceOf, fromFirstOccurrenceOf
	*/
	String upToLastOccurrenceOf (const String& substringToFind,
								 bool includeSubStringInResult,
								 bool ignoreCase) const;

	/** Returns a copy of this string with any whitespace characters removed from the start and end. */
	String trim() const;

	/** Returns a copy of this string with any whitespace characters removed from the start. */
	String trimStart() const;

	/** Returns a copy of this string with any whitespace characters removed from the end. */
	String trimEnd() const;

	/** Returns a copy of this string, having removed a specified set of characters from its start.
		Characters are removed from the start of the string until it finds one that is not in the
		specified set, and then it stops.
		@param charactersToTrim     the set of characters to remove.
		@see trim, trimStart, trimCharactersAtEnd
	*/
	String trimCharactersAtStart (const String& charactersToTrim) const;

	/** Returns a copy of this string, having removed a specified set of characters from its end.
		Characters are removed from the end of the string until it finds one that is not in the
		specified set, and then it stops.
		@param charactersToTrim     the set of characters to remove.
		@see trim, trimEnd, trimCharactersAtStart
	*/
	String trimCharactersAtEnd (const String& charactersToTrim) const;

	/** Returns an upper-case version of this string. */
	String toUpperCase() const;

	/** Returns an lower-case version of this string. */
	String toLowerCase() const;

	/** Replaces a sub-section of the string with another string.

		This will return a copy of this string, with a set of characters
		from startIndex to startIndex + numCharsToReplace removed, and with
		a new string inserted in their place.

		Note that this is a const method, and won't alter the string itself.

		@param startIndex               the first character to remove. If this is beyond the bounds of the string,
										it will be constrained to a valid range.
		@param numCharactersToReplace   the number of characters to remove. If zero or less, no
										characters will be taken out.
		@param stringToInsert           the new string to insert at startIndex after the characters have been
										removed.
	*/
	String replaceSection (int startIndex,
						   int numCharactersToReplace,
						   const String& stringToInsert) const;

	/** Replaces all occurrences of a substring with another string.

		Returns a copy of this string, with any occurrences of stringToReplace
		swapped for stringToInsertInstead.

		Note that this is a const method, and won't alter the string itself.
	*/
	String replace (const String& stringToReplace,
					const String& stringToInsertInstead,
					bool ignoreCase = false) const;

	/** Returns a string with all occurrences of a character replaced with a different one. */
	String replaceCharacter (juce_wchar characterToReplace,
							 juce_wchar characterToInsertInstead) const;

	/** Replaces a set of characters with another set.

		Returns a string in which each character from charactersToReplace has been replaced
		by the character at the equivalent position in newCharacters (so the two strings
		passed in must be the same length).

		e.g. replaceCharacters ("abc", "def") replaces 'a' with 'd', 'b' with 'e', etc.

		Note that this is a const method, and won't affect the string itself.
	*/
	String replaceCharacters (const String& charactersToReplace,
							  const String& charactersToInsertInstead) const;

	/** Returns a version of this string that only retains a fixed set of characters.

		This will return a copy of this string, omitting any characters which are not
		found in the string passed-in.

		e.g. for "1122334455", retainCharacters ("432") would return "223344"

		Note that this is a const method, and won't alter the string itself.
	*/
	String retainCharacters (const String& charactersToRetain) const;

	/** Returns a version of this string with a set of characters removed.

		This will return a copy of this string, omitting any characters which are
		found in the string passed-in.

		e.g. for "1122334455", removeCharacters ("432") would return "1155"

		Note that this is a const method, and won't alter the string itself.
	*/
	String removeCharacters (const String& charactersToRemove) const;

	/** Returns a section from the start of the string that only contains a certain set of characters.

		This returns the leftmost section of the string, up to (and not including) the
		first character that doesn't appear in the string passed in.
	*/
	String initialSectionContainingOnly (const String& permittedCharacters) const;

	/** Returns a section from the start of the string that only contains a certain set of characters.

		This returns the leftmost section of the string, up to (and not including) the
		first character that occurs in the string passed in. (If none of the specified
		characters are found in the string, the return value will just be the original string).
	*/
	String initialSectionNotContaining (const String& charactersToStopAt) const;

	/** Checks whether the string might be in quotation marks.

		@returns    true if the string begins with a quote character (either a double or single quote).
					It is also true if there is whitespace before the quote, but it doesn't check the end of the string.
		@see unquoted, quoted
	*/
	bool isQuotedString() const;

	/** Removes quotation marks from around the string, (if there are any).

		Returns a copy of this string with any quotes removed from its ends. Quotes that aren't
		at the ends of the string are not affected. If there aren't any quotes, the original string
		is returned.

		Note that this is a const method, and won't alter the string itself.

		@see isQuotedString, quoted
	*/
	String unquoted() const;

	/** Adds quotation marks around a string.

		This will return a copy of the string with a quote at the start and end, (but won't
		add the quote if there's already one there, so it's safe to call this on strings that
		may already have quotes around them).

		Note that this is a const method, and won't alter the string itself.

		@param quoteCharacter   the character to add at the start and end
		@see isQuotedString, unquoted
	*/
	String quoted (juce_wchar quoteCharacter = '"') const;

	/** Creates a string which is a version of a string repeated and joined together.

		@param stringToRepeat         the string to repeat
		@param numberOfTimesToRepeat  how many times to repeat it
	*/
	static String repeatedString (const String& stringToRepeat,
								  int numberOfTimesToRepeat);

	/** Returns a copy of this string with the specified character repeatedly added to its
		beginning until the total length is at least the minimum length specified.
	*/
	String paddedLeft (juce_wchar padCharacter, int minimumLength) const;

	/** Returns a copy of this string with the specified character repeatedly added to its
		end until the total length is at least the minimum length specified.
	*/
	String paddedRight (juce_wchar padCharacter, int minimumLength) const;

	/** Creates a string from data in an unknown format.

		This looks at some binary data and tries to guess whether it's Unicode
		or 8-bit characters, then returns a string that represents it correctly.

		Should be able to handle Unicode endianness correctly, by looking at
		the first two bytes.
	*/
	static String createStringFromData (const void* data, int size);

	/** Creates a String from a printf-style parameter list.

		I don't like this method. I don't use it myself, and I recommend avoiding it and
		using the operator<< methods or pretty much anything else instead. It's only provided
		here because of the popular unrest that was stirred-up when I tried to remove it...

		If you're really determined to use it, at least make sure that you never, ever,
		pass any String objects to it as parameters. And bear in mind that internally, depending
		on the platform, it may be using wchar_t or char character types, so that even string
		literals can't be safely used as parameters if you're writing portable code.
	*/
	static String formatted (const String formatString, ... );

	// Numeric conversions..

	/** Creates a string containing this signed 32-bit integer as a decimal number.
		@see getIntValue, getFloatValue, getDoubleValue, toHexString
	*/
	explicit String (int decimalInteger);

	/** Creates a string containing this unsigned 32-bit integer as a decimal number.
		@see getIntValue, getFloatValue, getDoubleValue, toHexString
	*/
	explicit String (unsigned int decimalInteger);

	/** Creates a string containing this signed 16-bit integer as a decimal number.
		@see getIntValue, getFloatValue, getDoubleValue, toHexString
	*/
	explicit String (short decimalInteger);

	/** Creates a string containing this unsigned 16-bit integer as a decimal number.
		@see getIntValue, getFloatValue, getDoubleValue, toHexString
	*/
	explicit String (unsigned short decimalInteger);

	/** Creates a string containing this signed 64-bit integer as a decimal number.
		@see getLargeIntValue, getFloatValue, getDoubleValue, toHexString
	*/
	explicit String (int64 largeIntegerValue);

	/** Creates a string containing this unsigned 64-bit integer as a decimal number.
		@see getLargeIntValue, getFloatValue, getDoubleValue, toHexString
	*/
	explicit String (uint64 largeIntegerValue);

	/** Creates a string representing this floating-point number.
		@param floatValue               the value to convert to a string
		@see getDoubleValue, getIntValue
	*/
	explicit String (float floatValue);

	/** Creates a string representing this floating-point number.
		@param doubleValue              the value to convert to a string
		@see getFloatValue, getIntValue
	*/
	explicit String (double doubleValue);

	/** Creates a string representing this floating-point number.
		@param floatValue               the value to convert to a string
		@param numberOfDecimalPlaces    if this is > 0, it will format the number using that many
										decimal places, and will not use exponent notation. If 0 or
										less, it will use exponent notation if necessary.
		@see getDoubleValue, getIntValue
	*/
	String (float floatValue, int numberOfDecimalPlaces);

	/** Creates a string representing this floating-point number.
		@param doubleValue              the value to convert to a string
		@param numberOfDecimalPlaces    if this is > 0, it will format the number using that many
										decimal places, and will not use exponent notation. If 0 or
										less, it will use exponent notation if necessary.
		@see getFloatValue, getIntValue
	*/
	String (double doubleValue, int numberOfDecimalPlaces);

	/** Reads the value of the string as a decimal number (up to 32 bits in size).

		@returns the value of the string as a 32 bit signed base-10 integer.
		@see getTrailingIntValue, getHexValue32, getHexValue64
	*/
	int getIntValue() const noexcept;

	/** Reads the value of the string as a decimal number (up to 64 bits in size).

		@returns the value of the string as a 64 bit signed base-10 integer.
	*/
	int64 getLargeIntValue() const noexcept;

	/** Parses a decimal number from the end of the string.

		This will look for a value at the end of the string.
		e.g. for "321 xyz654" it will return 654; for "2 3 4" it'll return 4.

		Negative numbers are not handled, so "xyz-5" returns 5.

		@see getIntValue
	*/
	int getTrailingIntValue() const noexcept;

	/** Parses this string as a floating point number.

		@returns    the value of the string as a 32-bit floating point value.
		@see getDoubleValue
	*/
	float getFloatValue() const noexcept;

	/** Parses this string as a floating point number.

		@returns    the value of the string as a 64-bit floating point value.
		@see getFloatValue
	*/
	double getDoubleValue() const noexcept;

	/** Parses the string as a hexadecimal number.

		Non-hexadecimal characters in the string are ignored.

		If the string contains too many characters, then the lowest significant
		digits are returned, e.g. "ffff12345678" would produce 0x12345678.

		@returns    a 32-bit number which is the value of the string in hex.
	*/
	int getHexValue32() const noexcept;

	/** Parses the string as a hexadecimal number.

		Non-hexadecimal characters in the string are ignored.

		If the string contains too many characters, then the lowest significant
		digits are returned, e.g. "ffff1234567812345678" would produce 0x1234567812345678.

		@returns    a 64-bit number which is the value of the string in hex.
	*/
	int64 getHexValue64() const noexcept;

	/** Creates a string representing this 32-bit value in hexadecimal. */
	static String toHexString (int number);

	/** Creates a string representing this 64-bit value in hexadecimal. */
	static String toHexString (int64 number);

	/** Creates a string representing this 16-bit value in hexadecimal. */
	static String toHexString (short number);

	/** Creates a string containing a hex dump of a block of binary data.

		@param data         the binary data to use as input
		@param size         how many bytes of data to use
		@param groupSize    how many bytes are grouped together before inserting a
							space into the output. e.g. group size 0 has no spaces,
							group size 1 looks like: "be a1 c2 ff", group size 2 looks
							like "bea1 c2ff".
	*/
	static String toHexString (const void* data, int size, int groupSize = 1);

	/** Returns the character pointer currently being used to store this string.

		Because it returns a reference to the string's internal data, the pointer
		that is returned must not be stored anywhere, as it can be deleted whenever the
		string changes.
	*/
	inline const CharPointerType& getCharPointer() const noexcept    { return text; }

	/** Returns a pointer to a UTF-8 version of this string.

		Because it returns a reference to the string's internal data, the pointer
		that is returned must not be stored anywhere, as it can be deleted whenever the
		string changes.

		To find out how many bytes you need to store this string as UTF-8, you can call
		CharPointer_UTF8::getBytesRequiredFor (myString.getCharPointer())

		@see getCharPointer, toUTF16, toUTF32
	*/
	CharPointer_UTF8 toUTF8() const;

	/** Returns a pointer to a UTF-32 version of this string.

		Because it returns a reference to the string's internal data, the pointer
		that is returned must not be stored anywhere, as it can be deleted whenever the
		string changes.

		To find out how many bytes you need to store this string as UTF-16, you can call
		CharPointer_UTF16::getBytesRequiredFor (myString.getCharPointer())

		@see getCharPointer, toUTF8, toUTF32
	*/
	CharPointer_UTF16 toUTF16() const;

	/** Returns a pointer to a UTF-32 version of this string.

		Because it returns a reference to the string's internal data, the pointer
		that is returned must not be stored anywhere, as it can be deleted whenever the
		string changes.

		@see getCharPointer, toUTF8, toUTF16
	*/
	CharPointer_UTF32 toUTF32() const;

	/** Returns a pointer to a wchar_t version of this string.

		Because it returns a reference to the string's internal data, the pointer
		that is returned must not be stored anywhere, as it can be deleted whenever the
		string changes.

		Bear in mind that the wchar_t type is different on different platforms, so on
		Windows, this will be equivalent to calling toUTF16(), on unix it'll be the same
		as calling toUTF32(), etc.

		@see getCharPointer, toUTF8, toUTF16, toUTF32
	*/
	const wchar_t* toWideCharPointer() const;

	/** Creates a String from a UTF-8 encoded buffer.
		If the size is < 0, it'll keep reading until it hits a zero.
	*/
	static String fromUTF8 (const char* utf8buffer, int bufferSizeBytes = -1);

	/** Returns the number of bytes required to represent this string as UTF8.
		The number returned does NOT include the trailing zero.
		@see toUTF8, copyToUTF8
	*/
	int getNumBytesAsUTF8() const noexcept;

	/** Copies the string to a buffer as UTF-8 characters.

		Returns the number of bytes copied to the buffer, including the terminating null
		character.

		To find out how many bytes you need to store this string as UTF-8, you can call
		CharPointer_UTF8::getBytesRequiredFor (myString.getCharPointer())

		@param destBuffer       the place to copy it to; if this is a null pointer, the method just
								returns the number of bytes required (including the terminating null character).
		@param maxBufferSizeBytes  the size of the destination buffer, in bytes. If the string won't fit, it'll
								put in as many as it can while still allowing for a terminating null char at the
								end, and will return the number of bytes that were actually used.
		@see CharPointer_UTF8::writeWithDestByteLimit
	*/
	int copyToUTF8 (CharPointer_UTF8::CharType* destBuffer, int maxBufferSizeBytes) const noexcept;

	/** Copies the string to a buffer as UTF-16 characters.

		Returns the number of bytes copied to the buffer, including the terminating null
		character.

		To find out how many bytes you need to store this string as UTF-16, you can call
		CharPointer_UTF16::getBytesRequiredFor (myString.getCharPointer())

		@param destBuffer       the place to copy it to; if this is a null pointer, the method just
								returns the number of bytes required (including the terminating null character).
		@param maxBufferSizeBytes  the size of the destination buffer, in bytes. If the string won't fit, it'll
								put in as many as it can while still allowing for a terminating null char at the
								end, and will return the number of bytes that were actually used.
		@see CharPointer_UTF16::writeWithDestByteLimit
	*/
	int copyToUTF16 (CharPointer_UTF16::CharType* destBuffer, int maxBufferSizeBytes) const noexcept;

	/** Copies the string to a buffer as UTF-16 characters.

		Returns the number of bytes copied to the buffer, including the terminating null
		character.

		To find out how many bytes you need to store this string as UTF-32, you can call
		CharPointer_UTF32::getBytesRequiredFor (myString.getCharPointer())

		@param destBuffer       the place to copy it to; if this is a null pointer, the method just
								returns the number of bytes required (including the terminating null character).
		@param maxBufferSizeBytes  the size of the destination buffer, in bytes. If the string won't fit, it'll
								put in as many as it can while still allowing for a terminating null char at the
								end, and will return the number of bytes that were actually used.
		@see CharPointer_UTF32::writeWithDestByteLimit
	*/
	int copyToUTF32 (CharPointer_UTF32::CharType* destBuffer, int maxBufferSizeBytes) const noexcept;

	/** Increases the string's internally allocated storage.

		Although the string's contents won't be affected by this call, it will
		increase the amount of memory allocated internally for the string to grow into.

		If you're about to make a large number of calls to methods such
		as += or <<, it's more efficient to preallocate enough extra space
		beforehand, so that these methods won't have to keep resizing the string
		to append the extra characters.

		@param numBytesNeeded   the number of bytes to allocate storage for. If this
								value is less than the currently allocated size, it will
								have no effect.
	*/
	void preallocateBytes (size_t numBytesNeeded);

	/** Swaps the contents of this string with another one.
		This is a very fast operation, as no allocation or copying needs to be done.
	*/
	void swapWith (String& other) noexcept;

   #if JUCE_MAC || JUCE_IOS || DOXYGEN
	/** MAC ONLY - Creates a String from an OSX CFString. */
	static String fromCFString (CFStringRef cfString);

	/** MAC ONLY - Converts this string to a CFString.
		Remember that you must use CFRelease() to free the returned string when you're
		finished with it.
	*/
	CFStringRef toCFString() const;

	/** MAC ONLY - Returns a copy of this string in which any decomposed unicode characters have
		been converted to their precomposed equivalents. */
	String convertToPrecomposedUnicode() const;
   #endif

private:

	CharPointerType text;

	struct PreallocationBytes
	{
		explicit PreallocationBytes (size_t);
		size_t numBytes;
	};

	explicit String (const PreallocationBytes&); // This constructor preallocates a certain amount of memory
	void appendFixedLength (const char* text, int numExtraChars);
	size_t getByteOffsetOfEnd() const noexcept;
	JUCE_DEPRECATED (String (const String& stringToCopy, size_t charsToAllocate));

	// This private cast operator should prevent strings being accidentally cast
	// to bools (this is possible because the compiler can add an implicit cast
	// via a const char*)
	operator bool() const noexcept  { return false; }
};

/** Concatenates two strings. */
JUCE_API String JUCE_CALLTYPE operator+ (const char* string1,     const String& string2);
/** Concatenates two strings. */
JUCE_API String JUCE_CALLTYPE operator+ (const wchar_t* string1,  const String& string2);
/** Concatenates two strings. */
JUCE_API String JUCE_CALLTYPE operator+ (char string1,            const String& string2);
/** Concatenates two strings. */
JUCE_API String JUCE_CALLTYPE operator+ (wchar_t string1,         const String& string2);
#if ! JUCE_NATIVE_WCHAR_IS_UTF32
/** Concatenates two strings. */
JUCE_API String JUCE_CALLTYPE operator+ (juce_wchar string1,      const String& string2);
#endif

/** Concatenates two strings. */
JUCE_API String JUCE_CALLTYPE operator+ (String string1, const String& string2);
/** Concatenates two strings. */
JUCE_API String JUCE_CALLTYPE operator+ (String string1, const char* string2);
/** Concatenates two strings. */
JUCE_API String JUCE_CALLTYPE operator+ (String string1, const wchar_t* string2);
/** Concatenates two strings. */
JUCE_API String JUCE_CALLTYPE operator+ (String string1, char characterToAppend);
/** Concatenates two strings. */
JUCE_API String JUCE_CALLTYPE operator+ (String string1, wchar_t characterToAppend);
#if ! JUCE_NATIVE_WCHAR_IS_UTF32
/** Concatenates two strings. */
JUCE_API String JUCE_CALLTYPE operator+ (String string1, juce_wchar characterToAppend);
#endif

/** Appends a character at the end of a string. */
JUCE_API String& JUCE_CALLTYPE operator<< (String& string1, char characterToAppend);
/** Appends a character at the end of a string. */
JUCE_API String& JUCE_CALLTYPE operator<< (String& string1, wchar_t characterToAppend);
#if ! JUCE_NATIVE_WCHAR_IS_UTF32
/** Appends a character at the end of a string. */
JUCE_API String& JUCE_CALLTYPE operator<< (String& string1, juce_wchar characterToAppend);
#endif

/** Appends a string to the end of the first one. */
JUCE_API String& JUCE_CALLTYPE operator<< (String& string1, const char* string2);
/** Appends a string to the end of the first one. */
JUCE_API String& JUCE_CALLTYPE operator<< (String& string1, const wchar_t* string2);
/** Appends a string to the end of the first one. */
JUCE_API String& JUCE_CALLTYPE operator<< (String& string1, const String& string2);

/** Appends a decimal number at the end of a string. */
JUCE_API String& JUCE_CALLTYPE operator<< (String& string1, short number);
/** Appends a decimal number at the end of a string. */
JUCE_API String& JUCE_CALLTYPE operator<< (String& string1, int number);
/** Appends a decimal number at the end of a string. */
JUCE_API String& JUCE_CALLTYPE operator<< (String& string1, long number);
/** Appends a decimal number at the end of a string. */
JUCE_API String& JUCE_CALLTYPE operator<< (String& string1, float number);
/** Appends a decimal number at the end of a string. */
JUCE_API String& JUCE_CALLTYPE operator<< (String& string1, double number);

/** Case-sensitive comparison of two strings. */
JUCE_API bool JUCE_CALLTYPE operator== (const String& string1, const String& string2) noexcept;
/** Case-sensitive comparison of two strings. */
JUCE_API bool JUCE_CALLTYPE operator== (const String& string1, const char* string2) noexcept;
/** Case-sensitive comparison of two strings. */
JUCE_API bool JUCE_CALLTYPE operator== (const String& string1, const wchar_t* string2) noexcept;
/** Case-sensitive comparison of two strings. */
JUCE_API bool JUCE_CALLTYPE operator== (const String& string1, const CharPointer_UTF8& string2) noexcept;
/** Case-sensitive comparison of two strings. */
JUCE_API bool JUCE_CALLTYPE operator== (const String& string1, const CharPointer_UTF16& string2) noexcept;
/** Case-sensitive comparison of two strings. */
JUCE_API bool JUCE_CALLTYPE operator== (const String& string1, const CharPointer_UTF32& string2) noexcept;
/** Case-sensitive comparison of two strings. */
JUCE_API bool JUCE_CALLTYPE operator!= (const String& string1, const String& string2) noexcept;
/** Case-sensitive comparison of two strings. */
JUCE_API bool JUCE_CALLTYPE operator!= (const String& string1, const char* string2) noexcept;
/** Case-sensitive comparison of two strings. */
JUCE_API bool JUCE_CALLTYPE operator!= (const String& string1, const wchar_t* string2) noexcept;
/** Case-sensitive comparison of two strings. */
JUCE_API bool JUCE_CALLTYPE operator!= (const String& string1, const CharPointer_UTF8& string2) noexcept;
/** Case-sensitive comparison of two strings. */
JUCE_API bool JUCE_CALLTYPE operator!= (const String& string1, const CharPointer_UTF16& string2) noexcept;
/** Case-sensitive comparison of two strings. */
JUCE_API bool JUCE_CALLTYPE operator!= (const String& string1, const CharPointer_UTF32& string2) noexcept;
/** Case-sensitive comparison of two strings. */
JUCE_API bool JUCE_CALLTYPE operator>  (const String& string1, const String& string2) noexcept;
/** Case-sensitive comparison of two strings. */
JUCE_API bool JUCE_CALLTYPE operator<  (const String& string1, const String& string2) noexcept;
/** Case-sensitive comparison of two strings. */
JUCE_API bool JUCE_CALLTYPE operator>= (const String& string1, const String& string2) noexcept;
/** Case-sensitive comparison of two strings. */
JUCE_API bool JUCE_CALLTYPE operator<= (const String& string1, const String& string2) noexcept;

/** This operator allows you to write a juce String directly to std output streams.
	This is handy for writing strings to std::cout, std::cerr, etc.
*/
template <class traits>
std::basic_ostream <char, traits>& JUCE_CALLTYPE operator<< (std::basic_ostream <char, traits>& stream, const String& stringToWrite)
{
	return stream << stringToWrite.toUTF8().getAddress();
}

/** This operator allows you to write a juce String directly to std output streams.
	This is handy for writing strings to std::wcout, std::wcerr, etc.
*/
template <class traits>
std::basic_ostream <wchar_t, traits>& JUCE_CALLTYPE operator<< (std::basic_ostream <wchar_t, traits>& stream, const String& stringToWrite)
{
	return stream << stringToWrite.toWideCharPointer();
}

/** Writes a string to an OutputStream as UTF8. */
JUCE_API OutputStream& JUCE_CALLTYPE operator<< (OutputStream& stream, const String& stringToWrite);

#endif   // __JUCE_STRING_JUCEHEADER__

/*** End of inlined file: juce_String.h ***/

/**
	Acts as an application-wide logging class.

	A subclass of Logger can be created and passed into the Logger::setCurrentLogger
	method and this will then be used by all calls to writeToLog.

	The logger class also contains methods for writing messages to the debugger's
	output stream.

	@see FileLogger
*/
class JUCE_API  Logger
{
public:

	/** Destructor. */
	virtual ~Logger();

	/** Sets the current logging class to use.

		Note that the object passed in won't be deleted when no longer needed.
		A null pointer can be passed-in to disable any logging.

		If deleteOldLogger is set to true, the existing logger will be
		deleted (if there is one).
	*/
	static void JUCE_CALLTYPE setCurrentLogger (Logger* newLogger,
												bool deleteOldLogger = false);

	/** Writes a string to the current logger.

		This will pass the string to the logger's logMessage() method if a logger
		has been set.

		@see logMessage
	*/
	static void JUCE_CALLTYPE writeToLog (const String& message);

	/** Writes a message to the standard error stream.

		This can be called directly, or by using the DBG() macro in
		juce_PlatformDefs.h (which will avoid calling the method in non-debug builds).
	*/
	static void JUCE_CALLTYPE outputDebugString (const String& text);

protected:

	Logger();

	/** This is overloaded by subclasses to implement custom logging behaviour.

		@see setCurrentLogger
	*/
	virtual void logMessage (const String& message) = 0;

private:
	static Logger* currentLogger;
};

#endif   // __JUCE_LOGGER_JUCEHEADER__

/*** End of inlined file: juce_Logger.h ***/


/*** Start of inlined file: juce_LeakedObjectDetector.h ***/
#ifndef __JUCE_LEAKEDOBJECTDETECTOR_JUCEHEADER__
#define __JUCE_LEAKEDOBJECTDETECTOR_JUCEHEADER__

/**
	Embedding an instance of this class inside another class can be used as a low-overhead
	way of detecting leaked instances.

	This class keeps an internal static count of the number of instances that are
	active, so that when the app is shutdown and the static destructors are called,
	it can check whether there are any left-over instances that may have been leaked.

	To use it, use the JUCE_LEAK_DETECTOR macro as a simple way to put one in your
	class declaration. Have a look through the juce codebase for examples, it's used
	in most of the classes.
*/
template <class OwnerClass>
class LeakedObjectDetector
{
public:

	LeakedObjectDetector() noexcept                                 { ++(getCounter().numObjects); }
	LeakedObjectDetector (const LeakedObjectDetector&) noexcept     { ++(getCounter().numObjects); }

	~LeakedObjectDetector()
	{
		if (--(getCounter().numObjects) < 0)
		{
			DBG ("*** Dangling pointer deletion! Class: " << getLeakedObjectClassName());

			/** If you hit this, then you've managed to delete more instances of this class than you've
				created.. That indicates that you're deleting some dangling pointers.

				Note that although this assertion will have been triggered during a destructor, it might
				not be this particular deletion that's at fault - the incorrect one may have happened
				at an earlier point in the program, and simply not been detected until now.

				Most errors like this are caused by using old-fashioned, non-RAII techniques for
				your object management. Tut, tut. Always, always use ScopedPointers, OwnedArrays,
				ReferenceCountedObjects, etc, and avoid the 'delete' operator at all costs!
			*/
			jassertfalse;
		}
	}

private:

	class LeakCounter
	{
	public:
		LeakCounter() noexcept {}

		~LeakCounter()
		{
			if (numObjects.value > 0)
			{
				DBG ("*** Leaked objects detected: " << numObjects.value << " instance(s) of class " << getLeakedObjectClassName());

				/** If you hit this, then you've leaked one or more objects of the type specified by
					the 'OwnerClass' template parameter - the name should have been printed by the line above.

					If you're leaking, it's probably because you're using old-fashioned, non-RAII techniques for
					your object management. Tut, tut. Always, always use ScopedPointers, OwnedArrays,
					ReferenceCountedObjects, etc, and avoid the 'delete' operator at all costs!
				*/
				jassertfalse;
			}
		}

		Atomic<int> numObjects;
	};

	static const char* getLeakedObjectClassName()
	{
		return OwnerClass::getLeakedObjectClassName();
	}

	static LeakCounter& getCounter() noexcept
	{
		static LeakCounter counter;
		return counter;
	}
};

#if DOXYGEN || ! defined (JUCE_LEAK_DETECTOR)
 #if (DOXYGEN || JUCE_CHECK_MEMORY_LEAKS)
  /** This macro lets you embed a leak-detecting object inside a class.

	  To use it, simply declare a JUCE_LEAK_DETECTOR(YourClassName) inside a private section
	  of the class declaration. E.g.

	  @code
	  class MyClass
	  {
	  public:
		  MyClass();
		  void blahBlah();

	  private:
		  JUCE_LEAK_DETECTOR (MyClass);
	  };@endcode

	  @see JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR, LeakedObjectDetector
  */
  #define JUCE_LEAK_DETECTOR(OwnerClass) \
		friend class juce::LeakedObjectDetector<OwnerClass>; \
		static const char* getLeakedObjectClassName() noexcept { return #OwnerClass; } \
		juce::LeakedObjectDetector<OwnerClass> JUCE_JOIN_MACRO (leakDetector, __LINE__);
 #else
  #define JUCE_LEAK_DETECTOR(OwnerClass)
 #endif
#endif

#endif   // __JUCE_LEAKEDOBJECTDETECTOR_JUCEHEADER__

/*** End of inlined file: juce_LeakedObjectDetector.h ***/

// unbelievably, some system headers actually use macros to define these symbols:
#undef check
#undef TYPE_BOOL

#if JUCE_MAC || JUCE_IOS || DOXYGEN

 /** A handy C++ wrapper that creates and deletes an NSAutoreleasePool object using RAII.
	 You should use the JUCE_AUTORELEASEPOOL macro to create a local auto-release pool on the stack.
 */
 class JUCE_API  ScopedAutoReleasePool
 {
 public:
	 ScopedAutoReleasePool();
	 ~ScopedAutoReleasePool();

 private:
	 void* pool;

	 JUCE_DECLARE_NON_COPYABLE (ScopedAutoReleasePool);
 };

 /** A macro that can be used to easily declare a local ScopedAutoReleasePool object for RAII-based obj-C autoreleasing. */
 #define JUCE_AUTORELEASEPOOL  const juce::ScopedAutoReleasePool JUCE_JOIN_MACRO (autoReleasePool_, __LINE__);

#else
 #define JUCE_AUTORELEASEPOOL
#endif

END_JUCE_NAMESPACE

#endif   // __JUCE_STANDARDHEADER_JUCEHEADER__

/*** End of inlined file: juce_StandardHeader.h ***/

namespace juce
{

// START_AUTOINCLUDE containers, files, json, logging, maths, memory, misc, network,
// streams, system, text, threads, time, unit_tests, xml, zip
#ifndef __JUCE_ABSTRACTFIFO_JUCEHEADER__

/*** Start of inlined file: juce_AbstractFifo.h ***/
#ifndef __JUCE_ABSTRACTFIFO_JUCEHEADER__
#define __JUCE_ABSTRACTFIFO_JUCEHEADER__

/**
	Encapsulates the logic required to implement a lock-free FIFO.

	This class handles the logic needed when building a single-reader, single-writer FIFO.

	It doesn't actually hold any data itself, but your FIFO class can use one of these to manage
	its position and status when reading or writing to it.

	To use it, you can call prepareToWrite() to determine the position within your own buffer that
	an incoming block of data should be stored, and prepareToRead() to find out when the next
	outgoing block should be read from.

	e.g.
	@code
	class MyFifo
	{
	public:
		MyFifo()  : abstractFifo (1024)
		{
		}

		void addToFifo (const int* someData, int numItems)
		{
			int start1, size1, start2, size2;
			abstractFifo.prepareToWrite (numItems, start1, size1, start2, size2);

			if (size1 > 0)
				copySomeData (myBuffer + start1, someData, size1);

			if (size2 > 0)
				copySomeData (myBuffer + start2, someData + size1, size2);

			abstractFifo.finishedWrite (size1 + size2);
		}

		void readFromFifo (int* someData, int numItems)
		{
			int start1, size1, start2, size2;
			abstractFifo.prepareToRead (numSamples, start1, size1, start2, size2);

			if (size1 > 0)
				copySomeData (someData, myBuffer + start1, size1);

			if (size2 > 0)
				copySomeData (someData + size1, myBuffer + start2, size2);

			abstractFifo.finishedRead (size1 + size2);
		}

	private:
		AbstractFifo abstractFifo;
		int myBuffer [1024];
	};
	@endcode
*/
class JUCE_API  AbstractFifo
{
public:

	/** Creates a FIFO to manage a buffer with the specified capacity. */
	AbstractFifo (int capacity) noexcept;

	/** Destructor */
	~AbstractFifo();

	/** Returns the total size of the buffer being managed. */
	int getTotalSize() const noexcept;

	/** Returns the number of items that can currently be added to the buffer without it overflowing. */
	int getFreeSpace() const noexcept;

	/** Returns the number of items that can currently be read from the buffer. */
	int getNumReady() const noexcept;

	/** Clears the buffer positions, so that it appears empty. */
	void reset() noexcept;

	/** Changes the buffer's total size.
		Note that this isn't thread-safe, so don't call it if there's any danger that it
		might overlap with a call to any other method in this class!
	*/
	void setTotalSize (int newSize) noexcept;

	/** Returns the location within the buffer at which an incoming block of data should be written.

		Because the section of data that you want to add to the buffer may overlap the end
		and wrap around to the start, two blocks within your buffer are returned, and you
		should copy your data into the first one, with any remaining data spilling over into
		the second.

		If the number of items you ask for is too large to fit within the buffer's free space, then
		blockSize1 + blockSize2 may add up to a lower value than numToWrite. If this happens, you
		may decide to keep waiting and re-trying the method until there's enough space available.

		After calling this method, if you choose to write your data into the blocks returned, you
		must call finishedWrite() to tell the FIFO how much data you actually added.

		e.g.
		@code
		void addToFifo (const int* someData, int numItems)
		{
			int start1, size1, start2, size2;
			prepareToWrite (numItems, start1, size1, start2, size2);

			if (size1 > 0)
				copySomeData (myBuffer + start1, someData, size1);

			if (size2 > 0)
				copySomeData (myBuffer + start2, someData + size1, size2);

			finishedWrite (size1 + size2);
		}
		@endcode

		@param numToWrite       indicates how many items you'd like to add to the buffer
		@param startIndex1      on exit, this will contain the start index in your buffer at which your data should be written
		@param blockSize1       on exit, this indicates how many items can be written to the block starting at startIndex1
		@param startIndex2      on exit, this will contain the start index in your buffer at which any data that didn't fit into
								the first block should be written
		@param blockSize2       on exit, this indicates how many items can be written to the block starting at startIndex2
		@see finishedWrite
	*/
	void prepareToWrite (int numToWrite, int& startIndex1, int& blockSize1, int& startIndex2, int& blockSize2) const noexcept;

	/** Called after reading from the FIFO, to indicate that this many items have been added.
		@see prepareToWrite
	*/
	void finishedWrite (int numWritten) noexcept;

	/** Returns the location within the buffer from which the next block of data should be read.

		Because the section of data that you want to read from the buffer may overlap the end
		and wrap around to the start, two blocks within your buffer are returned, and you
		should read from both of them.

		If the number of items you ask for is greater than the amount of data available, then
		blockSize1 + blockSize2 may add up to a lower value than numWanted. If this happens, you
		may decide to keep waiting and re-trying the method until there's enough data available.

		After calling this method, if you choose to read the data, you must call finishedRead() to
		tell the FIFO how much data you have consumed.

		e.g.
		@code
		void readFromFifo (int* someData, int numItems)
		{
			int start1, size1, start2, size2;
			prepareToRead (numSamples, start1, size1, start2, size2);

			if (size1 > 0)
				copySomeData (someData, myBuffer + start1, size1);

			if (size2 > 0)
				copySomeData (someData + size1, myBuffer + start2, size2);

			finishedRead (size1 + size2);
		}
		@endcode

		@param numWanted        indicates how many items you'd like to add to the buffer
		@param startIndex1      on exit, this will contain the start index in your buffer at which your data should be written
		@param blockSize1       on exit, this indicates how many items can be written to the block starting at startIndex1
		@param startIndex2      on exit, this will contain the start index in your buffer at which any data that didn't fit into
								the first block should be written
		@param blockSize2       on exit, this indicates how many items can be written to the block starting at startIndex2
		@see finishedRead
	*/
	void prepareToRead (int numWanted, int& startIndex1, int& blockSize1, int& startIndex2, int& blockSize2) const noexcept;

	/** Called after reading from the FIFO, to indicate that this many items have now been consumed.
		@see prepareToRead
	*/
	void finishedRead (int numRead) noexcept;

private:

	int bufferSize;
	Atomic <int> validStart, validEnd;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (AbstractFifo);
};

#endif   // __JUCE_ABSTRACTFIFO_JUCEHEADER__

/*** End of inlined file: juce_AbstractFifo.h ***/


#endif
#ifndef __JUCE_ARRAY_JUCEHEADER__

/*** Start of inlined file: juce_Array.h ***/
#ifndef __JUCE_ARRAY_JUCEHEADER__
#define __JUCE_ARRAY_JUCEHEADER__


/*** Start of inlined file: juce_ArrayAllocationBase.h ***/
#ifndef __JUCE_ARRAYALLOCATIONBASE_JUCEHEADER__
#define __JUCE_ARRAYALLOCATIONBASE_JUCEHEADER__


/*** Start of inlined file: juce_HeapBlock.h ***/
#ifndef __JUCE_HEAPBLOCK_JUCEHEADER__
#define __JUCE_HEAPBLOCK_JUCEHEADER__

#ifndef DOXYGEN
namespace HeapBlockHelper
{
	template <bool shouldThrow>
	struct ThrowOnFail          { static void check (void*) {} };

	template<>
	struct ThrowOnFail <true>   { static void check (void* data) { if (data == nullptr) throw std::bad_alloc(); } };
}
#endif

/**
	Very simple container class to hold a pointer to some data on the heap.

	When you need to allocate some heap storage for something, always try to use
	this class instead of allocating the memory directly using malloc/free.

	A HeapBlock<char> object can be treated in pretty much exactly the same way
	as an char*, but as long as you allocate it on the stack or as a class member,
	it's almost impossible for it to leak memory.

	It also makes your code much more concise and readable than doing the same thing
	using direct allocations,

	E.g. instead of this:
	@code
		int* temp = (int*) malloc (1024 * sizeof (int));
		memcpy (temp, xyz, 1024 * sizeof (int));
		free (temp);
		temp = (int*) calloc (2048 * sizeof (int));
		temp[0] = 1234;
		memcpy (foobar, temp, 2048 * sizeof (int));
		free (temp);
	@endcode

	..you could just write this:
	@code
		HeapBlock <int> temp (1024);
		memcpy (temp, xyz, 1024 * sizeof (int));
		temp.calloc (2048);
		temp[0] = 1234;
		memcpy (foobar, temp, 2048 * sizeof (int));
	@endcode

	The class is extremely lightweight, containing only a pointer to the
	data, and exposes malloc/realloc/calloc/free methods that do the same jobs
	as their less object-oriented counterparts. Despite adding safety, you probably
	won't sacrifice any performance by using this in place of normal pointers.

	The throwOnFailure template parameter can be set to true if you'd like the class
	to throw a std::bad_alloc exception when an allocation fails. If this is false,
	then a failed allocation will just leave the heapblock with a null pointer (assuming
	that the system's malloc() function doesn't throw).

	@see Array, OwnedArray, MemoryBlock
*/
template <class ElementType, bool throwOnFailure = false>
class HeapBlock
{
public:

	/** Creates a HeapBlock which is initially just a null pointer.

		After creation, you can resize the array using the malloc(), calloc(),
		or realloc() methods.
	*/
	HeapBlock() noexcept  : data (nullptr)
	{
	}

	/** Creates a HeapBlock containing a number of elements.

		The contents of the block are undefined, as it will have been created by a
		malloc call.

		If you want an array of zero values, you can use the calloc() method instead.
	*/
	explicit HeapBlock (const size_t numElements)
		: data (static_cast <ElementType*> (::malloc (numElements * sizeof (ElementType))))
	{
		throwOnAllocationFailure();
	}

	/** Destructor.

		This will free the data, if any has been allocated.
	*/
	~HeapBlock()
	{
		::free (data);
	}

   #if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
	HeapBlock (HeapBlock&& other) noexcept
		: data (other.data)
	{
		other.data = nullptr;
	}

	HeapBlock& operator= (HeapBlock&& other) noexcept
	{
		std::swap (data, other.data);
		return *this;
	}
   #endif

	/** Returns a raw pointer to the allocated data.
		This may be a null pointer if the data hasn't yet been allocated, or if it has been
		freed by calling the free() method.
	*/
	inline operator ElementType*() const noexcept                           { return data; }

	/** Returns a raw pointer to the allocated data.
		This may be a null pointer if the data hasn't yet been allocated, or if it has been
		freed by calling the free() method.
	*/
	inline ElementType* getData() const noexcept                            { return data; }

	/** Returns a void pointer to the allocated data.
		This may be a null pointer if the data hasn't yet been allocated, or if it has been
		freed by calling the free() method.
	*/
	inline operator void*() const noexcept                                  { return static_cast <void*> (data); }

	/** Returns a void pointer to the allocated data.
		This may be a null pointer if the data hasn't yet been allocated, or if it has been
		freed by calling the free() method.
	*/
	inline operator const void*() const noexcept                            { return static_cast <const void*> (data); }

	/** Lets you use indirect calls to the first element in the array.
		Obviously this will cause problems if the array hasn't been initialised, because it'll
		be referencing a null pointer.
	*/
	inline ElementType* operator->() const  noexcept                        { return data; }

	/** Returns a reference to one of the data elements.
		Obviously there's no bounds-checking here, as this object is just a dumb pointer and
		has no idea of the size it currently has allocated.
	*/
	template <typename IndexType>
	inline ElementType& operator[] (IndexType index) const noexcept         { return data [index]; }

	/** Returns a pointer to a data element at an offset from the start of the array.
		This is the same as doing pointer arithmetic on the raw pointer itself.
	*/
	template <typename IndexType>
	inline ElementType* operator+ (IndexType index) const noexcept          { return data + index; }

	/** Compares the pointer with another pointer.
		This can be handy for checking whether this is a null pointer.
	*/
	inline bool operator== (const ElementType* const otherPointer) const noexcept   { return otherPointer == data; }

	/** Compares the pointer with another pointer.
		This can be handy for checking whether this is a null pointer.
	*/
	inline bool operator!= (const ElementType* const otherPointer) const noexcept   { return otherPointer != data; }

	/** Allocates a specified amount of memory.

		This uses the normal malloc to allocate an amount of memory for this object.
		Any previously allocated memory will be freed by this method.

		The number of bytes allocated will be (newNumElements * elementSize). Normally
		you wouldn't need to specify the second parameter, but it can be handy if you need
		to allocate a size in bytes rather than in terms of the number of elements.

		The data that is allocated will be freed when this object is deleted, or when you
		call free() or any of the allocation methods.
	*/
	void malloc (const size_t newNumElements, const size_t elementSize = sizeof (ElementType))
	{
		::free (data);
		data = static_cast <ElementType*> (::malloc (newNumElements * elementSize));
		throwOnAllocationFailure();
	}

	/** Allocates a specified amount of memory and clears it.
		This does the same job as the malloc() method, but clears the memory that it allocates.
	*/
	void calloc (const size_t newNumElements, const size_t elementSize = sizeof (ElementType))
	{
		::free (data);
		data = static_cast <ElementType*> (::calloc (newNumElements, elementSize));
		throwOnAllocationFailure();
	}

	/** Allocates a specified amount of memory and optionally clears it.
		This does the same job as either malloc() or calloc(), depending on the
		initialiseToZero parameter.
	*/
	void allocate (const size_t newNumElements, const bool initialiseToZero)
	{
		::free (data);

		if (initialiseToZero)
			data = static_cast <ElementType*> (::calloc (newNumElements, sizeof (ElementType)));
		else
			data = static_cast <ElementType*> (::malloc (newNumElements * sizeof (ElementType)));

		throwOnAllocationFailure();
	}

	/** Re-allocates a specified amount of memory.

		The semantics of this method are the same as malloc() and calloc(), but it
		uses realloc() to keep as much of the existing data as possible.
	*/
	void realloc (const size_t newNumElements, const size_t elementSize = sizeof (ElementType))
	{
		if (data == nullptr)
			data = static_cast <ElementType*> (::malloc (newNumElements * elementSize));
		else
			data = static_cast <ElementType*> (::realloc (data, newNumElements * elementSize));

		throwOnAllocationFailure();
	}

	/** Frees any currently-allocated data.
		This will free the data and reset this object to be a null pointer.
	*/
	void free()
	{
		::free (data);
		data = nullptr;
	}

	/** Swaps this object's data with the data of another HeapBlock.
		The two objects simply exchange their data pointers.
	*/
	template <bool otherBlockThrows>
	void swapWith (HeapBlock <ElementType, otherBlockThrows>& other) noexcept
	{
		std::swap (data, other.data);
	}

	/** This fills the block with zeros, up to the number of elements specified.
		Since the block has no way of knowing its own size, you must make sure that the number of
		elements you specify doesn't exceed the allocated size.
	*/
	void clear (size_t numElements) noexcept
	{
		zeromem (data, sizeof (ElementType) * numElements);
	}

private:

	ElementType* data;

	void throwOnAllocationFailure() const
	{
		HeapBlockHelper::ThrowOnFail<throwOnFailure>::check (data);
	}

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (HeapBlock);

	JUCE_PREVENT_HEAP_ALLOCATION; // Creating a 'new HeapBlock' would be missing the point!
};

#endif   // __JUCE_HEAPBLOCK_JUCEHEADER__

/*** End of inlined file: juce_HeapBlock.h ***/

/**
	Implements some basic array storage allocation functions.

	This class isn't really for public use - it's used by the other
	array classes, but might come in handy for some purposes.

	It inherits from a critical section class to allow the arrays to use
	the "empty base class optimisation" pattern to reduce their footprint.

	@see Array, OwnedArray, ReferenceCountedArray
*/
template <class ElementType, class TypeOfCriticalSectionToUse>
class ArrayAllocationBase  : public TypeOfCriticalSectionToUse
{
public:

	/** Creates an empty array. */
	ArrayAllocationBase() noexcept
		: numAllocated (0)
	{
	}

	/** Destructor. */
	~ArrayAllocationBase() noexcept
	{
	}

   #if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
	ArrayAllocationBase (ArrayAllocationBase<ElementType, TypeOfCriticalSectionToUse>&& other) noexcept
		: elements (static_cast <HeapBlock <ElementType>&&> (other.elements)),
		  numAllocated (other.numAllocated)
	{
	}

	ArrayAllocationBase& operator= (ArrayAllocationBase<ElementType, TypeOfCriticalSectionToUse>&& other) noexcept
	{
		elements = static_cast <HeapBlock <ElementType>&&> (other.elements);
		numAllocated = other.numAllocated;
		return *this;
	}
   #endif

	/** Changes the amount of storage allocated.

		This will retain any data currently held in the array, and either add or
		remove extra space at the end.

		@param numElements  the number of elements that are needed
	*/
	void setAllocatedSize (const int numElements)
	{
		if (numAllocated != numElements)
		{
			if (numElements > 0)
				elements.realloc ((size_t) numElements);
			else
				elements.free();

			numAllocated = numElements;
		}
	}

	/** Increases the amount of storage allocated if it is less than a given amount.

		This will retain any data currently held in the array, but will add
		extra space at the end to make sure there it's at least as big as the size
		passed in. If it's already bigger, no action is taken.

		@param minNumElements  the minimum number of elements that are needed
	*/
	void ensureAllocatedSize (const int minNumElements)
	{
		if (minNumElements > numAllocated)
			setAllocatedSize ((minNumElements + minNumElements / 2 + 8) & ~7);
	}

	/** Minimises the amount of storage allocated so that it's no more than
		the given number of elements.
	*/
	void shrinkToNoMoreThan (const int maxNumElements)
	{
		if (maxNumElements < numAllocated)
			setAllocatedSize (maxNumElements);
	}

	/** Swap the contents of two objects. */
	void swapWith (ArrayAllocationBase <ElementType, TypeOfCriticalSectionToUse>& other) noexcept
	{
		elements.swapWith (other.elements);
		std::swap (numAllocated, other.numAllocated);
	}

	HeapBlock <ElementType> elements;
	int numAllocated;

private:
	JUCE_DECLARE_NON_COPYABLE (ArrayAllocationBase);
};

#endif   // __JUCE_ARRAYALLOCATIONBASE_JUCEHEADER__

/*** End of inlined file: juce_ArrayAllocationBase.h ***/


/*** Start of inlined file: juce_ElementComparator.h ***/
#ifndef __JUCE_ELEMENTCOMPARATOR_JUCEHEADER__
#define __JUCE_ELEMENTCOMPARATOR_JUCEHEADER__

/**
	Sorts a range of elements in an array.

	The comparator object that is passed-in must define a public method with the following
	signature:
	@code
	int compareElements (ElementType first, ElementType second);
	@endcode

	..and this method must return:
	  - a value of < 0 if the first comes before the second
	  - a value of 0 if the two objects are equivalent
	  - a value of > 0 if the second comes before the first

	To improve performance, the compareElements() method can be declared as static or const.

	@param comparator       an object which defines a compareElements() method
	@param array            the array to sort
	@param firstElement     the index of the first element of the range to be sorted
	@param lastElement      the index of the last element in the range that needs
							sorting (this is inclusive)
	@param retainOrderOfEquivalentItems     if true, the order of items that the
							comparator deems the same will be maintained - this will be
							a slower algorithm than if they are allowed to be moved around.

	@see sortArrayRetainingOrder
*/
template <class ElementType, class ElementComparator>
static void sortArray (ElementComparator& comparator,
					   ElementType* const array,
					   int firstElement,
					   int lastElement,
					   const bool retainOrderOfEquivalentItems)
{
	(void) comparator;  // if you pass in an object with a static compareElements() method, this
						// avoids getting warning messages about the parameter being unused

	if (lastElement > firstElement)
	{
		if (retainOrderOfEquivalentItems)
		{
			for (int i = firstElement; i < lastElement; ++i)
			{
				if (comparator.compareElements (array[i], array [i + 1]) > 0)
				{
					std::swap (array[i], array[i + 1]);

					if (i > firstElement)
						i -= 2;
				}
			}
		}
		else
		{
			int fromStack[30], toStack[30];
			int stackIndex = 0;

			for (;;)
			{
				const int size = (lastElement - firstElement) + 1;

				if (size <= 8)
				{
					int j = lastElement;
					int maxIndex;

					while (j > firstElement)
					{
						maxIndex = firstElement;
						for (int k = firstElement + 1; k <= j; ++k)
							if (comparator.compareElements (array[k], array [maxIndex]) > 0)
								maxIndex = k;

						std::swap (array[j], array[maxIndex]);
						--j;
					}
				}
				else
				{
					const int mid = firstElement + (size >> 1);
					std::swap (array[mid], array[firstElement]);

					int i = firstElement;
					int j = lastElement + 1;

					for (;;)
					{
						while (++i <= lastElement
								&& comparator.compareElements (array[i], array [firstElement]) <= 0)
						{}

						while (--j > firstElement
								&& comparator.compareElements (array[j], array [firstElement]) >= 0)
						{}

						if (j < i)
							break;

						std::swap (array[i], array[j]);
					}

					std::swap (array[j], array[firstElement]);

					if (j - 1 - firstElement >= lastElement - i)
					{
						if (firstElement + 1 < j)
						{
							fromStack [stackIndex] = firstElement;
							toStack [stackIndex] = j - 1;
							++stackIndex;
						}

						if (i < lastElement)
						{
							firstElement = i;
							continue;
						}
					}
					else
					{
						if (i < lastElement)
						{
							fromStack [stackIndex] = i;
							toStack [stackIndex] = lastElement;
							++stackIndex;
						}

						if (firstElement + 1 < j)
						{
							lastElement = j - 1;
							continue;
						}
					}
				}

				if (--stackIndex < 0)
					break;

				jassert (stackIndex < numElementsInArray (fromStack));

				firstElement = fromStack [stackIndex];
				lastElement = toStack [stackIndex];
			}
		}
	}
}

/**
	Searches a sorted array of elements, looking for the index at which a specified value
	should be inserted for it to be in the correct order.

	The comparator object that is passed-in must define a public method with the following
	signature:
	@code
	int compareElements (ElementType first, ElementType second);
	@endcode

	..and this method must return:
	  - a value of < 0 if the first comes before the second
	  - a value of 0 if the two objects are equivalent
	  - a value of > 0 if the second comes before the first

	To improve performance, the compareElements() method can be declared as static or const.

	@param comparator       an object which defines a compareElements() method
	@param array            the array to search
	@param newElement       the value that is going to be inserted
	@param firstElement     the index of the first element to search
	@param lastElement      the index of the last element in the range (this is non-inclusive)
*/
template <class ElementType, class ElementComparator>
static int findInsertIndexInSortedArray (ElementComparator& comparator,
										 ElementType* const array,
										 const ElementType newElement,
										 int firstElement,
										 int lastElement)
{
	jassert (firstElement <= lastElement);

	(void) comparator;  // if you pass in an object with a static compareElements() method, this
						// avoids getting warning messages about the parameter being unused

	while (firstElement < lastElement)
	{
		if (comparator.compareElements (newElement, array [firstElement]) == 0)
		{
			++firstElement;
			break;
		}
		else
		{
			const int halfway = (firstElement + lastElement) >> 1;

			if (halfway == firstElement)
			{
				if (comparator.compareElements (newElement, array [halfway]) >= 0)
					++firstElement;

				break;
			}
			else if (comparator.compareElements (newElement, array [halfway]) >= 0)
			{
				firstElement = halfway;
			}
			else
			{
				lastElement = halfway;
			}
		}
	}

	return firstElement;
}

/**
	A simple ElementComparator class that can be used to sort an array of
	objects that support the '<' operator.

	This will work for primitive types and objects that implement operator<().

	Example: @code
	Array <int> myArray;
	DefaultElementComparator<int> sorter;
	myArray.sort (sorter);
	@endcode

	@see ElementComparator
*/
template <class ElementType>
class DefaultElementComparator
{
private:
	typedef PARAMETER_TYPE (ElementType) ParameterType;

public:
	static int compareElements (ParameterType first, ParameterType second)
	{
		return (first < second) ? -1 : ((second < first) ? 1 : 0);
	}
};

#endif   // __JUCE_ELEMENTCOMPARATOR_JUCEHEADER__

/*** End of inlined file: juce_ElementComparator.h ***/


/*** Start of inlined file: juce_CriticalSection.h ***/
#ifndef __JUCE_CRITICALSECTION_JUCEHEADER__
#define __JUCE_CRITICALSECTION_JUCEHEADER__


/*** Start of inlined file: juce_ScopedLock.h ***/
#ifndef __JUCE_SCOPEDLOCK_JUCEHEADER__
#define __JUCE_SCOPEDLOCK_JUCEHEADER__

/**
	Automatically locks and unlocks a mutex object.

	Use one of these as a local variable to provide RAII-based locking of a mutex.

	The templated class could be a CriticalSection, SpinLock, or anything else that
	provides enter() and exit() methods.

	e.g. @code
	CriticalSection myCriticalSection;

	for (;;)
	{
		const GenericScopedLock<CriticalSection> myScopedLock (myCriticalSection);
		// myCriticalSection is now locked

		...do some stuff...

		// myCriticalSection gets unlocked here.
	}
	@endcode

	@see GenericScopedUnlock, CriticalSection, SpinLock, ScopedLock, ScopedUnlock
*/
template <class LockType>
class GenericScopedLock
{
public:

	/** Creates a GenericScopedLock.

		As soon as it is created, this will acquire the lock, and when the GenericScopedLock
		object is deleted, the lock will be released.

		Make sure this object is created and deleted by the same thread,
		otherwise there are no guarantees what will happen! Best just to use it
		as a local stack object, rather than creating one with the new() operator.
	*/
	inline explicit GenericScopedLock (const LockType& lock) noexcept : lock_ (lock)     { lock.enter(); }

	/** Destructor.
		The lock will be released when the destructor is called.
		Make sure this object is created and deleted by the same thread, otherwise there are
		no guarantees what will happen!
	*/
	inline ~GenericScopedLock() noexcept                                                 { lock_.exit(); }

private:

	const LockType& lock_;

	JUCE_DECLARE_NON_COPYABLE (GenericScopedLock);
};

/**
	Automatically unlocks and re-locks a mutex object.

	This is the reverse of a GenericScopedLock object - instead of locking the mutex
	for the lifetime of this object, it unlocks it.

	Make sure you don't try to unlock mutexes that aren't actually locked!

	e.g. @code

	CriticalSection myCriticalSection;

	for (;;)
	{
		const GenericScopedLock<CriticalSection> myScopedLock (myCriticalSection);
		// myCriticalSection is now locked

		... do some stuff with it locked ..

		while (xyz)
		{
			... do some stuff with it locked ..

			const GenericScopedUnlock<CriticalSection> unlocker (myCriticalSection);

			// myCriticalSection is now unlocked for the remainder of this block,
			// and re-locked at the end.

			...do some stuff with it unlocked ...
		}

		// myCriticalSection gets unlocked here.
	}
	@endcode

	@see GenericScopedLock, CriticalSection, ScopedLock, ScopedUnlock
*/
template <class LockType>
class GenericScopedUnlock
{
public:

	/** Creates a GenericScopedUnlock.

		As soon as it is created, this will unlock the CriticalSection, and
		when the ScopedLock object is deleted, the CriticalSection will
		be re-locked.

		Make sure this object is created and deleted by the same thread,
		otherwise there are no guarantees what will happen! Best just to use it
		as a local stack object, rather than creating one with the new() operator.
	*/
	inline explicit GenericScopedUnlock (const LockType& lock) noexcept : lock_ (lock)   { lock.exit(); }

	/** Destructor.

		The CriticalSection will be unlocked when the destructor is called.

		Make sure this object is created and deleted by the same thread,
		otherwise there are no guarantees what will happen!
	*/
	inline ~GenericScopedUnlock() noexcept                                               { lock_.enter(); }

private:

	const LockType& lock_;

	JUCE_DECLARE_NON_COPYABLE (GenericScopedUnlock);
};

/**
	Automatically locks and unlocks a mutex object.

	Use one of these as a local variable to provide RAII-based locking of a mutex.

	The templated class could be a CriticalSection, SpinLock, or anything else that
	provides enter() and exit() methods.

	e.g. @code

	CriticalSection myCriticalSection;

	for (;;)
	{
		const GenericScopedTryLock<CriticalSection> myScopedTryLock (myCriticalSection);

		// Unlike using a ScopedLock, this may fail to actually get the lock, so you
		// should test this with the isLocked() method before doing your thread-unsafe
		// action..
		if (myScopedTryLock.isLocked())
		{
		   ...do some stuff...
		}
		else
		{
			..our attempt at locking failed because another thread had already locked it..
		}

		// myCriticalSection gets unlocked here (if it was locked)
	}
	@endcode

	@see CriticalSection::tryEnter, GenericScopedLock, GenericScopedUnlock
*/
template <class LockType>
class GenericScopedTryLock
{
public:

	/** Creates a GenericScopedTryLock.

		As soon as it is created, this will attempt to acquire the lock, and when the
		GenericScopedTryLock is deleted, the lock will be released (if the lock was
		successfully acquired).

		Make sure this object is created and deleted by the same thread,
		otherwise there are no guarantees what will happen! Best just to use it
		as a local stack object, rather than creating one with the new() operator.
	*/
	inline explicit GenericScopedTryLock (const LockType& lock) noexcept
		: lock_ (lock), lockWasSuccessful (lock.tryEnter()) {}

	/** Destructor.

		The mutex will be unlocked (if it had been successfully locked) when the
		destructor is called.

		Make sure this object is created and deleted by the same thread,
		otherwise there are no guarantees what will happen!
	*/
	inline ~GenericScopedTryLock() noexcept         { if (lockWasSuccessful) lock_.exit(); }

	/** Returns true if the mutex was successfully locked. */
	bool isLocked() const noexcept                  { return lockWasSuccessful; }

private:

	const LockType& lock_;
	const bool lockWasSuccessful;

	JUCE_DECLARE_NON_COPYABLE (GenericScopedTryLock);
};

#endif   // __JUCE_SCOPEDLOCK_JUCEHEADER__

/*** End of inlined file: juce_ScopedLock.h ***/

/**
	A mutex class.

	A CriticalSection acts as a re-entrant mutex lock. The best way to lock and unlock
	one of these is by using RAII in the form of a local ScopedLock object - have a look
	through the codebase for many examples of how to do this.

	@see ScopedLock, ScopedTryLock, ScopedUnlock, SpinLock, ReadWriteLock, Thread, InterProcessLock
*/
class JUCE_API  CriticalSection
{
public:

	/** Creates a CriticalSection object. */
	CriticalSection() noexcept;

	/** Destructor.
		If the critical section is deleted whilst locked, any subsequent behaviour
		is unpredictable.
	*/
	~CriticalSection() noexcept;

	/** Acquires the lock.

		If the lock is already held by the caller thread, the method returns immediately.
		If the lock is currently held by another thread, this will wait until it becomes free.

		It's strongly recommended that you never call this method directly - instead use the
		ScopedLock class to manage the locking using an RAII pattern instead.

		@see exit, tryEnter, ScopedLock
	*/
	void enter() const noexcept;

	/** Attempts to lock this critical section without blocking.

		This method behaves identically to CriticalSection::enter, except that the caller thread
		does not wait if the lock is currently held by another thread but returns false immediately.

		@returns false if the lock is currently held by another thread, true otherwise.
		@see enter
	*/
	bool tryEnter() const noexcept;

	/** Releases the lock.

		If the caller thread hasn't got the lock, this can have unpredictable results.

		If the enter() method has been called multiple times by the thread, each
		call must be matched by a call to exit() before other threads will be allowed
		to take over the lock.

		@see enter, ScopedLock
	*/
	void exit() const noexcept;

	/** Provides the type of scoped lock to use with a CriticalSection. */
	typedef GenericScopedLock <CriticalSection>       ScopedLockType;

	/** Provides the type of scoped unlocker to use with a CriticalSection. */
	typedef GenericScopedUnlock <CriticalSection>     ScopedUnlockType;

	/** Provides the type of scoped try-locker to use with a CriticalSection. */
	typedef GenericScopedTryLock <CriticalSection>    ScopedTryLockType;

private:

   #if JUCE_WINDOWS
	// To avoid including windows.h in the public JUCE headers, we'll just allocate a
	// block of memory here that's big enough to be used internally as a windows critical
	// section structure.
	#if JUCE_64BIT
	 uint8 internal [44];
	#else
	 uint8 internal [24];
	#endif
   #else
	mutable pthread_mutex_t internal;
   #endif

	JUCE_DECLARE_NON_COPYABLE (CriticalSection);
};

/**
	A class that can be used in place of a real CriticalSection object, but which
	doesn't perform any locking.

	This is currently used by some templated classes, and most compilers should
	manage to optimise it out of existence.

	@see CriticalSection, Array, OwnedArray, ReferenceCountedArray
*/
class JUCE_API  DummyCriticalSection
{
public:
	inline DummyCriticalSection() noexcept      {}
	inline ~DummyCriticalSection() noexcept     {}

	inline void enter() const noexcept          {}
	inline bool tryEnter() const noexcept       { return true; }
	inline void exit() const noexcept           {}

	/** A dummy scoped-lock type to use with a dummy critical section. */
	struct ScopedLockType
	{
		ScopedLockType (const DummyCriticalSection&) noexcept {}
	};

	/** A dummy scoped-unlocker type to use with a dummy critical section. */
	typedef ScopedLockType ScopedUnlockType;

private:
	JUCE_DECLARE_NON_COPYABLE (DummyCriticalSection);
};

/**
	Automatically locks and unlocks a CriticalSection object.

	Use one of these as a local variable to provide RAII-based locking of a CriticalSection.

	e.g. @code

	CriticalSection myCriticalSection;

	for (;;)
	{
		const ScopedLock myScopedLock (myCriticalSection);
		// myCriticalSection is now locked

		...do some stuff...

		// myCriticalSection gets unlocked here.
	}
	@endcode

	@see CriticalSection, ScopedUnlock
*/
typedef CriticalSection::ScopedLockType  ScopedLock;

/**
	Automatically unlocks and re-locks a CriticalSection object.

	This is the reverse of a ScopedLock object - instead of locking the critical
	section for the lifetime of this object, it unlocks it.

	Make sure you don't try to unlock critical sections that aren't actually locked!

	e.g. @code

	CriticalSection myCriticalSection;

	for (;;)
	{
		const ScopedLock myScopedLock (myCriticalSection);
		// myCriticalSection is now locked

		... do some stuff with it locked ..

		while (xyz)
		{
			... do some stuff with it locked ..

			const ScopedUnlock unlocker (myCriticalSection);

			// myCriticalSection is now unlocked for the remainder of this block,
			// and re-locked at the end.

			...do some stuff with it unlocked ...
		}

		// myCriticalSection gets unlocked here.
	}
	@endcode

	@see CriticalSection, ScopedLock
*/
typedef CriticalSection::ScopedUnlockType  ScopedUnlock;

/**
	Automatically tries to lock and unlock a CriticalSection object.

	Use one of these as a local variable to control access to a CriticalSection.

	e.g. @code
	CriticalSection myCriticalSection;

	for (;;)
	{
		const ScopedTryLock myScopedTryLock (myCriticalSection);

		// Unlike using a ScopedLock, this may fail to actually get the lock, so you
		// should test this with the isLocked() method before doing your thread-unsafe
		// action..
		if (myScopedTryLock.isLocked())
		{
		   ...do some stuff...
		}
		else
		{
			..our attempt at locking failed because another thread had already locked it..
		}

		// myCriticalSection gets unlocked here (if it was locked)
	}
	@endcode

	@see CriticalSection::tryEnter, ScopedLock, ScopedUnlock, ScopedReadLock
*/
typedef CriticalSection::ScopedTryLockType  ScopedTryLock;

#endif   // __JUCE_CRITICALSECTION_JUCEHEADER__

/*** End of inlined file: juce_CriticalSection.h ***/

/**
	Holds a resizable array of primitive or copy-by-value objects.

	Examples of arrays are: Array<int>, Array<Rectangle> or Array<MyClass*>

	The Array class can be used to hold simple, non-polymorphic objects as well as primitive types - to
	do so, the class must fulfil these requirements:
	- it must have a copy constructor and assignment operator
	- it must be able to be relocated in memory by a memcpy without this causing any problems - so
	  objects whose functionality relies on external pointers or references to themselves can be used.

	You can of course have an array of pointers to any kind of object, e.g. Array <MyClass*>, but if
	you do this, the array doesn't take any ownership of the objects - see the OwnedArray class or the
	ReferenceCountedArray class for more powerful ways of holding lists of objects.

	For holding lists of strings, you can use Array\<String\>, but it's usually better to use the
	specialised class StringArray, which provides more useful functions.

	To make all the array's methods thread-safe, pass in "CriticalSection" as the templated
	TypeOfCriticalSectionToUse parameter, instead of the default DummyCriticalSection.

	@see OwnedArray, ReferenceCountedArray, StringArray, CriticalSection
*/
template <typename ElementType,
		  typename TypeOfCriticalSectionToUse = DummyCriticalSection>
class Array
{
private:
	typedef PARAMETER_TYPE (ElementType) ParameterType;

public:

	/** Creates an empty array. */
	Array() noexcept
	   : numUsed (0)
	{
	}

	/** Creates a copy of another array.
		@param other    the array to copy
	*/
	Array (const Array<ElementType, TypeOfCriticalSectionToUse>& other)
	{
		const ScopedLockType lock (other.getLock());
		numUsed = other.numUsed;
		data.setAllocatedSize (other.numUsed);

		for (int i = 0; i < numUsed; ++i)
			new (data.elements + i) ElementType (other.data.elements[i]);
	}

   #if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
	Array (Array<ElementType, TypeOfCriticalSectionToUse>&& other) noexcept
		: data (static_cast <ArrayAllocationBase<ElementType, TypeOfCriticalSectionToUse>&&> (other.data)),
		  numUsed (other.numUsed)
	{
		other.numUsed = 0;
	}
   #endif

	/** Initalises from a null-terminated C array of values.

		@param values   the array to copy from
	*/
	template <typename TypeToCreateFrom>
	explicit Array (const TypeToCreateFrom* values)
	   : numUsed (0)
	{
		while (*values != TypeToCreateFrom())
			add (*values++);
	}

	/** Initalises from a C array of values.

		@param values       the array to copy from
		@param numValues    the number of values in the array
	*/
	template <typename TypeToCreateFrom>
	Array (const TypeToCreateFrom* values, int numValues)
	   : numUsed (numValues)
	{
		data.setAllocatedSize (numValues);

		for (int i = 0; i < numValues; ++i)
			new (data.elements + i) ElementType (values[i]);
	}

	/** Destructor. */
	~Array()
	{
		deleteAllElements();
	}

	/** Copies another array.
		@param other    the array to copy
	*/
	Array& operator= (const Array& other)
	{
		if (this != &other)
		{
			Array<ElementType, TypeOfCriticalSectionToUse> otherCopy (other);
			swapWithArray (otherCopy);
		}

		return *this;
	}

   #if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
	Array& operator= (Array&& other) noexcept
	{
		data = static_cast <ArrayAllocationBase<ElementType, TypeOfCriticalSectionToUse>&&> (other.data);
		numUsed = other.numUsed;
		other.numUsed = 0;
		return *this;
	}
   #endif

	/** Compares this array to another one.
		Two arrays are considered equal if they both contain the same set of
		elements, in the same order.
		@param other    the other array to compare with
	*/
	template <class OtherArrayType>
	bool operator== (const OtherArrayType& other) const
	{
		const ScopedLockType lock (getLock());
		const typename OtherArrayType::ScopedLockType lock2 (other.getLock());

		if (numUsed != other.numUsed)
			return false;

		for (int i = numUsed; --i >= 0;)
			if (! (data.elements [i] == other.data.elements [i]))
				return false;

		return true;
	}

	/** Compares this array to another one.
		Two arrays are considered equal if they both contain the same set of
		elements, in the same order.
		@param other    the other array to compare with
	*/
	template <class OtherArrayType>
	bool operator!= (const OtherArrayType& other) const
	{
		return ! operator== (other);
	}

	/** Removes all elements from the array.
		This will remove all the elements, and free any storage that the array is
		using. To clear the array without freeing the storage, use the clearQuick()
		method instead.

		@see clearQuick
	*/
	void clear()
	{
		const ScopedLockType lock (getLock());
		deleteAllElements();
		data.setAllocatedSize (0);
		numUsed = 0;
	}

	/** Removes all elements from the array without freeing the array's allocated storage.

		@see clear
	*/
	void clearQuick()
	{
		const ScopedLockType lock (getLock());
		deleteAllElements();
		numUsed = 0;
	}

	/** Returns the current number of elements in the array.
	*/
	inline int size() const noexcept
	{
		return numUsed;
	}

	/** Returns one of the elements in the array.
		If the index passed in is beyond the range of valid elements, this
		will return zero.

		If you're certain that the index will always be a valid element, you
		can call getUnchecked() instead, which is faster.

		@param index    the index of the element being requested (0 is the first element in the array)
		@see getUnchecked, getFirst, getLast
	*/
	ElementType operator[] (const int index) const
	{
		const ScopedLockType lock (getLock());
		return isPositiveAndBelow (index, numUsed) ? data.elements [index]
												   : ElementType();
	}

	/** Returns one of the elements in the array, without checking the index passed in.

		Unlike the operator[] method, this will try to return an element without
		checking that the index is within the bounds of the array, so should only
		be used when you're confident that it will always be a valid index.

		@param index    the index of the element being requested (0 is the first element in the array)
		@see operator[], getFirst, getLast
	*/
	inline ElementType getUnchecked (const int index) const
	{
		const ScopedLockType lock (getLock());
		jassert (isPositiveAndBelow (index, numUsed));
		return data.elements [index];
	}

	/** Returns a direct reference to one of the elements in the array, without checking the index passed in.

		This is like getUnchecked, but returns a direct reference to the element, so that
		you can alter it directly. Obviously this can be dangerous, so only use it when
		absolutely necessary.

		@param index    the index of the element being requested (0 is the first element in the array)
		@see operator[], getFirst, getLast
	*/
	inline ElementType& getReference (const int index) const noexcept
	{
		const ScopedLockType lock (getLock());
		jassert (isPositiveAndBelow (index, numUsed));
		return data.elements [index];
	}

	/** Returns the first element in the array, or 0 if the array is empty.

		@see operator[], getUnchecked, getLast
	*/
	inline ElementType getFirst() const
	{
		const ScopedLockType lock (getLock());
		return (numUsed > 0) ? data.elements [0]
							 : ElementType();
	}

	/** Returns the last element in the array, or 0 if the array is empty.

		@see operator[], getUnchecked, getFirst
	*/
	inline ElementType getLast() const
	{
		const ScopedLockType lock (getLock());
		return (numUsed > 0) ? data.elements [numUsed - 1]
							 : ElementType();
	}

	/** Returns a pointer to the actual array data.
		This pointer will only be valid until the next time a non-const method
		is called on the array.
	*/
	inline ElementType* getRawDataPointer() noexcept
	{
		return data.elements;
	}

	/** Returns a pointer to the first element in the array.
		This method is provided for compatibility with standard C++ iteration mechanisms.
	*/
	inline ElementType* begin() const noexcept
	{
		return data.elements;
	}

	/** Returns a pointer to the element which follows the last element in the array.
		This method is provided for compatibility with standard C++ iteration mechanisms.
	*/
	inline ElementType* end() const noexcept
	{
		return data.elements + numUsed;
	}

	/** Finds the index of the first element which matches the value passed in.

		This will search the array for the given object, and return the index
		of its first occurrence. If the object isn't found, the method will return -1.

		@param elementToLookFor   the value or object to look for
		@returns                  the index of the object, or -1 if it's not found
	*/
	int indexOf (ParameterType elementToLookFor) const
	{
		const ScopedLockType lock (getLock());
		const ElementType* e = data.elements.getData();
		const ElementType* const end_ = e + numUsed;

		for (; e != end_; ++e)
			if (elementToLookFor == *e)
				return static_cast <int> (e - data.elements.getData());

		return -1;
	}

	/** Returns true if the array contains at least one occurrence of an object.

		@param elementToLookFor     the value or object to look for
		@returns                    true if the item is found
	*/
	bool contains (ParameterType elementToLookFor) const
	{
		const ScopedLockType lock (getLock());
		const ElementType* e = data.elements.getData();
		const ElementType* const end_ = e + numUsed;

		for (; e != end_; ++e)
			if (elementToLookFor == *e)
				return true;

		return false;
	}

	/** Appends a new element at the end of the array.

		@param newElement       the new object to add to the array
		@see set, insert, addIfNotAlreadyThere, addSorted, addUsingDefaultSort, addArray
	*/
	void add (ParameterType newElement)
	{
		const ScopedLockType lock (getLock());
		data.ensureAllocatedSize (numUsed + 1);
		new (data.elements + numUsed++) ElementType (newElement);
	}

	/** Inserts a new element into the array at a given position.

		If the index is less than 0 or greater than the size of the array, the
		element will be added to the end of the array.
		Otherwise, it will be inserted into the array, moving all the later elements
		along to make room.

		@param indexToInsertAt    the index at which the new element should be
								  inserted (pass in -1 to add it to the end)
		@param newElement         the new object to add to the array
		@see add, addSorted, addUsingDefaultSort, set
	*/
	void insert (int indexToInsertAt, ParameterType newElement)
	{
		const ScopedLockType lock (getLock());
		data.ensureAllocatedSize (numUsed + 1);

		if (isPositiveAndBelow (indexToInsertAt, numUsed))
		{
			ElementType* const insertPos = data.elements + indexToInsertAt;
			const int numberToMove = numUsed - indexToInsertAt;

			if (numberToMove > 0)
				memmove (insertPos + 1, insertPos, numberToMove * sizeof (ElementType));

			new (insertPos) ElementType (newElement);
			++numUsed;
		}
		else
		{
			new (data.elements + numUsed++) ElementType (newElement);
		}
	}

	/** Inserts multiple copies of an element into the array at a given position.

		If the index is less than 0 or greater than the size of the array, the
		element will be added to the end of the array.
		Otherwise, it will be inserted into the array, moving all the later elements
		along to make room.

		@param indexToInsertAt    the index at which the new element should be inserted
		@param newElement         the new object to add to the array
		@param numberOfTimesToInsertIt  how many copies of the value to insert
		@see insert, add, addSorted, set
	*/
	void insertMultiple (int indexToInsertAt, ParameterType newElement,
						 int numberOfTimesToInsertIt)
	{
		if (numberOfTimesToInsertIt > 0)
		{
			const ScopedLockType lock (getLock());
			data.ensureAllocatedSize (numUsed + numberOfTimesToInsertIt);
			ElementType* insertPos;

			if (isPositiveAndBelow (indexToInsertAt, numUsed))
			{
				insertPos = data.elements + indexToInsertAt;
				const int numberToMove = numUsed - indexToInsertAt;
				memmove (insertPos + numberOfTimesToInsertIt, insertPos, numberToMove * sizeof (ElementType));
			}
			else
			{
				insertPos = data.elements + numUsed;
			}

			numUsed += numberOfTimesToInsertIt;

			while (--numberOfTimesToInsertIt >= 0)
				new (insertPos++) ElementType (newElement);
		}
	}

	/** Inserts an array of values into this array at a given position.

		If the index is less than 0 or greater than the size of the array, the
		new elements will be added to the end of the array.
		Otherwise, they will be inserted into the array, moving all the later elements
		along to make room.

		@param indexToInsertAt      the index at which the first new element should be inserted
		@param newElements          the new values to add to the array
		@param numberOfElements     how many items are in the array
		@see insert, add, addSorted, set
	*/
	void insertArray (int indexToInsertAt,
					  const ElementType* newElements,
					  int numberOfElements)
	{
		if (numberOfElements > 0)
		{
			const ScopedLockType lock (getLock());
			data.ensureAllocatedSize (numUsed + numberOfElements);
			ElementType* insertPos;

			if (isPositiveAndBelow (indexToInsertAt, numUsed))
			{
				insertPos = data.elements + indexToInsertAt;
				const int numberToMove = numUsed - indexToInsertAt;
				memmove (insertPos + numberOfElements, insertPos, numberToMove * sizeof (ElementType));
			}
			else
			{
				insertPos = data.elements + numUsed;
			}

			numUsed += numberOfElements;

			while (--numberOfElements >= 0)
				new (insertPos++) ElementType (*newElements++);
		}
	}

	/** Appends a new element at the end of the array as long as the array doesn't
		already contain it.

		If the array already contains an element that matches the one passed in, nothing
		will be done.

		@param newElement   the new object to add to the array
	*/
	void addIfNotAlreadyThere (ParameterType newElement)
	{
		const ScopedLockType lock (getLock());

		if (! contains (newElement))
			add (newElement);
	}

	/** Replaces an element with a new value.

		If the index is less than zero, this method does nothing.
		If the index is beyond the end of the array, the item is added to the end of the array.

		@param indexToChange    the index whose value you want to change
		@param newValue         the new value to set for this index.
		@see add, insert
	*/
	void set (const int indexToChange, ParameterType newValue)
	{
		jassert (indexToChange >= 0);
		const ScopedLockType lock (getLock());

		if (isPositiveAndBelow (indexToChange, numUsed))
		{
			data.elements [indexToChange] = newValue;
		}
		else if (indexToChange >= 0)
		{
			data.ensureAllocatedSize (numUsed + 1);
			new (data.elements + numUsed++) ElementType (newValue);
		}
	}

	/** Replaces an element with a new value without doing any bounds-checking.

		This just sets a value directly in the array's internal storage, so you'd
		better make sure it's in range!

		@param indexToChange    the index whose value you want to change
		@param newValue         the new value to set for this index.
		@see set, getUnchecked
	*/
	void setUnchecked (const int indexToChange, ParameterType newValue)
	{
		const ScopedLockType lock (getLock());
		jassert (isPositiveAndBelow (indexToChange, numUsed));
		data.elements [indexToChange] = newValue;
	}

	/** Adds elements from an array to the end of this array.

		@param elementsToAdd        the array of elements to add
		@param numElementsToAdd     how many elements are in this other array
		@see add
	*/
	void addArray (const ElementType* elementsToAdd, int numElementsToAdd)
	{
		const ScopedLockType lock (getLock());

		if (numElementsToAdd > 0)
		{
			data.ensureAllocatedSize (numUsed + numElementsToAdd);

			while (--numElementsToAdd >= 0)
			{
				new (data.elements + numUsed) ElementType (*elementsToAdd++);
				++numUsed;
			}
		}
	}

	/** This swaps the contents of this array with those of another array.

		If you need to exchange two arrays, this is vastly quicker than using copy-by-value
		because it just swaps their internal pointers.
	*/
	void swapWithArray (Array& otherArray) noexcept
	{
		const ScopedLockType lock1 (getLock());
		const ScopedLockType lock2 (otherArray.getLock());

		data.swapWith (otherArray.data);
		swapVariables (numUsed, otherArray.numUsed);
	}

	/** Adds elements from another array to the end of this array.

		@param arrayToAddFrom       the array from which to copy the elements
		@param startIndex           the first element of the other array to start copying from
		@param numElementsToAdd     how many elements to add from the other array. If this
									value is negative or greater than the number of available elements,
									all available elements will be copied.
		@see add
	*/
	template <class OtherArrayType>
	void addArray (const OtherArrayType& arrayToAddFrom,
				   int startIndex = 0,
				   int numElementsToAdd = -1)
	{
		const typename OtherArrayType::ScopedLockType lock1 (arrayToAddFrom.getLock());

		{
			const ScopedLockType lock2 (getLock());

			if (startIndex < 0)
			{
				jassertfalse;
				startIndex = 0;
			}

			if (numElementsToAdd < 0 || startIndex + numElementsToAdd > arrayToAddFrom.size())
				numElementsToAdd = arrayToAddFrom.size() - startIndex;

			while (--numElementsToAdd >= 0)
				add (arrayToAddFrom.getUnchecked (startIndex++));
		}
	}

	/** This will enlarge or shrink the array to the given number of elements, by adding
		or removing items from its end.

		If the array is smaller than the given target size, empty elements will be appended
		until its size is as specified. If its size is larger than the target, items will be
		removed from its end to shorten it.
	*/
	void resize (const int targetNumItems)
	{
		jassert (targetNumItems >= 0);

		const int numToAdd = targetNumItems - numUsed;
		if (numToAdd > 0)
			insertMultiple (numUsed, ElementType(), numToAdd);
		else if (numToAdd < 0)
			removeRange (targetNumItems, -numToAdd);
	}

	/** Inserts a new element into the array, assuming that the array is sorted.

		This will use a comparator to find the position at which the new element
		should go. If the array isn't sorted, the behaviour of this
		method will be unpredictable.

		@param comparator   the comparator to use to compare the elements - see the sort()
							method for details about the form this object should take
		@param newElement   the new element to insert to the array
		@returns the index at which the new item was added
		@see addUsingDefaultSort, add, sort
	*/
	template <class ElementComparator>
	int addSorted (ElementComparator& comparator, ParameterType newElement)
	{
		const ScopedLockType lock (getLock());
		const int index = findInsertIndexInSortedArray (comparator, data.elements.getData(), newElement, 0, numUsed);
		insert (index, newElement);
		return index;
	}

	/** Inserts a new element into the array, assuming that the array is sorted.

		This will use the DefaultElementComparator class for sorting, so your ElementType
		must be suitable for use with that class. If the array isn't sorted, the behaviour of this
		method will be unpredictable.

		@param newElement   the new element to insert to the array
		@see addSorted, sort
	*/
	void addUsingDefaultSort (ParameterType newElement)
	{
		DefaultElementComparator <ElementType> comparator;
		addSorted (comparator, newElement);
	}

	/** Finds the index of an element in the array, assuming that the array is sorted.

		This will use a comparator to do a binary-chop to find the index of the given
		element, if it exists. If the array isn't sorted, the behaviour of this
		method will be unpredictable.

		@param comparator           the comparator to use to compare the elements - see the sort()
									method for details about the form this object should take
		@param elementToLookFor     the element to search for
		@returns                    the index of the element, or -1 if it's not found
		@see addSorted, sort
	*/
	template <class ElementComparator>
	int indexOfSorted (ElementComparator& comparator, ParameterType elementToLookFor) const
	{
		(void) comparator;  // if you pass in an object with a static compareElements() method, this
							// avoids getting warning messages about the parameter being unused

		const ScopedLockType lock (getLock());
		int start = 0;
		int end_ = numUsed;

		for (;;)
		{
			if (start >= end_)
			{
				return -1;
			}
			else if (comparator.compareElements (elementToLookFor, data.elements [start]) == 0)
			{
				return start;
			}
			else
			{
				const int halfway = (start + end_) >> 1;

				if (halfway == start)
					return -1;
				else if (comparator.compareElements (elementToLookFor, data.elements [halfway]) >= 0)
					start = halfway;
				else
					end_ = halfway;
			}
		}
	}

	/** Removes an element from the array.

		This will remove the element at a given index, and move back
		all the subsequent elements to close the gap.
		If the index passed in is out-of-range, nothing will happen.

		@param indexToRemove    the index of the element to remove
		@returns                the element that has been removed
		@see removeValue, removeRange
	*/
	ElementType remove (const int indexToRemove)
	{
		const ScopedLockType lock (getLock());

		if (isPositiveAndBelow (indexToRemove, numUsed))
		{
			--numUsed;

			ElementType* const e = data.elements + indexToRemove;
			ElementType removed (*e);
			e->~ElementType();
			const int numberToShift = numUsed - indexToRemove;

			if (numberToShift > 0)
				memmove (e, e + 1, numberToShift * sizeof (ElementType));

			if ((numUsed << 1) < data.numAllocated)
				minimiseStorageOverheads();

			return removed;
		}
		else
		{
			return ElementType();
		}
	}

	/** Removes an item from the array.

		This will remove the first occurrence of the given element from the array.
		If the item isn't found, no action is taken.

		@param valueToRemove   the object to try to remove
		@see remove, removeRange
	*/
	void removeValue (ParameterType valueToRemove)
	{
		const ScopedLockType lock (getLock());
		ElementType* const e = data.elements;

		for (int i = 0; i < numUsed; ++i)
		{
			if (valueToRemove == e[i])
			{
				remove (i);
				break;
			}
		}
	}

	/** Removes a range of elements from the array.

		This will remove a set of elements, starting from the given index,
		and move subsequent elements down to close the gap.

		If the range extends beyond the bounds of the array, it will
		be safely clipped to the size of the array.

		@param startIndex       the index of the first element to remove
		@param numberToRemove   how many elements should be removed
		@see remove, removeValue
	*/
	void removeRange (int startIndex, int numberToRemove)
	{
		const ScopedLockType lock (getLock());
		const int endIndex = jlimit (0, numUsed, startIndex + numberToRemove);
		startIndex = jlimit (0, numUsed, startIndex);

		if (endIndex > startIndex)
		{
			ElementType* const e = data.elements + startIndex;

			numberToRemove = endIndex - startIndex;
			for (int i = 0; i < numberToRemove; ++i)
				e[i].~ElementType();

			const int numToShift = numUsed - endIndex;
			if (numToShift > 0)
				memmove (e, e + numberToRemove, numToShift * sizeof (ElementType));

			numUsed -= numberToRemove;

			if ((numUsed << 1) < data.numAllocated)
				minimiseStorageOverheads();
		}
	}

	/** Removes the last n elements from the array.

		@param howManyToRemove   how many elements to remove from the end of the array
		@see remove, removeValue, removeRange
	*/
	void removeLast (int howManyToRemove = 1)
	{
		const ScopedLockType lock (getLock());

		if (howManyToRemove > numUsed)
			howManyToRemove = numUsed;

		for (int i = 1; i <= howManyToRemove; ++i)
			data.elements [numUsed - i].~ElementType();

		numUsed -= howManyToRemove;

		if ((numUsed << 1) < data.numAllocated)
			minimiseStorageOverheads();
	}

	/** Removes any elements which are also in another array.

		@param otherArray   the other array in which to look for elements to remove
		@see removeValuesNotIn, remove, removeValue, removeRange
	*/
	template <class OtherArrayType>
	void removeValuesIn (const OtherArrayType& otherArray)
	{
		const typename OtherArrayType::ScopedLockType lock1 (otherArray.getLock());
		const ScopedLockType lock2 (getLock());

		if (this == &otherArray)
		{
			clear();
		}
		else
		{
			if (otherArray.size() > 0)
			{
				for (int i = numUsed; --i >= 0;)
					if (otherArray.contains (data.elements [i]))
						remove (i);
			}
		}
	}

	/** Removes any elements which are not found in another array.

		Only elements which occur in this other array will be retained.

		@param otherArray    the array in which to look for elements NOT to remove
		@see removeValuesIn, remove, removeValue, removeRange
	*/
	template <class OtherArrayType>
	void removeValuesNotIn (const OtherArrayType& otherArray)
	{
		const typename OtherArrayType::ScopedLockType lock1 (otherArray.getLock());
		const ScopedLockType lock2 (getLock());

		if (this != &otherArray)
		{
			if (otherArray.size() <= 0)
			{
				clear();
			}
			else
			{
				for (int i = numUsed; --i >= 0;)
					if (! otherArray.contains (data.elements [i]))
						remove (i);
			}
		}
	}

	/** Swaps over two elements in the array.

		This swaps over the elements found at the two indexes passed in.
		If either index is out-of-range, this method will do nothing.

		@param index1   index of one of the elements to swap
		@param index2   index of the other element to swap
	*/
	void swap (const int index1,
			   const int index2)
	{
		const ScopedLockType lock (getLock());

		if (isPositiveAndBelow (index1, numUsed)
			 && isPositiveAndBelow (index2, numUsed))
		{
			swapVariables (data.elements [index1],
						   data.elements [index2]);
		}
	}

	/** Moves one of the values to a different position.

		This will move the value to a specified index, shuffling along
		any intervening elements as required.

		So for example, if you have the array { 0, 1, 2, 3, 4, 5 } then calling
		move (2, 4) would result in { 0, 1, 3, 4, 2, 5 }.

		@param currentIndex     the index of the value to be moved. If this isn't a
								valid index, then nothing will be done
		@param newIndex         the index at which you'd like this value to end up. If this
								is less than zero, the value will be moved to the end
								of the array
	*/
	void move (const int currentIndex, int newIndex) noexcept
	{
		if (currentIndex != newIndex)
		{
			const ScopedLockType lock (getLock());

			if (isPositiveAndBelow (currentIndex, numUsed))
			{
				if (! isPositiveAndBelow (newIndex, numUsed))
					newIndex = numUsed - 1;

				char tempCopy [sizeof (ElementType)];
				memcpy (tempCopy, data.elements + currentIndex, sizeof (ElementType));

				if (newIndex > currentIndex)
				{
					memmove (data.elements + currentIndex,
							 data.elements + currentIndex + 1,
							 (newIndex - currentIndex) * sizeof (ElementType));
				}
				else
				{
					memmove (data.elements + newIndex + 1,
							 data.elements + newIndex,
							 (currentIndex - newIndex) * sizeof (ElementType));
				}

				memcpy (data.elements + newIndex, tempCopy, sizeof (ElementType));
			}
		}
	}

	/** Reduces the amount of storage being used by the array.

		Arrays typically allocate slightly more storage than they need, and after
		removing elements, they may have quite a lot of unused space allocated.
		This method will reduce the amount of allocated storage to a minimum.
	*/
	void minimiseStorageOverheads()
	{
		const ScopedLockType lock (getLock());
		data.shrinkToNoMoreThan (numUsed);
	}

	/** Increases the array's internal storage to hold a minimum number of elements.

		Calling this before adding a large known number of elements means that
		the array won't have to keep dynamically resizing itself as the elements
		are added, and it'll therefore be more efficient.
	*/
	void ensureStorageAllocated (const int minNumElements)
	{
		const ScopedLockType lock (getLock());
		data.ensureAllocatedSize (minNumElements);
	}

	/** Sorts the elements in the array.

		This will use a comparator object to sort the elements into order. The object
		passed must have a method of the form:
		@code
		int compareElements (ElementType first, ElementType second);
		@endcode

		..and this method must return:
		  - a value of < 0 if the first comes before the second
		  - a value of 0 if the two objects are equivalent
		  - a value of > 0 if the second comes before the first

		To improve performance, the compareElements() method can be declared as static or const.

		@param comparator   the comparator to use for comparing elements.
		@param retainOrderOfEquivalentItems     if this is true, then items
							which the comparator says are equivalent will be
							kept in the order in which they currently appear
							in the array. This is slower to perform, but may
							be important in some cases. If it's false, a faster
							algorithm is used, but equivalent elements may be
							rearranged.

		@see addSorted, indexOfSorted, sortArray
	*/
	template <class ElementComparator>
	void sort (ElementComparator& comparator,
			   const bool retainOrderOfEquivalentItems = false) const
	{
		const ScopedLockType lock (getLock());
		(void) comparator;  // if you pass in an object with a static compareElements() method, this
							// avoids getting warning messages about the parameter being unused
		sortArray (comparator, data.elements.getData(), 0, size() - 1, retainOrderOfEquivalentItems);
	}

	/** Returns the CriticalSection that locks this array.
		To lock, you can call getLock().enter() and getLock().exit(), or preferably use
		an object of ScopedLockType as an RAII lock for it.
	*/
	inline const TypeOfCriticalSectionToUse& getLock() const noexcept      { return data; }

	/** Returns the type of scoped lock to use for locking this array */
	typedef typename TypeOfCriticalSectionToUse::ScopedLockType ScopedLockType;

private:

	ArrayAllocationBase <ElementType, TypeOfCriticalSectionToUse> data;
	int numUsed;

	inline void deleteAllElements() noexcept
	{
		for (int i = 0; i < numUsed; ++i)
			data.elements[i].~ElementType();
	}
};

#endif   // __JUCE_ARRAY_JUCEHEADER__

/*** End of inlined file: juce_Array.h ***/


#endif
#ifndef __JUCE_ARRAYALLOCATIONBASE_JUCEHEADER__

#endif
#ifndef __JUCE_DYNAMICOBJECT_JUCEHEADER__

/*** Start of inlined file: juce_DynamicObject.h ***/
#ifndef __JUCE_DYNAMICOBJECT_JUCEHEADER__
#define __JUCE_DYNAMICOBJECT_JUCEHEADER__


/*** Start of inlined file: juce_NamedValueSet.h ***/
#ifndef __JUCE_NAMEDVALUESET_JUCEHEADER__
#define __JUCE_NAMEDVALUESET_JUCEHEADER__


/*** Start of inlined file: juce_Variant.h ***/
#ifndef __JUCE_VARIANT_JUCEHEADER__
#define __JUCE_VARIANT_JUCEHEADER__


/*** Start of inlined file: juce_Identifier.h ***/
#ifndef __JUCE_IDENTIFIER_JUCEHEADER__
#define __JUCE_IDENTIFIER_JUCEHEADER__

class StringPool;

/**
	Represents a string identifier, designed for accessing properties by name.

	Identifier objects are very light and fast to copy, but slower to initialise
	from a string, so it's much faster to keep a static identifier object to refer
	to frequently-used names, rather than constructing them each time you need it.

	@see NamedPropertySet, ValueTree
*/
class JUCE_API  Identifier
{
public:
	/** Creates a null identifier. */
	Identifier() noexcept;

	/** Creates an identifier with a specified name.
		Because this name may need to be used in contexts such as script variables or XML
		tags, it must only contain ascii letters and digits, or the underscore character.
	*/
	Identifier (const char* name);

	/** Creates an identifier with a specified name.
		Because this name may need to be used in contexts such as script variables or XML
		tags, it must only contain ascii letters and digits, or the underscore character.
	*/
	Identifier (const String& name);

	/** Creates a copy of another identifier. */
	Identifier (const Identifier& other) noexcept;

	/** Creates a copy of another identifier. */
	Identifier& operator= (const Identifier& other) noexcept;

	/** Destructor */
	~Identifier();

	/** Compares two identifiers. This is a very fast operation. */
	inline bool operator== (const Identifier& other) const noexcept     { return name == other.name; }

	/** Compares two identifiers. This is a very fast operation. */
	inline bool operator!= (const Identifier& other) const noexcept     { return name != other.name; }

	/** Returns this identifier as a string. */
	String toString() const                                             { return name; }

	/** Returns this identifier's raw string pointer. */
	operator const String::CharPointerType() const noexcept             { return name; }

	/** Returns this identifier's raw string pointer. */
	const String::CharPointerType getCharPointer() const noexcept       { return name; }

	/** Checks a given string for characters that might not be valid in an Identifier.
		Since Identifiers are used as a script variables and XML attributes, they should only contain
		alphanumeric characters, underscores, or the '-' and ':' characters.
	*/
	static bool isValidIdentifier (const String& possibleIdentifier) noexcept;

private:

	String::CharPointerType name;

	static StringPool& getPool();
};

#endif   // __JUCE_IDENTIFIER_JUCEHEADER__

/*** End of inlined file: juce_Identifier.h ***/


/*** Start of inlined file: juce_OutputStream.h ***/
#ifndef __JUCE_OUTPUTSTREAM_JUCEHEADER__
#define __JUCE_OUTPUTSTREAM_JUCEHEADER__


/*** Start of inlined file: juce_NewLine.h ***/
#ifndef __JUCE_NEWLINE_JUCEHEADER__
#define __JUCE_NEWLINE_JUCEHEADER__

/** This class is used for represent a new-line character sequence.

	To write a new-line to a stream, you can use the predefined 'newLine' variable, e.g.
	@code
	myOutputStream << "Hello World" << newLine << newLine;
	@endcode

	The exact character sequence that will be used for the new-line can be set and
	retrieved with OutputStream::setNewLineString() and OutputStream::getNewLineString().
*/
class JUCE_API  NewLine
{
public:
	/** Returns the default new-line sequence that the library uses.
		@see OutputStream::setNewLineString()
	*/
	static const char* getDefault() noexcept        { return "\r\n"; }

	/** Returns the default new-line sequence that the library uses.
		@see getDefault()
	*/
	operator String() const                         { return getDefault(); }
};

/** A predefined object representing a new-line, which can be written to a string or stream.

	To write a new-line to a stream, you can use the predefined 'newLine' variable like this:
	@code
	myOutputStream << "Hello World" << newLine << newLine;
	@endcode
*/
extern NewLine newLine;

/** Writes a new-line sequence to a string.
	You can use the predefined object 'newLine' to invoke this, e.g.
	@code
	myString << "Hello World" << newLine << newLine;
	@endcode
*/
JUCE_API String& JUCE_CALLTYPE operator<< (String& string1, const NewLine&);

#endif   // __JUCE_NEWLINE_JUCEHEADER__

/*** End of inlined file: juce_NewLine.h ***/

class InputStream;
class MemoryBlock;
class File;

/**
	The base class for streams that write data to some kind of destination.

	Input and output streams are used throughout the library - subclasses can override
	some or all of the virtual functions to implement their behaviour.

	@see InputStream, MemoryOutputStream, FileOutputStream
*/
class JUCE_API  OutputStream
{
protected:

	OutputStream();

public:
	/** Destructor.

		Some subclasses might want to do things like call flush() during their
		destructors.
	*/
	virtual ~OutputStream();

	/** If the stream is using a buffer, this will ensure it gets written
		out to the destination. */
	virtual void flush() = 0;

	/** Tries to move the stream's output position.

		Not all streams will be able to seek to a new position - this will return
		false if it fails to work.

		@see getPosition
	*/
	virtual bool setPosition (int64 newPosition) = 0;

	/** Returns the stream's current position.

		@see setPosition
	*/
	virtual int64 getPosition() = 0;

	/** Writes a block of data to the stream.

		When creating a subclass of OutputStream, this is the only write method
		that needs to be overloaded - the base class has methods for writing other
		types of data which use this to do the work.

		@param dataToWrite      the target buffer to receive the data. This must not be null.
		@param numberOfBytes    the number of bytes to write. This must not be negative.
		@returns false if the write operation fails for some reason
	*/
	virtual bool write (const void* dataToWrite,
						int numberOfBytes) = 0;

	/** Writes a single byte to the stream.

		@see InputStream::readByte
	*/
	virtual void writeByte (char byte);

	/** Writes a boolean to the stream as a single byte.
		This is encoded as a binary byte (not as text) with a value of 1 or 0.
		@see InputStream::readBool
	*/
	virtual void writeBool (bool boolValue);

	/** Writes a 16-bit integer to the stream in a little-endian byte order.
		This will write two bytes to the stream: (value & 0xff), then (value >> 8).
		@see InputStream::readShort
	*/
	virtual void writeShort (short value);

	/** Writes a 16-bit integer to the stream in a big-endian byte order.
		This will write two bytes to the stream: (value >> 8), then (value & 0xff).
		@see InputStream::readShortBigEndian
	*/
	virtual void writeShortBigEndian (short value);

	/** Writes a 32-bit integer to the stream in a little-endian byte order.
		@see InputStream::readInt
	*/
	virtual void writeInt (int value);

	/** Writes a 32-bit integer to the stream in a big-endian byte order.
		@see InputStream::readIntBigEndian
	*/
	virtual void writeIntBigEndian (int value);

	/** Writes a 64-bit integer to the stream in a little-endian byte order.
		@see InputStream::readInt64
	*/
	virtual void writeInt64 (int64 value);

	/** Writes a 64-bit integer to the stream in a big-endian byte order.
		@see InputStream::readInt64BigEndian
	*/
	virtual void writeInt64BigEndian (int64 value);

	/** Writes a 32-bit floating point value to the stream in a binary format.
		The binary 32-bit encoding of the float is written as a little-endian int.
		@see InputStream::readFloat
	*/
	virtual void writeFloat (float value);

	/** Writes a 32-bit floating point value to the stream in a binary format.
		The binary 32-bit encoding of the float is written as a big-endian int.
		@see InputStream::readFloatBigEndian
	*/
	virtual void writeFloatBigEndian (float value);

	/** Writes a 64-bit floating point value to the stream in a binary format.
		The eight raw bytes of the double value are written out as a little-endian 64-bit int.
		@see InputStream::readDouble
	*/
	virtual void writeDouble (double value);

	/** Writes a 64-bit floating point value to the stream in a binary format.
		The eight raw bytes of the double value are written out as a big-endian 64-bit int.
		@see InputStream::readDoubleBigEndian
	*/
	virtual void writeDoubleBigEndian (double value);

	/** Writes a byte to the output stream a given number of times. */
	virtual void writeRepeatedByte (uint8 byte, int numTimesToRepeat);

	/** Writes a condensed binary encoding of a 32-bit integer.

		If you're storing a lot of integers which are unlikely to have very large values,
		this can save a lot of space, because values under 0xff will only take up 2 bytes,
		under 0xffff only 3 bytes, etc.

		The format used is: number of significant bytes + up to 4 bytes in little-endian order.

		@see InputStream::readCompressedInt
	*/
	virtual void writeCompressedInt (int value);

	/** Stores a string in the stream in a binary format.

		This isn't the method to use if you're trying to append text to the end of a
		text-file! It's intended for storing a string so that it can be retrieved later
		by InputStream::readString().

		It writes the string to the stream as UTF8, including the null termination character.

		For appending text to a file, instead use writeText, or operator<<

		@see InputStream::readString, writeText, operator<<
	*/
	virtual void writeString (const String& text);

	/** Writes a string of text to the stream.

		It can either write the text as UTF-8 or UTF-16, and can also add the UTF-16 byte-order-mark
		bytes (0xff, 0xfe) to indicate the endianness (these should only be used at the start
		of a file).

		The method also replaces '\\n' characters in the text with '\\r\\n'.
	*/
	virtual void writeText (const String& text,
							bool asUTF16,
							bool writeUTF16ByteOrderMark);

	/** Reads data from an input stream and writes it to this stream.

		@param source               the stream to read from
		@param maxNumBytesToWrite   the number of bytes to read from the stream (if this is
									less than zero, it will keep reading until the input
									is exhausted)
	*/
	virtual int writeFromInputStream (InputStream& source, int64 maxNumBytesToWrite);

	/** Sets the string that will be written to the stream when the writeNewLine()
		method is called.
		By default this will be set the the value of NewLine::getDefault().
	*/
	void setNewLineString (const String& newLineString);

	/** Returns the current new-line string that was set by setNewLineString(). */
	const String& getNewLineString() const noexcept         { return newLineString; }

private:

	String newLineString;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (OutputStream);
};

/** Writes a number to a stream as 8-bit characters in the default system encoding. */
OutputStream& JUCE_CALLTYPE operator<< (OutputStream& stream, int number);

/** Writes a number to a stream as 8-bit characters in the default system encoding. */
OutputStream& JUCE_CALLTYPE operator<< (OutputStream& stream, double number);

/** Writes a character to a stream. */
OutputStream& JUCE_CALLTYPE operator<< (OutputStream& stream, char character);

/** Writes a null-terminated text string to a stream. */
OutputStream& JUCE_CALLTYPE operator<< (OutputStream& stream, const char* text);

/** Writes a block of data from a MemoryBlock to a stream. */
OutputStream& JUCE_CALLTYPE operator<< (OutputStream& stream, const MemoryBlock& data);

/** Writes the contents of a file to a stream. */
OutputStream& JUCE_CALLTYPE operator<< (OutputStream& stream, const File& fileToRead);

/** Writes the complete contents of an input stream to an output stream. */
OutputStream& JUCE_CALLTYPE operator<< (OutputStream& stream, InputStream& streamToRead);

/** Writes a new-line to a stream.
	You can use the predefined symbol 'newLine' to invoke this, e.g.
	@code
	myOutputStream << "Hello World" << newLine << newLine;
	@endcode
	@see OutputStream::setNewLineString
*/
OutputStream& JUCE_CALLTYPE operator<< (OutputStream& stream, const NewLine&);

#endif   // __JUCE_OUTPUTSTREAM_JUCEHEADER__

/*** End of inlined file: juce_OutputStream.h ***/


/*** Start of inlined file: juce_InputStream.h ***/
#ifndef __JUCE_INPUTSTREAM_JUCEHEADER__
#define __JUCE_INPUTSTREAM_JUCEHEADER__

class MemoryBlock;

/** The base class for streams that read data.

	Input and output streams are used throughout the library - subclasses can override
	some or all of the virtual functions to implement their behaviour.

	@see OutputStream, MemoryInputStream, BufferedInputStream, FileInputStream
*/
class JUCE_API  InputStream
{
public:
	/** Destructor. */
	virtual ~InputStream()  {}

	/** Returns the total number of bytes available for reading in this stream.

		Note that this is the number of bytes available from the start of the
		stream, not from the current position.

		If the size of the stream isn't actually known, this may return -1.
	*/
	virtual int64 getTotalLength() = 0;

	/** Returns true if the stream has no more data to read. */
	virtual bool isExhausted() = 0;

	/** Reads some data from the stream into a memory buffer.

		This is the only read method that subclasses actually need to implement, as the
		InputStream base class implements the other read methods in terms of this one (although
		it's often more efficient for subclasses to implement them directly).

		@param destBuffer       the destination buffer for the data. This must not be null.
		@param maxBytesToRead   the maximum number of bytes to read - make sure the
								memory block passed in is big enough to contain this
								many bytes. This value must not be negative.

		@returns    the actual number of bytes that were read, which may be less than
					maxBytesToRead if the stream is exhausted before it gets that far
	*/
	virtual int read (void* destBuffer, int maxBytesToRead) = 0;

	/** Reads a byte from the stream.

		If the stream is exhausted, this will return zero.

		@see OutputStream::writeByte
	*/
	virtual char readByte();

	/** Reads a boolean from the stream.

		The bool is encoded as a single byte - 1 for true, 0 for false.

		If the stream is exhausted, this will return false.

		@see OutputStream::writeBool
	*/
	virtual bool readBool();

	/** Reads two bytes from the stream as a little-endian 16-bit value.

		If the next two bytes read are byte1 and byte2, this returns
		(byte1 | (byte2 << 8)).

		If the stream is exhausted partway through reading the bytes, this will return zero.

		@see OutputStream::writeShort, readShortBigEndian
	*/
	virtual short readShort();

	/** Reads two bytes from the stream as a little-endian 16-bit value.

		If the next two bytes read are byte1 and byte2, this returns
		(byte2 | (byte1 << 8)).

		If the stream is exhausted partway through reading the bytes, this will return zero.

		@see OutputStream::writeShortBigEndian, readShort
	*/
	virtual short readShortBigEndian();

	/** Reads four bytes from the stream as a little-endian 32-bit value.

		If the next four bytes are byte1 to byte4, this returns
		(byte1 | (byte2 << 8) | (byte3 << 16) | (byte4 << 24)).

		If the stream is exhausted partway through reading the bytes, this will return zero.

		@see OutputStream::writeInt, readIntBigEndian
	*/
	virtual int readInt();

	/** Reads four bytes from the stream as a big-endian 32-bit value.

		If the next four bytes are byte1 to byte4, this returns
		(byte4 | (byte3 << 8) | (byte2 << 16) | (byte1 << 24)).

		If the stream is exhausted partway through reading the bytes, this will return zero.

		@see OutputStream::writeIntBigEndian, readInt
	*/
	virtual int readIntBigEndian();

	/** Reads eight bytes from the stream as a little-endian 64-bit value.

		If the next eight bytes are byte1 to byte8, this returns
		(byte1 | (byte2 << 8) | (byte3 << 16) | (byte4 << 24) | (byte5 << 32) | (byte6 << 40) | (byte7 << 48) | (byte8 << 56)).

		If the stream is exhausted partway through reading the bytes, this will return zero.

		@see OutputStream::writeInt64, readInt64BigEndian
	*/
	virtual int64 readInt64();

	/** Reads eight bytes from the stream as a big-endian 64-bit value.

		If the next eight bytes are byte1 to byte8, this returns
		(byte8 | (byte7 << 8) | (byte6 << 16) | (byte5 << 24) | (byte4 << 32) | (byte3 << 40) | (byte2 << 48) | (byte1 << 56)).

		If the stream is exhausted partway through reading the bytes, this will return zero.

		@see OutputStream::writeInt64BigEndian, readInt64
	*/
	virtual int64 readInt64BigEndian();

	/** Reads four bytes as a 32-bit floating point value.

		The raw 32-bit encoding of the float is read from the stream as a little-endian int.

		If the stream is exhausted partway through reading the bytes, this will return zero.

		@see OutputStream::writeFloat, readDouble
	*/
	virtual float readFloat();

	/** Reads four bytes as a 32-bit floating point value.

		The raw 32-bit encoding of the float is read from the stream as a big-endian int.

		If the stream is exhausted partway through reading the bytes, this will return zero.

		@see OutputStream::writeFloatBigEndian, readDoubleBigEndian
	*/
	virtual float readFloatBigEndian();

	/** Reads eight bytes as a 64-bit floating point value.

		The raw 64-bit encoding of the double is read from the stream as a little-endian int64.

		If the stream is exhausted partway through reading the bytes, this will return zero.

		@see OutputStream::writeDouble, readFloat
	*/
	virtual double readDouble();

	/** Reads eight bytes as a 64-bit floating point value.

		The raw 64-bit encoding of the double is read from the stream as a big-endian int64.

		If the stream is exhausted partway through reading the bytes, this will return zero.

		@see OutputStream::writeDoubleBigEndian, readFloatBigEndian
	*/
	virtual double readDoubleBigEndian();

	/** Reads an encoded 32-bit number from the stream using a space-saving compressed format.

		For small values, this is more space-efficient than using readInt() and OutputStream::writeInt()

		The format used is: number of significant bytes + up to 4 bytes in little-endian order.

		@see OutputStream::writeCompressedInt()
	*/
	virtual int readCompressedInt();

	/** Reads a UTF8 string from the stream, up to the next linefeed or carriage return.

		This will read up to the next "\n" or "\r\n" or end-of-stream.

		After this call, the stream's position will be left pointing to the next character
		following the line-feed, but the linefeeds aren't included in the string that
		is returned.
	*/
	virtual String readNextLine();

	/** Reads a zero-terminated UTF8 string from the stream.

		This will read characters from the stream until it hits a zero character or
		end-of-stream.

		@see OutputStream::writeString, readEntireStreamAsString
	*/
	virtual String readString();

	/** Tries to read the whole stream and turn it into a string.

		This will read from the stream's current position until the end-of-stream, and
		will try to make an educated guess about whether it's unicode or an 8-bit encoding.
	*/
	virtual String readEntireStreamAsString();

	/** Reads from the stream and appends the data to a MemoryBlock.

		@param destBlock            the block to append the data onto
		@param maxNumBytesToRead    if this is a positive value, it sets a limit to the number
									of bytes that will be read - if it's negative, data
									will be read until the stream is exhausted.
		@returns the number of bytes that were added to the memory block
	*/
	virtual int readIntoMemoryBlock (MemoryBlock& destBlock,
									 ssize_t maxNumBytesToRead = -1);

	/** Returns the offset of the next byte that will be read from the stream.

		@see setPosition
	*/
	virtual int64 getPosition() = 0;

	/** Tries to move the current read position of the stream.

		The position is an absolute number of bytes from the stream's start.

		Some streams might not be able to do this, in which case they should do
		nothing and return false. Others might be able to manage it by resetting
		themselves and skipping to the correct position, although this is
		obviously a bit slow.

		@returns  true if the stream manages to reposition itself correctly
		@see getPosition
	*/
	virtual bool setPosition (int64 newPosition) = 0;

	/** Reads and discards a number of bytes from the stream.

		Some input streams might implement this efficiently, but the base
		class will just keep reading data until the requisite number of bytes
		have been done.
	*/
	virtual void skipNextBytes (int64 numBytesToSkip);

protected:

	InputStream() noexcept {}

private:
	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (InputStream);
};

#endif   // __JUCE_INPUTSTREAM_JUCEHEADER__

/*** End of inlined file: juce_InputStream.h ***/

#ifndef DOXYGEN
 class ReferenceCountedObject;
 class DynamicObject;
#endif

/**
	A variant class, that can be used to hold a range of primitive values.

	A var object can hold a range of simple primitive values, strings, or
	any kind of ReferenceCountedObject. The var class is intended to act like
	the kind of values used in dynamic scripting languages.

	You can save/load var objects either in a small, proprietary binary format
	using writeToStream()/readFromStream(), or as JSON by using the JSON class.

	@see JSON, DynamicObject
*/
class JUCE_API  var
{
public:

	typedef const var (DynamicObject::*MethodFunction) (const var* arguments, int numArguments);
	typedef Identifier identifier;

	/** Creates a void variant. */
	var() noexcept;

	/** Destructor. */
	~var() noexcept;

	/** A static var object that can be used where you need an empty variant object. */
	static const var null;

	var (const var& valueToCopy);
	var (int value) noexcept;
	var (int64 value) noexcept;
	var (bool value) noexcept;
	var (double value) noexcept;
	var (const char* value);
	var (const wchar_t* value);
	var (const String& value);
	var (const Array<var>& value);
	var (ReferenceCountedObject* object);
	var (MethodFunction method) noexcept;

	var& operator= (const var& valueToCopy);
	var& operator= (int value);
	var& operator= (int64 value);
	var& operator= (bool value);
	var& operator= (double value);
	var& operator= (const char* value);
	var& operator= (const wchar_t* value);
	var& operator= (const String& value);
	var& operator= (const Array<var>& value);
	var& operator= (ReferenceCountedObject* object);
	var& operator= (MethodFunction method);

   #if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
	var (var&& other) noexcept;
	var (String&& value);
	var& operator= (var&& other) noexcept;
	var& operator= (String&& value);
   #endif

	void swapWith (var& other) noexcept;

	operator int() const noexcept;
	operator int64() const noexcept;
	operator bool() const noexcept;
	operator float() const noexcept;
	operator double() const noexcept;
	operator String() const;
	String toString() const;
	Array<var>* getArray() const noexcept;
	ReferenceCountedObject* getObject() const noexcept;
	DynamicObject* getDynamicObject() const noexcept;

	bool isVoid() const noexcept;
	bool isInt() const noexcept;
	bool isInt64() const noexcept;
	bool isBool() const noexcept;
	bool isDouble() const noexcept;
	bool isString() const noexcept;
	bool isObject() const noexcept;
	bool isArray() const noexcept;
	bool isMethod() const noexcept;

	/** Returns true if this var has the same value as the one supplied.
		Note that this ignores the type, so a string var "123" and an integer var with the
		value 123 are considered to be equal.
		@see equalsWithSameType
	*/
	bool equals (const var& other) const noexcept;

	/** Returns true if this var has the same value and type as the one supplied.
		This differs from equals() because e.g. "123" and 123 will be considered different.
		@see equals
	*/
	bool equalsWithSameType (const var& other) const noexcept;

	/** If the var is an array, this returns the number of elements.
		If the var isn't actually an array, this will return 0.
	*/
	int size() const;

	/** If the var is an array, this can be used to return one of its elements.
		To call this method, you must make sure that the var is actually an array, and
		that the index is a valid number. If these conditions aren't met, behaviour is
		undefined.
		For more control over the array's contents, you can call getArray() and manipulate
		it directly as an Array\<var\>.
	*/
	const var& operator[] (int arrayIndex) const;

	/** If the var is an array, this can be used to return one of its elements.
		To call this method, you must make sure that the var is actually an array, and
		that the index is a valid number. If these conditions aren't met, behaviour is
		undefined.
		For more control over the array's contents, you can call getArray() and manipulate
		it directly as an Array\<var\>.
	*/
	var& operator[] (int arrayIndex);

	/** Appends an element to the var, converting it to an array if it isn't already one.
		If the var isn't an array, it will be converted to one, and if its value was non-void,
		this value will be kept as the first element of the new array. The parameter value
		will then be appended to it.
		For more control over the array's contents, you can call getArray() and manipulate
		it directly as an Array\<var\>.
	*/
	void append (const var& valueToAppend);

	/** Inserts an element to the var, converting it to an array if it isn't already one.
		If the var isn't an array, it will be converted to one, and if its value was non-void,
		this value will be kept as the first element of the new array. The parameter value
		will then be inserted into it.
		For more control over the array's contents, you can call getArray() and manipulate
		it directly as an Array\<var\>.
	*/
	void insert (int index, const var& value);

	/** If the var is an array, this removes one of its elements.
		If the index is out-of-range or the var isn't an array, nothing will be done.
		For more control over the array's contents, you can call getArray() and manipulate
		it directly as an Array\<var\>.
	*/
	void remove (int index);

	/** Treating the var as an array, this resizes it to contain the specified number of elements.
		If the var isn't an array, it will be converted to one, and if its value was non-void,
		this value will be kept as the first element of the new array before resizing.
		For more control over the array's contents, you can call getArray() and manipulate
		it directly as an Array\<var\>.
	*/
	void resize (int numArrayElementsWanted);

	/** If the var is an array, this searches it for the first occurrence of the specified value,
		and returns its index.
		If the var isn't an array, or if the value isn't found, this returns -1.
	*/
	int indexOf (const var& value) const;

	/** If this variant is an object, this returns one of its properties. */
	var operator[] (const Identifier& propertyName) const;
	/** If this variant is an object, this returns one of its properties. */
	var operator[] (const char* propertyName) const;
	/** If this variant is an object, this returns one of its properties, or a default
		fallback value if the property is not set. */
	var getProperty (const Identifier& propertyName, const var& defaultReturnValue) const;

	/** If this variant is an object, this invokes one of its methods with no arguments. */
	var call (const Identifier& method) const;
	/** If this variant is an object, this invokes one of its methods with one argument. */
	var call (const Identifier& method, const var& arg1) const;
	/** If this variant is an object, this invokes one of its methods with 2 arguments. */
	var call (const Identifier& method, const var& arg1, const var& arg2) const;
	/** If this variant is an object, this invokes one of its methods with 3 arguments. */
	var call (const Identifier& method, const var& arg1, const var& arg2, const var& arg3);
	/** If this variant is an object, this invokes one of its methods with 4 arguments. */
	var call (const Identifier& method, const var& arg1, const var& arg2, const var& arg3, const var& arg4) const;
	/** If this variant is an object, this invokes one of its methods with 5 arguments. */
	var call (const Identifier& method, const var& arg1, const var& arg2, const var& arg3, const var& arg4, const var& arg5) const;
	/** If this variant is an object, this invokes one of its methods with a list of arguments. */
	var invoke (const Identifier& method, const var* arguments, int numArguments) const;

	/** Writes a binary representation of this value to a stream.
		The data can be read back later using readFromStream().
		@see JSON
	*/
	void writeToStream (OutputStream& output) const;

	/** Reads back a stored binary representation of a value.
		The data in the stream must have been written using writeToStream(), or this
		will have unpredictable results.
		@see JSON
	*/
	static var readFromStream (InputStream& input);

private:

	class VariantType;         friend class VariantType;
	class VariantType_Void;    friend class VariantType_Void;
	class VariantType_Int;     friend class VariantType_Int;
	class VariantType_Int64;   friend class VariantType_Int64;
	class VariantType_Double;  friend class VariantType_Double;
	class VariantType_Bool;    friend class VariantType_Bool;
	class VariantType_String;  friend class VariantType_String;
	class VariantType_Object;  friend class VariantType_Object;
	class VariantType_Array;   friend class VariantType_Array;
	class VariantType_Method;  friend class VariantType_Method;

	union ValueUnion
	{
		int intValue;
		int64 int64Value;
		bool boolValue;
		double doubleValue;
		char stringValue [sizeof (String)];
		ReferenceCountedObject* objectValue;
		Array<var>* arrayValue;
		MethodFunction methodValue;
	};

	const VariantType* type;
	ValueUnion value;

	Array<var>* convertToArray();
	friend class DynamicObject;
	var invokeMethod (DynamicObject*, const var*, int) const;
};

/** Compares the values of two var objects, using the var::equals() comparison. */
bool operator== (const var& v1, const var& v2) noexcept;
/** Compares the values of two var objects, using the var::equals() comparison. */
bool operator!= (const var& v1, const var& v2) noexcept;
bool operator== (const var& v1, const String& v2);
bool operator!= (const var& v1, const String& v2);
bool operator== (const var& v1, const char* v2);
bool operator!= (const var& v1, const char* v2);

#endif   // __JUCE_VARIANT_JUCEHEADER__

/*** End of inlined file: juce_Variant.h ***/


/*** Start of inlined file: juce_LinkedListPointer.h ***/
#ifndef __JUCE_LINKEDLISTPOINTER_JUCEHEADER__
#define __JUCE_LINKEDLISTPOINTER_JUCEHEADER__

/**
	Helps to manipulate singly-linked lists of objects.

	For objects that are designed to contain a pointer to the subsequent item in the
	list, this class contains methods to deal with the list. To use it, the ObjectType
	class that it points to must contain a LinkedListPointer called nextListItem, e.g.

	@code
	struct MyObject
	{
		int x, y, z;

		// A linkable object must contain a member with this name and type, which must be
		// accessible by the LinkedListPointer class. (This doesn't mean it has to be public -
		// you could make your class a friend of a LinkedListPointer<MyObject> instead).
		LinkedListPointer<MyObject> nextListItem;
	};

	LinkedListPointer<MyObject> myList;
	myList.append (new MyObject());
	myList.append (new MyObject());

	int numItems = myList.size(); // returns 2
	MyObject* lastInList = myList.getLast();
	@endcode
*/
template <class ObjectType>
class LinkedListPointer
{
public:

	/** Creates a null pointer to an empty list. */
	LinkedListPointer() noexcept
		: item (nullptr)
	{
	}

	/** Creates a pointer to a list whose head is the item provided. */
	explicit LinkedListPointer (ObjectType* const headItem) noexcept
		: item (headItem)
	{
	}

	/** Sets this pointer to point to a new list. */
	LinkedListPointer& operator= (ObjectType* const newItem) noexcept
	{
		item = newItem;
		return *this;
	}

   #if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
	LinkedListPointer (LinkedListPointer&& other) noexcept
		: item (other.item)
	{
		other.item = nullptr;
	}

	LinkedListPointer& operator= (LinkedListPointer&& other) noexcept
	{
		jassert (this != &other); // hopefully the compiler should make this situation impossible!

		item = other.item;
		other.item = nullptr;
		return *this;
	}
   #endif

	/** Returns the item which this pointer points to. */
	inline operator ObjectType*() const noexcept
	{
		return item;
	}

	/** Returns the item which this pointer points to. */
	inline ObjectType* get() const noexcept
	{
		return item;
	}

	/** Returns the last item in the list which this pointer points to.
		This will iterate the list and return the last item found. Obviously the speed
		of this operation will be proportional to the size of the list. If the list is
		empty the return value will be this object.
		If you're planning on appending a number of items to your list, it's much more
		efficient to use the Appender class than to repeatedly call getLast() to find the end.
	*/
	LinkedListPointer& getLast() noexcept
	{
		LinkedListPointer* l = this;

		while (l->item != nullptr)
			l = &(l->item->nextListItem);

		return *l;
	}

	/** Returns the number of items in the list.
		Obviously with a simple linked list, getting the size involves iterating the list, so
		this can be a lengthy operation - be careful when using this method in your code.
	*/
	int size() const noexcept
	{
		int total = 0;

		for (ObjectType* i = item; i != nullptr; i = i->nextListItem)
			++total;

		return total;
	}

	/** Returns the item at a given index in the list.
		Since the only way to find an item is to iterate the list, this operation can obviously
		be slow, depending on its size, so you should be careful when using this in algorithms.
	*/
	LinkedListPointer& operator[] (int index) noexcept
	{
		LinkedListPointer* l = this;

		while (--index >= 0 && l->item != nullptr)
			l = &(l->item->nextListItem);

		return *l;
	}

	/** Returns the item at a given index in the list.
		Since the only way to find an item is to iterate the list, this operation can obviously
		be slow, depending on its size, so you should be careful when using this in algorithms.
	*/
	const LinkedListPointer& operator[] (int index) const noexcept
	{
		const LinkedListPointer* l = this;

		while (--index >= 0 && l->item != nullptr)
			l = &(l->item->nextListItem);

		return *l;
	}

	/** Returns true if the list contains the given item. */
	bool contains (const ObjectType* const itemToLookFor) const noexcept
	{
		for (ObjectType* i = item; i != nullptr; i = i->nextListItem)
			if (itemToLookFor == i)
				return true;

		return false;
	}

	/** Inserts an item into the list, placing it before the item that this pointer
		currently points to.
	*/
	void insertNext (ObjectType* const newItem)
	{
		jassert (newItem != nullptr);
		jassert (newItem->nextListItem == nullptr);
		newItem->nextListItem = item;
		item = newItem;
	}

	/** Inserts an item at a numeric index in the list.
		Obviously this will involve iterating the list to find the item at the given index,
		so be careful about the impact this may have on execution time.
	*/
	void insertAtIndex (int index, ObjectType* newItem)
	{
		jassert (newItem != nullptr);
		LinkedListPointer* l = this;

		while (index != 0 && l->item != nullptr)
		{
			l = &(l->item->nextListItem);
			--index;
		}

		l->insertNext (newItem);
	}

	/** Replaces the object that this pointer points to, appending the rest of the list to
		the new object, and returning the old one.
	*/
	ObjectType* replaceNext (ObjectType* const newItem) noexcept
	{
		jassert (newItem != nullptr);
		jassert (newItem->nextListItem == nullptr);

		ObjectType* const oldItem = item;
		item = newItem;
		item->nextListItem = oldItem->nextListItem.item;
		oldItem->nextListItem = (ObjectType*) 0;
		return oldItem;
	}

	/** Adds an item to the end of the list.

		This operation involves iterating the whole list, so can be slow - if you need to
		append a number of items to your list, it's much more efficient to use the Appender
		class than to repeatedly call append().
	*/
	void append (ObjectType* const newItem)
	{
		getLast().item = newItem;
	}

	/** Creates copies of all the items in another list and adds them to this one.
		This will use the ObjectType's copy constructor to try to create copies of each
		item in the other list, and appends them to this list.
	*/
	void addCopyOfList (const LinkedListPointer& other)
	{
		LinkedListPointer* insertPoint = this;

		for (ObjectType* i = other.item; i != nullptr; i = i->nextListItem)
		{
			insertPoint->insertNext (new ObjectType (*i));
			insertPoint = &(insertPoint->item->nextListItem);
		}
	}

	/** Removes the head item from the list.
		This won't delete the object that is removed, but returns it, so the caller can
		delete it if necessary.
	*/
	ObjectType* removeNext() noexcept
	{
		ObjectType* const oldItem = item;

		if (oldItem != nullptr)
		{
			item = oldItem->nextListItem;
			oldItem->nextListItem = (ObjectType*) 0;
		}

		return oldItem;
	}

	/** Removes a specific item from the list.
		Note that this will not delete the item, it simply unlinks it from the list.
	*/
	void remove (ObjectType* const itemToRemove)
	{
		LinkedListPointer* const l = findPointerTo (itemToRemove);

		if (l != nullptr)
			l->removeNext();
	}

	/** Iterates the list, calling the delete operator on all of its elements and
		leaving this pointer empty.
	*/
	void deleteAll()
	{
		while (item != nullptr)
		{
			ObjectType* const oldItem = item;
			item = oldItem->nextListItem;
			delete oldItem;
		}
	}

	/** Finds a pointer to a given item.
		If the item is found in the list, this returns the pointer that points to it. If
		the item isn't found, this returns null.
	*/
	LinkedListPointer* findPointerTo (ObjectType* const itemToLookFor) noexcept
	{
		LinkedListPointer* l = this;

		while (l->item != nullptr)
		{
			if (l->item == itemToLookFor)
				return l;

			l = &(l->item->nextListItem);
		}

		return nullptr;
	}

	/** Copies the items in the list to an array.
		The destArray must contain enough elements to hold the entire list - no checks are
		made for this!
	*/
	void copyToArray (ObjectType** destArray) const noexcept
	{
		jassert (destArray != nullptr);

		for (ObjectType* i = item; i != nullptr; i = i->nextListItem)
			*destArray++ = i;
	}

	/** Swaps this pointer with another one */
	void swapWith (LinkedListPointer& other) noexcept
	{
		std::swap (item, other.item);
	}

	/**
		Allows efficient repeated insertions into a list.

		You can create an Appender object which points to the last element in your
		list, and then repeatedly call Appender::append() to add items to the end
		of the list in O(1) time.
	*/
	class Appender
	{
	public:
		/** Creates an appender which will add items to the given list.
		*/
		Appender (LinkedListPointer& endOfListPointer) noexcept
			: endOfList (&endOfListPointer)
		{
			// This can only be used to add to the end of a list.
			jassert (endOfListPointer.item == nullptr);
		}

		/** Appends an item to the list. */
		void append (ObjectType* const newItem) noexcept
		{
			*endOfList = newItem;
			endOfList = &(newItem->nextListItem);
		}

	private:
		LinkedListPointer* endOfList;

		JUCE_DECLARE_NON_COPYABLE (Appender);
	};

private:

	ObjectType* item;

	JUCE_DECLARE_NON_COPYABLE (LinkedListPointer);
};

#endif   // __JUCE_LINKEDLISTPOINTER_JUCEHEADER__

/*** End of inlined file: juce_LinkedListPointer.h ***/

class XmlElement;
#ifndef DOXYGEN
 class JSONFormatter;
#endif

/** Holds a set of named var objects.

	This can be used as a basic structure to hold a set of var object, which can
	be retrieved by using their identifier.
*/
class JUCE_API  NamedValueSet
{
public:
	/** Creates an empty set. */
	NamedValueSet() noexcept;

	/** Creates a copy of another set. */
	NamedValueSet (const NamedValueSet& other);

	/** Replaces this set with a copy of another set. */
	NamedValueSet& operator= (const NamedValueSet& other);

   #if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
	NamedValueSet (NamedValueSet&& other) noexcept;
	NamedValueSet& operator= (NamedValueSet&& other) noexcept;
   #endif

	/** Destructor. */
	~NamedValueSet();

	bool operator== (const NamedValueSet& other) const;
	bool operator!= (const NamedValueSet& other) const;

	/** Returns the total number of values that the set contains. */
	int size() const noexcept;

	/** Returns the value of a named item.
		If the name isn't found, this will return a void variant.
		@see getProperty
	*/
	const var& operator[] (const Identifier& name) const;

	/** Tries to return the named value, but if no such value is found, this will
		instead return the supplied default value.
	*/
	var getWithDefault (const Identifier& name, const var& defaultReturnValue) const;

	/** Changes or adds a named value.
		@returns    true if a value was changed or added; false if the
					value was already set the the value passed-in.
	*/
	bool set (const Identifier& name, const var& newValue);

   #if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
	/** Changes or adds a named value.
		@returns    true if a value was changed or added; false if the
					value was already set the the value passed-in.
	*/
	bool set (const Identifier& name, var&& newValue);
   #endif

	/** Returns true if the set contains an item with the specified name. */
	bool contains (const Identifier& name) const;

	/** Removes a value from the set.
		@returns    true if a value was removed; false if there was no value
					with the name that was given.
	*/
	bool remove (const Identifier& name);

	/** Returns the name of the value at a given index.
		The index must be between 0 and size() - 1.
	*/
	const Identifier getName (int index) const;

	/** Returns the value of the item at a given index.
		The index must be between 0 and size() - 1.
	*/
	const var& getValueAt (int index) const;

	/** Removes all values. */
	void clear();

	/** Returns a pointer to the var that holds a named value, or null if there is
		no value with this name.

		Do not use this method unless you really need access to the internal var object
		for some reason - for normal reading and writing always prefer operator[]() and set().
	*/
	var* getVarPointer (const Identifier& name) const noexcept;

	/** Sets properties to the values of all of an XML element's attributes. */
	void setFromXmlAttributes (const XmlElement& xml);

	/** Sets attributes in an XML element corresponding to each of this object's
		properties.
	*/
	void copyToXmlAttributes (XmlElement& xml) const;

private:

	class NamedValue
	{
	public:
		NamedValue() noexcept;
		NamedValue (const NamedValue&);
		NamedValue (const Identifier& name, const var& value);
		NamedValue& operator= (const NamedValue&);
	   #if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
		NamedValue (NamedValue&&) noexcept;
		NamedValue (const Identifier& name, var&& value);
		NamedValue& operator= (NamedValue&&) noexcept;
	   #endif
		bool operator== (const NamedValue& other) const noexcept;

		LinkedListPointer<NamedValue> nextListItem;
		Identifier name;
		var value;

	private:
		JUCE_LEAK_DETECTOR (NamedValue);
	};

	friend class LinkedListPointer<NamedValue>;
	LinkedListPointer<NamedValue> values;

	friend class JSONFormatter;
};

#endif   // __JUCE_NAMEDVALUESET_JUCEHEADER__

/*** End of inlined file: juce_NamedValueSet.h ***/


/*** Start of inlined file: juce_ReferenceCountedObject.h ***/
#ifndef __JUCE_REFERENCECOUNTEDOBJECT_JUCEHEADER__
#define __JUCE_REFERENCECOUNTEDOBJECT_JUCEHEADER__

/**
	Adds reference-counting to an object.

	To add reference-counting to a class, derive it from this class, and
	use the ReferenceCountedObjectPtr class to point to it.

	e.g. @code
	class MyClass : public ReferenceCountedObject
	{
		void foo();

		// This is a neat way of declaring a typedef for a pointer class,
		// rather than typing out the full templated name each time..
		typedef ReferenceCountedObjectPtr<MyClass> Ptr;
	};

	MyClass::Ptr p = new MyClass();
	MyClass::Ptr p2 = p;
	p = nullptr;
	p2->foo();
	@endcode

	Once a new ReferenceCountedObject has been assigned to a pointer, be
	careful not to delete the object manually.

	This class uses an Atomic<int> value to hold the reference count, so that it
	the pointers can be passed between threads safely. For a faster but non-thread-safe
	version, use SingleThreadedReferenceCountedObject instead.

	@see ReferenceCountedObjectPtr, ReferenceCountedArray, SingleThreadedReferenceCountedObject
*/
class JUCE_API  ReferenceCountedObject
{
public:

	/** Increments the object's reference count.

		This is done automatically by the smart pointer, but is public just
		in case it's needed for nefarious purposes.
	*/
	inline void incReferenceCount() noexcept
	{
		++refCount;
	}

	/** Decreases the object's reference count.

		If the count gets to zero, the object will be deleted.
	*/
	inline void decReferenceCount() noexcept
	{
		jassert (getReferenceCount() > 0);

		if (--refCount == 0)
			delete this;
	}

	/** Returns the object's current reference count. */
	inline int getReferenceCount() const noexcept       { return refCount.get(); }

protected:

	/** Creates the reference-counted object (with an initial ref count of zero). */
	ReferenceCountedObject()
	{
	}

	/** Destructor. */
	virtual ~ReferenceCountedObject()
	{
		// it's dangerous to delete an object that's still referenced by something else!
		jassert (getReferenceCount() == 0);
	}

	/** Resets the reference count to zero without deleting the object.
		You should probably never need to use this!
	*/
	void resetReferenceCount() noexcept
	{
		refCount = 0;
	}

private:

	Atomic <int> refCount;
};

/**
	Adds reference-counting to an object.

	This is efectively a version of the ReferenceCountedObject class, but which
	uses a non-atomic counter, and so is not thread-safe (but which will be more
	efficient).
	For more details on how to use it, see the ReferenceCountedObject class notes.

	@see ReferenceCountedObject, ReferenceCountedObjectPtr, ReferenceCountedArray
*/
class JUCE_API  SingleThreadedReferenceCountedObject
{
public:

	/** Increments the object's reference count.

		This is done automatically by the smart pointer, but is public just
		in case it's needed for nefarious purposes.
	*/
	inline void incReferenceCount() noexcept
	{
		++refCount;
	}

	/** Decreases the object's reference count.

		If the count gets to zero, the object will be deleted.
	*/
	inline void decReferenceCount() noexcept
	{
		jassert (getReferenceCount() > 0);

		if (--refCount == 0)
			delete this;
	}

	/** Returns the object's current reference count. */
	inline int getReferenceCount() const noexcept       { return refCount; }

protected:

	/** Creates the reference-counted object (with an initial ref count of zero). */
	SingleThreadedReferenceCountedObject() : refCount (0)  {}

	/** Destructor. */
	virtual ~SingleThreadedReferenceCountedObject()
	{
		// it's dangerous to delete an object that's still referenced by something else!
		jassert (getReferenceCount() == 0);
	}

private:

	int refCount;
};

/**
	A smart-pointer class which points to a reference-counted object.

	The template parameter specifies the class of the object you want to point to - the easiest
	way to make a class reference-countable is to simply make it inherit from ReferenceCountedObject,
	but if you need to, you could roll your own reference-countable class by implementing a pair of
	mathods called incReferenceCount() and decReferenceCount().

	When using this class, you'll probably want to create a typedef to abbreviate the full
	templated name - e.g.
	@code typedef ReferenceCountedObjectPtr<MyClass> MyClassPtr;@endcode

	@see ReferenceCountedObject, ReferenceCountedObjectArray
*/
template <class ReferenceCountedObjectClass>
class ReferenceCountedObjectPtr
{
public:
	/** The class being referenced by this pointer. */
	typedef ReferenceCountedObjectClass ReferencedType;

	/** Creates a pointer to a null object. */
	inline ReferenceCountedObjectPtr() noexcept
		: referencedObject (nullptr)
	{
	}

	/** Creates a pointer to an object.

		This will increment the object's reference-count if it is non-null.
	*/
	inline ReferenceCountedObjectPtr (ReferenceCountedObjectClass* const refCountedObject) noexcept
		: referencedObject (refCountedObject)
	{
		if (refCountedObject != nullptr)
			refCountedObject->incReferenceCount();
	}

	/** Copies another pointer.
		This will increment the object's reference-count (if it is non-null).
	*/
	inline ReferenceCountedObjectPtr (const ReferenceCountedObjectPtr& other) noexcept
		: referencedObject (other.referencedObject)
	{
		if (referencedObject != nullptr)
			referencedObject->incReferenceCount();
	}

   #if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
	/** Takes-over the object from another pointer. */
	inline ReferenceCountedObjectPtr (ReferenceCountedObjectPtr&& other) noexcept
		: referencedObject (other.referencedObject)
	{
		other.referencedObject = nullptr;
	}
   #endif

	/** Copies another pointer.
		This will increment the object's reference-count (if it is non-null).
	*/
	template <class DerivedClass>
	inline ReferenceCountedObjectPtr (const ReferenceCountedObjectPtr<DerivedClass>& other) noexcept
		: referencedObject (static_cast <ReferenceCountedObjectClass*> (other.getObject()))
	{
		if (referencedObject != nullptr)
			referencedObject->incReferenceCount();
	}

	/** Changes this pointer to point at a different object.

		The reference count of the old object is decremented, and it might be
		deleted if it hits zero. The new object's count is incremented.
	*/
	ReferenceCountedObjectPtr& operator= (const ReferenceCountedObjectPtr& other)
	{
		return operator= (other.referencedObject);
	}

	/** Changes this pointer to point at a different object.

		The reference count of the old object is decremented, and it might be
		deleted if it hits zero. The new object's count is incremented.
	*/
	template <class DerivedClass>
	ReferenceCountedObjectPtr& operator= (const ReferenceCountedObjectPtr<DerivedClass>& other)
	{
		return operator= (static_cast <ReferenceCountedObjectClass*> (other.getObject()));
	}

   #if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
	/** Takes-over the object from another pointer. */
	ReferenceCountedObjectPtr& operator= (ReferenceCountedObjectPtr&& other)
	{
		std::swap (referencedObject, other.referencedObject);
		return *this;
	}
   #endif

	/** Changes this pointer to point at a different object.

		The reference count of the old object is decremented, and it might be
		deleted if it hits zero. The new object's count is incremented.
	*/
	ReferenceCountedObjectPtr& operator= (ReferenceCountedObjectClass* const newObject)
	{
		if (referencedObject != newObject)
		{
			if (newObject != nullptr)
				newObject->incReferenceCount();

			ReferenceCountedObjectClass* const oldObject = referencedObject;
			referencedObject = newObject;

			if (oldObject != nullptr)
				oldObject->decReferenceCount();
		}

		return *this;
	}

	/** Destructor.

		This will decrement the object's reference-count, and may delete it if it
		gets to zero.
	*/
	inline ~ReferenceCountedObjectPtr()
	{
		if (referencedObject != nullptr)
			referencedObject->decReferenceCount();
	}

	/** Returns the object that this pointer references.
		The pointer returned may be zero, of course.
	*/
	inline operator ReferenceCountedObjectClass*() const noexcept
	{
		return referencedObject;
	}

	// the -> operator is called on the referenced object
	inline ReferenceCountedObjectClass* operator->() const noexcept
	{
		return referencedObject;
	}

	/** Returns the object that this pointer references.
		The pointer returned may be zero, of course.
	*/
	inline ReferenceCountedObjectClass* getObject() const noexcept
	{
		return referencedObject;
	}

private:

	ReferenceCountedObjectClass* referencedObject;
};

/** Compares two ReferenceCountedObjectPointers. */
template <class ReferenceCountedObjectClass>
bool operator== (const ReferenceCountedObjectPtr<ReferenceCountedObjectClass>& object1, ReferenceCountedObjectClass* const object2) noexcept
{
	return object1.getObject() == object2;
}

/** Compares two ReferenceCountedObjectPointers. */
template <class ReferenceCountedObjectClass>
bool operator== (const ReferenceCountedObjectPtr<ReferenceCountedObjectClass>& object1, const ReferenceCountedObjectPtr<ReferenceCountedObjectClass>& object2) noexcept
{
	return object1.getObject() == object2.getObject();
}

/** Compares two ReferenceCountedObjectPointers. */
template <class ReferenceCountedObjectClass>
bool operator== (ReferenceCountedObjectClass* object1, ReferenceCountedObjectPtr<ReferenceCountedObjectClass>& object2) noexcept
{
	return object1 == object2.getObject();
}

/** Compares two ReferenceCountedObjectPointers. */
template <class ReferenceCountedObjectClass>
bool operator!= (const ReferenceCountedObjectPtr<ReferenceCountedObjectClass>& object1, const ReferenceCountedObjectClass* object2) noexcept
{
	return object1.getObject() != object2;
}

/** Compares two ReferenceCountedObjectPointers. */
template <class ReferenceCountedObjectClass>
bool operator!= (const ReferenceCountedObjectPtr<ReferenceCountedObjectClass>& object1, ReferenceCountedObjectPtr<ReferenceCountedObjectClass>& object2) noexcept
{
	return object1.getObject() != object2.getObject();
}

/** Compares two ReferenceCountedObjectPointers. */
template <class ReferenceCountedObjectClass>
bool operator!= (ReferenceCountedObjectClass* object1, ReferenceCountedObjectPtr<ReferenceCountedObjectClass>& object2) noexcept
{
	return object1 != object2.getObject();
}

#endif   // __JUCE_REFERENCECOUNTEDOBJECT_JUCEHEADER__

/*** End of inlined file: juce_ReferenceCountedObject.h ***/

/**
	Represents a dynamically implemented object.

	This class is primarily intended for wrapping scripting language objects,
	but could be used for other purposes.

	An instance of a DynamicObject can be used to store named properties, and
	by subclassing hasMethod() and invokeMethod(), you can give your object
	methods.
*/
class JUCE_API  DynamicObject  : public ReferenceCountedObject
{
public:

	DynamicObject();

	/** Destructor. */
	virtual ~DynamicObject();

	/** Returns true if the object has a property with this name.
		Note that if the property is actually a method, this will return false.
	*/
	virtual bool hasProperty (const Identifier& propertyName) const;

	/** Returns a named property.

		This returns a void if no such property exists.
	*/
	virtual var getProperty (const Identifier& propertyName) const;

	/** Sets a named property. */
	virtual void setProperty (const Identifier& propertyName, const var& newValue);

	/** Removes a named property. */
	virtual void removeProperty (const Identifier& propertyName);

	/** Checks whether this object has the specified method.

		The default implementation of this just checks whether there's a property
		with this name that's actually a method, but this can be overridden for
		building objects with dynamic invocation.
	*/
	virtual bool hasMethod (const Identifier& methodName) const;

	/** Invokes a named method on this object.

		The default implementation looks up the named property, and if it's a method
		call, then it invokes it.

		This method is virtual to allow more dynamic invocation to used for objects
		where the methods may not already be set as properies.
	*/
	virtual var invokeMethod (const Identifier& methodName,
							  const var* parameters,
							  int numParameters);

	/** Sets up a method.

		This is basically the same as calling setProperty (methodName, (var::MethodFunction) myFunction), but
		helps to avoid accidentally invoking the wrong type of var constructor. It also makes
		the code easier to read,

		The compiler will probably force you to use an explicit cast your method to a (var::MethodFunction), e.g.
		@code
		setMethod ("doSomething", (var::MethodFunction) &MyClass::doSomething);
		@endcode
	*/
	void setMethod (const Identifier& methodName,
					var::MethodFunction methodFunction);

	/** Removes all properties and methods from the object. */
	void clear();

	/** Returns the NamedValueSet that holds the object's properties. */
	NamedValueSet& getProperties() noexcept     { return properties; }

private:

	NamedValueSet properties;

	JUCE_LEAK_DETECTOR (DynamicObject);
};

#endif   // __JUCE_DYNAMICOBJECT_JUCEHEADER__

/*** End of inlined file: juce_DynamicObject.h ***/


#endif
#ifndef __JUCE_ELEMENTCOMPARATOR_JUCEHEADER__

#endif
#ifndef __JUCE_HASHMAP_JUCEHEADER__

/*** Start of inlined file: juce_HashMap.h ***/
#ifndef __JUCE_HASHMAP_JUCEHEADER__
#define __JUCE_HASHMAP_JUCEHEADER__


/*** Start of inlined file: juce_OwnedArray.h ***/
#ifndef __JUCE_OWNEDARRAY_JUCEHEADER__
#define __JUCE_OWNEDARRAY_JUCEHEADER__

/** An array designed for holding objects.

	This holds a list of pointers to objects, and will automatically
	delete the objects when they are removed from the array, or when the
	array is itself deleted.

	Declare it in the form:  OwnedArray<MyObjectClass>

	..and then add new objects, e.g.   myOwnedArray.add (new MyObjectClass());

	After adding objects, they are 'owned' by the array and will be deleted when
	removed or replaced.

	To make all the array's methods thread-safe, pass in "CriticalSection" as the templated
	TypeOfCriticalSectionToUse parameter, instead of the default DummyCriticalSection.

	@see Array, ReferenceCountedArray, StringArray, CriticalSection
*/
template <class ObjectClass,
		  class TypeOfCriticalSectionToUse = DummyCriticalSection>

class OwnedArray
{
public:

	/** Creates an empty array. */
	OwnedArray() noexcept
		: numUsed (0)
	{
	}

	/** Deletes the array and also deletes any objects inside it.

		To get rid of the array without deleting its objects, use its
		clear (false) method before deleting it.
	*/
	~OwnedArray()
	{
		clear (true);
	}

   #if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
	OwnedArray (OwnedArray&& other) noexcept
		: data (static_cast <ArrayAllocationBase <ObjectClass*, TypeOfCriticalSectionToUse>&&> (other.data)),
		  numUsed (other.numUsed)
	{
		other.numUsed = 0;
	}

	OwnedArray& operator= (OwnedArray&& other) noexcept
	{
		data = static_cast <ArrayAllocationBase <ObjectClass*, TypeOfCriticalSectionToUse>&&> (other.data);
		numUsed = other.numUsed;
		other.numUsed = 0;
		return *this;
	}
   #endif

	/** Clears the array, optionally deleting the objects inside it first. */
	void clear (const bool deleteObjects = true)
	{
		const ScopedLockType lock (getLock());

		if (deleteObjects)
		{
			while (numUsed > 0)
				delete data.elements [--numUsed];
		}

		data.setAllocatedSize (0);
		numUsed = 0;
	}

	/** Returns the number of items currently in the array.
		@see operator[]
	*/
	inline int size() const noexcept
	{
		return numUsed;
	}

	/** Returns a pointer to the object at this index in the array.

		If the index is out-of-range, this will return a null pointer, (and
		it could be null anyway, because it's ok for the array to hold null
		pointers as well as objects).

		@see getUnchecked
	*/
	inline ObjectClass* operator[] (const int index) const noexcept
	{
		const ScopedLockType lock (getLock());
		return isPositiveAndBelow (index, numUsed) ? data.elements [index]
												   : static_cast <ObjectClass*> (nullptr);
	}

	/** Returns a pointer to the object at this index in the array, without checking whether the index is in-range.

		This is a faster and less safe version of operator[] which doesn't check the index passed in, so
		it can be used when you're sure the index if always going to be legal.
	*/
	inline ObjectClass* getUnchecked (const int index) const noexcept
	{
		const ScopedLockType lock (getLock());
		jassert (isPositiveAndBelow (index, numUsed));
		return data.elements [index];
	}

	/** Returns a pointer to the first object in the array.

		This will return a null pointer if the array's empty.
		@see getLast
	*/
	inline ObjectClass* getFirst() const noexcept
	{
		const ScopedLockType lock (getLock());
		return numUsed > 0 ? data.elements [0]
						   : static_cast <ObjectClass*> (nullptr);
	}

	/** Returns a pointer to the last object in the array.

		This will return a null pointer if the array's empty.
		@see getFirst
	*/
	inline ObjectClass* getLast() const noexcept
	{
		const ScopedLockType lock (getLock());
		return numUsed > 0 ? data.elements [numUsed - 1]
						   : static_cast <ObjectClass*> (nullptr);
	}

	/** Returns a pointer to the actual array data.
		This pointer will only be valid until the next time a non-const method
		is called on the array.
	*/
	inline ObjectClass** getRawDataPointer() noexcept
	{
		return data.elements;
	}

	/** Returns a pointer to the first element in the array.
		This method is provided for compatibility with standard C++ iteration mechanisms.
	*/
	inline ObjectClass** begin() const noexcept
	{
		return data.elements;
	}

	/** Returns a pointer to the element which follows the last element in the array.
		This method is provided for compatibility with standard C++ iteration mechanisms.
	*/
	inline ObjectClass** end() const noexcept
	{
		return data.elements + numUsed;
	}

	/** Finds the index of an object which might be in the array.

		@param objectToLookFor    the object to look for
		@returns                  the index at which the object was found, or -1 if it's not found
	*/
	int indexOf (const ObjectClass* const objectToLookFor) const noexcept
	{
		const ScopedLockType lock (getLock());
		ObjectClass* const* e = data.elements.getData();
		ObjectClass* const* const end_ = e + numUsed;

		for (; e != end_; ++e)
			if (objectToLookFor == *e)
				return static_cast <int> (e - data.elements.getData());

		return -1;
	}

	/** Returns true if the array contains a specified object.

		@param objectToLookFor      the object to look for
		@returns                    true if the object is in the array
	*/
	bool contains (const ObjectClass* const objectToLookFor) const noexcept
	{
		const ScopedLockType lock (getLock());
		ObjectClass* const* e = data.elements.getData();
		ObjectClass* const* const end_ = e + numUsed;

		for (; e != end_; ++e)
			if (objectToLookFor == *e)
				return true;

		return false;
	}

	/** Appends a new object to the end of the array.

		Note that the this object will be deleted by the OwnedArray when it
		is removed, so be careful not to delete it somewhere else.

		Also be careful not to add the same object to the array more than once,
		as this will obviously cause deletion of dangling pointers.

		@param newObject       the new object to add to the array
		@see set, insert, addIfNotAlreadyThere, addSorted
	*/
	void add (const ObjectClass* const newObject) noexcept
	{
		const ScopedLockType lock (getLock());
		data.ensureAllocatedSize (numUsed + 1);
		data.elements [numUsed++] = const_cast <ObjectClass*> (newObject);
	}

	/** Inserts a new object into the array at the given index.

		Note that the this object will be deleted by the OwnedArray when it
		is removed, so be careful not to delete it somewhere else.

		If the index is less than 0 or greater than the size of the array, the
		element will be added to the end of the array.
		Otherwise, it will be inserted into the array, moving all the later elements
		along to make room.

		Be careful not to add the same object to the array more than once,
		as this will obviously cause deletion of dangling pointers.

		@param indexToInsertAt      the index at which the new element should be inserted
		@param newObject            the new object to add to the array
		@see add, addSorted, addIfNotAlreadyThere, set
	*/
	void insert (int indexToInsertAt,
				 const ObjectClass* const newObject) noexcept
	{
		if (indexToInsertAt >= 0)
		{
			const ScopedLockType lock (getLock());

			if (indexToInsertAt > numUsed)
				indexToInsertAt = numUsed;

			data.ensureAllocatedSize (numUsed + 1);

			ObjectClass** const e = data.elements + indexToInsertAt;
			const int numToMove = numUsed - indexToInsertAt;

			if (numToMove > 0)
				memmove (e + 1, e, numToMove * sizeof (ObjectClass*));

			*e = const_cast <ObjectClass*> (newObject);
			++numUsed;
		}
		else
		{
			add (newObject);
		}
	}

	/** Appends a new object at the end of the array as long as the array doesn't
		already contain it.

		If the array already contains a matching object, nothing will be done.

		@param newObject   the new object to add to the array
	*/
	void addIfNotAlreadyThere (const ObjectClass* const newObject) noexcept
	{
		const ScopedLockType lock (getLock());

		if (! contains (newObject))
			add (newObject);
	}

	/** Replaces an object in the array with a different one.

		If the index is less than zero, this method does nothing.
		If the index is beyond the end of the array, the new object is added to the end of the array.

		Be careful not to add the same object to the array more than once,
		as this will obviously cause deletion of dangling pointers.

		@param indexToChange        the index whose value you want to change
		@param newObject            the new value to set for this index.
		@param deleteOldElement     whether to delete the object that's being replaced with the new one
		@see add, insert, remove
	*/
	void set (const int indexToChange,
			  const ObjectClass* const newObject,
			  const bool deleteOldElement = true)
	{
		if (indexToChange >= 0)
		{
			ObjectClass* toDelete = nullptr;

			{
				const ScopedLockType lock (getLock());

				if (indexToChange < numUsed)
				{
					if (deleteOldElement)
					{
						toDelete = data.elements [indexToChange];

						if (toDelete == newObject)
							toDelete = nullptr;
					}

					data.elements [indexToChange] = const_cast <ObjectClass*> (newObject);
				}
				else
				{
					data.ensureAllocatedSize (numUsed + 1);
					data.elements [numUsed++] = const_cast <ObjectClass*> (newObject);
				}
			}

			delete toDelete; // don't want to use a ScopedPointer here because if the
							 // object has a private destructor, both OwnedArray and
							 // ScopedPointer would need to be friend classes..
		}
		else
		{
			jassertfalse; // you're trying to set an object at a negative index, which doesn't have
						  // any effect - but since the object is not being added, it may be leaking..
		}
	}

	/** Adds elements from another array to the end of this array.

		@param arrayToAddFrom       the array from which to copy the elements
		@param startIndex           the first element of the other array to start copying from
		@param numElementsToAdd     how many elements to add from the other array. If this
									value is negative or greater than the number of available elements,
									all available elements will be copied.
		@see add
	*/
	template <class OtherArrayType>
	void addArray (const OtherArrayType& arrayToAddFrom,
				   int startIndex = 0,
				   int numElementsToAdd = -1)
	{
		const typename OtherArrayType::ScopedLockType lock1 (arrayToAddFrom.getLock());
		const ScopedLockType lock2 (getLock());

		if (startIndex < 0)
		{
			jassertfalse;
			startIndex = 0;
		}

		if (numElementsToAdd < 0 || startIndex + numElementsToAdd > arrayToAddFrom.size())
			numElementsToAdd = arrayToAddFrom.size() - startIndex;

		data.ensureAllocatedSize (numUsed + numElementsToAdd);

		while (--numElementsToAdd >= 0)
		{
			data.elements [numUsed] = arrayToAddFrom.getUnchecked (startIndex++);
			++numUsed;
		}
	}

	/** Adds copies of the elements in another array to the end of this array.

		The other array must be either an OwnedArray of a compatible type of object, or an Array
		containing pointers to the same kind of object. The objects involved must provide
		a copy constructor, and this will be used to create new copies of each element, and
		add them to this array.

		@param arrayToAddFrom       the array from which to copy the elements
		@param startIndex           the first element of the other array to start copying from
		@param numElementsToAdd     how many elements to add from the other array. If this
									value is negative or greater than the number of available elements,
									all available elements will be copied.
		@see add
	*/
	template <class OtherArrayType>
	void addCopiesOf (const OtherArrayType& arrayToAddFrom,
					  int startIndex = 0,
					  int numElementsToAdd = -1)
	{
		const typename OtherArrayType::ScopedLockType lock1 (arrayToAddFrom.getLock());
		const ScopedLockType lock2 (getLock());

		if (startIndex < 0)
		{
			jassertfalse;
			startIndex = 0;
		}

		if (numElementsToAdd < 0 || startIndex + numElementsToAdd > arrayToAddFrom.size())
			numElementsToAdd = arrayToAddFrom.size() - startIndex;

		data.ensureAllocatedSize (numUsed + numElementsToAdd);

		while (--numElementsToAdd >= 0)
		{
			data.elements [numUsed] = new ObjectClass (*arrayToAddFrom.getUnchecked (startIndex++));
			++numUsed;
		}
	}

	/** Inserts a new object into the array assuming that the array is sorted.

		This will use a comparator to find the position at which the new object
		should go. If the array isn't sorted, the behaviour of this
		method will be unpredictable.

		@param comparator   the comparator to use to compare the elements - see the sort method
							for details about this object's structure
		@param newObject    the new object to insert to the array
		@returns the index at which the new object was added
		@see add, sort, indexOfSorted
	*/
	template <class ElementComparator>
	int addSorted (ElementComparator& comparator, ObjectClass* const newObject) noexcept
	{
		(void) comparator;  // if you pass in an object with a static compareElements() method, this
							// avoids getting warning messages about the parameter being unused
		const ScopedLockType lock (getLock());
		const int index = findInsertIndexInSortedArray (comparator, data.elements.getData(), newObject, 0, numUsed);
		insert (index, newObject);
		return index;
	}

	/** Finds the index of an object in the array, assuming that the array is sorted.

		This will use a comparator to do a binary-chop to find the index of the given
		element, if it exists. If the array isn't sorted, the behaviour of this
		method will be unpredictable.

		@param comparator           the comparator to use to compare the elements - see the sort()
									method for details about the form this object should take
		@param objectToLookFor      the object to search for
		@returns                    the index of the element, or -1 if it's not found
		@see addSorted, sort
	*/
	template <class ElementComparator>
	int indexOfSorted (ElementComparator& comparator,
					   const ObjectClass* const objectToLookFor) const noexcept
	{
		(void) comparator;  // if you pass in an object with a static compareElements() method, this
							// avoids getting warning messages about the parameter being unused
		const ScopedLockType lock (getLock());

		int start = 0;
		int end_ = numUsed;

		for (;;)
		{
			if (start >= end_)
			{
				return -1;
			}
			else if (comparator.compareElements (objectToLookFor, data.elements [start]) == 0)
			{
				return start;
			}
			else
			{
				const int halfway = (start + end_) >> 1;

				if (halfway == start)
					return -1;
				else if (comparator.compareElements (objectToLookFor, data.elements [halfway]) >= 0)
					start = halfway;
				else
					end_ = halfway;
			}
		}
	}

	/** Removes an object from the array.

		This will remove the object at a given index (optionally also
		deleting it) and move back all the subsequent objects to close the gap.
		If the index passed in is out-of-range, nothing will happen.

		@param indexToRemove    the index of the element to remove
		@param deleteObject     whether to delete the object that is removed
		@see removeObject, removeRange
	*/
	void remove (const int indexToRemove,
				 const bool deleteObject = true)
	{
		ObjectClass* toDelete = nullptr;

		{
			const ScopedLockType lock (getLock());

			if (isPositiveAndBelow (indexToRemove, numUsed))
			{
				ObjectClass** const e = data.elements + indexToRemove;

				if (deleteObject)
					toDelete = *e;

				--numUsed;
				const int numToShift = numUsed - indexToRemove;

				if (numToShift > 0)
					memmove (e, e + 1, numToShift * sizeof (ObjectClass*));
			}
		}

		delete toDelete; // don't want to use a ScopedPointer here because if the
						 // object has a private destructor, both OwnedArray and
						 // ScopedPointer would need to be friend classes..

		if ((numUsed << 1) < data.numAllocated)
			minimiseStorageOverheads();
	}

	/** Removes and returns an object from the array without deleting it.

		This will remove the object at a given index and return it, moving back all
		the subsequent objects to close the gap. If the index passed in is out-of-range,
		nothing will happen.

		@param indexToRemove    the index of the element to remove
		@see remove, removeObject, removeRange
	*/
	ObjectClass* removeAndReturn (const int indexToRemove)
	{
		ObjectClass* removedItem = nullptr;
		const ScopedLockType lock (getLock());

		if (isPositiveAndBelow (indexToRemove, numUsed))
		{
			ObjectClass** const e = data.elements + indexToRemove;
			removedItem = *e;

			--numUsed;
			const int numToShift = numUsed - indexToRemove;

			if (numToShift > 0)
				memmove (e, e + 1, numToShift * sizeof (ObjectClass*));

			if ((numUsed << 1) < data.numAllocated)
				minimiseStorageOverheads();
		}

		return removedItem;
	}

	/** Removes a specified object from the array.

		If the item isn't found, no action is taken.

		@param objectToRemove   the object to try to remove
		@param deleteObject     whether to delete the object (if it's found)
		@see remove, removeRange
	*/
	void removeObject (const ObjectClass* const objectToRemove,
					   const bool deleteObject = true)
	{
		const ScopedLockType lock (getLock());
		ObjectClass** const e = data.elements.getData();

		for (int i = 0; i < numUsed; ++i)
		{
			if (objectToRemove == e[i])
			{
				remove (i, deleteObject);
				break;
			}
		}
	}

	/** Removes a range of objects from the array.

		This will remove a set of objects, starting from the given index,
		and move any subsequent elements down to close the gap.

		If the range extends beyond the bounds of the array, it will
		be safely clipped to the size of the array.

		@param startIndex       the index of the first object to remove
		@param numberToRemove   how many objects should be removed
		@param deleteObjects    whether to delete the objects that get removed
		@see remove, removeObject
	*/
	void removeRange (int startIndex,
					  const int numberToRemove,
					  const bool deleteObjects = true)
	{
		const ScopedLockType lock (getLock());
		const int endIndex = jlimit (0, numUsed, startIndex + numberToRemove);
		startIndex = jlimit (0, numUsed, startIndex);

		if (endIndex > startIndex)
		{
			if (deleteObjects)
			{
				for (int i = startIndex; i < endIndex; ++i)
				{
					delete data.elements [i];
					data.elements [i] = nullptr; // (in case one of the destructors accesses this array and hits a dangling pointer)
				}
			}

			const int rangeSize = endIndex - startIndex;
			ObjectClass** e = data.elements + startIndex;
			int numToShift = numUsed - endIndex;
			numUsed -= rangeSize;

			while (--numToShift >= 0)
			{
				*e = e [rangeSize];
				++e;
			}

			if ((numUsed << 1) < data.numAllocated)
				minimiseStorageOverheads();
		}
	}

	/** Removes the last n objects from the array.

		@param howManyToRemove   how many objects to remove from the end of the array
		@param deleteObjects     whether to also delete the objects that are removed
		@see remove, removeObject, removeRange
	*/
	void removeLast (int howManyToRemove = 1,
					 const bool deleteObjects = true)
	{
		const ScopedLockType lock (getLock());

		if (howManyToRemove >= numUsed)
			clear (deleteObjects);
		else
			removeRange (numUsed - howManyToRemove, howManyToRemove, deleteObjects);
	}

	/** Swaps a pair of objects in the array.

		If either of the indexes passed in is out-of-range, nothing will happen,
		otherwise the two objects at these positions will be exchanged.
	*/
	void swap (const int index1,
			   const int index2) noexcept
	{
		const ScopedLockType lock (getLock());

		if (isPositiveAndBelow (index1, numUsed)
			 && isPositiveAndBelow (index2, numUsed))
		{
			swapVariables (data.elements [index1],
						   data.elements [index2]);
		}
	}

	/** Moves one of the objects to a different position.

		This will move the object to a specified index, shuffling along
		any intervening elements as required.

		So for example, if you have the array { 0, 1, 2, 3, 4, 5 } then calling
		move (2, 4) would result in { 0, 1, 3, 4, 2, 5 }.

		@param currentIndex     the index of the object to be moved. If this isn't a
								valid index, then nothing will be done
		@param newIndex         the index at which you'd like this object to end up. If this
								is less than zero, it will be moved to the end of the array
	*/
	void move (const int currentIndex,
			   int newIndex) noexcept
	{
		if (currentIndex != newIndex)
		{
			const ScopedLockType lock (getLock());

			if (isPositiveAndBelow (currentIndex, numUsed))
			{
				if (! isPositiveAndBelow (newIndex, numUsed))
					newIndex = numUsed - 1;

				ObjectClass* const value = data.elements [currentIndex];

				if (newIndex > currentIndex)
				{
					memmove (data.elements + currentIndex,
							 data.elements + currentIndex + 1,
							 (newIndex - currentIndex) * sizeof (ObjectClass*));
				}
				else
				{
					memmove (data.elements + newIndex + 1,
							 data.elements + newIndex,
							 (currentIndex - newIndex) * sizeof (ObjectClass*));
				}

				data.elements [newIndex] = value;
			}
		}
	}

	/** This swaps the contents of this array with those of another array.

		If you need to exchange two arrays, this is vastly quicker than using copy-by-value
		because it just swaps their internal pointers.
	*/
	void swapWithArray (OwnedArray& otherArray) noexcept
	{
		const ScopedLockType lock1 (getLock());
		const ScopedLockType lock2 (otherArray.getLock());

		data.swapWith (otherArray.data);
		swapVariables (numUsed, otherArray.numUsed);
	}

	/** Reduces the amount of storage being used by the array.

		Arrays typically allocate slightly more storage than they need, and after
		removing elements, they may have quite a lot of unused space allocated.
		This method will reduce the amount of allocated storage to a minimum.
	*/
	void minimiseStorageOverheads() noexcept
	{
		const ScopedLockType lock (getLock());
		data.shrinkToNoMoreThan (numUsed);
	}

	/** Increases the array's internal storage to hold a minimum number of elements.

		Calling this before adding a large known number of elements means that
		the array won't have to keep dynamically resizing itself as the elements
		are added, and it'll therefore be more efficient.
	*/
	void ensureStorageAllocated (const int minNumElements) noexcept
	{
		const ScopedLockType lock (getLock());
		data.ensureAllocatedSize (minNumElements);
	}

	/** Sorts the elements in the array.

		This will use a comparator object to sort the elements into order. The object
		passed must have a method of the form:
		@code
		int compareElements (ElementType first, ElementType second);
		@endcode

		..and this method must return:
		  - a value of < 0 if the first comes before the second
		  - a value of 0 if the two objects are equivalent
		  - a value of > 0 if the second comes before the first

		To improve performance, the compareElements() method can be declared as static or const.

		@param comparator   the comparator to use for comparing elements.
		@param retainOrderOfEquivalentItems     if this is true, then items
							which the comparator says are equivalent will be
							kept in the order in which they currently appear
							in the array. This is slower to perform, but may
							be important in some cases. If it's false, a faster
							algorithm is used, but equivalent elements may be
							rearranged.
		@see sortArray, indexOfSorted
	*/
	template <class ElementComparator>
	void sort (ElementComparator& comparator,
			   const bool retainOrderOfEquivalentItems = false) const noexcept
	{
		(void) comparator;  // if you pass in an object with a static compareElements() method, this
							// avoids getting warning messages about the parameter being unused

		const ScopedLockType lock (getLock());
		sortArray (comparator, data.elements.getData(), 0, size() - 1, retainOrderOfEquivalentItems);
	}

	/** Returns the CriticalSection that locks this array.
		To lock, you can call getLock().enter() and getLock().exit(), or preferably use
		an object of ScopedLockType as an RAII lock for it.
	*/
	inline const TypeOfCriticalSectionToUse& getLock() const noexcept      { return data; }

	/** Returns the type of scoped lock to use for locking this array */
	typedef typename TypeOfCriticalSectionToUse::ScopedLockType ScopedLockType;

private:

	ArrayAllocationBase <ObjectClass*, TypeOfCriticalSectionToUse> data;
	int numUsed;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (OwnedArray);
};

#endif   // __JUCE_OWNEDARRAY_JUCEHEADER__

/*** End of inlined file: juce_OwnedArray.h ***/


/*** Start of inlined file: juce_ScopedPointer.h ***/
#ifndef __JUCE_SCOPEDPOINTER_JUCEHEADER__
#define __JUCE_SCOPEDPOINTER_JUCEHEADER__

/**
	This class holds a pointer which is automatically deleted when this object goes
	out of scope.

	Once a pointer has been passed to a ScopedPointer, it will make sure that the pointer
	gets deleted when the ScopedPointer is deleted. Using the ScopedPointer on the stack or
	as member variables is a good way to use RAII to avoid accidentally leaking dynamically
	created objects.

	A ScopedPointer can be used in pretty much the same way that you'd use a normal pointer
	to an object. If you use the assignment operator to assign a different object to a
	ScopedPointer, the old one will be automatically deleted.

	A const ScopedPointer is guaranteed not to lose ownership of its object or change the
	object to which it points during its lifetime. This means that making a copy of a const
	ScopedPointer is impossible, as that would involve the new copy taking ownership from the
	old one.

	If you need to get a pointer out of a ScopedPointer without it being deleted, you
	can use the release() method.

	Something to note is the main difference between this class and the std::auto_ptr class,
	which is that ScopedPointer provides a cast-to-object operator, wheras std::auto_ptr
	requires that you always call get() to retrieve the pointer. The advantages of providing
	the cast is that you don't need to call get(), so can use the ScopedPointer in pretty much
	exactly the same way as a raw pointer. The disadvantage is that the compiler is free to
	use the cast in unexpected and sometimes dangerous ways - in particular, it becomes difficult
	to return a ScopedPointer as the result of a function. To avoid this causing errors,
	ScopedPointer contains an overloaded constructor that should cause a syntax error in these
	circumstances, but it does mean that instead of returning a ScopedPointer from a function,
	you'd need to return a raw pointer (or use a std::auto_ptr instead).
*/
template <class ObjectType>
class ScopedPointer
{
public:

	/** Creates a ScopedPointer containing a null pointer. */
	inline ScopedPointer() noexcept   : object (nullptr)
	{
	}

	/** Creates a ScopedPointer that owns the specified object. */
	inline ScopedPointer (ObjectType* const objectToTakePossessionOf) noexcept
		: object (objectToTakePossessionOf)
	{
	}

	/** Creates a ScopedPointer that takes its pointer from another ScopedPointer.

		Because a pointer can only belong to one ScopedPointer, this transfers
		the pointer from the other object to this one, and the other object is reset to
		be a null pointer.
	*/
	ScopedPointer (ScopedPointer& objectToTransferFrom) noexcept
		: object (objectToTransferFrom.object)
	{
		objectToTransferFrom.object = nullptr;
	}

	/** Destructor.
		This will delete the object that this ScopedPointer currently refers to.
	*/
	inline ~ScopedPointer()                                                         { delete object; }

	/** Changes this ScopedPointer to point to a new object.

		Because a pointer can only belong to one ScopedPointer, this transfers
		the pointer from the other object to this one, and the other object is reset to
		be a null pointer.

		If this ScopedPointer already points to an object, that object
		will first be deleted.
	*/
	ScopedPointer& operator= (ScopedPointer& objectToTransferFrom)
	{
		if (this != objectToTransferFrom.getAddress())
		{
			// Two ScopedPointers should never be able to refer to the same object - if
			// this happens, you must have done something dodgy!
			jassert (object == nullptr || object != objectToTransferFrom.object);

			ObjectType* const oldObject = object;
			object = objectToTransferFrom.object;
			objectToTransferFrom.object = nullptr;
			delete oldObject;
		}

		return *this;
	}

	/** Changes this ScopedPointer to point to a new object.

		If this ScopedPointer already points to an object, that object
		will first be deleted.

		The pointer that you pass is may be null.
	*/
	ScopedPointer& operator= (ObjectType* const newObjectToTakePossessionOf)
	{
		if (object != newObjectToTakePossessionOf)
		{
			ObjectType* const oldObject = object;
			object = newObjectToTakePossessionOf;
			delete oldObject;
		}

		return *this;
	}

	/** Returns the object that this ScopedPointer refers to. */
	inline operator ObjectType*() const noexcept                                    { return object; }

	/** Returns the object that this ScopedPointer refers to. */
	inline ObjectType* get() const noexcept                                         { return object; }

	/** Returns the object that this ScopedPointer refers to. */
	inline ObjectType& operator*() const noexcept                                   { return *object; }

	/** Lets you access methods and properties of the object that this ScopedPointer refers to. */
	inline ObjectType* operator->() const noexcept                                  { return object; }

	/** Removes the current object from this ScopedPointer without deleting it.
		This will return the current object, and set the ScopedPointer to a null pointer.
	*/
	ObjectType* release() noexcept                                                  { ObjectType* const o = object; object = nullptr; return o; }

	/** Swaps this object with that of another ScopedPointer.
		The two objects simply exchange their pointers.
	*/
	void swapWith (ScopedPointer <ObjectType>& other) noexcept
	{
		// Two ScopedPointers should never be able to refer to the same object - if
		// this happens, you must have done something dodgy!
		jassert (object != other.object);

		std::swap (object, other.object);
	}

	/** If the pointer is non-null, this will attempt to return a new copy of the object that is pointed to.
		If the pointer is null, this will safely return a nullptr.
	*/
	inline ObjectType* createCopy() const                                           { return createCopyIfNotNull (object); }

private:

	ObjectType* object;

	// (Required as an alternative to the overloaded & operator).
	const ScopedPointer* getAddress() const noexcept                                { return this; }

  #if ! JUCE_MSVC  // (MSVC can't deal with multiple copy constructors)
	/* These are private to stop people accidentally copying a const ScopedPointer (the compiler
	   would let you do so by implicitly casting the source to its raw object pointer).

	   A side effect of this is that you may hit a puzzling compiler error when you write something
	   like this:

		  ScopedPointer<MyClass> m = new MyClass();  // Compile error: copy constructor is private.

	   Even though the compiler would normally ignore the assignment here, it can't do so when the
	   copy constructor is private. It's very easy to fis though - just write it like this:

		  ScopedPointer<MyClass> m (new MyClass());  // Compiles OK

	   It's good practice to always use the latter form when writing your object declarations anyway,
	   rather than writing them as assignments and assuming (or hoping) that the compiler will be
	   smart enough to replace your construction + assignment with a single constructor.
	*/
	ScopedPointer (const ScopedPointer&);
	ScopedPointer& operator= (const ScopedPointer&);
  #endif
};

/** Compares a ScopedPointer with another pointer.
	This can be handy for checking whether this is a null pointer.
*/
template <class ObjectType>
bool operator== (const ScopedPointer<ObjectType>& pointer1, ObjectType* const pointer2) noexcept
{
	return static_cast <ObjectType*> (pointer1) == pointer2;
}

/** Compares a ScopedPointer with another pointer.
	This can be handy for checking whether this is a null pointer.
*/
template <class ObjectType>
bool operator!= (const ScopedPointer<ObjectType>& pointer1, ObjectType* const pointer2) noexcept
{
	return static_cast <ObjectType*> (pointer1) != pointer2;
}

#endif   // __JUCE_SCOPEDPOINTER_JUCEHEADER__

/*** End of inlined file: juce_ScopedPointer.h ***/

/**
	A simple class to generate hash functions for some primitive types, intended for
	use with the HashMap class.
	@see HashMap
*/
class DefaultHashFunctions
{
public:
	/** Generates a simple hash from an integer. */
	static int generateHash (const int key, const int upperLimit) noexcept        { return std::abs (key) % upperLimit; }
	/** Generates a simple hash from a string. */
	static int generateHash (const String& key, const int upperLimit) noexcept    { return (int) (((uint32) key.hashCode()) % upperLimit); }
	/** Generates a simple hash from a variant. */
	static int generateHash (const var& key, const int upperLimit) noexcept       { return generateHash (key.toString(), upperLimit); }
};

/**
	Holds a set of mappings between some key/value pairs.

	The types of the key and value objects are set as template parameters.
	You can also specify a class to supply a hash function that converts a key value
	into an hashed integer. This class must have the form:

	@code
	struct MyHashGenerator
	{
		static int generateHash (MyKeyType key, int upperLimit)
		{
			// The function must return a value 0 <= x < upperLimit
			return someFunctionOfMyKeyType (key) % upperLimit;
		}
	};
	@endcode

	Like the Array class, the key and value types are expected to be copy-by-value types, so
	if you define them to be pointer types, this class won't delete the objects that they
	point to.

	If you don't supply a class for the HashFunctionToUse template parameter, the
	default one provides some simple mappings for strings and ints.

	@code
	HashMap<int, String> hash;
	hash.set (1, "item1");
	hash.set (2, "item2");

	DBG (hash [1]); // prints "item1"
	DBG (hash [2]); // prints "item2"

	// This iterates the map, printing all of its key -> value pairs..
	for (HashMap<int, String>::Iterator i (hash); i.next();)
		DBG (i.getKey() << " -> " << i.getValue());
	@endcode

	@see CriticalSection, DefaultHashFunctions, NamedValueSet, SortedSet
*/
template <typename KeyType,
		  typename ValueType,
		  class HashFunctionToUse = DefaultHashFunctions,
		  class TypeOfCriticalSectionToUse = DummyCriticalSection>
class HashMap
{
private:
	typedef PARAMETER_TYPE (KeyType)   KeyTypeParameter;
	typedef PARAMETER_TYPE (ValueType) ValueTypeParameter;

public:

	/** Creates an empty hash-map.

		The numberOfSlots parameter specifies the number of hash entries the map will use. This
		will be the "upperLimit" parameter that is passed to your generateHash() function. The number
		of hash slots will grow automatically if necessary, or it can be remapped manually using remapTable().
	*/
	explicit HashMap (const int numberOfSlots = defaultHashTableSize)
	   : totalNumItems (0)
	{
		slots.insertMultiple (0, nullptr, numberOfSlots);
	}

	/** Destructor. */
	~HashMap()
	{
		clear();
	}

	/** Removes all values from the map.
		Note that this will clear the content, but won't affect the number of slots (see
		remapTable and getNumSlots).
	*/
	void clear()
	{
		const ScopedLockType sl (getLock());

		for (int i = slots.size(); --i >= 0;)
		{
			HashEntry* h = slots.getUnchecked(i);

			while (h != nullptr)
			{
				const ScopedPointer<HashEntry> deleter (h);
				h = h->nextEntry;
			}

			slots.set (i, nullptr);
		}

		totalNumItems = 0;
	}

	/** Returns the current number of items in the map. */
	inline int size() const noexcept
	{
		return totalNumItems;
	}

	/** Returns the value corresponding to a given key.
		If the map doesn't contain the key, a default instance of the value type is returned.
		@param keyToLookFor    the key of the item being requested
	*/
	inline const ValueType operator[] (KeyTypeParameter keyToLookFor) const
	{
		const ScopedLockType sl (getLock());

		for (const HashEntry* entry = slots.getUnchecked (generateHashFor (keyToLookFor)); entry != nullptr; entry = entry->nextEntry)
			if (entry->key == keyToLookFor)
				return entry->value;

		return ValueType();
	}

	/** Returns true if the map contains an item with the specied key. */
	bool contains (KeyTypeParameter keyToLookFor) const
	{
		const ScopedLockType sl (getLock());

		for (const HashEntry* entry = slots.getUnchecked (generateHashFor (keyToLookFor)); entry != nullptr; entry = entry->nextEntry)
			if (entry->key == keyToLookFor)
				return true;

		return false;
	}

	/** Returns true if the hash contains at least one occurrence of a given value. */
	bool containsValue (ValueTypeParameter valueToLookFor) const
	{
		const ScopedLockType sl (getLock());

		for (int i = getNumSlots(); --i >= 0;)
			for (const HashEntry* entry = slots.getUnchecked(i); entry != nullptr; entry = entry->nextEntry)
				if (entry->value == valueToLookFor)
					return true;

		return false;
	}

	/** Adds or replaces an element in the hash-map.
		If there's already an item with the given key, this will replace its value. Otherwise, a new item
		will be added to the map.
	*/
	void set (KeyTypeParameter newKey, ValueTypeParameter newValue)
	{
		const ScopedLockType sl (getLock());
		const int hashIndex = generateHashFor (newKey);

		HashEntry* const firstEntry = slots.getUnchecked (hashIndex);

		for (HashEntry* entry = firstEntry; entry != nullptr; entry = entry->nextEntry)
		{
			if (entry->key == newKey)
			{
				entry->value = newValue;
				return;
			}
		}

		slots.set (hashIndex, new HashEntry (newKey, newValue, firstEntry));
		++totalNumItems;

		if (totalNumItems > (getNumSlots() * 3) / 2)
			remapTable (getNumSlots() * 2);
	}

	/** Removes an item with the given key. */
	void remove (KeyTypeParameter keyToRemove)
	{
		const ScopedLockType sl (getLock());
		const int hashIndex = generateHashFor (keyToRemove);
		HashEntry* entry = slots.getUnchecked (hashIndex);
		HashEntry* previous = nullptr;

		while (entry != nullptr)
		{
			if (entry->key == keyToRemove)
			{
				const ScopedPointer<HashEntry> deleter (entry);

				entry = entry->nextEntry;

				if (previous != nullptr)
					previous->nextEntry = entry;
				else
					slots.set (hashIndex, entry);

				--totalNumItems;
			}
			else
			{
				previous = entry;
				entry = entry->nextEntry;
			}
		}
	}

	/** Removes all items with the given value. */
	void removeValue (ValueTypeParameter valueToRemove)
	{
		const ScopedLockType sl (getLock());

		for (int i = getNumSlots(); --i >= 0;)
		{
			HashEntry* entry = slots.getUnchecked(i);
			HashEntry* previous = nullptr;

			while (entry != nullptr)
			{
				if (entry->value == valueToRemove)
				{
					const ScopedPointer<HashEntry> deleter (entry);

					entry = entry->nextEntry;

					if (previous != nullptr)
						previous->nextEntry = entry;
					else
						slots.set (i, entry);

					--totalNumItems;
				}
				else
				{
					previous = entry;
					entry = entry->nextEntry;
				}
			}
		}
	}

	/** Remaps the hash-map to use a different number of slots for its hash function.
		Each slot corresponds to a single hash-code, and each one can contain multiple items.
		@see getNumSlots()
	*/
	void remapTable (int newNumberOfSlots)
	{
		HashMap newTable (newNumberOfSlots);

		for (int i = getNumSlots(); --i >= 0;)
			for (const HashEntry* entry = slots.getUnchecked(i); entry != nullptr; entry = entry->nextEntry)
				newTable.set (entry->key, entry->value);

		swapWith (newTable);
	}

	/** Returns the number of slots which are available for hashing.
		Each slot corresponds to a single hash-code, and each one can contain multiple items.
		@see getNumSlots()
	*/
	inline int getNumSlots() const noexcept
	{
		return slots.size();
	}

	/** Efficiently swaps the contents of two hash-maps. */
	void swapWith (HashMap& otherHashMap) noexcept
	{
		const ScopedLockType lock1 (getLock());
		const ScopedLockType lock2 (otherHashMap.getLock());

		slots.swapWithArray (otherHashMap.slots);
		std::swap (totalNumItems, otherHashMap.totalNumItems);
	}

	/** Returns the CriticalSection that locks this structure.
		To lock, you can call getLock().enter() and getLock().exit(), or preferably use
		an object of ScopedLockType as an RAII lock for it.
	*/
	inline const TypeOfCriticalSectionToUse& getLock() const noexcept      { return lock; }

	/** Returns the type of scoped lock to use for locking this array */
	typedef typename TypeOfCriticalSectionToUse::ScopedLockType ScopedLockType;

private:

	class HashEntry
	{
	public:
		HashEntry (KeyTypeParameter key_, ValueTypeParameter value_, HashEntry* const nextEntry_)
			: key (key_), value (value_), nextEntry (nextEntry_)
		{}

		const KeyType key;
		ValueType value;
		HashEntry* nextEntry;

		JUCE_DECLARE_NON_COPYABLE (HashEntry);
	};

public:

	/** Iterates over the items in a HashMap.

		To use it, repeatedly call next() until it returns false, e.g.
		@code
		HashMap <String, String> myMap;

		HashMap<String, String>::Iterator i (myMap);

		while (i.next())
		{
			DBG (i.getKey() << " -> " << i.getValue());
		}
		@endcode

		The order in which items are iterated bears no resemblence to the order in which
		they were originally added!

		Obviously as soon as you call any non-const methods on the original hash-map, any
		iterators that were created beforehand will cease to be valid, and should not be used.

		@see HashMap
	*/
	class Iterator
	{
	public:

		Iterator (const HashMap& hashMapToIterate)
			: hashMap (hashMapToIterate), entry (nullptr), index (0)
		{}

		/** Moves to the next item, if one is available.
			When this returns true, you can get the item's key and value using getKey() and
			getValue(). If it returns false, the iteration has finished and you should stop.
		*/
		bool next()
		{
			if (entry != nullptr)
				entry = entry->nextEntry;

			while (entry == nullptr)
			{
				if (index >= hashMap.getNumSlots())
					return false;

				entry = hashMap.slots.getUnchecked (index++);
			}

			return true;
		}

		/** Returns the current item's key.
			This should only be called when a call to next() has just returned true.
		*/
		KeyType getKey() const
		{
			return entry != nullptr ? entry->key : KeyType();
		}

		/** Returns the current item's value.
			This should only be called when a call to next() has just returned true.
		*/
		ValueType getValue() const
		{
			return entry != nullptr ? entry->value : ValueType();
		}

	private:

		const HashMap& hashMap;
		HashEntry* entry;
		int index;

		JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (Iterator);
	};

private:

	enum { defaultHashTableSize = 101 };
	friend class Iterator;

	Array <HashEntry*> slots;
	int totalNumItems;
	TypeOfCriticalSectionToUse lock;

	int generateHashFor (KeyTypeParameter key) const
	{
		const int hash = HashFunctionToUse::generateHash (key, getNumSlots());
		jassert (isPositiveAndBelow (hash, getNumSlots())); // your hash function is generating out-of-range numbers!
		return hash;
	}

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (HashMap);
};

#endif   // __JUCE_HASHMAP_JUCEHEADER__

/*** End of inlined file: juce_HashMap.h ***/


#endif
#ifndef __JUCE_LINKEDLISTPOINTER_JUCEHEADER__

#endif
#ifndef __JUCE_NAMEDVALUESET_JUCEHEADER__

#endif
#ifndef __JUCE_OWNEDARRAY_JUCEHEADER__

#endif
#ifndef __JUCE_PROPERTYSET_JUCEHEADER__

/*** Start of inlined file: juce_PropertySet.h ***/
#ifndef __JUCE_PROPERTYSET_JUCEHEADER__
#define __JUCE_PROPERTYSET_JUCEHEADER__


/*** Start of inlined file: juce_StringPairArray.h ***/
#ifndef __JUCE_STRINGPAIRARRAY_JUCEHEADER__
#define __JUCE_STRINGPAIRARRAY_JUCEHEADER__


/*** Start of inlined file: juce_StringArray.h ***/
#ifndef __JUCE_STRINGARRAY_JUCEHEADER__
#define __JUCE_STRINGARRAY_JUCEHEADER__

/**
	A special array for holding a list of strings.

	@see String, StringPairArray
*/
class JUCE_API  StringArray
{
public:

	/** Creates an empty string array */
	StringArray() noexcept;

	/** Creates a copy of another string array */
	StringArray (const StringArray& other);

   #if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
	StringArray (StringArray&& other) noexcept;
   #endif

	/** Creates an array containing a single string. */
	explicit StringArray (const String& firstValue);

	/** Creates a copy of an array of string literals.
		@param strings          an array of strings to add. Null pointers in the array will be
								treated as empty strings
		@param numberOfStrings  how many items there are in the array
	*/
	StringArray (const char* const* strings, int numberOfStrings);

	/** Creates a copy of a null-terminated array of string literals.

		Each item from the array passed-in is added, until it encounters a null pointer,
		at which point it stops.
	*/
	explicit StringArray (const char* const* strings);

	/** Creates a copy of a null-terminated array of string literals.
		Each item from the array passed-in is added, until it encounters a null pointer,
		at which point it stops.
	*/
	explicit StringArray (const wchar_t* const* strings);

	/** Creates a copy of an array of string literals.
		@param strings          an array of strings to add. Null pointers in the array will be
								treated as empty strings
		@param numberOfStrings  how many items there are in the array
	*/
	StringArray (const wchar_t* const* strings, int numberOfStrings);

	/** Destructor. */
	~StringArray();

	/** Copies the contents of another string array into this one */
	StringArray& operator= (const StringArray& other);

   #if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
	StringArray& operator= (StringArray&& other) noexcept;
   #endif

	/** Compares two arrays.
		Comparisons are case-sensitive.
		@returns    true only if the other array contains exactly the same strings in the same order
	*/
	bool operator== (const StringArray& other) const noexcept;

	/** Compares two arrays.
		Comparisons are case-sensitive.
		@returns    false if the other array contains exactly the same strings in the same order
	*/
	bool operator!= (const StringArray& other) const noexcept;

	/** Returns the number of strings in the array */
	inline int size() const noexcept                                    { return strings.size(); };

	/** Returns one of the strings from the array.

		If the index is out-of-range, an empty string is returned.

		Obviously the reference returned shouldn't be stored for later use, as the
		string it refers to may disappear when the array changes.
	*/
	const String& operator[] (int index) const noexcept;

	/** Returns a reference to one of the strings in the array.
		This lets you modify a string in-place in the array, but you must be sure that
		the index is in-range.
	*/
	String& getReference (int index) noexcept;

	/** Searches for a string in the array.

		The comparison will be case-insensitive if the ignoreCase parameter is true.

		@returns    true if the string is found inside the array
	*/
	bool contains (const String& stringToLookFor,
				   bool ignoreCase = false) const;

	/** Searches for a string in the array.

		The comparison will be case-insensitive if the ignoreCase parameter is true.

		@param stringToLookFor  the string to try to find
		@param ignoreCase       whether the comparison should be case-insensitive
		@param startIndex       the first index to start searching from
		@returns                the index of the first occurrence of the string in this array,
								or -1 if it isn't found.
	*/
	int indexOf (const String& stringToLookFor,
				 bool ignoreCase = false,
				 int startIndex = 0) const;

	/** Appends a string at the end of the array. */
	void add (const String& stringToAdd);

	/** Inserts a string into the array.

		This will insert a string into the array at the given index, moving
		up the other elements to make room for it.
		If the index is less than zero or greater than the size of the array,
		the new string will be added to the end of the array.
	*/
	void insert (int index, const String& stringToAdd);

	/** Adds a string to the array as long as it's not already in there.

		The search can optionally be case-insensitive.
	*/
	void addIfNotAlreadyThere (const String& stringToAdd, bool ignoreCase = false);

	/** Replaces one of the strings in the array with another one.

		If the index is higher than the array's size, the new string will be
		added to the end of the array; if it's less than zero nothing happens.
	*/
	void set (int index, const String& newString);

	/** Appends some strings from another array to the end of this one.

		@param other                the array to add
		@param startIndex           the first element of the other array to add
		@param numElementsToAdd     the maximum number of elements to add (if this is
									less than zero, they are all added)
	*/
	void addArray (const StringArray& other,
				   int startIndex = 0,
				   int numElementsToAdd = -1);

	/** Breaks up a string into tokens and adds them to this array.

		This will tokenise the given string using whitespace characters as the
		token delimiters, and will add these tokens to the end of the array.

		@returns    the number of tokens added
	*/
	int addTokens (const String& stringToTokenise,
				   bool preserveQuotedStrings);

	/** Breaks up a string into tokens and adds them to this array.

		This will tokenise the given string (using the string passed in to define the
		token delimiters), and will add these tokens to the end of the array.

		@param stringToTokenise     the string to tokenise
		@param breakCharacters      a string of characters, any of which will be considered
									to be a token delimiter.
		@param quoteCharacters      if this string isn't empty, it defines a set of characters
									which are treated as quotes. Any text occurring
									between quotes is not broken up into tokens.
		@returns    the number of tokens added
	*/
	int addTokens (const String& stringToTokenise,
				   const String& breakCharacters,
				   const String& quoteCharacters);

	/** Breaks up a string into lines and adds them to this array.

		This breaks a string down into lines separated by \\n or \\r\\n, and adds each line
		to the array. Line-break characters are omitted from the strings that are added to
		the array.
	*/
	int addLines (const String& stringToBreakUp);

	/** Removes all elements from the array. */
	void clear();

	/** Removes a string from the array.

		If the index is out-of-range, no action will be taken.
	*/
	void remove (int index);

	/** Finds a string in the array and removes it.

		This will remove the first occurrence of the given string from the array. The
		comparison may be case-insensitive depending on the ignoreCase parameter.
	*/
	void removeString (const String& stringToRemove,
					   bool ignoreCase = false);

	/** Removes a range of elements from the array.

		This will remove a set of elements, starting from the given index,
		and move subsequent elements down to close the gap.

		If the range extends beyond the bounds of the array, it will
		be safely clipped to the size of the array.

		@param startIndex       the index of the first element to remove
		@param numberToRemove   how many elements should be removed
	*/
	void removeRange (int startIndex, int numberToRemove);

	/** Removes any duplicated elements from the array.

		If any string appears in the array more than once, only the first occurrence of
		it will be retained.

		@param ignoreCase   whether to use a case-insensitive comparison
	*/
	void removeDuplicates (bool ignoreCase);

	/** Removes empty strings from the array.

		@param removeWhitespaceStrings  if true, strings that only contain whitespace
										characters will also be removed
	*/
	void removeEmptyStrings (bool removeWhitespaceStrings = true);

	/** Moves one of the strings to a different position.

		This will move the string to a specified index, shuffling along
		any intervening elements as required.

		So for example, if you have the array { 0, 1, 2, 3, 4, 5 } then calling
		move (2, 4) would result in { 0, 1, 3, 4, 2, 5 }.

		@param currentIndex     the index of the value to be moved. If this isn't a
								valid index, then nothing will be done
		@param newIndex         the index at which you'd like this value to end up. If this
								is less than zero, the value will be moved to the end
								of the array
	*/
	void move (int currentIndex, int newIndex) noexcept;

	/** Deletes any whitespace characters from the starts and ends of all the strings. */
	void trim();

	/** Adds numbers to the strings in the array, to make each string unique.

		This will add numbers to the ends of groups of similar strings.
		e.g. if there are two "moose" strings, they will become "moose (1)" and "moose (2)"

		@param ignoreCaseWhenComparing      whether the comparison used is case-insensitive
		@param appendNumberToFirstInstance  whether the first of a group of similar strings
											also has a number appended to it.
		@param preNumberString              when adding a number, this string is added before the number.
											If you pass 0, a default string will be used, which adds
											brackets around the number.
		@param postNumberString             this string is appended after any numbers that are added.
											If you pass 0, a default string will be used, which adds
											brackets around the number.
	*/
	void appendNumbersToDuplicates (bool ignoreCaseWhenComparing,
									bool appendNumberToFirstInstance,
									CharPointer_UTF8 preNumberString = CharPointer_UTF8 (nullptr),
									CharPointer_UTF8 postNumberString = CharPointer_UTF8 (nullptr));

	/** Joins the strings in the array together into one string.

		This will join a range of elements from the array into a string, separating
		them with a given string.

		e.g. joinIntoString (",") will turn an array of "a" "b" and "c" into "a,b,c".

		@param separatorString      the string to insert between all the strings
		@param startIndex           the first element to join
		@param numberOfElements     how many elements to join together. If this is less
									than zero, all available elements will be used.
	*/
	String joinIntoString (const String& separatorString,
						   int startIndex = 0,
						   int numberOfElements = -1) const;

	/** Sorts the array into alphabetical order.

		@param ignoreCase       if true, the comparisons used will be case-sensitive.
	*/
	void sort (bool ignoreCase);

	/** Reduces the amount of storage being used by the array.

		Arrays typically allocate slightly more storage than they need, and after
		removing elements, they may have quite a lot of unused space allocated.
		This method will reduce the amount of allocated storage to a minimum.
	*/
	void minimiseStorageOverheads();

private:

	Array <String> strings;

	JUCE_LEAK_DETECTOR (StringArray);
};

#endif   // __JUCE_STRINGARRAY_JUCEHEADER__

/*** End of inlined file: juce_StringArray.h ***/

/**
	A container for holding a set of strings which are keyed by another string.

	@see StringArray
*/
class JUCE_API  StringPairArray
{
public:

	/** Creates an empty array */
	StringPairArray (bool ignoreCaseWhenComparingKeys = true);

	/** Creates a copy of another array */
	StringPairArray (const StringPairArray& other);

	/** Destructor. */
	~StringPairArray();

	/** Copies the contents of another string array into this one */
	StringPairArray& operator= (const StringPairArray& other);

	/** Compares two arrays.
		Comparisons are case-sensitive.
		@returns    true only if the other array contains exactly the same strings with the same keys
	*/
	bool operator== (const StringPairArray& other) const;

	/** Compares two arrays.
		Comparisons are case-sensitive.
		@returns    false if the other array contains exactly the same strings with the same keys
	*/
	bool operator!= (const StringPairArray& other) const;

	/** Finds the value corresponding to a key string.

		If no such key is found, this will just return an empty string. To check whether
		a given key actually exists (because it might actually be paired with an empty string), use
		the getAllKeys() method to obtain a list.

		Obviously the reference returned shouldn't be stored for later use, as the
		string it refers to may disappear when the array changes.

		@see getValue
	*/
	const String& operator[] (const String& key) const;

	/** Finds the value corresponding to a key string.

		If no such key is found, this will just return the value provided as a default.

		@see operator[]
	*/
	String getValue (const String& key, const String& defaultReturnValue) const;

	/** Returns a list of all keys in the array. */
	const StringArray& getAllKeys() const noexcept          { return keys; }

	/** Returns a list of all values in the array. */
	const StringArray& getAllValues() const noexcept        { return values; }

	/** Returns the number of strings in the array */
	inline int size() const noexcept                        { return keys.size(); };

	/** Adds or amends a key/value pair.

		If a value already exists with this key, its value will be overwritten,
		otherwise the key/value pair will be added to the array.
	*/
	void set (const String& key, const String& value);

	/** Adds the items from another array to this one.

		This is equivalent to using set() to add each of the pairs from the other array.
	*/
	void addArray (const StringPairArray& other);

	/** Removes all elements from the array. */
	void clear();

	/** Removes a string from the array based on its key.

		If the key isn't found, nothing will happen.
	*/
	void remove (const String& key);

	/** Removes a string from the array based on its index.

		If the index is out-of-range, no action will be taken.
	*/
	void remove (int index);

	/** Indicates whether to use a case-insensitive search when looking up a key string.
	*/
	void setIgnoresCase (bool shouldIgnoreCase);

	/** Returns a descriptive string containing the items.
		This is handy for dumping the contents of an array.
	*/
	String getDescription() const;

	/** Reduces the amount of storage being used by the array.

		Arrays typically allocate slightly more storage than they need, and after
		removing elements, they may have quite a lot of unused space allocated.
		This method will reduce the amount of allocated storage to a minimum.
	*/
	void minimiseStorageOverheads();

private:

	StringArray keys, values;
	bool ignoreCase;

	JUCE_LEAK_DETECTOR (StringPairArray);
};

#endif   // __JUCE_STRINGPAIRARRAY_JUCEHEADER__

/*** End of inlined file: juce_StringPairArray.h ***/


/*** Start of inlined file: juce_XmlElement.h ***/
#ifndef __JUCE_XMLELEMENT_JUCEHEADER__
#define __JUCE_XMLELEMENT_JUCEHEADER__


/*** Start of inlined file: juce_File.h ***/
#ifndef __JUCE_FILE_JUCEHEADER__
#define __JUCE_FILE_JUCEHEADER__


/*** Start of inlined file: juce_Time.h ***/
#ifndef __JUCE_TIME_JUCEHEADER__
#define __JUCE_TIME_JUCEHEADER__


/*** Start of inlined file: juce_RelativeTime.h ***/
#ifndef __JUCE_RELATIVETIME_JUCEHEADER__
#define __JUCE_RELATIVETIME_JUCEHEADER__

/** A relative measure of time.

	The time is stored as a number of seconds, at double-precision floating
	point accuracy, and may be positive or negative.

	If you need an absolute time, (i.e. a date + time), see the Time class.
*/
class JUCE_API  RelativeTime
{
public:

	/** Creates a RelativeTime.

		@param seconds  the number of seconds, which may be +ve or -ve.
		@see milliseconds, minutes, hours, days, weeks
	*/
	explicit RelativeTime (double seconds = 0.0) noexcept;

	/** Copies another relative time. */
	RelativeTime (const RelativeTime& other) noexcept;

	/** Copies another relative time. */
	RelativeTime& operator= (const RelativeTime& other) noexcept;

	/** Destructor. */
	~RelativeTime() noexcept;

	/** Creates a new RelativeTime object representing a number of milliseconds.
		@see minutes, hours, days, weeks
	*/
	static const RelativeTime milliseconds (int milliseconds) noexcept;

	/** Creates a new RelativeTime object representing a number of milliseconds.
		@see minutes, hours, days, weeks
	*/
	static const RelativeTime milliseconds (int64 milliseconds) noexcept;

	/** Creates a new RelativeTime object representing a number of minutes.
		@see milliseconds, hours, days, weeks
	*/
	static const RelativeTime minutes (double numberOfMinutes) noexcept;

	/** Creates a new RelativeTime object representing a number of hours.
		@see milliseconds, minutes, days, weeks
	*/
	static const RelativeTime hours (double numberOfHours) noexcept;

	/** Creates a new RelativeTime object representing a number of days.
		@see milliseconds, minutes, hours, weeks
	*/
	static const RelativeTime days (double numberOfDays) noexcept;

	/** Creates a new RelativeTime object representing a number of weeks.
		@see milliseconds, minutes, hours, days
	*/
	static const RelativeTime weeks (double numberOfWeeks) noexcept;

	/** Returns the number of milliseconds this time represents.
		@see milliseconds, inSeconds, inMinutes, inHours, inDays, inWeeks
	*/
	int64 inMilliseconds() const noexcept;

	/** Returns the number of seconds this time represents.
		@see inMilliseconds, inMinutes, inHours, inDays, inWeeks
	*/
	double inSeconds() const noexcept       { return seconds; }

	/** Returns the number of minutes this time represents.
		@see inMilliseconds, inSeconds, inHours, inDays, inWeeks
	*/
	double inMinutes() const noexcept;

	/** Returns the number of hours this time represents.
		@see inMilliseconds, inSeconds, inMinutes, inDays, inWeeks
	*/
	double inHours() const noexcept;

	/** Returns the number of days this time represents.
		@see inMilliseconds, inSeconds, inMinutes, inHours, inWeeks
	*/
	double inDays() const noexcept;

	/** Returns the number of weeks this time represents.
		@see inMilliseconds, inSeconds, inMinutes, inHours, inDays
	*/
	double inWeeks() const noexcept;

	/** Returns a readable textual description of the time.

		The exact format of the string returned will depend on
		the magnitude of the time - e.g.

		"1 min 4 secs", "1 hr 45 mins", "2 weeks 5 days", "140 ms"

		so that only the two most significant units are printed.

		The returnValueForZeroTime value is the result that is returned if the
		length is zero. Depending on your application you might want to use this
		to return something more relevant like "empty" or "0 secs", etc.

		@see inMilliseconds, inSeconds, inMinutes, inHours, inDays, inWeeks
	*/
	String getDescription (const String& returnValueForZeroTime = "0") const;

	/** Adds another RelativeTime to this one. */
	const RelativeTime& operator+= (const RelativeTime& timeToAdd) noexcept;
	/** Subtracts another RelativeTime from this one. */
	const RelativeTime& operator-= (const RelativeTime& timeToSubtract) noexcept;

	/** Adds a number of seconds to this time. */
	const RelativeTime& operator+= (double secondsToAdd) noexcept;
	/** Subtracts a number of seconds from this time. */
	const RelativeTime& operator-= (double secondsToSubtract) noexcept;

private:

	double seconds;
};

/** Compares two RelativeTimes. */
bool operator== (const RelativeTime& t1, const RelativeTime& t2) noexcept;
/** Compares two RelativeTimes. */
bool operator!= (const RelativeTime& t1, const RelativeTime& t2) noexcept;
/** Compares two RelativeTimes. */
bool operator>  (const RelativeTime& t1, const RelativeTime& t2) noexcept;
/** Compares two RelativeTimes. */
bool operator<  (const RelativeTime& t1, const RelativeTime& t2) noexcept;
/** Compares two RelativeTimes. */
bool operator>= (const RelativeTime& t1, const RelativeTime& t2) noexcept;
/** Compares two RelativeTimes. */
bool operator<= (const RelativeTime& t1, const RelativeTime& t2) noexcept;

/** Adds two RelativeTimes together. */
RelativeTime  operator+  (const RelativeTime&  t1, const RelativeTime& t2) noexcept;
/** Subtracts two RelativeTimes. */
RelativeTime  operator-  (const RelativeTime&  t1, const RelativeTime& t2) noexcept;

#endif   // __JUCE_RELATIVETIME_JUCEHEADER__

/*** End of inlined file: juce_RelativeTime.h ***/

/**
	Holds an absolute date and time.

	Internally, the time is stored at millisecond precision.

	@see RelativeTime
*/
class JUCE_API  Time
{
public:

	/** Creates a Time object.

		This default constructor creates a time of 1st January 1970, (which is
		represented internally as 0ms).

		To create a time object representing the current time, use getCurrentTime().

		@see getCurrentTime
	*/
	Time() noexcept;

	/** Creates a time based on a number of milliseconds.

		The internal millisecond count is set to 0 (1st January 1970). To create a
		time object set to the current time, use getCurrentTime().

		@param millisecondsSinceEpoch   the number of milliseconds since the unix
										'epoch' (midnight Jan 1st 1970).
		@see getCurrentTime, currentTimeMillis
	*/
	explicit Time (int64 millisecondsSinceEpoch) noexcept;

	/** Creates a time from a set of date components.

		The timezone is assumed to be whatever the system is using as its locale.

		@param year             the year, in 4-digit format, e.g. 2004
		@param month            the month, in the range 0 to 11
		@param day              the day of the month, in the range 1 to 31
		@param hours            hours in 24-hour clock format, 0 to 23
		@param minutes          minutes 0 to 59
		@param seconds          seconds 0 to 59
		@param milliseconds     milliseconds 0 to 999
		@param useLocalTime     if true, encode using the current machine's local time; if
								false, it will always work in GMT.
	*/
	Time (int year,
		  int month,
		  int day,
		  int hours,
		  int minutes,
		  int seconds = 0,
		  int milliseconds = 0,
		  bool useLocalTime = true) noexcept;

	/** Creates a copy of another Time object. */
	Time (const Time& other) noexcept;

	/** Destructor. */
	~Time() noexcept;

	/** Copies this time from another one. */
	Time& operator= (const Time& other) noexcept;

	/** Returns a Time object that is set to the current system time.

		@see currentTimeMillis
	*/
	static Time JUCE_CALLTYPE getCurrentTime() noexcept;

	/** Returns the time as a number of milliseconds.

		@returns    the number of milliseconds this Time object represents, since
					midnight jan 1st 1970.
		@see getMilliseconds
	*/
	int64 toMilliseconds() const noexcept                           { return millisSinceEpoch; }

	/** Returns the year.

		A 4-digit format is used, e.g. 2004.
	*/
	int getYear() const noexcept;

	/** Returns the number of the month.

		The value returned is in the range 0 to 11.
		@see getMonthName
	*/
	int getMonth() const noexcept;

	/** Returns the name of the month.

		@param threeLetterVersion   if true, it'll be a 3-letter abbreviation, e.g. "Jan"; if false
									it'll return the long form, e.g. "January"
		@see getMonth
	*/
	String getMonthName (bool threeLetterVersion) const;

	/** Returns the day of the month.
		The value returned is in the range 1 to 31.
	*/
	int getDayOfMonth() const noexcept;

	/** Returns the number of the day of the week.
		The value returned is in the range 0 to 6 (0 = sunday, 1 = monday, etc).
	*/
	int getDayOfWeek() const noexcept;

	/** Returns the number of the day of the year.
		The value returned is in the range 0 to 365.
	*/
	int getDayOfYear() const noexcept;

	/** Returns the name of the weekday.

		@param threeLetterVersion   if true, it'll return a 3-letter abbreviation, e.g. "Tue"; if
									false, it'll return the full version, e.g. "Tuesday".
	*/
	String getWeekdayName (bool threeLetterVersion) const;

	/** Returns the number of hours since midnight.

		This is in 24-hour clock format, in the range 0 to 23.

		@see getHoursInAmPmFormat, isAfternoon
	*/
	int getHours() const noexcept;

	/** Returns true if the time is in the afternoon.

		So it returns true for "PM", false for "AM".

		@see getHoursInAmPmFormat, getHours
	*/
	bool isAfternoon() const noexcept;

	/** Returns the hours in 12-hour clock format.

		This will return a value 1 to 12 - use isAfternoon() to find out
		whether this is in the afternoon or morning.

		@see getHours, isAfternoon
	*/
	int getHoursInAmPmFormat() const noexcept;

	/** Returns the number of minutes, 0 to 59. */
	int getMinutes() const noexcept;

	/** Returns the number of seconds, 0 to 59. */
	int getSeconds() const noexcept;

	/** Returns the number of milliseconds, 0 to 999.

		Unlike toMilliseconds(), this just returns the position within the
		current second rather than the total number since the epoch.

		@see toMilliseconds
	*/
	int getMilliseconds() const noexcept;

	/** Returns true if the local timezone uses a daylight saving correction. */
	bool isDaylightSavingTime() const noexcept;

	/** Returns a 3-character string to indicate the local timezone. */
	String getTimeZone() const noexcept;

	/** Quick way of getting a string version of a date and time.

		For a more powerful way of formatting the date and time, see the formatted() method.

		@param includeDate      whether to include the date in the string
		@param includeTime      whether to include the time in the string
		@param includeSeconds   if the time is being included, this provides an option not to include
								the seconds in it
		@param use24HourClock   if the time is being included, sets whether to use am/pm or 24
								hour notation.
		@see formatted
	*/
	String toString (bool includeDate,
					 bool includeTime,
					 bool includeSeconds = true,
					 bool use24HourClock = false) const noexcept;

	/** Converts this date/time to a string with a user-defined format.

		This uses the C strftime() function to format this time as a string. To save you
		looking it up, these are the escape codes that strftime uses (other codes might
		work on some platforms and not others, but these are the common ones):

		%a  is replaced by the locale's abbreviated weekday name.
		%A  is replaced by the locale's full weekday name.
		%b  is replaced by the locale's abbreviated month name.
		%B  is replaced by the locale's full month name.
		%c  is replaced by the locale's appropriate date and time representation.
		%d  is replaced by the day of the month as a decimal number [01,31].
		%H  is replaced by the hour (24-hour clock) as a decimal number [00,23].
		%I  is replaced by the hour (12-hour clock) as a decimal number [01,12].
		%j  is replaced by the day of the year as a decimal number [001,366].
		%m  is replaced by the month as a decimal number [01,12].
		%M  is replaced by the minute as a decimal number [00,59].
		%p  is replaced by the locale's equivalent of either a.m. or p.m.
		%S  is replaced by the second as a decimal number [00,61].
		%U  is replaced by the week number of the year (Sunday as the first day of the week) as a decimal number [00,53].
		%w  is replaced by the weekday as a decimal number [0,6], with 0 representing Sunday.
		%W  is replaced by the week number of the year (Monday as the first day of the week) as a decimal number [00,53]. All days in a new year preceding the first Monday are considered to be in week 0.
		%x  is replaced by the locale's appropriate date representation.
		%X  is replaced by the locale's appropriate time representation.
		%y  is replaced by the year without century as a decimal number [00,99].
		%Y  is replaced by the year with century as a decimal number.
		%Z  is replaced by the timezone name or abbreviation, or by no bytes if no timezone information exists.
		%%  is replaced by %.

		@see toString
	*/
	String formatted (const String& format) const;

	/** Adds a RelativeTime to this time. */
	Time& operator+= (const RelativeTime& delta);
	/** Subtracts a RelativeTime from this time. */
	Time& operator-= (const RelativeTime& delta);

	/** Tries to set the computer's clock.

		@returns    true if this succeeds, although depending on the system, the
					application might not have sufficient privileges to do this.
	*/
	bool setSystemTimeToThisTime() const;

	/** Returns the name of a day of the week.

		@param dayNumber            the day, 0 to 6 (0 = sunday, 1 = monday, etc)
		@param threeLetterVersion   if true, it'll return a 3-letter abbreviation, e.g. "Tue"; if
									false, it'll return the full version, e.g. "Tuesday".
	*/
	static String getWeekdayName (int dayNumber,
								  bool threeLetterVersion);

	/** Returns the name of one of the months.

		@param monthNumber  the month, 0 to 11
		@param threeLetterVersion   if true, it'll be a 3-letter abbreviation, e.g. "Jan"; if false
									it'll return the long form, e.g. "January"
	*/
	static String getMonthName (int monthNumber,
								bool threeLetterVersion);

	// Static methods for getting system timers directly..

	/** Returns the current system time.

		Returns the number of milliseconds since midnight jan 1st 1970.

		Should be accurate to within a few millisecs, depending on platform,
		hardware, etc.
	*/
	static int64 currentTimeMillis() noexcept;

	/** Returns the number of millisecs since a fixed event (usually system startup).

		This returns a monotonically increasing value which it unaffected by changes to the
		system clock. It should be accurate to within a few millisecs, depending on platform,
		hardware, etc.

		Being a 32-bit return value, it will of course wrap back to 0 after 2^32 seconds of
		uptime, so be careful to take that into account. If you need a 64-bit time, you can
		use currentTimeMillis() instead.

		@see getApproximateMillisecondCounter
	*/
	static uint32 getMillisecondCounter() noexcept;

	/** Returns the number of millisecs since a fixed event (usually system startup).

		This has the same function as getMillisecondCounter(), but returns a more accurate
		value, using a higher-resolution timer if one is available.

		@see getMillisecondCounter
	*/
	static double getMillisecondCounterHiRes() noexcept;

	/** Waits until the getMillisecondCounter() reaches a given value.

		This will make the thread sleep as efficiently as it can while it's waiting.
	*/
	static void waitForMillisecondCounter (uint32 targetTime) noexcept;

	/** Less-accurate but faster version of getMillisecondCounter().

		This will return the last value that getMillisecondCounter() returned, so doesn't
		need to make a system call, but is less accurate - it shouldn't be more than
		100ms away from the correct time, though, so is still accurate enough for a
		lot of purposes.

		@see getMillisecondCounter
	*/
	static uint32 getApproximateMillisecondCounter() noexcept;

	// High-resolution timers..

	/** Returns the current high-resolution counter's tick-count.

		This is a similar idea to getMillisecondCounter(), but with a higher
		resolution.

		@see getHighResolutionTicksPerSecond, highResolutionTicksToSeconds,
			 secondsToHighResolutionTicks
	*/
	static int64 getHighResolutionTicks() noexcept;

	/** Returns the resolution of the high-resolution counter in ticks per second.

		@see getHighResolutionTicks, highResolutionTicksToSeconds,
			 secondsToHighResolutionTicks
	*/
	static int64 getHighResolutionTicksPerSecond() noexcept;

	/** Converts a number of high-resolution ticks into seconds.

		@see getHighResolutionTicks, getHighResolutionTicksPerSecond,
			 secondsToHighResolutionTicks
	*/
	static double highResolutionTicksToSeconds (int64 ticks) noexcept;

	/** Converts a number seconds into high-resolution ticks.

		@see getHighResolutionTicks, getHighResolutionTicksPerSecond,
			 highResolutionTicksToSeconds
	*/
	static int64 secondsToHighResolutionTicks (double seconds) noexcept;

private:

	int64 millisSinceEpoch;
};

/** Adds a RelativeTime to a Time. */
JUCE_API Time operator+ (const Time& time, const RelativeTime& delta);
/** Adds a RelativeTime to a Time. */
JUCE_API Time operator+ (const RelativeTime& delta, const Time& time);

/** Subtracts a RelativeTime from a Time. */
JUCE_API Time operator- (const Time& time, const RelativeTime& delta);
/** Returns the relative time difference between two times. */
JUCE_API const RelativeTime operator- (const Time& time1, const Time& time2);

/** Compares two Time objects. */
JUCE_API bool operator== (const Time& time1, const Time& time2);
/** Compares two Time objects. */
JUCE_API bool operator!= (const Time& time1, const Time& time2);
/** Compares two Time objects. */
JUCE_API bool operator<  (const Time& time1, const Time& time2);
/** Compares two Time objects. */
JUCE_API bool operator<= (const Time& time1, const Time& time2);
/** Compares two Time objects. */
JUCE_API bool operator>  (const Time& time1, const Time& time2);
/** Compares two Time objects. */
JUCE_API bool operator>= (const Time& time1, const Time& time2);

#endif   // __JUCE_TIME_JUCEHEADER__

/*** End of inlined file: juce_Time.h ***/


/*** Start of inlined file: juce_MemoryBlock.h ***/
#ifndef __JUCE_MEMORYBLOCK_JUCEHEADER__
#define __JUCE_MEMORYBLOCK_JUCEHEADER__

/**
	A class to hold a resizable block of raw data.

*/
class JUCE_API  MemoryBlock
{
public:

	/** Create an uninitialised block with 0 size. */
	MemoryBlock() noexcept;

	/** Creates a memory block with a given initial size.

		@param initialSize          the size of block to create
		@param initialiseToZero     whether to clear the memory or just leave it uninitialised
	*/
	MemoryBlock (const size_t initialSize,
				 bool initialiseToZero = false);

	/** Creates a copy of another memory block. */
	MemoryBlock (const MemoryBlock& other);

	/** Creates a memory block using a copy of a block of data.

		@param dataToInitialiseFrom     some data to copy into this block
		@param sizeInBytes              how much space to use
	*/
	MemoryBlock (const void* dataToInitialiseFrom, size_t sizeInBytes);

	/** Destructor. */
	~MemoryBlock() noexcept;

	/** Copies another memory block onto this one.

		This block will be resized and copied to exactly match the other one.
	*/
	MemoryBlock& operator= (const MemoryBlock& other);

   #if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
	MemoryBlock (MemoryBlock&& other) noexcept;
	MemoryBlock& operator= (MemoryBlock&& other) noexcept;
   #endif

	/** Compares two memory blocks.

		@returns true only if the two blocks are the same size and have identical contents.
	*/
	bool operator== (const MemoryBlock& other) const noexcept;

	/** Compares two memory blocks.

		@returns true if the two blocks are different sizes or have different contents.
	*/
	bool operator!= (const MemoryBlock& other) const noexcept;

	/** Returns true if the data in this MemoryBlock matches the raw bytes passed-in.
	*/
	bool matches (const void* data, size_t dataSize) const noexcept;

	/** Returns a void pointer to the data.

		Note that the pointer returned will probably become invalid when the
		block is resized.
	*/
	void* getData() const noexcept                                  { return data; }

	/** Returns a byte from the memory block.

		This returns a reference, so you can also use it to set a byte.
	*/
	template <typename Type>
	char& operator[] (const Type offset) const noexcept             { return data [offset]; }

	/** Returns the block's current allocated size, in bytes. */
	size_t getSize() const noexcept                                 { return size; }

	/** Resizes the memory block.

		This will try to keep as much of the block's current content as it can,
		and can optionally be made to clear any new space that gets allocated at
		the end of the block.

		@param newSize                      the new desired size for the block
		@param initialiseNewSpaceToZero     if the block gets enlarged, this determines
											whether to clear the new section or just leave it
											uninitialised
		@see ensureSize
	*/
	void setSize (const size_t newSize,
				  bool initialiseNewSpaceToZero = false);

	/** Increases the block's size only if it's smaller than a given size.

		@param minimumSize                  if the block is already bigger than this size, no action
											will be taken; otherwise it will be increased to this size
		@param initialiseNewSpaceToZero     if the block gets enlarged, this determines
											whether to clear the new section or just leave it
											uninitialised
		@see setSize
	*/
	void ensureSize (const size_t minimumSize,
					 bool initialiseNewSpaceToZero = false);

	/** Fills the entire memory block with a repeated byte value.

		This is handy for clearing a block of memory to zero.
	*/
	void fillWith (uint8 valueToUse) noexcept;

	/** Adds another block of data to the end of this one.
		The data pointer must not be null. This block's size will be increased accordingly.
	*/
	void append (const void* data, size_t numBytes);

	/** Inserts some data into the block.
		The dataToInsert pointer must not be null. This block's size will be increased accordingly.
		If the insert position lies outside the valid range of the block, it will be clipped to
		within the range before being used.
	*/
	void insert (const void* dataToInsert, size_t numBytesToInsert, size_t insertPosition);

	/** Chops out a section  of the block.

		This will remove a section of the memory block and close the gap around it,
		shifting any subsequent data downwards and reducing the size of the block.

		If the range specified goes beyond the size of the block, it will be clipped.
	*/
	void removeSection (size_t startByte, size_t numBytesToRemove);

	/** Copies data into this MemoryBlock from a memory address.

		@param srcData              the memory location of the data to copy into this block
		@param destinationOffset    the offset in this block at which the data being copied should begin
		@param numBytes             how much to copy in (if this goes beyond the size of the memory block,
									it will be clipped so not to do anything nasty)
	*/
	void copyFrom (const void* srcData,
				   int destinationOffset,
				   size_t numBytes) noexcept;

	/** Copies data from this MemoryBlock to a memory address.

		@param destData         the memory location to write to
		@param sourceOffset     the offset within this block from which the copied data will be read
		@param numBytes         how much to copy (if this extends beyond the limits of the memory block,
								zeros will be used for that portion of the data)
	*/
	void copyTo (void* destData,
				 int sourceOffset,
				 size_t numBytes) const noexcept;

	/** Exchanges the contents of this and another memory block.
		No actual copying is required for this, so it's very fast.
	*/
	void swapWith (MemoryBlock& other) noexcept;

	/** Attempts to parse the contents of the block as a zero-terminated UTF8 string. */
	String toString() const;

	/** Parses a string of hexadecimal numbers and writes this data into the memory block.

		The block will be resized to the number of valid bytes read from the string.
		Non-hex characters in the string will be ignored.

		@see String::toHexString()
	*/
	void loadFromHexString (const String& sourceHexString);

	/** Sets a number of bits in the memory block, treating it as a long binary sequence. */
	void setBitRange (size_t bitRangeStart,
					  size_t numBits,
					  int binaryNumberToApply) noexcept;

	/** Reads a number of bits from the memory block, treating it as one long binary sequence */
	int getBitRange (size_t bitRangeStart,
					 size_t numBitsToRead) const noexcept;

	/** Returns a string of characters that represent the binary contents of this block.

		Uses a 64-bit encoding system to allow binary data to be turned into a string
		of simple non-extended characters, e.g. for storage in XML.

		@see fromBase64Encoding
	*/
	String toBase64Encoding() const;

	/** Takes a string of encoded characters and turns it into binary data.

		The string passed in must have been created by to64BitEncoding(), and this
		block will be resized to recreate the original data block.

		@see toBase64Encoding
	*/
	bool fromBase64Encoding  (const String& encodedString);

private:

	HeapBlock <char> data;
	size_t size;
	static const char* const encodingTable;

	JUCE_LEAK_DETECTOR (MemoryBlock);
};

#endif   // __JUCE_MEMORYBLOCK_JUCEHEADER__

/*** End of inlined file: juce_MemoryBlock.h ***/


/*** Start of inlined file: juce_Result.h ***/
#ifndef __JUCE_RESULT_JUCEHEADER__
#define __JUCE_RESULT_JUCEHEADER__

/**
	Represents the 'success' or 'failure' of an operation, and holds an associated
	error message to describe the error when there's a failure.

	E.g.
	@code
	Result myOperation()
	{
		if (doSomeKindOfFoobar())
			return Result::ok();
		else
			return Result::fail ("foobar didn't work!");
	}

	const Result result (myOperation());

	if (result.wasOk())
	{
		...it's all good...
	}
	else
	{
		warnUserAboutFailure ("The foobar operation failed! Error message was: "
								+ result.getErrorMessage());
	}
	@endcode
*/
class JUCE_API  Result
{
public:

	/** Creates and returns a 'successful' result. */
	static Result ok() noexcept;

	/** Creates a 'failure' result.
		If you pass a blank error message in here, a default "Unknown Error" message
		will be used instead.
	*/
	static Result fail (const String& errorMessage) noexcept;

	/** Returns true if this result indicates a success. */
	bool wasOk() const noexcept;

	/** Returns true if this result indicates a failure.
		You can use getErrorMessage() to retrieve the error message associated
		with the failure.
	*/
	bool failed() const noexcept;

	/** Returns true if this result indicates a success.
		This is equivalent to calling wasOk().
	*/
	operator bool() const noexcept;

	/** Returns true if this result indicates a failure.
		This is equivalent to calling failed().
	*/
	bool operator!() const noexcept;

	/** Returns the error message that was set when this result was created.
		For a successful result, this will be an empty string;
	*/
	const String& getErrorMessage() const noexcept;

	Result (const Result& other);
	Result& operator= (const Result& other);

   #if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
	Result (Result&& other) noexcept;
	Result& operator= (Result&& other) noexcept;
   #endif

	bool operator== (const Result& other) const noexcept;
	bool operator!= (const Result& other) const noexcept;

private:
	String errorMessage;

	explicit Result (const String& errorMessage) noexcept;

	// These casts are private to prevent people trying to use the Result object in numeric contexts
	operator int() const;
	operator void*() const;
};

#endif   // __JUCE_RESULT_JUCEHEADER__

/*** End of inlined file: juce_Result.h ***/

class FileInputStream;
class FileOutputStream;

/**
	Represents a local file or directory.

	This class encapsulates the absolute pathname of a file or directory, and
	has methods for finding out about the file and changing its properties.

	To read or write to the file, there are methods for returning an input or
	output stream.

	@see FileInputStream, FileOutputStream
*/
class JUCE_API  File
{
public:

	/** Creates an (invalid) file object.

		The file is initially set to an empty path, so getFullPath() will return
		an empty string, and comparing the file to File::nonexistent will return
		true.

		You can use its operator= method to point it at a proper file.
	*/
	File()   {}

	/** Creates a file from an absolute path.

		If the path supplied is a relative path, it is taken to be relative
		to the current working directory (see File::getCurrentWorkingDirectory()),
		but this isn't a recommended way of creating a file, because you
		never know what the CWD is going to be.

		On the Mac/Linux, the path can include "~" notation for referring to
		user home directories.
	*/
	File (const String& path);

	/** Creates a copy of another file object. */
	File (const File& other);

	/** Destructor. */
	~File()  {}

	/** Sets the file based on an absolute pathname.

		If the path supplied is a relative path, it is taken to be relative
		to the current working directory (see File::getCurrentWorkingDirectory()),
		but this isn't a recommended way of creating a file, because you
		never know what the CWD is going to be.

		On the Mac/Linux, the path can include "~" notation for referring to
		user home directories.
	*/
	File& operator= (const String& newFilePath);

	/** Copies from another file object. */
	File& operator= (const File& otherFile);

   #if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
	File (File&& otherFile) noexcept;
	File& operator= (File&& otherFile) noexcept;
   #endif

	/** This static constant is used for referring to an 'invalid' file. */
	static const File nonexistent;

	/** Checks whether the file actually exists.

		@returns    true if the file exists, either as a file or a directory.
		@see existsAsFile, isDirectory
	*/
	bool exists() const;

	/** Checks whether the file exists and is a file rather than a directory.

		@returns    true only if this is a real file, false if it's a directory
					or doesn't exist
		@see exists, isDirectory
	*/
	bool existsAsFile() const;

	/** Checks whether the file is a directory that exists.

		@returns    true only if the file is a directory which actually exists, so
					false if it's a file or doesn't exist at all
		@see exists, existsAsFile
	*/
	bool isDirectory() const;

	/** Returns the size of the file in bytes.

		@returns    the number of bytes in the file, or 0 if it doesn't exist.
	*/
	int64 getSize() const;

	/** Utility function to convert a file size in bytes to a neat string description.

		So for example 100 would return "100 bytes", 2000 would return "2 KB",
		2000000 would produce "2 MB", etc.
	*/
	static String descriptionOfSizeInBytes (int64 bytes);

	/** Returns the complete, absolute path of this file.

		This includes the filename and all its parent folders. On Windows it'll
		also include the drive letter prefix; on Mac or Linux it'll be a complete
		path starting from the root folder.

		If you just want the file's name, you should use getFileName() or
		getFileNameWithoutExtension().

		@see getFileName, getRelativePathFrom
	*/
	const String& getFullPathName() const noexcept          { return fullPath; }

	/** Returns the last section of the pathname.

		Returns just the final part of the path - e.g. if the whole path
		is "/moose/fish/foo.txt" this will return "foo.txt".

		For a directory, it returns the final part of the path - e.g. for the
		directory "/moose/fish" it'll return "fish".

		If the filename begins with a dot, it'll return the whole filename, e.g. for
		"/moose/.fish", it'll return ".fish"

		@see getFullPathName, getFileNameWithoutExtension
	*/
	String getFileName() const;

	/** Creates a relative path that refers to a file relatively to a given directory.

		e.g. File ("/moose/foo.txt").getRelativePathFrom (File ("/moose/fish/haddock"))
			 would return "../../foo.txt".

		If it's not possible to navigate from one file to the other, an absolute
		path is returned. If the paths are invalid, an empty string may also be
		returned.

		@param directoryToBeRelativeTo  the directory which the resultant string will
										be relative to. If this is actually a file rather than
										a directory, its parent directory will be used instead.
										If it doesn't exist, it's assumed to be a directory.
		@see getChildFile, isAbsolutePath
	*/
	String getRelativePathFrom (const File& directoryToBeRelativeTo) const;

	/** Returns the file's extension.

		Returns the file extension of this file, also including the dot.

		e.g. "/moose/fish/foo.txt" would return ".txt"

		@see hasFileExtension, withFileExtension, getFileNameWithoutExtension
	*/
	String getFileExtension() const;

	/** Checks whether the file has a given extension.

		@param extensionToTest  the extension to look for - it doesn't matter whether or
								not this string has a dot at the start, so ".wav" and "wav"
								will have the same effect. The comparison used is
								case-insensitve. To compare with multiple extensions, this
								parameter can contain multiple strings, separated by semi-colons -
								so, for example: hasFileExtension (".jpeg;png;gif") would return
								true if the file has any of those three extensions.

		@see getFileExtension, withFileExtension, getFileNameWithoutExtension
	*/
	bool hasFileExtension (const String& extensionToTest) const;

	/** Returns a version of this file with a different file extension.

		e.g. File ("/moose/fish/foo.txt").withFileExtension ("html") returns "/moose/fish/foo.html"

		@param newExtension     the new extension, either with or without a dot at the start (this
								doesn't make any difference). To get remove a file's extension altogether,
								pass an empty string into this function.

		@see getFileName, getFileExtension, hasFileExtension, getFileNameWithoutExtension
	*/
	File withFileExtension (const String& newExtension) const;

	/** Returns the last part of the filename, without its file extension.

		e.g. for "/moose/fish/foo.txt" this will return "foo".

		@see getFileName, getFileExtension, hasFileExtension, withFileExtension
	*/
	String getFileNameWithoutExtension() const;

	/** Returns a 32-bit hash-code that identifies this file.

		This is based on the filename. Obviously it's possible, although unlikely, that
		two files will have the same hash-code.
	*/
	int hashCode() const;

	/** Returns a 64-bit hash-code that identifies this file.

		This is based on the filename. Obviously it's possible, although unlikely, that
		two files will have the same hash-code.
	*/
	int64 hashCode64() const;

	/** Returns a file based on a relative path.

		This will find a child file or directory of the current object.

		e.g.
			File ("/moose/fish").getChildFile ("foo.txt") will produce "/moose/fish/foo.txt".
			File ("/moose/fish").getChildFile ("../foo.txt") will produce "/moose/foo.txt".

		If the string is actually an absolute path, it will be treated as such, e.g.
			File ("/moose/fish").getChildFile ("/foo.txt") will produce "/foo.txt"

		@see getSiblingFile, getParentDirectory, getRelativePathFrom, isAChildOf
	*/
	File getChildFile (String relativePath) const;

	/** Returns a file which is in the same directory as this one.

		This is equivalent to getParentDirectory().getChildFile (name).

		@see getChildFile, getParentDirectory
	*/
	File getSiblingFile (const String& siblingFileName) const;

	/** Returns the directory that contains this file or directory.

		e.g. for "/moose/fish/foo.txt" this will return "/moose/fish".
	*/
	File getParentDirectory() const;

	/** Checks whether a file is somewhere inside a directory.

		Returns true if this file is somewhere inside a subdirectory of the directory
		that is passed in. Neither file actually has to exist, because the function
		just checks the paths for similarities.

		e.g. File ("/moose/fish/foo.txt").isAChildOf ("/moose") is true.
			 File ("/moose/fish/foo.txt").isAChildOf ("/moose/fish") is also true.
	*/
	bool isAChildOf (const File& potentialParentDirectory) const;

	/** Chooses a filename relative to this one that doesn't already exist.

		If this file is a directory, this will return a child file of this
		directory that doesn't exist, by adding numbers to a prefix and suffix until
		it finds one that isn't already there.

		If the prefix + the suffix doesn't exist, it won't bother adding a number.

		e.g. File ("/moose/fish").getNonexistentChildFile ("foo", ".txt", true) might
			 return "/moose/fish/foo(2).txt" if there's already a file called "foo.txt".

		@param prefix                   the string to use for the filename before the number
		@param suffix                   the string to add to the filename after the number
		@param putNumbersInBrackets     if true, this will create filenames in the
										format "prefix(number)suffix", if false, it will leave the
										brackets out.
	*/
	File getNonexistentChildFile (const String& prefix,
								  const String& suffix,
								  bool putNumbersInBrackets = true) const;

	/** Chooses a filename for a sibling file to this one that doesn't already exist.

		If this file doesn't exist, this will just return itself, otherwise it
		will return an appropriate sibling that doesn't exist, e.g. if a file
		"/moose/fish/foo.txt" exists, this might return "/moose/fish/foo(2).txt".

		@param putNumbersInBrackets     whether to add brackets around the numbers that
										get appended to the new filename.
	*/
	File getNonexistentSibling (bool putNumbersInBrackets = true) const;

	/** Compares the pathnames for two files. */
	bool operator== (const File& otherFile) const;
	/** Compares the pathnames for two files. */
	bool operator!= (const File& otherFile) const;
	/** Compares the pathnames for two files. */
	bool operator< (const File& otherFile) const;
	/** Compares the pathnames for two files. */
	bool operator> (const File& otherFile) const;

	/** Checks whether a file can be created or written to.

		@returns    true if it's possible to create and write to this file. If the file
					doesn't already exist, this will check its parent directory to
					see if writing is allowed.
		@see setReadOnly
	*/
	bool hasWriteAccess() const;

	/** Changes the write-permission of a file or directory.

		@param shouldBeReadOnly     whether to add or remove write-permission
		@param applyRecursively     if the file is a directory and this is true, it will
									recurse through all the subfolders changing the permissions
									of all files
		@returns    true if it manages to change the file's permissions.
		@see hasWriteAccess
	*/
	bool setReadOnly (bool shouldBeReadOnly,
					  bool applyRecursively = false) const;

	/** Returns true if this file is a hidden or system file.

		The criteria for deciding whether a file is hidden are platform-dependent.
	*/
	bool isHidden() const;

	/** If this file is a link, this returns the file that it points to.

		If this file isn't actually link, it'll just return itself.
	*/
	File getLinkedTarget() const;

	/** Returns the last modification time of this file.

		@returns    the time, or an invalid time if the file doesn't exist.
		@see setLastModificationTime, getLastAccessTime, getCreationTime
	*/
	Time getLastModificationTime() const;

	/** Returns the last time this file was accessed.

		@returns    the time, or an invalid time if the file doesn't exist.
		@see setLastAccessTime, getLastModificationTime, getCreationTime
	*/
	Time getLastAccessTime() const;

	/** Returns the time that this file was created.

		@returns    the time, or an invalid time if the file doesn't exist.
		@see getLastModificationTime, getLastAccessTime
	*/
	Time getCreationTime() const;

	/** Changes the modification time for this file.

		@param newTime  the time to apply to the file
		@returns true if it manages to change the file's time.
		@see getLastModificationTime, setLastAccessTime, setCreationTime
	*/
	bool setLastModificationTime (const Time& newTime) const;

	/** Changes the last-access time for this file.

		@param newTime  the time to apply to the file
		@returns true if it manages to change the file's time.
		@see getLastAccessTime, setLastModificationTime, setCreationTime
	*/
	bool setLastAccessTime (const Time& newTime) const;

	/** Changes the creation date for this file.

		@param newTime  the time to apply to the file
		@returns true if it manages to change the file's time.
		@see getCreationTime, setLastModificationTime, setLastAccessTime
	*/
	bool setCreationTime (const Time& newTime) const;

	/** If possible, this will try to create a version string for the given file.

		The OS may be able to look at the file and give a version for it - e.g. with
		executables, bundles, dlls, etc. If no version is available, this will
		return an empty string.
	*/
	String getVersion() const;

	/** Creates an empty file if it doesn't already exist.

		If the file that this object refers to doesn't exist, this will create a file
		of zero size.

		If it already exists or is a directory, this method will do nothing.

		@returns    true if the file has been created (or if it already existed).
		@see createDirectory
	*/
	Result create() const;

	/** Creates a new directory for this filename.

		This will try to create the file as a directory, and fill also create
		any parent directories it needs in order to complete the operation.

		@returns    a result to indicate whether the directory was created successfully, or
					an error message if it failed.
		@see create
	*/
	Result createDirectory() const;

	/** Deletes a file.

		If this file is actually a directory, it may not be deleted correctly if it
		contains files. See deleteRecursively() as a better way of deleting directories.

		@returns    true if the file has been successfully deleted (or if it didn't exist to
					begin with).
		@see deleteRecursively
	*/
	bool deleteFile() const;

	/** Deletes a file or directory and all its subdirectories.

		If this file is a directory, this will try to delete it and all its subfolders. If
		it's just a file, it will just try to delete the file.

		@returns    true if the file and all its subfolders have been successfully deleted
					(or if it didn't exist to begin with).
		@see deleteFile
	*/
	bool deleteRecursively() const;

	/** Moves this file or folder to the trash.

		@returns true if the operation succeeded. It could fail if the trash is full, or
				 if the file is write-protected, so you should check the return value
				 and act appropriately.
	*/
	bool moveToTrash() const;

	/** Moves or renames a file.

		Tries to move a file to a different location.
		If the target file already exists, this will attempt to delete it first, and
		will fail if this can't be done.

		Note that the destination file isn't the directory to put it in, it's the actual
		filename that you want the new file to have.

		@returns    true if the operation succeeds
	*/
	bool moveFileTo (const File& targetLocation) const;

	/** Copies a file.

		Tries to copy a file to a different location.
		If the target file already exists, this will attempt to delete it first, and
		will fail if this can't be done.

		@returns    true if the operation succeeds
	*/
	bool copyFileTo (const File& targetLocation) const;

	/** Copies a directory.

		Tries to copy an entire directory, recursively.

		If this file isn't a directory or if any target files can't be created, this
		will return false.

		@param newDirectory    the directory that this one should be copied to. Note that this
							   is the name of the actual directory to create, not the directory
							   into which the new one should be placed, so there must be enough
							   write privileges to create it if it doesn't exist. Any files inside
							   it will be overwritten by similarly named ones that are copied.
	*/
	bool copyDirectoryTo (const File& newDirectory) const;

	/** Used in file searching, to specify whether to return files, directories, or both.
	*/
	enum TypesOfFileToFind
	{
		findDirectories             = 1,    /**< Use this flag to indicate that you want to find directories. */
		findFiles                   = 2,    /**< Use this flag to indicate that you want to find files. */
		findFilesAndDirectories     = 3,    /**< Use this flag to indicate that you want to find both files and directories. */
		ignoreHiddenFiles           = 4     /**< Add this flag to avoid returning any hidden files in the results. */
	};

	/** Searches inside a directory for files matching a wildcard pattern.

		Assuming that this file is a directory, this method will search it
		for either files or subdirectories whose names match a filename pattern.

		@param results                  an array to which File objects will be added for the
										files that the search comes up with
		@param whatToLookFor            a value from the TypesOfFileToFind enum, specifying whether to
										return files, directories, or both. If the ignoreHiddenFiles flag
										is also added to this value, hidden files won't be returned
		@param searchRecursively        if true, all subdirectories will be recursed into to do
										an exhaustive search
		@param wildCardPattern          the filename pattern to search for, e.g. "*.txt"
		@returns                        the number of results that have been found

		@see getNumberOfChildFiles, DirectoryIterator
	*/
	int findChildFiles (Array<File>& results,
						int whatToLookFor,
						bool searchRecursively,
						const String& wildCardPattern = "*") const;

	/** Searches inside a directory and counts how many files match a wildcard pattern.

		Assuming that this file is a directory, this method will search it
		for either files or subdirectories whose names match a filename pattern,
		and will return the number of matches found.

		This isn't a recursive call, and will only search this directory, not
		its children.

		@param whatToLookFor    a value from the TypesOfFileToFind enum, specifying whether to
								count files, directories, or both. If the ignoreHiddenFiles flag
								is also added to this value, hidden files won't be counted
		@param wildCardPattern  the filename pattern to search for, e.g. "*.txt"
		@returns                the number of matches found
		@see findChildFiles, DirectoryIterator
	*/
	int getNumberOfChildFiles (int whatToLookFor,
							   const String& wildCardPattern = "*") const;

	/** Returns true if this file is a directory that contains one or more subdirectories.
		@see isDirectory, findChildFiles
	*/
	bool containsSubDirectories() const;

	/** Creates a stream to read from this file.

		@returns    a stream that will read from this file (initially positioned at the
					start of the file), or 0 if the file can't be opened for some reason
		@see createOutputStream, loadFileAsData
	*/
	FileInputStream* createInputStream() const;

	/** Creates a stream to write to this file.

		If the file exists, the stream that is returned will be positioned ready for
		writing at the end of the file, so you might want to use deleteFile() first
		to write to an empty file.

		@returns    a stream that will write to this file (initially positioned at the
					end of the file), or 0 if the file can't be opened for some reason
		@see createInputStream, appendData, appendText
	*/
	FileOutputStream* createOutputStream (int bufferSize = 0x8000) const;

	/** Loads a file's contents into memory as a block of binary data.

		Of course, trying to load a very large file into memory will blow up, so
		it's better to check first.

		@param result   the data block to which the file's contents should be appended - note
						that if the memory block might already contain some data, you
						might want to clear it first
		@returns        true if the file could all be read into memory
	*/
	bool loadFileAsData (MemoryBlock& result) const;

	/** Reads a file into memory as a string.

		Attempts to load the entire file as a zero-terminated string.

		This makes use of InputStream::readEntireStreamAsString, which should
		automatically cope with unicode/acsii file formats.
	*/
	String loadFileAsString() const;

	/** Reads the contents of this file as text and splits it into lines, which are
		appended to the given StringArray.
	*/
	void readLines (StringArray& destLines) const;

	/** Appends a block of binary data to the end of the file.

		This will try to write the given buffer to the end of the file.

		@returns false if it can't write to the file for some reason
	*/
	bool appendData (const void* dataToAppend,
					 int numberOfBytes) const;

	/** Replaces this file's contents with a given block of data.

		This will delete the file and replace it with the given data.

		A nice feature of this method is that it's safe - instead of deleting
		the file first and then re-writing it, it creates a new temporary file,
		writes the data to that, and then moves the new file to replace the existing
		file. This means that if the power gets pulled out or something crashes,
		you're a lot less likely to end up with a corrupted or unfinished file..

		Returns true if the operation succeeds, or false if it fails.

		@see appendText
	*/
	bool replaceWithData (const void* dataToWrite,
						  int numberOfBytes) const;

	/** Appends a string to the end of the file.

		This will try to append a text string to the file, as either 16-bit unicode
		or 8-bit characters in the default system encoding.

		It can also write the 'ff fe' unicode header bytes before the text to indicate
		the endianness of the file.

		Any single \\n characters in the string are replaced with \\r\\n before it is written.

		@see replaceWithText
	*/
	bool appendText (const String& textToAppend,
					 bool asUnicode = false,
					 bool writeUnicodeHeaderBytes = false) const;

	/** Replaces this file's contents with a given text string.

		This will delete the file and replace it with the given text.

		A nice feature of this method is that it's safe - instead of deleting
		the file first and then re-writing it, it creates a new temporary file,
		writes the text to that, and then moves the new file to replace the existing
		file. This means that if the power gets pulled out or something crashes,
		you're a lot less likely to end up with an empty file..

		For an explanation of the parameters here, see the appendText() method.

		Returns true if the operation succeeds, or false if it fails.

		@see appendText
	*/
	bool replaceWithText (const String& textToWrite,
						  bool asUnicode = false,
						  bool writeUnicodeHeaderBytes = false) const;

	/** Attempts to scan the contents of this file and compare it to another file, returning
		true if this is possible and they match byte-for-byte.
	*/
	bool hasIdenticalContentTo (const File& other) const;

	/** Creates a set of files to represent each file root.

		e.g. on Windows this will create files for "c:\", "d:\" etc according
		to which ones are available. On the Mac/Linux, this will probably
		just add a single entry for "/".
	*/
	static void findFileSystemRoots (Array<File>& results);

	/** Finds the name of the drive on which this file lives.

		@returns the volume label of the drive, or an empty string if this isn't possible
	*/
	String getVolumeLabel() const;

	/** Returns the serial number of the volume on which this file lives.

		@returns the serial number, or zero if there's a problem doing this
	*/
	int getVolumeSerialNumber() const;

	/** Returns the number of bytes free on the drive that this file lives on.

		@returns the number of bytes free, or 0 if there's a problem finding this out
		@see getVolumeTotalSize
	*/
	int64 getBytesFreeOnVolume() const;

	/** Returns the total size of the drive that contains this file.

		@returns the total number of bytes that the volume can hold
		@see getBytesFreeOnVolume
	*/
	int64 getVolumeTotalSize() const;

	/** Returns true if this file is on a CD or DVD drive. */
	bool isOnCDRomDrive() const;

	/** Returns true if this file is on a hard disk.

		This will fail if it's a network drive, but will still be true for
		removable hard-disks.
	*/
	bool isOnHardDisk() const;

	/** Returns true if this file is on a removable disk drive.

		This might be a usb-drive, a CD-rom, or maybe a network drive.
	*/
	bool isOnRemovableDrive() const;

	/** Launches the file as a process.

		- if the file is executable, this will run it.

		- if it's a document of some kind, it will launch the document with its
		default viewer application.

		- if it's a folder, it will be opened in Explorer, Finder, or equivalent.

		@see revealToUser
	*/
	bool startAsProcess (const String& parameters = String::empty) const;

	/** Opens Finder, Explorer, or whatever the OS uses, to show the user this file's location.
		@see startAsProcess
	*/
	void revealToUser() const;

	/** A set of types of location that can be passed to the getSpecialLocation() method.
	*/
	enum SpecialLocationType
	{
		/** The user's home folder. This is the same as using File ("~"). */
		userHomeDirectory,

		/** The user's default documents folder. On Windows, this might be the user's
			"My Documents" folder. On the Mac it'll be their "Documents" folder. Linux
			doesn't tend to have one of these, so it might just return their home folder.
		*/
		userDocumentsDirectory,

		/** The folder that contains the user's desktop objects. */
		userDesktopDirectory,

		/** The folder in which applications store their persistent user-specific settings.
			On Windows, this might be "\Documents and Settings\username\Application Data".
			On the Mac, it might be "~/Library". If you're going to store your settings in here,
			always create your own sub-folder to put them in, to avoid making a mess.
		*/
		userApplicationDataDirectory,

		/** An equivalent of the userApplicationDataDirectory folder that is shared by all users
			of the computer, rather than just the current user.

			On the Mac it'll be "/Library", on Windows, it could be something like
			"\Documents and Settings\All Users\Application Data".

			Depending on the setup, this folder may be read-only.
		*/
		commonApplicationDataDirectory,

		/** The folder that should be used for temporary files.

			Always delete them when you're finished, to keep the user's computer tidy!
		*/
		tempDirectory,

		/** Returns this application's executable file.

			If running as a plug-in or DLL, this will (where possible) be the DLL rather than the
			host app.

			On the mac this will return the unix binary, not the package folder - see
			currentApplicationFile for that.

			See also invokedExecutableFile, which is similar, but if the exe was launched from a
			file link, invokedExecutableFile will return the name of the link.
		*/
		currentExecutableFile,

		/** Returns this application's location.

			If running as a plug-in or DLL, this will (where possible) be the DLL rather than the
			host app.

			On the mac this will return the package folder (if it's in one), not the unix binary
			that's inside it - compare with currentExecutableFile.
		*/
		currentApplicationFile,

		/** Returns the file that was invoked to launch this executable.
			This may differ from currentExecutableFile if the app was started from e.g. a link - this
			will return the name of the link that was used, whereas currentExecutableFile will return
			the actual location of the target executable.
		*/
		invokedExecutableFile,

		/** In a plugin, this will return the path of the host executable. */
		hostApplicationPath,

		/** The directory in which applications normally get installed.

			So on windows, this would be something like "c:\program files", on the
			Mac "/Applications", or "/usr" on linux.
		*/
		globalApplicationsDirectory,

		/** The most likely place where a user might store their music files.
		*/
		userMusicDirectory,

		/** The most likely place where a user might store their movie files.
		*/
		userMoviesDirectory,
	};

	/** Finds the location of a special type of file or directory, such as a home folder or
		documents folder.

		@see SpecialLocationType
	*/
	static File JUCE_CALLTYPE getSpecialLocation (const SpecialLocationType type);

	/** Returns a temporary file in the system's temp directory.

		This will try to return the name of a non-existent temp file.

		To get the temp folder, you can use getSpecialLocation (File::tempDirectory).
	*/
	static File createTempFile (const String& fileNameEnding);

	/** Returns the current working directory.

		@see setAsCurrentWorkingDirectory
	*/
	static File getCurrentWorkingDirectory();

	/** Sets the current working directory to be this file.

		For this to work the file must point to a valid directory.

		@returns true if the current directory has been changed.
		@see getCurrentWorkingDirectory
	*/
	bool setAsCurrentWorkingDirectory() const;

	/** The system-specific file separator character.

		On Windows, this will be '\', on Mac/Linux, it'll be '/'
	*/
	static const juce_wchar separator;

	/** The system-specific file separator character, as a string.

		On Windows, this will be '\', on Mac/Linux, it'll be '/'
	*/
	static const String separatorString;

	/** Removes illegal characters from a filename.

		This will return a copy of the given string after removing characters
		that are not allowed in a legal filename, and possibly shortening the
		string if it's too long.

		Because this will remove slashes, don't use it on an absolute pathname.

		@see createLegalPathName
	*/
	static String createLegalFileName (const String& fileNameToFix);

	/** Removes illegal characters from a pathname.

		Similar to createLegalFileName(), but this won't remove slashes, so can
		be used on a complete pathname.

		@see createLegalFileName
	*/
	static String createLegalPathName (const String& pathNameToFix);

	/** Indicates whether filenames are case-sensitive on the current operating system.
	*/
	static bool areFileNamesCaseSensitive();

	/** Returns true if the string seems to be a fully-specified absolute path.
	*/
	static bool isAbsolutePath (const String& path);

	/** Creates a file that simply contains this string, without doing the sanity-checking
		that the normal constructors do.

		Best to avoid this unless you really know what you're doing.
	*/
	static File createFileWithoutCheckingPath (const String& path);

	/** Adds a separator character to the end of a path if it doesn't already have one. */
	static String addTrailingSeparator (const String& path);

   #if JUCE_MAC || JUCE_IOS || DOXYGEN

	/** OSX ONLY - Finds the OSType of a file from the its resources. */
	OSType getMacOSType() const;

	/** OSX ONLY - Returns true if this file is actually a bundle. */
	bool isBundle() const;
   #endif

   #if JUCE_MAC || DOXYGEN
	/** OSX ONLY - Adds this file to the OSX dock */
	void addToDock() const;
   #endif

private:

	String fullPath;

	static String parseAbsolutePath (const String&);
	String getPathUpToLastSlash() const;

	Result createDirectoryInternal (const String&) const;
	bool copyInternal (const File&) const;
	bool moveInternal (const File&) const;
	bool setFileTimesInternal (int64 modificationTime, int64 accessTime, int64 creationTime) const;
	void getFileTimesInternal (int64& modificationTime, int64& accessTime, int64& creationTime) const;
	bool setFileReadOnlyInternal (bool shouldBeReadOnly) const;

	JUCE_LEAK_DETECTOR (File);
};

#endif   // __JUCE_FILE_JUCEHEADER__

/*** End of inlined file: juce_File.h ***/

/** A handy macro to make it easy to iterate all the child elements in an XmlElement.

	The parentXmlElement should be a reference to the parent XML, and the childElementVariableName
	will be the name of a pointer to each child element.

	E.g. @code
	XmlElement* myParentXml = createSomeKindOfXmlDocument();

	forEachXmlChildElement (*myParentXml, child)
	{
		if (child->hasTagName ("FOO"))
			doSomethingWithXmlElement (child);
	}

	@endcode

	@see forEachXmlChildElementWithTagName
*/
#define forEachXmlChildElement(parentXmlElement, childElementVariableName) \
\
	for (juce::XmlElement* childElementVariableName = (parentXmlElement).getFirstChildElement(); \
		 childElementVariableName != nullptr; \
		 childElementVariableName = childElementVariableName->getNextElement())

/** A macro that makes it easy to iterate all the child elements of an XmlElement
	which have a specified tag.

	This does the same job as the forEachXmlChildElement macro, but only for those
	elements that have a particular tag name.

	The parentXmlElement should be a reference to the parent XML, and the childElementVariableName
	will be the name of a pointer to each child element. The requiredTagName is the
	tag name to match.

	E.g. @code
	XmlElement* myParentXml = createSomeKindOfXmlDocument();

	forEachXmlChildElementWithTagName (*myParentXml, child, "MYTAG")
	{
		// the child object is now guaranteed to be a <MYTAG> element..
		doSomethingWithMYTAGElement (child);
	}

	@endcode

	@see forEachXmlChildElement
*/
#define forEachXmlChildElementWithTagName(parentXmlElement, childElementVariableName, requiredTagName) \
\
	for (juce::XmlElement* childElementVariableName = (parentXmlElement).getChildByName (requiredTagName); \
		 childElementVariableName != nullptr; \
		 childElementVariableName = childElementVariableName->getNextElementWithTagName (requiredTagName))

/** Used to build a tree of elements representing an XML document.

	An XML document can be parsed into a tree of XmlElements, each of which
	represents an XML tag structure, and which may itself contain other
	nested elements.

	An XmlElement can also be converted back into a text document, and has
	lots of useful methods for manipulating its attributes and sub-elements,
	so XmlElements can actually be used as a handy general-purpose data
	structure.

	Here's an example of parsing some elements: @code
	// check we're looking at the right kind of document..
	if (myElement->hasTagName ("ANIMALS"))
	{
		// now we'll iterate its sub-elements looking for 'giraffe' elements..
		forEachXmlChildElement (*myElement, e)
		{
			if (e->hasTagName ("GIRAFFE"))
			{
				// found a giraffe, so use some of its attributes..

				String giraffeName  = e->getStringAttribute ("name");
				int giraffeAge      = e->getIntAttribute ("age");
				bool isFriendly     = e->getBoolAttribute ("friendly");
			}
		}
	}
	@endcode

	And here's an example of how to create an XML document from scratch: @code
	// create an outer node called "ANIMALS"
	XmlElement animalsList ("ANIMALS");

	for (int i = 0; i < numAnimals; ++i)
	{
		// create an inner element..
		XmlElement* giraffe = new XmlElement ("GIRAFFE");

		giraffe->setAttribute ("name", "nigel");
		giraffe->setAttribute ("age", 10);
		giraffe->setAttribute ("friendly", true);

		// ..and add our new element to the parent node
		animalsList.addChildElement (giraffe);
	}

	// now we can turn the whole thing into a text document..
	String myXmlDoc = animalsList.createDocument (String::empty);
	@endcode

	@see XmlDocument
*/
class JUCE_API  XmlElement
{
public:

	/** Creates an XmlElement with this tag name. */
	explicit XmlElement (const String& tagName) noexcept;

	/** Creates a (deep) copy of another element. */
	XmlElement (const XmlElement& other);

	/** Creates a (deep) copy of another element. */
	XmlElement& operator= (const XmlElement& other);

   #if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
	XmlElement (XmlElement&& other) noexcept;
	XmlElement& operator= (XmlElement&& other) noexcept;
   #endif

	/** Deleting an XmlElement will also delete all its child elements. */
	~XmlElement() noexcept;

	/** Compares two XmlElements to see if they contain the same text and attiributes.

		The elements are only considered equivalent if they contain the same attiributes
		with the same values, and have the same sub-nodes.

		@param other                    the other element to compare to
		@param ignoreOrderOfAttributes  if true, this means that two elements with the
										same attributes in a different order will be
										considered the same; if false, the attributes must
										be in the same order as well
	*/
	bool isEquivalentTo (const XmlElement* other,
						 bool ignoreOrderOfAttributes) const noexcept;

	/** Returns an XML text document that represents this element.

		The string returned can be parsed to recreate the same XmlElement that
		was used to create it.

		@param dtdToUse         the DTD to add to the document
		@param allOnOneLine     if true, this means that the document will not contain any
								linefeeds, so it'll be smaller but not very easy to read.
		@param includeXmlHeader whether to add the "<?xml version..etc" line at the start of the
								document
		@param encodingType     the character encoding format string to put into the xml
								header
		@param lineWrapLength   the line length that will be used before items get placed on
								a new line. This isn't an absolute maximum length, it just
								determines how lists of attributes get broken up
		@see writeToStream, writeToFile
	*/
	String createDocument (const String& dtdToUse,
						   bool allOnOneLine = false,
						   bool includeXmlHeader = true,
						   const String& encodingType = "UTF-8",
						   int lineWrapLength = 60) const;

	/** Writes the document to a stream as UTF-8.

		@param output           the stream to write to
		@param dtdToUse         the DTD to add to the document
		@param allOnOneLine     if true, this means that the document will not contain any
								linefeeds, so it'll be smaller but not very easy to read.
		@param includeXmlHeader whether to add the "<?xml version..etc" line at the start of the
								document
		@param encodingType     the character encoding format string to put into the xml
								header
		@param lineWrapLength   the line length that will be used before items get placed on
								a new line. This isn't an absolute maximum length, it just
								determines how lists of attributes get broken up
		@see writeToFile, createDocument
	*/
	void writeToStream (OutputStream& output,
						const String& dtdToUse,
						bool allOnOneLine = false,
						bool includeXmlHeader = true,
						const String& encodingType = "UTF-8",
						int lineWrapLength = 60) const;

	/** Writes the element to a file as an XML document.

		To improve safety in case something goes wrong while writing the file, this
		will actually write the document to a new temporary file in the same
		directory as the destination file, and if this succeeds, it will rename this
		new file as the destination file (overwriting any existing file that was there).

		@param destinationFile  the file to write to. If this already exists, it will be
								overwritten.
		@param dtdToUse         the DTD to add to the document
		@param encodingType     the character encoding format string to put into the xml
								header
		@param lineWrapLength   the line length that will be used before items get placed on
								a new line. This isn't an absolute maximum length, it just
								determines how lists of attributes get broken up
		@returns    true if the file is written successfully; false if something goes wrong
					in the process
		@see createDocument
	*/
	bool writeToFile (const File& destinationFile,
					  const String& dtdToUse,
					  const String& encodingType = "UTF-8",
					  int lineWrapLength = 60) const;

	/** Returns this element's tag type name.

		E.g. for an element such as \<MOOSE legs="4" antlers="2">, this would return
		"MOOSE".

		@see hasTagName
	*/
	inline const String& getTagName() const noexcept            { return tagName; }

	/** Tests whether this element has a particular tag name.

		@param possibleTagName  the tag name you're comparing it with

		@see getTagName
	*/
	bool hasTagName (const String& possibleTagName) const noexcept;

	/** Returns the number of XML attributes this element contains.

		E.g. for an element such as \<MOOSE legs="4" antlers="2">, this would
		return 2.
	*/
	int getNumAttributes() const noexcept;

	/** Returns the name of one of the elements attributes.

		E.g. for an element such as \<MOOSE legs="4" antlers="2">, then
		getAttributeName(1) would return "antlers".

		@see getAttributeValue, getStringAttribute
	*/
	const String& getAttributeName (int attributeIndex) const noexcept;

	/** Returns the value of one of the elements attributes.

		E.g. for an element such as \<MOOSE legs="4" antlers="2">, then
		getAttributeName(1) would return "2".

		@see getAttributeName, getStringAttribute
	*/
	const String& getAttributeValue (int attributeIndex) const noexcept;

	// Attribute-handling methods..

	/** Checks whether the element contains an attribute with a certain name. */
	bool hasAttribute (const String& attributeName) const noexcept;

	/** Returns the value of a named attribute.

		@param attributeName        the name of the attribute to look up
	*/
	const String& getStringAttribute (const String& attributeName) const noexcept;

	/** Returns the value of a named attribute.

		@param attributeName        the name of the attribute to look up
		@param defaultReturnValue   a value to return if the element doesn't have an attribute
									with this name
	*/
	String getStringAttribute (const String& attributeName,
							   const String& defaultReturnValue) const;

	/** Compares the value of a named attribute with a value passed-in.

		@param attributeName            the name of the attribute to look up
		@param stringToCompareAgainst   the value to compare it with
		@param ignoreCase               whether the comparison should be case-insensitive
		@returns    true if the value of the attribute is the same as the string passed-in;
					false if it's different (or if no such attribute exists)
	*/
	bool compareAttribute (const String& attributeName,
						   const String& stringToCompareAgainst,
						   bool ignoreCase = false) const noexcept;

	/** Returns the value of a named attribute as an integer.

		This will try to find the attribute and convert it to an integer (using
		the String::getIntValue() method).

		@param attributeName        the name of the attribute to look up
		@param defaultReturnValue   a value to return if the element doesn't have an attribute
									with this name
		@see setAttribute
	*/
	int getIntAttribute (const String& attributeName,
						 int defaultReturnValue = 0) const;

	/** Returns the value of a named attribute as floating-point.

		This will try to find the attribute and convert it to an integer (using
		the String::getDoubleValue() method).

		@param attributeName        the name of the attribute to look up
		@param defaultReturnValue   a value to return if the element doesn't have an attribute
									with this name
		@see setAttribute
	*/
	double getDoubleAttribute (const String& attributeName,
							   double defaultReturnValue = 0.0) const;

	/** Returns the value of a named attribute as a boolean.

		This will try to find the attribute and interpret it as a boolean. To do this,
		it'll return true if the value is "1", "true", "y", etc, or false for other
		values.

		@param attributeName        the name of the attribute to look up
		@param defaultReturnValue   a value to return if the element doesn't have an attribute
									with this name
	*/
	bool getBoolAttribute (const String& attributeName,
						   bool defaultReturnValue = false) const;

	/** Adds a named attribute to the element.

		If the element already contains an attribute with this name, it's value will
		be updated to the new value. If there's no such attribute yet, a new one will
		be added.

		Note that there are other setAttribute() methods that take integers,
		doubles, etc. to make it easy to store numbers.

		@param attributeName        the name of the attribute to set
		@param newValue             the value to set it to
		@see removeAttribute
	*/
	void setAttribute (const String& attributeName,
					   const String& newValue);

	/** Adds a named attribute to the element, setting it to an integer value.

		If the element already contains an attribute with this name, it's value will
		be updated to the new value. If there's no such attribute yet, a new one will
		be added.

		Note that there are other setAttribute() methods that take integers,
		doubles, etc. to make it easy to store numbers.

		@param attributeName        the name of the attribute to set
		@param newValue             the value to set it to
	*/
	void setAttribute (const String& attributeName,
					   int newValue);

	/** Adds a named attribute to the element, setting it to a floating-point value.

		If the element already contains an attribute with this name, it's value will
		be updated to the new value. If there's no such attribute yet, a new one will
		be added.

		Note that there are other setAttribute() methods that take integers,
		doubles, etc. to make it easy to store numbers.

		@param attributeName        the name of the attribute to set
		@param newValue             the value to set it to
	*/
	void setAttribute (const String& attributeName,
					   double newValue);

	/** Removes a named attribute from the element.

		@param attributeName    the name of the attribute to remove
		@see removeAllAttributes
	*/
	void removeAttribute (const String& attributeName) noexcept;

	/** Removes all attributes from this element.
	*/
	void removeAllAttributes() noexcept;

	// Child element methods..

	/** Returns the first of this element's sub-elements.

		see getNextElement() for an example of how to iterate the sub-elements.

		@see forEachXmlChildElement
	*/
	XmlElement* getFirstChildElement() const noexcept       { return firstChildElement; }

	/** Returns the next of this element's siblings.

		This can be used for iterating an element's sub-elements, e.g.
		@code
		XmlElement* child = myXmlDocument->getFirstChildElement();

		while (child != nullptr)
		{
			...do stuff with this child..

			child = child->getNextElement();
		}
		@endcode

		Note that when iterating the child elements, some of them might be
		text elements as well as XML tags - use isTextElement() to work this
		out.

		Also, it's much easier and neater to use this method indirectly via the
		forEachXmlChildElement macro.

		@returns    the sibling element that follows this one, or zero if this is the last
					element in its parent

		@see getNextElement, isTextElement, forEachXmlChildElement
	*/
	inline XmlElement* getNextElement() const noexcept          { return nextListItem; }

	/** Returns the next of this element's siblings which has the specified tag
		name.

		This is like getNextElement(), but will scan through the list until it
		finds an element with the given tag name.

		@see getNextElement, forEachXmlChildElementWithTagName
	*/
	XmlElement* getNextElementWithTagName (const String& requiredTagName) const;

	/** Returns the number of sub-elements in this element.

		@see getChildElement
	*/
	int getNumChildElements() const noexcept;

	/** Returns the sub-element at a certain index.

		It's not very efficient to iterate the sub-elements by index - see
		getNextElement() for an example of how best to iterate.

		@returns the n'th child of this element, or 0 if the index is out-of-range
		@see getNextElement, isTextElement, getChildByName
	*/
	XmlElement* getChildElement (int index) const noexcept;

	/** Returns the first sub-element with a given tag-name.

		@param tagNameToLookFor     the tag name of the element you want to find
		@returns the first element with this tag name, or 0 if none is found
		@see getNextElement, isTextElement, getChildElement
	*/
	XmlElement* getChildByName (const String& tagNameToLookFor) const noexcept;

	/** Appends an element to this element's list of children.

		Child elements are deleted automatically when their parent is deleted, so
		make sure the object that you pass in will not be deleted by anything else,
		and make sure it's not already the child of another element.

		@see getFirstChildElement, getNextElement, getNumChildElements,
			 getChildElement, removeChildElement
	*/
	void addChildElement (XmlElement* newChildElement) noexcept;

	/** Inserts an element into this element's list of children.

		Child elements are deleted automatically when their parent is deleted, so
		make sure the object that you pass in will not be deleted by anything else,
		and make sure it's not already the child of another element.

		@param newChildNode     the element to add
		@param indexToInsertAt  the index at which to insert the new element - if this is
								below zero, it will be added to the end of the list
		@see addChildElement, insertChildElement
	*/
	void insertChildElement (XmlElement* newChildNode,
							 int indexToInsertAt) noexcept;

	/** Creates a new element with the given name and returns it, after adding it
		as a child element.

		This is a handy method that means that instead of writing this:
		@code
		XmlElement* newElement = new XmlElement ("foobar");
		myParentElement->addChildElement (newElement);
		@endcode

		..you could just write this:
		@code
		XmlElement* newElement = myParentElement->createNewChildElement ("foobar");
		@endcode
	*/
	XmlElement* createNewChildElement (const String& tagName);

	/** Replaces one of this element's children with another node.

		If the current element passed-in isn't actually a child of this element,
		this will return false and the new one won't be added. Otherwise, the
		existing element will be deleted, replaced with the new one, and it
		will return true.
	*/
	bool replaceChildElement (XmlElement* currentChildElement,
							  XmlElement* newChildNode) noexcept;

	/** Removes a child element.

		@param childToRemove            the child to look for and remove
		@param shouldDeleteTheChild     if true, the child will be deleted, if false it'll
										just remove it
	*/
	void removeChildElement (XmlElement* childToRemove,
							 bool shouldDeleteTheChild) noexcept;

	/** Deletes all the child elements in the element.

		@see removeChildElement, deleteAllChildElementsWithTagName
	*/
	void deleteAllChildElements() noexcept;

	/** Deletes all the child elements with a given tag name.

		@see removeChildElement
	*/
	void deleteAllChildElementsWithTagName (const String& tagName) noexcept;

	/** Returns true if the given element is a child of this one. */
	bool containsChildElement (const XmlElement* possibleChild) const noexcept;

	/** Recursively searches all sub-elements to find one that contains the specified
		child element.
	*/
	XmlElement* findParentElementOf (const XmlElement* elementToLookFor) noexcept;

	/** Sorts the child elements using a comparator.

		This will use a comparator object to sort the elements into order. The object
		passed must have a method of the form:
		@code
		int compareElements (const XmlElement* first, const XmlElement* second);
		@endcode

		..and this method must return:
		  - a value of < 0 if the first comes before the second
		  - a value of 0 if the two objects are equivalent
		  - a value of > 0 if the second comes before the first

		To improve performance, the compareElements() method can be declared as static or const.

		@param comparator   the comparator to use for comparing elements.
		@param retainOrderOfEquivalentItems     if this is true, then items which the comparator
							says are equivalent will be kept in the order in which they
							currently appear in the array. This is slower to perform, but
							may be important in some cases. If it's false, a faster algorithm
							is used, but equivalent elements may be rearranged.
	*/
	template <class ElementComparator>
	void sortChildElements (ElementComparator& comparator,
							bool retainOrderOfEquivalentItems = false)
	{
		const int num = getNumChildElements();

		if (num > 1)
		{
			HeapBlock <XmlElement*> elems (num);
			getChildElementsAsArray (elems);
			sortArray (comparator, (XmlElement**) elems, 0, num - 1, retainOrderOfEquivalentItems);
			reorderChildElements (elems, num);
		}
	}

	/** Returns true if this element is a section of text.

		Elements can either be an XML tag element or a secton of text, so this
		is used to find out what kind of element this one is.

		@see getAllText, addTextElement, deleteAllTextElements
	*/
	bool isTextElement() const noexcept;

	/** Returns the text for a text element.

		Note that if you have an element like this:

		@code<xyz>hello</xyz>@endcode

		then calling getText on the "xyz" element won't return "hello", because that is
		actually stored in a special text sub-element inside the xyz element. To get the
		"hello" string, you could either call getText on the (unnamed) sub-element, or
		use getAllSubText() to do this automatically.

		Note that leading and trailing whitespace will be included in the string - to remove
		if, just call String::trim() on the result.

		@see isTextElement, getAllSubText, getChildElementAllSubText
	*/
	const String& getText() const noexcept;

	/** Sets the text in a text element.

		Note that this is only a valid call if this element is a text element. If it's
		not, then no action will be performed. If you're trying to add text inside a normal
		element, you probably want to use addTextElement() instead.
	*/
	void setText (const String& newText);

	/** Returns all the text from this element's child nodes.

		This iterates all the child elements and when it finds text elements,
		it concatenates their text into a big string which it returns.

		E.g. @code<xyz>hello <x>there</x> world</xyz>@endcode
		if you called getAllSubText on the "xyz" element, it'd return "hello there world".

		Note that leading and trailing whitespace will be included in the string - to remove
		if, just call String::trim() on the result.

		@see isTextElement, getChildElementAllSubText, getText, addTextElement
	*/
	String getAllSubText() const;

	/** Returns all the sub-text of a named child element.

		If there is a child element with the given tag name, this will return
		all of its sub-text (by calling getAllSubText() on it). If there is
		no such child element, this will return the default string passed-in.

		@see getAllSubText
	*/
	String getChildElementAllSubText (const String& childTagName,
									  const String& defaultReturnValue) const;

	/** Appends a section of text to this element.

		@see isTextElement, getText, getAllSubText
	*/
	void addTextElement (const String& text);

	/** Removes all the text elements from this element.

		@see isTextElement, getText, getAllSubText, addTextElement
	*/
	void deleteAllTextElements() noexcept;

	/** Creates a text element that can be added to a parent element.
	*/
	static XmlElement* createTextElement (const String& text);

private:
	struct XmlAttributeNode
	{
		XmlAttributeNode (const XmlAttributeNode&) noexcept;
		XmlAttributeNode (const String& name, const String& value) noexcept;

		LinkedListPointer<XmlAttributeNode> nextListItem;
		String name, value;

		bool hasName (const String&) const noexcept;

	private:
		XmlAttributeNode& operator= (const XmlAttributeNode&);
	};

	friend class XmlDocument;
	friend class LinkedListPointer <XmlAttributeNode>;
	friend class LinkedListPointer <XmlElement>;
	friend class LinkedListPointer <XmlElement>::Appender;

	LinkedListPointer <XmlElement> nextListItem;
	LinkedListPointer <XmlElement> firstChildElement;
	LinkedListPointer <XmlAttributeNode> attributes;
	String tagName;

	XmlElement (int) noexcept;
	void copyChildrenAndAttributesFrom (const XmlElement&);
	void writeElementAsText (OutputStream&, int indentationLevel, int lineWrapLength) const;
	void getChildElementsAsArray (XmlElement**) const noexcept;
	void reorderChildElements (XmlElement**, int) noexcept;

	JUCE_LEAK_DETECTOR (XmlElement);
};

#endif   // __JUCE_XMLELEMENT_JUCEHEADER__

/*** End of inlined file: juce_XmlElement.h ***/

/**
	A set of named property values, which can be strings, integers, floating point, etc.

	Effectively, this just wraps a StringPairArray in an interface that makes it easier
	to load and save types other than strings.

	See the PropertiesFile class for a subclass of this, which automatically broadcasts change
	messages and saves/loads the list from a file.
*/
class JUCE_API  PropertySet
{
public:

	/** Creates an empty PropertySet.

		@param ignoreCaseOfKeyNames         if true, the names of properties are compared in a
											case-insensitive way
	*/
	PropertySet (bool ignoreCaseOfKeyNames = false);

	/** Creates a copy of another PropertySet.
	*/
	PropertySet (const PropertySet& other);

	/** Copies another PropertySet over this one.
	*/
	PropertySet& operator= (const PropertySet& other);

	/** Destructor. */
	virtual ~PropertySet();

	/** Returns one of the properties as a string.

		If the value isn't found in this set, then this will look for it in a fallback
		property set (if you've specified one with the setFallbackPropertySet() method),
		and if it can't find one there, it'll return the default value passed-in.

		@param keyName              the name of the property to retrieve
		@param defaultReturnValue   a value to return if the named property doesn't actually exist
	*/
	String getValue (const String& keyName,
					 const String& defaultReturnValue = String::empty) const noexcept;

	/** Returns one of the properties as an integer.

		If the value isn't found in this set, then this will look for it in a fallback
		property set (if you've specified one with the setFallbackPropertySet() method),
		and if it can't find one there, it'll return the default value passed-in.

		@param keyName              the name of the property to retrieve
		@param defaultReturnValue   a value to return if the named property doesn't actually exist
	*/
	int getIntValue (const String& keyName,
					 const int defaultReturnValue = 0) const noexcept;

	/** Returns one of the properties as an double.

		If the value isn't found in this set, then this will look for it in a fallback
		property set (if you've specified one with the setFallbackPropertySet() method),
		and if it can't find one there, it'll return the default value passed-in.

		@param keyName              the name of the property to retrieve
		@param defaultReturnValue   a value to return if the named property doesn't actually exist
	*/
	double getDoubleValue (const String& keyName,
						   const double defaultReturnValue = 0.0) const noexcept;

	/** Returns one of the properties as an boolean.

		The result will be true if the string found for this key name can be parsed as a non-zero
		integer.

		If the value isn't found in this set, then this will look for it in a fallback
		property set (if you've specified one with the setFallbackPropertySet() method),
		and if it can't find one there, it'll return the default value passed-in.

		@param keyName              the name of the property to retrieve
		@param defaultReturnValue   a value to return if the named property doesn't actually exist
	*/
	bool getBoolValue (const String& keyName,
					   const bool defaultReturnValue = false) const noexcept;

	/** Returns one of the properties as an XML element.

		The result will a new XMLElement object that the caller must delete. If may return 0 if the
		key isn't found, or if the entry contains an string that isn't valid XML.

		If the value isn't found in this set, then this will look for it in a fallback
		property set (if you've specified one with the setFallbackPropertySet() method),
		and if it can't find one there, it'll return the default value passed-in.

		@param keyName              the name of the property to retrieve
	*/
	XmlElement* getXmlValue (const String& keyName) const;

	/** Sets a named property.

		@param keyName      the name of the property to set. (This mustn't be an empty string)
		@param value        the new value to set it to
	*/
	void setValue (const String& keyName, const var& value);

	/** Sets a named property to an XML element.

		@param keyName      the name of the property to set. (This mustn't be an empty string)
		@param xml          the new element to set it to. If this is zero, the value will be set to
							an empty string
		@see getXmlValue
	*/
	void setValue (const String& keyName, const XmlElement* xml);

	/** This copies all the values from a source PropertySet to this one.
		This won't remove any existing settings, it just adds any that it finds in the source set.
	*/
	void addAllPropertiesFrom (const PropertySet& source);

	/** Deletes a property.

		@param keyName      the name of the property to delete. (This mustn't be an empty string)
	*/
	void removeValue (const String& keyName);

	/** Returns true if the properies include the given key. */
	bool containsKey (const String& keyName) const noexcept;

	/** Removes all values. */
	void clear();

	/** Returns the keys/value pair array containing all the properties. */
	StringPairArray& getAllProperties() noexcept                        { return properties; }

	/** Returns the lock used when reading or writing to this set */
	const CriticalSection& getLock() const noexcept                     { return lock; }

	/** Returns an XML element which encapsulates all the items in this property set.

		The string parameter is the tag name that should be used for the node.

		@see restoreFromXml
	*/
	XmlElement* createXml (const String& nodeName) const;

	/** Reloads a set of properties that were previously stored as XML.

		The node passed in must have been created by the createXml() method.

		@see createXml
	*/
	void restoreFromXml (const XmlElement& xml);

	/** Sets up a second PopertySet that will be used to look up any values that aren't
		set in this one.

		If you set this up to be a pointer to a second property set, then whenever one
		of the getValue() methods fails to find an entry in this set, it will look up that
		value in the fallback set, and if it finds it, it will return that.

		Make sure that you don't delete the fallback set while it's still being used by
		another set! To remove the fallback set, just call this method with a null pointer.

		@see getFallbackPropertySet
	*/
	void setFallbackPropertySet (PropertySet* fallbackProperties) noexcept;

	/** Returns the fallback property set.
		@see setFallbackPropertySet
	*/
	PropertySet* getFallbackPropertySet() const noexcept                { return fallbackProperties; }

protected:

	/** Subclasses can override this to be told when one of the properies has been changed. */
	virtual void propertyChanged();

private:

	StringPairArray properties;
	PropertySet* fallbackProperties;
	CriticalSection lock;
	bool ignoreCaseOfKeys;

	JUCE_LEAK_DETECTOR (PropertySet);
};

#endif   // __JUCE_PROPERTYSET_JUCEHEADER__

/*** End of inlined file: juce_PropertySet.h ***/


#endif
#ifndef __JUCE_REFERENCECOUNTEDARRAY_JUCEHEADER__

/*** Start of inlined file: juce_ReferenceCountedArray.h ***/
#ifndef __JUCE_REFERENCECOUNTEDARRAY_JUCEHEADER__
#define __JUCE_REFERENCECOUNTEDARRAY_JUCEHEADER__

/**
	Holds a list of objects derived from ReferenceCountedObject.

	A ReferenceCountedArray holds objects derived from ReferenceCountedObject,
	and takes care of incrementing and decrementing their ref counts when they
	are added and removed from the array.

	To make all the array's methods thread-safe, pass in "CriticalSection" as the templated
	TypeOfCriticalSectionToUse parameter, instead of the default DummyCriticalSection.

	@see Array, OwnedArray, StringArray
*/
template <class ObjectClass, class TypeOfCriticalSectionToUse = DummyCriticalSection>
class ReferenceCountedArray
{
public:
	typedef ReferenceCountedObjectPtr<ObjectClass> ObjectClassPtr;

	/** Creates an empty array.
		@see ReferenceCountedObject, Array, OwnedArray
	*/
	ReferenceCountedArray() noexcept
		: numUsed (0)
	{
	}

	/** Creates a copy of another array */
	template <class OtherObjectClass>
	ReferenceCountedArray (const ReferenceCountedArray<OtherObjectClass, TypeOfCriticalSectionToUse>& other) noexcept
	{
		const ScopedLockType lock (other.getLock());
		numUsed = other.size();
		data.setAllocatedSize (numUsed);
		memcpy (data.elements, other.getRawDataPointer(), numUsed * sizeof (ObjectClass*));

		for (int i = numUsed; --i >= 0;)
			if (data.elements[i] != nullptr)
				data.elements[i]->incReferenceCount();
	}

	/** Copies another array into this one.

		Any existing objects in this array will first be released.
	*/
	template <class OtherObjectClass>
	ReferenceCountedArray<ObjectClass, TypeOfCriticalSectionToUse>& operator= (const ReferenceCountedArray<OtherObjectClass, TypeOfCriticalSectionToUse>& other) noexcept
	{
		ReferenceCountedArray<ObjectClass, TypeOfCriticalSectionToUse> otherCopy (other);
		swapWithArray (otherCopy);
		return *this;
	}

	/** Destructor.
		Any objects in the array will be released, and may be deleted if not referenced from elsewhere.
	*/
	~ReferenceCountedArray()
	{
		clear();
	}

	/** Removes all objects from the array.

		Any objects in the array that are not referenced from elsewhere will be deleted.
	*/
	void clear()
	{
		const ScopedLockType lock (getLock());

		while (numUsed > 0)
			if (data.elements [--numUsed] != nullptr)
				data.elements [numUsed]->decReferenceCount();

		jassert (numUsed == 0);
		data.setAllocatedSize (0);
	}

	/** Returns the current number of objects in the array. */
	inline int size() const noexcept
	{
		return numUsed;
	}

	/** Returns a pointer to the object at this index in the array.

		If the index is out-of-range, this will return a null pointer, (and
		it could be null anyway, because it's ok for the array to hold null
		pointers as well as objects).

		@see getUnchecked
	*/
	inline ObjectClassPtr operator[] (const int index) const noexcept
	{
		return getObjectPointer (index);
	}

	/** Returns a pointer to the object at this index in the array, without checking
		whether the index is in-range.

		This is a faster and less safe version of operator[] which doesn't check the index passed in, so
		it can be used when you're sure the index if always going to be legal.
	*/
	inline ObjectClassPtr getUnchecked (const int index) const noexcept
	{
		return getObjectPointerUnchecked (index);
	}

	/** Returns a raw pointer to the object at this index in the array.

		If the index is out-of-range, this will return a null pointer, (and
		it could be null anyway, because it's ok for the array to hold null
		pointers as well as objects).

		@see getUnchecked
	*/
	inline ObjectClass* getObjectPointer (const int index) const noexcept
	{
		const ScopedLockType lock (getLock());
		return isPositiveAndBelow (index, numUsed) ? data.elements [index]
												   : nullptr;
	}

	/** Returns a raw pointer to the object at this index in the array, without checking
		whether the index is in-range.
	*/
	inline ObjectClass* getObjectPointerUnchecked (const int index) const noexcept
	{
		const ScopedLockType lock (getLock());
		jassert (isPositiveAndBelow (index, numUsed));
		return data.elements [index];
	}

	/** Returns a pointer to the first object in the array.

		This will return a null pointer if the array's empty.
		@see getLast
	*/
	inline ObjectClassPtr getFirst() const noexcept
	{
		const ScopedLockType lock (getLock());
		return numUsed > 0 ? data.elements [0]
						   : static_cast <ObjectClass*> (nullptr);
	}

	/** Returns a pointer to the last object in the array.

		This will return a null pointer if the array's empty.
		@see getFirst
	*/
	inline ObjectClassPtr getLast() const noexcept
	{
		const ScopedLockType lock (getLock());
		return numUsed > 0 ? data.elements [numUsed - 1]
						   : static_cast <ObjectClass*> (nullptr);
	}

	/** Returns a pointer to the actual array data.
		This pointer will only be valid until the next time a non-const method
		is called on the array.
	*/
	inline ObjectClass** getRawDataPointer() const noexcept
	{
		return data.elements;
	}

	/** Returns a pointer to the first element in the array.
		This method is provided for compatibility with standard C++ iteration mechanisms.
	*/
	inline ObjectClass** begin() const noexcept
	{
		return data.elements;
	}

	/** Returns a pointer to the element which follows the last element in the array.
		This method is provided for compatibility with standard C++ iteration mechanisms.
	*/
	inline ObjectClass** end() const noexcept
	{
		return data.elements + numUsed;
	}

	/** Finds the index of the first occurrence of an object in the array.

		@param objectToLookFor    the object to look for
		@returns                  the index at which the object was found, or -1 if it's not found
	*/
	int indexOf (const ObjectClass* const objectToLookFor) const noexcept
	{
		const ScopedLockType lock (getLock());
		ObjectClass** e = data.elements.getData();
		ObjectClass** const end_ = e + numUsed;

		while (e != end_)
		{
			if (objectToLookFor == *e)
				return static_cast <int> (e - data.elements.getData());

			++e;
		}

		return -1;
	}

	/** Returns true if the array contains a specified object.

		@param objectToLookFor      the object to look for
		@returns                    true if the object is in the array
	*/
	bool contains (const ObjectClass* const objectToLookFor) const noexcept
	{
		const ScopedLockType lock (getLock());
		ObjectClass** e = data.elements.getData();
		ObjectClass** const end_ = e + numUsed;

		while (e != end_)
		{
			if (objectToLookFor == *e)
				return true;

			++e;
		}

		return false;
	}

	/** Appends a new object to the end of the array.

		This will increase the new object's reference count.

		@param newObject       the new object to add to the array
		@see set, insert, addIfNotAlreadyThere, addSorted, addArray
	*/
	void add (ObjectClass* const newObject) noexcept
	{
		const ScopedLockType lock (getLock());
		data.ensureAllocatedSize (numUsed + 1);
		data.elements [numUsed++] = newObject;

		if (newObject != nullptr)
			newObject->incReferenceCount();
	}

	/** Inserts a new object into the array at the given index.

		If the index is less than 0 or greater than the size of the array, the
		element will be added to the end of the array.
		Otherwise, it will be inserted into the array, moving all the later elements
		along to make room.

		This will increase the new object's reference count.

		@param indexToInsertAt      the index at which the new element should be inserted
		@param newObject            the new object to add to the array
		@see add, addSorted, addIfNotAlreadyThere, set
	*/
	void insert (int indexToInsertAt,
				 ObjectClass* const newObject) noexcept
	{
		if (indexToInsertAt >= 0)
		{
			const ScopedLockType lock (getLock());

			if (indexToInsertAt > numUsed)
				indexToInsertAt = numUsed;

			data.ensureAllocatedSize (numUsed + 1);

			ObjectClass** const e = data.elements + indexToInsertAt;
			const int numToMove = numUsed - indexToInsertAt;

			if (numToMove > 0)
				memmove (e + 1, e, numToMove * sizeof (ObjectClass*));

			*e = newObject;

			if (newObject != nullptr)
				newObject->incReferenceCount();

			++numUsed;
		}
		else
		{
			add (newObject);
		}
	}

	/** Appends a new object at the end of the array as long as the array doesn't
		already contain it.

		If the array already contains a matching object, nothing will be done.

		@param newObject   the new object to add to the array
	*/
	void addIfNotAlreadyThere (ObjectClass* const newObject) noexcept
	{
		const ScopedLockType lock (getLock());
		if (! contains (newObject))
			add (newObject);
	}

	/** Replaces an object in the array with a different one.

		If the index is less than zero, this method does nothing.
		If the index is beyond the end of the array, the new object is added to the end of the array.

		The object being added has its reference count increased, and if it's replacing
		another object, then that one has its reference count decreased, and may be deleted.

		@param indexToChange        the index whose value you want to change
		@param newObject            the new value to set for this index.
		@see add, insert, remove
	*/
	void set (const int indexToChange,
			  ObjectClass* const newObject)
	{
		if (indexToChange >= 0)
		{
			const ScopedLockType lock (getLock());

			if (newObject != nullptr)
				newObject->incReferenceCount();

			if (indexToChange < numUsed)
			{
				if (data.elements [indexToChange] != nullptr)
					data.elements [indexToChange]->decReferenceCount();

				data.elements [indexToChange] = newObject;
			}
			else
			{
				data.ensureAllocatedSize (numUsed + 1);
				data.elements [numUsed++] = newObject;
			}
		}
	}

	/** Adds elements from another array to the end of this array.

		@param arrayToAddFrom       the array from which to copy the elements
		@param startIndex           the first element of the other array to start copying from
		@param numElementsToAdd     how many elements to add from the other array. If this
									value is negative or greater than the number of available elements,
									all available elements will be copied.
		@see add
	*/
	void addArray (const ReferenceCountedArray<ObjectClass, TypeOfCriticalSectionToUse>& arrayToAddFrom,
				   int startIndex = 0,
				   int numElementsToAdd = -1) noexcept
	{
		const ScopedLockType lock1 (arrayToAddFrom.getLock());

		{
			const ScopedLockType lock2 (getLock());

			if (startIndex < 0)
			{
				jassertfalse;
				startIndex = 0;
			}

			if (numElementsToAdd < 0 || startIndex + numElementsToAdd > arrayToAddFrom.size())
				numElementsToAdd = arrayToAddFrom.size() - startIndex;

			if (numElementsToAdd > 0)
			{
				data.ensureAllocatedSize (numUsed + numElementsToAdd);

				while (--numElementsToAdd >= 0)
					add (arrayToAddFrom.getUnchecked (startIndex++));
			}
		}
	}

	/** Inserts a new object into the array assuming that the array is sorted.

		This will use a comparator to find the position at which the new object
		should go. If the array isn't sorted, the behaviour of this
		method will be unpredictable.

		@param comparator   the comparator object to use to compare the elements - see the
							sort() method for details about this object's form
		@param newObject    the new object to insert to the array
		@returns the index at which the new object was added
		@see add, sort
	*/
	template <class ElementComparator>
	int addSorted (ElementComparator& comparator, ObjectClass* newObject) noexcept
	{
		const ScopedLockType lock (getLock());
		const int index = findInsertIndexInSortedArray (comparator, data.elements.getData(), newObject, 0, numUsed);
		insert (index, newObject);
		return index;
	}

	/** Inserts or replaces an object in the array, assuming it is sorted.

		This is similar to addSorted, but if a matching element already exists, then it will be
		replaced by the new one, rather than the new one being added as well.
	*/
	template <class ElementComparator>
	void addOrReplaceSorted (ElementComparator& comparator,
							 ObjectClass* newObject) noexcept
	{
		const ScopedLockType lock (getLock());
		const int index = findInsertIndexInSortedArray (comparator, data.elements.getData(), newObject, 0, numUsed);

		if (index > 0 && comparator.compareElements (newObject, data.elements [index - 1]) == 0)
			set (index - 1, newObject); // replace an existing object that matches
		else
			insert (index, newObject);  // no match, so insert the new one
	}

	/** Removes an object from the array.

		This will remove the object at a given index and move back all the
		subsequent objects to close the gap.

		If the index passed in is out-of-range, nothing will happen.

		The object that is removed will have its reference count decreased,
		and may be deleted if not referenced from elsewhere.

		@param indexToRemove    the index of the element to remove
		@see removeObject, removeRange
	*/
	void remove (const int indexToRemove)
	{
		const ScopedLockType lock (getLock());

		if (isPositiveAndBelow (indexToRemove, numUsed))
		{
			ObjectClass** const e = data.elements + indexToRemove;

			if (*e != nullptr)
				(*e)->decReferenceCount();

			--numUsed;
			const int numberToShift = numUsed - indexToRemove;

			if (numberToShift > 0)
				memmove (e, e + 1, numberToShift * sizeof (ObjectClass*));

			if ((numUsed << 1) < data.numAllocated)
				minimiseStorageOverheads();
		}
	}

	/** Removes and returns an object from the array.

		This will remove the object at a given index and return it, moving back all
		the subsequent objects to close the gap. If the index passed in is out-of-range,
		nothing will happen and a null pointer will be returned.

		@param indexToRemove    the index of the element to remove
		@see remove, removeObject, removeRange
	*/
	ObjectClassPtr removeAndReturn (const int indexToRemove)
	{
		ObjectClassPtr removedItem;
		const ScopedLockType lock (getLock());

		if (isPositiveAndBelow (indexToRemove, numUsed))
		{
			ObjectClass** const e = data.elements + indexToRemove;

			if (*e != nullptr)
			{
				removedItem = *e;
				(*e)->decReferenceCount();
			}

			--numUsed;
			const int numberToShift = numUsed - indexToRemove;

			if (numberToShift > 0)
				memmove (e, e + 1, numberToShift * sizeof (ObjectClass*));

			if ((numUsed << 1) < data.numAllocated)
				minimiseStorageOverheads();
		}

		return removedItem;
	}

	/** Removes the first occurrence of a specified object from the array.

		If the item isn't found, no action is taken. If it is found, it is
		removed and has its reference count decreased.

		@param objectToRemove   the object to try to remove
		@see remove, removeRange
	*/
	void removeObject (ObjectClass* const objectToRemove)
	{
		const ScopedLockType lock (getLock());
		remove (indexOf (objectToRemove));
	}

	/** Removes a range of objects from the array.

		This will remove a set of objects, starting from the given index,
		and move any subsequent elements down to close the gap.

		If the range extends beyond the bounds of the array, it will
		be safely clipped to the size of the array.

		The objects that are removed will have their reference counts decreased,
		and may be deleted if not referenced from elsewhere.

		@param startIndex       the index of the first object to remove
		@param numberToRemove   how many objects should be removed
		@see remove, removeObject
	*/
	void removeRange (const int startIndex,
					  const int numberToRemove)
	{
		const ScopedLockType lock (getLock());

		const int start = jlimit (0, numUsed, startIndex);
		const int end_   = jlimit (0, numUsed, startIndex + numberToRemove);

		if (end_ > start)
		{
			int i;
			for (i = start; i < end_; ++i)
			{
				if (data.elements[i] != nullptr)
				{
					data.elements[i]->decReferenceCount();
					data.elements[i] = nullptr; // (in case one of the destructors accesses this array and hits a dangling pointer)
				}
			}

			const int rangeSize = end_ - start;
			ObjectClass** e = data.elements + start;
			i = numUsed - end_;
			numUsed -= rangeSize;

			while (--i >= 0)
			{
				*e = e [rangeSize];
				++e;
			}

			if ((numUsed << 1) < data.numAllocated)
				minimiseStorageOverheads();
		}
	}

	/** Removes the last n objects from the array.

		The objects that are removed will have their reference counts decreased,
		and may be deleted if not referenced from elsewhere.

		@param howManyToRemove   how many objects to remove from the end of the array
		@see remove, removeObject, removeRange
	*/
	void removeLast (int howManyToRemove = 1)
	{
		const ScopedLockType lock (getLock());

		if (howManyToRemove > numUsed)
			howManyToRemove = numUsed;

		while (--howManyToRemove >= 0)
			remove (numUsed - 1);
	}

	/** Swaps a pair of objects in the array.

		If either of the indexes passed in is out-of-range, nothing will happen,
		otherwise the two objects at these positions will be exchanged.
	*/
	void swap (const int index1,
			   const int index2) noexcept
	{
		const ScopedLockType lock (getLock());

		if (isPositiveAndBelow (index1, numUsed)
			 && isPositiveAndBelow (index2, numUsed))
		{
			std::swap (data.elements [index1],
					   data.elements [index2]);
		}
	}

	/** Moves one of the objects to a different position.

		This will move the object to a specified index, shuffling along
		any intervening elements as required.

		So for example, if you have the array { 0, 1, 2, 3, 4, 5 } then calling
		move (2, 4) would result in { 0, 1, 3, 4, 2, 5 }.

		@param currentIndex     the index of the object to be moved. If this isn't a
								valid index, then nothing will be done
		@param newIndex         the index at which you'd like this object to end up. If this
								is less than zero, it will be moved to the end of the array
	*/
	void move (const int currentIndex,
			   int newIndex) noexcept
	{
		if (currentIndex != newIndex)
		{
			const ScopedLockType lock (getLock());

			if (isPositiveAndBelow (currentIndex, numUsed))
			{
				if (! isPositiveAndBelow (newIndex, numUsed))
					newIndex = numUsed - 1;

				ObjectClass* const value = data.elements [currentIndex];

				if (newIndex > currentIndex)
				{
					memmove (data.elements + currentIndex,
							 data.elements + currentIndex + 1,
							 (newIndex - currentIndex) * sizeof (ObjectClass*));
				}
				else
				{
					memmove (data.elements + newIndex + 1,
							 data.elements + newIndex,
							 (currentIndex - newIndex) * sizeof (ObjectClass*));
				}

				data.elements [newIndex] = value;
			}
		}
	}

	/** This swaps the contents of this array with those of another array.

		If you need to exchange two arrays, this is vastly quicker than using copy-by-value
		because it just swaps their internal pointers.
	*/
	void swapWithArray (ReferenceCountedArray& otherArray) noexcept
	{
		const ScopedLockType lock1 (getLock());
		const ScopedLockType lock2 (otherArray.getLock());

		data.swapWith (otherArray.data);
		std::swap (numUsed, otherArray.numUsed);
	}

	/** Compares this array to another one.

		@returns true only if the other array contains the same objects in the same order
	*/
	bool operator== (const ReferenceCountedArray& other) const noexcept
	{
		const ScopedLockType lock2 (other.getLock());
		const ScopedLockType lock1 (getLock());

		if (numUsed != other.numUsed)
			return false;

		for (int i = numUsed; --i >= 0;)
			if (data.elements [i] != other.data.elements [i])
				return false;

		return true;
	}

	/** Compares this array to another one.

		@see operator==
	*/
	bool operator!= (const ReferenceCountedArray<ObjectClass, TypeOfCriticalSectionToUse>& other) const noexcept
	{
		return ! operator== (other);
	}

	/** Sorts the elements in the array.

		This will use a comparator object to sort the elements into order. The object
		passed must have a method of the form:
		@code
		int compareElements (ElementType first, ElementType second);
		@endcode

		..and this method must return:
		  - a value of < 0 if the first comes before the second
		  - a value of 0 if the two objects are equivalent
		  - a value of > 0 if the second comes before the first

		To improve performance, the compareElements() method can be declared as static or const.

		@param comparator   the comparator to use for comparing elements.
		@param retainOrderOfEquivalentItems     if this is true, then items
							which the comparator says are equivalent will be
							kept in the order in which they currently appear
							in the array. This is slower to perform, but may
							be important in some cases. If it's false, a faster
							algorithm is used, but equivalent elements may be
							rearranged.

		@see sortArray
	*/
	template <class ElementComparator>
	void sort (ElementComparator& comparator,
			   const bool retainOrderOfEquivalentItems = false) const noexcept
	{
		(void) comparator;  // if you pass in an object with a static compareElements() method, this
							// avoids getting warning messages about the parameter being unused

		const ScopedLockType lock (getLock());
		sortArray (comparator, data.elements.getData(), 0, size() - 1, retainOrderOfEquivalentItems);
	}

	/** Reduces the amount of storage being used by the array.

		Arrays typically allocate slightly more storage than they need, and after
		removing elements, they may have quite a lot of unused space allocated.
		This method will reduce the amount of allocated storage to a minimum.
	*/
	void minimiseStorageOverheads() noexcept
	{
		const ScopedLockType lock (getLock());
		data.shrinkToNoMoreThan (numUsed);
	}

	/** Increases the array's internal storage to hold a minimum number of elements.

		Calling this before adding a large known number of elements means that
		the array won't have to keep dynamically resizing itself as the elements
		are added, and it'll therefore be more efficient.
	*/
	void ensureStorageAllocated (const int minNumElements)
	{
		const ScopedLockType lock (getLock());
		data.ensureAllocatedSize (minNumElements);
	}

	/** Returns the CriticalSection that locks this array.
		To lock, you can call getLock().enter() and getLock().exit(), or preferably use
		an object of ScopedLockType as an RAII lock for it.
	*/
	inline const TypeOfCriticalSectionToUse& getLock() const noexcept      { return data; }

	/** Returns the type of scoped lock to use for locking this array */
	typedef typename TypeOfCriticalSectionToUse::ScopedLockType ScopedLockType;

private:

	ArrayAllocationBase <ObjectClass*, TypeOfCriticalSectionToUse> data;
	int numUsed;
};

#endif   // __JUCE_REFERENCECOUNTEDARRAY_JUCEHEADER__

/*** End of inlined file: juce_ReferenceCountedArray.h ***/


#endif
#ifndef __JUCE_SCOPEDVALUESETTER_JUCEHEADER__

/*** Start of inlined file: juce_ScopedValueSetter.h ***/
#ifndef __JUCE_SCOPEDVALUESETTER_JUCEHEADER__
#define __JUCE_SCOPEDVALUESETTER_JUCEHEADER__

/**
	Helper class providing an RAII-based mechanism for temporarily setting and
	then re-setting a value.

	E.g. @code
	int x = 1;

	{
		ScopedValueSetter setter (x, 2);

		// x is now 2
	}

	// x is now 1 again

	{
		ScopedValueSetter setter (x, 3, 4);

		// x is now 3
	}

	// x is now 4
	@endcode

*/
template <typename ValueType>
class ScopedValueSetter
{
public:
	/** Creates a ScopedValueSetter that will immediately change the specified value to the
		given new value, and will then reset it to its original value when this object is deleted.
	*/
	ScopedValueSetter (ValueType& valueToSet,
					   const ValueType& newValue)
		: value (valueToSet),
		  originalValue (valueToSet)
	{
		valueToSet = newValue;
	}

	/** Creates a ScopedValueSetter that will immediately change the specified value to the
		given new value, and will then reset it to be valueWhenDeleted when this object is deleted.
	*/
	ScopedValueSetter (ValueType& valueToSet,
					   const ValueType& newValue,
					   const ValueType& valueWhenDeleted)
		: value (valueToSet),
		  originalValue (valueWhenDeleted)
	{
		valueToSet = newValue;
	}

	~ScopedValueSetter()
	{
		value = originalValue;
	}

private:

	ValueType& value;
	const ValueType originalValue;

	JUCE_DECLARE_NON_COPYABLE (ScopedValueSetter);
};

#endif   // __JUCE_SCOPEDVALUESETTER_JUCEHEADER__

/*** End of inlined file: juce_ScopedValueSetter.h ***/


#endif
#ifndef __JUCE_SORTEDSET_JUCEHEADER__

/*** Start of inlined file: juce_SortedSet.h ***/
#ifndef __JUCE_SORTEDSET_JUCEHEADER__
#define __JUCE_SORTEDSET_JUCEHEADER__

#if JUCE_MSVC
  #pragma warning (push)
  #pragma warning (disable: 4512)
#endif

/**
	Holds a set of unique primitive objects, such as ints or doubles.

	A set can only hold one item with a given value, so if for example it's a
	set of integers, attempting to add the same integer twice will do nothing
	the second time.

	Internally, the list of items is kept sorted (which means that whatever
	kind of primitive type is used must support the ==, <, >, <= and >= operators
	to determine the order), and searching the set for known values is very fast
	because it uses a binary-chop method.

	Note that if you're using a class or struct as the element type, it must be
	capable of being copied or moved with a straightforward memcpy, rather than
	needing construction and destruction code.

	To make all the set's methods thread-safe, pass in "CriticalSection" as the templated
	TypeOfCriticalSectionToUse parameter, instead of the default DummyCriticalSection.

	@see Array, OwnedArray, ReferenceCountedArray, StringArray, CriticalSection
*/
template <class ElementType, class TypeOfCriticalSectionToUse = DummyCriticalSection>
class SortedSet
{
public:

	/** Creates an empty set. */
	SortedSet() noexcept
	   : numUsed (0)
	{
	}

	/** Creates a copy of another set.
		@param other    the set to copy
	*/
	SortedSet (const SortedSet& other) noexcept
	{
		const ScopedLockType lock (other.getLock());
		numUsed = other.numUsed;
		data.setAllocatedSize (other.numUsed);
		memcpy (data.elements, other.data.elements, numUsed * sizeof (ElementType));
	}

	/** Destructor. */
	~SortedSet() noexcept
	{
	}

	/** Copies another set over this one.
		@param other    the set to copy
	*/
	SortedSet& operator= (const SortedSet& other) noexcept
	{
		if (this != &other)
		{
			const ScopedLockType lock1 (other.getLock());
			const ScopedLockType lock2 (getLock());

			data.ensureAllocatedSize (other.size());
			numUsed = other.numUsed;
			memcpy (data.elements, other.data.elements, numUsed * sizeof (ElementType));
			minimiseStorageOverheads();
		}

		return *this;
	}

	/** Compares this set to another one.

		Two sets are considered equal if they both contain the same set of
		elements.

		@param other    the other set to compare with
	*/
	bool operator== (const SortedSet<ElementType>& other) const noexcept
	{
		const ScopedLockType lock (getLock());

		if (numUsed != other.numUsed)
			return false;

		for (int i = numUsed; --i >= 0;)
			if (! (data.elements[i] == other.data.elements[i]))
				return false;

		return true;
	}

	/** Compares this set to another one.

		Two sets are considered equal if they both contain the same set of
		elements.

		@param other    the other set to compare with
	*/
	bool operator!= (const SortedSet<ElementType>& other) const noexcept
	{
		return ! operator== (other);
	}

	/** Removes all elements from the set.

		This will remove all the elements, and free any storage that the set is
		using. To clear it without freeing the storage, use the clearQuick()
		method instead.

		@see clearQuick
	*/
	void clear() noexcept
	{
		const ScopedLockType lock (getLock());
		data.setAllocatedSize (0);
		numUsed = 0;
	}

	/** Removes all elements from the set without freeing the array's allocated storage.

		@see clear
	*/
	void clearQuick() noexcept
	{
		const ScopedLockType lock (getLock());
		numUsed = 0;
	}

	/** Returns the current number of elements in the set.
	*/
	inline int size() const noexcept
	{
		return numUsed;
	}

	/** Returns one of the elements in the set.

		If the index passed in is beyond the range of valid elements, this
		will return zero.

		If you're certain that the index will always be a valid element, you
		can call getUnchecked() instead, which is faster.

		@param index    the index of the element being requested (0 is the first element in the set)
		@see getUnchecked, getFirst, getLast
	*/
	inline ElementType operator[] (const int index) const noexcept
	{
		const ScopedLockType lock (getLock());
		return isPositiveAndBelow (index, numUsed) ? data.elements [index]
												   : ElementType();
	}

	/** Returns one of the elements in the set, without checking the index passed in.
		Unlike the operator[] method, this will try to return an element without
		checking that the index is within the bounds of the set, so should only
		be used when you're confident that it will always be a valid index.

		@param index    the index of the element being requested (0 is the first element in the set)
		@see operator[], getFirst, getLast
	*/
	inline ElementType getUnchecked (const int index) const noexcept
	{
		const ScopedLockType lock (getLock());
		jassert (isPositiveAndBelow (index, numUsed));
		return data.elements [index];
	}

	/** Returns a direct reference to one of the elements in the set, without checking the index passed in.

		This is like getUnchecked, but returns a direct reference to the element, so that
		you can alter it directly. Obviously this can be dangerous, so only use it when
		absolutely necessary.

		@param index    the index of the element being requested (0 is the first element in the array)
	*/
	inline ElementType& getReference (const int index) const noexcept
	{
		const ScopedLockType lock (getLock());
		jassert (isPositiveAndBelow (index, numUsed));
		return data.elements [index];
	}

	/** Returns the first element in the set, or 0 if the set is empty.

		@see operator[], getUnchecked, getLast
	*/
	inline ElementType getFirst() const noexcept
	{
		const ScopedLockType lock (getLock());
		return numUsed > 0 ? data.elements [0] : ElementType();
	}

	/** Returns the last element in the set, or 0 if the set is empty.

		@see operator[], getUnchecked, getFirst
	*/
	inline ElementType getLast() const noexcept
	{
		const ScopedLockType lock (getLock());
		return numUsed > 0 ? data.elements [numUsed - 1] : ElementType();
	}

	/** Returns a pointer to the first element in the set.
		This method is provided for compatibility with standard C++ iteration mechanisms.
	*/
	inline ElementType* begin() const noexcept
	{
		return data.elements;
	}

	/** Returns a pointer to the element which follows the last element in the set.
		This method is provided for compatibility with standard C++ iteration mechanisms.
	*/
	inline ElementType* end() const noexcept
	{
		return data.elements + numUsed;
	}

	/** Finds the index of the first element which matches the value passed in.

		This will search the set for the given object, and return the index
		of its first occurrence. If the object isn't found, the method will return -1.

		@param elementToLookFor   the value or object to look for
		@returns                  the index of the object, or -1 if it's not found
	*/
	int indexOf (const ElementType elementToLookFor) const noexcept
	{
		const ScopedLockType lock (getLock());

		int start = 0;
		int end_ = numUsed;

		for (;;)
		{
			if (start >= end_)
			{
				return -1;
			}
			else if (elementToLookFor == data.elements [start])
			{
				return start;
			}
			else
			{
				const int halfway = (start + end_) >> 1;

				if (halfway == start)
					return -1;
				else if (elementToLookFor < data.elements [halfway])
					end_ = halfway;
				else
					start = halfway;
			}
		}
	}

	/** Returns true if the set contains at least one occurrence of an object.

		@param elementToLookFor     the value or object to look for
		@returns                    true if the item is found
	*/
	bool contains (const ElementType elementToLookFor) const noexcept
	{
		const ScopedLockType lock (getLock());

		int start = 0;
		int end_ = numUsed;

		for (;;)
		{
			if (start >= end_)
			{
				return false;
			}
			else if (elementToLookFor == data.elements [start])
			{
				return true;
			}
			else
			{
				const int halfway = (start + end_) >> 1;

				if (halfway == start)
					return false;
				else if (elementToLookFor < data.elements [halfway])
					end_ = halfway;
				else
					start = halfway;
			}
		}
	}

	/** Adds a new element to the set, (as long as it's not already in there).

		@param newElement       the new object to add to the set
		@see set, insert, addIfNotAlreadyThere, addSorted, addSet, addArray
	*/
	void add (const ElementType newElement) noexcept
	{
		const ScopedLockType lock (getLock());

		int start = 0;
		int end_ = numUsed;

		for (;;)
		{
			if (start >= end_)
			{
				jassert (start <= end_);
				insertInternal (start, newElement);
				break;
			}
			else if (newElement == data.elements [start])
			{
				break;
			}
			else
			{
				const int halfway = (start + end_) >> 1;

				if (halfway == start)
				{
					if (newElement < data.elements [halfway])
						insertInternal (start, newElement);
					else
						insertInternal (start + 1, newElement);

					break;
				}
				else if (newElement < data.elements [halfway])
					end_ = halfway;
				else
					start = halfway;
			}
		}
	}

	/** Adds elements from an array to this set.

		@param elementsToAdd        the array of elements to add
		@param numElementsToAdd     how many elements are in this other array
		@see add
	*/
	void addArray (const ElementType* elementsToAdd,
				   int numElementsToAdd) noexcept
	{
		const ScopedLockType lock (getLock());

		while (--numElementsToAdd >= 0)
			add (*elementsToAdd++);
	}

	/** Adds elements from another set to this one.

		@param setToAddFrom         the set from which to copy the elements
		@param startIndex           the first element of the other set to start copying from
		@param numElementsToAdd     how many elements to add from the other set. If this
									value is negative or greater than the number of available elements,
									all available elements will be copied.
		@see add
	*/
	template <class OtherSetType>
	void addSet (const OtherSetType& setToAddFrom,
				 int startIndex = 0,
				 int numElementsToAdd = -1) noexcept
	{
		const typename OtherSetType::ScopedLockType lock1 (setToAddFrom.getLock());

		{
			const ScopedLockType lock2 (getLock());
			jassert (this != &setToAddFrom);

			if (this != &setToAddFrom)
			{
				if (startIndex < 0)
				{
					jassertfalse;
					startIndex = 0;
				}

				if (numElementsToAdd < 0 || startIndex + numElementsToAdd > setToAddFrom.size())
					numElementsToAdd = setToAddFrom.size() - startIndex;

				addArray (setToAddFrom.elements + startIndex, numElementsToAdd);
			}
		}
	}

	/** Removes an element from the set.

		This will remove the element at a given index.
		If the index passed in is out-of-range, nothing will happen.

		@param indexToRemove    the index of the element to remove
		@returns                the element that has been removed
		@see removeValue, removeRange
	*/
	ElementType remove (const int indexToRemove) noexcept
	{
		const ScopedLockType lock (getLock());

		if (isPositiveAndBelow (indexToRemove, numUsed))
		{
			--numUsed;

			ElementType* const e = data.elements + indexToRemove;
			ElementType const removed = *e;
			const int numberToShift = numUsed - indexToRemove;

			if (numberToShift > 0)
				memmove (e, e + 1, numberToShift * sizeof (ElementType));

			if ((numUsed << 1) < data.numAllocated)
				minimiseStorageOverheads();

			return removed;
		}

		return ElementType();
	}

	/** Removes an item from the set.

		This will remove the given element from the set, if it's there.

		@param valueToRemove   the object to try to remove
		@see remove, removeRange
	*/
	void removeValue (const ElementType valueToRemove) noexcept
	{
		const ScopedLockType lock (getLock());
		remove (indexOf (valueToRemove));
	}

	/** Removes any elements which are also in another set.

		@param otherSet   the other set in which to look for elements to remove
		@see removeValuesNotIn, remove, removeValue, removeRange
	*/
	template <class OtherSetType>
	void removeValuesIn (const OtherSetType& otherSet) noexcept
	{
		const typename OtherSetType::ScopedLockType lock1 (otherSet.getLock());
		const ScopedLockType lock2 (getLock());

		if (this == &otherSet)
		{
			clear();
		}
		else
		{
			if (otherSet.size() > 0)
			{
				for (int i = numUsed; --i >= 0;)
					if (otherSet.contains (data.elements [i]))
						remove (i);
			}
		}
	}

	/** Removes any elements which are not found in another set.

		Only elements which occur in this other set will be retained.

		@param otherSet    the set in which to look for elements NOT to remove
		@see removeValuesIn, remove, removeValue, removeRange
	*/
	template <class OtherSetType>
	void removeValuesNotIn (const OtherSetType& otherSet) noexcept
	{
		const typename OtherSetType::ScopedLockType lock1 (otherSet.getLock());
		const ScopedLockType lock2 (getLock());

		if (this != &otherSet)
		{
			if (otherSet.size() <= 0)
			{
				clear();
			}
			else
			{
				for (int i = numUsed; --i >= 0;)
					if (! otherSet.contains (data.elements [i]))
						remove (i);
			}
		}
	}

	/** Reduces the amount of storage being used by the set.

		Sets typically allocate slightly more storage than they need, and after
		removing elements, they may have quite a lot of unused space allocated.
		This method will reduce the amount of allocated storage to a minimum.
	*/
	void minimiseStorageOverheads() noexcept
	{
		const ScopedLockType lock (getLock());
		data.shrinkToNoMoreThan (numUsed);
	}

	/** Increases the set's internal storage to hold a minimum number of elements.

		Calling this before adding a large known number of elements means that
		the set won't have to keep dynamically resizing itself as the elements
		are added, and it'll therefore be more efficient.
	*/
	void ensureStorageAllocated (const int minNumElements)
	{
		const ScopedLockType lock (getLock());
		data.ensureAllocatedSize (minNumElements);
	}

	/** Returns the CriticalSection that locks this array.
		To lock, you can call getLock().enter() and getLock().exit(), or preferably use
		an object of ScopedLockType as an RAII lock for it.
	*/
	inline const TypeOfCriticalSectionToUse& getLock() const noexcept      { return data; }

	/** Returns the type of scoped lock to use for locking this array */
	typedef typename TypeOfCriticalSectionToUse::ScopedLockType ScopedLockType;

private:

	ArrayAllocationBase <ElementType, TypeOfCriticalSectionToUse> data;
	int numUsed;

	void insertInternal (const int indexToInsertAt, const ElementType newElement) noexcept
	{
		data.ensureAllocatedSize (numUsed + 1);

		ElementType* const insertPos = data.elements + indexToInsertAt;
		const int numberToMove = numUsed - indexToInsertAt;

		if (numberToMove > 0)
			memmove (insertPos + 1, insertPos, numberToMove * sizeof (ElementType));

		*insertPos = newElement;
		++numUsed;
	}
};

#if JUCE_MSVC
  #pragma warning (pop)
#endif

#endif   // __JUCE_SORTEDSET_JUCEHEADER__

/*** End of inlined file: juce_SortedSet.h ***/


#endif
#ifndef __JUCE_SPARSESET_JUCEHEADER__

/*** Start of inlined file: juce_SparseSet.h ***/
#ifndef __JUCE_SPARSESET_JUCEHEADER__
#define __JUCE_SPARSESET_JUCEHEADER__


/*** Start of inlined file: juce_Range.h ***/
#ifndef __JUCE_RANGE_JUCEHEADER__
#define __JUCE_RANGE_JUCEHEADER__

/** A general-purpose range object, that simply represents any linear range with
	a start and end point.

	The templated parameter is expected to be a primitive integer or floating point
	type, though class types could also be used if they behave in a number-like way.
*/
template <typename ValueType>
class Range
{
public:

	/** Constructs an empty range. */
	Range() noexcept
		: start (ValueType()), end (ValueType())
	{
	}

	/** Constructs a range with given start and end values. */
	Range (const ValueType start_, const ValueType end_) noexcept
		: start (start_), end (jmax (start_, end_))
	{
	}

	/** Constructs a copy of another range. */
	Range (const Range& other) noexcept
		: start (other.start), end (other.end)
	{
	}

	/** Copies another range object. */
	Range& operator= (const Range& other) noexcept
	{
		start = other.start;
		end = other.end;
		return *this;
	}

	/** Destructor. */
	~Range() noexcept
	{
	}

	/** Returns the range that lies between two positions (in either order). */
	static Range between (const ValueType position1, const ValueType position2) noexcept
	{
		return (position1 < position2) ? Range (position1, position2)
									   : Range (position2, position1);
	}

	/** Returns a range with the specified start position and a length of zero. */
	static Range emptyRange (const ValueType start) noexcept
	{
		return Range (start, start);
	}

	/** Returns the start of the range. */
	inline ValueType getStart() const noexcept          { return start; }

	/** Returns the length of the range. */
	inline ValueType getLength() const noexcept         { return end - start; }

	/** Returns the end of the range. */
	inline ValueType getEnd() const noexcept            { return end; }

	/** Returns true if the range has a length of zero. */
	inline bool isEmpty() const noexcept                { return start == end; }

	/** Changes the start position of the range, leaving the end position unchanged.
		If the new start position is higher than the current end of the range, the end point
		will be pushed along to equal it, leaving an empty range at the new position.
	*/
	void setStart (const ValueType newStart) noexcept
	{
		start = newStart;
		if (end < newStart)
			end = newStart;
	}

	/** Returns a range with the same end as this one, but a different start.
		If the new start position is higher than the current end of the range, the end point
		will be pushed along to equal it, returning an empty range at the new position.
	*/
	Range withStart (const ValueType newStart) const noexcept
	{
		return Range (newStart, jmax (newStart, end));
	}

	/** Returns a range with the same length as this one, but moved to have the given start position. */
	Range movedToStartAt (const ValueType newStart) const noexcept
	{
		return Range (newStart, end + (newStart - start));
	}

	/** Changes the end position of the range, leaving the start unchanged.
		If the new end position is below the current start of the range, the start point
		will be pushed back to equal the new end point.
	*/
	void setEnd (const ValueType newEnd) noexcept
	{
		end = newEnd;
		if (newEnd < start)
			start = newEnd;
	}

	/** Returns a range with the same start position as this one, but a different end.
		If the new end position is below the current start of the range, the start point
		will be pushed back to equal the new end point.
	*/
	Range withEnd (const ValueType newEnd) const noexcept
	{
		return Range (jmin (start, newEnd), newEnd);
	}

	/** Returns a range with the same length as this one, but moved to have the given start position. */
	Range movedToEndAt (const ValueType newEnd) const noexcept
	{
		return Range (start + (newEnd - end), newEnd);
	}

	/** Changes the length of the range.
		Lengths less than zero are treated as zero.
	*/
	void setLength (const ValueType newLength) noexcept
	{
		end = start + jmax (ValueType(), newLength);
	}

	/** Returns a range with the same start as this one, but a different length.
		Lengths less than zero are treated as zero.
	*/
	Range withLength (const ValueType newLength) const noexcept
	{
		return Range (start, start + newLength);
	}

	/** Adds an amount to the start and end of the range. */
	inline const Range& operator+= (const ValueType amountToAdd) noexcept
	{
		start += amountToAdd;
		end += amountToAdd;
		return *this;
	}

	/** Subtracts an amount from the start and end of the range. */
	inline const Range& operator-= (const ValueType amountToSubtract) noexcept
	{
		start -= amountToSubtract;
		end -= amountToSubtract;
		return *this;
	}

	/** Returns a range that is equal to this one with an amount added to its
		start and end.
	*/
	Range operator+ (const ValueType amountToAdd) const noexcept
	{
		return Range (start + amountToAdd, end + amountToAdd);
	}

	/** Returns a range that is equal to this one with the specified amount
		subtracted from its start and end. */
	Range operator- (const ValueType amountToSubtract) const noexcept
	{
		return Range (start - amountToSubtract, end - amountToSubtract);
	}

	bool operator== (const Range& other) const noexcept     { return start == other.start && end == other.end; }
	bool operator!= (const Range& other) const noexcept     { return start != other.start || end != other.end; }

	/** Returns true if the given position lies inside this range. */
	bool contains (const ValueType position) const noexcept
	{
		return start <= position && position < end;
	}

	/** Returns the nearest value to the one supplied, which lies within the range. */
	ValueType clipValue (const ValueType value) const noexcept
	{
		return jlimit (start, end, value);
	}

	/** Returns true if the given range lies entirely inside this range. */
	bool contains (const Range& other) const noexcept
	{
		return start <= other.start && end >= other.end;
	}

	/** Returns true if the given range intersects this one. */
	bool intersects (const Range& other) const noexcept
	{
		return other.start < end && start < other.end;
	}

	/** Returns the range that is the intersection of the two ranges, or an empty range
		with an undefined start position if they don't overlap. */
	Range getIntersectionWith (const Range& other) const noexcept
	{
		return Range (jmax (start, other.start),
					  jmin (end, other.end));
	}

	/** Returns the smallest range that contains both this one and the other one. */
	Range getUnionWith (const Range& other) const noexcept
	{
		return Range (jmin (start, other.start),
					  jmax (end, other.end));
	}

	/** Returns a given range, after moving it forwards or backwards to fit it
		within this range.

		If the supplied range has a greater length than this one, the return value
		will be this range.

		Otherwise, if the supplied range is smaller than this one, the return value
		will be the new range, shifted forwards or backwards so that it doesn't extend
		beyond this one, but keeping its original length.
	*/
	Range constrainRange (const Range& rangeToConstrain) const noexcept
	{
		const ValueType otherLen = rangeToConstrain.getLength();
		return getLength() <= otherLen
				? *this
				: rangeToConstrain.movedToStartAt (jlimit (start, end - otherLen, rangeToConstrain.getStart()));
	}

private:

	ValueType start, end;
};

#endif   // __JUCE_RANGE_JUCEHEADER__

/*** End of inlined file: juce_Range.h ***/

/**
	Holds a set of primitive values, storing them as a set of ranges.

	This container acts like an array, but can efficiently hold large continguous
	ranges of values. It's quite a specialised class, mostly useful for things
	like keeping the set of selected rows in a listbox.

	The type used as a template paramter must be an integer type, such as int, short,
	int64, etc.
*/
template <class Type>
class SparseSet
{
public:

	/** Creates a new empty set. */
	SparseSet()
	{
	}

	/** Creates a copy of another SparseSet. */
	SparseSet (const SparseSet<Type>& other)
		: values (other.values)
	{
	}

	/** Clears the set. */
	void clear()
	{
		values.clear();
	}

	/** Checks whether the set is empty.

		This is much quicker than using (size() == 0).
	*/
	bool isEmpty() const noexcept
	{
		return values.size() == 0;
	}

	/** Returns the number of values in the set.

		Because of the way the data is stored, this method can take longer if there
		are a lot of items in the set. Use isEmpty() for a quick test of whether there
		are any items.
	*/
	Type size() const
	{
		Type total (0);

		for (int i = 0; i < values.size(); i += 2)
			total += values.getUnchecked (i + 1) - values.getUnchecked (i);

		return total;
	}

	/** Returns one of the values in the set.

		@param index    the index of the value to retrieve, in the range 0 to (size() - 1).
		@returns        the value at this index, or 0 if it's out-of-range
	*/
	Type operator[] (Type index) const
	{
		for (int i = 0; i < values.size(); i += 2)
		{
			const Type start (values.getUnchecked (i));
			const Type len (values.getUnchecked (i + 1) - start);

			if (index < len)
				return start + index;

			index -= len;
		}

		return Type();
	}

	/** Checks whether a particular value is in the set. */
	bool contains (const Type valueToLookFor) const
	{
		for (int i = 0; i < values.size(); ++i)
			if (valueToLookFor < values.getUnchecked(i))
				return (i & 1) != 0;

		return false;
	}

	/** Returns the number of contiguous blocks of values.
		@see getRange
	*/
	int getNumRanges() const noexcept
	{
		return values.size() >> 1;
	}

	/** Returns one of the contiguous ranges of values stored.
		@param rangeIndex   the index of the range to look up, between 0
							and (getNumRanges() - 1)
		@see getTotalRange
	*/
	const Range<Type> getRange (const int rangeIndex) const
	{
		if (isPositiveAndBelow (rangeIndex, getNumRanges()))
			return Range<Type> (values.getUnchecked (rangeIndex << 1),
								values.getUnchecked ((rangeIndex << 1) + 1));
		else
			return Range<Type>();
	}

	/** Returns the range between the lowest and highest values in the set.
		@see getRange
	*/
	Range<Type> getTotalRange() const
	{
		if (values.size() > 0)
		{
			jassert ((values.size() & 1) == 0);
			return Range<Type> (values.getUnchecked (0),
								values.getUnchecked (values.size() - 1));
		}

		return Range<Type>();
	}

	/** Adds a range of contiguous values to the set.
		e.g. addRange (Range \<int\> (10, 14)) will add (10, 11, 12, 13) to the set.
	*/
	void addRange (const Range<Type>& range)
	{
		jassert (range.getLength() >= 0);
		if (range.getLength() > 0)
		{
			removeRange (range);

			values.addUsingDefaultSort (range.getStart());
			values.addUsingDefaultSort (range.getEnd());

			simplify();
		}
	}

	/** Removes a range of values from the set.
		e.g. removeRange (Range\<int\> (10, 14)) will remove (10, 11, 12, 13) from the set.
	*/
	void removeRange (const Range<Type>& rangeToRemove)
	{
		jassert (rangeToRemove.getLength() >= 0);

		if (rangeToRemove.getLength() > 0
			 && values.size() > 0
			 && rangeToRemove.getStart() < values.getUnchecked (values.size() - 1)
			 && values.getUnchecked(0) < rangeToRemove.getEnd())
		{
			const bool onAtStart = contains (rangeToRemove.getStart() - 1);
			const Type lastValue (jmin (rangeToRemove.getEnd(), values.getLast()));
			const bool onAtEnd = contains (lastValue);

			for (int i = values.size(); --i >= 0;)
			{
				if (values.getUnchecked(i) <= lastValue)
				{
					while (values.getUnchecked(i) >= rangeToRemove.getStart())
					{
						values.remove (i);

						if (--i < 0)
							break;
					}

					break;
				}
			}

			if (onAtStart)   values.addUsingDefaultSort (rangeToRemove.getStart());
			if (onAtEnd)     values.addUsingDefaultSort (lastValue);

			simplify();
		}
	}

	/** Does an XOR of the values in a given range. */
	void invertRange (const Range<Type>& range)
	{
		SparseSet newItems;
		newItems.addRange (range);

		int i;
		for (i = getNumRanges(); --i >= 0;)
			newItems.removeRange (getRange (i));

		removeRange (range);

		for (i = newItems.getNumRanges(); --i >= 0;)
			addRange (newItems.getRange(i));
	}

	/** Checks whether any part of a given range overlaps any part of this set. */
	bool overlapsRange (const Range<Type>& range)
	{
		if (range.getLength() > 0)
		{
			for (int i = getNumRanges(); --i >= 0;)
			{
				if (values.getUnchecked ((i << 1) + 1) <= range.getStart())
					return false;

				if (values.getUnchecked (i << 1) < range.getEnd())
					return true;
			}
		}

		return false;
	}

	/** Checks whether the whole of a given range is contained within this one. */
	bool containsRange (const Range<Type>& range)
	{
		if (range.getLength() > 0)
		{
			for (int i = getNumRanges(); --i >= 0;)
			{
				if (values.getUnchecked ((i << 1) + 1) <= range.getStart())
					return false;

				if (values.getUnchecked (i << 1) <= range.getStart()
					 && range.getEnd() <= values.getUnchecked ((i << 1) + 1))
					return true;
			}
		}

		return false;
	}

	bool operator== (const SparseSet<Type>& other) noexcept
	{
		return values == other.values;
	}

	bool operator!= (const SparseSet<Type>& other) noexcept
	{
		return values != other.values;
	}

private:

	// alternating start/end values of ranges of values that are present.
	Array<Type, DummyCriticalSection> values;

	void simplify()
	{
		jassert ((values.size() & 1) == 0);

		for (int i = values.size(); --i > 0;)
			if (values.getUnchecked(i) == values.getUnchecked (i - 1))
				values.removeRange (--i, 2);
	}
};

#endif   // __JUCE_SPARSESET_JUCEHEADER__

/*** End of inlined file: juce_SparseSet.h ***/


#endif
#ifndef __JUCE_VARIANT_JUCEHEADER__

#endif
#ifndef __JUCE_DIRECTORYITERATOR_JUCEHEADER__

/*** Start of inlined file: juce_DirectoryIterator.h ***/
#ifndef __JUCE_DIRECTORYITERATOR_JUCEHEADER__
#define __JUCE_DIRECTORYITERATOR_JUCEHEADER__

/**
	Searches through a the files in a directory, returning each file that is found.

	A DirectoryIterator will search through a directory and its subdirectories using
	a wildcard filepattern match.

	If you may be finding a large number of files, this is better than
	using File::findChildFiles() because it doesn't block while it finds them
	all, and this is more memory-efficient.

	It can also guess how far it's got using a wildly inaccurate algorithm.
*/
class JUCE_API  DirectoryIterator
{
public:

	/** Creates a DirectoryIterator for a given directory.

		After creating one of these, call its next() method to get the
		first file - e.g. @code

		DirectoryIterator iter (File ("/animals/mooses"), true, "*.moose");

		while (iter.next())
		{
			File theFileItFound (iter.getFile());

			... etc
		}
		@endcode

		@param directory    the directory to search in
		@param isRecursive  whether all the subdirectories should also be searched
		@param wildCard     the file pattern to match
		@param whatToLookFor    a value from the File::TypesOfFileToFind enum, specifying
								whether to look for files, directories, or both.
	*/
	DirectoryIterator (const File& directory,
					   bool isRecursive,
					   const String& wildCard = "*",
					   int whatToLookFor = File::findFiles);

	/** Destructor. */
	~DirectoryIterator();

	/** Moves the iterator along to the next file.

		@returns    true if a file was found (you can then use getFile() to see what it was) - or
					false if there are no more matching files.
	*/
	bool next();

	/** Moves the iterator along to the next file, and returns various properties of that file.

		If you need to find out details about the file, it's more efficient to call this method than
		to call the normal next() method and then find out the details afterwards.

		All the parameters are optional, so pass null pointers for any items that you're not
		interested in.

		@returns    true if a file was found (you can then use getFile() to see what it was) - or
					false if there are no more matching files. If it returns false, then none of the
					parameters will be filled-in.
	*/
	bool next (bool* isDirectory,
			   bool* isHidden,
			   int64* fileSize,
			   Time* modTime,
			   Time* creationTime,
			   bool* isReadOnly);

	/** Returns the file that the iterator is currently pointing at.

		The result of this call is only valid after a call to next() has returned true.
	*/
	const File& getFile() const;

	/** Returns a guess of how far through the search the iterator has got.

		@returns    a value 0.0 to 1.0 to show the progress, although this won't be
					very accurate.
	*/
	float getEstimatedProgress() const;

private:

	class NativeIterator
	{
	public:
		NativeIterator (const File& directory, const String& wildCard);
		~NativeIterator();

		bool next (String& filenameFound,
				   bool* isDirectory, bool* isHidden, int64* fileSize,
				   Time* modTime, Time* creationTime, bool* isReadOnly);

		class Pimpl;

	private:
		friend class DirectoryIterator;
		friend class ScopedPointer<Pimpl>;
		ScopedPointer<Pimpl> pimpl;

		JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (NativeIterator);
	};

	friend class ScopedPointer<NativeIterator::Pimpl>;
	NativeIterator fileFinder;
	String wildCard, path;
	int index;
	mutable int totalNumFiles;
	const int whatToLookFor;
	const bool isRecursive;
	bool hasBeenAdvanced;
	ScopedPointer <DirectoryIterator> subIterator;
	File currentFile;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (DirectoryIterator);
};

#endif   // __JUCE_DIRECTORYITERATOR_JUCEHEADER__

/*** End of inlined file: juce_DirectoryIterator.h ***/


#endif
#ifndef __JUCE_FILE_JUCEHEADER__

#endif
#ifndef __JUCE_FILEINPUTSTREAM_JUCEHEADER__

/*** Start of inlined file: juce_FileInputStream.h ***/
#ifndef __JUCE_FILEINPUTSTREAM_JUCEHEADER__
#define __JUCE_FILEINPUTSTREAM_JUCEHEADER__

/**
	An input stream that reads from a local file.

	@see InputStream, FileOutputStream, File::createInputStream
*/
class JUCE_API  FileInputStream  : public InputStream
{
public:

	/** Creates a FileInputStream.

		@param fileToRead   the file to read from - if the file can't be accessed for some
							reason, then the stream will just contain no data
	*/
	explicit FileInputStream (const File& fileToRead);

	/** Destructor. */
	~FileInputStream();

	/** Returns the file that this stream is reading from. */
	const File& getFile() const noexcept                { return file; }

	/** Returns the status of the file stream.
		The result will be ok if the file opened successfully. If an error occurs while
		opening or reading from the file, this will contain an error message.
	*/
	const Result& getStatus() const noexcept            { return status; }

	/** Returns true if the stream couldn't be opened for some reason.
		@see getResult()
	*/
	bool failedToOpen() const noexcept                  { return status.failed(); }

	/** Returns true if the stream opened without problems.
		@see getResult()
	*/
	bool openedOk() const noexcept                      { return status.wasOk(); }

	int64 getTotalLength();
	int read (void* destBuffer, int maxBytesToRead);
	bool isExhausted();
	int64 getPosition();
	bool setPosition (int64 pos);

private:

	File file;
	void* fileHandle;
	int64 currentPosition, totalSize;
	Result status;
	bool needToSeek;

	void openHandle();
	void closeHandle();
	size_t readInternal (void* buffer, size_t numBytes);

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (FileInputStream);
};

#endif   // __JUCE_FILEINPUTSTREAM_JUCEHEADER__

/*** End of inlined file: juce_FileInputStream.h ***/


#endif
#ifndef __JUCE_FILEOUTPUTSTREAM_JUCEHEADER__

/*** Start of inlined file: juce_FileOutputStream.h ***/
#ifndef __JUCE_FILEOUTPUTSTREAM_JUCEHEADER__
#define __JUCE_FILEOUTPUTSTREAM_JUCEHEADER__

/**
	An output stream that writes into a local file.

	@see OutputStream, FileInputStream, File::createOutputStream
*/
class JUCE_API  FileOutputStream  : public OutputStream
{
public:

	/** Creates a FileOutputStream.

		If the file doesn't exist, it will first be created. If the file can't be
		created or opened, the failedToOpen() method will return
		true.

		If the file already exists when opened, the stream's write-postion will
		be set to the end of the file. To overwrite an existing file,
		use File::deleteFile() before opening the stream, or use setPosition(0)
		after it's opened (although this won't truncate the file).

		@see TemporaryFile
	*/
	FileOutputStream (const File& fileToWriteTo,
					  int bufferSizeToUse = 16384);

	/** Destructor. */
	~FileOutputStream();

	/** Returns the file that this stream is writing to.
	*/
	const File& getFile() const                         { return file; }

	/** Returns the status of the file stream.
		The result will be ok if the file opened successfully. If an error occurs while
		opening or writing to the file, this will contain an error message.
	*/
	const Result& getStatus() const noexcept            { return status; }

	/** Returns true if the stream couldn't be opened for some reason.
		@see getResult()
	*/
	bool failedToOpen() const noexcept                  { return status.failed(); }

	/** Returns true if the stream opened without problems.
		@see getResult()
	*/
	bool openedOk() const noexcept                      { return status.wasOk(); }

	/** Attempts to truncate the file to the current write position.
		To truncate a file to a specific size, first use setPosition() to seek to the
		appropriate location, and then call this method.
	*/
	Result truncate();

	void flush();
	int64 getPosition();
	bool setPosition (int64 pos);
	bool write (const void* data, int numBytes);
	void writeRepeatedByte (uint8 byte, int numTimesToRepeat);

private:

	File file;
	void* fileHandle;
	Result status;
	int64 currentPosition;
	int bufferSize, bytesInBuffer;
	HeapBlock <char> buffer;

	void openHandle();
	void closeHandle();
	void flushInternal();
	bool flushBuffer();
	int64 setPositionInternal (int64 newPosition);
	int writeInternal (const void* data, int numBytes);

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (FileOutputStream);
};

#endif   // __JUCE_FILEOUTPUTSTREAM_JUCEHEADER__

/*** End of inlined file: juce_FileOutputStream.h ***/


#endif
#ifndef __JUCE_FILESEARCHPATH_JUCEHEADER__

/*** Start of inlined file: juce_FileSearchPath.h ***/
#ifndef __JUCE_FILESEARCHPATH_JUCEHEADER__
#define __JUCE_FILESEARCHPATH_JUCEHEADER__

/**
	Encapsulates a set of folders that make up a search path.

	@see File
*/
class JUCE_API  FileSearchPath
{
public:

	/** Creates an empty search path. */
	FileSearchPath();

	/** Creates a search path from a string of pathnames.

		The path can be semicolon- or comma-separated, e.g.
		"/foo/bar;/foo/moose;/fish/moose"

		The separate folders are tokenised and added to the search path.
	*/
	FileSearchPath (const String& path);

	/** Creates a copy of another search path. */
	FileSearchPath (const FileSearchPath& other);

	/** Destructor. */
	~FileSearchPath();

	/** Uses a string containing a list of pathnames to re-initialise this list.

		This search path is cleared and the semicolon- or comma-separated folders
		in this string are added instead. e.g. "/foo/bar;/foo/moose;/fish/moose"
	*/
	FileSearchPath& operator= (const String& path);

	/** Returns the number of folders in this search path.

		@see operator[]
	*/
	int getNumPaths() const;

	/** Returns one of the folders in this search path.

		The file returned isn't guaranteed to actually be a valid directory.

		@see getNumPaths
	*/
	File operator[] (int index) const;

	/** Returns the search path as a semicolon-separated list of directories. */
	String toString() const;

	/** Adds a new directory to the search path.

		The new directory is added to the end of the list if the insertIndex parameter is
		less than zero, otherwise it is inserted at the given index.
	*/
	void add (const File& directoryToAdd,
			  int insertIndex = -1);

	/** Adds a new directory to the search path if it's not already in there. */
	void addIfNotAlreadyThere (const File& directoryToAdd);

	/** Removes a directory from the search path. */
	void remove (int indexToRemove);

	/** Merges another search path into this one.

		This will remove any duplicate directories.
	*/
	void addPath (const FileSearchPath& other);

	/** Removes any directories that are actually subdirectories of one of the other directories in the search path.

		If the search is intended to be recursive, there's no point having nested folders in the search
		path, because they'll just get searched twice and you'll get duplicate results.

		e.g. if the path is "c:\abc\de;c:\abc", this method will simplify it to "c:\abc"
	*/
	void removeRedundantPaths();

	/** Removes any directories that don't actually exist. */
	void removeNonExistentPaths();

	/** Searches the path for a wildcard.

		This will search all the directories in the search path in order, adding any
		matching files to the results array.

		@param results                  an array to append the results to
		@param whatToLookFor            a value from the File::TypesOfFileToFind enum, specifying whether to
										return files, directories, or both.
		@param searchRecursively        whether to recursively search the subdirectories too
		@param wildCardPattern          a pattern to match against the filenames
		@returns the number of files added to the array
		@see File::findChildFiles
	*/
	int findChildFiles (Array<File>& results,
						int whatToLookFor,
						bool searchRecursively,
						const String& wildCardPattern = "*") const;

	/** Finds out whether a file is inside one of the path's directories.

		This will return true if the specified file is a child of one of the
		directories specified by this path. Note that this doesn't actually do any
		searching or check that the files exist - it just looks at the pathnames
		to work out whether the file would be inside a directory.

		@param fileToCheck      the file to look for
		@param checkRecursively if true, then this will return true if the file is inside a
								subfolder of one of the path's directories (at any depth). If false
								it will only return true if the file is actually a direct child
								of one of the directories.
		@see File::isAChildOf

	*/
	bool isFileInPath (const File& fileToCheck,
					   bool checkRecursively) const;

private:

	StringArray directories;

	void init (const String& path);

	JUCE_LEAK_DETECTOR (FileSearchPath);
};

#endif   // __JUCE_FILESEARCHPATH_JUCEHEADER__

/*** End of inlined file: juce_FileSearchPath.h ***/


#endif
#ifndef __JUCE_MEMORYMAPPEDFILE_JUCEHEADER__

/*** Start of inlined file: juce_MemoryMappedFile.h ***/
#ifndef __JUCE_MEMORYMAPPEDFILE_JUCEHEADER__
#define __JUCE_MEMORYMAPPEDFILE_JUCEHEADER__

/**
	Maps a file into virtual memory for easy reading and/or writing.
*/
class JUCE_API  MemoryMappedFile
{
public:
	/** The read/write flags used when opening a memory mapped file. */
	enum AccessMode
	{
		readOnly,   /**< Indicates that the memory can only be read. */
		readWrite   /**< Indicates that the memory can be read and written to - changes that are
						 made will be flushed back to disk at the whim of the OS. */
	};

	/** Opens a file and maps it to an area of virtual memory.

		The file should already exist, and should already be the size that you want to work with
		when you call this. If the file is resized after being opened, the behaviour is undefined.

		If the file exists and the operation succeeds, the getData() and getSize() methods will
		return the location and size of the data that can be read or written. Note that the entire
		file is not read into memory immediately - the OS simply creates a virtual mapping, which
		will lazily pull the data into memory when blocks are accessed.

		If the file can't be opened for some reason, the getData() method will return a null pointer.
	*/
	MemoryMappedFile (const File& file, AccessMode mode);

	/** Destructor. */
	~MemoryMappedFile();

	/** Returns the address at which this file has been mapped, or a null pointer if
		the file couldn't be successfully mapped.
	*/
	void* getData() const noexcept              { return address; }

	/** Returns the number of bytes of data that are available for reading or writing.
		This will normally be the size of the file.
	*/
	size_t getSize() const noexcept             { return length; }

private:

	void* address;
	size_t length;

   #if JUCE_WINDOWS
	void* fileHandle;
   #else
	int fileHandle;
   #endif

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (MemoryMappedFile);
};

#endif   // __JUCE_MEMORYMAPPEDFILE_JUCEHEADER__

/*** End of inlined file: juce_MemoryMappedFile.h ***/


#endif
#ifndef __JUCE_TEMPORARYFILE_JUCEHEADER__

/*** Start of inlined file: juce_TemporaryFile.h ***/
#ifndef __JUCE_TEMPORARYFILE_JUCEHEADER__
#define __JUCE_TEMPORARYFILE_JUCEHEADER__

/**
	Manages a temporary file, which will be deleted when this object is deleted.

	This object is intended to be used as a stack based object, using its scope
	to make sure the temporary file isn't left lying around.

	For example:

	@code
	{
		File myTargetFile ("~/myfile.txt");

		// this will choose a file called something like "~/myfile_temp239348.txt"
		// which definitely doesn't exist at the time the constructor is called.
		TemporaryFile temp (myTargetFile);

		// create a stream to the temporary file, and write some data to it...
		ScopedPointer <FileOutputStream> out (temp.getFile().createOutputStream());

		if (out != nullptr)
		{
			out->write ( ...etc )
			out = nullptr; // (deletes the stream)

			// ..now we've finished writing, this will rename the temp file to
			// make it replace the target file we specified above.
			bool succeeded = temp.overwriteTargetFileWithTemporary();
		}

		// ..and even if something went wrong and our overwrite failed,
		// as the TemporaryFile object goes out of scope here, it'll make sure
		// that the temp file gets deleted.
	}
	@endcode

	@see File, FileOutputStream
*/
class JUCE_API  TemporaryFile
{
public:

	enum OptionFlags
	{
		useHiddenFile = 1,          /**< Indicates that the temporary file should be hidden -
										 i.e. its name should start with a dot. */
		putNumbersInBrackets = 2    /**< Indicates that when numbers are appended to make sure
										 the file is unique, they should go in brackets rather
										 than just being appended (see File::getNonexistentSibling() )*/
	};

	/** Creates a randomly-named temporary file in the default temp directory.

		@param suffix       a file suffix to use for the file
		@param optionFlags  a combination of the values listed in the OptionFlags enum
		The file will not be created until you write to it. And remember that when
		this object is deleted, the file will also be deleted!
	*/
	TemporaryFile (const String& suffix = String::empty,
				   int optionFlags = 0);

	/** Creates a temporary file in the same directory as a specified file.

		This is useful if you have a file that you want to overwrite, but don't
		want to harm the original file if the write operation fails. You can
		use this to create a temporary file next to the target file, then
		write to the temporary file, and finally use overwriteTargetFileWithTemporary()
		to replace the target file with the one you've just written.

		This class won't create any files until you actually write to them. And remember
		that when this object is deleted, the temporary file will also be deleted!

		@param targetFile   the file that you intend to overwrite - the temporary
							file will be created in the same directory as this
		@param optionFlags  a combination of the values listed in the OptionFlags enum
	*/
	TemporaryFile (const File& targetFile,
				   int optionFlags = 0);

	/** Destructor.

		When this object is deleted it will make sure that its temporary file is
		also deleted! If the operation fails, it'll throw an assertion in debug
		mode.
	*/
	~TemporaryFile();

	/** Returns the temporary file. */
	const File& getFile() const                 { return temporaryFile; }

	/** Returns the target file that was specified in the constructor. */
	const File& getTargetFile() const           { return targetFile; }

	/** Tries to move the temporary file to overwrite the target file that was
		specified in the constructor.

		If you used the constructor that specified a target file, this will attempt
		to replace that file with the temporary one.

		Before calling this, make sure:
		- that you've actually written to the temporary file
		- that you've closed any open streams that you were using to write to it
		- and that you don't have any streams open to the target file, which would
		  prevent it being overwritten

		If the file move succeeds, this returns false, and the temporary file will
		have disappeared. If it fails, the temporary file will probably still exist,
		but will be deleted when this object is destroyed.
	*/
	bool overwriteTargetFileWithTemporary() const;

	/** Attempts to delete the temporary file, if it exists.
		@returns true if the file is successfully deleted (or if it didn't exist).
	*/
	bool deleteTemporaryFile() const;

private:

	File temporaryFile, targetFile;

	void createTempFile (const File& parentDirectory, String name, const String& suffix, int optionFlags);

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (TemporaryFile);
};

#endif   // __JUCE_TEMPORARYFILE_JUCEHEADER__

/*** End of inlined file: juce_TemporaryFile.h ***/


#endif
#ifndef __JUCE_JSON_JUCEHEADER__

/*** Start of inlined file: juce_JSON.h ***/
#ifndef __JUCE_JSON_JUCEHEADER__
#define __JUCE_JSON_JUCEHEADER__

class InputStream;
class OutputStream;
class File;

/**
	Contains static methods for converting JSON-formatted text to and from var objects.

	The var class is structurally compatible with JSON-formatted data, so these
	functions allow you to parse JSON into a var object, and to convert a var
	object to JSON-formatted text.

	@see var
*/
class JSON
{
public:

	/** Parses a string of JSON-formatted text, and returns a result code containing
		any parse errors.

		This will return the parsed structure in the parsedResult parameter, and will
		return a Result object to indicate whether parsing was successful, and if not,
		it will contain an error message.

		If you're not interested in the error message, you can use one of the other
		shortcut parse methods, which simply return a var::null if the parsing fails.
	*/
	static Result parse (const String& text, var& parsedResult);

	/** Attempts to parse some JSON-formatted text, and returns the result as a var object.

		If the parsing fails, this simply returns var::null - if you need to find out more
		detail about the parse error, use the alternative parse() method which returns a Result.
	*/
	static var parse (const String& text);

	/** Attempts to parse some JSON-formatted text from a file, and returns the result
		as a var object.

		Note that this is just a short-cut for reading the entire file into a string and
		parsing the result.

		If the parsing fails, this simply returns var::null - if you need to find out more
		detail about the parse error, use the alternative parse() method which returns a Result.
	*/
	static var parse (const File& file);

	/** Attempts to parse some JSON-formatted text from a stream, and returns the result
		as a var object.

		Note that this is just a short-cut for reading the entire stream into a string and
		parsing the result.

		If the parsing fails, this simply returns var::null - if you need to find out more
		detail about the parse error, use the alternative parse() method which returns a Result.
	*/
	static var parse (InputStream& input);

	/** Returns a string which contains a JSON-formatted representation of the var object.
		If allOnOneLine is true, the result will be compacted into a single line of text
		with no carriage-returns. If false, it will be laid-out in a more human-readable format.
		@see writeToStream
	*/
	static String toString (const var& objectToFormat,
							bool allOnOneLine = false);

	/** Writes a JSON-formatted representation of the var object to the given stream.
		If allOnOneLine is true, the result will be compacted into a single line of text
		with no carriage-returns. If false, it will be laid-out in a more human-readable format.
		@see toString
	*/
	static void writeToStream (OutputStream& output,
							   const var& objectToFormat,
							   bool allOnOneLine = false);

private:

	JSON(); // This class can't be instantiated - just use its static methods.
};

#endif   // __JUCE_JSON_JUCEHEADER__

/*** End of inlined file: juce_JSON.h ***/


#endif
#ifndef __JUCE_FILELOGGER_JUCEHEADER__

/*** Start of inlined file: juce_FileLogger.h ***/
#ifndef __JUCE_FILELOGGER_JUCEHEADER__
#define __JUCE_FILELOGGER_JUCEHEADER__

/**
	A simple implemenation of a Logger that writes to a file.

	@see Logger
*/
class JUCE_API  FileLogger  : public Logger
{
public:

	/** Creates a FileLogger for a given file.

		@param fileToWriteTo    the file that to use - new messages will be appended
								to the file. If the file doesn't exist, it will be created,
								along with any parent directories that are needed.
		@param welcomeMessage   when opened, the logger will write a header to the log, along
								with the current date and time, and this welcome message
		@param maxInitialFileSizeBytes  if this is zero or greater, then if the file already exists
								but is larger than this number of bytes, then the start of the
								file will be truncated to keep the size down. This prevents a log
								file getting ridiculously large over time. The file will be truncated
								at a new-line boundary. If this value is less than zero, no size limit
								will be imposed; if it's zero, the file will always be deleted. Note that
								the size is only checked once when this object is created - any logging
								that is done later will be appended without any checking
	*/
	FileLogger (const File& fileToWriteTo,
				const String& welcomeMessage,
				const int maxInitialFileSizeBytes = 128 * 1024);

	/** Destructor. */
	~FileLogger();

	void logMessage (const String& message);

	File getLogFile() const               { return logFile; }

	/** Helper function to create a log file in the correct place for this platform.

		On Windows this will return a logger with a path such as:
		c:\\Documents and Settings\\username\\Application Data\\[logFileSubDirectoryName]\\[logFileName]

		On the Mac it'll create something like:
		~/Library/Logs/[logFileName]

		The method might return 0 if the file can't be created for some reason.

		@param logFileSubDirectoryName      if a subdirectory is needed, this is what it will be called -
											it's best to use the something like the name of your application here.
		@param logFileName                  the name of the file to create, e.g. "MyAppLog.txt". Don't just
											call it "log.txt" because if it goes in a directory with logs
											from other applications (as it will do on the Mac) then no-one
											will know which one is yours!
		@param welcomeMessage               a message that will be written to the log when it's opened.
		@param maxInitialFileSizeBytes      (see the FileLogger constructor for more info on this)
	*/
	static FileLogger* createDefaultAppLogger (const String& logFileSubDirectoryName,
											   const String& logFileName,
											   const String& welcomeMessage,
											   const int maxInitialFileSizeBytes = 128 * 1024);

private:

	File logFile;
	CriticalSection logLock;

	void trimFileSize (int maxFileSizeBytes) const;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (FileLogger);
};

#endif   // __JUCE_FILELOGGER_JUCEHEADER__

/*** End of inlined file: juce_FileLogger.h ***/


#endif
#ifndef __JUCE_LOGGER_JUCEHEADER__

#endif
#ifndef __JUCE_BIGINTEGER_JUCEHEADER__

/*** Start of inlined file: juce_BigInteger.h ***/
#ifndef __JUCE_BIGINTEGER_JUCEHEADER__
#define __JUCE_BIGINTEGER_JUCEHEADER__

class MemoryBlock;

/**
	An arbitrarily large integer class.

	A BigInteger can be used in a similar way to a normal integer, but has no size
	limit (except for memory and performance constraints).

	Negative values are possible, but the value isn't stored as 2s-complement, so
	be careful if you use negative values and look at the values of individual bits.
*/
class JUCE_API  BigInteger
{
public:

	/** Creates an empty BigInteger */
	BigInteger();

	/** Creates a BigInteger containing an integer value in its low bits.

		The low 32 bits of the number are initialised with this value.
	*/
	BigInteger (uint32 value);

	/** Creates a BigInteger containing an integer value in its low bits.

		The low 32 bits of the number are initialised with the absolute value
		passed in, and its sign is set to reflect the sign of the number.
	*/
	BigInteger (int32 value);

	/** Creates a BigInteger containing an integer value in its low bits.

		The low 64 bits of the number are initialised with the absolute value
		passed in, and its sign is set to reflect the sign of the number.
	*/
	BigInteger (int64 value);

	/** Creates a copy of another BigInteger. */
	BigInteger (const BigInteger& other);

   #if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
	BigInteger (BigInteger&& other) noexcept;
	BigInteger& operator= (BigInteger&& other) noexcept;
   #endif

	/** Destructor. */
	~BigInteger();

	/** Copies another BigInteger onto this one. */
	BigInteger& operator= (const BigInteger& other);

	/** Swaps the internal contents of this with another object. */
	void swapWith (BigInteger& other) noexcept;

	/** Returns the value of a specified bit in the number.
		If the index is out-of-range, the result will be false.
	*/
	bool operator[] (int bit) const noexcept;

	/** Returns true if no bits are set. */
	bool isZero() const noexcept;

	/** Returns true if the value is 1. */
	bool isOne() const noexcept;

	/** Attempts to get the lowest bits of the value as an integer.
		If the value is bigger than the integer limits, this will return only the lower bits.
	*/
	int toInteger() const noexcept;

	/** Resets the value to 0. */
	void clear();

	/** Clears a particular bit in the number. */
	void clearBit (int bitNumber) noexcept;

	/** Sets a specified bit to 1. */
	void setBit (int bitNumber);

	/** Sets or clears a specified bit. */
	void setBit (int bitNumber, bool shouldBeSet);

	/** Sets a range of bits to be either on or off.

		@param startBit     the first bit to change
		@param numBits      the number of bits to change
		@param shouldBeSet  whether to turn these bits on or off
	*/
	void setRange (int startBit, int numBits, bool shouldBeSet);

	/** Inserts a bit an a given position, shifting up any bits above it. */
	void insertBit (int bitNumber, bool shouldBeSet);

	/** Returns a range of bits as a new BigInteger.

		e.g. getBitRangeAsInt (0, 64) would return the lowest 64 bits.
		@see getBitRangeAsInt
	*/
	BigInteger getBitRange (int startBit, int numBits) const;

	/** Returns a range of bits as an integer value.

		e.g. getBitRangeAsInt (0, 32) would return the lowest 32 bits.

		Asking for more than 32 bits isn't allowed (obviously) - for that, use
		getBitRange().
	*/
	uint32 getBitRangeAsInt (int startBit, int numBits) const noexcept;

	/** Sets a range of bits to an integer value.

		Copies the given integer onto a range of bits, starting at startBit,
		and using up to numBits of the available bits.
	*/
	void setBitRangeAsInt (int startBit, int numBits, uint32 valueToSet);

	/** Shifts a section of bits left or right.

		@param howManyBitsLeft  how far to move the bits (+ve numbers shift it left, -ve numbers shift it right).
		@param startBit         the first bit to affect - if this is > 0, only bits above that index will be affected.
	*/
	void shiftBits (int howManyBitsLeft, int startBit);

	/** Returns the total number of set bits in the value. */
	int countNumberOfSetBits() const noexcept;

	/** Looks for the index of the next set bit after a given starting point.

		This searches from startIndex (inclusive) upwards for the first set bit,
		and returns its index. If no set bits are found, it returns -1.
	*/
	int findNextSetBit (int startIndex = 0) const noexcept;

	/** Looks for the index of the next clear bit after a given starting point.

		This searches from startIndex (inclusive) upwards for the first clear bit,
		and returns its index.
	*/
	int findNextClearBit (int startIndex = 0) const noexcept;

	/** Returns the index of the highest set bit in the number.
		If the value is zero, this will return -1.
	*/
	int getHighestBit() const noexcept;

	// All the standard arithmetic ops...

	BigInteger& operator+= (const BigInteger& other);
	BigInteger& operator-= (const BigInteger& other);
	BigInteger& operator*= (const BigInteger& other);
	BigInteger& operator/= (const BigInteger& other);
	BigInteger& operator|= (const BigInteger& other);
	BigInteger& operator&= (const BigInteger& other);
	BigInteger& operator^= (const BigInteger& other);
	BigInteger& operator%= (const BigInteger& other);
	BigInteger& operator<<= (int numBitsToShift);
	BigInteger& operator>>= (int numBitsToShift);
	BigInteger& operator++();
	BigInteger& operator--();
	BigInteger operator++ (int);
	BigInteger operator-- (int);

	BigInteger operator-() const;
	BigInteger operator+ (const BigInteger& other) const;
	BigInteger operator- (const BigInteger& other) const;
	BigInteger operator* (const BigInteger& other) const;
	BigInteger operator/ (const BigInteger& other) const;
	BigInteger operator| (const BigInteger& other) const;
	BigInteger operator& (const BigInteger& other) const;
	BigInteger operator^ (const BigInteger& other) const;
	BigInteger operator% (const BigInteger& other) const;
	BigInteger operator<< (int numBitsToShift) const;
	BigInteger operator>> (int numBitsToShift) const;

	bool operator== (const BigInteger& other) const noexcept;
	bool operator!= (const BigInteger& other) const noexcept;
	bool operator<  (const BigInteger& other) const noexcept;
	bool operator<= (const BigInteger& other) const noexcept;
	bool operator>  (const BigInteger& other) const noexcept;
	bool operator>= (const BigInteger& other) const noexcept;

	/** Does a signed comparison of two BigIntegers.

		Return values are:
			- 0 if the numbers are the same
			- < 0 if this number is smaller than the other
			- > 0 if this number is bigger than the other
	*/
	int compare (const BigInteger& other) const noexcept;

	/** Compares the magnitudes of two BigIntegers, ignoring their signs.

		Return values are:
			- 0 if the numbers are the same
			- < 0 if this number is smaller than the other
			- > 0 if this number is bigger than the other
	*/
	int compareAbsolute (const BigInteger& other) const noexcept;

	/** Divides this value by another one and returns the remainder.

		This number is divided by other, leaving the quotient in this number,
		with the remainder being copied to the other BigInteger passed in.
	*/
	void divideBy (const BigInteger& divisor, BigInteger& remainder);

	/** Returns the largest value that will divide both this value and the one passed-in.
	*/
	BigInteger findGreatestCommonDivisor (BigInteger other) const;

	/** Performs a combined exponent and modulo operation.

		This BigInteger's value becomes (this ^ exponent) % modulus.
	*/
	void exponentModulo (const BigInteger& exponent, const BigInteger& modulus);

	/** Performs an inverse modulo on the value.

		i.e. the result is (this ^ -1) mod (modulus).
	*/
	void inverseModulo (const BigInteger& modulus);

	/** Returns true if the value is less than zero.
		@see setNegative, negate
	*/
	bool isNegative() const noexcept;

	/** Changes the sign of the number to be positive or negative.
		@see isNegative, negate
	*/
	void setNegative (bool shouldBeNegative) noexcept;

	/** Inverts the sign of the number.
		@see isNegative, setNegative
	*/
	void negate() noexcept;

	/** Converts the number to a string.

		Specify a base such as 2 (binary), 8 (octal), 10 (decimal), 16 (hex).
		If minimumNumCharacters is greater than 0, the returned string will be
		padded with leading zeros to reach at least that length.
	*/
	String toString (int base, int minimumNumCharacters = 1) const;

	/** Reads the numeric value from a string.

		Specify a base such as 2 (binary), 8 (octal), 10 (decimal), 16 (hex).
		Any invalid characters will be ignored.
	*/
	void parseString (const String& text, int base);

	/** Turns the number into a block of binary data.

		The data is arranged as little-endian, so the first byte of data is the low 8 bits
		of the number, and so on.

		@see loadFromMemoryBlock
	*/
	MemoryBlock toMemoryBlock() const;

	/** Converts a block of raw data into a number.

		The data is arranged as little-endian, so the first byte of data is the low 8 bits
		of the number, and so on.

		@see toMemoryBlock
	*/
	void loadFromMemoryBlock (const MemoryBlock& data);

private:

	HeapBlock <uint32> values;
	size_t numValues;
	int highestBit;
	bool negative;

	void ensureSize (size_t numVals);
	void shiftLeft (int bits, int startBit);
	void shiftRight (int bits, int startBit);

	JUCE_LEAK_DETECTOR (BigInteger);
};

/** Writes a BigInteger to an OutputStream as a UTF8 decimal string. */
OutputStream& JUCE_CALLTYPE operator<< (OutputStream& stream, const BigInteger& value);

#ifndef DOXYGEN
 // For backwards compatibility, BitArray is defined as an alias for BigInteger.
 typedef BigInteger BitArray;
#endif

#endif   // __JUCE_BIGINTEGER_JUCEHEADER__

/*** End of inlined file: juce_BigInteger.h ***/


#endif
#ifndef __JUCE_EXPRESSION_JUCEHEADER__

/*** Start of inlined file: juce_Expression.h ***/
#ifndef __JUCE_EXPRESSION_JUCEHEADER__
#define __JUCE_EXPRESSION_JUCEHEADER__

/**
	A class for dynamically evaluating simple numeric expressions.

	This class can parse a simple C-style string expression involving floating point
	numbers, named symbols and functions. The basic arithmetic operations of +, -, *, /
	are supported, as well as parentheses, and any alphanumeric identifiers are
	assumed to be named symbols which will be resolved when the expression is
	evaluated.

	Expressions which use identifiers and functions require a subclass of
	Expression::Scope to be supplied when evaluating them, and this object
	is expected to be able to resolve the symbol names and perform the functions that
	are used.
*/
class JUCE_API  Expression
{
public:

	/** Creates a simple expression with a value of 0. */
	Expression();

	/** Destructor. */
	~Expression();

	/** Creates a simple expression with a specified constant value. */
	explicit Expression (double constant);

	/** Creates a copy of an expression. */
	Expression (const Expression& other);

	/** Copies another expression. */
	Expression& operator= (const Expression& other);

   #if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
	Expression (Expression&& other) noexcept;
	Expression& operator= (Expression&& other) noexcept;
   #endif

	/** Creates an expression by parsing a string.
		If there's a syntax error in the string, this will throw a ParseError exception.
		@throws ParseError
	*/
	explicit Expression (const String& stringToParse);

	/** Returns a string version of the expression. */
	String toString() const;

	/** Returns an expression which is an addtion operation of two existing expressions. */
	Expression operator+ (const Expression& other) const;
	/** Returns an expression which is a subtraction operation of two existing expressions. */
	Expression operator- (const Expression& other) const;
	/** Returns an expression which is a multiplication operation of two existing expressions. */
	Expression operator* (const Expression& other) const;
	/** Returns an expression which is a division operation of two existing expressions. */
	Expression operator/ (const Expression& other) const;
	/** Returns an expression which performs a negation operation on an existing expression. */
	Expression operator-() const;

	/** Returns an Expression which is an identifier reference. */
	static Expression symbol (const String& symbol);

	/** Returns an Expression which is a function call. */
	static Expression function (const String& functionName, const Array<Expression>& parameters);

	/** Returns an Expression which parses a string from a character pointer, and updates the pointer
		to indicate where it finished.

		The pointer is incremented so that on return, it indicates the character that follows
		the end of the expression that was parsed.

		If there's a syntax error in the string, this will throw a ParseError exception.
		@throws ParseError
	*/
	static Expression parse (String::CharPointerType& stringToParse);

	/** When evaluating an Expression object, this class is used to resolve symbols and
		perform functions that the expression uses.
	*/
	class JUCE_API  Scope
	{
	public:
		Scope();
		virtual ~Scope();

		/** Returns some kind of globally unique ID that identifies this scope. */
		virtual String getScopeUID() const;

		/** Returns the value of a symbol.
			If the symbol is unknown, this can throw an Expression::EvaluationError exception.
			The member value is set to the part of the symbol that followed the dot, if there is
			one, e.g. for "foo.bar", symbol = "foo" and member = "bar".
			@throws Expression::EvaluationError
		*/
		virtual Expression getSymbolValue (const String& symbol) const;

		/** Executes a named function.
			If the function name is unknown, this can throw an Expression::EvaluationError exception.
			@throws Expression::EvaluationError
		*/
		virtual double evaluateFunction (const String& functionName,
										 const double* parameters, int numParameters) const;

		/** Used as a callback by the Scope::visitRelativeScope() method.
			You should never create an instance of this class yourself, it's used by the
			expression evaluation code.
		*/
		class Visitor
		{
		public:
			virtual ~Visitor() {}
			virtual void visit (const Scope&) = 0;
		};

		/** Creates a Scope object for a named scope, and then calls a visitor
			to do some kind of processing with this new scope.

			If the name is valid, this method must create a suitable (temporary) Scope
			object to represent it, and must call the Visitor::visit() method with this
			new scope.
		*/
		virtual void visitRelativeScope (const String& scopeName, Visitor& visitor) const;
	};

	/** Evaluates this expression, without using a Scope.
		Without a Scope, no symbols can be used, and only basic functions such as sin, cos, tan,
		min, max are available.
		To find out about any errors during evaluation, use the other version of this method which
		takes a String parameter.
	*/
	double evaluate() const;

	/** Evaluates this expression, providing a scope that should be able to evaluate any symbols
		or functions that it uses.
		To find out about any errors during evaluation, use the other version of this method which
		takes a String parameter.
	*/
	double evaluate (const Scope& scope) const;

	/** Evaluates this expression, providing a scope that should be able to evaluate any symbols
		or functions that it uses.
	*/
	double evaluate (const Scope& scope, String& evaluationError) const;

	/** Attempts to return an expression which is a copy of this one, but with a constant adjusted
		to make the expression resolve to a target value.

		E.g. if the expression is "x + 10" and x is 5, then asking for a target value of 8 will return
		the expression "x + 3". Obviously some expressions can't be reversed in this way, in which
		case they might just be adjusted by adding a constant to the original expression.

		@throws Expression::EvaluationError
	*/
	Expression adjustedToGiveNewResult (double targetValue, const Scope& scope) const;

	/** Represents a symbol that is used in an Expression. */
	struct Symbol
	{
		Symbol (const String& scopeUID, const String& symbolName);
		bool operator== (const Symbol&) const noexcept;
		bool operator!= (const Symbol&) const noexcept;

		String scopeUID;    /**< The unique ID of the Scope that contains this symbol. */
		String symbolName;  /**< The name of the symbol. */
	};

	/** Returns a copy of this expression in which all instances of a given symbol have been renamed. */
	Expression withRenamedSymbol (const Symbol& oldSymbol, const String& newName, const Scope& scope) const;

	/** Returns true if this expression makes use of the specified symbol.
		If a suitable scope is supplied, the search will dereference and recursively check
		all symbols, so that it can be determined whether this expression relies on the given
		symbol at any level in its evaluation. If the scope parameter is null, this just checks
		whether the expression contains any direct references to the symbol.

		@throws Expression::EvaluationError
	*/
	bool referencesSymbol (const Symbol& symbol, const Scope& scope) const;

	/** Returns true if this expression contains any symbols. */
	bool usesAnySymbols() const;

	/** Returns a list of all symbols that may be needed to resolve this expression in the given scope. */
	void findReferencedSymbols (Array<Symbol>& results, const Scope& scope) const;

	/** An exception that can be thrown by Expression::parse(). */
	class ParseError  : public std::exception
	{
	public:
		ParseError (const String& message);

		String description;
	};

	/** Expression type.
		@see Expression::getType()
	*/
	enum Type
	{
		constantType,
		functionType,
		operatorType,
		symbolType
	};

	/** Returns the type of this expression. */
	Type getType() const noexcept;

	/** If this expression is a symbol, function or operator, this returns its identifier. */
	String getSymbolOrFunction() const;

	/** Returns the number of inputs to this expression.
		@see getInput
	*/
	int getNumInputs() const;

	/** Retrieves one of the inputs to this expression.
		@see getNumInputs
	*/
	Expression getInput (int index) const;

private:

	class Term;
	struct Helpers;
	friend class Term;
	friend struct Helpers;
	friend class ScopedPointer<Term>;
	friend class ReferenceCountedObjectPtr<Term>;
	ReferenceCountedObjectPtr<Term> term;

	explicit Expression (Term*);
};

#endif   // __JUCE_EXPRESSION_JUCEHEADER__

/*** End of inlined file: juce_Expression.h ***/


#endif
#ifndef __JUCE_MATHSFUNCTIONS_JUCEHEADER__

#endif
#ifndef __JUCE_RANDOM_JUCEHEADER__

/*** Start of inlined file: juce_Random.h ***/
#ifndef __JUCE_RANDOM_JUCEHEADER__
#define __JUCE_RANDOM_JUCEHEADER__

/**
	A random number generator.

	You can create a Random object and use it to generate a sequence of random numbers.
*/
class JUCE_API  Random
{
public:

	/** Creates a Random object based on a seed value.

		For a given seed value, the subsequent numbers generated by this object
		will be predictable, so a good idea is to set this value based
		on the time, e.g.

		new Random (Time::currentTimeMillis())
	*/
	explicit Random (int64 seedValue) noexcept;

	/** Creates a Random object using a random seed value.
		Internally, this calls setSeedRandomly() to randomise the seed.
	*/
	Random();

	/** Destructor. */
	~Random() noexcept;

	/** Returns the next random 32 bit integer.

		@returns a random integer from the full range 0x80000000 to 0x7fffffff
	*/
	int nextInt() noexcept;

	/** Returns the next random number, limited to a given range.
		The maxValue parameter may not be negative, or zero.
		@returns a random integer between 0 (inclusive) and maxValue (exclusive).
	*/
	int nextInt (int maxValue) noexcept;

	/** Returns the next 64-bit random number.

		@returns a random integer from the full range 0x8000000000000000 to 0x7fffffffffffffff
	*/
	int64 nextInt64() noexcept;

	/** Returns the next random floating-point number.

		@returns a random value in the range 0 to 1.0
	*/
	float nextFloat() noexcept;

	/** Returns the next random floating-point number.

		@returns a random value in the range 0 to 1.0
	*/
	double nextDouble() noexcept;

	/** Returns the next random boolean value.
	*/
	bool nextBool() noexcept;

	/** Returns a BigInteger containing a random number.

		@returns a random value in the range 0 to (maximumValue - 1).
	*/
	BigInteger nextLargeNumber (const BigInteger& maximumValue);

	/** Sets a range of bits in a BigInteger to random values. */
	void fillBitsRandomly (BigInteger& arrayToChange, int startBit, int numBits);

	/** Resets this Random object to a given seed value. */
	void setSeed (int64 newSeed) noexcept;

	/** Merges this object's seed with another value.
		This sets the seed to be a value created by combining the current seed and this
		new value.
	*/
	void combineSeed (int64 seedValue) noexcept;

	/** Reseeds this generator using a value generated from various semi-random system
		properties like the current time, etc.

		Because this function convolves the time with the last seed value, calling
		it repeatedly will increase the randomness of the final result.
	*/
	void setSeedRandomly();

	/** The overhead of creating a new Random object is fairly small, but if you want to avoid
		it, you can call this method to get a global shared Random object.

		It's not thread-safe though, so threads should use their own Random object, otherwise
		you run the risk of your random numbers becoming.. erm.. randomly corrupted..
	*/
	static Random& getSystemRandom() noexcept;

private:

	int64 seed;

	JUCE_LEAK_DETECTOR (Random);
};

#endif   // __JUCE_RANDOM_JUCEHEADER__

/*** End of inlined file: juce_Random.h ***/


#endif
#ifndef __JUCE_RANGE_JUCEHEADER__

#endif
#ifndef __JUCE_ATOMIC_JUCEHEADER__

#endif
#ifndef __JUCE_BYTEORDER_JUCEHEADER__

#endif
#ifndef __JUCE_HEAPBLOCK_JUCEHEADER__

#endif
#ifndef __JUCE_LEAKEDOBJECTDETECTOR_JUCEHEADER__

#endif
#ifndef __JUCE_MEMORY_JUCEHEADER__

#endif
#ifndef __JUCE_MEMORYBLOCK_JUCEHEADER__

#endif
#ifndef __JUCE_OPTIONALSCOPEDPOINTER_JUCEHEADER__

/*** Start of inlined file: juce_OptionalScopedPointer.h ***/
#ifndef __JUCE_OPTIONALSCOPEDPOINTER_JUCEHEADER__
#define __JUCE_OPTIONALSCOPEDPOINTER_JUCEHEADER__

/**
	Holds a pointer to an object which can optionally be deleted when this pointer
	goes out of scope.

	This acts in many ways like a ScopedPointer, but allows you to specify whether or
	not the object is deleted.

	@see ScopedPointer
*/
template <class ObjectType>
class OptionalScopedPointer
{
public:

	/** Creates an empty OptionalScopedPointer. */
	OptionalScopedPointer() : shouldDelete (false) {}

	/** Creates an OptionalScopedPointer to point to a given object, and specifying whether
		the OptionalScopedPointer will delete it.

		If takeOwnership is true, then the OptionalScopedPointer will act like a ScopedPointer,
		deleting the object when it is itself deleted. If this parameter is false, then the
		OptionalScopedPointer just holds a normal pointer to the object, and won't delete it.
	*/
	OptionalScopedPointer (ObjectType* objectToHold, bool takeOwnership)
		: object (objectToHold), shouldDelete (takeOwnership)
	{
	}

	/** Takes ownership of the object that another OptionalScopedPointer holds.

		Like a normal ScopedPointer, the objectToTransferFrom object will become null,
		as ownership of the managed object is transferred to this object.

		The flag to indicate whether or not to delete the managed object is also
		copied from the source object.
	*/
	OptionalScopedPointer (OptionalScopedPointer& objectToTransferFrom)
		: object (objectToTransferFrom.release()),
		  shouldDelete (objectToTransferFrom.shouldDelete)
	{
	}

	/** Takes ownership of the object that another OptionalScopedPointer holds.

		Like a normal ScopedPointer, the objectToTransferFrom object will become null,
		as ownership of the managed object is transferred to this object.

		The ownership flag that says whether or not to delete the managed object is also
		copied from the source object.
	*/
	OptionalScopedPointer& operator= (OptionalScopedPointer& objectToTransferFrom)
	{
		if (object != objectToTransferFrom.object)
		{
			clear();
			object = objectToTransferFrom.object;
		}

		shouldDelete = objectToTransferFrom.shouldDelete;
		return *this;
	}

	/** The destructor may or may not delete the object that is being held, depending on the
		takeOwnership flag that was specified when the object was first passed into an
		OptionalScopedPointer constructor.
	*/
	~OptionalScopedPointer()
	{
		clear();
	}

	/** Returns the object that this pointer is managing. */
	inline operator ObjectType*() const noexcept                    { return object; }

	/** Returns the object that this pointer is managing. */
	inline ObjectType& operator*() const noexcept                   { return *object; }

	/** Lets you access methods and properties of the object that this pointer is holding. */
	inline ObjectType* operator->() const noexcept                  { return object; }

	/** Removes the current object from this OptionalScopedPointer without deleting it.
		This will return the current object, and set this OptionalScopedPointer to a null pointer.
	*/
	ObjectType* release() noexcept                                  { return object.release(); }

	/** Resets this pointer to null, possibly deleting the object that it holds, if it has
		ownership of it.
	*/
	void clear()
	{
		if (! shouldDelete)
			object.release();
	}

	/** Swaps this object with another OptionalScopedPointer.
		The two objects simply exchange their states.
	*/
	void swapWith (OptionalScopedPointer<ObjectType>& other) noexcept
	{
		object.swapWith (other.object);
		std::swap (shouldDelete, other.shouldDelete);
	}

private:

	ScopedPointer<ObjectType> object;
	bool shouldDelete;
};

#endif   // __JUCE_OPTIONALSCOPEDPOINTER_JUCEHEADER__

/*** End of inlined file: juce_OptionalScopedPointer.h ***/


#endif
#ifndef __JUCE_REFERENCECOUNTEDOBJECT_JUCEHEADER__

#endif
#ifndef __JUCE_SCOPEDPOINTER_JUCEHEADER__

#endif
#ifndef __JUCE_SINGLETON_JUCEHEADER__

/*** Start of inlined file: juce_Singleton.h ***/
#ifndef __JUCE_SINGLETON_JUCEHEADER__
#define __JUCE_SINGLETON_JUCEHEADER__

/**
	Macro to declare member variables and methods for a singleton class.

	To use this, add the line juce_DeclareSingleton (MyClass, doNotRecreateAfterDeletion)
	to the class's definition.

	Then put a macro juce_ImplementSingleton (MyClass) along with the class's
	implementation code.

	It's also a very good idea to also add the call clearSingletonInstance() in your class's
	destructor, in case it is deleted by other means than deleteInstance()

	Clients can then call the static method MyClass::getInstance() to get a pointer
	to the singleton, or MyClass::getInstanceWithoutCreating() which will return 0 if
	no instance currently exists.

	e.g. @code

		class MySingleton
		{
		public:
			MySingleton()
			{
			}

			~MySingleton()
			{
				// this ensures that no dangling pointers are left when the
				// singleton is deleted.
				clearSingletonInstance();
			}

			juce_DeclareSingleton (MySingleton, false)
		};

		juce_ImplementSingleton (MySingleton)

		// example of usage:
		MySingleton* m = MySingleton::getInstance(); // creates the singleton if there isn't already one.

		...

		MySingleton::deleteInstance(); // safely deletes the singleton (if it's been created).

	@endcode

	If doNotRecreateAfterDeletion = true, it won't allow the object to be created more
	than once during the process's lifetime - i.e. after you've created and deleted the
	object, getInstance() will refuse to create another one. This can be useful to stop
	objects being accidentally re-created during your app's shutdown code.

	If you know that your object will only be created and deleted by a single thread, you
	can use the slightly more efficient juce_DeclareSingleton_SingleThreaded() macro instead
	of this one.

	@see juce_ImplementSingleton, juce_DeclareSingleton_SingleThreaded
*/
#define juce_DeclareSingleton(classname, doNotRecreateAfterDeletion) \
\
	static classname* _singletonInstance;  \
	static juce::CriticalSection _singletonLock; \
\
	static classname* JUCE_CALLTYPE getInstance() \
	{ \
		if (_singletonInstance == nullptr) \
		{\
			const juce::ScopedLock sl (_singletonLock); \
\
			if (_singletonInstance == nullptr) \
			{ \
				static bool alreadyInside = false; \
				static bool createdOnceAlready = false; \
\
				const bool problem = alreadyInside || ((doNotRecreateAfterDeletion) && createdOnceAlready); \
				jassert (! problem); \
				if (! problem) \
				{ \
					createdOnceAlready = true; \
					alreadyInside = true; \
					classname* newObject = new classname();  /* (use a stack variable to avoid setting the newObject value before the class has finished its constructor) */ \
					alreadyInside = false; \
\
					_singletonInstance = newObject; \
				} \
			} \
		} \
\
		return _singletonInstance; \
	} \
\
	static inline classname* JUCE_CALLTYPE getInstanceWithoutCreating() noexcept\
	{ \
		return _singletonInstance; \
	} \
\
	static void JUCE_CALLTYPE deleteInstance() \
	{ \
		const juce::ScopedLock sl (_singletonLock); \
		if (_singletonInstance != nullptr) \
		{ \
			classname* const old = _singletonInstance; \
			_singletonInstance = nullptr; \
			delete old; \
		} \
	} \
\
	void clearSingletonInstance() noexcept\
	{ \
		if (_singletonInstance == this) \
			_singletonInstance = nullptr; \
	}

/** This is a counterpart to the juce_DeclareSingleton macro.

	After adding the juce_DeclareSingleton to the class definition, this macro has
	to be used in the cpp file.
*/
#define juce_ImplementSingleton(classname) \
\
	classname* classname::_singletonInstance = nullptr; \
	juce::CriticalSection classname::_singletonLock;

/**
	Macro to declare member variables and methods for a singleton class.

	This is exactly the same as juce_DeclareSingleton, but doesn't use a critical
	section to make access to it thread-safe. If you know that your object will
	only ever be created or deleted by a single thread, then this is a
	more efficient version to use.

	If doNotRecreateAfterDeletion = true, it won't allow the object to be created more
	than once during the process's lifetime - i.e. after you've created and deleted the
	object, getInstance() will refuse to create another one. This can be useful to stop
	objects being accidentally re-created during your app's shutdown code.

	See the documentation for juce_DeclareSingleton for more information about
	how to use it, the only difference being that you have to use
	juce_ImplementSingleton_SingleThreaded instead of juce_ImplementSingleton.

	@see juce_ImplementSingleton_SingleThreaded, juce_DeclareSingleton, juce_DeclareSingleton_SingleThreaded_Minimal
*/
#define juce_DeclareSingleton_SingleThreaded(classname, doNotRecreateAfterDeletion) \
\
	static classname* _singletonInstance;  \
\
	static classname* getInstance() \
	{ \
		if (_singletonInstance == nullptr) \
		{ \
			static bool alreadyInside = false; \
			static bool createdOnceAlready = false; \
\
			const bool problem = alreadyInside || ((doNotRecreateAfterDeletion) && createdOnceAlready); \
			jassert (! problem); \
			if (! problem) \
			{ \
				createdOnceAlready = true; \
				alreadyInside = true; \
				classname* newObject = new classname();  /* (use a stack variable to avoid setting the newObject value before the class has finished its constructor) */ \
				alreadyInside = false; \
\
				_singletonInstance = newObject; \
			} \
		} \
\
		return _singletonInstance; \
	} \
\
	static inline classname* getInstanceWithoutCreating() noexcept\
	{ \
		return _singletonInstance; \
	} \
\
	static void deleteInstance() \
	{ \
		if (_singletonInstance != nullptr) \
		{ \
			classname* const old = _singletonInstance; \
			_singletonInstance = nullptr; \
			delete old; \
		} \
	} \
\
	void clearSingletonInstance() noexcept\
	{ \
		if (_singletonInstance == this) \
			_singletonInstance = nullptr; \
	}

/**
	Macro to declare member variables and methods for a singleton class.

	This is like juce_DeclareSingleton_SingleThreaded, but doesn't do any checking
	for recursion or repeated instantiation. It's intended for use as a lightweight
	version of a singleton, where you're using it in very straightforward
	circumstances and don't need the extra checking.

	Juce use the normal juce_ImplementSingleton_SingleThreaded as the counterpart
	to this declaration, as you would with juce_DeclareSingleton_SingleThreaded.

	See the documentation for juce_DeclareSingleton for more information about
	how to use it, the only difference being that you have to use
	juce_ImplementSingleton_SingleThreaded instead of juce_ImplementSingleton.

	@see juce_ImplementSingleton_SingleThreaded, juce_DeclareSingleton
*/
#define juce_DeclareSingleton_SingleThreaded_Minimal(classname) \
\
	static classname* _singletonInstance;  \
\
	static classname* getInstance() \
	{ \
		if (_singletonInstance == nullptr) \
			_singletonInstance = new classname(); \
\
		return _singletonInstance; \
	} \
\
	static inline classname* getInstanceWithoutCreating() noexcept\
	{ \
		return _singletonInstance; \
	} \
\
	static void deleteInstance() \
	{ \
		if (_singletonInstance != nullptr) \
		{ \
			classname* const old = _singletonInstance; \
			_singletonInstance = nullptr; \
			delete old; \
		} \
	} \
\
	void clearSingletonInstance() noexcept\
	{ \
		if (_singletonInstance == this) \
			_singletonInstance = nullptr; \
	}

/** This is a counterpart to the juce_DeclareSingleton_SingleThreaded macro.

	After adding juce_DeclareSingleton_SingleThreaded or juce_DeclareSingleton_SingleThreaded_Minimal
	to the class definition, this macro has to be used somewhere in the cpp file.
*/
#define juce_ImplementSingleton_SingleThreaded(classname) \
\
	classname* classname::_singletonInstance = nullptr;

#endif   // __JUCE_SINGLETON_JUCEHEADER__

/*** End of inlined file: juce_Singleton.h ***/


#endif
#ifndef __JUCE_WEAKREFERENCE_JUCEHEADER__

/*** Start of inlined file: juce_WeakReference.h ***/
#ifndef __JUCE_WEAKREFERENCE_JUCEHEADER__
#define __JUCE_WEAKREFERENCE_JUCEHEADER__

/**
	This class acts as a pointer which will automatically become null if the object
	to which it points is deleted.

	To accomplish this, the source object needs to cooperate by performing a couple of simple tasks.
	It must embed a WeakReference::Master object, which stores a shared pointer object, and must clear
	this master pointer in its destructor.

	E.g.
	@code
	class MyObject
	{
	public:
		MyObject()
		{
			// If you're planning on using your WeakReferences in a multi-threaded situation, you may choose
			// to create a WeakReference to the object here in the constructor, which will pre-initialise the
			// embedded object, avoiding an (extremely unlikely) race condition that could occur if multiple
			// threads overlap while creating the first WeakReference to it.
		}

		~MyObject()
		{
			// This will zero all the references - you need to call this in your destructor.
			masterReference.clear();
		}

	private:
		// You need to embed a variable of this type, with the name "masterReference" inside your object. If the
		// variable is not public, you should make your class a friend of WeakReference<MyObject> so that the
		// WeakReference class can access it.
		WeakReference<MyObject>::Master masterReference;
		friend class WeakReference<MyObject>;
	};

	// Here's an example of using a pointer..

	MyObject* n = new MyObject();
	WeakReference<MyObject> myObjectRef = n;

	MyObject* pointer1 = myObjectRef;  // returns a valid pointer to 'n'
	delete n;
	MyObject* pointer2 = myObjectRef;  // returns a null pointer
	@endcode

	@see WeakReference::Master
*/
template <class ObjectType, class ReferenceCountingType = ReferenceCountedObject>
class WeakReference
{
public:
	/** Creates a null SafePointer. */
	inline WeakReference() noexcept {}

	/** Creates a WeakReference that points at the given object. */
	WeakReference (ObjectType* const object)  : holder (getRef (object)) {}

	/** Creates a copy of another WeakReference. */
	WeakReference (const WeakReference& other) noexcept         : holder (other.holder) {}

	/** Copies another pointer to this one. */
	WeakReference& operator= (const WeakReference& other)       { holder = other.holder; return *this; }

	/** Copies another pointer to this one. */
	WeakReference& operator= (ObjectType* const newObject)      { holder = getRef (newObject); return *this; }

   #if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
	WeakReference (WeakReference&& other) noexcept              : holder (static_cast <SharedRef&&> (other.holder)) {}
	WeakReference& operator= (WeakReference&& other) noexcept   { holder = static_cast <SharedRef&&> (other.holder); return *this; }
   #endif

	/** Returns the object that this pointer refers to, or null if the object no longer exists. */
	ObjectType* get() const noexcept                            { return holder != nullptr ? holder->get() : nullptr; }

	/** Returns the object that this pointer refers to, or null if the object no longer exists. */
	operator ObjectType*() const noexcept                       { return get(); }

	/** Returns the object that this pointer refers to, or null if the object no longer exists. */
	ObjectType* operator->() noexcept                           { return get(); }

	/** Returns the object that this pointer refers to, or null if the object no longer exists. */
	const ObjectType* operator->() const noexcept               { return get(); }

	/** This returns true if this reference has been pointing at an object, but that object has
		since been deleted.

		If this reference was only ever pointing at a null pointer, this will return false. Using
		operator=() to make this refer to a different object will reset this flag to match the status
		of the reference from which you're copying.
	*/
	bool wasObjectDeleted() const noexcept                      { return holder != nullptr && holder->get() == nullptr; }

	bool operator== (ObjectType* const object) const noexcept   { return get() == object; }
	bool operator!= (ObjectType* const object) const noexcept   { return get() != object; }

	/** This class is used internally by the WeakReference class - don't use it directly
		in your code!
		@see WeakReference
	*/
	class SharedPointer   : public ReferenceCountingType
	{
	public:
		explicit SharedPointer (ObjectType* const owner_) noexcept : owner (owner_) {}

		inline ObjectType* get() const noexcept     { return owner; }
		void clearPointer() noexcept                { owner = nullptr; }

	private:
		ObjectType* volatile owner;

		JUCE_DECLARE_NON_COPYABLE (SharedPointer);
	};

	typedef ReferenceCountedObjectPtr<SharedPointer> SharedRef;

	/**
		This class is embedded inside an object to which you want to attach WeakReference pointers.
		See the WeakReference class notes for an example of how to use this class.
		@see WeakReference
	*/
	class Master
	{
	public:
		Master() noexcept {}

		~Master()
		{
			// You must remember to call clear() in your source object's destructor! See the notes
			// for the WeakReference class for an example of how to do this.
			jassert (sharedPointer == nullptr || sharedPointer->get() == nullptr);
		}

		/** The first call to this method will create an internal object that is shared by all weak
			references to the object.
		*/
		SharedPointer* getSharedPointer (ObjectType* const object)
		{
			if (sharedPointer == nullptr)
			{
				sharedPointer = new SharedPointer (object);
			}
			else
			{
				// You're trying to create a weak reference to an object that has already been deleted!!
				jassert (sharedPointer->get() != nullptr);
			}

			return sharedPointer;
		}

		/** The object that owns this master pointer should call this before it gets destroyed,
			to zero all the references to this object that may be out there. See the WeakReference
			class notes for an example of how to do this.
		*/
		void clear()
		{
			if (sharedPointer != nullptr)
				sharedPointer->clearPointer();
		}

	private:
		SharedRef sharedPointer;

		JUCE_DECLARE_NON_COPYABLE (Master);
	};

private:
	SharedRef holder;

	static inline SharedPointer* getRef (ObjectType* const o)
	{
		return (o != nullptr) ? o->masterReference.getSharedPointer (o) : nullptr;
	}
};

#endif   // __JUCE_WEAKREFERENCE_JUCEHEADER__

/*** End of inlined file: juce_WeakReference.h ***/


#endif
#ifndef __JUCE_RESULT_JUCEHEADER__

#endif
#ifndef __JUCE_UUID_JUCEHEADER__

/*** Start of inlined file: juce_Uuid.h ***/
#ifndef __JUCE_UUID_JUCEHEADER__
#define __JUCE_UUID_JUCEHEADER__

/**
	A universally unique 128-bit identifier.

	This class generates very random unique numbers based on the system time
	and MAC addresses if any are available. It's extremely unlikely that two identical
	UUIDs would ever be created by chance.

	The class includes methods for saving the ID as a string or as raw binary data.
*/
class JUCE_API  Uuid
{
public:

	/** Creates a new unique ID. */
	Uuid();

	/** Destructor. */
	~Uuid() noexcept;

	/** Creates a copy of another UUID. */
	Uuid (const Uuid& other);

	/** Copies another UUID. */
	Uuid& operator= (const Uuid& other);

	/** Returns true if the ID is zero. */
	bool isNull() const noexcept;

	/** Compares two UUIDs. */
	bool operator== (const Uuid& other) const;

	/** Compares two UUIDs. */
	bool operator!= (const Uuid& other) const;

	/** Returns a stringified version of this UUID.

		A Uuid object can later be reconstructed from this string using operator= or
		the constructor that takes a string parameter.

		@returns a 32 character hex string.
	*/
	String toString() const;

	/** Creates an ID from an encoded string version.

		@see toString
	*/
	Uuid (const String& uuidString);

	/** Copies from a stringified UUID.

		The string passed in should be one that was created with the toString() method.
	*/
	Uuid& operator= (const String& uuidString);

	/** Returns a pointer to the internal binary representation of the ID.

		This is an array of 16 bytes. To reconstruct a Uuid from its data, use
		the constructor or operator= method that takes an array of uint8s.
	*/
	const uint8* getRawData() const noexcept                { return value.asBytes; }

	/** Creates a UUID from a 16-byte array.

		@see getRawData
	*/
	Uuid (const uint8* rawData);

	/** Sets this UUID from 16-bytes of raw data. */
	Uuid& operator= (const uint8* rawData);

private:

   #ifndef DOXYGEN
	union
	{
		uint8 asBytes [16];
		int asInt[4];
		int64 asInt64[2];

	} value;
   #endif

	JUCE_LEAK_DETECTOR (Uuid);
};

#endif   // __JUCE_UUID_JUCEHEADER__

/*** End of inlined file: juce_Uuid.h ***/


#endif
#ifndef __JUCE_WINDOWSREGISTRY_JUCEHEADER__

/*** Start of inlined file: juce_WindowsRegistry.h ***/
#ifndef __JUCE_WINDOWSREGISTRY_JUCEHEADER__
#define __JUCE_WINDOWSREGISTRY_JUCEHEADER__

#if JUCE_WINDOWS || DOXYGEN

/**
	Contains some static helper functions for manipulating the MS Windows registry
	(Only available on Windows, of course!)
*/
class WindowsRegistry
{
public:

	/** Returns a string from the registry.

		The path is a string for the entire path of a value in the registry,
		e.g. "HKEY_CURRENT_USER\Software\foo\bar"
	*/
	static String getValue (const String& regValuePath,
							const String& defaultValue = String::empty);

	/** Sets a registry value as a string.

		This will take care of creating any groups needed to get to the given
		registry value.
	*/
	static void setValue (const String& regValuePath,
						  const String& value);

	/** Returns true if the given value exists in the registry. */
	static bool valueExists (const String& regValuePath);

	/** Deletes a registry value. */
	static void deleteValue (const String& regValuePath);

	/** Deletes a registry key (which is registry-talk for 'folder'). */
	static void deleteKey (const String& regKeyPath);

	/** Creates a file association in the registry.

		This lets you set the executable that should be launched by a given file extension.
		@param fileExtension        the file extension to associate, including the
									initial dot, e.g. ".txt"
		@param symbolicDescription  a space-free short token to identify the file type
		@param fullDescription      a human-readable description of the file type
		@param targetExecutable     the executable that should be launched
		@param iconResourceNumber   the icon that gets displayed for the file type will be
									found by looking up this resource number in the
									executable. Pass 0 here to not use an icon
	*/
	static void registerFileAssociation (const String& fileExtension,
										 const String& symbolicDescription,
										 const String& fullDescription,
										 const File& targetExecutable,
										 int iconResourceNumber);

private:
	WindowsRegistry();
	JUCE_DECLARE_NON_COPYABLE (WindowsRegistry);
};

#endif
#endif   // __JUCE_WINDOWSREGISTRY_JUCEHEADER__

/*** End of inlined file: juce_WindowsRegistry.h ***/


#endif
#ifndef __JUCE_MACADDRESS_JUCEHEADER__

/*** Start of inlined file: juce_MACAddress.h ***/
#ifndef __JUCE_MACADDRESS_JUCEHEADER__
#define __JUCE_MACADDRESS_JUCEHEADER__

/**
	A wrapper for a streaming (TCP) socket.

	This allows low-level use of sockets; for an easier-to-use messaging layer on top of
	sockets, you could also try the InterprocessConnection class.

	@see DatagramSocket, InterprocessConnection, InterprocessConnectionServer
*/
class JUCE_API  MACAddress
{
public:

	/** Populates a list of the MAC addresses of all the available network cards. */
	static void findAllAddresses (Array<MACAddress>& results);

	/** Creates a null address (00-00-00-00-00-00). */
	MACAddress();

	/** Creates a copy of another address. */
	MACAddress (const MACAddress& other);

	/** Creates a copy of another address. */
	MACAddress& operator= (const MACAddress& other);

	/** Creates an address from 6 bytes. */
	explicit MACAddress (const uint8 bytes[6]);

	/** Returns a pointer to the 6 bytes that make up this address. */
	const uint8* getBytes() const noexcept        { return asBytes; }

	/** Returns a dash-separated string in the form "11-22-33-44-55-66" */
	String toString() const;

	/** Returns the address in the lower 6 bytes of an int64.

		This uses a little-endian arrangement, with the first byte of the address being
		stored in the least-significant byte of the result value.
	*/
	int64 toInt64() const noexcept;

	/** Returns true if this address is null (00-00-00-00-00-00). */
	bool isNull() const noexcept;

	bool operator== (const MACAddress& other) const noexcept;
	bool operator!= (const MACAddress& other) const noexcept;

private:
   #ifndef DOXYGEN
	union
	{
		uint64 asInt64;
		uint8 asBytes[6];
	};
   #endif
};

#endif   // __JUCE_MACADDRESS_JUCEHEADER__

/*** End of inlined file: juce_MACAddress.h ***/


#endif
#ifndef __JUCE_NAMEDPIPE_JUCEHEADER__

/*** Start of inlined file: juce_NamedPipe.h ***/
#ifndef __JUCE_NAMEDPIPE_JUCEHEADER__
#define __JUCE_NAMEDPIPE_JUCEHEADER__

/**
	A cross-process pipe that can have data written to and read from it.

	Two or more processes can use these for inter-process communication.

	@see InterprocessConnection
*/
class JUCE_API  NamedPipe
{
public:

	/** Creates a NamedPipe. */
	NamedPipe();

	/** Destructor. */
	~NamedPipe();

	/** Tries to open a pipe that already exists.

		Returns true if it succeeds.
	*/
	bool openExisting (const String& pipeName);

	/** Tries to create a new pipe.

		Returns true if it succeeds.
	*/
	bool createNewPipe (const String& pipeName);

	/** Closes the pipe, if it's open. */
	void close();

	/** True if the pipe is currently open. */
	bool isOpen() const;

	/** Returns the last name that was used to try to open this pipe. */
	String getName() const;

	/** Reads data from the pipe.

		This will block until another thread has written enough data into the pipe to fill
		the number of bytes specified, or until another thread calls the cancelPendingReads()
		method.

		If the operation fails, it returns -1, otherwise, it will return the number of
		bytes read.

		If timeOutMilliseconds is less than zero, it will wait indefinitely, otherwise
		this is a maximum timeout for reading from the pipe.
	*/
	int read (void* destBuffer, int maxBytesToRead, int timeOutMilliseconds = 5000);

	/** Writes some data to the pipe.

		If the operation fails, it returns -1, otherwise, it will return the number of
		bytes written.
	*/
	int write (const void* sourceBuffer, int numBytesToWrite,
			   int timeOutMilliseconds = 2000);

	/** If any threads are currently blocked on a read operation, this tells them to abort.
	*/
	void cancelPendingReads();

private:

	class Pimpl;
	ScopedPointer<Pimpl> pimpl;
	String currentPipeName;
	CriticalSection lock;

	bool openInternal (const String& pipeName, const bool createPipe);

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (NamedPipe);
};

#endif   // __JUCE_NAMEDPIPE_JUCEHEADER__

/*** End of inlined file: juce_NamedPipe.h ***/


#endif
#ifndef __JUCE_SOCKET_JUCEHEADER__

/*** Start of inlined file: juce_Socket.h ***/
#ifndef __JUCE_SOCKET_JUCEHEADER__
#define __JUCE_SOCKET_JUCEHEADER__

/**
	A wrapper for a streaming (TCP) socket.

	This allows low-level use of sockets; for an easier-to-use messaging layer on top of
	sockets, you could also try the InterprocessConnection class.

	@see DatagramSocket, InterprocessConnection, InterprocessConnectionServer
*/
class JUCE_API  StreamingSocket
{
public:

	/** Creates an uninitialised socket.

		To connect it, use the connect() method, after which you can read() or write()
		to it.

		To wait for other sockets to connect to this one, the createListener() method
		enters "listener" mode, and can be used to spawn new sockets for each connection
		that comes along.
	*/
	StreamingSocket();

	/** Destructor. */
	~StreamingSocket();

	/** Binds the socket to the specified local port.

		@returns    true on success; false may indicate that another socket is already bound
					on the same port
	*/
	bool bindToPort (int localPortNumber);

	/** Tries to connect the socket to hostname:port.

		If timeOutMillisecs is 0, then this method will block until the operating system
		rejects the connection (which could take a long time).

		@returns true if it succeeds.
		@see isConnected
	*/
	bool connect (const String& remoteHostname,
				  int remotePortNumber,
				  int timeOutMillisecs = 3000);

	/** True if the socket is currently connected. */
	bool isConnected() const noexcept                           { return connected; }

	/** Closes the connection. */
	void close();

	/** Returns the name of the currently connected host. */
	const String& getHostName() const noexcept                  { return hostName; }

	/** Returns the port number that's currently open. */
	int getPort() const noexcept                                { return portNumber; }

	/** True if the socket is connected to this machine rather than over the network. */
	bool isLocal() const noexcept;

	/** Waits until the socket is ready for reading or writing.

		If readyForReading is true, it will wait until the socket is ready for
		reading; if false, it will wait until it's ready for writing.

		If the timeout is < 0, it will wait forever, or else will give up after
		the specified time.

		If the socket is ready on return, this returns 1. If it times-out before
		the socket becomes ready, it returns 0. If an error occurs, it returns -1.
	*/
	int waitUntilReady (bool readyForReading,
						int timeoutMsecs) const;

	/** Reads bytes from the socket.

		If blockUntilSpecifiedAmountHasArrived is true, the method will block until
		maxBytesToRead bytes have been read, (or until an error occurs). If this
		flag is false, the method will return as much data as is currently available
		without blocking.

		@returns the number of bytes read, or -1 if there was an error.
		@see waitUntilReady
	*/
	int read (void* destBuffer, int maxBytesToRead,
			  bool blockUntilSpecifiedAmountHasArrived);

	/** Writes bytes to the socket from a buffer.

		Note that this method will block unless you have checked the socket is ready
		for writing before calling it (see the waitUntilReady() method).

		@returns the number of bytes written, or -1 if there was an error.
	*/
	int write (const void* sourceBuffer, int numBytesToWrite);

	/** Puts this socket into "listener" mode.

		When in this mode, your thread can call waitForNextConnection() repeatedly,
		which will spawn new sockets for each new connection, so that these can
		be handled in parallel by other threads.

		@param portNumber       the port number to listen on
		@param localHostName    the interface address to listen on - pass an empty
								string to listen on all addresses
		@returns    true if it manages to open the socket successfully.

		@see waitForNextConnection
	*/
	bool createListener (int portNumber, const String& localHostName = String::empty);

	/** When in "listener" mode, this waits for a connection and spawns it as a new
		socket.

		The object that gets returned will be owned by the caller.

		This method can only be called after using createListener().

		@see createListener
	*/
	StreamingSocket* waitForNextConnection() const;

private:

	String hostName;
	int volatile portNumber, handle;
	bool connected, isListener;

	StreamingSocket (const String& hostname, int portNumber, int handle);

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (StreamingSocket);
};

/**
	A wrapper for a datagram (UDP) socket.

	This allows low-level use of sockets; for an easier-to-use messaging layer on top of
	sockets, you could also try the InterprocessConnection class.

	@see StreamingSocket, InterprocessConnection, InterprocessConnectionServer
*/
class JUCE_API  DatagramSocket
{
public:

	/**
		Creates an (uninitialised) datagram socket.

		The localPortNumber is the port on which to bind this socket. If this value is 0,
		the port number is assigned by the operating system.

		To use the socket for sending, call the connect() method. This will not immediately
		make a connection, but will save the destination you've provided. After this, you can
		call read() or write().

		If enableBroadcasting is true, the socket will be allowed to send broadcast messages
		(may require extra privileges on linux)

		To wait for other sockets to connect to this one, call waitForNextConnection().
	*/
	DatagramSocket (int localPortNumber,
					bool enableBroadcasting = false);

	/** Destructor. */
	~DatagramSocket();

	/** Binds the socket to the specified local port.

		@returns    true on success; false may indicate that another socket is already bound
					on the same port
	*/
	bool bindToPort (int localPortNumber);

	/** Tries to connect the socket to hostname:port.

		If timeOutMillisecs is 0, then this method will block until the operating system
		rejects the connection (which could take a long time).

		@returns true if it succeeds.
		@see isConnected
	*/
	bool connect (const String& remoteHostname,
				  int remotePortNumber,
				  int timeOutMillisecs = 3000);

	/** True if the socket is currently connected. */
	bool isConnected() const noexcept                           { return connected; }

	/** Closes the connection. */
	void close();

	/** Returns the name of the currently connected host. */
	const String& getHostName() const noexcept                  { return hostName; }

	/** Returns the port number that's currently open. */
	int getPort() const noexcept                                { return portNumber; }

	/** True if the socket is connected to this machine rather than over the network. */
	bool isLocal() const noexcept;

	/** Waits until the socket is ready for reading or writing.

		If readyForReading is true, it will wait until the socket is ready for
		reading; if false, it will wait until it's ready for writing.

		If the timeout is < 0, it will wait forever, or else will give up after
		the specified time.

		If the socket is ready on return, this returns 1. If it times-out before
		the socket becomes ready, it returns 0. If an error occurs, it returns -1.
	*/
	int waitUntilReady (bool readyForReading,
						int timeoutMsecs) const;

	/** Reads bytes from the socket.

		If blockUntilSpecifiedAmountHasArrived is true, the method will block until
		maxBytesToRead bytes have been read, (or until an error occurs). If this
		flag is false, the method will return as much data as is currently available
		without blocking.

		@returns the number of bytes read, or -1 if there was an error.
		@see waitUntilReady
	*/
	int read (void* destBuffer, int maxBytesToRead,
			  bool blockUntilSpecifiedAmountHasArrived);

	/** Writes bytes to the socket from a buffer.

		Note that this method will block unless you have checked the socket is ready
		for writing before calling it (see the waitUntilReady() method).

		@returns the number of bytes written, or -1 if there was an error.
	*/
	int write (const void* sourceBuffer, int numBytesToWrite);

	/** This waits for incoming data to be sent, and returns a socket that can be used
		to read it.

		The object that gets returned is owned by the caller, and can't be used for
		sending, but can be used to read the data.
	*/
	DatagramSocket* waitForNextConnection() const;

private:

	String hostName;
	int volatile portNumber, handle;
	bool connected, allowBroadcast;
	void* serverAddress;

	DatagramSocket (const String& hostname, int portNumber, int handle, int localPortNumber);

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (DatagramSocket);
};

#endif   // __JUCE_SOCKET_JUCEHEADER__

/*** End of inlined file: juce_Socket.h ***/


#endif
#ifndef __JUCE_URL_JUCEHEADER__

/*** Start of inlined file: juce_URL.h ***/
#ifndef __JUCE_URL_JUCEHEADER__
#define __JUCE_URL_JUCEHEADER__

class InputStream;
class XmlElement;

/**
	Represents a URL and has a bunch of useful functions to manipulate it.

	This class can be used to launch URLs in browsers, and also to create
	InputStreams that can read from remote http or ftp sources.
*/
class JUCE_API  URL
{
public:

	/** Creates an empty URL. */
	URL();

	/** Creates a URL from a string. */
	URL (const String& url);

	/** Creates a copy of another URL. */
	URL (const URL& other);

	/** Destructor. */
	~URL();

	/** Copies this URL from another one. */
	URL& operator= (const URL& other);

	/** Compares two URLs.
		All aspects of the URLs must be identical for them to match, including any parameters,
		upload files, etc.
	*/
	bool operator== (const URL&) const;
	bool operator!= (const URL&) const;

	/** Returns a string version of the URL.

		If includeGetParameters is true and any parameters have been set with the
		withParameter() method, then the string will have these appended on the
		end and url-encoded.
	*/
	String toString (bool includeGetParameters) const;

	/** True if it seems to be valid. */
	bool isWellFormed() const;

	/** Returns just the domain part of the URL.

		E.g. for "http://www.xyz.com/foobar", this will return "www.xyz.com".
	*/
	String getDomain() const;

	/** Returns the path part of the URL.

		E.g. for "http://www.xyz.com/foo/bar?x=1", this will return "foo/bar".
	*/
	String getSubPath() const;

	/** Returns the scheme of the URL.

		E.g. for "http://www.xyz.com/foobar", this will return "http". (It won't
		include the colon).
	*/
	String getScheme() const;

	/** Attempts to read a port number from the URL.
		@returns the port number, or 0 if none is explicitly specified.
	*/
	int getPort() const;

	/** Returns a new version of this URL that uses a different sub-path.

		E.g. if the URL is "http://www.xyz.com/foo?x=1" and you call this with
		"bar", it'll return "http://www.xyz.com/bar?x=1".
	*/
	URL withNewSubPath (const String& newPath) const;

	/** Returns a new URL that refers to a sub-path relative to this one.

		E.g. if the URL is "http://www.xyz.com/foo" and you call this with
		"bar", it'll return "http://www.xyz.com/foo/bar". Note that there's no way for
		this method to know whether the original URL is a file or directory, so it's
		up to you to make sure it's a directory. It also won't attempt to be smart about
		the content of the childPath string, so if this string is an absolute URL, it'll
		still just get bolted onto the end of the path.

		@see File::getChildFile
	*/
	URL getChildURL (const String& subPath) const;

	/** Returns a copy of this URL, with a GET or POST parameter added to the end.

		Any control characters in the value will be encoded.

		e.g. calling "withParameter ("amount", "some fish") for the url "www.fish.com"
		would produce a new url whose toString(true) method would return
		"www.fish.com?amount=some+fish".

		@see getParameterNames, getParameterValues
	*/
	URL withParameter (const String& parameterName,
					   const String& parameterValue) const;

	/** Returns a copy of this URl, with a file-upload type parameter added to it.

		When performing a POST where one of your parameters is a binary file, this
		lets you specify the file.

		Note that the filename is stored, but the file itself won't actually be read
		until this URL is later used to create a network input stream.
	*/
	URL withFileToUpload (const String& parameterName,
						  const File& fileToUpload,
						  const String& mimeType) const;

	/** Returns an array of the names of all the URL's parameters.

		E.g. for the url "www.fish.com?type=haddock&amount=some+fish", this array would
		contain two items: "type" and "haddock".

		You can call getParameterValues() to get the corresponding value of each
		parameter. Note that the list can contain multiple parameters with the same name.

		@see getParameterValues, withParameter
	*/
	const StringArray& getParameterNames() const noexcept       { return parameterNames; }

	/** Returns an array of the values of all the URL's parameters.

		E.g. for the url "www.fish.com?type=haddock&amount=some+fish", this array would
		contain two items: "haddock" and "some fish".

		The values returned will have been cleaned up to remove any escape characters.

		You can call getParameterNames() to get the corresponding name of each
		parameter. Note that the list can contain multiple parameters with the same name.

		@see getParameterNames, withParameter
	*/
	const StringArray& getParameterValues() const noexcept      { return parameterValues; }

	/** Returns the set of files that should be uploaded as part of a POST operation.

		This is the set of files that were added to the URL with the withFileToUpload()
		method.
	*/
	const StringPairArray& getFilesToUpload() const;

	/** Returns the set of mime types associated with each of the upload files.
	*/
	const StringPairArray& getMimeTypesOfUploadFiles() const;

	/** Returns a copy of this URL, with a block of data to send as the POST data.

		If you're setting the POST data, be careful not to have any parameters set
		as well, otherwise it'll all get thrown in together, and might not have the
		desired effect.

		If the URL already contains some POST data, this will replace it, rather
		than being appended to it.

		This data will only be used if you specify a post operation when you call
		createInputStream().
	*/
	URL withPOSTData (const String& postData) const;

	/** Returns the data that was set using withPOSTData(). */
	const String& getPostData() const noexcept                  { return postData; }

	/** Tries to launch the system's default browser to open the URL.

		Returns true if this seems to have worked.
	*/
	bool launchInDefaultBrowser() const;

	/** Takes a guess as to whether a string might be a valid website address.

		This isn't foolproof!
	*/
	static bool isProbablyAWebsiteURL (const String& possibleURL);

	/** Takes a guess as to whether a string might be a valid email address.

		This isn't foolproof!
	*/
	static bool isProbablyAnEmailAddress (const String& possibleEmailAddress);

	/** This callback function can be used by the createInputStream() method.

		It allows your app to receive progress updates during a lengthy POST operation. If you
		want to continue the operation, this should return true, or false to abort.
	*/
	typedef bool (OpenStreamProgressCallback) (void* context, int bytesSent, int totalBytes);

	/** Attempts to open a stream that can read from this URL.

		@param usePostCommand   if true, it will try to do use a http 'POST' to pass
								the paramters, otherwise it'll encode them into the
								URL and do a 'GET'.
		@param progressCallback if this is non-zero, it lets you supply a callback function
								to keep track of the operation's progress. This can be useful
								for lengthy POST operations, so that you can provide user feedback.
		@param progressCallbackContext  if a callback is specified, this value will be passed to
								the function
		@param extraHeaders     if not empty, this string is appended onto the headers that
								are used for the request. It must therefore be a valid set of HTML
								header directives, separated by newlines.
		@param connectionTimeOutMs  if 0, this will use whatever default setting the OS chooses. If
								a negative number, it will be infinite. Otherwise it specifies a
								time in milliseconds.
		@param responseHeaders  if this is non-zero, all the (key, value) pairs received as headers
								in the response will be stored in this array
		@returns    an input stream that the caller must delete, or a null pointer if there was an
					error trying to open it.
	 */
	InputStream* createInputStream (bool usePostCommand,
									OpenStreamProgressCallback* progressCallback = nullptr,
									void* progressCallbackContext = nullptr,
									const String& extraHeaders = String::empty,
									int connectionTimeOutMs = 0,
									StringPairArray* responseHeaders = nullptr) const;

	/** Tries to download the entire contents of this URL into a binary data block.

		If it succeeds, this will return true and append the data it read onto the end
		of the memory block.

		@param destData         the memory block to append the new data to
		@param usePostCommand   whether to use a POST command to get the data (uses
								a GET command if this is false)
		@see readEntireTextStream, readEntireXmlStream
	*/
	bool readEntireBinaryStream (MemoryBlock& destData,
								 bool usePostCommand = false) const;

	/** Tries to download the entire contents of this URL as a string.

		If it fails, this will return an empty string, otherwise it will return the
		contents of the downloaded file. If you need to distinguish between a read
		operation that fails and one that returns an empty string, you'll need to use
		a different method, such as readEntireBinaryStream().

		@param usePostCommand   whether to use a POST command to get the data (uses
								a GET command if this is false)
		@see readEntireBinaryStream, readEntireXmlStream
	*/
	String readEntireTextStream (bool usePostCommand = false) const;

	/** Tries to download the entire contents of this URL and parse it as XML.

		If it fails, or if the text that it reads can't be parsed as XML, this will
		return 0.

		When it returns a valid XmlElement object, the caller is responsibile for deleting
		this object when no longer needed.

		@param usePostCommand   whether to use a POST command to get the data (uses
								a GET command if this is false)

		@see readEntireBinaryStream, readEntireTextStream
	*/
	XmlElement* readEntireXmlStream (bool usePostCommand = false) const;

	/** Adds escape sequences to a string to encode any characters that aren't
		legal in a URL.

		E.g. any spaces will be replaced with "%20".

		This is the opposite of removeEscapeChars().

		If isParameter is true, it means that the string is going to be used
		as a parameter, so it also encodes '$' and ',' (which would otherwise
		be legal in a URL.

		@see removeEscapeChars
	*/
	static String addEscapeChars (const String& stringToAddEscapeCharsTo,
								  bool isParameter);

	/** Replaces any escape character sequences in a string with their original
		character codes.

		E.g. any instances of "%20" will be replaced by a space.

		This is the opposite of addEscapeChars().

		@see addEscapeChars
	*/
	static String removeEscapeChars (const String& stringToRemoveEscapeCharsFrom);

private:

	String url, postData;
	StringArray parameterNames, parameterValues;
	StringPairArray filesToUpload, mimeTypes;

	void addParameter (const String&, const String&);

	static InputStream* createNativeStream (const String& address, bool isPost, const MemoryBlock& postData,
											OpenStreamProgressCallback* progressCallback,
											void* progressCallbackContext, const String& headers,
											const int timeOutMs, StringPairArray* responseHeaders);
	JUCE_LEAK_DETECTOR (URL);
};

#endif   // __JUCE_URL_JUCEHEADER__

/*** End of inlined file: juce_URL.h ***/


#endif
#ifndef __JUCE_BUFFEREDINPUTSTREAM_JUCEHEADER__

/*** Start of inlined file: juce_BufferedInputStream.h ***/
#ifndef __JUCE_BUFFEREDINPUTSTREAM_JUCEHEADER__
#define __JUCE_BUFFEREDINPUTSTREAM_JUCEHEADER__

/** Wraps another input stream, and reads from it using an intermediate buffer

	If you're using an input stream such as a file input stream, and making lots of
	small read accesses to it, it's probably sensible to wrap it in one of these,
	so that the source stream gets accessed in larger chunk sizes, meaning less
	work for the underlying stream.
*/
class JUCE_API  BufferedInputStream  : public InputStream
{
public:

	/** Creates a BufferedInputStream from an input source.

		@param sourceStream                 the source stream to read from
		@param bufferSize                   the size of reservoir to use to buffer the source
		@param deleteSourceWhenDestroyed    whether the sourceStream that is passed in should be
											deleted by this object when it is itself deleted.
	*/
	BufferedInputStream (InputStream* sourceStream,
						 int bufferSize,
						 bool deleteSourceWhenDestroyed);

	/** Creates a BufferedInputStream from an input source.

		@param sourceStream     the source stream to read from - the source stream  must not
								be deleted until this object has been destroyed.
		@param bufferSize       the size of reservoir to use to buffer the source
	*/
	BufferedInputStream (InputStream& sourceStream, int bufferSize);

	/** Destructor.

		This may also delete the source stream, if that option was chosen when the
		buffered stream was created.
	*/
	~BufferedInputStream();

	int64 getTotalLength();
	int64 getPosition();
	bool setPosition (int64 newPosition);
	int read (void* destBuffer, int maxBytesToRead);
	String readString();
	bool isExhausted();

private:

	OptionalScopedPointer<InputStream> source;
	int bufferSize;
	int64 position, lastReadPos, bufferStart, bufferOverlap;
	HeapBlock <char> buffer;
	void ensureBuffered();

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (BufferedInputStream);
};

#endif   // __JUCE_BUFFEREDINPUTSTREAM_JUCEHEADER__

/*** End of inlined file: juce_BufferedInputStream.h ***/


#endif
#ifndef __JUCE_FILEINPUTSOURCE_JUCEHEADER__

/*** Start of inlined file: juce_FileInputSource.h ***/
#ifndef __JUCE_FILEINPUTSOURCE_JUCEHEADER__
#define __JUCE_FILEINPUTSOURCE_JUCEHEADER__


/*** Start of inlined file: juce_InputSource.h ***/
#ifndef __JUCE_INPUTSOURCE_JUCEHEADER__
#define __JUCE_INPUTSOURCE_JUCEHEADER__

/**
	A lightweight object that can create a stream to read some kind of resource.

	This may be used to refer to a file, or some other kind of source, allowing a
	caller to create an input stream that can read from it when required.

	@see FileInputSource
*/
class JUCE_API  InputSource
{
public:

	InputSource() noexcept      {}

	/** Destructor. */
	virtual ~InputSource()      {}

	/** Returns a new InputStream to read this item.

		@returns            an inputstream that the caller will delete, or 0 if
							the filename isn't found.
	*/
	virtual InputStream* createInputStream() = 0;

	/** Returns a new InputStream to read an item, relative.

		@param relatedItemPath  the relative pathname of the resource that is required
		@returns            an inputstream that the caller will delete, or 0 if
							the item isn't found.
	*/
	virtual InputStream* createInputStreamFor (const String& relatedItemPath) = 0;

	/** Returns a hash code that uniquely represents this item.
	*/
	virtual int64 hashCode() const = 0;

private:

	JUCE_LEAK_DETECTOR (InputSource);
};

#endif   // __JUCE_INPUTSOURCE_JUCEHEADER__

/*** End of inlined file: juce_InputSource.h ***/

/**
	A type of InputSource that represents a normal file.

	@see InputSource
*/
class JUCE_API  FileInputSource     : public InputSource
{
public:

	FileInputSource (const File& file, bool useFileTimeInHashGeneration = false);
	~FileInputSource();

	InputStream* createInputStream();
	InputStream* createInputStreamFor (const String& relatedItemPath);
	int64 hashCode() const;

private:

	const File file;
	bool useFileTimeInHashGeneration;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (FileInputSource);
};

#endif   // __JUCE_FILEINPUTSOURCE_JUCEHEADER__

/*** End of inlined file: juce_FileInputSource.h ***/


#endif
#ifndef __JUCE_INPUTSOURCE_JUCEHEADER__

#endif
#ifndef __JUCE_INPUTSTREAM_JUCEHEADER__

#endif
#ifndef __JUCE_MEMORYINPUTSTREAM_JUCEHEADER__

/*** Start of inlined file: juce_MemoryInputStream.h ***/
#ifndef __JUCE_MEMORYINPUTSTREAM_JUCEHEADER__
#define __JUCE_MEMORYINPUTSTREAM_JUCEHEADER__

/**
	Allows a block of data and to be accessed as a stream.

	This can either be used to refer to a shared block of memory, or can make its
	own internal copy of the data when the MemoryInputStream is created.
*/
class JUCE_API  MemoryInputStream  : public InputStream
{
public:

	/** Creates a MemoryInputStream.

		@param sourceData               the block of data to use as the stream's source
		@param sourceDataSize           the number of bytes in the source data block
		@param keepInternalCopyOfData   if false, the stream will just keep a pointer to
										the source data, so this data shouldn't be changed
										for the lifetime of the stream; if this parameter is
										true, the stream will make its own copy of the
										data and use that.
	*/
	MemoryInputStream (const void* sourceData,
					   size_t sourceDataSize,
					   bool keepInternalCopyOfData);

	/** Creates a MemoryInputStream.

		@param data                     a block of data to use as the stream's source
		@param keepInternalCopyOfData   if false, the stream will just keep a reference to
										the source data, so this data shouldn't be changed
										for the lifetime of the stream; if this parameter is
										true, the stream will make its own copy of the
										data and use that.
	*/
	MemoryInputStream (const MemoryBlock& data,
					   bool keepInternalCopyOfData);

	/** Destructor. */
	~MemoryInputStream();

	int64 getPosition();
	bool setPosition (int64 pos);
	int64 getTotalLength();
	bool isExhausted();
	int read (void* destBuffer, int maxBytesToRead);

private:

	const char* data;
	size_t dataSize, position;
	HeapBlock<char> internalCopy;

	void createInternalCopy();

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (MemoryInputStream);
};

#endif   // __JUCE_MEMORYINPUTSTREAM_JUCEHEADER__

/*** End of inlined file: juce_MemoryInputStream.h ***/


#endif
#ifndef __JUCE_MEMORYOUTPUTSTREAM_JUCEHEADER__

/*** Start of inlined file: juce_MemoryOutputStream.h ***/
#ifndef __JUCE_MEMORYOUTPUTSTREAM_JUCEHEADER__
#define __JUCE_MEMORYOUTPUTSTREAM_JUCEHEADER__

/**
	Writes data to an internal memory buffer, which grows as required.

	The data that was written into the stream can then be accessed later as
	a contiguous block of memory.
*/
class JUCE_API  MemoryOutputStream  : public OutputStream
{
public:

	/** Creates an empty memory stream ready for writing into.

		@param initialSize  the intial amount of capacity to allocate for writing into
	*/
	MemoryOutputStream (size_t initialSize = 256);

	/** Creates a memory stream for writing into into a pre-existing MemoryBlock object.

		Note that the destination block will always be larger than the amount of data
		that has been written to the stream, because the MemoryOutputStream keeps some
		spare capactity at its end. To trim the block's size down to fit the actual
		data, call flush(), or delete the MemoryOutputStream.

		@param memoryBlockToWriteTo             the block into which new data will be written.
		@param appendToExistingBlockContent     if this is true, the contents of the block will be
												kept, and new data will be appended to it. If false,
												the block will be cleared before use
	*/
	MemoryOutputStream (MemoryBlock& memoryBlockToWriteTo,
						bool appendToExistingBlockContent);

	/** Destructor.
		This will free any data that was written to it.
	*/
	~MemoryOutputStream();

	/** Returns a pointer to the data that has been written to the stream.

		@see getDataSize
	*/
	const void* getData() const noexcept;

	/** Returns the number of bytes of data that have been written to the stream.

		@see getData
	*/
	size_t getDataSize() const noexcept                 { return size; }

	/** Resets the stream, clearing any data that has been written to it so far. */
	void reset() noexcept;

	/** Increases the internal storage capacity to be able to contain at least the specified
		amount of data without needing to be resized.
	*/
	void preallocate (size_t bytesToPreallocate);

	/** Returns a String created from the (UTF8) data that has been written to the stream. */
	String toUTF8() const;

	/** Attempts to detect the encoding of the data and convert it to a string.
		@see String::createStringFromData
	*/
	String toString() const;

	/** Returns a copy of the stream's data as a memory block. */
	MemoryBlock getMemoryBlock() const;

	/** If the stream is writing to a user-supplied MemoryBlock, this will trim any excess
		capacity off the block, so that its length matches the amount of actual data that
		has been written so far.
	*/
	void flush();

	bool write (const void* buffer, int howMany);
	int64 getPosition()                                 { return position; }
	bool setPosition (int64 newPosition);
	int writeFromInputStream (InputStream& source, int64 maxNumBytesToWrite);
	void writeRepeatedByte (uint8 byte, int numTimesToRepeat);

private:

	MemoryBlock& data;
	MemoryBlock internalBlock;
	size_t position, size;

	void trimExternalBlockSize();
	void prepareToWrite (int numBytes);

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (MemoryOutputStream);
};

/** Copies all the data that has been written to a MemoryOutputStream into another stream. */
OutputStream& JUCE_CALLTYPE operator<< (OutputStream& stream, const MemoryOutputStream& streamToRead);

#endif   // __JUCE_MEMORYOUTPUTSTREAM_JUCEHEADER__

/*** End of inlined file: juce_MemoryOutputStream.h ***/


#endif
#ifndef __JUCE_OUTPUTSTREAM_JUCEHEADER__

#endif
#ifndef __JUCE_SUBREGIONSTREAM_JUCEHEADER__

/*** Start of inlined file: juce_SubregionStream.h ***/
#ifndef __JUCE_SUBREGIONSTREAM_JUCEHEADER__
#define __JUCE_SUBREGIONSTREAM_JUCEHEADER__

/** Wraps another input stream, and reads from a specific part of it.

	This lets you take a subsection of a stream and present it as an entire
	stream in its own right.
*/
class JUCE_API  SubregionStream  : public InputStream
{
public:

	/** Creates a SubregionStream from an input source.

		@param sourceStream                 the source stream to read from
		@param startPositionInSourceStream  this is the position in the source stream that
											corresponds to position 0 in this stream
		@param lengthOfSourceStream         this specifies the maximum number of bytes
											from the source stream that will be passed through
											by this stream. When the position of this stream
											exceeds lengthOfSourceStream, it will cause an end-of-stream.
											If the length passed in here is greater than the length
											of the source stream (as returned by getTotalLength()),
											then the smaller value will be used.
											Passing a negative value for this parameter means it
											will keep reading until the source's end-of-stream.
		@param deleteSourceWhenDestroyed    whether the sourceStream that is passed in should be
											deleted by this object when it is itself deleted.
	*/
	SubregionStream (InputStream* sourceStream,
					 int64 startPositionInSourceStream,
					 int64 lengthOfSourceStream,
					 bool deleteSourceWhenDestroyed);

	/** Destructor.

		This may also delete the source stream, if that option was chosen when the
		buffered stream was created.
	*/
	~SubregionStream();

	int64 getTotalLength();
	int64 getPosition();
	bool setPosition (int64 newPosition);
	int read (void* destBuffer, int maxBytesToRead);
	bool isExhausted();

private:
	OptionalScopedPointer<InputStream> source;
	const int64 startPositionInSourceStream, lengthOfSourceStream;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (SubregionStream);
};

#endif   // __JUCE_SUBREGIONSTREAM_JUCEHEADER__

/*** End of inlined file: juce_SubregionStream.h ***/


#endif
#ifndef __JUCE_PLATFORMDEFS_JUCEHEADER__

#endif
#ifndef __JUCE_STANDARDHEADER_JUCEHEADER__

#endif
#ifndef __JUCE_SYSTEMSTATS_JUCEHEADER__

/*** Start of inlined file: juce_SystemStats.h ***/
#ifndef __JUCE_SYSTEMSTATS_JUCEHEADER__
#define __JUCE_SYSTEMSTATS_JUCEHEADER__

/**
	Contains methods for finding out about the current hardware and OS configuration.
*/
class JUCE_API  SystemStats
{
public:

	/** Returns the current version of JUCE,

		See also the JUCE_VERSION, JUCE_MAJOR_VERSION and JUCE_MINOR_VERSION macros.
	*/
	static String getJUCEVersion();

	/** The set of possible results of the getOperatingSystemType() method.
	*/
	enum OperatingSystemType
	{
		UnknownOS   = 0,

		MacOSX      = 0x1000,
		Linux       = 0x2000,
		Android     = 0x3000,

		Win95       = 0x4001,
		Win98       = 0x4002,
		WinNT351    = 0x4103,
		WinNT40     = 0x4104,
		Win2000     = 0x4105,
		WinXP       = 0x4106,
		WinVista    = 0x4107,
		Windows7    = 0x4108,

		Windows     = 0x4000,   /**< To test whether any version of Windows is running,
									 you can use the expression ((getOperatingSystemType() & Windows) != 0). */
		WindowsNT   = 0x0100,   /**< To test whether the platform is Windows NT or later (i.e. not Win95 or 98),
									 you can use the expression ((getOperatingSystemType() & WindowsNT) != 0). */
	};

	/** Returns the type of operating system we're running on.

		@returns one of the values from the OperatingSystemType enum.
		@see getOperatingSystemName
	*/
	static OperatingSystemType getOperatingSystemType();

	/** Returns the name of the type of operating system we're running on.

		@returns a string describing the OS type.
		@see getOperatingSystemType
	*/
	static String getOperatingSystemName();

	/** Returns true if the OS is 64-bit, or false for a 32-bit OS.
	*/
	static bool isOperatingSystem64Bit();

   #if JUCE_MAC || DOXYGEN
	/** OSX ONLY - Returns the current OS version number.
		E.g. if it's running on 10.4, this will be 4, 10.5 will return 5, etc.
	*/
	static int getOSXMinorVersionNumber();
   #endif

	/** Returns the current user's name, if available.
		@see getFullUserName()
	*/
	static String getLogonName();

	/** Returns the current user's full name, if available.
		On some OSes, this may just return the same value as getLogonName().
		@see getLogonName()
	*/
	static String getFullUserName();

	/** Returns the host-name of the computer. */
	static String getComputerName();

	// CPU and memory information..

	/** Returns the approximate CPU speed.

		@returns    the speed in megahertz, e.g. 1500, 2500, 32000 (depending on
					what year you're reading this...)
	*/
	static int getCpuSpeedInMegaherz();

	/** Returns a string to indicate the CPU vendor.

		Might not be known on some systems.
	*/
	static String getCpuVendor();

	/** Checks whether Intel MMX instructions are available. */
	static bool hasMMX() noexcept               { return getCPUFlags().hasMMX; }

	/** Checks whether Intel SSE instructions are available. */
	static bool hasSSE() noexcept               { return getCPUFlags().hasSSE; }

	/** Checks whether Intel SSE2 instructions are available. */
	static bool hasSSE2() noexcept              { return getCPUFlags().hasSSE2; }

	/** Checks whether AMD 3DNOW instructions are available. */
	static bool has3DNow() noexcept             { return getCPUFlags().has3DNow; }

	/** Returns the number of CPUs. */
	static int getNumCpus() noexcept            { return getCPUFlags().numCpus; }

	/** Finds out how much RAM is in the machine.

		@returns    the approximate number of megabytes of memory, or zero if
					something goes wrong when finding out.
	*/
	static int getMemorySizeInMegabytes();

	/** Returns the system page-size.

		This is only used by programmers with beards.
	*/
	static int getPageSize();

private:

	struct CPUFlags
	{
		CPUFlags();

		int numCpus;
		bool hasMMX : 1;
		bool hasSSE : 1;
		bool hasSSE2 : 1;
		bool has3DNow : 1;
	};

	SystemStats();
	static const CPUFlags& getCPUFlags();

	JUCE_DECLARE_NON_COPYABLE (SystemStats);
};

#endif   // __JUCE_SYSTEMSTATS_JUCEHEADER__

/*** End of inlined file: juce_SystemStats.h ***/


#endif
#ifndef __JUCE_TARGETPLATFORM_JUCEHEADER__

#endif
#ifndef __JUCE_CHARACTERFUNCTIONS_JUCEHEADER__

#endif
#ifndef __JUCE_CHARPOINTER_ASCII_JUCEHEADER__

#endif
#ifndef __JUCE_CHARPOINTER_UTF16_JUCEHEADER__

#endif
#ifndef __JUCE_CHARPOINTER_UTF32_JUCEHEADER__

#endif
#ifndef __JUCE_CHARPOINTER_UTF8_JUCEHEADER__

#endif
#ifndef __JUCE_IDENTIFIER_JUCEHEADER__

#endif
#ifndef __JUCE_LOCALISEDSTRINGS_JUCEHEADER__

/*** Start of inlined file: juce_LocalisedStrings.h ***/
#ifndef __JUCE_LOCALISEDSTRINGS_JUCEHEADER__
#define __JUCE_LOCALISEDSTRINGS_JUCEHEADER__

/**
	Used to convert strings to localised foreign-language versions.

	This is basically a look-up table of strings and their translated equivalents.
	It can be loaded from a text file, so that you can supply a set of localised
	versions of strings that you use in your app.

	To use it in your code, simply call the translate() method on each string that
	might have foreign versions, and if none is found, the method will just return
	the original string.

	The translation file should start with some lines specifying a description of
	the language it contains, and also a list of ISO country codes where it might
	be appropriate to use the file. After that, each line of the file should contain
	a pair of quoted strings with an '=' sign.

	E.g. for a french translation, the file might be:

	@code
	language: French
	countries: fr be mc ch lu

	"hello" = "bonjour"
	"goodbye" = "au revoir"
	@endcode

	If the strings need to contain a quote character, they can use '\"' instead, and
	if the first non-whitespace character on a line isn't a quote, then it's ignored,
	(you can use this to add comments).

	Note that this is a singleton class, so don't create or destroy the object directly.
	There's also a TRANS(text) macro defined to make it easy to use the this.

	E.g. @code
	printSomething (TRANS("hello"));
	@endcode

	This macro is used in the Juce classes themselves, so your application has a chance to
	intercept and translate any internal Juce text strings that might be shown. (You can easily
	get a list of all the messages by searching for the TRANS() macro in the Juce source
	code).
*/
class JUCE_API  LocalisedStrings
{
public:

	/** Creates a set of translations from the text of a translation file.

		When you create one of these, you can call setCurrentMappings() to make it
		the set of mappings that the system's using.
	*/
	LocalisedStrings (const String& fileContents);

	/** Creates a set of translations from a file.

		When you create one of these, you can call setCurrentMappings() to make it
		the set of mappings that the system's using.
	*/
	LocalisedStrings (const File& fileToLoad);

	/** Destructor. */
	~LocalisedStrings();

	/** Selects the current set of mappings to be used by the system.

		The object you pass in will be automatically deleted when no longer needed, so
		don't keep a pointer to it. You can also pass in zero to remove the current
		mappings.

		See also the TRANS() macro, which uses the current set to do its translation.

		@see translateWithCurrentMappings
	*/
	static void setCurrentMappings (LocalisedStrings* newTranslations);

	/** Returns the currently selected set of mappings.

		This is the object that was last passed to setCurrentMappings(). It may
		be 0 if none has been created.
	*/
	static LocalisedStrings* getCurrentMappings();

	/** Tries to translate a string using the currently selected set of mappings.

		If no mapping has been set, or if the mapping doesn't contain a translation
		for the string, this will just return the original string.

		See also the TRANS() macro, which uses this method to do its translation.

		@see setCurrentMappings, getCurrentMappings
	*/
	static String translateWithCurrentMappings (const String& text);

	/** Tries to translate a string using the currently selected set of mappings.

		If no mapping has been set, or if the mapping doesn't contain a translation
		for the string, this will just return the original string.

		See also the TRANS() macro, which uses this method to do its translation.

		@see setCurrentMappings, getCurrentMappings
	*/
	static String translateWithCurrentMappings (const char* text);

	/** Attempts to look up a string and return its localised version.
		If the string isn't found in the list, the original string will be returned.
	*/
	String translate (const String& text) const;

	/** Attempts to look up a string and return its localised version.
		If the string isn't found in the list, the resultIfNotFound string will be returned.
	*/
	String translate (const String& text, const String& resultIfNotFound) const;

	/** Returns the name of the language specified in the translation file.

		This is specified in the file using a line starting with "language:", e.g.
		@code
		language: german
		@endcode
	*/
	String getLanguageName() const                        { return languageName; }

	/** Returns the list of suitable country codes listed in the translation file.

		These is specified in the file using a line starting with "countries:", e.g.
		@code
		countries: fr be mc ch lu
		@endcode

		The country codes are supposed to be 2-character ISO complient codes.
	*/
	const StringArray& getCountryCodes() const            { return countryCodes; }

	/** Indicates whether to use a case-insensitive search when looking up a string.
		This defaults to true.
	*/
	void setIgnoresCase (bool shouldIgnoreCase);

private:

	String languageName;
	StringArray countryCodes;
	StringPairArray translations;

	void loadFromText (const String& fileContents);

	JUCE_LEAK_DETECTOR (LocalisedStrings);
};

#ifndef TRANS
 /** Uses the LocalisedStrings class to translate the given string literal.
	 This macro is provided for backwards-compatibility, and just calls the translate()
	 function. In new code, it's recommended that you just call translate() directly
	 instead, and avoid using macros.
	 @see translate(), LocalisedStrings
 */
 #define TRANS(stringLiteral) juce::translate (stringLiteral)
#endif

/** Uses the LocalisedStrings class to translate the given string literal.
	@see LocalisedStrings
*/
String translate (const String& stringLiteral);

/** Uses the LocalisedStrings class to translate the given string literal.
	@see LocalisedStrings
*/
String translate (const char* stringLiteral);

/** Uses the LocalisedStrings class to translate the given string literal.
	@see LocalisedStrings
*/
String translate (const String& stringLiteral, const String& resultIfNotFound);

#endif   // __JUCE_LOCALISEDSTRINGS_JUCEHEADER__

/*** End of inlined file: juce_LocalisedStrings.h ***/


#endif
#ifndef __JUCE_NEWLINE_JUCEHEADER__

#endif
#ifndef __JUCE_STRING_JUCEHEADER__

#endif
#ifndef __JUCE_STRINGARRAY_JUCEHEADER__

#endif
#ifndef __JUCE_STRINGPAIRARRAY_JUCEHEADER__

#endif
#ifndef __JUCE_STRINGPOOL_JUCEHEADER__

/*** Start of inlined file: juce_StringPool.h ***/
#ifndef __JUCE_STRINGPOOL_JUCEHEADER__
#define __JUCE_STRINGPOOL_JUCEHEADER__

/**
	A StringPool holds a set of shared strings, which reduces storage overheads and improves
	comparison speed when dealing with many duplicate strings.

	When you add a string to a pool using getPooledString, it'll return a character
	array containing the same string. This array is owned by the pool, and the same array
	is returned every time a matching string is asked for. This means that it's trivial to
	compare two pooled strings for equality, as you can simply compare their pointers. It
	also cuts down on storage if you're using many copies of the same string.
*/
class JUCE_API  StringPool
{
public:

	/** Creates an empty pool. */
	StringPool() noexcept;

	/** Destructor */
	~StringPool();

	/** Returns a pointer to a copy of the string that is passed in.

		The pool will always return the same pointer when asked for a string that matches it.
		The pool will own all the pointers that it returns, deleting them when the pool itself
		is deleted.
	*/
	String::CharPointerType getPooledString (const String& original);

	/** Returns a pointer to a copy of the string that is passed in.

		The pool will always return the same pointer when asked for a string that matches it.
		The pool will own all the pointers that it returns, deleting them when the pool itself
		is deleted.
	*/
	String::CharPointerType getPooledString (const char* original);

	/** Returns a pointer to a copy of the string that is passed in.

		The pool will always return the same pointer when asked for a string that matches it.
		The pool will own all the pointers that it returns, deleting them when the pool itself
		is deleted.
	*/
	String::CharPointerType getPooledString (const wchar_t* original);

	/** Returns the number of strings in the pool. */
	int size() const noexcept;

	/** Returns one of the strings in the pool, by index. */
	String::CharPointerType operator[] (int index) const noexcept;

private:
	Array <String> strings;
	CriticalSection lock;
};

#endif   // __JUCE_STRINGPOOL_JUCEHEADER__

/*** End of inlined file: juce_StringPool.h ***/


#endif
#ifndef __JUCE_CHILDPROCESS_JUCEHEADER__

/*** Start of inlined file: juce_ChildProcess.h ***/
#ifndef __JUCE_CHILDPROCESS_JUCEHEADER__
#define __JUCE_CHILDPROCESS_JUCEHEADER__

/**
	Launches and monitors a child process.

	This class lets you launch an executable, and read its output. You can also
	use it to check whether the child process has finished.
*/
class JUCE_API  ChildProcess
{
public:

	/** Creates a process object.
		To actually launch the process, use start().
	*/
	ChildProcess();

	/** Destructor.
		Note that deleting this object won't terminate the child process.
	*/
	~ChildProcess();

	/** Attempts to launch a child process command.

		The command should be the name of the executable file, followed by any arguments
		that are required.
		If the process has already been launched, this will launch it again. If a problem
		occurs, the method will return false.
	*/
	bool start (const String& command);

	/** Returns true if the child process is alive. */
	bool isRunning() const;

	/** Attempts to read some output from the child process.
		This will attempt to read up to the given number of bytes of data from the
		process. It returns the number of bytes that were actually read.
	*/
	int readProcessOutput (void* destBuffer, int numBytesToRead);

	/** Blocks until the process has finished, and then returns its complete output
		as a string.
	*/
	String readAllProcessOutput();

	/** Blocks until the process is no longer running. */
	bool waitForProcessToFinish (int timeoutMs) const;

	/** Attempts to kill the child process.
		Returns true if it succeeded. Trying to read from the process after calling this may
		result in undefined behaviour.
	*/
	bool kill();

private:

	class ActiveProcess;
	friend class ScopedPointer<ActiveProcess>;
	ScopedPointer<ActiveProcess> activeProcess;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ChildProcess);
};

#endif   // __JUCE_CHILDPROCESS_JUCEHEADER__

/*** End of inlined file: juce_ChildProcess.h ***/


#endif
#ifndef __JUCE_CRITICALSECTION_JUCEHEADER__

#endif
#ifndef __JUCE_DYNAMICLIBRARY_JUCEHEADER__

/*** Start of inlined file: juce_DynamicLibrary.h ***/
#ifndef __JUCE_DYNAMICLIBRARY_JUCEHEADER__
#define __JUCE_DYNAMICLIBRARY_JUCEHEADER__

/**
	Handles the opening and closing of DLLs.

	This class can be used to open a DLL and get some function pointers from it.
	Since the DLL is freed when this object is deleted, it's handy for managing
	library lifetimes using RAII.
*/
class JUCE_API  DynamicLibrary
{
public:
	/** Creates an unopened DynamicLibrary object.
		Call open() to actually open one.
	*/
	DynamicLibrary() noexcept : handle (nullptr) {}

	/**
	*/
	DynamicLibrary (const String& name) : handle (nullptr) { open (name); }

	/** Destructor.
		If a library is currently open, it will be closed when this object is destroyed.
	*/
	~DynamicLibrary()   { close(); }

	/** Opens a DLL.
		The name and the method by which it gets found is of course platform-specific, and
		may or may not include a path, depending on the OS.
		If a library is already open when this method is called, it will first close the library
		before attempting to load the new one.
		@returns true if the library was successfully found and opened.
	*/
	bool open (const String& name);

	/** Releases the currently-open DLL, or has no effect if none was open. */
	void close();

	/** Tries to find a named function in the currently-open DLL, and returns a pointer to it.
		If no library is open, or if the function isn't found, this will return a null pointer.
	*/
	void* getFunction (const String& functionName) noexcept;

	/** Returns the platform-specific native library handle.
		You'll need to cast this to whatever is appropriate for the OS that's in use.
	*/
	void* getNativeHandle() const noexcept     { return handle; }

private:
	void* handle;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (DynamicLibrary);
};

#endif   // __JUCE_DYNAMICLIBRARY_JUCEHEADER__

/*** End of inlined file: juce_DynamicLibrary.h ***/


#endif
#ifndef __JUCE_INTERPROCESSLOCK_JUCEHEADER__

/*** Start of inlined file: juce_InterProcessLock.h ***/
#ifndef __JUCE_INTERPROCESSLOCK_JUCEHEADER__
#define __JUCE_INTERPROCESSLOCK_JUCEHEADER__

/**
	Acts as a critical section which processes can use to block each other.

	@see CriticalSection
*/
class JUCE_API  InterProcessLock
{
public:

	/** Creates a lock object.

		@param name     a name that processes will use to identify this lock object
	*/
	explicit InterProcessLock (const String& name);

	/** Destructor.

		This will also release the lock if it's currently held by this process.
	*/
	~InterProcessLock();

	/** Attempts to lock the critical section.

		@param timeOutMillisecs     how many milliseconds to wait if the lock
									is already held by another process - a value of
									0 will return immediately, negative values will wait
									forever
		@returns    true if the lock could be gained within the timeout period, or
					false if the timeout expired.
	*/
	bool enter (int timeOutMillisecs = -1);

	/** Releases the lock if it's currently held by this process.
	*/
	void exit();

	/**
		Automatically locks and unlocks an InterProcessLock object.

		This works like a ScopedLock, but using an InterprocessLock rather than
		a CriticalSection.

		@see ScopedLock
	*/
	class ScopedLockType
	{
	public:

		/** Creates a scoped lock.

			As soon as it is created, this will lock the InterProcessLock, and
			when the ScopedLockType object is deleted, the InterProcessLock will
			be unlocked.

			Note that since an InterprocessLock can fail due to errors, you should check
			isLocked() to make sure that the lock was successful before using it.

			Make sure this object is created and deleted by the same thread,
			otherwise there are no guarantees what will happen! Best just to use it
			as a local stack object, rather than creating one with the new() operator.
		*/
		explicit ScopedLockType (InterProcessLock& lock)                    : lock_ (lock) { lockWasSuccessful = lock.enter(); }

		/** Destructor.

			The InterProcessLock will be unlocked when the destructor is called.

			Make sure this object is created and deleted by the same thread,
			otherwise there are no guarantees what will happen!
		*/
		inline ~ScopedLockType()                                            { lock_.exit(); }

		/** Returns true if the InterProcessLock was successfully locked. */
		bool isLocked() const noexcept                                      { return lockWasSuccessful; }

	private:

		InterProcessLock& lock_;
		bool lockWasSuccessful;

		JUCE_DECLARE_NON_COPYABLE (ScopedLockType);
	};

private:

	class Pimpl;
	friend class ScopedPointer <Pimpl>;
	ScopedPointer <Pimpl> pimpl;

	CriticalSection lock;
	String name;

	JUCE_DECLARE_NON_COPYABLE (InterProcessLock);
};

#endif   // __JUCE_INTERPROCESSLOCK_JUCEHEADER__

/*** End of inlined file: juce_InterProcessLock.h ***/


#endif
#ifndef __JUCE_PROCESS_JUCEHEADER__

/*** Start of inlined file: juce_Process.h ***/
#ifndef __JUCE_PROCESS_JUCEHEADER__
#define __JUCE_PROCESS_JUCEHEADER__

/** Represents the current executable's process.

	This contains methods for controlling the current application at the
	process-level.

	@see Thread, JUCEApplication
*/
class JUCE_API  Process
{
public:

	enum ProcessPriority
	{
		LowPriority         = 0,
		NormalPriority      = 1,
		HighPriority        = 2,
		RealtimePriority    = 3
	};

	/** Changes the current process's priority.

		@param priority     the process priority, where
							0=low, 1=normal, 2=high, 3=realtime
	*/
	static void setPriority (const ProcessPriority priority);

	/** Kills the current process immediately.

		This is an emergency process terminator that kills the application
		immediately - it's intended only for use only when something goes
		horribly wrong.

		@see JUCEApplication::quit
	*/
	static void terminate();

	/** Returns true if this application process is the one that the user is
		currently using.
	*/
	static bool isForegroundProcess();

	/** Raises the current process's privilege level.

		Does nothing if this isn't supported by the current OS, or if process
		privilege level is fixed.
	*/
	static void raisePrivilege();

	/** Lowers the current process's privilege level.

		Does nothing if this isn't supported by the current OS, or if process
		privilege level is fixed.
	*/
	static void lowerPrivilege();

	/** Returns true if this process is being hosted by a debugger.
	*/
	static bool JUCE_CALLTYPE isRunningUnderDebugger();

	/** Tries to launch the OS's default reader application for a given file or URL. */
	static bool openDocument (const String& documentURL, const String& parameters);

	/** Tries to launch the OS's default email application to let the user create a message. */
	static bool openEmailWithAttachments (const String& targetEmailAddress,
										  const String& emailSubject,
										  const String& bodyText,
										  const StringArray& filesToAttach);

   #if JUCE_WINDOWS || DOXYGEN

	/** WINDOWS ONLY - This returns the HINSTANCE of the current module.

		The return type is a void* to avoid being dependent on windows.h - just cast
		it to a HINSTANCE to use it.

		In a normal JUCE application, this will be automatically set to the module
		handle of the executable.

		If you've built a DLL and plan to use any JUCE messaging or windowing classes,
		you'll need to make sure you call the setCurrentModuleInstanceHandle()
		to provide the correct module handle in your DllMain() function, because
		the system relies on the correct instance handle when opening windows.
	*/
	static void* JUCE_CALLTYPE getCurrentModuleInstanceHandle() noexcept;

	/** WINDOWS ONLY - Sets a new module handle to be used by the library.

		The parameter type is a void* to avoid being dependent on windows.h, but it actually
		expects a HINSTANCE value.

		@see getCurrentModuleInstanceHandle()
	*/
	static void JUCE_CALLTYPE setCurrentModuleInstanceHandle (void* newHandle) noexcept;

	/** WINDOWS ONLY - Gets the command-line params as a string.
		This is needed to avoid unicode problems with the argc type params.
	*/
	static String JUCE_CALLTYPE getCurrentCommandLineParams();
   #endif

private:
	Process();
	JUCE_DECLARE_NON_COPYABLE (Process);
};

#endif   // __JUCE_PROCESS_JUCEHEADER__

/*** End of inlined file: juce_Process.h ***/


#endif
#ifndef __JUCE_READWRITELOCK_JUCEHEADER__

/*** Start of inlined file: juce_ReadWriteLock.h ***/
#ifndef __JUCE_READWRITELOCK_JUCEHEADER__
#define __JUCE_READWRITELOCK_JUCEHEADER__


/*** Start of inlined file: juce_SpinLock.h ***/
#ifndef __JUCE_SPINLOCK_JUCEHEADER__
#define __JUCE_SPINLOCK_JUCEHEADER__

/**
	A simple spin-lock class that can be used as a simple, low-overhead mutex for
	uncontended situations.

	Note that unlike a CriticalSection, this type of lock is not re-entrant, and may
	be less efficient when used it a highly contended situation, but it's very small and
	requires almost no initialisation.
	It's most appropriate for simple situations where you're only going to hold the
	lock for a very brief time.

	@see CriticalSection
*/
class JUCE_API  SpinLock
{
public:
	inline SpinLock() noexcept {}
	inline ~SpinLock() noexcept {}

	/** Acquires the lock.
		This will block until the lock has been successfully acquired by this thread.
		Note that a SpinLock is NOT re-entrant, and is not smart enough to know whether the
		caller thread already has the lock - so if a thread tries to acquire a lock that it
		already holds, this method will never return!

		It's strongly recommended that you never call this method directly - instead use the
		ScopedLockType class to manage the locking using an RAII pattern instead.
	*/
	void enter() const noexcept;

	/** Attempts to acquire the lock, returning true if this was successful. */
	inline bool tryEnter() const noexcept
	{
		return lock.compareAndSetBool (1, 0);
	}

	/** Releases the lock. */
	inline void exit() const noexcept
	{
		jassert (lock.value == 1); // Agh! Releasing a lock that isn't currently held!
		lock = 0;
	}

	/** Provides the type of scoped lock to use for locking a SpinLock. */
	typedef GenericScopedLock <SpinLock>       ScopedLockType;

	/** Provides the type of scoped unlocker to use with a SpinLock. */
	typedef GenericScopedUnlock <SpinLock>     ScopedUnlockType;

private:

	mutable Atomic<int> lock;

	JUCE_DECLARE_NON_COPYABLE (SpinLock);
};

#endif   // __JUCE_SPINLOCK_JUCEHEADER__

/*** End of inlined file: juce_SpinLock.h ***/


/*** Start of inlined file: juce_WaitableEvent.h ***/
#ifndef __JUCE_WAITABLEEVENT_JUCEHEADER__
#define __JUCE_WAITABLEEVENT_JUCEHEADER__

/**
	Allows threads to wait for events triggered by other threads.

	A thread can call wait() on a WaitableObject, and this will suspend the
	calling thread until another thread wakes it up by calling the signal()
	method.
*/
class JUCE_API  WaitableEvent
{
public:

	/** Creates a WaitableEvent object.

		@param manualReset  If this is false, the event will be reset automatically when the wait()
							method is called. If manualReset is true, then once the event is signalled,
							the only way to reset it will be by calling the reset() method.
	*/
	WaitableEvent (bool manualReset = false) noexcept;

	/** Destructor.

		If other threads are waiting on this object when it gets deleted, this
		can cause nasty errors, so be careful!
	*/
	~WaitableEvent() noexcept;

	/** Suspends the calling thread until the event has been signalled.

		This will wait until the object's signal() method is called by another thread,
		or until the timeout expires.

		After the event has been signalled, this method will return true and if manualReset
		was set to false in the WaitableEvent's constructor, then the event will be reset.

		@param timeOutMilliseconds  the maximum time to wait, in milliseconds. A negative
									value will cause it to wait forever.

		@returns    true if the object has been signalled, false if the timeout expires first.
		@see signal, reset
	*/
	bool wait (int timeOutMilliseconds = -1) const noexcept;

	/** Wakes up any threads that are currently waiting on this object.

		If signal() is called when nothing is waiting, the next thread to call wait()
		will return immediately and reset the signal.

		If the WaitableEvent is manual reset, all current and future threads that wait upon this
		object will be woken, until reset() is explicitly called.

		If the WaitableEvent is automatic reset, and one or more threads is waiting upon the object,
		then one of them will be woken up. If no threads are currently waiting, then the next thread
		to call wait() will be woken up. As soon as a thread is woken, the signal is automatically
		reset.

		@see wait, reset
	*/
	void signal() const noexcept;

	/** Resets the event to an unsignalled state.

		If it's not already signalled, this does nothing.
	*/
	void reset() const noexcept;

private:

	void* internal;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (WaitableEvent);
};

#endif   // __JUCE_WAITABLEEVENT_JUCEHEADER__

/*** End of inlined file: juce_WaitableEvent.h ***/


/*** Start of inlined file: juce_Thread.h ***/
#ifndef __JUCE_THREAD_JUCEHEADER__
#define __JUCE_THREAD_JUCEHEADER__

/**
	Encapsulates a thread.

	Subclasses derive from Thread and implement the run() method, in which they
	do their business. The thread can then be started with the startThread() method
	and controlled with various other methods.

	This class also contains some thread-related static methods, such
	as sleep(), yield(), getCurrentThreadId() etc.

	@see CriticalSection, WaitableEvent, Process, ThreadWithProgressWindow,
		 MessageManagerLock
*/
class JUCE_API  Thread
{
public:

	/**
		Creates a thread.

		When first created, the thread is not running. Use the startThread()
		method to start it.
	*/
	explicit Thread (const String& threadName);

	/** Destructor.

		Deleting a Thread object that is running will only give the thread a
		brief opportunity to stop itself cleanly, so it's recommended that you
		should always call stopThread() with a decent timeout before deleting,
		to avoid the thread being forcibly killed (which is a Bad Thing).
	*/
	virtual ~Thread();

	/** Must be implemented to perform the thread's actual code.

		Remember that the thread must regularly check the threadShouldExit()
		method whilst running, and if this returns true it should return from
		the run() method as soon as possible to avoid being forcibly killed.

		@see threadShouldExit, startThread
	*/
	virtual void run() = 0;

	// Thread control functions..

	/** Starts the thread running.

		This will start the thread's run() method.
		(if it's already started, startThread() won't do anything).

		@see stopThread
	*/
	void startThread();

	/** Starts the thread with a given priority.

		Launches the thread with a given priority, where 0 = lowest, 10 = highest.
		If the thread is already running, its priority will be changed.

		@see startThread, setPriority
	*/
	void startThread (int priority);

	/** Attempts to stop the thread running.

		This method will cause the threadShouldExit() method to return true
		and call notify() in case the thread is currently waiting.

		Hopefully the thread will then respond to this by exiting cleanly, and
		the stopThread method will wait for a given time-period for this to
		happen.

		If the thread is stuck and fails to respond after the time-out, it gets
		forcibly killed, which is a very bad thing to happen, as it could still
		be holding locks, etc. which are needed by other parts of your program.

		@param timeOutMilliseconds  The number of milliseconds to wait for the
									thread to finish before killing it by force. A negative
									value in here will wait forever.
		@see signalThreadShouldExit, threadShouldExit, waitForThreadToExit, isThreadRunning
	*/
	void stopThread (int timeOutMilliseconds);

	/** Returns true if the thread is currently active */
	bool isThreadRunning() const;

	/** Sets a flag to tell the thread it should stop.

		Calling this means that the threadShouldExit() method will then return true.
		The thread should be regularly checking this to see whether it should exit.

		If your thread makes use of wait(), you might want to call notify() after calling
		this method, to interrupt any waits that might be in progress, and allow it
		to reach a point where it can exit.

		@see threadShouldExit
		@see waitForThreadToExit
	*/
	void signalThreadShouldExit();

	/** Checks whether the thread has been told to stop running.

		Threads need to check this regularly, and if it returns true, they should
		return from their run() method at the first possible opportunity.

		@see signalThreadShouldExit
	*/
	inline bool threadShouldExit() const                { return threadShouldExit_; }

	/** Waits for the thread to stop.

		This will waits until isThreadRunning() is false or until a timeout expires.

		@param timeOutMilliseconds  the time to wait, in milliseconds. If this value
									is less than zero, it will wait forever.
		@returns    true if the thread exits, or false if the timeout expires first.
	*/
	bool waitForThreadToExit (int timeOutMilliseconds) const;

	/** Changes the thread's priority.
		May return false if for some reason the priority can't be changed.

		@param priority     the new priority, in the range 0 (lowest) to 10 (highest). A priority
							of 5 is normal.
	*/
	bool setPriority (int priority);

	/** Changes the priority of the caller thread.

		Similar to setPriority(), but this static method acts on the caller thread.
		May return false if for some reason the priority can't be changed.

		@see setPriority
	*/
	static bool setCurrentThreadPriority (int priority);

	/** Sets the affinity mask for the thread.

		This will only have an effect next time the thread is started - i.e. if the
		thread is already running when called, it'll have no effect.

		@see setCurrentThreadAffinityMask
	*/
	void setAffinityMask (uint32 affinityMask);

	/** Changes the affinity mask for the caller thread.

		This will change the affinity mask for the thread that calls this static method.

		@see setAffinityMask
	*/
	static void setCurrentThreadAffinityMask (uint32 affinityMask);

	// this can be called from any thread that needs to pause..
	static void JUCE_CALLTYPE sleep (int milliseconds);

	/** Yields the calling thread's current time-slot. */
	static void JUCE_CALLTYPE yield();

	/** Makes the thread wait for a notification.

		This puts the thread to sleep until either the timeout period expires, or
		another thread calls the notify() method to wake it up.

		A negative time-out value means that the method will wait indefinitely.

		@returns    true if the event has been signalled, false if the timeout expires.
	*/
	bool wait (int timeOutMilliseconds) const;

	/** Wakes up the thread.

		If the thread has called the wait() method, this will wake it up.

		@see wait
	*/
	void notify() const;

	/** A value type used for thread IDs.
		@see getCurrentThreadId(), getThreadId()
	*/
	typedef void* ThreadID;

	/** Returns an id that identifies the caller thread.

		To find the ID of a particular thread object, use getThreadId().

		@returns    a unique identifier that identifies the calling thread.
		@see getThreadId
	*/
	static ThreadID getCurrentThreadId();

	/** Finds the thread object that is currently running.

		Note that the main UI thread (or other non-Juce threads) don't have a Thread
		object associated with them, so this will return 0.
	*/
	static Thread* getCurrentThread();

	/** Returns the ID of this thread.

		That means the ID of this thread object - not of the thread that's calling the method.

		This can change when the thread is started and stopped, and will be invalid if the
		thread's not actually running.

		@see getCurrentThreadId
	*/
	ThreadID getThreadId() const noexcept                           { return threadId_; }

	/** Returns the name of the thread.

		This is the name that gets set in the constructor.
	*/
	const String& getThreadName() const                             { return threadName_; }

	/** Changes the name of the caller thread.
		Different OSes may place different length or content limits on this name.
	*/
	static void setCurrentThreadName (const String& newThreadName);

	/** Returns the number of currently-running threads.

		@returns  the number of Thread objects known to be currently running.
		@see stopAllThreads
	*/
	static int getNumRunningThreads();

	/** Tries to stop all currently-running threads.

		This will attempt to stop all the threads known to be running at the moment.
	*/
	static void stopAllThreads (int timeoutInMillisecs);

private:

	const String threadName_;
	void* volatile threadHandle_;
	ThreadID threadId_;
	CriticalSection startStopLock;
	WaitableEvent startSuspensionEvent_, defaultEvent_;
	int threadPriority_;
	uint32 affinityMask_;
	bool volatile threadShouldExit_;

   #ifndef DOXYGEN
	friend void JUCE_API juce_threadEntryPoint (void*);
   #endif

	void launchThread();
	void closeThreadHandle();
	void killThread();
	void threadEntryPoint();
	static bool setThreadPriority (void*, int priority);

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (Thread);
};

#endif   // __JUCE_THREAD_JUCEHEADER__

/*** End of inlined file: juce_Thread.h ***/

/**
	A critical section that allows multiple simultaneous readers.

	Features of this type of lock are:

	- Multiple readers can hold the lock at the same time, but only one writer
	  can hold it at once.
	- Writers trying to gain the lock will be blocked until all readers and writers
	  have released it
	- Readers trying to gain the lock while a writer is waiting to acquire it will be
	  blocked until the writer has obtained and released it
	- If a thread already has a read lock and tries to obtain a write lock, it will succeed if
	  there are no other readers
	- If a thread already has the write lock and tries to obtain a read lock, this will succeed.
	- Recursive locking is supported.

	@see ScopedReadLock, ScopedWriteLock, CriticalSection
*/
class JUCE_API  ReadWriteLock
{
public:

	/**
		Creates a ReadWriteLock object.
	*/
	ReadWriteLock() noexcept;

	/** Destructor.

		If the object is deleted whilst locked, any subsequent behaviour
		is unpredictable.
	*/
	~ReadWriteLock() noexcept;

	/** Locks this object for reading.

		Multiple threads can simulaneously lock the object for reading, but if another
		thread has it locked for writing, then this will block until it releases the
		lock.

		@see exitRead, ScopedReadLock
	*/
	void enterRead() const noexcept;

	/** Releases the read-lock.

		If the caller thread hasn't got the lock, this can have unpredictable results.

		If the enterRead() method has been called multiple times by the thread, each
		call must be matched by a call to exitRead() before other threads will be allowed
		to take over the lock.

		@see enterRead, ScopedReadLock
	*/
	void exitRead() const noexcept;

	/** Locks this object for writing.

		This will block until any other threads that have it locked for reading or
		writing have released their lock.

		@see exitWrite, ScopedWriteLock
	*/
	void enterWrite() const noexcept;

	/** Tries to lock this object for writing.

		This is like enterWrite(), but doesn't block - it returns true if it manages
		to obtain the lock.

		@see enterWrite
	*/
	bool tryEnterWrite() const noexcept;

	/** Releases the write-lock.

		If the caller thread hasn't got the lock, this can have unpredictable results.

		If the enterWrite() method has been called multiple times by the thread, each
		call must be matched by a call to exit() before other threads will be allowed
		to take over the lock.

		@see enterWrite, ScopedWriteLock
	*/
	void exitWrite() const noexcept;

private:

	SpinLock accessLock;
	WaitableEvent waitEvent;
	mutable int numWaitingWriters, numWriters;
	mutable Thread::ThreadID writerThreadId;
	mutable Array <Thread::ThreadID> readerThreads;

	JUCE_DECLARE_NON_COPYABLE (ReadWriteLock);
};

#endif   // __JUCE_READWRITELOCK_JUCEHEADER__

/*** End of inlined file: juce_ReadWriteLock.h ***/


#endif
#ifndef __JUCE_SCOPEDLOCK_JUCEHEADER__

#endif
#ifndef __JUCE_SCOPEDREADLOCK_JUCEHEADER__

/*** Start of inlined file: juce_ScopedReadLock.h ***/
#ifndef __JUCE_SCOPEDREADLOCK_JUCEHEADER__
#define __JUCE_SCOPEDREADLOCK_JUCEHEADER__

/**
	Automatically locks and unlocks a ReadWriteLock object.

	Use one of these as a local variable to control access to a ReadWriteLock.

	e.g. @code

	ReadWriteLock myLock;

	for (;;)
	{
		const ScopedReadLock myScopedLock (myLock);
		// myLock is now locked

		...do some stuff...

		// myLock gets unlocked here.
	}
	@endcode

	@see ReadWriteLock, ScopedWriteLock
*/
class JUCE_API  ScopedReadLock
{
public:

	/** Creates a ScopedReadLock.

		As soon as it is created, this will call ReadWriteLock::enterRead(), and
		when the ScopedReadLock object is deleted, the ReadWriteLock will
		be unlocked.

		Make sure this object is created and deleted by the same thread,
		otherwise there are no guarantees what will happen! Best just to use it
		as a local stack object, rather than creating one with the new() operator.
	*/
	inline explicit ScopedReadLock (const ReadWriteLock& lock) noexcept   : lock_ (lock) { lock.enterRead(); }

	/** Destructor.

		The ReadWriteLock's exitRead() method will be called when the destructor is called.

		Make sure this object is created and deleted by the same thread,
		otherwise there are no guarantees what will happen!
	*/
	inline ~ScopedReadLock() noexcept                                     { lock_.exitRead(); }

private:

	const ReadWriteLock& lock_;

	JUCE_DECLARE_NON_COPYABLE (ScopedReadLock);
};

#endif   // __JUCE_SCOPEDREADLOCK_JUCEHEADER__

/*** End of inlined file: juce_ScopedReadLock.h ***/


#endif
#ifndef __JUCE_SCOPEDWRITELOCK_JUCEHEADER__

/*** Start of inlined file: juce_ScopedWriteLock.h ***/
#ifndef __JUCE_SCOPEDWRITELOCK_JUCEHEADER__
#define __JUCE_SCOPEDWRITELOCK_JUCEHEADER__

/**
	Automatically locks and unlocks a ReadWriteLock object.

	Use one of these as a local variable to control access to a ReadWriteLock.

	e.g. @code

	ReadWriteLock myLock;

	for (;;)
	{
		const ScopedWriteLock myScopedLock (myLock);
		// myLock is now locked

		...do some stuff...

		// myLock gets unlocked here.
	}
	@endcode

	@see ReadWriteLock, ScopedReadLock
*/
class JUCE_API  ScopedWriteLock
{
public:

	/** Creates a ScopedWriteLock.

		As soon as it is created, this will call ReadWriteLock::enterWrite(), and
		when the ScopedWriteLock object is deleted, the ReadWriteLock will
		be unlocked.

		Make sure this object is created and deleted by the same thread,
		otherwise there are no guarantees what will happen! Best just to use it
		as a local stack object, rather than creating one with the new() operator.
	*/
	inline explicit ScopedWriteLock (const ReadWriteLock& lock) noexcept : lock_ (lock) { lock.enterWrite(); }

	/** Destructor.

		The ReadWriteLock's exitWrite() method will be called when the destructor is called.

		Make sure this object is created and deleted by the same thread,
		otherwise there are no guarantees what will happen!
	*/
	inline ~ScopedWriteLock() noexcept                                   { lock_.exitWrite(); }

private:

	const ReadWriteLock& lock_;

	JUCE_DECLARE_NON_COPYABLE (ScopedWriteLock);
};

#endif   // __JUCE_SCOPEDWRITELOCK_JUCEHEADER__

/*** End of inlined file: juce_ScopedWriteLock.h ***/


#endif
#ifndef __JUCE_SPINLOCK_JUCEHEADER__

#endif
#ifndef __JUCE_THREAD_JUCEHEADER__

#endif
#ifndef __JUCE_THREADLOCALVALUE_JUCEHEADER__

/*** Start of inlined file: juce_ThreadLocalValue.h ***/
#ifndef __JUCE_THREADLOCALVALUE_JUCEHEADER__
#define __JUCE_THREADLOCALVALUE_JUCEHEADER__

/**
	Provides cross-platform support for thread-local objects.

	This class holds an internal list of objects of the templated type, keeping
	an instance for each thread that requests one. The first time a thread attempts
	to access its value, an object is created and added to the list for that thread.

	The templated class for your value could be a primitive type, or any class that
	has a default constructor.

	Once a thread has accessed its object, that object will not be deleted until the
	ThreadLocalValue object itself is deleted, even if its thread exits before that.
	But, because thread ID numbers are used to identify threads, and OSes often re-use
	these ID numbers, value objects will often be implicitly re-used by new threads whose
	ID number is the same as one that was used by an earlier thread.
*/
template <typename Type>
class ThreadLocalValue
{
public:
	/** */
	ThreadLocalValue() noexcept
	{
	}

	/** Destructor.
		When this object is deleted, all the value objects for all threads will be deleted.
	*/
	~ThreadLocalValue()
	{
		for (ObjectHolder* o = first.value; o != nullptr;)
		{
			ObjectHolder* const next = o->next;
			delete o;
			o = next;
		}
	}

	/** Returns a reference to this thread's instance of the value.
		Note that the first time a thread tries to access the value, an instance of the
		value object will be created - so if your value's class has a non-trivial
		constructor, be aware that this method could invoke it.
	*/
	Type& operator*() const noexcept    { return get(); }

	/** Returns a pointer to this thread's instance of the value.
		Note that the first time a thread tries to access the value, an instance of the
		value object will be created - so if your value's class has a non-trivial
		constructor, be aware that this method could invoke it.
	*/
	operator Type*() const noexcept     { return &get(); }

	/** Accesses a method or field of the value object.
		Note that the first time a thread tries to access the value, an instance of the
		value object will be created - so if your value's class has a non-trivial
		constructor, be aware that this method could invoke it.
	*/
	Type* operator->() const noexcept   { return &get(); }

	/** Returns a reference to this thread's instance of the value.
		Note that the first time a thread tries to access the value, an instance of the
		value object will be created - so if your value's class has a non-trivial
		constructor, be aware that this method could invoke it.
	*/
	Type& get() const noexcept
	{
		const Thread::ThreadID threadId = Thread::getCurrentThreadId();

		for (ObjectHolder* o = first.get(); o != nullptr; o = o->next)
			if (o->threadId == threadId)
				return o->object;

		ObjectHolder* const newObject = new ObjectHolder (threadId);

		do
		{
			newObject->next = first.get();
		}
		while (! first.compareAndSetBool (newObject, newObject->next));

		return newObject->object;
	}

private:

	struct ObjectHolder
	{
		ObjectHolder (const Thread::ThreadID& threadId_)
			: threadId (threadId_), object()
		{}

		const Thread::ThreadID threadId;
		ObjectHolder* next;
		Type object;

		JUCE_DECLARE_NON_COPYABLE (ObjectHolder);
	};

	mutable Atomic<ObjectHolder*> first;

	JUCE_DECLARE_NON_COPYABLE (ThreadLocalValue);
};

#endif   // __JUCE_THREADLOCALVALUE_JUCEHEADER__

/*** End of inlined file: juce_ThreadLocalValue.h ***/


#endif
#ifndef __JUCE_THREADPOOL_JUCEHEADER__

/*** Start of inlined file: juce_ThreadPool.h ***/
#ifndef __JUCE_THREADPOOL_JUCEHEADER__
#define __JUCE_THREADPOOL_JUCEHEADER__

class ThreadPool;
class ThreadPoolThread;

/**
	A task that is executed by a ThreadPool object.

	A ThreadPool keeps a list of ThreadPoolJob objects which are executed by
	its threads.

	The runJob() method needs to be implemented to do the task, and if the code that
	does the work takes a significant time to run, it must keep checking the shouldExit()
	method to see if something is trying to interrupt the job. If shouldExit() returns
	true, the runJob() method must return immediately.

	@see ThreadPool, Thread
*/
class JUCE_API  ThreadPoolJob
{
public:

	/** Creates a thread pool job object.

		After creating your job, add it to a thread pool with ThreadPool::addJob().
	*/
	explicit ThreadPoolJob (const String& name);

	/** Destructor. */
	virtual ~ThreadPoolJob();

	/** Returns the name of this job.
		@see setJobName
	*/
	String getJobName() const;

	/** Changes the job's name.
		@see getJobName
	*/
	void setJobName (const String& newName);

	/** These are the values that can be returned by the runJob() method.
	*/
	enum JobStatus
	{
		jobHasFinished = 0,     /**< indicates that the job has finished and can be
									 removed from the pool. */

		jobHasFinishedAndShouldBeDeleted,  /**< indicates that the job has finished and that it
												should be automatically deleted by the pool. */

		jobNeedsRunningAgain    /**< indicates that the job would like to be called
									 again when a thread is free. */
	};

	/** Peforms the actual work that this job needs to do.

		Your subclass must implement this method, in which is does its work.

		If the code in this method takes a significant time to run, it must repeatedly check
		the shouldExit() method to see if something is trying to interrupt the job.
		If shouldExit() ever returns true, the runJob() method must return immediately.

		If this method returns jobHasFinished, then the job will be removed from the pool
		immediately. If it returns jobNeedsRunningAgain, then the job will be left in the
		pool and will get a chance to run again as soon as a thread is free.

		@see shouldExit()
	*/
	virtual JobStatus runJob() = 0;

	/** Returns true if this job is currently running its runJob() method. */
	bool isRunning() const                  { return isActive; }

	/** Returns true if something is trying to interrupt this job and make it stop.

		Your runJob() method must call this whenever it gets a chance, and if it ever
		returns true, the runJob() method must return immediately.

		@see signalJobShouldExit()
	*/
	bool shouldExit() const                 { return shouldStop; }

	/** Calling this will cause the shouldExit() method to return true, and the job
		should (if it's been implemented correctly) stop as soon as possible.

		@see shouldExit()
	*/
	void signalJobShouldExit();

private:
	friend class ThreadPool;
	friend class ThreadPoolThread;
	String jobName;
	ThreadPool* pool;
	bool shouldStop, isActive, shouldBeDeleted;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ThreadPoolJob);
};

/**
	A set of threads that will run a list of jobs.

	When a ThreadPoolJob object is added to the ThreadPool's list, its run() method
	will be called by the next pooled thread that becomes free.

	@see ThreadPoolJob, Thread
*/
class JUCE_API  ThreadPool
{
public:

	/** Creates a thread pool.

		Once you've created a pool, you can give it some things to do with the addJob()
		method.

		@param numberOfThreads              the maximum number of actual threads to run.
		@param startThreadsOnlyWhenNeeded   if this is true, then no threads will be started
											until there are some jobs to run. If false, then
											all the threads will be fired-up immediately so that
											they're ready for action
		@param stopThreadsWhenNotUsedTimeoutMs  if this timeout is > 0, then if any threads have been
											inactive for this length of time, they will automatically
											be stopped until more jobs come along and they're needed
	*/
	ThreadPool (int numberOfThreads,
				bool startThreadsOnlyWhenNeeded = true,
				int stopThreadsWhenNotUsedTimeoutMs = 5000);

	/** Destructor.

		This will attempt to remove all the jobs before deleting, but if you want to
		specify a timeout, you should call removeAllJobs() explicitly before deleting
		the pool.
	*/
	~ThreadPool();

	/** A callback class used when you need to select which ThreadPoolJob objects are suitable
		for some kind of operation.
		@see ThreadPool::removeAllJobs
	*/
	class JUCE_API  JobSelector
	{
	public:
		virtual ~JobSelector() {}

		/** Should return true if the specified thread matches your criteria for whatever
			operation that this object is being used for.

			Any implementation of this method must be extremely fast and thread-safe!
		*/
		virtual bool isJobSuitable (ThreadPoolJob* job) = 0;
	};

	/** Adds a job to the queue.

		Once a job has been added, then the next time a thread is free, it will run
		the job's ThreadPoolJob::runJob() method. Depending on the return value of the
		runJob() method, the pool will either remove the job from the pool or add it to
		the back of the queue to be run again.
	*/
	void addJob (ThreadPoolJob* job);

	/** Tries to remove a job from the pool.

		If the job isn't yet running, this will simply remove it. If it is running, it
		will wait for it to finish.

		If the timeout period expires before the job finishes running, then the job will be
		left in the pool and this will return false. It returns true if the job is sucessfully
		stopped and removed.

		@param job                  the job to remove
		@param interruptIfRunning   if true, then if the job is currently busy, its
									ThreadPoolJob::signalJobShouldExit() method will be called to try
									to interrupt it. If false, then if the job will be allowed to run
									until it stops normally (or the timeout expires)
		@param timeOutMilliseconds  the length of time this method should wait for the job to finish
									before giving up and returning false
	*/
	bool removeJob (ThreadPoolJob* job,
					bool interruptIfRunning,
					int timeOutMilliseconds);

	/** Tries to remove all jobs from the pool.

		@param interruptRunningJobs if true, then all running jobs will have their ThreadPoolJob::signalJobShouldExit()
									methods called to try to interrupt them
		@param timeOutMilliseconds  the length of time this method should wait for all the jobs to finish
									before giving up and returning false
		@param deleteInactiveJobs   if true, any jobs that aren't currently running will be deleted. If false,
									they will simply be removed from the pool. Jobs that are already running when
									this method is called can choose whether they should be deleted by
									returning jobHasFinishedAndShouldBeDeleted from their runJob() method.
		@param selectedJobsToRemove if this is non-zero, the JobSelector object is asked to decide which
									jobs should be removed. If it is zero, all jobs are removed
		@returns    true if all jobs are successfully stopped and removed; false if the timeout period
					expires while waiting for one or more jobs to stop
	*/
	bool removeAllJobs (bool interruptRunningJobs,
						int timeOutMilliseconds,
						bool deleteInactiveJobs = false,
						JobSelector* selectedJobsToRemove = nullptr);

	/** Returns the number of jobs currently running or queued.
	*/
	int getNumJobs() const;

	/** Returns one of the jobs in the queue.

		Note that this can be a very volatile list as jobs might be continuously getting shifted
		around in the list, and this method may return 0 if the index is currently out-of-range.
	*/
	ThreadPoolJob* getJob (int index) const;

	/** Returns true if the given job is currently queued or running.

		@see isJobRunning()
	*/
	bool contains (const ThreadPoolJob* job) const;

	/** Returns true if the given job is currently being run by a thread.
	*/
	bool isJobRunning (const ThreadPoolJob* job) const;

	/** Waits until a job has finished running and has been removed from the pool.

		This will wait until the job is no longer in the pool - i.e. until its
		runJob() method returns ThreadPoolJob::jobHasFinished.

		If the timeout period expires before the job finishes, this will return false;
		it returns true if the job has finished successfully.
	*/
	bool waitForJobToFinish (const ThreadPoolJob* job,
							 int timeOutMilliseconds) const;

	/** Returns a list of the names of all the jobs currently running or queued.

		If onlyReturnActiveJobs is true, only the ones currently running are returned.
	*/
	StringArray getNamesOfAllJobs (bool onlyReturnActiveJobs) const;

	/** Changes the priority of all the threads.

		This will call Thread::setPriority() for each thread in the pool.
		May return false if for some reason the priority can't be changed.
	*/
	bool setThreadPriorities (int newPriority);

private:

	const int threadStopTimeout;
	int priority;
	class ThreadPoolThread;
	friend class OwnedArray <ThreadPoolThread>;
	OwnedArray <ThreadPoolThread> threads;
	Array <ThreadPoolJob*> jobs;

	CriticalSection lock;
	uint32 lastJobEndTime;
	WaitableEvent jobFinishedSignal;

	friend class ThreadPoolThread;
	bool runNextJob();

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ThreadPool);
};

#endif   // __JUCE_THREADPOOL_JUCEHEADER__

/*** End of inlined file: juce_ThreadPool.h ***/


#endif
#ifndef __JUCE_TIMESLICETHREAD_JUCEHEADER__

/*** Start of inlined file: juce_TimeSliceThread.h ***/
#ifndef __JUCE_TIMESLICETHREAD_JUCEHEADER__
#define __JUCE_TIMESLICETHREAD_JUCEHEADER__

class TimeSliceThread;

/**
	Used by the TimeSliceThread class.

	To register your class with a TimeSliceThread, derive from this class and
	use the TimeSliceThread::addTimeSliceClient() method to add it to the list.

	Make sure you always call TimeSliceThread::removeTimeSliceClient() before
	deleting your client!

	@see TimeSliceThread
*/
class JUCE_API  TimeSliceClient
{
public:
	/** Destructor. */
	virtual ~TimeSliceClient()   {}

	/** Called back by a TimeSliceThread.

		When you register this class with it, a TimeSliceThread will repeatedly call
		this method.

		The implementation of this method should use its time-slice to do something that's
		quick - never block for longer than absolutely necessary.

		@returns    Your method should return the number of milliseconds which it would like to wait before being called
					again. Returning 0 will make the thread call again as soon as possible (after possibly servicing
					other busy clients). If you return a value below zero, your client will be removed from the list of clients,
					and won't be called again. The value you specify isn't a guaranteee, and is only used as a hint by the
					thread - the actual time before the next callback may be more or less than specified.
					You can force the TimeSliceThread to wake up and poll again immediately by calling its notify() method.
	*/
	virtual int useTimeSlice() = 0;

private:
	friend class TimeSliceThread;
	Time nextCallTime;
};

/**
	A thread that keeps a list of clients, and calls each one in turn, giving them
	all a chance to run some sort of short task.

	@see TimeSliceClient, Thread
*/
class JUCE_API  TimeSliceThread   : public Thread
{
public:

	/**
		Creates a TimeSliceThread.

		When first created, the thread is not running. Use the startThread()
		method to start it.
	*/
	explicit TimeSliceThread (const String& threadName);

	/** Destructor.

		Deleting a Thread object that is running will only give the thread a
		brief opportunity to stop itself cleanly, so it's recommended that you
		should always call stopThread() with a decent timeout before deleting,
		to avoid the thread being forcibly killed (which is a Bad Thing).
	*/
	~TimeSliceThread();

	/** Adds a client to the list.

		The client's callbacks will start after the number of milliseconds specified
		by millisecondsBeforeStarting (and this may happen before this method has returned).
	*/
	void addTimeSliceClient (TimeSliceClient* client, int millisecondsBeforeStarting = 0);

	/** Removes a client from the list.

		This method will make sure that all callbacks to the client have completely
		finished before the method returns.
	*/
	void removeTimeSliceClient (TimeSliceClient* client);

	/** If the given client is waiting in the queue, it will be moved to the front
		and given a time-slice as soon as possible.
		If the specified client has not been added, nothing will happen.
	*/
	void moveToFrontOfQueue (TimeSliceClient* client);

	/** Returns the number of registered clients. */
	int getNumClients() const;

	/** Returns one of the registered clients. */
	TimeSliceClient* getClient (int index) const;

   #ifndef DOXYGEN
	void run();
   #endif

private:
	CriticalSection callbackLock, listLock;
	Array <TimeSliceClient*> clients;
	TimeSliceClient* clientBeingCalled;

	TimeSliceClient* getNextClient (int index) const;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (TimeSliceThread);
};

#endif   // __JUCE_TIMESLICETHREAD_JUCEHEADER__

/*** End of inlined file: juce_TimeSliceThread.h ***/


#endif
#ifndef __JUCE_WAITABLEEVENT_JUCEHEADER__

#endif
#ifndef __JUCE_PERFORMANCECOUNTER_JUCEHEADER__

/*** Start of inlined file: juce_PerformanceCounter.h ***/
#ifndef __JUCE_PERFORMANCECOUNTER_JUCEHEADER__
#define __JUCE_PERFORMANCECOUNTER_JUCEHEADER__

/** A timer for measuring performance of code and dumping the results to a file.

	e.g. @code

		PerformanceCounter pc ("fish", 50, "/temp/myfishlog.txt");

		for (;;)
		{
			pc.start();

			doSomethingFishy();

			pc.stop();
		}
	@endcode

	In this example, the time of each period between calling start/stop will be
	measured and averaged over 50 runs, and the results printed to a file
	every 50 times round the loop.
*/
class JUCE_API  PerformanceCounter
{
public:

	/** Creates a PerformanceCounter object.

		@param counterName      the name used when printing out the statistics
		@param runsPerPrintout  the number of start/stop iterations before calling
								printStatistics()
		@param loggingFile      a file to dump the results to - if this is File::nonexistent,
								the results are just written to the debugger output
	*/
	PerformanceCounter (const String& counterName,
						int runsPerPrintout = 100,
						const File& loggingFile = File::nonexistent);

	/** Destructor. */
	~PerformanceCounter();

	/** Starts timing.

		@see stop
	*/
	void start();

	/** Stops timing and prints out the results.

		The number of iterations before doing a printout of the
		results is set in the constructor.

		@see start
	*/
	void stop();

	/** Dumps the current metrics to the debugger output and to a file.

		As well as using Logger::outputDebugString to print the results,
		this will write then to the file specified in the constructor (if
		this was valid).
	*/
	void printStatistics();

private:

	String name;
	int numRuns, runsPerPrint;
	double totalTime;
	int64 started;
	File outputFile;
};

#endif   // __JUCE_PERFORMANCECOUNTER_JUCEHEADER__

/*** End of inlined file: juce_PerformanceCounter.h ***/


#endif
#ifndef __JUCE_RELATIVETIME_JUCEHEADER__

#endif
#ifndef __JUCE_TIME_JUCEHEADER__

#endif
#ifndef __JUCE_UNITTEST_JUCEHEADER__

/*** Start of inlined file: juce_UnitTest.h ***/
#ifndef __JUCE_UNITTEST_JUCEHEADER__
#define __JUCE_UNITTEST_JUCEHEADER__

class UnitTestRunner;

/**
	This is a base class for classes that perform a unit test.

	To write a test using this class, your code should look something like this:

	@code
	class MyTest  : public UnitTest
	{
	public:
		MyTest()  : UnitTest ("Foobar testing") {}

		void runTest()
		{
			beginTest ("Part 1");

			expect (myFoobar.doesSomething());
			expect (myFoobar.doesSomethingElse());

			beginTest ("Part 2");

			expect (myOtherFoobar.doesSomething());
			expect (myOtherFoobar.doesSomethingElse());

			...etc..
		}
	};

	// Creating a static instance will automatically add the instance to the array
	// returned by UnitTest::getAllTests(), so the test will be included when you call
	// UnitTestRunner::runAllTests()
	static MyTest test;
	@endcode

	To run a test, use the UnitTestRunner class.

	@see UnitTestRunner
*/
class JUCE_API  UnitTest
{
public:

	/** Creates a test with the given name. */
	explicit UnitTest (const String& name);

	/** Destructor. */
	virtual ~UnitTest();

	/** Returns the name of the test. */
	const String& getName() const noexcept       { return name; }

	/** Runs the test, using the specified UnitTestRunner.
		You shouldn't need to call this method directly - use
		UnitTestRunner::runTests() instead.
	*/
	void performTest (UnitTestRunner* runner);

	/** Returns the set of all UnitTest objects that currently exist. */
	static Array<UnitTest*>& getAllTests();

	/** You can optionally implement this method to set up your test.
		This method will be called before runTest().
	*/
	virtual void initialise();

	/** You can optionally implement this method to clear up after your test has been run.
		This method will be called after runTest() has returned.
	*/
	virtual void shutdown();

	/** Implement this method in your subclass to actually run your tests.

		The content of your implementation should call beginTest() and expect()
		to perform the tests.
	*/
	virtual void runTest() = 0;

	/** Tells the system that a new subsection of tests is beginning.
		This should be called from your runTest() method, and may be called
		as many times as you like, to demarcate different sets of tests.
	*/
	void beginTest (const String& testName);

	/** Checks that the result of a test is true, and logs this result.

		In your runTest() method, you should call this method for each condition that
		you want to check, e.g.

		@code
		void runTest()
		{
			beginTest ("basic tests");
			expect (x + y == 2);
			expect (getThing() == someThing);
			...etc...
		}
		@endcode

		If testResult is true, a pass is logged; if it's false, a failure is logged.
		If the failure message is specified, it will be written to the log if the test fails.
	*/
	void expect (bool testResult, const String& failureMessage = String::empty);

	/** Compares two values, and if they don't match, prints out a message containing the
		expected and actual result values.
	*/
	template <class ValueType>
	void expectEquals (ValueType actual, ValueType expected, String failureMessage = String::empty)
	{
		const bool result = (actual == expected);

		if (! result)
		{
			if (failureMessage.isNotEmpty())
				failureMessage << " -- ";

			failureMessage << "Expected value: " << expected << ", Actual value: " << actual;
		}

		expect (result, failureMessage);
	}

	/** Writes a message to the test log.
		This can only be called from within your runTest() method.
	*/
	void logMessage (const String& message);

private:

	const String name;
	UnitTestRunner* runner;

	JUCE_DECLARE_NON_COPYABLE (UnitTest);
};

/**
	Runs a set of unit tests.

	You can instantiate one of these objects and use it to invoke tests on a set of
	UnitTest objects.

	By using a subclass of UnitTestRunner, you can intercept logging messages and
	perform custom behaviour when each test completes.

	@see UnitTest
*/
class JUCE_API  UnitTestRunner
{
public:

	/** */
	UnitTestRunner();

	/** Destructor. */
	virtual ~UnitTestRunner();

	/** Runs a set of tests.

		The tests are performed in order, and the results are logged. To run all the
		registered UnitTest objects that exist, use runAllTests().
	*/
	void runTests (const Array<UnitTest*>& tests);

	/** Runs all the UnitTest objects that currently exist.
		This calls runTests() for all the objects listed in UnitTest::getAllTests().
	*/
	void runAllTests();

	/** Sets a flag to indicate whether an assertion should be triggered if a test fails.
		This is true by default.
	*/
	void setAssertOnFailure (bool shouldAssert) noexcept;

	/** Sets a flag to indicate whether successful tests should be logged.
		By default, this is set to false, so that only failures will be displayed in the log.
	*/
	void setPassesAreLogged (bool shouldDisplayPasses) noexcept;

	/** Contains the results of a test.

		One of these objects is instantiated each time UnitTest::beginTest() is called, and
		it contains details of the number of subsequent UnitTest::expect() calls that are
		made.
	*/
	struct TestResult
	{
		/** The main name of this test (i.e. the name of the UnitTest object being run). */
		String unitTestName;
		/** The name of the current subcategory (i.e. the name that was set when UnitTest::beginTest() was called). */
		String subcategoryName;

		/** The number of UnitTest::expect() calls that succeeded. */
		int passes;
		/** The number of UnitTest::expect() calls that failed. */
		int failures;

		/** A list of messages describing the failed tests. */
		StringArray messages;
	};

	/** Returns the number of TestResult objects that have been performed.
		@see getResult
	*/
	int getNumResults() const noexcept;

	/** Returns one of the TestResult objects that describes a test that has been run.
		@see getNumResults
	*/
	const TestResult* getResult (int index) const noexcept;

protected:
	/** Called when the list of results changes.
		You can override this to perform some sort of behaviour when results are added.
	*/
	virtual void resultsUpdated();

	/** Logs a message about the current test progress.
		By default this just writes the message to the Logger class, but you could override
		this to do something else with the data.
	*/
	virtual void logMessage (const String& message);

	/** This can be overridden to let the runner know that it should abort the tests
		as soon as possible, e.g. because the thread needs to stop.
	*/
	virtual bool shouldAbortTests();

private:

	friend class UnitTest;

	UnitTest* currentTest;
	String currentSubCategory;
	OwnedArray <TestResult, CriticalSection> results;
	bool assertOnFailure, logPasses;

	void beginNewTest (UnitTest* test, const String& subCategory);
	void endTest();

	void addPass();
	void addFail (const String& failureMessage);

	JUCE_DECLARE_NON_COPYABLE (UnitTestRunner);
};

#endif   // __JUCE_UNITTEST_JUCEHEADER__

/*** End of inlined file: juce_UnitTest.h ***/


#endif
#ifndef __JUCE_XMLDOCUMENT_JUCEHEADER__

/*** Start of inlined file: juce_XmlDocument.h ***/
#ifndef __JUCE_XMLDOCUMENT_JUCEHEADER__
#define __JUCE_XMLDOCUMENT_JUCEHEADER__

class InputSource;

/**
	Parses a text-based XML document and creates an XmlElement object from it.

	The parser will parse DTDs to load external entities but won't
	check the document for validity against the DTD.

	e.g.
	@code

	XmlDocument myDocument (File ("myfile.xml"));
	XmlElement* mainElement = myDocument.getDocumentElement();

	if (mainElement == nullptr)
	{
		String error = myDocument.getLastParseError();
	}
	else
	{
		..use the element
	}

	@endcode

	Or you can use the static helper methods for quick parsing..

	@code
	XmlElement* xml = XmlDocument::parse (myXmlFile);

	if (xml != nullptr && xml->hasTagName ("foobar"))
	{
		...etc
	@endcode

	@see XmlElement
*/
class JUCE_API  XmlDocument
{
public:

	/** Creates an XmlDocument from the xml text.
		The text doesn't actually get parsed until the getDocumentElement() method is called.
	*/
	XmlDocument (const String& documentText);

	/** Creates an XmlDocument from a file.
		The text doesn't actually get parsed until the getDocumentElement() method is called.
	*/
	XmlDocument (const File& file);

	/** Destructor. */
	~XmlDocument();

	/** Creates an XmlElement object to represent the main document node.

		This method will do the actual parsing of the text, and if there's a
		parse error, it may returns 0 (and you can find out the error using
		the getLastParseError() method).

		See also the parse() methods, which provide a shorthand way to quickly
		parse a file or string.

		@param onlyReadOuterDocumentElement     if true, the parser will only read the
												first section of the file, and will only
												return the outer document element - this
												allows quick checking of large files to
												see if they contain the correct type of
												tag, without having to parse the entire file
		@returns    a new XmlElement which the caller will need to delete, or null if
					there was an error.
		@see getLastParseError
	*/
	XmlElement* getDocumentElement (bool onlyReadOuterDocumentElement = false);

	/** Returns the parsing error that occurred the last time getDocumentElement was called.

		@returns the error, or an empty string if there was no error.
	*/
	const String& getLastParseError() const noexcept;

	/** Sets an input source object to use for parsing documents that reference external entities.

		If the document has been created from a file, this probably won't be needed, but
		if you're parsing some text and there might be a DTD that references external
		files, you may need to create a custom input source that can retrieve the
		other files it needs.

		The object that is passed-in will be deleted automatically when no longer needed.

		@see InputSource
	*/
	void setInputSource (InputSource* newSource) noexcept;

	/** Sets a flag to change the treatment of empty text elements.

		If this is true (the default state), then any text elements that contain only
		whitespace characters will be ingored during parsing. If you need to catch
		whitespace-only text, then you should set this to false before calling the
		getDocumentElement() method.
	*/
	void setEmptyTextElementsIgnored (bool shouldBeIgnored) noexcept;

	/** A handy static method that parses a file.
		This is a shortcut for creating an XmlDocument object and calling getDocumentElement() on it.
		@returns    a new XmlElement which the caller will need to delete, or null if there was an error.
	*/
	static XmlElement* parse (const File& file);

	/** A handy static method that parses some XML data.
		This is a shortcut for creating an XmlDocument object and calling getDocumentElement() on it.
		@returns    a new XmlElement which the caller will need to delete, or null if there was an error.
	*/
	static XmlElement* parse (const String& xmlData);

private:
	String originalText;
	String::CharPointerType input;
	bool outOfData, errorOccurred;

	String lastError, dtdText;
	StringArray tokenisedDTD;
	bool needToLoadDTD, ignoreEmptyTextElements;
	ScopedPointer <InputSource> inputSource;

	void setLastError (const String& desc, bool carryOn);
	void skipHeader();
	void skipNextWhiteSpace();
	juce_wchar readNextChar() noexcept;
	XmlElement* readNextElement (bool alsoParseSubElements);
	void readChildElements (XmlElement* parent);
	int findNextTokenLength() noexcept;
	void readQuotedString (String& result);
	void readEntity (String& result);

	String getFileContents (const String& filename) const;
	String expandEntity (const String& entity);
	String expandExternalEntity (const String& entity);
	String getParameterEntity (const String& entity);

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (XmlDocument);
};

#endif   // __JUCE_XMLDOCUMENT_JUCEHEADER__

/*** End of inlined file: juce_XmlDocument.h ***/


#endif
#ifndef __JUCE_XMLELEMENT_JUCEHEADER__

#endif
#ifndef __JUCE_GZIPCOMPRESSOROUTPUTSTREAM_JUCEHEADER__

/*** Start of inlined file: juce_GZIPCompressorOutputStream.h ***/
#ifndef __JUCE_GZIPCOMPRESSOROUTPUTSTREAM_JUCEHEADER__
#define __JUCE_GZIPCOMPRESSOROUTPUTSTREAM_JUCEHEADER__

/**
	A stream which uses zlib to compress the data written into it.

	Important note: When you call flush() on a GZIPCompressorOutputStream,
	the gzip data is closed - this means that no more data can be written to
	it, and any subsequent attempts to call write() will cause an assertion.

	@see GZIPDecompressorInputStream
*/
class JUCE_API  GZIPCompressorOutputStream  : public OutputStream
{
public:

	/** Creates a compression stream.

		@param destStream                       the stream into which the compressed data should
												be written
		@param compressionLevel                 how much to compress the data, between 1 and 9, where
												1 is the fastest/lowest compression, and 9 is the
												slowest/highest compression. Any value outside this range
												indicates that a default compression level should be used.
		@param deleteDestStreamWhenDestroyed    whether or not to delete the destStream object when
												this stream is destroyed
		@param windowBits                       this is used internally to change the window size used
												by zlib - leave it as 0 unless you specifically need to set
												its value for some reason
	*/
	GZIPCompressorOutputStream (OutputStream* destStream,
								int compressionLevel = 0,
								bool deleteDestStreamWhenDestroyed = false,
								int windowBits = 0);

	/** Destructor. */
	~GZIPCompressorOutputStream();

	/** Flushes and closes the stream.
		Note that unlike most streams, when you call flush() on a GZIPCompressorOutputStream,
		the stream is closed - this means that no more data can be written to it, and any
		subsequent attempts to call write() will cause an assertion.
	*/
	void flush();

	int64 getPosition();
	bool setPosition (int64 newPosition);
	bool write (const void* destBuffer, int howMany);

	/** These are preset values that can be used for the constructor's windowBits paramter.
		For more info about this, see the zlib documentation for its windowBits parameter.
	*/
	enum WindowBitsValues
	{
		windowBitsRaw = -15,
		windowBitsGZIP = 15 + 16
	};

private:

	OptionalScopedPointer<OutputStream> destStream;

	class GZIPCompressorHelper;
	friend class ScopedPointer <GZIPCompressorHelper>;
	ScopedPointer <GZIPCompressorHelper> helper;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (GZIPCompressorOutputStream);
};

#endif   // __JUCE_GZIPCOMPRESSOROUTPUTSTREAM_JUCEHEADER__

/*** End of inlined file: juce_GZIPCompressorOutputStream.h ***/


#endif
#ifndef __JUCE_GZIPDECOMPRESSORINPUTSTREAM_JUCEHEADER__

/*** Start of inlined file: juce_GZIPDecompressorInputStream.h ***/
#ifndef __JUCE_GZIPDECOMPRESSORINPUTSTREAM_JUCEHEADER__
#define __JUCE_GZIPDECOMPRESSORINPUTSTREAM_JUCEHEADER__

/**
	This stream will decompress a source-stream using zlib.

	Tip: if you're reading lots of small items from one of these streams, you
		 can increase the performance enormously by passing it through a
		 BufferedInputStream, so that it has to read larger blocks less often.

	@see GZIPCompressorOutputStream
*/
class JUCE_API  GZIPDecompressorInputStream  : public InputStream
{
public:

	/** Creates a decompressor stream.

		@param sourceStream                 the stream to read from
		@param deleteSourceWhenDestroyed    whether or not to delete the source stream
											when this object is destroyed
		@param noWrap                       this is used internally by the ZipFile class
											and should be ignored by user applications
		@param uncompressedStreamLength     if the creator knows the length that the
											uncompressed stream will be, then it can supply this
											value, which will be returned by getTotalLength()
	*/
	GZIPDecompressorInputStream (InputStream* sourceStream,
								 bool deleteSourceWhenDestroyed,
								 bool noWrap = false,
								 int64 uncompressedStreamLength = -1);

	/** Creates a decompressor stream.

		@param sourceStream     the stream to read from - the source stream must not be
								deleted until this object has been destroyed
	*/
	GZIPDecompressorInputStream (InputStream& sourceStream);

	/** Destructor. */
	~GZIPDecompressorInputStream();

	int64 getPosition();
	bool setPosition (int64 pos);
	int64 getTotalLength();
	bool isExhausted();
	int read (void* destBuffer, int maxBytesToRead);

private:
	OptionalScopedPointer<InputStream> sourceStream;
	const int64 uncompressedStreamLength;
	const bool noWrap;
	bool isEof;
	int activeBufferSize;
	int64 originalSourcePos, currentPos;
	HeapBlock <uint8> buffer;

	class GZIPDecompressHelper;
	friend class ScopedPointer <GZIPDecompressHelper>;
	ScopedPointer <GZIPDecompressHelper> helper;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (GZIPDecompressorInputStream);
};

#endif   // __JUCE_GZIPDECOMPRESSORINPUTSTREAM_JUCEHEADER__

/*** End of inlined file: juce_GZIPDecompressorInputStream.h ***/


#endif
#ifndef __JUCE_ZIPFILE_JUCEHEADER__

/*** Start of inlined file: juce_ZipFile.h ***/
#ifndef __JUCE_ZIPFILE_JUCEHEADER__
#define __JUCE_ZIPFILE_JUCEHEADER__

/**
	Decodes a ZIP file from a stream.

	This can enumerate the items in a ZIP file and can create suitable stream objects
	to read each one.
*/
class JUCE_API  ZipFile
{
public:
	/** Creates a ZipFile based for a file. */
	ZipFile (const File& file);

	/** Creates a ZipFile for a given stream.

		@param inputStream                  the stream to read from
		@param deleteStreamWhenDestroyed    if set to true, the object passed-in
											will be deleted when this ZipFile object is deleted
	*/
	ZipFile (InputStream* inputStream, bool deleteStreamWhenDestroyed);

	/** Creates a ZipFile for a given stream.
		The stream will not be owned or deleted by this class - if you want the ZipFile to
		manage the stream's lifetime, use the other constructor.
	*/
	ZipFile (InputStream& inputStream);

	/** Creates a ZipFile for an input source.

		The inputSource object will be owned by the zip file, which will delete
		it later when not needed.
	*/
	ZipFile (InputSource* inputSource);

	/** Destructor. */
	~ZipFile();

	/**
		Contains information about one of the entries in a ZipFile.

		@see ZipFile::getEntry
	*/
	struct ZipEntry
	{
		/** The name of the file, which may also include a partial pathname. */
		String filename;

		/** The file's original size. */
		unsigned int uncompressedSize;

		/** The last time the file was modified. */
		Time fileTime;
	};

	/** Returns the number of items in the zip file. */
	int getNumEntries() const noexcept;

	/** Returns a structure that describes one of the entries in the zip file.

		This may return zero if the index is out of range.

		@see ZipFile::ZipEntry
	*/
	const ZipEntry* getEntry (int index) const noexcept;

	/** Returns the index of the first entry with a given filename.

		This uses a case-sensitive comparison to look for a filename in the
		list of entries. It might return -1 if no match is found.

		@see ZipFile::ZipEntry
	*/
	int getIndexOfFileName (const String& fileName) const noexcept;

	/** Returns a structure that describes one of the entries in the zip file.

		This uses a case-sensitive comparison to look for a filename in the
		list of entries. It might return 0 if no match is found.

		@see ZipFile::ZipEntry
	*/
	const ZipEntry* getEntry (const String& fileName) const noexcept;

	/** Sorts the list of entries, based on the filename.
	*/
	void sortEntriesByFilename();

	/** Creates a stream that can read from one of the zip file's entries.

		The stream that is returned must be deleted by the caller (and
		zero might be returned if a stream can't be opened for some reason).

		The stream must not be used after the ZipFile object that created
		has been deleted.
	*/
	InputStream* createStreamForEntry (int index);

	/** Creates a stream that can read from one of the zip file's entries.

		The stream that is returned must be deleted by the caller (and
		zero might be returned if a stream can't be opened for some reason).

		The stream must not be used after the ZipFile object that created
		has been deleted.
	*/
	InputStream* createStreamForEntry (ZipEntry& entry);

	/** Uncompresses all of the files in the zip file.

		This will expand all the entries into a target directory. The relative
		paths of the entries are used.

		@param targetDirectory      the root folder to uncompress to
		@param shouldOverwriteFiles whether to overwrite existing files with similarly-named ones
		@returns success if the file is successfully unzipped
	*/
	Result uncompressTo (const File& targetDirectory,
						 bool shouldOverwriteFiles = true);

	/** Uncompresses one of the entries from the zip file.

		This will expand the entry and write it in a target directory. The entry's path is used to
		determine which subfolder of the target should contain the new file.

		@param index                the index of the entry to uncompress - this must be a valid index
									between 0 and (getNumEntries() - 1).
		@param targetDirectory      the root folder to uncompress into
		@param shouldOverwriteFiles whether to overwrite existing files with similarly-named ones
		@returns success if all the files are successfully unzipped
	*/
	Result uncompressEntry (int index,
							const File& targetDirectory,
							bool shouldOverwriteFiles = true);

	/** Used to create a new zip file.

		Create a ZipFile::Builder object, and call its addFile() method to add some files,
		then you can write it to a stream with write().

		Currently this just stores the files with no compression.. That will be added
		soon!
	*/
	class Builder
	{
	public:
		Builder();
		~Builder();

		/** Adds a file while should be added to the archive.
			The file isn't read immediately, all the files will be read later when the writeToStream()
			method is called.

			The compressionLevel can be between 0 (no compression), and 9 (maximum compression).
			If the storedPathName parameter is specified, you can customise the partial pathname that
			will be stored for this file.
		*/
		void addFile (const File& fileToAdd, int compressionLevel,
					  const String& storedPathName = String::empty);

		/** Generates the zip file, writing it to the specified stream. */
		bool writeToStream (OutputStream& target) const;

	private:
		class Item;
		friend class OwnedArray<Item>;
		OwnedArray<Item> items;

		JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (Builder);
	};

private:

	class ZipInputStream;
	class ZipEntryHolder;
	friend class ZipInputStream;
	friend class ZipEntryHolder;

	OwnedArray <ZipEntryHolder> entries;
	CriticalSection lock;
	InputStream* inputStream;
	ScopedPointer <InputStream> streamToDelete;
	ScopedPointer <InputSource> inputSource;

   #if JUCE_DEBUG
	struct OpenStreamCounter
	{
		OpenStreamCounter() : numOpenStreams (0) {}
		~OpenStreamCounter();

		int numOpenStreams;
	};

	OpenStreamCounter streamCounter;
   #endif

	void init();

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ZipFile);
};

#endif   // __JUCE_ZIPFILE_JUCEHEADER__

/*** End of inlined file: juce_ZipFile.h ***/


#endif
// END_AUTOINCLUDE

}

#if JUCE_MSVC
 #pragma warning (pop)
 #pragma pack (pop)
#endif

#endif   // __JUCE_CORE_JUCEHEADER__

/*** End of inlined file: juce_core.h ***/

namespace juce
{

// START_AUTOINCLUDE buffers, effects, midi, sources, synthesisers
#ifndef __JUCE_AUDIODATACONVERTERS_JUCEHEADER__

/*** Start of inlined file: juce_AudioDataConverters.h ***/
#ifndef __JUCE_AUDIODATACONVERTERS_JUCEHEADER__
#define __JUCE_AUDIODATACONVERTERS_JUCEHEADER__

/**
	This class a container which holds all the classes pertaining to the AudioData::Pointer
	audio sample format class.

	@see AudioData::Pointer.
*/
class JUCE_API  AudioData
{
public:

	// These types can be used as the SampleFormat template parameter for the AudioData::Pointer class.

	class Int8;       /**< Used as a template parameter for AudioData::Pointer. Indicates an 8-bit integer packed data format. */
	class UInt8;      /**< Used as a template parameter for AudioData::Pointer. Indicates an 8-bit unsigned integer packed data format. */
	class Int16;      /**< Used as a template parameter for AudioData::Pointer. Indicates an 16-bit integer packed data format. */
	class Int24;      /**< Used as a template parameter for AudioData::Pointer. Indicates an 24-bit integer packed data format. */
	class Int32;      /**< Used as a template parameter for AudioData::Pointer. Indicates an 32-bit integer packed data format. */
	class Float32;    /**< Used as a template parameter for AudioData::Pointer. Indicates an 32-bit float data format. */

	// These types can be used as the Endianness template parameter for the AudioData::Pointer class.

	class BigEndian;      /**< Used as a template parameter for AudioData::Pointer. Indicates that the samples are stored in big-endian order. */
	class LittleEndian;   /**< Used as a template parameter for AudioData::Pointer. Indicates that the samples are stored in little-endian order. */
	class NativeEndian;   /**< Used as a template parameter for AudioData::Pointer. Indicates that the samples are stored in the CPU's native endianness. */

	// These types can be used as the InterleavingType template parameter for the AudioData::Pointer class.

	class NonInterleaved; /**< Used as a template parameter for AudioData::Pointer. Indicates that the samples are stored contiguously. */
	class Interleaved;    /**< Used as a template parameter for AudioData::Pointer. Indicates that the samples are interleaved with a number of other channels. */

	// These types can be used as the Constness template parameter for the AudioData::Pointer class.

	class NonConst; /**< Used as a template parameter for AudioData::Pointer. Indicates that the pointer can be used for non-const data. */
	class Const;    /**< Used as a template parameter for AudioData::Pointer. Indicates that the samples can only be used for const data.. */

  #ifndef DOXYGEN

	class BigEndian
	{
	public:
		template <class SampleFormatType> static inline float getAsFloat (SampleFormatType& s) noexcept                         { return s.getAsFloatBE(); }
		template <class SampleFormatType> static inline void setAsFloat (SampleFormatType& s, float newValue) noexcept          { s.setAsFloatBE (newValue); }
		template <class SampleFormatType> static inline int32 getAsInt32 (SampleFormatType& s) noexcept                         { return s.getAsInt32BE(); }
		template <class SampleFormatType> static inline void setAsInt32 (SampleFormatType& s, int32 newValue) noexcept          { s.setAsInt32BE (newValue); }
		template <class SourceType, class DestType> static inline void copyFrom (DestType& dest, SourceType& source) noexcept   { dest.copyFromBE (source); }
		enum { isBigEndian = 1 };
	};

	class LittleEndian
	{
	public:
		template <class SampleFormatType> static inline float getAsFloat (SampleFormatType& s) noexcept                         { return s.getAsFloatLE(); }
		template <class SampleFormatType> static inline void setAsFloat (SampleFormatType& s, float newValue) noexcept          { s.setAsFloatLE (newValue); }
		template <class SampleFormatType> static inline int32 getAsInt32 (SampleFormatType& s) noexcept                         { return s.getAsInt32LE(); }
		template <class SampleFormatType> static inline void setAsInt32 (SampleFormatType& s, int32 newValue) noexcept          { s.setAsInt32LE (newValue); }
		template <class SourceType, class DestType> static inline void copyFrom (DestType& dest, SourceType& source) noexcept   { dest.copyFromLE (source); }
		enum { isBigEndian = 0 };
	};

	#if JUCE_BIG_ENDIAN
	 class NativeEndian   : public BigEndian  {};
	#else
	 class NativeEndian   : public LittleEndian  {};
	#endif

	class Int8
	{
	public:
		inline Int8 (void* data_) noexcept  : data (static_cast <int8*> (data_))  {}

		inline void advance() noexcept                          { ++data; }
		inline void skip (int numSamples) noexcept              { data += numSamples; }
		inline float getAsFloatLE() const noexcept              { return (float) (*data * (1.0 / (1.0 + maxValue))); }
		inline float getAsFloatBE() const noexcept              { return getAsFloatLE(); }
		inline void setAsFloatLE (float newValue) noexcept      { *data = (int8) jlimit ((int) -maxValue, (int) maxValue, roundToInt (newValue * (1.0 + maxValue))); }
		inline void setAsFloatBE (float newValue) noexcept      { setAsFloatLE (newValue); }
		inline int32 getAsInt32LE() const noexcept              { return (int) (*data << 24); }
		inline int32 getAsInt32BE() const noexcept              { return getAsInt32LE(); }
		inline void setAsInt32LE (int newValue) noexcept        { *data = (int8) (newValue >> 24); }
		inline void setAsInt32BE (int newValue) noexcept        { setAsInt32LE (newValue); }
		inline void clear() noexcept                            { *data = 0; }
		inline void clearMultiple (int num) noexcept            { zeromem (data, (size_t) (num * bytesPerSample)) ;}
		template <class SourceType> inline void copyFromLE (SourceType& source) noexcept    { setAsInt32LE (source.getAsInt32()); }
		template <class SourceType> inline void copyFromBE (SourceType& source) noexcept    { setAsInt32BE (source.getAsInt32()); }
		inline void copyFromSameType (Int8& source) noexcept    { *data = *source.data; }

		int8* data;
		enum { bytesPerSample = 1, maxValue = 0x7f, resolution = (1 << 24), isFloat = 0 };
	};

	class UInt8
	{
	public:
		inline UInt8 (void* data_) noexcept  : data (static_cast <uint8*> (data_))  {}

		inline void advance() noexcept                          { ++data; }
		inline void skip (int numSamples) noexcept              { data += numSamples; }
		inline float getAsFloatLE() const noexcept              { return (float) ((*data - 128) * (1.0 / (1.0 + maxValue))); }
		inline float getAsFloatBE() const noexcept              { return getAsFloatLE(); }
		inline void setAsFloatLE (float newValue) noexcept      { *data = (uint8) jlimit (0, 255, 128 + roundToInt (newValue * (1.0 + maxValue))); }
		inline void setAsFloatBE (float newValue) noexcept      { setAsFloatLE (newValue); }
		inline int32 getAsInt32LE() const noexcept              { return (int) ((*data - 128) << 24); }
		inline int32 getAsInt32BE() const noexcept              { return getAsInt32LE(); }
		inline void setAsInt32LE (int newValue) noexcept        { *data = (uint8) (128 + (newValue >> 24)); }
		inline void setAsInt32BE (int newValue) noexcept        { setAsInt32LE (newValue); }
		inline void clear() noexcept                            { *data = 128; }
		inline void clearMultiple (int num) noexcept            { memset (data, 128, (size_t) num) ;}
		template <class SourceType> inline void copyFromLE (SourceType& source) noexcept    { setAsInt32LE (source.getAsInt32()); }
		template <class SourceType> inline void copyFromBE (SourceType& source) noexcept    { setAsInt32BE (source.getAsInt32()); }
		inline void copyFromSameType (UInt8& source) noexcept   { *data = *source.data; }

		uint8* data;
		enum { bytesPerSample = 1, maxValue = 0x7f, resolution = (1 << 24), isFloat = 0 };
	};

	class Int16
	{
	public:
		inline Int16 (void* data_) noexcept  : data (static_cast <uint16*> (data_))  {}

		inline void advance() noexcept                          { ++data; }
		inline void skip (int numSamples) noexcept              { data += numSamples; }
		inline float getAsFloatLE() const noexcept              { return (float) ((1.0 / (1.0 + maxValue)) * (int16) ByteOrder::swapIfBigEndian (*data)); }
		inline float getAsFloatBE() const noexcept              { return (float) ((1.0 / (1.0 + maxValue)) * (int16) ByteOrder::swapIfLittleEndian (*data)); }
		inline void setAsFloatLE (float newValue) noexcept      { *data = ByteOrder::swapIfBigEndian ((uint16) jlimit ((int) -maxValue, (int) maxValue, roundToInt (newValue * (1.0 + maxValue)))); }
		inline void setAsFloatBE (float newValue) noexcept      { *data = ByteOrder::swapIfLittleEndian ((uint16) jlimit ((int) -maxValue, (int) maxValue, roundToInt (newValue * (1.0 + maxValue)))); }
		inline int32 getAsInt32LE() const noexcept              { return (int32) (ByteOrder::swapIfBigEndian ((uint16) *data) << 16); }
		inline int32 getAsInt32BE() const noexcept              { return (int32) (ByteOrder::swapIfLittleEndian ((uint16) *data) << 16); }
		inline void setAsInt32LE (int32 newValue) noexcept      { *data = ByteOrder::swapIfBigEndian ((uint16) (newValue >> 16)); }
		inline void setAsInt32BE (int32 newValue) noexcept      { *data = ByteOrder::swapIfLittleEndian ((uint16) (newValue >> 16)); }
		inline void clear() noexcept                            { *data = 0; }
		inline void clearMultiple (int num) noexcept            { zeromem (data, (size_t) (num * bytesPerSample)) ;}
		template <class SourceType> inline void copyFromLE (SourceType& source) noexcept    { setAsInt32LE (source.getAsInt32()); }
		template <class SourceType> inline void copyFromBE (SourceType& source) noexcept    { setAsInt32BE (source.getAsInt32()); }
		inline void copyFromSameType (Int16& source) noexcept   { *data = *source.data; }

		uint16* data;
		enum { bytesPerSample = 2, maxValue = 0x7fff, resolution = (1 << 16), isFloat = 0 };
	};

	class Int24
	{
	public:
		inline Int24 (void* data_) noexcept  : data (static_cast <char*> (data_))  {}

		inline void advance() noexcept                          { data += 3; }
		inline void skip (int numSamples) noexcept              { data += 3 * numSamples; }
		inline float getAsFloatLE() const noexcept              { return (float) (ByteOrder::littleEndian24Bit (data) * (1.0 / (1.0 + maxValue))); }
		inline float getAsFloatBE() const noexcept              { return (float) (ByteOrder::bigEndian24Bit (data) * (1.0 / (1.0 + maxValue))); }
		inline void setAsFloatLE (float newValue) noexcept      { ByteOrder::littleEndian24BitToChars (jlimit ((int) -maxValue, (int) maxValue, roundToInt (newValue * (1.0 + maxValue))), data); }
		inline void setAsFloatBE (float newValue) noexcept      { ByteOrder::bigEndian24BitToChars (jlimit ((int) -maxValue, (int) maxValue, roundToInt (newValue * (1.0 + maxValue))), data); }
		inline int32 getAsInt32LE() const noexcept              { return (int32) ByteOrder::littleEndian24Bit (data) << 8; }
		inline int32 getAsInt32BE() const noexcept              { return (int32) ByteOrder::bigEndian24Bit (data) << 8; }
		inline void setAsInt32LE (int32 newValue) noexcept      { ByteOrder::littleEndian24BitToChars (newValue >> 8, data); }
		inline void setAsInt32BE (int32 newValue) noexcept      { ByteOrder::bigEndian24BitToChars (newValue >> 8, data); }
		inline void clear() noexcept                            { data[0] = 0; data[1] = 0; data[2] = 0; }
		inline void clearMultiple (int num) noexcept            { zeromem (data, (size_t) (num * bytesPerSample)) ;}
		template <class SourceType> inline void copyFromLE (SourceType& source) noexcept    { setAsInt32LE (source.getAsInt32()); }
		template <class SourceType> inline void copyFromBE (SourceType& source) noexcept    { setAsInt32BE (source.getAsInt32()); }
		inline void copyFromSameType (Int24& source) noexcept   { data[0] = source.data[0]; data[1] = source.data[1]; data[2] = source.data[2]; }

		char* data;
		enum { bytesPerSample = 3, maxValue = 0x7fffff, resolution = (1 << 8), isFloat = 0 };
	};

	class Int32
	{
	public:
		inline Int32 (void* data_) noexcept  : data (static_cast <uint32*> (data_))  {}

		inline void advance() noexcept                          { ++data; }
		inline void skip (int numSamples) noexcept              { data += numSamples; }
		inline float getAsFloatLE() const noexcept              { return (float) ((1.0 / (1.0 + maxValue)) * (int32) ByteOrder::swapIfBigEndian (*data)); }
		inline float getAsFloatBE() const noexcept              { return (float) ((1.0 / (1.0 + maxValue)) * (int32) ByteOrder::swapIfLittleEndian (*data)); }
		inline void setAsFloatLE (float newValue) noexcept      { *data = ByteOrder::swapIfBigEndian ((uint32) (maxValue * jlimit (-1.0, 1.0, (double) newValue))); }
		inline void setAsFloatBE (float newValue) noexcept      { *data = ByteOrder::swapIfLittleEndian ((uint32) (maxValue * jlimit (-1.0, 1.0, (double) newValue))); }
		inline int32 getAsInt32LE() const noexcept              { return (int32) ByteOrder::swapIfBigEndian (*data); }
		inline int32 getAsInt32BE() const noexcept              { return (int32) ByteOrder::swapIfLittleEndian (*data); }
		inline void setAsInt32LE (int32 newValue) noexcept      { *data = ByteOrder::swapIfBigEndian ((uint32) newValue); }
		inline void setAsInt32BE (int32 newValue) noexcept      { *data = ByteOrder::swapIfLittleEndian ((uint32) newValue); }
		inline void clear() noexcept                            { *data = 0; }
		inline void clearMultiple (int num) noexcept            { zeromem (data, (size_t) (num * bytesPerSample)) ;}
		template <class SourceType> inline void copyFromLE (SourceType& source) noexcept    { setAsInt32LE (source.getAsInt32()); }
		template <class SourceType> inline void copyFromBE (SourceType& source) noexcept    { setAsInt32BE (source.getAsInt32()); }
		inline void copyFromSameType (Int32& source) noexcept   { *data = *source.data; }

		uint32* data;
		enum { bytesPerSample = 4, maxValue = 0x7fffffff, resolution = 1, isFloat = 0 };
	};

	class Float32
	{
	public:
		inline Float32 (void* data_) noexcept : data (static_cast <float*> (data_))  {}

		inline void advance() noexcept                          { ++data; }
		inline void skip (int numSamples) noexcept              { data += numSamples; }
	   #if JUCE_BIG_ENDIAN
		inline float getAsFloatBE() const noexcept              { return *data; }
		inline void setAsFloatBE (float newValue) noexcept      { *data = newValue; }
		inline float getAsFloatLE() const noexcept              { union { uint32 asInt; float asFloat; } n; n.asInt = ByteOrder::swap (*(uint32*) data); return n.asFloat; }
		inline void setAsFloatLE (float newValue) noexcept      { union { uint32 asInt; float asFloat; } n; n.asFloat = newValue; *(uint32*) data = ByteOrder::swap (n.asInt); }
	   #else
		inline float getAsFloatLE() const noexcept              { return *data; }
		inline void setAsFloatLE (float newValue) noexcept      { *data = newValue; }
		inline float getAsFloatBE() const noexcept              { union { uint32 asInt; float asFloat; } n; n.asInt = ByteOrder::swap (*(uint32*) data); return n.asFloat; }
		inline void setAsFloatBE (float newValue) noexcept      { union { uint32 asInt; float asFloat; } n; n.asFloat = newValue; *(uint32*) data = ByteOrder::swap (n.asInt); }
	   #endif
		inline int32 getAsInt32LE() const noexcept              { return (int32) roundToInt (jlimit (-1.0, 1.0, (double) getAsFloatLE()) * (double) maxValue); }
		inline int32 getAsInt32BE() const noexcept              { return (int32) roundToInt (jlimit (-1.0, 1.0, (double) getAsFloatBE()) * (double) maxValue); }
		inline void setAsInt32LE (int32 newValue) noexcept      { setAsFloatLE ((float) (newValue * (1.0 / (1.0 + maxValue)))); }
		inline void setAsInt32BE (int32 newValue) noexcept      { setAsFloatBE ((float) (newValue * (1.0 / (1.0 + maxValue)))); }
		inline void clear() noexcept                            { *data = 0; }
		inline void clearMultiple (int num) noexcept            { zeromem (data, (size_t) (num * bytesPerSample)) ;}
		template <class SourceType> inline void copyFromLE (SourceType& source) noexcept    { setAsFloatLE (source.getAsFloat()); }
		template <class SourceType> inline void copyFromBE (SourceType& source) noexcept    { setAsFloatBE (source.getAsFloat()); }
		inline void copyFromSameType (Float32& source) noexcept { *data = *source.data; }

		float* data;
		enum { bytesPerSample = 4, maxValue = 0x7fffffff, resolution = (1 << 8), isFloat = 1 };
	};

	class NonInterleaved
	{
	public:
		inline NonInterleaved() noexcept {}
		inline NonInterleaved (const NonInterleaved&) noexcept {}
		inline NonInterleaved (const int) noexcept {}
		inline void copyFrom (const NonInterleaved&) noexcept {}
		template <class SampleFormatType> inline void advanceData (SampleFormatType& s) noexcept                    { s.advance(); }
		template <class SampleFormatType> inline void advanceDataBy (SampleFormatType& s, int numSamples) noexcept  { s.skip (numSamples); }
		template <class SampleFormatType> inline void clear (SampleFormatType& s, int numSamples) noexcept          { s.clearMultiple (numSamples); }
		template <class SampleFormatType> inline static int getNumBytesBetweenSamples (const SampleFormatType&) noexcept { return SampleFormatType::bytesPerSample; }

		enum { isInterleavedType = 0, numInterleavedChannels = 1 };
	};

	class Interleaved
	{
	public:
		inline Interleaved() noexcept : numInterleavedChannels (1) {}
		inline Interleaved (const Interleaved& other) noexcept : numInterleavedChannels (other.numInterleavedChannels) {}
		inline Interleaved (const int numInterleavedChannels_) noexcept : numInterleavedChannels (numInterleavedChannels_) {}
		inline void copyFrom (const Interleaved& other) noexcept { numInterleavedChannels = other.numInterleavedChannels; }
		template <class SampleFormatType> inline void advanceData (SampleFormatType& s) noexcept                    { s.skip (numInterleavedChannels); }
		template <class SampleFormatType> inline void advanceDataBy (SampleFormatType& s, int numSamples) noexcept  { s.skip (numInterleavedChannels * numSamples); }
		template <class SampleFormatType> inline void clear (SampleFormatType& s, int numSamples) noexcept          { while (--numSamples >= 0) { s.clear(); s.skip (numInterleavedChannels); } }
		template <class SampleFormatType> inline int getNumBytesBetweenSamples (const SampleFormatType&) const noexcept { return numInterleavedChannels * SampleFormatType::bytesPerSample; }
		int numInterleavedChannels;
		enum { isInterleavedType = 1 };
	};

	class NonConst
	{
	public:
		typedef void VoidType;
		static inline void* toVoidPtr (VoidType* v) noexcept { return v; }
		enum { isConst = 0 };
	};

	class Const
	{
	public:
		typedef const void VoidType;
		static inline void* toVoidPtr (VoidType* v) noexcept { return const_cast <void*> (v); }
		enum { isConst = 1 };
	};
  #endif

	/**
		A pointer to a block of audio data with a particular encoding.

		This object can be used to read and write from blocks of encoded audio samples. To create one, you specify
		the audio format as a series of template parameters, e.g.
		@code
		// this creates a pointer for reading from a const array of 16-bit little-endian packed samples.
		AudioData::Pointer <AudioData::Int16,
							AudioData::LittleEndian,
							AudioData::NonInterleaved,
							AudioData::Const> pointer (someRawAudioData);

		// These methods read the sample that is being pointed to
		float firstSampleAsFloat = pointer.getAsFloat();
		int32 firstSampleAsInt = pointer.getAsInt32();
		++pointer; // moves the pointer to the next sample.
		pointer += 3; // skips the next 3 samples.
		@endcode

		The convertSamples() method lets you copy a range of samples from one format to another, automatically
		converting its format.

		@see AudioData::Converter
	*/
	template <typename SampleFormat,
			  typename Endianness,
			  typename InterleavingType,
			  typename Constness>
	class Pointer  : private InterleavingType  // (inherited for EBCO)
	{
	public:

		/** Creates a non-interleaved pointer from some raw data in the appropriate format.
			This constructor is only used if you've specified the AudioData::NonInterleaved option -
			for interleaved formats, use the constructor that also takes a number of channels.
		*/
		Pointer (typename Constness::VoidType* sourceData) noexcept
			: data (Constness::toVoidPtr (sourceData))
		{
			// If you're using interleaved data, call the other constructor! If you're using non-interleaved data,
			// you should pass NonInterleaved as the template parameter for the interleaving type!
			static_jassert (InterleavingType::isInterleavedType == 0);
		}

		/** Creates a pointer from some raw data in the appropriate format with the specified number of interleaved channels.
			For non-interleaved data, use the other constructor.
		*/
		Pointer (typename Constness::VoidType* sourceData, int numInterleavedChannels) noexcept
			: InterleavingType (numInterleavedChannels), data (Constness::toVoidPtr (sourceData))
		{
		}

		/** Creates a copy of another pointer. */
		Pointer (const Pointer& other) noexcept
			: InterleavingType (other), data (other.data)
		{
		}

		Pointer& operator= (const Pointer& other) noexcept
		{
			InterleavingType::operator= (other);
			data = other.data;
			return *this;
		}

		/** Returns the value of the first sample as a floating point value.
			The value will be in the range -1.0 to 1.0 for integer formats. For floating point
			formats, the value could be outside that range, although -1 to 1 is the standard range.
		*/
		inline float getAsFloat() const noexcept                { return Endianness::getAsFloat (data); }

		/** Sets the value of the first sample as a floating point value.

			(This method can only be used if the AudioData::NonConst option was used).
			The value should be in the range -1.0 to 1.0 - for integer formats, values outside that
			range will be clipped. For floating point formats, any value passed in here will be
			written directly, although -1 to 1 is the standard range.
		*/
		inline void setAsFloat (float newValue) noexcept
		{
			static_jassert (Constness::isConst == 0); // trying to write to a const pointer! For a writeable one, use AudioData::NonConst instead!
			Endianness::setAsFloat (data, newValue);
		}

		/** Returns the value of the first sample as a 32-bit integer.
			The value returned will be in the range 0x80000000 to 0x7fffffff, and shorter values will be
			shifted to fill this range (e.g. if you're reading from 24-bit data, the values will be shifted up
			by 8 bits when returned here). If the source data is floating point, values beyond -1.0 to 1.0 will
			be clipped so that -1.0 maps onto -0x7fffffff and 1.0 maps to 0x7fffffff.
		*/
		inline int32 getAsInt32() const noexcept                { return Endianness::getAsInt32 (data); }

		/** Sets the value of the first sample as a 32-bit integer.
			This will be mapped to the range of the format that is being written - see getAsInt32().
		*/
		inline void setAsInt32 (int32 newValue) noexcept
		{
			static_jassert (Constness::isConst == 0); // trying to write to a const pointer! For a writeable one, use AudioData::NonConst instead!
			Endianness::setAsInt32 (data, newValue);
		}

		/** Moves the pointer along to the next sample. */
		inline Pointer& operator++() noexcept                   { advance(); return *this; }

		/** Moves the pointer back to the previous sample. */
		inline Pointer& operator--() noexcept                   { this->advanceDataBy (data, -1); return *this; }

		/** Adds a number of samples to the pointer's position. */
		Pointer& operator+= (int samplesToJump) noexcept        { this->advanceDataBy (data, samplesToJump); return *this; }

		/** Writes a stream of samples into this pointer from another pointer.
			This will copy the specified number of samples, converting between formats appropriately.
		*/
		void convertSamples (Pointer source, int numSamples) const noexcept
		{
			static_jassert (Constness::isConst == 0); // trying to write to a const pointer! For a writeable one, use AudioData::NonConst instead!

			Pointer dest (*this);
			while (--numSamples >= 0)
			{
				dest.data.copyFromSameType (source.data);
				dest.advance();
				source.advance();
			}
		}

		/** Writes a stream of samples into this pointer from another pointer.
			This will copy the specified number of samples, converting between formats appropriately.
		*/
		template <class OtherPointerType>
		void convertSamples (OtherPointerType source, int numSamples) const noexcept
		{
			static_jassert (Constness::isConst == 0); // trying to write to a const pointer! For a writeable one, use AudioData::NonConst instead!

			Pointer dest (*this);

			if (source.getRawData() != getRawData() || source.getNumBytesBetweenSamples() >= getNumBytesBetweenSamples())
			{
				while (--numSamples >= 0)
				{
					Endianness::copyFrom (dest.data, source);
					dest.advance();
					++source;
				}
			}
			else // copy backwards if we're increasing the sample width..
			{
				dest += numSamples;
				source += numSamples;

				while (--numSamples >= 0)
					Endianness::copyFrom ((--dest).data, --source);
			}
		}

		/** Sets a number of samples to zero. */
		void clearSamples (int numSamples) const noexcept
		{
			Pointer dest (*this);
			dest.clear (dest.data, numSamples);
		}

		/** Returns true if the pointer is using a floating-point format. */
		static bool isFloatingPoint() noexcept                  { return (bool) SampleFormat::isFloat; }

		/** Returns true if the format is big-endian. */
		static bool isBigEndian() noexcept                      { return (bool) Endianness::isBigEndian; }

		/** Returns the number of bytes in each sample (ignoring the number of interleaved channels). */
		static int getBytesPerSample() noexcept                 { return (int) SampleFormat::bytesPerSample; }

		/** Returns the number of interleaved channels in the format. */
		int getNumInterleavedChannels() const noexcept          { return (int) this->numInterleavedChannels; }

		/** Returns the number of bytes between the start address of each sample. */
		int getNumBytesBetweenSamples() const noexcept          { return InterleavingType::getNumBytesBetweenSamples (data); }

		/** Returns the accuracy of this format when represented as a 32-bit integer.
			This is the smallest number above 0 that can be represented in the sample format, converted to
			a 32-bit range. E,g. if the format is 8-bit, its resolution is 0x01000000; if the format is 24-bit,
			its resolution is 0x100.
		*/
		static int get32BitResolution() noexcept                { return (int) SampleFormat::resolution; }

		/** Returns a pointer to the underlying data. */
		const void* getRawData() const noexcept                 { return data.data; }

	private:

		SampleFormat data;

		inline void advance() noexcept                          { this->advanceData (data); }

		Pointer operator++ (int); // private to force you to use the more efficient pre-increment!
		Pointer operator-- (int);
	};

	/** A base class for objects that are used to convert between two different sample formats.

		The AudioData::ConverterInstance implements this base class and can be templated, so
		you can create an instance that converts between two particular formats, and then
		store this in the abstract base class.

		@see AudioData::ConverterInstance
	*/
	class Converter
	{
	public:
		virtual ~Converter() {}

		/** Converts a sequence of samples from the converter's source format into the dest format. */
		virtual void convertSamples (void* destSamples, const void* sourceSamples, int numSamples) const = 0;

		/** Converts a sequence of samples from the converter's source format into the dest format.
			This method takes sub-channel indexes, which can be used with interleaved formats in order to choose a
			particular sub-channel of the data to be used.
		*/
		virtual void convertSamples (void* destSamples, int destSubChannel,
									 const void* sourceSamples, int sourceSubChannel, int numSamples) const = 0;
	};

	/**
		A class that converts between two templated AudioData::Pointer types, and which
		implements the AudioData::Converter interface.

		This can be used as a concrete instance of the AudioData::Converter abstract class.

		@see AudioData::Converter
	*/
	template <class SourceSampleType, class DestSampleType>
	class ConverterInstance  : public Converter
	{
	public:
		ConverterInstance (int numSourceChannels = 1, int numDestChannels = 1)
			: sourceChannels (numSourceChannels), destChannels (numDestChannels)
		{}

		~ConverterInstance() {}

		void convertSamples (void* dest, const void* source, int numSamples) const
		{
			SourceSampleType s (source, sourceChannels);
			DestSampleType d (dest, destChannels);
			d.convertSamples (s, numSamples);
		}

		void convertSamples (void* dest, int destSubChannel,
							 const void* source, int sourceSubChannel, int numSamples) const
		{
			jassert (destSubChannel < destChannels && sourceSubChannel < sourceChannels);

			SourceSampleType s (addBytesToPointer (source, sourceSubChannel * SourceSampleType::getBytesPerSample()), sourceChannels);
			DestSampleType d (addBytesToPointer (dest, destSubChannel * DestSampleType::getBytesPerSample()), destChannels);
			d.convertSamples (s, numSamples);
		}

	private:
		JUCE_DECLARE_NON_COPYABLE (ConverterInstance);

		const int sourceChannels, destChannels;
	};
};

/**
	A set of routines to convert buffers of 32-bit floating point data to and from
	various integer formats.

	Note that these functions are deprecated - the AudioData class provides a much more
	flexible set of conversion classes now.
*/
class JUCE_API  AudioDataConverters
{
public:

	static void convertFloatToInt16LE (const float* source, void* dest, int numSamples, int destBytesPerSample = 2);
	static void convertFloatToInt16BE (const float* source, void* dest, int numSamples, int destBytesPerSample = 2);

	static void convertFloatToInt24LE (const float* source, void* dest, int numSamples, int destBytesPerSample = 3);
	static void convertFloatToInt24BE (const float* source, void* dest, int numSamples, int destBytesPerSample = 3);

	static void convertFloatToInt32LE (const float* source, void* dest, int numSamples, int destBytesPerSample = 4);
	static void convertFloatToInt32BE (const float* source, void* dest, int numSamples, int destBytesPerSample = 4);

	static void convertFloatToFloat32LE (const float* source, void* dest, int numSamples, int destBytesPerSample = 4);
	static void convertFloatToFloat32BE (const float* source, void* dest, int numSamples, int destBytesPerSample = 4);

	static void convertInt16LEToFloat (const void* source, float* dest, int numSamples, int srcBytesPerSample = 2);
	static void convertInt16BEToFloat (const void* source, float* dest, int numSamples, int srcBytesPerSample = 2);

	static void convertInt24LEToFloat (const void* source, float* dest, int numSamples, int srcBytesPerSample = 3);
	static void convertInt24BEToFloat (const void* source, float* dest, int numSamples, int srcBytesPerSample = 3);

	static void convertInt32LEToFloat (const void* source, float* dest, int numSamples, int srcBytesPerSample = 4);
	static void convertInt32BEToFloat (const void* source, float* dest, int numSamples, int srcBytesPerSample = 4);

	static void convertFloat32LEToFloat (const void* source, float* dest, int numSamples, int srcBytesPerSample = 4);
	static void convertFloat32BEToFloat (const void* source, float* dest, int numSamples, int srcBytesPerSample = 4);

	enum DataFormat
	{
		int16LE,
		int16BE,
		int24LE,
		int24BE,
		int32LE,
		int32BE,
		float32LE,
		float32BE,
	};

	static void convertFloatToFormat (DataFormat destFormat,
									  const float* source, void* dest, int numSamples);

	static void convertFormatToFloat (DataFormat sourceFormat,
									  const void* source, float* dest, int numSamples);

	static void interleaveSamples (const float** source, float* dest,
								   int numSamples, int numChannels);

	static void deinterleaveSamples (const float* source, float** dest,
									 int numSamples, int numChannels);

private:
	AudioDataConverters();
	JUCE_DECLARE_NON_COPYABLE (AudioDataConverters);
};

#endif   // __JUCE_AUDIODATACONVERTERS_JUCEHEADER__

/*** End of inlined file: juce_AudioDataConverters.h ***/


#endif
#ifndef __JUCE_AUDIOSAMPLEBUFFER_JUCEHEADER__

/*** Start of inlined file: juce_AudioSampleBuffer.h ***/
#ifndef __JUCE_AUDIOSAMPLEBUFFER_JUCEHEADER__
#define __JUCE_AUDIOSAMPLEBUFFER_JUCEHEADER__

/**
	A multi-channel buffer of 32-bit floating point audio samples.

*/
class JUCE_API  AudioSampleBuffer
{
public:

	/** Creates a buffer with a specified number of channels and samples.

		The contents of the buffer will initially be undefined, so use clear() to
		set all the samples to zero.

		The buffer will allocate its memory internally, and this will be released
		when the buffer is deleted. If the memory can't be allocated, this will
		throw a std::bad_alloc exception.
	*/
	AudioSampleBuffer (int numChannels,
					   int numSamples) noexcept;

	/** Creates a buffer using a pre-allocated block of memory.

		Note that if the buffer is resized or its number of channels is changed, it
		will re-allocate memory internally and copy the existing data to this new area,
		so it will then stop directly addressing this memory.

		@param dataToReferTo    a pre-allocated array containing pointers to the data
								for each channel that should be used by this buffer. The
								buffer will only refer to this memory, it won't try to delete
								it when the buffer is deleted or resized.
		@param numChannels      the number of channels to use - this must correspond to the
								number of elements in the array passed in
		@param numSamples       the number of samples to use - this must correspond to the
								size of the arrays passed in
	*/
	AudioSampleBuffer (float** dataToReferTo,
					   int numChannels,
					   int numSamples) noexcept;

	/** Creates a buffer using a pre-allocated block of memory.

		Note that if the buffer is resized or its number of channels is changed, it
		will re-allocate memory internally and copy the existing data to this new area,
		so it will then stop directly addressing this memory.

		@param dataToReferTo    a pre-allocated array containing pointers to the data
								for each channel that should be used by this buffer. The
								buffer will only refer to this memory, it won't try to delete
								it when the buffer is deleted or resized.
		@param numChannels      the number of channels to use - this must correspond to the
								number of elements in the array passed in
		@param startSample      the offset within the arrays at which the data begins
		@param numSamples       the number of samples to use - this must correspond to the
								size of the arrays passed in
	*/
	AudioSampleBuffer (float** dataToReferTo,
					   int numChannels,
					   int startSample,
					   int numSamples) noexcept;

	/** Copies another buffer.

		This buffer will make its own copy of the other's data, unless the buffer was created
		using an external data buffer, in which case boths buffers will just point to the same
		shared block of data.
	*/
	AudioSampleBuffer (const AudioSampleBuffer& other) noexcept;

	/** Copies another buffer onto this one.

		This buffer's size will be changed to that of the other buffer.
	*/
	AudioSampleBuffer& operator= (const AudioSampleBuffer& other) noexcept;

	/** Destructor.

		This will free any memory allocated by the buffer.
	*/
	virtual ~AudioSampleBuffer() noexcept;

	/** Returns the number of channels of audio data that this buffer contains.

		@see getSampleData
	*/
	int getNumChannels() const noexcept     { return numChannels; }

	/** Returns the number of samples allocated in each of the buffer's channels.

		@see getSampleData
	*/
	int getNumSamples() const noexcept      { return size; }

	/** Returns a pointer one of the buffer's channels.

		For speed, this doesn't check whether the channel number is out of range,
		so be careful when using it!
	*/
	float* getSampleData (const int channelNumber) const noexcept
	{
		jassert (isPositiveAndBelow (channelNumber, numChannels));
		return channels [channelNumber];
	}

	/** Returns a pointer to a sample in one of the buffer's channels.

		For speed, this doesn't check whether the channel and sample number
		are out-of-range, so be careful when using it!
	*/
	float* getSampleData (const int channelNumber,
						  const int sampleOffset) const noexcept
	{
		jassert (isPositiveAndBelow (channelNumber, numChannels));
		jassert (isPositiveAndBelow (sampleOffset, size));
		return channels [channelNumber] + sampleOffset;
	}

	/** Returns an array of pointers to the channels in the buffer.

		Don't modify any of the pointers that are returned, and bear in mind that
		these will become invalid if the buffer is resized.
	*/
	float** getArrayOfChannels() const noexcept         { return channels; }

	/** Changes the buffer's size or number of channels.

		This can expand or contract the buffer's length, and add or remove channels.

		If keepExistingContent is true, it will try to preserve as much of the
		old data as it can in the new buffer.

		If clearExtraSpace is true, then any extra channels or space that is
		allocated will be also be cleared. If false, then this space is left
		uninitialised.

		If avoidReallocating is true, then changing the buffer's size won't reduce the
		amount of memory that is currently allocated (but it will still increase it if
		the new size is bigger than the amount it currently has). If this is false, then
		a new allocation will be done so that the buffer uses takes up the minimum amount
		of memory that it needs.

		If the required memory can't be allocated, this will throw a std::bad_alloc exception.
	*/
	void setSize (int newNumChannels,
				  int newNumSamples,
				  bool keepExistingContent = false,
				  bool clearExtraSpace = false,
				  bool avoidReallocating = false) noexcept;

	/** Makes this buffer point to a pre-allocated set of channel data arrays.

		There's also a constructor that lets you specify arrays like this, but this
		lets you change the channels dynamically.

		Note that if the buffer is resized or its number of channels is changed, it
		will re-allocate memory internally and copy the existing data to this new area,
		so it will then stop directly addressing this memory.

		@param dataToReferTo    a pre-allocated array containing pointers to the data
								for each channel that should be used by this buffer. The
								buffer will only refer to this memory, it won't try to delete
								it when the buffer is deleted or resized.
		@param numChannels      the number of channels to use - this must correspond to the
								number of elements in the array passed in
		@param numSamples       the number of samples to use - this must correspond to the
								size of the arrays passed in
	*/
	void setDataToReferTo (float** dataToReferTo,
						   int numChannels,
						   int numSamples) noexcept;

	/** Clears all the samples in all channels. */
	void clear() noexcept;

	/** Clears a specified region of all the channels.

		For speed, this doesn't check whether the channel and sample number
		are in-range, so be careful!
	*/
	void clear (int startSample,
				int numSamples) noexcept;

	/** Clears a specified region of just one channel.

		For speed, this doesn't check whether the channel and sample number
		are in-range, so be careful!
	*/
	void clear (int channel,
				int startSample,
				int numSamples) noexcept;

	/** Applies a gain multiple to a region of one channel.

		For speed, this doesn't check whether the channel and sample number
		are in-range, so be careful!
	*/
	void applyGain (int channel,
					int startSample,
					int numSamples,
					float gain) noexcept;

	/** Applies a gain multiple to a region of all the channels.

		For speed, this doesn't check whether the sample numbers
		are in-range, so be careful!
	*/
	void applyGain (int startSample,
					int numSamples,
					float gain) noexcept;

	/** Applies a range of gains to a region of a channel.

		The gain that is applied to each sample will vary from
		startGain on the first sample to endGain on the last Sample,
		so it can be used to do basic fades.

		For speed, this doesn't check whether the sample numbers
		are in-range, so be careful!
	*/
	void applyGainRamp (int channel,
						int startSample,
						int numSamples,
						float startGain,
						float endGain) noexcept;

	/** Adds samples from another buffer to this one.

		@param destChannel          the channel within this buffer to add the samples to
		@param destStartSample      the start sample within this buffer's channel
		@param source               the source buffer to add from
		@param sourceChannel        the channel within the source buffer to read from
		@param sourceStartSample    the offset within the source buffer's channel to start reading samples from
		@param numSamples           the number of samples to process
		@param gainToApplyToSource  an optional gain to apply to the source samples before they are
									added to this buffer's samples

		@see copyFrom
	*/
	void addFrom (int destChannel,
				  int destStartSample,
				  const AudioSampleBuffer& source,
				  int sourceChannel,
				  int sourceStartSample,
				  int numSamples,
				  float gainToApplyToSource = 1.0f) noexcept;

	/** Adds samples from an array of floats to one of the channels.

		@param destChannel          the channel within this buffer to add the samples to
		@param destStartSample      the start sample within this buffer's channel
		@param source               the source data to use
		@param numSamples           the number of samples to process
		@param gainToApplyToSource  an optional gain to apply to the source samples before they are
									added to this buffer's samples

		@see copyFrom
	*/
	void addFrom (int destChannel,
				  int destStartSample,
				  const float* source,
				  int numSamples,
				  float gainToApplyToSource = 1.0f) noexcept;

	/** Adds samples from an array of floats, applying a gain ramp to them.

		@param destChannel          the channel within this buffer to add the samples to
		@param destStartSample      the start sample within this buffer's channel
		@param source               the source data to use
		@param numSamples           the number of samples to process
		@param startGain            the gain to apply to the first sample (this is multiplied with
									the source samples before they are added to this buffer)
		@param endGain              the gain to apply to the final sample. The gain is linearly
									interpolated between the first and last samples.
	*/
	void addFromWithRamp (int destChannel,
						  int destStartSample,
						  const float* source,
						  int numSamples,
						  float startGain,
						  float endGain) noexcept;

	/** Copies samples from another buffer to this one.

		@param destChannel          the channel within this buffer to copy the samples to
		@param destStartSample      the start sample within this buffer's channel
		@param source               the source buffer to read from
		@param sourceChannel        the channel within the source buffer to read from
		@param sourceStartSample    the offset within the source buffer's channel to start reading samples from
		@param numSamples           the number of samples to process

		@see addFrom
	*/
	void copyFrom (int destChannel,
				   int destStartSample,
				   const AudioSampleBuffer& source,
				   int sourceChannel,
				   int sourceStartSample,
				   int numSamples) noexcept;

	/** Copies samples from an array of floats into one of the channels.

		@param destChannel          the channel within this buffer to copy the samples to
		@param destStartSample      the start sample within this buffer's channel
		@param source               the source buffer to read from
		@param numSamples           the number of samples to process

		@see addFrom
	*/
	void copyFrom (int destChannel,
				   int destStartSample,
				   const float* source,
				   int numSamples) noexcept;

	/** Copies samples from an array of floats into one of the channels, applying a gain to it.

		@param destChannel          the channel within this buffer to copy the samples to
		@param destStartSample      the start sample within this buffer's channel
		@param source               the source buffer to read from
		@param numSamples           the number of samples to process
		@param gain                 the gain to apply

		@see addFrom
	*/
	void copyFrom (int destChannel,
				   int destStartSample,
				   const float* source,
				   int numSamples,
				   float gain) noexcept;

	/** Copies samples from an array of floats into one of the channels, applying a gain ramp.

		@param destChannel          the channel within this buffer to copy the samples to
		@param destStartSample      the start sample within this buffer's channel
		@param source               the source buffer to read from
		@param numSamples           the number of samples to process
		@param startGain            the gain to apply to the first sample (this is multiplied with
									the source samples before they are copied to this buffer)
		@param endGain              the gain to apply to the final sample. The gain is linearly
									interpolated between the first and last samples.

		@see addFrom
	*/
	void copyFromWithRamp (int destChannel,
						   int destStartSample,
						   const float* source,
						   int numSamples,
						   float startGain,
						   float endGain) noexcept;

	/** Finds the highest and lowest sample values in a given range.

		@param channel      the channel to read from
		@param startSample  the start sample within the channel
		@param numSamples   the number of samples to check
		@param minVal       on return, the lowest value that was found
		@param maxVal       on return, the highest value that was found
	*/
	void findMinMax (int channel,
					 int startSample,
					 int numSamples,
					 float& minVal,
					 float& maxVal) const noexcept;

	/** Finds the highest absolute sample value within a region of a channel.
	*/
	float getMagnitude (int channel,
						int startSample,
						int numSamples) const noexcept;

	/** Finds the highest absolute sample value within a region on all channels.
	*/
	float getMagnitude (int startSample,
						int numSamples) const noexcept;

	/** Returns the root mean squared level for a region of a channel.
	*/
	float getRMSLevel (int channel,
					   int startSample,
					   int numSamples) const noexcept;

private:

	int numChannels, size;
	size_t allocatedBytes;
	float** channels;
	HeapBlock <char, true> allocatedData;
	float* preallocatedChannelSpace [32];

	void allocateData();
	void allocateChannels (float** dataToReferTo, int offset);

	JUCE_LEAK_DETECTOR (AudioSampleBuffer);
};

#endif   // __JUCE_AUDIOSAMPLEBUFFER_JUCEHEADER__

/*** End of inlined file: juce_AudioSampleBuffer.h ***/


#endif
#ifndef __JUCE_DECIBELS_JUCEHEADER__

/*** Start of inlined file: juce_Decibels.h ***/
#ifndef __JUCE_DECIBELS_JUCEHEADER__
#define __JUCE_DECIBELS_JUCEHEADER__

/**
	This class contains some helpful static methods for dealing with decibel values.
*/
class Decibels
{
public:

	/** Converts a dBFS value to its equivalent gain level.

		A gain of 1.0 = 0 dB, and lower gains map onto negative decibel values. Any
		decibel value lower than minusInfinityDb will return a gain of 0.
	*/
	template <typename Type>
	static Type decibelsToGain (const Type decibels,
								const Type minusInfinityDb = (Type) defaultMinusInfinitydB)
	{
		return decibels > minusInfinityDb ? powf ((Type) 10.0, decibels * (Type) 0.05)
										  : Type();
	}

	/** Converts a gain level into a dBFS value.

		A gain of 1.0 = 0 dB, and lower gains map onto negative decibel values.
		If the gain is 0 (or negative), then the method will return the value
		provided as minusInfinityDb.
	*/
	template <typename Type>
	static Type gainToDecibels (const Type gain,
								const Type minusInfinityDb = (Type) defaultMinusInfinitydB)
	{
		return gain > Type() ? jmax (minusInfinityDb, (Type) std::log10 (gain) * (Type) 20.0)
							 : minusInfinityDb;
	}

	/** Converts a decibel reading to a string, with the 'dB' suffix.
		If the decibel value is lower than minusInfinityDb, the return value will
		be "-INF dB".
	*/
	template <typename Type>
	static String toString (const Type decibels,
							const int decimalPlaces = 2,
							const Type minusInfinityDb = (Type) defaultMinusInfinitydB)
	{
		String s;

		if (decibels <= minusInfinityDb)
		{
			s = "-INF dB";
		}
		else
		{
			if (decibels >= Type())
				s << '+';

			s << String (decibels, decimalPlaces) << " dB";
		}

		return s;
	}

private:

	enum
	{
		defaultMinusInfinitydB = -100
	};

	Decibels(); // This class can't be instantiated, it's just a holder for static methods..
	JUCE_DECLARE_NON_COPYABLE (Decibels);
};

#endif   // __JUCE_DECIBELS_JUCEHEADER__

/*** End of inlined file: juce_Decibels.h ***/


#endif
#ifndef __JUCE_IIRFILTER_JUCEHEADER__

/*** Start of inlined file: juce_IIRFilter.h ***/
#ifndef __JUCE_IIRFILTER_JUCEHEADER__
#define __JUCE_IIRFILTER_JUCEHEADER__

/**
	An IIR filter that can perform low, high, or band-pass filtering on an
	audio signal.

	@see IIRFilterAudioSource
*/
class JUCE_API  IIRFilter
{
public:

	/** Creates a filter.

		Initially the filter is inactive, so will have no effect on samples that
		you process with it. Use the appropriate method to turn it into the type
		of filter needed.
	*/
	IIRFilter();

	/** Creates a copy of another filter. */
	IIRFilter (const IIRFilter& other);

	/** Destructor. */
	~IIRFilter();

	/** Resets the filter's processing pipeline, ready to start a new stream of data.

		Note that this clears the processing state, but the type of filter and
		its coefficients aren't changed. To put a filter into an inactive state, use
		the makeInactive() method.
	*/
	void reset() noexcept;

	/** Performs the filter operation on the given set of samples.
	*/
	void processSamples (float* samples,
						 int numSamples) noexcept;

	/** Processes a single sample, without any locking or checking.

		Use this if you need fast processing of a single value, but be aware that
		this isn't thread-safe in the way that processSamples() is.
	*/
	float processSingleSampleRaw (float sample) noexcept;

	/** Sets the filter up to act as a low-pass filter.
	*/
	void makeLowPass (double sampleRate,
					  double frequency) noexcept;

	/** Sets the filter up to act as a high-pass filter.
	*/
	void makeHighPass (double sampleRate,
					   double frequency) noexcept;

	/** Sets the filter up to act as a low-pass shelf filter with variable Q and gain.

		The gain is a scale factor that the low frequencies are multiplied by, so values
		greater than 1.0 will boost the low frequencies, values less than 1.0 will
		attenuate them.
	*/
	void makeLowShelf (double sampleRate,
					   double cutOffFrequency,
					   double Q,
					   float gainFactor) noexcept;

	/** Sets the filter up to act as a high-pass shelf filter with variable Q and gain.

		The gain is a scale factor that the high frequencies are multiplied by, so values
		greater than 1.0 will boost the high frequencies, values less than 1.0 will
		attenuate them.
	*/
	void makeHighShelf (double sampleRate,
						double cutOffFrequency,
						double Q,
						float gainFactor) noexcept;

	/** Sets the filter up to act as a band pass filter centred around a
		frequency, with a variable Q and gain.

		The gain is a scale factor that the centre frequencies are multiplied by, so
		values greater than 1.0 will boost the centre frequencies, values less than
		1.0 will attenuate them.
	*/
	void makeBandPass (double sampleRate,
					   double centreFrequency,
					   double Q,
					   float gainFactor) noexcept;

	/** Clears the filter's coefficients so that it becomes inactive.
	*/
	void makeInactive() noexcept;

	/** Makes this filter duplicate the set-up of another one.
	*/
	void copyCoefficientsFrom (const IIRFilter& other) noexcept;

protected:

	CriticalSection processLock;

	void setCoefficients (double c1, double c2, double c3,
						  double c4, double c5, double c6) noexcept;

	bool active;
	float coefficients[6];
	float x1, x2, y1, y2;

	// (use the copyCoefficientsFrom() method instead of this operator)
	IIRFilter& operator= (const IIRFilter&);
	JUCE_LEAK_DETECTOR (IIRFilter);
};

#endif   // __JUCE_IIRFILTER_JUCEHEADER__

/*** End of inlined file: juce_IIRFilter.h ***/


#endif
#ifndef __JUCE_REVERB_JUCEHEADER__

/*** Start of inlined file: juce_Reverb.h ***/
#ifndef __JUCE_REVERB_JUCEHEADER__
#define __JUCE_REVERB_JUCEHEADER__

/**
	Performs a simple reverb effect on a stream of audio data.

	This is a simple stereo reverb, based on the technique and tunings used in FreeVerb.
	Use setSampleRate() to prepare it, and then call processStereo() or processMono() to
	apply the reverb to your audio data.

	@see ReverbAudioSource
*/
class Reverb
{
public:

	Reverb()
	{
		setParameters (Parameters());
		setSampleRate (44100.0);
	}

	/** Holds the parameters being used by a Reverb object. */
	struct Parameters
	{
		Parameters() noexcept
		  : roomSize   (0.5f),
			damping    (0.5f),
			wetLevel   (0.33f),
			dryLevel   (0.4f),
			width      (1.0f),
			freezeMode (0)
		{}

		float roomSize;     /**< Room size, 0 to 1.0, where 1.0 is big, 0 is small. */
		float damping;      /**< Damping, 0 to 1.0, where 0 is not damped, 1.0 is fully damped. */
		float wetLevel;     /**< Wet level, 0 to 1.0 */
		float dryLevel;     /**< Dry level, 0 to 1.0 */
		float width;        /**< Reverb width, 0 to 1.0, where 1.0 is very wide. */
		float freezeMode;   /**< Freeze mode - values < 0.5 are "normal" mode, values > 0.5
								 put the reverb into a continuous feedback loop. */
	};

	/** Returns the reverb's current parameters. */
	const Parameters& getParameters() const noexcept    { return parameters; }

	/** Applies a new set of parameters to the reverb.
		Note that this doesn't attempt to lock the reverb, so if you call this in parallel with
		the process method, you may get artifacts.
	*/
	void setParameters (const Parameters& newParams)
	{
		const float wetScaleFactor = 3.0f;
		const float dryScaleFactor = 2.0f;

		const float wet = newParams.wetLevel * wetScaleFactor;
		wet1 = wet * (newParams.width * 0.5f + 0.5f);
		wet2 = wet * (1.0f - newParams.width) * 0.5f;
		dry = newParams.dryLevel * dryScaleFactor;
		gain = isFrozen (newParams.freezeMode) ? 0.0f : 0.015f;
		parameters = newParams;
		shouldUpdateDamping = true;
	}

	/** Sets the sample rate that will be used for the reverb.
		You must call this before the process methods, in order to tell it the correct sample rate.
	*/
	void setSampleRate (const double sampleRate)
	{
		jassert (sampleRate > 0);

		static const short combTunings[] = { 1116, 1188, 1277, 1356, 1422, 1491, 1557, 1617 }; // (at 44100Hz)
		static const short allPassTunings[] = { 556, 441, 341, 225 };
		const int stereoSpread = 23;
		const int intSampleRate = (int) sampleRate;

		int i;
		for (i = 0; i < numCombs; ++i)
		{
			comb[0][i].setSize ((intSampleRate * combTunings[i]) / 44100);
			comb[1][i].setSize ((intSampleRate * (combTunings[i] + stereoSpread)) / 44100);
		}

		for (i = 0; i < numAllPasses; ++i)
		{
			allPass[0][i].setSize ((intSampleRate * allPassTunings[i]) / 44100);
			allPass[1][i].setSize ((intSampleRate * (allPassTunings[i] + stereoSpread)) / 44100);
		}

		shouldUpdateDamping = true;
	}

	/** Clears the reverb's buffers. */
	void reset()
	{
		for (int j = 0; j < numChannels; ++j)
		{
			int i;
			for (i = 0; i < numCombs; ++i)
				comb[j][i].clear();

			for (i = 0; i < numAllPasses; ++i)
				allPass[j][i].clear();
		}
	}

	/** Applies the reverb to two stereo channels of audio data. */
	void processStereo (float* const left, float* const right, const int numSamples) noexcept
	{
		jassert (left != nullptr && right != nullptr);

		if (shouldUpdateDamping)
			updateDamping();

		for (int i = 0; i < numSamples; ++i)
		{
			const float input = (left[i] + right[i]) * gain;
			float outL = 0, outR = 0;

			int j;
			for (j = 0; j < numCombs; ++j)  // accumulate the comb filters in parallel
			{
				outL += comb[0][j].process (input);
				outR += comb[1][j].process (input);
			}

			for (j = 0; j < numAllPasses; ++j)  // run the allpass filters in series
			{
				outL = allPass[0][j].process (outL);
				outR = allPass[1][j].process (outR);
			}

			left[i]  = outL * wet1 + outR * wet2 + left[i]  * dry;
			right[i] = outR * wet1 + outL * wet2 + right[i] * dry;
		}
	}

	/** Applies the reverb to a single mono channel of audio data. */
	void processMono (float* const samples, const int numSamples) noexcept
	{
		jassert (samples != nullptr);

		if (shouldUpdateDamping)
			updateDamping();

		for (int i = 0; i < numSamples; ++i)
		{
			const float input = samples[i] * gain;
			float output = 0;

			int j;
			for (j = 0; j < numCombs; ++j)  // accumulate the comb filters in parallel
				output += comb[0][j].process (input);

			for (j = 0; j < numAllPasses; ++j)  // run the allpass filters in series
				output = allPass[0][j].process (output);

			samples[i] = output * wet1 + input * dry;
		}
	}

private:

	Parameters parameters;

	volatile bool shouldUpdateDamping;
	float gain, wet1, wet2, dry;

	inline static bool isFrozen (const float freezeMode) noexcept  { return freezeMode >= 0.5f; }

	void updateDamping() noexcept
	{
		const float roomScaleFactor = 0.28f;
		const float roomOffset = 0.7f;
		const float dampScaleFactor = 0.4f;

		shouldUpdateDamping = false;

		if (isFrozen (parameters.freezeMode))
			setDamping (1.0f, 0.0f);
		else
			setDamping (parameters.damping * dampScaleFactor,
						parameters.roomSize * roomScaleFactor + roomOffset);
	}

	void setDamping (const float dampingToUse, const float roomSizeToUse) noexcept
	{
		for (int j = 0; j < numChannels; ++j)
			for (int i = numCombs; --i >= 0;)
				comb[j][i].setFeedbackAndDamp (roomSizeToUse, dampingToUse);
	}

	class CombFilter
	{
	public:
		CombFilter() noexcept  : bufferSize (0), bufferIndex (0) {}

		void setSize (const int size)
		{
			if (size != bufferSize)
			{
				bufferIndex = 0;
				buffer.malloc ((size_t) size);
				bufferSize = size;
			}

			clear();
		}

		void clear() noexcept
		{
			last = 0;
			buffer.clear ((size_t) bufferSize);
		}

		void setFeedbackAndDamp (const float f, const float d) noexcept
		{
			damp1 = d;
			damp2 = 1.0f - d;
			feedback = f;
		}

		inline float process (const float input) noexcept
		{
			const float output = buffer [bufferIndex];
			last = (output * damp2) + (last * damp1);
			JUCE_UNDENORMALISE (last);

			float temp = input + (last * feedback);
			JUCE_UNDENORMALISE (temp);
			buffer [bufferIndex] = temp;
			bufferIndex = (bufferIndex + 1) % bufferSize;
			return output;
		}

	private:
		HeapBlock<float> buffer;
		int bufferSize, bufferIndex;
		float feedback, last, damp1, damp2;

		JUCE_DECLARE_NON_COPYABLE (CombFilter);
	};

	class AllPassFilter
	{
	public:
		AllPassFilter() noexcept  : bufferSize (0), bufferIndex (0) {}

		void setSize (const int size)
		{
			if (size != bufferSize)
			{
				bufferIndex = 0;
				buffer.malloc ((size_t) size);
				bufferSize = size;
			}

			clear();
		}

		void clear() noexcept
		{
			buffer.clear ((size_t) bufferSize);
		}

		inline float process (const float input) noexcept
		{
			const float bufferedValue = buffer [bufferIndex];
			float temp = input + (bufferedValue * 0.5f);
			JUCE_UNDENORMALISE (temp);
			buffer [bufferIndex] = temp;
			bufferIndex = (bufferIndex + 1) % bufferSize;
			return bufferedValue - input;
		}

	private:
		HeapBlock<float> buffer;
		int bufferSize, bufferIndex;

		JUCE_DECLARE_NON_COPYABLE (AllPassFilter);
	};

	enum { numCombs = 8, numAllPasses = 4, numChannels = 2 };

	CombFilter comb [numChannels][numCombs];
	AllPassFilter allPass [numChannels][numAllPasses];

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (Reverb);
};

#endif   // __JUCE_REVERB_JUCEHEADER__

/*** End of inlined file: juce_Reverb.h ***/


#endif
#ifndef __JUCE_MIDIBUFFER_JUCEHEADER__

/*** Start of inlined file: juce_MidiBuffer.h ***/
#ifndef __JUCE_MIDIBUFFER_JUCEHEADER__
#define __JUCE_MIDIBUFFER_JUCEHEADER__


/*** Start of inlined file: juce_MidiMessage.h ***/
#ifndef __JUCE_MIDIMESSAGE_JUCEHEADER__
#define __JUCE_MIDIMESSAGE_JUCEHEADER__

/**
	Encapsulates a MIDI message.

	@see MidiMessageSequence, MidiOutput, MidiInput
*/
class JUCE_API  MidiMessage
{
public:

	/** Creates a 3-byte short midi message.

		@param byte1            message byte 1
		@param byte2            message byte 2
		@param byte3            message byte 3
		@param timeStamp        the time to give the midi message - this value doesn't
								use any particular units, so will be application-specific
	*/
	MidiMessage (int byte1, int byte2, int byte3, double timeStamp = 0) noexcept;

	/** Creates a 2-byte short midi message.

		@param byte1            message byte 1
		@param byte2            message byte 2
		@param timeStamp        the time to give the midi message - this value doesn't
								use any particular units, so will be application-specific
	*/
	MidiMessage (int byte1, int byte2, double timeStamp = 0) noexcept;

	/** Creates a 1-byte short midi message.

		@param byte1            message byte 1
		@param timeStamp        the time to give the midi message - this value doesn't
								use any particular units, so will be application-specific
	*/
	MidiMessage (int byte1, double timeStamp = 0) noexcept;

	/** Creates a midi message from a block of data. */
	MidiMessage (const void* data, int numBytes, double timeStamp = 0);

	/** Reads the next midi message from some data.

		This will read as many bytes from a data stream as it needs to make a
		complete message, and will return the number of bytes it used. This lets
		you read a sequence of midi messages from a file or stream.

		@param data             the data to read from
		@param maxBytesToUse    the maximum number of bytes it's allowed to read
		@param numBytesUsed     returns the number of bytes that were actually needed
		@param lastStatusByte   in a sequence of midi messages, the initial byte
								can be dropped from a message if it's the same as the
								first byte of the previous message, so this lets you
								supply the byte to use if the first byte of the message
								has in fact been dropped.
		@param timeStamp        the time to give the midi message - this value doesn't
								use any particular units, so will be application-specific
	*/
	MidiMessage (const void* data, int maxBytesToUse,
				 int& numBytesUsed, uint8 lastStatusByte,
				 double timeStamp = 0);

	/** Creates an active-sense message.
		Since the MidiMessage has to contain a valid message, this default constructor
		just initialises it with an empty sysex message.
	*/
	MidiMessage() noexcept;

	/** Creates a copy of another midi message. */
	MidiMessage (const MidiMessage& other);

	/** Creates a copy of another midi message, with a different timestamp. */
	MidiMessage (const MidiMessage& other, double newTimeStamp);

	/** Destructor. */
	~MidiMessage();

	/** Copies this message from another one. */
	MidiMessage& operator= (const MidiMessage& other);

   #if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
	MidiMessage (MidiMessage&& other) noexcept;
	MidiMessage& operator= (MidiMessage&& other) noexcept;
   #endif

	/** Returns a pointer to the raw midi data.

		@see getRawDataSize
	*/
	uint8* getRawData() const noexcept                          { return data; }

	/** Returns the number of bytes of data in the message.

		@see getRawData
	*/
	int getRawDataSize() const noexcept                         { return size; }

	/** Returns the timestamp associated with this message.

		The exact meaning of this time and its units will vary, as messages are used in
		a variety of different contexts.

		If you're getting the message from a midi file, this could be a time in seconds, or
		a number of ticks - see MidiFile::convertTimestampTicksToSeconds().

		If the message is being used in a MidiBuffer, it might indicate the number of
		audio samples from the start of the buffer.

		If the message was created by a MidiInput, see MidiInputCallback::handleIncomingMidiMessage()
		for details of the way that it initialises this value.

		@see setTimeStamp, addToTimeStamp
	*/
	double getTimeStamp() const noexcept                        { return timeStamp; }

	/** Changes the message's associated timestamp.

		The units for the timestamp will be application-specific - see the notes for getTimeStamp().

		@see addToTimeStamp, getTimeStamp
	*/
	void setTimeStamp (double newTimestamp) noexcept      { timeStamp = newTimestamp; }

	/** Adds a value to the message's timestamp.

		The units for the timestamp will be application-specific.
	*/
	void addToTimeStamp (double delta) noexcept           { timeStamp += delta; }

	/** Returns the midi channel associated with the message.

		@returns    a value 1 to 16 if the message has a channel, or 0 if it hasn't (e.g.
					if it's a sysex)
		@see isForChannel, setChannel
	*/
	int getChannel() const noexcept;

	/** Returns true if the message applies to the given midi channel.

		@param channelNumber    the channel number to look for, in the range 1 to 16
		@see getChannel, setChannel
	*/
	bool isForChannel (int channelNumber) const noexcept;

	/** Changes the message's midi channel.

		This won't do anything for non-channel messages like sysexes.

		@param newChannelNumber    the channel number to change it to, in the range 1 to 16
	*/
	void setChannel (int newChannelNumber) noexcept;

	/** Returns true if this is a system-exclusive message.
	*/
	bool isSysEx() const noexcept;

	/** Returns a pointer to the sysex data inside the message.

		If this event isn't a sysex event, it'll return 0.

		@see getSysExDataSize
	*/
	const uint8* getSysExData() const noexcept;

	/** Returns the size of the sysex data.

		This value excludes the 0xf0 header byte and the 0xf7 at the end.

		@see getSysExData
	*/
	int getSysExDataSize() const noexcept;

	/** Returns true if this message is a 'key-down' event.

		@param returnTrueForVelocity0   if true, then if this event is a note-on with
						velocity 0, it will still be considered to be a note-on and the
						method will return true. If returnTrueForVelocity0 is false, then
						if this is a note-on event with velocity 0, it'll be regarded as
						a note-off, and the method will return false

		@see isNoteOff, getNoteNumber, getVelocity, noteOn
	*/
	bool isNoteOn (bool returnTrueForVelocity0 = false) const noexcept;

	/** Creates a key-down message (using a floating-point velocity).

		@param channel      the midi channel, in the range 1 to 16
		@param noteNumber   the key number, 0 to 127
		@param velocity     in the range 0 to 1.0
		@see isNoteOn
	*/
	static MidiMessage noteOn (int channel, int noteNumber, float velocity) noexcept;

	/** Creates a key-down message (using an integer velocity).

		@param channel      the midi channel, in the range 1 to 16
		@param noteNumber   the key number, 0 to 127
		@param velocity     in the range 0 to 127
		@see isNoteOn
	*/
	static MidiMessage noteOn (int channel, int noteNumber, uint8 velocity) noexcept;

	/** Returns true if this message is a 'key-up' event.

		If returnTrueForNoteOnVelocity0 is true, then his will also return true
		for a note-on event with a velocity of 0.

		@see isNoteOn, getNoteNumber, getVelocity, noteOff
	*/
	bool isNoteOff (bool returnTrueForNoteOnVelocity0 = true) const noexcept;

	/** Creates a key-up message.

		@param channel      the midi channel, in the range 1 to 16
		@param noteNumber   the key number, 0 to 127
		@param velocity     in the range 0 to 127
		@see isNoteOff
	*/
	static MidiMessage noteOff (int channel, int noteNumber, uint8 velocity = 0) noexcept;

	/** Returns true if this message is a 'key-down' or 'key-up' event.

		@see isNoteOn, isNoteOff
	*/
	bool isNoteOnOrOff() const noexcept;

	/** Returns the midi note number for note-on and note-off messages.

		If the message isn't a note-on or off, the value returned is undefined.

		@see isNoteOff, getMidiNoteName, getMidiNoteInHertz, setNoteNumber
	*/
	int getNoteNumber() const noexcept;

	/** Changes the midi note number of a note-on or note-off message.

		If the message isn't a note on or off, this will do nothing.
	*/
	void setNoteNumber (int newNoteNumber) noexcept;

	/** Returns the velocity of a note-on or note-off message.

		The value returned will be in the range 0 to 127.
		If the message isn't a note-on or off event, it will return 0.

		@see getFloatVelocity
	*/
	uint8 getVelocity() const noexcept;

	/** Returns the velocity of a note-on or note-off message.

		The value returned will be in the range 0 to 1.0
		If the message isn't a note-on or off event, it will return 0.

		@see getVelocity, setVelocity
	*/
	float getFloatVelocity() const noexcept;

	/** Changes the velocity of a note-on or note-off message.

		If the message isn't a note on or off, this will do nothing.

		@param newVelocity  the new velocity, in the range 0 to 1.0
		@see getFloatVelocity, multiplyVelocity
	*/
	void setVelocity (float newVelocity) noexcept;

	/** Multiplies the velocity of a note-on or note-off message by a given amount.

		If the message isn't a note on or off, this will do nothing.

		@param scaleFactor  the value by which to multiply the velocity
		@see setVelocity
	*/
	void multiplyVelocity (float scaleFactor) noexcept;

	/** Returns true if this message is a 'sustain pedal down' controller message. */
	bool isSustainPedalOn() const noexcept;
	/** Returns true if this message is a 'sustain pedal up' controller message. */
	bool isSustainPedalOff() const noexcept;

	/** Returns true if this message is a 'sostenuto pedal down' controller message. */
	bool isSostenutoPedalOn() const noexcept;
	/** Returns true if this message is a 'sostenuto pedal up' controller message. */
	bool isSostenutoPedalOff() const noexcept;

	/** Returns true if this message is a 'soft pedal down' controller message. */
	bool isSoftPedalOn() const noexcept;
	/** Returns true if this message is a 'soft pedal up' controller message. */
	bool isSoftPedalOff() const noexcept;

	/** Returns true if the message is a program (patch) change message.

		@see getProgramChangeNumber, getGMInstrumentName
	*/
	bool isProgramChange() const noexcept;

	/** Returns the new program number of a program change message.

		If the message isn't a program change, the value returned will be
		nonsense.

		@see isProgramChange, getGMInstrumentName
	*/
	int getProgramChangeNumber() const noexcept;

	/** Creates a program-change message.

		@param channel          the midi channel, in the range 1 to 16
		@param programNumber    the midi program number, 0 to 127
		@see isProgramChange, getGMInstrumentName
	*/
	static MidiMessage programChange (int channel, int programNumber) noexcept;

	/** Returns true if the message is a pitch-wheel move.

		@see getPitchWheelValue, pitchWheel
	*/
	bool isPitchWheel() const noexcept;

	/** Returns the pitch wheel position from a pitch-wheel move message.

		The value returned is a 14-bit number from 0 to 0x3fff, indicating the wheel position.
		If called for messages which aren't pitch wheel events, the number returned will be
		nonsense.

		@see isPitchWheel
	*/
	int getPitchWheelValue() const noexcept;

	/** Creates a pitch-wheel move message.

		@param channel      the midi channel, in the range 1 to 16
		@param position     the wheel position, in the range 0 to 16383
		@see isPitchWheel
	*/
	static MidiMessage pitchWheel (int channel, int position) noexcept;

	/** Returns true if the message is an aftertouch event.

		For aftertouch events, use the getNoteNumber() method to find out the key
		that it applies to, and getAftertouchValue() to find out the amount. Use
		getChannel() to find out the channel.

		@see getAftertouchValue, getNoteNumber
	*/
	bool isAftertouch() const noexcept;

	/** Returns the amount of aftertouch from an aftertouch messages.

		The value returned is in the range 0 to 127, and will be nonsense for messages
		other than aftertouch messages.

		@see isAftertouch
	*/
	int getAfterTouchValue() const noexcept;

	/** Creates an aftertouch message.

		@param channel              the midi channel, in the range 1 to 16
		@param noteNumber           the key number, 0 to 127
		@param aftertouchAmount     the amount of aftertouch, 0 to 127
		@see isAftertouch
	*/
	static MidiMessage aftertouchChange (int channel,
										 int noteNumber,
										 int aftertouchAmount) noexcept;

	/** Returns true if the message is a channel-pressure change event.

		This is like aftertouch, but common to the whole channel rather than a specific
		note. Use getChannelPressureValue() to find out the pressure, and getChannel()
		to find out the channel.

		@see channelPressureChange
	*/
	bool isChannelPressure() const noexcept;

	/** Returns the pressure from a channel pressure change message.

		@returns the pressure, in the range 0 to 127
		@see isChannelPressure, channelPressureChange
	*/
	int getChannelPressureValue() const noexcept;

	/** Creates a channel-pressure change event.

		@param channel              the midi channel: 1 to 16
		@param pressure             the pressure, 0 to 127
		@see isChannelPressure
	*/
	static MidiMessage channelPressureChange (int channel, int pressure) noexcept;

	/** Returns true if this is a midi controller message.

		@see getControllerNumber, getControllerValue, controllerEvent
	*/
	bool isController() const noexcept;

	/** Returns the controller number of a controller message.

		The name of the controller can be looked up using the getControllerName() method.

		Note that the value returned is invalid for messages that aren't controller changes.

		@see isController, getControllerName, getControllerValue
	*/
	int getControllerNumber() const noexcept;

	/** Returns the controller value from a controller message.

		A value 0 to 127 is returned to indicate the new controller position.

		Note that the value returned is invalid for messages that aren't controller changes.

		@see isController, getControllerNumber
	*/
	int getControllerValue() const noexcept;

	/** Returns true if this message is a controller message and if it has the specified
		controller type.
	*/
	bool isControllerOfType (int controllerType) const noexcept;

	/** Creates a controller message.

		@param channel          the midi channel, in the range 1 to 16
		@param controllerType   the type of controller
		@param value            the controller value
		@see isController
	*/
	static MidiMessage controllerEvent (int channel,
										int controllerType,
										int value) noexcept;

	/** Checks whether this message is an all-notes-off message.

		@see allNotesOff
	*/
	bool isAllNotesOff() const noexcept;

	/** Checks whether this message is an all-sound-off message.

		@see allSoundOff
	*/
	bool isAllSoundOff() const noexcept;

	/** Creates an all-notes-off message.

		@param channel              the midi channel, in the range 1 to 16
		@see isAllNotesOff
	*/
	static MidiMessage allNotesOff (int channel) noexcept;

	/** Creates an all-sound-off message.

		@param channel              the midi channel, in the range 1 to 16
		@see isAllSoundOff
	*/
	static MidiMessage allSoundOff (int channel) noexcept;

	/** Creates an all-controllers-off message.

		@param channel              the midi channel, in the range 1 to 16
	*/
	static MidiMessage allControllersOff (int channel) noexcept;

	/** Returns true if this event is a meta-event.

		Meta-events are things like tempo changes, track names, etc.

		@see getMetaEventType, isTrackMetaEvent, isEndOfTrackMetaEvent,
			 isTextMetaEvent, isTrackNameEvent, isTempoMetaEvent, isTimeSignatureMetaEvent,
			 isKeySignatureMetaEvent, isMidiChannelMetaEvent
	*/
	bool isMetaEvent() const noexcept;

	/** Returns a meta-event's type number.

		If the message isn't a meta-event, this will return -1.

		@see isMetaEvent, isTrackMetaEvent, isEndOfTrackMetaEvent,
			 isTextMetaEvent, isTrackNameEvent, isTempoMetaEvent, isTimeSignatureMetaEvent,
			 isKeySignatureMetaEvent, isMidiChannelMetaEvent
	*/
	int getMetaEventType() const noexcept;

	/** Returns a pointer to the data in a meta-event.

		@see isMetaEvent, getMetaEventLength
	*/
	const uint8* getMetaEventData() const noexcept;

	/** Returns the length of the data for a meta-event.

		@see isMetaEvent, getMetaEventData
	*/
	int getMetaEventLength() const noexcept;

	/** Returns true if this is a 'track' meta-event. */
	bool isTrackMetaEvent() const noexcept;

	/** Returns true if this is an 'end-of-track' meta-event. */
	bool isEndOfTrackMetaEvent() const noexcept;

	/** Creates an end-of-track meta-event.

		@see isEndOfTrackMetaEvent
	*/
	static MidiMessage endOfTrack() noexcept;

	/** Returns true if this is an 'track name' meta-event.

		You can use the getTextFromTextMetaEvent() method to get the track's name.
	*/
	bool isTrackNameEvent() const noexcept;

	/** Returns true if this is a 'text' meta-event.

		@see getTextFromTextMetaEvent
	*/
	bool isTextMetaEvent() const noexcept;

	/** Returns the text from a text meta-event.

		@see isTextMetaEvent
	*/
	String getTextFromTextMetaEvent() const;

	/** Returns true if this is a 'tempo' meta-event.

		@see getTempoMetaEventTickLength, getTempoSecondsPerQuarterNote
	*/
	bool isTempoMetaEvent() const noexcept;

	/** Returns the tick length from a tempo meta-event.

		@param timeFormat   the 16-bit time format value from the midi file's header.
		@returns the tick length (in seconds).
		@see isTempoMetaEvent
	*/
	double getTempoMetaEventTickLength (short timeFormat) const noexcept;

	/** Calculates the seconds-per-quarter-note from a tempo meta-event.

		@see isTempoMetaEvent, getTempoMetaEventTickLength
	*/
	double getTempoSecondsPerQuarterNote() const noexcept;

	/** Creates a tempo meta-event.

		@see isTempoMetaEvent
	*/
	static MidiMessage tempoMetaEvent (int microsecondsPerQuarterNote) noexcept;

	/** Returns true if this is a 'time-signature' meta-event.

		@see getTimeSignatureInfo
	*/
	bool isTimeSignatureMetaEvent() const noexcept;

	/** Returns the time-signature values from a time-signature meta-event.

		@see isTimeSignatureMetaEvent
	*/
	void getTimeSignatureInfo (int& numerator, int& denominator) const noexcept;

	/** Creates a time-signature meta-event.

		@see isTimeSignatureMetaEvent
	*/
	static MidiMessage timeSignatureMetaEvent (int numerator, int denominator);

	/** Returns true if this is a 'key-signature' meta-event.

		@see getKeySignatureNumberOfSharpsOrFlats
	*/
	bool isKeySignatureMetaEvent() const noexcept;

	/** Returns the key from a key-signature meta-event.

		@see isKeySignatureMetaEvent
	*/
	int getKeySignatureNumberOfSharpsOrFlats() const noexcept;

	/** Returns true if this is a 'channel' meta-event.

		A channel meta-event specifies the midi channel that should be used
		for subsequent meta-events.

		@see getMidiChannelMetaEventChannel
	*/
	bool isMidiChannelMetaEvent() const noexcept;

	/** Returns the channel number from a channel meta-event.

		@returns the channel, in the range 1 to 16.
		@see isMidiChannelMetaEvent
	*/
	int getMidiChannelMetaEventChannel() const noexcept;

	/** Creates a midi channel meta-event.

		@param channel              the midi channel, in the range 1 to 16
		@see isMidiChannelMetaEvent
	*/
	static MidiMessage midiChannelMetaEvent (int channel) noexcept;

	/** Returns true if this is an active-sense message. */
	bool isActiveSense() const noexcept;

	/** Returns true if this is a midi start event.

		@see midiStart
	*/
	bool isMidiStart() const noexcept;

	/** Creates a midi start event. */
	static MidiMessage midiStart() noexcept;

	/** Returns true if this is a midi continue event.

		@see midiContinue
	*/
	bool isMidiContinue() const noexcept;

	/** Creates a midi continue event. */
	static MidiMessage midiContinue() noexcept;

	/** Returns true if this is a midi stop event.

		@see midiStop
	*/
	bool isMidiStop() const noexcept;

	/** Creates a midi stop event. */
	static MidiMessage midiStop() noexcept;

	/** Returns true if this is a midi clock event.

		@see midiClock, songPositionPointer
	*/
	bool isMidiClock() const noexcept;

	/** Creates a midi clock event. */
	static MidiMessage midiClock() noexcept;

	/** Returns true if this is a song-position-pointer message.

		@see getSongPositionPointerMidiBeat, songPositionPointer
	*/
	bool isSongPositionPointer() const noexcept;

	/** Returns the midi beat-number of a song-position-pointer message.

		@see isSongPositionPointer, songPositionPointer
	*/
	int getSongPositionPointerMidiBeat() const noexcept;

	/** Creates a song-position-pointer message.

		The position is a number of midi beats from the start of the song, where 1 midi
		beat is 6 midi clocks, and there are 24 midi clocks in a quarter-note. So there
		are 4 midi beats in a quarter-note.

		@see isSongPositionPointer, getSongPositionPointerMidiBeat
	*/
	static MidiMessage songPositionPointer (int positionInMidiBeats) noexcept;

	/** Returns true if this is a quarter-frame midi timecode message.

		@see quarterFrame, getQuarterFrameSequenceNumber, getQuarterFrameValue
	*/
	bool isQuarterFrame() const noexcept;

	/** Returns the sequence number of a quarter-frame midi timecode message.

		This will be a value between 0 and 7.

		@see isQuarterFrame, getQuarterFrameValue, quarterFrame
	*/
	int getQuarterFrameSequenceNumber() const noexcept;

	/** Returns the value from a quarter-frame message.

		This will be the lower nybble of the message's data-byte, a value
		between 0 and 15
	*/
	int getQuarterFrameValue() const noexcept;

	/** Creates a quarter-frame MTC message.

		@param sequenceNumber   a value 0 to 7 for the upper nybble of the message's data byte
		@param value            a value 0 to 15 for the lower nybble of the message's data byte
	*/
	static MidiMessage quarterFrame (int sequenceNumber, int value) noexcept;

	/** SMPTE timecode types.

		Used by the getFullFrameParameters() and fullFrame() methods.
	*/
	enum SmpteTimecodeType
	{
		fps24       = 0,
		fps25       = 1,
		fps30drop   = 2,
		fps30       = 3
	};

	/** Returns true if this is a full-frame midi timecode message.
	*/
	bool isFullFrame() const noexcept;

	/** Extracts the timecode information from a full-frame midi timecode message.

		You should only call this on messages where you've used isFullFrame() to
		check that they're the right kind.
	*/
	void getFullFrameParameters (int& hours,
								 int& minutes,
								 int& seconds,
								 int& frames,
								 SmpteTimecodeType& timecodeType) const noexcept;

	/** Creates a full-frame MTC message.
	*/
	static MidiMessage fullFrame (int hours,
								  int minutes,
								  int seconds,
								  int frames,
								  SmpteTimecodeType timecodeType);

	/** Types of MMC command.

		@see isMidiMachineControlMessage, getMidiMachineControlCommand, midiMachineControlCommand
	*/
	enum MidiMachineControlCommand
	{
		mmc_stop            = 1,
		mmc_play            = 2,
		mmc_deferredplay    = 3,
		mmc_fastforward     = 4,
		mmc_rewind          = 5,
		mmc_recordStart     = 6,
		mmc_recordStop      = 7,
		mmc_pause           = 9
	};

	/** Checks whether this is an MMC message.

		If it is, you can use the getMidiMachineControlCommand() to find out its type.
	*/
	bool isMidiMachineControlMessage() const noexcept;

	/** For an MMC message, this returns its type.

		Make sure it's actually an MMC message with isMidiMachineControlMessage() before
		calling this method.
	*/
	MidiMachineControlCommand getMidiMachineControlCommand() const noexcept;

	/** Creates an MMC message.
	*/
	static MidiMessage midiMachineControlCommand (MidiMachineControlCommand command);

	/** Checks whether this is an MMC "goto" message.

		If it is, the parameters passed-in are set to the time that the message contains.

		@see midiMachineControlGoto
	*/
	bool isMidiMachineControlGoto (int& hours,
								   int& minutes,
								   int& seconds,
								   int& frames) const noexcept;

	/** Creates an MMC "goto" message.

		This messages tells the device to go to a specific frame.

		@see isMidiMachineControlGoto
	*/
	static MidiMessage midiMachineControlGoto (int hours,
											   int minutes,
											   int seconds,
											   int frames);

	/** Creates a master-volume change message.

		@param volume   the volume, 0 to 1.0
	*/
	static MidiMessage masterVolume (float volume);

	/** Creates a system-exclusive message.

		The data passed in is wrapped with header and tail bytes of 0xf0 and 0xf7.
	*/
	static MidiMessage createSysExMessage (const uint8* sysexData,
										   int dataSize);

	/** Reads a midi variable-length integer.

		@param data             the data to read the number from
		@param numBytesUsed     on return, this will be set to the number of bytes that were read
	*/
	static int readVariableLengthVal (const uint8* data,
									  int& numBytesUsed) noexcept;

	/** Based on the first byte of a short midi message, this uses a lookup table
		to return the message length (either 1, 2, or 3 bytes).

		The value passed in must be 0x80 or higher.
	*/
	static int getMessageLengthFromFirstByte (const uint8 firstByte) noexcept;

	/** Returns the name of a midi note number.

		E.g "C", "D#", etc.

		@param noteNumber           the midi note number, 0 to 127
		@param useSharps            if true, sharpened notes are used, e.g. "C#", otherwise
									they'll be flattened, e.g. "Db"
		@param includeOctaveNumber  if true, the octave number will be appended to the string,
									e.g. "C#4"
		@param octaveNumForMiddleC  if an octave number is being appended, this indicates the
									number that will be used for middle C's octave

		@see getMidiNoteInHertz
	*/
	static String getMidiNoteName (int noteNumber,
								   bool useSharps,
								   bool includeOctaveNumber,
								   int octaveNumForMiddleC);

	/** Returns the frequency of a midi note number.

		The frequencyOfA parameter is an optional frequency for 'A', normally 440-444Hz for concert pitch.
		@see getMidiNoteName
	*/
	static const double getMidiNoteInHertz (int noteNumber, const double frequencyOfA = 440.0) noexcept;

	/** Returns the standard name of a GM instrument.

		@param midiInstrumentNumber     the program number 0 to 127
		@see getProgramChangeNumber
	*/
	static String getGMInstrumentName (int midiInstrumentNumber);

	/** Returns the name of a bank of GM instruments.

		@param midiBankNumber   the bank, 0 to 15
	*/
	static String getGMInstrumentBankName (int midiBankNumber);

	/** Returns the standard name of a channel 10 percussion sound.

		@param midiNoteNumber   the key number, 35 to 81
	*/
	static String getRhythmInstrumentName (int midiNoteNumber);

	/** Returns the name of a controller type number.

		@see getControllerNumber
	*/
	static String getControllerName (int controllerNumber);

private:

	double timeStamp;
	uint8* data;
	int size;

   #ifndef DOXYGEN
	union
	{
		uint8 asBytes[4];
		uint32 asInt32;
	} preallocatedData;
   #endif

	void freeData() noexcept;
	void setToUseInternalData() noexcept;
	bool usesAllocatedData() const noexcept;
};

#endif   // __JUCE_MIDIMESSAGE_JUCEHEADER__

/*** End of inlined file: juce_MidiMessage.h ***/

/**
	Holds a sequence of time-stamped midi events.

	Analogous to the AudioSampleBuffer, this holds a set of midi events with
	integer time-stamps. The buffer is kept sorted in order of the time-stamps.

	@see MidiMessage
*/
class JUCE_API  MidiBuffer
{
public:

	/** Creates an empty MidiBuffer. */
	MidiBuffer() noexcept;

	/** Creates a MidiBuffer containing a single midi message. */
	explicit MidiBuffer (const MidiMessage& message) noexcept;

	/** Creates a copy of another MidiBuffer. */
	MidiBuffer (const MidiBuffer& other) noexcept;

	/** Makes a copy of another MidiBuffer. */
	MidiBuffer& operator= (const MidiBuffer& other) noexcept;

	/** Destructor */
	~MidiBuffer();

	/** Removes all events from the buffer. */
	void clear() noexcept;

	/** Removes all events between two times from the buffer.

		All events for which (start <= event position < start + numSamples) will
		be removed.
	*/
	void clear (int start, int numSamples);

	/** Returns true if the buffer is empty.

		To actually retrieve the events, use a MidiBuffer::Iterator object
	*/
	bool isEmpty() const noexcept;

	/** Counts the number of events in the buffer.

		This is actually quite a slow operation, as it has to iterate through all
		the events, so you might prefer to call isEmpty() if that's all you need
		to know.
	*/
	int getNumEvents() const noexcept;

	/** Adds an event to the buffer.

		The sample number will be used to determine the position of the event in
		the buffer, which is always kept sorted. The MidiMessage's timestamp is
		ignored.

		If an event is added whose sample position is the same as one or more events
		already in the buffer, the new event will be placed after the existing ones.

		To retrieve events, use a MidiBuffer::Iterator object
	*/
	void addEvent (const MidiMessage& midiMessage, int sampleNumber);

	/** Adds an event to the buffer from raw midi data.

		The sample number will be used to determine the position of the event in
		the buffer, which is always kept sorted.

		If an event is added whose sample position is the same as one or more events
		already in the buffer, the new event will be placed after the existing ones.

		The event data will be inspected to calculate the number of bytes in length that
		the midi event really takes up, so maxBytesOfMidiData may be longer than the data
		that actually gets stored. E.g. if you pass in a note-on and a length of 4 bytes,
		it'll actually only store 3 bytes. If the midi data is invalid, it might not
		add an event at all.

		To retrieve events, use a MidiBuffer::Iterator object
	*/
	void addEvent (const void* rawMidiData,
				   int maxBytesOfMidiData,
				   int sampleNumber);

	/** Adds some events from another buffer to this one.

		@param otherBuffer          the buffer containing the events you want to add
		@param startSample          the lowest sample number in the source buffer for which
									events should be added. Any source events whose timestamp is
									less than this will be ignored
		@param numSamples           the valid range of samples from the source buffer for which
									events should be added - i.e. events in the source buffer whose
									timestamp is greater than or equal to (startSample + numSamples)
									will be ignored. If this value is less than 0, all events after
									startSample will be taken.
		@param sampleDeltaToAdd     a value which will be added to the source timestamps of the events
									that are added to this buffer
	*/
	void addEvents (const MidiBuffer& otherBuffer,
					int startSample,
					int numSamples,
					int sampleDeltaToAdd);

	/** Returns the sample number of the first event in the buffer.

		If the buffer's empty, this will just return 0.
	*/
	int getFirstEventTime() const noexcept;

	/** Returns the sample number of the last event in the buffer.

		If the buffer's empty, this will just return 0.
	*/
	int getLastEventTime() const noexcept;

	/** Exchanges the contents of this buffer with another one.

		This is a quick operation, because no memory allocating or copying is done, it
		just swaps the internal state of the two buffers.
	*/
	void swapWith (MidiBuffer& other) noexcept;

	/** Preallocates some memory for the buffer to use.
		This helps to avoid needing to reallocate space when the buffer has messages
		added to it.
	*/
	void ensureSize (size_t minimumNumBytes);

	/**
		Used to iterate through the events in a MidiBuffer.

		Note that altering the buffer while an iterator is using it isn't a
		safe operation.

		@see MidiBuffer
	*/
	class JUCE_API  Iterator
	{
	public:

		/** Creates an Iterator for this MidiBuffer. */
		Iterator (const MidiBuffer& buffer) noexcept;

		/** Destructor. */
		~Iterator() noexcept;

		/** Repositions the iterator so that the next event retrieved will be the first
			one whose sample position is at greater than or equal to the given position.
		*/
		void setNextSamplePosition (int samplePosition) noexcept;

		/** Retrieves a copy of the next event from the buffer.

			@param result   on return, this will be the message (the MidiMessage's timestamp
							is not set)
			@param samplePosition   on return, this will be the position of the event
			@returns        true if an event was found, or false if the iterator has reached
							the end of the buffer
		*/
		bool getNextEvent (MidiMessage& result,
						   int& samplePosition) noexcept;

		/** Retrieves the next event from the buffer.

			@param midiData     on return, this pointer will be set to a block of data containing
								the midi message. Note that to make it fast, this is a pointer
								directly into the MidiBuffer's internal data, so is only valid
								temporarily until the MidiBuffer is altered.
			@param numBytesOfMidiData   on return, this is the number of bytes of data used by the
										midi message
			@param samplePosition   on return, this will be the position of the event
			@returns        true if an event was found, or false if the iterator has reached
							the end of the buffer
		*/
		bool getNextEvent (const uint8* &midiData,
						   int& numBytesOfMidiData,
						   int& samplePosition) noexcept;

	private:

		const MidiBuffer& buffer;
		const uint8* data;

		JUCE_DECLARE_NON_COPYABLE (Iterator);
	};

private:

	friend class MidiBuffer::Iterator;
	MemoryBlock data;
	int bytesUsed;

	uint8* getData() const noexcept;
	uint8* findEventAfter (uint8*, int samplePosition) const noexcept;

	JUCE_LEAK_DETECTOR (MidiBuffer);
};

#endif   // __JUCE_MIDIBUFFER_JUCEHEADER__

/*** End of inlined file: juce_MidiBuffer.h ***/


#endif
#ifndef __JUCE_MIDIFILE_JUCEHEADER__

/*** Start of inlined file: juce_MidiFile.h ***/
#ifndef __JUCE_MIDIFILE_JUCEHEADER__
#define __JUCE_MIDIFILE_JUCEHEADER__


/*** Start of inlined file: juce_MidiMessageSequence.h ***/
#ifndef __JUCE_MIDIMESSAGESEQUENCE_JUCEHEADER__
#define __JUCE_MIDIMESSAGESEQUENCE_JUCEHEADER__

/**
	A sequence of timestamped midi messages.

	This allows the sequence to be manipulated, and also to be read from and
	written to a standard midi file.

	@see MidiMessage, MidiFile
*/
class JUCE_API  MidiMessageSequence
{
public:

	/** Creates an empty midi sequence object. */
	MidiMessageSequence();

	/** Creates a copy of another sequence. */
	MidiMessageSequence (const MidiMessageSequence& other);

	/** Replaces this sequence with another one. */
	MidiMessageSequence& operator= (const MidiMessageSequence& other);

	/** Destructor. */
	~MidiMessageSequence();

	/** Structure used to hold midi events in the sequence.

		These structures act as 'handles' on the events as they are moved about in
		the list, and make it quick to find the matching note-offs for note-on events.

		@see MidiMessageSequence::getEventPointer
	*/
	class MidiEventHolder
	{
	public:

		/** Destructor. */
		~MidiEventHolder();

		/** The message itself, whose timestamp is used to specify the event's time.
		*/
		MidiMessage message;

		/** The matching note-off event (if this is a note-on event).

			If this isn't a note-on, this pointer will be null.

			Use the MidiMessageSequence::updateMatchedPairs() method to keep these
			note-offs up-to-date after events have been moved around in the sequence
			or deleted.
		*/
		MidiEventHolder* noteOffObject;

	private:

		friend class MidiMessageSequence;
		MidiEventHolder (const MidiMessage& message);
		JUCE_LEAK_DETECTOR (MidiEventHolder);
	};

	/** Clears the sequence. */
	void clear();

	/** Returns the number of events in the sequence. */
	int getNumEvents() const;

	/** Returns a pointer to one of the events. */
	MidiEventHolder* getEventPointer (int index) const;

	/** Returns the time of the note-up that matches the note-on at this index.

		If the event at this index isn't a note-on, it'll just return 0.

		@see MidiMessageSequence::MidiEventHolder::noteOffObject
	*/
	double getTimeOfMatchingKeyUp (int index) const;

	/** Returns the index of the note-up that matches the note-on at this index.

		If the event at this index isn't a note-on, it'll just return -1.

		@see MidiMessageSequence::MidiEventHolder::noteOffObject
	*/
	int getIndexOfMatchingKeyUp (int index) const;

	/** Returns the index of an event. */
	int getIndexOf (MidiEventHolder* event) const;

	/** Returns the index of the first event on or after the given timestamp.

		If the time is beyond the end of the sequence, this will return the
		number of events.
	*/
	int getNextIndexAtTime (double timeStamp) const;

	/** Returns the timestamp of the first event in the sequence.

		@see getEndTime
	*/
	double getStartTime() const;

	/** Returns the timestamp of the last event in the sequence.

		@see getStartTime
	*/
	double getEndTime() const;

	/** Returns the timestamp of the event at a given index.

		If the index is out-of-range, this will return 0.0
	*/
	double getEventTime (int index) const;

	/** Inserts a midi message into the sequence.

		The index at which the new message gets inserted will depend on its timestamp,
		because the sequence is kept sorted.

		Remember to call updateMatchedPairs() after adding note-on events.

		@param newMessage       the new message to add (an internal copy will be made)
		@param timeAdjustment   an optional value to add to the timestamp of the message
								that will be inserted
		@see updateMatchedPairs
	*/
	void addEvent (const MidiMessage& newMessage,
				   double timeAdjustment = 0);

	/** Deletes one of the events in the sequence.

		Remember to call updateMatchedPairs() after removing events.

		@param index                 the index of the event to delete
		@param deleteMatchingNoteUp  whether to also remove the matching note-off
									 if the event you're removing is a note-on
	*/
	void deleteEvent (int index, bool deleteMatchingNoteUp);

	/** Merges another sequence into this one.

		Remember to call updateMatchedPairs() after using this method.

		@param other                    the sequence to add from
		@param timeAdjustmentDelta      an amount to add to the timestamps of the midi events
										as they are read from the other sequence
		@param firstAllowableDestTime   events will not be added if their time is earlier
										than this time. (This is after their time has been adjusted
										by the timeAdjustmentDelta)
		@param endOfAllowableDestTimes  events will not be added if their time is equal to
										or greater than this time. (This is after their time has
										been adjusted by the timeAdjustmentDelta)
	*/
	void addSequence (const MidiMessageSequence& other,
					  double timeAdjustmentDelta,
					  double firstAllowableDestTime,
					  double endOfAllowableDestTimes);

	/** Makes sure all the note-on and note-off pairs are up-to-date.

		Call this after moving messages about or deleting/adding messages, and it
		will scan the list and make sure all the note-offs in the MidiEventHolder
		structures are pointing at the correct ones.
	*/
	void updateMatchedPairs();

	/** Copies all the messages for a particular midi channel to another sequence.

		@param channelNumberToExtract   the midi channel to look for, in the range 1 to 16
		@param destSequence             the sequence that the chosen events should be copied to
		@param alsoIncludeMetaEvents    if true, any meta-events (which don't apply to a specific
										channel) will also be copied across.
		@see extractSysExMessages
	*/
	void extractMidiChannelMessages (int channelNumberToExtract,
									 MidiMessageSequence& destSequence,
									 bool alsoIncludeMetaEvents) const;

	/** Copies all midi sys-ex messages to another sequence.

		@param destSequence     this is the sequence to which any sys-exes in this sequence
								will be added
		@see extractMidiChannelMessages
	*/
	void extractSysExMessages (MidiMessageSequence& destSequence) const;

	/** Removes any messages in this sequence that have a specific midi channel.

		@param channelNumberToRemove    the midi channel to look for, in the range 1 to 16
	*/
	void deleteMidiChannelMessages (int channelNumberToRemove);

	/** Removes any sys-ex messages from this sequence.
	*/
	void deleteSysExMessages();

	/** Adds an offset to the timestamps of all events in the sequence.

		@param deltaTime    the amount to add to each timestamp.
	*/
	void addTimeToMessages (double deltaTime);

	/** Scans through the sequence to determine the state of any midi controllers at
		a given time.

		This will create a sequence of midi controller changes that can be
		used to set all midi controllers to the state they would be in at the
		specified time within this sequence.

		As well as controllers, it will also recreate the midi program number
		and pitch bend position.

		@param channelNumber    the midi channel to look for, in the range 1 to 16. Controllers
								for other channels will be ignored.
		@param time             the time at which you want to find out the state - there are
								no explicit units for this time measurement, it's the same units
								as used for the timestamps of the messages
		@param resultMessages   an array to which midi controller-change messages will be added. This
								will be the minimum number of controller changes to recreate the
								state at the required time.
	*/
	void createControllerUpdatesForTime (int channelNumber, double time,
										 OwnedArray<MidiMessage>& resultMessages);

	/** Swaps this sequence with another one. */
	void swapWith (MidiMessageSequence& other) noexcept;

private:

	friend class MidiFile;
	OwnedArray <MidiEventHolder> list;

	JUCE_LEAK_DETECTOR (MidiMessageSequence);
};

#endif   // __JUCE_MIDIMESSAGESEQUENCE_JUCEHEADER__

/*** End of inlined file: juce_MidiMessageSequence.h ***/

/**
	Reads/writes standard midi format files.

	To read a midi file, create a MidiFile object and call its readFrom() method. You
	can then get the individual midi tracks from it using the getTrack() method.

	To write a file, create a MidiFile object, add some MidiMessageSequence objects
	to it using the addTrack() method, and then call its writeTo() method to stream
	it out.

	@see MidiMessageSequence
*/
class JUCE_API  MidiFile
{
public:

	/** Creates an empty MidiFile object.
	*/
	MidiFile();

	/** Destructor. */
	~MidiFile();

	/** Returns the number of tracks in the file.

		@see getTrack, addTrack
	*/
	int getNumTracks() const noexcept;

	/** Returns a pointer to one of the tracks in the file.

		@returns a pointer to the track, or 0 if the index is out-of-range
		@see getNumTracks, addTrack
	*/
	const MidiMessageSequence* getTrack (int index) const noexcept;

	/** Adds a midi track to the file.

		This will make its own internal copy of the sequence that is passed-in.

		@see getNumTracks, getTrack
	*/
	void addTrack (const MidiMessageSequence& trackSequence);

	/** Removes all midi tracks from the file.

		@see getNumTracks
	*/
	void clear();

	/** Returns the raw time format code that will be written to a stream.

		After reading a midi file, this method will return the time-format that
		was read from the file's header. It can be changed using the setTicksPerQuarterNote()
		or setSmpteTimeFormat() methods.

		If the value returned is positive, it indicates the number of midi ticks
		per quarter-note - see setTicksPerQuarterNote().

		It it's negative, the upper byte indicates the frames-per-second (but negative), and
		the lower byte is the number of ticks per frame - see setSmpteTimeFormat().
	*/
	short getTimeFormat() const noexcept;

	/** Sets the time format to use when this file is written to a stream.

		If this is called, the file will be written as bars/beats using the
		specified resolution, rather than SMPTE absolute times, as would be
		used if setSmpteTimeFormat() had been called instead.

		@param ticksPerQuarterNote  e.g. 96, 960
		@see setSmpteTimeFormat
	*/
	void setTicksPerQuarterNote (int ticksPerQuarterNote) noexcept;

	/** Sets the time format to use when this file is written to a stream.

		If this is called, the file will be written using absolute times, rather
		than bars/beats as would be the case if setTicksPerBeat() had been called
		instead.

		@param framesPerSecond      must be 24, 25, 29 or 30
		@param subframeResolution   the sub-second resolution, e.g. 4 (midi time code),
									8, 10, 80 (SMPTE bit resolution), or 100. For millisecond
									timing, setSmpteTimeFormat (25, 40)
		@see setTicksPerBeat
	*/
	void setSmpteTimeFormat (int framesPerSecond,
							 int subframeResolution) noexcept;

	/** Makes a list of all the tempo-change meta-events from all tracks in the midi file.

		Useful for finding the positions of all the tempo changes in a file.

		@param tempoChangeEvents    a list to which all the events will be added
	*/
	void findAllTempoEvents (MidiMessageSequence& tempoChangeEvents) const;

	/** Makes a list of all the time-signature meta-events from all tracks in the midi file.

		Useful for finding the positions of all the tempo changes in a file.

		@param timeSigEvents        a list to which all the events will be added
	*/
	void findAllTimeSigEvents (MidiMessageSequence& timeSigEvents) const;

	/** Returns the latest timestamp in any of the tracks.

		(Useful for finding the length of the file).
	*/
	double getLastTimestamp() const;

	/** Reads a midi file format stream.

		After calling this, you can get the tracks that were read from the file by using the
		getNumTracks() and getTrack() methods.

		The timestamps of the midi events in the tracks will represent their positions in
		terms of midi ticks. To convert them to seconds, use the convertTimestampTicksToSeconds()
		method.

		@returns true if the stream was read successfully
	*/
	bool readFrom (InputStream& sourceStream);

	/** Writes the midi tracks as a standard midi file.

		@returns true if the operation succeeded.
	*/
	bool writeTo (OutputStream& destStream);

	/** Converts the timestamp of all the midi events from midi ticks to seconds.

		This will use the midi time format and tempo/time signature info in the
		tracks to convert all the timestamps to absolute values in seconds.
	*/
	void convertTimestampTicksToSeconds();

private:

	OwnedArray <MidiMessageSequence> tracks;
	short timeFormat;

	void readNextTrack (const uint8* data, int size);
	void writeTrack (OutputStream& mainOut, int trackNum);

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (MidiFile);
};

#endif   // __JUCE_MIDIFILE_JUCEHEADER__

/*** End of inlined file: juce_MidiFile.h ***/


#endif
#ifndef __JUCE_MIDIKEYBOARDSTATE_JUCEHEADER__

/*** Start of inlined file: juce_MidiKeyboardState.h ***/
#ifndef __JUCE_MIDIKEYBOARDSTATE_JUCEHEADER__
#define __JUCE_MIDIKEYBOARDSTATE_JUCEHEADER__

class MidiKeyboardState;

/**
	Receives events from a MidiKeyboardState object.

	@see MidiKeyboardState
*/
class JUCE_API  MidiKeyboardStateListener
{
public:

	MidiKeyboardStateListener() noexcept        {}
	virtual ~MidiKeyboardStateListener()        {}

	/** Called when one of the MidiKeyboardState's keys is pressed.

		This will be called synchronously when the state is either processing a
		buffer in its MidiKeyboardState::processNextMidiBuffer() method, or
		when a note is being played with its MidiKeyboardState::noteOn() method.

		Note that this callback could happen from an audio callback thread, so be
		careful not to block, and avoid any UI activity in the callback.
	*/
	virtual void handleNoteOn (MidiKeyboardState* source,
							   int midiChannel, int midiNoteNumber, float velocity) = 0;

	/** Called when one of the MidiKeyboardState's keys is released.

		This will be called synchronously when the state is either processing a
		buffer in its MidiKeyboardState::processNextMidiBuffer() method, or
		when a note is being played with its MidiKeyboardState::noteOff() method.

		Note that this callback could happen from an audio callback thread, so be
		careful not to block, and avoid any UI activity in the callback.
	*/
	virtual void handleNoteOff (MidiKeyboardState* source,
								int midiChannel, int midiNoteNumber) = 0;
};

/**
	Represents a piano keyboard, keeping track of which keys are currently pressed.

	This object can parse a stream of midi events, using them to update its idea
	of which keys are pressed for each individiual midi channel.

	When keys go up or down, it can broadcast these events to listener objects.

	It also allows key up/down events to be triggered with its noteOn() and noteOff()
	methods, and midi messages for these events will be merged into the
	midi stream that gets processed by processNextMidiBuffer().
*/
class JUCE_API  MidiKeyboardState
{
public:

	MidiKeyboardState();
	~MidiKeyboardState();

	/** Resets the state of the object.

		All internal data for all the channels is reset, but no events are sent as a
		result.

		If you want to release any keys that are currently down, and to send out note-up
		midi messages for this, use the allNotesOff() method instead.
	*/
	void reset();

	/** Returns true if the given midi key is currently held down for the given midi channel.

		The channel number must be between 1 and 16. If you want to see if any notes are
		on for a range of channels, use the isNoteOnForChannels() method.
	*/
	bool isNoteOn (int midiChannel, int midiNoteNumber) const noexcept;

	/** Returns true if the given midi key is currently held down on any of a set of midi channels.

		The channel mask has a bit set for each midi channel you want to test for - bit
		0 = midi channel 1, bit 1 = midi channel 2, etc.

		If a note is on for at least one of the specified channels, this returns true.
	*/
	bool isNoteOnForChannels (int midiChannelMask, int midiNoteNumber) const noexcept;

	/** Turns a specified note on.

		This will cause a suitable midi note-on event to be injected into the midi buffer during the
		next call to processNextMidiBuffer().

		It will also trigger a synchronous callback to the listeners to tell them that the key has
		gone down.
	*/
	void noteOn (int midiChannel, int midiNoteNumber, float velocity);

	/** Turns a specified note off.

		This will cause a suitable midi note-off event to be injected into the midi buffer during the
		next call to processNextMidiBuffer().

		It will also trigger a synchronous callback to the listeners to tell them that the key has
		gone up.

		But if the note isn't acutally down for the given channel, this method will in fact do nothing.
	*/
	void noteOff (int midiChannel, int midiNoteNumber);

	/** This will turn off any currently-down notes for the given midi channel.

		If you pass 0 for the midi channel, it will in fact turn off all notes on all channels.

		Calling this method will make calls to noteOff(), so can trigger synchronous callbacks
		and events being added to the midi stream.
	*/
	void allNotesOff (int midiChannel);

	/** Looks at a key-up/down event and uses it to update the state of this object.

		To process a buffer full of midi messages, use the processNextMidiBuffer() method
		instead.
	*/
	void processNextMidiEvent (const MidiMessage& message);

	/** Scans a midi stream for up/down events and adds its own events to it.

		This will look for any up/down events and use them to update the internal state,
		synchronously making suitable callbacks to the listeners.

		If injectIndirectEvents is true, then midi events to produce the recent noteOn()
		and noteOff() calls will be added into the buffer.

		Only the section of the buffer whose timestamps are between startSample and
		(startSample + numSamples) will be affected, and any events added will be placed
		between these times.

		If you're going to use this method, you'll need to keep calling it regularly for
		it to work satisfactorily.

		To process a single midi event at a time, use the processNextMidiEvent() method
		instead.
	*/
	void processNextMidiBuffer (MidiBuffer& buffer,
								int startSample,
								int numSamples,
								bool injectIndirectEvents);

	/** Registers a listener for callbacks when keys go up or down.

		@see removeListener
	*/
	void addListener (MidiKeyboardStateListener* listener);

	/** Deregisters a listener.

		@see addListener
	*/
	void removeListener (MidiKeyboardStateListener* listener);

private:

	CriticalSection lock;
	uint16 noteStates [128];
	MidiBuffer eventsToAdd;
	Array <MidiKeyboardStateListener*> listeners;

	void noteOnInternal (int midiChannel, int midiNoteNumber, float velocity);
	void noteOffInternal (int midiChannel, int midiNoteNumber);

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (MidiKeyboardState);
};

#endif   // __JUCE_MIDIKEYBOARDSTATE_JUCEHEADER__

/*** End of inlined file: juce_MidiKeyboardState.h ***/


#endif
#ifndef __JUCE_MIDIMESSAGE_JUCEHEADER__

#endif
#ifndef __JUCE_MIDIMESSAGESEQUENCE_JUCEHEADER__

#endif
#ifndef __JUCE_AUDIOSOURCE_JUCEHEADER__

/*** Start of inlined file: juce_AudioSource.h ***/
#ifndef __JUCE_AUDIOSOURCE_JUCEHEADER__
#define __JUCE_AUDIOSOURCE_JUCEHEADER__

/**
	Used by AudioSource::getNextAudioBlock().
*/
struct JUCE_API  AudioSourceChannelInfo
{
	/** The destination buffer to fill with audio data.

		When the AudioSource::getNextAudioBlock() method is called, the active section
		of this buffer should be filled with whatever output the source produces.

		Only the samples specified by the startSample and numSamples members of this structure
		should be affected by the call.

		The contents of the buffer when it is passed to the the AudioSource::getNextAudioBlock()
		method can be treated as the input if the source is performing some kind of filter operation,
		but should be cleared if this is not the case - the clearActiveBufferRegion() is
		a handy way of doing this.

		The number of channels in the buffer could be anything, so the AudioSource
		must cope with this in whatever way is appropriate for its function.
	*/
	AudioSampleBuffer* buffer;

	/** The first sample in the buffer from which the callback is expected
		to write data. */
	int startSample;

	/** The number of samples in the buffer which the callback is expected to
		fill with data. */
	int numSamples;

	/** Convenient method to clear the buffer if the source is not producing any data. */
	void clearActiveBufferRegion() const
	{
		if (buffer != nullptr)
			buffer->clear (startSample, numSamples);
	}
};

/**
	Base class for objects that can produce a continuous stream of audio.

	An AudioSource has two states: 'prepared' and 'unprepared'.

	When a source needs to be played, it is first put into a 'prepared' state by a call to
	prepareToPlay(), and then repeated calls will be made to its getNextAudioBlock() method to
	process the audio data.

	Once playback has finished, the releaseResources() method is called to put the stream
	back into an 'unprepared' state.

	@see AudioFormatReaderSource, ResamplingAudioSource
*/
class JUCE_API  AudioSource
{
protected:

	/** Creates an AudioSource. */
	AudioSource() noexcept      {}

public:
	/** Destructor. */
	virtual ~AudioSource()      {}

	/** Tells the source to prepare for playing.

		An AudioSource has two states: prepared and unprepared.

		The prepareToPlay() method is guaranteed to be called at least once on an 'unpreprared'
		source to put it into a 'prepared' state before any calls will be made to getNextAudioBlock().
		This callback allows the source to initialise any resources it might need when playing.

		Once playback has finished, the releaseResources() method is called to put the stream
		back into an 'unprepared' state.

		Note that this method could be called more than once in succession without
		a matching call to releaseResources(), so make sure your code is robust and
		can handle that kind of situation.

		@param samplesPerBlockExpected  the number of samples that the source
										will be expected to supply each time its
										getNextAudioBlock() method is called. This
										number may vary slightly, because it will be dependent
										on audio hardware callbacks, and these aren't
										guaranteed to always use a constant block size, so
										the source should be able to cope with small variations.
		@param sampleRate               the sample rate that the output will be used at - this
										is needed by sources such as tone generators.
		@see releaseResources, getNextAudioBlock
	*/
	virtual void prepareToPlay (int samplesPerBlockExpected,
								double sampleRate) = 0;

	/** Allows the source to release anything it no longer needs after playback has stopped.

		This will be called when the source is no longer going to have its getNextAudioBlock()
		method called, so it should release any spare memory, etc. that it might have
		allocated during the prepareToPlay() call.

		Note that there's no guarantee that prepareToPlay() will actually have been called before
		releaseResources(), and it may be called more than once in succession, so make sure your
		code is robust and doesn't make any assumptions about when it will be called.

		@see prepareToPlay, getNextAudioBlock
	*/
	virtual void releaseResources() = 0;

	/** Called repeatedly to fetch subsequent blocks of audio data.

		After calling the prepareToPlay() method, this callback will be made each
		time the audio playback hardware (or whatever other destination the audio
		data is going to) needs another block of data.

		It will generally be called on a high-priority system thread, or possibly even
		an interrupt, so be careful not to do too much work here, as that will cause
		audio glitches!

		@see AudioSourceChannelInfo, prepareToPlay, releaseResources
	*/
	virtual void getNextAudioBlock (const AudioSourceChannelInfo& bufferToFill) = 0;
};

#endif   // __JUCE_AUDIOSOURCE_JUCEHEADER__

/*** End of inlined file: juce_AudioSource.h ***/


#endif
#ifndef __JUCE_BUFFERINGAUDIOSOURCE_JUCEHEADER__

/*** Start of inlined file: juce_BufferingAudioSource.h ***/
#ifndef __JUCE_BUFFERINGAUDIOSOURCE_JUCEHEADER__
#define __JUCE_BUFFERINGAUDIOSOURCE_JUCEHEADER__


/*** Start of inlined file: juce_PositionableAudioSource.h ***/
#ifndef __JUCE_POSITIONABLEAUDIOSOURCE_JUCEHEADER__
#define __JUCE_POSITIONABLEAUDIOSOURCE_JUCEHEADER__

/**
	A type of AudioSource which can be repositioned.

	The basic AudioSource just streams continuously with no idea of a current
	time or length, so the PositionableAudioSource is used for a finite stream
	that has a current read position.

	@see AudioSource, AudioTransportSource
*/
class JUCE_API  PositionableAudioSource  : public AudioSource
{
protected:

	/** Creates the PositionableAudioSource. */
	PositionableAudioSource() noexcept  {}

public:
	/** Destructor */
	~PositionableAudioSource()          {}

	/** Tells the stream to move to a new position.

		Calling this indicates that the next call to AudioSource::getNextAudioBlock()
		should return samples from this position.

		Note that this may be called on a different thread to getNextAudioBlock(),
		so the subclass should make sure it's synchronised.
	*/
	virtual void setNextReadPosition (int64 newPosition) = 0;

	/** Returns the position from which the next block will be returned.

		@see setNextReadPosition
	*/
	virtual int64 getNextReadPosition() const = 0;

	/** Returns the total length of the stream (in samples). */
	virtual int64 getTotalLength() const = 0;

	/** Returns true if this source is actually playing in a loop. */
	virtual bool isLooping() const = 0;

	/** Tells the source whether you'd like it to play in a loop. */
	virtual void setLooping (bool shouldLoop)       { (void) shouldLoop; }
};

#endif   // __JUCE_POSITIONABLEAUDIOSOURCE_JUCEHEADER__

/*** End of inlined file: juce_PositionableAudioSource.h ***/

/**
	An AudioSource which takes another source as input, and buffers it using a thread.

	Create this as a wrapper around another thread, and it will read-ahead with
	a background thread to smooth out playback. You can either create one of these
	directly, or use it indirectly using an AudioTransportSource.

	@see PositionableAudioSource, AudioTransportSource
*/
class JUCE_API  BufferingAudioSource  : public PositionableAudioSource,
										private TimeSliceClient
{
public:

	/** Creates a BufferingAudioSource.

		@param source                   the input source to read from
		@param backgroundThread         a background thread that will be used for the
										background read-ahead. This object must not be deleted
										until after any BufferedAudioSources that are using it
										have been deleted!
		@param deleteSourceWhenDeleted  if true, then the input source object will
										be deleted when this object is deleted
		@param numberOfSamplesToBuffer  the size of buffer to use for reading ahead
		@param numberOfChannels         the number of channels that will be played
	*/
	BufferingAudioSource (PositionableAudioSource* source,
						  TimeSliceThread& backgroundThread,
						  bool deleteSourceWhenDeleted,
						  int numberOfSamplesToBuffer,
						  int numberOfChannels = 2);

	/** Destructor.

		The input source may be deleted depending on whether the deleteSourceWhenDeleted
		flag was set in the constructor.
	*/
	~BufferingAudioSource();

	/** Implementation of the AudioSource method. */
	void prepareToPlay (int samplesPerBlockExpected, double sampleRate);

	/** Implementation of the AudioSource method. */
	void releaseResources();

	/** Implementation of the AudioSource method. */
	void getNextAudioBlock (const AudioSourceChannelInfo& bufferToFill);

	/** Implements the PositionableAudioSource method. */
	void setNextReadPosition (int64 newPosition);

	/** Implements the PositionableAudioSource method. */
	int64 getNextReadPosition() const;

	/** Implements the PositionableAudioSource method. */
	int64 getTotalLength() const                { return source->getTotalLength(); }

	/** Implements the PositionableAudioSource method. */
	bool isLooping() const                      { return source->isLooping(); }

private:

	OptionalScopedPointer<PositionableAudioSource> source;
	TimeSliceThread& backgroundThread;
	int numberOfSamplesToBuffer, numberOfChannels;
	AudioSampleBuffer buffer;
	CriticalSection bufferStartPosLock;
	int64 volatile bufferValidStart, bufferValidEnd, nextPlayPos;
	double volatile sampleRate;
	bool wasSourceLooping, isPrepared;

	friend class SharedBufferingAudioSourceThread;
	bool readNextBufferChunk();
	void readBufferSection (int64 start, int length, int bufferOffset);
	int useTimeSlice();

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (BufferingAudioSource);
};

#endif   // __JUCE_BUFFERINGAUDIOSOURCE_JUCEHEADER__

/*** End of inlined file: juce_BufferingAudioSource.h ***/


#endif
#ifndef __JUCE_CHANNELREMAPPINGAUDIOSOURCE_JUCEHEADER__

/*** Start of inlined file: juce_ChannelRemappingAudioSource.h ***/
#ifndef __JUCE_CHANNELREMAPPINGAUDIOSOURCE_JUCEHEADER__
#define __JUCE_CHANNELREMAPPINGAUDIOSOURCE_JUCEHEADER__

/**
	An AudioSource that takes the audio from another source, and re-maps its
	input and output channels to a different arrangement.

	You can use this to increase or decrease the number of channels that an
	audio source uses, or to re-order those channels.

	Call the reset() method before using it to set up a default mapping, and then
	the setInputChannelMapping() and setOutputChannelMapping() methods to
	create an appropriate mapping, otherwise no channels will be connected and
	it'll produce silence.

	@see AudioSource
*/
class ChannelRemappingAudioSource  : public AudioSource
{
public:

	/** Creates a remapping source that will pass on audio from the given input.

		@param source       the input source to use. Make sure that this doesn't
							get deleted before the ChannelRemappingAudioSource object
		@param deleteSourceWhenDeleted  if true, the input source will be deleted
							when this object is deleted, if false, the caller is
							responsible for its deletion
	*/
	ChannelRemappingAudioSource (AudioSource* source,
								 bool deleteSourceWhenDeleted);

	/** Destructor. */
	~ChannelRemappingAudioSource();

	/** Specifies a number of channels that this audio source must produce from its
		getNextAudioBlock() callback.
	*/
	void setNumberOfChannelsToProduce (int requiredNumberOfChannels);

	/** Clears any mapped channels.

		After this, no channels are mapped, so this object will produce silence. Create
		some mappings with setInputChannelMapping() and setOutputChannelMapping().
	*/
	void clearAllMappings();

	/** Creates an input channel mapping.

		When the getNextAudioBlock() method is called, the data in channel sourceChannelIndex of the incoming
		data will be sent to destChannelIndex of our input source.

		@param destChannelIndex     the index of an input channel in our input audio source (i.e. the
									source specified when this object was created).
		@param sourceChannelIndex   the index of the input channel in the incoming audio data buffer
									during our getNextAudioBlock() callback
	*/
	void setInputChannelMapping (int destChannelIndex,
								 int sourceChannelIndex);

	/** Creates an output channel mapping.

		When the getNextAudioBlock() method is called, the data returned in channel sourceChannelIndex by
		our input audio source will be copied to channel destChannelIndex of the final buffer.

		@param sourceChannelIndex   the index of an output channel coming from our input audio source
									(i.e. the source specified when this object was created).
		@param destChannelIndex     the index of the output channel in the incoming audio data buffer
									during our getNextAudioBlock() callback
	*/
	void setOutputChannelMapping (int sourceChannelIndex,
								  int destChannelIndex);

	/** Returns the channel from our input that will be sent to channel inputChannelIndex of
		our input audio source.
	*/
	int getRemappedInputChannel (int inputChannelIndex) const;

	/** Returns the output channel to which channel outputChannelIndex of our input audio
		source will be sent to.
	*/
	int getRemappedOutputChannel (int outputChannelIndex) const;

	/** Returns an XML object to encapsulate the state of the mappings.

		@see restoreFromXml
	*/
	XmlElement* createXml() const;

	/** Restores the mappings from an XML object created by createXML().

		@see createXml
	*/
	void restoreFromXml (const XmlElement& e);

	void prepareToPlay (int samplesPerBlockExpected, double sampleRate);
	void releaseResources();
	void getNextAudioBlock (const AudioSourceChannelInfo& bufferToFill);

private:

	OptionalScopedPointer<AudioSource> source;
	Array <int> remappedInputs, remappedOutputs;
	int requiredNumberOfChannels;

	AudioSampleBuffer buffer;
	AudioSourceChannelInfo remappedInfo;

	CriticalSection lock;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ChannelRemappingAudioSource);
};

#endif   // __JUCE_CHANNELREMAPPINGAUDIOSOURCE_JUCEHEADER__

/*** End of inlined file: juce_ChannelRemappingAudioSource.h ***/


#endif
#ifndef __JUCE_IIRFILTERAUDIOSOURCE_JUCEHEADER__

/*** Start of inlined file: juce_IIRFilterAudioSource.h ***/
#ifndef __JUCE_IIRFILTERAUDIOSOURCE_JUCEHEADER__
#define __JUCE_IIRFILTERAUDIOSOURCE_JUCEHEADER__

/**
	An AudioSource that performs an IIR filter on another source.
*/
class JUCE_API  IIRFilterAudioSource  : public AudioSource
{
public:

	/** Creates a IIRFilterAudioSource for a given input source.

		@param inputSource              the input source to read from - this must not be null
		@param deleteInputWhenDeleted   if true, the input source will be deleted when
										this object is deleted
	*/
	IIRFilterAudioSource (AudioSource* inputSource,
						  bool deleteInputWhenDeleted);

	/** Destructor. */
	~IIRFilterAudioSource();

	/** Changes the filter to use the same parameters as the one being passed in. */
	void setFilterParameters (const IIRFilter& newSettings);

	void prepareToPlay (int samplesPerBlockExpected, double sampleRate);
	void releaseResources();
	void getNextAudioBlock (const AudioSourceChannelInfo& bufferToFill);

private:

	OptionalScopedPointer<AudioSource> input;
	OwnedArray <IIRFilter> iirFilters;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (IIRFilterAudioSource);
};

#endif   // __JUCE_IIRFILTERAUDIOSOURCE_JUCEHEADER__

/*** End of inlined file: juce_IIRFilterAudioSource.h ***/


#endif
#ifndef __JUCE_MIXERAUDIOSOURCE_JUCEHEADER__

/*** Start of inlined file: juce_MixerAudioSource.h ***/
#ifndef __JUCE_MIXERAUDIOSOURCE_JUCEHEADER__
#define __JUCE_MIXERAUDIOSOURCE_JUCEHEADER__

/**
	An AudioSource that mixes together the output of a set of other AudioSources.

	Input sources can be added and removed while the mixer is running as long as their
	prepareToPlay() and releaseResources() methods are called before and after adding
	them to the mixer.
*/
class JUCE_API  MixerAudioSource  : public AudioSource
{
public:

	/** Creates a MixerAudioSource.
	*/
	MixerAudioSource();

	/** Destructor. */
	~MixerAudioSource();

	/** Adds an input source to the mixer.

		If the mixer is running you'll need to make sure that the input source
		is ready to play by calling its prepareToPlay() method before adding it.
		If the mixer is stopped, then its input sources will be automatically
		prepared when the mixer's prepareToPlay() method is called.

		@param newInput             the source to add to the mixer
		@param deleteWhenRemoved    if true, then this source will be deleted when
									the mixer is deleted or when removeAllInputs() is
									called (unless the source is previously removed
									with the removeInputSource method)
	*/
	void addInputSource (AudioSource* newInput, bool deleteWhenRemoved);

	/** Removes an input source.

		If the mixer is running, this will remove the source but not call its
		releaseResources() method, so the caller might want to do this manually.

		@param input            the source to remove
		@param deleteSource     whether to delete this source after it's been removed
	*/
	void removeInputSource (AudioSource* input, bool deleteSource);

	/** Removes all the input sources.

		If the mixer is running, this will remove the sources but not call their
		releaseResources() method, so the caller might want to do this manually.

		Any sources which were added with the deleteWhenRemoved flag set will be
		deleted by this method.
	*/
	void removeAllInputs();

	/** Implementation of the AudioSource method.

		This will call prepareToPlay() on all its input sources.
	*/
	void prepareToPlay (int samplesPerBlockExpected, double sampleRate);

	/** Implementation of the AudioSource method.

		This will call releaseResources() on all its input sources.
	*/
	void releaseResources();

	/** Implementation of the AudioSource method. */
	void getNextAudioBlock (const AudioSourceChannelInfo& bufferToFill);

private:

	Array <AudioSource*> inputs;
	BigInteger inputsToDelete;
	CriticalSection lock;
	AudioSampleBuffer tempBuffer;
	double currentSampleRate;
	int bufferSizeExpected;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (MixerAudioSource);
};

#endif   // __JUCE_MIXERAUDIOSOURCE_JUCEHEADER__

/*** End of inlined file: juce_MixerAudioSource.h ***/


#endif
#ifndef __JUCE_POSITIONABLEAUDIOSOURCE_JUCEHEADER__

#endif
#ifndef __JUCE_RESAMPLINGAUDIOSOURCE_JUCEHEADER__

/*** Start of inlined file: juce_ResamplingAudioSource.h ***/
#ifndef __JUCE_RESAMPLINGAUDIOSOURCE_JUCEHEADER__
#define __JUCE_RESAMPLINGAUDIOSOURCE_JUCEHEADER__

/**
	A type of AudioSource that takes an input source and changes its sample rate.

	@see AudioSource
*/
class JUCE_API  ResamplingAudioSource  : public AudioSource
{
public:

	/** Creates a ResamplingAudioSource for a given input source.

		@param inputSource              the input source to read from
		@param deleteInputWhenDeleted   if true, the input source will be deleted when
										this object is deleted
		@param numChannels              the number of channels to process
	*/
	ResamplingAudioSource (AudioSource* inputSource,
						   bool deleteInputWhenDeleted,
						   int numChannels = 2);

	/** Destructor. */
	~ResamplingAudioSource();

	/** Changes the resampling ratio.

		(This value can be changed at any time, even while the source is running).

		@param samplesInPerOutputSample     if set to 1.0, the input is passed through; higher
											values will speed it up; lower values will slow it
											down. The ratio must be greater than 0
	*/
	void setResamplingRatio (double samplesInPerOutputSample);

	/** Returns the current resampling ratio.

		This is the value that was set by setResamplingRatio().
	*/
	double getResamplingRatio() const noexcept                  { return ratio; }

	void prepareToPlay (int samplesPerBlockExpected, double sampleRate);
	void releaseResources();
	void getNextAudioBlock (const AudioSourceChannelInfo& bufferToFill);

private:

	OptionalScopedPointer<AudioSource> input;
	double ratio, lastRatio;
	AudioSampleBuffer buffer;
	int bufferPos, sampsInBuffer;
	double subSampleOffset;
	double coefficients[6];
	SpinLock ratioLock;
	const int numChannels;
	HeapBlock<float*> destBuffers, srcBuffers;

	void setFilterCoefficients (double c1, double c2, double c3, double c4, double c5, double c6);
	void createLowPass (double proportionalRate);

	struct FilterState
	{
		double x1, x2, y1, y2;
	};

	HeapBlock<FilterState> filterStates;
	void resetFilters();

	void applyFilter (float* samples, int num, FilterState& fs);

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ResamplingAudioSource);
};

#endif   // __JUCE_RESAMPLINGAUDIOSOURCE_JUCEHEADER__

/*** End of inlined file: juce_ResamplingAudioSource.h ***/


#endif
#ifndef __JUCE_REVERBAUDIOSOURCE_JUCEHEADER__

/*** Start of inlined file: juce_ReverbAudioSource.h ***/
#ifndef __JUCE_REVERBAUDIOSOURCE_JUCEHEADER__
#define __JUCE_REVERBAUDIOSOURCE_JUCEHEADER__

/**
	An AudioSource that uses the Reverb class to apply a reverb to another AudioSource.

	@see Reverb
*/
class JUCE_API  ReverbAudioSource   : public AudioSource
{
public:
	/** Creates a ReverbAudioSource to process a given input source.

		@param inputSource              the input source to read from - this must not be null
		@param deleteInputWhenDeleted   if true, the input source will be deleted when
										this object is deleted
	*/
	ReverbAudioSource (AudioSource* inputSource,
					   bool deleteInputWhenDeleted);

	/** Destructor. */
	~ReverbAudioSource();

	/** Returns the parameters from the reverb. */
	const Reverb::Parameters& getParameters() const noexcept    { return reverb.getParameters(); }

	/** Changes the reverb's parameters. */
	void setParameters (const Reverb::Parameters& newParams);

	void setBypassed (bool isBypassed) noexcept;
	bool isBypassed() const noexcept                            { return bypass; }

	void prepareToPlay (int samplesPerBlockExpected, double sampleRate);
	void releaseResources();
	void getNextAudioBlock (const AudioSourceChannelInfo& bufferToFill);

private:

	CriticalSection lock;
	OptionalScopedPointer<AudioSource> input;
	Reverb reverb;
	volatile bool bypass;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ReverbAudioSource);
};

#endif   // __JUCE_REVERBAUDIOSOURCE_JUCEHEADER__

/*** End of inlined file: juce_ReverbAudioSource.h ***/


#endif
#ifndef __JUCE_TONEGENERATORAUDIOSOURCE_JUCEHEADER__

/*** Start of inlined file: juce_ToneGeneratorAudioSource.h ***/
#ifndef __JUCE_TONEGENERATORAUDIOSOURCE_JUCEHEADER__
#define __JUCE_TONEGENERATORAUDIOSOURCE_JUCEHEADER__

/**
	A simple AudioSource that generates a sine wave.

*/
class JUCE_API  ToneGeneratorAudioSource  : public AudioSource
{
public:

	/** Creates a ToneGeneratorAudioSource. */
	ToneGeneratorAudioSource();

	/** Destructor. */
	~ToneGeneratorAudioSource();

	/** Sets the signal's amplitude. */
	void setAmplitude (float newAmplitude);

	/** Sets the signal's frequency. */
	void setFrequency (double newFrequencyHz);

	/** Implementation of the AudioSource method. */
	void prepareToPlay (int samplesPerBlockExpected, double sampleRate);

	/** Implementation of the AudioSource method. */
	void releaseResources();

	/** Implementation of the AudioSource method. */
	void getNextAudioBlock (const AudioSourceChannelInfo& bufferToFill);

private:

	double frequency, sampleRate;
	double currentPhase, phasePerSample;
	float amplitude;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ToneGeneratorAudioSource);
};

#endif   // __JUCE_TONEGENERATORAUDIOSOURCE_JUCEHEADER__

/*** End of inlined file: juce_ToneGeneratorAudioSource.h ***/


#endif
#ifndef __JUCE_SYNTHESISER_JUCEHEADER__

/*** Start of inlined file: juce_Synthesiser.h ***/
#ifndef __JUCE_SYNTHESISER_JUCEHEADER__
#define __JUCE_SYNTHESISER_JUCEHEADER__

/**
	Describes one of the sounds that a Synthesiser can play.

	A synthesiser can contain one or more sounds, and a sound can choose which
	midi notes and channels can trigger it.

	The SynthesiserSound is a passive class that just describes what the sound is -
	the actual audio rendering for a sound is done by a SynthesiserVoice. This allows
	more than one SynthesiserVoice to play the same sound at the same time.

	@see Synthesiser, SynthesiserVoice
*/
class JUCE_API  SynthesiserSound    : public ReferenceCountedObject
{
protected:

	SynthesiserSound();

public:
	/** Destructor. */
	virtual ~SynthesiserSound();

	/** Returns true if this sound should be played when a given midi note is pressed.

		The Synthesiser will use this information when deciding which sounds to trigger
		for a given note.
	*/
	virtual bool appliesToNote (const int midiNoteNumber) = 0;

	/** Returns true if the sound should be triggered by midi events on a given channel.

		The Synthesiser will use this information when deciding which sounds to trigger
		for a given note.
	*/
	virtual bool appliesToChannel (const int midiChannel) = 0;

	/**
	*/
	typedef ReferenceCountedObjectPtr <SynthesiserSound> Ptr;

private:

	JUCE_LEAK_DETECTOR (SynthesiserSound);
};

/**
	Represents a voice that a Synthesiser can use to play a SynthesiserSound.

	A voice plays a single sound at a time, and a synthesiser holds an array of
	voices so that it can play polyphonically.

	@see Synthesiser, SynthesiserSound
*/
class JUCE_API  SynthesiserVoice
{
public:

	/** Creates a voice. */
	SynthesiserVoice();

	/** Destructor. */
	virtual ~SynthesiserVoice();

	/** Returns the midi note that this voice is currently playing.

		Returns a value less than 0 if no note is playing.
	*/
	int getCurrentlyPlayingNote() const                               { return currentlyPlayingNote; }

	/** Returns the sound that this voice is currently playing.

		Returns 0 if it's not playing.
	*/
	SynthesiserSound::Ptr getCurrentlyPlayingSound() const            { return currentlyPlayingSound; }

	/** Must return true if this voice object is capable of playing the given sound.

		If there are different classes of sound, and different classes of voice, a voice can
		choose which ones it wants to take on.

		A typical implementation of this method may just return true if there's only one type
		of voice and sound, or it might check the type of the sound object passed-in and
		see if it's one that it understands.
	*/
	virtual bool canPlaySound (SynthesiserSound* sound) = 0;

	/** Called to start a new note.

		This will be called during the rendering callback, so must be fast and thread-safe.
	*/
	virtual void startNote (const int midiNoteNumber,
							const float velocity,
							SynthesiserSound* sound,
							const int currentPitchWheelPosition) = 0;

	/** Called to stop a note.

		This will be called during the rendering callback, so must be fast and thread-safe.

		If allowTailOff is false or the voice doesn't want to tail-off, then it must stop all
		sound immediately, and must call clearCurrentNote() to reset the state of this voice
		and allow the synth to reassign it another sound.

		If allowTailOff is true and the voice decides to do a tail-off, then it's allowed to
		begin fading out its sound, and it can stop playing until it's finished. As soon as it
		finishes playing (during the rendering callback), it must make sure that it calls
		clearCurrentNote().
	*/
	virtual void stopNote (const bool allowTailOff) = 0;

	/** Called to let the voice know that the pitch wheel has been moved.

		This will be called during the rendering callback, so must be fast and thread-safe.
	*/
	virtual void pitchWheelMoved (const int newValue) = 0;

	/** Called to let the voice know that a midi controller has been moved.

		This will be called during the rendering callback, so must be fast and thread-safe.
	*/
	virtual void controllerMoved (const int controllerNumber,
								  const int newValue) = 0;

	/** Renders the next block of data for this voice.

		The output audio data must be added to the current contents of the buffer provided.
		Only the region of the buffer between startSample and (startSample + numSamples)
		should be altered by this method.

		If the voice is currently silent, it should just return without doing anything.

		If the sound that the voice is playing finishes during the course of this rendered
		block, it must call clearCurrentNote(), to tell the synthesiser that it has finished.

		The size of the blocks that are rendered can change each time it is called, and may
		involve rendering as little as 1 sample at a time. In between rendering callbacks,
		the voice's methods will be called to tell it about note and controller events.
	*/
	virtual void renderNextBlock (AudioSampleBuffer& outputBuffer,
								  int startSample,
								  int numSamples) = 0;

	/** Returns true if the voice is currently playing a sound which is mapped to the given
		midi channel.

		If it's not currently playing, this will return false.
	*/
	bool isPlayingChannel (int midiChannel) const;

	/** Changes the voice's reference sample rate.

		The rate is set so that subclasses know the output rate and can set their pitch
		accordingly.

		This method is called by the synth, and subclasses can access the current rate with
		the currentSampleRate member.
	*/
	void setCurrentPlaybackSampleRate (double newRate);

protected:

	/** Returns the current target sample rate at which rendering is being done.

		This is available for subclasses so they can pitch things correctly.
	*/
	double getSampleRate() const                                { return currentSampleRate; }

	/** Resets the state of this voice after a sound has finished playing.

		The subclass must call this when it finishes playing a note and becomes available
		to play new ones.

		It must either call it in the stopNote() method, or if the voice is tailing off,
		then it should call it later during the renderNextBlock method, as soon as it
		finishes its tail-off.

		It can also be called at any time during the render callback if the sound happens
		to have finished, e.g. if it's playing a sample and the sample finishes.
	*/
	void clearCurrentNote();

private:

	friend class Synthesiser;

	double currentSampleRate;
	int currentlyPlayingNote;
	uint32 noteOnTime;
	SynthesiserSound::Ptr currentlyPlayingSound;
	bool keyIsDown; // the voice may still be playing when the key is not down (i.e. sustain pedal)
	bool sostenutoPedalDown;

	JUCE_LEAK_DETECTOR (SynthesiserVoice);
};

/**
	Base class for a musical device that can play sounds.

	To create a synthesiser, you'll need to create a subclass of SynthesiserSound
	to describe each sound available to your synth, and a subclass of SynthesiserVoice
	which can play back one of these sounds.

	Then you can use the addVoice() and addSound() methods to give the synthesiser a
	set of sounds, and a set of voices it can use to play them. If you only give it
	one voice it will be monophonic - the more voices it has, the more polyphony it'll
	have available.

	Then repeatedly call the renderNextBlock() method to produce the audio. Any midi
	events that go in will be scanned for note on/off messages, and these are used to
	start and stop the voices playing the appropriate sounds.

	While it's playing, you can also cause notes to be triggered by calling the noteOn(),
	noteOff() and other controller methods.

	Before rendering, be sure to call the setCurrentPlaybackSampleRate() to tell it
	what the target playback rate is. This value is passed on to the voices so that
	they can pitch their output correctly.
*/
class JUCE_API  Synthesiser
{
public:

	/** Creates a new synthesiser.

		You'll need to add some sounds and voices before it'll make any sound..
	*/
	Synthesiser();

	/** Destructor. */
	virtual ~Synthesiser();

	/** Deletes all voices. */
	void clearVoices();

	/** Returns the number of voices that have been added. */
	int getNumVoices() const                                        { return voices.size(); }

	/** Returns one of the voices that have been added. */
	SynthesiserVoice* getVoice (int index) const;

	/** Adds a new voice to the synth.

		All the voices should be the same class of object and are treated equally.

		The object passed in will be managed by the synthesiser, which will delete
		it later on when no longer needed. The caller should not retain a pointer to the
		voice.
	*/
	void addVoice (SynthesiserVoice* newVoice);

	/** Deletes one of the voices. */
	void removeVoice (int index);

	/** Deletes all sounds. */
	void clearSounds();

	/** Returns the number of sounds that have been added to the synth. */
	int getNumSounds() const                                        { return sounds.size(); }

	/** Returns one of the sounds. */
	SynthesiserSound* getSound (int index) const                    { return sounds [index]; }

	/** Adds a new sound to the synthesiser.

		The object passed in is reference counted, so will be deleted when it is removed
		from the synthesiser, and when no voices are still using it.
	*/
	void addSound (const SynthesiserSound::Ptr& newSound);

	/** Removes and deletes one of the sounds. */
	void removeSound (int index);

	/** If set to true, then the synth will try to take over an existing voice if
		it runs out and needs to play another note.

		The value of this boolean is passed into findFreeVoice(), so the result will
		depend on the implementation of this method.
	*/
	void setNoteStealingEnabled (bool shouldStealNotes);

	/** Returns true if note-stealing is enabled.
		@see setNoteStealingEnabled
	*/
	bool isNoteStealingEnabled() const                              { return shouldStealNotes; }

	/** Triggers a note-on event.

		The default method here will find all the sounds that want to be triggered by
		this note/channel. For each sound, it'll try to find a free voice, and use the
		voice to start playing the sound.

		Subclasses might want to override this if they need a more complex algorithm.

		This method will be called automatically according to the midi data passed into
		renderNextBlock(), but may be called explicitly too.

		The midiChannel parameter is the channel, between 1 and 16 inclusive.
	*/
	virtual void noteOn (int midiChannel,
						 int midiNoteNumber,
						 float velocity);

	/** Triggers a note-off event.

		This will turn off any voices that are playing a sound for the given note/channel.

		If allowTailOff is true, the voices will be allowed to fade out the notes gracefully
		(if they can do). If this is false, the notes will all be cut off immediately.

		This method will be called automatically according to the midi data passed into
		renderNextBlock(), but may be called explicitly too.

		The midiChannel parameter is the channel, between 1 and 16 inclusive.
	*/
	virtual void noteOff (int midiChannel,
						  int midiNoteNumber,
						  bool allowTailOff);

	/** Turns off all notes.

		This will turn off any voices that are playing a sound on the given midi channel.

		If midiChannel is 0 or less, then all voices will be turned off, regardless of
		which channel they're playing. Otherwise it represents a valid midi channel, from
		1 to 16 inclusive.

		If allowTailOff is true, the voices will be allowed to fade out the notes gracefully
		(if they can do). If this is false, the notes will all be cut off immediately.

		This method will be called automatically according to the midi data passed into
		renderNextBlock(), but may be called explicitly too.
	*/
	virtual void allNotesOff (int midiChannel,
							  bool allowTailOff);

	/** Sends a pitch-wheel message.

		This will send a pitch-wheel message to any voices that are playing sounds on
		the given midi channel.

		This method will be called automatically according to the midi data passed into
		renderNextBlock(), but may be called explicitly too.

		@param midiChannel          the midi channel, from 1 to 16 inclusive
		@param wheelValue           the wheel position, from 0 to 0x3fff, as returned by MidiMessage::getPitchWheelValue()
	*/
	virtual void handlePitchWheel (int midiChannel,
								   int wheelValue);

	/** Sends a midi controller message.

		This will send a midi controller message to any voices that are playing sounds on
		the given midi channel.

		This method will be called automatically according to the midi data passed into
		renderNextBlock(), but may be called explicitly too.

		@param midiChannel          the midi channel, from 1 to 16 inclusive
		@param controllerNumber     the midi controller type, as returned by MidiMessage::getControllerNumber()
		@param controllerValue      the midi controller value, between 0 and 127, as returned by MidiMessage::getControllerValue()
	*/
	virtual void handleController (int midiChannel,
								   int controllerNumber,
								   int controllerValue);

	virtual void handleSustainPedal (int midiChannel, bool isDown);
	virtual void handleSostenutoPedal (int midiChannel, bool isDown);
	virtual void handleSoftPedal (int midiChannel, bool isDown);

	/** Tells the synthesiser what the sample rate is for the audio it's being used to
		render.

		This value is propagated to the voices so that they can use it to render the correct
		pitches.
	*/
	void setCurrentPlaybackSampleRate (double sampleRate);

	/** Creates the next block of audio output.

		This will process the next numSamples of data from all the voices, and add that output
		to the audio block supplied, starting from the offset specified. Note that the
		data will be added to the current contents of the buffer, so you should clear it
		before calling this method if necessary.

		The midi events in the inputMidi buffer are parsed for note and controller events,
		and these are used to trigger the voices. Note that the startSample offset applies
		both to the audio output buffer and the midi input buffer, so any midi events
		with timestamps outside the specified region will be ignored.
	*/
	void renderNextBlock (AudioSampleBuffer& outputAudio,
						  const MidiBuffer& inputMidi,
						  int startSample,
						  int numSamples);

protected:

	/** This is used to control access to the rendering callback and the note trigger methods. */
	CriticalSection lock;

	OwnedArray <SynthesiserVoice> voices;
	ReferenceCountedArray <SynthesiserSound> sounds;

	/** The last pitch-wheel values for each midi channel. */
	int lastPitchWheelValues [16];

	/** Searches through the voices to find one that's not currently playing, and which
		can play the given sound.

		Returns 0 if all voices are busy and stealing isn't enabled.

		This can be overridden to implement custom voice-stealing algorithms.
	*/
	virtual SynthesiserVoice* findFreeVoice (SynthesiserSound* soundToPlay,
											 const bool stealIfNoneAvailable) const;

	/** Starts a specified voice playing a particular sound.

		You'll probably never need to call this, it's used internally by noteOn(), but
		may be needed by subclasses for custom behaviours.
	*/
	void startVoice (SynthesiserVoice* voice,
					 SynthesiserSound* sound,
					 int midiChannel,
					 int midiNoteNumber,
					 float velocity);

private:

	double sampleRate;
	uint32 lastNoteOnCounter;
	bool shouldStealNotes;
	BigInteger sustainPedalsDown;

	void handleMidiEvent (const MidiMessage& m);
	void stopVoice (SynthesiserVoice* voice, bool allowTailOff);

   #if JUCE_CATCH_DEPRECATED_CODE_MISUSE
	// Note the new parameters for this method.
	virtual int findFreeVoice (const bool) const { return 0; }
   #endif

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (Synthesiser);
};

#endif   // __JUCE_SYNTHESISER_JUCEHEADER__

/*** End of inlined file: juce_Synthesiser.h ***/


#endif
// END_AUTOINCLUDE

}

#endif   // __JUCE_AUDIO_BASICS_JUCEHEADER__

/*** End of inlined file: juce_audio_basics.h ***/

/** Config: JUCE_USE_FLAC
	Enables the FLAC audio codec classes (available on all platforms).
	If your app doesn't need to read FLAC files, you might want to disable this to
	reduce the size of your codebase and build time.
*/
#ifndef JUCE_USE_FLAC
 #define JUCE_USE_FLAC 1
#endif

/** Config: JUCE_USE_OGGVORBIS
	Enables the Ogg-Vorbis audio codec classes (available on all platforms).
	If your app doesn't need to read Ogg-Vorbis files, you might want to disable this to
	reduce the size of your codebase and build time.
*/
#ifndef JUCE_USE_OGGVORBIS
 #define JUCE_USE_OGGVORBIS 1
#endif

/** Config: JUCE_USE_MP3AUDIOFORMAT
	Enables the software-based MP3AudioFormat class.
	IMPORTANT DISCLAIMER: By choosing to enable the JUCE_USE_MP3AUDIOFORMAT flag and to compile
	this MP3 code into your software, you do so AT YOUR OWN RISK! By doing so, you are agreeing
	that Raw Material Software is in no way responsible for any patent, copyright, or other
	legal issues that you may suffer as a result.

	The code in juce_MP3AudioFormat.cpp is NOT guaranteed to be free from infringements of 3rd-party
	intellectual property. If you wish to use it, please seek your own independent advice about the
	legality of doing so. If you are not willing to accept full responsibility for the consequences
	of using this code, then do not enable this setting.
*/
#ifndef JUCE_USE_MP3AUDIOFORMAT
 #define JUCE_USE_MP3AUDIOFORMAT 0
#endif

namespace juce
{

// START_AUTOINCLUDE format, codecs, sampler
#ifndef __JUCE_AUDIOFORMAT_JUCEHEADER__

/*** Start of inlined file: juce_AudioFormat.h ***/
#ifndef __JUCE_AUDIOFORMAT_JUCEHEADER__
#define __JUCE_AUDIOFORMAT_JUCEHEADER__


/*** Start of inlined file: juce_AudioFormatReader.h ***/
#ifndef __JUCE_AUDIOFORMATREADER_JUCEHEADER__
#define __JUCE_AUDIOFORMATREADER_JUCEHEADER__

class AudioFormat;

/**
	Reads samples from an audio file stream.

	A subclass that reads a specific type of audio format will be created by
	an AudioFormat object.

	@see AudioFormat, AudioFormatWriter
*/
class JUCE_API  AudioFormatReader
{
protected:

	/** Creates an AudioFormatReader object.

		@param sourceStream     the stream to read from - this will be deleted
								by this object when it is no longer needed. (Some
								specialised readers might not use this parameter and
								can leave it as 0).
		@param formatName       the description that will be returned by the getFormatName()
								method
	*/
	AudioFormatReader (InputStream* sourceStream,
					   const String& formatName);

public:
	/** Destructor. */
	virtual ~AudioFormatReader();

	/** Returns a description of what type of format this is.

		E.g. "AIFF"
	*/
	const String& getFormatName() const noexcept    { return formatName; }

	/** Reads samples from the stream.

		@param destSamples          an array of buffers into which the sample data for each
									channel will be written.
									If the format is fixed-point, each channel will be written
									as an array of 32-bit signed integers using the full
									range -0x80000000 to 0x7fffffff, regardless of the source's
									bit-depth. If it is a floating-point format, you should cast
									the resulting array to a (float**) to get the values (in the
									range -1.0 to 1.0 or beyond)
									If the format is stereo, then destSamples[0] is the left channel
									data, and destSamples[1] is the right channel.
									The numDestChannels parameter indicates how many pointers this array
									contains, but some of these pointers can be null if you don't want to
									read data for some of the channels
		@param numDestChannels      the number of array elements in the destChannels array
		@param startSampleInSource  the position in the audio file or stream at which the samples
									should be read, as a number of samples from the start of the
									stream. It's ok for this to be beyond the start or end of the
									available data - any samples that are out-of-range will be returned
									as zeros.
		@param numSamplesToRead     the number of samples to read. If this is greater than the number
									of samples that the file or stream contains. the result will be padded
									with zeros
		@param fillLeftoverChannelsWithCopies   if true, this indicates that if there's no source data available
									for some of the channels that you pass in, then they should be filled with
									copies of valid source channels.
									E.g. if you're reading a mono file and you pass 2 channels to this method, then
									if fillLeftoverChannelsWithCopies is true, both destination channels will be filled
									with the same data from the file's single channel. If fillLeftoverChannelsWithCopies
									was false, then only the first channel would be filled with the file's contents, and
									the second would be cleared. If there are many channels, e.g. you try to read 4 channels
									from a stereo file, then the last 3 would all end up with copies of the same data.
		@returns                    true if the operation succeeded, false if there was an error. Note
									that reading sections of data beyond the extent of the stream isn't an
									error - the reader should just return zeros for these regions
		@see readMaxLevels
	*/
	bool read (int* const* destSamples,
			   int numDestChannels,
			   int64 startSampleInSource,
			   int numSamplesToRead,
			   bool fillLeftoverChannelsWithCopies);

	/** Fills a section of an AudioSampleBuffer from this reader.

		This will convert the reader's fixed- or floating-point data to
		the buffer's floating-point format, and will try to intelligently
		cope with mismatches between the number of channels in the reader
		and the buffer.
	*/
	void read (AudioSampleBuffer* buffer,
			   int startSampleInDestBuffer,
			   int numSamples,
			   int64 readerStartSample,
			   bool useReaderLeftChan,
			   bool useReaderRightChan);

	/** Finds the highest and lowest sample levels from a section of the audio stream.

		This will read a block of samples from the stream, and measure the
		highest and lowest sample levels from the channels in that section, returning
		these as normalised floating-point levels.

		@param startSample          the offset into the audio stream to start reading from. It's
									ok for this to be beyond the start or end of the stream.
		@param numSamples           how many samples to read
		@param lowestLeft           on return, this is the lowest absolute sample from the left channel
		@param highestLeft          on return, this is the highest absolute sample from the left channel
		@param lowestRight          on return, this is the lowest absolute sample from the right
									channel (if there is one)
		@param highestRight         on return, this is the highest absolute sample from the right
									channel (if there is one)
		@see read
	*/
	virtual void readMaxLevels (int64 startSample,
								int64 numSamples,
								float& lowestLeft,
								float& highestLeft,
								float& lowestRight,
								float& highestRight);

	/** Scans the source looking for a sample whose magnitude is in a specified range.

		This will read from the source, either forwards or backwards between two sample
		positions, until it finds a sample whose magnitude lies between two specified levels.

		If it finds a suitable sample, it returns its position; if not, it will return -1.

		There's also a minimumConsecutiveSamples setting to help avoid spikes or zero-crossing
		points when you're searching for a continuous range of samples

		@param startSample              the first sample to look at
		@param numSamplesToSearch       the number of samples to scan. If this value is negative,
										the search will go backwards
		@param magnitudeRangeMinimum    the lowest magnitude (inclusive) that is considered a hit, from 0 to 1.0
		@param magnitudeRangeMaximum    the highest magnitude (inclusive) that is considered a hit, from 0 to 1.0
		@param minimumConsecutiveSamples    if this is > 0, the method will only look for a sequence
											of this many consecutive samples, all of which lie
											within the target range. When it finds such a sequence,
											it returns the position of the first in-range sample
											it found (i.e. the earliest one if scanning forwards, the
											latest one if scanning backwards)
	*/
	int64 searchForLevel (int64 startSample,
						  int64 numSamplesToSearch,
						  double magnitudeRangeMinimum,
						  double magnitudeRangeMaximum,
						  int minimumConsecutiveSamples);

	/** The sample-rate of the stream. */
	double sampleRate;

	/** The number of bits per sample, e.g. 16, 24, 32. */
	unsigned int bitsPerSample;

	/** The total number of samples in the audio stream. */
	int64 lengthInSamples;

	/** The total number of channels in the audio stream. */
	unsigned int numChannels;

	/** Indicates whether the data is floating-point or fixed. */
	bool usesFloatingPointData;

	/** A set of metadata values that the reader has pulled out of the stream.

		Exactly what these values are depends on the format, so you can
		check out the format implementation code to see what kind of stuff
		they understand.
	*/
	StringPairArray metadataValues;

	/** The input stream, for use by subclasses. */
	InputStream* input;

	/** Subclasses must implement this method to perform the low-level read operation.

		Callers should use read() instead of calling this directly.

		@param destSamples  the array of destination buffers to fill. Some of these
							pointers may be null
		@param numDestChannels  the number of items in the destSamples array. This
							value is guaranteed not to be greater than the number of
							channels that this reader object contains
		@param startOffsetInDestBuffer      the number of samples from the start of the
							dest data at which to begin writing
		@param startSampleInFile    the number of samples into the source data at which
							to begin reading. This value is guaranteed to be >= 0.
		@param numSamples   the number of samples to read
	*/
	virtual bool readSamples (int** destSamples,
							  int numDestChannels,
							  int startOffsetInDestBuffer,
							  int64 startSampleInFile,
							  int numSamples) = 0;

protected:

	/** Used by AudioFormatReader subclasses to copy data to different formats. */
	template <class DestSampleType, class SourceSampleType, class SourceEndianness>
	struct ReadHelper
	{
		typedef AudioData::Pointer <DestSampleType, AudioData::NativeEndian, AudioData::NonInterleaved, AudioData::NonConst>    DestType;
		typedef AudioData::Pointer <SourceSampleType, SourceEndianness, AudioData::Interleaved, AudioData::Const>               SourceType;

		static void read (int** destData, int destOffset, int numDestChannels, const void* sourceData, int numSourceChannels, int numSamples) noexcept
		{
			for (int i = 0; i < numDestChannels; ++i)
			{
				if (destData[i] != nullptr)
				{
					DestType dest (destData[i]);
					dest += destOffset;

					if (i < numSourceChannels)
						dest.convertSamples (SourceType (addBytesToPointer (sourceData, i * SourceType::getBytesPerSample()), numSourceChannels), numSamples);
					else
						dest.clearSamples (numSamples);
				}
			}
		}
	};

private:
	String formatName;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (AudioFormatReader);
};

#endif   // __JUCE_AUDIOFORMATREADER_JUCEHEADER__

/*** End of inlined file: juce_AudioFormatReader.h ***/


/*** Start of inlined file: juce_AudioFormatWriter.h ***/
#ifndef __JUCE_AUDIOFORMATWRITER_JUCEHEADER__
#define __JUCE_AUDIOFORMATWRITER_JUCEHEADER__

/**
	Writes samples to an audio file stream.

	A subclass that writes a specific type of audio format will be created by
	an AudioFormat object.

	After creating one of these with the AudioFormat::createWriterFor() method
	you can call its write() method to store the samples, and then delete it.

	@see AudioFormat, AudioFormatReader
*/
class JUCE_API  AudioFormatWriter
{
protected:

	/** Creates an AudioFormatWriter object.

		@param destStream       the stream to write to - this will be deleted
								by this object when it is no longer needed
		@param formatName       the description that will be returned by the getFormatName()
								method
		@param sampleRate       the sample rate to use - the base class just stores
								this value, it doesn't do anything with it
		@param numberOfChannels the number of channels to write - the base class just stores
								this value, it doesn't do anything with it
		@param bitsPerSample    the bit depth of the stream - the base class just stores
								this value, it doesn't do anything with it
	*/
	AudioFormatWriter (OutputStream* destStream,
					   const String& formatName,
					   double sampleRate,
					   unsigned int numberOfChannels,
					   unsigned int bitsPerSample);

public:
	/** Destructor. */
	virtual ~AudioFormatWriter();

	/** Returns a description of what type of format this is.

		E.g. "AIFF file"
	*/
	const String& getFormatName() const noexcept        { return formatName; }

	/** Writes a set of samples to the audio stream.

		Note that if you're trying to write the contents of an AudioSampleBuffer, you
		can use AudioSampleBuffer::writeToAudioWriter().

		@param samplesToWrite   an array of arrays containing the sample data for
								each channel to write. This is a zero-terminated
								array of arrays, and can contain a different number
								of channels than the actual stream uses, and the
								writer should do its best to cope with this.
								If the format is fixed-point, each channel will be formatted
								as an array of signed integers using the full 32-bit
								range -0x80000000 to 0x7fffffff, regardless of the source's
								bit-depth. If it is a floating-point format, you should treat
								the arrays as arrays of floats, and just cast it to an (int**)
								to pass it into the method.
		@param numSamples       the number of samples to write
	*/
	virtual bool write (const int** samplesToWrite,
						int numSamples) = 0;

	/** Reads a section of samples from an AudioFormatReader, and writes these to
		the output.

		This will take care of any floating-point conversion that's required to convert
		between the two formats. It won't deal with sample-rate conversion, though.

		If numSamplesToRead < 0, it will write the entire length of the reader.

		@returns false if it can't read or write properly during the operation
	*/
	bool writeFromAudioReader (AudioFormatReader& reader,
							   int64 startSample,
							   int64 numSamplesToRead);

	/** Reads some samples from an AudioSource, and writes these to the output.

		The source must already have been initialised with the AudioSource::prepareToPlay() method

		@param source               the source to read from
		@param numSamplesToRead     total number of samples to read and write
		@param samplesPerBlock      the maximum number of samples to fetch from the source
		@returns false if it can't read or write properly during the operation
	*/
	bool writeFromAudioSource (AudioSource& source,
							   int numSamplesToRead,
							   int samplesPerBlock = 2048);

	/** Writes some samples from an AudioSampleBuffer. */
	bool writeFromAudioSampleBuffer (const AudioSampleBuffer& source,
									 int startSample, int numSamples);

	/** Returns the sample rate being used. */
	double getSampleRate() const noexcept       { return sampleRate; }

	/** Returns the number of channels being written. */
	int getNumChannels() const noexcept         { return (int) numChannels; }

	/** Returns the bit-depth of the data being written. */
	int getBitsPerSample() const noexcept       { return (int) bitsPerSample; }

	/** Returns true if it's a floating-point format, false if it's fixed-point. */
	bool isFloatingPoint() const noexcept       { return usesFloatingPointData; }

	/**
		Provides a FIFO for an AudioFormatWriter, allowing you to push incoming
		data into a buffer which will be flushed to disk by a background thread.
	*/
	class ThreadedWriter
	{
	public:
		/** Creates a ThreadedWriter for a given writer and a thread.

			The writer object which is passed in here will be owned and deleted by
			the ThreadedWriter when it is no longer needed.

			To stop the writer and flush the buffer to disk, simply delete this object.
		*/
		ThreadedWriter (AudioFormatWriter* writer,
						TimeSliceThread& backgroundThread,
						int numSamplesToBuffer);

		/** Destructor. */
		~ThreadedWriter();

		/** Pushes some incoming audio data into the FIFO.

			If there's enough free space in the buffer, this will add the data to it,

			If the FIFO is too full to accept this many samples, the method will return
			false - then you could either wait until the background thread has had time to
			consume some of the buffered data and try again, or you can give up
			and lost this block.

			The data must be an array containing the same number of channels as the
			AudioFormatWriter object is using. None of these channels can be null.
		*/
		bool write (const float** data, int numSamples);

		class JUCE_API  IncomingDataReceiver
		{
		public:
			IncomingDataReceiver() {}
			virtual ~IncomingDataReceiver() {}

			virtual void reset (int numChannels, double sampleRate, int64 totalSamplesInSource) = 0;
			virtual void addBlock (int64 sampleNumberInSource, const AudioSampleBuffer& newData,
								   int startOffsetInBuffer, int numSamples) = 0;
		};

		/** Allows you to specify a callback that this writer should update with the
			incoming data.
			The receiver will be cleared and will the writer will begin adding data to
			it as the data arrives. Pass a null pointer to remove the current receiver.

			The object passed-in must not be deleted while this writer is still using it.
		*/
		void setDataReceiver (IncomingDataReceiver* receiver);

	private:
		class Buffer;
		friend class ScopedPointer<Buffer>;
		ScopedPointer<Buffer> buffer;
	};

protected:

	/** The sample rate of the stream. */
	double sampleRate;

	/** The number of channels being written to the stream. */
	unsigned int numChannels;

	/** The bit depth of the file. */
	unsigned int bitsPerSample;

	/** True if it's a floating-point format, false if it's fixed-point. */
	bool usesFloatingPointData;

	/** The output stream for Use by subclasses. */
	OutputStream* output;

	/** Used by AudioFormatWriter subclasses to copy data to different formats. */
	template <class DestSampleType, class SourceSampleType, class DestEndianness>
	struct WriteHelper
	{
		typedef AudioData::Pointer <DestSampleType, DestEndianness, AudioData::Interleaved, AudioData::NonConst>                DestType;
		typedef AudioData::Pointer <SourceSampleType, AudioData::NativeEndian, AudioData::NonInterleaved, AudioData::Const>     SourceType;

		static void write (void* destData, int numDestChannels, const int** source,
						   int numSamples, const int sourceOffset = 0) noexcept
		{
			for (int i = 0; i < numDestChannels; ++i)
			{
				const DestType dest (addBytesToPointer (destData, i * DestType::getBytesPerSample()), numDestChannels);

				if (*source != nullptr)
				{
					dest.convertSamples (SourceType (*source + sourceOffset), numSamples);
					++source;
				}
				else
				{
					dest.clearSamples (numSamples);
				}
			}
		}
	};

private:
	String formatName;
	friend class ThreadedWriter;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (AudioFormatWriter);
};

#endif   // __JUCE_AUDIOFORMATWRITER_JUCEHEADER__

/*** End of inlined file: juce_AudioFormatWriter.h ***/

/**
	Subclasses of AudioFormat are used to read and write different audio
	file formats.

	@see AudioFormatReader, AudioFormatWriter, WavAudioFormat, AiffAudioFormat
*/
class JUCE_API  AudioFormat
{
public:

	/** Destructor. */
	virtual ~AudioFormat();

	/** Returns the name of this format.

		e.g. "WAV file" or "AIFF file"
	*/
	const String& getFormatName() const;

	/** Returns all the file extensions that might apply to a file of this format.

		The first item will be the one that's preferred when creating a new file.

		So for a wav file this might just return ".wav"; for an AIFF file it might
		return two items, ".aif" and ".aiff"
	*/
	const StringArray& getFileExtensions() const;

	/** Returns true if this the given file can be read by this format.

		Subclasses shouldn't do too much work here, just check the extension or
		file type. The base class implementation just checks the file's extension
		against one of the ones that was registered in the constructor.
	*/
	virtual bool canHandleFile (const File& fileToTest);

	/** Returns a set of sample rates that the format can read and write. */
	virtual Array<int> getPossibleSampleRates() = 0;

	/** Returns a set of bit depths that the format can read and write. */
	virtual Array<int> getPossibleBitDepths() = 0;

	/** Returns true if the format can do 2-channel audio. */
	virtual bool canDoStereo() = 0;

	/** Returns true if the format can do 1-channel audio. */
	virtual bool canDoMono() = 0;

	/** Returns true if the format uses compressed data. */
	virtual bool isCompressed();

	/** Returns a list of different qualities that can be used when writing.

		Non-compressed formats will just return an empty array, but for something
		like Ogg-Vorbis or MP3, it might return a list of bit-rates, etc.

		When calling createWriterFor(), an index from this array is passed in to
		tell the format which option is required.
	*/
	virtual StringArray getQualityOptions();

	/** Tries to create an object that can read from a stream containing audio
		data in this format.

		The reader object that is returned can be used to read from the stream, and
		should then be deleted by the caller.

		@param sourceStream                 the stream to read from - the AudioFormatReader object
											that is returned will delete this stream when it no longer
											needs it.
		@param deleteStreamIfOpeningFails   if no reader can be created, this determines whether this method
											should delete the stream object that was passed-in. (If a valid
											reader is returned, it will always be in charge of deleting the
											stream, so this parameter is ignored)
		@see AudioFormatReader
	*/
	virtual AudioFormatReader* createReaderFor (InputStream* sourceStream,
												bool deleteStreamIfOpeningFails) = 0;

	/** Tries to create an object that can write to a stream with this audio format.

		The writer object that is returned can be used to write to the stream, and
		should then be deleted by the caller.

		If the stream can't be created for some reason (e.g. the parameters passed in
		here aren't suitable), this will return 0.

		@param streamToWriteTo      the stream that the data will go to - this will be
									deleted by the AudioFormatWriter object when it's no longer
									needed. If no AudioFormatWriter can be created by this method,
									the stream will NOT be deleted, so that the caller can re-use it
									to try to open a different format, etc
		@param sampleRateToUse      the sample rate for the file, which must be one of the ones
									returned by getPossibleSampleRates()
		@param numberOfChannels     the number of channels - this must be either 1 or 2, and
									the choice will depend on the results of canDoMono() and
									canDoStereo()
		@param bitsPerSample        the bits per sample to use - this must be one of the values
									returned by getPossibleBitDepths()
		@param metadataValues       a set of metadata values that the writer should try to write
									to the stream. Exactly what these are depends on the format,
									and the subclass doesn't actually have to do anything with
									them if it doesn't want to. Have a look at the specific format
									implementation classes to see possible values that can be
									used
		@param qualityOptionIndex   the index of one of compression qualities returned by the
									getQualityOptions() method. If there aren't any quality options
									for this format, just pass 0 in this parameter, as it'll be
									ignored
		@see AudioFormatWriter
	*/
	virtual AudioFormatWriter* createWriterFor (OutputStream* streamToWriteTo,
												double sampleRateToUse,
												unsigned int numberOfChannels,
												int bitsPerSample,
												const StringPairArray& metadataValues,
												int qualityOptionIndex) = 0;

protected:
	/** Creates an AudioFormat object.

		@param formatName       this sets the value that will be returned by getFormatName()
		@param fileExtensions   a zero-terminated list of file extensions - this is what will
								be returned by getFileExtension()
	*/
	AudioFormat (const String& formatName,
				 const StringArray& fileExtensions);

private:

	String formatName;
	StringArray fileExtensions;
};

#endif   // __JUCE_AUDIOFORMAT_JUCEHEADER__

/*** End of inlined file: juce_AudioFormat.h ***/


#endif
#ifndef __JUCE_AUDIOFORMATMANAGER_JUCEHEADER__

/*** Start of inlined file: juce_AudioFormatManager.h ***/
#ifndef __JUCE_AUDIOFORMATMANAGER_JUCEHEADER__
#define __JUCE_AUDIOFORMATMANAGER_JUCEHEADER__

/**
	A class for keeping a list of available audio formats, and for deciding which
	one to use to open a given file.

	After creating an AudioFormatManager object, you should call registerFormat()
	or registerBasicFormats() to give it a list of format types that it can use.

	@see AudioFormat
*/
class JUCE_API  AudioFormatManager
{
public:

	/** Creates an empty format manager.

		Before it'll be any use, you'll need to call registerFormat() with all the
		formats you want it to be able to recognise.
	*/
	AudioFormatManager();

	/** Destructor. */
	~AudioFormatManager();

	/** Adds a format to the manager's list of available file types.

		The object passed-in will be deleted by this object, so don't keep a pointer
		to it!

		If makeThisTheDefaultFormat is true, then the getDefaultFormat() method will
		return this one when called.
	*/
	void registerFormat (AudioFormat* newFormat,
						 bool makeThisTheDefaultFormat);

	/** Handy method to make it easy to register the formats that come with Juce.

		Currently, this will add WAV and AIFF to the list.
	*/
	void registerBasicFormats();

	/** Clears the list of known formats. */
	void clearFormats();

	/** Returns the number of currently registered file formats. */
	int getNumKnownFormats() const;

	/** Returns one of the registered file formats. */
	AudioFormat* getKnownFormat (int index) const;

	/** Looks for which of the known formats is listed as being for a given file
		extension.

		The extension may have a dot before it, so e.g. ".wav" or "wav" are both ok.
	*/
	AudioFormat* findFormatForFileExtension (const String& fileExtension) const;

	/** Returns the format which has been set as the default one.

		You can set a format as being the default when it is registered. It's useful
		when you want to write to a file, because the best format may change between
		platforms, e.g. AIFF is preferred on the Mac, WAV on Windows.

		If none has been set as the default, this method will just return the first
		one in the list.
	*/
	AudioFormat* getDefaultFormat() const;

	/** Returns a set of wildcards for file-matching that contains the extensions for
		all known formats.

		E.g. if might return "*.wav;*.aiff" if it just knows about wavs and aiffs.
	*/
	String getWildcardForAllFormats() const;

	/** Searches through the known formats to try to create a suitable reader for
		this file.

		If none of the registered formats can open the file, it'll return 0. If it
		returns a reader, it's the caller's responsibility to delete the reader.
	*/
	AudioFormatReader* createReaderFor (const File& audioFile);

	/** Searches through the known formats to try to create a suitable reader for
		this stream.

		The stream object that is passed-in will be deleted by this method or by the
		reader that is returned, so the caller should not keep any references to it.

		The stream that is passed-in must be capable of being repositioned so
		that all the formats can have a go at opening it.

		If none of the registered formats can open the stream, it'll return 0. If it
		returns a reader, it's the caller's responsibility to delete the reader.
	*/
	AudioFormatReader* createReaderFor (InputStream* audioFileStream);

private:

	OwnedArray<AudioFormat> knownFormats;
	int defaultFormatIndex;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (AudioFormatManager);
};

#endif   // __JUCE_AUDIOFORMATMANAGER_JUCEHEADER__

/*** End of inlined file: juce_AudioFormatManager.h ***/


#endif
#ifndef __JUCE_AUDIOFORMATREADER_JUCEHEADER__

#endif
#ifndef __JUCE_AUDIOFORMATREADERSOURCE_JUCEHEADER__

/*** Start of inlined file: juce_AudioFormatReaderSource.h ***/
#ifndef __JUCE_AUDIOFORMATREADERSOURCE_JUCEHEADER__
#define __JUCE_AUDIOFORMATREADERSOURCE_JUCEHEADER__

/**
	A type of AudioSource that will read from an AudioFormatReader.

	@see PositionableAudioSource, AudioTransportSource, BufferingAudioSource
*/
class JUCE_API  AudioFormatReaderSource  : public PositionableAudioSource
{
public:

	/** Creates an AudioFormatReaderSource for a given reader.

		@param sourceReader                     the reader to use as the data source - this must
												not be null
		@param deleteReaderWhenThisIsDeleted    if true, the reader passed-in will be deleted
												when this object is deleted; if false it will be
												left up to the caller to manage its lifetime
	*/
	AudioFormatReaderSource (AudioFormatReader* sourceReader,
							 bool deleteReaderWhenThisIsDeleted);

	/** Destructor. */
	~AudioFormatReaderSource();

	/** Toggles loop-mode.

		If set to true, it will continuously loop the input source. If false,
		it will just emit silence after the source has finished.

		@see isLooping
	*/
	void setLooping (bool shouldLoop);

	/** Returns whether loop-mode is turned on or not. */
	bool isLooping() const                                      { return looping; }

	/** Returns the reader that's being used. */
	AudioFormatReader* getAudioFormatReader() const noexcept    { return reader; }

	/** Implementation of the AudioSource method. */
	void prepareToPlay (int samplesPerBlockExpected, double sampleRate);

	/** Implementation of the AudioSource method. */
	void releaseResources();

	/** Implementation of the AudioSource method. */
	void getNextAudioBlock (const AudioSourceChannelInfo& bufferToFill);

	/** Implements the PositionableAudioSource method. */
	void setNextReadPosition (int64 newPosition);

	/** Implements the PositionableAudioSource method. */
	int64 getNextReadPosition() const;

	/** Implements the PositionableAudioSource method. */
	int64 getTotalLength() const;

private:

	OptionalScopedPointer<AudioFormatReader> reader;

	int64 volatile nextPlayPos;
	bool volatile looping;

	void readBufferSection (int start, int length, AudioSampleBuffer& buffer, int startSample);

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (AudioFormatReaderSource);
};

#endif   // __JUCE_AUDIOFORMATREADERSOURCE_JUCEHEADER__

/*** End of inlined file: juce_AudioFormatReaderSource.h ***/


#endif
#ifndef __JUCE_AUDIOFORMATWRITER_JUCEHEADER__

#endif
#ifndef __JUCE_AUDIOSUBSECTIONREADER_JUCEHEADER__

/*** Start of inlined file: juce_AudioSubsectionReader.h ***/
#ifndef __JUCE_AUDIOSUBSECTIONREADER_JUCEHEADER__
#define __JUCE_AUDIOSUBSECTIONREADER_JUCEHEADER__

/**
	This class is used to wrap an AudioFormatReader and only read from a
	subsection of the file.

	So if you have a reader which can read a 1000 sample file, you could wrap it
	in one of these to only access, e.g. samples 100 to 200, and any samples
	outside that will come back as 0. Accessing sample 0 from this reader will
	actually read the first sample from the other's subsection, which might
	be at a non-zero position.

	@see AudioFormatReader
*/
class JUCE_API  AudioSubsectionReader  : public AudioFormatReader
{
public:

	/** Creates a AudioSubsectionReader for a given data source.

		@param sourceReader             the source reader from which we'll be taking data
		@param subsectionStartSample    the sample within the source reader which will be
										mapped onto sample 0 for this reader.
		@param subsectionLength         the number of samples from the source that will
										make up the subsection. If this reader is asked for
										any samples beyond this region, it will return zero.
		@param deleteSourceWhenDeleted  if true, the sourceReader object will be deleted when
										this object is deleted.
	*/
	AudioSubsectionReader (AudioFormatReader* sourceReader,
						   int64 subsectionStartSample,
						   int64 subsectionLength,
						   bool deleteSourceWhenDeleted);

	/** Destructor. */
	~AudioSubsectionReader();

	bool readSamples (int** destSamples, int numDestChannels, int startOffsetInDestBuffer,
					  int64 startSampleInFile, int numSamples);

	void readMaxLevels (int64 startSample,
						int64 numSamples,
						float& lowestLeft,
						float& highestLeft,
						float& lowestRight,
						float& highestRight);

private:

	AudioFormatReader* const source;
	int64 startSample, length;
	const bool deleteSourceWhenDeleted;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (AudioSubsectionReader);
};

#endif   // __JUCE_AUDIOSUBSECTIONREADER_JUCEHEADER__

/*** End of inlined file: juce_AudioSubsectionReader.h ***/


#endif

/*** Start of inlined file: juce_AiffAudioFormat.h ***/
/**
	Reads and Writes AIFF format audio files.

	@see AudioFormat
*/
class JUCE_API  AiffAudioFormat  : public AudioFormat
{
public:

	/** Creates an format object. */
	AiffAudioFormat();

	/** Destructor. */
	~AiffAudioFormat();

	Array<int> getPossibleSampleRates();
	Array<int> getPossibleBitDepths();
	bool canDoStereo();
	bool canDoMono();

   #if JUCE_MAC
	bool canHandleFile (const File& fileToTest);
   #endif

	AudioFormatReader* createReaderFor (InputStream* sourceStream,
										bool deleteStreamIfOpeningFails);

	AudioFormatWriter* createWriterFor (OutputStream* streamToWriteTo,
										double sampleRateToUse,
										unsigned int numberOfChannels,
										int bitsPerSample,
										const StringPairArray& metadataValues,
										int qualityOptionIndex);

private:
	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(AiffAudioFormat);
};

/*** End of inlined file: juce_AiffAudioFormat.h ***/



/*** Start of inlined file: juce_CoreAudioFormat.h ***/
#if JUCE_MAC || JUCE_IOS

/**
	OSX and iOS only - This uses the AudioToolbox framework to read any audio
	format that the system has a codec for.

	This should be able to understand formats such as mp3, m4a, etc.

	@see AudioFormat
 */
class JUCE_API  CoreAudioFormat     : public AudioFormat
{
public:

	/** Creates a format object. */
	CoreAudioFormat();

	/** Destructor. */
	~CoreAudioFormat();

	Array<int> getPossibleSampleRates();
	Array<int> getPossibleBitDepths();
	bool canDoStereo();
	bool canDoMono();

	AudioFormatReader* createReaderFor (InputStream* sourceStream,
										bool deleteStreamIfOpeningFails);

	AudioFormatWriter* createWriterFor (OutputStream* streamToWriteTo,
										double sampleRateToUse,
										unsigned int numberOfChannels,
										int bitsPerSample,
										const StringPairArray& metadataValues,
										int qualityOptionIndex);

private:
	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (CoreAudioFormat);
};

#endif

/*** End of inlined file: juce_CoreAudioFormat.h ***/


/*** Start of inlined file: juce_FlacAudioFormat.h ***/
#if JUCE_USE_FLAC || defined (DOXYGEN)

/**
	Reads and writes the lossless-compression FLAC audio format.

	To compile this, you'll need to set the JUCE_USE_FLAC flag.

	@see AudioFormat
*/
class JUCE_API  FlacAudioFormat    : public AudioFormat
{
public:

	FlacAudioFormat();
	~FlacAudioFormat();

	Array<int> getPossibleSampleRates();
	Array<int> getPossibleBitDepths();
	bool canDoStereo();
	bool canDoMono();
	bool isCompressed();
	StringArray getQualityOptions();

	AudioFormatReader* createReaderFor (InputStream* sourceStream,
										bool deleteStreamIfOpeningFails);

	AudioFormatWriter* createWriterFor (OutputStream* streamToWriteTo,
										double sampleRateToUse,
										unsigned int numberOfChannels,
										int bitsPerSample,
										const StringPairArray& metadataValues,
										int qualityOptionIndex);
private:
	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (FlacAudioFormat);
};

#endif

/*** End of inlined file: juce_FlacAudioFormat.h ***/


/*** Start of inlined file: juce_MP3AudioFormat.h ***/
#if JUCE_USE_MP3AUDIOFORMAT

/**
	Software-based MP3 decoding format (doesn't currently provide an encoder).

	IMPORTANT DISCLAIMER: By choosing to enable the JUCE_USE_MP3AUDIOFORMAT flag and
	to compile the MP3 code into your software, you do so AT YOUR OWN RISK! By doing so,
	you are agreeing that Raw Material Software is in no way responsible for any patent,
	copyright, or other legal issues that you may suffer as a result.

	The code in juce_MP3AudioFormat.cpp is NOT guaranteed to be free from infringements of 3rd-party
	intellectual property. If you wish to use it, please seek your own independent advice about the
	legality of doing so. If you are not willing to accept full responsibility for the consequences
	of using this code, then do not enable the JUCE_USE_MP3AUDIOFORMAT setting.
*/
class MP3AudioFormat  : public AudioFormat
{
public:

	MP3AudioFormat();
	~MP3AudioFormat();

	Array<int> getPossibleSampleRates();
	Array<int> getPossibleBitDepths();
	bool canDoStereo();
	bool canDoMono();
	bool isCompressed();
	StringArray getQualityOptions();

	AudioFormatReader* createReaderFor (InputStream*, bool deleteStreamIfOpeningFails);

	AudioFormatWriter* createWriterFor (OutputStream*, double sampleRateToUse,
										unsigned int numberOfChannels, int bitsPerSample,
										const StringPairArray& metadataValues, int qualityOptionIndex);
};

#endif

/*** End of inlined file: juce_MP3AudioFormat.h ***/


/*** Start of inlined file: juce_OggVorbisAudioFormat.h ***/
#if JUCE_USE_OGGVORBIS || defined (DOXYGEN)

/**
	Reads and writes the Ogg-Vorbis audio format.

	To compile this, you'll need to set the JUCE_USE_OGGVORBIS flag.

	@see AudioFormat,
*/
class JUCE_API  OggVorbisAudioFormat : public AudioFormat
{
public:

	OggVorbisAudioFormat();
	~OggVorbisAudioFormat();

	Array<int> getPossibleSampleRates();
	Array<int> getPossibleBitDepths();
	bool canDoStereo();
	bool canDoMono();
	bool isCompressed();
	StringArray getQualityOptions();

	/** Tries to estimate the quality level of an ogg file based on its size.

		If it can't read the file for some reason, this will just return 1 (medium quality),
		otherwise it will return the approximate quality setting that would have been used
		to create the file.

		@see getQualityOptions
	*/
	int estimateOggFileQuality (const File& source);

	/** Metadata property name used by the Ogg writer - if you set a string for this
		value, it will be written into the ogg file as the name of the encoder app.

		@see createWriterFor
	*/
	static const char* const encoderName;

	AudioFormatReader* createReaderFor (InputStream* sourceStream,
										bool deleteStreamIfOpeningFails);

	AudioFormatWriter* createWriterFor (OutputStream* streamToWriteTo,
										double sampleRateToUse,
										unsigned int numberOfChannels,
										int bitsPerSample,
										const StringPairArray& metadataValues,
										int qualityOptionIndex);

private:
	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (OggVorbisAudioFormat);
};

#endif

/*** End of inlined file: juce_OggVorbisAudioFormat.h ***/


/*** Start of inlined file: juce_QuickTimeAudioFormat.h ***/
#if JUCE_QUICKTIME

/**
	Uses QuickTime to read the audio track a movie or media file.

	As well as QuickTime movies, this should also manage to open other audio
	files that quicktime can understand, like mp3, m4a, etc.

	@see AudioFormat
*/
class JUCE_API  QuickTimeAudioFormat  : public AudioFormat
{
public:

	/** Creates a format object. */
	QuickTimeAudioFormat();

	/** Destructor. */
	~QuickTimeAudioFormat();

	Array<int> getPossibleSampleRates();
	Array<int> getPossibleBitDepths();
	bool canDoStereo();
	bool canDoMono();

	AudioFormatReader* createReaderFor (InputStream* sourceStream,
										bool deleteStreamIfOpeningFails);

	AudioFormatWriter* createWriterFor (OutputStream* streamToWriteTo,
										double sampleRateToUse,
										unsigned int numberOfChannels,
										int bitsPerSample,
										const StringPairArray& metadataValues,
										int qualityOptionIndex);

private:
	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (QuickTimeAudioFormat);
};

#endif

/*** End of inlined file: juce_QuickTimeAudioFormat.h ***/


/*** Start of inlined file: juce_WavAudioFormat.h ***/
/**
	Reads and Writes WAV format audio files.

	@see AudioFormat
*/
class JUCE_API  WavAudioFormat  : public AudioFormat
{
public:

	/** Creates a format object. */
	WavAudioFormat();

	/** Destructor. */
	~WavAudioFormat();

	/** Metadata property name used by wav readers and writers for adding
		a BWAV chunk to the file.

		@see AudioFormatReader::metadataValues, createWriterFor
	*/
	static const char* const bwavDescription;

	/** Metadata property name used by wav readers and writers for adding
		a BWAV chunk to the file.

		@see AudioFormatReader::metadataValues, createWriterFor
	*/
	static const char* const bwavOriginator;

	/** Metadata property name used by wav readers and writers for adding
		a BWAV chunk to the file.

		@see AudioFormatReader::metadataValues, createWriterFor
	*/
	static const char* const bwavOriginatorRef;

	/** Metadata property name used by wav readers and writers for adding
		a BWAV chunk to the file.

		Date format is: yyyy-mm-dd

		@see AudioFormatReader::metadataValues, createWriterFor
	*/
	static const char* const bwavOriginationDate;

	/** Metadata property name used by wav readers and writers for adding
		a BWAV chunk to the file.

		Time format is: hh-mm-ss

		@see AudioFormatReader::metadataValues, createWriterFor
	*/
	static const char* const bwavOriginationTime;

	/** Metadata property name used by wav readers and writers for adding
		a BWAV chunk to the file.

		This is the number of samples from the start of an edit that the
		file is supposed to begin at. Seems like an obvious mistake to
		only allow a file to occur in an edit once, but that's the way
		it is..

		@see AudioFormatReader::metadataValues, createWriterFor
	*/
	static const char* const bwavTimeReference;

	/** Metadata property name used by wav readers and writers for adding
		a BWAV chunk to the file.

		This is a

		@see AudioFormatReader::metadataValues, createWriterFor
	*/
	static const char* const bwavCodingHistory;

	/** Utility function to fill out the appropriate metadata for a BWAV file.

		This just makes it easier than using the property names directly, and it
		fills out the time and date in the right format.
	*/
	static StringPairArray createBWAVMetadata (const String& description,
											   const String& originator,
											   const String& originatorRef,
											   const Time& dateAndTime,
											   const int64 timeReferenceSamples,
											   const String& codingHistory);

	Array<int> getPossibleSampleRates();
	Array<int> getPossibleBitDepths();
	bool canDoStereo();
	bool canDoMono();

	AudioFormatReader* createReaderFor (InputStream* sourceStream,
										bool deleteStreamIfOpeningFails);

	AudioFormatWriter* createWriterFor (OutputStream* streamToWriteTo,
										double sampleRateToUse,
										unsigned int numberOfChannels,
										int bitsPerSample,
										const StringPairArray& metadataValues,
										int qualityOptionIndex);

	/** Utility function to replace the metadata in a wav file with a new set of values.

		If possible, this cheats by overwriting just the metadata region of the file, rather
		than by copying the whole file again.
	*/
	bool replaceMetadataInFile (const File& wavFile, const StringPairArray& newMetadata);

private:
	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (WavAudioFormat);
};

/*** End of inlined file: juce_WavAudioFormat.h ***/


/*** Start of inlined file: juce_WindowsMediaAudioFormat.h ***/
#if JUCE_WINDOWS

/**
	Audio format which uses the Windows Media codecs (Windows only).
*/
class WindowsMediaAudioFormat  : public AudioFormat
{
public:

	WindowsMediaAudioFormat();
	~WindowsMediaAudioFormat();

	Array<int> getPossibleSampleRates();
	Array<int> getPossibleBitDepths();
	bool canDoStereo();
	bool canDoMono();

	AudioFormatReader* createReaderFor (InputStream*, bool deleteStreamIfOpeningFails);

	AudioFormatWriter* createWriterFor (OutputStream*, double sampleRateToUse,
										unsigned int numberOfChannels, int bitsPerSample,
										const StringPairArray& metadataValues, int qualityOptionIndex);
};

#endif

/*** End of inlined file: juce_WindowsMediaAudioFormat.h ***/

#ifndef __JUCE_SAMPLER_JUCEHEADER__

/*** Start of inlined file: juce_Sampler.h ***/
#ifndef __JUCE_SAMPLER_JUCEHEADER__
#define __JUCE_SAMPLER_JUCEHEADER__

/**
	A subclass of SynthesiserSound that represents a sampled audio clip.

	This is a pretty basic sampler, and just attempts to load the whole audio stream
	into memory.

	To use it, create a Synthesiser, add some SamplerVoice objects to it, then
	give it some SampledSound objects to play.

	@see SamplerVoice, Synthesiser, SynthesiserSound
*/
class JUCE_API  SamplerSound    : public SynthesiserSound
{
public:

	/** Creates a sampled sound from an audio reader.

		This will attempt to load the audio from the source into memory and store
		it in this object.

		@param name         a name for the sample
		@param source       the audio to load. This object can be safely deleted by the
							caller after this constructor returns
		@param midiNotes    the set of midi keys that this sound should be played on. This
							is used by the SynthesiserSound::appliesToNote() method
		@param midiNoteForNormalPitch   the midi note at which the sample should be played
										with its natural rate. All other notes will be pitched
										up or down relative to this one
		@param attackTimeSecs   the attack (fade-in) time, in seconds
		@param releaseTimeSecs  the decay (fade-out) time, in seconds
		@param maxSampleLengthSeconds   a maximum length of audio to read from the audio
										source, in seconds
	*/
	SamplerSound (const String& name,
				  AudioFormatReader& source,
				  const BigInteger& midiNotes,
				  int midiNoteForNormalPitch,
				  double attackTimeSecs,
				  double releaseTimeSecs,
				  double maxSampleLengthSeconds);

	/** Destructor. */
	~SamplerSound();

	/** Returns the sample's name */
	const String& getName() const                           { return name; }

	/** Returns the audio sample data.
		This could be 0 if there was a problem loading it.
	*/
	AudioSampleBuffer* getAudioData() const                 { return data; }

	bool appliesToNote (const int midiNoteNumber);
	bool appliesToChannel (const int midiChannel);

private:

	friend class SamplerVoice;

	String name;
	ScopedPointer <AudioSampleBuffer> data;
	double sourceSampleRate;
	BigInteger midiNotes;
	int length, attackSamples, releaseSamples;
	int midiRootNote;

	JUCE_LEAK_DETECTOR (SamplerSound);
};

/**
	A subclass of SynthesiserVoice that can play a SamplerSound.

	To use it, create a Synthesiser, add some SamplerVoice objects to it, then
	give it some SampledSound objects to play.

	@see SamplerSound, Synthesiser, SynthesiserVoice
*/
class JUCE_API  SamplerVoice    : public SynthesiserVoice
{
public:

	/** Creates a SamplerVoice.
	*/
	SamplerVoice();

	/** Destructor. */
	~SamplerVoice();

	bool canPlaySound (SynthesiserSound* sound);

	void startNote (const int midiNoteNumber,
					const float velocity,
					SynthesiserSound* sound,
					const int currentPitchWheelPosition);

	void stopNote (const bool allowTailOff);

	void pitchWheelMoved (const int newValue);
	void controllerMoved (const int controllerNumber,
						  const int newValue);

	void renderNextBlock (AudioSampleBuffer& outputBuffer, int startSample, int numSamples);

private:

	double pitchRatio;
	double sourceSamplePosition;
	float lgain, rgain, attackReleaseLevel, attackDelta, releaseDelta;
	bool isInAttack, isInRelease;

	JUCE_LEAK_DETECTOR (SamplerVoice);
};

#endif   // __JUCE_SAMPLER_JUCEHEADER__

/*** End of inlined file: juce_Sampler.h ***/


#endif
// END_AUTOINCLUDE

}

#endif   // __JUCE_AUDIO_FORMATS_JUCEHEADER__

/*** End of inlined file: juce_audio_formats.h ***/

#if JUCE_MAC
 #define Point CarbonDummyPointName
 #define Component CarbonDummyCompName
 #if JUCE_QUICKTIME
  #import <QTKit/QTKit.h>
 #endif
 #include <AudioToolbox/AudioToolbox.h>
 #undef Component
 #undef Point

#elif JUCE_IOS
 #import <AudioToolbox/AudioToolbox.h>
 #import <AVFoundation/AVFoundation.h>

#elif JUCE_WINDOWS
 #if JUCE_QUICKTIME
  /* If you've got an include error here, you probably need to install the QuickTime SDK and
	 add its header directory to your include path.

	 Alternatively, if you don't need any QuickTime services, just set the JUCE_QUICKTIME flag to 0.
  */
  #include <Movies.h>
  #include <QTML.h>
  #include <QuickTimeComponents.h>
  #include <MediaHandlers.h>
  #include <ImageCodec.h>

  /* If you've got QuickTime 7 installed, then these COM objects should be found in
	 the "\Program Files\Quicktime" directory. You'll need to add this directory to
	 your include search path to make these import statements work.
  */
  #import <QTOLibrary.dll>
  #import <QTOControl.dll>

  #if JUCE_MSVC && ! JUCE_DONT_AUTOLINK_TO_WIN32_LIBRARIES
   #pragma comment (lib, "QTMLClient.lib")
  #endif
 #endif

 #include <wmsdk.h>
#endif

namespace juce
{

#if JUCE_ANDROID

/*** Start of inlined file: juce_android_JNIHelpers.h ***/
#ifndef __JUCE_ANDROID_JNIHELPERS_JUCEHEADER__
#define __JUCE_ANDROID_JNIHELPERS_JUCEHEADER__

#ifndef USE_ANDROID_CANVAS
 #define USE_ANDROID_CANVAS 0
#endif

#if ! (defined (JUCE_ANDROID_ACTIVITY_CLASSNAME) && defined (JUCE_ANDROID_ACTIVITY_CLASSPATH))
 #error "The JUCE_ANDROID_ACTIVITY_CLASSNAME and JUCE_ANDROID_ACTIVITY_CLASSPATH macros must be set!"
#endif

extern JNIEnv* getEnv() noexcept;

class GlobalRef
{
public:
	inline GlobalRef() noexcept                 : obj (0) {}
	inline explicit GlobalRef (jobject obj_)    : obj (retain (obj_)) {}
	inline GlobalRef (const GlobalRef& other)   : obj (retain (other.obj)) {}
	~GlobalRef()                                { clear(); }

	inline void clear()
	{
		if (obj != 0)
		{
			getEnv()->DeleteGlobalRef (obj);
			obj = 0;
		}
	}

	inline GlobalRef& operator= (const GlobalRef& other)
	{
		jobject newObj = retain (other.obj);
		clear();
		obj = newObj;
		return *this;
	}

	inline operator jobject() const noexcept    { return obj; }
	inline jobject get() const noexcept         { return obj; }

	#define DECLARE_CALL_TYPE_METHOD(returnType, typeName) \
		returnType call##typeName##Method (jmethodID methodID, ... ) const \
		{ \
			va_list args; \
			va_start (args, methodID); \
			returnType result = getEnv()->Call##typeName##MethodV (obj, methodID, args); \
			va_end (args); \
			return result; \
		}

	DECLARE_CALL_TYPE_METHOD (jobject, Object)
	DECLARE_CALL_TYPE_METHOD (jboolean, Boolean)
	DECLARE_CALL_TYPE_METHOD (jbyte, Byte)
	DECLARE_CALL_TYPE_METHOD (jchar, Char)
	DECLARE_CALL_TYPE_METHOD (jshort, Short)
	DECLARE_CALL_TYPE_METHOD (jint, Int)
	DECLARE_CALL_TYPE_METHOD (jlong, Long)
	DECLARE_CALL_TYPE_METHOD (jfloat, Float)
	DECLARE_CALL_TYPE_METHOD (jdouble, Double)
	#undef DECLARE_CALL_TYPE_METHOD

	void callVoidMethod (jmethodID methodID, ... ) const
	{
		va_list args;
		va_start (args, methodID);
		getEnv()->CallVoidMethodV (obj, methodID, args);
		va_end (args);
	}

private:

	jobject obj;

	static inline jobject retain (jobject obj_)
	{
		return obj_ == 0 ? 0 : getEnv()->NewGlobalRef (obj_);
	}
};

template <typename JavaType>
class LocalRef
{
public:
	explicit inline LocalRef (JavaType obj_) noexcept   : obj (obj_){}
	inline LocalRef (const LocalRef& other) noexcept    : obj (retain (other.obj)) {}
	~LocalRef()                                         { clear(); }

	void clear()
	{
		if (obj != 0)
			getEnv()->DeleteLocalRef (obj);
	}

	LocalRef& operator= (const LocalRef& other)
	{
		jobject newObj = retain (other.obj);
		clear();
		obj = newObj;
		return *this;
	}

	inline operator JavaType() const noexcept   { return obj; }
	inline JavaType get() const noexcept        { return obj; }

private:
	JavaType obj;

	static JavaType retain (JavaType obj_)
	{
		return obj_ == 0 ? 0 : (JavaType) getEnv()->NewLocalRef (obj_);
	}
};

namespace
{
	String juceString (JNIEnv* env, jstring s)
	{
		jboolean isCopy;
		const char* const utf8 = env->GetStringUTFChars (s, &isCopy);
		CharPointer_UTF8 utf8CP (utf8);
		const String result (utf8CP);
		env->ReleaseStringUTFChars (s, utf8);
		return result;
	}

	String juceString (jstring s)
	{
		return juceString (getEnv(), s);
	}

	LocalRef<jstring> javaString (const String& s)
	{
		return LocalRef<jstring> (getEnv()->NewStringUTF (s.toUTF8()));
	}

	LocalRef<jstring> javaStringFromChar (const juce_wchar c)
	{
		char utf8[8] = { 0 };
		CharPointer_UTF8 (utf8).write (c);
		return LocalRef<jstring> (getEnv()->NewStringUTF (utf8));
	}
}

class JNIClassBase
{
public:
	explicit JNIClassBase (const char* classPath_);
	virtual ~JNIClassBase();

	inline operator jclass() const noexcept { return classRef; }

	static void initialiseAllClasses (JNIEnv*);
	static void releaseAllClasses (JNIEnv*);

protected:
	virtual void initialiseFields (JNIEnv*) = 0;

	jmethodID resolveMethod (JNIEnv*, const char* methodName, const char* params);
	jmethodID resolveStaticMethod (JNIEnv*, const char* methodName, const char* params);
	jfieldID resolveField (JNIEnv*, const char* fieldName, const char* signature);
	jfieldID resolveStaticField (JNIEnv*, const char* fieldName, const char* signature);

private:
	const char* const classPath;
	jclass classRef;

	static Array<JNIClassBase*>& getClasses();
	void initialise (JNIEnv*);
	void release (JNIEnv*);

	JUCE_DECLARE_NON_COPYABLE (JNIClassBase);
};

#define CREATE_JNI_METHOD(methodID, stringName, params)         methodID = resolveMethod (env, stringName, params);
#define CREATE_JNI_STATICMETHOD(methodID, stringName, params)   methodID = resolveStaticMethod (env, stringName, params);
#define CREATE_JNI_FIELD(fieldID, stringName, signature)        fieldID  = resolveField (env, stringName, signature);
#define CREATE_JNI_STATICFIELD(fieldID, stringName, signature)  fieldID  = resolveStaticField (env, stringName, signature);
#define DECLARE_JNI_METHOD(methodID, stringName, params)        jmethodID methodID;
#define DECLARE_JNI_FIELD(fieldID, stringName, signature)       jfieldID  fieldID;

#define DECLARE_JNI_CLASS(CppClassName, javaPath) \
	class CppClassName ## _Class   : public JNIClassBase \
	{ \
	public: \
		CppClassName ## _Class() : JNIClassBase (javaPath) {} \
	\
		void initialiseFields (JNIEnv* env) \
		{ \
			JNI_CLASS_MEMBERS (CREATE_JNI_METHOD, CREATE_JNI_STATICMETHOD, CREATE_JNI_FIELD, CREATE_JNI_STATICFIELD); \
		} \
	\
		JNI_CLASS_MEMBERS (DECLARE_JNI_METHOD, DECLARE_JNI_METHOD, DECLARE_JNI_FIELD, DECLARE_JNI_FIELD); \
	}; \
	static CppClassName ## _Class CppClassName;

#define JUCE_JNI_CALLBACK(className, methodName, returnType, params) \
  extern "C" __attribute__ ((visibility("default"))) returnType JUCE_JOIN_MACRO (JUCE_JOIN_MACRO (Java_, className), _ ## methodName) params

class AndroidSystem
{
public:
	AndroidSystem();

	void initialise (JNIEnv*, jobject activity, jstring appFile, jstring appDataDir);
	void shutdown (JNIEnv*);

	GlobalRef activity;
	String appFile, appDataDir;
	int screenWidth, screenHeight;
};

extern AndroidSystem android;

class ThreadLocalJNIEnvHolder
{
public:
	ThreadLocalJNIEnvHolder()
		: jvm (nullptr)
	{
		zeromem (threads, sizeof (threads));
		zeromem (envs, sizeof (envs));
	}

	void initialise (JNIEnv* env)
	{
		env->GetJavaVM (&jvm);
		addEnv (env);
	}

	void attach()
	{
		JNIEnv* env = nullptr;
		jvm->AttachCurrentThread (&env, 0);

		if (env != 0)
			addEnv (env);
	}

	void detach()
	{
		jvm->DetachCurrentThread();

		const pthread_t thisThread = pthread_self();

		SpinLock::ScopedLockType sl (addRemoveLock);
		for (int i = 0; i < maxThreads; ++i)
			if (threads[i] == thisThread)
				threads[i] = 0;
	}

	JNIEnv* get() const noexcept
	{
		const pthread_t thisThread = pthread_self();

		for (int i = 0; i < maxThreads; ++i)
			if (threads[i] == thisThread)
				return envs[i];

		return nullptr;
	}

	enum { maxThreads = 16 };

private:
	JavaVM* jvm;
	pthread_t threads [maxThreads];
	JNIEnv* envs [maxThreads];
	SpinLock addRemoveLock;

	void addEnv (JNIEnv* env)
	{
		SpinLock::ScopedLockType sl (addRemoveLock);

		if (get() == nullptr)
		{
			const pthread_t thisThread = pthread_self();

			for (int i = 0; i < maxThreads; ++i)
			{
				if (threads[i] == 0)
				{
					envs[i] = env;
					threads[i] = thisThread;
					return;
				}
			}
		}

		jassertfalse; // too many threads!
	}
};

extern ThreadLocalJNIEnvHolder threadLocalJNIEnvHolder;

#define JNI_CLASS_MEMBERS(METHOD, STATICMETHOD, FIELD, STATICFIELD) \
 METHOD (createNewView,          "createNewView",        "(Z)L" JUCE_ANDROID_ACTIVITY_CLASSPATH "$ComponentPeerView;") \
 METHOD (deleteView,             "deleteView",           "(L" JUCE_ANDROID_ACTIVITY_CLASSPATH "$ComponentPeerView;)V") \
 METHOD (postMessage,            "postMessage",          "(J)V") \
 METHOD (finish,                 "finish",               "()V") \
 METHOD (getClipboardContent,    "getClipboardContent",  "()Ljava/lang/String;") \
 METHOD (setClipboardContent,    "setClipboardContent",  "(Ljava/lang/String;)V") \
 METHOD (excludeClipRegion,      "excludeClipRegion",    "(Landroid/graphics/Canvas;FFFF)V") \
 METHOD (renderGlyph,            "renderGlyph",          "(CLandroid/graphics/Paint;Landroid/graphics/Matrix;Landroid/graphics/Rect;)[I") \
 STATICMETHOD (createHTTPStream, "createHTTPStream",     "(Ljava/lang/String;Z[BLjava/lang/String;ILjava/lang/StringBuffer;)L" JUCE_ANDROID_ACTIVITY_CLASSPATH "$HTTPStream;") \
 METHOD (launchURL,              "launchURL",            "(Ljava/lang/String;)V") \
 METHOD (showMessageBox,         "showMessageBox",       "(Ljava/lang/String;Ljava/lang/String;J)V") \
 METHOD (showOkCancelBox,        "showOkCancelBox",      "(Ljava/lang/String;Ljava/lang/String;J)V") \
 METHOD (showYesNoCancelBox,     "showYesNoCancelBox",   "(Ljava/lang/String;Ljava/lang/String;J)V") \

DECLARE_JNI_CLASS (JuceAppActivity, JUCE_ANDROID_ACTIVITY_CLASSPATH);
#undef JNI_CLASS_MEMBERS

#define JNI_CLASS_MEMBERS(METHOD, STATICMETHOD, FIELD, STATICFIELD) \
 METHOD (constructor,   "<init>",           "(I)V") \
 METHOD (setColor,      "setColor",         "(I)V") \
 METHOD (setAlpha,      "setAlpha",         "(I)V") \
 METHOD (setTypeface,   "setTypeface",      "(Landroid/graphics/Typeface;)Landroid/graphics/Typeface;") \
 METHOD (ascent,        "ascent",           "()F") \
 METHOD (descent,       "descent",          "()F") \
 METHOD (setTextSize,   "setTextSize",      "(F)V") \
 METHOD (getTextWidths, "getTextWidths",    "(Ljava/lang/String;[F)I") \
 METHOD (setTextScaleX, "setTextScaleX",    "(F)V") \
 METHOD (getTextPath,   "getTextPath",      "(Ljava/lang/String;IIFFLandroid/graphics/Path;)V") \
 METHOD (setShader,     "setShader",        "(Landroid/graphics/Shader;)Landroid/graphics/Shader;") \

DECLARE_JNI_CLASS (Paint, "android/graphics/Paint");
#undef JNI_CLASS_MEMBERS

#define JNI_CLASS_MEMBERS(METHOD, STATICMETHOD, FIELD, STATICFIELD) \
 METHOD (constructor,   "<init>",    "()V") \
 METHOD (setValues,     "setValues", "([F)V") \

DECLARE_JNI_CLASS (Matrix, "android/graphics/Matrix");
#undef JNI_CLASS_MEMBERS

#define JNI_CLASS_MEMBERS(METHOD, STATICMETHOD, FIELD, STATICFIELD) \
 METHOD (constructor,   "<init>",   "(IIII)V") \
 FIELD (left,           "left",     "I") \
 FIELD (right,          "right",    "I") \
 FIELD (top,            "top",      "I") \
 FIELD (bottom,         "bottom",   "I") \

DECLARE_JNI_CLASS (RectClass, "android/graphics/Rect");
#undef JNI_CLASS_MEMBERS

#endif   // __JUCE_ANDROID_JNIHELPERS_JUCEHEADER__

/*** End of inlined file: juce_android_JNIHelpers.h ***/


 #undef JUCE_QUICKTIME
#endif

#if JUCE_WINDOWS

/*** Start of inlined file: juce_win32_ComSmartPtr.h ***/
#ifndef __JUCE_WIN32_COMSMARTPTR_JUCEHEADER__
#define __JUCE_WIN32_COMSMARTPTR_JUCEHEADER__

/** A simple COM smart pointer.
*/
template <class ComClass>
class ComSmartPtr
{
public:
	ComSmartPtr() throw() : p (0)                               {}
	ComSmartPtr (ComClass* const p_) : p (p_)                   { if (p_ != 0) p_->AddRef(); }
	ComSmartPtr (const ComSmartPtr<ComClass>& p_) : p (p_.p)    { if (p  != 0) p ->AddRef(); }
	~ComSmartPtr()                                              { release(); }

	operator ComClass*() const throw()     { return p; }
	ComClass& operator*() const throw()    { return *p; }
	ComClass* operator->() const throw()   { return p; }

	ComSmartPtr& operator= (ComClass* const newP)
	{
		if (newP != 0)  newP->AddRef();
		release();
		p = newP;
		return *this;
	}

	ComSmartPtr& operator= (const ComSmartPtr<ComClass>& newP)  { return operator= (newP.p); }

	// Releases and nullifies this pointer and returns its address
	ComClass** resetAndGetPointerAddress()
	{
		release();
		p = 0;
		return &p;
	}

	HRESULT CoCreateInstance (REFCLSID classUUID, DWORD dwClsContext = CLSCTX_INPROC_SERVER)
	{
	   #if ! JUCE_MINGW
		return ::CoCreateInstance (classUUID, 0, dwClsContext, __uuidof (ComClass), (void**) resetAndGetPointerAddress());
	   #else
		jassertfalse; // need to find a mingw equivalent of __uuidof to make this possible
		return E_NOTIMPL;
	   #endif
	}

	template <class OtherComClass>
	HRESULT QueryInterface (REFCLSID classUUID, ComSmartPtr<OtherComClass>& destObject) const
	{
		if (p == 0)
			return E_POINTER;

		return p->QueryInterface (classUUID, (void**) destObject.resetAndGetPointerAddress());
	}

	template <class OtherComClass>
	HRESULT QueryInterface (ComSmartPtr<OtherComClass>& destObject) const
	{
	   #if ! JUCE_MINGW
		return this->QueryInterface (__uuidof (OtherComClass), destObject);
	   #else
		jassertfalse; // need to find a mingw equivalent of __uuidof to make this possible
		return E_NOTIMPL;
	   #endif
	}

private:
	ComClass* p;

	void release()  { if (p != 0) p->Release(); }

	ComClass** operator&() throw(); // private to avoid it being used accidentally
};

#define JUCE_COMRESULT  HRESULT __stdcall

/** Handy base class for writing COM objects, providing ref-counting and a basic QueryInterface method.
*/
template <class ComClass>
class ComBaseClassHelper   : public ComClass
{
public:
	ComBaseClassHelper()  : refCount (1) {}
	virtual ~ComBaseClassHelper() {}

	JUCE_COMRESULT QueryInterface (REFIID refId, void** result)
	{
	   #if ! JUCE_MINGW
		if (refId == __uuidof (ComClass))   { AddRef(); *result = dynamic_cast <ComClass*> (this); return S_OK; }
	   #else
		jassertfalse; // need to find a mingw equivalent of __uuidof to make this possible
	   #endif

		if (refId == IID_IUnknown)          { AddRef(); *result = dynamic_cast <IUnknown*> (this); return S_OK; }

		*result = 0;
		return E_NOINTERFACE;
	}

	ULONG __stdcall AddRef()    { return ++refCount; }
	ULONG __stdcall Release()   { const ULONG r = --refCount; if (r == 0) delete this; return r; }

	void resetReferenceCount() noexcept     { refCount = 0; }

protected:
	ULONG refCount;
};

#endif   // __JUCE_WIN32_COMSMARTPTR_JUCEHEADER__

/*** End of inlined file: juce_win32_ComSmartPtr.h ***/


#endif

// START_AUTOINCLUDE format/*.cpp, sampler/*.cpp, codecs/*.cpp

/*** Start of inlined file: juce_AudioFormat.cpp ***/
AudioFormat::AudioFormat (const String& name, const StringArray& extensions)
  : formatName (name),
	fileExtensions (extensions)
{
}

AudioFormat::~AudioFormat()
{
}

bool AudioFormat::canHandleFile (const File& f)
{
	for (int i = 0; i < fileExtensions.size(); ++i)
		if (f.hasFileExtension (fileExtensions[i]))
			return true;

	return false;
}

const String& AudioFormat::getFormatName() const                { return formatName; }
const StringArray& AudioFormat::getFileExtensions() const       { return fileExtensions; }
bool AudioFormat::isCompressed()                                { return false; }
StringArray AudioFormat::getQualityOptions()                    { return StringArray(); }

/*** End of inlined file: juce_AudioFormat.cpp ***/



/*** Start of inlined file: juce_AudioFormatManager.cpp ***/
AudioFormatManager::AudioFormatManager()
	: defaultFormatIndex (0)
{
}

AudioFormatManager::~AudioFormatManager()
{
}

void AudioFormatManager::registerFormat (AudioFormat* newFormat, const bool makeThisTheDefaultFormat)
{
	jassert (newFormat != nullptr);

	if (newFormat != nullptr)
	{
	   #if JUCE_DEBUG
		for (int i = getNumKnownFormats(); --i >= 0;)
		{
			if (getKnownFormat (i)->getFormatName() == newFormat->getFormatName())
			{
				jassertfalse; // trying to add the same format twice!
			}
		}
	   #endif

		if (makeThisTheDefaultFormat)
			defaultFormatIndex = getNumKnownFormats();

		knownFormats.add (newFormat);
	}
}

void AudioFormatManager::registerBasicFormats()
{
	registerFormat (new WavAudioFormat(), true);
	registerFormat (new AiffAudioFormat(), false);

   #if JUCE_USE_FLAC
	registerFormat (new FlacAudioFormat(), false);
   #endif

   #if JUCE_USE_OGGVORBIS
	registerFormat (new OggVorbisAudioFormat(), false);
   #endif

   #if JUCE_MAC || JUCE_IOS
	registerFormat (new CoreAudioFormat(), false);
   #elif JUCE_WINDOWS
	registerFormat (new WindowsMediaAudioFormat(), false);
   #elif JUCE_USE_MP3AUDIOFORMAT
	// The software MP3 decoder is only used as a default format if
	// there isn't an OS-provided alternative.
	registerFormat (new MP3AudioFormat(), false);
   #endif
}

void AudioFormatManager::clearFormats()
{
	knownFormats.clear();
	defaultFormatIndex = 0;
}

int AudioFormatManager::getNumKnownFormats() const
{
	return knownFormats.size();
}

AudioFormat* AudioFormatManager::getKnownFormat (const int index) const
{
	return knownFormats [index];
}

AudioFormat* AudioFormatManager::getDefaultFormat() const
{
	return getKnownFormat (defaultFormatIndex);
}

AudioFormat* AudioFormatManager::findFormatForFileExtension (const String& fileExtension) const
{
	if (! fileExtension.startsWithChar ('.'))
		return findFormatForFileExtension ("." + fileExtension);

	for (int i = 0; i < getNumKnownFormats(); ++i)
		if (getKnownFormat(i)->getFileExtensions().contains (fileExtension, true))
			return getKnownFormat(i);

	return nullptr;
}

String AudioFormatManager::getWildcardForAllFormats() const
{
	StringArray extensions;

	int i;
	for (i = 0; i < getNumKnownFormats(); ++i)
		extensions.addArray (getKnownFormat(i)->getFileExtensions());

	extensions.trim();
	extensions.removeEmptyStrings();

	for (i = 0; i < extensions.size(); ++i)
		extensions.set (i, (extensions[i].startsWithChar ('.') ? "*" : "*.") + extensions[i]);

	extensions.removeDuplicates (true);
	return extensions.joinIntoString (";");
}

AudioFormatReader* AudioFormatManager::createReaderFor (const File& file)
{
	// you need to actually register some formats before the manager can
	// use them to open a file!
	jassert (getNumKnownFormats() > 0);

	for (int i = 0; i < getNumKnownFormats(); ++i)
	{
		AudioFormat* const af = getKnownFormat(i);

		if (af->canHandleFile (file))
		{
			InputStream* const in = file.createInputStream();

			if (in != nullptr)
			{
				AudioFormatReader* const r = af->createReaderFor (in, true);

				if (r != nullptr)
					return r;
			}
		}
	}

	return nullptr;
}

AudioFormatReader* AudioFormatManager::createReaderFor (InputStream* audioFileStream)
{
	// you need to actually register some formats before the manager can
	// use them to open a file!
	jassert (getNumKnownFormats() > 0);

	ScopedPointer <InputStream> in (audioFileStream);

	if (in != nullptr)
	{
		const int64 originalStreamPos = in->getPosition();

		for (int i = 0; i < getNumKnownFormats(); ++i)
		{
			AudioFormatReader* const r = getKnownFormat(i)->createReaderFor (in, false);

			if (r != nullptr)
			{
				in.release();
				return r;
			}

			in->setPosition (originalStreamPos);

			// the stream that is passed-in must be capable of being repositioned so
			// that all the formats can have a go at opening it.
			jassert (in->getPosition() == originalStreamPos);
		}
	}

	return nullptr;
}

/*** End of inlined file: juce_AudioFormatManager.cpp ***/


/*** Start of inlined file: juce_AudioFormatReader.cpp ***/
AudioFormatReader::AudioFormatReader (InputStream* const in,
									  const String& formatName_)
	: sampleRate (0),
	  bitsPerSample (0),
	  lengthInSamples (0),
	  numChannels (0),
	  usesFloatingPointData (false),
	  input (in),
	  formatName (formatName_)
{
}

AudioFormatReader::~AudioFormatReader()
{
	delete input;
}

bool AudioFormatReader::read (int* const* destSamples,
							  int numDestChannels,
							  int64 startSampleInSource,
							  int numSamplesToRead,
							  const bool fillLeftoverChannelsWithCopies)
{
	jassert (numDestChannels > 0); // you have to actually give this some channels to work with!

	int startOffsetInDestBuffer = 0;

	if (startSampleInSource < 0)
	{
		const int silence = (int) jmin (-startSampleInSource, (int64) numSamplesToRead);

		for (int i = numDestChannels; --i >= 0;)
			if (destSamples[i] != nullptr)
				zeromem (destSamples[i], sizeof (int) * silence);

		startOffsetInDestBuffer += silence;
		numSamplesToRead -= silence;
		startSampleInSource = 0;
	}

	if (numSamplesToRead <= 0)
		return true;

	if (! readSamples (const_cast <int**> (destSamples),
					   jmin ((int) numChannels, numDestChannels), startOffsetInDestBuffer,
					   startSampleInSource, numSamplesToRead))
		return false;

	if (numDestChannels > (int) numChannels)
	{
		if (fillLeftoverChannelsWithCopies)
		{
			int* lastFullChannel = destSamples[0];

			for (int i = (int) numChannels; --i > 0;)
			{
				if (destSamples[i] != nullptr)
				{
					lastFullChannel = destSamples[i];
					break;
				}
			}

			if (lastFullChannel != nullptr)
				for (int i = (int) numChannels; i < numDestChannels; ++i)
					if (destSamples[i] != nullptr)
						memcpy (destSamples[i], lastFullChannel, sizeof (int) * numSamplesToRead);
		}
		else
		{
			for (int i = (int) numChannels; i < numDestChannels; ++i)
				if (destSamples[i] != nullptr)
					zeromem (destSamples[i], sizeof (int) * numSamplesToRead);
		}
	}

	return true;
}

void AudioFormatReader::read (AudioSampleBuffer* buffer,
							  int startSample,
							  int numSamples,
							  int64 readerStartSample,
							  bool useReaderLeftChan,
							  bool useReaderRightChan)
{
	jassert (buffer != nullptr);
	jassert (startSample >= 0 && startSample + numSamples <= buffer->getNumSamples());

	if (numSamples > 0)
	{
		const int numTargetChannels = buffer->getNumChannels();
		int* chans[3];

		if (useReaderLeftChan == useReaderRightChan)
		{
			chans[0] = reinterpret_cast<int*> (buffer->getSampleData (0, startSample));
			chans[1] = (numChannels > 1 && numTargetChannels > 1) ? reinterpret_cast<int*> (buffer->getSampleData (1, startSample)) : nullptr;
		}
		else if (useReaderLeftChan || (numChannels == 1))
		{
			chans[0] = reinterpret_cast<int*> (buffer->getSampleData (0, startSample));
			chans[1] = nullptr;
		}
		else if (useReaderRightChan)
		{
			chans[0] = nullptr;
			chans[1] = reinterpret_cast<int*> (buffer->getSampleData (0, startSample));
		}

		chans[2] = nullptr;

		read (chans, 2, readerStartSample, numSamples, true);

		if (! usesFloatingPointData)
		{
			for (int j = 0; j < 2; ++j)
			{
				float* const d = reinterpret_cast <float*> (chans[j]);

				if (d != nullptr)
				{
					const float multiplier = 1.0f / 0x7fffffff;

					for (int i = 0; i < numSamples; ++i)
						d[i] = *reinterpret_cast<int*> (d + i) * multiplier;
				}
			}
		}

		if (numTargetChannels > 1 && (chans[0] == nullptr || chans[1] == nullptr))
		{
			// if this is a stereo buffer and the source was mono, dupe the first channel..
			memcpy (buffer->getSampleData (1, startSample),
					buffer->getSampleData (0, startSample),
					sizeof (float) * numSamples);
		}
	}
}

void AudioFormatReader::readMaxLevels (int64 startSampleInFile,
									   int64 numSamples,
									   float& lowestLeft, float& highestLeft,
									   float& lowestRight, float& highestRight)
{
	if (numSamples <= 0)
	{
		lowestLeft = 0;
		lowestRight = 0;
		highestLeft = 0;
		highestRight = 0;
		return;
	}

	const int bufferSize = (int) jmin (numSamples, (int64) 4096);
	HeapBlock<int> tempSpace ((size_t) bufferSize * 2 + 64);

	int* tempBuffer[3];
	tempBuffer[0] = tempSpace.getData();
	tempBuffer[1] = tempSpace.getData() + bufferSize;
	tempBuffer[2] = 0;

	if (usesFloatingPointData)
	{
		float lmin = 1.0e6f;
		float lmax = -lmin;
		float rmin = lmin;
		float rmax = lmax;

		while (numSamples > 0)
		{
			const int numToDo = (int) jmin (numSamples, (int64) bufferSize);
			read (tempBuffer, 2, startSampleInFile, numToDo, false);

			numSamples -= numToDo;
			startSampleInFile += numToDo;

			float bufMin, bufMax;
			findMinAndMax (reinterpret_cast<float*> (tempBuffer[0]), numToDo, bufMin, bufMax);
			lmin = jmin (lmin, bufMin);
			lmax = jmax (lmax, bufMax);

			if (numChannels > 1)
			{
				findMinAndMax (reinterpret_cast<float*> (tempBuffer[1]), numToDo, bufMin, bufMax);
				rmin = jmin (rmin, bufMin);
				rmax = jmax (rmax, bufMax);
			}
		}

		if (numChannels <= 1)
		{
			rmax = lmax;
			rmin = lmin;
		}

		lowestLeft   = lmin;
		highestLeft  = lmax;
		lowestRight  = rmin;
		highestRight = rmax;
	}
	else
	{
		int lmax = std::numeric_limits<int>::min();
		int lmin = std::numeric_limits<int>::max();
		int rmax = std::numeric_limits<int>::min();
		int rmin = std::numeric_limits<int>::max();

		while (numSamples > 0)
		{
			const int numToDo = (int) jmin (numSamples, (int64) bufferSize);
			if (! read (tempBuffer, 2, startSampleInFile, numToDo, false))
				break;

			numSamples -= numToDo;
			startSampleInFile += numToDo;

			for (int j = (int) numChannels; --j >= 0;)
			{
				int bufMin, bufMax;
				findMinAndMax (tempBuffer[j], numToDo, bufMin, bufMax);

				if (j == 0)
				{
					lmax = jmax (lmax, bufMax);
					lmin = jmin (lmin, bufMin);
				}
				else
				{
					rmax = jmax (rmax, bufMax);
					rmin = jmin (rmin, bufMin);
				}
			}
		}

		if (numChannels <= 1)
		{
			rmax = lmax;
			rmin = lmin;
		}

		lowestLeft   = lmin / (float) std::numeric_limits<int>::max();
		highestLeft  = lmax / (float) std::numeric_limits<int>::max();
		lowestRight  = rmin / (float) std::numeric_limits<int>::max();
		highestRight = rmax / (float) std::numeric_limits<int>::max();
	}
}

int64 AudioFormatReader::searchForLevel (int64 startSample,
										 int64 numSamplesToSearch,
										 const double magnitudeRangeMinimum,
										 const double magnitudeRangeMaximum,
										 const int minimumConsecutiveSamples)
{
	if (numSamplesToSearch == 0)
		return -1;

	const int bufferSize = 4096;
	HeapBlock<int> tempSpace (bufferSize * 2 + 64);

	int* tempBuffer[3];
	tempBuffer[0] = tempSpace.getData();
	tempBuffer[1] = tempSpace.getData() + bufferSize;
	tempBuffer[2] = 0;

	int consecutive = 0;
	int64 firstMatchPos = -1;

	jassert (magnitudeRangeMaximum > magnitudeRangeMinimum);

	const double doubleMin = jlimit (0.0, (double) std::numeric_limits<int>::max(), magnitudeRangeMinimum * std::numeric_limits<int>::max());
	const double doubleMax = jlimit (doubleMin, (double) std::numeric_limits<int>::max(), magnitudeRangeMaximum * std::numeric_limits<int>::max());
	const int intMagnitudeRangeMinimum = roundToInt (doubleMin);
	const int intMagnitudeRangeMaximum = roundToInt (doubleMax);

	while (numSamplesToSearch != 0)
	{
		const int numThisTime = (int) jmin (abs64 (numSamplesToSearch), (int64) bufferSize);
		int64 bufferStart = startSample;

		if (numSamplesToSearch < 0)
			bufferStart -= numThisTime;

		if (bufferStart >= (int) lengthInSamples)
			break;

		read (tempBuffer, 2, bufferStart, numThisTime, false);

		int num = numThisTime;
		while (--num >= 0)
		{
			if (numSamplesToSearch < 0)
				--startSample;

			bool matches = false;
			const int index = (int) (startSample - bufferStart);

			if (usesFloatingPointData)
			{
				const float sample1 = std::abs (((float*) tempBuffer[0]) [index]);

				if (sample1 >= magnitudeRangeMinimum
					 && sample1 <= magnitudeRangeMaximum)
				{
					matches = true;
				}
				else if (numChannels > 1)
				{
					const float sample2 = std::abs (((float*) tempBuffer[1]) [index]);

					matches = (sample2 >= magnitudeRangeMinimum
								 && sample2 <= magnitudeRangeMaximum);
				}
			}
			else
			{
				const int sample1 = abs (tempBuffer[0] [index]);

				if (sample1 >= intMagnitudeRangeMinimum
					 && sample1 <= intMagnitudeRangeMaximum)
				{
					matches = true;
				}
				else if (numChannels > 1)
				{
					const int sample2 = abs (tempBuffer[1][index]);

					matches = (sample2 >= intMagnitudeRangeMinimum
								 && sample2 <= intMagnitudeRangeMaximum);
				}
			}

			if (matches)
			{
				if (firstMatchPos < 0)
					firstMatchPos = startSample;

				if (++consecutive >= minimumConsecutiveSamples)
				{
					if (firstMatchPos < 0 || firstMatchPos >= lengthInSamples)
						return -1;

					return firstMatchPos;
				}
			}
			else
			{
				consecutive = 0;
				firstMatchPos = -1;
			}

			if (numSamplesToSearch > 0)
				++startSample;
		}

		if (numSamplesToSearch > 0)
			numSamplesToSearch -= numThisTime;
		else
			numSamplesToSearch += numThisTime;
	}

	return -1;
}

/*** End of inlined file: juce_AudioFormatReader.cpp ***/


/*** Start of inlined file: juce_AudioFormatReaderSource.cpp ***/
AudioFormatReaderSource::AudioFormatReaderSource (AudioFormatReader* const reader_,
												  const bool deleteReaderWhenThisIsDeleted)
	: reader (reader_, deleteReaderWhenThisIsDeleted),
	  nextPlayPos (0),
	  looping (false)
{
	jassert (reader != nullptr);
}

AudioFormatReaderSource::~AudioFormatReaderSource() {}

int64 AudioFormatReaderSource::getTotalLength() const                   { return reader->lengthInSamples; }
void AudioFormatReaderSource::setNextReadPosition (int64 newPosition)   { nextPlayPos = newPosition; }
void AudioFormatReaderSource::setLooping (bool shouldLoop)              { looping = shouldLoop; }

int64 AudioFormatReaderSource::getNextReadPosition() const
{
	return looping ? nextPlayPos % reader->lengthInSamples
				   : nextPlayPos;
}

void AudioFormatReaderSource::prepareToPlay (int /*samplesPerBlockExpected*/, double /*sampleRate*/) {}
void AudioFormatReaderSource::releaseResources() {}

void AudioFormatReaderSource::getNextAudioBlock (const AudioSourceChannelInfo& info)
{
	if (info.numSamples > 0)
	{
		const int64 start = nextPlayPos;

		if (looping)
		{
			const int newStart = (int) (start % (int) reader->lengthInSamples);
			const int newEnd = (int) ((start + info.numSamples) % (int) reader->lengthInSamples);

			if (newEnd > newStart)
			{
				reader->read (info.buffer, info.startSample,
							  newEnd - newStart, newStart, true, true);
			}
			else
			{
				const int endSamps = (int) reader->lengthInSamples - newStart;

				reader->read (info.buffer, info.startSample,
							  endSamps, newStart, true, true);

				reader->read (info.buffer, info.startSample + endSamps,
							  newEnd, 0, true, true);
			}

			nextPlayPos = newEnd;
		}
		else
		{
			reader->read (info.buffer, info.startSample,
						  info.numSamples, start, true, true);
			nextPlayPos += info.numSamples;
		}
	}
}

/*** End of inlined file: juce_AudioFormatReaderSource.cpp ***/


/*** Start of inlined file: juce_AudioFormatWriter.cpp ***/
AudioFormatWriter::AudioFormatWriter (OutputStream* const out,
									  const String& formatName_,
									  const double rate,
									  const unsigned int numChannels_,
									  const unsigned int bitsPerSample_)
  : sampleRate (rate),
	numChannels (numChannels_),
	bitsPerSample (bitsPerSample_),
	usesFloatingPointData (false),
	output (out),
	formatName (formatName_)
{
}

AudioFormatWriter::~AudioFormatWriter()
{
	delete output;
}

bool AudioFormatWriter::writeFromAudioReader (AudioFormatReader& reader,
											  int64 startSample,
											  int64 numSamplesToRead)
{
	const int bufferSize = 16384;
	AudioSampleBuffer tempBuffer ((int) numChannels, bufferSize);

	int* buffers [128] = { 0 };

	for (int i = tempBuffer.getNumChannels(); --i >= 0;)
		buffers[i] = reinterpret_cast<int*> (tempBuffer.getSampleData (i, 0));

	if (numSamplesToRead < 0)
		numSamplesToRead = reader.lengthInSamples;

	while (numSamplesToRead > 0)
	{
		const int numToDo = (int) jmin (numSamplesToRead, (int64) bufferSize);

		if (! reader.read (buffers, (int) numChannels, startSample, numToDo, false))
			return false;

		if (reader.usesFloatingPointData != isFloatingPoint())
		{
			int** bufferChan = buffers;

			while (*bufferChan != nullptr)
			{
				int* b = *bufferChan++;

				if (isFloatingPoint())
				{
					// int -> float
					const double factor = 1.0 / std::numeric_limits<int>::max();

					for (int i = 0; i < numToDo; ++i)
						reinterpret_cast<float*> (b)[i] = (float) (factor * b[i]);
				}
				else
				{
					// float -> int
					for (int i = 0; i < numToDo; ++i)
					{
						const double samp = *(const float*) b;

						if (samp <= -1.0)
							*b++ = std::numeric_limits<int>::min();
						else if (samp >= 1.0)
							*b++ = std::numeric_limits<int>::max();
						else
							*b++ = roundToInt (std::numeric_limits<int>::max() * samp);
					}
				}
			}
		}

		if (! write (const_cast <const int**> (buffers), numToDo))
			return false;

		numSamplesToRead -= numToDo;
		startSample += numToDo;
	}

	return true;
}

bool AudioFormatWriter::writeFromAudioSource (AudioSource& source, int numSamplesToRead, const int samplesPerBlock)
{
	AudioSampleBuffer tempBuffer (getNumChannels(), samplesPerBlock);

	while (numSamplesToRead > 0)
	{
		const int numToDo = jmin (numSamplesToRead, samplesPerBlock);

		AudioSourceChannelInfo info;
		info.buffer = &tempBuffer;
		info.startSample = 0;
		info.numSamples = numToDo;
		info.clearActiveBufferRegion();

		source.getNextAudioBlock (info);

		if (! writeFromAudioSampleBuffer (tempBuffer, 0, numToDo))
			return false;

		numSamplesToRead -= numToDo;
	}

	return true;
}

bool AudioFormatWriter::writeFromAudioSampleBuffer (const AudioSampleBuffer& source, int startSample, int numSamples)
{
	jassert (startSample >= 0 && startSample + numSamples <= source.getNumSamples() && source.getNumChannels() > 0);

	if (numSamples <= 0)
		return true;

	HeapBlock<int> tempBuffer;
	HeapBlock<int*> chans (numChannels + 1);
	chans [numChannels] = 0;

	if (isFloatingPoint())
	{
		for (int i = (int) numChannels; --i >= 0;)
			chans[i] = reinterpret_cast<int*> (source.getSampleData (i, startSample));
	}
	else
	{
		tempBuffer.malloc (numSamples * numChannels);

		for (unsigned int i = 0; i < numChannels; ++i)
		{
			typedef AudioData::Pointer <AudioData::Int32, AudioData::NativeEndian, AudioData::NonInterleaved, AudioData::NonConst> DestSampleType;
			typedef AudioData::Pointer <AudioData::Float32, AudioData::NativeEndian, AudioData::NonInterleaved, AudioData::Const> SourceSampleType;

			DestSampleType destData (chans[i] = tempBuffer + i * numSamples);
			SourceSampleType sourceData (source.getSampleData ((int) i, startSample));
			destData.convertSamples (sourceData, numSamples);
		}
	}

	return write ((const int**) chans.getData(), numSamples);
}

class AudioFormatWriter::ThreadedWriter::Buffer   : public TimeSliceClient,
													public AbstractFifo
{
public:
	Buffer (TimeSliceThread& timeSliceThread_, AudioFormatWriter* writer_, int numChannels, int bufferSize_)
		: AbstractFifo (bufferSize_),
		  buffer (numChannels, bufferSize_),
		  timeSliceThread (timeSliceThread_),
		  writer (writer_),
		  receiver (nullptr),
		  samplesWritten (0),
		  isRunning (true)
	{
		timeSliceThread.addTimeSliceClient (this);
	}

	~Buffer()
	{
		isRunning = false;
		timeSliceThread.removeTimeSliceClient (this);

		while (writePendingData() == 0)
		{}
	}

	bool write (const float** data, int numSamples)
	{
		if (numSamples <= 0 || ! isRunning)
			return true;

		jassert (timeSliceThread.isThreadRunning());  // you need to get your thread running before pumping data into this!

		int start1, size1, start2, size2;
		prepareToWrite (numSamples, start1, size1, start2, size2);

		if (size1 + size2 < numSamples)
			return false;

		for (int i = buffer.getNumChannels(); --i >= 0;)
		{
			buffer.copyFrom (i, start1, data[i], size1);
			buffer.copyFrom (i, start2, data[i] + size1, size2);
		}

		finishedWrite (size1 + size2);
		timeSliceThread.notify();
		return true;
	}

	int useTimeSlice()
	{
		return writePendingData();
	}

	int writePendingData()
	{
		const int numToDo = getTotalSize() / 4;

		int start1, size1, start2, size2;
		prepareToRead (numToDo, start1, size1, start2, size2);

		if (size1 <= 0)
			return 10;

		writer->writeFromAudioSampleBuffer (buffer, start1, size1);

		const ScopedLock sl (thumbnailLock);
		if (receiver != nullptr)
			receiver->addBlock (samplesWritten, buffer, start1, size1);

		samplesWritten += size1;

		if (size2 > 0)
		{
			writer->writeFromAudioSampleBuffer (buffer, start2, size2);

			if (receiver != nullptr)
				receiver->addBlock (samplesWritten, buffer, start2, size2);

			samplesWritten += size2;
		}

		finishedRead (size1 + size2);
		return 0;
	}

	void setDataReceiver (IncomingDataReceiver* newReceiver)
	{
		if (newReceiver != nullptr)
			newReceiver->reset (buffer.getNumChannels(), writer->getSampleRate(), 0);

		const ScopedLock sl (thumbnailLock);
		receiver = newReceiver;
		samplesWritten = 0;
	}

private:
	AudioSampleBuffer buffer;
	TimeSliceThread& timeSliceThread;
	ScopedPointer<AudioFormatWriter> writer;
	CriticalSection thumbnailLock;
	IncomingDataReceiver* receiver;
	int64 samplesWritten;
	volatile bool isRunning;

	JUCE_DECLARE_NON_COPYABLE (Buffer);
};

AudioFormatWriter::ThreadedWriter::ThreadedWriter (AudioFormatWriter* writer, TimeSliceThread& backgroundThread, int numSamplesToBuffer)
	: buffer (new AudioFormatWriter::ThreadedWriter::Buffer (backgroundThread, writer, (int) writer->numChannels, numSamplesToBuffer))
{
}

AudioFormatWriter::ThreadedWriter::~ThreadedWriter()
{
}

bool AudioFormatWriter::ThreadedWriter::write (const float** data, int numSamples)
{
	return buffer->write (data, numSamples);
}

void AudioFormatWriter::ThreadedWriter::setDataReceiver (AudioFormatWriter::ThreadedWriter::IncomingDataReceiver* receiver)
{
	buffer->setDataReceiver (receiver);
}

/*** End of inlined file: juce_AudioFormatWriter.cpp ***/


/*** Start of inlined file: juce_AudioSubsectionReader.cpp ***/
AudioSubsectionReader::AudioSubsectionReader (AudioFormatReader* const source_,
											  const int64 startSample_,
											  const int64 length_,
											  const bool deleteSourceWhenDeleted_)
   : AudioFormatReader (0, source_->getFormatName()),
	 source (source_),
	 startSample (startSample_),
	 deleteSourceWhenDeleted (deleteSourceWhenDeleted_)
{
	length = jmin (jmax ((int64) 0, source->lengthInSamples - startSample), length_);

	sampleRate = source->sampleRate;
	bitsPerSample = source->bitsPerSample;
	lengthInSamples = length;
	numChannels = source->numChannels;
	usesFloatingPointData = source->usesFloatingPointData;
}

AudioSubsectionReader::~AudioSubsectionReader()
{
	if (deleteSourceWhenDeleted)
		delete source;
}

bool AudioSubsectionReader::readSamples (int** destSamples, int numDestChannels, int startOffsetInDestBuffer,
										 int64 startSampleInFile, int numSamples)
{
	if (startSampleInFile + numSamples > length)
	{
		for (int i = numDestChannels; --i >= 0;)
			if (destSamples[i] != nullptr)
				zeromem (destSamples[i], sizeof (int) * numSamples);

		numSamples = jmin (numSamples, (int) (length - startSampleInFile));

		if (numSamples <= 0)
			return true;
	}

	return source->readSamples (destSamples, numDestChannels, startOffsetInDestBuffer,
								startSampleInFile + startSample, numSamples);
}

void AudioSubsectionReader::readMaxLevels (int64 startSampleInFile,
										   int64 numSamples,
										   float& lowestLeft,
										   float& highestLeft,
										   float& lowestRight,
										   float& highestRight)
{
	startSampleInFile = jmax ((int64) 0, startSampleInFile);
	numSamples = jmax ((int64) 0, jmin (numSamples, length - startSampleInFile));

	source->readMaxLevels (startSampleInFile + startSample, numSamples,
						   lowestLeft, highestLeft,
						   lowestRight, highestRight);
}

/*** End of inlined file: juce_AudioSubsectionReader.cpp ***/


/*** Start of inlined file: juce_Sampler.cpp ***/
SamplerSound::SamplerSound (const String& name_,
							AudioFormatReader& source,
							const BigInteger& midiNotes_,
							const int midiNoteForNormalPitch,
							const double attackTimeSecs,
							const double releaseTimeSecs,
							const double maxSampleLengthSeconds)
	: name (name_),
	  midiNotes (midiNotes_),
	  midiRootNote (midiNoteForNormalPitch)
{
	sourceSampleRate = source.sampleRate;

	if (sourceSampleRate <= 0 || source.lengthInSamples <= 0)
	{
		length = 0;
		attackSamples = 0;
		releaseSamples = 0;
	}
	else
	{
		length = jmin ((int) source.lengthInSamples,
					   (int) (maxSampleLengthSeconds * sourceSampleRate));

		data = new AudioSampleBuffer (jmin (2, (int) source.numChannels), length + 4);

		source.read (data, 0, length + 4, 0, true, true);

		attackSamples = roundToInt (attackTimeSecs * sourceSampleRate);
		releaseSamples = roundToInt (releaseTimeSecs * sourceSampleRate);
	}
}

SamplerSound::~SamplerSound()
{
}

bool SamplerSound::appliesToNote (const int midiNoteNumber)
{
	return midiNotes [midiNoteNumber];
}

bool SamplerSound::appliesToChannel (const int /*midiChannel*/)
{
	return true;
}

SamplerVoice::SamplerVoice()
	: pitchRatio (0.0),
	  sourceSamplePosition (0.0),
	  lgain (0.0f),
	  rgain (0.0f),
	  isInAttack (false),
	  isInRelease (false)
{
}

SamplerVoice::~SamplerVoice()
{
}

bool SamplerVoice::canPlaySound (SynthesiserSound* sound)
{
	return dynamic_cast <const SamplerSound*> (sound) != nullptr;
}

void SamplerVoice::startNote (const int midiNoteNumber,
							  const float velocity,
							  SynthesiserSound* s,
							  const int /*currentPitchWheelPosition*/)
{
	const SamplerSound* const sound = dynamic_cast <const SamplerSound*> (s);
	jassert (sound != nullptr); // this object can only play SamplerSounds!

	if (sound != nullptr)
	{
		const double targetFreq = MidiMessage::getMidiNoteInHertz (midiNoteNumber);
		const double naturalFreq = MidiMessage::getMidiNoteInHertz (sound->midiRootNote);

		pitchRatio = (targetFreq * sound->sourceSampleRate) / (naturalFreq * getSampleRate());

		sourceSamplePosition = 0.0;
		lgain = velocity;
		rgain = velocity;

		isInAttack = (sound->attackSamples > 0);
		isInRelease = false;

		if (isInAttack)
		{
			attackReleaseLevel = 0.0f;
			attackDelta = (float) (pitchRatio / sound->attackSamples);
		}
		else
		{
			attackReleaseLevel = 1.0f;
			attackDelta = 0.0f;
		}

		if (sound->releaseSamples > 0)
		{
			releaseDelta = (float) (-pitchRatio / sound->releaseSamples);
		}
		else
		{
			releaseDelta = 0.0f;
		}
	}
}

void SamplerVoice::stopNote (const bool allowTailOff)
{
	if (allowTailOff)
	{
		isInAttack = false;
		isInRelease = true;
	}
	else
	{
		clearCurrentNote();
	}
}

void SamplerVoice::pitchWheelMoved (const int /*newValue*/)
{
}

void SamplerVoice::controllerMoved (const int /*controllerNumber*/,
									const int /*newValue*/)
{
}

void SamplerVoice::renderNextBlock (AudioSampleBuffer& outputBuffer, int startSample, int numSamples)
{
	const SamplerSound* const playingSound = static_cast <SamplerSound*> (getCurrentlyPlayingSound().getObject());

	if (playingSound != nullptr)
	{
		const float* const inL = playingSound->data->getSampleData (0, 0);
		const float* const inR = playingSound->data->getNumChannels() > 1
									? playingSound->data->getSampleData (1, 0) : nullptr;

		float* outL = outputBuffer.getSampleData (0, startSample);
		float* outR = outputBuffer.getNumChannels() > 1 ? outputBuffer.getSampleData (1, startSample) : nullptr;

		while (--numSamples >= 0)
		{
			const int pos = (int) sourceSamplePosition;
			const float alpha = (float) (sourceSamplePosition - pos);
			const float invAlpha = 1.0f - alpha;

			// just using a very simple linear interpolation here..
			float l = (inL [pos] * invAlpha + inL [pos + 1] * alpha);
			float r = (inR != nullptr) ? (inR [pos] * invAlpha + inR [pos + 1] * alpha)
									   : l;

			l *= lgain;
			r *= rgain;

			if (isInAttack)
			{
				l *= attackReleaseLevel;
				r *= attackReleaseLevel;

				attackReleaseLevel += attackDelta;

				if (attackReleaseLevel >= 1.0f)
				{
					attackReleaseLevel = 1.0f;
					isInAttack = false;
				}
			}
			else if (isInRelease)
			{
				l *= attackReleaseLevel;
				r *= attackReleaseLevel;

				attackReleaseLevel += releaseDelta;

				if (attackReleaseLevel <= 0.0f)
				{
					stopNote (false);
					break;
				}
			}

			if (outR != nullptr)
			{
				*outL++ += l;
				*outR++ += r;
			}
			else
			{
				*outL++ += (l + r) * 0.5f;
			}

			sourceSamplePosition += pitchRatio;

			if (sourceSamplePosition > playingSound->length)
			{
				stopNote (false);
				break;
			}
		}
	}
}

/*** End of inlined file: juce_Sampler.cpp ***/


/*** Start of inlined file: juce_AiffAudioFormat.cpp ***/
static const char* const aiffFormatName = "AIFF file";
static const char* const aiffExtensions[] = { ".aiff", ".aif", 0 };

namespace AiffFileHelpers
{
	inline int chunkName (const char* const name)   { return (int) ByteOrder::littleEndianInt (name); }

   #if JUCE_MSVC
	#pragma pack (push, 1)
	#define PACKED
   #elif JUCE_GCC
	#define PACKED __attribute__((packed))
   #else
	#define PACKED
   #endif

	struct InstChunk
	{
		struct Loop
		{
			uint16 type; // these are different in AIFF and WAV
			uint16 startIdentifier;
			uint16 endIdentifier;
		} PACKED;

		int8 baseNote;
		int8 detune;
		int8 lowNote;
		int8 highNote;
		int8 lowVelocity;
		int8 highVelocity;
		int16 gain;
		Loop sustainLoop;
		Loop releaseLoop;

		void copyTo (StringPairArray& values) const
		{
			values.set ("MidiUnityNote",        String (baseNote));
			values.set ("Detune",               String (detune));

			values.set ("LowNote",              String (lowNote));
			values.set ("HighNote",             String (highNote));
			values.set ("LowVelocity",          String (lowVelocity));
			values.set ("HighVelocity",         String (highVelocity));

			values.set ("Gain",                 String ((int16) ByteOrder::swapIfLittleEndian ((uint16) gain)));

			values.set ("NumSampleLoops",       String (2));        // always 2 with AIFF, WAV can have more
			values.set ("Loop0Type",            String (ByteOrder::swapIfLittleEndian (sustainLoop.type)));
			values.set ("Loop0StartIdentifier", String (ByteOrder::swapIfLittleEndian (sustainLoop.startIdentifier)));
			values.set ("Loop0EndIdentifier",   String (ByteOrder::swapIfLittleEndian (sustainLoop.endIdentifier)));
			values.set ("Loop1Type",            String (ByteOrder::swapIfLittleEndian (releaseLoop.type)));
			values.set ("Loop1StartIdentifier", String (ByteOrder::swapIfLittleEndian (releaseLoop.startIdentifier)));
			values.set ("Loop1EndIdentifier",   String (ByteOrder::swapIfLittleEndian (releaseLoop.endIdentifier)));
		}

		static void create (MemoryBlock& block, const StringPairArray& values)
		{
			if (values.getAllKeys().contains ("MidiUnityNote", true))
			{
				block.setSize ((sizeof (InstChunk) + 3) & ~3, true);
				InstChunk* const inst = static_cast <InstChunk*> (block.getData());

				inst->baseNote      = (int8) values.getValue ("MidiUnityNote", "60").getIntValue();
				inst->detune        = (int8) values.getValue ("Detune", "0").getIntValue();
				inst->lowNote       = (int8) values.getValue ("LowNote", "0").getIntValue();
				inst->highNote      = (int8) values.getValue ("HighNote", "127").getIntValue();
				inst->lowVelocity   = (int8) values.getValue ("LowVelocity", "1").getIntValue();
				inst->highVelocity  = (int8) values.getValue ("HighVelocity", "127").getIntValue();
				inst->gain          = (int16) ByteOrder::swapIfLittleEndian ((uint16) values.getValue ("Gain", "0").getIntValue());

				inst->sustainLoop.type              = ByteOrder::swapIfLittleEndian ((uint16) values.getValue ("Loop0Type", "0").getIntValue());
				inst->sustainLoop.startIdentifier   = ByteOrder::swapIfLittleEndian ((uint16) values.getValue ("Loop0StartIdentifier", "0").getIntValue());
				inst->sustainLoop.endIdentifier     = ByteOrder::swapIfLittleEndian ((uint16) values.getValue ("Loop0EndIdentifier", "0").getIntValue());
				inst->releaseLoop.type              = ByteOrder::swapIfLittleEndian ((uint16) values.getValue ("Loop1Type", "0").getIntValue());
				inst->releaseLoop.startIdentifier   = ByteOrder::swapIfLittleEndian ((uint16) values.getValue ("Loop1StartIdentifier", "0").getIntValue());
				inst->releaseLoop.endIdentifier     = ByteOrder::swapIfLittleEndian ((uint16) values.getValue ("Loop1EndIdentifier", "0").getIntValue());
			}
		}

	} PACKED;

   #if JUCE_MSVC
	#pragma pack (pop)
   #endif

	#undef PACKED

	namespace MarkChunk
	{
		bool metaDataContainsZeroIdentifiers (const StringPairArray& values)
		{
			// (zero cue identifiers are valid for WAV but not for AIFF)
			const String cueString ("Cue");
			const String noteString ("CueNote");
			const String identifierString ("Identifier");

			const StringArray& keys = values.getAllKeys();

			for (int i = 0; i < keys.size(); ++i)
			{
				const String key (keys[i]);

				if (key.startsWith (noteString))
					continue; // zero identifier IS valid in a COMT chunk

				if (key.startsWith (cueString) && key.contains (identifierString))
				{
					const int value = values.getValue (key, "-1").getIntValue();

					if (value == 0)
						return true;
				}
			}

			return false;
		}

		void create (MemoryBlock& block, const StringPairArray& values)
		{
			const int numCues = values.getValue ("NumCuePoints", "0").getIntValue();

			if (numCues > 0)
			{
				MemoryOutputStream out (block, false);

				out.writeShortBigEndian ((short) numCues);

				const int numCueLabels = values.getValue ("NumCueLabels", "0").getIntValue();
				const int idOffset = metaDataContainsZeroIdentifiers (values) ? 1 : 0; // can't have zero IDs in AIFF

			   #if JUCE_DEBUG
				Array<int> identifiers;
			   #endif

				for (int i = 0; i < numCues; ++i)
				{
					const String prefixCue ("Cue" + String (i));
					const int identifier = idOffset + values.getValue (prefixCue + "Identifier", "1").getIntValue();

				   #if JUCE_DEBUG
					jassert (! identifiers.contains (identifier));
					identifiers.add (identifier);
				   #endif

					const int offset = values.getValue (prefixCue + "Offset", "0").getIntValue();
					String label ("CueLabel" + String (i));

					for (int labelIndex = 0; labelIndex < numCueLabels; ++labelIndex)
					{
						const String prefixLabel ("CueLabel" + String (labelIndex));
						const int labelIdentifier = idOffset + values.getValue (prefixLabel + "Identifier", "1").getIntValue();

						if (labelIdentifier == identifier)
						{
							label = values.getValue (prefixLabel + "Text", label);
							break;
						}
					}

					out.writeShortBigEndian ((short) identifier);
					out.writeIntBigEndian (offset);

					const int labelLength = jmin (254, label.getNumBytesAsUTF8()); // seems to need null terminator even though it's a pstring
					out.writeByte ((char) labelLength + 1);
					out.write (label.toUTF8(), labelLength);
					out.writeByte (0);
				}

				if ((out.getDataSize() & 1) != 0)
					out.writeByte (0);
			}
		}
	}

	namespace COMTChunk
	{
		void create (MemoryBlock& block, const StringPairArray& values)
		{
			const int numNotes = values.getValue ("NumCueNotes", "0").getIntValue();

			if (numNotes > 0)
			{
				MemoryOutputStream out (block, false);
				out.writeShortBigEndian ((short) numNotes);

				for (int i = 0; i < numNotes; ++i)
				{
					const String prefix ("CueNote" + String (i));

					out.writeIntBigEndian (values.getValue (prefix + "TimeStamp", "0").getIntValue());
					out.writeShortBigEndian ((short) values.getValue (prefix + "Identifier", "0").getIntValue());

					const String comment (values.getValue (prefix + "Text", String::empty));
					out.write (comment.toUTF8(), jmin (comment.getNumBytesAsUTF8(), 65534));
					out.writeByte (0);

					if ((out.getDataSize() & 1) != 0)
						out.writeByte (0);
				}
			}
		}
	}
}

class AiffAudioFormatReader  : public AudioFormatReader
{
public:
	AiffAudioFormatReader (InputStream* in)
		: AudioFormatReader (in, TRANS (aiffFormatName))
	{
		using namespace AiffFileHelpers;

		if (input->readInt() == chunkName ("FORM"))
		{
			const int len = input->readIntBigEndian();
			const int64 end = input->getPosition() + len;

			const int nextType = input->readInt();
			if (nextType == chunkName ("AIFF") || nextType == chunkName ("AIFC"))
			{
				bool hasGotVer = false;
				bool hasGotData = false;
				bool hasGotType = false;

				while (input->getPosition() < end)
				{
					const int type = input->readInt();
					const uint32 length = (uint32) input->readIntBigEndian();
					const int64 chunkEnd = input->getPosition() + length;

					if (type == chunkName ("FVER"))
					{
						hasGotVer = true;

						const int ver = input->readIntBigEndian();
						if (ver != 0 && ver != (int) 0xa2805140)
							break;
					}
					else if (type == chunkName ("COMM"))
					{
						hasGotType = true;

						numChannels = (unsigned int) input->readShortBigEndian();
						lengthInSamples = input->readIntBigEndian();
						bitsPerSample = (unsigned int) input->readShortBigEndian();
						bytesPerFrame = (int) ((numChannels * bitsPerSample) >> 3);

						unsigned char sampleRateBytes[10];
						input->read (sampleRateBytes, 10);
						const int byte0 = sampleRateBytes[0];

						if ((byte0 & 0x80) != 0
							 || byte0 <= 0x3F || byte0 > 0x40
							 || (byte0 == 0x40 && sampleRateBytes[1] > 0x1C))
							break;

						unsigned int sampRate = ByteOrder::bigEndianInt (sampleRateBytes + 2);
						sampRate >>= (16414 - ByteOrder::bigEndianShort (sampleRateBytes));
						sampleRate = (int) sampRate;

						if (length <= 18)
						{
							// some types don't have a chunk large enough to include a compression
							// type, so assume it's just big-endian pcm
							littleEndian = false;
						}
						else
						{
							const int compType = input->readInt();

							if (compType == chunkName ("NONE") || compType == chunkName ("twos"))
							{
								littleEndian = false;
							}
							else if (compType == chunkName ("sowt"))
							{
								littleEndian = true;
							}
							else
							{
								sampleRate = 0;
								break;
							}
						}
					}
					else if (type == chunkName ("SSND"))
					{
						hasGotData = true;

						const int offset = input->readIntBigEndian();
						dataChunkStart = input->getPosition() + 4 + offset;
						lengthInSamples = (bytesPerFrame > 0) ? jmin (lengthInSamples, (int64) (length / bytesPerFrame)) : 0;
					}
					else if (type == chunkName ("MARK"))
					{
						const uint16 numCues = (uint16) input->readShortBigEndian();

						// these two are always the same for AIFF-read files
						metadataValues.set ("NumCuePoints", String (numCues));
						metadataValues.set ("NumCueLabels", String (numCues));

						for (uint16 i = 0; i < numCues; ++i)
						{
							uint16 identifier = (uint16) input->readShortBigEndian();
							uint32 offset = (uint32) input->readIntBigEndian();
							uint8 stringLength = (uint8) input->readByte();
							MemoryBlock textBlock;
							input->readIntoMemoryBlock (textBlock, stringLength);

							// if the stringLength is even then read one more byte as the
							// string needs to be an even number of bytes INCLUDING the
							// leading length character in the pascal string
							if ((stringLength & 1) == 0)
								input->readByte();

							const String prefixCue ("Cue" + String (i));
							metadataValues.set (prefixCue + "Identifier", String (identifier));
							metadataValues.set (prefixCue + "Offset", String (offset));

							const String prefixLabel ("CueLabel" + String (i));
							metadataValues.set (prefixLabel + "Identifier", String (identifier));
							metadataValues.set (prefixLabel + "Text", textBlock.toString());
						}
					}
					else if (type == chunkName ("COMT"))
					{
						const uint16 numNotes = (uint16) input->readShortBigEndian();
						metadataValues.set ("NumCueNotes", String (numNotes));

						for (uint16 i = 0; i < numNotes; ++i)
						{
							uint32 timestamp = (uint32) input->readIntBigEndian();
							uint16 identifier = (uint16) input->readShortBigEndian(); // may be zero in this case
							uint16 stringLength = (uint16) input->readShortBigEndian();

							MemoryBlock textBlock;
							input->readIntoMemoryBlock (textBlock, stringLength + (stringLength & 1));

							const String prefix ("CueNote" + String (i));
							metadataValues.set (prefix + "TimeStamp", String (timestamp));
							metadataValues.set (prefix + "Identifier", String (identifier));
							metadataValues.set (prefix + "Text", textBlock.toString());
						}
					}
					else if (type == chunkName ("INST"))
					{
						HeapBlock <InstChunk> inst;
						inst.calloc (jmax ((size_t) length + 1, sizeof (InstChunk)), 1);
						input->read (inst, (int) length);
						inst->copyTo (metadataValues);
					}
					else if ((hasGotVer && hasGotData && hasGotType)
							  || chunkEnd < input->getPosition()
							  || input->isExhausted())
					{
						break;
					}

					input->setPosition (chunkEnd + (chunkEnd & 1)); // (chunks should be aligned to an even byte address)
				}
			}
		}

		if (metadataValues.size() > 0)
			metadataValues.set ("MetaDataSource", "AIFF");
	}

	bool readSamples (int** destSamples, int numDestChannels, int startOffsetInDestBuffer,
					  int64 startSampleInFile, int numSamples)
	{
		const int64 samplesAvailable = lengthInSamples - startSampleInFile;

		if (samplesAvailable < numSamples)
		{
			for (int i = numDestChannels; --i >= 0;)
				if (destSamples[i] != nullptr)
					zeromem (destSamples[i] + startOffsetInDestBuffer, sizeof (int) * numSamples);

			numSamples = (int) samplesAvailable;
		}

		if (numSamples <= 0)
			return true;

		input->setPosition (dataChunkStart + startSampleInFile * bytesPerFrame);

		while (numSamples > 0)
		{
			const int tempBufSize = 480 * 3 * 4; // (keep this a multiple of 3)
			char tempBuffer [tempBufSize];

			const int numThisTime = jmin (tempBufSize / bytesPerFrame, numSamples);
			const int bytesRead = input->read (tempBuffer, numThisTime * bytesPerFrame);

			if (bytesRead < numThisTime * bytesPerFrame)
			{
				jassert (bytesRead >= 0);
				zeromem (tempBuffer + bytesRead, (size_t) (numThisTime * bytesPerFrame - bytesRead));
			}

			jassert (! usesFloatingPointData); // (would need to add support for this if it's possible)

			if (littleEndian)
			{
				switch (bitsPerSample)
				{
					case 8:     ReadHelper<AudioData::Int32, AudioData::Int8,  AudioData::LittleEndian>::read (destSamples, startOffsetInDestBuffer, numDestChannels, tempBuffer, (int) numChannels, numThisTime); break;
					case 16:    ReadHelper<AudioData::Int32, AudioData::Int16, AudioData::LittleEndian>::read (destSamples, startOffsetInDestBuffer, numDestChannels, tempBuffer, (int) numChannels, numThisTime); break;
					case 24:    ReadHelper<AudioData::Int32, AudioData::Int24, AudioData::LittleEndian>::read (destSamples, startOffsetInDestBuffer, numDestChannels, tempBuffer, (int) numChannels, numThisTime); break;
					case 32:    ReadHelper<AudioData::Int32, AudioData::Int32, AudioData::LittleEndian>::read (destSamples, startOffsetInDestBuffer, numDestChannels, tempBuffer, (int) numChannels, numThisTime); break;
					default:    jassertfalse; break;
				}
			}
			else
			{
				switch (bitsPerSample)
				{
					case 8:     ReadHelper<AudioData::Int32, AudioData::Int8,  AudioData::BigEndian>::read (destSamples, startOffsetInDestBuffer, numDestChannels, tempBuffer, (int) numChannels, numThisTime); break;
					case 16:    ReadHelper<AudioData::Int32, AudioData::Int16, AudioData::BigEndian>::read (destSamples, startOffsetInDestBuffer, numDestChannels, tempBuffer, (int) numChannels, numThisTime); break;
					case 24:    ReadHelper<AudioData::Int32, AudioData::Int24, AudioData::BigEndian>::read (destSamples, startOffsetInDestBuffer, numDestChannels, tempBuffer, (int) numChannels, numThisTime); break;
					case 32:    ReadHelper<AudioData::Int32, AudioData::Int32, AudioData::BigEndian>::read (destSamples, startOffsetInDestBuffer, numDestChannels, tempBuffer, (int) numChannels, numThisTime); break;
					default:    jassertfalse; break;
				}
			}

			startOffsetInDestBuffer += numThisTime;
			numSamples -= numThisTime;
		}

		return true;
	}

	int bytesPerFrame;
	int64 dataChunkStart;
	bool littleEndian;

private:
	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (AiffAudioFormatReader);
};

class AiffAudioFormatWriter  : public AudioFormatWriter
{
public:
	AiffAudioFormatWriter (OutputStream* out, double sampleRate_,
						   unsigned int numChans, unsigned int bits,
						   const StringPairArray& metadataValues)
		: AudioFormatWriter (out, TRANS (aiffFormatName), sampleRate_, numChans, bits),
		  lengthInSamples (0),
		  bytesWritten (0),
		  writeFailed (false)
	{
		using namespace AiffFileHelpers;

		if (metadataValues.size() > 0)
		{
			// The meta data should have been santised for the AIFF format.
			// If it was originally sourced from a WAV file the MetaDataSource
			// key should be removed (or set to "AIFF") once this has been done
			jassert (metadataValues.getValue ("MetaDataSource", "None") != "WAV");

			MarkChunk::create (markChunk, metadataValues);
			COMTChunk::create (comtChunk, metadataValues);
			InstChunk::create (instChunk, metadataValues);
		}

		headerPosition = out->getPosition();
		writeHeader();
	}

	~AiffAudioFormatWriter()
	{
		if ((bytesWritten & 1) != 0)
			output->writeByte (0);

		writeHeader();
	}

	bool write (const int** data, int numSamples)
	{
		jassert (data != nullptr && *data != nullptr); // the input must contain at least one channel!

		if (writeFailed)
			return false;

		const int bytes = numChannels * numSamples * bitsPerSample / 8;
		tempBlock.ensureSize ((size_t) bytes, false);

		switch (bitsPerSample)
		{
			case 8:     WriteHelper<AudioData::Int8,  AudioData::Int32, AudioData::BigEndian>::write (tempBlock.getData(), (int) numChannels, data, numSamples); break;
			case 16:    WriteHelper<AudioData::Int16, AudioData::Int32, AudioData::BigEndian>::write (tempBlock.getData(), (int) numChannels, data, numSamples); break;
			case 24:    WriteHelper<AudioData::Int24, AudioData::Int32, AudioData::BigEndian>::write (tempBlock.getData(), (int) numChannels, data, numSamples); break;
			case 32:    WriteHelper<AudioData::Int32, AudioData::Int32, AudioData::BigEndian>::write (tempBlock.getData(), (int) numChannels, data, numSamples); break;
			default:    jassertfalse; break;
		}

		if (bytesWritten + bytes >= (size_t) 0xfff00000
			 || ! output->write (tempBlock.getData(), bytes))
		{
			// failed to write to disk, so let's try writing the header.
			// If it's just run out of disk space, then if it does manage
			// to write the header, we'll still have a useable file..
			writeHeader();
			writeFailed = true;
			return false;
		}
		else
		{
			bytesWritten += bytes;
			lengthInSamples += numSamples;

			return true;
		}
	}

private:
	MemoryBlock tempBlock, markChunk, comtChunk, instChunk;
	uint32 lengthInSamples, bytesWritten;
	int64 headerPosition;
	bool writeFailed;

	void writeHeader()
	{
		using namespace AiffFileHelpers;

		const bool couldSeekOk = output->setPosition (headerPosition);
		(void) couldSeekOk;

		// if this fails, you've given it an output stream that can't seek! It needs
		// to be able to seek back to write the header
		jassert (couldSeekOk);

		const int headerLen = (int) (54 + (markChunk.getSize() > 0 ? markChunk.getSize() + 8 : 0)
										+ (comtChunk.getSize() > 0 ? comtChunk.getSize() + 8 : 0)
										+ (instChunk.getSize() > 0 ? instChunk.getSize() + 8 : 0));
		int audioBytes = (int) (lengthInSamples * ((bitsPerSample * numChannels) / 8));
		audioBytes += (audioBytes & 1);

		output->writeInt (chunkName ("FORM"));
		output->writeIntBigEndian (headerLen + audioBytes - 8);
		output->writeInt (chunkName ("AIFF"));
		output->writeInt (chunkName ("COMM"));
		output->writeIntBigEndian (18);
		output->writeShortBigEndian ((short) numChannels);
		output->writeIntBigEndian ((int) lengthInSamples);
		output->writeShortBigEndian ((short) bitsPerSample);

		uint8 sampleRateBytes[10] = { 0 };

		if (sampleRate <= 1)
		{
			sampleRateBytes[0] = 0x3f;
			sampleRateBytes[1] = 0xff;
			sampleRateBytes[2] = 0x80;
		}
		else
		{
			int mask = 0x40000000;
			sampleRateBytes[0] = 0x40;

			if (sampleRate >= mask)
			{
				jassertfalse;
				sampleRateBytes[1] = 0x1d;
			}
			else
			{
				int n = (int) sampleRate;

				int i;
				for (i = 0; i <= 32 ; ++i)
				{
					if ((n & mask) != 0)
						break;

					mask >>= 1;
				}

				n = n << (i + 1);

				sampleRateBytes[1] = (uint8) (29 - i);
				sampleRateBytes[2] = (uint8) ((n >> 24) & 0xff);
				sampleRateBytes[3] = (uint8) ((n >> 16) & 0xff);
				sampleRateBytes[4] = (uint8) ((n >>  8) & 0xff);
				sampleRateBytes[5] = (uint8) (n & 0xff);
			}
		}

		output->write (sampleRateBytes, 10);

		if (markChunk.getSize() > 0)
		{
			output->writeInt (chunkName ("MARK"));
			output->writeIntBigEndian ((int) markChunk.getSize());
			*output << markChunk;
		}

		if (comtChunk.getSize() > 0)
		{
			output->writeInt (chunkName ("COMT"));
			output->writeIntBigEndian ((int) comtChunk.getSize());
			*output << comtChunk;
		}

		if (instChunk.getSize() > 0)
		{
			output->writeInt (chunkName ("INST"));
			output->writeIntBigEndian ((int) instChunk.getSize());
			*output << instChunk;
		}

		output->writeInt (chunkName ("SSND"));
		output->writeIntBigEndian (audioBytes + 8);
		output->writeInt (0);
		output->writeInt (0);

		jassert (output->getPosition() == headerLen);
	}

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (AiffAudioFormatWriter);
};

AiffAudioFormat::AiffAudioFormat()
	: AudioFormat (TRANS (aiffFormatName), StringArray (aiffExtensions))
{
}

AiffAudioFormat::~AiffAudioFormat()
{
}

Array<int> AiffAudioFormat::getPossibleSampleRates()
{
	const int rates[] = { 22050, 32000, 44100, 48000, 88200, 96000, 176400, 192000, 0 };
	return Array <int> (rates);
}

Array<int> AiffAudioFormat::getPossibleBitDepths()
{
	const int depths[] = { 8, 16, 24, 0 };
	return Array <int> (depths);
}

bool AiffAudioFormat::canDoStereo() { return true; }
bool AiffAudioFormat::canDoMono()   { return true; }

#if JUCE_MAC
bool AiffAudioFormat::canHandleFile (const File& f)
{
	if (AudioFormat::canHandleFile (f))
		return true;

	const OSType type = f.getMacOSType();
	return type == 'AIFF' || type == 'AIFC'
		|| type == 'aiff' || type == 'aifc';
}
#endif

AudioFormatReader* AiffAudioFormat::createReaderFor (InputStream* sourceStream, const bool deleteStreamIfOpeningFails)
{
	ScopedPointer <AiffAudioFormatReader> w (new AiffAudioFormatReader (sourceStream));

	if (w->sampleRate > 0)
		return w.release();

	if (! deleteStreamIfOpeningFails)
		w->input = nullptr;

	return nullptr;
}

AudioFormatWriter* AiffAudioFormat::createWriterFor (OutputStream* out,
													 double sampleRate,
													 unsigned int numberOfChannels,
													 int bitsPerSample,
													 const StringPairArray& metadataValues,
													 int /*qualityOptionIndex*/)
{
	if (getPossibleBitDepths().contains (bitsPerSample))
		return new AiffAudioFormatWriter (out, sampleRate, numberOfChannels, (unsigned int) bitsPerSample, metadataValues);

	return nullptr;
}

/*** End of inlined file: juce_AiffAudioFormat.cpp ***/


/*** Start of inlined file: juce_CoreAudioFormat.cpp ***/
#if JUCE_MAC || JUCE_IOS

namespace
{
	const char* const coreAudioFormatName = "CoreAudio supported file";

	StringArray findFileExtensionsForCoreAudioCodecs()
	{
		StringArray extensionsArray;
		CFMutableArrayRef extensions = CFArrayCreateMutable (0, 0, 0);
		UInt32 sizeOfArray = sizeof (CFMutableArrayRef);

		if (AudioFileGetGlobalInfo (kAudioFileGlobalInfo_AllExtensions, 0, 0, &sizeOfArray, &extensions) == noErr)
		{
			const CFIndex numValues = CFArrayGetCount (extensions);

			for (CFIndex i = 0; i < numValues; ++i)
				extensionsArray.add ("." + String::fromCFString ((CFStringRef) CFArrayGetValueAtIndex (extensions, i)));
		}

		CFRelease (extensions);
		return extensionsArray;
	}
}

class CoreAudioReader : public AudioFormatReader
{
public:
	CoreAudioReader (InputStream* const inp)
		: AudioFormatReader (inp, TRANS (coreAudioFormatName)),
		  ok (false), lastReadPosition (0)
	{
		usesFloatingPointData = true;

		OSStatus status = AudioFileOpenWithCallbacks (this,
													  &readCallback,
													  0,        // write needs to be null to avoid permisisions errors
													  &getSizeCallback,
													  0,        // setSize needs to be null to avoid permisisions errors
													  0,        // AudioFileTypeID inFileTypeHint
													  &audioFileID);
		if (status == noErr)
		{
			status = ExtAudioFileWrapAudioFileID (audioFileID, false, &audioFileRef);

			if (status == noErr)
			{
				AudioStreamBasicDescription sourceAudioFormat;
				UInt32 audioStreamBasicDescriptionSize = sizeof (AudioStreamBasicDescription);
				ExtAudioFileGetProperty (audioFileRef,
										 kExtAudioFileProperty_FileDataFormat,
										 &audioStreamBasicDescriptionSize,
										 &sourceAudioFormat);

				numChannels   = sourceAudioFormat.mChannelsPerFrame;
				sampleRate    = sourceAudioFormat.mSampleRate;
				bitsPerSample = sourceAudioFormat.mBitsPerChannel;

				UInt32 sizeOfLengthProperty = sizeof (int64);
				ExtAudioFileGetProperty (audioFileRef,
										 kExtAudioFileProperty_FileLengthFrames,
										 &sizeOfLengthProperty,
										 &lengthInSamples);

				destinationAudioFormat.mSampleRate       = sampleRate;
				destinationAudioFormat.mFormatID         = kAudioFormatLinearPCM;
				destinationAudioFormat.mFormatFlags      = kLinearPCMFormatFlagIsFloat | kLinearPCMFormatFlagIsNonInterleaved | kAudioFormatFlagsNativeEndian;
				destinationAudioFormat.mBitsPerChannel   = sizeof (float) * 8;
				destinationAudioFormat.mChannelsPerFrame = numChannels;
				destinationAudioFormat.mBytesPerFrame    = sizeof (float);
				destinationAudioFormat.mFramesPerPacket  = 1;
				destinationAudioFormat.mBytesPerPacket   = destinationAudioFormat.mFramesPerPacket * destinationAudioFormat.mBytesPerFrame;

				status = ExtAudioFileSetProperty (audioFileRef,
												  kExtAudioFileProperty_ClientDataFormat,
												  sizeof (AudioStreamBasicDescription),
												  &destinationAudioFormat);
				if (status == noErr)
				{
					bufferList.malloc (1, sizeof (AudioBufferList) + numChannels * sizeof (AudioBuffer));
					bufferList->mNumberBuffers = numChannels;
					ok = true;
				}
			}
		}
	}

	~CoreAudioReader()
	{
		ExtAudioFileDispose (audioFileRef);
		AudioFileClose (audioFileID);
	}

	bool readSamples (int** destSamples, int numDestChannels, int startOffsetInDestBuffer,
					  int64 startSampleInFile, int numSamples)
	{
		jassert (destSamples != nullptr);
		const int64 samplesAvailable = lengthInSamples - startSampleInFile;

		if (samplesAvailable < numSamples)
		{
			for (int i = numDestChannels; --i >= 0;)
				if (destSamples[i] != nullptr)
					zeromem (destSamples[i] + startOffsetInDestBuffer, sizeof (int) * numSamples);

			numSamples = (int) samplesAvailable;
		}

		if (numSamples <= 0)
			return true;

		if (lastReadPosition != startSampleInFile)
		{
			OSStatus status = ExtAudioFileSeek (audioFileRef, startSampleInFile);
			if (status != noErr)
				return false;

			lastReadPosition = startSampleInFile;
		}

		while (numSamples > 0)
		{
			const int numThisTime = jmin (8192, numSamples);
			const int numBytes = numThisTime * sizeof (float);

			audioDataBlock.ensureSize (numBytes * numChannels, false);
			float* data = static_cast<float*> (audioDataBlock.getData());

			for (int j = numChannels; --j >= 0;)
			{
				bufferList->mBuffers[j].mNumberChannels = 1;
				bufferList->mBuffers[j].mDataByteSize = numBytes;
				bufferList->mBuffers[j].mData = data;
				data += numThisTime;
			}

			UInt32 numFramesToRead = numThisTime;
			OSStatus status = ExtAudioFileRead (audioFileRef, &numFramesToRead, bufferList);
			if (status != noErr)
				return false;

			for (int i = numDestChannels; --i >= 0;)
			{
				if (destSamples[i] != nullptr)
				{
					if (i < numChannels)
						memcpy (destSamples[i] + startOffsetInDestBuffer, bufferList->mBuffers[i].mData, numBytes);
					else
						zeromem (destSamples[i] + startOffsetInDestBuffer, numBytes);
				}
			}

			startOffsetInDestBuffer += numThisTime;
			numSamples -= numThisTime;
			lastReadPosition += numThisTime;
		}

		return true;
	}

	bool ok;

private:
	AudioFileID audioFileID;
	ExtAudioFileRef audioFileRef;
	AudioStreamBasicDescription destinationAudioFormat;
	MemoryBlock audioDataBlock;
	HeapBlock<AudioBufferList> bufferList;
	int64 lastReadPosition;

	static SInt64 getSizeCallback (void* inClientData)
	{
		return static_cast<CoreAudioReader*> (inClientData)->input->getTotalLength();
	}

	static OSStatus readCallback (void* inClientData,
								  SInt64 inPosition,
								  UInt32 requestCount,
								  void* buffer,
								  UInt32* actualCount)
	{
		CoreAudioReader* const reader = static_cast<CoreAudioReader*> (inClientData);

		reader->input->setPosition (inPosition);
		*actualCount = reader->input->read (buffer, requestCount);

		return noErr;
	}

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (CoreAudioReader);
};

CoreAudioFormat::CoreAudioFormat()
	: AudioFormat (TRANS (coreAudioFormatName), findFileExtensionsForCoreAudioCodecs())
{
}

CoreAudioFormat::~CoreAudioFormat() {}

Array<int> CoreAudioFormat::getPossibleSampleRates()    { return Array<int>(); }
Array<int> CoreAudioFormat::getPossibleBitDepths()      { return Array<int>(); }

bool CoreAudioFormat::canDoStereo()     { return true; }
bool CoreAudioFormat::canDoMono()       { return true; }

AudioFormatReader* CoreAudioFormat::createReaderFor (InputStream* sourceStream,
													 bool deleteStreamIfOpeningFails)
{
	ScopedPointer<CoreAudioReader> r (new CoreAudioReader (sourceStream));

	if (r->ok)
		return r.release();

	if (! deleteStreamIfOpeningFails)
		r->input = nullptr;

	return nullptr;
}

AudioFormatWriter* CoreAudioFormat::createWriterFor (OutputStream* streamToWriteTo,
													 double sampleRateToUse,
													 unsigned int numberOfChannels,
													 int bitsPerSample,
													 const StringPairArray& metadataValues,
													 int qualityOptionIndex)
{
	jassertfalse; // not yet implemented!
	return nullptr;
}

#endif

/*** End of inlined file: juce_CoreAudioFormat.cpp ***/


/*** Start of inlined file: juce_FlacAudioFormat.cpp ***/
#if JUCE_USE_FLAC

namespace FlacNamespace
{
#if JUCE_INCLUDE_FLAC_CODE || ! defined (JUCE_INCLUDE_FLAC_CODE)

 #undef VERSION
 #define VERSION "1.2.1"

 #define FLAC__NO_DLL 1

 #if JUCE_MSVC
  #pragma warning (disable: 4267 4127 4244 4996 4100 4701 4702 4013 4133 4206 4312 4505 4365 4005 4334 181 111)
 #endif

 #if JUCE_MAC
  #define FLAC__SYS_DARWIN 1
 #endif

 #ifndef SIZE_MAX
  #define SIZE_MAX 0xffffffff
 #endif

 #define __STDC_LIMIT_MACROS 1

/*** Start of inlined file: all.h ***/
#ifndef FLAC__ALL_H
#define FLAC__ALL_H


/*** Start of inlined file: export.h ***/
#ifndef FLAC__EXPORT_H
#define FLAC__EXPORT_H

/** \file include/FLAC/export.h
 *
 *  \brief
 *  This module contains #defines and symbols for exporting function
 *  calls, and providing version information and compiled-in features.
 *
 *  See the \link flac_export export \endlink module.
 */

/** \defgroup flac_export FLAC/export.h: export symbols
 *  \ingroup flac
 *
 *  \brief
 *  This module contains #defines and symbols for exporting function
 *  calls, and providing version information and compiled-in features.
 *
 *  If you are compiling with MSVC and will link to the static library
 *  (libFLAC.lib) you should define FLAC__NO_DLL in your project to
 *  make sure the symbols are exported properly.
 *
 * \{
 */

#if defined(FLAC__NO_DLL) || !defined(_MSC_VER)
#define FLAC_API

#else

#ifdef FLAC_API_EXPORTS
#define	FLAC_API	_declspec(dllexport)
#else
#define FLAC_API	_declspec(dllimport)

#endif
#endif

/** These #defines will mirror the libtool-based library version number, see
 * http://www.gnu.org/software/libtool/manual.html#Libtool-versioning
 */
#define FLAC_API_VERSION_CURRENT 10
#define FLAC_API_VERSION_REVISION 0 /**< see above */
#define FLAC_API_VERSION_AGE 2 /**< see above */

#ifdef __cplusplus
extern "C" {
#endif

/** \c 1 if the library has been compiled with support for Ogg FLAC, else \c 0. */
extern FLAC_API int FLAC_API_SUPPORTS_OGG_FLAC;

#ifdef __cplusplus
}
#endif

/* \} */

#endif

/*** End of inlined file: export.h ***/


/*** Start of inlined file: assert.h ***/
#ifndef FLAC__ASSERT_H
#define FLAC__ASSERT_H

/* we need this since some compilers (like MSVC) leave assert()s on release code (and we don't want to use their ASSERT) */
#ifdef DEBUG
#include <assert.h>
#define FLAC__ASSERT(x) assert(x)
#define FLAC__ASSERT_DECLARATION(x) x
#else
#define FLAC__ASSERT(x)
#define FLAC__ASSERT_DECLARATION(x)
#endif

#endif

/*** End of inlined file: assert.h ***/


/*** Start of inlined file: callback.h ***/
#ifndef FLAC__CALLBACK_H
#define FLAC__CALLBACK_H


/*** Start of inlined file: ordinals.h ***/
#ifndef FLAC__ORDINALS_H
#define FLAC__ORDINALS_H

#if !(defined(_MSC_VER) || defined(__BORLANDC__) || defined(__EMX__))
#include <inttypes.h>
#endif

typedef signed char FLAC__int8;
typedef unsigned char FLAC__uint8;

#if defined(_MSC_VER) || defined(__BORLANDC__)
typedef __int16 FLAC__int16;
typedef __int32 FLAC__int32;
typedef __int64 FLAC__int64;
typedef unsigned __int16 FLAC__uint16;
typedef unsigned __int32 FLAC__uint32;
typedef unsigned __int64 FLAC__uint64;
#elif defined(__EMX__)
typedef short FLAC__int16;
typedef long FLAC__int32;
typedef long long FLAC__int64;
typedef unsigned short FLAC__uint16;
typedef unsigned long FLAC__uint32;
typedef unsigned long long FLAC__uint64;
#else
typedef int16_t FLAC__int16;
typedef int32_t FLAC__int32;
typedef int64_t FLAC__int64;
typedef uint16_t FLAC__uint16;
typedef uint32_t FLAC__uint32;
typedef uint64_t FLAC__uint64;
#endif

typedef int FLAC__bool;

typedef FLAC__uint8 FLAC__byte;

#ifdef true
#undef true
#endif
#ifdef false
#undef false
#endif
#ifndef __cplusplus
#define true 1
#define false 0
#endif

#endif

/*** End of inlined file: ordinals.h ***/

#include <stdlib.h> /* for size_t */

/** \file include/FLAC/callback.h
 *
 *  \brief
 *  This module defines the structures for describing I/O callbacks
 *  to the other FLAC interfaces.
 *
 *  See the detailed documentation for callbacks in the
 *  \link flac_callbacks callbacks \endlink module.
 */

/** \defgroup flac_callbacks FLAC/callback.h: I/O callback structures
 *  \ingroup flac
 *
 *  \brief
 *  This module defines the structures for describing I/O callbacks
 *  to the other FLAC interfaces.
 *
 *  The purpose of the I/O callback functions is to create a common way
 *  for the metadata interfaces to handle I/O.
 *
 *  Originally the metadata interfaces required filenames as the way of
 *  specifying FLAC files to operate on.  This is problematic in some
 *  environments so there is an additional option to specify a set of
 *  callbacks for doing I/O on the FLAC file, instead of the filename.
 *
 *  In addition to the callbacks, a FLAC__IOHandle type is defined as an
 *  opaque structure for a data source.
 *
 *  The callback function prototypes are similar (but not identical) to the
 *  stdio functions fread, fwrite, fseek, ftell, feof, and fclose.  If you use
 *  stdio streams to implement the callbacks, you can pass fread, fwrite, and
 *  fclose anywhere a FLAC__IOCallback_Read, FLAC__IOCallback_Write, or
 *  FLAC__IOCallback_Close is required, and a FILE* anywhere a FLAC__IOHandle
 *  is required.  \warning You generally CANNOT directly use fseek or ftell
 *  for FLAC__IOCallback_Seek or FLAC__IOCallback_Tell since on most systems
 *  these use 32-bit offsets and FLAC requires 64-bit offsets to deal with
 *  large files.  You will have to find an equivalent function (e.g. ftello),
 *  or write a wrapper.  The same is true for feof() since this is usually
 *  implemented as a macro, not as a function whose address can be taken.
 *
 * \{
 */

#ifdef __cplusplus
extern "C" {
#endif

/** This is the opaque handle type used by the callbacks.  Typically
 *  this is a \c FILE* or address of a file descriptor.
 */
typedef void* FLAC__IOHandle;

/** Signature for the read callback.
 *  The signature and semantics match POSIX fread() implementations
 *  and can generally be used interchangeably.
 *
 * \param  ptr      The address of the read buffer.
 * \param  size     The size of the records to be read.
 * \param  nmemb    The number of records to be read.
 * \param  handle   The handle to the data source.
 * \retval size_t
 *    The number of records read.
 */
typedef size_t (*FLAC__IOCallback_Read) (void *ptr, size_t size, size_t nmemb, FLAC__IOHandle handle);

/** Signature for the write callback.
 *  The signature and semantics match POSIX fwrite() implementations
 *  and can generally be used interchangeably.
 *
 * \param  ptr      The address of the write buffer.
 * \param  size     The size of the records to be written.
 * \param  nmemb    The number of records to be written.
 * \param  handle   The handle to the data source.
 * \retval size_t
 *    The number of records written.
 */
typedef size_t (*FLAC__IOCallback_Write) (const void *ptr, size_t size, size_t nmemb, FLAC__IOHandle handle);

/** Signature for the seek callback.
 *  The signature and semantics mostly match POSIX fseek() WITH ONE IMPORTANT
 *  EXCEPTION: the offset is a 64-bit type whereas fseek() is generally 'long'
 *  and 32-bits wide.
 *
 * \param  handle   The handle to the data source.
 * \param  offset   The new position, relative to \a whence
 * \param  whence   \c SEEK_SET, \c SEEK_CUR, or \c SEEK_END
 * \retval int
 *    \c 0 on success, \c -1 on error.
 */
typedef int (*FLAC__IOCallback_Seek) (FLAC__IOHandle handle, FLAC__int64 offset, int whence);

/** Signature for the tell callback.
 *  The signature and semantics mostly match POSIX ftell() WITH ONE IMPORTANT
 *  EXCEPTION: the offset is a 64-bit type whereas ftell() is generally 'long'
 *  and 32-bits wide.
 *
 * \param  handle   The handle to the data source.
 * \retval FLAC__int64
 *    The current position on success, \c -1 on error.
 */
typedef FLAC__int64 (*FLAC__IOCallback_Tell) (FLAC__IOHandle handle);

/** Signature for the EOF callback.
 *  The signature and semantics mostly match POSIX feof() but WATCHOUT:
 *  on many systems, feof() is a macro, so in this case a wrapper function
 *  must be provided instead.
 *
 * \param  handle   The handle to the data source.
 * \retval int
 *    \c 0 if not at end of file, nonzero if at end of file.
 */
typedef int (*FLAC__IOCallback_Eof) (FLAC__IOHandle handle);

/** Signature for the close callback.
 *  The signature and semantics match POSIX fclose() implementations
 *  and can generally be used interchangeably.
 *
 * \param  handle   The handle to the data source.
 * \retval int
 *    \c 0 on success, \c EOF on error.
 */
typedef int (*FLAC__IOCallback_Close) (FLAC__IOHandle handle);

/** A structure for holding a set of callbacks.
 *  Each FLAC interface that requires a FLAC__IOCallbacks structure will
 *  describe which of the callbacks are required.  The ones that are not
 *  required may be set to NULL.
 *
 *  If the seek requirement for an interface is optional, you can signify that
 *  a data sorce is not seekable by setting the \a seek field to \c NULL.
 */
typedef struct {
	FLAC__IOCallback_Read read;
	FLAC__IOCallback_Write write;
	FLAC__IOCallback_Seek seek;
	FLAC__IOCallback_Tell tell;
	FLAC__IOCallback_Eof eof;
	FLAC__IOCallback_Close close;
} FLAC__IOCallbacks;

/* \} */

#ifdef __cplusplus
}
#endif

#endif

/*** End of inlined file: callback.h ***/


/*** Start of inlined file: format.h ***/
#ifndef FLAC__FORMAT_H
#define FLAC__FORMAT_H

#ifdef __cplusplus
extern "C" {
#endif

/** \file include/FLAC/format.h
 *
 *  \brief
 *  This module contains structure definitions for the representation
 *  of FLAC format components in memory.  These are the basic
 *  structures used by the rest of the interfaces.
 *
 *  See the detailed documentation in the
 *  \link flac_format format \endlink module.
 */

/** \defgroup flac_format FLAC/format.h: format components
 *  \ingroup flac
 *
 *  \brief
 *  This module contains structure definitions for the representation
 *  of FLAC format components in memory.  These are the basic
 *  structures used by the rest of the interfaces.
 *
 *  First, you should be familiar with the
 *  <A HREF="../format.html">FLAC format</A>.  Many of the values here
 *  follow directly from the specification.  As a user of libFLAC, the
 *  interesting parts really are the structures that describe the frame
 *  header and metadata blocks.
 *
 *  The format structures here are very primitive, designed to store
 *  information in an efficient way.  Reading information from the
 *  structures is easy but creating or modifying them directly is
 *  more complex.  For the most part, as a user of a library, editing
 *  is not necessary; however, for metadata blocks it is, so there are
 *  convenience functions provided in the \link flac_metadata metadata
 *  module \endlink to simplify the manipulation of metadata blocks.
 *
 * \note
 * It's not the best convention, but symbols ending in _LEN are in bits
 * and _LENGTH are in bytes.  _LENGTH symbols are \#defines instead of
 * global variables because they are usually used when declaring byte
 * arrays and some compilers require compile-time knowledge of array
 * sizes when declared on the stack.
 *
 * \{
 */

/*
	Most of the values described in this file are defined by the FLAC
	format specification.  There is nothing to tune here.
*/

/** The largest legal metadata type code. */
#define FLAC__MAX_METADATA_TYPE_CODE (126u)

/** The minimum block size, in samples, permitted by the format. */
#define FLAC__MIN_BLOCK_SIZE (16u)

/** The maximum block size, in samples, permitted by the format. */
#define FLAC__MAX_BLOCK_SIZE (65535u)

/** The maximum block size, in samples, permitted by the FLAC subset for
 *  sample rates up to 48kHz. */
#define FLAC__SUBSET_MAX_BLOCK_SIZE_48000HZ (4608u)

/** The maximum number of channels permitted by the format. */
#define FLAC__MAX_CHANNELS (8u)

/** The minimum sample resolution permitted by the format. */
#define FLAC__MIN_BITS_PER_SAMPLE (4u)

/** The maximum sample resolution permitted by the format. */
#define FLAC__MAX_BITS_PER_SAMPLE (32u)

/** The maximum sample resolution permitted by libFLAC.
 *
 * \warning
 * FLAC__MAX_BITS_PER_SAMPLE is the limit of the FLAC format.  However,
 * the reference encoder/decoder is currently limited to 24 bits because
 * of prevalent 32-bit math, so make sure and use this value when
 * appropriate.
 */
#define FLAC__REFERENCE_CODEC_MAX_BITS_PER_SAMPLE (24u)

/** The maximum sample rate permitted by the format.  The value is
 *  ((2 ^ 16) - 1) * 10; see <A HREF="../format.html">FLAC format</A>
 *  as to why.
 */
#define FLAC__MAX_SAMPLE_RATE (655350u)

/** The maximum LPC order permitted by the format. */
#define FLAC__MAX_LPC_ORDER (32u)

/** The maximum LPC order permitted by the FLAC subset for sample rates
 *  up to 48kHz. */
#define FLAC__SUBSET_MAX_LPC_ORDER_48000HZ (12u)

/** The minimum quantized linear predictor coefficient precision
 *  permitted by the format.
 */
#define FLAC__MIN_QLP_COEFF_PRECISION (5u)

/** The maximum quantized linear predictor coefficient precision
 *  permitted by the format.
 */
#define FLAC__MAX_QLP_COEFF_PRECISION (15u)

/** The maximum order of the fixed predictors permitted by the format. */
#define FLAC__MAX_FIXED_ORDER (4u)

/** The maximum Rice partition order permitted by the format. */
#define FLAC__MAX_RICE_PARTITION_ORDER (15u)

/** The maximum Rice partition order permitted by the FLAC Subset. */
#define FLAC__SUBSET_MAX_RICE_PARTITION_ORDER (8u)

/** The version string of the release, stamped onto the libraries and binaries.
 *
 * \note
 * This does not correspond to the shared library version number, which
 * is used to determine binary compatibility.
 */
extern FLAC_API const char *FLAC__VERSION_STRING;

/** The vendor string inserted by the encoder into the VORBIS_COMMENT block.
 *  This is a NUL-terminated ASCII string; when inserted into the
 *  VORBIS_COMMENT the trailing null is stripped.
 */
extern FLAC_API const char *FLAC__VENDOR_STRING;

/** The byte string representation of the beginning of a FLAC stream. */
extern FLAC_API const FLAC__byte FLAC__STREAM_SYNC_STRING[4]; /* = "fLaC" */

/** The 32-bit integer big-endian representation of the beginning of
 *  a FLAC stream.
 */
extern FLAC_API const unsigned FLAC__STREAM_SYNC; /* = 0x664C6143 */

/** The length of the FLAC signature in bits. */
extern FLAC_API const unsigned FLAC__STREAM_SYNC_LEN; /* = 32 bits */

/** The length of the FLAC signature in bytes. */
#define FLAC__STREAM_SYNC_LENGTH (4u)

/*****************************************************************************
 *
 * Subframe structures
 *
 *****************************************************************************/

/*****************************************************************************/

/** An enumeration of the available entropy coding methods. */
typedef enum {
	FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE = 0,
	/**< Residual is coded by partitioning into contexts, each with it's own
	 * 4-bit Rice parameter. */

	FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2 = 1
	/**< Residual is coded by partitioning into contexts, each with it's own
	 * 5-bit Rice parameter. */
} FLAC__EntropyCodingMethodType;

/** Maps a FLAC__EntropyCodingMethodType to a C string.
 *
 *  Using a FLAC__EntropyCodingMethodType as the index to this array will
 *  give the string equivalent.  The contents should not be modified.
 */
extern FLAC_API const char * const FLAC__EntropyCodingMethodTypeString[];

/** Contents of a Rice partitioned residual
 */
typedef struct {

	unsigned *parameters;
	/**< The Rice parameters for each context. */

	unsigned *raw_bits;
	/**< Widths for escape-coded partitions.  Will be non-zero for escaped
	 * partitions and zero for unescaped partitions.
	 */

	unsigned capacity_by_order;
	/**< The capacity of the \a parameters and \a raw_bits arrays
	 * specified as an order, i.e. the number of array elements
	 * allocated is 2 ^ \a capacity_by_order.
	 */
} FLAC__EntropyCodingMethod_PartitionedRiceContents;

/** Header for a Rice partitioned residual.  (c.f. <A HREF="../format.html#partitioned_rice">format specification</A>)
 */
typedef struct {

	unsigned order;
	/**< The partition order, i.e. # of contexts = 2 ^ \a order. */

	const FLAC__EntropyCodingMethod_PartitionedRiceContents *contents;
	/**< The context's Rice parameters and/or raw bits. */

} FLAC__EntropyCodingMethod_PartitionedRice;

extern FLAC_API const unsigned FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_ORDER_LEN; /**< == 4 (bits) */
extern FLAC_API const unsigned FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_PARAMETER_LEN; /**< == 4 (bits) */
extern FLAC_API const unsigned FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2_PARAMETER_LEN; /**< == 5 (bits) */
extern FLAC_API const unsigned FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_RAW_LEN; /**< == 5 (bits) */

extern FLAC_API const unsigned FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_ESCAPE_PARAMETER;
/**< == (1<<FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_PARAMETER_LEN)-1 */
extern FLAC_API const unsigned FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2_ESCAPE_PARAMETER;
/**< == (1<<FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2_PARAMETER_LEN)-1 */

/** Header for the entropy coding method.  (c.f. <A HREF="../format.html#residual">format specification</A>)
 */
typedef struct {
	FLAC__EntropyCodingMethodType type;
	union {
		FLAC__EntropyCodingMethod_PartitionedRice partitioned_rice;
	} data;
} FLAC__EntropyCodingMethod;

extern FLAC_API const unsigned FLAC__ENTROPY_CODING_METHOD_TYPE_LEN; /**< == 2 (bits) */

/*****************************************************************************/

/** An enumeration of the available subframe types. */
typedef enum {
	FLAC__SUBFRAME_TYPE_CONSTANT = 0, /**< constant signal */
	FLAC__SUBFRAME_TYPE_VERBATIM = 1, /**< uncompressed signal */
	FLAC__SUBFRAME_TYPE_FIXED = 2, /**< fixed polynomial prediction */
	FLAC__SUBFRAME_TYPE_LPC = 3 /**< linear prediction */
} FLAC__SubframeType;

/** Maps a FLAC__SubframeType to a C string.
 *
 *  Using a FLAC__SubframeType as the index to this array will
 *  give the string equivalent.  The contents should not be modified.
 */
extern FLAC_API const char * const FLAC__SubframeTypeString[];

/** CONSTANT subframe.  (c.f. <A HREF="../format.html#subframe_constant">format specification</A>)
 */
typedef struct {
	FLAC__int32 value; /**< The constant signal value. */
} FLAC__Subframe_Constant;

/** VERBATIM subframe.  (c.f. <A HREF="../format.html#subframe_verbatim">format specification</A>)
 */
typedef struct {
	const FLAC__int32 *data; /**< A pointer to verbatim signal. */
} FLAC__Subframe_Verbatim;

/** FIXED subframe.  (c.f. <A HREF="../format.html#subframe_fixed">format specification</A>)
 */
typedef struct {
	FLAC__EntropyCodingMethod entropy_coding_method;
	/**< The residual coding method. */

	unsigned order;
	/**< The polynomial order. */

	FLAC__int32 warmup[FLAC__MAX_FIXED_ORDER];
	/**< Warmup samples to prime the predictor, length == order. */

	const FLAC__int32 *residual;
	/**< The residual signal, length == (blocksize minus order) samples. */
} FLAC__Subframe_Fixed;

/** LPC subframe.  (c.f. <A HREF="../format.html#subframe_lpc">format specification</A>)
 */
typedef struct {
	FLAC__EntropyCodingMethod entropy_coding_method;
	/**< The residual coding method. */

	unsigned order;
	/**< The FIR order. */

	unsigned qlp_coeff_precision;
	/**< Quantized FIR filter coefficient precision in bits. */

	int quantization_level;
	/**< The qlp coeff shift needed. */

	FLAC__int32 qlp_coeff[FLAC__MAX_LPC_ORDER];
	/**< FIR filter coefficients. */

	FLAC__int32 warmup[FLAC__MAX_LPC_ORDER];
	/**< Warmup samples to prime the predictor, length == order. */

	const FLAC__int32 *residual;
	/**< The residual signal, length == (blocksize minus order) samples. */
} FLAC__Subframe_LPC;

extern FLAC_API const unsigned FLAC__SUBFRAME_LPC_QLP_COEFF_PRECISION_LEN; /**< == 4 (bits) */
extern FLAC_API const unsigned FLAC__SUBFRAME_LPC_QLP_SHIFT_LEN; /**< == 5 (bits) */

/** FLAC subframe structure.  (c.f. <A HREF="../format.html#subframe">format specification</A>)
 */
typedef struct {
	FLAC__SubframeType type;
	union {
		FLAC__Subframe_Constant constant;
		FLAC__Subframe_Fixed fixed;
		FLAC__Subframe_LPC lpc;
		FLAC__Subframe_Verbatim verbatim;
	} data;
	unsigned wasted_bits;
} FLAC__Subframe;

/** == 1 (bit)
 *
 * This used to be a zero-padding bit (hence the name
 * FLAC__SUBFRAME_ZERO_PAD_LEN) but is now a reserved bit.  It still has a
 * mandatory value of \c 0 but in the future may take on the value \c 0 or \c 1
 * to mean something else.
 */
extern FLAC_API const unsigned FLAC__SUBFRAME_ZERO_PAD_LEN;
extern FLAC_API const unsigned FLAC__SUBFRAME_TYPE_LEN; /**< == 6 (bits) */
extern FLAC_API const unsigned FLAC__SUBFRAME_WASTED_BITS_FLAG_LEN; /**< == 1 (bit) */

extern FLAC_API const unsigned FLAC__SUBFRAME_TYPE_CONSTANT_BYTE_ALIGNED_MASK; /**< = 0x00 */
extern FLAC_API const unsigned FLAC__SUBFRAME_TYPE_VERBATIM_BYTE_ALIGNED_MASK; /**< = 0x02 */
extern FLAC_API const unsigned FLAC__SUBFRAME_TYPE_FIXED_BYTE_ALIGNED_MASK; /**< = 0x10 */
extern FLAC_API const unsigned FLAC__SUBFRAME_TYPE_LPC_BYTE_ALIGNED_MASK; /**< = 0x40 */

/*****************************************************************************/

/*****************************************************************************
 *
 * Frame structures
 *
 *****************************************************************************/

/** An enumeration of the available channel assignments. */
typedef enum {
	FLAC__CHANNEL_ASSIGNMENT_INDEPENDENT = 0, /**< independent channels */
	FLAC__CHANNEL_ASSIGNMENT_LEFT_SIDE = 1, /**< left+side stereo */
	FLAC__CHANNEL_ASSIGNMENT_RIGHT_SIDE = 2, /**< right+side stereo */
	FLAC__CHANNEL_ASSIGNMENT_MID_SIDE = 3 /**< mid+side stereo */
} FLAC__ChannelAssignment;

/** Maps a FLAC__ChannelAssignment to a C string.
 *
 *  Using a FLAC__ChannelAssignment as the index to this array will
 *  give the string equivalent.  The contents should not be modified.
 */
extern FLAC_API const char * const FLAC__ChannelAssignmentString[];

/** An enumeration of the possible frame numbering methods. */
typedef enum {
	FLAC__FRAME_NUMBER_TYPE_FRAME_NUMBER, /**< number contains the frame number */
	FLAC__FRAME_NUMBER_TYPE_SAMPLE_NUMBER /**< number contains the sample number of first sample in frame */
} FLAC__FrameNumberType;

/** Maps a FLAC__FrameNumberType to a C string.
 *
 *  Using a FLAC__FrameNumberType as the index to this array will
 *  give the string equivalent.  The contents should not be modified.
 */
extern FLAC_API const char * const FLAC__FrameNumberTypeString[];

/** FLAC frame header structure.  (c.f. <A HREF="../format.html#frame_header">format specification</A>)
 */
typedef struct {
	unsigned blocksize;
	/**< The number of samples per subframe. */

	unsigned sample_rate;
	/**< The sample rate in Hz. */

	unsigned channels;
	/**< The number of channels (== number of subframes). */

	FLAC__ChannelAssignment channel_assignment;
	/**< The channel assignment for the frame. */

	unsigned bits_per_sample;
	/**< The sample resolution. */

	FLAC__FrameNumberType number_type;
	/**< The numbering scheme used for the frame.  As a convenience, the
	 * decoder will always convert a frame number to a sample number because
	 * the rules are complex. */

	union {
		FLAC__uint32 frame_number;
		FLAC__uint64 sample_number;
	} number;
	/**< The frame number or sample number of first sample in frame;
	 * use the \a number_type value to determine which to use. */

	FLAC__uint8 crc;
	/**< CRC-8 (polynomial = x^8 + x^2 + x^1 + x^0, initialized with 0)
	 * of the raw frame header bytes, meaning everything before the CRC byte
	 * including the sync code.
	 */
} FLAC__FrameHeader;

extern FLAC_API const unsigned FLAC__FRAME_HEADER_SYNC; /**< == 0x3ffe; the frame header sync code */
extern FLAC_API const unsigned FLAC__FRAME_HEADER_SYNC_LEN; /**< == 14 (bits) */
extern FLAC_API const unsigned FLAC__FRAME_HEADER_RESERVED_LEN; /**< == 1 (bits) */
extern FLAC_API const unsigned FLAC__FRAME_HEADER_BLOCKING_STRATEGY_LEN; /**< == 1 (bits) */
extern FLAC_API const unsigned FLAC__FRAME_HEADER_BLOCK_SIZE_LEN; /**< == 4 (bits) */
extern FLAC_API const unsigned FLAC__FRAME_HEADER_SAMPLE_RATE_LEN; /**< == 4 (bits) */
extern FLAC_API const unsigned FLAC__FRAME_HEADER_CHANNEL_ASSIGNMENT_LEN; /**< == 4 (bits) */
extern FLAC_API const unsigned FLAC__FRAME_HEADER_BITS_PER_SAMPLE_LEN; /**< == 3 (bits) */
extern FLAC_API const unsigned FLAC__FRAME_HEADER_ZERO_PAD_LEN; /**< == 1 (bit) */
extern FLAC_API const unsigned FLAC__FRAME_HEADER_CRC_LEN; /**< == 8 (bits) */

/** FLAC frame footer structure.  (c.f. <A HREF="../format.html#frame_footer">format specification</A>)
 */
typedef struct {
	FLAC__uint16 crc;
	/**< CRC-16 (polynomial = x^16 + x^15 + x^2 + x^0, initialized with
	 * 0) of the bytes before the crc, back to and including the frame header
	 * sync code.
	 */
} FLAC__FrameFooter;

extern FLAC_API const unsigned FLAC__FRAME_FOOTER_CRC_LEN; /**< == 16 (bits) */

/** FLAC frame structure.  (c.f. <A HREF="../format.html#frame">format specification</A>)
 */
typedef struct {
	FLAC__FrameHeader header;
	FLAC__Subframe subframes[FLAC__MAX_CHANNELS];
	FLAC__FrameFooter footer;
} FLAC__Frame;

/*****************************************************************************/

/*****************************************************************************
 *
 * Meta-data structures
 *
 *****************************************************************************/

/** An enumeration of the available metadata block types. */
typedef enum {

	FLAC__METADATA_TYPE_STREAMINFO = 0,
	/**< <A HREF="../format.html#metadata_block_streaminfo">STREAMINFO</A> block */

	FLAC__METADATA_TYPE_PADDING = 1,
	/**< <A HREF="../format.html#metadata_block_padding">PADDING</A> block */

	FLAC__METADATA_TYPE_APPLICATION = 2,
	/**< <A HREF="../format.html#metadata_block_application">APPLICATION</A> block */

	FLAC__METADATA_TYPE_SEEKTABLE = 3,
	/**< <A HREF="../format.html#metadata_block_seektable">SEEKTABLE</A> block */

	FLAC__METADATA_TYPE_VORBIS_COMMENT = 4,
	/**< <A HREF="../format.html#metadata_block_vorbis_comment">VORBISCOMMENT</A> block (a.k.a. FLAC tags) */

	FLAC__METADATA_TYPE_CUESHEET = 5,
	/**< <A HREF="../format.html#metadata_block_cuesheet">CUESHEET</A> block */

	FLAC__METADATA_TYPE_PICTURE = 6,
	/**< <A HREF="../format.html#metadata_block_picture">PICTURE</A> block */

	FLAC__METADATA_TYPE_UNDEFINED = 7
	/**< marker to denote beginning of undefined type range; this number will increase as new metadata types are added */

} FLAC__MetadataType;

/** Maps a FLAC__MetadataType to a C string.
 *
 *  Using a FLAC__MetadataType as the index to this array will
 *  give the string equivalent.  The contents should not be modified.
 */
extern FLAC_API const char * const FLAC__MetadataTypeString[];

/** FLAC STREAMINFO structure.  (c.f. <A HREF="../format.html#metadata_block_streaminfo">format specification</A>)
 */
typedef struct {
	unsigned min_blocksize, max_blocksize;
	unsigned min_framesize, max_framesize;
	unsigned sample_rate;
	unsigned channels;
	unsigned bits_per_sample;
	FLAC__uint64 total_samples;
	FLAC__byte md5sum[16];
} FLAC__StreamMetadata_StreamInfo;

extern FLAC_API const unsigned FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN; /**< == 16 (bits) */
extern FLAC_API const unsigned FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN; /**< == 16 (bits) */
extern FLAC_API const unsigned FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN; /**< == 24 (bits) */
extern FLAC_API const unsigned FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN; /**< == 24 (bits) */
extern FLAC_API const unsigned FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN; /**< == 20 (bits) */
extern FLAC_API const unsigned FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN; /**< == 3 (bits) */
extern FLAC_API const unsigned FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN; /**< == 5 (bits) */
extern FLAC_API const unsigned FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN; /**< == 36 (bits) */
extern FLAC_API const unsigned FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN; /**< == 128 (bits) */

/** The total stream length of the STREAMINFO block in bytes. */
#define FLAC__STREAM_METADATA_STREAMINFO_LENGTH (34u)

/** FLAC PADDING structure.  (c.f. <A HREF="../format.html#metadata_block_padding">format specification</A>)
 */
typedef struct {
	int dummy;
	/**< Conceptually this is an empty struct since we don't store the
	 * padding bytes.  Empty structs are not allowed by some C compilers,
	 * hence the dummy.
	 */
} FLAC__StreamMetadata_Padding;

/** FLAC APPLICATION structure.  (c.f. <A HREF="../format.html#metadata_block_application">format specification</A>)
 */
typedef struct {
	FLAC__byte id[4];
	FLAC__byte *data;
} FLAC__StreamMetadata_Application;

extern FLAC_API const unsigned FLAC__STREAM_METADATA_APPLICATION_ID_LEN; /**< == 32 (bits) */

/** SeekPoint structure used in SEEKTABLE blocks.  (c.f. <A HREF="../format.html#seekpoint">format specification</A>)
 */
typedef struct {
	FLAC__uint64 sample_number;
	/**<  The sample number of the target frame. */

	FLAC__uint64 stream_offset;
	/**< The offset, in bytes, of the target frame with respect to
	 * beginning of the first frame. */

	unsigned frame_samples;
	/**< The number of samples in the target frame. */
} FLAC__StreamMetadata_SeekPoint;

extern FLAC_API const unsigned FLAC__STREAM_METADATA_SEEKPOINT_SAMPLE_NUMBER_LEN; /**< == 64 (bits) */
extern FLAC_API const unsigned FLAC__STREAM_METADATA_SEEKPOINT_STREAM_OFFSET_LEN; /**< == 64 (bits) */
extern FLAC_API const unsigned FLAC__STREAM_METADATA_SEEKPOINT_FRAME_SAMPLES_LEN; /**< == 16 (bits) */

/** The total stream length of a seek point in bytes. */
#define FLAC__STREAM_METADATA_SEEKPOINT_LENGTH (18u)

/** The value used in the \a sample_number field of
 *  FLAC__StreamMetadataSeekPoint used to indicate a placeholder
 *  point (== 0xffffffffffffffff).
 */
extern FLAC_API const FLAC__uint64 FLAC__STREAM_METADATA_SEEKPOINT_PLACEHOLDER;

/** FLAC SEEKTABLE structure.  (c.f. <A HREF="../format.html#metadata_block_seektable">format specification</A>)
 *
 * \note From the format specification:
 * - The seek points must be sorted by ascending sample number.
 * - Each seek point's sample number must be the first sample of the
 *   target frame.
 * - Each seek point's sample number must be unique within the table.
 * - Existence of a SEEKTABLE block implies a correct setting of
 *   total_samples in the stream_info block.
 * - Behavior is undefined when more than one SEEKTABLE block is
 *   present in a stream.
 */
typedef struct {
	unsigned num_points;
	FLAC__StreamMetadata_SeekPoint *points;
} FLAC__StreamMetadata_SeekTable;

/** Vorbis comment entry structure used in VORBIS_COMMENT blocks.  (c.f. <A HREF="../format.html#metadata_block_vorbis_comment">format specification</A>)
 *
 *  For convenience, the APIs maintain a trailing NUL character at the end of
 *  \a entry which is not counted toward \a length, i.e.
 *  \code strlen(entry) == length \endcode
 */
typedef struct {
	FLAC__uint32 length;
	FLAC__byte *entry;
} FLAC__StreamMetadata_VorbisComment_Entry;

extern FLAC_API const unsigned FLAC__STREAM_METADATA_VORBIS_COMMENT_ENTRY_LENGTH_LEN; /**< == 32 (bits) */

/** FLAC VORBIS_COMMENT structure.  (c.f. <A HREF="../format.html#metadata_block_vorbis_comment">format specification</A>)
 */
typedef struct {
	FLAC__StreamMetadata_VorbisComment_Entry vendor_string;
	FLAC__uint32 num_comments;
	FLAC__StreamMetadata_VorbisComment_Entry *comments;
} FLAC__StreamMetadata_VorbisComment;

extern FLAC_API const unsigned FLAC__STREAM_METADATA_VORBIS_COMMENT_NUM_COMMENTS_LEN; /**< == 32 (bits) */

/** FLAC CUESHEET track index structure.  (See the
 * <A HREF="../format.html#cuesheet_track_index">format specification</A> for
 * the full description of each field.)
 */
typedef struct {
	FLAC__uint64 offset;
	/**< Offset in samples, relative to the track offset, of the index
	 * point.
	 */

	FLAC__byte number;
	/**< The index point number. */
} FLAC__StreamMetadata_CueSheet_Index;

extern FLAC_API const unsigned FLAC__STREAM_METADATA_CUESHEET_INDEX_OFFSET_LEN; /**< == 64 (bits) */
extern FLAC_API const unsigned FLAC__STREAM_METADATA_CUESHEET_INDEX_NUMBER_LEN; /**< == 8 (bits) */
extern FLAC_API const unsigned FLAC__STREAM_METADATA_CUESHEET_INDEX_RESERVED_LEN; /**< == 3*8 (bits) */

/** FLAC CUESHEET track structure.  (See the
 * <A HREF="../format.html#cuesheet_track">format specification</A> for
 * the full description of each field.)
 */
typedef struct {
	FLAC__uint64 offset;
	/**< Track offset in samples, relative to the beginning of the FLAC audio stream. */

	FLAC__byte number;
	/**< The track number. */

	char isrc[13];
	/**< Track ISRC.  This is a 12-digit alphanumeric code plus a trailing \c NUL byte */

	unsigned type:1;
	/**< The track type: 0 for audio, 1 for non-audio. */

	unsigned pre_emphasis:1;
	/**< The pre-emphasis flag: 0 for no pre-emphasis, 1 for pre-emphasis. */

	FLAC__byte num_indices;
	/**< The number of track index points. */

	FLAC__StreamMetadata_CueSheet_Index *indices;
	/**< NULL if num_indices == 0, else pointer to array of index points. */

} FLAC__StreamMetadata_CueSheet_Track;

extern FLAC_API const unsigned FLAC__STREAM_METADATA_CUESHEET_TRACK_OFFSET_LEN; /**< == 64 (bits) */
extern FLAC_API const unsigned FLAC__STREAM_METADATA_CUESHEET_TRACK_NUMBER_LEN; /**< == 8 (bits) */
extern FLAC_API const unsigned FLAC__STREAM_METADATA_CUESHEET_TRACK_ISRC_LEN; /**< == 12*8 (bits) */
extern FLAC_API const unsigned FLAC__STREAM_METADATA_CUESHEET_TRACK_TYPE_LEN; /**< == 1 (bit) */
extern FLAC_API const unsigned FLAC__STREAM_METADATA_CUESHEET_TRACK_PRE_EMPHASIS_LEN; /**< == 1 (bit) */
extern FLAC_API const unsigned FLAC__STREAM_METADATA_CUESHEET_TRACK_RESERVED_LEN; /**< == 6+13*8 (bits) */
extern FLAC_API const unsigned FLAC__STREAM_METADATA_CUESHEET_TRACK_NUM_INDICES_LEN; /**< == 8 (bits) */

/** FLAC CUESHEET structure.  (See the
 * <A HREF="../format.html#metadata_block_cuesheet">format specification</A>
 * for the full description of each field.)
 */
typedef struct {
	char media_catalog_number[129];
	/**< Media catalog number, in ASCII printable characters 0x20-0x7e.  In
	 * general, the media catalog number may be 0 to 128 bytes long; any
	 * unused characters should be right-padded with NUL characters.
	 */

	FLAC__uint64 lead_in;
	/**< The number of lead-in samples. */

	FLAC__bool is_cd;
	/**< \c true if CUESHEET corresponds to a Compact Disc, else \c false. */

	unsigned num_tracks;
	/**< The number of tracks. */

	FLAC__StreamMetadata_CueSheet_Track *tracks;
	/**< NULL if num_tracks == 0, else pointer to array of tracks. */

} FLAC__StreamMetadata_CueSheet;

extern FLAC_API const unsigned FLAC__STREAM_METADATA_CUESHEET_MEDIA_CATALOG_NUMBER_LEN; /**< == 128*8 (bits) */
extern FLAC_API const unsigned FLAC__STREAM_METADATA_CUESHEET_LEAD_IN_LEN; /**< == 64 (bits) */
extern FLAC_API const unsigned FLAC__STREAM_METADATA_CUESHEET_IS_CD_LEN; /**< == 1 (bit) */
extern FLAC_API const unsigned FLAC__STREAM_METADATA_CUESHEET_RESERVED_LEN; /**< == 7+258*8 (bits) */
extern FLAC_API const unsigned FLAC__STREAM_METADATA_CUESHEET_NUM_TRACKS_LEN; /**< == 8 (bits) */

/** An enumeration of the PICTURE types (see FLAC__StreamMetadataPicture and id3 v2.4 APIC tag). */
typedef enum {
	FLAC__STREAM_METADATA_PICTURE_TYPE_OTHER = 0, /**< Other */
	FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON_STANDARD = 1, /**< 32x32 pixels 'file icon' (PNG only) */
	FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON = 2, /**< Other file icon */
	FLAC__STREAM_METADATA_PICTURE_TYPE_FRONT_COVER = 3, /**< Cover (front) */
	FLAC__STREAM_METADATA_PICTURE_TYPE_BACK_COVER = 4, /**< Cover (back) */
	FLAC__STREAM_METADATA_PICTURE_TYPE_LEAFLET_PAGE = 5, /**< Leaflet page */
	FLAC__STREAM_METADATA_PICTURE_TYPE_MEDIA = 6, /**< Media (e.g. label side of CD) */
	FLAC__STREAM_METADATA_PICTURE_TYPE_LEAD_ARTIST = 7, /**< Lead artist/lead performer/soloist */
	FLAC__STREAM_METADATA_PICTURE_TYPE_ARTIST = 8, /**< Artist/performer */
	FLAC__STREAM_METADATA_PICTURE_TYPE_CONDUCTOR = 9, /**< Conductor */
	FLAC__STREAM_METADATA_PICTURE_TYPE_BAND = 10, /**< Band/Orchestra */
	FLAC__STREAM_METADATA_PICTURE_TYPE_COMPOSER = 11, /**< Composer */
	FLAC__STREAM_METADATA_PICTURE_TYPE_LYRICIST = 12, /**< Lyricist/text writer */
	FLAC__STREAM_METADATA_PICTURE_TYPE_RECORDING_LOCATION = 13, /**< Recording Location */
	FLAC__STREAM_METADATA_PICTURE_TYPE_DURING_RECORDING = 14, /**< During recording */
	FLAC__STREAM_METADATA_PICTURE_TYPE_DURING_PERFORMANCE = 15, /**< During performance */
	FLAC__STREAM_METADATA_PICTURE_TYPE_VIDEO_SCREEN_CAPTURE = 16, /**< Movie/video screen capture */
	FLAC__STREAM_METADATA_PICTURE_TYPE_FISH = 17, /**< A bright coloured fish */
	FLAC__STREAM_METADATA_PICTURE_TYPE_ILLUSTRATION = 18, /**< Illustration */
	FLAC__STREAM_METADATA_PICTURE_TYPE_BAND_LOGOTYPE = 19, /**< Band/artist logotype */
	FLAC__STREAM_METADATA_PICTURE_TYPE_PUBLISHER_LOGOTYPE = 20, /**< Publisher/Studio logotype */
	FLAC__STREAM_METADATA_PICTURE_TYPE_UNDEFINED
} FLAC__StreamMetadata_Picture_Type;

/** Maps a FLAC__StreamMetadata_Picture_Type to a C string.
 *
 *  Using a FLAC__StreamMetadata_Picture_Type as the index to this array
 *  will give the string equivalent.  The contents should not be
 *  modified.
 */
extern FLAC_API const char * const FLAC__StreamMetadata_Picture_TypeString[];

/** FLAC PICTURE structure.  (See the
 * <A HREF="../format.html#metadata_block_picture">format specification</A>
 * for the full description of each field.)
 */
typedef struct {
	FLAC__StreamMetadata_Picture_Type type;
	/**< The kind of picture stored. */

	char *mime_type;
	/**< Picture data's MIME type, in ASCII printable characters
	 * 0x20-0x7e, NUL terminated.  For best compatibility with players,
	 * use picture data of MIME type \c image/jpeg or \c image/png.  A
	 * MIME type of '-->' is also allowed, in which case the picture
	 * data should be a complete URL.  In file storage, the MIME type is
	 * stored as a 32-bit length followed by the ASCII string with no NUL
	 * terminator, but is converted to a plain C string in this structure
	 * for convenience.
	 */

	FLAC__byte *description;
	/**< Picture's description in UTF-8, NUL terminated.  In file storage,
	 * the description is stored as a 32-bit length followed by the UTF-8
	 * string with no NUL terminator, but is converted to a plain C string
	 * in this structure for convenience.
	 */

	FLAC__uint32 width;
	/**< Picture's width in pixels. */

	FLAC__uint32 height;
	/**< Picture's height in pixels. */

	FLAC__uint32 depth;
	/**< Picture's color depth in bits-per-pixel. */

	FLAC__uint32 colors;
	/**< For indexed palettes (like GIF), picture's number of colors (the
	 * number of palette entries), or \c 0 for non-indexed (i.e. 2^depth).
	 */

	FLAC__uint32 data_length;
	/**< Length of binary picture data in bytes. */

	FLAC__byte *data;
	/**< Binary picture data. */

} FLAC__StreamMetadata_Picture;

extern FLAC_API const unsigned FLAC__STREAM_METADATA_PICTURE_TYPE_LEN; /**< == 32 (bits) */
extern FLAC_API const unsigned FLAC__STREAM_METADATA_PICTURE_MIME_TYPE_LENGTH_LEN; /**< == 32 (bits) */
extern FLAC_API const unsigned FLAC__STREAM_METADATA_PICTURE_DESCRIPTION_LENGTH_LEN; /**< == 32 (bits) */
extern FLAC_API const unsigned FLAC__STREAM_METADATA_PICTURE_WIDTH_LEN; /**< == 32 (bits) */
extern FLAC_API const unsigned FLAC__STREAM_METADATA_PICTURE_HEIGHT_LEN; /**< == 32 (bits) */
extern FLAC_API const unsigned FLAC__STREAM_METADATA_PICTURE_DEPTH_LEN; /**< == 32 (bits) */
extern FLAC_API const unsigned FLAC__STREAM_METADATA_PICTURE_COLORS_LEN; /**< == 32 (bits) */
extern FLAC_API const unsigned FLAC__STREAM_METADATA_PICTURE_DATA_LENGTH_LEN; /**< == 32 (bits) */

/** Structure that is used when a metadata block of unknown type is loaded.
 *  The contents are opaque.  The structure is used only internally to
 *  correctly handle unknown metadata.
 */
typedef struct {
	FLAC__byte *data;
} FLAC__StreamMetadata_Unknown;

/** FLAC metadata block structure.  (c.f. <A HREF="../format.html#metadata_block">format specification</A>)
 */
typedef struct {
	FLAC__MetadataType type;
	/**< The type of the metadata block; used determine which member of the
	 * \a data union to dereference.  If type >= FLAC__METADATA_TYPE_UNDEFINED
	 * then \a data.unknown must be used. */

	FLAC__bool is_last;
	/**< \c true if this metadata block is the last, else \a false */

	unsigned length;
	/**< Length, in bytes, of the block data as it appears in the stream. */

	union {
		FLAC__StreamMetadata_StreamInfo stream_info;
		FLAC__StreamMetadata_Padding padding;
		FLAC__StreamMetadata_Application application;
		FLAC__StreamMetadata_SeekTable seek_table;
		FLAC__StreamMetadata_VorbisComment vorbis_comment;
		FLAC__StreamMetadata_CueSheet cue_sheet;
		FLAC__StreamMetadata_Picture picture;
		FLAC__StreamMetadata_Unknown unknown;
	} data;
	/**< Polymorphic block data; use the \a type value to determine which
	 * to use. */
} FLAC__StreamMetadata;

extern FLAC_API const unsigned FLAC__STREAM_METADATA_IS_LAST_LEN; /**< == 1 (bit) */
extern FLAC_API const unsigned FLAC__STREAM_METADATA_TYPE_LEN; /**< == 7 (bits) */
extern FLAC_API const unsigned FLAC__STREAM_METADATA_LENGTH_LEN; /**< == 24 (bits) */

/** The total stream length of a metadata block header in bytes. */
#define FLAC__STREAM_METADATA_HEADER_LENGTH (4u)

/*****************************************************************************/

/*****************************************************************************
 *
 * Utility functions
 *
 *****************************************************************************/

/** Tests that a sample rate is valid for FLAC.
 *
 * \param sample_rate  The sample rate to test for compliance.
 * \retval FLAC__bool
 *    \c true if the given sample rate conforms to the specification, else
 *    \c false.
 */
FLAC_API FLAC__bool FLAC__format_sample_rate_is_valid(unsigned sample_rate);

/** Tests that a sample rate is valid for the FLAC subset.  The subset rules
 *  for valid sample rates are slightly more complex since the rate has to
 *  be expressible completely in the frame header.
 *
 * \param sample_rate  The sample rate to test for compliance.
 * \retval FLAC__bool
 *    \c true if the given sample rate conforms to the specification for the
 *    subset, else \c false.
 */
FLAC_API FLAC__bool FLAC__format_sample_rate_is_subset(unsigned sample_rate);

/** Check a Vorbis comment entry name to see if it conforms to the Vorbis
 *  comment specification.
 *
 *  Vorbis comment names must be composed only of characters from
 *  [0x20-0x3C,0x3E-0x7D].
 *
 * \param name       A NUL-terminated string to be checked.
 * \assert
 *    \code name != NULL \endcode
 * \retval FLAC__bool
 *    \c false if entry name is illegal, else \c true.
 */
FLAC_API FLAC__bool FLAC__format_vorbiscomment_entry_name_is_legal(const char *name);

/** Check a Vorbis comment entry value to see if it conforms to the Vorbis
 *  comment specification.
 *
 *  Vorbis comment values must be valid UTF-8 sequences.
 *
 * \param value      A string to be checked.
 * \param length     A the length of \a value in bytes.  May be
 *                   \c (unsigned)(-1) to indicate that \a value is a plain
 *                   UTF-8 NUL-terminated string.
 * \assert
 *    \code value != NULL \endcode
 * \retval FLAC__bool
 *    \c false if entry name is illegal, else \c true.
 */
FLAC_API FLAC__bool FLAC__format_vorbiscomment_entry_value_is_legal(const FLAC__byte *value, unsigned length);

/** Check a Vorbis comment entry to see if it conforms to the Vorbis
 *  comment specification.
 *
 *  Vorbis comment entries must be of the form 'name=value', and 'name' and
 *  'value' must be legal according to
 *  FLAC__format_vorbiscomment_entry_name_is_legal() and
 *  FLAC__format_vorbiscomment_entry_value_is_legal() respectively.
 *
 * \param entry      An entry to be checked.
 * \param length     The length of \a entry in bytes.
 * \assert
 *    \code value != NULL \endcode
 * \retval FLAC__bool
 *    \c false if entry name is illegal, else \c true.
 */
FLAC_API FLAC__bool FLAC__format_vorbiscomment_entry_is_legal(const FLAC__byte *entry, unsigned length);

/** Check a seek table to see if it conforms to the FLAC specification.
 *  See the format specification for limits on the contents of the
 *  seek table.
 *
 * \param seek_table  A pointer to a seek table to be checked.
 * \assert
 *    \code seek_table != NULL \endcode
 * \retval FLAC__bool
 *    \c false if seek table is illegal, else \c true.
 */
FLAC_API FLAC__bool FLAC__format_seektable_is_legal(const FLAC__StreamMetadata_SeekTable *seek_table);

/** Sort a seek table's seek points according to the format specification.
 *  This includes a "unique-ification" step to remove duplicates, i.e.
 *  seek points with identical \a sample_number values.  Duplicate seek
 *  points are converted into placeholder points and sorted to the end of
 *  the table.
 *
 * \param seek_table  A pointer to a seek table to be sorted.
 * \assert
 *    \code seek_table != NULL \endcode
 * \retval unsigned
 *    The number of duplicate seek points converted into placeholders.
 */
FLAC_API unsigned FLAC__format_seektable_sort(FLAC__StreamMetadata_SeekTable *seek_table);

/** Check a cue sheet to see if it conforms to the FLAC specification.
 *  See the format specification for limits on the contents of the
 *  cue sheet.
 *
 * \param cue_sheet  A pointer to an existing cue sheet to be checked.
 * \param check_cd_da_subset  If \c true, check CUESHEET against more
 *                   stringent requirements for a CD-DA (audio) disc.
 * \param violation  Address of a pointer to a string.  If there is a
 *                   violation, a pointer to a string explanation of the
 *                   violation will be returned here. \a violation may be
 *                   \c NULL if you don't need the returned string.  Do not
 *                   free the returned string; it will always point to static
 *                   data.
 * \assert
 *    \code cue_sheet != NULL \endcode
 * \retval FLAC__bool
 *    \c false if cue sheet is illegal, else \c true.
 */
FLAC_API FLAC__bool FLAC__format_cuesheet_is_legal(const FLAC__StreamMetadata_CueSheet *cue_sheet, FLAC__bool check_cd_da_subset, const char **violation);

/** Check picture data to see if it conforms to the FLAC specification.
 *  See the format specification for limits on the contents of the
 *  PICTURE block.
 *
 * \param picture    A pointer to existing picture data to be checked.
 * \param violation  Address of a pointer to a string.  If there is a
 *                   violation, a pointer to a string explanation of the
 *                   violation will be returned here. \a violation may be
 *                   \c NULL if you don't need the returned string.  Do not
 *                   free the returned string; it will always point to static
 *                   data.
 * \assert
 *    \code picture != NULL \endcode
 * \retval FLAC__bool
 *    \c false if picture data is illegal, else \c true.
 */
FLAC_API FLAC__bool FLAC__format_picture_is_legal(const FLAC__StreamMetadata_Picture *picture, const char **violation);

/* \} */

#ifdef __cplusplus
}
#endif

#endif

/*** End of inlined file: format.h ***/


/*** Start of inlined file: metadata.h ***/
#ifndef FLAC__METADATA_H
#define FLAC__METADATA_H

#include <sys/types.h> /* for off_t */

/* --------------------------------------------------------------------
   (For an example of how all these routines are used, see the source
   code for the unit tests in src/test_libFLAC/metadata_*.c, or
   metaflac in src/metaflac/)
   ------------------------------------------------------------------*/

/** \file include/FLAC/metadata.h
 *
 *  \brief
 *  This module provides functions for creating and manipulating FLAC
 *  metadata blocks in memory, and three progressively more powerful
 *  interfaces for traversing and editing metadata in FLAC files.
 *
 *  See the detailed documentation for each interface in the
 *  \link flac_metadata metadata \endlink module.
 */

/** \defgroup flac_metadata FLAC/metadata.h: metadata interfaces
 *  \ingroup flac
 *
 *  \brief
 *  This module provides functions for creating and manipulating FLAC
 *  metadata blocks in memory, and three progressively more powerful
 *  interfaces for traversing and editing metadata in native FLAC files.
 *  Note that currently only the Chain interface (level 2) supports Ogg
 *  FLAC files, and it is read-only i.e. no writing back changed
 *  metadata to file.
 *
 *  There are three metadata interfaces of increasing complexity:
 *
 *  Level 0:
 *  Read-only access to the STREAMINFO, VORBIS_COMMENT, CUESHEET, and
 *  PICTURE blocks.
 *
 *  Level 1:
 *  Read-write access to all metadata blocks.  This level is write-
 *  efficient in most cases (more on this below), and uses less memory
 *  than level 2.
 *
 *  Level 2:
 *  Read-write access to all metadata blocks.  This level is write-
 *  efficient in all cases, but uses more memory since all metadata for
 *  the whole file is read into memory and manipulated before writing
 *  out again.
 *
 *  What do we mean by efficient?  Since FLAC metadata appears at the
 *  beginning of the file, when writing metadata back to a FLAC file
 *  it is possible to grow or shrink the metadata such that the entire
 *  file must be rewritten.  However, if the size remains the same during
 *  changes or PADDING blocks are utilized, only the metadata needs to be
 *  overwritten, which is much faster.
 *
 *  Efficient means the whole file is rewritten at most one time, and only
 *  when necessary.  Level 1 is not efficient only in the case that you
 *  cause more than one metadata block to grow or shrink beyond what can
 *  be accomodated by padding.  In this case you should probably use level
 *  2, which allows you to edit all the metadata for a file in memory and
 *  write it out all at once.
 *
 *  All levels know how to skip over and not disturb an ID3v2 tag at the
 *  front of the file.
 *
 *  All levels access files via their filenames.  In addition, level 2
 *  has additional alternative read and write functions that take an I/O
 *  handle and callbacks, for situations where access by filename is not
 *  possible.
 *
 *  In addition to the three interfaces, this module defines functions for
 *  creating and manipulating various metadata objects in memory.  As we see
 *  from the Format module, FLAC metadata blocks in memory are very primitive
 *  structures for storing information in an efficient way.  Reading
 *  information from the structures is easy but creating or modifying them
 *  directly is more complex.  The metadata object routines here facilitate
 *  this by taking care of the consistency and memory management drudgery.
 *
 *  Unless you will be using the level 1 or 2 interfaces to modify existing
 *  metadata however, you will not probably not need these.
 *
 *  From a dependency standpoint, none of the encoders or decoders require
 *  the metadata module.  This is so that embedded users can strip out the
 *  metadata module from libFLAC to reduce the size and complexity.
 */

#ifdef __cplusplus
extern "C" {
#endif

/** \defgroup flac_metadata_level0 FLAC/metadata.h: metadata level 0 interface
 *  \ingroup flac_metadata
 *
 *  \brief
 *  The level 0 interface consists of individual routines to read the
 *  STREAMINFO, VORBIS_COMMENT, CUESHEET, and PICTURE blocks, requiring
 *  only a filename.
 *
 *  They try to skip any ID3v2 tag at the head of the file.
 *
 * \{
 */

/** Read the STREAMINFO metadata block of the given FLAC file.  This function
 *  will try to skip any ID3v2 tag at the head of the file.
 *
 * \param filename    The path to the FLAC file to read.
 * \param streaminfo  A pointer to space for the STREAMINFO block.  Since
 *                    FLAC__StreamMetadata is a simple structure with no
 *                    memory allocation involved, you pass the address of
 *                    an existing structure.  It need not be initialized.
 * \assert
 *    \code filename != NULL \endcode
 *    \code streaminfo != NULL \endcode
 * \retval FLAC__bool
 *    \c true if a valid STREAMINFO block was read from \a filename.  Returns
 *    \c false if there was a memory allocation error, a file decoder error,
 *    or the file contained no STREAMINFO block.  (A memory allocation error
 *    is possible because this function must set up a file decoder.)
 */
FLAC_API FLAC__bool FLAC__metadata_get_streaminfo(const char *filename, FLAC__StreamMetadata *streaminfo);

/** Read the VORBIS_COMMENT metadata block of the given FLAC file.  This
 *  function will try to skip any ID3v2 tag at the head of the file.
 *
 * \param filename    The path to the FLAC file to read.
 * \param tags        The address where the returned pointer will be
 *                    stored.  The \a tags object must be deleted by
 *                    the caller using FLAC__metadata_object_delete().
 * \assert
 *    \code filename != NULL \endcode
 *    \code tags != NULL \endcode
 * \retval FLAC__bool
 *    \c true if a valid VORBIS_COMMENT block was read from \a filename,
 *    and \a *tags will be set to the address of the metadata structure.
 *    Returns \c false if there was a memory allocation error, a file
 *    decoder error, or the file contained no VORBIS_COMMENT block, and
 *    \a *tags will be set to \c NULL.
 */
FLAC_API FLAC__bool FLAC__metadata_get_tags(const char *filename, FLAC__StreamMetadata **tags);

/** Read the CUESHEET metadata block of the given FLAC file.  This
 *  function will try to skip any ID3v2 tag at the head of the file.
 *
 * \param filename    The path to the FLAC file to read.
 * \param cuesheet    The address where the returned pointer will be
 *                    stored.  The \a cuesheet object must be deleted by
 *                    the caller using FLAC__metadata_object_delete().
 * \assert
 *    \code filename != NULL \endcode
 *    \code cuesheet != NULL \endcode
 * \retval FLAC__bool
 *    \c true if a valid CUESHEET block was read from \a filename,
 *    and \a *cuesheet will be set to the address of the metadata
 *    structure.  Returns \c false if there was a memory allocation
 *    error, a file decoder error, or the file contained no CUESHEET
 *    block, and \a *cuesheet will be set to \c NULL.
 */
FLAC_API FLAC__bool FLAC__metadata_get_cuesheet(const char *filename, FLAC__StreamMetadata **cuesheet);

/** Read a PICTURE metadata block of the given FLAC file.  This
 *  function will try to skip any ID3v2 tag at the head of the file.
 *  Since there can be more than one PICTURE block in a file, this
 *  function takes a number of parameters that act as constraints to
 *  the search.  The PICTURE block with the largest area matching all
 *  the constraints will be returned, or \a *picture will be set to
 *  \c NULL if there was no such block.
 *
 * \param filename    The path to the FLAC file to read.
 * \param picture     The address where the returned pointer will be
 *                    stored.  The \a picture object must be deleted by
 *                    the caller using FLAC__metadata_object_delete().
 * \param type        The desired picture type.  Use \c -1 to mean
 *                    "any type".
 * \param mime_type   The desired MIME type, e.g. "image/jpeg".  The
 *                    string will be matched exactly.  Use \c NULL to
 *                    mean "any MIME type".
 * \param description The desired description.  The string will be
 *                    matched exactly.  Use \c NULL to mean "any
 *                    description".
 * \param max_width   The maximum width in pixels desired.  Use
 *                    \c (unsigned)(-1) to mean "any width".
 * \param max_height  The maximum height in pixels desired.  Use
 *                    \c (unsigned)(-1) to mean "any height".
 * \param max_depth   The maximum color depth in bits-per-pixel desired.
 *                    Use \c (unsigned)(-1) to mean "any depth".
 * \param max_colors  The maximum number of colors desired.  Use
 *                    \c (unsigned)(-1) to mean "any number of colors".
 * \assert
 *    \code filename != NULL \endcode
 *    \code picture != NULL \endcode
 * \retval FLAC__bool
 *    \c true if a valid PICTURE block was read from \a filename,
 *    and \a *picture will be set to the address of the metadata
 *    structure.  Returns \c false if there was a memory allocation
 *    error, a file decoder error, or the file contained no PICTURE
 *    block, and \a *picture will be set to \c NULL.
 */
FLAC_API FLAC__bool FLAC__metadata_get_picture(const char *filename, FLAC__StreamMetadata **picture, FLAC__StreamMetadata_Picture_Type type, const char *mime_type, const FLAC__byte *description, unsigned max_width, unsigned max_height, unsigned max_depth, unsigned max_colors);

/* \} */

/** \defgroup flac_metadata_level1 FLAC/metadata.h: metadata level 1 interface
 *  \ingroup flac_metadata
 *
 * \brief
 * The level 1 interface provides read-write access to FLAC file metadata and
 * operates directly on the FLAC file.
 *
 * The general usage of this interface is:
 *
 * - Create an iterator using FLAC__metadata_simple_iterator_new()
 * - Attach it to a file using FLAC__metadata_simple_iterator_init() and check
 *   the exit code.  Call FLAC__metadata_simple_iterator_is_writable() to
 *   see if the file is writable, or only read access is allowed.
 * - Use FLAC__metadata_simple_iterator_next() and
 *   FLAC__metadata_simple_iterator_prev() to traverse the blocks.
 *   This is does not read the actual blocks themselves.
 *   FLAC__metadata_simple_iterator_next() is relatively fast.
 *   FLAC__metadata_simple_iterator_prev() is slower since it needs to search
 *   forward from the front of the file.
 * - Use FLAC__metadata_simple_iterator_get_block_type() or
 *   FLAC__metadata_simple_iterator_get_block() to access the actual data at
 *   the current iterator position.  The returned object is yours to modify
 *   and free.
 * - Use FLAC__metadata_simple_iterator_set_block() to write a modified block
 *   back.  You must have write permission to the original file.  Make sure to
 *   read the whole comment to FLAC__metadata_simple_iterator_set_block()
 *   below.
 * - Use FLAC__metadata_simple_iterator_insert_block_after() to add new blocks.
 *   Use the object creation functions from
 *   \link flac_metadata_object here \endlink to generate new objects.
 * - Use FLAC__metadata_simple_iterator_delete_block() to remove the block
 *   currently referred to by the iterator, or replace it with padding.
 * - Destroy the iterator with FLAC__metadata_simple_iterator_delete() when
 *   finished.
 *
 * \note
 * The FLAC file remains open the whole time between
 * FLAC__metadata_simple_iterator_init() and
 * FLAC__metadata_simple_iterator_delete(), so make sure you are not altering
 * the file during this time.
 *
 * \note
 * Do not modify the \a is_last, \a length, or \a type fields of returned
 * FLAC__StreamMetadata objects.  These are managed automatically.
 *
 * \note
 * If any of the modification functions
 * (FLAC__metadata_simple_iterator_set_block(),
 * FLAC__metadata_simple_iterator_delete_block(),
 * FLAC__metadata_simple_iterator_insert_block_after(), etc.) return \c false,
 * you should delete the iterator as it may no longer be valid.
 *
 * \{
 */

struct FLAC__Metadata_SimpleIterator;
/** The opaque structure definition for the level 1 iterator type.
 *  See the
 *  \link flac_metadata_level1 metadata level 1 module \endlink
 *  for a detailed description.
 */
typedef struct FLAC__Metadata_SimpleIterator FLAC__Metadata_SimpleIterator;

/** Status type for FLAC__Metadata_SimpleIterator.
 *
 *  The iterator's current status can be obtained by calling FLAC__metadata_simple_iterator_status().
 */
typedef enum {

	FLAC__METADATA_SIMPLE_ITERATOR_STATUS_OK = 0,
	/**< The iterator is in the normal OK state */

	FLAC__METADATA_SIMPLE_ITERATOR_STATUS_ILLEGAL_INPUT,
	/**< The data passed into a function violated the function's usage criteria */

	FLAC__METADATA_SIMPLE_ITERATOR_STATUS_ERROR_OPENING_FILE,
	/**< The iterator could not open the target file */

	FLAC__METADATA_SIMPLE_ITERATOR_STATUS_NOT_A_FLAC_FILE,
	/**< The iterator could not find the FLAC signature at the start of the file */

	FLAC__METADATA_SIMPLE_ITERATOR_STATUS_NOT_WRITABLE,
	/**< The iterator tried to write to a file that was not writable */

	FLAC__METADATA_SIMPLE_ITERATOR_STATUS_BAD_METADATA,
	/**< The iterator encountered input that does not conform to the FLAC metadata specification */

	FLAC__METADATA_SIMPLE_ITERATOR_STATUS_READ_ERROR,
	/**< The iterator encountered an error while reading the FLAC file */

	FLAC__METADATA_SIMPLE_ITERATOR_STATUS_SEEK_ERROR,
	/**< The iterator encountered an error while seeking in the FLAC file */

	FLAC__METADATA_SIMPLE_ITERATOR_STATUS_WRITE_ERROR,
	/**< The iterator encountered an error while writing the FLAC file */

	FLAC__METADATA_SIMPLE_ITERATOR_STATUS_RENAME_ERROR,
	/**< The iterator encountered an error renaming the FLAC file */

	FLAC__METADATA_SIMPLE_ITERATOR_STATUS_UNLINK_ERROR,
	/**< The iterator encountered an error removing the temporary file */

	FLAC__METADATA_SIMPLE_ITERATOR_STATUS_MEMORY_ALLOCATION_ERROR,
	/**< Memory allocation failed */

	FLAC__METADATA_SIMPLE_ITERATOR_STATUS_INTERNAL_ERROR
	/**< The caller violated an assertion or an unexpected error occurred */

} FLAC__Metadata_SimpleIteratorStatus;

/** Maps a FLAC__Metadata_SimpleIteratorStatus to a C string.
 *
 *  Using a FLAC__Metadata_SimpleIteratorStatus as the index to this array
 *  will give the string equivalent.  The contents should not be modified.
 */
extern FLAC_API const char * const FLAC__Metadata_SimpleIteratorStatusString[];

/** Create a new iterator instance.
 *
 * \retval FLAC__Metadata_SimpleIterator*
 *    \c NULL if there was an error allocating memory, else the new instance.
 */
FLAC_API FLAC__Metadata_SimpleIterator *FLAC__metadata_simple_iterator_new(void);

/** Free an iterator instance.  Deletes the object pointed to by \a iterator.
 *
 * \param iterator  A pointer to an existing iterator.
 * \assert
 *    \code iterator != NULL \endcode
 */
FLAC_API void FLAC__metadata_simple_iterator_delete(FLAC__Metadata_SimpleIterator *iterator);

/** Get the current status of the iterator.  Call this after a function
 *  returns \c false to get the reason for the error.  Also resets the status
 *  to FLAC__METADATA_SIMPLE_ITERATOR_STATUS_OK.
 *
 * \param iterator  A pointer to an existing iterator.
 * \assert
 *    \code iterator != NULL \endcode
 * \retval FLAC__Metadata_SimpleIteratorStatus
 *    The current status of the iterator.
 */
FLAC_API FLAC__Metadata_SimpleIteratorStatus FLAC__metadata_simple_iterator_status(FLAC__Metadata_SimpleIterator *iterator);

/** Initialize the iterator to point to the first metadata block in the
 *  given FLAC file.
 *
 * \param iterator             A pointer to an existing iterator.
 * \param filename             The path to the FLAC file.
 * \param read_only            If \c true, the FLAC file will be opened
 *                             in read-only mode; if \c false, the FLAC
 *                             file will be opened for edit even if no
 *                             edits are performed.
 * \param preserve_file_stats  If \c true, the owner and modification
 *                             time will be preserved even if the FLAC
 *                             file is written to.
 * \assert
 *    \code iterator != NULL \endcode
 *    \code filename != NULL \endcode
 * \retval FLAC__bool
 *    \c false if a memory allocation error occurs, the file can't be
 *    opened, or another error occurs, else \c true.
 */
FLAC_API FLAC__bool FLAC__metadata_simple_iterator_init(FLAC__Metadata_SimpleIterator *iterator, const char *filename, FLAC__bool read_only, FLAC__bool preserve_file_stats);

/** Returns \c true if the FLAC file is writable.  If \c false, calls to
 *  FLAC__metadata_simple_iterator_set_block() and
 *  FLAC__metadata_simple_iterator_insert_block_after() will fail.
 *
 * \param iterator             A pointer to an existing iterator.
 * \assert
 *    \code iterator != NULL \endcode
 * \retval FLAC__bool
 *    See above.
 */
FLAC_API FLAC__bool FLAC__metadata_simple_iterator_is_writable(const FLAC__Metadata_SimpleIterator *iterator);

/** Moves the iterator forward one metadata block, returning \c false if
 *  already at the end.
 *
 * \param iterator  A pointer to an existing initialized iterator.
 * \assert
 *    \code iterator != NULL \endcode
 *    \a iterator has been successfully initialized with
 *    FLAC__metadata_simple_iterator_init()
 * \retval FLAC__bool
 *    \c false if already at the last metadata block of the chain, else
 *    \c true.
 */
FLAC_API FLAC__bool FLAC__metadata_simple_iterator_next(FLAC__Metadata_SimpleIterator *iterator);

/** Moves the iterator backward one metadata block, returning \c false if
 *  already at the beginning.
 *
 * \param iterator  A pointer to an existing initialized iterator.
 * \assert
 *    \code iterator != NULL \endcode
 *    \a iterator has been successfully initialized with
 *    FLAC__metadata_simple_iterator_init()
 * \retval FLAC__bool
 *    \c false if already at the first metadata block of the chain, else
 *    \c true.
 */
FLAC_API FLAC__bool FLAC__metadata_simple_iterator_prev(FLAC__Metadata_SimpleIterator *iterator);

/** Returns a flag telling if the current metadata block is the last.
 *
 * \param iterator  A pointer to an existing initialized iterator.
 * \assert
 *    \code iterator != NULL \endcode
 *    \a iterator has been successfully initialized with
 *    FLAC__metadata_simple_iterator_init()
 * \retval FLAC__bool
 *    \c true if the current metadata block is the last in the file,
 *    else \c false.
 */
FLAC_API FLAC__bool FLAC__metadata_simple_iterator_is_last(const FLAC__Metadata_SimpleIterator *iterator);

/** Get the offset of the metadata block at the current position.  This
 *  avoids reading the actual block data which can save time for large
 *  blocks.
 *
 * \param iterator  A pointer to an existing initialized iterator.
 * \assert
 *    \code iterator != NULL \endcode
 *    \a iterator has been successfully initialized with
 *    FLAC__metadata_simple_iterator_init()
 * \retval off_t
 *    The offset of the metadata block at the current iterator position.
 *    This is the byte offset relative to the beginning of the file of
 *    the current metadata block's header.
 */
FLAC_API off_t FLAC__metadata_simple_iterator_get_block_offset(const FLAC__Metadata_SimpleIterator *iterator);

/** Get the type of the metadata block at the current position.  This
 *  avoids reading the actual block data which can save time for large
 *  blocks.
 *
 * \param iterator  A pointer to an existing initialized iterator.
 * \assert
 *    \code iterator != NULL \endcode
 *    \a iterator has been successfully initialized with
 *    FLAC__metadata_simple_iterator_init()
 * \retval FLAC__MetadataType
 *    The type of the metadata block at the current iterator position.
 */
FLAC_API FLAC__MetadataType FLAC__metadata_simple_iterator_get_block_type(const FLAC__Metadata_SimpleIterator *iterator);

/** Get the length of the metadata block at the current position.  This
 *  avoids reading the actual block data which can save time for large
 *  blocks.
 *
 * \param iterator  A pointer to an existing initialized iterator.
 * \assert
 *    \code iterator != NULL \endcode
 *    \a iterator has been successfully initialized with
 *    FLAC__metadata_simple_iterator_init()
 * \retval unsigned
 *    The length of the metadata block at the current iterator position.
 *    The is same length as that in the
 *    <a href="http://flac.sourceforge.net/format.html#metadata_block_header">metadata block header</a>,
 *    i.e. the length of the metadata body that follows the header.
 */
FLAC_API unsigned FLAC__metadata_simple_iterator_get_block_length(const FLAC__Metadata_SimpleIterator *iterator);

/** Get the application ID of the \c APPLICATION block at the current
 *  position.  This avoids reading the actual block data which can save
 *  time for large blocks.
 *
 * \param iterator  A pointer to an existing initialized iterator.
 * \param id        A pointer to a buffer of at least \c 4 bytes where
 *                  the ID will be stored.
 * \assert
 *    \code iterator != NULL \endcode
 *    \code id != NULL \endcode
 *    \a iterator has been successfully initialized with
 *    FLAC__metadata_simple_iterator_init()
 * \retval FLAC__bool
 *    \c true if the ID was successfully read, else \c false, in which
 *    case you should check FLAC__metadata_simple_iterator_status() to
 *    find out why.  If the status is
 *    \c FLAC__METADATA_SIMPLE_ITERATOR_STATUS_ILLEGAL_INPUT, then the
 *    current metadata block is not an \c APPLICATION block.  Otherwise
 *    if the status is
 *    \c FLAC__METADATA_SIMPLE_ITERATOR_STATUS_READ_ERROR or
 *    \c FLAC__METADATA_SIMPLE_ITERATOR_STATUS_SEEK_ERROR, an I/O error
 *    occurred and the iterator can no longer be used.
 */
FLAC_API FLAC__bool FLAC__metadata_simple_iterator_get_application_id(FLAC__Metadata_SimpleIterator *iterator, FLAC__byte *id);

/** Get the metadata block at the current position.  You can modify the
 *  block but must use FLAC__metadata_simple_iterator_set_block() to
 *  write it back to the FLAC file.
 *
 *  You must call FLAC__metadata_object_delete() on the returned object
 *  when you are finished with it.
 *
 * \param iterator  A pointer to an existing initialized iterator.
 * \assert
 *    \code iterator != NULL \endcode
 *    \a iterator has been successfully initialized with
 *    FLAC__metadata_simple_iterator_init()
 * \retval FLAC__StreamMetadata*
 *    The current metadata block, or \c NULL if there was a memory
 *    allocation error.
 */
FLAC_API FLAC__StreamMetadata *FLAC__metadata_simple_iterator_get_block(FLAC__Metadata_SimpleIterator *iterator);

/** Write a block back to the FLAC file.  This function tries to be
 *  as efficient as possible; how the block is actually written is
 *  shown by the following:
 *
 *  Existing block is a STREAMINFO block and the new block is a
 *  STREAMINFO block: the new block is written in place.  Make sure
 *  you know what you're doing when changing the values of a
 *  STREAMINFO block.
 *
 *  Existing block is a STREAMINFO block and the new block is a
 *  not a STREAMINFO block: this is an error since the first block
 *  must be a STREAMINFO block.  Returns \c false without altering the
 *  file.
 *
 *  Existing block is not a STREAMINFO block and the new block is a
 *  STREAMINFO block: this is an error since there may be only one
 *  STREAMINFO block.  Returns \c false without altering the file.
 *
 *  Existing block and new block are the same length: the existing
 *  block will be replaced by the new block, written in place.
 *
 *  Existing block is longer than new block: if use_padding is \c true,
 *  the existing block will be overwritten in place with the new
 *  block followed by a PADDING block, if possible, to make the total
 *  size the same as the existing block.  Remember that a padding
 *  block requires at least four bytes so if the difference in size
 *  between the new block and existing block is less than that, the
 *  entire file will have to be rewritten, using the new block's
 *  exact size.  If use_padding is \c false, the entire file will be
 *  rewritten, replacing the existing block by the new block.
 *
 *  Existing block is shorter than new block: if use_padding is \c true,
 *  the function will try and expand the new block into the following
 *  PADDING block, if it exists and doing so won't shrink the PADDING
 *  block to less than 4 bytes.  If there is no following PADDING
 *  block, or it will shrink to less than 4 bytes, or use_padding is
 *  \c false, the entire file is rewritten, replacing the existing block
 *  with the new block.  Note that in this case any following PADDING
 *  block is preserved as is.
 *
 *  After writing the block, the iterator will remain in the same
 *  place, i.e. pointing to the new block.
 *
 * \param iterator     A pointer to an existing initialized iterator.
 * \param block        The block to set.
 * \param use_padding  See above.
 * \assert
 *    \code iterator != NULL \endcode
 *    \a iterator has been successfully initialized with
 *    FLAC__metadata_simple_iterator_init()
 *    \code block != NULL \endcode
 * \retval FLAC__bool
 *    \c true if successful, else \c false.
 */
FLAC_API FLAC__bool FLAC__metadata_simple_iterator_set_block(FLAC__Metadata_SimpleIterator *iterator, FLAC__StreamMetadata *block, FLAC__bool use_padding);

/** This is similar to FLAC__metadata_simple_iterator_set_block()
 *  except that instead of writing over an existing block, it appends
 *  a block after the existing block.  \a use_padding is again used to
 *  tell the function to try an expand into following padding in an
 *  attempt to avoid rewriting the entire file.
 *
 *  This function will fail and return \c false if given a STREAMINFO
 *  block.
 *
 *  After writing the block, the iterator will be pointing to the
 *  new block.
 *
 * \param iterator     A pointer to an existing initialized iterator.
 * \param block        The block to set.
 * \param use_padding  See above.
 * \assert
 *    \code iterator != NULL \endcode
 *    \a iterator has been successfully initialized with
 *    FLAC__metadata_simple_iterator_init()
 *    \code block != NULL \endcode
 * \retval FLAC__bool
 *    \c true if successful, else \c false.
 */
FLAC_API FLAC__bool FLAC__metadata_simple_iterator_insert_block_after(FLAC__Metadata_SimpleIterator *iterator, FLAC__StreamMetadata *block, FLAC__bool use_padding);

/** Deletes the block at the current position.  This will cause the
 *  entire FLAC file to be rewritten, unless \a use_padding is \c true,
 *  in which case the block will be replaced by an equal-sized PADDING
 *  block.  The iterator will be left pointing to the block before the
 *  one just deleted.
 *
 *  You may not delete the STREAMINFO block.
 *
 * \param iterator     A pointer to an existing initialized iterator.
 * \param use_padding  See above.
 * \assert
 *    \code iterator != NULL \endcode
 *    \a iterator has been successfully initialized with
 *    FLAC__metadata_simple_iterator_init()
 * \retval FLAC__bool
 *    \c true if successful, else \c false.
 */
FLAC_API FLAC__bool FLAC__metadata_simple_iterator_delete_block(FLAC__Metadata_SimpleIterator *iterator, FLAC__bool use_padding);

/* \} */

/** \defgroup flac_metadata_level2 FLAC/metadata.h: metadata level 2 interface
 *  \ingroup flac_metadata
 *
 * \brief
 * The level 2 interface provides read-write access to FLAC file metadata;
 * all metadata is read into memory, operated on in memory, and then written
 * to file, which is more efficient than level 1 when editing multiple blocks.
 *
 * Currently Ogg FLAC is supported for read only, via
 * FLAC__metadata_chain_read_ogg() but a subsequent
 * FLAC__metadata_chain_write() will fail.
 *
 * The general usage of this interface is:
 *
 * - Create a new chain using FLAC__metadata_chain_new().  A chain is a
 *   linked list of FLAC metadata blocks.
 * - Read all metadata into the the chain from a FLAC file using
 *   FLAC__metadata_chain_read() or FLAC__metadata_chain_read_ogg() and
 *   check the status.
 * - Optionally, consolidate the padding using
 *   FLAC__metadata_chain_merge_padding() or
 *   FLAC__metadata_chain_sort_padding().
 * - Create a new iterator using FLAC__metadata_iterator_new()
 * - Initialize the iterator to point to the first element in the chain
 *   using FLAC__metadata_iterator_init()
 * - Traverse the chain using FLAC__metadata_iterator_next and
 *   FLAC__metadata_iterator_prev().
 * - Get a block for reading or modification using
 *   FLAC__metadata_iterator_get_block().  The pointer to the object
 *   inside the chain is returned, so the block is yours to modify.
 *   Changes will be reflected in the FLAC file when you write the
 *   chain.  You can also add and delete blocks (see functions below).
 * - When done, write out the chain using FLAC__metadata_chain_write().
 *   Make sure to read the whole comment to the function below.
 * - Delete the chain using FLAC__metadata_chain_delete().
 *
 * \note
 * Even though the FLAC file is not open while the chain is being
 * manipulated, you must not alter the file externally during
 * this time.  The chain assumes the FLAC file will not change
 * between the time of FLAC__metadata_chain_read()/FLAC__metadata_chain_read_ogg()
 * and FLAC__metadata_chain_write().
 *
 * \note
 * Do not modify the is_last, length, or type fields of returned
 * FLAC__StreamMetadata objects.  These are managed automatically.
 *
 * \note
 * The metadata objects returned by FLAC__metadata_iterator_get_block()
 * are owned by the chain; do not FLAC__metadata_object_delete() them.
 * In the same way, blocks passed to FLAC__metadata_iterator_set_block()
 * become owned by the chain and they will be deleted when the chain is
 * deleted.
 *
 * \{
 */

struct FLAC__Metadata_Chain;
/** The opaque structure definition for the level 2 chain type.
 */
typedef struct FLAC__Metadata_Chain FLAC__Metadata_Chain;

struct FLAC__Metadata_Iterator;
/** The opaque structure definition for the level 2 iterator type.
 */
typedef struct FLAC__Metadata_Iterator FLAC__Metadata_Iterator;

typedef enum {
	FLAC__METADATA_CHAIN_STATUS_OK = 0,
	/**< The chain is in the normal OK state */

	FLAC__METADATA_CHAIN_STATUS_ILLEGAL_INPUT,
	/**< The data passed into a function violated the function's usage criteria */

	FLAC__METADATA_CHAIN_STATUS_ERROR_OPENING_FILE,
	/**< The chain could not open the target file */

	FLAC__METADATA_CHAIN_STATUS_NOT_A_FLAC_FILE,
	/**< The chain could not find the FLAC signature at the start of the file */

	FLAC__METADATA_CHAIN_STATUS_NOT_WRITABLE,
	/**< The chain tried to write to a file that was not writable */

	FLAC__METADATA_CHAIN_STATUS_BAD_METADATA,
	/**< The chain encountered input that does not conform to the FLAC metadata specification */

	FLAC__METADATA_CHAIN_STATUS_READ_ERROR,
	/**< The chain encountered an error while reading the FLAC file */

	FLAC__METADATA_CHAIN_STATUS_SEEK_ERROR,
	/**< The chain encountered an error while seeking in the FLAC file */

	FLAC__METADATA_CHAIN_STATUS_WRITE_ERROR,
	/**< The chain encountered an error while writing the FLAC file */

	FLAC__METADATA_CHAIN_STATUS_RENAME_ERROR,
	/**< The chain encountered an error renaming the FLAC file */

	FLAC__METADATA_CHAIN_STATUS_UNLINK_ERROR,
	/**< The chain encountered an error removing the temporary file */

	FLAC__METADATA_CHAIN_STATUS_MEMORY_ALLOCATION_ERROR,
	/**< Memory allocation failed */

	FLAC__METADATA_CHAIN_STATUS_INTERNAL_ERROR,
	/**< The caller violated an assertion or an unexpected error occurred */

	FLAC__METADATA_CHAIN_STATUS_INVALID_CALLBACKS,
	/**< One or more of the required callbacks was NULL */

	FLAC__METADATA_CHAIN_STATUS_READ_WRITE_MISMATCH,
	/**< FLAC__metadata_chain_write() was called on a chain read by
	 *   FLAC__metadata_chain_read_with_callbacks()/FLAC__metadata_chain_read_ogg_with_callbacks(),
	 *   or
	 *   FLAC__metadata_chain_write_with_callbacks()/FLAC__metadata_chain_write_with_callbacks_and_tempfile()
	 *   was called on a chain read by
	 *   FLAC__metadata_chain_read()/FLAC__metadata_chain_read_ogg().
	 *   Matching read/write methods must always be used. */

	FLAC__METADATA_CHAIN_STATUS_WRONG_WRITE_CALL
	/**< FLAC__metadata_chain_write_with_callbacks() was called when the
	 *   chain write requires a tempfile; use
	 *   FLAC__metadata_chain_write_with_callbacks_and_tempfile() instead.
	 *   Or, FLAC__metadata_chain_write_with_callbacks_and_tempfile() was
	 *   called when the chain write does not require a tempfile; use
	 *   FLAC__metadata_chain_write_with_callbacks() instead.
	 *   Always check FLAC__metadata_chain_check_if_tempfile_needed()
	 *   before writing via callbacks. */

} FLAC__Metadata_ChainStatus;

/** Maps a FLAC__Metadata_ChainStatus to a C string.
 *
 *  Using a FLAC__Metadata_ChainStatus as the index to this array
 *  will give the string equivalent.  The contents should not be modified.
 */
extern FLAC_API const char * const FLAC__Metadata_ChainStatusString[];

/*********** FLAC__Metadata_Chain ***********/

/** Create a new chain instance.
 *
 * \retval FLAC__Metadata_Chain*
 *    \c NULL if there was an error allocating memory, else the new instance.
 */
FLAC_API FLAC__Metadata_Chain *FLAC__metadata_chain_new(void);

/** Free a chain instance.  Deletes the object pointed to by \a chain.
 *
 * \param chain  A pointer to an existing chain.
 * \assert
 *    \code chain != NULL \endcode
 */
FLAC_API void FLAC__metadata_chain_delete(FLAC__Metadata_Chain *chain);

/** Get the current status of the chain.  Call this after a function
 *  returns \c false to get the reason for the error.  Also resets the
 *  status to FLAC__METADATA_CHAIN_STATUS_OK.
 *
 * \param chain    A pointer to an existing chain.
 * \assert
 *    \code chain != NULL \endcode
 * \retval FLAC__Metadata_ChainStatus
 *    The current status of the chain.
 */
FLAC_API FLAC__Metadata_ChainStatus FLAC__metadata_chain_status(FLAC__Metadata_Chain *chain);

/** Read all metadata from a FLAC file into the chain.
 *
 * \param chain    A pointer to an existing chain.
 * \param filename The path to the FLAC file to read.
 * \assert
 *    \code chain != NULL \endcode
 *    \code filename != NULL \endcode
 * \retval FLAC__bool
 *    \c true if a valid list of metadata blocks was read from
 *    \a filename, else \c false.  On failure, check the status with
 *    FLAC__metadata_chain_status().
 */
FLAC_API FLAC__bool FLAC__metadata_chain_read(FLAC__Metadata_Chain *chain, const char *filename);

/** Read all metadata from an Ogg FLAC file into the chain.
 *
 * \note Ogg FLAC metadata data writing is not supported yet and
 * FLAC__metadata_chain_write() will fail.
 *
 * \param chain    A pointer to an existing chain.
 * \param filename The path to the Ogg FLAC file to read.
 * \assert
 *    \code chain != NULL \endcode
 *    \code filename != NULL \endcode
 * \retval FLAC__bool
 *    \c true if a valid list of metadata blocks was read from
 *    \a filename, else \c false.  On failure, check the status with
 *    FLAC__metadata_chain_status().
 */
FLAC_API FLAC__bool FLAC__metadata_chain_read_ogg(FLAC__Metadata_Chain *chain, const char *filename);

/** Read all metadata from a FLAC stream into the chain via I/O callbacks.
 *
 *  The \a handle need only be open for reading, but must be seekable.
 *  The equivalent minimum stdio fopen() file mode is \c "r" (or \c "rb"
 *  for Windows).
 *
 * \param chain    A pointer to an existing chain.
 * \param handle   The I/O handle of the FLAC stream to read.  The
 *                 handle will NOT be closed after the metadata is read;
 *                 that is the duty of the caller.
 * \param callbacks
 *                 A set of callbacks to use for I/O.  The mandatory
 *                 callbacks are \a read, \a seek, and \a tell.
 * \assert
 *    \code chain != NULL \endcode
 * \retval FLAC__bool
 *    \c true if a valid list of metadata blocks was read from
 *    \a handle, else \c false.  On failure, check the status with
 *    FLAC__metadata_chain_status().
 */
FLAC_API FLAC__bool FLAC__metadata_chain_read_with_callbacks(FLAC__Metadata_Chain *chain, FLAC__IOHandle handle, FLAC__IOCallbacks callbacks);

/** Read all metadata from an Ogg FLAC stream into the chain via I/O callbacks.
 *
 *  The \a handle need only be open for reading, but must be seekable.
 *  The equivalent minimum stdio fopen() file mode is \c "r" (or \c "rb"
 *  for Windows).
 *
 * \note Ogg FLAC metadata data writing is not supported yet and
 * FLAC__metadata_chain_write() will fail.
 *
 * \param chain    A pointer to an existing chain.
 * \param handle   The I/O handle of the Ogg FLAC stream to read.  The
 *                 handle will NOT be closed after the metadata is read;
 *                 that is the duty of the caller.
 * \param callbacks
 *                 A set of callbacks to use for I/O.  The mandatory
 *                 callbacks are \a read, \a seek, and \a tell.
 * \assert
 *    \code chain != NULL \endcode
 * \retval FLAC__bool
 *    \c true if a valid list of metadata blocks was read from
 *    \a handle, else \c false.  On failure, check the status with
 *    FLAC__metadata_chain_status().
 */
FLAC_API FLAC__bool FLAC__metadata_chain_read_ogg_with_callbacks(FLAC__Metadata_Chain *chain, FLAC__IOHandle handle, FLAC__IOCallbacks callbacks);

/** Checks if writing the given chain would require the use of a
 *  temporary file, or if it could be written in place.
 *
 *  Under certain conditions, padding can be utilized so that writing
 *  edited metadata back to the FLAC file does not require rewriting the
 *  entire file.  If rewriting is required, then a temporary workfile is
 *  required.  When writing metadata using callbacks, you must check
 *  this function to know whether to call
 *  FLAC__metadata_chain_write_with_callbacks() or
 *  FLAC__metadata_chain_write_with_callbacks_and_tempfile().  When
 *  writing with FLAC__metadata_chain_write(), the temporary file is
 *  handled internally.
 *
 * \param chain    A pointer to an existing chain.
 * \param use_padding
 *                 Whether or not padding will be allowed to be used
 *                 during the write.  The value of \a use_padding given
 *                 here must match the value later passed to
 *                 FLAC__metadata_chain_write_with_callbacks() or
 *                 FLAC__metadata_chain_write_with_callbacks_with_tempfile().
 * \assert
 *    \code chain != NULL \endcode
 * \retval FLAC__bool
 *    \c true if writing the current chain would require a tempfile, or
 *    \c false if metadata can be written in place.
 */
FLAC_API FLAC__bool FLAC__metadata_chain_check_if_tempfile_needed(FLAC__Metadata_Chain *chain, FLAC__bool use_padding);

/** Write all metadata out to the FLAC file.  This function tries to be as
 *  efficient as possible; how the metadata is actually written is shown by
 *  the following:
 *
 *  If the current chain is the same size as the existing metadata, the new
 *  data is written in place.
 *
 *  If the current chain is longer than the existing metadata, and
 *  \a use_padding is \c true, and the last block is a PADDING block of
 *  sufficient length, the function will truncate the final padding block
 *  so that the overall size of the metadata is the same as the existing
 *  metadata, and then just rewrite the metadata.  Otherwise, if not all of
 *  the above conditions are met, the entire FLAC file must be rewritten.
 *  If you want to use padding this way it is a good idea to call
 *  FLAC__metadata_chain_sort_padding() first so that you have the maximum
 *  amount of padding to work with, unless you need to preserve ordering
 *  of the PADDING blocks for some reason.
 *
 *  If the current chain is shorter than the existing metadata, and
 *  \a use_padding is \c true, and the final block is a PADDING block, the padding
 *  is extended to make the overall size the same as the existing data.  If
 *  \a use_padding is \c true and the last block is not a PADDING block, a new
 *  PADDING block is added to the end of the new data to make it the same
 *  size as the existing data (if possible, see the note to
 *  FLAC__metadata_simple_iterator_set_block() about the four byte limit)
 *  and the new data is written in place.  If none of the above apply or
 *  \a use_padding is \c false, the entire FLAC file is rewritten.
 *
 *  If \a preserve_file_stats is \c true, the owner and modification time will
 *  be preserved even if the FLAC file is written.
 *
 *  For this write function to be used, the chain must have been read with
 *  FLAC__metadata_chain_read()/FLAC__metadata_chain_read_ogg(), not
 *  FLAC__metadata_chain_read_with_callbacks()/FLAC__metadata_chain_read_ogg_with_callbacks().
 *
 * \param chain               A pointer to an existing chain.
 * \param use_padding         See above.
 * \param preserve_file_stats See above.
 * \assert
 *    \code chain != NULL \endcode
 * \retval FLAC__bool
 *    \c true if the write succeeded, else \c false.  On failure,
 *    check the status with FLAC__metadata_chain_status().
 */
FLAC_API FLAC__bool FLAC__metadata_chain_write(FLAC__Metadata_Chain *chain, FLAC__bool use_padding, FLAC__bool preserve_file_stats);

/** Write all metadata out to a FLAC stream via callbacks.
 *
 *  (See FLAC__metadata_chain_write() for the details on how padding is
 *  used to write metadata in place if possible.)
 *
 *  The \a handle must be open for updating and be seekable.  The
 *  equivalent minimum stdio fopen() file mode is \c "r+" (or \c "r+b"
 *  for Windows).
 *
 *  For this write function to be used, the chain must have been read with
 *  FLAC__metadata_chain_read_with_callbacks()/FLAC__metadata_chain_read_ogg_with_callbacks(),
 *  not FLAC__metadata_chain_read()/FLAC__metadata_chain_read_ogg().
 *  Also, FLAC__metadata_chain_check_if_tempfile_needed() must have returned
 *  \c false.
 *
 * \param chain        A pointer to an existing chain.
 * \param use_padding  See FLAC__metadata_chain_write()
 * \param handle       The I/O handle of the FLAC stream to write.  The
 *                     handle will NOT be closed after the metadata is
 *                     written; that is the duty of the caller.
 * \param callbacks    A set of callbacks to use for I/O.  The mandatory
 *                     callbacks are \a write and \a seek.
 * \assert
 *    \code chain != NULL \endcode
 * \retval FLAC__bool
 *    \c true if the write succeeded, else \c false.  On failure,
 *    check the status with FLAC__metadata_chain_status().
 */
FLAC_API FLAC__bool FLAC__metadata_chain_write_with_callbacks(FLAC__Metadata_Chain *chain, FLAC__bool use_padding, FLAC__IOHandle handle, FLAC__IOCallbacks callbacks);

/** Write all metadata out to a FLAC stream via callbacks.
 *
 *  (See FLAC__metadata_chain_write() for the details on how padding is
 *  used to write metadata in place if possible.)
 *
 *  This version of the write-with-callbacks function must be used when
 *  FLAC__metadata_chain_check_if_tempfile_needed() returns true.  In
 *  this function, you must supply an I/O handle corresponding to the
 *  FLAC file to edit, and a temporary handle to which the new FLAC
 *  file will be written.  It is the caller's job to move this temporary
 *  FLAC file on top of the original FLAC file to complete the metadata
 *  edit.
 *
 *  The \a handle must be open for reading and be seekable.  The
 *  equivalent minimum stdio fopen() file mode is \c "r" (or \c "rb"
 *  for Windows).
 *
 *  The \a temp_handle must be open for writing.  The
 *  equivalent minimum stdio fopen() file mode is \c "w" (or \c "wb"
 *  for Windows).  It should be an empty stream, or at least positioned
 *  at the start-of-file (in which case it is the caller's duty to
 *  truncate it on return).
 *
 *  For this write function to be used, the chain must have been read with
 *  FLAC__metadata_chain_read_with_callbacks()/FLAC__metadata_chain_read_ogg_with_callbacks(),
 *  not FLAC__metadata_chain_read()/FLAC__metadata_chain_read_ogg().
 *  Also, FLAC__metadata_chain_check_if_tempfile_needed() must have returned
 *  \c true.
 *
 * \param chain        A pointer to an existing chain.
 * \param use_padding  See FLAC__metadata_chain_write()
 * \param handle       The I/O handle of the original FLAC stream to read.
 *                     The handle will NOT be closed after the metadata is
 *                     written; that is the duty of the caller.
 * \param callbacks    A set of callbacks to use for I/O on \a handle.
 *                     The mandatory callbacks are \a read, \a seek, and
 *                     \a eof.
 * \param temp_handle  The I/O handle of the FLAC stream to write.  The
 *                     handle will NOT be closed after the metadata is
 *                     written; that is the duty of the caller.
 * \param temp_callbacks
 *                     A set of callbacks to use for I/O on temp_handle.
 *                     The only mandatory callback is \a write.
 * \assert
 *    \code chain != NULL \endcode
 * \retval FLAC__bool
 *    \c true if the write succeeded, else \c false.  On failure,
 *    check the status with FLAC__metadata_chain_status().
 */
FLAC_API FLAC__bool FLAC__metadata_chain_write_with_callbacks_and_tempfile(FLAC__Metadata_Chain *chain, FLAC__bool use_padding, FLAC__IOHandle handle, FLAC__IOCallbacks callbacks, FLAC__IOHandle temp_handle, FLAC__IOCallbacks temp_callbacks);

/** Merge adjacent PADDING blocks into a single block.
 *
 * \note This function does not write to the FLAC file, it only
 * modifies the chain.
 *
 * \warning Any iterator on the current chain will become invalid after this
 * call.  You should delete the iterator and get a new one.
 *
 * \param chain               A pointer to an existing chain.
 * \assert
 *    \code chain != NULL \endcode
 */
FLAC_API void FLAC__metadata_chain_merge_padding(FLAC__Metadata_Chain *chain);

/** This function will move all PADDING blocks to the end on the metadata,
 *  then merge them into a single block.
 *
 * \note This function does not write to the FLAC file, it only
 * modifies the chain.
 *
 * \warning Any iterator on the current chain will become invalid after this
 * call.  You should delete the iterator and get a new one.
 *
 * \param chain  A pointer to an existing chain.
 * \assert
 *    \code chain != NULL \endcode
 */
FLAC_API void FLAC__metadata_chain_sort_padding(FLAC__Metadata_Chain *chain);

/*********** FLAC__Metadata_Iterator ***********/

/** Create a new iterator instance.
 *
 * \retval FLAC__Metadata_Iterator*
 *    \c NULL if there was an error allocating memory, else the new instance.
 */
FLAC_API FLAC__Metadata_Iterator *FLAC__metadata_iterator_new(void);

/** Free an iterator instance.  Deletes the object pointed to by \a iterator.
 *
 * \param iterator  A pointer to an existing iterator.
 * \assert
 *    \code iterator != NULL \endcode
 */
FLAC_API void FLAC__metadata_iterator_delete(FLAC__Metadata_Iterator *iterator);

/** Initialize the iterator to point to the first metadata block in the
 *  given chain.
 *
 * \param iterator  A pointer to an existing iterator.
 * \param chain     A pointer to an existing and initialized (read) chain.
 * \assert
 *    \code iterator != NULL \endcode
 *    \code chain != NULL \endcode
 */
FLAC_API void FLAC__metadata_iterator_init(FLAC__Metadata_Iterator *iterator, FLAC__Metadata_Chain *chain);

/** Moves the iterator forward one metadata block, returning \c false if
 *  already at the end.
 *
 * \param iterator  A pointer to an existing initialized iterator.
 * \assert
 *    \code iterator != NULL \endcode
 *    \a iterator has been successfully initialized with
 *    FLAC__metadata_iterator_init()
 * \retval FLAC__bool
 *    \c false if already at the last metadata block of the chain, else
 *    \c true.
 */
FLAC_API FLAC__bool FLAC__metadata_iterator_next(FLAC__Metadata_Iterator *iterator);

/** Moves the iterator backward one metadata block, returning \c false if
 *  already at the beginning.
 *
 * \param iterator  A pointer to an existing initialized iterator.
 * \assert
 *    \code iterator != NULL \endcode
 *    \a iterator has been successfully initialized with
 *    FLAC__metadata_iterator_init()
 * \retval FLAC__bool
 *    \c false if already at the first metadata block of the chain, else
 *    \c true.
 */
FLAC_API FLAC__bool FLAC__metadata_iterator_prev(FLAC__Metadata_Iterator *iterator);

/** Get the type of the metadata block at the current position.
 *
 * \param iterator  A pointer to an existing initialized iterator.
 * \assert
 *    \code iterator != NULL \endcode
 *    \a iterator has been successfully initialized with
 *    FLAC__metadata_iterator_init()
 * \retval FLAC__MetadataType
 *    The type of the metadata block at the current iterator position.
 */
FLAC_API FLAC__MetadataType FLAC__metadata_iterator_get_block_type(const FLAC__Metadata_Iterator *iterator);

/** Get the metadata block at the current position.  You can modify
 *  the block in place but must write the chain before the changes
 *  are reflected to the FLAC file.  You do not need to call
 *  FLAC__metadata_iterator_set_block() to reflect the changes;
 *  the pointer returned by FLAC__metadata_iterator_get_block()
 *  points directly into the chain.
 *
 * \warning
 * Do not call FLAC__metadata_object_delete() on the returned object;
 * to delete a block use FLAC__metadata_iterator_delete_block().
 *
 * \param iterator  A pointer to an existing initialized iterator.
 * \assert
 *    \code iterator != NULL \endcode
 *    \a iterator has been successfully initialized with
 *    FLAC__metadata_iterator_init()
 * \retval FLAC__StreamMetadata*
 *    The current metadata block.
 */
FLAC_API FLAC__StreamMetadata *FLAC__metadata_iterator_get_block(FLAC__Metadata_Iterator *iterator);

/** Set the metadata block at the current position, replacing the existing
 *  block.  The new block passed in becomes owned by the chain and it will be
 *  deleted when the chain is deleted.
 *
 * \param iterator  A pointer to an existing initialized iterator.
 * \param block     A pointer to a metadata block.
 * \assert
 *    \code iterator != NULL \endcode
 *    \a iterator has been successfully initialized with
 *    FLAC__metadata_iterator_init()
 *    \code block != NULL \endcode
 * \retval FLAC__bool
 *    \c false if the conditions in the above description are not met, or
 *    a memory allocation error occurs, otherwise \c true.
 */
FLAC_API FLAC__bool FLAC__metadata_iterator_set_block(FLAC__Metadata_Iterator *iterator, FLAC__StreamMetadata *block);

/** Removes the current block from the chain.  If \a replace_with_padding is
 *  \c true, the block will instead be replaced with a padding block of equal
 *  size.  You can not delete the STREAMINFO block.  The iterator will be
 *  left pointing to the block before the one just "deleted", even if
 *  \a replace_with_padding is \c true.
 *
 * \param iterator              A pointer to an existing initialized iterator.
 * \param replace_with_padding  See above.
 * \assert
 *    \code iterator != NULL \endcode
 *    \a iterator has been successfully initialized with
 *    FLAC__metadata_iterator_init()
 * \retval FLAC__bool
 *    \c false if the conditions in the above description are not met,
 *    otherwise \c true.
 */
FLAC_API FLAC__bool FLAC__metadata_iterator_delete_block(FLAC__Metadata_Iterator *iterator, FLAC__bool replace_with_padding);

/** Insert a new block before the current block.  You cannot insert a block
 *  before the first STREAMINFO block.  You cannot insert a STREAMINFO block
 *  as there can be only one, the one that already exists at the head when you
 *  read in a chain.  The chain takes ownership of the new block and it will be
 *  deleted when the chain is deleted.  The iterator will be left pointing to
 *  the new block.
 *
 * \param iterator  A pointer to an existing initialized iterator.
 * \param block     A pointer to a metadata block to insert.
 * \assert
 *    \code iterator != NULL \endcode
 *    \a iterator has been successfully initialized with
 *    FLAC__metadata_iterator_init()
 * \retval FLAC__bool
 *    \c false if the conditions in the above description are not met, or
 *    a memory allocation error occurs, otherwise \c true.
 */
FLAC_API FLAC__bool FLAC__metadata_iterator_insert_block_before(FLAC__Metadata_Iterator *iterator, FLAC__StreamMetadata *block);

/** Insert a new block after the current block.  You cannot insert a STREAMINFO
 *  block as there can be only one, the one that already exists at the head when
 *  you read in a chain.  The chain takes ownership of the new block and it will
 *  be deleted when the chain is deleted.  The iterator will be left pointing to
 *  the new block.
 *
 * \param iterator  A pointer to an existing initialized iterator.
 * \param block     A pointer to a metadata block to insert.
 * \assert
 *    \code iterator != NULL \endcode
 *    \a iterator has been successfully initialized with
 *    FLAC__metadata_iterator_init()
 * \retval FLAC__bool
 *    \c false if the conditions in the above description are not met, or
 *    a memory allocation error occurs, otherwise \c true.
 */
FLAC_API FLAC__bool FLAC__metadata_iterator_insert_block_after(FLAC__Metadata_Iterator *iterator, FLAC__StreamMetadata *block);

/* \} */

/** \defgroup flac_metadata_object FLAC/metadata.h: metadata object methods
 *  \ingroup flac_metadata
 *
 * \brief
 * This module contains methods for manipulating FLAC metadata objects.
 *
 * Since many are variable length we have to be careful about the memory
 * management.  We decree that all pointers to data in the object are
 * owned by the object and memory-managed by the object.
 *
 * Use the FLAC__metadata_object_new() and FLAC__metadata_object_delete()
 * functions to create all instances.  When using the
 * FLAC__metadata_object_set_*() functions to set pointers to data, set
 * \a copy to \c true to have the function make it's own copy of the data, or
 * to \c false to give the object ownership of your data.  In the latter case
 * your pointer must be freeable by free() and will be free()d when the object
 * is FLAC__metadata_object_delete()d.  It is legal to pass a null pointer as
 * the data pointer to a FLAC__metadata_object_set_*() function as long as
 * the length argument is 0 and the \a copy argument is \c false.
 *
 * The FLAC__metadata_object_new() and FLAC__metadata_object_clone() function
 * will return \c NULL in the case of a memory allocation error, otherwise a new
 * object.  The FLAC__metadata_object_set_*() functions return \c false in the
 * case of a memory allocation error.
 *
 * We don't have the convenience of C++ here, so note that the library relies
 * on you to keep the types straight.  In other words, if you pass, for
 * example, a FLAC__StreamMetadata* that represents a STREAMINFO block to
 * FLAC__metadata_object_application_set_data(), you will get an assertion
 * failure.
 *
 * For convenience the FLAC__metadata_object_vorbiscomment_*() functions
 * maintain a trailing NUL on each Vorbis comment entry.  This is not counted
 * toward the length or stored in the stream, but it can make working with plain
 * comments (those that don't contain embedded-NULs in the value) easier.
 * Entries passed into these functions have trailing NULs added if missing, and
 * returned entries are guaranteed to have a trailing NUL.
 *
 * The FLAC__metadata_object_vorbiscomment_*() functions that take a Vorbis
 * comment entry/name/value will first validate that it complies with the Vorbis
 * comment specification and return false if it does not.
 *
 * There is no need to recalculate the length field on metadata blocks you
 * have modified.  They will be calculated automatically before they  are
 * written back to a file.
 *
 * \{
 */

/** Create a new metadata object instance of the given type.
 *
 *  The object will be "empty"; i.e. values and data pointers will be \c 0,
 *  with the exception of FLAC__METADATA_TYPE_VORBIS_COMMENT, which will have
 *  the vendor string set (but zero comments).
 *
 *  Do not pass in a value greater than or equal to
 *  \a FLAC__METADATA_TYPE_UNDEFINED unless you really know what you're
 *  doing.
 *
 * \param type  Type of object to create
 * \retval FLAC__StreamMetadata*
 *    \c NULL if there was an error allocating memory or the type code is
 *    greater than FLAC__MAX_METADATA_TYPE_CODE, else the new instance.
 */
FLAC_API FLAC__StreamMetadata *FLAC__metadata_object_new(FLAC__MetadataType type);

/** Create a copy of an existing metadata object.
 *
 *  The copy is a "deep" copy, i.e. dynamically allocated data within the
 *  object is also copied.  The caller takes ownership of the new block and
 *  is responsible for freeing it with FLAC__metadata_object_delete().
 *
 * \param object  Pointer to object to copy.
 * \assert
 *    \code object != NULL \endcode
 * \retval FLAC__StreamMetadata*
 *    \c NULL if there was an error allocating memory, else the new instance.
 */
FLAC_API FLAC__StreamMetadata *FLAC__metadata_object_clone(const FLAC__StreamMetadata *object);

/** Free a metadata object.  Deletes the object pointed to by \a object.
 *
 *  The delete is a "deep" delete, i.e. dynamically allocated data within the
 *  object is also deleted.
 *
 * \param object  A pointer to an existing object.
 * \assert
 *    \code object != NULL \endcode
 */
FLAC_API void FLAC__metadata_object_delete(FLAC__StreamMetadata *object);

/** Compares two metadata objects.
 *
 *  The compare is "deep", i.e. dynamically allocated data within the
 *  object is also compared.
 *
 * \param block1  A pointer to an existing object.
 * \param block2  A pointer to an existing object.
 * \assert
 *    \code block1 != NULL \endcode
 *    \code block2 != NULL \endcode
 * \retval FLAC__bool
 *    \c true if objects are identical, else \c false.
 */
FLAC_API FLAC__bool FLAC__metadata_object_is_equal(const FLAC__StreamMetadata *block1, const FLAC__StreamMetadata *block2);

/** Sets the application data of an APPLICATION block.
 *
 *  If \a copy is \c true, a copy of the data is stored; otherwise, the object
 *  takes ownership of the pointer.  The existing data will be freed if this
 *  function is successful, otherwise the original data will remain if \a copy
 *  is \c true and malloc() fails.
 *
 * \note It is safe to pass a const pointer to \a data if \a copy is \c true.
 *
 * \param object  A pointer to an existing APPLICATION object.
 * \param data    A pointer to the data to set.
 * \param length  The length of \a data in bytes.
 * \param copy    See above.
 * \assert
 *    \code object != NULL \endcode
 *    \code object->type == FLAC__METADATA_TYPE_APPLICATION \endcode
 *    \code (data != NULL && length > 0) ||
 * (data == NULL && length == 0 && copy == false) \endcode
 * \retval FLAC__bool
 *    \c false if \a copy is \c true and malloc() fails, else \c true.
 */
FLAC_API FLAC__bool FLAC__metadata_object_application_set_data(FLAC__StreamMetadata *object, FLAC__byte *data, unsigned length, FLAC__bool copy);

/** Resize the seekpoint array.
 *
 *  If the size shrinks, elements will truncated; if it grows, new placeholder
 *  points will be added to the end.
 *
 * \param object          A pointer to an existing SEEKTABLE object.
 * \param new_num_points  The desired length of the array; may be \c 0.
 * \assert
 *    \code object != NULL \endcode
 *    \code object->type == FLAC__METADATA_TYPE_SEEKTABLE \endcode
 *    \code (object->data.seek_table.points == NULL && object->data.seek_table.num_points == 0) ||
 * (object->data.seek_table.points != NULL && object->data.seek_table.num_points > 0) \endcode
 * \retval FLAC__bool
 *    \c false if memory allocation error, else \c true.
 */
FLAC_API FLAC__bool FLAC__metadata_object_seektable_resize_points(FLAC__StreamMetadata *object, unsigned new_num_points);

/** Set a seekpoint in a seektable.
 *
 * \param object     A pointer to an existing SEEKTABLE object.
 * \param point_num  Index into seekpoint array to set.
 * \param point      The point to set.
 * \assert
 *    \code object != NULL \endcode
 *    \code object->type == FLAC__METADATA_TYPE_SEEKTABLE \endcode
 *    \code object->data.seek_table.num_points > point_num \endcode
 */
FLAC_API void FLAC__metadata_object_seektable_set_point(FLAC__StreamMetadata *object, unsigned point_num, FLAC__StreamMetadata_SeekPoint point);

/** Insert a seekpoint into a seektable.
 *
 * \param object     A pointer to an existing SEEKTABLE object.
 * \param point_num  Index into seekpoint array to set.
 * \param point      The point to set.
 * \assert
 *    \code object != NULL \endcode
 *    \code object->type == FLAC__METADATA_TYPE_SEEKTABLE \endcode
 *    \code object->data.seek_table.num_points >= point_num \endcode
 * \retval FLAC__bool
 *    \c false if memory allocation error, else \c true.
 */
FLAC_API FLAC__bool FLAC__metadata_object_seektable_insert_point(FLAC__StreamMetadata *object, unsigned point_num, FLAC__StreamMetadata_SeekPoint point);

/** Delete a seekpoint from a seektable.
 *
 * \param object     A pointer to an existing SEEKTABLE object.
 * \param point_num  Index into seekpoint array to set.
 * \assert
 *    \code object != NULL \endcode
 *    \code object->type == FLAC__METADATA_TYPE_SEEKTABLE \endcode
 *    \code object->data.seek_table.num_points > point_num \endcode
 * \retval FLAC__bool
 *    \c false if memory allocation error, else \c true.
 */
FLAC_API FLAC__bool FLAC__metadata_object_seektable_delete_point(FLAC__StreamMetadata *object, unsigned point_num);

/** Check a seektable to see if it conforms to the FLAC specification.
 *  See the format specification for limits on the contents of the
 *  seektable.
 *
 * \param object  A pointer to an existing SEEKTABLE object.
 * \assert
 *    \code object != NULL \endcode
 *    \code object->type == FLAC__METADATA_TYPE_SEEKTABLE \endcode
 * \retval FLAC__bool
 *    \c false if seek table is illegal, else \c true.
 */
FLAC_API FLAC__bool FLAC__metadata_object_seektable_is_legal(const FLAC__StreamMetadata *object);

/** Append a number of placeholder points to the end of a seek table.
 *
 * \note
 * As with the other ..._seektable_template_... functions, you should
 * call FLAC__metadata_object_seektable_template_sort() when finished
 * to make the seek table legal.
 *
 * \param object  A pointer to an existing SEEKTABLE object.
 * \param num     The number of placeholder points to append.
 * \assert
 *    \code object != NULL \endcode
 *    \code object->type == FLAC__METADATA_TYPE_SEEKTABLE \endcode
 * \retval FLAC__bool
 *    \c false if memory allocation fails, else \c true.
 */
FLAC_API FLAC__bool FLAC__metadata_object_seektable_template_append_placeholders(FLAC__StreamMetadata *object, unsigned num);

/** Append a specific seek point template to the end of a seek table.
 *
 * \note
 * As with the other ..._seektable_template_... functions, you should
 * call FLAC__metadata_object_seektable_template_sort() when finished
 * to make the seek table legal.
 *
 * \param object  A pointer to an existing SEEKTABLE object.
 * \param sample_number  The sample number of the seek point template.
 * \assert
 *    \code object != NULL \endcode
 *    \code object->type == FLAC__METADATA_TYPE_SEEKTABLE \endcode
 * \retval FLAC__bool
 *    \c false if memory allocation fails, else \c true.
 */
FLAC_API FLAC__bool FLAC__metadata_object_seektable_template_append_point(FLAC__StreamMetadata *object, FLAC__uint64 sample_number);

/** Append specific seek point templates to the end of a seek table.
 *
 * \note
 * As with the other ..._seektable_template_... functions, you should
 * call FLAC__metadata_object_seektable_template_sort() when finished
 * to make the seek table legal.
 *
 * \param object  A pointer to an existing SEEKTABLE object.
 * \param sample_numbers  An array of sample numbers for the seek points.
 * \param num     The number of seek point templates to append.
 * \assert
 *    \code object != NULL \endcode
 *    \code object->type == FLAC__METADATA_TYPE_SEEKTABLE \endcode
 * \retval FLAC__bool
 *    \c false if memory allocation fails, else \c true.
 */
FLAC_API FLAC__bool FLAC__metadata_object_seektable_template_append_points(FLAC__StreamMetadata *object, FLAC__uint64 sample_numbers[], unsigned num);

/** Append a set of evenly-spaced seek point templates to the end of a
 *  seek table.
 *
 * \note
 * As with the other ..._seektable_template_... functions, you should
 * call FLAC__metadata_object_seektable_template_sort() when finished
 * to make the seek table legal.
 *
 * \param object  A pointer to an existing SEEKTABLE object.
 * \param num     The number of placeholder points to append.
 * \param total_samples  The total number of samples to be encoded;
 *                       the seekpoints will be spaced approximately
 *                       \a total_samples / \a num samples apart.
 * \assert
 *    \code object != NULL \endcode
 *    \code object->type == FLAC__METADATA_TYPE_SEEKTABLE \endcode
 *    \code total_samples > 0 \endcode
 * \retval FLAC__bool
 *    \c false if memory allocation fails, else \c true.
 */
FLAC_API FLAC__bool FLAC__metadata_object_seektable_template_append_spaced_points(FLAC__StreamMetadata *object, unsigned num, FLAC__uint64 total_samples);

/** Append a set of evenly-spaced seek point templates to the end of a
 *  seek table.
 *
 * \note
 * As with the other ..._seektable_template_... functions, you should
 * call FLAC__metadata_object_seektable_template_sort() when finished
 * to make the seek table legal.
 *
 * \param object  A pointer to an existing SEEKTABLE object.
 * \param samples The number of samples apart to space the placeholder
 *                points.  The first point will be at sample \c 0, the
 *                second at sample \a samples, then 2*\a samples, and
 *                so on.  As long as \a samples and \a total_samples
 *                are greater than \c 0, there will always be at least
 *                one seekpoint at sample \c 0.
 * \param total_samples  The total number of samples to be encoded;
 *                       the seekpoints will be spaced
 *                       \a samples samples apart.
 * \assert
 *    \code object != NULL \endcode
 *    \code object->type == FLAC__METADATA_TYPE_SEEKTABLE \endcode
 *    \code samples > 0 \endcode
 *    \code total_samples > 0 \endcode
 * \retval FLAC__bool
 *    \c false if memory allocation fails, else \c true.
 */
FLAC_API FLAC__bool FLAC__metadata_object_seektable_template_append_spaced_points_by_samples(FLAC__StreamMetadata *object, unsigned samples, FLAC__uint64 total_samples);

/** Sort a seek table's seek points according to the format specification,
 *  removing duplicates.
 *
 * \param object   A pointer to a seek table to be sorted.
 * \param compact  If \c false, behaves like FLAC__format_seektable_sort().
 *                 If \c true, duplicates are deleted and the seek table is
 *                 shrunk appropriately; the number of placeholder points
 *                 present in the seek table will be the same after the call
 *                 as before.
 * \assert
 *    \code object != NULL \endcode
 *    \code object->type == FLAC__METADATA_TYPE_SEEKTABLE \endcode
 * \retval FLAC__bool
 *    \c false if realloc() fails, else \c true.
 */
FLAC_API FLAC__bool FLAC__metadata_object_seektable_template_sort(FLAC__StreamMetadata *object, FLAC__bool compact);

/** Sets the vendor string in a VORBIS_COMMENT block.
 *
 *  For convenience, a trailing NUL is added to the entry if it doesn't have
 *  one already.
 *
 *  If \a copy is \c true, a copy of the entry is stored; otherwise, the object
 *  takes ownership of the \c entry.entry pointer.
 *
 *  \note If this function returns \c false, the caller still owns the
 *  pointer.
 *
 * \param object  A pointer to an existing VORBIS_COMMENT object.
 * \param entry   The entry to set the vendor string to.
 * \param copy    See above.
 * \assert
 *    \code object != NULL \endcode
 *    \code object->type == FLAC__METADATA_TYPE_VORBIS_COMMENT \endcode
 *    \code (entry.entry != NULL && entry.length > 0) ||
 * (entry.entry == NULL && entry.length == 0) \endcode
 * \retval FLAC__bool
 *    \c false if memory allocation fails or \a entry does not comply with the
 *    Vorbis comment specification, else \c true.
 */
FLAC_API FLAC__bool FLAC__metadata_object_vorbiscomment_set_vendor_string(FLAC__StreamMetadata *object, FLAC__StreamMetadata_VorbisComment_Entry entry, FLAC__bool copy);

/** Resize the comment array.
 *
 *  If the size shrinks, elements will truncated; if it grows, new empty
 *  fields will be added to the end.
 *
 * \param object            A pointer to an existing VORBIS_COMMENT object.
 * \param new_num_comments  The desired length of the array; may be \c 0.
 * \assert
 *    \code object != NULL \endcode
 *    \code object->type == FLAC__METADATA_TYPE_VORBIS_COMMENT \endcode
 *    \code (object->data.vorbis_comment.comments == NULL && object->data.vorbis_comment.num_comments == 0) ||
 * (object->data.vorbis_comment.comments != NULL && object->data.vorbis_comment.num_comments > 0) \endcode
 * \retval FLAC__bool
 *    \c false if memory allocation fails, else \c true.
 */
FLAC_API FLAC__bool FLAC__metadata_object_vorbiscomment_resize_comments(FLAC__StreamMetadata *object, unsigned new_num_comments);

/** Sets a comment in a VORBIS_COMMENT block.
 *
 *  For convenience, a trailing NUL is added to the entry if it doesn't have
 *  one already.
 *
 *  If \a copy is \c true, a copy of the entry is stored; otherwise, the object
 *  takes ownership of the \c entry.entry pointer.
 *
 *  \note If this function returns \c false, the caller still owns the
 *  pointer.
 *
 * \param object       A pointer to an existing VORBIS_COMMENT object.
 * \param comment_num  Index into comment array to set.
 * \param entry        The entry to set the comment to.
 * \param copy         See above.
 * \assert
 *    \code object != NULL \endcode
 *    \code object->type == FLAC__METADATA_TYPE_VORBIS_COMMENT \endcode
 *    \code comment_num < object->data.vorbis_comment.num_comments \endcode
 *    \code (entry.entry != NULL && entry.length > 0) ||
 * (entry.entry == NULL && entry.length == 0) \endcode
 * \retval FLAC__bool
 *    \c false if memory allocation fails or \a entry does not comply with the
 *    Vorbis comment specification, else \c true.
 */
FLAC_API FLAC__bool FLAC__metadata_object_vorbiscomment_set_comment(FLAC__StreamMetadata *object, unsigned comment_num, FLAC__StreamMetadata_VorbisComment_Entry entry, FLAC__bool copy);

/** Insert a comment in a VORBIS_COMMENT block at the given index.
 *
 *  For convenience, a trailing NUL is added to the entry if it doesn't have
 *  one already.
 *
 *  If \a copy is \c true, a copy of the entry is stored; otherwise, the object
 *  takes ownership of the \c entry.entry pointer.
 *
 *  \note If this function returns \c false, the caller still owns the
 *  pointer.
 *
 * \param object       A pointer to an existing VORBIS_COMMENT object.
 * \param comment_num  The index at which to insert the comment.  The comments
 *                     at and after \a comment_num move right one position.
 *                     To append a comment to the end, set \a comment_num to
 *                     \c object->data.vorbis_comment.num_comments .
 * \param entry        The comment to insert.
 * \param copy         See above.
 * \assert
 *    \code object != NULL \endcode
 *    \code object->type == FLAC__METADATA_TYPE_VORBIS_COMMENT \endcode
 *    \code object->data.vorbis_comment.num_comments >= comment_num \endcode
 *    \code (entry.entry != NULL && entry.length > 0) ||
 * (entry.entry == NULL && entry.length == 0 && copy == false) \endcode
 * \retval FLAC__bool
 *    \c false if memory allocation fails or \a entry does not comply with the
 *    Vorbis comment specification, else \c true.
 */
FLAC_API FLAC__bool FLAC__metadata_object_vorbiscomment_insert_comment(FLAC__StreamMetadata *object, unsigned comment_num, FLAC__StreamMetadata_VorbisComment_Entry entry, FLAC__bool copy);

/** Appends a comment to a VORBIS_COMMENT block.
 *
 *  For convenience, a trailing NUL is added to the entry if it doesn't have
 *  one already.
 *
 *  If \a copy is \c true, a copy of the entry is stored; otherwise, the object
 *  takes ownership of the \c entry.entry pointer.
 *
 *  \note If this function returns \c false, the caller still owns the
 *  pointer.
 *
 * \param object       A pointer to an existing VORBIS_COMMENT object.
 * \param entry        The comment to insert.
 * \param copy         See above.
 * \assert
 *    \code object != NULL \endcode
 *    \code object->type == FLAC__METADATA_TYPE_VORBIS_COMMENT \endcode
 *    \code (entry.entry != NULL && entry.length > 0) ||
 * (entry.entry == NULL && entry.length == 0 && copy == false) \endcode
 * \retval FLAC__bool
 *    \c false if memory allocation fails or \a entry does not comply with the
 *    Vorbis comment specification, else \c true.
 */
FLAC_API FLAC__bool FLAC__metadata_object_vorbiscomment_append_comment(FLAC__StreamMetadata *object, FLAC__StreamMetadata_VorbisComment_Entry entry, FLAC__bool copy);

/** Replaces comments in a VORBIS_COMMENT block with a new one.
 *
 *  For convenience, a trailing NUL is added to the entry if it doesn't have
 *  one already.
 *
 *  Depending on the the value of \a all, either all or just the first comment
 *  whose field name(s) match the given entry's name will be replaced by the
 *  given entry.  If no comments match, \a entry will simply be appended.
 *
 *  If \a copy is \c true, a copy of the entry is stored; otherwise, the object
 *  takes ownership of the \c entry.entry pointer.
 *
 *  \note If this function returns \c false, the caller still owns the
 *  pointer.
 *
 * \param object       A pointer to an existing VORBIS_COMMENT object.
 * \param entry        The comment to insert.
 * \param all          If \c true, all comments whose field name matches
 *                     \a entry's field name will be removed, and \a entry will
 *                     be inserted at the position of the first matching
 *                     comment.  If \c false, only the first comment whose
 *                     field name matches \a entry's field name will be
 *                     replaced with \a entry.
 * \param copy         See above.
 * \assert
 *    \code object != NULL \endcode
 *    \code object->type == FLAC__METADATA_TYPE_VORBIS_COMMENT \endcode
 *    \code (entry.entry != NULL && entry.length > 0) ||
 * (entry.entry == NULL && entry.length == 0 && copy == false) \endcode
 * \retval FLAC__bool
 *    \c false if memory allocation fails or \a entry does not comply with the
 *    Vorbis comment specification, else \c true.
 */
FLAC_API FLAC__bool FLAC__metadata_object_vorbiscomment_replace_comment(FLAC__StreamMetadata *object, FLAC__StreamMetadata_VorbisComment_Entry entry, FLAC__bool all, FLAC__bool copy);

/** Delete a comment in a VORBIS_COMMENT block at the given index.
 *
 * \param object       A pointer to an existing VORBIS_COMMENT object.
 * \param comment_num  The index of the comment to delete.
 * \assert
 *    \code object != NULL \endcode
 *    \code object->type == FLAC__METADATA_TYPE_VORBIS_COMMENT \endcode
 *    \code object->data.vorbis_comment.num_comments > comment_num \endcode
 * \retval FLAC__bool
 *    \c false if realloc() fails, else \c true.
 */
FLAC_API FLAC__bool FLAC__metadata_object_vorbiscomment_delete_comment(FLAC__StreamMetadata *object, unsigned comment_num);

/** Creates a Vorbis comment entry from NUL-terminated name and value strings.
 *
 *  On return, the filled-in \a entry->entry pointer will point to malloc()ed
 *  memory and shall be owned by the caller.  For convenience the entry will
 *  have a terminating NUL.
 *
 * \param entry              A pointer to a Vorbis comment entry.  The entry's
 *                           \c entry pointer should not point to allocated
 *                           memory as it will be overwritten.
 * \param field_name         The field name in ASCII, \c NUL terminated.
 * \param field_value        The field value in UTF-8, \c NUL terminated.
 * \assert
 *    \code entry != NULL \endcode
 *    \code field_name != NULL \endcode
 *    \code field_value != NULL \endcode
 * \retval FLAC__bool
 *    \c false if malloc() fails, or if \a field_name or \a field_value does
 *    not comply with the Vorbis comment specification, else \c true.
 */
FLAC_API FLAC__bool FLAC__metadata_object_vorbiscomment_entry_from_name_value_pair(FLAC__StreamMetadata_VorbisComment_Entry *entry, const char *field_name, const char *field_value);

/** Splits a Vorbis comment entry into NUL-terminated name and value strings.
 *
 *  The returned pointers to name and value will be allocated by malloc()
 *  and shall be owned by the caller.
 *
 * \param entry              An existing Vorbis comment entry.
 * \param field_name         The address of where the returned pointer to the
 *                           field name will be stored.
 * \param field_value        The address of where the returned pointer to the
 *                           field value will be stored.
 * \assert
 *    \code (entry.entry != NULL && entry.length > 0) \endcode
 *    \code memchr(entry.entry, '=', entry.length) != NULL \endcode
 *    \code field_name != NULL \endcode
 *    \code field_value != NULL \endcode
 * \retval FLAC__bool
 *    \c false if memory allocation fails or \a entry does not comply with the
 *    Vorbis comment specification, else \c true.
 */
FLAC_API FLAC__bool FLAC__metadata_object_vorbiscomment_entry_to_name_value_pair(const FLAC__StreamMetadata_VorbisComment_Entry entry, char **field_name, char **field_value);

/** Check if the given Vorbis comment entry's field name matches the given
 *  field name.
 *
 * \param entry              An existing Vorbis comment entry.
 * \param field_name         The field name to check.
 * \param field_name_length  The length of \a field_name, not including the
 *                           terminating \c NUL.
 * \assert
 *    \code (entry.entry != NULL && entry.length > 0) \endcode
 * \retval FLAC__bool
 *    \c true if the field names match, else \c false
 */
FLAC_API FLAC__bool FLAC__metadata_object_vorbiscomment_entry_matches(const FLAC__StreamMetadata_VorbisComment_Entry entry, const char *field_name, unsigned field_name_length);

/** Find a Vorbis comment with the given field name.
 *
 *  The search begins at entry number \a offset; use an offset of 0 to
 *  search from the beginning of the comment array.
 *
 * \param object      A pointer to an existing VORBIS_COMMENT object.
 * \param offset      The offset into the comment array from where to start
 *                    the search.
 * \param field_name  The field name of the comment to find.
 * \assert
 *    \code object != NULL \endcode
 *    \code object->type == FLAC__METADATA_TYPE_VORBIS_COMMENT \endcode
 *    \code field_name != NULL \endcode
 * \retval int
 *    The offset in the comment array of the first comment whose field
 *    name matches \a field_name, or \c -1 if no match was found.
 */
FLAC_API int FLAC__metadata_object_vorbiscomment_find_entry_from(const FLAC__StreamMetadata *object, unsigned offset, const char *field_name);

/** Remove first Vorbis comment matching the given field name.
 *
 * \param object      A pointer to an existing VORBIS_COMMENT object.
 * \param field_name  The field name of comment to delete.
 * \assert
 *    \code object != NULL \endcode
 *    \code object->type == FLAC__METADATA_TYPE_VORBIS_COMMENT \endcode
 * \retval int
 *    \c -1 for memory allocation error, \c 0 for no matching entries,
 *    \c 1 for one matching entry deleted.
 */
FLAC_API int FLAC__metadata_object_vorbiscomment_remove_entry_matching(FLAC__StreamMetadata *object, const char *field_name);

/** Remove all Vorbis comments matching the given field name.
 *
 * \param object      A pointer to an existing VORBIS_COMMENT object.
 * \param field_name  The field name of comments to delete.
 * \assert
 *    \code object != NULL \endcode
 *    \code object->type == FLAC__METADATA_TYPE_VORBIS_COMMENT \endcode
 * \retval int
 *    \c -1 for memory allocation error, \c 0 for no matching entries,
 *    else the number of matching entries deleted.
 */
FLAC_API int FLAC__metadata_object_vorbiscomment_remove_entries_matching(FLAC__StreamMetadata *object, const char *field_name);

/** Create a new CUESHEET track instance.
 *
 *  The object will be "empty"; i.e. values and data pointers will be \c 0.
 *
 * \retval FLAC__StreamMetadata_CueSheet_Track*
 *    \c NULL if there was an error allocating memory, else the new instance.
 */
FLAC_API FLAC__StreamMetadata_CueSheet_Track *FLAC__metadata_object_cuesheet_track_new(void);

/** Create a copy of an existing CUESHEET track object.
 *
 *  The copy is a "deep" copy, i.e. dynamically allocated data within the
 *  object is also copied.  The caller takes ownership of the new object and
 *  is responsible for freeing it with
 *  FLAC__metadata_object_cuesheet_track_delete().
 *
 * \param object  Pointer to object to copy.
 * \assert
 *    \code object != NULL \endcode
 * \retval FLAC__StreamMetadata_CueSheet_Track*
 *    \c NULL if there was an error allocating memory, else the new instance.
 */
FLAC_API FLAC__StreamMetadata_CueSheet_Track *FLAC__metadata_object_cuesheet_track_clone(const FLAC__StreamMetadata_CueSheet_Track *object);

/** Delete a CUESHEET track object
 *
 * \param object       A pointer to an existing CUESHEET track object.
 * \assert
 *    \code object != NULL \endcode
 */
FLAC_API void FLAC__metadata_object_cuesheet_track_delete(FLAC__StreamMetadata_CueSheet_Track *object);

/** Resize a track's index point array.
 *
 *  If the size shrinks, elements will truncated; if it grows, new blank
 *  indices will be added to the end.
 *
 * \param object           A pointer to an existing CUESHEET object.
 * \param track_num        The index of the track to modify.  NOTE: this is not
 *                         necessarily the same as the track's \a number field.
 * \param new_num_indices  The desired length of the array; may be \c 0.
 * \assert
 *    \code object != NULL \endcode
 *    \code object->type == FLAC__METADATA_TYPE_CUESHEET \endcode
 *    \code object->data.cue_sheet.num_tracks > track_num \endcode
 *    \code (object->data.cue_sheet.tracks[track_num].indices == NULL && object->data.cue_sheet.tracks[track_num].num_indices == 0) ||
 * (object->data.cue_sheet.tracks[track_num].indices != NULL && object->data.cue_sheet.tracks[track_num].num_indices > 0) \endcode
 * \retval FLAC__bool
 *    \c false if memory allocation error, else \c true.
 */
FLAC_API FLAC__bool FLAC__metadata_object_cuesheet_track_resize_indices(FLAC__StreamMetadata *object, unsigned track_num, unsigned new_num_indices);

/** Insert an index point in a CUESHEET track at the given index.
 *
 * \param object       A pointer to an existing CUESHEET object.
 * \param track_num    The index of the track to modify.  NOTE: this is not
 *                     necessarily the same as the track's \a number field.
 * \param index_num    The index into the track's index array at which to
 *                     insert the index point.  NOTE: this is not necessarily
 *                     the same as the index point's \a number field.  The
 *                     indices at and after \a index_num move right one
 *                     position.  To append an index point to the end, set
 *                     \a index_num to
 *                     \c object->data.cue_sheet.tracks[track_num].num_indices .
 * \param index        The index point to insert.
 * \assert
 *    \code object != NULL \endcode
 *    \code object->type == FLAC__METADATA_TYPE_CUESHEET \endcode
 *    \code object->data.cue_sheet.num_tracks > track_num \endcode
 *    \code object->data.cue_sheet.tracks[track_num].num_indices >= index_num \endcode
 * \retval FLAC__bool
 *    \c false if realloc() fails, else \c true.
 */
FLAC_API FLAC__bool FLAC__metadata_object_cuesheet_track_insert_index(FLAC__StreamMetadata *object, unsigned track_num, unsigned index_num, FLAC__StreamMetadata_CueSheet_Index index);

/** Insert a blank index point in a CUESHEET track at the given index.
 *
 *  A blank index point is one in which all field values are zero.
 *
 * \param object       A pointer to an existing CUESHEET object.
 * \param track_num    The index of the track to modify.  NOTE: this is not
 *                     necessarily the same as the track's \a number field.
 * \param index_num    The index into the track's index array at which to
 *                     insert the index point.  NOTE: this is not necessarily
 *                     the same as the index point's \a number field.  The
 *                     indices at and after \a index_num move right one
 *                     position.  To append an index point to the end, set
 *                     \a index_num to
 *                     \c object->data.cue_sheet.tracks[track_num].num_indices .
 * \assert
 *    \code object != NULL \endcode
 *    \code object->type == FLAC__METADATA_TYPE_CUESHEET \endcode
 *    \code object->data.cue_sheet.num_tracks > track_num \endcode
 *    \code object->data.cue_sheet.tracks[track_num].num_indices >= index_num \endcode
 * \retval FLAC__bool
 *    \c false if realloc() fails, else \c true.
 */
FLAC_API FLAC__bool FLAC__metadata_object_cuesheet_track_insert_blank_index(FLAC__StreamMetadata *object, unsigned track_num, unsigned index_num);

/** Delete an index point in a CUESHEET track at the given index.
 *
 * \param object       A pointer to an existing CUESHEET object.
 * \param track_num    The index into the track array of the track to
 *                     modify.  NOTE: this is not necessarily the same
 *                     as the track's \a number field.
 * \param index_num    The index into the track's index array of the index
 *                     to delete.  NOTE: this is not necessarily the same
 *                     as the index's \a number field.
 * \assert
 *    \code object != NULL \endcode
 *    \code object->type == FLAC__METADATA_TYPE_CUESHEET \endcode
 *    \code object->data.cue_sheet.num_tracks > track_num \endcode
 *    \code object->data.cue_sheet.tracks[track_num].num_indices > index_num \endcode
 * \retval FLAC__bool
 *    \c false if realloc() fails, else \c true.
 */
FLAC_API FLAC__bool FLAC__metadata_object_cuesheet_track_delete_index(FLAC__StreamMetadata *object, unsigned track_num, unsigned index_num);

/** Resize the track array.
 *
 *  If the size shrinks, elements will truncated; if it grows, new blank
 *  tracks will be added to the end.
 *
 * \param object            A pointer to an existing CUESHEET object.
 * \param new_num_tracks    The desired length of the array; may be \c 0.
 * \assert
 *    \code object != NULL \endcode
 *    \code object->type == FLAC__METADATA_TYPE_CUESHEET \endcode
 *    \code (object->data.cue_sheet.tracks == NULL && object->data.cue_sheet.num_tracks == 0) ||
 * (object->data.cue_sheet.tracks != NULL && object->data.cue_sheet.num_tracks > 0) \endcode
 * \retval FLAC__bool
 *    \c false if memory allocation error, else \c true.
 */
FLAC_API FLAC__bool FLAC__metadata_object_cuesheet_resize_tracks(FLAC__StreamMetadata *object, unsigned new_num_tracks);

/** Sets a track in a CUESHEET block.
 *
 *  If \a copy is \c true, a copy of the track is stored; otherwise, the object
 *  takes ownership of the \a track pointer.
 *
 * \param object       A pointer to an existing CUESHEET object.
 * \param track_num    Index into track array to set.  NOTE: this is not
 *                     necessarily the same as the track's \a number field.
 * \param track        The track to set the track to.  You may safely pass in
 *                     a const pointer if \a copy is \c true.
 * \param copy         See above.
 * \assert
 *    \code object != NULL \endcode
 *    \code object->type == FLAC__METADATA_TYPE_CUESHEET \endcode
 *    \code track_num < object->data.cue_sheet.num_tracks \endcode
 *    \code (track->indices != NULL && track->num_indices > 0) ||
 * (track->indices == NULL && track->num_indices == 0)
 * \retval FLAC__bool
 *    \c false if \a copy is \c true and malloc() fails, else \c true.
 */
FLAC_API FLAC__bool FLAC__metadata_object_cuesheet_set_track(FLAC__StreamMetadata *object, unsigned track_num, FLAC__StreamMetadata_CueSheet_Track *track, FLAC__bool copy);

/** Insert a track in a CUESHEET block at the given index.
 *
 *  If \a copy is \c true, a copy of the track is stored; otherwise, the object
 *  takes ownership of the \a track pointer.
 *
 * \param object       A pointer to an existing CUESHEET object.
 * \param track_num    The index at which to insert the track.  NOTE: this
 *                     is not necessarily the same as the track's \a number
 *                     field.  The tracks at and after \a track_num move right
 *                     one position.  To append a track to the end, set
 *                     \a track_num to \c object->data.cue_sheet.num_tracks .
 * \param track        The track to insert.  You may safely pass in a const
 *                     pointer if \a copy is \c true.
 * \param copy         See above.
 * \assert
 *    \code object != NULL \endcode
 *    \code object->type == FLAC__METADATA_TYPE_CUESHEET \endcode
 *    \code object->data.cue_sheet.num_tracks >= track_num \endcode
 * \retval FLAC__bool
 *    \c false if \a copy is \c true and malloc() fails, else \c true.
 */
FLAC_API FLAC__bool FLAC__metadata_object_cuesheet_insert_track(FLAC__StreamMetadata *object, unsigned track_num, FLAC__StreamMetadata_CueSheet_Track *track, FLAC__bool copy);

/** Insert a blank track in a CUESHEET block at the given index.
 *
 *  A blank track is one in which all field values are zero.
 *
 * \param object       A pointer to an existing CUESHEET object.
 * \param track_num    The index at which to insert the track.  NOTE: this
 *                     is not necessarily the same as the track's \a number
 *                     field.  The tracks at and after \a track_num move right
 *                     one position.  To append a track to the end, set
 *                     \a track_num to \c object->data.cue_sheet.num_tracks .
 * \assert
 *    \code object != NULL \endcode
 *    \code object->type == FLAC__METADATA_TYPE_CUESHEET \endcode
 *    \code object->data.cue_sheet.num_tracks >= track_num \endcode
 * \retval FLAC__bool
 *    \c false if \a copy is \c true and malloc() fails, else \c true.
 */
FLAC_API FLAC__bool FLAC__metadata_object_cuesheet_insert_blank_track(FLAC__StreamMetadata *object, unsigned track_num);

/** Delete a track in a CUESHEET block at the given index.
 *
 * \param object       A pointer to an existing CUESHEET object.
 * \param track_num    The index into the track array of the track to
 *                     delete.  NOTE: this is not necessarily the same
 *                     as the track's \a number field.
 * \assert
 *    \code object != NULL \endcode
 *    \code object->type == FLAC__METADATA_TYPE_CUESHEET \endcode
 *    \code object->data.cue_sheet.num_tracks > track_num \endcode
 * \retval FLAC__bool
 *    \c false if realloc() fails, else \c true.
 */
FLAC_API FLAC__bool FLAC__metadata_object_cuesheet_delete_track(FLAC__StreamMetadata *object, unsigned track_num);

/** Check a cue sheet to see if it conforms to the FLAC specification.
 *  See the format specification for limits on the contents of the
 *  cue sheet.
 *
 * \param object     A pointer to an existing CUESHEET object.
 * \param check_cd_da_subset  If \c true, check CUESHEET against more
 *                   stringent requirements for a CD-DA (audio) disc.
 * \param violation  Address of a pointer to a string.  If there is a
 *                   violation, a pointer to a string explanation of the
 *                   violation will be returned here. \a violation may be
 *                   \c NULL if you don't need the returned string.  Do not
 *                   free the returned string; it will always point to static
 *                   data.
 * \assert
 *    \code object != NULL \endcode
 *    \code object->type == FLAC__METADATA_TYPE_CUESHEET \endcode
 * \retval FLAC__bool
 *    \c false if cue sheet is illegal, else \c true.
 */
FLAC_API FLAC__bool FLAC__metadata_object_cuesheet_is_legal(const FLAC__StreamMetadata *object, FLAC__bool check_cd_da_subset, const char **violation);

/** Calculate and return the CDDB/freedb ID for a cue sheet.  The function
 *  assumes the cue sheet corresponds to a CD; the result is undefined
 *  if the cuesheet's is_cd bit is not set.
 *
 * \param object     A pointer to an existing CUESHEET object.
 * \assert
 *    \code object != NULL \endcode
 *    \code object->type == FLAC__METADATA_TYPE_CUESHEET \endcode
 * \retval FLAC__uint32
 *    The unsigned integer representation of the CDDB/freedb ID
 */
FLAC_API FLAC__uint32 FLAC__metadata_object_cuesheet_calculate_cddb_id(const FLAC__StreamMetadata *object);

/** Sets the MIME type of a PICTURE block.
 *
 *  If \a copy is \c true, a copy of the string is stored; otherwise, the object
 *  takes ownership of the pointer.  The existing string will be freed if this
 *  function is successful, otherwise the original string will remain if \a copy
 *  is \c true and malloc() fails.
 *
 * \note It is safe to pass a const pointer to \a mime_type if \a copy is \c true.
 *
 * \param object      A pointer to an existing PICTURE object.
 * \param mime_type   A pointer to the MIME type string.  The string must be
 *                    ASCII characters 0x20-0x7e, NUL-terminated.  No validation
 *                    is done.
 * \param copy        See above.
 * \assert
 *    \code object != NULL \endcode
 *    \code object->type == FLAC__METADATA_TYPE_PICTURE \endcode
 *    \code (mime_type != NULL) \endcode
 * \retval FLAC__bool
 *    \c false if \a copy is \c true and malloc() fails, else \c true.
 */
FLAC_API FLAC__bool FLAC__metadata_object_picture_set_mime_type(FLAC__StreamMetadata *object, char *mime_type, FLAC__bool copy);

/** Sets the description of a PICTURE block.
 *
 *  If \a copy is \c true, a copy of the string is stored; otherwise, the object
 *  takes ownership of the pointer.  The existing string will be freed if this
 *  function is successful, otherwise the original string will remain if \a copy
 *  is \c true and malloc() fails.
 *
 * \note It is safe to pass a const pointer to \a description if \a copy is \c true.
 *
 * \param object      A pointer to an existing PICTURE object.
 * \param description A pointer to the description string.  The string must be
 *                    valid UTF-8, NUL-terminated.  No validation is done.
 * \param copy        See above.
 * \assert
 *    \code object != NULL \endcode
 *    \code object->type == FLAC__METADATA_TYPE_PICTURE \endcode
 *    \code (description != NULL) \endcode
 * \retval FLAC__bool
 *    \c false if \a copy is \c true and malloc() fails, else \c true.
 */
FLAC_API FLAC__bool FLAC__metadata_object_picture_set_description(FLAC__StreamMetadata *object, FLAC__byte *description, FLAC__bool copy);

/** Sets the picture data of a PICTURE block.
 *
 *  If \a copy is \c true, a copy of the data is stored; otherwise, the object
 *  takes ownership of the pointer.  Also sets the \a data_length field of the
 *  metadata object to what is passed in as the \a length parameter.  The
 *  existing data will be freed if this function is successful, otherwise the
 *  original data and data_length will remain if \a copy is \c true and
 *  malloc() fails.
 *
 * \note It is safe to pass a const pointer to \a data if \a copy is \c true.
 *
 * \param object  A pointer to an existing PICTURE object.
 * \param data    A pointer to the data to set.
 * \param length  The length of \a data in bytes.
 * \param copy    See above.
 * \assert
 *    \code object != NULL \endcode
 *    \code object->type == FLAC__METADATA_TYPE_PICTURE \endcode
 *    \code (data != NULL && length > 0) ||
 * (data == NULL && length == 0 && copy == false) \endcode
 * \retval FLAC__bool
 *    \c false if \a copy is \c true and malloc() fails, else \c true.
 */
FLAC_API FLAC__bool FLAC__metadata_object_picture_set_data(FLAC__StreamMetadata *object, FLAC__byte *data, FLAC__uint32 length, FLAC__bool copy);

/** Check a PICTURE block to see if it conforms to the FLAC specification.
 *  See the format specification for limits on the contents of the
 *  PICTURE block.
 *
 * \param object     A pointer to existing PICTURE block to be checked.
 * \param violation  Address of a pointer to a string.  If there is a
 *                   violation, a pointer to a string explanation of the
 *                   violation will be returned here. \a violation may be
 *                   \c NULL if you don't need the returned string.  Do not
 *                   free the returned string; it will always point to static
 *                   data.
 * \assert
 *    \code object != NULL \endcode
 *    \code object->type == FLAC__METADATA_TYPE_PICTURE \endcode
 * \retval FLAC__bool
 *    \c false if PICTURE block is illegal, else \c true.
 */
FLAC_API FLAC__bool FLAC__metadata_object_picture_is_legal(const FLAC__StreamMetadata *object, const char **violation);

/* \} */

#ifdef __cplusplus
}
#endif

#endif

/*** End of inlined file: metadata.h ***/


/*** Start of inlined file: stream_decoder.h ***/
#ifndef FLAC__STREAM_DECODER_H
#define FLAC__STREAM_DECODER_H

#include <stdio.h> /* for FILE */

#ifdef __cplusplus
extern "C" {
#endif

/** \file include/FLAC/stream_decoder.h
 *
 *  \brief
 *  This module contains the functions which implement the stream
 *  decoder.
 *
 *  See the detailed documentation in the
 *  \link flac_stream_decoder stream decoder \endlink module.
 */

/** \defgroup flac_decoder FLAC/ \*_decoder.h: decoder interfaces
 *  \ingroup flac
 *
 *  \brief
 *  This module describes the decoder layers provided by libFLAC.
 *
 * The stream decoder can be used to decode complete streams either from
 * the client via callbacks, or directly from a file, depending on how
 * it is initialized.  When decoding via callbacks, the client provides
 * callbacks for reading FLAC data and writing decoded samples, and
 * handling metadata and errors.  If the client also supplies seek-related
 * callback, the decoder function for sample-accurate seeking within the
 * FLAC input is also available.  When decoding from a file, the client
 * needs only supply a filename or open \c FILE* and write/metadata/error
 * callbacks; the rest of the callbacks are supplied internally.  For more
 * info see the \link flac_stream_decoder stream decoder \endlink module.
 */

/** \defgroup flac_stream_decoder FLAC/stream_decoder.h: stream decoder interface
 *  \ingroup flac_decoder
 *
 *  \brief
 *  This module contains the functions which implement the stream
 *  decoder.
 *
 * The stream decoder can decode native FLAC, and optionally Ogg FLAC
 * (check FLAC_API_SUPPORTS_OGG_FLAC) streams and files.
 *
 * The basic usage of this decoder is as follows:
 * - The program creates an instance of a decoder using
 *   FLAC__stream_decoder_new().
 * - The program overrides the default settings using
 *   FLAC__stream_decoder_set_*() functions.
 * - The program initializes the instance to validate the settings and
 *   prepare for decoding using
 *   - FLAC__stream_decoder_init_stream() or FLAC__stream_decoder_init_FILE()
 *     or FLAC__stream_decoder_init_file() for native FLAC,
 *   - FLAC__stream_decoder_init_ogg_stream() or FLAC__stream_decoder_init_ogg_FILE()
 *     or FLAC__stream_decoder_init_ogg_file() for Ogg FLAC
 * - The program calls the FLAC__stream_decoder_process_*() functions
 *   to decode data, which subsequently calls the callbacks.
 * - The program finishes the decoding with FLAC__stream_decoder_finish(),
 *   which flushes the input and output and resets the decoder to the
 *   uninitialized state.
 * - The instance may be used again or deleted with
 *   FLAC__stream_decoder_delete().
 *
 * In more detail, the program will create a new instance by calling
 * FLAC__stream_decoder_new(), then call FLAC__stream_decoder_set_*()
 * functions to override the default decoder options, and call
 * one of the FLAC__stream_decoder_init_*() functions.
 *
 * There are three initialization functions for native FLAC, one for
 * setting up the decoder to decode FLAC data from the client via
 * callbacks, and two for decoding directly from a FLAC file.
 *
 * For decoding via callbacks, use FLAC__stream_decoder_init_stream().
 * You must also supply several callbacks for handling I/O.  Some (like
 * seeking) are optional, depending on the capabilities of the input.
 *
 * For decoding directly from a file, use FLAC__stream_decoder_init_FILE()
 * or FLAC__stream_decoder_init_file().  Then you must only supply an open
 * \c FILE* or filename and fewer callbacks; the decoder will handle
 * the other callbacks internally.
 *
 * There are three similarly-named init functions for decoding from Ogg
 * FLAC streams.  Check \c FLAC_API_SUPPORTS_OGG_FLAC to find out if the
 * library has been built with Ogg support.
 *
 * Once the decoder is initialized, your program will call one of several
 * functions to start the decoding process:
 *
 * - FLAC__stream_decoder_process_single() - Tells the decoder to process at
 *   most one metadata block or audio frame and return, calling either the
 *   metadata callback or write callback, respectively, once.  If the decoder
 *   loses sync it will return with only the error callback being called.
 * - FLAC__stream_decoder_process_until_end_of_metadata() - Tells the decoder
 *   to process the stream from the current location and stop upon reaching
 *   the first audio frame.  The client will get one metadata, write, or error
 *   callback per metadata block, audio frame, or sync error, respectively.
 * - FLAC__stream_decoder_process_until_end_of_stream() - Tells the decoder
 *   to process the stream from the current location until the read callback
 *   returns FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM or
 *   FLAC__STREAM_DECODER_READ_STATUS_ABORT.  The client will get one metadata,
 *   write, or error callback per metadata block, audio frame, or sync error,
 *   respectively.
 *
 * When the decoder has finished decoding (normally or through an abort),
 * the instance is finished by calling FLAC__stream_decoder_finish(), which
 * ensures the decoder is in the correct state and frees memory.  Then the
 * instance may be deleted with FLAC__stream_decoder_delete() or initialized
 * again to decode another stream.
 *
 * Seeking is exposed through the FLAC__stream_decoder_seek_absolute() method.
 * At any point after the stream decoder has been initialized, the client can
 * call this function to seek to an exact sample within the stream.
 * Subsequently, the first time the write callback is called it will be
 * passed a (possibly partial) block starting at that sample.
 *
 * If the client cannot seek via the callback interface provided, but still
 * has another way of seeking, it can flush the decoder using
 * FLAC__stream_decoder_flush() and start feeding data from the new position
 * through the read callback.
 *
 * The stream decoder also provides MD5 signature checking.  If this is
 * turned on before initialization, FLAC__stream_decoder_finish() will
 * report when the decoded MD5 signature does not match the one stored
 * in the STREAMINFO block.  MD5 checking is automatically turned off
 * (until the next FLAC__stream_decoder_reset()) if there is no signature
 * in the STREAMINFO block or when a seek is attempted.
 *
 * The FLAC__stream_decoder_set_metadata_*() functions deserve special
 * attention.  By default, the decoder only calls the metadata_callback for
 * the STREAMINFO block.  These functions allow you to tell the decoder
 * explicitly which blocks to parse and return via the metadata_callback
 * and/or which to skip.  Use a FLAC__stream_decoder_set_metadata_respond_all(),
 * FLAC__stream_decoder_set_metadata_ignore() ... or FLAC__stream_decoder_set_metadata_ignore_all(),
 * FLAC__stream_decoder_set_metadata_respond() ... sequence to exactly specify
 * which blocks to return.  Remember that metadata blocks can potentially
 * be big (for example, cover art) so filtering out the ones you don't
 * use can reduce the memory requirements of the decoder.  Also note the
 * special forms FLAC__stream_decoder_set_metadata_respond_application(id)
 * and FLAC__stream_decoder_set_metadata_ignore_application(id) for
 * filtering APPLICATION blocks based on the application ID.
 *
 * STREAMINFO and SEEKTABLE blocks are always parsed and used internally, but
 * they still can legally be filtered from the metadata_callback.
 *
 * \note
 * The "set" functions may only be called when the decoder is in the
 * state FLAC__STREAM_DECODER_UNINITIALIZED, i.e. after
 * FLAC__stream_decoder_new() or FLAC__stream_decoder_finish(), but
 * before FLAC__stream_decoder_init_*().  If this is the case they will
 * return \c true, otherwise \c false.
 *
 * \note
 * FLAC__stream_decoder_finish() resets all settings to the constructor
 * defaults, including the callbacks.
 *
 * \{
 */

/** State values for a FLAC__StreamDecoder
 *
 * The decoder's state can be obtained by calling FLAC__stream_decoder_get_state().
 */
typedef enum {

	FLAC__STREAM_DECODER_SEARCH_FOR_METADATA = 0,
	/**< The decoder is ready to search for metadata. */

	FLAC__STREAM_DECODER_READ_METADATA,
	/**< The decoder is ready to or is in the process of reading metadata. */

	FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC,
	/**< The decoder is ready to or is in the process of searching for the
	 * frame sync code.
	 */

	FLAC__STREAM_DECODER_READ_FRAME,
	/**< The decoder is ready to or is in the process of reading a frame. */

	FLAC__STREAM_DECODER_END_OF_STREAM,
	/**< The decoder has reached the end of the stream. */

	FLAC__STREAM_DECODER_OGG_ERROR,
	/**< An error occurred in the underlying Ogg layer.  */

	FLAC__STREAM_DECODER_SEEK_ERROR,
	/**< An error occurred while seeking.  The decoder must be flushed
	 * with FLAC__stream_decoder_flush() or reset with
	 * FLAC__stream_decoder_reset() before decoding can continue.
	 */

	FLAC__STREAM_DECODER_ABORTED,
	/**< The decoder was aborted by the read callback. */

	FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR,
	/**< An error occurred allocating memory.  The decoder is in an invalid
	 * state and can no longer be used.
	 */

	FLAC__STREAM_DECODER_UNINITIALIZED
	/**< The decoder is in the uninitialized state; one of the
	 * FLAC__stream_decoder_init_*() functions must be called before samples
	 * can be processed.
	 */

} FLAC__StreamDecoderState;

/** Maps a FLAC__StreamDecoderState to a C string.
 *
 *  Using a FLAC__StreamDecoderState as the index to this array
 *  will give the string equivalent.  The contents should not be modified.
 */
extern FLAC_API const char * const FLAC__StreamDecoderStateString[];

/** Possible return values for the FLAC__stream_decoder_init_*() functions.
 */
typedef enum {

	FLAC__STREAM_DECODER_INIT_STATUS_OK = 0,
	/**< Initialization was successful. */

	FLAC__STREAM_DECODER_INIT_STATUS_UNSUPPORTED_CONTAINER,
	/**< The library was not compiled with support for the given container
	 * format.
	 */

	FLAC__STREAM_DECODER_INIT_STATUS_INVALID_CALLBACKS,
	/**< A required callback was not supplied. */

	FLAC__STREAM_DECODER_INIT_STATUS_MEMORY_ALLOCATION_ERROR,
	/**< An error occurred allocating memory. */

	FLAC__STREAM_DECODER_INIT_STATUS_ERROR_OPENING_FILE,
	/**< fopen() failed in FLAC__stream_decoder_init_file() or
	 * FLAC__stream_decoder_init_ogg_file(). */

	FLAC__STREAM_DECODER_INIT_STATUS_ALREADY_INITIALIZED
	/**< FLAC__stream_decoder_init_*() was called when the decoder was
	 * already initialized, usually because
	 * FLAC__stream_decoder_finish() was not called.
	 */

} FLAC__StreamDecoderInitStatus;

/** Maps a FLAC__StreamDecoderInitStatus to a C string.
 *
 *  Using a FLAC__StreamDecoderInitStatus as the index to this array
 *  will give the string equivalent.  The contents should not be modified.
 */
extern FLAC_API const char * const FLAC__StreamDecoderInitStatusString[];

/** Return values for the FLAC__StreamDecoder read callback.
 */
typedef enum {

	FLAC__STREAM_DECODER_READ_STATUS_CONTINUE,
	/**< The read was OK and decoding can continue. */

	FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM,
	/**< The read was attempted while at the end of the stream.  Note that
	 * the client must only return this value when the read callback was
	 * called when already at the end of the stream.  Otherwise, if the read
	 * itself moves to the end of the stream, the client should still return
	 * the data and \c FLAC__STREAM_DECODER_READ_STATUS_CONTINUE, and then on
	 * the next read callback it should return
	 * \c FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM with a byte count
	 * of \c 0.
	 */

	FLAC__STREAM_DECODER_READ_STATUS_ABORT
	/**< An unrecoverable error occurred.  The decoder will return from the process call. */

} FLAC__StreamDecoderReadStatus;

/** Maps a FLAC__StreamDecoderReadStatus to a C string.
 *
 *  Using a FLAC__StreamDecoderReadStatus as the index to this array
 *  will give the string equivalent.  The contents should not be modified.
 */
extern FLAC_API const char * const FLAC__StreamDecoderReadStatusString[];

/** Return values for the FLAC__StreamDecoder seek callback.
 */
typedef enum {

	FLAC__STREAM_DECODER_SEEK_STATUS_OK,
	/**< The seek was OK and decoding can continue. */

	FLAC__STREAM_DECODER_SEEK_STATUS_ERROR,
	/**< An unrecoverable error occurred.  The decoder will return from the process call. */

	FLAC__STREAM_DECODER_SEEK_STATUS_UNSUPPORTED
	/**< Client does not support seeking. */

} FLAC__StreamDecoderSeekStatus;

/** Maps a FLAC__StreamDecoderSeekStatus to a C string.
 *
 *  Using a FLAC__StreamDecoderSeekStatus as the index to this array
 *  will give the string equivalent.  The contents should not be modified.
 */
extern FLAC_API const char * const FLAC__StreamDecoderSeekStatusString[];

/** Return values for the FLAC__StreamDecoder tell callback.
 */
typedef enum {

	FLAC__STREAM_DECODER_TELL_STATUS_OK,
	/**< The tell was OK and decoding can continue. */

	FLAC__STREAM_DECODER_TELL_STATUS_ERROR,
	/**< An unrecoverable error occurred.  The decoder will return from the process call. */

	FLAC__STREAM_DECODER_TELL_STATUS_UNSUPPORTED
	/**< Client does not support telling the position. */

} FLAC__StreamDecoderTellStatus;

/** Maps a FLAC__StreamDecoderTellStatus to a C string.
 *
 *  Using a FLAC__StreamDecoderTellStatus as the index to this array
 *  will give the string equivalent.  The contents should not be modified.
 */
extern FLAC_API const char * const FLAC__StreamDecoderTellStatusString[];

/** Return values for the FLAC__StreamDecoder length callback.
 */
typedef enum {

	FLAC__STREAM_DECODER_LENGTH_STATUS_OK,
	/**< The length call was OK and decoding can continue. */

	FLAC__STREAM_DECODER_LENGTH_STATUS_ERROR,
	/**< An unrecoverable error occurred.  The decoder will return from the process call. */

	FLAC__STREAM_DECODER_LENGTH_STATUS_UNSUPPORTED
	/**< Client does not support reporting the length. */

} FLAC__StreamDecoderLengthStatus;

/** Maps a FLAC__StreamDecoderLengthStatus to a C string.
 *
 *  Using a FLAC__StreamDecoderLengthStatus as the index to this array
 *  will give the string equivalent.  The contents should not be modified.
 */
extern FLAC_API const char * const FLAC__StreamDecoderLengthStatusString[];

/** Return values for the FLAC__StreamDecoder write callback.
 */
typedef enum {

	FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE,
	/**< The write was OK and decoding can continue. */

	FLAC__STREAM_DECODER_WRITE_STATUS_ABORT
	/**< An unrecoverable error occurred.  The decoder will return from the process call. */

} FLAC__StreamDecoderWriteStatus;

/** Maps a FLAC__StreamDecoderWriteStatus to a C string.
 *
 *  Using a FLAC__StreamDecoderWriteStatus as the index to this array
 *  will give the string equivalent.  The contents should not be modified.
 */
extern FLAC_API const char * const FLAC__StreamDecoderWriteStatusString[];

/** Possible values passed back to the FLAC__StreamDecoder error callback.
 *  \c FLAC__STREAM_DECODER_ERROR_STATUS_LOST_SYNC is the generic catch-
 *  all.  The rest could be caused by bad sync (false synchronization on
 *  data that is not the start of a frame) or corrupted data.  The error
 *  itself is the decoder's best guess at what happened assuming a correct
 *  sync.  For example \c FLAC__STREAM_DECODER_ERROR_STATUS_BAD_HEADER
 *  could be caused by a correct sync on the start of a frame, but some
 *  data in the frame header was corrupted.  Or it could be the result of
 *  syncing on a point the stream that looked like the starting of a frame
 *  but was not.  \c FLAC__STREAM_DECODER_ERROR_STATUS_UNPARSEABLE_STREAM
 *  could be because the decoder encountered a valid frame made by a future
 *  version of the encoder which it cannot parse, or because of a false
 *  sync making it appear as though an encountered frame was generated by
 *  a future encoder.
 */
typedef enum {

	FLAC__STREAM_DECODER_ERROR_STATUS_LOST_SYNC,
	/**< An error in the stream caused the decoder to lose synchronization. */

	FLAC__STREAM_DECODER_ERROR_STATUS_BAD_HEADER,
	/**< The decoder encountered a corrupted frame header. */

	FLAC__STREAM_DECODER_ERROR_STATUS_FRAME_CRC_MISMATCH,
	/**< The frame's data did not match the CRC in the footer. */

	FLAC__STREAM_DECODER_ERROR_STATUS_UNPARSEABLE_STREAM
	/**< The decoder encountered reserved fields in use in the stream. */

} FLAC__StreamDecoderErrorStatus;

/** Maps a FLAC__StreamDecoderErrorStatus to a C string.
 *
 *  Using a FLAC__StreamDecoderErrorStatus as the index to this array
 *  will give the string equivalent.  The contents should not be modified.
 */
extern FLAC_API const char * const FLAC__StreamDecoderErrorStatusString[];

/***********************************************************************
 *
 * class FLAC__StreamDecoder
 *
 ***********************************************************************/

struct FLAC__StreamDecoderProtected;
struct FLAC__StreamDecoderPrivate;
/** The opaque structure definition for the stream decoder type.
 *  See the \link flac_stream_decoder stream decoder module \endlink
 *  for a detailed description.
 */
typedef struct {
	struct FLAC__StreamDecoderProtected *protected_; /* avoid the C++ keyword 'protected' */
	struct FLAC__StreamDecoderPrivate *private_; /* avoid the C++ keyword 'private' */
} FLAC__StreamDecoder;

/** Signature for the read callback.
 *
 *  A function pointer matching this signature must be passed to
 *  FLAC__stream_decoder_init*_stream(). The supplied function will be
 *  called when the decoder needs more input data.  The address of the
 *  buffer to be filled is supplied, along with the number of bytes the
 *  buffer can hold.  The callback may choose to supply less data and
 *  modify the byte count but must be careful not to overflow the buffer.
 *  The callback then returns a status code chosen from
 *  FLAC__StreamDecoderReadStatus.
 *
 * Here is an example of a read callback for stdio streams:
 * \code
 * FLAC__StreamDecoderReadStatus read_cb(const FLAC__StreamDecoder *decoder, FLAC__byte buffer[], size_t *bytes, void *client_data)
 * {
 *   FILE *file = ((MyClientData*)client_data)->file;
 *   if(*bytes > 0) {
 *     *bytes = fread(buffer, sizeof(FLAC__byte), *bytes, file);
 *     if(ferror(file))
 *       return FLAC__STREAM_DECODER_READ_STATUS_ABORT;
 *     else if(*bytes == 0)
 *       return FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM;
 *     else
 *       return FLAC__STREAM_DECODER_READ_STATUS_CONTINUE;
 *   }
 *   else
 *     return FLAC__STREAM_DECODER_READ_STATUS_ABORT;
 * }
 * \endcode
 *
 * \note In general, FLAC__StreamDecoder functions which change the
 * state should not be called on the \a decoder while in the callback.
 *
 * \param  decoder  The decoder instance calling the callback.
 * \param  buffer   A pointer to a location for the callee to store
 *                  data to be decoded.
 * \param  bytes    A pointer to the size of the buffer.  On entry
 *                  to the callback, it contains the maximum number
 *                  of bytes that may be stored in \a buffer.  The
 *                  callee must set it to the actual number of bytes
 *                  stored (0 in case of error or end-of-stream) before
 *                  returning.
 * \param  client_data  The callee's client data set through
 *                      FLAC__stream_decoder_init_*().
 * \retval FLAC__StreamDecoderReadStatus
 *    The callee's return status.  Note that the callback should return
 *    \c FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM if and only if
 *    zero bytes were read and there is no more data to be read.
 */
typedef FLAC__StreamDecoderReadStatus (*FLAC__StreamDecoderReadCallback)(const FLAC__StreamDecoder *decoder, FLAC__byte buffer[], size_t *bytes, void *client_data);

/** Signature for the seek callback.
 *
 *  A function pointer matching this signature may be passed to
 *  FLAC__stream_decoder_init*_stream().  The supplied function will be
 *  called when the decoder needs to seek the input stream.  The decoder
 *  will pass the absolute byte offset to seek to, 0 meaning the
 *  beginning of the stream.
 *
 * Here is an example of a seek callback for stdio streams:
 * \code
 * FLAC__StreamDecoderSeekStatus seek_cb(const FLAC__StreamDecoder *decoder, FLAC__uint64 absolute_byte_offset, void *client_data)
 * {
 *   FILE *file = ((MyClientData*)client_data)->file;
 *   if(file == stdin)
 *     return FLAC__STREAM_DECODER_SEEK_STATUS_UNSUPPORTED;
 *   else if(fseeko(file, (off_t)absolute_byte_offset, SEEK_SET) < 0)
 *     return FLAC__STREAM_DECODER_SEEK_STATUS_ERROR;
 *   else
 *     return FLAC__STREAM_DECODER_SEEK_STATUS_OK;
 * }
 * \endcode
 *
 * \note In general, FLAC__StreamDecoder functions which change the
 * state should not be called on the \a decoder while in the callback.
 *
 * \param  decoder  The decoder instance calling the callback.
 * \param  absolute_byte_offset  The offset from the beginning of the stream
 *                               to seek to.
 * \param  client_data  The callee's client data set through
 *                      FLAC__stream_decoder_init_*().
 * \retval FLAC__StreamDecoderSeekStatus
 *    The callee's return status.
 */
typedef FLAC__StreamDecoderSeekStatus (*FLAC__StreamDecoderSeekCallback)(const FLAC__StreamDecoder *decoder, FLAC__uint64 absolute_byte_offset, void *client_data);

/** Signature for the tell callback.
 *
 *  A function pointer matching this signature may be passed to
 *  FLAC__stream_decoder_init*_stream().  The supplied function will be
 *  called when the decoder wants to know the current position of the
 *  stream.  The callback should return the byte offset from the
 *  beginning of the stream.
 *
 * Here is an example of a tell callback for stdio streams:
 * \code
 * FLAC__StreamDecoderTellStatus tell_cb(const FLAC__StreamDecoder *decoder, FLAC__uint64 *absolute_byte_offset, void *client_data)
 * {
 *   FILE *file = ((MyClientData*)client_data)->file;
 *   off_t pos;
 *   if(file == stdin)
 *     return FLAC__STREAM_DECODER_TELL_STATUS_UNSUPPORTED;
 *   else if((pos = ftello(file)) < 0)
 *     return FLAC__STREAM_DECODER_TELL_STATUS_ERROR;
 *   else {
 *     *absolute_byte_offset = (FLAC__uint64)pos;
 *     return FLAC__STREAM_DECODER_TELL_STATUS_OK;
 *   }
 * }
 * \endcode
 *
 * \note In general, FLAC__StreamDecoder functions which change the
 * state should not be called on the \a decoder while in the callback.
 *
 * \param  decoder  The decoder instance calling the callback.
 * \param  absolute_byte_offset  A pointer to storage for the current offset
 *                               from the beginning of the stream.
 * \param  client_data  The callee's client data set through
 *                      FLAC__stream_decoder_init_*().
 * \retval FLAC__StreamDecoderTellStatus
 *    The callee's return status.
 */
typedef FLAC__StreamDecoderTellStatus (*FLAC__StreamDecoderTellCallback)(const FLAC__StreamDecoder *decoder, FLAC__uint64 *absolute_byte_offset, void *client_data);

/** Signature for the length callback.
 *
 *  A function pointer matching this signature may be passed to
 *  FLAC__stream_decoder_init*_stream().  The supplied function will be
 *  called when the decoder wants to know the total length of the stream
 *  in bytes.
 *
 * Here is an example of a length callback for stdio streams:
 * \code
 * FLAC__StreamDecoderLengthStatus length_cb(const FLAC__StreamDecoder *decoder, FLAC__uint64 *stream_length, void *client_data)
 * {
 *   FILE *file = ((MyClientData*)client_data)->file;
 *   struct stat filestats;
 *
 *   if(file == stdin)
 *     return FLAC__STREAM_DECODER_LENGTH_STATUS_UNSUPPORTED;
 *   else if(fstat(fileno(file), &filestats) != 0)
 *     return FLAC__STREAM_DECODER_LENGTH_STATUS_ERROR;
 *   else {
 *     *stream_length = (FLAC__uint64)filestats.st_size;
 *     return FLAC__STREAM_DECODER_LENGTH_STATUS_OK;
 *   }
 * }
 * \endcode
 *
 * \note In general, FLAC__StreamDecoder functions which change the
 * state should not be called on the \a decoder while in the callback.
 *
 * \param  decoder  The decoder instance calling the callback.
 * \param  stream_length  A pointer to storage for the length of the stream
 *                        in bytes.
 * \param  client_data  The callee's client data set through
 *                      FLAC__stream_decoder_init_*().
 * \retval FLAC__StreamDecoderLengthStatus
 *    The callee's return status.
 */
typedef FLAC__StreamDecoderLengthStatus (*FLAC__StreamDecoderLengthCallback)(const FLAC__StreamDecoder *decoder, FLAC__uint64 *stream_length, void *client_data);

/** Signature for the EOF callback.
 *
 *  A function pointer matching this signature may be passed to
 *  FLAC__stream_decoder_init*_stream().  The supplied function will be
 *  called when the decoder needs to know if the end of the stream has
 *  been reached.
 *
 * Here is an example of a EOF callback for stdio streams:
 * FLAC__bool eof_cb(const FLAC__StreamDecoder *decoder, void *client_data)
 * \code
 * {
 *   FILE *file = ((MyClientData*)client_data)->file;
 *   return feof(file)? true : false;
 * }
 * \endcode
 *
 * \note In general, FLAC__StreamDecoder functions which change the
 * state should not be called on the \a decoder while in the callback.
 *
 * \param  decoder  The decoder instance calling the callback.
 * \param  client_data  The callee's client data set through
 *                      FLAC__stream_decoder_init_*().
 * \retval FLAC__bool
 *    \c true if the currently at the end of the stream, else \c false.
 */
typedef FLAC__bool (*FLAC__StreamDecoderEofCallback)(const FLAC__StreamDecoder *decoder, void *client_data);

/** Signature for the write callback.
 *
 *  A function pointer matching this signature must be passed to one of
 *  the FLAC__stream_decoder_init_*() functions.
 *  The supplied function will be called when the decoder has decoded a
 *  single audio frame.  The decoder will pass the frame metadata as well
 *  as an array of pointers (one for each channel) pointing to the
 *  decoded audio.
 *
 * \note In general, FLAC__StreamDecoder functions which change the
 * state should not be called on the \a decoder while in the callback.
 *
 * \param  decoder  The decoder instance calling the callback.
 * \param  frame    The description of the decoded frame.  See
 *                  FLAC__Frame.
 * \param  buffer   An array of pointers to decoded channels of data.
 *                  Each pointer will point to an array of signed
 *                  samples of length \a frame->header.blocksize.
 *                  Channels will be ordered according to the FLAC
 *                  specification; see the documentation for the
 *                  <A HREF="../format.html#frame_header">frame header</A>.
 * \param  client_data  The callee's client data set through
 *                      FLAC__stream_decoder_init_*().
 * \retval FLAC__StreamDecoderWriteStatus
 *    The callee's return status.
 */
typedef FLAC__StreamDecoderWriteStatus (*FLAC__StreamDecoderWriteCallback)(const FLAC__StreamDecoder *decoder, const FLAC__Frame *frame, const FLAC__int32 * const buffer[], void *client_data);

/** Signature for the metadata callback.
 *
 *  A function pointer matching this signature must be passed to one of
 *  the FLAC__stream_decoder_init_*() functions.
 *  The supplied function will be called when the decoder has decoded a
 *  metadata block.  In a valid FLAC file there will always be one
 *  \c STREAMINFO block, followed by zero or more other metadata blocks.
 *  These will be supplied by the decoder in the same order as they
 *  appear in the stream and always before the first audio frame (i.e.
 *  write callback).  The metadata block that is passed in must not be
 *  modified, and it doesn't live beyond the callback, so you should make
 *  a copy of it with FLAC__metadata_object_clone() if you will need it
 *  elsewhere.  Since metadata blocks can potentially be large, by
 *  default the decoder only calls the metadata callback for the
 *  \c STREAMINFO block; you can instruct the decoder to pass or filter
 *  other blocks with FLAC__stream_decoder_set_metadata_*() calls.
 *
 * \note In general, FLAC__StreamDecoder functions which change the
 * state should not be called on the \a decoder while in the callback.
 *
 * \param  decoder  The decoder instance calling the callback.
 * \param  metadata The decoded metadata block.
 * \param  client_data  The callee's client data set through
 *                      FLAC__stream_decoder_init_*().
 */
typedef void (*FLAC__StreamDecoderMetadataCallback)(const FLAC__StreamDecoder *decoder, const FLAC__StreamMetadata *metadata, void *client_data);

/** Signature for the error callback.
 *
 *  A function pointer matching this signature must be passed to one of
 *  the FLAC__stream_decoder_init_*() functions.
 *  The supplied function will be called whenever an error occurs during
 *  decoding.
 *
 * \note In general, FLAC__StreamDecoder functions which change the
 * state should not be called on the \a decoder while in the callback.
 *
 * \param  decoder  The decoder instance calling the callback.
 * \param  status   The error encountered by the decoder.
 * \param  client_data  The callee's client data set through
 *                      FLAC__stream_decoder_init_*().
 */
typedef void (*FLAC__StreamDecoderErrorCallback)(const FLAC__StreamDecoder *decoder, FLAC__StreamDecoderErrorStatus status, void *client_data);

/***********************************************************************
 *
 * Class constructor/destructor
 *
 ***********************************************************************/

/** Create a new stream decoder instance.  The instance is created with
 *  default settings; see the individual FLAC__stream_decoder_set_*()
 *  functions for each setting's default.
 *
 * \retval FLAC__StreamDecoder*
 *    \c NULL if there was an error allocating memory, else the new instance.
 */
FLAC_API FLAC__StreamDecoder *FLAC__stream_decoder_new(void);

/** Free a decoder instance.  Deletes the object pointed to by \a decoder.
 *
 * \param decoder  A pointer to an existing decoder.
 * \assert
 *    \code decoder != NULL \endcode
 */
FLAC_API void FLAC__stream_decoder_delete(FLAC__StreamDecoder *decoder);

/***********************************************************************
 *
 * Public class method prototypes
 *
 ***********************************************************************/

/** Set the serial number for the FLAC stream within the Ogg container.
 *  The default behavior is to use the serial number of the first Ogg
 *  page.  Setting a serial number here will explicitly specify which
 *  stream is to be decoded.
 *
 * \note
 * This does not need to be set for native FLAC decoding.
 *
 * \default \c use serial number of first page
 * \param  decoder        A decoder instance to set.
 * \param  serial_number  See above.
 * \assert
 *    \code decoder != NULL \endcode
 * \retval FLAC__bool
 *    \c false if the decoder is already initialized, else \c true.
 */
FLAC_API FLAC__bool FLAC__stream_decoder_set_ogg_serial_number(FLAC__StreamDecoder *decoder, long serial_number);

/** Set the "MD5 signature checking" flag.  If \c true, the decoder will
 *  compute the MD5 signature of the unencoded audio data while decoding
 *  and compare it to the signature from the STREAMINFO block, if it
 *  exists, during FLAC__stream_decoder_finish().
 *
 *  MD5 signature checking will be turned off (until the next
 *  FLAC__stream_decoder_reset()) if there is no signature in the
 *  STREAMINFO block or when a seek is attempted.
 *
 *  Clients that do not use the MD5 check should leave this off to speed
 *  up decoding.
 *
 * \default \c false
 * \param  decoder  A decoder instance to set.
 * \param  value    Flag value (see above).
 * \assert
 *    \code decoder != NULL \endcode
 * \retval FLAC__bool
 *    \c false if the decoder is already initialized, else \c true.
 */
FLAC_API FLAC__bool FLAC__stream_decoder_set_md5_checking(FLAC__StreamDecoder *decoder, FLAC__bool value);

/** Direct the decoder to pass on all metadata blocks of type \a type.
 *
 * \default By default, only the \c STREAMINFO block is returned via the
 *          metadata callback.
 * \param  decoder  A decoder instance to set.
 * \param  type     See above.
 * \assert
 *    \code decoder != NULL \endcode
 *    \a type is valid
 * \retval FLAC__bool
 *    \c false if the decoder is already initialized, else \c true.
 */
FLAC_API FLAC__bool FLAC__stream_decoder_set_metadata_respond(FLAC__StreamDecoder *decoder, FLAC__MetadataType type);

/** Direct the decoder to pass on all APPLICATION metadata blocks of the
 *  given \a id.
 *
 * \default By default, only the \c STREAMINFO block is returned via the
 *          metadata callback.
 * \param  decoder  A decoder instance to set.
 * \param  id       See above.
 * \assert
 *    \code decoder != NULL \endcode
 *    \code id != NULL \endcode
 * \retval FLAC__bool
 *    \c false if the decoder is already initialized, else \c true.
 */
FLAC_API FLAC__bool FLAC__stream_decoder_set_metadata_respond_application(FLAC__StreamDecoder *decoder, const FLAC__byte id[4]);

/** Direct the decoder to pass on all metadata blocks of any type.
 *
 * \default By default, only the \c STREAMINFO block is returned via the
 *          metadata callback.
 * \param  decoder  A decoder instance to set.
 * \assert
 *    \code decoder != NULL \endcode
 * \retval FLAC__bool
 *    \c false if the decoder is already initialized, else \c true.
 */
FLAC_API FLAC__bool FLAC__stream_decoder_set_metadata_respond_all(FLAC__StreamDecoder *decoder);

/** Direct the decoder to filter out all metadata blocks of type \a type.
 *
 * \default By default, only the \c STREAMINFO block is returned via the
 *          metadata callback.
 * \param  decoder  A decoder instance to set.
 * \param  type     See above.
 * \assert
 *    \code decoder != NULL \endcode
 *    \a type is valid
 * \retval FLAC__bool
 *    \c false if the decoder is already initialized, else \c true.
 */
FLAC_API FLAC__bool FLAC__stream_decoder_set_metadata_ignore(FLAC__StreamDecoder *decoder, FLAC__MetadataType type);

/** Direct the decoder to filter out all APPLICATION metadata blocks of
 *  the given \a id.
 *
 * \default By default, only the \c STREAMINFO block is returned via the
 *          metadata callback.
 * \param  decoder  A decoder instance to set.
 * \param  id       See above.
 * \assert
 *    \code decoder != NULL \endcode
 *    \code id != NULL \endcode
 * \retval FLAC__bool
 *    \c false if the decoder is already initialized, else \c true.
 */
FLAC_API FLAC__bool FLAC__stream_decoder_set_metadata_ignore_application(FLAC__StreamDecoder *decoder, const FLAC__byte id[4]);

/** Direct the decoder to filter out all metadata blocks of any type.
 *
 * \default By default, only the \c STREAMINFO block is returned via the
 *          metadata callback.
 * \param  decoder  A decoder instance to set.
 * \assert
 *    \code decoder != NULL \endcode
 * \retval FLAC__bool
 *    \c false if the decoder is already initialized, else \c true.
 */
FLAC_API FLAC__bool FLAC__stream_decoder_set_metadata_ignore_all(FLAC__StreamDecoder *decoder);

/** Get the current decoder state.
 *
 * \param  decoder  A decoder instance to query.
 * \assert
 *    \code decoder != NULL \endcode
 * \retval FLAC__StreamDecoderState
 *    The current decoder state.
 */
FLAC_API FLAC__StreamDecoderState FLAC__stream_decoder_get_state(const FLAC__StreamDecoder *decoder);

/** Get the current decoder state as a C string.
 *
 * \param  decoder  A decoder instance to query.
 * \assert
 *    \code decoder != NULL \endcode
 * \retval const char *
 *    The decoder state as a C string.  Do not modify the contents.
 */
FLAC_API const char *FLAC__stream_decoder_get_resolved_state_string(const FLAC__StreamDecoder *decoder);

/** Get the "MD5 signature checking" flag.
 *  This is the value of the setting, not whether or not the decoder is
 *  currently checking the MD5 (remember, it can be turned off automatically
 *  by a seek).  When the decoder is reset the flag will be restored to the
 *  value returned by this function.
 *
 * \param  decoder  A decoder instance to query.
 * \assert
 *    \code decoder != NULL \endcode
 * \retval FLAC__bool
 *    See above.
 */
FLAC_API FLAC__bool FLAC__stream_decoder_get_md5_checking(const FLAC__StreamDecoder *decoder);

/** Get the total number of samples in the stream being decoded.
 *  Will only be valid after decoding has started and will contain the
 *  value from the \c STREAMINFO block.  A value of \c 0 means "unknown".
 *
 * \param  decoder  A decoder instance to query.
 * \assert
 *    \code decoder != NULL \endcode
 * \retval unsigned
 *    See above.
 */
FLAC_API FLAC__uint64 FLAC__stream_decoder_get_total_samples(const FLAC__StreamDecoder *decoder);

/** Get the current number of channels in the stream being decoded.
 *  Will only be valid after decoding has started and will contain the
 *  value from the most recently decoded frame header.
 *
 * \param  decoder  A decoder instance to query.
 * \assert
 *    \code decoder != NULL \endcode
 * \retval unsigned
 *    See above.
 */
FLAC_API unsigned FLAC__stream_decoder_get_channels(const FLAC__StreamDecoder *decoder);

/** Get the current channel assignment in the stream being decoded.
 *  Will only be valid after decoding has started and will contain the
 *  value from the most recently decoded frame header.
 *
 * \param  decoder  A decoder instance to query.
 * \assert
 *    \code decoder != NULL \endcode
 * \retval FLAC__ChannelAssignment
 *    See above.
 */
FLAC_API FLAC__ChannelAssignment FLAC__stream_decoder_get_channel_assignment(const FLAC__StreamDecoder *decoder);

/** Get the current sample resolution in the stream being decoded.
 *  Will only be valid after decoding has started and will contain the
 *  value from the most recently decoded frame header.
 *
 * \param  decoder  A decoder instance to query.
 * \assert
 *    \code decoder != NULL \endcode
 * \retval unsigned
 *    See above.
 */
FLAC_API unsigned FLAC__stream_decoder_get_bits_per_sample(const FLAC__StreamDecoder *decoder);

/** Get the current sample rate in Hz of the stream being decoded.
 *  Will only be valid after decoding has started and will contain the
 *  value from the most recently decoded frame header.
 *
 * \param  decoder  A decoder instance to query.
 * \assert
 *    \code decoder != NULL \endcode
 * \retval unsigned
 *    See above.
 */
FLAC_API unsigned FLAC__stream_decoder_get_sample_rate(const FLAC__StreamDecoder *decoder);

/** Get the current blocksize of the stream being decoded.
 *  Will only be valid after decoding has started and will contain the
 *  value from the most recently decoded frame header.
 *
 * \param  decoder  A decoder instance to query.
 * \assert
 *    \code decoder != NULL \endcode
 * \retval unsigned
 *    See above.
 */
FLAC_API unsigned FLAC__stream_decoder_get_blocksize(const FLAC__StreamDecoder *decoder);

/** Returns the decoder's current read position within the stream.
 *  The position is the byte offset from the start of the stream.
 *  Bytes before this position have been fully decoded.  Note that
 *  there may still be undecoded bytes in the decoder's read FIFO.
 *  The returned position is correct even after a seek.
 *
 *  \warning This function currently only works for native FLAC,
 *           not Ogg FLAC streams.
 *
 * \param  decoder   A decoder instance to query.
 * \param  position  Address at which to return the desired position.
 * \assert
 *    \code decoder != NULL \endcode
 *    \code position != NULL \endcode
 * \retval FLAC__bool
 *    \c true if successful, \c false if the stream is not native FLAC,
 *    or there was an error from the 'tell' callback or it returned
 *    \c FLAC__STREAM_DECODER_TELL_STATUS_UNSUPPORTED.
 */
FLAC_API FLAC__bool FLAC__stream_decoder_get_decode_position(const FLAC__StreamDecoder *decoder, FLAC__uint64 *position);

/** Initialize the decoder instance to decode native FLAC streams.
 *
 *  This flavor of initialization sets up the decoder to decode from a
 *  native FLAC stream. I/O is performed via callbacks to the client.
 *  For decoding from a plain file via filename or open FILE*,
 *  FLAC__stream_decoder_init_file() and FLAC__stream_decoder_init_FILE()
 *  provide a simpler interface.
 *
 *  This function should be called after FLAC__stream_decoder_new() and
 *  FLAC__stream_decoder_set_*() but before any of the
 *  FLAC__stream_decoder_process_*() functions.  Will set and return the
 *  decoder state, which will be FLAC__STREAM_DECODER_SEARCH_FOR_METADATA
 *  if initialization succeeded.
 *
 * \param  decoder            An uninitialized decoder instance.
 * \param  read_callback      See FLAC__StreamDecoderReadCallback.  This
 *                            pointer must not be \c NULL.
 * \param  seek_callback      See FLAC__StreamDecoderSeekCallback.  This
 *                            pointer may be \c NULL if seeking is not
 *                            supported.  If \a seek_callback is not \c NULL then a
 *                            \a tell_callback, \a length_callback, and \a eof_callback must also be supplied.
 *                            Alternatively, a dummy seek callback that just
 *                            returns \c FLAC__STREAM_DECODER_SEEK_STATUS_UNSUPPORTED
 *                            may also be supplied, all though this is slightly
 *                            less efficient for the decoder.
 * \param  tell_callback      See FLAC__StreamDecoderTellCallback.  This
 *                            pointer may be \c NULL if not supported by the client.  If
 *                            \a seek_callback is not \c NULL then a
 *                            \a tell_callback must also be supplied.
 *                            Alternatively, a dummy tell callback that just
 *                            returns \c FLAC__STREAM_DECODER_TELL_STATUS_UNSUPPORTED
 *                            may also be supplied, all though this is slightly
 *                            less efficient for the decoder.
 * \param  length_callback    See FLAC__StreamDecoderLengthCallback.  This
 *                            pointer may be \c NULL if not supported by the client.  If
 *                            \a seek_callback is not \c NULL then a
 *                            \a length_callback must also be supplied.
 *                            Alternatively, a dummy length callback that just
 *                            returns \c FLAC__STREAM_DECODER_LENGTH_STATUS_UNSUPPORTED
 *                            may also be supplied, all though this is slightly
 *                            less efficient for the decoder.
 * \param  eof_callback       See FLAC__StreamDecoderEofCallback.  This
 *                            pointer may be \c NULL if not supported by the client.  If
 *                            \a seek_callback is not \c NULL then a
 *                            \a eof_callback must also be supplied.
 *                            Alternatively, a dummy length callback that just
 *                            returns \c false
 *                            may also be supplied, all though this is slightly
 *                            less efficient for the decoder.
 * \param  write_callback     See FLAC__StreamDecoderWriteCallback.  This
 *                            pointer must not be \c NULL.
 * \param  metadata_callback  See FLAC__StreamDecoderMetadataCallback.  This
 *                            pointer may be \c NULL if the callback is not
 *                            desired.
 * \param  error_callback     See FLAC__StreamDecoderErrorCallback.  This
 *                            pointer must not be \c NULL.
 * \param  client_data        This value will be supplied to callbacks in their
 *                            \a client_data argument.
 * \assert
 *    \code decoder != NULL \endcode
 * \retval FLAC__StreamDecoderInitStatus
 *    \c FLAC__STREAM_DECODER_INIT_STATUS_OK if initialization was successful;
 *    see FLAC__StreamDecoderInitStatus for the meanings of other return values.
 */
FLAC_API FLAC__StreamDecoderInitStatus FLAC__stream_decoder_init_stream(
	FLAC__StreamDecoder *decoder,
	FLAC__StreamDecoderReadCallback read_callback,
	FLAC__StreamDecoderSeekCallback seek_callback,
	FLAC__StreamDecoderTellCallback tell_callback,
	FLAC__StreamDecoderLengthCallback length_callback,
	FLAC__StreamDecoderEofCallback eof_callback,
	FLAC__StreamDecoderWriteCallback write_callback,
	FLAC__StreamDecoderMetadataCallback metadata_callback,
	FLAC__StreamDecoderErrorCallback error_callback,
	void *client_data
);

/** Initialize the decoder instance to decode Ogg FLAC streams.
 *
 *  This flavor of initialization sets up the decoder to decode from a
 *  FLAC stream in an Ogg container. I/O is performed via callbacks to the
 *  client.  For decoding from a plain file via filename or open FILE*,
 *  FLAC__stream_decoder_init_ogg_file() and FLAC__stream_decoder_init_ogg_FILE()
 *  provide a simpler interface.
 *
 *  This function should be called after FLAC__stream_decoder_new() and
 *  FLAC__stream_decoder_set_*() but before any of the
 *  FLAC__stream_decoder_process_*() functions.  Will set and return the
 *  decoder state, which will be FLAC__STREAM_DECODER_SEARCH_FOR_METADATA
 *  if initialization succeeded.
 *
 *  \note Support for Ogg FLAC in the library is optional.  If this
 *  library has been built without support for Ogg FLAC, this function
 *  will return \c FLAC__STREAM_DECODER_INIT_STATUS_UNSUPPORTED_CONTAINER.
 *
 * \param  decoder            An uninitialized decoder instance.
 * \param  read_callback      See FLAC__StreamDecoderReadCallback.  This
 *                            pointer must not be \c NULL.
 * \param  seek_callback      See FLAC__StreamDecoderSeekCallback.  This
 *                            pointer may be \c NULL if seeking is not
 *                            supported.  If \a seek_callback is not \c NULL then a
 *                            \a tell_callback, \a length_callback, and \a eof_callback must also be supplied.
 *                            Alternatively, a dummy seek callback that just
 *                            returns \c FLAC__STREAM_DECODER_SEEK_STATUS_UNSUPPORTED
 *                            may also be supplied, all though this is slightly
 *                            less efficient for the decoder.
 * \param  tell_callback      See FLAC__StreamDecoderTellCallback.  This
 *                            pointer may be \c NULL if not supported by the client.  If
 *                            \a seek_callback is not \c NULL then a
 *                            \a tell_callback must also be supplied.
 *                            Alternatively, a dummy tell callback that just
 *                            returns \c FLAC__STREAM_DECODER_TELL_STATUS_UNSUPPORTED
 *                            may also be supplied, all though this is slightly
 *                            less efficient for the decoder.
 * \param  length_callback    See FLAC__StreamDecoderLengthCallback.  This
 *                            pointer may be \c NULL if not supported by the client.  If
 *                            \a seek_callback is not \c NULL then a
 *                            \a length_callback must also be supplied.
 *                            Alternatively, a dummy length callback that just
 *                            returns \c FLAC__STREAM_DECODER_LENGTH_STATUS_UNSUPPORTED
 *                            may also be supplied, all though this is slightly
 *                            less efficient for the decoder.
 * \param  eof_callback       See FLAC__StreamDecoderEofCallback.  This
 *                            pointer may be \c NULL if not supported by the client.  If
 *                            \a seek_callback is not \c NULL then a
 *                            \a eof_callback must also be supplied.
 *                            Alternatively, a dummy length callback that just
 *                            returns \c false
 *                            may also be supplied, all though this is slightly
 *                            less efficient for the decoder.
 * \param  write_callback     See FLAC__StreamDecoderWriteCallback.  This
 *                            pointer must not be \c NULL.
 * \param  metadata_callback  See FLAC__StreamDecoderMetadataCallback.  This
 *                            pointer may be \c NULL if the callback is not
 *                            desired.
 * \param  error_callback     See FLAC__StreamDecoderErrorCallback.  This
 *                            pointer must not be \c NULL.
 * \param  client_data        This value will be supplied to callbacks in their
 *                            \a client_data argument.
 * \assert
 *    \code decoder != NULL \endcode
 * \retval FLAC__StreamDecoderInitStatus
 *    \c FLAC__STREAM_DECODER_INIT_STATUS_OK if initialization was successful;
 *    see FLAC__StreamDecoderInitStatus for the meanings of other return values.
 */
FLAC_API FLAC__StreamDecoderInitStatus FLAC__stream_decoder_init_ogg_stream(
	FLAC__StreamDecoder *decoder,
	FLAC__StreamDecoderReadCallback read_callback,
	FLAC__StreamDecoderSeekCallback seek_callback,
	FLAC__StreamDecoderTellCallback tell_callback,
	FLAC__StreamDecoderLengthCallback length_callback,
	FLAC__StreamDecoderEofCallback eof_callback,
	FLAC__StreamDecoderWriteCallback write_callback,
	FLAC__StreamDecoderMetadataCallback metadata_callback,
	FLAC__StreamDecoderErrorCallback error_callback,
	void *client_data
);

/** Initialize the decoder instance to decode native FLAC files.
 *
 *  This flavor of initialization sets up the decoder to decode from a
 *  plain native FLAC file.  For non-stdio streams, you must use
 *  FLAC__stream_decoder_init_stream() and provide callbacks for the I/O.
 *
 *  This function should be called after FLAC__stream_decoder_new() and
 *  FLAC__stream_decoder_set_*() but before any of the
 *  FLAC__stream_decoder_process_*() functions.  Will set and return the
 *  decoder state, which will be FLAC__STREAM_DECODER_SEARCH_FOR_METADATA
 *  if initialization succeeded.
 *
 * \param  decoder            An uninitialized decoder instance.
 * \param  file               An open FLAC file.  The file should have been
 *                            opened with mode \c "rb" and rewound.  The file
 *                            becomes owned by the decoder and should not be
 *                            manipulated by the client while decoding.
 *                            Unless \a file is \c stdin, it will be closed
 *                            when FLAC__stream_decoder_finish() is called.
 *                            Note however that seeking will not work when
 *                            decoding from \c stdout since it is not seekable.
 * \param  write_callback     See FLAC__StreamDecoderWriteCallback.  This
 *                            pointer must not be \c NULL.
 * \param  metadata_callback  See FLAC__StreamDecoderMetadataCallback.  This
 *                            pointer may be \c NULL if the callback is not
 *                            desired.
 * \param  error_callback     See FLAC__StreamDecoderErrorCallback.  This
 *                            pointer must not be \c NULL.
 * \param  client_data        This value will be supplied to callbacks in their
 *                            \a client_data argument.
 * \assert
 *    \code decoder != NULL \endcode
 *    \code file != NULL \endcode
 * \retval FLAC__StreamDecoderInitStatus
 *    \c FLAC__STREAM_DECODER_INIT_STATUS_OK if initialization was successful;
 *    see FLAC__StreamDecoderInitStatus for the meanings of other return values.
 */
FLAC_API FLAC__StreamDecoderInitStatus FLAC__stream_decoder_init_FILE(
	FLAC__StreamDecoder *decoder,
	FILE *file,
	FLAC__StreamDecoderWriteCallback write_callback,
	FLAC__StreamDecoderMetadataCallback metadata_callback,
	FLAC__StreamDecoderErrorCallback error_callback,
	void *client_data
);

/** Initialize the decoder instance to decode Ogg FLAC files.
 *
 *  This flavor of initialization sets up the decoder to decode from a
 *  plain Ogg FLAC file.  For non-stdio streams, you must use
 *  FLAC__stream_decoder_init_ogg_stream() and provide callbacks for the I/O.
 *
 *  This function should be called after FLAC__stream_decoder_new() and
 *  FLAC__stream_decoder_set_*() but before any of the
 *  FLAC__stream_decoder_process_*() functions.  Will set and return the
 *  decoder state, which will be FLAC__STREAM_DECODER_SEARCH_FOR_METADATA
 *  if initialization succeeded.
 *
 *  \note Support for Ogg FLAC in the library is optional.  If this
 *  library has been built without support for Ogg FLAC, this function
 *  will return \c FLAC__STREAM_DECODER_INIT_STATUS_UNSUPPORTED_CONTAINER.
 *
 * \param  decoder            An uninitialized decoder instance.
 * \param  file               An open FLAC file.  The file should have been
 *                            opened with mode \c "rb" and rewound.  The file
 *                            becomes owned by the decoder and should not be
 *                            manipulated by the client while decoding.
 *                            Unless \a file is \c stdin, it will be closed
 *                            when FLAC__stream_decoder_finish() is called.
 *                            Note however that seeking will not work when
 *                            decoding from \c stdout since it is not seekable.
 * \param  write_callback     See FLAC__StreamDecoderWriteCallback.  This
 *                            pointer must not be \c NULL.
 * \param  metadata_callback  See FLAC__StreamDecoderMetadataCallback.  This
 *                            pointer may be \c NULL if the callback is not
 *                            desired.
 * \param  error_callback     See FLAC__StreamDecoderErrorCallback.  This
 *                            pointer must not be \c NULL.
 * \param  client_data        This value will be supplied to callbacks in their
 *                            \a client_data argument.
 * \assert
 *    \code decoder != NULL \endcode
 *    \code file != NULL \endcode
 * \retval FLAC__StreamDecoderInitStatus
 *    \c FLAC__STREAM_DECODER_INIT_STATUS_OK if initialization was successful;
 *    see FLAC__StreamDecoderInitStatus for the meanings of other return values.
 */
FLAC_API FLAC__StreamDecoderInitStatus FLAC__stream_decoder_init_ogg_FILE(
	FLAC__StreamDecoder *decoder,
	FILE *file,
	FLAC__StreamDecoderWriteCallback write_callback,
	FLAC__StreamDecoderMetadataCallback metadata_callback,
	FLAC__StreamDecoderErrorCallback error_callback,
	void *client_data
);

/** Initialize the decoder instance to decode native FLAC files.
 *
 *  This flavor of initialization sets up the decoder to decode from a plain
 *  native FLAC file.  If POSIX fopen() semantics are not sufficient, (for
 *  example, with Unicode filenames on Windows), you must use
 *  FLAC__stream_decoder_init_FILE(), or FLAC__stream_decoder_init_stream()
 *  and provide callbacks for the I/O.
 *
 *  This function should be called after FLAC__stream_decoder_new() and
 *  FLAC__stream_decoder_set_*() but before any of the
 *  FLAC__stream_decoder_process_*() functions.  Will set and return the
 *  decoder state, which will be FLAC__STREAM_DECODER_SEARCH_FOR_METADATA
 *  if initialization succeeded.
 *
 * \param  decoder            An uninitialized decoder instance.
 * \param  filename           The name of the file to decode from.  The file will
 *                            be opened with fopen().  Use \c NULL to decode from
 *                            \c stdin.  Note that \c stdin is not seekable.
 * \param  write_callback     See FLAC__StreamDecoderWriteCallback.  This
 *                            pointer must not be \c NULL.
 * \param  metadata_callback  See FLAC__StreamDecoderMetadataCallback.  This
 *                            pointer may be \c NULL if the callback is not
 *                            desired.
 * \param  error_callback     See FLAC__StreamDecoderErrorCallback.  This
 *                            pointer must not be \c NULL.
 * \param  client_data        This value will be supplied to callbacks in their
 *                            \a client_data argument.
 * \assert
 *    \code decoder != NULL \endcode
 * \retval FLAC__StreamDecoderInitStatus
 *    \c FLAC__STREAM_DECODER_INIT_STATUS_OK if initialization was successful;
 *    see FLAC__StreamDecoderInitStatus for the meanings of other return values.
 */
FLAC_API FLAC__StreamDecoderInitStatus FLAC__stream_decoder_init_file(
	FLAC__StreamDecoder *decoder,
	const char *filename,
	FLAC__StreamDecoderWriteCallback write_callback,
	FLAC__StreamDecoderMetadataCallback metadata_callback,
	FLAC__StreamDecoderErrorCallback error_callback,
	void *client_data
);

/** Initialize the decoder instance to decode Ogg FLAC files.
 *
 *  This flavor of initialization sets up the decoder to decode from a plain
 *  Ogg FLAC file.  If POSIX fopen() semantics are not sufficient, (for
 *  example, with Unicode filenames on Windows), you must use
 *  FLAC__stream_decoder_init_ogg_FILE(), or FLAC__stream_decoder_init_ogg_stream()
 *  and provide callbacks for the I/O.
 *
 *  This function should be called after FLAC__stream_decoder_new() and
 *  FLAC__stream_decoder_set_*() but before any of the
 *  FLAC__stream_decoder_process_*() functions.  Will set and return the
 *  decoder state, which will be FLAC__STREAM_DECODER_SEARCH_FOR_METADATA
 *  if initialization succeeded.
 *
 *  \note Support for Ogg FLAC in the library is optional.  If this
 *  library has been built without support for Ogg FLAC, this function
 *  will return \c FLAC__STREAM_DECODER_INIT_STATUS_UNSUPPORTED_CONTAINER.
 *
 * \param  decoder            An uninitialized decoder instance.
 * \param  filename           The name of the file to decode from.  The file will
 *                            be opened with fopen().  Use \c NULL to decode from
 *                            \c stdin.  Note that \c stdin is not seekable.
 * \param  write_callback     See FLAC__StreamDecoderWriteCallback.  This
 *                            pointer must not be \c NULL.
 * \param  metadata_callback  See FLAC__StreamDecoderMetadataCallback.  This
 *                            pointer may be \c NULL if the callback is not
 *                            desired.
 * \param  error_callback     See FLAC__StreamDecoderErrorCallback.  This
 *                            pointer must not be \c NULL.
 * \param  client_data        This value will be supplied to callbacks in their
 *                            \a client_data argument.
 * \assert
 *    \code decoder != NULL \endcode
 * \retval FLAC__StreamDecoderInitStatus
 *    \c FLAC__STREAM_DECODER_INIT_STATUS_OK if initialization was successful;
 *    see FLAC__StreamDecoderInitStatus for the meanings of other return values.
 */
FLAC_API FLAC__StreamDecoderInitStatus FLAC__stream_decoder_init_ogg_file(
	FLAC__StreamDecoder *decoder,
	const char *filename,
	FLAC__StreamDecoderWriteCallback write_callback,
	FLAC__StreamDecoderMetadataCallback metadata_callback,
	FLAC__StreamDecoderErrorCallback error_callback,
	void *client_data
);

/** Finish the decoding process.
 *  Flushes the decoding buffer, releases resources, resets the decoder
 *  settings to their defaults, and returns the decoder state to
 *  FLAC__STREAM_DECODER_UNINITIALIZED.
 *
 *  In the event of a prematurely-terminated decode, it is not strictly
 *  necessary to call this immediately before FLAC__stream_decoder_delete()
 *  but it is good practice to match every FLAC__stream_decoder_init_*()
 *  with a FLAC__stream_decoder_finish().
 *
 * \param  decoder  An uninitialized decoder instance.
 * \assert
 *    \code decoder != NULL \endcode
 * \retval FLAC__bool
 *    \c false if MD5 checking is on AND a STREAMINFO block was available
 *    AND the MD5 signature in the STREAMINFO block was non-zero AND the
 *    signature does not match the one computed by the decoder; else
 *    \c true.
 */
FLAC_API FLAC__bool FLAC__stream_decoder_finish(FLAC__StreamDecoder *decoder);

/** Flush the stream input.
 *  The decoder's input buffer will be cleared and the state set to
 *  \c FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC.  This will also turn
 *  off MD5 checking.
 *
 * \param  decoder  A decoder instance.
 * \assert
 *    \code decoder != NULL \endcode
 * \retval FLAC__bool
 *    \c true if successful, else \c false if a memory allocation
 *    error occurs (in which case the state will be set to
 *    \c FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR).
 */
FLAC_API FLAC__bool FLAC__stream_decoder_flush(FLAC__StreamDecoder *decoder);

/** Reset the decoding process.
 *  The decoder's input buffer will be cleared and the state set to
 *  \c FLAC__STREAM_DECODER_SEARCH_FOR_METADATA.  This is similar to
 *  FLAC__stream_decoder_finish() except that the settings are
 *  preserved; there is no need to call FLAC__stream_decoder_init_*()
 *  before decoding again.  MD5 checking will be restored to its original
 *  setting.
 *
 *  If the decoder is seekable, or was initialized with
 *  FLAC__stream_decoder_init*_FILE() or FLAC__stream_decoder_init*_file(),
 *  the decoder will also attempt to seek to the beginning of the file.
 *  If this rewind fails, this function will return \c false.  It follows
 *  that FLAC__stream_decoder_reset() cannot be used when decoding from
 *  \c stdin.
 *
 *  If the decoder was initialized with FLAC__stream_encoder_init*_stream()
 *  and is not seekable (i.e. no seek callback was provided or the seek
 *  callback returns \c FLAC__STREAM_DECODER_SEEK_STATUS_UNSUPPORTED), it
 *  is the duty of the client to start feeding data from the beginning of
 *  the stream on the next FLAC__stream_decoder_process() or
 *  FLAC__stream_decoder_process_interleaved() call.
 *
 * \param  decoder  A decoder instance.
 * \assert
 *    \code decoder != NULL \endcode
 * \retval FLAC__bool
 *    \c true if successful, else \c false if a memory allocation occurs
 *    (in which case the state will be set to
 *    \c FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR) or a seek error
 *    occurs (the state will be unchanged).
 */
FLAC_API FLAC__bool FLAC__stream_decoder_reset(FLAC__StreamDecoder *decoder);

/** Decode one metadata block or audio frame.
 *  This version instructs the decoder to decode a either a single metadata
 *  block or a single frame and stop, unless the callbacks return a fatal
 *  error or the read callback returns
 *  \c FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM.
 *
 *  As the decoder needs more input it will call the read callback.
 *  Depending on what was decoded, the metadata or write callback will be
 *  called with the decoded metadata block or audio frame.
 *
 *  Unless there is a fatal read error or end of stream, this function
 *  will return once one whole frame is decoded.  In other words, if the
 *  stream is not synchronized or points to a corrupt frame header, the
 *  decoder will continue to try and resync until it gets to a valid
 *  frame, then decode one frame, then return.  If the decoder points to
 *  a frame whose frame CRC in the frame footer does not match the
 *  computed frame CRC, this function will issue a
 *  FLAC__STREAM_DECODER_ERROR_STATUS_FRAME_CRC_MISMATCH error to the
 *  error callback, and return, having decoded one complete, although
 *  corrupt, frame.  (Such corrupted frames are sent as silence of the
 *  correct length to the write callback.)
 *
 * \param  decoder  An initialized decoder instance.
 * \assert
 *    \code decoder != NULL \endcode
 * \retval FLAC__bool
 *    \c false if any fatal read, write, or memory allocation error
 *    occurred (meaning decoding must stop), else \c true; for more
 *    information about the decoder, check the decoder state with
 *    FLAC__stream_decoder_get_state().
 */
FLAC_API FLAC__bool FLAC__stream_decoder_process_single(FLAC__StreamDecoder *decoder);

/** Decode until the end of the metadata.
 *  This version instructs the decoder to decode from the current position
 *  and continue until all the metadata has been read, or until the
 *  callbacks return a fatal error or the read callback returns
 *  \c FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM.
 *
 *  As the decoder needs more input it will call the read callback.
 *  As each metadata block is decoded, the metadata callback will be called
 *  with the decoded metadata.
 *
 * \param  decoder  An initialized decoder instance.
 * \assert
 *    \code decoder != NULL \endcode
 * \retval FLAC__bool
 *    \c false if any fatal read, write, or memory allocation error
 *    occurred (meaning decoding must stop), else \c true; for more
 *    information about the decoder, check the decoder state with
 *    FLAC__stream_decoder_get_state().
 */
FLAC_API FLAC__bool FLAC__stream_decoder_process_until_end_of_metadata(FLAC__StreamDecoder *decoder);

/** Decode until the end of the stream.
 *  This version instructs the decoder to decode from the current position
 *  and continue until the end of stream (the read callback returns
 *  \c FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM), or until the
 *  callbacks return a fatal error.
 *
 *  As the decoder needs more input it will call the read callback.
 *  As each metadata block and frame is decoded, the metadata or write
 *  callback will be called with the decoded metadata or frame.
 *
 * \param  decoder  An initialized decoder instance.
 * \assert
 *    \code decoder != NULL \endcode
 * \retval FLAC__bool
 *    \c false if any fatal read, write, or memory allocation error
 *    occurred (meaning decoding must stop), else \c true; for more
 *    information about the decoder, check the decoder state with
 *    FLAC__stream_decoder_get_state().
 */
FLAC_API FLAC__bool FLAC__stream_decoder_process_until_end_of_stream(FLAC__StreamDecoder *decoder);

/** Skip one audio frame.
 *  This version instructs the decoder to 'skip' a single frame and stop,
 *  unless the callbacks return a fatal error or the read callback returns
 *  \c FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM.
 *
 *  The decoding flow is the same as what occurs when
 *  FLAC__stream_decoder_process_single() is called to process an audio
 *  frame, except that this function does not decode the parsed data into
 *  PCM or call the write callback.  The integrity of the frame is still
 *  checked the same way as in the other process functions.
 *
 *  This function will return once one whole frame is skipped, in the
 *  same way that FLAC__stream_decoder_process_single() will return once
 *  one whole frame is decoded.
 *
 *  This function can be used in more quickly determining FLAC frame
 *  boundaries when decoding of the actual data is not needed, for
 *  example when an application is separating a FLAC stream into frames
 *  for editing or storing in a container.  To do this, the application
 *  can use FLAC__stream_decoder_skip_single_frame() to quickly advance
 *  to the next frame, then use
 *  FLAC__stream_decoder_get_decode_position() to find the new frame
 *  boundary.
 *
 *  This function should only be called when the stream has advanced
 *  past all the metadata, otherwise it will return \c false.
 *
 * \param  decoder  An initialized decoder instance not in a metadata
 *                  state.
 * \assert
 *    \code decoder != NULL \endcode
 * \retval FLAC__bool
 *    \c false if any fatal read, write, or memory allocation error
 *    occurred (meaning decoding must stop), or if the decoder
 *    is in the FLAC__STREAM_DECODER_SEARCH_FOR_METADATA or
 *    FLAC__STREAM_DECODER_READ_METADATA state, else \c true; for more
 *    information about the decoder, check the decoder state with
 *    FLAC__stream_decoder_get_state().
 */
FLAC_API FLAC__bool FLAC__stream_decoder_skip_single_frame(FLAC__StreamDecoder *decoder);

/** Flush the input and seek to an absolute sample.
 *  Decoding will resume at the given sample.  Note that because of
 *  this, the next write callback may contain a partial block.  The
 *  client must support seeking the input or this function will fail
 *  and return \c false.  Furthermore, if the decoder state is
 *  \c FLAC__STREAM_DECODER_SEEK_ERROR, then the decoder must be flushed
 *  with FLAC__stream_decoder_flush() or reset with
 *  FLAC__stream_decoder_reset() before decoding can continue.
 *
 * \param  decoder  A decoder instance.
 * \param  sample   The target sample number to seek to.
 * \assert
 *    \code decoder != NULL \endcode
 * \retval FLAC__bool
 *    \c true if successful, else \c false.
 */
FLAC_API FLAC__bool FLAC__stream_decoder_seek_absolute(FLAC__StreamDecoder *decoder, FLAC__uint64 sample);

/* \} */

#ifdef __cplusplus
}
#endif

#endif

/*** End of inlined file: stream_decoder.h ***/


/*** Start of inlined file: stream_encoder.h ***/
#ifndef FLAC__STREAM_ENCODER_H
#define FLAC__STREAM_ENCODER_H

#include <stdio.h> /* for FILE */

#ifdef __cplusplus
extern "C" {
#endif

/** \file include/FLAC/stream_encoder.h
 *
 *  \brief
 *  This module contains the functions which implement the stream
 *  encoder.
 *
 *  See the detailed documentation in the
 *  \link flac_stream_encoder stream encoder \endlink module.
 */

/** \defgroup flac_encoder FLAC/ \*_encoder.h: encoder interfaces
 *  \ingroup flac
 *
 *  \brief
 *  This module describes the encoder layers provided by libFLAC.
 *
 * The stream encoder can be used to encode complete streams either to the
 * client via callbacks, or directly to a file, depending on how it is
 * initialized.  When encoding via callbacks, the client provides a write
 * callback which will be called whenever FLAC data is ready to be written.
 * If the client also supplies a seek callback, the encoder will also
 * automatically handle the writing back of metadata discovered while
 * encoding, like stream info, seek points offsets, etc.  When encoding to
 * a file, the client needs only supply a filename or open \c FILE* and an
 * optional progress callback for periodic notification of progress; the
 * write and seek callbacks are supplied internally.  For more info see the
 * \link flac_stream_encoder stream encoder \endlink module.
 */

/** \defgroup flac_stream_encoder FLAC/stream_encoder.h: stream encoder interface
 *  \ingroup flac_encoder
 *
 *  \brief
 *  This module contains the functions which implement the stream
 *  encoder.
 *
 * The stream encoder can encode to native FLAC, and optionally Ogg FLAC
 * (check FLAC_API_SUPPORTS_OGG_FLAC) streams and files.
 *
 * The basic usage of this encoder is as follows:
 * - The program creates an instance of an encoder using
 *   FLAC__stream_encoder_new().
 * - The program overrides the default settings using
 *   FLAC__stream_encoder_set_*() functions.  At a minimum, the following
 *   functions should be called:
 *   - FLAC__stream_encoder_set_channels()
 *   - FLAC__stream_encoder_set_bits_per_sample()
 *   - FLAC__stream_encoder_set_sample_rate()
 *   - FLAC__stream_encoder_set_ogg_serial_number() (if encoding to Ogg FLAC)
 *   - FLAC__stream_encoder_set_total_samples_estimate() (if known)
 * - If the application wants to control the compression level or set its own
 *   metadata, then the following should also be called:
 *   - FLAC__stream_encoder_set_compression_level()
 *   - FLAC__stream_encoder_set_verify()
 *   - FLAC__stream_encoder_set_metadata()
 * - The rest of the set functions should only be called if the client needs
 *   exact control over how the audio is compressed; thorough understanding
 *   of the FLAC format is necessary to achieve good results.
 * - The program initializes the instance to validate the settings and
 *   prepare for encoding using
 *   - FLAC__stream_encoder_init_stream() or FLAC__stream_encoder_init_FILE()
 *     or FLAC__stream_encoder_init_file() for native FLAC
 *   - FLAC__stream_encoder_init_ogg_stream() or FLAC__stream_encoder_init_ogg_FILE()
 *     or FLAC__stream_encoder_init_ogg_file() for Ogg FLAC
 * - The program calls FLAC__stream_encoder_process() or
 *   FLAC__stream_encoder_process_interleaved() to encode data, which
 *   subsequently calls the callbacks when there is encoder data ready
 *   to be written.
 * - The program finishes the encoding with FLAC__stream_encoder_finish(),
 *   which causes the encoder to encode any data still in its input pipe,
 *   update the metadata with the final encoding statistics if output
 *   seeking is possible, and finally reset the encoder to the
 *   uninitialized state.
 * - The instance may be used again or deleted with
 *   FLAC__stream_encoder_delete().
 *
 * In more detail, the stream encoder functions similarly to the
 * \link flac_stream_decoder stream decoder \endlink, but has fewer
 * callbacks and more options.  Typically the client will create a new
 * instance by calling FLAC__stream_encoder_new(), then set the necessary
 * parameters with FLAC__stream_encoder_set_*(), and initialize it by
 * calling one of the FLAC__stream_encoder_init_*() functions.
 *
 * Unlike the decoders, the stream encoder has many options that can
 * affect the speed and compression ratio.  When setting these parameters
 * you should have some basic knowledge of the format (see the
 * <A HREF="../documentation.html#format">user-level documentation</A>
 * or the <A HREF="../format.html">formal description</A>).  The
 * FLAC__stream_encoder_set_*() functions themselves do not validate the
 * values as many are interdependent.  The FLAC__stream_encoder_init_*()
 * functions will do this, so make sure to pay attention to the state
 * returned by FLAC__stream_encoder_init_*() to make sure that it is
 * FLAC__STREAM_ENCODER_INIT_STATUS_OK.  Any parameters that are not set
 * before FLAC__stream_encoder_init_*() will take on the defaults from
 * the constructor.
 *
 * There are three initialization functions for native FLAC, one for
 * setting up the encoder to encode FLAC data to the client via
 * callbacks, and two for encoding directly to a file.
 *
 * For encoding via callbacks, use FLAC__stream_encoder_init_stream().
 * You must also supply a write callback which will be called anytime
 * there is raw encoded data to write.  If the client can seek the output
 * it is best to also supply seek and tell callbacks, as this allows the
 * encoder to go back after encoding is finished to write back
 * information that was collected while encoding, like seek point offsets,
 * frame sizes, etc.
 *
 * For encoding directly to a file, use FLAC__stream_encoder_init_FILE()
 * or FLAC__stream_encoder_init_file().  Then you must only supply a
 * filename or open \c FILE*; the encoder will handle all the callbacks
 * internally.  You may also supply a progress callback for periodic
 * notification of the encoding progress.
 *
 * There are three similarly-named init functions for encoding to Ogg
 * FLAC streams.  Check \c FLAC_API_SUPPORTS_OGG_FLAC to find out if the
 * library has been built with Ogg support.
 *
 * The call to FLAC__stream_encoder_init_*() currently will also immediately
 * call the write callback several times, once with the \c fLaC signature,
 * and once for each encoded metadata block.  Note that for Ogg FLAC
 * encoding you will usually get at least twice the number of callbacks than
 * with native FLAC, one for the Ogg page header and one for the page body.
 *
 * After initializing the instance, the client may feed audio data to the
 * encoder in one of two ways:
 *
 * - Channel separate, through FLAC__stream_encoder_process() - The client
 *   will pass an array of pointers to buffers, one for each channel, to
 *   the encoder, each of the same length.  The samples need not be
 *   block-aligned, but each channel should have the same number of samples.
 * - Channel interleaved, through
 *   FLAC__stream_encoder_process_interleaved() - The client will pass a single
 *   pointer to data that is channel-interleaved (i.e. channel0_sample0,
 *   channel1_sample0, ... , channelN_sample0, channel0_sample1, ...).
 *   Again, the samples need not be block-aligned but they must be
 *   sample-aligned, i.e. the first value should be channel0_sample0 and
 *   the last value channelN_sampleM.
 *
 * Note that for either process call, each sample in the buffers should be a
 * signed integer, right-justified to the resolution set by
 * FLAC__stream_encoder_set_bits_per_sample().  For example, if the resolution
 * is 16 bits per sample, the samples should all be in the range [-32768,32767].
 *
 * When the client is finished encoding data, it calls
 * FLAC__stream_encoder_finish(), which causes the encoder to encode any
 * data still in its input pipe, and call the metadata callback with the
 * final encoding statistics.  Then the instance may be deleted with
 * FLAC__stream_encoder_delete() or initialized again to encode another
 * stream.
 *
 * For programs that write their own metadata, but that do not know the
 * actual metadata until after encoding, it is advantageous to instruct
 * the encoder to write a PADDING block of the correct size, so that
 * instead of rewriting the whole stream after encoding, the program can
 * just overwrite the PADDING block.  If only the maximum size of the
 * metadata is known, the program can write a slightly larger padding
 * block, then split it after encoding.
 *
 * Make sure you understand how lengths are calculated.  All FLAC metadata
 * blocks have a 4 byte header which contains the type and length.  This
 * length does not include the 4 bytes of the header.  See the format page
 * for the specification of metadata blocks and their lengths.
 *
 * \note
 * If you are writing the FLAC data to a file via callbacks, make sure it
 * is open for update (e.g. mode "w+" for stdio streams).  This is because
 * after the first encoding pass, the encoder will try to seek back to the
 * beginning of the stream, to the STREAMINFO block, to write some data
 * there.  (If using FLAC__stream_encoder_init*_file() or
 * FLAC__stream_encoder_init*_FILE(), the file is managed internally.)
 *
 * \note
 * The "set" functions may only be called when the encoder is in the
 * state FLAC__STREAM_ENCODER_UNINITIALIZED, i.e. after
 * FLAC__stream_encoder_new() or FLAC__stream_encoder_finish(), but
 * before FLAC__stream_encoder_init_*().  If this is the case they will
 * return \c true, otherwise \c false.
 *
 * \note
 * FLAC__stream_encoder_finish() resets all settings to the constructor
 * defaults.
 *
 * \{
 */

/** State values for a FLAC__StreamEncoder.
 *
 * The encoder's state can be obtained by calling FLAC__stream_encoder_get_state().
 *
 * If the encoder gets into any other state besides \c FLAC__STREAM_ENCODER_OK
 * or \c FLAC__STREAM_ENCODER_UNINITIALIZED, it becomes invalid for encoding and
 * must be deleted with FLAC__stream_encoder_delete().
 */
typedef enum {

	FLAC__STREAM_ENCODER_OK = 0,
	/**< The encoder is in the normal OK state and samples can be processed. */

	FLAC__STREAM_ENCODER_UNINITIALIZED,
	/**< The encoder is in the uninitialized state; one of the
	 * FLAC__stream_encoder_init_*() functions must be called before samples
	 * can be processed.
	 */

	FLAC__STREAM_ENCODER_OGG_ERROR,
	/**< An error occurred in the underlying Ogg layer.  */

	FLAC__STREAM_ENCODER_VERIFY_DECODER_ERROR,
	/**< An error occurred in the underlying verify stream decoder;
	 * check FLAC__stream_encoder_get_verify_decoder_state().
	 */

	FLAC__STREAM_ENCODER_VERIFY_MISMATCH_IN_AUDIO_DATA,
	/**< The verify decoder detected a mismatch between the original
	 * audio signal and the decoded audio signal.
	 */

	FLAC__STREAM_ENCODER_CLIENT_ERROR,
	/**< One of the callbacks returned a fatal error. */

	FLAC__STREAM_ENCODER_IO_ERROR,
	/**< An I/O error occurred while opening/reading/writing a file.
	 * Check \c errno.
	 */

	FLAC__STREAM_ENCODER_FRAMING_ERROR,
	/**< An error occurred while writing the stream; usually, the
	 * write_callback returned an error.
	 */

	FLAC__STREAM_ENCODER_MEMORY_ALLOCATION_ERROR
	/**< Memory allocation failed. */

} FLAC__StreamEncoderState;

/** Maps a FLAC__StreamEncoderState to a C string.
 *
 *  Using a FLAC__StreamEncoderState as the index to this array
 *  will give the string equivalent.  The contents should not be modified.
 */
extern FLAC_API const char * const FLAC__StreamEncoderStateString[];

/** Possible return values for the FLAC__stream_encoder_init_*() functions.
 */
typedef enum {

	FLAC__STREAM_ENCODER_INIT_STATUS_OK = 0,
	/**< Initialization was successful. */

	FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR,
	/**< General failure to set up encoder; call FLAC__stream_encoder_get_state() for cause. */

	FLAC__STREAM_ENCODER_INIT_STATUS_UNSUPPORTED_CONTAINER,
	/**< The library was not compiled with support for the given container
	 * format.
	 */

	FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_CALLBACKS,
	/**< A required callback was not supplied. */

	FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_NUMBER_OF_CHANNELS,
	/**< The encoder has an invalid setting for number of channels. */

	FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_BITS_PER_SAMPLE,
	/**< The encoder has an invalid setting for bits-per-sample.
	 * FLAC supports 4-32 bps but the reference encoder currently supports
	 * only up to 24 bps.
	 */

	FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_SAMPLE_RATE,
	/**< The encoder has an invalid setting for the input sample rate. */

	FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_BLOCK_SIZE,
	/**< The encoder has an invalid setting for the block size. */

	FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_MAX_LPC_ORDER,
	/**< The encoder has an invalid setting for the maximum LPC order. */

	FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_QLP_COEFF_PRECISION,
	/**< The encoder has an invalid setting for the precision of the quantized linear predictor coefficients. */

	FLAC__STREAM_ENCODER_INIT_STATUS_BLOCK_SIZE_TOO_SMALL_FOR_LPC_ORDER,
	/**< The specified block size is less than the maximum LPC order. */

	FLAC__STREAM_ENCODER_INIT_STATUS_NOT_STREAMABLE,
	/**< The encoder is bound to the <A HREF="../format.html#subset">Subset</A> but other settings violate it. */

	FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_METADATA,
	/**< The metadata input to the encoder is invalid, in one of the following ways:
	 * - FLAC__stream_encoder_set_metadata() was called with a null pointer but a block count > 0
	 * - One of the metadata blocks contains an undefined type
	 * - It contains an illegal CUESHEET as checked by FLAC__format_cuesheet_is_legal()
	 * - It contains an illegal SEEKTABLE as checked by FLAC__format_seektable_is_legal()
	 * - It contains more than one SEEKTABLE block or more than one VORBIS_COMMENT block
	 */

	FLAC__STREAM_ENCODER_INIT_STATUS_ALREADY_INITIALIZED
	/**< FLAC__stream_encoder_init_*() was called when the encoder was
	 * already initialized, usually because
	 * FLAC__stream_encoder_finish() was not called.
	 */

} FLAC__StreamEncoderInitStatus;

/** Maps a FLAC__StreamEncoderInitStatus to a C string.
 *
 *  Using a FLAC__StreamEncoderInitStatus as the index to this array
 *  will give the string equivalent.  The contents should not be modified.
 */
extern FLAC_API const char * const FLAC__StreamEncoderInitStatusString[];

/** Return values for the FLAC__StreamEncoder read callback.
 */
typedef enum {

	FLAC__STREAM_ENCODER_READ_STATUS_CONTINUE,
	/**< The read was OK and decoding can continue. */

	FLAC__STREAM_ENCODER_READ_STATUS_END_OF_STREAM,
	/**< The read was attempted at the end of the stream. */

	FLAC__STREAM_ENCODER_READ_STATUS_ABORT,
	/**< An unrecoverable error occurred. */

	FLAC__STREAM_ENCODER_READ_STATUS_UNSUPPORTED
	/**< Client does not support reading back from the output. */

} FLAC__StreamEncoderReadStatus;

/** Maps a FLAC__StreamEncoderReadStatus to a C string.
 *
 *  Using a FLAC__StreamEncoderReadStatus as the index to this array
 *  will give the string equivalent.  The contents should not be modified.
 */
extern FLAC_API const char * const FLAC__StreamEncoderReadStatusString[];

/** Return values for the FLAC__StreamEncoder write callback.
 */
typedef enum {

	FLAC__STREAM_ENCODER_WRITE_STATUS_OK = 0,
	/**< The write was OK and encoding can continue. */

	FLAC__STREAM_ENCODER_WRITE_STATUS_FATAL_ERROR
	/**< An unrecoverable error occurred.  The encoder will return from the process call. */

} FLAC__StreamEncoderWriteStatus;

/** Maps a FLAC__StreamEncoderWriteStatus to a C string.
 *
 *  Using a FLAC__StreamEncoderWriteStatus as the index to this array
 *  will give the string equivalent.  The contents should not be modified.
 */
extern FLAC_API const char * const FLAC__StreamEncoderWriteStatusString[];

/** Return values for the FLAC__StreamEncoder seek callback.
 */
typedef enum {

	FLAC__STREAM_ENCODER_SEEK_STATUS_OK,
	/**< The seek was OK and encoding can continue. */

	FLAC__STREAM_ENCODER_SEEK_STATUS_ERROR,
	/**< An unrecoverable error occurred. */

	FLAC__STREAM_ENCODER_SEEK_STATUS_UNSUPPORTED
	/**< Client does not support seeking. */

} FLAC__StreamEncoderSeekStatus;

/** Maps a FLAC__StreamEncoderSeekStatus to a C string.
 *
 *  Using a FLAC__StreamEncoderSeekStatus as the index to this array
 *  will give the string equivalent.  The contents should not be modified.
 */
extern FLAC_API const char * const FLAC__StreamEncoderSeekStatusString[];

/** Return values for the FLAC__StreamEncoder tell callback.
 */
typedef enum {

	FLAC__STREAM_ENCODER_TELL_STATUS_OK,
	/**< The tell was OK and encoding can continue. */

	FLAC__STREAM_ENCODER_TELL_STATUS_ERROR,
	/**< An unrecoverable error occurred. */

	FLAC__STREAM_ENCODER_TELL_STATUS_UNSUPPORTED
	/**< Client does not support seeking. */

} FLAC__StreamEncoderTellStatus;

/** Maps a FLAC__StreamEncoderTellStatus to a C string.
 *
 *  Using a FLAC__StreamEncoderTellStatus as the index to this array
 *  will give the string equivalent.  The contents should not be modified.
 */
extern FLAC_API const char * const FLAC__StreamEncoderTellStatusString[];

/***********************************************************************
 *
 * class FLAC__StreamEncoder
 *
 ***********************************************************************/

struct FLAC__StreamEncoderProtected;
struct FLAC__StreamEncoderPrivate;
/** The opaque structure definition for the stream encoder type.
 *  See the \link flac_stream_encoder stream encoder module \endlink
 *  for a detailed description.
 */
typedef struct {
	struct FLAC__StreamEncoderProtected *protected_; /* avoid the C++ keyword 'protected' */
	struct FLAC__StreamEncoderPrivate *private_; /* avoid the C++ keyword 'private' */
} FLAC__StreamEncoder;

/** Signature for the read callback.
 *
 *  A function pointer matching this signature must be passed to
 *  FLAC__stream_encoder_init_ogg_stream() if seeking is supported.
 *  The supplied function will be called when the encoder needs to read back
 *  encoded data.  This happens during the metadata callback, when the encoder
 *  has to read, modify, and rewrite the metadata (e.g. seekpoints) gathered
 *  while encoding.  The address of the buffer to be filled is supplied, along
 *  with the number of bytes the buffer can hold.  The callback may choose to
 *  supply less data and modify the byte count but must be careful not to
 *  overflow the buffer.  The callback then returns a status code chosen from
 *  FLAC__StreamEncoderReadStatus.
 *
 * Here is an example of a read callback for stdio streams:
 * \code
 * FLAC__StreamEncoderReadStatus read_cb(const FLAC__StreamEncoder *encoder, FLAC__byte buffer[], size_t *bytes, void *client_data)
 * {
 *   FILE *file = ((MyClientData*)client_data)->file;
 *   if(*bytes > 0) {
 *     *bytes = fread(buffer, sizeof(FLAC__byte), *bytes, file);
 *     if(ferror(file))
 *       return FLAC__STREAM_ENCODER_READ_STATUS_ABORT;
 *     else if(*bytes == 0)
 *       return FLAC__STREAM_ENCODER_READ_STATUS_END_OF_STREAM;
 *     else
 *       return FLAC__STREAM_ENCODER_READ_STATUS_CONTINUE;
 *   }
 *   else
 *     return FLAC__STREAM_ENCODER_READ_STATUS_ABORT;
 * }
 * \endcode
 *
 * \note In general, FLAC__StreamEncoder functions which change the
 * state should not be called on the \a encoder while in the callback.
 *
 * \param  encoder  The encoder instance calling the callback.
 * \param  buffer   A pointer to a location for the callee to store
 *                  data to be encoded.
 * \param  bytes    A pointer to the size of the buffer.  On entry
 *                  to the callback, it contains the maximum number
 *                  of bytes that may be stored in \a buffer.  The
 *                  callee must set it to the actual number of bytes
 *                  stored (0 in case of error or end-of-stream) before
 *                  returning.
 * \param  client_data  The callee's client data set through
 *                      FLAC__stream_encoder_set_client_data().
 * \retval FLAC__StreamEncoderReadStatus
 *    The callee's return status.
 */
typedef FLAC__StreamEncoderReadStatus (*FLAC__StreamEncoderReadCallback)(const FLAC__StreamEncoder *encoder, FLAC__byte buffer[], size_t *bytes, void *client_data);

/** Signature for the write callback.
 *
 *  A function pointer matching this signature must be passed to
 *  FLAC__stream_encoder_init*_stream().  The supplied function will be called
 *  by the encoder anytime there is raw encoded data ready to write.  It may
 *  include metadata mixed with encoded audio frames and the data is not
 *  guaranteed to be aligned on frame or metadata block boundaries.
 *
 *  The only duty of the callback is to write out the \a bytes worth of data
 *  in \a buffer to the current position in the output stream.  The arguments
 *  \a samples and \a current_frame are purely informational.  If \a samples
 *  is greater than \c 0, then \a current_frame will hold the current frame
 *  number that is being written; otherwise it indicates that the write
 *  callback is being called to write metadata.
 *
 * \note
 * Unlike when writing to native FLAC, when writing to Ogg FLAC the
 * write callback will be called twice when writing each audio
 * frame; once for the page header, and once for the page body.
 * When writing the page header, the \a samples argument to the
 * write callback will be \c 0.
 *
 * \note In general, FLAC__StreamEncoder functions which change the
 * state should not be called on the \a encoder while in the callback.
 *
 * \param  encoder  The encoder instance calling the callback.
 * \param  buffer   An array of encoded data of length \a bytes.
 * \param  bytes    The byte length of \a buffer.
 * \param  samples  The number of samples encoded by \a buffer.
 *                  \c 0 has a special meaning; see above.
 * \param  current_frame  The number of the current frame being encoded.
 * \param  client_data  The callee's client data set through
 *                      FLAC__stream_encoder_init_*().
 * \retval FLAC__StreamEncoderWriteStatus
 *    The callee's return status.
 */
typedef FLAC__StreamEncoderWriteStatus (*FLAC__StreamEncoderWriteCallback)(const FLAC__StreamEncoder *encoder, const FLAC__byte buffer[], size_t bytes, unsigned samples, unsigned current_frame, void *client_data);

/** Signature for the seek callback.
 *
 *  A function pointer matching this signature may be passed to
 *  FLAC__stream_encoder_init*_stream().  The supplied function will be called
 *  when the encoder needs to seek the output stream.  The encoder will pass
 *  the absolute byte offset to seek to, 0 meaning the beginning of the stream.
 *
 * Here is an example of a seek callback for stdio streams:
 * \code
 * FLAC__StreamEncoderSeekStatus seek_cb(const FLAC__StreamEncoder *encoder, FLAC__uint64 absolute_byte_offset, void *client_data)
 * {
 *   FILE *file = ((MyClientData*)client_data)->file;
 *   if(file == stdin)
 *     return FLAC__STREAM_ENCODER_SEEK_STATUS_UNSUPPORTED;
 *   else if(fseeko(file, (off_t)absolute_byte_offset, SEEK_SET) < 0)
 *     return FLAC__STREAM_ENCODER_SEEK_STATUS_ERROR;
 *   else
 *     return FLAC__STREAM_ENCODER_SEEK_STATUS_OK;
 * }
 * \endcode
 *
 * \note In general, FLAC__StreamEncoder functions which change the
 * state should not be called on the \a encoder while in the callback.
 *
 * \param  encoder  The encoder instance calling the callback.
 * \param  absolute_byte_offset  The offset from the beginning of the stream
 *                               to seek to.
 * \param  client_data  The callee's client data set through
 *                      FLAC__stream_encoder_init_*().
 * \retval FLAC__StreamEncoderSeekStatus
 *    The callee's return status.
 */
typedef FLAC__StreamEncoderSeekStatus (*FLAC__StreamEncoderSeekCallback)(const FLAC__StreamEncoder *encoder, FLAC__uint64 absolute_byte_offset, void *client_data);

/** Signature for the tell callback.
 *
 *  A function pointer matching this signature may be passed to
 *  FLAC__stream_encoder_init*_stream().  The supplied function will be called
 *  when the encoder needs to know the current position of the output stream.
 *
 * \warning
 * The callback must return the true current byte offset of the output to
 * which the encoder is writing.  If you are buffering the output, make
 * sure and take this into account.  If you are writing directly to a
 * FILE* from your write callback, ftell() is sufficient.  If you are
 * writing directly to a file descriptor from your write callback, you
 * can use lseek(fd, SEEK_CUR, 0).  The encoder may later seek back to
 * these points to rewrite metadata after encoding.
 *
 * Here is an example of a tell callback for stdio streams:
 * \code
 * FLAC__StreamEncoderTellStatus tell_cb(const FLAC__StreamEncoder *encoder, FLAC__uint64 *absolute_byte_offset, void *client_data)
 * {
 *   FILE *file = ((MyClientData*)client_data)->file;
 *   off_t pos;
 *   if(file == stdin)
 *     return FLAC__STREAM_ENCODER_TELL_STATUS_UNSUPPORTED;
 *   else if((pos = ftello(file)) < 0)
 *     return FLAC__STREAM_ENCODER_TELL_STATUS_ERROR;
 *   else {
 *     *absolute_byte_offset = (FLAC__uint64)pos;
 *     return FLAC__STREAM_ENCODER_TELL_STATUS_OK;
 *   }
 * }
 * \endcode
 *
 * \note In general, FLAC__StreamEncoder functions which change the
 * state should not be called on the \a encoder while in the callback.
 *
 * \param  encoder  The encoder instance calling the callback.
 * \param  absolute_byte_offset  The address at which to store the current
 *                               position of the output.
 * \param  client_data  The callee's client data set through
 *                      FLAC__stream_encoder_init_*().
 * \retval FLAC__StreamEncoderTellStatus
 *    The callee's return status.
 */
typedef FLAC__StreamEncoderTellStatus (*FLAC__StreamEncoderTellCallback)(const FLAC__StreamEncoder *encoder, FLAC__uint64 *absolute_byte_offset, void *client_data);

/** Signature for the metadata callback.
 *
 *  A function pointer matching this signature may be passed to
 *  FLAC__stream_encoder_init*_stream().  The supplied function will be called
 *  once at the end of encoding with the populated STREAMINFO structure.  This
 *  is so the client can seek back to the beginning of the file and write the
 *  STREAMINFO block with the correct statistics after encoding (like
 *  minimum/maximum frame size and total samples).
 *
 * \note In general, FLAC__StreamEncoder functions which change the
 * state should not be called on the \a encoder while in the callback.
 *
 * \param  encoder      The encoder instance calling the callback.
 * \param  metadata     The final populated STREAMINFO block.
 * \param  client_data  The callee's client data set through
 *                      FLAC__stream_encoder_init_*().
 */
typedef void (*FLAC__StreamEncoderMetadataCallback)(const FLAC__StreamEncoder *encoder, const FLAC__StreamMetadata *metadata, void *client_data);

/** Signature for the progress callback.
 *
 *  A function pointer matching this signature may be passed to
 *  FLAC__stream_encoder_init*_file() or FLAC__stream_encoder_init*_FILE().
 *  The supplied function will be called when the encoder has finished
 *  writing a frame.  The \c total_frames_estimate argument to the
 *  callback will be based on the value from
 *  FLAC__stream_encoder_set_total_samples_estimate().
 *
 * \note In general, FLAC__StreamEncoder functions which change the
 * state should not be called on the \a encoder while in the callback.
 *
 * \param  encoder          The encoder instance calling the callback.
 * \param  bytes_written    Bytes written so far.
 * \param  samples_written  Samples written so far.
 * \param  frames_written   Frames written so far.
 * \param  total_frames_estimate  The estimate of the total number of
 *                                frames to be written.
 * \param  client_data      The callee's client data set through
 *                          FLAC__stream_encoder_init_*().
 */
typedef void (*FLAC__StreamEncoderProgressCallback)(const FLAC__StreamEncoder *encoder, FLAC__uint64 bytes_written, FLAC__uint64 samples_written, unsigned frames_written, unsigned total_frames_estimate, void *client_data);

/***********************************************************************
 *
 * Class constructor/destructor
 *
 ***********************************************************************/

/** Create a new stream encoder instance.  The instance is created with
 *  default settings; see the individual FLAC__stream_encoder_set_*()
 *  functions for each setting's default.
 *
 * \retval FLAC__StreamEncoder*
 *    \c NULL if there was an error allocating memory, else the new instance.
 */
FLAC_API FLAC__StreamEncoder *FLAC__stream_encoder_new(void);

/** Free an encoder instance.  Deletes the object pointed to by \a encoder.
 *
 * \param encoder  A pointer to an existing encoder.
 * \assert
 *    \code encoder != NULL \endcode
 */
FLAC_API void FLAC__stream_encoder_delete(FLAC__StreamEncoder *encoder);

/***********************************************************************
 *
 * Public class method prototypes
 *
 ***********************************************************************/

/** Set the serial number for the FLAC stream to use in the Ogg container.
 *
 * \note
 * This does not need to be set for native FLAC encoding.
 *
 * \note
 * It is recommended to set a serial number explicitly as the default of '0'
 * may collide with other streams.
 *
 * \default \c 0
 * \param  encoder        An encoder instance to set.
 * \param  serial_number  See above.
 * \assert
 *    \code encoder != NULL \endcode
 * \retval FLAC__bool
 *    \c false if the encoder is already initialized, else \c true.
 */
FLAC_API FLAC__bool FLAC__stream_encoder_set_ogg_serial_number(FLAC__StreamEncoder *encoder, long serial_number);

/** Set the "verify" flag.  If \c true, the encoder will verify it's own
 *  encoded output by feeding it through an internal decoder and comparing
 *  the original signal against the decoded signal.  If a mismatch occurs,
 *  the process call will return \c false.  Note that this will slow the
 *  encoding process by the extra time required for decoding and comparison.
 *
 * \default \c false
 * \param  encoder  An encoder instance to set.
 * \param  value    Flag value (see above).
 * \assert
 *    \code encoder != NULL \endcode
 * \retval FLAC__bool
 *    \c false if the encoder is already initialized, else \c true.
 */
FLAC_API FLAC__bool FLAC__stream_encoder_set_verify(FLAC__StreamEncoder *encoder, FLAC__bool value);

/** Set the <A HREF="../format.html#subset">Subset</A> flag.  If \c true,
 *  the encoder will comply with the Subset and will check the
 *  settings during FLAC__stream_encoder_init_*() to see if all settings
 *  comply.  If \c false, the settings may take advantage of the full
 *  range that the format allows.
 *
 *  Make sure you know what it entails before setting this to \c false.
 *
 * \default \c true
 * \param  encoder  An encoder instance to set.
 * \param  value    Flag value (see above).
 * \assert
 *    \code encoder != NULL \endcode
 * \retval FLAC__bool
 *    \c false if the encoder is already initialized, else \c true.
 */
FLAC_API FLAC__bool FLAC__stream_encoder_set_streamable_subset(FLAC__StreamEncoder *encoder, FLAC__bool value);

/** Set the number of channels to be encoded.
 *
 * \default \c 2
 * \param  encoder  An encoder instance to set.
 * \param  value    See above.
 * \assert
 *    \code encoder != NULL \endcode
 * \retval FLAC__bool
 *    \c false if the encoder is already initialized, else \c true.
 */
FLAC_API FLAC__bool FLAC__stream_encoder_set_channels(FLAC__StreamEncoder *encoder, unsigned value);

/** Set the sample resolution of the input to be encoded.
 *
 * \warning
 * Do not feed the encoder data that is wider than the value you
 * set here or you will generate an invalid stream.
 *
 * \default \c 16
 * \param  encoder  An encoder instance to set.
 * \param  value    See above.
 * \assert
 *    \code encoder != NULL \endcode
 * \retval FLAC__bool
 *    \c false if the encoder is already initialized, else \c true.
 */
FLAC_API FLAC__bool FLAC__stream_encoder_set_bits_per_sample(FLAC__StreamEncoder *encoder, unsigned value);

/** Set the sample rate (in Hz) of the input to be encoded.
 *
 * \default \c 44100
 * \param  encoder  An encoder instance to set.
 * \param  value    See above.
 * \assert
 *    \code encoder != NULL \endcode
 * \retval FLAC__bool
 *    \c false if the encoder is already initialized, else \c true.
 */
FLAC_API FLAC__bool FLAC__stream_encoder_set_sample_rate(FLAC__StreamEncoder *encoder, unsigned value);

/** Set the compression level
 *
 * The compression level is roughly proportional to the amount of effort
 * the encoder expends to compress the file.  A higher level usually
 * means more computation but higher compression.  The default level is
 * suitable for most applications.
 *
 * Currently the levels range from \c 0 (fastest, least compression) to
 * \c 8 (slowest, most compression).  A value larger than \c 8 will be
 * treated as \c 8.
 *
 * This function automatically calls the following other \c _set_
 * functions with appropriate values, so the client does not need to
 * unless it specifically wants to override them:
 * - FLAC__stream_encoder_set_do_mid_side_stereo()
 * - FLAC__stream_encoder_set_loose_mid_side_stereo()
 * - FLAC__stream_encoder_set_apodization()
 * - FLAC__stream_encoder_set_max_lpc_order()
 * - FLAC__stream_encoder_set_qlp_coeff_precision()
 * - FLAC__stream_encoder_set_do_qlp_coeff_prec_search()
 * - FLAC__stream_encoder_set_do_escape_coding()
 * - FLAC__stream_encoder_set_do_exhaustive_model_search()
 * - FLAC__stream_encoder_set_min_residual_partition_order()
 * - FLAC__stream_encoder_set_max_residual_partition_order()
 * - FLAC__stream_encoder_set_rice_parameter_search_dist()
 *
 * The actual values set for each level are:
 * <table>
 * <tr>
 *  <td><b>level</b><td>
 *  <td>do mid-side stereo<td>
 *  <td>loose mid-side stereo<td>
 *  <td>apodization<td>
 *  <td>max lpc order<td>
 *  <td>qlp coeff precision<td>
 *  <td>qlp coeff prec search<td>
 *  <td>escape coding<td>
 *  <td>exhaustive model search<td>
 *  <td>min residual partition order<td>
 *  <td>max residual partition order<td>
 *  <td>rice parameter search dist<td>
 * </tr>
 * <tr>  <td><b>0</b><td>  <td>false<td>  <td>false<td>  <td>tukey(0.5)<td>  <td>0<td>   <td>0<td>  <td>false<td>  <td>false<td>  <td>false<td>  <td>0<td>  <td>3<td>  <td>0<td>  </tr>
 * <tr>  <td><b>1</b><td>  <td>true<td>   <td>true<td>   <td>tukey(0.5)<td>  <td>0<td>   <td>0<td>  <td>false<td>  <td>false<td>  <td>false<td>  <td>0<td>  <td>3<td>  <td>0<td>  </tr>
 * <tr>  <td><b>2</b><td>  <td>true<td>   <td>false<td>  <td>tukey(0.5)<td>  <td>0<td>   <td>0<td>  <td>false<td>  <td>false<td>  <td>false<td>  <td>0<td>  <td>3<td>  <td>0<td>  </tr>
 * <tr>  <td><b>3</b><td>  <td>false<td>  <td>false<td>  <td>tukey(0.5)<td>  <td>6<td>   <td>0<td>  <td>false<td>  <td>false<td>  <td>false<td>  <td>0<td>  <td>4<td>  <td>0<td>  </tr>
 * <tr>  <td><b>4</b><td>  <td>true<td>   <td>true<td>   <td>tukey(0.5)<td>  <td>8<td>   <td>0<td>  <td>false<td>  <td>false<td>  <td>false<td>  <td>0<td>  <td>4<td>  <td>0<td>  </tr>
 * <tr>  <td><b>5</b><td>  <td>true<td>   <td>false<td>  <td>tukey(0.5)<td>  <td>8<td>   <td>0<td>  <td>false<td>  <td>false<td>  <td>false<td>  <td>0<td>  <td>5<td>  <td>0<td>  </tr>
 * <tr>  <td><b>6</b><td>  <td>true<td>   <td>false<td>  <td>tukey(0.5)<td>  <td>8<td>   <td>0<td>  <td>false<td>  <td>false<td>  <td>false<td>  <td>0<td>  <td>6<td>  <td>0<td>  </tr>
 * <tr>  <td><b>7</b><td>  <td>true<td>   <td>false<td>  <td>tukey(0.5)<td>  <td>8<td>   <td>0<td>  <td>false<td>  <td>false<td>  <td>true<td>   <td>0<td>  <td>6<td>  <td>0<td>  </tr>
 * <tr>  <td><b>8</b><td>  <td>true<td>   <td>false<td>  <td>tukey(0.5)<td>  <td>12<td>  <td>0<td>  <td>false<td>  <td>false<td>  <td>true<td>   <td>0<td>  <td>6<td>  <td>0<td>  </tr>
 * </table>
 *
 * \default \c 5
 * \param  encoder  An encoder instance to set.
 * \param  value    See above.
 * \assert
 *    \code encoder != NULL \endcode
 * \retval FLAC__bool
 *    \c false if the encoder is already initialized, else \c true.
 */
FLAC_API FLAC__bool FLAC__stream_encoder_set_compression_level(FLAC__StreamEncoder *encoder, unsigned value);

/** Set the blocksize to use while encoding.
 *
 * The number of samples to use per frame.  Use \c 0 to let the encoder
 * estimate a blocksize; this is usually best.
 *
 * \default \c 0
 * \param  encoder  An encoder instance to set.
 * \param  value    See above.
 * \assert
 *    \code encoder != NULL \endcode
 * \retval FLAC__bool
 *    \c false if the encoder is already initialized, else \c true.
 */
FLAC_API FLAC__bool FLAC__stream_encoder_set_blocksize(FLAC__StreamEncoder *encoder, unsigned value);

/** Set to \c true to enable mid-side encoding on stereo input.  The
 *  number of channels must be 2 for this to have any effect.  Set to
 *  \c false to use only independent channel coding.
 *
 * \default \c false
 * \param  encoder  An encoder instance to set.
 * \param  value    Flag value (see above).
 * \assert
 *    \code encoder != NULL \endcode
 * \retval FLAC__bool
 *    \c false if the encoder is already initialized, else \c true.
 */
FLAC_API FLAC__bool FLAC__stream_encoder_set_do_mid_side_stereo(FLAC__StreamEncoder *encoder, FLAC__bool value);

/** Set to \c true to enable adaptive switching between mid-side and
 *  left-right encoding on stereo input.  Set to \c false to use
 *  exhaustive searching.  Setting this to \c true requires
 *  FLAC__stream_encoder_set_do_mid_side_stereo() to also be set to
 *  \c true in order to have any effect.
 *
 * \default \c false
 * \param  encoder  An encoder instance to set.
 * \param  value    Flag value (see above).
 * \assert
 *    \code encoder != NULL \endcode
 * \retval FLAC__bool
 *    \c false if the encoder is already initialized, else \c true.
 */
FLAC_API FLAC__bool FLAC__stream_encoder_set_loose_mid_side_stereo(FLAC__StreamEncoder *encoder, FLAC__bool value);

/** Sets the apodization function(s) the encoder will use when windowing
 *  audio data for LPC analysis.
 *
 * The \a specification is a plain ASCII string which specifies exactly
 * which functions to use.  There may be more than one (up to 32),
 * separated by \c ';' characters.  Some functions take one or more
 * comma-separated arguments in parentheses.
 *
 * The available functions are \c bartlett, \c bartlett_hann,
 * \c blackman, \c blackman_harris_4term_92db, \c connes, \c flattop,
 * \c gauss(STDDEV), \c hamming, \c hann, \c kaiser_bessel, \c nuttall,
 * \c rectangle, \c triangle, \c tukey(P), \c welch.
 *
 * For \c gauss(STDDEV), STDDEV specifies the standard deviation
 * (0<STDDEV<=0.5).
 *
 * For \c tukey(P), P specifies the fraction of the window that is
 * tapered (0<=P<=1).  P=0 corresponds to \c rectangle and P=1
 * corresponds to \c hann.
 *
 * Example specifications are \c "blackman" or
 * \c "hann;triangle;tukey(0.5);tukey(0.25);tukey(0.125)"
 *
 * Any function that is specified erroneously is silently dropped.  Up
 * to 32 functions are kept, the rest are dropped.  If the specification
 * is empty the encoder defaults to \c "tukey(0.5)".
 *
 * When more than one function is specified, then for every subframe the
 * encoder will try each of them separately and choose the window that
 * results in the smallest compressed subframe.
 *
 * Note that each function specified causes the encoder to occupy a
 * floating point array in which to store the window.
 *
 * \default \c "tukey(0.5)"
 * \param  encoder        An encoder instance to set.
 * \param  specification  See above.
 * \assert
 *    \code encoder != NULL \endcode
 *    \code specification != NULL \endcode
 * \retval FLAC__bool
 *    \c false if the encoder is already initialized, else \c true.
 */
FLAC_API FLAC__bool FLAC__stream_encoder_set_apodization(FLAC__StreamEncoder *encoder, const char *specification);

/** Set the maximum LPC order, or \c 0 to use only the fixed predictors.
 *
 * \default \c 0
 * \param  encoder  An encoder instance to set.
 * \param  value    See above.
 * \assert
 *    \code encoder != NULL \endcode
 * \retval FLAC__bool
 *    \c false if the encoder is already initialized, else \c true.
 */
FLAC_API FLAC__bool FLAC__stream_encoder_set_max_lpc_order(FLAC__StreamEncoder *encoder, unsigned value);

/** Set the precision, in bits, of the quantized linear predictor
 *  coefficients, or \c 0 to let the encoder select it based on the
 *  blocksize.
 *
 * \note
 * In the current implementation, qlp_coeff_precision + bits_per_sample must
 * be less than 32.
 *
 * \default \c 0
 * \param  encoder  An encoder instance to set.
 * \param  value    See above.
 * \assert
 *    \code encoder != NULL \endcode
 * \retval FLAC__bool
 *    \c false if the encoder is already initialized, else \c true.
 */
FLAC_API FLAC__bool FLAC__stream_encoder_set_qlp_coeff_precision(FLAC__StreamEncoder *encoder, unsigned value);

/** Set to \c false to use only the specified quantized linear predictor
 *  coefficient precision, or \c true to search neighboring precision
 *  values and use the best one.
 *
 * \default \c false
 * \param  encoder  An encoder instance to set.
 * \param  value    See above.
 * \assert
 *    \code encoder != NULL \endcode
 * \retval FLAC__bool
 *    \c false if the encoder is already initialized, else \c true.
 */
FLAC_API FLAC__bool FLAC__stream_encoder_set_do_qlp_coeff_prec_search(FLAC__StreamEncoder *encoder, FLAC__bool value);

/** Deprecated.  Setting this value has no effect.
 *
 * \default \c false
 * \param  encoder  An encoder instance to set.
 * \param  value    See above.
 * \assert
 *    \code encoder != NULL \endcode
 * \retval FLAC__bool
 *    \c false if the encoder is already initialized, else \c true.
 */
FLAC_API FLAC__bool FLAC__stream_encoder_set_do_escape_coding(FLAC__StreamEncoder *encoder, FLAC__bool value);

/** Set to \c false to let the encoder estimate the best model order
 *  based on the residual signal energy, or \c true to force the
 *  encoder to evaluate all order models and select the best.
 *
 * \default \c false
 * \param  encoder  An encoder instance to set.
 * \param  value    See above.
 * \assert
 *    \code encoder != NULL \endcode
 * \retval FLAC__bool
 *    \c false if the encoder is already initialized, else \c true.
 */
FLAC_API FLAC__bool FLAC__stream_encoder_set_do_exhaustive_model_search(FLAC__StreamEncoder *encoder, FLAC__bool value);

/** Set the minimum partition order to search when coding the residual.
 *  This is used in tandem with
 *  FLAC__stream_encoder_set_max_residual_partition_order().
 *
 *  The partition order determines the context size in the residual.
 *  The context size will be approximately <tt>blocksize / (2 ^ order)</tt>.
 *
 *  Set both min and max values to \c 0 to force a single context,
 *  whose Rice parameter is based on the residual signal variance.
 *  Otherwise, set a min and max order, and the encoder will search
 *  all orders, using the mean of each context for its Rice parameter,
 *  and use the best.
 *
 * \default \c 0
 * \param  encoder  An encoder instance to set.
 * \param  value    See above.
 * \assert
 *    \code encoder != NULL \endcode
 * \retval FLAC__bool
 *    \c false if the encoder is already initialized, else \c true.
 */
FLAC_API FLAC__bool FLAC__stream_encoder_set_min_residual_partition_order(FLAC__StreamEncoder *encoder, unsigned value);

/** Set the maximum partition order to search when coding the residual.
 *  This is used in tandem with
 *  FLAC__stream_encoder_set_min_residual_partition_order().
 *
 *  The partition order determines the context size in the residual.
 *  The context size will be approximately <tt>blocksize / (2 ^ order)</tt>.
 *
 *  Set both min and max values to \c 0 to force a single context,
 *  whose Rice parameter is based on the residual signal variance.
 *  Otherwise, set a min and max order, and the encoder will search
 *  all orders, using the mean of each context for its Rice parameter,
 *  and use the best.
 *
 * \default \c 0
 * \param  encoder  An encoder instance to set.
 * \param  value    See above.
 * \assert
 *    \code encoder != NULL \endcode
 * \retval FLAC__bool
 *    \c false if the encoder is already initialized, else \c true.
 */
FLAC_API FLAC__bool FLAC__stream_encoder_set_max_residual_partition_order(FLAC__StreamEncoder *encoder, unsigned value);

/** Deprecated.  Setting this value has no effect.
 *
 * \default \c 0
 * \param  encoder  An encoder instance to set.
 * \param  value    See above.
 * \assert
 *    \code encoder != NULL \endcode
 * \retval FLAC__bool
 *    \c false if the encoder is already initialized, else \c true.
 */
FLAC_API FLAC__bool FLAC__stream_encoder_set_rice_parameter_search_dist(FLAC__StreamEncoder *encoder, unsigned value);

/** Set an estimate of the total samples that will be encoded.
 *  This is merely an estimate and may be set to \c 0 if unknown.
 *  This value will be written to the STREAMINFO block before encoding,
 *  and can remove the need for the caller to rewrite the value later
 *  if the value is known before encoding.
 *
 * \default \c 0
 * \param  encoder  An encoder instance to set.
 * \param  value    See above.
 * \assert
 *    \code encoder != NULL \endcode
 * \retval FLAC__bool
 *    \c false if the encoder is already initialized, else \c true.
 */
FLAC_API FLAC__bool FLAC__stream_encoder_set_total_samples_estimate(FLAC__StreamEncoder *encoder, FLAC__uint64 value);

/** Set the metadata blocks to be emitted to the stream before encoding.
 *  A value of \c NULL, \c 0 implies no metadata; otherwise, supply an
 *  array of pointers to metadata blocks.  The array is non-const since
 *  the encoder may need to change the \a is_last flag inside them, and
 *  in some cases update seek point offsets.  Otherwise, the encoder will
 *  not modify or free the blocks.  It is up to the caller to free the
 *  metadata blocks after encoding finishes.
 *
 * \note
 * The encoder stores only copies of the pointers in the \a metadata array;
 * the metadata blocks themselves must survive at least until after
 * FLAC__stream_encoder_finish() returns.  Do not free the blocks until then.
 *
 * \note
 * The STREAMINFO block is always written and no STREAMINFO block may
 * occur in the supplied array.
 *
 * \note
 * By default the encoder does not create a SEEKTABLE.  If one is supplied
 * in the \a metadata array, but the client has specified that it does not
 * support seeking, then the SEEKTABLE will be written verbatim.  However
 * by itself this is not very useful as the client will not know the stream
 * offsets for the seekpoints ahead of time.  In order to get a proper
 * seektable the client must support seeking.  See next note.
 *
 * \note
 * SEEKTABLE blocks are handled specially.  Since you will not know
 * the values for the seek point stream offsets, you should pass in
 * a SEEKTABLE 'template', that is, a SEEKTABLE object with the
 * required sample numbers (or placeholder points), with \c 0 for the
 * \a frame_samples and \a stream_offset fields for each point.  If the
 * client has specified that it supports seeking by providing a seek
 * callback to FLAC__stream_encoder_init_stream() or both seek AND read
 * callback to FLAC__stream_encoder_init_ogg_stream() (or by using
 * FLAC__stream_encoder_init*_file() or FLAC__stream_encoder_init*_FILE()),
 * then while it is encoding the encoder will fill the stream offsets in
 * for you and when encoding is finished, it will seek back and write the
 * real values into the SEEKTABLE block in the stream.  There are helper
 * routines for manipulating seektable template blocks; see metadata.h:
 * FLAC__metadata_object_seektable_template_*().  If the client does
 * not support seeking, the SEEKTABLE will have inaccurate offsets which
 * will slow down or remove the ability to seek in the FLAC stream.
 *
 * \note
 * The encoder instance \b will modify the first \c SEEKTABLE block
 * as it transforms the template to a valid seektable while encoding,
 * but it is still up to the caller to free all metadata blocks after
 * encoding.
 *
 * \note
 * A VORBIS_COMMENT block may be supplied.  The vendor string in it
 * will be ignored.  libFLAC will use it's own vendor string. libFLAC
 * will not modify the passed-in VORBIS_COMMENT's vendor string, it
 * will simply write it's own into the stream.  If no VORBIS_COMMENT
 * block is present in the \a metadata array, libFLAC will write an
 * empty one, containing only the vendor string.
 *
 * \note The Ogg FLAC mapping requires that the VORBIS_COMMENT block be
 * the second metadata block of the stream.  The encoder already supplies
 * the STREAMINFO block automatically.  If \a metadata does not contain a
 * VORBIS_COMMENT block, the encoder will supply that too.  Otherwise, if
 * \a metadata does contain a VORBIS_COMMENT block and it is not the
 * first, the init function will reorder \a metadata by moving the
 * VORBIS_COMMENT block to the front; the relative ordering of the other
 * blocks will remain as they were.
 *
 * \note The Ogg FLAC mapping limits the number of metadata blocks per
 * stream to \c 65535.  If \a num_blocks exceeds this the function will
 * return \c false.
 *
 * \default \c NULL, 0
 * \param  encoder     An encoder instance to set.
 * \param  metadata    See above.
 * \param  num_blocks  See above.
 * \assert
 *    \code encoder != NULL \endcode
 * \retval FLAC__bool
 *    \c false if the encoder is already initialized, else \c true.
 *    \c false if the encoder is already initialized, or if
 *    \a num_blocks > 65535 if encoding to Ogg FLAC, else \c true.
 */
FLAC_API FLAC__bool FLAC__stream_encoder_set_metadata(FLAC__StreamEncoder *encoder, FLAC__StreamMetadata **metadata, unsigned num_blocks);

/** Get the current encoder state.
 *
 * \param  encoder  An encoder instance to query.
 * \assert
 *    \code encoder != NULL \endcode
 * \retval FLAC__StreamEncoderState
 *    The current encoder state.
 */
FLAC_API FLAC__StreamEncoderState FLAC__stream_encoder_get_state(const FLAC__StreamEncoder *encoder);

/** Get the state of the verify stream decoder.
 *  Useful when the stream encoder state is
 *  \c FLAC__STREAM_ENCODER_VERIFY_DECODER_ERROR.
 *
 * \param  encoder  An encoder instance to query.
 * \assert
 *    \code encoder != NULL \endcode
 * \retval FLAC__StreamDecoderState
 *    The verify stream decoder state.
 */
FLAC_API FLAC__StreamDecoderState FLAC__stream_encoder_get_verify_decoder_state(const FLAC__StreamEncoder *encoder);

/** Get the current encoder state as a C string.
 *  This version automatically resolves
 *  \c FLAC__STREAM_ENCODER_VERIFY_DECODER_ERROR by getting the
 *  verify decoder's state.
 *
 * \param  encoder  A encoder instance to query.
 * \assert
 *    \code encoder != NULL \endcode
 * \retval const char *
 *    The encoder state as a C string.  Do not modify the contents.
 */
FLAC_API const char *FLAC__stream_encoder_get_resolved_state_string(const FLAC__StreamEncoder *encoder);

/** Get relevant values about the nature of a verify decoder error.
 *  Useful when the stream encoder state is
 *  \c FLAC__STREAM_ENCODER_VERIFY_DECODER_ERROR.  The arguments should
 *  be addresses in which the stats will be returned, or NULL if value
 *  is not desired.
 *
 * \param  encoder  An encoder instance to query.
 * \param  absolute_sample  The absolute sample number of the mismatch.
 * \param  frame_number  The number of the frame in which the mismatch occurred.
 * \param  channel       The channel in which the mismatch occurred.
 * \param  sample        The number of the sample (relative to the frame) in
 *                       which the mismatch occurred.
 * \param  expected      The expected value for the sample in question.
 * \param  got           The actual value returned by the decoder.
 * \assert
 *    \code encoder != NULL \endcode
 */
FLAC_API void FLAC__stream_encoder_get_verify_decoder_error_stats(const FLAC__StreamEncoder *encoder, FLAC__uint64 *absolute_sample, unsigned *frame_number, unsigned *channel, unsigned *sample, FLAC__int32 *expected, FLAC__int32 *got);

/** Get the "verify" flag.
 *
 * \param  encoder  An encoder instance to query.
 * \assert
 *    \code encoder != NULL \endcode
 * \retval FLAC__bool
 *    See FLAC__stream_encoder_set_verify().
 */
FLAC_API FLAC__bool FLAC__stream_encoder_get_verify(const FLAC__StreamEncoder *encoder);

/** Get the <A HREF="../format.html#subset>Subset</A> flag.
 *
 * \param  encoder  An encoder instance to query.
 * \assert
 *    \code encoder != NULL \endcode
 * \retval FLAC__bool
 *    See FLAC__stream_encoder_set_streamable_subset().
 */
FLAC_API FLAC__bool FLAC__stream_encoder_get_streamable_subset(const FLAC__StreamEncoder *encoder);

/** Get the number of input channels being processed.
 *
 * \param  encoder  An encoder instance to query.
 * \assert
 *    \code encoder != NULL \endcode
 * \retval unsigned
 *    See FLAC__stream_encoder_set_channels().
 */
FLAC_API unsigned FLAC__stream_encoder_get_channels(const FLAC__StreamEncoder *encoder);

/** Get the input sample resolution setting.
 *
 * \param  encoder  An encoder instance to query.
 * \assert
 *    \code encoder != NULL \endcode
 * \retval unsigned
 *    See FLAC__stream_encoder_set_bits_per_sample().
 */
FLAC_API unsigned FLAC__stream_encoder_get_bits_per_sample(const FLAC__StreamEncoder *encoder);

/** Get the input sample rate setting.
 *
 * \param  encoder  An encoder instance to query.
 * \assert
 *    \code encoder != NULL \endcode
 * \retval unsigned
 *    See FLAC__stream_encoder_set_sample_rate().
 */
FLAC_API unsigned FLAC__stream_encoder_get_sample_rate(const FLAC__StreamEncoder *encoder);

/** Get the blocksize setting.
 *
 * \param  encoder  An encoder instance to query.
 * \assert
 *    \code encoder != NULL \endcode
 * \retval unsigned
 *    See FLAC__stream_encoder_set_blocksize().
 */
FLAC_API unsigned FLAC__stream_encoder_get_blocksize(const FLAC__StreamEncoder *encoder);

/** Get the "mid/side stereo coding" flag.
 *
 * \param  encoder  An encoder instance to query.
 * \assert
 *    \code encoder != NULL \endcode
 * \retval FLAC__bool
 *    See FLAC__stream_encoder_get_do_mid_side_stereo().
 */
FLAC_API FLAC__bool FLAC__stream_encoder_get_do_mid_side_stereo(const FLAC__StreamEncoder *encoder);

/** Get the "adaptive mid/side switching" flag.
 *
 * \param  encoder  An encoder instance to query.
 * \assert
 *    \code encoder != NULL \endcode
 * \retval FLAC__bool
 *    See FLAC__stream_encoder_set_loose_mid_side_stereo().
 */
FLAC_API FLAC__bool FLAC__stream_encoder_get_loose_mid_side_stereo(const FLAC__StreamEncoder *encoder);

/** Get the maximum LPC order setting.
 *
 * \param  encoder  An encoder instance to query.
 * \assert
 *    \code encoder != NULL \endcode
 * \retval unsigned
 *    See FLAC__stream_encoder_set_max_lpc_order().
 */
FLAC_API unsigned FLAC__stream_encoder_get_max_lpc_order(const FLAC__StreamEncoder *encoder);

/** Get the quantized linear predictor coefficient precision setting.
 *
 * \param  encoder  An encoder instance to query.
 * \assert
 *    \code encoder != NULL \endcode
 * \retval unsigned
 *    See FLAC__stream_encoder_set_qlp_coeff_precision().
 */
FLAC_API unsigned FLAC__stream_encoder_get_qlp_coeff_precision(const FLAC__StreamEncoder *encoder);

/** Get the qlp coefficient precision search flag.
 *
 * \param  encoder  An encoder instance to query.
 * \assert
 *    \code encoder != NULL \endcode
 * \retval FLAC__bool
 *    See FLAC__stream_encoder_set_do_qlp_coeff_prec_search().
 */
FLAC_API FLAC__bool FLAC__stream_encoder_get_do_qlp_coeff_prec_search(const FLAC__StreamEncoder *encoder);

/** Get the "escape coding" flag.
 *
 * \param  encoder  An encoder instance to query.
 * \assert
 *    \code encoder != NULL \endcode
 * \retval FLAC__bool
 *    See FLAC__stream_encoder_set_do_escape_coding().
 */
FLAC_API FLAC__bool FLAC__stream_encoder_get_do_escape_coding(const FLAC__StreamEncoder *encoder);

/** Get the exhaustive model search flag.
 *
 * \param  encoder  An encoder instance to query.
 * \assert
 *    \code encoder != NULL \endcode
 * \retval FLAC__bool
 *    See FLAC__stream_encoder_set_do_exhaustive_model_search().
 */
FLAC_API FLAC__bool FLAC__stream_encoder_get_do_exhaustive_model_search(const FLAC__StreamEncoder *encoder);

/** Get the minimum residual partition order setting.
 *
 * \param  encoder  An encoder instance to query.
 * \assert
 *    \code encoder != NULL \endcode
 * \retval unsigned
 *    See FLAC__stream_encoder_set_min_residual_partition_order().
 */
FLAC_API unsigned FLAC__stream_encoder_get_min_residual_partition_order(const FLAC__StreamEncoder *encoder);

/** Get maximum residual partition order setting.
 *
 * \param  encoder  An encoder instance to query.
 * \assert
 *    \code encoder != NULL \endcode
 * \retval unsigned
 *    See FLAC__stream_encoder_set_max_residual_partition_order().
 */
FLAC_API unsigned FLAC__stream_encoder_get_max_residual_partition_order(const FLAC__StreamEncoder *encoder);

/** Get the Rice parameter search distance setting.
 *
 * \param  encoder  An encoder instance to query.
 * \assert
 *    \code encoder != NULL \endcode
 * \retval unsigned
 *    See FLAC__stream_encoder_set_rice_parameter_search_dist().
 */
FLAC_API unsigned FLAC__stream_encoder_get_rice_parameter_search_dist(const FLAC__StreamEncoder *encoder);

/** Get the previously set estimate of the total samples to be encoded.
 *  The encoder merely mimics back the value given to
 *  FLAC__stream_encoder_set_total_samples_estimate() since it has no
 *  other way of knowing how many samples the client will encode.
 *
 * \param  encoder  An encoder instance to set.
 * \assert
 *    \code encoder != NULL \endcode
 * \retval FLAC__uint64
 *    See FLAC__stream_encoder_get_total_samples_estimate().
 */
FLAC_API FLAC__uint64 FLAC__stream_encoder_get_total_samples_estimate(const FLAC__StreamEncoder *encoder);

/** Initialize the encoder instance to encode native FLAC streams.
 *
 *  This flavor of initialization sets up the encoder to encode to a
 *  native FLAC stream. I/O is performed via callbacks to the client.
 *  For encoding to a plain file via filename or open \c FILE*,
 *  FLAC__stream_encoder_init_file() and FLAC__stream_encoder_init_FILE()
 *  provide a simpler interface.
 *
 *  This function should be called after FLAC__stream_encoder_new() and
 *  FLAC__stream_encoder_set_*() but before FLAC__stream_encoder_process()
 *  or FLAC__stream_encoder_process_interleaved().
 *  initialization succeeded.
 *
 *  The call to FLAC__stream_encoder_init_stream() currently will also
 *  immediately call the write callback several times, once with the \c fLaC
 *  signature, and once for each encoded metadata block.
 *
 * \param  encoder            An uninitialized encoder instance.
 * \param  write_callback     See FLAC__StreamEncoderWriteCallback.  This
 *                            pointer must not be \c NULL.
 * \param  seek_callback      See FLAC__StreamEncoderSeekCallback.  This
 *                            pointer may be \c NULL if seeking is not
 *                            supported.  The encoder uses seeking to go back
 *                            and write some some stream statistics to the
 *                            STREAMINFO block; this is recommended but not
 *                            necessary to create a valid FLAC stream.  If
 *                            \a seek_callback is not \c NULL then a
 *                            \a tell_callback must also be supplied.
 *                            Alternatively, a dummy seek callback that just
 *                            returns \c FLAC__STREAM_ENCODER_SEEK_STATUS_UNSUPPORTED
 *                            may also be supplied, all though this is slightly
 *                            less efficient for the encoder.
 * \param  tell_callback      See FLAC__StreamEncoderTellCallback.  This
 *                            pointer may be \c NULL if seeking is not
 *                            supported.  If \a seek_callback is \c NULL then
 *                            this argument will be ignored.  If
 *                            \a seek_callback is not \c NULL then a
 *                            \a tell_callback must also be supplied.
 *                            Alternatively, a dummy tell callback that just
 *                            returns \c FLAC__STREAM_ENCODER_TELL_STATUS_UNSUPPORTED
 *                            may also be supplied, all though this is slightly
 *                            less efficient for the encoder.
 * \param  metadata_callback  See FLAC__StreamEncoderMetadataCallback.  This
 *                            pointer may be \c NULL if the callback is not
 *                            desired.  If the client provides a seek callback,
 *                            this function is not necessary as the encoder
 *                            will automatically seek back and update the
 *                            STREAMINFO block.  It may also be \c NULL if the
 *                            client does not support seeking, since it will
 *                            have no way of going back to update the
 *                            STREAMINFO.  However the client can still supply
 *                            a callback if it would like to know the details
 *                            from the STREAMINFO.
 * \param  client_data        This value will be supplied to callbacks in their
 *                            \a client_data argument.
 * \assert
 *    \code encoder != NULL \endcode
 * \retval FLAC__StreamEncoderInitStatus
 *    \c FLAC__STREAM_ENCODER_INIT_STATUS_OK if initialization was successful;
 *    see FLAC__StreamEncoderInitStatus for the meanings of other return values.
 */
FLAC_API FLAC__StreamEncoderInitStatus FLAC__stream_encoder_init_stream(FLAC__StreamEncoder *encoder, FLAC__StreamEncoderWriteCallback write_callback, FLAC__StreamEncoderSeekCallback seek_callback, FLAC__StreamEncoderTellCallback tell_callback, FLAC__StreamEncoderMetadataCallback metadata_callback, void *client_data);

/** Initialize the encoder instance to encode Ogg FLAC streams.
 *
 *  This flavor of initialization sets up the encoder to encode to a FLAC
 *  stream in an Ogg container.  I/O is performed via callbacks to the
 *  client.  For encoding to a plain file via filename or open \c FILE*,
 *  FLAC__stream_encoder_init_ogg_file() and FLAC__stream_encoder_init_ogg_FILE()
 *  provide a simpler interface.
 *
 *  This function should be called after FLAC__stream_encoder_new() and
 *  FLAC__stream_encoder_set_*() but before FLAC__stream_encoder_process()
 *  or FLAC__stream_encoder_process_interleaved().
 *  initialization succeeded.
 *
 *  The call to FLAC__stream_encoder_init_ogg_stream() currently will also
 *  immediately call the write callback several times to write the metadata
 *  packets.
 *
 * \param  encoder            An uninitialized encoder instance.
 * \param  read_callback      See FLAC__StreamEncoderReadCallback.  This
 *                            pointer must not be \c NULL if \a seek_callback
 *                            is non-NULL since they are both needed to be
 *                            able to write data back to the Ogg FLAC stream
 *                            in the post-encode phase.
 * \param  write_callback     See FLAC__StreamEncoderWriteCallback.  This
 *                            pointer must not be \c NULL.
 * \param  seek_callback      See FLAC__StreamEncoderSeekCallback.  This
 *                            pointer may be \c NULL if seeking is not
 *                            supported.  The encoder uses seeking to go back
 *                            and write some some stream statistics to the
 *                            STREAMINFO block; this is recommended but not
 *                            necessary to create a valid FLAC stream.  If
 *                            \a seek_callback is not \c NULL then a
 *                            \a tell_callback must also be supplied.
 *                            Alternatively, a dummy seek callback that just
 *                            returns \c FLAC__STREAM_ENCODER_SEEK_STATUS_UNSUPPORTED
 *                            may also be supplied, all though this is slightly
 *                            less efficient for the encoder.
 * \param  tell_callback      See FLAC__StreamEncoderTellCallback.  This
 *                            pointer may be \c NULL if seeking is not
 *                            supported.  If \a seek_callback is \c NULL then
 *                            this argument will be ignored.  If
 *                            \a seek_callback is not \c NULL then a
 *                            \a tell_callback must also be supplied.
 *                            Alternatively, a dummy tell callback that just
 *                            returns \c FLAC__STREAM_ENCODER_TELL_STATUS_UNSUPPORTED
 *                            may also be supplied, all though this is slightly
 *                            less efficient for the encoder.
 * \param  metadata_callback  See FLAC__StreamEncoderMetadataCallback.  This
 *                            pointer may be \c NULL if the callback is not
 *                            desired.  If the client provides a seek callback,
 *                            this function is not necessary as the encoder
 *                            will automatically seek back and update the
 *                            STREAMINFO block.  It may also be \c NULL if the
 *                            client does not support seeking, since it will
 *                            have no way of going back to update the
 *                            STREAMINFO.  However the client can still supply
 *                            a callback if it would like to know the details
 *                            from the STREAMINFO.
 * \param  client_data        This value will be supplied to callbacks in their
 *                            \a client_data argument.
 * \assert
 *    \code encoder != NULL \endcode
 * \retval FLAC__StreamEncoderInitStatus
 *    \c FLAC__STREAM_ENCODER_INIT_STATUS_OK if initialization was successful;
 *    see FLAC__StreamEncoderInitStatus for the meanings of other return values.
 */
FLAC_API FLAC__StreamEncoderInitStatus FLAC__stream_encoder_init_ogg_stream(FLAC__StreamEncoder *encoder, FLAC__StreamEncoderReadCallback read_callback, FLAC__StreamEncoderWriteCallback write_callback, FLAC__StreamEncoderSeekCallback seek_callback, FLAC__StreamEncoderTellCallback tell_callback, FLAC__StreamEncoderMetadataCallback metadata_callback, void *client_data);

/** Initialize the encoder instance to encode native FLAC files.
 *
 *  This flavor of initialization sets up the encoder to encode to a
 *  plain native FLAC file.  For non-stdio streams, you must use
 *  FLAC__stream_encoder_init_stream() and provide callbacks for the I/O.
 *
 *  This function should be called after FLAC__stream_encoder_new() and
 *  FLAC__stream_encoder_set_*() but before FLAC__stream_encoder_process()
 *  or FLAC__stream_encoder_process_interleaved().
 *  initialization succeeded.
 *
 * \param  encoder            An uninitialized encoder instance.
 * \param  file               An open file.  The file should have been opened
 *                            with mode \c "w+b" and rewound.  The file
 *                            becomes owned by the encoder and should not be
 *                            manipulated by the client while encoding.
 *                            Unless \a file is \c stdout, it will be closed
 *                            when FLAC__stream_encoder_finish() is called.
 *                            Note however that a proper SEEKTABLE cannot be
 *                            created when encoding to \c stdout since it is
 *                            not seekable.
 * \param  progress_callback  See FLAC__StreamEncoderProgressCallback.  This
 *                            pointer may be \c NULL if the callback is not
 *                            desired.
 * \param  client_data        This value will be supplied to callbacks in their
 *                            \a client_data argument.
 * \assert
 *    \code encoder != NULL \endcode
 *    \code file != NULL \endcode
 * \retval FLAC__StreamEncoderInitStatus
 *    \c FLAC__STREAM_ENCODER_INIT_STATUS_OK if initialization was successful;
 *    see FLAC__StreamEncoderInitStatus for the meanings of other return values.
 */
FLAC_API FLAC__StreamEncoderInitStatus FLAC__stream_encoder_init_FILE(FLAC__StreamEncoder *encoder, FILE *file, FLAC__StreamEncoderProgressCallback progress_callback, void *client_data);

/** Initialize the encoder instance to encode Ogg FLAC files.
 *
 *  This flavor of initialization sets up the encoder to encode to a
 *  plain Ogg FLAC file.  For non-stdio streams, you must use
 *  FLAC__stream_encoder_init_ogg_stream() and provide callbacks for the I/O.
 *
 *  This function should be called after FLAC__stream_encoder_new() and
 *  FLAC__stream_encoder_set_*() but before FLAC__stream_encoder_process()
 *  or FLAC__stream_encoder_process_interleaved().
 *  initialization succeeded.
 *
 * \param  encoder            An uninitialized encoder instance.
 * \param  file               An open file.  The file should have been opened
 *                            with mode \c "w+b" and rewound.  The file
 *                            becomes owned by the encoder and should not be
 *                            manipulated by the client while encoding.
 *                            Unless \a file is \c stdout, it will be closed
 *                            when FLAC__stream_encoder_finish() is called.
 *                            Note however that a proper SEEKTABLE cannot be
 *                            created when encoding to \c stdout since it is
 *                            not seekable.
 * \param  progress_callback  See FLAC__StreamEncoderProgressCallback.  This
 *                            pointer may be \c NULL if the callback is not
 *                            desired.
 * \param  client_data        This value will be supplied to callbacks in their
 *                            \a client_data argument.
 * \assert
 *    \code encoder != NULL \endcode
 *    \code file != NULL \endcode
 * \retval FLAC__StreamEncoderInitStatus
 *    \c FLAC__STREAM_ENCODER_INIT_STATUS_OK if initialization was successful;
 *    see FLAC__StreamEncoderInitStatus for the meanings of other return values.
 */
FLAC_API FLAC__StreamEncoderInitStatus FLAC__stream_encoder_init_ogg_FILE(FLAC__StreamEncoder *encoder, FILE *file, FLAC__StreamEncoderProgressCallback progress_callback, void *client_data);

/** Initialize the encoder instance to encode native FLAC files.
 *
 *  This flavor of initialization sets up the encoder to encode to a plain
 *  FLAC file.  If POSIX fopen() semantics are not sufficient (for example,
 *  with Unicode filenames on Windows), you must use
 *  FLAC__stream_encoder_init_FILE(), or FLAC__stream_encoder_init_stream()
 *  and provide callbacks for the I/O.
 *
 *  This function should be called after FLAC__stream_encoder_new() and
 *  FLAC__stream_encoder_set_*() but before FLAC__stream_encoder_process()
 *  or FLAC__stream_encoder_process_interleaved().
 *  initialization succeeded.
 *
 * \param  encoder            An uninitialized encoder instance.
 * \param  filename           The name of the file to encode to.  The file will
 *                            be opened with fopen().  Use \c NULL to encode to
 *                            \c stdout.  Note however that a proper SEEKTABLE
 *                            cannot be created when encoding to \c stdout since
 *                            it is not seekable.
 * \param  progress_callback  See FLAC__StreamEncoderProgressCallback.  This
 *                            pointer may be \c NULL if the callback is not
 *                            desired.
 * \param  client_data        This value will be supplied to callbacks in their
 *                            \a client_data argument.
 * \assert
 *    \code encoder != NULL \endcode
 * \retval FLAC__StreamEncoderInitStatus
 *    \c FLAC__STREAM_ENCODER_INIT_STATUS_OK if initialization was successful;
 *    see FLAC__StreamEncoderInitStatus for the meanings of other return values.
 */
FLAC_API FLAC__StreamEncoderInitStatus FLAC__stream_encoder_init_file(FLAC__StreamEncoder *encoder, const char *filename, FLAC__StreamEncoderProgressCallback progress_callback, void *client_data);

/** Initialize the encoder instance to encode Ogg FLAC files.
 *
 *  This flavor of initialization sets up the encoder to encode to a plain
 *  Ogg FLAC file.  If POSIX fopen() semantics are not sufficient (for example,
 *  with Unicode filenames on Windows), you must use
 *  FLAC__stream_encoder_init_ogg_FILE(), or FLAC__stream_encoder_init_ogg_stream()
 *  and provide callbacks for the I/O.
 *
 *  This function should be called after FLAC__stream_encoder_new() and
 *  FLAC__stream_encoder_set_*() but before FLAC__stream_encoder_process()
 *  or FLAC__stream_encoder_process_interleaved().
 *  initialization succeeded.
 *
 * \param  encoder            An uninitialized encoder instance.
 * \param  filename           The name of the file to encode to.  The file will
 *                            be opened with fopen().  Use \c NULL to encode to
 *                            \c stdout.  Note however that a proper SEEKTABLE
 *                            cannot be created when encoding to \c stdout since
 *                            it is not seekable.
 * \param  progress_callback  See FLAC__StreamEncoderProgressCallback.  This
 *                            pointer may be \c NULL if the callback is not
 *                            desired.
 * \param  client_data        This value will be supplied to callbacks in their
 *                            \a client_data argument.
 * \assert
 *    \code encoder != NULL \endcode
 * \retval FLAC__StreamEncoderInitStatus
 *    \c FLAC__STREAM_ENCODER_INIT_STATUS_OK if initialization was successful;
 *    see FLAC__StreamEncoderInitStatus for the meanings of other return values.
 */
FLAC_API FLAC__StreamEncoderInitStatus FLAC__stream_encoder_init_ogg_file(FLAC__StreamEncoder *encoder, const char *filename, FLAC__StreamEncoderProgressCallback progress_callback, void *client_data);

/** Finish the encoding process.
 *  Flushes the encoding buffer, releases resources, resets the encoder
 *  settings to their defaults, and returns the encoder state to
 *  FLAC__STREAM_ENCODER_UNINITIALIZED.  Note that this can generate
 *  one or more write callbacks before returning, and will generate
 *  a metadata callback.
 *
 *  Note that in the course of processing the last frame, errors can
 *  occur, so the caller should be sure to check the return value to
 *  ensure the file was encoded properly.
 *
 *  In the event of a prematurely-terminated encode, it is not strictly
 *  necessary to call this immediately before FLAC__stream_encoder_delete()
 *  but it is good practice to match every FLAC__stream_encoder_init_*()
 *  with a FLAC__stream_encoder_finish().
 *
 * \param  encoder  An uninitialized encoder instance.
 * \assert
 *    \code encoder != NULL \endcode
 * \retval FLAC__bool
 *    \c false if an error occurred processing the last frame; or if verify
 *    mode is set (see FLAC__stream_encoder_set_verify()), there was a
 *    verify mismatch; else \c true.  If \c false, caller should check the
 *    state with FLAC__stream_encoder_get_state() for more information
 *    about the error.
 */
FLAC_API FLAC__bool FLAC__stream_encoder_finish(FLAC__StreamEncoder *encoder);

/** Submit data for encoding.
 *  This version allows you to supply the input data via an array of
 *  pointers, each pointer pointing to an array of \a samples samples
 *  representing one channel.  The samples need not be block-aligned,
 *  but each channel should have the same number of samples.  Each sample
 *  should be a signed integer, right-justified to the resolution set by
 *  FLAC__stream_encoder_set_bits_per_sample().  For example, if the
 *  resolution is 16 bits per sample, the samples should all be in the
 *  range [-32768,32767].
 *
 *  For applications where channel order is important, channels must
 *  follow the order as described in the
 *  <A HREF="../format.html#frame_header">frame header</A>.
 *
 * \param  encoder  An initialized encoder instance in the OK state.
 * \param  buffer   An array of pointers to each channel's signal.
 * \param  samples  The number of samples in one channel.
 * \assert
 *    \code encoder != NULL \endcode
 *    \code FLAC__stream_encoder_get_state(encoder) == FLAC__STREAM_ENCODER_OK \endcode
 * \retval FLAC__bool
 *    \c true if successful, else \c false; in this case, check the
 *    encoder state with FLAC__stream_encoder_get_state() to see what
 *    went wrong.
 */
FLAC_API FLAC__bool FLAC__stream_encoder_process(FLAC__StreamEncoder *encoder, const FLAC__int32 * const buffer[], unsigned samples);

/** Submit data for encoding.
 *  This version allows you to supply the input data where the channels
 *  are interleaved into a single array (i.e. channel0_sample0,
 *  channel1_sample0, ... , channelN_sample0, channel0_sample1, ...).
 *  The samples need not be block-aligned but they must be
 *  sample-aligned, i.e. the first value should be channel0_sample0
 *  and the last value channelN_sampleM.  Each sample should be a signed
 *  integer, right-justified to the resolution set by
 *  FLAC__stream_encoder_set_bits_per_sample().  For example, if the
 *  resolution is 16 bits per sample, the samples should all be in the
 *  range [-32768,32767].
 *
 *  For applications where channel order is important, channels must
 *  follow the order as described in the
 *  <A HREF="../format.html#frame_header">frame header</A>.
 *
 * \param  encoder  An initialized encoder instance in the OK state.
 * \param  buffer   An array of channel-interleaved data (see above).
 * \param  samples  The number of samples in one channel, the same as for
 *                  FLAC__stream_encoder_process().  For example, if
 *                  encoding two channels, \c 1000 \a samples corresponds
 *                  to a \a buffer of 2000 values.
 * \assert
 *    \code encoder != NULL \endcode
 *    \code FLAC__stream_encoder_get_state(encoder) == FLAC__STREAM_ENCODER_OK \endcode
 * \retval FLAC__bool
 *    \c true if successful, else \c false; in this case, check the
 *    encoder state with FLAC__stream_encoder_get_state() to see what
 *    went wrong.
 */
FLAC_API FLAC__bool FLAC__stream_encoder_process_interleaved(FLAC__StreamEncoder *encoder, const FLAC__int32 buffer[], unsigned samples);

/* \} */

#ifdef __cplusplus
}
#endif

#endif

/*** End of inlined file: stream_encoder.h ***/

#ifdef _MSC_VER
/* OPT: an MSVC built-in would be better */
static _inline FLAC__uint32 local_swap32_(FLAC__uint32 x)
{
	x = ((x<<8)&0xFF00FF00) | ((x>>8)&0x00FF00FF);
	return (x>>16) | (x<<16);
}
#endif

#if defined(_MSC_VER) && defined(_X86_)
/* OPT: an MSVC built-in would be better */
static void local_swap32_block_(FLAC__uint32 *start, FLAC__uint32 len)
{
	__asm {
		mov edx, start
		mov ecx, len
		test ecx, ecx
loop1:
		jz done1
		mov eax, [edx]
		bswap eax
		mov [edx], eax
		add edx, 4
		dec ecx
		jmp short loop1
done1:
	}
}
#endif

/** \mainpage
 *
 * \section intro Introduction
 *
 * This is the documentation for the FLAC C and C++ APIs.  It is
 * highly interconnected; this introduction should give you a top
 * level idea of the structure and how to find the information you
 * need.  As a prerequisite you should have at least a basic
 * knowledge of the FLAC format, documented
 * <A HREF="../format.html">here</A>.
 *
 * \section c_api FLAC C API
 *
 * The FLAC C API is the interface to libFLAC, a set of structures
 * describing the components of FLAC streams, and functions for
 * encoding and decoding streams, as well as manipulating FLAC
 * metadata in files.  The public include files will be installed
 * in your include area (for example /usr/include/FLAC/...).
 *
 * By writing a little code and linking against libFLAC, it is
 * relatively easy to add FLAC support to another program.  The
 * library is licensed under <A HREF="../license.html">Xiph's BSD license</A>.
 * Complete source code of libFLAC as well as the command-line
 * encoder and plugins is available and is a useful source of
 * examples.
 *
 * Aside from encoders and decoders, libFLAC provides a powerful
 * metadata interface for manipulating metadata in FLAC files.  It
 * allows the user to add, delete, and modify FLAC metadata blocks
 * and it can automatically take advantage of PADDING blocks to avoid
 * rewriting the entire FLAC file when changing the size of the
 * metadata.
 *
 * libFLAC usually only requires the standard C library and C math
 * library. In particular, threading is not used so there is no
 * dependency on a thread library. However, libFLAC does not use
 * global variables and should be thread-safe.
 *
 * libFLAC also supports encoding to and decoding from Ogg FLAC.
 * However the metadata editing interfaces currently have limited
 * read-only support for Ogg FLAC files.
 *
 * \section cpp_api FLAC C++ API
 *
 * The FLAC C++ API is a set of classes that encapsulate the
 * structures and functions in libFLAC.  They provide slightly more
 * functionality with respect to metadata but are otherwise
 * equivalent.  For the most part, they share the same usage as
 * their counterparts in libFLAC, and the FLAC C API documentation
 * can be used as a supplement.  The public include files
 * for the C++ API will be installed in your include area (for
 * example /usr/include/FLAC++/...).
 *
 * libFLAC++ is also licensed under
 * <A HREF="../license.html">Xiph's BSD license</A>.
 *
 * \section getting_started Getting Started
 *
 * A good starting point for learning the API is to browse through
 * the <A HREF="modules.html">modules</A>.  Modules are logical
 * groupings of related functions or classes, which correspond roughly
 * to header files or sections of header files.  Each module includes a
 * detailed description of the general usage of its functions or
 * classes.
 *
 * From there you can go on to look at the documentation of
 * individual functions.  You can see different views of the individual
 * functions through the links in top bar across this page.
 *
 * If you prefer a more hands-on approach, you can jump right to some
 * <A HREF="../documentation_example_code.html">example code</A>.
 *
 * \section porting_guide Porting Guide
 *
 * Starting with FLAC 1.1.3 a \link porting Porting Guide \endlink
 * has been introduced which gives detailed instructions on how to
 * port your code to newer versions of FLAC.
 *
 * \section embedded_developers Embedded Developers
 *
 * libFLAC has grown larger over time as more functionality has been
 * included, but much of it may be unnecessary for a particular embedded
 * implementation.  Unused parts may be pruned by some simple editing of
 * src/libFLAC/Makefile.am.  In general, the decoders, encoders, and
 * metadata interface are all independent from each other.
 *
 * It is easiest to just describe the dependencies:
 *
 * - All modules depend on the \link flac_format Format \endlink module.
 * - The decoders and encoders depend on the bitbuffer.
 * - The decoder is independent of the encoder.  The encoder uses the
 *   decoder because of the verify feature, but this can be removed if
 *   not needed.
 * - Parts of the metadata interface require the stream decoder (but not
 *   the encoder).
 * - Ogg support is selectable through the compile time macro
 *   \c FLAC__HAS_OGG.
 *
 * For example, if your application only requires the stream decoder, no
 * encoder, and no metadata interface, you can remove the stream encoder
 * and the metadata interface, which will greatly reduce the size of the
 * library.
 *
 * Also, there are several places in the libFLAC code with comments marked
 * with "OPT:" where a #define can be changed to enable code that might be
 * faster on a specific platform.  Experimenting with these can yield faster
 * binaries.
 */

/** \defgroup porting Porting Guide for New Versions
 *
 * This module describes differences in the library interfaces from
 * version to version.  It assists in the porting of code that uses
 * the libraries to newer versions of FLAC.
 *
 * One simple facility for making porting easier that has been added
 * in FLAC 1.1.3 is a set of \c #defines in \c export.h of each
 * library's includes (e.g. \c include/FLAC/export.h).  The
 * \c #defines mirror the libraries'
 * <A HREF="http://www.gnu.org/software/libtool/manual.html#Libtool-versioning">libtool version numbers</A>,
 * e.g. in libFLAC there are \c FLAC_API_VERSION_CURRENT,
 * \c FLAC_API_VERSION_REVISION, and \c FLAC_API_VERSION_AGE.
 * These can be used to support multiple versions of an API during the
 * transition phase, e.g.
 *
 * \code
 * #if !defined(FLAC_API_VERSION_CURRENT) || FLAC_API_VERSION_CURRENT <= 7
 *   legacy code
 * #else
 *   new code
 * #endif
 * \endcode
 *
 * The the source will work for multiple versions and the legacy code can
 * easily be removed when the transition is complete.
 *
 * Another available symbol is FLAC_API_SUPPORTS_OGG_FLAC (defined in
 * include/FLAC/export.h), which can be used to determine whether or not
 * the library has been compiled with support for Ogg FLAC.  This is
 * simpler than trying to call an Ogg init function and catching the
 * error.
 */

/** \defgroup porting_1_1_2_to_1_1_3 Porting from FLAC 1.1.2 to 1.1.3
 *  \ingroup porting
 *
 *  \brief
 *  This module describes porting from FLAC 1.1.2 to FLAC 1.1.3.
 *
 * The main change between the APIs in 1.1.2 and 1.1.3 is that they have
 * been simplified.  First, libOggFLAC has been merged into libFLAC and
 * libOggFLAC++ has been merged into libFLAC++.  Second, both the three
 * decoding layers and three encoding layers have been merged into a
 * single stream decoder and stream encoder.  That is, the functionality
 * of FLAC__SeekableStreamDecoder and FLAC__FileDecoder has been merged
 * into FLAC__StreamDecoder, and FLAC__SeekableStreamEncoder and
 * FLAC__FileEncoder into FLAC__StreamEncoder.  Only the
 * FLAC__StreamDecoder and FLAC__StreamEncoder remain.  What this means
 * is there is now a single API that can be used to encode or decode
 * streams to/from native FLAC or Ogg FLAC and the single API can work
 * on both seekable and non-seekable streams.
 *
 * Instead of creating an encoder or decoder of a certain layer, now the
 * client will always create a FLAC__StreamEncoder or
 * FLAC__StreamDecoder.  The old layers are now differentiated by the
 * initialization function.  For example, for the decoder,
 * FLAC__stream_decoder_init() has been replaced by
 * FLAC__stream_decoder_init_stream().  This init function takes
 * callbacks for the I/O, and the seeking callbacks are optional.  This
 * allows the client to use the same object for seekable and
 * non-seekable streams.  For decoding a FLAC file directly, the client
 * can use FLAC__stream_decoder_init_file() and pass just a filename
 * and fewer callbacks; most of the other callbacks are supplied
 * internally.  For situations where fopen()ing by filename is not
 * possible (e.g. Unicode filenames on Windows) the client can instead
 * open the file itself and supply the FILE* to
 * FLAC__stream_decoder_init_FILE().  The init functions now returns a
 * FLAC__StreamDecoderInitStatus instead of FLAC__StreamDecoderState.
 * Since the callbacks and client data are now passed to the init
 * function, the FLAC__stream_decoder_set_*_callback() functions and
 * FLAC__stream_decoder_set_client_data() are no longer needed.  The
 * rest of the calls to the decoder are the same as before.
 *
 * There are counterpart init functions for Ogg FLAC, e.g.
 * FLAC__stream_decoder_init_ogg_stream().  All the rest of the calls
 * and callbacks are the same as for native FLAC.
 *
 * As an example, in FLAC 1.1.2 a seekable stream decoder would have
 * been set up like so:
 *
 * \code
 * FLAC__SeekableStreamDecoder *decoder = FLAC__seekable_stream_decoder_new();
 * if(decoder == NULL) do_something;
 * FLAC__seekable_stream_decoder_set_md5_checking(decoder, true);
 * [... other settings ...]
 * FLAC__seekable_stream_decoder_set_read_callback(decoder, my_read_callback);
 * FLAC__seekable_stream_decoder_set_seek_callback(decoder, my_seek_callback);
 * FLAC__seekable_stream_decoder_set_tell_callback(decoder, my_tell_callback);
 * FLAC__seekable_stream_decoder_set_length_callback(decoder, my_length_callback);
 * FLAC__seekable_stream_decoder_set_eof_callback(decoder, my_eof_callback);
 * FLAC__seekable_stream_decoder_set_write_callback(decoder, my_write_callback);
 * FLAC__seekable_stream_decoder_set_metadata_callback(decoder, my_metadata_callback);
 * FLAC__seekable_stream_decoder_set_error_callback(decoder, my_error_callback);
 * FLAC__seekable_stream_decoder_set_client_data(decoder, my_client_data);
 * if(FLAC__seekable_stream_decoder_init(decoder) != FLAC__SEEKABLE_STREAM_DECODER_OK) do_something;
 * \endcode
 *
 * In FLAC 1.1.3 it is like this:
 *
 * \code
 * FLAC__StreamDecoder *decoder = FLAC__stream_decoder_new();
 * if(decoder == NULL) do_something;
 * FLAC__stream_decoder_set_md5_checking(decoder, true);
 * [... other settings ...]
 * if(FLAC__stream_decoder_init_stream(
 *   decoder,
 *   my_read_callback,
 *   my_seek_callback,      // or NULL
 *   my_tell_callback,      // or NULL
 *   my_length_callback,    // or NULL
 *   my_eof_callback,       // or NULL
 *   my_write_callback,
 *   my_metadata_callback,  // or NULL
 *   my_error_callback,
 *   my_client_data
 * ) != FLAC__STREAM_DECODER_INIT_STATUS_OK) do_something;
 * \endcode
 *
 * or you could do;
 *
 * \code
 * [...]
 * FILE *file = fopen("somefile.flac","rb");
 * if(file == NULL) do_somthing;
 * if(FLAC__stream_decoder_init_FILE(
 *   decoder,
 *   file,
 *   my_write_callback,
 *   my_metadata_callback,  // or NULL
 *   my_error_callback,
 *   my_client_data
 * ) != FLAC__STREAM_DECODER_INIT_STATUS_OK) do_something;
 * \endcode
 *
 * or just:
 *
 * \code
 * [...]
 * if(FLAC__stream_decoder_init_file(
 *   decoder,
 *   "somefile.flac",
 *   my_write_callback,
 *   my_metadata_callback,  // or NULL
 *   my_error_callback,
 *   my_client_data
 * ) != FLAC__STREAM_DECODER_INIT_STATUS_OK) do_something;
 * \endcode
 *
 * Another small change to the decoder is in how it handles unparseable
 * streams.  Before, when the decoder found an unparseable stream
 * (reserved for when the decoder encounters a stream from a future
 * encoder that it can't parse), it changed the state to
 * \c FLAC__STREAM_DECODER_UNPARSEABLE_STREAM.  Now the decoder instead
 * drops sync and calls the error callback with a new error code
 * \c FLAC__STREAM_DECODER_ERROR_STATUS_UNPARSEABLE_STREAM.  This is
 * more robust.  If your error callback does not discriminate on the the
 * error state, your code does not need to be changed.
 *
 * The encoder now has a new setting:
 * FLAC__stream_encoder_set_apodization().  This is for setting the
 * method used to window the data before LPC analysis.  You only need to
 * add a call to this function if the default is not suitable.   There
 * are also two new convenience functions that may be useful:
 * FLAC__metadata_object_cuesheet_calculate_cddb_id() and
 * FLAC__metadata_get_cuesheet().
 *
 * The \a bytes parameter to FLAC__StreamDecoderReadCallback,
 * FLAC__StreamEncoderReadCallback, and FLAC__StreamEncoderWriteCallback
 * is now \c size_t instead of \c unsigned.
 */

/** \defgroup porting_1_1_3_to_1_1_4 Porting from FLAC 1.1.3 to 1.1.4
 *  \ingroup porting
 *
 *  \brief
 *  This module describes porting from FLAC 1.1.3 to FLAC 1.1.4.
 *
 * There were no changes to any of the interfaces from 1.1.3 to 1.1.4.
 * There was a slight change in the implementation of
 * FLAC__stream_encoder_set_metadata(); the function now makes a copy
 * of the \a metadata array of pointers so the client no longer needs
 * to maintain it after the call.  The objects themselves that are
 * pointed to by the array are still not copied though and must be
 * maintained until the call to FLAC__stream_encoder_finish().
 */

/** \defgroup porting_1_1_4_to_1_2_0 Porting from FLAC 1.1.4 to 1.2.0
 *  \ingroup porting
 *
 *  \brief
 *  This module describes porting from FLAC 1.1.4 to FLAC 1.2.0.
 *
 * There were only very minor changes to the interfaces from 1.1.4 to 1.2.0.
 * In libFLAC, \c FLAC__format_sample_rate_is_subset() was added.
 * In libFLAC++, \c FLAC::Decoder::Stream::get_decode_position() was added.
 *
 * Finally, value of the constant \c FLAC__FRAME_HEADER_RESERVED_LEN
 * has changed to reflect the conversion of one of the reserved bits
 * into active use.  It used to be \c 2 and now is \c 1.  However the
 * FLAC frame header length has not changed, so to skip the proper
 * number of bits, use \c FLAC__FRAME_HEADER_RESERVED_LEN +
 * \c FLAC__FRAME_HEADER_BLOCKING_STRATEGY_LEN
 */

/** \defgroup flac FLAC C API
 *
 * The FLAC C API is the interface to libFLAC, a set of structures
 * describing the components of FLAC streams, and functions for
 * encoding and decoding streams, as well as manipulating FLAC
 * metadata in files.
 *
 * You should start with the format components as all other modules
 * are dependent on it.
 */

#endif

/*** End of inlined file: all.h ***/



/*** Start of inlined file: bitmath.c ***/
#if HAVE_CONFIG_H
#  include <config.h>
#endif


/*** Start of inlined file: bitmath.h ***/
#ifndef FLAC__PRIVATE__BITMATH_H
#define FLAC__PRIVATE__BITMATH_H

unsigned FLAC__bitmath_ilog2(FLAC__uint32 v);
unsigned FLAC__bitmath_ilog2_wide(FLAC__uint64 v);
unsigned FLAC__bitmath_silog2(int v);
unsigned FLAC__bitmath_silog2_wide(FLAC__int64 v);

#endif

/*** End of inlined file: bitmath.h ***/

/* An example of what FLAC__bitmath_ilog2() computes:
 *
 * ilog2( 0) = assertion failure
 * ilog2( 1) = 0
 * ilog2( 2) = 1
 * ilog2( 3) = 1
 * ilog2( 4) = 2
 * ilog2( 5) = 2
 * ilog2( 6) = 2
 * ilog2( 7) = 2
 * ilog2( 8) = 3
 * ilog2( 9) = 3
 * ilog2(10) = 3
 * ilog2(11) = 3
 * ilog2(12) = 3
 * ilog2(13) = 3
 * ilog2(14) = 3
 * ilog2(15) = 3
 * ilog2(16) = 4
 * ilog2(17) = 4
 * ilog2(18) = 4
 */
unsigned FLAC__bitmath_ilog2(FLAC__uint32 v)
{
	unsigned l = 0;
	FLAC__ASSERT(v > 0);
	while(v >>= 1)
		l++;
	return l;
}

unsigned FLAC__bitmath_ilog2_wide(FLAC__uint64 v)
{
	unsigned l = 0;
	FLAC__ASSERT(v > 0);
	while(v >>= 1)
		l++;
	return l;
}

/* An example of what FLAC__bitmath_silog2() computes:
 *
 * silog2(-10) = 5
 * silog2(- 9) = 5
 * silog2(- 8) = 4
 * silog2(- 7) = 4
 * silog2(- 6) = 4
 * silog2(- 5) = 4
 * silog2(- 4) = 3
 * silog2(- 3) = 3
 * silog2(- 2) = 2
 * silog2(- 1) = 2
 * silog2(  0) = 0
 * silog2(  1) = 2
 * silog2(  2) = 3
 * silog2(  3) = 3
 * silog2(  4) = 4
 * silog2(  5) = 4
 * silog2(  6) = 4
 * silog2(  7) = 4
 * silog2(  8) = 5
 * silog2(  9) = 5
 * silog2( 10) = 5
 */
unsigned FLAC__bitmath_silog2(int v)
{
	while(1) {
		if(v == 0) {
			return 0;
		}
		else if(v > 0) {
			unsigned l = 0;
			while(v) {
				l++;
				v >>= 1;
			}
			return l+1;
		}
		else if(v == -1) {
			return 2;
		}
		else {
			v++;
			v = -v;
		}
	}
}

unsigned FLAC__bitmath_silog2_wide(FLAC__int64 v)
{
	while(1) {
		if(v == 0) {
			return 0;
		}
		else if(v > 0) {
			unsigned l = 0;
			while(v) {
				l++;
				v >>= 1;
			}
			return l+1;
		}
		else if(v == -1) {
			return 2;
		}
		else {
			v++;
			v = -v;
		}
	}
}

/*** End of inlined file: bitmath.c ***/


/*** Start of inlined file: bitreader.c ***/
#if HAVE_CONFIG_H
#  include <config.h>
#endif

#include <stdlib.h> /* for malloc() */
#include <string.h> /* for memcpy(), memset() */
#ifdef _MSC_VER
#include <winsock.h> /* for ntohl() */
#elif defined FLAC__SYS_DARWIN
#include <machine/endian.h> /* for ntohl() */
#elif defined __MINGW32__
#include <winsock.h> /* for ntohl() */
#else
#include <netinet/in.h> /* for ntohl() */
#endif


/*** Start of inlined file: bitreader.h ***/
#ifndef FLAC__PRIVATE__BITREADER_H
#define FLAC__PRIVATE__BITREADER_H

#include <stdio.h> /* for FILE */


/*** Start of inlined file: cpu.h ***/
#ifndef FLAC__PRIVATE__CPU_H
#define FLAC__PRIVATE__CPU_H

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

typedef enum {
	FLAC__CPUINFO_TYPE_IA32,
	FLAC__CPUINFO_TYPE_PPC,
	FLAC__CPUINFO_TYPE_UNKNOWN
} FLAC__CPUInfo_Type;

typedef struct {
	FLAC__bool cpuid;
	FLAC__bool bswap;
	FLAC__bool cmov;
	FLAC__bool mmx;
	FLAC__bool fxsr;
	FLAC__bool sse;
	FLAC__bool sse2;
	FLAC__bool sse3;
	FLAC__bool ssse3;
	FLAC__bool _3dnow;
	FLAC__bool ext3dnow;
	FLAC__bool extmmx;
} FLAC__CPUInfo_IA32;

typedef struct {
	FLAC__bool altivec;
	FLAC__bool ppc64;
} FLAC__CPUInfo_PPC;

typedef struct {
	FLAC__bool use_asm;
	FLAC__CPUInfo_Type type;
	union {
		FLAC__CPUInfo_IA32 ia32;
		FLAC__CPUInfo_PPC ppc;
	} data;
} FLAC__CPUInfo;

void FLAC__cpu_info(FLAC__CPUInfo *info);

#ifndef FLAC__NO_ASM
#ifdef FLAC__CPU_IA32
#ifdef FLAC__HAS_NASM
FLAC__uint32 FLAC__cpu_have_cpuid_asm_ia32(void);
void         FLAC__cpu_info_asm_ia32(FLAC__uint32 *flags_edx, FLAC__uint32 *flags_ecx);
FLAC__uint32 FLAC__cpu_info_extended_amd_asm_ia32(void);
#endif
#endif
#endif

#endif

/*** End of inlined file: cpu.h ***/

/*
 * opaque structure definition
 */
struct FLAC__BitReader;
typedef struct FLAC__BitReader FLAC__BitReader;

typedef FLAC__bool (*FLAC__BitReaderReadCallback)(FLAC__byte buffer[], size_t *bytes, void *client_data);

/*
 * construction, deletion, initialization, etc functions
 */
FLAC__BitReader *FLAC__bitreader_new(void);
void FLAC__bitreader_delete(FLAC__BitReader *br);
FLAC__bool FLAC__bitreader_init(FLAC__BitReader *br, FLAC__CPUInfo cpu, FLAC__BitReaderReadCallback rcb, void *cd);
void FLAC__bitreader_free(FLAC__BitReader *br); /* does not 'free(br)' */
FLAC__bool FLAC__bitreader_clear(FLAC__BitReader *br);
void FLAC__bitreader_dump(const FLAC__BitReader *br, FILE *out);

/*
 * CRC functions
 */
void FLAC__bitreader_reset_read_crc16(FLAC__BitReader *br, FLAC__uint16 seed);
FLAC__uint16 FLAC__bitreader_get_read_crc16(FLAC__BitReader *br);

/*
 * info functions
 */
FLAC__bool FLAC__bitreader_is_consumed_byte_aligned(const FLAC__BitReader *br);
unsigned FLAC__bitreader_bits_left_for_byte_alignment(const FLAC__BitReader *br);
unsigned FLAC__bitreader_get_input_bits_unconsumed(const FLAC__BitReader *br);

/*
 * read functions
 */

FLAC__bool FLAC__bitreader_read_raw_uint32(FLAC__BitReader *br, FLAC__uint32 *val, unsigned bits);
FLAC__bool FLAC__bitreader_read_raw_int32(FLAC__BitReader *br, FLAC__int32 *val, unsigned bits);
FLAC__bool FLAC__bitreader_read_raw_uint64(FLAC__BitReader *br, FLAC__uint64 *val, unsigned bits);
FLAC__bool FLAC__bitreader_read_uint32_little_endian(FLAC__BitReader *br, FLAC__uint32 *val); /*only for bits=32*/
FLAC__bool FLAC__bitreader_skip_bits_no_crc(FLAC__BitReader *br, unsigned bits); /* WATCHOUT: does not CRC the skipped data! */ /*@@@@ add to unit tests */
FLAC__bool FLAC__bitreader_skip_byte_block_aligned_no_crc(FLAC__BitReader *br, unsigned nvals); /* WATCHOUT: does not CRC the read data! */
FLAC__bool FLAC__bitreader_read_byte_block_aligned_no_crc(FLAC__BitReader *br, FLAC__byte *val, unsigned nvals); /* WATCHOUT: does not CRC the read data! */
FLAC__bool FLAC__bitreader_read_unary_unsigned(FLAC__BitReader *br, unsigned *val);
FLAC__bool FLAC__bitreader_read_rice_signed(FLAC__BitReader *br, int *val, unsigned parameter);
FLAC__bool FLAC__bitreader_read_rice_signed_block(FLAC__BitReader *br, int vals[], unsigned nvals, unsigned parameter);
#ifndef FLAC__NO_ASM
#  ifdef FLAC__CPU_IA32
#    ifdef FLAC__HAS_NASM
FLAC__bool FLAC__bitreader_read_rice_signed_block_asm_ia32_bswap(FLAC__BitReader *br, int vals[], unsigned nvals, unsigned parameter);
#    endif
#  endif
#endif
#if 0 /* UNUSED */
FLAC__bool FLAC__bitreader_read_golomb_signed(FLAC__BitReader *br, int *val, unsigned parameter);
FLAC__bool FLAC__bitreader_read_golomb_unsigned(FLAC__BitReader *br, unsigned *val, unsigned parameter);
#endif
FLAC__bool FLAC__bitreader_read_utf8_uint32(FLAC__BitReader *br, FLAC__uint32 *val, FLAC__byte *raw, unsigned *rawlen);
FLAC__bool FLAC__bitreader_read_utf8_uint64(FLAC__BitReader *br, FLAC__uint64 *val, FLAC__byte *raw, unsigned *rawlen);

FLAC__bool bitreader_read_from_client_(FLAC__BitReader *br);
#endif

/*** End of inlined file: bitreader.h ***/


/*** Start of inlined file: crc.h ***/
#ifndef FLAC__PRIVATE__CRC_H
#define FLAC__PRIVATE__CRC_H

/* 8 bit CRC generator, MSB shifted first
** polynomial = x^8 + x^2 + x^1 + x^0
** init = 0
*/
extern FLAC__byte const FLAC__crc8_table[256];
#define FLAC__CRC8_UPDATE(data, crc) (crc) = FLAC__crc8_table[(crc) ^ (data)];
void FLAC__crc8_update(const FLAC__byte data, FLAC__uint8 *crc);
void FLAC__crc8_update_block(const FLAC__byte *data, unsigned len, FLAC__uint8 *crc);
FLAC__uint8 FLAC__crc8(const FLAC__byte *data, unsigned len);

/* 16 bit CRC generator, MSB shifted first
** polynomial = x^16 + x^15 + x^2 + x^0
** init = 0
*/
extern unsigned FLAC__crc16_table[256];

#define FLAC__CRC16_UPDATE(data, crc) (((((crc)<<8) & 0xffff) ^ FLAC__crc16_table[((crc)>>8) ^ (data)]))
/* this alternate may be faster on some systems/compilers */
#if 0
#define FLAC__CRC16_UPDATE(data, crc) ((((crc)<<8) ^ FLAC__crc16_table[((crc)>>8) ^ (data)]) & 0xffff)
#endif

unsigned FLAC__crc16(const FLAC__byte *data, unsigned len);

#endif

/*** End of inlined file: crc.h ***/

/* Things should be fastest when this matches the machine word size */
/* WATCHOUT: if you change this you must also change the following #defines down to COUNT_ZERO_MSBS below to match */
/* WATCHOUT: there are a few places where the code will not work unless brword is >= 32 bits wide */
/*           also, some sections currently only have fast versions for 4 or 8 bytes per word */
typedef FLAC__uint32 brword;
#define FLAC__BYTES_PER_WORD 4
#define FLAC__BITS_PER_WORD 32
#define FLAC__WORD_ALL_ONES ((FLAC__uint32)0xffffffff)
/* SWAP_BE_WORD_TO_HOST swaps bytes in a brword (which is always big-endian) if necessary to match host byte order */
#if WORDS_BIGENDIAN
#define SWAP_BE_WORD_TO_HOST(x) (x)
#else
#if defined (_MSC_VER) && defined (_X86_)
#define SWAP_BE_WORD_TO_HOST(x) local_swap32_(x)
#else
#define SWAP_BE_WORD_TO_HOST(x) ntohl(x)
#endif
#endif
/* counts the # of zero MSBs in a word */
#define COUNT_ZERO_MSBS(word) ( \
	(word) <= 0xffff ? \
		( (word) <= 0xff? byte_to_unary_table[word] + 24 : byte_to_unary_table[(word) >> 8] + 16 ) : \
		( (word) <= 0xffffff? byte_to_unary_table[word >> 16] + 8 : byte_to_unary_table[(word) >> 24] ) \
)
/* this alternate might be slightly faster on some systems/compilers: */
#define COUNT_ZERO_MSBS2(word) ( (word) <= 0xff ? byte_to_unary_table[word] + 24 : ((word) <= 0xffff ? byte_to_unary_table[(word) >> 8] + 16 : ((word) <= 0xffffff ? byte_to_unary_table[(word) >> 16] + 8 : byte_to_unary_table[(word) >> 24])) )

/*
 * This should be at least twice as large as the largest number of words
 * required to represent any 'number' (in any encoding) you are going to
 * read.  With FLAC this is on the order of maybe a few hundred bits.
 * If the buffer is smaller than that, the decoder won't be able to read
 * in a whole number that is in a variable length encoding (e.g. Rice).
 * But to be practical it should be at least 1K bytes.
 *
 * Increase this number to decrease the number of read callbacks, at the
 * expense of using more memory.  Or decrease for the reverse effect,
 * keeping in mind the limit from the first paragraph.  The optimal size
 * also depends on the CPU cache size and other factors; some twiddling
 * may be necessary to squeeze out the best performance.
 */
static const unsigned FLAC__BITREADER_DEFAULT_CAPACITY = 65536u / FLAC__BITS_PER_WORD; /* in words */

static const unsigned char byte_to_unary_table[] = {
	8, 7, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

#ifdef min
#undef min
#endif
#define min(x,y) ((x)<(y)?(x):(y))
#ifdef max
#undef max
#endif
#define max(x,y) ((x)>(y)?(x):(y))

/* adjust for compilers that can't understand using LLU suffix for uint64_t literals */
#ifdef _MSC_VER
#define FLAC__U64L(x) x
#else
#define FLAC__U64L(x) x##LLU
#endif

#ifndef FLaC__INLINE
#define FLaC__INLINE
#endif

/* WATCHOUT: assembly routines rely on the order in which these fields are declared */
struct FLAC__BitReader {
	/* any partially-consumed word at the head will stay right-justified as bits are consumed from the left */
	/* any incomplete word at the tail will be left-justified, and bytes from the read callback are added on the right */
	brword *buffer;
	unsigned capacity; /* in words */
	unsigned words; /* # of completed words in buffer */
	unsigned bytes; /* # of bytes in incomplete word at buffer[words] */
	unsigned consumed_words; /* #words ... */
	unsigned consumed_bits; /* ... + (#bits of head word) already consumed from the front of buffer */
	unsigned read_crc16; /* the running frame CRC */
	unsigned crc16_align; /* the number of bits in the current consumed word that should not be CRC'd */
	FLAC__BitReaderReadCallback read_callback;
	void *client_data;
	FLAC__CPUInfo cpu_info;
};

static FLaC__INLINE void crc16_update_word_(FLAC__BitReader *br, brword word)
{
	register unsigned crc = br->read_crc16;
#if FLAC__BYTES_PER_WORD == 4
	switch(br->crc16_align) {
		case  0: crc = FLAC__CRC16_UPDATE((unsigned)(word >> 24), crc);
		case  8: crc = FLAC__CRC16_UPDATE((unsigned)((word >> 16) & 0xff), crc);
		case 16: crc = FLAC__CRC16_UPDATE((unsigned)((word >> 8) & 0xff), crc);
		case 24: br->read_crc16 = FLAC__CRC16_UPDATE((unsigned)(word & 0xff), crc);
	}
#elif FLAC__BYTES_PER_WORD == 8
	switch(br->crc16_align) {
		case  0: crc = FLAC__CRC16_UPDATE((unsigned)(word >> 56), crc);
		case  8: crc = FLAC__CRC16_UPDATE((unsigned)((word >> 48) & 0xff), crc);
		case 16: crc = FLAC__CRC16_UPDATE((unsigned)((word >> 40) & 0xff), crc);
		case 24: crc = FLAC__CRC16_UPDATE((unsigned)((word >> 32) & 0xff), crc);
		case 32: crc = FLAC__CRC16_UPDATE((unsigned)((word >> 24) & 0xff), crc);
		case 40: crc = FLAC__CRC16_UPDATE((unsigned)((word >> 16) & 0xff), crc);
		case 48: crc = FLAC__CRC16_UPDATE((unsigned)((word >> 8) & 0xff), crc);
		case 56: br->read_crc16 = FLAC__CRC16_UPDATE((unsigned)(word & 0xff), crc);
	}
#else
	for( ; br->crc16_align < FLAC__BITS_PER_WORD; br->crc16_align += 8)
		crc = FLAC__CRC16_UPDATE((unsigned)((word >> (FLAC__BITS_PER_WORD-8-br->crc16_align)) & 0xff), crc);
	br->read_crc16 = crc;
#endif
	br->crc16_align = 0;
}

/* would be static except it needs to be called by asm routines */
FLAC__bool bitreader_read_from_client_(FLAC__BitReader *br)
{
	unsigned start, end;
	size_t bytes;
	FLAC__byte *target;

	/* first shift the unconsumed buffer data toward the front as much as possible */
	if(br->consumed_words > 0) {
		start = br->consumed_words;
		end = br->words + (br->bytes? 1:0);
		memmove(br->buffer, br->buffer+start, FLAC__BYTES_PER_WORD * (end - start));

		br->words -= start;
		br->consumed_words = 0;
	}

	/*
	 * set the target for reading, taking into account word alignment and endianness
	 */
	bytes = (br->capacity - br->words) * FLAC__BYTES_PER_WORD - br->bytes;
	if(bytes == 0)
		return false; /* no space left, buffer is too small; see note for FLAC__BITREADER_DEFAULT_CAPACITY  */
	target = ((FLAC__byte*)(br->buffer+br->words)) + br->bytes;

	/* before reading, if the existing reader looks like this (say brword is 32 bits wide)
	 *   bitstream :  11 22 33 44 55            br->words=1 br->bytes=1 (partial tail word is left-justified)
	 *   buffer[BE]:  11 22 33 44 55 ?? ?? ??   (shown layed out as bytes sequentially in memory)
	 *   buffer[LE]:  44 33 22 11 ?? ?? ?? 55   (?? being don't-care)
	 *                               ^^-------target, bytes=3
	 * on LE machines, have to byteswap the odd tail word so nothing is
	 * overwritten:
	 */
#if WORDS_BIGENDIAN
#else
	if(br->bytes)
		br->buffer[br->words] = SWAP_BE_WORD_TO_HOST(br->buffer[br->words]);
#endif

	/* now it looks like:
	 *   bitstream :  11 22 33 44 55            br->words=1 br->bytes=1
	 *   buffer[BE]:  11 22 33 44 55 ?? ?? ??
	 *   buffer[LE]:  44 33 22 11 55 ?? ?? ??
	 *                               ^^-------target, bytes=3
	 */

	/* read in the data; note that the callback may return a smaller number of bytes */
	if(!br->read_callback(target, &bytes, br->client_data))
		return false;

	/* after reading bytes 66 77 88 99 AA BB CC DD EE FF from the client:
	 *   bitstream :  11 22 33 44 55 66 77 88 99 AA BB CC DD EE FF
	 *   buffer[BE]:  11 22 33 44 55 66 77 88 99 AA BB CC DD EE FF ??
	 *   buffer[LE]:  44 33 22 11 55 66 77 88 99 AA BB CC DD EE FF ??
	 * now have to byteswap on LE machines:
	 */
#if WORDS_BIGENDIAN
#else
	end = (br->words*FLAC__BYTES_PER_WORD + br->bytes + bytes + (FLAC__BYTES_PER_WORD-1)) / FLAC__BYTES_PER_WORD;
# if defined(_MSC_VER) && defined (_X86_) && (FLAC__BYTES_PER_WORD == 4)
	if(br->cpu_info.type == FLAC__CPUINFO_TYPE_IA32 && br->cpu_info.data.ia32.bswap) {
		start = br->words;
		local_swap32_block_(br->buffer + start, end - start);
	}
	else
# endif
	for(start = br->words; start < end; start++)
		br->buffer[start] = SWAP_BE_WORD_TO_HOST(br->buffer[start]);
#endif

	/* now it looks like:
	 *   bitstream :  11 22 33 44 55 66 77 88 99 AA BB CC DD EE FF
	 *   buffer[BE]:  11 22 33 44 55 66 77 88 99 AA BB CC DD EE FF ??
	 *   buffer[LE]:  44 33 22 11 88 77 66 55 CC BB AA 99 ?? FF EE DD
	 * finally we'll update the reader values:
	 */
	end = br->words*FLAC__BYTES_PER_WORD + br->bytes + bytes;
	br->words = end / FLAC__BYTES_PER_WORD;
	br->bytes = end % FLAC__BYTES_PER_WORD;

	return true;
}

/***********************************************************************
 *
 * Class constructor/destructor
 *
 ***********************************************************************/

FLAC__BitReader *FLAC__bitreader_new(void)
{
	FLAC__BitReader *br = (FLAC__BitReader*)calloc(1, sizeof(FLAC__BitReader));

	/* calloc() implies:
		memset(br, 0, sizeof(FLAC__BitReader));
		br->buffer = 0;
		br->capacity = 0;
		br->words = br->bytes = 0;
		br->consumed_words = br->consumed_bits = 0;
		br->read_callback = 0;
		br->client_data = 0;
	*/
	return br;
}

void FLAC__bitreader_delete(FLAC__BitReader *br)
{
	FLAC__ASSERT(0 != br);

	FLAC__bitreader_free(br);
	free(br);
}

/***********************************************************************
 *
 * Public class methods
 *
 ***********************************************************************/

FLAC__bool FLAC__bitreader_init(FLAC__BitReader *br, FLAC__CPUInfo cpu, FLAC__BitReaderReadCallback rcb, void *cd)
{
	FLAC__ASSERT(0 != br);

	br->words = br->bytes = 0;
	br->consumed_words = br->consumed_bits = 0;
	br->capacity = FLAC__BITREADER_DEFAULT_CAPACITY;
	br->buffer = (brword*)malloc(sizeof(brword) * br->capacity);
	if(br->buffer == 0)
		return false;
	br->read_callback = rcb;
	br->client_data = cd;
	br->cpu_info = cpu;

	return true;
}

void FLAC__bitreader_free(FLAC__BitReader *br)
{
	FLAC__ASSERT(0 != br);

	if(0 != br->buffer)
		free(br->buffer);
	br->buffer = 0;
	br->capacity = 0;
	br->words = br->bytes = 0;
	br->consumed_words = br->consumed_bits = 0;
	br->read_callback = 0;
	br->client_data = 0;
}

FLAC__bool FLAC__bitreader_clear(FLAC__BitReader *br)
{
	br->words = br->bytes = 0;
	br->consumed_words = br->consumed_bits = 0;
	return true;
}

void FLAC__bitreader_dump(const FLAC__BitReader *br, FILE *out)
{
	unsigned i, j;
	if(br == 0) {
		fprintf(out, "bitreader is NULL\n");
	}
	else {
		fprintf(out, "bitreader: capacity=%u words=%u bytes=%u consumed: words=%u, bits=%u\n", br->capacity, br->words, br->bytes, br->consumed_words, br->consumed_bits);

		for(i = 0; i < br->words; i++) {
			fprintf(out, "%08X: ", i);
			for(j = 0; j < FLAC__BITS_PER_WORD; j++)
				if(i < br->consumed_words || (i == br->consumed_words && j < br->consumed_bits))
					fprintf(out, ".");
				else
					fprintf(out, "%01u", br->buffer[i] & (1 << (FLAC__BITS_PER_WORD-j-1)) ? 1:0);
			fprintf(out, "\n");
		}
		if(br->bytes > 0) {
			fprintf(out, "%08X: ", i);
			for(j = 0; j < br->bytes*8; j++)
				if(i < br->consumed_words || (i == br->consumed_words && j < br->consumed_bits))
					fprintf(out, ".");
				else
					fprintf(out, "%01u", br->buffer[i] & (1 << (br->bytes*8-j-1)) ? 1:0);
			fprintf(out, "\n");
		}
	}
}

void FLAC__bitreader_reset_read_crc16(FLAC__BitReader *br, FLAC__uint16 seed)
{
	FLAC__ASSERT(0 != br);
	FLAC__ASSERT(0 != br->buffer);
	FLAC__ASSERT((br->consumed_bits & 7) == 0);

	br->read_crc16 = (unsigned)seed;
	br->crc16_align = br->consumed_bits;
}

FLAC__uint16 FLAC__bitreader_get_read_crc16(FLAC__BitReader *br)
{
	FLAC__ASSERT(0 != br);
	FLAC__ASSERT(0 != br->buffer);
	FLAC__ASSERT((br->consumed_bits & 7) == 0);
	FLAC__ASSERT(br->crc16_align <= br->consumed_bits);

	/* CRC any tail bytes in a partially-consumed word */
	if(br->consumed_bits) {
		const brword tail = br->buffer[br->consumed_words];
		for( ; br->crc16_align < br->consumed_bits; br->crc16_align += 8)
			br->read_crc16 = FLAC__CRC16_UPDATE((unsigned)((tail >> (FLAC__BITS_PER_WORD-8-br->crc16_align)) & 0xff), br->read_crc16);
	}
	return br->read_crc16;
}

FLaC__INLINE FLAC__bool FLAC__bitreader_is_consumed_byte_aligned(const FLAC__BitReader *br)
{
	return ((br->consumed_bits & 7) == 0);
}

FLaC__INLINE unsigned FLAC__bitreader_bits_left_for_byte_alignment(const FLAC__BitReader *br)
{
	return 8 - (br->consumed_bits & 7);
}

FLaC__INLINE unsigned FLAC__bitreader_get_input_bits_unconsumed(const FLAC__BitReader *br)
{
	return (br->words-br->consumed_words)*FLAC__BITS_PER_WORD + br->bytes*8 - br->consumed_bits;
}

FLaC__INLINE FLAC__bool FLAC__bitreader_read_raw_uint32(FLAC__BitReader *br, FLAC__uint32 *val, unsigned bits)
{
	FLAC__ASSERT(0 != br);
	FLAC__ASSERT(0 != br->buffer);

	FLAC__ASSERT(bits <= 32);
	FLAC__ASSERT((br->capacity*FLAC__BITS_PER_WORD) * 2 >= bits);
	FLAC__ASSERT(br->consumed_words <= br->words);

	/* WATCHOUT: code does not work with <32bit words; we can make things much faster with this assertion */
	FLAC__ASSERT(FLAC__BITS_PER_WORD >= 32);

	if(bits == 0) { /* OPT: investigate if this can ever happen, maybe change to assertion */
		*val = 0;
		return true;
	}

	while((br->words-br->consumed_words)*FLAC__BITS_PER_WORD + br->bytes*8 - br->consumed_bits < bits) {
		if(!bitreader_read_from_client_(br))
			return false;
	}
	if(br->consumed_words < br->words) { /* if we've not consumed up to a partial tail word... */
		/* OPT: taking out the consumed_bits==0 "else" case below might make things faster if less code allows the compiler to inline this function */
		if(br->consumed_bits) {
			/* this also works when consumed_bits==0, it's just a little slower than necessary for that case */
			const unsigned n = FLAC__BITS_PER_WORD - br->consumed_bits;
			const brword word = br->buffer[br->consumed_words];
			if(bits < n) {
				*val = (word & (FLAC__WORD_ALL_ONES >> br->consumed_bits)) >> (n-bits);
				br->consumed_bits += bits;
				return true;
			}
			*val = word & (FLAC__WORD_ALL_ONES >> br->consumed_bits);
			bits -= n;
			crc16_update_word_(br, word);
			br->consumed_words++;
			br->consumed_bits = 0;
			if(bits) { /* if there are still bits left to read, there have to be less than 32 so they will all be in the next word */
				*val <<= bits;
				*val |= (br->buffer[br->consumed_words] >> (FLAC__BITS_PER_WORD-bits));
				br->consumed_bits = bits;
			}
			return true;
		}
		else {
			const brword word = br->buffer[br->consumed_words];
			if(bits < FLAC__BITS_PER_WORD) {
				*val = word >> (FLAC__BITS_PER_WORD-bits);
				br->consumed_bits = bits;
				return true;
			}
			/* at this point 'bits' must be == FLAC__BITS_PER_WORD; because of previous assertions, it can't be larger */
			*val = word;
			crc16_update_word_(br, word);
			br->consumed_words++;
			return true;
		}
	}
	else {
		/* in this case we're starting our read at a partial tail word;
		 * the reader has guaranteed that we have at least 'bits' bits
		 * available to read, which makes this case simpler.
		 */
		/* OPT: taking out the consumed_bits==0 "else" case below might make things faster if less code allows the compiler to inline this function */
		if(br->consumed_bits) {
			/* this also works when consumed_bits==0, it's just a little slower than necessary for that case */
			FLAC__ASSERT(br->consumed_bits + bits <= br->bytes*8);
			*val = (br->buffer[br->consumed_words] & (FLAC__WORD_ALL_ONES >> br->consumed_bits)) >> (FLAC__BITS_PER_WORD-br->consumed_bits-bits);
			br->consumed_bits += bits;
			return true;
		}
		else {
			*val = br->buffer[br->consumed_words] >> (FLAC__BITS_PER_WORD-bits);
			br->consumed_bits += bits;
			return true;
		}
	}
}

FLAC__bool FLAC__bitreader_read_raw_int32(FLAC__BitReader *br, FLAC__int32 *val, unsigned bits)
{
	/* OPT: inline raw uint32 code here, or make into a macro if possible in the .h file */
	if(!FLAC__bitreader_read_raw_uint32(br, (FLAC__uint32*)val, bits))
		return false;
	/* sign-extend: */
	*val <<= (32-bits);
	*val >>= (32-bits);
	return true;
}

FLAC__bool FLAC__bitreader_read_raw_uint64(FLAC__BitReader *br, FLAC__uint64 *val, unsigned bits)
{
	FLAC__uint32 hi, lo;

	if(bits > 32) {
		if(!FLAC__bitreader_read_raw_uint32(br, &hi, bits-32))
			return false;
		if(!FLAC__bitreader_read_raw_uint32(br, &lo, 32))
			return false;
		*val = hi;
		*val <<= 32;
		*val |= lo;
	}
	else {
		if(!FLAC__bitreader_read_raw_uint32(br, &lo, bits))
			return false;
		*val = lo;
	}
	return true;
}

FLaC__INLINE FLAC__bool FLAC__bitreader_read_uint32_little_endian(FLAC__BitReader *br, FLAC__uint32 *val)
{
	FLAC__uint32 x8, x32 = 0;

	/* this doesn't need to be that fast as currently it is only used for vorbis comments */

	if(!FLAC__bitreader_read_raw_uint32(br, &x32, 8))
		return false;

	if(!FLAC__bitreader_read_raw_uint32(br, &x8, 8))
		return false;
	x32 |= (x8 << 8);

	if(!FLAC__bitreader_read_raw_uint32(br, &x8, 8))
		return false;
	x32 |= (x8 << 16);

	if(!FLAC__bitreader_read_raw_uint32(br, &x8, 8))
		return false;
	x32 |= (x8 << 24);

	*val = x32;
	return true;
}

FLAC__bool FLAC__bitreader_skip_bits_no_crc(FLAC__BitReader *br, unsigned bits)
{
	/*
	 * OPT: a faster implementation is possible but probably not that useful
	 * since this is only called a couple of times in the metadata readers.
	 */
	FLAC__ASSERT(0 != br);
	FLAC__ASSERT(0 != br->buffer);

	if(bits > 0) {
		const unsigned n = br->consumed_bits & 7;
		unsigned m;
		FLAC__uint32 x;

		if(n != 0) {
			m = min(8-n, bits);
			if(!FLAC__bitreader_read_raw_uint32(br, &x, m))
				return false;
			bits -= m;
		}
		m = bits / 8;
		if(m > 0) {
			if(!FLAC__bitreader_skip_byte_block_aligned_no_crc(br, m))
				return false;
			bits %= 8;
		}
		if(bits > 0) {
			if(!FLAC__bitreader_read_raw_uint32(br, &x, bits))
				return false;
		}
	}

	return true;
}

FLAC__bool FLAC__bitreader_skip_byte_block_aligned_no_crc(FLAC__BitReader *br, unsigned nvals)
{
	FLAC__uint32 x;

	FLAC__ASSERT(0 != br);
	FLAC__ASSERT(0 != br->buffer);
	FLAC__ASSERT(FLAC__bitreader_is_consumed_byte_aligned(br));

	/* step 1: skip over partial head word to get word aligned */
	while(nvals && br->consumed_bits) { /* i.e. run until we read 'nvals' bytes or we hit the end of the head word */
		if(!FLAC__bitreader_read_raw_uint32(br, &x, 8))
			return false;
		nvals--;
	}
	if(0 == nvals)
		return true;
	/* step 2: skip whole words in chunks */
	while(nvals >= FLAC__BYTES_PER_WORD) {
		if(br->consumed_words < br->words) {
			br->consumed_words++;
			nvals -= FLAC__BYTES_PER_WORD;
		}
		else if(!bitreader_read_from_client_(br))
			return false;
	}
	/* step 3: skip any remainder from partial tail bytes */
	while(nvals) {
		if(!FLAC__bitreader_read_raw_uint32(br, &x, 8))
			return false;
		nvals--;
	}

	return true;
}

FLAC__bool FLAC__bitreader_read_byte_block_aligned_no_crc(FLAC__BitReader *br, FLAC__byte *val, unsigned nvals)
{
	FLAC__uint32 x;

	FLAC__ASSERT(0 != br);
	FLAC__ASSERT(0 != br->buffer);
	FLAC__ASSERT(FLAC__bitreader_is_consumed_byte_aligned(br));

	/* step 1: read from partial head word to get word aligned */
	while(nvals && br->consumed_bits) { /* i.e. run until we read 'nvals' bytes or we hit the end of the head word */
		if(!FLAC__bitreader_read_raw_uint32(br, &x, 8))
			return false;
		*val++ = (FLAC__byte)x;
		nvals--;
	}
	if(0 == nvals)
		return true;
	/* step 2: read whole words in chunks */
	while(nvals >= FLAC__BYTES_PER_WORD) {
		if(br->consumed_words < br->words) {
			const brword word = br->buffer[br->consumed_words++];
#if FLAC__BYTES_PER_WORD == 4
			val[0] = (FLAC__byte)(word >> 24);
			val[1] = (FLAC__byte)(word >> 16);
			val[2] = (FLAC__byte)(word >> 8);
			val[3] = (FLAC__byte)word;
#elif FLAC__BYTES_PER_WORD == 8
			val[0] = (FLAC__byte)(word >> 56);
			val[1] = (FLAC__byte)(word >> 48);
			val[2] = (FLAC__byte)(word >> 40);
			val[3] = (FLAC__byte)(word >> 32);
			val[4] = (FLAC__byte)(word >> 24);
			val[5] = (FLAC__byte)(word >> 16);
			val[6] = (FLAC__byte)(word >> 8);
			val[7] = (FLAC__byte)word;
#else
			for(x = 0; x < FLAC__BYTES_PER_WORD; x++)
				val[x] = (FLAC__byte)(word >> (8*(FLAC__BYTES_PER_WORD-x-1)));
#endif
			val += FLAC__BYTES_PER_WORD;
			nvals -= FLAC__BYTES_PER_WORD;
		}
		else if(!bitreader_read_from_client_(br))
			return false;
	}
	/* step 3: read any remainder from partial tail bytes */
	while(nvals) {
		if(!FLAC__bitreader_read_raw_uint32(br, &x, 8))
			return false;
		*val++ = (FLAC__byte)x;
		nvals--;
	}

	return true;
}

FLaC__INLINE FLAC__bool FLAC__bitreader_read_unary_unsigned(FLAC__BitReader *br, unsigned *val)
#if 0 /* slow but readable version */
{
	unsigned bit;

	FLAC__ASSERT(0 != br);
	FLAC__ASSERT(0 != br->buffer);

	*val = 0;
	while(1) {
		if(!FLAC__bitreader_read_bit(br, &bit))
			return false;
		if(bit)
			break;
		else
			*val++;
	}
	return true;
}
#else
{
	unsigned i;

	FLAC__ASSERT(0 != br);
	FLAC__ASSERT(0 != br->buffer);

	*val = 0;
	while(1) {
		while(br->consumed_words < br->words) { /* if we've not consumed up to a partial tail word... */
			brword b = br->buffer[br->consumed_words] << br->consumed_bits;
			if(b) {
				i = COUNT_ZERO_MSBS(b);
				*val += i;
				i++;
				br->consumed_bits += i;
				if(br->consumed_bits >= FLAC__BITS_PER_WORD) { /* faster way of testing if(br->consumed_bits == FLAC__BITS_PER_WORD) */
					crc16_update_word_(br, br->buffer[br->consumed_words]);
					br->consumed_words++;
					br->consumed_bits = 0;
				}
				return true;
			}
			else {
				*val += FLAC__BITS_PER_WORD - br->consumed_bits;
				crc16_update_word_(br, br->buffer[br->consumed_words]);
				br->consumed_words++;
				br->consumed_bits = 0;
				/* didn't find stop bit yet, have to keep going... */
			}
		}
		/* at this point we've eaten up all the whole words; have to try
		 * reading through any tail bytes before calling the read callback.
		 * this is a repeat of the above logic adjusted for the fact we
		 * don't have a whole word.  note though if the client is feeding
		 * us data a byte at a time (unlikely), br->consumed_bits may not
		 * be zero.
		 */
		if(br->bytes) {
			const unsigned end = br->bytes * 8;
			brword b = (br->buffer[br->consumed_words] & (FLAC__WORD_ALL_ONES << (FLAC__BITS_PER_WORD-end))) << br->consumed_bits;
			if(b) {
				i = COUNT_ZERO_MSBS(b);
				*val += i;
				i++;
				br->consumed_bits += i;
				FLAC__ASSERT(br->consumed_bits < FLAC__BITS_PER_WORD);
				return true;
			}
			else {
				*val += end - br->consumed_bits;
				br->consumed_bits += end;
				FLAC__ASSERT(br->consumed_bits < FLAC__BITS_PER_WORD);
				/* didn't find stop bit yet, have to keep going... */
			}
		}
		if(!bitreader_read_from_client_(br))
			return false;
	}
}
#endif

FLAC__bool FLAC__bitreader_read_rice_signed(FLAC__BitReader *br, int *val, unsigned parameter)
{
	FLAC__uint32 lsbs = 0, msbs = 0;
	unsigned uval;

	FLAC__ASSERT(0 != br);
	FLAC__ASSERT(0 != br->buffer);
	FLAC__ASSERT(parameter <= 31);

	/* read the unary MSBs and end bit */
	if(!FLAC__bitreader_read_unary_unsigned(br, (unsigned int*) &msbs))
		return false;

	/* read the binary LSBs */
	if(!FLAC__bitreader_read_raw_uint32(br, &lsbs, parameter))
		return false;

	/* compose the value */
	uval = (msbs << parameter) | lsbs;
	if(uval & 1)
		*val = -((int)(uval >> 1)) - 1;
	else
		*val = (int)(uval >> 1);

	return true;
}

/* this is by far the most heavily used reader call.  it ain't pretty but it's fast */
/* a lot of the logic is copied, then adapted, from FLAC__bitreader_read_unary_unsigned() and FLAC__bitreader_read_raw_uint32() */
FLAC__bool FLAC__bitreader_read_rice_signed_block(FLAC__BitReader *br, int vals[], unsigned nvals, unsigned parameter)
/* OPT: possibly faster version for use with MSVC */
#ifdef _MSC_VER
{
	unsigned i;
	unsigned uval = 0;
	unsigned bits; /* the # of binary LSBs left to read to finish a rice codeword */

	/* try and get br->consumed_words and br->consumed_bits into register;
	 * must remember to flush them back to *br before calling other
	 * bitwriter functions that use them, and before returning */
	register unsigned cwords;
	register unsigned cbits;

	FLAC__ASSERT(0 != br);
	FLAC__ASSERT(0 != br->buffer);
	/* WATCHOUT: code does not work with <32bit words; we can make things much faster with this assertion */
	FLAC__ASSERT(FLAC__BITS_PER_WORD >= 32);
	FLAC__ASSERT(parameter < 32);
	/* the above two asserts also guarantee that the binary part never straddles more that 2 words, so we don't have to loop to read it */

	if(nvals == 0)
		return true;

	cbits = br->consumed_bits;
	cwords = br->consumed_words;

	while(1) {

		/* read unary part */
		while(1) {
			while(cwords < br->words) { /* if we've not consumed up to a partial tail word... */
				brword b = br->buffer[cwords] << cbits;
				if(b) {
#if 0 /* slower, probably due to bad register allocation... */ && defined FLAC__CPU_IA32 && !defined FLAC__NO_ASM && FLAC__BITS_PER_WORD == 32
					__asm {
						bsr eax, b
						not eax
						and eax, 31
						mov i, eax
					}
#else
					i = COUNT_ZERO_MSBS(b);
#endif
					uval += i;
					bits = parameter;
					i++;
					cbits += i;
					if(cbits == FLAC__BITS_PER_WORD) {
						crc16_update_word_(br, br->buffer[cwords]);
						cwords++;
						cbits = 0;
					}
					goto break1;
				}
				else {
					uval += FLAC__BITS_PER_WORD - cbits;
					crc16_update_word_(br, br->buffer[cwords]);
					cwords++;
					cbits = 0;
					/* didn't find stop bit yet, have to keep going... */
				}
			}
			/* at this point we've eaten up all the whole words; have to try
			 * reading through any tail bytes before calling the read callback.
			 * this is a repeat of the above logic adjusted for the fact we
			 * don't have a whole word.  note though if the client is feeding
			 * us data a byte at a time (unlikely), br->consumed_bits may not
			 * be zero.
			 */
			if(br->bytes) {
				const unsigned end = br->bytes * 8;
				brword b = (br->buffer[cwords] & (FLAC__WORD_ALL_ONES << (FLAC__BITS_PER_WORD-end))) << cbits;
				if(b) {
					i = COUNT_ZERO_MSBS(b);
					uval += i;
					bits = parameter;
					i++;
					cbits += i;
					FLAC__ASSERT(cbits < FLAC__BITS_PER_WORD);
					goto break1;
				}
				else {
					uval += end - cbits;
					cbits += end;
					FLAC__ASSERT(cbits < FLAC__BITS_PER_WORD);
					/* didn't find stop bit yet, have to keep going... */
				}
			}
			/* flush registers and read; bitreader_read_from_client_() does
			 * not touch br->consumed_bits at all but we still need to set
			 * it in case it fails and we have to return false.
			 */
			br->consumed_bits = cbits;
			br->consumed_words = cwords;
			if(!bitreader_read_from_client_(br))
				return false;
			cwords = br->consumed_words;
		}
break1:
		/* read binary part */
		FLAC__ASSERT(cwords <= br->words);

		if(bits) {
			while((br->words-cwords)*FLAC__BITS_PER_WORD + br->bytes*8 - cbits < bits) {
				/* flush registers and read; bitreader_read_from_client_() does
				 * not touch br->consumed_bits at all but we still need to set
				 * it in case it fails and we have to return false.
				 */
				br->consumed_bits = cbits;
				br->consumed_words = cwords;
				if(!bitreader_read_from_client_(br))
					return false;
				cwords = br->consumed_words;
			}
			if(cwords < br->words) { /* if we've not consumed up to a partial tail word... */
				if(cbits) {
					/* this also works when consumed_bits==0, it's just a little slower than necessary for that case */
					const unsigned n = FLAC__BITS_PER_WORD - cbits;
					const brword word = br->buffer[cwords];
					if(bits < n) {
						uval <<= bits;
						uval |= (word & (FLAC__WORD_ALL_ONES >> cbits)) >> (n-bits);
						cbits += bits;
						goto break2;
					}
					uval <<= n;
					uval |= word & (FLAC__WORD_ALL_ONES >> cbits);
					bits -= n;
					crc16_update_word_(br, word);
					cwords++;
					cbits = 0;
					if(bits) { /* if there are still bits left to read, there have to be less than 32 so they will all be in the next word */
						uval <<= bits;
						uval |= (br->buffer[cwords] >> (FLAC__BITS_PER_WORD-bits));
						cbits = bits;
					}
					goto break2;
				}
				else {
					FLAC__ASSERT(bits < FLAC__BITS_PER_WORD);
					uval <<= bits;
					uval |= br->buffer[cwords] >> (FLAC__BITS_PER_WORD-bits);
					cbits = bits;
					goto break2;
				}
			}
			else {
				/* in this case we're starting our read at a partial tail word;
				 * the reader has guaranteed that we have at least 'bits' bits
				 * available to read, which makes this case simpler.
				 */
				uval <<= bits;
				if(cbits) {
					/* this also works when consumed_bits==0, it's just a little slower than necessary for that case */
					FLAC__ASSERT(cbits + bits <= br->bytes*8);
					uval |= (br->buffer[cwords] & (FLAC__WORD_ALL_ONES >> cbits)) >> (FLAC__BITS_PER_WORD-cbits-bits);
					cbits += bits;
					goto break2;
				}
				else {
					uval |= br->buffer[cwords] >> (FLAC__BITS_PER_WORD-bits);
					cbits += bits;
					goto break2;
				}
			}
		}
break2:
		/* compose the value */
		*vals = (int)(uval >> 1 ^ -(int)(uval & 1));

		/* are we done? */
		--nvals;
		if(nvals == 0) {
			br->consumed_bits = cbits;
			br->consumed_words = cwords;
			return true;
		}

		uval = 0;
		++vals;

	}
}
#else
{
	unsigned i;
	unsigned uval = 0;

	/* try and get br->consumed_words and br->consumed_bits into register;
	 * must remember to flush them back to *br before calling other
	 * bitwriter functions that use them, and before returning */
	register unsigned cwords;
	register unsigned cbits;
	unsigned ucbits; /* keep track of the number of unconsumed bits in the buffer */

	FLAC__ASSERT(0 != br);
	FLAC__ASSERT(0 != br->buffer);
	/* WATCHOUT: code does not work with <32bit words; we can make things much faster with this assertion */
	FLAC__ASSERT(FLAC__BITS_PER_WORD >= 32);
	FLAC__ASSERT(parameter < 32);
	/* the above two asserts also guarantee that the binary part never straddles more than 2 words, so we don't have to loop to read it */

	if(nvals == 0)
		return true;

	cbits = br->consumed_bits;
	cwords = br->consumed_words;
	ucbits = (br->words-cwords)*FLAC__BITS_PER_WORD + br->bytes*8 - cbits;

	while(1) {

		/* read unary part */
		while(1) {
			while(cwords < br->words) { /* if we've not consumed up to a partial tail word... */
				brword b = br->buffer[cwords] << cbits;
				if(b) {
#if 0 /* is not discernably faster... */ && defined FLAC__CPU_IA32 && !defined FLAC__NO_ASM && FLAC__BITS_PER_WORD == 32 && defined __GNUC__
					asm volatile (
						"bsrl %1, %0;"
						"notl %0;"
						"andl $31, %0;"
						: "=r"(i)
						: "r"(b)
					);
#else
					i = COUNT_ZERO_MSBS(b);
#endif
					uval += i;
					cbits += i;
					cbits++; /* skip over stop bit */
					if(cbits >= FLAC__BITS_PER_WORD) { /* faster way of testing if(cbits == FLAC__BITS_PER_WORD) */
						crc16_update_word_(br, br->buffer[cwords]);
						cwords++;
						cbits = 0;
					}
					goto break1;
				}
				else {
					uval += FLAC__BITS_PER_WORD - cbits;
					crc16_update_word_(br, br->buffer[cwords]);
					cwords++;
					cbits = 0;
					/* didn't find stop bit yet, have to keep going... */
				}
			}
			/* at this point we've eaten up all the whole words; have to try
			 * reading through any tail bytes before calling the read callback.
			 * this is a repeat of the above logic adjusted for the fact we
			 * don't have a whole word.  note though if the client is feeding
			 * us data a byte at a time (unlikely), br->consumed_bits may not
			 * be zero.
			 */
			if(br->bytes) {
				const unsigned end = br->bytes * 8;
				brword b = (br->buffer[cwords] & ~(FLAC__WORD_ALL_ONES >> end)) << cbits;
				if(b) {
					i = COUNT_ZERO_MSBS(b);
					uval += i;
					cbits += i;
					cbits++; /* skip over stop bit */
					FLAC__ASSERT(cbits < FLAC__BITS_PER_WORD);
					goto break1;
				}
				else {
					uval += end - cbits;
					cbits += end;
					FLAC__ASSERT(cbits < FLAC__BITS_PER_WORD);
					/* didn't find stop bit yet, have to keep going... */
				}
			}
			/* flush registers and read; bitreader_read_from_client_() does
			 * not touch br->consumed_bits at all but we still need to set
			 * it in case it fails and we have to return false.
			 */
			br->consumed_bits = cbits;
			br->consumed_words = cwords;
			if(!bitreader_read_from_client_(br))
				return false;
			cwords = br->consumed_words;
			ucbits = (br->words-cwords)*FLAC__BITS_PER_WORD + br->bytes*8 - cbits + uval;
			/* + uval to offset our count by the # of unary bits already
			 * consumed before the read, because we will add these back
			 * in all at once at break1
			 */
		}
break1:
		ucbits -= uval;
		ucbits--; /* account for stop bit */

		/* read binary part */
		FLAC__ASSERT(cwords <= br->words);

		if(parameter) {
			while(ucbits < parameter) {
				/* flush registers and read; bitreader_read_from_client_() does
				 * not touch br->consumed_bits at all but we still need to set
				 * it in case it fails and we have to return false.
				 */
				br->consumed_bits = cbits;
				br->consumed_words = cwords;
				if(!bitreader_read_from_client_(br))
					return false;
				cwords = br->consumed_words;
				ucbits = (br->words-cwords)*FLAC__BITS_PER_WORD + br->bytes*8 - cbits;
			}
			if(cwords < br->words) { /* if we've not consumed up to a partial tail word... */
				if(cbits) {
					/* this also works when consumed_bits==0, it's just slower than necessary for that case */
					const unsigned n = FLAC__BITS_PER_WORD - cbits;
					const brword word = br->buffer[cwords];
					if(parameter < n) {
						uval <<= parameter;
						uval |= (word & (FLAC__WORD_ALL_ONES >> cbits)) >> (n-parameter);
						cbits += parameter;
					}
					else {
						uval <<= n;
						uval |= word & (FLAC__WORD_ALL_ONES >> cbits);
						crc16_update_word_(br, word);
						cwords++;
						cbits = parameter - n;
						if(cbits) { /* parameter > n, i.e. if there are still bits left to read, there have to be less than 32 so they will all be in the next word */
							uval <<= cbits;
							uval |= (br->buffer[cwords] >> (FLAC__BITS_PER_WORD-cbits));
						}
					}
				}
				else {
					cbits = parameter;
					uval <<= parameter;
					uval |= br->buffer[cwords] >> (FLAC__BITS_PER_WORD-cbits);
				}
			}
			else {
				/* in this case we're starting our read at a partial tail word;
				 * the reader has guaranteed that we have at least 'parameter'
				 * bits available to read, which makes this case simpler.
				 */
				uval <<= parameter;
				if(cbits) {
					/* this also works when consumed_bits==0, it's just a little slower than necessary for that case */
					FLAC__ASSERT(cbits + parameter <= br->bytes*8);
					uval |= (br->buffer[cwords] & (FLAC__WORD_ALL_ONES >> cbits)) >> (FLAC__BITS_PER_WORD-cbits-parameter);
					cbits += parameter;
				}
				else {
					cbits = parameter;
					uval |= br->buffer[cwords] >> (FLAC__BITS_PER_WORD-cbits);
				}
			}
		}

		ucbits -= parameter;

		/* compose the value */
		*vals = (int)(uval >> 1 ^ -(int)(uval & 1));

		/* are we done? */
		--nvals;
		if(nvals == 0) {
			br->consumed_bits = cbits;
			br->consumed_words = cwords;
			return true;
		}

		uval = 0;
		++vals;

	}
}
#endif

#if 0 /* UNUSED */
FLAC__bool FLAC__bitreader_read_golomb_signed(FLAC__BitReader *br, int *val, unsigned parameter)
{
	FLAC__uint32 lsbs = 0, msbs = 0;
	unsigned bit, uval, k;

	FLAC__ASSERT(0 != br);
	FLAC__ASSERT(0 != br->buffer);

	k = FLAC__bitmath_ilog2(parameter);

	/* read the unary MSBs and end bit */
	if(!FLAC__bitreader_read_unary_unsigned(br, &msbs))
		return false;

	/* read the binary LSBs */
	if(!FLAC__bitreader_read_raw_uint32(br, &lsbs, k))
		return false;

	if(parameter == 1u<<k) {
		/* compose the value */
		uval = (msbs << k) | lsbs;
	}
	else {
		unsigned d = (1 << (k+1)) - parameter;
		if(lsbs >= d) {
			if(!FLAC__bitreader_read_bit(br, &bit))
				return false;
			lsbs <<= 1;
			lsbs |= bit;
			lsbs -= d;
		}
		/* compose the value */
		uval = msbs * parameter + lsbs;
	}

	/* unfold unsigned to signed */
	if(uval & 1)
		*val = -((int)(uval >> 1)) - 1;
	else
		*val = (int)(uval >> 1);

	return true;
}

FLAC__bool FLAC__bitreader_read_golomb_unsigned(FLAC__BitReader *br, unsigned *val, unsigned parameter)
{
	FLAC__uint32 lsbs, msbs = 0;
	unsigned bit, k;

	FLAC__ASSERT(0 != br);
	FLAC__ASSERT(0 != br->buffer);

	k = FLAC__bitmath_ilog2(parameter);

	/* read the unary MSBs and end bit */
	if(!FLAC__bitreader_read_unary_unsigned(br, &msbs))
		return false;

	/* read the binary LSBs */
	if(!FLAC__bitreader_read_raw_uint32(br, &lsbs, k))
		return false;

	if(parameter == 1u<<k) {
		/* compose the value */
		*val = (msbs << k) | lsbs;
	}
	else {
		unsigned d = (1 << (k+1)) - parameter;
		if(lsbs >= d) {
			if(!FLAC__bitreader_read_bit(br, &bit))
				return false;
			lsbs <<= 1;
			lsbs |= bit;
			lsbs -= d;
		}
		/* compose the value */
		*val = msbs * parameter + lsbs;
	}

	return true;
}
#endif /* UNUSED */

/* on return, if *val == 0xffffffff then the utf-8 sequence was invalid, but the return value will be true */
FLAC__bool FLAC__bitreader_read_utf8_uint32(FLAC__BitReader *br, FLAC__uint32 *val, FLAC__byte *raw, unsigned *rawlen)
{
	FLAC__uint32 v = 0;
	FLAC__uint32 x;
	unsigned i;

	if(!FLAC__bitreader_read_raw_uint32(br, &x, 8))
		return false;
	if(raw)
		raw[(*rawlen)++] = (FLAC__byte)x;
	if(!(x & 0x80)) { /* 0xxxxxxx */
		v = x;
		i = 0;
	}
	else if(x & 0xC0 && !(x & 0x20)) { /* 110xxxxx */
		v = x & 0x1F;
		i = 1;
	}
	else if(x & 0xE0 && !(x & 0x10)) { /* 1110xxxx */
		v = x & 0x0F;
		i = 2;
	}
	else if(x & 0xF0 && !(x & 0x08)) { /* 11110xxx */
		v = x & 0x07;
		i = 3;
	}
	else if(x & 0xF8 && !(x & 0x04)) { /* 111110xx */
		v = x & 0x03;
		i = 4;
	}
	else if(x & 0xFC && !(x & 0x02)) { /* 1111110x */
		v = x & 0x01;
		i = 5;
	}
	else {
		*val = 0xffffffff;
		return true;
	}
	for( ; i; i--) {
		if(!FLAC__bitreader_read_raw_uint32(br, &x, 8))
			return false;
		if(raw)
			raw[(*rawlen)++] = (FLAC__byte)x;
		if(!(x & 0x80) || (x & 0x40)) { /* 10xxxxxx */
			*val = 0xffffffff;
			return true;
		}
		v <<= 6;
		v |= (x & 0x3F);
	}
	*val = v;
	return true;
}

/* on return, if *val == 0xffffffffffffffff then the utf-8 sequence was invalid, but the return value will be true */
FLAC__bool FLAC__bitreader_read_utf8_uint64(FLAC__BitReader *br, FLAC__uint64 *val, FLAC__byte *raw, unsigned *rawlen)
{
	FLAC__uint64 v = 0;
	FLAC__uint32 x;
	unsigned i;

	if(!FLAC__bitreader_read_raw_uint32(br, &x, 8))
		return false;
	if(raw)
		raw[(*rawlen)++] = (FLAC__byte)x;
	if(!(x & 0x80)) { /* 0xxxxxxx */
		v = x;
		i = 0;
	}
	else if(x & 0xC0 && !(x & 0x20)) { /* 110xxxxx */
		v = x & 0x1F;
		i = 1;
	}
	else if(x & 0xE0 && !(x & 0x10)) { /* 1110xxxx */
		v = x & 0x0F;
		i = 2;
	}
	else if(x & 0xF0 && !(x & 0x08)) { /* 11110xxx */
		v = x & 0x07;
		i = 3;
	}
	else if(x & 0xF8 && !(x & 0x04)) { /* 111110xx */
		v = x & 0x03;
		i = 4;
	}
	else if(x & 0xFC && !(x & 0x02)) { /* 1111110x */
		v = x & 0x01;
		i = 5;
	}
	else if(x & 0xFE && !(x & 0x01)) { /* 11111110 */
		v = 0;
		i = 6;
	}
	else {
		*val = FLAC__U64L(0xffffffffffffffff);
		return true;
	}
	for( ; i; i--) {
		if(!FLAC__bitreader_read_raw_uint32(br, &x, 8))
			return false;
		if(raw)
			raw[(*rawlen)++] = (FLAC__byte)x;
		if(!(x & 0x80) || (x & 0x40)) { /* 10xxxxxx */
			*val = FLAC__U64L(0xffffffffffffffff);
			return true;
		}
		v <<= 6;
		v |= (x & 0x3F);
	}
	*val = v;
	return true;
}

/*** End of inlined file: bitreader.c ***/


/*** Start of inlined file: bitwriter.c ***/
#if HAVE_CONFIG_H
#  include <config.h>
#endif

#include <stdlib.h> /* for malloc() */
#include <string.h> /* for memcpy(), memset() */
#ifdef _MSC_VER
#include <winsock.h> /* for ntohl() */
#elif defined FLAC__SYS_DARWIN
#include <machine/endian.h> /* for ntohl() */
#elif defined __MINGW32__
#include <winsock.h> /* for ntohl() */
#else
#include <netinet/in.h> /* for ntohl() */
#endif
#if 0 /* UNUSED */

#endif

/*** Start of inlined file: bitwriter.h ***/
#ifndef FLAC__PRIVATE__BITWRITER_H
#define FLAC__PRIVATE__BITWRITER_H

#include <stdio.h> /* for FILE */

/*
 * opaque structure definition
 */
struct FLAC__BitWriter;
typedef struct FLAC__BitWriter FLAC__BitWriter;

/*
 * construction, deletion, initialization, etc functions
 */
FLAC__BitWriter *FLAC__bitwriter_new(void);
void FLAC__bitwriter_delete(FLAC__BitWriter *bw);
FLAC__bool FLAC__bitwriter_init(FLAC__BitWriter *bw);
void FLAC__bitwriter_free(FLAC__BitWriter *bw); /* does not 'free(buffer)' */
void FLAC__bitwriter_clear(FLAC__BitWriter *bw);
void FLAC__bitwriter_dump(const FLAC__BitWriter *bw, FILE *out);

/*
 * CRC functions
 *
 * non-const *bw because they have to cal FLAC__bitwriter_get_buffer()
 */
FLAC__bool FLAC__bitwriter_get_write_crc16(FLAC__BitWriter *bw, FLAC__uint16 *crc);
FLAC__bool FLAC__bitwriter_get_write_crc8(FLAC__BitWriter *bw, FLAC__byte *crc);

/*
 * info functions
 */
FLAC__bool FLAC__bitwriter_is_byte_aligned(const FLAC__BitWriter *bw);
unsigned FLAC__bitwriter_get_input_bits_unconsumed(const FLAC__BitWriter *bw); /* can be called anytime, returns total # of bits unconsumed */

/*
 * direct buffer access
 *
 * there may be no calls on the bitwriter between get and release.
 * the bitwriter continues to own the returned buffer.
 * before get, bitwriter MUST be byte aligned: check with FLAC__bitwriter_is_byte_aligned()
 */
FLAC__bool FLAC__bitwriter_get_buffer(FLAC__BitWriter *bw, const FLAC__byte **buffer, size_t *bytes);
void FLAC__bitwriter_release_buffer(FLAC__BitWriter *bw);

/*
 * write functions
 */
FLAC__bool FLAC__bitwriter_write_zeroes(FLAC__BitWriter *bw, unsigned bits);
FLAC__bool FLAC__bitwriter_write_raw_uint32(FLAC__BitWriter *bw, FLAC__uint32 val, unsigned bits);
FLAC__bool FLAC__bitwriter_write_raw_int32(FLAC__BitWriter *bw, FLAC__int32 val, unsigned bits);
FLAC__bool FLAC__bitwriter_write_raw_uint64(FLAC__BitWriter *bw, FLAC__uint64 val, unsigned bits);
FLAC__bool FLAC__bitwriter_write_raw_uint32_little_endian(FLAC__BitWriter *bw, FLAC__uint32 val); /*only for bits=32*/
FLAC__bool FLAC__bitwriter_write_byte_block(FLAC__BitWriter *bw, const FLAC__byte vals[], unsigned nvals);
FLAC__bool FLAC__bitwriter_write_unary_unsigned(FLAC__BitWriter *bw, unsigned val);
unsigned FLAC__bitwriter_rice_bits(FLAC__int32 val, unsigned parameter);
#if 0 /* UNUSED */
unsigned FLAC__bitwriter_golomb_bits_signed(int val, unsigned parameter);
unsigned FLAC__bitwriter_golomb_bits_unsigned(unsigned val, unsigned parameter);
#endif
FLAC__bool FLAC__bitwriter_write_rice_signed(FLAC__BitWriter *bw, FLAC__int32 val, unsigned parameter);
FLAC__bool FLAC__bitwriter_write_rice_signed_block(FLAC__BitWriter *bw, const FLAC__int32 *vals, unsigned nvals, unsigned parameter);
#if 0 /* UNUSED */
FLAC__bool FLAC__bitwriter_write_golomb_signed(FLAC__BitWriter *bw, int val, unsigned parameter);
FLAC__bool FLAC__bitwriter_write_golomb_unsigned(FLAC__BitWriter *bw, unsigned val, unsigned parameter);
#endif
FLAC__bool FLAC__bitwriter_write_utf8_uint32(FLAC__BitWriter *bw, FLAC__uint32 val);
FLAC__bool FLAC__bitwriter_write_utf8_uint64(FLAC__BitWriter *bw, FLAC__uint64 val);
FLAC__bool FLAC__bitwriter_zero_pad_to_byte_boundary(FLAC__BitWriter *bw);

#endif

/*** End of inlined file: bitwriter.h ***/



/*** Start of inlined file: alloc.h ***/
#ifndef FLAC__SHARE__ALLOC_H
#define FLAC__SHARE__ALLOC_H

#if HAVE_CONFIG_H
#  include <config.h>
#endif

/* WATCHOUT: for c++ you may have to #define __STDC_LIMIT_MACROS 1 real early
 * before #including this file,  otherwise SIZE_MAX might not be defined
 */

#include <limits.h> /* for SIZE_MAX */
#if !defined _MSC_VER && !defined __MINGW32__ && !defined __EMX__
#include <stdint.h> /* for SIZE_MAX in case limits.h didn't get it */
#endif
#include <stdlib.h> /* for size_t, malloc(), etc */

#ifndef SIZE_MAX
# ifndef SIZE_T_MAX
#  ifdef _MSC_VER
#   define SIZE_T_MAX UINT_MAX
#  else
#   error
#  endif
# endif
# define SIZE_MAX SIZE_T_MAX
#endif

#ifndef FLaC__INLINE
#define FLaC__INLINE
#endif

/* avoid malloc()ing 0 bytes, see:
 * https://www.securecoding.cert.org/confluence/display/seccode/MEM04-A.+Do+not+make+assumptions+about+the+result+of+allocating+0+bytes?focusedCommentId=5407003
*/
static FLaC__INLINE void *safe_malloc_(size_t size)
{
	/* malloc(0) is undefined; FLAC src convention is to always allocate */
	if(!size)
		size++;
	return malloc(size);
}

static FLaC__INLINE void *safe_calloc_(size_t nmemb, size_t size)
{
	if(!nmemb || !size)
		return malloc(1); /* malloc(0) is undefined; FLAC src convention is to always allocate */
	return calloc(nmemb, size);
}

/*@@@@ there's probably a better way to prevent overflows when allocating untrusted sums but this works for now */

static FLaC__INLINE void *safe_malloc_add_2op_(size_t size1, size_t size2)
{
	size2 += size1;
	if(size2 < size1)
		return 0;
	return safe_malloc_(size2);
}

static FLaC__INLINE void *safe_malloc_add_3op_(size_t size1, size_t size2, size_t size3)
{
	size2 += size1;
	if(size2 < size1)
		return 0;
	size3 += size2;
	if(size3 < size2)
		return 0;
	return safe_malloc_(size3);
}

static FLaC__INLINE void *safe_malloc_add_4op_(size_t size1, size_t size2, size_t size3, size_t size4)
{
	size2 += size1;
	if(size2 < size1)
		return 0;
	size3 += size2;
	if(size3 < size2)
		return 0;
	size4 += size3;
	if(size4 < size3)
		return 0;
	return safe_malloc_(size4);
}

static FLaC__INLINE void *safe_malloc_mul_2op_(size_t size1, size_t size2)
#if 0
needs support for cases where sizeof(size_t) != 4
{
	/* could be faster #ifdef'ing off SIZEOF_SIZE_T */
	if(sizeof(size_t) == 4) {
		if ((double)size1 * (double)size2 < 4294967296.0)
			return malloc(size1*size2);
	}
	return 0;
}
#else
/* better? */
{
	if(!size1 || !size2)
		return malloc(1); /* malloc(0) is undefined; FLAC src convention is to always allocate */
	if(size1 > SIZE_MAX / size2)
		return 0;
	return malloc(size1*size2);
}
#endif

static FLaC__INLINE void *safe_malloc_mul_3op_(size_t size1, size_t size2, size_t size3)
{
	if(!size1 || !size2 || !size3)
		return malloc(1); /* malloc(0) is undefined; FLAC src convention is to always allocate */
	if(size1 > SIZE_MAX / size2)
		return 0;
	size1 *= size2;
	if(size1 > SIZE_MAX / size3)
		return 0;
	return malloc(size1*size3);
}

/* size1*size2 + size3 */
static FLaC__INLINE void *safe_malloc_mul2add_(size_t size1, size_t size2, size_t size3)
{
	if(!size1 || !size2)
		return safe_malloc_(size3);
	if(size1 > SIZE_MAX / size2)
		return 0;
	return safe_malloc_add_2op_(size1*size2, size3);
}

/* size1 * (size2 + size3) */
static FLaC__INLINE void *safe_malloc_muladd2_(size_t size1, size_t size2, size_t size3)
{
	if(!size1 || (!size2 && !size3))
		return malloc(1); /* malloc(0) is undefined; FLAC src convention is to always allocate */
	size2 += size3;
	if(size2 < size3)
		return 0;
	return safe_malloc_mul_2op_(size1, size2);
}

static FLaC__INLINE void *safe_realloc_add_2op_(void *ptr, size_t size1, size_t size2)
{
	size2 += size1;
	if(size2 < size1)
		return 0;
	return realloc(ptr, size2);
}

static FLaC__INLINE void *safe_realloc_add_3op_(void *ptr, size_t size1, size_t size2, size_t size3)
{
	size2 += size1;
	if(size2 < size1)
		return 0;
	size3 += size2;
	if(size3 < size2)
		return 0;
	return realloc(ptr, size3);
}

static FLaC__INLINE void *safe_realloc_add_4op_(void *ptr, size_t size1, size_t size2, size_t size3, size_t size4)
{
	size2 += size1;
	if(size2 < size1)
		return 0;
	size3 += size2;
	if(size3 < size2)
		return 0;
	size4 += size3;
	if(size4 < size3)
		return 0;
	return realloc(ptr, size4);
}

static FLaC__INLINE void *safe_realloc_mul_2op_(void *ptr, size_t size1, size_t size2)
{
	if(!size1 || !size2)
		return realloc(ptr, 0); /* preserve POSIX realloc(ptr, 0) semantics */
	if(size1 > SIZE_MAX / size2)
		return 0;
	return realloc(ptr, size1*size2);
}

/* size1 * (size2 + size3) */
static FLaC__INLINE void *safe_realloc_muladd2_(void *ptr, size_t size1, size_t size2, size_t size3)
{
	if(!size1 || (!size2 && !size3))
		return realloc(ptr, 0); /* preserve POSIX realloc(ptr, 0) semantics */
	size2 += size3;
	if(size2 < size3)
		return 0;
	return safe_realloc_mul_2op_(ptr, size1, size2);
}

#endif

/*** End of inlined file: alloc.h ***/

/* Things should be fastest when this matches the machine word size */
/* WATCHOUT: if you change this you must also change the following #defines down to SWAP_BE_WORD_TO_HOST below to match */
/* WATCHOUT: there are a few places where the code will not work unless bwword is >= 32 bits wide */
typedef FLAC__uint32 bwword;
#define FLAC__BYTES_PER_WORD 4
#define FLAC__BITS_PER_WORD 32
#define FLAC__WORD_ALL_ONES ((FLAC__uint32)0xffffffff)
/* SWAP_BE_WORD_TO_HOST swaps bytes in a bwword (which is always big-endian) if necessary to match host byte order */
#if WORDS_BIGENDIAN
#define SWAP_BE_WORD_TO_HOST(x) (x)
#else
#ifdef _MSC_VER
#define SWAP_BE_WORD_TO_HOST(x) local_swap32_(x)
#else
#define SWAP_BE_WORD_TO_HOST(x) ntohl(x)
#endif
#endif

/*
 * The default capacity here doesn't matter too much.  The buffer always grows
 * to hold whatever is written to it.  Usually the encoder will stop adding at
 * a frame or metadata block, then write that out and clear the buffer for the
 * next one.
 */
static const unsigned FLAC__BITWRITER_DEFAULT_CAPACITY = 32768u / sizeof(bwword); /* size in words */
/* When growing, increment 4K at a time */
static const unsigned FLAC__BITWRITER_DEFAULT_INCREMENT = 4096u / sizeof(bwword); /* size in words */

#define FLAC__WORDS_TO_BITS(words) ((words) * FLAC__BITS_PER_WORD)
#define FLAC__TOTAL_BITS(bw) (FLAC__WORDS_TO_BITS((bw)->words) + (bw)->bits)

#ifdef min
#undef min
#endif
#define min(x,y) ((x)<(y)?(x):(y))

/* adjust for compilers that can't understand using LLU suffix for uint64_t literals */
#ifdef _MSC_VER
#define FLAC__U64L(x) x
#else
#define FLAC__U64L(x) x##LLU
#endif

#ifndef FLaC__INLINE
#define FLaC__INLINE
#endif

struct FLAC__BitWriter {
	bwword *buffer;
	bwword accum; /* accumulator; bits are right-justified; when full, accum is appended to buffer */
	unsigned capacity; /* capacity of buffer in words */
	unsigned words; /* # of complete words in buffer */
	unsigned bits; /* # of used bits in accum */
};

/* * WATCHOUT: The current implementation only grows the buffer. */
static FLAC__bool bitwriter_grow_(FLAC__BitWriter *bw, unsigned bits_to_add)
{
	unsigned new_capacity;
	bwword *new_buffer;

	FLAC__ASSERT(0 != bw);
	FLAC__ASSERT(0 != bw->buffer);

	/* calculate total words needed to store 'bits_to_add' additional bits */
	new_capacity = bw->words + ((bw->bits + bits_to_add + FLAC__BITS_PER_WORD - 1) / FLAC__BITS_PER_WORD);

	/* it's possible (due to pessimism in the growth estimation that
	 * leads to this call) that we don't actually need to grow
	 */
	if(bw->capacity >= new_capacity)
		return true;

	/* round up capacity increase to the nearest FLAC__BITWRITER_DEFAULT_INCREMENT */
	if((new_capacity - bw->capacity) % FLAC__BITWRITER_DEFAULT_INCREMENT)
		new_capacity += FLAC__BITWRITER_DEFAULT_INCREMENT - ((new_capacity - bw->capacity) % FLAC__BITWRITER_DEFAULT_INCREMENT);
	/* make sure we got everything right */
	FLAC__ASSERT(0 == (new_capacity - bw->capacity) % FLAC__BITWRITER_DEFAULT_INCREMENT);
	FLAC__ASSERT(new_capacity > bw->capacity);
	FLAC__ASSERT(new_capacity >= bw->words + ((bw->bits + bits_to_add + FLAC__BITS_PER_WORD - 1) / FLAC__BITS_PER_WORD));

	new_buffer = (bwword*)safe_realloc_mul_2op_(bw->buffer, sizeof(bwword), /*times*/new_capacity);
	if(new_buffer == 0)
		return false;
	bw->buffer = new_buffer;
	bw->capacity = new_capacity;
	return true;
}

/***********************************************************************
 *
 * Class constructor/destructor
 *
 ***********************************************************************/

FLAC__BitWriter *FLAC__bitwriter_new(void)
{
	FLAC__BitWriter *bw = (FLAC__BitWriter*)calloc(1, sizeof(FLAC__BitWriter));
	/* note that calloc() sets all members to 0 for us */
	return bw;
}

void FLAC__bitwriter_delete(FLAC__BitWriter *bw)
{
	FLAC__ASSERT(0 != bw);

	FLAC__bitwriter_free(bw);
	free(bw);
}

/***********************************************************************
 *
 * Public class methods
 *
 ***********************************************************************/

FLAC__bool FLAC__bitwriter_init(FLAC__BitWriter *bw)
{
	FLAC__ASSERT(0 != bw);

	bw->words = bw->bits = 0;
	bw->capacity = FLAC__BITWRITER_DEFAULT_CAPACITY;
	bw->buffer = (bwword*)malloc(sizeof(bwword) * bw->capacity);
	if(bw->buffer == 0)
		return false;

	return true;
}

void FLAC__bitwriter_free(FLAC__BitWriter *bw)
{
	FLAC__ASSERT(0 != bw);

	if(0 != bw->buffer)
		free(bw->buffer);
	bw->buffer = 0;
	bw->capacity = 0;
	bw->words = bw->bits = 0;
}

void FLAC__bitwriter_clear(FLAC__BitWriter *bw)
{
	bw->words = bw->bits = 0;
}

void FLAC__bitwriter_dump(const FLAC__BitWriter *bw, FILE *out)
{
	unsigned i, j;
	if(bw == 0) {
		fprintf(out, "bitwriter is NULL\n");
	}
	else {
		fprintf(out, "bitwriter: capacity=%u words=%u bits=%u total_bits=%u\n", bw->capacity, bw->words, bw->bits, FLAC__TOTAL_BITS(bw));

		for(i = 0; i < bw->words; i++) {
			fprintf(out, "%08X: ", i);
			for(j = 0; j < FLAC__BITS_PER_WORD; j++)
				fprintf(out, "%01u", bw->buffer[i] & (1 << (FLAC__BITS_PER_WORD-j-1)) ? 1:0);
			fprintf(out, "\n");
		}
		if(bw->bits > 0) {
			fprintf(out, "%08X: ", i);
			for(j = 0; j < bw->bits; j++)
				fprintf(out, "%01u", bw->accum & (1 << (bw->bits-j-1)) ? 1:0);
			fprintf(out, "\n");
		}
	}
}

FLAC__bool FLAC__bitwriter_get_write_crc16(FLAC__BitWriter *bw, FLAC__uint16 *crc)
{
	const FLAC__byte *buffer;
	size_t bytes;

	FLAC__ASSERT((bw->bits & 7) == 0); /* assert that we're byte-aligned */

	if(!FLAC__bitwriter_get_buffer(bw, &buffer, &bytes))
		return false;

	*crc = (FLAC__uint16)FLAC__crc16(buffer, bytes);
	FLAC__bitwriter_release_buffer(bw);
	return true;
}

FLAC__bool FLAC__bitwriter_get_write_crc8(FLAC__BitWriter *bw, FLAC__byte *crc)
{
	const FLAC__byte *buffer;
	size_t bytes;

	FLAC__ASSERT((bw->bits & 7) == 0); /* assert that we're byte-aligned */

	if(!FLAC__bitwriter_get_buffer(bw, &buffer, &bytes))
		return false;

	*crc = FLAC__crc8(buffer, bytes);
	FLAC__bitwriter_release_buffer(bw);
	return true;
}

FLAC__bool FLAC__bitwriter_is_byte_aligned(const FLAC__BitWriter *bw)
{
	return ((bw->bits & 7) == 0);
}

unsigned FLAC__bitwriter_get_input_bits_unconsumed(const FLAC__BitWriter *bw)
{
	return FLAC__TOTAL_BITS(bw);
}

FLAC__bool FLAC__bitwriter_get_buffer(FLAC__BitWriter *bw, const FLAC__byte **buffer, size_t *bytes)
{
	FLAC__ASSERT((bw->bits & 7) == 0);
	/* double protection */
	if(bw->bits & 7)
		return false;
	/* if we have bits in the accumulator we have to flush those to the buffer first */
	if(bw->bits) {
		FLAC__ASSERT(bw->words <= bw->capacity);
		if(bw->words == bw->capacity && !bitwriter_grow_(bw, FLAC__BITS_PER_WORD))
			return false;
		/* append bits as complete word to buffer, but don't change bw->accum or bw->bits */
		bw->buffer[bw->words] = SWAP_BE_WORD_TO_HOST(bw->accum << (FLAC__BITS_PER_WORD-bw->bits));
	}
	/* now we can just return what we have */
	*buffer = (FLAC__byte*)bw->buffer;
	*bytes = (FLAC__BYTES_PER_WORD * bw->words) + (bw->bits >> 3);
	return true;
}

void FLAC__bitwriter_release_buffer(FLAC__BitWriter *bw)
{
	/* nothing to do.  in the future, strict checking of a 'writer-is-in-
	 * get-mode' flag could be added everywhere and then cleared here
	 */
	(void)bw;
}

FLaC__INLINE FLAC__bool FLAC__bitwriter_write_zeroes(FLAC__BitWriter *bw, unsigned bits)
{
	unsigned n;

	FLAC__ASSERT(0 != bw);
	FLAC__ASSERT(0 != bw->buffer);

	if(bits == 0)
		return true;
	/* slightly pessimistic size check but faster than "<= bw->words + (bw->bits+bits+FLAC__BITS_PER_WORD-1)/FLAC__BITS_PER_WORD" */
	if(bw->capacity <= bw->words + bits && !bitwriter_grow_(bw, bits))
		return false;
	/* first part gets to word alignment */
	if(bw->bits) {
		n = min(FLAC__BITS_PER_WORD - bw->bits, bits);
		bw->accum <<= n;
		bits -= n;
		bw->bits += n;
		if(bw->bits == FLAC__BITS_PER_WORD) {
			bw->buffer[bw->words++] = SWAP_BE_WORD_TO_HOST(bw->accum);
			bw->bits = 0;
		}
		else
			return true;
	}
	/* do whole words */
	while(bits >= FLAC__BITS_PER_WORD) {
		bw->buffer[bw->words++] = 0;
		bits -= FLAC__BITS_PER_WORD;
	}
	/* do any leftovers */
	if(bits > 0) {
		bw->accum = 0;
		bw->bits = bits;
	}
	return true;
}

FLaC__INLINE FLAC__bool FLAC__bitwriter_write_raw_uint32(FLAC__BitWriter *bw, FLAC__uint32 val, unsigned bits)
{
	register unsigned left;

	/* WATCHOUT: code does not work with <32bit words; we can make things much faster with this assertion */
	FLAC__ASSERT(FLAC__BITS_PER_WORD >= 32);

	FLAC__ASSERT(0 != bw);
	FLAC__ASSERT(0 != bw->buffer);

	FLAC__ASSERT(bits <= 32);
	if(bits == 0)
		return true;

	/* slightly pessimistic size check but faster than "<= bw->words + (bw->bits+bits+FLAC__BITS_PER_WORD-1)/FLAC__BITS_PER_WORD" */
	if(bw->capacity <= bw->words + bits && !bitwriter_grow_(bw, bits))
		return false;

	left = FLAC__BITS_PER_WORD - bw->bits;
	if(bits < left) {
		bw->accum <<= bits;
		bw->accum |= val;
		bw->bits += bits;
	}
	else if(bw->bits) { /* WATCHOUT: if bw->bits == 0, left==FLAC__BITS_PER_WORD and bw->accum<<=left is a NOP instead of setting to 0 */
		bw->accum <<= left;
		bw->accum |= val >> (bw->bits = bits - left);
		bw->buffer[bw->words++] = SWAP_BE_WORD_TO_HOST(bw->accum);
		bw->accum = val;
	}
	else {
		bw->accum = val;
		bw->bits = 0;
		bw->buffer[bw->words++] = SWAP_BE_WORD_TO_HOST(val);
	}

	return true;
}

FLaC__INLINE FLAC__bool FLAC__bitwriter_write_raw_int32(FLAC__BitWriter *bw, FLAC__int32 val, unsigned bits)
{
	/* zero-out unused bits */
	if(bits < 32)
		val &= (~(0xffffffff << bits));

	return FLAC__bitwriter_write_raw_uint32(bw, (FLAC__uint32)val, bits);
}

FLaC__INLINE FLAC__bool FLAC__bitwriter_write_raw_uint64(FLAC__BitWriter *bw, FLAC__uint64 val, unsigned bits)
{
	/* this could be a little faster but it's not used for much */
	if(bits > 32) {
		return
			FLAC__bitwriter_write_raw_uint32(bw, (FLAC__uint32)(val>>32), bits-32) &&
			FLAC__bitwriter_write_raw_uint32(bw, (FLAC__uint32)val, 32);
	}
	else
		return FLAC__bitwriter_write_raw_uint32(bw, (FLAC__uint32)val, bits);
}

FLaC__INLINE FLAC__bool FLAC__bitwriter_write_raw_uint32_little_endian(FLAC__BitWriter *bw, FLAC__uint32 val)
{
	/* this doesn't need to be that fast as currently it is only used for vorbis comments */

	if(!FLAC__bitwriter_write_raw_uint32(bw, val & 0xff, 8))
		return false;
	if(!FLAC__bitwriter_write_raw_uint32(bw, (val>>8) & 0xff, 8))
		return false;
	if(!FLAC__bitwriter_write_raw_uint32(bw, (val>>16) & 0xff, 8))
		return false;
	if(!FLAC__bitwriter_write_raw_uint32(bw, val>>24, 8))
		return false;

	return true;
}

FLaC__INLINE FLAC__bool FLAC__bitwriter_write_byte_block(FLAC__BitWriter *bw, const FLAC__byte vals[], unsigned nvals)
{
	unsigned i;

	/* this could be faster but currently we don't need it to be since it's only used for writing metadata */
	for(i = 0; i < nvals; i++) {
		if(!FLAC__bitwriter_write_raw_uint32(bw, (FLAC__uint32)(vals[i]), 8))
			return false;
	}

	return true;
}

FLAC__bool FLAC__bitwriter_write_unary_unsigned(FLAC__BitWriter *bw, unsigned val)
{
	if(val < 32)
		return FLAC__bitwriter_write_raw_uint32(bw, 1, ++val);
	else
		return
			FLAC__bitwriter_write_zeroes(bw, val) &&
			FLAC__bitwriter_write_raw_uint32(bw, 1, 1);
}

unsigned FLAC__bitwriter_rice_bits(FLAC__int32 val, unsigned parameter)
{
	FLAC__uint32 uval;

	FLAC__ASSERT(parameter < sizeof(unsigned)*8);

	/* fold signed to unsigned; actual formula is: negative(v)? -2v-1 : 2v */
	uval = (val<<1) ^ (val>>31);

	return 1 + parameter + (uval >> parameter);
}

#if 0 /* UNUSED */
unsigned FLAC__bitwriter_golomb_bits_signed(int val, unsigned parameter)
{
	unsigned bits, msbs, uval;
	unsigned k;

	FLAC__ASSERT(parameter > 0);

	/* fold signed to unsigned */
	if(val < 0)
		uval = (unsigned)(((-(++val)) << 1) + 1);
	else
		uval = (unsigned)(val << 1);

	k = FLAC__bitmath_ilog2(parameter);
	if(parameter == 1u<<k) {
		FLAC__ASSERT(k <= 30);

		msbs = uval >> k;
		bits = 1 + k + msbs;
	}
	else {
		unsigned q, r, d;

		d = (1 << (k+1)) - parameter;
		q = uval / parameter;
		r = uval - (q * parameter);

		bits = 1 + q + k;
		if(r >= d)
			bits++;
	}
	return bits;
}

unsigned FLAC__bitwriter_golomb_bits_unsigned(unsigned uval, unsigned parameter)
{
	unsigned bits, msbs;
	unsigned k;

	FLAC__ASSERT(parameter > 0);

	k = FLAC__bitmath_ilog2(parameter);
	if(parameter == 1u<<k) {
		FLAC__ASSERT(k <= 30);

		msbs = uval >> k;
		bits = 1 + k + msbs;
	}
	else {
		unsigned q, r, d;

		d = (1 << (k+1)) - parameter;
		q = uval / parameter;
		r = uval - (q * parameter);

		bits = 1 + q + k;
		if(r >= d)
			bits++;
	}
	return bits;
}
#endif /* UNUSED */

FLAC__bool FLAC__bitwriter_write_rice_signed(FLAC__BitWriter *bw, FLAC__int32 val, unsigned parameter)
{
	unsigned total_bits, interesting_bits, msbs;
	FLAC__uint32 uval, pattern;

	FLAC__ASSERT(0 != bw);
	FLAC__ASSERT(0 != bw->buffer);
	FLAC__ASSERT(parameter < 8*sizeof(uval));

	/* fold signed to unsigned; actual formula is: negative(v)? -2v-1 : 2v */
	uval = (val<<1) ^ (val>>31);

	msbs = uval >> parameter;
	interesting_bits = 1 + parameter;
	total_bits = interesting_bits + msbs;
	pattern = 1 << parameter; /* the unary end bit */
	pattern |= (uval & ((1<<parameter)-1)); /* the binary LSBs */

	if(total_bits <= 32)
		return FLAC__bitwriter_write_raw_uint32(bw, pattern, total_bits);
	else
		return
			FLAC__bitwriter_write_zeroes(bw, msbs) && /* write the unary MSBs */
			FLAC__bitwriter_write_raw_uint32(bw, pattern, interesting_bits); /* write the unary end bit and binary LSBs */
}

FLAC__bool FLAC__bitwriter_write_rice_signed_block(FLAC__BitWriter *bw, const FLAC__int32 *vals, unsigned nvals, unsigned parameter)
{
	const FLAC__uint32 mask1 = FLAC__WORD_ALL_ONES << parameter; /* we val|=mask1 to set the stop bit above it... */
	const FLAC__uint32 mask2 = FLAC__WORD_ALL_ONES >> (31-parameter); /* ...then mask off the bits above the stop bit with val&=mask2*/
	FLAC__uint32 uval;
	unsigned left;
	const unsigned lsbits = 1 + parameter;
	unsigned msbits;

	FLAC__ASSERT(0 != bw);
	FLAC__ASSERT(0 != bw->buffer);
	FLAC__ASSERT(parameter < 8*sizeof(bwword)-1);
	/* WATCHOUT: code does not work with <32bit words; we can make things much faster with this assertion */
	FLAC__ASSERT(FLAC__BITS_PER_WORD >= 32);

	while(nvals) {
		/* fold signed to unsigned; actual formula is: negative(v)? -2v-1 : 2v */
		uval = (*vals<<1) ^ (*vals>>31);

		msbits = uval >> parameter;

#if 0 /* OPT: can remove this special case if it doesn't make up for the extra compare (doesn't make a statistically significant difference with msvc or gcc/x86) */
		if(bw->bits && bw->bits + msbits + lsbits <= FLAC__BITS_PER_WORD) { /* i.e. if the whole thing fits in the current bwword */
			/* ^^^ if bw->bits is 0 then we may have filled the buffer and have no free bwword to work in */
			bw->bits = bw->bits + msbits + lsbits;
			uval |= mask1; /* set stop bit */
			uval &= mask2; /* mask off unused top bits */
			/* NOT: bw->accum <<= msbits + lsbits because msbits+lsbits could be 32, then the shift would be a NOP */
			bw->accum <<= msbits;
			bw->accum <<= lsbits;
			bw->accum |= uval;
			if(bw->bits == FLAC__BITS_PER_WORD) {
				bw->buffer[bw->words++] = SWAP_BE_WORD_TO_HOST(bw->accum);
				bw->bits = 0;
				/* burying the capacity check down here means we have to grow the buffer a little if there are more vals to do */
				if(bw->capacity <= bw->words && nvals > 1 && !bitwriter_grow_(bw, 1)) {
					FLAC__ASSERT(bw->capacity == bw->words);
					return false;
				}
			}
		}
		else {
#elif 1 /*@@@@@@ OPT: try this version with MSVC6 to see if better, not much difference for gcc-4 */
		if(bw->bits && bw->bits + msbits + lsbits < FLAC__BITS_PER_WORD) { /* i.e. if the whole thing fits in the current bwword */
			/* ^^^ if bw->bits is 0 then we may have filled the buffer and have no free bwword to work in */
			bw->bits = bw->bits + msbits + lsbits;
			uval |= mask1; /* set stop bit */
			uval &= mask2; /* mask off unused top bits */
			bw->accum <<= msbits + lsbits;
			bw->accum |= uval;
		}
		else {
#endif
			/* slightly pessimistic size check but faster than "<= bw->words + (bw->bits+msbits+lsbits+FLAC__BITS_PER_WORD-1)/FLAC__BITS_PER_WORD" */
			/* OPT: pessimism may cause flurry of false calls to grow_ which eat up all savings before it */
			if(bw->capacity <= bw->words + bw->bits + msbits + 1/*lsbits always fit in 1 bwword*/ && !bitwriter_grow_(bw, msbits+lsbits))
				return false;

			if(msbits) {
				/* first part gets to word alignment */
				if(bw->bits) {
					left = FLAC__BITS_PER_WORD - bw->bits;
					if(msbits < left) {
						bw->accum <<= msbits;
						bw->bits += msbits;
						goto break1;
					}
					else {
						bw->accum <<= left;
						msbits -= left;
						bw->buffer[bw->words++] = SWAP_BE_WORD_TO_HOST(bw->accum);
						bw->bits = 0;
					}
				}
				/* do whole words */
				while(msbits >= FLAC__BITS_PER_WORD) {
					bw->buffer[bw->words++] = 0;
					msbits -= FLAC__BITS_PER_WORD;
				}
				/* do any leftovers */
				if(msbits > 0) {
					bw->accum = 0;
					bw->bits = msbits;
				}
			}
break1:
			uval |= mask1; /* set stop bit */
			uval &= mask2; /* mask off unused top bits */

			left = FLAC__BITS_PER_WORD - bw->bits;
			if(lsbits < left) {
				bw->accum <<= lsbits;
				bw->accum |= uval;
				bw->bits += lsbits;
			}
			else {
				/* if bw->bits == 0, left==FLAC__BITS_PER_WORD which will always
				 * be > lsbits (because of previous assertions) so it would have
				 * triggered the (lsbits<left) case above.
				 */
				FLAC__ASSERT(bw->bits);
				FLAC__ASSERT(left < FLAC__BITS_PER_WORD);
				bw->accum <<= left;
				bw->accum |= uval >> (bw->bits = lsbits - left);
				bw->buffer[bw->words++] = SWAP_BE_WORD_TO_HOST(bw->accum);
				bw->accum = uval;
			}
#if 1
		}
#endif
		vals++;
		nvals--;
	}
	return true;
}

#if 0 /* UNUSED */
FLAC__bool FLAC__bitwriter_write_golomb_signed(FLAC__BitWriter *bw, int val, unsigned parameter)
{
	unsigned total_bits, msbs, uval;
	unsigned k;

	FLAC__ASSERT(0 != bw);
	FLAC__ASSERT(0 != bw->buffer);
	FLAC__ASSERT(parameter > 0);

	/* fold signed to unsigned */
	if(val < 0)
		uval = (unsigned)(((-(++val)) << 1) + 1);
	else
		uval = (unsigned)(val << 1);

	k = FLAC__bitmath_ilog2(parameter);
	if(parameter == 1u<<k) {
		unsigned pattern;

		FLAC__ASSERT(k <= 30);

		msbs = uval >> k;
		total_bits = 1 + k + msbs;
		pattern = 1 << k; /* the unary end bit */
		pattern |= (uval & ((1u<<k)-1)); /* the binary LSBs */

		if(total_bits <= 32) {
			if(!FLAC__bitwriter_write_raw_uint32(bw, pattern, total_bits))
				return false;
		}
		else {
			/* write the unary MSBs */
			if(!FLAC__bitwriter_write_zeroes(bw, msbs))
				return false;
			/* write the unary end bit and binary LSBs */
			if(!FLAC__bitwriter_write_raw_uint32(bw, pattern, k+1))
				return false;
		}
	}
	else {
		unsigned q, r, d;

		d = (1 << (k+1)) - parameter;
		q = uval / parameter;
		r = uval - (q * parameter);
		/* write the unary MSBs */
		if(!FLAC__bitwriter_write_zeroes(bw, q))
			return false;
		/* write the unary end bit */
		if(!FLAC__bitwriter_write_raw_uint32(bw, 1, 1))
			return false;
		/* write the binary LSBs */
		if(r >= d) {
			if(!FLAC__bitwriter_write_raw_uint32(bw, r+d, k+1))
				return false;
		}
		else {
			if(!FLAC__bitwriter_write_raw_uint32(bw, r, k))
				return false;
		}
	}
	return true;
}

FLAC__bool FLAC__bitwriter_write_golomb_unsigned(FLAC__BitWriter *bw, unsigned uval, unsigned parameter)
{
	unsigned total_bits, msbs;
	unsigned k;

	FLAC__ASSERT(0 != bw);
	FLAC__ASSERT(0 != bw->buffer);
	FLAC__ASSERT(parameter > 0);

	k = FLAC__bitmath_ilog2(parameter);
	if(parameter == 1u<<k) {
		unsigned pattern;

		FLAC__ASSERT(k <= 30);

		msbs = uval >> k;
		total_bits = 1 + k + msbs;
		pattern = 1 << k; /* the unary end bit */
		pattern |= (uval & ((1u<<k)-1)); /* the binary LSBs */

		if(total_bits <= 32) {
			if(!FLAC__bitwriter_write_raw_uint32(bw, pattern, total_bits))
				return false;
		}
		else {
			/* write the unary MSBs */
			if(!FLAC__bitwriter_write_zeroes(bw, msbs))
				return false;
			/* write the unary end bit and binary LSBs */
			if(!FLAC__bitwriter_write_raw_uint32(bw, pattern, k+1))
				return false;
		}
	}
	else {
		unsigned q, r, d;

		d = (1 << (k+1)) - parameter;
		q = uval / parameter;
		r = uval - (q * parameter);
		/* write the unary MSBs */
		if(!FLAC__bitwriter_write_zeroes(bw, q))
			return false;
		/* write the unary end bit */
		if(!FLAC__bitwriter_write_raw_uint32(bw, 1, 1))
			return false;
		/* write the binary LSBs */
		if(r >= d) {
			if(!FLAC__bitwriter_write_raw_uint32(bw, r+d, k+1))
				return false;
		}
		else {
			if(!FLAC__bitwriter_write_raw_uint32(bw, r, k))
				return false;
		}
	}
	return true;
}
#endif /* UNUSED */

FLAC__bool FLAC__bitwriter_write_utf8_uint32(FLAC__BitWriter *bw, FLAC__uint32 val)
{
	FLAC__bool ok = 1;

	FLAC__ASSERT(0 != bw);
	FLAC__ASSERT(0 != bw->buffer);

	FLAC__ASSERT(!(val & 0x80000000)); /* this version only handles 31 bits */

	if(val < 0x80) {
		return FLAC__bitwriter_write_raw_uint32(bw, val, 8);
	}
	else if(val < 0x800) {
		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0xC0 | (val>>6), 8);
		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | (val&0x3F), 8);
	}
	else if(val < 0x10000) {
		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0xE0 | (val>>12), 8);
		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | ((val>>6)&0x3F), 8);
		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | (val&0x3F), 8);
	}
	else if(val < 0x200000) {
		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0xF0 | (val>>18), 8);
		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | ((val>>12)&0x3F), 8);
		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | ((val>>6)&0x3F), 8);
		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | (val&0x3F), 8);
	}
	else if(val < 0x4000000) {
		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0xF8 | (val>>24), 8);
		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | ((val>>18)&0x3F), 8);
		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | ((val>>12)&0x3F), 8);
		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | ((val>>6)&0x3F), 8);
		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | (val&0x3F), 8);
	}
	else {
		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0xFC | (val>>30), 8);
		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | ((val>>24)&0x3F), 8);
		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | ((val>>18)&0x3F), 8);
		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | ((val>>12)&0x3F), 8);
		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | ((val>>6)&0x3F), 8);
		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | (val&0x3F), 8);
	}

	return ok;
}

FLAC__bool FLAC__bitwriter_write_utf8_uint64(FLAC__BitWriter *bw, FLAC__uint64 val)
{
	FLAC__bool ok = 1;

	FLAC__ASSERT(0 != bw);
	FLAC__ASSERT(0 != bw->buffer);

	FLAC__ASSERT(!(val & FLAC__U64L(0xFFFFFFF000000000))); /* this version only handles 36 bits */

	if(val < 0x80) {
		return FLAC__bitwriter_write_raw_uint32(bw, (FLAC__uint32)val, 8);
	}
	else if(val < 0x800) {
		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0xC0 | (FLAC__uint32)(val>>6), 8);
		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | (FLAC__uint32)(val&0x3F), 8);
	}
	else if(val < 0x10000) {
		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0xE0 | (FLAC__uint32)(val>>12), 8);
		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | (FLAC__uint32)((val>>6)&0x3F), 8);
		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | (FLAC__uint32)(val&0x3F), 8);
	}
	else if(val < 0x200000) {
		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0xF0 | (FLAC__uint32)(val>>18), 8);
		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | (FLAC__uint32)((val>>12)&0x3F), 8);
		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | (FLAC__uint32)((val>>6)&0x3F), 8);
		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | (FLAC__uint32)(val&0x3F), 8);
	}
	else if(val < 0x4000000) {
		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0xF8 | (FLAC__uint32)(val>>24), 8);
		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | (FLAC__uint32)((val>>18)&0x3F), 8);
		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | (FLAC__uint32)((val>>12)&0x3F), 8);
		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | (FLAC__uint32)((val>>6)&0x3F), 8);
		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | (FLAC__uint32)(val&0x3F), 8);
	}
	else if(val < 0x80000000) {
		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0xFC | (FLAC__uint32)(val>>30), 8);
		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | (FLAC__uint32)((val>>24)&0x3F), 8);
		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | (FLAC__uint32)((val>>18)&0x3F), 8);
		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | (FLAC__uint32)((val>>12)&0x3F), 8);
		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | (FLAC__uint32)((val>>6)&0x3F), 8);
		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | (FLAC__uint32)(val&0x3F), 8);
	}
	else {
		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0xFE, 8);
		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | (FLAC__uint32)((val>>30)&0x3F), 8);
		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | (FLAC__uint32)((val>>24)&0x3F), 8);
		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | (FLAC__uint32)((val>>18)&0x3F), 8);
		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | (FLAC__uint32)((val>>12)&0x3F), 8);
		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | (FLAC__uint32)((val>>6)&0x3F), 8);
		ok &= FLAC__bitwriter_write_raw_uint32(bw, 0x80 | (FLAC__uint32)(val&0x3F), 8);
	}

	return ok;
}

FLAC__bool FLAC__bitwriter_zero_pad_to_byte_boundary(FLAC__BitWriter *bw)
{
	/* 0-pad to byte boundary */
	if(bw->bits & 7u)
		return FLAC__bitwriter_write_zeroes(bw, 8 - (bw->bits & 7u));
	else
		return true;
}

/*** End of inlined file: bitwriter.c ***/


/*** Start of inlined file: cpu.c ***/
#if HAVE_CONFIG_H
#  include <config.h>
#endif

#include <stdlib.h>
#include <stdio.h>

#if defined FLAC__CPU_IA32
# include <signal.h>
#elif defined FLAC__CPU_PPC
# if !defined FLAC__NO_ASM
#  if defined FLAC__SYS_DARWIN
#   include <sys/sysctl.h>
#   include <mach/mach.h>
#   include <mach/mach_host.h>
#   include <mach/host_info.h>
#   include <mach/machine.h>
#   ifndef CPU_SUBTYPE_POWERPC_970
#    define CPU_SUBTYPE_POWERPC_970 ((cpu_subtype_t) 100)
#   endif
#  else /* FLAC__SYS_DARWIN */

#   include <signal.h>
#   include <setjmp.h>

static sigjmp_buf jmpbuf;
static volatile sig_atomic_t canjump = 0;

static void sigill_handler (int sig)
{
	if (!canjump) {
		signal (sig, SIG_DFL);
		raise (sig);
	}
	canjump = 0;
	siglongjmp (jmpbuf, 1);
}
#  endif /* FLAC__SYS_DARWIN */
# endif /* FLAC__NO_ASM */
#endif /* FLAC__CPU_PPC */

#if defined (__NetBSD__) || defined(__OpenBSD__)
#include <sys/param.h>
#include <sys/sysctl.h>
#include <machine/cpu.h>
#endif

#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__DragonFly__)
#include <sys/types.h>
#include <sys/sysctl.h>
#endif

#if defined(__APPLE__)
/* how to get sysctlbyname()? */
#endif

/* these are flags in EDX of CPUID AX=00000001 */
static const unsigned FLAC__CPUINFO_IA32_CPUID_CMOV = 0x00008000;
static const unsigned FLAC__CPUINFO_IA32_CPUID_MMX = 0x00800000;
static const unsigned FLAC__CPUINFO_IA32_CPUID_FXSR = 0x01000000;
static const unsigned FLAC__CPUINFO_IA32_CPUID_SSE = 0x02000000;
static const unsigned FLAC__CPUINFO_IA32_CPUID_SSE2 = 0x04000000;
/* these are flags in ECX of CPUID AX=00000001 */
static const unsigned FLAC__CPUINFO_IA32_CPUID_SSE3 = 0x00000001;
static const unsigned FLAC__CPUINFO_IA32_CPUID_SSSE3 = 0x00000200;
/* these are flags in EDX of CPUID AX=80000001 */
static const unsigned FLAC__CPUINFO_IA32_CPUID_EXTENDED_AMD_3DNOW = 0x80000000;
static const unsigned FLAC__CPUINFO_IA32_CPUID_EXTENDED_AMD_EXT3DNOW = 0x40000000;
static const unsigned FLAC__CPUINFO_IA32_CPUID_EXTENDED_AMD_EXTMMX = 0x00400000;

/*
 * Extra stuff needed for detection of OS support for SSE on IA-32
 */
#if defined(FLAC__CPU_IA32) && !defined FLAC__NO_ASM && defined FLAC__HAS_NASM && !defined FLAC__NO_SSE_OS && !defined FLAC__SSE_OS
# if defined(__linux__)
/*
 * If the OS doesn't support SSE, we will get here with a SIGILL.  We
 * modify the return address to jump over the offending SSE instruction
 * and also the operation following it that indicates the instruction
 * executed successfully.  In this way we use no global variables and
 * stay thread-safe.
 *
 * 3 + 3 + 6:
 *   3 bytes for "xorps xmm0,xmm0"
 *   3 bytes for estimate of how long the follwing "inc var" instruction is
 *   6 bytes extra in case our estimate is wrong
 * 12 bytes puts us in the NOP "landing zone"
 */
#  undef USE_OBSOLETE_SIGCONTEXT_FLAVOR /* #define this to use the older signal handler method */
#  ifdef USE_OBSOLETE_SIGCONTEXT_FLAVOR
	static void sigill_handler_sse_os(int signal, struct sigcontext sc)
	{
		(void)signal;
		sc.eip += 3 + 3 + 6;
	}
#  else
#   include <sys/ucontext.h>
	static void sigill_handler_sse_os(int signal, siginfo_t *si, void *uc)
	{
		(void)signal, (void)si;
		((ucontext_t*)uc)->uc_mcontext.gregs[14/*REG_EIP*/] += 3 + 3 + 6;
	}
#  endif
# elif defined(_MSC_VER)
#  include <windows.h>
#  undef USE_TRY_CATCH_FLAVOR /* #define this to use the try/catch method for catching illegal opcode exception */
#  ifdef USE_TRY_CATCH_FLAVOR
#  else
	LONG CALLBACK sigill_handler_sse_os(EXCEPTION_POINTERS *ep)
	{
		if(ep->ExceptionRecord->ExceptionCode == EXCEPTION_ILLEGAL_INSTRUCTION) {
			ep->ContextRecord->Eip += 3 + 3 + 6;
			return EXCEPTION_CONTINUE_EXECUTION;
		}
		return EXCEPTION_CONTINUE_SEARCH;
	}
#  endif
# endif
#endif

void FLAC__cpu_info(FLAC__CPUInfo *info)
{
/*
 * IA32-specific
 */
#ifdef FLAC__CPU_IA32
	info->type = FLAC__CPUINFO_TYPE_IA32;
#if !defined FLAC__NO_ASM && defined FLAC__HAS_NASM
	info->use_asm = true; /* we assume a minimum of 80386 with FLAC__CPU_IA32 */
	info->data.ia32.cpuid = FLAC__cpu_have_cpuid_asm_ia32()? true : false;
	info->data.ia32.bswap = info->data.ia32.cpuid; /* CPUID => BSWAP since it came after */
	info->data.ia32.cmov = false;
	info->data.ia32.mmx = false;
	info->data.ia32.fxsr = false;
	info->data.ia32.sse = false;
	info->data.ia32.sse2 = false;
	info->data.ia32.sse3 = false;
	info->data.ia32.ssse3 = false;
	info->data.ia32._3dnow = false;
	info->data.ia32.ext3dnow = false;
	info->data.ia32.extmmx = false;
	if(info->data.ia32.cpuid) {
		/* http://www.sandpile.org/ia32/cpuid.htm */
		FLAC__uint32 flags_edx, flags_ecx;
		FLAC__cpu_info_asm_ia32(&flags_edx, &flags_ecx);
		info->data.ia32.cmov  = (flags_edx & FLAC__CPUINFO_IA32_CPUID_CMOV )? true : false;
		info->data.ia32.mmx   = (flags_edx & FLAC__CPUINFO_IA32_CPUID_MMX  )? true : false;
		info->data.ia32.fxsr  = (flags_edx & FLAC__CPUINFO_IA32_CPUID_FXSR )? true : false;
		info->data.ia32.sse   = (flags_edx & FLAC__CPUINFO_IA32_CPUID_SSE  )? true : false;
		info->data.ia32.sse2  = (flags_edx & FLAC__CPUINFO_IA32_CPUID_SSE2 )? true : false;
		info->data.ia32.sse3  = (flags_ecx & FLAC__CPUINFO_IA32_CPUID_SSE3 )? true : false;
		info->data.ia32.ssse3 = (flags_ecx & FLAC__CPUINFO_IA32_CPUID_SSSE3)? true : false;

#ifdef FLAC__USE_3DNOW
		flags_edx = FLAC__cpu_info_extended_amd_asm_ia32();
		info->data.ia32._3dnow   = (flags_edx & FLAC__CPUINFO_IA32_CPUID_EXTENDED_AMD_3DNOW   )? true : false;
		info->data.ia32.ext3dnow = (flags_edx & FLAC__CPUINFO_IA32_CPUID_EXTENDED_AMD_EXT3DNOW)? true : false;
		info->data.ia32.extmmx   = (flags_edx & FLAC__CPUINFO_IA32_CPUID_EXTENDED_AMD_EXTMMX  )? true : false;
#else
		info->data.ia32._3dnow = info->data.ia32.ext3dnow = info->data.ia32.extmmx = false;
#endif

#ifdef DEBUG
		fprintf(stderr, "CPU info (IA-32):\n");
		fprintf(stderr, "  CPUID ...... %c\n", info->data.ia32.cpuid   ? 'Y' : 'n');
		fprintf(stderr, "  BSWAP ...... %c\n", info->data.ia32.bswap   ? 'Y' : 'n');
		fprintf(stderr, "  CMOV ....... %c\n", info->data.ia32.cmov    ? 'Y' : 'n');
		fprintf(stderr, "  MMX ........ %c\n", info->data.ia32.mmx     ? 'Y' : 'n');
		fprintf(stderr, "  FXSR ....... %c\n", info->data.ia32.fxsr    ? 'Y' : 'n');
		fprintf(stderr, "  SSE ........ %c\n", info->data.ia32.sse     ? 'Y' : 'n');
		fprintf(stderr, "  SSE2 ....... %c\n", info->data.ia32.sse2    ? 'Y' : 'n');
		fprintf(stderr, "  SSE3 ....... %c\n", info->data.ia32.sse3    ? 'Y' : 'n');
		fprintf(stderr, "  SSSE3 ...... %c\n", info->data.ia32.ssse3   ? 'Y' : 'n');
		fprintf(stderr, "  3DNow! ..... %c\n", info->data.ia32._3dnow  ? 'Y' : 'n');
		fprintf(stderr, "  3DNow!-ext . %c\n", info->data.ia32.ext3dnow? 'Y' : 'n');
		fprintf(stderr, "  3DNow!-MMX . %c\n", info->data.ia32.extmmx  ? 'Y' : 'n');
#endif

		/*
		 * now have to check for OS support of SSE/SSE2
		 */
		if(info->data.ia32.fxsr || info->data.ia32.sse || info->data.ia32.sse2) {
#if defined FLAC__NO_SSE_OS
			/* assume user knows better than us; turn it off */
			info->data.ia32.fxsr = info->data.ia32.sse = info->data.ia32.sse2 = info->data.ia32.sse3 = info->data.ia32.ssse3 = false;
#elif defined FLAC__SSE_OS
			/* assume user knows better than us; leave as detected above */
#elif defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__DragonFly__) || defined(__APPLE__)
			int sse = 0;
			size_t len;
			/* at least one of these must work: */
			len = sizeof(sse); sse = sse || (sysctlbyname("hw.instruction_sse", &sse, &len, NULL, 0) == 0 && sse);
			len = sizeof(sse); sse = sse || (sysctlbyname("hw.optional.sse"   , &sse, &len, NULL, 0) == 0 && sse); /* __APPLE__ ? */
			if(!sse)
				info->data.ia32.fxsr = info->data.ia32.sse = info->data.ia32.sse2 = info->data.ia32.sse3 = info->data.ia32.ssse3 = false;
#elif defined(__NetBSD__) || defined (__OpenBSD__)
# if __NetBSD_Version__ >= 105250000 || (defined __OpenBSD__)
			int val = 0, mib[2] = { CTL_MACHDEP, CPU_SSE };
			size_t len = sizeof(val);
			if(sysctl(mib, 2, &val, &len, NULL, 0) < 0 || !val)
				info->data.ia32.fxsr = info->data.ia32.sse = info->data.ia32.sse2 = info->data.ia32.sse3 = info->data.ia32.ssse3 = false;
			else { /* double-check SSE2 */
				mib[1] = CPU_SSE2;
				len = sizeof(val);
				if(sysctl(mib, 2, &val, &len, NULL, 0) < 0 || !val)
					info->data.ia32.sse2 = info->data.ia32.sse3 = info->data.ia32.ssse3 = false;
			}
# else
			info->data.ia32.fxsr = info->data.ia32.sse = info->data.ia32.sse2 = info->data.ia32.sse3 = info->data.ia32.ssse3 = false;
# endif
#elif defined(__linux__)
			int sse = 0;
			struct sigaction sigill_save;
#ifdef USE_OBSOLETE_SIGCONTEXT_FLAVOR
			if(0 == sigaction(SIGILL, NULL, &sigill_save) && signal(SIGILL, (void (*)(int))sigill_handler_sse_os) != SIG_ERR)
#else
			struct sigaction sigill_sse;
			sigill_sse.sa_sigaction = sigill_handler_sse_os;
			__sigemptyset(&sigill_sse.sa_mask);
			sigill_sse.sa_flags = SA_SIGINFO | SA_RESETHAND; /* SA_RESETHAND just in case our SIGILL return jump breaks, so we don't get stuck in a loop */
			if(0 == sigaction(SIGILL, &sigill_sse, &sigill_save))
#endif
			{
				/* http://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html */
				/* see sigill_handler_sse_os() for an explanation of the following: */
				asm volatile (
					"xorl %0,%0\n\t"          /* for some reason, still need to do this to clear 'sse' var */
					"xorps %%xmm0,%%xmm0\n\t" /* will cause SIGILL if unsupported by OS */
					"incl %0\n\t"             /* SIGILL handler will jump over this */
					/* landing zone */
					"nop\n\t" /* SIGILL jump lands here if "inc" is 9 bytes */
					"nop\n\t"
					"nop\n\t"
					"nop\n\t"
					"nop\n\t"
					"nop\n\t"
					"nop\n\t" /* SIGILL jump lands here if "inc" is 3 bytes (expected) */
					"nop\n\t"
					"nop"     /* SIGILL jump lands here if "inc" is 1 byte */
					: "=r"(sse)
					: "r"(sse)
				);

				sigaction(SIGILL, &sigill_save, NULL);
			}

			if(!sse)
				info->data.ia32.fxsr = info->data.ia32.sse = info->data.ia32.sse2 = info->data.ia32.sse3 = info->data.ia32.ssse3 = false;
#elif defined(_MSC_VER)
# ifdef USE_TRY_CATCH_FLAVOR
			_try {
				__asm {
#  if _MSC_VER <= 1200
					/* VC6 assembler doesn't know SSE, have to emit bytecode instead */
					_emit 0x0F
					_emit 0x57
					_emit 0xC0
#  else
					xorps xmm0,xmm0
#  endif
				}
			}
			_except(EXCEPTION_EXECUTE_HANDLER) {
				if (_exception_code() == STATUS_ILLEGAL_INSTRUCTION)
					info->data.ia32.fxsr = info->data.ia32.sse = info->data.ia32.sse2 = info->data.ia32.sse3 = info->data.ia32.ssse3 = false;
			}
# else
			int sse = 0;
			LPTOP_LEVEL_EXCEPTION_FILTER save = SetUnhandledExceptionFilter(sigill_handler_sse_os);
			/* see GCC version above for explanation */
			/*  http://msdn2.microsoft.com/en-us/library/4ks26t93.aspx */
			/*  http://www.codeproject.com/cpp/gccasm.asp */
			/*  http://www.hick.org/~mmiller/msvc_inline_asm.html */
			__asm {
#  if _MSC_VER <= 1200
				/* VC6 assembler doesn't know SSE, have to emit bytecode instead */
				_emit 0x0F
				_emit 0x57
				_emit 0xC0
#  else
				xorps xmm0,xmm0
#  endif
				inc sse
				nop
				nop
				nop
				nop
				nop
				nop
				nop
				nop
				nop
			}
			SetUnhandledExceptionFilter(save);
			if(!sse)
				info->data.ia32.fxsr = info->data.ia32.sse = info->data.ia32.sse2 = info->data.ia32.sse3 = info->data.ia32.ssse3 = false;
# endif
#else
			/* no way to test, disable to be safe */
			info->data.ia32.fxsr = info->data.ia32.sse = info->data.ia32.sse2 = info->data.ia32.sse3 = info->data.ia32.ssse3 = false;
#endif
#ifdef DEBUG
		fprintf(stderr, "  SSE OS sup . %c\n", info->data.ia32.sse     ? 'Y' : 'n');
#endif

		}
	}
#else
	info->use_asm = false;
#endif

/*
 * PPC-specific
 */
#elif defined FLAC__CPU_PPC
	info->type = FLAC__CPUINFO_TYPE_PPC;
# if !defined FLAC__NO_ASM
	info->use_asm = true;
#  ifdef FLAC__USE_ALTIVEC
#   if defined FLAC__SYS_DARWIN
	{
		int val = 0, mib[2] = { CTL_HW, HW_VECTORUNIT };
		size_t len = sizeof(val);
		info->data.ppc.altivec = !(sysctl(mib, 2, &val, &len, NULL, 0) || !val);
	}
	{
		host_basic_info_data_t hostInfo;
		mach_msg_type_number_t infoCount;

		infoCount = HOST_BASIC_INFO_COUNT;
		host_info(mach_host_self(), HOST_BASIC_INFO, (host_info_t)&hostInfo, &infoCount);

		info->data.ppc.ppc64 = (hostInfo.cpu_type == CPU_TYPE_POWERPC) && (hostInfo.cpu_subtype == CPU_SUBTYPE_POWERPC_970);
	}
#   else /* FLAC__USE_ALTIVEC && !FLAC__SYS_DARWIN */
	{
		/* no Darwin, do it the brute-force way */
		/* @@@@@@ this is not thread-safe; replace with SSE OS method above or remove */
		info->data.ppc.altivec = 0;
		info->data.ppc.ppc64 = 0;

		signal (SIGILL, sigill_handler);
		canjump = 0;
		if (!sigsetjmp (jmpbuf, 1)) {
			canjump = 1;

			asm volatile (
				"mtspr 256, %0\n\t"
				"vand %%v0, %%v0, %%v0"
				:
				: "r" (-1)
			);

			info->data.ppc.altivec = 1;
		}
		canjump = 0;
		if (!sigsetjmp (jmpbuf, 1)) {
			int x = 0;
			canjump = 1;

			/* PPC64 hardware implements the cntlzd instruction */
			asm volatile ("cntlzd %0, %1" : "=r" (x) : "r" (x) );

			info->data.ppc.ppc64 = 1;
		}
		signal (SIGILL, SIG_DFL); /*@@@@@@ should save and restore old signal */
	}
#   endif
#  else /* !FLAC__USE_ALTIVEC */
	info->data.ppc.altivec = 0;
	info->data.ppc.ppc64 = 0;
#  endif
# else
	info->use_asm = false;
# endif

/*
 * unknown CPI
 */
#else
	info->type = FLAC__CPUINFO_TYPE_UNKNOWN;
	info->use_asm = false;
#endif
}

/*** End of inlined file: cpu.c ***/


/*** Start of inlined file: crc.c ***/
#if HAVE_CONFIG_H
#  include <config.h>
#endif

/* CRC-8, poly = x^8 + x^2 + x^1 + x^0, init = 0 */

FLAC__byte const FLAC__crc8_table[256] = {
	0x00, 0x07, 0x0E, 0x09, 0x1C, 0x1B, 0x12, 0x15,
	0x38, 0x3F, 0x36, 0x31, 0x24, 0x23, 0x2A, 0x2D,
	0x70, 0x77, 0x7E, 0x79, 0x6C, 0x6B, 0x62, 0x65,
	0x48, 0x4F, 0x46, 0x41, 0x54, 0x53, 0x5A, 0x5D,
	0xE0, 0xE7, 0xEE, 0xE9, 0xFC, 0xFB, 0xF2, 0xF5,
	0xD8, 0xDF, 0xD6, 0xD1, 0xC4, 0xC3, 0xCA, 0xCD,
	0x90, 0x97, 0x9E, 0x99, 0x8C, 0x8B, 0x82, 0x85,
	0xA8, 0xAF, 0xA6, 0xA1, 0xB4, 0xB3, 0xBA, 0xBD,
	0xC7, 0xC0, 0xC9, 0xCE, 0xDB, 0xDC, 0xD5, 0xD2,
	0xFF, 0xF8, 0xF1, 0xF6, 0xE3, 0xE4, 0xED, 0xEA,
	0xB7, 0xB0, 0xB9, 0xBE, 0xAB, 0xAC, 0xA5, 0xA2,
	0x8F, 0x88, 0x81, 0x86, 0x93, 0x94, 0x9D, 0x9A,
	0x27, 0x20, 0x29, 0x2E, 0x3B, 0x3C, 0x35, 0x32,
	0x1F, 0x18, 0x11, 0x16, 0x03, 0x04, 0x0D, 0x0A,
	0x57, 0x50, 0x59, 0x5E, 0x4B, 0x4C, 0x45, 0x42,
	0x6F, 0x68, 0x61, 0x66, 0x73, 0x74, 0x7D, 0x7A,
	0x89, 0x8E, 0x87, 0x80, 0x95, 0x92, 0x9B, 0x9C,
	0xB1, 0xB6, 0xBF, 0xB8, 0xAD, 0xAA, 0xA3, 0xA4,
	0xF9, 0xFE, 0xF7, 0xF0, 0xE5, 0xE2, 0xEB, 0xEC,
	0xC1, 0xC6, 0xCF, 0xC8, 0xDD, 0xDA, 0xD3, 0xD4,
	0x69, 0x6E, 0x67, 0x60, 0x75, 0x72, 0x7B, 0x7C,
	0x51, 0x56, 0x5F, 0x58, 0x4D, 0x4A, 0x43, 0x44,
	0x19, 0x1E, 0x17, 0x10, 0x05, 0x02, 0x0B, 0x0C,
	0x21, 0x26, 0x2F, 0x28, 0x3D, 0x3A, 0x33, 0x34,
	0x4E, 0x49, 0x40, 0x47, 0x52, 0x55, 0x5C, 0x5B,
	0x76, 0x71, 0x78, 0x7F, 0x6A, 0x6D, 0x64, 0x63,
	0x3E, 0x39, 0x30, 0x37, 0x22, 0x25, 0x2C, 0x2B,
	0x06, 0x01, 0x08, 0x0F, 0x1A, 0x1D, 0x14, 0x13,
	0xAE, 0xA9, 0xA0, 0xA7, 0xB2, 0xB5, 0xBC, 0xBB,
	0x96, 0x91, 0x98, 0x9F, 0x8A, 0x8D, 0x84, 0x83,
	0xDE, 0xD9, 0xD0, 0xD7, 0xC2, 0xC5, 0xCC, 0xCB,
	0xE6, 0xE1, 0xE8, 0xEF, 0xFA, 0xFD, 0xF4, 0xF3
};

/* CRC-16, poly = x^16 + x^15 + x^2 + x^0, init = 0 */

unsigned FLAC__crc16_table[256] = {
	0x0000,  0x8005,  0x800f,  0x000a,  0x801b,  0x001e,  0x0014,  0x8011,
	0x8033,  0x0036,  0x003c,  0x8039,  0x0028,  0x802d,  0x8027,  0x0022,
	0x8063,  0x0066,  0x006c,  0x8069,  0x0078,  0x807d,  0x8077,  0x0072,
	0x0050,  0x8055,  0x805f,  0x005a,  0x804b,  0x004e,  0x0044,  0x8041,
	0x80c3,  0x00c6,  0x00cc,  0x80c9,  0x00d8,  0x80dd,  0x80d7,  0x00d2,
	0x00f0,  0x80f5,  0x80ff,  0x00fa,  0x80eb,  0x00ee,  0x00e4,  0x80e1,
	0x00a0,  0x80a5,  0x80af,  0x00aa,  0x80bb,  0x00be,  0x00b4,  0x80b1,
	0x8093,  0x0096,  0x009c,  0x8099,  0x0088,  0x808d,  0x8087,  0x0082,
	0x8183,  0x0186,  0x018c,  0x8189,  0x0198,  0x819d,  0x8197,  0x0192,
	0x01b0,  0x81b5,  0x81bf,  0x01ba,  0x81ab,  0x01ae,  0x01a4,  0x81a1,
	0x01e0,  0x81e5,  0x81ef,  0x01ea,  0x81fb,  0x01fe,  0x01f4,  0x81f1,
	0x81d3,  0x01d6,  0x01dc,  0x81d9,  0x01c8,  0x81cd,  0x81c7,  0x01c2,
	0x0140,  0x8145,  0x814f,  0x014a,  0x815b,  0x015e,  0x0154,  0x8151,
	0x8173,  0x0176,  0x017c,  0x8179,  0x0168,  0x816d,  0x8167,  0x0162,
	0x8123,  0x0126,  0x012c,  0x8129,  0x0138,  0x813d,  0x8137,  0x0132,
	0x0110,  0x8115,  0x811f,  0x011a,  0x810b,  0x010e,  0x0104,  0x8101,
	0x8303,  0x0306,  0x030c,  0x8309,  0x0318,  0x831d,  0x8317,  0x0312,
	0x0330,  0x8335,  0x833f,  0x033a,  0x832b,  0x032e,  0x0324,  0x8321,
	0x0360,  0x8365,  0x836f,  0x036a,  0x837b,  0x037e,  0x0374,  0x8371,
	0x8353,  0x0356,  0x035c,  0x8359,  0x0348,  0x834d,  0x8347,  0x0342,
	0x03c0,  0x83c5,  0x83cf,  0x03ca,  0x83db,  0x03de,  0x03d4,  0x83d1,
	0x83f3,  0x03f6,  0x03fc,  0x83f9,  0x03e8,  0x83ed,  0x83e7,  0x03e2,
	0x83a3,  0x03a6,  0x03ac,  0x83a9,  0x03b8,  0x83bd,  0x83b7,  0x03b2,
	0x0390,  0x8395,  0x839f,  0x039a,  0x838b,  0x038e,  0x0384,  0x8381,
	0x0280,  0x8285,  0x828f,  0x028a,  0x829b,  0x029e,  0x0294,  0x8291,
	0x82b3,  0x02b6,  0x02bc,  0x82b9,  0x02a8,  0x82ad,  0x82a7,  0x02a2,
	0x82e3,  0x02e6,  0x02ec,  0x82e9,  0x02f8,  0x82fd,  0x82f7,  0x02f2,
	0x02d0,  0x82d5,  0x82df,  0x02da,  0x82cb,  0x02ce,  0x02c4,  0x82c1,
	0x8243,  0x0246,  0x024c,  0x8249,  0x0258,  0x825d,  0x8257,  0x0252,
	0x0270,  0x8275,  0x827f,  0x027a,  0x826b,  0x026e,  0x0264,  0x8261,
	0x0220,  0x8225,  0x822f,  0x022a,  0x823b,  0x023e,  0x0234,  0x8231,
	0x8213,  0x0216,  0x021c,  0x8219,  0x0208,  0x820d,  0x8207,  0x0202
};

void FLAC__crc8_update(const FLAC__byte data, FLAC__uint8 *crc)
{
	*crc = FLAC__crc8_table[*crc ^ data];
}

void FLAC__crc8_update_block(const FLAC__byte *data, unsigned len, FLAC__uint8 *crc)
{
	while(len--)
		*crc = FLAC__crc8_table[*crc ^ *data++];
}

FLAC__uint8 FLAC__crc8(const FLAC__byte *data, unsigned len)
{
	FLAC__uint8 crc = 0;

	while(len--)
		crc = FLAC__crc8_table[crc ^ *data++];

	return crc;
}

unsigned FLAC__crc16(const FLAC__byte *data, unsigned len)
{
	unsigned crc = 0;

	while(len--)
		crc = ((crc<<8) ^ FLAC__crc16_table[(crc>>8) ^ *data++]) & 0xffff;

	return crc;
}

/*** End of inlined file: crc.c ***/


/*** Start of inlined file: fixed.c ***/
#if HAVE_CONFIG_H
#  include <config.h>
#endif

#include <math.h>
#include <string.h>


/*** Start of inlined file: fixed.h ***/
#ifndef FLAC__PRIVATE__FIXED_H
#define FLAC__PRIVATE__FIXED_H

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif


/*** Start of inlined file: float.h ***/
#ifndef FLAC__PRIVATE__FLOAT_H
#define FLAC__PRIVATE__FLOAT_H

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

/*
 * These typedefs make it easier to ensure that integer versions of
 * the library really only contain integer operations.  All the code
 * in libFLAC should use FLAC__float and FLAC__double in place of
 * float and double, and be protected by checks of the macro
 * FLAC__INTEGER_ONLY_LIBRARY.
 *
 * FLAC__real is the basic floating point type used in LPC analysis.
 */
#ifndef FLAC__INTEGER_ONLY_LIBRARY
typedef double FLAC__double;
typedef float FLAC__float;
/*
 * WATCHOUT: changing FLAC__real will change the signatures of many
 * functions that have assembly language equivalents and break them.
 */
typedef float FLAC__real;
#else
/*
 * The convention for FLAC__fixedpoint is to use the upper 16 bits
 * for the integer part and lower 16 bits for the fractional part.
 */
typedef FLAC__int32 FLAC__fixedpoint;
extern const FLAC__fixedpoint FLAC__FP_ZERO;
extern const FLAC__fixedpoint FLAC__FP_ONE_HALF;
extern const FLAC__fixedpoint FLAC__FP_ONE;
extern const FLAC__fixedpoint FLAC__FP_LN2;
extern const FLAC__fixedpoint FLAC__FP_E;

#define FLAC__fixedpoint_trunc(x) ((x)>>16)

#define FLAC__fixedpoint_mul(x, y) ( (FLAC__fixedpoint) ( ((FLAC__int64)(x)*(FLAC__int64)(y)) >> 16 ) )

#define FLAC__fixedpoint_div(x, y) ( (FLAC__fixedpoint) ( ( ((FLAC__int64)(x)<<32) / (FLAC__int64)(y) ) >> 16 ) )

/*
 *	FLAC__fixedpoint_log2()
 *	--------------------------------------------------------------------
 *	Returns the base-2 logarithm of the fixed-point number 'x' using an
 *	algorithm by Knuth for x >= 1.0
 *
 *	'fracbits' is the number of fractional bits of 'x'.  'fracbits' must
 *	be < 32 and evenly divisible by 4 (0 is OK but not very precise).
 *
 *	'precision' roughly limits the number of iterations that are done;
 *	use (unsigned)(-1) for maximum precision.
 *
 *	If 'x' is less than one -- that is, x < (1<<fracbits) -- then this
 *	function will punt and return 0.
 *
 *	The return value will also have 'fracbits' fractional bits.
 */
FLAC__uint32 FLAC__fixedpoint_log2(FLAC__uint32 x, unsigned fracbits, unsigned precision);

#endif

#endif

/*** End of inlined file: float.h ***/


/*** Start of inlined file: format.h ***/
#ifndef FLAC__PRIVATE__FORMAT_H
#define FLAC__PRIVATE__FORMAT_H

unsigned FLAC__format_get_max_rice_partition_order(unsigned blocksize, unsigned predictor_order);
unsigned FLAC__format_get_max_rice_partition_order_from_blocksize(unsigned blocksize);
unsigned FLAC__format_get_max_rice_partition_order_from_blocksize_limited_max_and_predictor_order(unsigned limit, unsigned blocksize, unsigned predictor_order);
void FLAC__format_entropy_coding_method_partitioned_rice_contents_init(FLAC__EntropyCodingMethod_PartitionedRiceContents *object);
void FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(FLAC__EntropyCodingMethod_PartitionedRiceContents *object);
FLAC__bool FLAC__format_entropy_coding_method_partitioned_rice_contents_ensure_size(FLAC__EntropyCodingMethod_PartitionedRiceContents *object, unsigned max_partition_order);

#endif

/*** End of inlined file: format.h ***/

/*
 *	FLAC__fixed_compute_best_predictor()
 *	--------------------------------------------------------------------
 *	Compute the best fixed predictor and the expected bits-per-sample
 *  of the residual signal for each order.  The _wide() version uses
 *  64-bit integers which is statistically necessary when bits-per-
 *  sample + log2(blocksize) > 30
 *
 *	IN data[0,data_len-1]
 *	IN data_len
 *	OUT residual_bits_per_sample[0,FLAC__MAX_FIXED_ORDER]
 */
#ifndef FLAC__INTEGER_ONLY_LIBRARY
unsigned FLAC__fixed_compute_best_predictor(const FLAC__int32 data[], unsigned data_len, FLAC__float residual_bits_per_sample[FLAC__MAX_FIXED_ORDER+1]);
# ifndef FLAC__NO_ASM
#  ifdef FLAC__CPU_IA32
#   ifdef FLAC__HAS_NASM
unsigned FLAC__fixed_compute_best_predictor_asm_ia32_mmx_cmov(const FLAC__int32 data[], unsigned data_len, FLAC__float residual_bits_per_sample[FLAC__MAX_FIXED_ORDER+1]);
#   endif
#  endif
# endif
unsigned FLAC__fixed_compute_best_predictor_wide(const FLAC__int32 data[], unsigned data_len, FLAC__float residual_bits_per_sample[FLAC__MAX_FIXED_ORDER+1]);
#else
unsigned FLAC__fixed_compute_best_predictor(const FLAC__int32 data[], unsigned data_len, FLAC__fixedpoint residual_bits_per_sample[FLAC__MAX_FIXED_ORDER+1]);
unsigned FLAC__fixed_compute_best_predictor_wide(const FLAC__int32 data[], unsigned data_len, FLAC__fixedpoint residual_bits_per_sample[FLAC__MAX_FIXED_ORDER+1]);
#endif

/*
 *	FLAC__fixed_compute_residual()
 *	--------------------------------------------------------------------
 *	Compute the residual signal obtained from sutracting the predicted
 *	signal from the original.
 *
 *	IN data[-order,data_len-1]        original signal (NOTE THE INDICES!)
 *	IN data_len                       length of original signal
 *	IN order <= FLAC__MAX_FIXED_ORDER fixed-predictor order
 *	OUT residual[0,data_len-1]        residual signal
 */
void FLAC__fixed_compute_residual(const FLAC__int32 data[], unsigned data_len, unsigned order, FLAC__int32 residual[]);

/*
 *	FLAC__fixed_restore_signal()
 *	--------------------------------------------------------------------
 *	Restore the original signal by summing the residual and the
 *	predictor.
 *
 *	IN residual[0,data_len-1]         residual signal
 *	IN data_len                       length of original signal
 *	IN order <= FLAC__MAX_FIXED_ORDER fixed-predictor order
 *	*** IMPORTANT: the caller must pass in the historical samples:
 *	IN  data[-order,-1]               previously-reconstructed historical samples
 *	OUT data[0,data_len-1]            original signal
 */
void FLAC__fixed_restore_signal(const FLAC__int32 residual[], unsigned data_len, unsigned order, FLAC__int32 data[]);

#endif

/*** End of inlined file: fixed.h ***/

#ifndef M_LN2
/* math.h in VC++ doesn't seem to have this (how Microsoft is that?) */
#define M_LN2 0.69314718055994530942
#endif

#ifdef min
#undef min
#endif
#define min(x,y) ((x) < (y)? (x) : (y))

#ifdef local_abs
#undef local_abs
#endif
#define local_abs(x) ((unsigned)((x)<0? -(x) : (x)))

#ifdef FLAC__INTEGER_ONLY_LIBRARY
/* rbps stands for residual bits per sample
 *
 *             (ln(2) * err)
 * rbps = log  (-----------)
 *           2 (     n     )
 */
static FLAC__fixedpoint local__compute_rbps_integerized(FLAC__uint32 err, FLAC__uint32 n)
{
	FLAC__uint32 rbps;
	unsigned bits; /* the number of bits required to represent a number */
	int fracbits; /* the number of bits of rbps that comprise the fractional part */

	FLAC__ASSERT(sizeof(rbps) == sizeof(FLAC__fixedpoint));
	FLAC__ASSERT(err > 0);
	FLAC__ASSERT(n > 0);

	FLAC__ASSERT(n <= FLAC__MAX_BLOCK_SIZE);
	if(err <= n)
		return 0;
	/*
	 * The above two things tell us 1) n fits in 16 bits; 2) err/n > 1.
	 * These allow us later to know we won't lose too much precision in the
	 * fixed-point division (err<<fracbits)/n.
	 */

	fracbits = (8*sizeof(err)) - (FLAC__bitmath_ilog2(err)+1);

	err <<= fracbits;
	err /= n;
	/* err now holds err/n with fracbits fractional bits */

	/*
	 * Whittle err down to 16 bits max.  16 significant bits is enough for
	 * our purposes.
	 */
	FLAC__ASSERT(err > 0);
	bits = FLAC__bitmath_ilog2(err)+1;
	if(bits > 16) {
		err >>= (bits-16);
		fracbits -= (bits-16);
	}
	rbps = (FLAC__uint32)err;

	/* Multiply by fixed-point version of ln(2), with 16 fractional bits */
	rbps *= FLAC__FP_LN2;
	fracbits += 16;
	FLAC__ASSERT(fracbits >= 0);

	/* FLAC__fixedpoint_log2 requires fracbits%4 to be 0 */
	{
		const int f = fracbits & 3;
		if(f) {
			rbps >>= f;
			fracbits -= f;
		}
	}

	rbps = FLAC__fixedpoint_log2(rbps, fracbits, (unsigned)(-1));

	if(rbps == 0)
		return 0;

	/*
	 * The return value must have 16 fractional bits.  Since the whole part
	 * of the base-2 log of a 32 bit number must fit in 5 bits, and fracbits
	 * must be >= -3, these assertion allows us to be able to shift rbps
	 * left if necessary to get 16 fracbits without losing any bits of the
	 * whole part of rbps.
	 *
	 * There is a slight chance due to accumulated error that the whole part
	 * will require 6 bits, so we use 6 in the assertion.  Really though as
	 * long as it fits in 13 bits (32 - (16 - (-3))) we are fine.
	 */
	FLAC__ASSERT((int)FLAC__bitmath_ilog2(rbps)+1 <= fracbits + 6);
	FLAC__ASSERT(fracbits >= -3);

	/* now shift the decimal point into place */
	if(fracbits < 16)
		return rbps << (16-fracbits);
	else if(fracbits > 16)
		return rbps >> (fracbits-16);
	else
		return rbps;
}

static FLAC__fixedpoint local__compute_rbps_wide_integerized(FLAC__uint64 err, FLAC__uint32 n)
{
	FLAC__uint32 rbps;
	unsigned bits; /* the number of bits required to represent a number */
	int fracbits; /* the number of bits of rbps that comprise the fractional part */

	FLAC__ASSERT(sizeof(rbps) == sizeof(FLAC__fixedpoint));
	FLAC__ASSERT(err > 0);
	FLAC__ASSERT(n > 0);

	FLAC__ASSERT(n <= FLAC__MAX_BLOCK_SIZE);
	if(err <= n)
		return 0;
	/*
	 * The above two things tell us 1) n fits in 16 bits; 2) err/n > 1.
	 * These allow us later to know we won't lose too much precision in the
	 * fixed-point division (err<<fracbits)/n.
	 */

	fracbits = (8*sizeof(err)) - (FLAC__bitmath_ilog2_wide(err)+1);

	err <<= fracbits;
	err /= n;
	/* err now holds err/n with fracbits fractional bits */

	/*
	 * Whittle err down to 16 bits max.  16 significant bits is enough for
	 * our purposes.
	 */
	FLAC__ASSERT(err > 0);
	bits = FLAC__bitmath_ilog2_wide(err)+1;
	if(bits > 16) {
		err >>= (bits-16);
		fracbits -= (bits-16);
	}
	rbps = (FLAC__uint32)err;

	/* Multiply by fixed-point version of ln(2), with 16 fractional bits */
	rbps *= FLAC__FP_LN2;
	fracbits += 16;
	FLAC__ASSERT(fracbits >= 0);

	/* FLAC__fixedpoint_log2 requires fracbits%4 to be 0 */
	{
		const int f = fracbits & 3;
		if(f) {
			rbps >>= f;
			fracbits -= f;
		}
	}

	rbps = FLAC__fixedpoint_log2(rbps, fracbits, (unsigned)(-1));

	if(rbps == 0)
		return 0;

	/*
	 * The return value must have 16 fractional bits.  Since the whole part
	 * of the base-2 log of a 32 bit number must fit in 5 bits, and fracbits
	 * must be >= -3, these assertion allows us to be able to shift rbps
	 * left if necessary to get 16 fracbits without losing any bits of the
	 * whole part of rbps.
	 *
	 * There is a slight chance due to accumulated error that the whole part
	 * will require 6 bits, so we use 6 in the assertion.  Really though as
	 * long as it fits in 13 bits (32 - (16 - (-3))) we are fine.
	 */
	FLAC__ASSERT((int)FLAC__bitmath_ilog2(rbps)+1 <= fracbits + 6);
	FLAC__ASSERT(fracbits >= -3);

	/* now shift the decimal point into place */
	if(fracbits < 16)
		return rbps << (16-fracbits);
	else if(fracbits > 16)
		return rbps >> (fracbits-16);
	else
		return rbps;
}
#endif

#ifndef FLAC__INTEGER_ONLY_LIBRARY
unsigned FLAC__fixed_compute_best_predictor(const FLAC__int32 data[], unsigned data_len, FLAC__float residual_bits_per_sample[FLAC__MAX_FIXED_ORDER+1])
#else
unsigned FLAC__fixed_compute_best_predictor(const FLAC__int32 data[], unsigned data_len, FLAC__fixedpoint residual_bits_per_sample[FLAC__MAX_FIXED_ORDER+1])
#endif
{
	FLAC__int32 last_error_0 = data[-1];
	FLAC__int32 last_error_1 = data[-1] - data[-2];
	FLAC__int32 last_error_2 = last_error_1 - (data[-2] - data[-3]);
	FLAC__int32 last_error_3 = last_error_2 - (data[-2] - 2*data[-3] + data[-4]);
	FLAC__int32 error, save;
	FLAC__uint32 total_error_0 = 0, total_error_1 = 0, total_error_2 = 0, total_error_3 = 0, total_error_4 = 0;
	unsigned i, order;

	for(i = 0; i < data_len; i++) {
		error  = data[i]     ; total_error_0 += local_abs(error);                      save = error;
		error -= last_error_0; total_error_1 += local_abs(error); last_error_0 = save; save = error;
		error -= last_error_1; total_error_2 += local_abs(error); last_error_1 = save; save = error;
		error -= last_error_2; total_error_3 += local_abs(error); last_error_2 = save; save = error;
		error -= last_error_3; total_error_4 += local_abs(error); last_error_3 = save;
	}

	if(total_error_0 < min(min(min(total_error_1, total_error_2), total_error_3), total_error_4))
		order = 0;
	else if(total_error_1 < min(min(total_error_2, total_error_3), total_error_4))
		order = 1;
	else if(total_error_2 < min(total_error_3, total_error_4))
		order = 2;
	else if(total_error_3 < total_error_4)
		order = 3;
	else
		order = 4;

	/* Estimate the expected number of bits per residual signal sample. */
	/* 'total_error*' is linearly related to the variance of the residual */
	/* signal, so we use it directly to compute E(|x|) */
	FLAC__ASSERT(data_len > 0 || total_error_0 == 0);
	FLAC__ASSERT(data_len > 0 || total_error_1 == 0);
	FLAC__ASSERT(data_len > 0 || total_error_2 == 0);
	FLAC__ASSERT(data_len > 0 || total_error_3 == 0);
	FLAC__ASSERT(data_len > 0 || total_error_4 == 0);
#ifndef FLAC__INTEGER_ONLY_LIBRARY
	residual_bits_per_sample[0] = (FLAC__float)((total_error_0 > 0) ? log(M_LN2 * (FLAC__double)total_error_0 / (FLAC__double)data_len) / M_LN2 : 0.0);
	residual_bits_per_sample[1] = (FLAC__float)((total_error_1 > 0) ? log(M_LN2 * (FLAC__double)total_error_1 / (FLAC__double)data_len) / M_LN2 : 0.0);
	residual_bits_per_sample[2] = (FLAC__float)((total_error_2 > 0) ? log(M_LN2 * (FLAC__double)total_error_2 / (FLAC__double)data_len) / M_LN2 : 0.0);
	residual_bits_per_sample[3] = (FLAC__float)((total_error_3 > 0) ? log(M_LN2 * (FLAC__double)total_error_3 / (FLAC__double)data_len) / M_LN2 : 0.0);
	residual_bits_per_sample[4] = (FLAC__float)((total_error_4 > 0) ? log(M_LN2 * (FLAC__double)total_error_4 / (FLAC__double)data_len) / M_LN2 : 0.0);
#else
	residual_bits_per_sample[0] = (total_error_0 > 0) ? local__compute_rbps_integerized(total_error_0, data_len) : 0;
	residual_bits_per_sample[1] = (total_error_1 > 0) ? local__compute_rbps_integerized(total_error_1, data_len) : 0;
	residual_bits_per_sample[2] = (total_error_2 > 0) ? local__compute_rbps_integerized(total_error_2, data_len) : 0;
	residual_bits_per_sample[3] = (total_error_3 > 0) ? local__compute_rbps_integerized(total_error_3, data_len) : 0;
	residual_bits_per_sample[4] = (total_error_4 > 0) ? local__compute_rbps_integerized(total_error_4, data_len) : 0;
#endif

	return order;
}

#ifndef FLAC__INTEGER_ONLY_LIBRARY
unsigned FLAC__fixed_compute_best_predictor_wide(const FLAC__int32 data[], unsigned data_len, FLAC__float residual_bits_per_sample[FLAC__MAX_FIXED_ORDER+1])
#else
unsigned FLAC__fixed_compute_best_predictor_wide(const FLAC__int32 data[], unsigned data_len, FLAC__fixedpoint residual_bits_per_sample[FLAC__MAX_FIXED_ORDER+1])
#endif
{
	FLAC__int32 last_error_0 = data[-1];
	FLAC__int32 last_error_1 = data[-1] - data[-2];
	FLAC__int32 last_error_2 = last_error_1 - (data[-2] - data[-3]);
	FLAC__int32 last_error_3 = last_error_2 - (data[-2] - 2*data[-3] + data[-4]);
	FLAC__int32 error, save;
	/* total_error_* are 64-bits to avoid overflow when encoding
	 * erratic signals when the bits-per-sample and blocksize are
	 * large.
	 */
	FLAC__uint64 total_error_0 = 0, total_error_1 = 0, total_error_2 = 0, total_error_3 = 0, total_error_4 = 0;
	unsigned i, order;

	for(i = 0; i < data_len; i++) {
		error  = data[i]     ; total_error_0 += local_abs(error);                      save = error;
		error -= last_error_0; total_error_1 += local_abs(error); last_error_0 = save; save = error;
		error -= last_error_1; total_error_2 += local_abs(error); last_error_1 = save; save = error;
		error -= last_error_2; total_error_3 += local_abs(error); last_error_2 = save; save = error;
		error -= last_error_3; total_error_4 += local_abs(error); last_error_3 = save;
	}

	if(total_error_0 < min(min(min(total_error_1, total_error_2), total_error_3), total_error_4))
		order = 0;
	else if(total_error_1 < min(min(total_error_2, total_error_3), total_error_4))
		order = 1;
	else if(total_error_2 < min(total_error_3, total_error_4))
		order = 2;
	else if(total_error_3 < total_error_4)
		order = 3;
	else
		order = 4;

	/* Estimate the expected number of bits per residual signal sample. */
	/* 'total_error*' is linearly related to the variance of the residual */
	/* signal, so we use it directly to compute E(|x|) */
	FLAC__ASSERT(data_len > 0 || total_error_0 == 0);
	FLAC__ASSERT(data_len > 0 || total_error_1 == 0);
	FLAC__ASSERT(data_len > 0 || total_error_2 == 0);
	FLAC__ASSERT(data_len > 0 || total_error_3 == 0);
	FLAC__ASSERT(data_len > 0 || total_error_4 == 0);
#ifndef FLAC__INTEGER_ONLY_LIBRARY
#if defined _MSC_VER || defined __MINGW32__
	/* with MSVC you have to spoon feed it the casting */
	residual_bits_per_sample[0] = (FLAC__float)((total_error_0 > 0) ? log(M_LN2 * (FLAC__double)(FLAC__int64)total_error_0 / (FLAC__double)data_len) / M_LN2 : 0.0);
	residual_bits_per_sample[1] = (FLAC__float)((total_error_1 > 0) ? log(M_LN2 * (FLAC__double)(FLAC__int64)total_error_1 / (FLAC__double)data_len) / M_LN2 : 0.0);
	residual_bits_per_sample[2] = (FLAC__float)((total_error_2 > 0) ? log(M_LN2 * (FLAC__double)(FLAC__int64)total_error_2 / (FLAC__double)data_len) / M_LN2 : 0.0);
	residual_bits_per_sample[3] = (FLAC__float)((total_error_3 > 0) ? log(M_LN2 * (FLAC__double)(FLAC__int64)total_error_3 / (FLAC__double)data_len) / M_LN2 : 0.0);
	residual_bits_per_sample[4] = (FLAC__float)((total_error_4 > 0) ? log(M_LN2 * (FLAC__double)(FLAC__int64)total_error_4 / (FLAC__double)data_len) / M_LN2 : 0.0);
#else
	residual_bits_per_sample[0] = (FLAC__float)((total_error_0 > 0) ? log(M_LN2 * (FLAC__double)total_error_0 / (FLAC__double)data_len) / M_LN2 : 0.0);
	residual_bits_per_sample[1] = (FLAC__float)((total_error_1 > 0) ? log(M_LN2 * (FLAC__double)total_error_1 / (FLAC__double)data_len) / M_LN2 : 0.0);
	residual_bits_per_sample[2] = (FLAC__float)((total_error_2 > 0) ? log(M_LN2 * (FLAC__double)total_error_2 / (FLAC__double)data_len) / M_LN2 : 0.0);
	residual_bits_per_sample[3] = (FLAC__float)((total_error_3 > 0) ? log(M_LN2 * (FLAC__double)total_error_3 / (FLAC__double)data_len) / M_LN2 : 0.0);
	residual_bits_per_sample[4] = (FLAC__float)((total_error_4 > 0) ? log(M_LN2 * (FLAC__double)total_error_4 / (FLAC__double)data_len) / M_LN2 : 0.0);
#endif
#else
	residual_bits_per_sample[0] = (total_error_0 > 0) ? local__compute_rbps_wide_integerized(total_error_0, data_len) : 0;
	residual_bits_per_sample[1] = (total_error_1 > 0) ? local__compute_rbps_wide_integerized(total_error_1, data_len) : 0;
	residual_bits_per_sample[2] = (total_error_2 > 0) ? local__compute_rbps_wide_integerized(total_error_2, data_len) : 0;
	residual_bits_per_sample[3] = (total_error_3 > 0) ? local__compute_rbps_wide_integerized(total_error_3, data_len) : 0;
	residual_bits_per_sample[4] = (total_error_4 > 0) ? local__compute_rbps_wide_integerized(total_error_4, data_len) : 0;
#endif

	return order;
}

void FLAC__fixed_compute_residual(const FLAC__int32 data[], unsigned data_len, unsigned order, FLAC__int32 residual[])
{
	const int idata_len = (int)data_len;
	int i;

	switch(order) {
		case 0:
			FLAC__ASSERT(sizeof(residual[0]) == sizeof(data[0]));
			memcpy(residual, data, sizeof(residual[0])*data_len);
			break;
		case 1:
			for(i = 0; i < idata_len; i++)
				residual[i] = data[i] - data[i-1];
			break;
		case 2:
			for(i = 0; i < idata_len; i++)
#if 1 /* OPT: may be faster with some compilers on some systems */
				residual[i] = data[i] - (data[i-1] << 1) + data[i-2];
#else
				residual[i] = data[i] - 2*data[i-1] + data[i-2];
#endif
			break;
		case 3:
			for(i = 0; i < idata_len; i++)
#if 1 /* OPT: may be faster with some compilers on some systems */
				residual[i] = data[i] - (((data[i-1]-data[i-2])<<1) + (data[i-1]-data[i-2])) - data[i-3];
#else
				residual[i] = data[i] - 3*data[i-1] + 3*data[i-2] - data[i-3];
#endif
			break;
		case 4:
			for(i = 0; i < idata_len; i++)
#if 1 /* OPT: may be faster with some compilers on some systems */
				residual[i] = data[i] - ((data[i-1]+data[i-3])<<2) + ((data[i-2]<<2) + (data[i-2]<<1)) + data[i-4];
#else
				residual[i] = data[i] - 4*data[i-1] + 6*data[i-2] - 4*data[i-3] + data[i-4];
#endif
			break;
		default:
			FLAC__ASSERT(0);
	}
}

void FLAC__fixed_restore_signal(const FLAC__int32 residual[], unsigned data_len, unsigned order, FLAC__int32 data[])
{
	int i, idata_len = (int)data_len;

	switch(order) {
		case 0:
			FLAC__ASSERT(sizeof(residual[0]) == sizeof(data[0]));
			memcpy(data, residual, sizeof(residual[0])*data_len);
			break;
		case 1:
			for(i = 0; i < idata_len; i++)
				data[i] = residual[i] + data[i-1];
			break;
		case 2:
			for(i = 0; i < idata_len; i++)
#if 1 /* OPT: may be faster with some compilers on some systems */
				data[i] = residual[i] + (data[i-1]<<1) - data[i-2];
#else
				data[i] = residual[i] + 2*data[i-1] - data[i-2];
#endif
			break;
		case 3:
			for(i = 0; i < idata_len; i++)
#if 1 /* OPT: may be faster with some compilers on some systems */
				data[i] = residual[i] + (((data[i-1]-data[i-2])<<1) + (data[i-1]-data[i-2])) + data[i-3];
#else
				data[i] = residual[i] + 3*data[i-1] - 3*data[i-2] + data[i-3];
#endif
			break;
		case 4:
			for(i = 0; i < idata_len; i++)
#if 1 /* OPT: may be faster with some compilers on some systems */
				data[i] = residual[i] + ((data[i-1]+data[i-3])<<2) - ((data[i-2]<<2) + (data[i-2]<<1)) - data[i-4];
#else
				data[i] = residual[i] + 4*data[i-1] - 6*data[i-2] + 4*data[i-3] - data[i-4];
#endif
			break;
		default:
			FLAC__ASSERT(0);
	}
}

/*** End of inlined file: fixed.c ***/


/*** Start of inlined file: float.c ***/
#if HAVE_CONFIG_H
#  include <config.h>
#endif

#ifdef FLAC__INTEGER_ONLY_LIBRARY

/* adjust for compilers that can't understand using LLU suffix for uint64_t literals */
#ifdef _MSC_VER
#define FLAC__U64L(x) x
#else
#define FLAC__U64L(x) x##LLU
#endif

const FLAC__fixedpoint FLAC__FP_ZERO = 0;
const FLAC__fixedpoint FLAC__FP_ONE_HALF = 0x00008000;
const FLAC__fixedpoint FLAC__FP_ONE = 0x00010000;
const FLAC__fixedpoint FLAC__FP_LN2 = 45426;
const FLAC__fixedpoint FLAC__FP_E = 178145;

/* Lookup tables for Knuth's logarithm algorithm */
#define LOG2_LOOKUP_PRECISION 16
static const FLAC__uint32 log2_lookup[][LOG2_LOOKUP_PRECISION] = {
	{
		/*
		 * 0 fraction bits
		 */
		/* undefined */ 0x00000000,
		/* lg(2/1) = */ 0x00000001,
		/* lg(4/3) = */ 0x00000000,
		/* lg(8/7) = */ 0x00000000,
		/* lg(16/15) = */ 0x00000000,
		/* lg(32/31) = */ 0x00000000,
		/* lg(64/63) = */ 0x00000000,
		/* lg(128/127) = */ 0x00000000,
		/* lg(256/255) = */ 0x00000000,
		/* lg(512/511) = */ 0x00000000,
		/* lg(1024/1023) = */ 0x00000000,
		/* lg(2048/2047) = */ 0x00000000,
		/* lg(4096/4095) = */ 0x00000000,
		/* lg(8192/8191) = */ 0x00000000,
		/* lg(16384/16383) = */ 0x00000000,
		/* lg(32768/32767) = */ 0x00000000
	},
	{
		/*
		 * 4 fraction bits
		 */
		/* undefined */ 0x00000000,
		/* lg(2/1) = */ 0x00000010,
		/* lg(4/3) = */ 0x00000007,
		/* lg(8/7) = */ 0x00000003,
		/* lg(16/15) = */ 0x00000001,
		/* lg(32/31) = */ 0x00000001,
		/* lg(64/63) = */ 0x00000000,
		/* lg(128/127) = */ 0x00000000,
		/* lg(256/255) = */ 0x00000000,
		/* lg(512/511) = */ 0x00000000,
		/* lg(1024/1023) = */ 0x00000000,
		/* lg(2048/2047) = */ 0x00000000,
		/* lg(4096/4095) = */ 0x00000000,
		/* lg(8192/8191) = */ 0x00000000,
		/* lg(16384/16383) = */ 0x00000000,
		/* lg(32768/32767) = */ 0x00000000
	},
	{
		/*
		 * 8 fraction bits
		 */
		/* undefined */ 0x00000000,
		/* lg(2/1) = */ 0x00000100,
		/* lg(4/3) = */ 0x0000006a,
		/* lg(8/7) = */ 0x00000031,
		/* lg(16/15) = */ 0x00000018,
		/* lg(32/31) = */ 0x0000000c,
		/* lg(64/63) = */ 0x00000006,
		/* lg(128/127) = */ 0x00000003,
		/* lg(256/255) = */ 0x00000001,
		/* lg(512/511) = */ 0x00000001,
		/* lg(1024/1023) = */ 0x00000000,
		/* lg(2048/2047) = */ 0x00000000,
		/* lg(4096/4095) = */ 0x00000000,
		/* lg(8192/8191) = */ 0x00000000,
		/* lg(16384/16383) = */ 0x00000000,
		/* lg(32768/32767) = */ 0x00000000
	},
	{
		/*
		 * 12 fraction bits
		 */
		/* undefined */ 0x00000000,
		/* lg(2/1) = */ 0x00001000,
		/* lg(4/3) = */ 0x000006a4,
		/* lg(8/7) = */ 0x00000315,
		/* lg(16/15) = */ 0x0000017d,
		/* lg(32/31) = */ 0x000000bc,
		/* lg(64/63) = */ 0x0000005d,
		/* lg(128/127) = */ 0x0000002e,
		/* lg(256/255) = */ 0x00000017,
		/* lg(512/511) = */ 0x0000000c,
		/* lg(1024/1023) = */ 0x00000006,
		/* lg(2048/2047) = */ 0x00000003,
		/* lg(4096/4095) = */ 0x00000001,
		/* lg(8192/8191) = */ 0x00000001,
		/* lg(16384/16383) = */ 0x00000000,
		/* lg(32768/32767) = */ 0x00000000
	},
	{
		/*
		 * 16 fraction bits
		 */
		/* undefined */ 0x00000000,
		/* lg(2/1) = */ 0x00010000,
		/* lg(4/3) = */ 0x00006a40,
		/* lg(8/7) = */ 0x00003151,
		/* lg(16/15) = */ 0x000017d6,
		/* lg(32/31) = */ 0x00000bba,
		/* lg(64/63) = */ 0x000005d1,
		/* lg(128/127) = */ 0x000002e6,
		/* lg(256/255) = */ 0x00000172,
		/* lg(512/511) = */ 0x000000b9,
		/* lg(1024/1023) = */ 0x0000005c,
		/* lg(2048/2047) = */ 0x0000002e,
		/* lg(4096/4095) = */ 0x00000017,
		/* lg(8192/8191) = */ 0x0000000c,
		/* lg(16384/16383) = */ 0x00000006,
		/* lg(32768/32767) = */ 0x00000003
	},
	{
		/*
		 * 20 fraction bits
		 */
		/* undefined */ 0x00000000,
		/* lg(2/1) = */ 0x00100000,
		/* lg(4/3) = */ 0x0006a3fe,
		/* lg(8/7) = */ 0x00031513,
		/* lg(16/15) = */ 0x00017d60,
		/* lg(32/31) = */ 0x0000bb9d,
		/* lg(64/63) = */ 0x00005d10,
		/* lg(128/127) = */ 0x00002e59,
		/* lg(256/255) = */ 0x00001721,
		/* lg(512/511) = */ 0x00000b8e,
		/* lg(1024/1023) = */ 0x000005c6,
		/* lg(2048/2047) = */ 0x000002e3,
		/* lg(4096/4095) = */ 0x00000171,
		/* lg(8192/8191) = */ 0x000000b9,
		/* lg(16384/16383) = */ 0x0000005c,
		/* lg(32768/32767) = */ 0x0000002e
	},
	{
		/*
		 * 24 fraction bits
		 */
		/* undefined */ 0x00000000,
		/* lg(2/1) = */ 0x01000000,
		/* lg(4/3) = */ 0x006a3fe6,
		/* lg(8/7) = */ 0x00315130,
		/* lg(16/15) = */ 0x0017d605,
		/* lg(32/31) = */ 0x000bb9ca,
		/* lg(64/63) = */ 0x0005d0fc,
		/* lg(128/127) = */ 0x0002e58f,
		/* lg(256/255) = */ 0x0001720e,
		/* lg(512/511) = */ 0x0000b8d8,
		/* lg(1024/1023) = */ 0x00005c61,
		/* lg(2048/2047) = */ 0x00002e2d,
		/* lg(4096/4095) = */ 0x00001716,
		/* lg(8192/8191) = */ 0x00000b8b,
		/* lg(16384/16383) = */ 0x000005c5,
		/* lg(32768/32767) = */ 0x000002e3
	},
	{
		/*
		 * 28 fraction bits
		 */
		/* undefined */ 0x00000000,
		/* lg(2/1) = */ 0x10000000,
		/* lg(4/3) = */ 0x06a3fe5c,
		/* lg(8/7) = */ 0x03151301,
		/* lg(16/15) = */ 0x017d6049,
		/* lg(32/31) = */ 0x00bb9ca6,
		/* lg(64/63) = */ 0x005d0fba,
		/* lg(128/127) = */ 0x002e58f7,
		/* lg(256/255) = */ 0x001720da,
		/* lg(512/511) = */ 0x000b8d87,
		/* lg(1024/1023) = */ 0x0005c60b,
		/* lg(2048/2047) = */ 0x0002e2d7,
		/* lg(4096/4095) = */ 0x00017160,
		/* lg(8192/8191) = */ 0x0000b8ad,
		/* lg(16384/16383) = */ 0x00005c56,
		/* lg(32768/32767) = */ 0x00002e2b
	}
};

#if 0
static const FLAC__uint64 log2_lookup_wide[] = {
	{
		/*
		 * 32 fraction bits
		 */
		/* undefined */ 0x00000000,
		/* lg(2/1) = */ FLAC__U64L(0x100000000),
		/* lg(4/3) = */ FLAC__U64L(0x6a3fe5c6),
		/* lg(8/7) = */ FLAC__U64L(0x31513015),
		/* lg(16/15) = */ FLAC__U64L(0x17d60497),
		/* lg(32/31) = */ FLAC__U64L(0x0bb9ca65),
		/* lg(64/63) = */ FLAC__U64L(0x05d0fba2),
		/* lg(128/127) = */ FLAC__U64L(0x02e58f74),
		/* lg(256/255) = */ FLAC__U64L(0x01720d9c),
		/* lg(512/511) = */ FLAC__U64L(0x00b8d875),
		/* lg(1024/1023) = */ FLAC__U64L(0x005c60aa),
		/* lg(2048/2047) = */ FLAC__U64L(0x002e2d72),
		/* lg(4096/4095) = */ FLAC__U64L(0x00171600),
		/* lg(8192/8191) = */ FLAC__U64L(0x000b8ad2),
		/* lg(16384/16383) = */ FLAC__U64L(0x0005c55d),
		/* lg(32768/32767) = */ FLAC__U64L(0x0002e2ac)
	},
	{
		/*
		 * 48 fraction bits
		 */
		/* undefined */ 0x00000000,
		/* lg(2/1) = */ FLAC__U64L(0x1000000000000),
		/* lg(4/3) = */ FLAC__U64L(0x6a3fe5c60429),
		/* lg(8/7) = */ FLAC__U64L(0x315130157f7a),
		/* lg(16/15) = */ FLAC__U64L(0x17d60496cfbb),
		/* lg(32/31) = */ FLAC__U64L(0xbb9ca64ecac),
		/* lg(64/63) = */ FLAC__U64L(0x5d0fba187cd),
		/* lg(128/127) = */ FLAC__U64L(0x2e58f7441ee),
		/* lg(256/255) = */ FLAC__U64L(0x1720d9c06a8),
		/* lg(512/511) = */ FLAC__U64L(0xb8d8752173),
		/* lg(1024/1023) = */ FLAC__U64L(0x5c60aa252e),
		/* lg(2048/2047) = */ FLAC__U64L(0x2e2d71b0d8),
		/* lg(4096/4095) = */ FLAC__U64L(0x1716001719),
		/* lg(8192/8191) = */ FLAC__U64L(0xb8ad1de1b),
		/* lg(16384/16383) = */ FLAC__U64L(0x5c55d640d),
		/* lg(32768/32767) = */ FLAC__U64L(0x2e2abcf52)
	}
};
#endif

FLAC__uint32 FLAC__fixedpoint_log2(FLAC__uint32 x, unsigned fracbits, unsigned precision)
{
	const FLAC__uint32 ONE = (1u << fracbits);
	const FLAC__uint32 *table = log2_lookup[fracbits >> 2];

	FLAC__ASSERT(fracbits < 32);
	FLAC__ASSERT((fracbits & 0x3) == 0);

	if(x < ONE)
		return 0;

	if(precision > LOG2_LOOKUP_PRECISION)
		precision = LOG2_LOOKUP_PRECISION;

	/* Knuth's algorithm for computing logarithms, optimized for base-2 with lookup tables */
	{
		FLAC__uint32 y = 0;
		FLAC__uint32 z = x >> 1, k = 1;
		while (x > ONE && k < precision) {
			if (x - z >= ONE) {
				x -= z;
				z = x >> k;
				y += table[k];
			}
			else {
				z >>= 1;
				k++;
			}
		}
		return y;
	}
}

#endif /* defined FLAC__INTEGER_ONLY_LIBRARY */

/*** End of inlined file: float.c ***/


/*** Start of inlined file: format.c ***/
#if HAVE_CONFIG_H
#  include <config.h>
#endif

#include <stdio.h>
#include <stdlib.h> /* for qsort() */
#include <string.h> /* for memset() */

#ifndef FLaC__INLINE
#define FLaC__INLINE
#endif

#ifdef min
#undef min
#endif
#define min(a,b) ((a)<(b)?(a):(b))

/* adjust for compilers that can't understand using LLU suffix for uint64_t literals */
#ifdef _MSC_VER
#define FLAC__U64L(x) x
#else
#define FLAC__U64L(x) x##LLU
#endif

/* VERSION should come from configure */
FLAC_API const char *FLAC__VERSION_STRING = VERSION

;

#if defined _MSC_VER || defined __BORLANDC__ || defined __MINW32__
/* yet one more hack because of MSVC6: */
FLAC_API const char *FLAC__VENDOR_STRING = "reference libFLAC 1.2.1 20070917";
#else
FLAC_API const char *FLAC__VENDOR_STRING = "reference libFLAC " VERSION " 20070917";
#endif

FLAC_API const FLAC__byte FLAC__STREAM_SYNC_STRING[4] = { 'f','L','a','C' };
FLAC_API const unsigned FLAC__STREAM_SYNC = 0x664C6143;
FLAC_API const unsigned FLAC__STREAM_SYNC_LEN = 32; /* bits */

FLAC_API const unsigned FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN = 16; /* bits */
FLAC_API const unsigned FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN = 16; /* bits */
FLAC_API const unsigned FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN = 24; /* bits */
FLAC_API const unsigned FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN = 24; /* bits */
FLAC_API const unsigned FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN = 20; /* bits */
FLAC_API const unsigned FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN = 3; /* bits */
FLAC_API const unsigned FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN = 5; /* bits */
FLAC_API const unsigned FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN = 36; /* bits */
FLAC_API const unsigned FLAC__STREAM_METADATA_STREAMINFO_MD5SUM_LEN = 128; /* bits */

FLAC_API const unsigned FLAC__STREAM_METADATA_APPLICATION_ID_LEN = 32; /* bits */

FLAC_API const unsigned FLAC__STREAM_METADATA_SEEKPOINT_SAMPLE_NUMBER_LEN = 64; /* bits */
FLAC_API const unsigned FLAC__STREAM_METADATA_SEEKPOINT_STREAM_OFFSET_LEN = 64; /* bits */
FLAC_API const unsigned FLAC__STREAM_METADATA_SEEKPOINT_FRAME_SAMPLES_LEN = 16; /* bits */

FLAC_API const FLAC__uint64 FLAC__STREAM_METADATA_SEEKPOINT_PLACEHOLDER = FLAC__U64L(0xffffffffffffffff);

FLAC_API const unsigned FLAC__STREAM_METADATA_VORBIS_COMMENT_ENTRY_LENGTH_LEN = 32; /* bits */
FLAC_API const unsigned FLAC__STREAM_METADATA_VORBIS_COMMENT_NUM_COMMENTS_LEN = 32; /* bits */

FLAC_API const unsigned FLAC__STREAM_METADATA_CUESHEET_INDEX_OFFSET_LEN = 64; /* bits */
FLAC_API const unsigned FLAC__STREAM_METADATA_CUESHEET_INDEX_NUMBER_LEN = 8; /* bits */
FLAC_API const unsigned FLAC__STREAM_METADATA_CUESHEET_INDEX_RESERVED_LEN = 3*8; /* bits */

FLAC_API const unsigned FLAC__STREAM_METADATA_CUESHEET_TRACK_OFFSET_LEN = 64; /* bits */
FLAC_API const unsigned FLAC__STREAM_METADATA_CUESHEET_TRACK_NUMBER_LEN = 8; /* bits */
FLAC_API const unsigned FLAC__STREAM_METADATA_CUESHEET_TRACK_ISRC_LEN = 12*8; /* bits */
FLAC_API const unsigned FLAC__STREAM_METADATA_CUESHEET_TRACK_TYPE_LEN = 1; /* bit */
FLAC_API const unsigned FLAC__STREAM_METADATA_CUESHEET_TRACK_PRE_EMPHASIS_LEN = 1; /* bit */
FLAC_API const unsigned FLAC__STREAM_METADATA_CUESHEET_TRACK_RESERVED_LEN = 6+13*8; /* bits */
FLAC_API const unsigned FLAC__STREAM_METADATA_CUESHEET_TRACK_NUM_INDICES_LEN = 8; /* bits */

FLAC_API const unsigned FLAC__STREAM_METADATA_CUESHEET_MEDIA_CATALOG_NUMBER_LEN = 128*8; /* bits */
FLAC_API const unsigned FLAC__STREAM_METADATA_CUESHEET_LEAD_IN_LEN = 64; /* bits */
FLAC_API const unsigned FLAC__STREAM_METADATA_CUESHEET_IS_CD_LEN = 1; /* bit */
FLAC_API const unsigned FLAC__STREAM_METADATA_CUESHEET_RESERVED_LEN = 7+258*8; /* bits */
FLAC_API const unsigned FLAC__STREAM_METADATA_CUESHEET_NUM_TRACKS_LEN = 8; /* bits */

FLAC_API const unsigned FLAC__STREAM_METADATA_PICTURE_TYPE_LEN = 32; /* bits */
FLAC_API const unsigned FLAC__STREAM_METADATA_PICTURE_MIME_TYPE_LENGTH_LEN = 32; /* bits */
FLAC_API const unsigned FLAC__STREAM_METADATA_PICTURE_DESCRIPTION_LENGTH_LEN = 32; /* bits */
FLAC_API const unsigned FLAC__STREAM_METADATA_PICTURE_WIDTH_LEN = 32; /* bits */
FLAC_API const unsigned FLAC__STREAM_METADATA_PICTURE_HEIGHT_LEN = 32; /* bits */
FLAC_API const unsigned FLAC__STREAM_METADATA_PICTURE_DEPTH_LEN = 32; /* bits */
FLAC_API const unsigned FLAC__STREAM_METADATA_PICTURE_COLORS_LEN = 32; /* bits */
FLAC_API const unsigned FLAC__STREAM_METADATA_PICTURE_DATA_LENGTH_LEN = 32; /* bits */

FLAC_API const unsigned FLAC__STREAM_METADATA_IS_LAST_LEN = 1; /* bits */
FLAC_API const unsigned FLAC__STREAM_METADATA_TYPE_LEN = 7; /* bits */
FLAC_API const unsigned FLAC__STREAM_METADATA_LENGTH_LEN = 24; /* bits */

FLAC_API const unsigned FLAC__FRAME_HEADER_SYNC = 0x3ffe;
FLAC_API const unsigned FLAC__FRAME_HEADER_SYNC_LEN = 14; /* bits */
FLAC_API const unsigned FLAC__FRAME_HEADER_RESERVED_LEN = 1; /* bits */
FLAC_API const unsigned FLAC__FRAME_HEADER_BLOCKING_STRATEGY_LEN = 1; /* bits */
FLAC_API const unsigned FLAC__FRAME_HEADER_BLOCK_SIZE_LEN = 4; /* bits */
FLAC_API const unsigned FLAC__FRAME_HEADER_SAMPLE_RATE_LEN = 4; /* bits */
FLAC_API const unsigned FLAC__FRAME_HEADER_CHANNEL_ASSIGNMENT_LEN = 4; /* bits */
FLAC_API const unsigned FLAC__FRAME_HEADER_BITS_PER_SAMPLE_LEN = 3; /* bits */
FLAC_API const unsigned FLAC__FRAME_HEADER_ZERO_PAD_LEN = 1; /* bits */
FLAC_API const unsigned FLAC__FRAME_HEADER_CRC_LEN = 8; /* bits */

FLAC_API const unsigned FLAC__FRAME_FOOTER_CRC_LEN = 16; /* bits */

FLAC_API const unsigned FLAC__ENTROPY_CODING_METHOD_TYPE_LEN = 2; /* bits */
FLAC_API const unsigned FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_ORDER_LEN = 4; /* bits */
FLAC_API const unsigned FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_PARAMETER_LEN = 4; /* bits */
FLAC_API const unsigned FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2_PARAMETER_LEN = 5; /* bits */
FLAC_API const unsigned FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_RAW_LEN = 5; /* bits */

FLAC_API const unsigned FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_ESCAPE_PARAMETER = 15; /* == (1<<FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_PARAMETER_LEN)-1 */
FLAC_API const unsigned FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2_ESCAPE_PARAMETER = 31; /* == (1<<FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2_PARAMETER_LEN)-1 */

FLAC_API const char * const FLAC__EntropyCodingMethodTypeString[] = {
	"PARTITIONED_RICE",
	"PARTITIONED_RICE2"
};

FLAC_API const unsigned FLAC__SUBFRAME_LPC_QLP_COEFF_PRECISION_LEN = 4; /* bits */
FLAC_API const unsigned FLAC__SUBFRAME_LPC_QLP_SHIFT_LEN = 5; /* bits */

FLAC_API const unsigned FLAC__SUBFRAME_ZERO_PAD_LEN = 1; /* bits */
FLAC_API const unsigned FLAC__SUBFRAME_TYPE_LEN = 6; /* bits */
FLAC_API const unsigned FLAC__SUBFRAME_WASTED_BITS_FLAG_LEN = 1; /* bits */

FLAC_API const unsigned FLAC__SUBFRAME_TYPE_CONSTANT_BYTE_ALIGNED_MASK = 0x00;
FLAC_API const unsigned FLAC__SUBFRAME_TYPE_VERBATIM_BYTE_ALIGNED_MASK = 0x02;
FLAC_API const unsigned FLAC__SUBFRAME_TYPE_FIXED_BYTE_ALIGNED_MASK = 0x10;
FLAC_API const unsigned FLAC__SUBFRAME_TYPE_LPC_BYTE_ALIGNED_MASK = 0x40;

FLAC_API const char * const FLAC__SubframeTypeString[] = {
	"CONSTANT",
	"VERBATIM",
	"FIXED",
	"LPC"
};

FLAC_API const char * const FLAC__ChannelAssignmentString[] = {
	"INDEPENDENT",
	"LEFT_SIDE",
	"RIGHT_SIDE",
	"MID_SIDE"
};

FLAC_API const char * const FLAC__FrameNumberTypeString[] = {
	"FRAME_NUMBER_TYPE_FRAME_NUMBER",
	"FRAME_NUMBER_TYPE_SAMPLE_NUMBER"
};

FLAC_API const char * const FLAC__MetadataTypeString[] = {
	"STREAMINFO",
	"PADDING",
	"APPLICATION",
	"SEEKTABLE",
	"VORBIS_COMMENT",
	"CUESHEET",
	"PICTURE"
};

FLAC_API const char * const FLAC__StreamMetadata_Picture_TypeString[] = {
	"Other",
	"32x32 pixels 'file icon' (PNG only)",
	"Other file icon",
	"Cover (front)",
	"Cover (back)",
	"Leaflet page",
	"Media (e.g. label side of CD)",
	"Lead artist/lead performer/soloist",
	"Artist/performer",
	"Conductor",
	"Band/Orchestra",
	"Composer",
	"Lyricist/text writer",
	"Recording Location",
	"During recording",
	"During performance",
	"Movie/video screen capture",
	"A bright coloured fish",
	"Illustration",
	"Band/artist logotype",
	"Publisher/Studio logotype"
};

FLAC_API FLAC__bool FLAC__format_sample_rate_is_valid(unsigned sample_rate)
{
	if(sample_rate == 0 || sample_rate > FLAC__MAX_SAMPLE_RATE) {
		return false;
	}
	else
		return true;
}

FLAC_API FLAC__bool FLAC__format_sample_rate_is_subset(unsigned sample_rate)
{
	if(
		!FLAC__format_sample_rate_is_valid(sample_rate) ||
		(
			sample_rate >= (1u << 16) &&
			!(sample_rate % 1000 == 0 || sample_rate % 10 == 0)
		)
	) {
		return false;
	}
	else
		return true;
}

/* @@@@ add to unit tests; it is already indirectly tested by the metadata_object tests */
FLAC_API FLAC__bool FLAC__format_seektable_is_legal(const FLAC__StreamMetadata_SeekTable *seek_table)
{
	unsigned i;
	FLAC__uint64 prev_sample_number = 0;
	FLAC__bool got_prev = false;

	FLAC__ASSERT(0 != seek_table);

	for(i = 0; i < seek_table->num_points; i++) {
		if(got_prev) {
			if(
				seek_table->points[i].sample_number != FLAC__STREAM_METADATA_SEEKPOINT_PLACEHOLDER &&
				seek_table->points[i].sample_number <= prev_sample_number
			)
				return false;
		}
		prev_sample_number = seek_table->points[i].sample_number;
		got_prev = true;
	}

	return true;
}

/* used as the sort predicate for qsort() */
static int JUCE_CDECL seekpoint_compare_(const FLAC__StreamMetadata_SeekPoint *l, const FLAC__StreamMetadata_SeekPoint *r)
{
	/* we don't just 'return l->sample_number - r->sample_number' since the result (FLAC__int64) might overflow an 'int' */
	if(l->sample_number == r->sample_number)
		return 0;
	else if(l->sample_number < r->sample_number)
		return -1;
	else
		return 1;
}

/* @@@@ add to unit tests; it is already indirectly tested by the metadata_object tests */
FLAC_API unsigned FLAC__format_seektable_sort(FLAC__StreamMetadata_SeekTable *seek_table)
{
	unsigned i, j;
	FLAC__bool first;

	FLAC__ASSERT(0 != seek_table);

	/* sort the seekpoints */
	qsort(seek_table->points, seek_table->num_points, sizeof(FLAC__StreamMetadata_SeekPoint), (int (JUCE_CDECL *)(const void *, const void *))seekpoint_compare_);

	/* uniquify the seekpoints */
	first = true;
	for(i = j = 0; i < seek_table->num_points; i++) {
		if(seek_table->points[i].sample_number != FLAC__STREAM_METADATA_SEEKPOINT_PLACEHOLDER) {
			if(!first) {
				if(seek_table->points[i].sample_number == seek_table->points[j-1].sample_number)
					continue;
			}
		}
		first = false;
		seek_table->points[j++] = seek_table->points[i];
	}

	for(i = j; i < seek_table->num_points; i++) {
		seek_table->points[i].sample_number = FLAC__STREAM_METADATA_SEEKPOINT_PLACEHOLDER;
		seek_table->points[i].stream_offset = 0;
		seek_table->points[i].frame_samples = 0;
	}

	return j;
}

/*
 * also disallows non-shortest-form encodings, c.f.
 *   http://www.unicode.org/versions/corrigendum1.html
 * and a more clear explanation at the end of this section:
 *   http://www.cl.cam.ac.uk/~mgk25/unicode.html#utf-8
 */
static FLaC__INLINE unsigned utf8len_(const FLAC__byte *utf8)
{
	FLAC__ASSERT(0 != utf8);
	if ((utf8[0] & 0x80) == 0) {
		return 1;
	}
	else if ((utf8[0] & 0xE0) == 0xC0 && (utf8[1] & 0xC0) == 0x80) {
		if ((utf8[0] & 0xFE) == 0xC0) /* overlong sequence check */
			return 0;
		return 2;
	}
	else if ((utf8[0] & 0xF0) == 0xE0 && (utf8[1] & 0xC0) == 0x80 && (utf8[2] & 0xC0) == 0x80) {
		if (utf8[0] == 0xE0 && (utf8[1] & 0xE0) == 0x80) /* overlong sequence check */
			return 0;
		/* illegal surrogates check (U+D800...U+DFFF and U+FFFE...U+FFFF) */
		if (utf8[0] == 0xED && (utf8[1] & 0xE0) == 0xA0) /* D800-DFFF */
			return 0;
		if (utf8[0] == 0xEF && utf8[1] == 0xBF && (utf8[2] & 0xFE) == 0xBE) /* FFFE-FFFF */
			return 0;
		return 3;
	}
	else if ((utf8[0] & 0xF8) == 0xF0 && (utf8[1] & 0xC0) == 0x80 && (utf8[2] & 0xC0) == 0x80 && (utf8[3] & 0xC0) == 0x80) {
		if (utf8[0] == 0xF0 && (utf8[1] & 0xF0) == 0x80) /* overlong sequence check */
			return 0;
		return 4;
	}
	else if ((utf8[0] & 0xFC) == 0xF8 && (utf8[1] & 0xC0) == 0x80 && (utf8[2] & 0xC0) == 0x80 && (utf8[3] & 0xC0) == 0x80 && (utf8[4] & 0xC0) == 0x80) {
		if (utf8[0] == 0xF8 && (utf8[1] & 0xF8) == 0x80) /* overlong sequence check */
			return 0;
		return 5;
	}
	else if ((utf8[0] & 0xFE) == 0xFC && (utf8[1] & 0xC0) == 0x80 && (utf8[2] & 0xC0) == 0x80 && (utf8[3] & 0xC0) == 0x80 && (utf8[4] & 0xC0) == 0x80 && (utf8[5] & 0xC0) == 0x80) {
		if (utf8[0] == 0xFC && (utf8[1] & 0xFC) == 0x80) /* overlong sequence check */
			return 0;
		return 6;
	}
	else {
		return 0;
	}
}

FLAC_API FLAC__bool FLAC__format_vorbiscomment_entry_name_is_legal(const char *name)
{
	char c;
	for(c = *name; c; c = *(++name))
		if(c < 0x20 || c == 0x3d || c > 0x7d)
			return false;
	return true;
}

FLAC_API FLAC__bool FLAC__format_vorbiscomment_entry_value_is_legal(const FLAC__byte *value, unsigned length)
{
	if(length == (unsigned)(-1)) {
		while(*value) {
			unsigned n = utf8len_(value);
			if(n == 0)
				return false;
			value += n;
		}
	}
	else {
		const FLAC__byte *end = value + length;
		while(value < end) {
			unsigned n = utf8len_(value);
			if(n == 0)
				return false;
			value += n;
		}
		if(value != end)
			return false;
	}
	return true;
}

FLAC_API FLAC__bool FLAC__format_vorbiscomment_entry_is_legal(const FLAC__byte *entry, unsigned length)
{
	const FLAC__byte *s, *end;

	for(s = entry, end = s + length; s < end && *s != '='; s++) {
		if(*s < 0x20 || *s > 0x7D)
			return false;
	}
	if(s == end)
		return false;

	s++; /* skip '=' */

	while(s < end) {
		unsigned n = utf8len_(s);
		if(n == 0)
			return false;
		s += n;
	}
	if(s != end)
		return false;

	return true;
}

/* @@@@ add to unit tests; it is already indirectly tested by the metadata_object tests */
FLAC_API FLAC__bool FLAC__format_cuesheet_is_legal(const FLAC__StreamMetadata_CueSheet *cue_sheet, FLAC__bool check_cd_da_subset, const char **violation)
{
	unsigned i, j;

	if(check_cd_da_subset) {
		if(cue_sheet->lead_in < 2 * 44100) {
			if(violation) *violation = "CD-DA cue sheet must have a lead-in length of at least 2 seconds";
			return false;
		}
		if(cue_sheet->lead_in % 588 != 0) {
			if(violation) *violation = "CD-DA cue sheet lead-in length must be evenly divisible by 588 samples";
			return false;
		}
	}

	if(cue_sheet->num_tracks == 0) {
		if(violation) *violation = "cue sheet must have at least one track (the lead-out)";
		return false;
	}

	if(check_cd_da_subset && cue_sheet->tracks[cue_sheet->num_tracks-1].number != 170) {
		if(violation) *violation = "CD-DA cue sheet must have a lead-out track number 170 (0xAA)";
		return false;
	}

	for(i = 0; i < cue_sheet->num_tracks; i++) {
		if(cue_sheet->tracks[i].number == 0) {
			if(violation) *violation = "cue sheet may not have a track number 0";
			return false;
		}

		if(check_cd_da_subset) {
			if(!((cue_sheet->tracks[i].number >= 1 && cue_sheet->tracks[i].number <= 99) || cue_sheet->tracks[i].number == 170)) {
				if(violation) *violation = "CD-DA cue sheet track number must be 1-99 or 170";
				return false;
			}
		}

		if(check_cd_da_subset && cue_sheet->tracks[i].offset % 588 != 0) {
			if(violation) {
				if(i == cue_sheet->num_tracks-1) /* the lead-out track... */
					*violation = "CD-DA cue sheet lead-out offset must be evenly divisible by 588 samples";
				else
					*violation = "CD-DA cue sheet track offset must be evenly divisible by 588 samples";
			}
			return false;
		}

		if(i < cue_sheet->num_tracks - 1) {
			if(cue_sheet->tracks[i].num_indices == 0) {
				if(violation) *violation = "cue sheet track must have at least one index point";
				return false;
			}

			if(cue_sheet->tracks[i].indices[0].number > 1) {
				if(violation) *violation = "cue sheet track's first index number must be 0 or 1";
				return false;
			}
		}

		for(j = 0; j < cue_sheet->tracks[i].num_indices; j++) {
			if(check_cd_da_subset && cue_sheet->tracks[i].indices[j].offset % 588 != 0) {
				if(violation) *violation = "CD-DA cue sheet track index offset must be evenly divisible by 588 samples";
				return false;
			}

			if(j > 0) {
				if(cue_sheet->tracks[i].indices[j].number != cue_sheet->tracks[i].indices[j-1].number + 1) {
					if(violation) *violation = "cue sheet track index numbers must increase by 1";
					return false;
				}
			}
		}
	}

	return true;
}

/* @@@@ add to unit tests; it is already indirectly tested by the metadata_object tests */
FLAC_API FLAC__bool FLAC__format_picture_is_legal(const FLAC__StreamMetadata_Picture *picture, const char **violation)
{
	char *p;
	FLAC__byte *b;

	for(p = picture->mime_type; *p; p++) {
		if(*p < 0x20 || *p > 0x7e) {
			if(violation) *violation = "MIME type string must contain only printable ASCII characters (0x20-0x7e)";
			return false;
		}
	}

	for(b = picture->description; *b; ) {
		unsigned n = utf8len_(b);
		if(n == 0) {
			if(violation) *violation = "description string must be valid UTF-8";
			return false;
		}
		b += n;
	}

	return true;
}

/*
 * These routines are private to libFLAC
 */
unsigned FLAC__format_get_max_rice_partition_order(unsigned blocksize, unsigned predictor_order)
{
	return
		FLAC__format_get_max_rice_partition_order_from_blocksize_limited_max_and_predictor_order(
			FLAC__format_get_max_rice_partition_order_from_blocksize(blocksize),
			blocksize,
			predictor_order
		);
}

unsigned FLAC__format_get_max_rice_partition_order_from_blocksize(unsigned blocksize)
{
	unsigned max_rice_partition_order = 0;
	while(!(blocksize & 1)) {
		max_rice_partition_order++;
		blocksize >>= 1;
	}
	return min(FLAC__MAX_RICE_PARTITION_ORDER, max_rice_partition_order);
}

unsigned FLAC__format_get_max_rice_partition_order_from_blocksize_limited_max_and_predictor_order(unsigned limit, unsigned blocksize, unsigned predictor_order)
{
	unsigned max_rice_partition_order = limit;

	while(max_rice_partition_order > 0 && (blocksize >> max_rice_partition_order) <= predictor_order)
		max_rice_partition_order--;

	FLAC__ASSERT(
		(max_rice_partition_order == 0 && blocksize >= predictor_order) ||
		(max_rice_partition_order > 0 && blocksize >> max_rice_partition_order > predictor_order)
	);

	return max_rice_partition_order;
}

void FLAC__format_entropy_coding_method_partitioned_rice_contents_init(FLAC__EntropyCodingMethod_PartitionedRiceContents *object)
{
	FLAC__ASSERT(0 != object);

	object->parameters = 0;
	object->raw_bits = 0;
	object->capacity_by_order = 0;
}

void FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(FLAC__EntropyCodingMethod_PartitionedRiceContents *object)
{
	FLAC__ASSERT(0 != object);

	if(0 != object->parameters)
		free(object->parameters);
	if(0 != object->raw_bits)
		free(object->raw_bits);
	FLAC__format_entropy_coding_method_partitioned_rice_contents_init(object);
}

FLAC__bool FLAC__format_entropy_coding_method_partitioned_rice_contents_ensure_size(FLAC__EntropyCodingMethod_PartitionedRiceContents *object, unsigned max_partition_order)
{
	FLAC__ASSERT(0 != object);

	FLAC__ASSERT(object->capacity_by_order > 0 || (0 == object->parameters && 0 == object->raw_bits));

	if(object->capacity_by_order < max_partition_order) {
		if(0 == (object->parameters = (unsigned*)realloc(object->parameters, sizeof(unsigned)*(1 << max_partition_order))))
			return false;
		if(0 == (object->raw_bits = (unsigned*)realloc(object->raw_bits, sizeof(unsigned)*(1 << max_partition_order))))
			return false;
		memset(object->raw_bits, 0, sizeof(unsigned)*(1 << max_partition_order));
		object->capacity_by_order = max_partition_order;
	}

	return true;
}

/*** End of inlined file: format.c ***/


/*** Start of inlined file: lpc_flac.c ***/
#if HAVE_CONFIG_H
#  include <config.h>
#endif

#include <math.h>


/*** Start of inlined file: lpc.h ***/
#ifndef FLAC__PRIVATE__LPC_H
#define FLAC__PRIVATE__LPC_H

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#ifndef FLAC__INTEGER_ONLY_LIBRARY

/*
 *	FLAC__lpc_window_data()
 *	--------------------------------------------------------------------
 *	Applies the given window to the data.
 *  OPT: asm implementation
 *
 *	IN in[0,data_len-1]
 *	IN window[0,data_len-1]
 *	OUT out[0,lag-1]
 *	IN data_len
 */
void FLAC__lpc_window_data(const FLAC__int32 in[], const FLAC__real window[], FLAC__real out[], unsigned data_len);

/*
 *	FLAC__lpc_compute_autocorrelation()
 *	--------------------------------------------------------------------
 *	Compute the autocorrelation for lags between 0 and lag-1.
 *	Assumes data[] outside of [0,data_len-1] == 0.
 *	Asserts that lag > 0.
 *
 *	IN data[0,data_len-1]
 *	IN data_len
 *	IN 0 < lag <= data_len
 *	OUT autoc[0,lag-1]
 */
void FLAC__lpc_compute_autocorrelation(const FLAC__real data[], unsigned data_len, unsigned lag, FLAC__real autoc[]);
#ifndef FLAC__NO_ASM
#  ifdef FLAC__CPU_IA32
#    ifdef FLAC__HAS_NASM
void FLAC__lpc_compute_autocorrelation_asm_ia32(const FLAC__real data[], unsigned data_len, unsigned lag, FLAC__real autoc[]);
void FLAC__lpc_compute_autocorrelation_asm_ia32_sse_lag_4(const FLAC__real data[], unsigned data_len, unsigned lag, FLAC__real autoc[]);
void FLAC__lpc_compute_autocorrelation_asm_ia32_sse_lag_8(const FLAC__real data[], unsigned data_len, unsigned lag, FLAC__real autoc[]);
void FLAC__lpc_compute_autocorrelation_asm_ia32_sse_lag_12(const FLAC__real data[], unsigned data_len, unsigned lag, FLAC__real autoc[]);
void FLAC__lpc_compute_autocorrelation_asm_ia32_3dnow(const FLAC__real data[], unsigned data_len, unsigned lag, FLAC__real autoc[]);
#    endif
#  endif
#endif

/*
 *	FLAC__lpc_compute_lp_coefficients()
 *	--------------------------------------------------------------------
 *	Computes LP coefficients for orders 1..max_order.
 *	Do not call if autoc[0] == 0.0.  This means the signal is zero
 *	and there is no point in calculating a predictor.
 *
 *	IN autoc[0,max_order]                      autocorrelation values
 *	IN 0 < max_order <= FLAC__MAX_LPC_ORDER    max LP order to compute
 *	OUT lp_coeff[0,max_order-1][0,max_order-1] LP coefficients for each order
 *	*** IMPORTANT:
 *	*** lp_coeff[0,max_order-1][max_order,FLAC__MAX_LPC_ORDER-1] are untouched
 *	OUT error[0,max_order-1]                   error for each order (more
 *	                                           specifically, the variance of
 *	                                           the error signal times # of
 *	                                           samples in the signal)
 *
 *	Example: if max_order is 9, the LP coefficients for order 9 will be
 *	         in lp_coeff[8][0,8], the LP coefficients for order 8 will be
 *			 in lp_coeff[7][0,7], etc.
 */
void FLAC__lpc_compute_lp_coefficients(const FLAC__real autoc[], unsigned *max_order, FLAC__real lp_coeff[][FLAC__MAX_LPC_ORDER], FLAC__double error[]);

/*
 *	FLAC__lpc_quantize_coefficients()
 *	--------------------------------------------------------------------
 *	Quantizes the LP coefficients.  NOTE: precision + bits_per_sample
 *	must be less than 32 (sizeof(FLAC__int32)*8).
 *
 *	IN lp_coeff[0,order-1]    LP coefficients
 *	IN order                  LP order
 *	IN FLAC__MIN_QLP_COEFF_PRECISION < precision
 *	                          desired precision (in bits, including sign
 *	                          bit) of largest coefficient
 *	OUT qlp_coeff[0,order-1]  quantized coefficients
 *	OUT shift                 # of bits to shift right to get approximated
 *	                          LP coefficients.  NOTE: could be negative.
 *	RETURN 0 => quantization OK
 *	       1 => coefficients require too much shifting for *shift to
 *              fit in the LPC subframe header.  'shift' is unset.
 *         2 => coefficients are all zero, which is bad.  'shift' is
 *              unset.
 */
int FLAC__lpc_quantize_coefficients(const FLAC__real lp_coeff[], unsigned order, unsigned precision, FLAC__int32 qlp_coeff[], int *shift);

/*
 *	FLAC__lpc_compute_residual_from_qlp_coefficients()
 *	--------------------------------------------------------------------
 *	Compute the residual signal obtained from sutracting the predicted
 *	signal from the original.
 *
 *	IN data[-order,data_len-1] original signal (NOTE THE INDICES!)
 *	IN data_len                length of original signal
 *	IN qlp_coeff[0,order-1]    quantized LP coefficients
 *	IN order > 0               LP order
 *	IN lp_quantization         quantization of LP coefficients in bits
 *	OUT residual[0,data_len-1] residual signal
 */
void FLAC__lpc_compute_residual_from_qlp_coefficients(const FLAC__int32 *data, unsigned data_len, const FLAC__int32 qlp_coeff[], unsigned order, int lp_quantization, FLAC__int32 residual[]);
void FLAC__lpc_compute_residual_from_qlp_coefficients_wide(const FLAC__int32 *data, unsigned data_len, const FLAC__int32 qlp_coeff[], unsigned order, int lp_quantization, FLAC__int32 residual[]);
#ifndef FLAC__NO_ASM
#  ifdef FLAC__CPU_IA32
#    ifdef FLAC__HAS_NASM
void FLAC__lpc_compute_residual_from_qlp_coefficients_asm_ia32(const FLAC__int32 *data, unsigned data_len, const FLAC__int32 qlp_coeff[], unsigned order, int lp_quantization, FLAC__int32 residual[]);
void FLAC__lpc_compute_residual_from_qlp_coefficients_asm_ia32_mmx(const FLAC__int32 *data, unsigned data_len, const FLAC__int32 qlp_coeff[], unsigned order, int lp_quantization, FLAC__int32 residual[]);
#    endif
#  endif
#endif

#endif /* !defined FLAC__INTEGER_ONLY_LIBRARY */

/*
 *	FLAC__lpc_restore_signal()
 *	--------------------------------------------------------------------
 *	Restore the original signal by summing the residual and the
 *	predictor.
 *
 *	IN residual[0,data_len-1]  residual signal
 *	IN data_len                length of original signal
 *	IN qlp_coeff[0,order-1]    quantized LP coefficients
 *	IN order > 0               LP order
 *	IN lp_quantization         quantization of LP coefficients in bits
 *	*** IMPORTANT: the caller must pass in the historical samples:
 *	IN  data[-order,-1]        previously-reconstructed historical samples
 *	OUT data[0,data_len-1]     original signal
 */
void FLAC__lpc_restore_signal(const FLAC__int32 residual[], unsigned data_len, const FLAC__int32 qlp_coeff[], unsigned order, int lp_quantization, FLAC__int32 data[]);
void FLAC__lpc_restore_signal_wide(const FLAC__int32 residual[], unsigned data_len, const FLAC__int32 qlp_coeff[], unsigned order, int lp_quantization, FLAC__int32 data[]);
#ifndef FLAC__NO_ASM
#  ifdef FLAC__CPU_IA32
#    ifdef FLAC__HAS_NASM
void FLAC__lpc_restore_signal_asm_ia32(const FLAC__int32 residual[], unsigned data_len, const FLAC__int32 qlp_coeff[], unsigned order, int lp_quantization, FLAC__int32 data[]);
void FLAC__lpc_restore_signal_asm_ia32_mmx(const FLAC__int32 residual[], unsigned data_len, const FLAC__int32 qlp_coeff[], unsigned order, int lp_quantization, FLAC__int32 data[]);
#    endif /* FLAC__HAS_NASM */
#  elif defined FLAC__CPU_PPC
void FLAC__lpc_restore_signal_asm_ppc_altivec_16(const FLAC__int32 residual[], unsigned data_len, const FLAC__int32 qlp_coeff[], unsigned order, int lp_quantization, FLAC__int32 data[]);
void FLAC__lpc_restore_signal_asm_ppc_altivec_16_order8(const FLAC__int32 residual[], unsigned data_len, const FLAC__int32 qlp_coeff[], unsigned order, int lp_quantization, FLAC__int32 data[]);
#  endif/* FLAC__CPU_IA32 || FLAC__CPU_PPC */
#endif /* FLAC__NO_ASM */

#ifndef FLAC__INTEGER_ONLY_LIBRARY

/*
 *	FLAC__lpc_compute_expected_bits_per_residual_sample()
 *	--------------------------------------------------------------------
 *	Compute the expected number of bits per residual signal sample
 *	based on the LP error (which is related to the residual variance).
 *
 *	IN lpc_error >= 0.0   error returned from calculating LP coefficients
 *	IN total_samples > 0  # of samples in residual signal
 *	RETURN                expected bits per sample
 */
FLAC__double FLAC__lpc_compute_expected_bits_per_residual_sample(FLAC__double lpc_error, unsigned total_samples);
FLAC__double FLAC__lpc_compute_expected_bits_per_residual_sample_with_error_scale(FLAC__double lpc_error, FLAC__double error_scale);

/*
 *	FLAC__lpc_compute_best_order()
 *	--------------------------------------------------------------------
 *	Compute the best order from the array of signal errors returned
 *	during coefficient computation.
 *
 *	IN lpc_error[0,max_order-1] >= 0.0  error returned from calculating LP coefficients
 *	IN max_order > 0                    max LP order
 *	IN total_samples > 0                # of samples in residual signal
 *	IN overhead_bits_per_order          # of bits overhead for each increased LP order
 *	                                    (includes warmup sample size and quantized LP coefficient)
 *	RETURN [1,max_order]                best order
 */
unsigned FLAC__lpc_compute_best_order(const FLAC__double lpc_error[], unsigned max_order, unsigned total_samples, unsigned overhead_bits_per_order);

#endif /* !defined FLAC__INTEGER_ONLY_LIBRARY */

#endif

/*** End of inlined file: lpc.h ***/

#if defined DEBUG || defined FLAC__OVERFLOW_DETECT || defined FLAC__OVERFLOW_DETECT_VERBOSE
#include <stdio.h>
#endif

#ifndef FLAC__INTEGER_ONLY_LIBRARY

#ifndef M_LN2
/* math.h in VC++ doesn't seem to have this (how Microsoft is that?) */
#define M_LN2 0.69314718055994530942
#endif

/* OPT: #undef'ing this may improve the speed on some architectures */
#define FLAC__LPC_UNROLLED_FILTER_LOOPS

void FLAC__lpc_window_data(const FLAC__int32 in[], const FLAC__real window[], FLAC__real out[], unsigned data_len)
{
	unsigned i;
	for(i = 0; i < data_len; i++)
		out[i] = in[i] * window[i];
}

void FLAC__lpc_compute_autocorrelation(const FLAC__real data[], unsigned data_len, unsigned lag, FLAC__real autoc[])
{
	/* a readable, but slower, version */
#if 0
	FLAC__real d;
	unsigned i;

	FLAC__ASSERT(lag > 0);
	FLAC__ASSERT(lag <= data_len);

	/*
	 * Technically we should subtract the mean first like so:
	 *   for(i = 0; i < data_len; i++)
	 *     data[i] -= mean;
	 * but it appears not to make enough of a difference to matter, and
	 * most signals are already closely centered around zero
	 */
	while(lag--) {
		for(i = lag, d = 0.0; i < data_len; i++)
			d += data[i] * data[i - lag];
		autoc[lag] = d;
	}
#endif

	/*
	 * this version tends to run faster because of better data locality
	 * ('data_len' is usually much larger than 'lag')
	 */
	FLAC__real d;
	unsigned sample, coeff;
	const unsigned limit = data_len - lag;

	FLAC__ASSERT(lag > 0);
	FLAC__ASSERT(lag <= data_len);

	for(coeff = 0; coeff < lag; coeff++)
		autoc[coeff] = 0.0;
	for(sample = 0; sample <= limit; sample++) {
		d = data[sample];
		for(coeff = 0; coeff < lag; coeff++)
			autoc[coeff] += d * data[sample+coeff];
	}
	for(; sample < data_len; sample++) {
		d = data[sample];
		for(coeff = 0; coeff < data_len - sample; coeff++)
			autoc[coeff] += d * data[sample+coeff];
	}
}

void FLAC__lpc_compute_lp_coefficients(const FLAC__real autoc[], unsigned *max_order, FLAC__real lp_coeff[][FLAC__MAX_LPC_ORDER], FLAC__double error[])
{
	unsigned i, j;
	FLAC__double r, err, ref[FLAC__MAX_LPC_ORDER], lpc[FLAC__MAX_LPC_ORDER];

	FLAC__ASSERT(0 != max_order);
	FLAC__ASSERT(0 < *max_order);
	FLAC__ASSERT(*max_order <= FLAC__MAX_LPC_ORDER);
	FLAC__ASSERT(autoc[0] != 0.0);

	err = autoc[0];

	for(i = 0; i < *max_order; i++) {
		/* Sum up this iteration's reflection coefficient. */
		r = -autoc[i+1];
		for(j = 0; j < i; j++)
			r -= lpc[j] * autoc[i-j];
		ref[i] = (r/=err);

		/* Update LPC coefficients and total error. */
		lpc[i]=r;
		for(j = 0; j < (i>>1); j++) {
			FLAC__double tmp = lpc[j];
			lpc[j] += r * lpc[i-1-j];
			lpc[i-1-j] += r * tmp;
		}
		if(i & 1)
			lpc[j] += lpc[j] * r;

		err *= (1.0 - r * r);

		/* save this order */
		for(j = 0; j <= i; j++)
			lp_coeff[i][j] = (FLAC__real)(-lpc[j]); /* negate FIR filter coeff to get predictor coeff */
		error[i] = err;

		/* see SF bug #1601812 http://sourceforge.net/tracker/index.php?func=detail&aid=1601812&group_id=13478&atid=113478 */
		if(err == 0.0) {
			*max_order = i+1;
			return;
		}
	}
}

int FLAC__lpc_quantize_coefficients(const FLAC__real lp_coeff[], unsigned order, unsigned precision, FLAC__int32 qlp_coeff[], int *shift)
{
	unsigned i;
	FLAC__double cmax;
	FLAC__int32 qmax, qmin;

	FLAC__ASSERT(precision > 0);
	FLAC__ASSERT(precision >= FLAC__MIN_QLP_COEFF_PRECISION);

	/* drop one bit for the sign; from here on out we consider only |lp_coeff[i]| */
	precision--;
	qmax = 1 << precision;
	qmin = -qmax;
	qmax--;

	/* calc cmax = max( |lp_coeff[i]| ) */
	cmax = 0.0;
	for(i = 0; i < order; i++) {
		const FLAC__double d = fabs(lp_coeff[i]);
		if(d > cmax)
			cmax = d;
	}

	if(cmax <= 0.0) {
		/* => coefficients are all 0, which means our constant-detect didn't work */
		return 2;
	}
	else {
		const int max_shiftlimit = (1 << (FLAC__SUBFRAME_LPC_QLP_SHIFT_LEN-1)) - 1;
		const int min_shiftlimit = -max_shiftlimit - 1;
		int log2cmax;

		(void)frexp(cmax, &log2cmax);
		log2cmax--;
		*shift = (int)precision - log2cmax - 1;

		if(*shift > max_shiftlimit)
			*shift = max_shiftlimit;
		else if(*shift < min_shiftlimit)
			return 1;
	}

	if(*shift >= 0) {
		FLAC__double error = 0.0;
		FLAC__int32 q;
		for(i = 0; i < order; i++) {
			error += lp_coeff[i] * (1 << *shift);
#if 1 /* unfortunately lround() is C99 */
			if(error >= 0.0)
				q = (FLAC__int32)(error + 0.5);
			else
				q = (FLAC__int32)(error - 0.5);
#else
			q = lround(error);
#endif
#ifdef FLAC__OVERFLOW_DETECT
			if(q > qmax+1) /* we expect q==qmax+1 occasionally due to rounding */
				fprintf(stderr,"FLAC__lpc_quantize_coefficients: quantizer overflow: q>qmax %d>%d shift=%d cmax=%f precision=%u lpc[%u]=%f\n",q,qmax,*shift,cmax,precision+1,i,lp_coeff[i]);
			else if(q < qmin)
				fprintf(stderr,"FLAC__lpc_quantize_coefficients: quantizer overflow: q<qmin %d<%d shift=%d cmax=%f precision=%u lpc[%u]=%f\n",q,qmin,*shift,cmax,precision+1,i,lp_coeff[i]);
#endif
			if(q > qmax)
				q = qmax;
			else if(q < qmin)
				q = qmin;
			error -= q;
			qlp_coeff[i] = q;
		}
	}
	/* negative shift is very rare but due to design flaw, negative shift is
	 * a NOP in the decoder, so it must be handled specially by scaling down
	 * coeffs
	 */
	else {
		const int nshift = -(*shift);
		FLAC__double error = 0.0;
		FLAC__int32 q;
#ifdef DEBUG
		fprintf(stderr,"FLAC__lpc_quantize_coefficients: negative shift=%d order=%u cmax=%f\n", *shift, order, cmax);
#endif
		for(i = 0; i < order; i++) {
			error += lp_coeff[i] / (1 << nshift);
#if 1 /* unfortunately lround() is C99 */
			if(error >= 0.0)
				q = (FLAC__int32)(error + 0.5);
			else
				q = (FLAC__int32)(error - 0.5);
#else
			q = lround(error);
#endif
#ifdef FLAC__OVERFLOW_DETECT
			if(q > qmax+1) /* we expect q==qmax+1 occasionally due to rounding */
				fprintf(stderr,"FLAC__lpc_quantize_coefficients: quantizer overflow: q>qmax %d>%d shift=%d cmax=%f precision=%u lpc[%u]=%f\n",q,qmax,*shift,cmax,precision+1,i,lp_coeff[i]);
			else if(q < qmin)
				fprintf(stderr,"FLAC__lpc_quantize_coefficients: quantizer overflow: q<qmin %d<%d shift=%d cmax=%f precision=%u lpc[%u]=%f\n",q,qmin,*shift,cmax,precision+1,i,lp_coeff[i]);
#endif
			if(q > qmax)
				q = qmax;
			else if(q < qmin)
				q = qmin;
			error -= q;
			qlp_coeff[i] = q;
		}
		*shift = 0;
	}

	return 0;
}

void FLAC__lpc_compute_residual_from_qlp_coefficients(const FLAC__int32 *data, unsigned data_len, const FLAC__int32 qlp_coeff[], unsigned order, int lp_quantization, FLAC__int32 residual[])
#if defined(FLAC__OVERFLOW_DETECT) || !defined(FLAC__LPC_UNROLLED_FILTER_LOOPS)
{
	FLAC__int64 sumo;
	unsigned i, j;
	FLAC__int32 sum;
	const FLAC__int32 *history;

#ifdef FLAC__OVERFLOW_DETECT_VERBOSE
	fprintf(stderr,"FLAC__lpc_compute_residual_from_qlp_coefficients: data_len=%d, order=%u, lpq=%d",data_len,order,lp_quantization);
	for(i=0;i<order;i++)
		fprintf(stderr,", q[%u]=%d",i,qlp_coeff[i]);
	fprintf(stderr,"\n");
#endif
	FLAC__ASSERT(order > 0);

	for(i = 0; i < data_len; i++) {
		sumo = 0;
		sum = 0;
		history = data;
		for(j = 0; j < order; j++) {
			sum += qlp_coeff[j] * (*(--history));
			sumo += (FLAC__int64)qlp_coeff[j] * (FLAC__int64)(*history);
#if defined _MSC_VER
			if(sumo > 2147483647I64 || sumo < -2147483648I64)
				fprintf(stderr,"FLAC__lpc_compute_residual_from_qlp_coefficients: OVERFLOW, i=%u, j=%u, c=%d, d=%d, sumo=%I64d\n",i,j,qlp_coeff[j],*history,sumo);
#else
			if(sumo > 2147483647ll || sumo < -2147483648ll)
				fprintf(stderr,"FLAC__lpc_compute_residual_from_qlp_coefficients: OVERFLOW, i=%u, j=%u, c=%d, d=%d, sumo=%lld\n",i,j,qlp_coeff[j],*history,(long long)sumo);
#endif
		}
		*(residual++) = *(data++) - (sum >> lp_quantization);
	}

	/* Here's a slower but clearer version:
	for(i = 0; i < data_len; i++) {
		sum = 0;
		for(j = 0; j < order; j++)
			sum += qlp_coeff[j] * data[i-j-1];
		residual[i] = data[i] - (sum >> lp_quantization);
	}
	*/
}
#else /* fully unrolled version for normal use */
{
	int i;
	FLAC__int32 sum;

	FLAC__ASSERT(order > 0);
	FLAC__ASSERT(order <= 32);

	/*
	 * We do unique versions up to 12th order since that's the subset limit.
	 * Also they are roughly ordered to match frequency of occurrence to
	 * minimize branching.
	 */
	if(order <= 12) {
		if(order > 8) {
			if(order > 10) {
				if(order == 12) {
					for(i = 0; i < (int)data_len; i++) {
						sum = 0;
						sum += qlp_coeff[11] * data[i-12];
						sum += qlp_coeff[10] * data[i-11];
						sum += qlp_coeff[9] * data[i-10];
						sum += qlp_coeff[8] * data[i-9];
						sum += qlp_coeff[7] * data[i-8];
						sum += qlp_coeff[6] * data[i-7];
						sum += qlp_coeff[5] * data[i-6];
						sum += qlp_coeff[4] * data[i-5];
						sum += qlp_coeff[3] * data[i-4];
						sum += qlp_coeff[2] * data[i-3];
						sum += qlp_coeff[1] * data[i-2];
						sum += qlp_coeff[0] * data[i-1];
						residual[i] = data[i] - (sum >> lp_quantization);
					}
				}
				else { /* order == 11 */
					for(i = 0; i < (int)data_len; i++) {
						sum = 0;
						sum += qlp_coeff[10] * data[i-11];
						sum += qlp_coeff[9] * data[i-10];
						sum += qlp_coeff[8] * data[i-9];
						sum += qlp_coeff[7] * data[i-8];
						sum += qlp_coeff[6] * data[i-7];
						sum += qlp_coeff[5] * data[i-6];
						sum += qlp_coeff[4] * data[i-5];
						sum += qlp_coeff[3] * data[i-4];
						sum += qlp_coeff[2] * data[i-3];
						sum += qlp_coeff[1] * data[i-2];
						sum += qlp_coeff[0] * data[i-1];
						residual[i] = data[i] - (sum >> lp_quantization);
					}
				}
			}
			else {
				if(order == 10) {
					for(i = 0; i < (int)data_len; i++) {
						sum = 0;
						sum += qlp_coeff[9] * data[i-10];
						sum += qlp_coeff[8] * data[i-9];
						sum += qlp_coeff[7] * data[i-8];
						sum += qlp_coeff[6] * data[i-7];
						sum += qlp_coeff[5] * data[i-6];
						sum += qlp_coeff[4] * data[i-5];
						sum += qlp_coeff[3] * data[i-4];
						sum += qlp_coeff[2] * data[i-3];
						sum += qlp_coeff[1] * data[i-2];
						sum += qlp_coeff[0] * data[i-1];
						residual[i] = data[i] - (sum >> lp_quantization);
					}
				}
				else { /* order == 9 */
					for(i = 0; i < (int)data_len; i++) {
						sum = 0;
						sum += qlp_coeff[8] * data[i-9];
						sum += qlp_coeff[7] * data[i-8];
						sum += qlp_coeff[6] * data[i-7];
						sum += qlp_coeff[5] * data[i-6];
						sum += qlp_coeff[4] * data[i-5];
						sum += qlp_coeff[3] * data[i-4];
						sum += qlp_coeff[2] * data[i-3];
						sum += qlp_coeff[1] * data[i-2];
						sum += qlp_coeff[0] * data[i-1];
						residual[i] = data[i] - (sum >> lp_quantization);
					}
				}
			}
		}
		else if(order > 4) {
			if(order > 6) {
				if(order == 8) {
					for(i = 0; i < (int)data_len; i++) {
						sum = 0;
						sum += qlp_coeff[7] * data[i-8];
						sum += qlp_coeff[6] * data[i-7];
						sum += qlp_coeff[5] * data[i-6];
						sum += qlp_coeff[4] * data[i-5];
						sum += qlp_coeff[3] * data[i-4];
						sum += qlp_coeff[2] * data[i-3];
						sum += qlp_coeff[1] * data[i-2];
						sum += qlp_coeff[0] * data[i-1];
						residual[i] = data[i] - (sum >> lp_quantization);
					}
				}
				else { /* order == 7 */
					for(i = 0; i < (int)data_len; i++) {
						sum = 0;
						sum += qlp_coeff[6] * data[i-7];
						sum += qlp_coeff[5] * data[i-6];
						sum += qlp_coeff[4] * data[i-5];
						sum += qlp_coeff[3] * data[i-4];
						sum += qlp_coeff[2] * data[i-3];
						sum += qlp_coeff[1] * data[i-2];
						sum += qlp_coeff[0] * data[i-1];
						residual[i] = data[i] - (sum >> lp_quantization);
					}
				}
			}
			else {
				if(order == 6) {
					for(i = 0; i < (int)data_len; i++) {
						sum = 0;
						sum += qlp_coeff[5] * data[i-6];
						sum += qlp_coeff[4] * data[i-5];
						sum += qlp_coeff[3] * data[i-4];
						sum += qlp_coeff[2] * data[i-3];
						sum += qlp_coeff[1] * data[i-2];
						sum += qlp_coeff[0] * data[i-1];
						residual[i] = data[i] - (sum >> lp_quantization);
					}
				}
				else { /* order == 5 */
					for(i = 0; i < (int)data_len; i++) {
						sum = 0;
						sum += qlp_coeff[4] * data[i-5];
						sum += qlp_coeff[3] * data[i-4];
						sum += qlp_coeff[2] * data[i-3];
						sum += qlp_coeff[1] * data[i-2];
						sum += qlp_coeff[0] * data[i-1];
						residual[i] = data[i] - (sum >> lp_quantization);
					}
				}
			}
		}
		else {
			if(order > 2) {
				if(order == 4) {
					for(i = 0; i < (int)data_len; i++) {
						sum = 0;
						sum += qlp_coeff[3] * data[i-4];
						sum += qlp_coeff[2] * data[i-3];
						sum += qlp_coeff[1] * data[i-2];
						sum += qlp_coeff[0] * data[i-1];
						residual[i] = data[i] - (sum >> lp_quantization);
					}
				}
				else { /* order == 3 */
					for(i = 0; i < (int)data_len; i++) {
						sum = 0;
						sum += qlp_coeff[2] * data[i-3];
						sum += qlp_coeff[1] * data[i-2];
						sum += qlp_coeff[0] * data[i-1];
						residual[i] = data[i] - (sum >> lp_quantization);
					}
				}
			}
			else {
				if(order == 2) {
					for(i = 0; i < (int)data_len; i++) {
						sum = 0;
						sum += qlp_coeff[1] * data[i-2];
						sum += qlp_coeff[0] * data[i-1];
						residual[i] = data[i] - (sum >> lp_quantization);
					}
				}
				else { /* order == 1 */
					for(i = 0; i < (int)data_len; i++)
						residual[i] = data[i] - ((qlp_coeff[0] * data[i-1]) >> lp_quantization);
				}
			}
		}
	}
	else { /* order > 12 */
		for(i = 0; i < (int)data_len; i++) {
			sum = 0;
			switch(order) {
				case 32: sum += qlp_coeff[31] * data[i-32];
				case 31: sum += qlp_coeff[30] * data[i-31];
				case 30: sum += qlp_coeff[29] * data[i-30];
				case 29: sum += qlp_coeff[28] * data[i-29];
				case 28: sum += qlp_coeff[27] * data[i-28];
				case 27: sum += qlp_coeff[26] * data[i-27];
				case 26: sum += qlp_coeff[25] * data[i-26];
				case 25: sum += qlp_coeff[24] * data[i-25];
				case 24: sum += qlp_coeff[23] * data[i-24];
				case 23: sum += qlp_coeff[22] * data[i-23];
				case 22: sum += qlp_coeff[21] * data[i-22];
				case 21: sum += qlp_coeff[20] * data[i-21];
				case 20: sum += qlp_coeff[19] * data[i-20];
				case 19: sum += qlp_coeff[18] * data[i-19];
				case 18: sum += qlp_coeff[17] * data[i-18];
				case 17: sum += qlp_coeff[16] * data[i-17];
				case 16: sum += qlp_coeff[15] * data[i-16];
				case 15: sum += qlp_coeff[14] * data[i-15];
				case 14: sum += qlp_coeff[13] * data[i-14];
				case 13: sum += qlp_coeff[12] * data[i-13];
				         sum += qlp_coeff[11] * data[i-12];
				         sum += qlp_coeff[10] * data[i-11];
				         sum += qlp_coeff[ 9] * data[i-10];
				         sum += qlp_coeff[ 8] * data[i- 9];
				         sum += qlp_coeff[ 7] * data[i- 8];
				         sum += qlp_coeff[ 6] * data[i- 7];
				         sum += qlp_coeff[ 5] * data[i- 6];
				         sum += qlp_coeff[ 4] * data[i- 5];
				         sum += qlp_coeff[ 3] * data[i- 4];
				         sum += qlp_coeff[ 2] * data[i- 3];
				         sum += qlp_coeff[ 1] * data[i- 2];
				         sum += qlp_coeff[ 0] * data[i- 1];
			}
			residual[i] = data[i] - (sum >> lp_quantization);
		}
	}
}
#endif

void FLAC__lpc_compute_residual_from_qlp_coefficients_wide(const FLAC__int32 *data, unsigned data_len, const FLAC__int32 qlp_coeff[], unsigned order, int lp_quantization, FLAC__int32 residual[])
#if defined(FLAC__OVERFLOW_DETECT) || !defined(FLAC__LPC_UNROLLED_FILTER_LOOPS)
{
	unsigned i, j;
	FLAC__int64 sum;
	const FLAC__int32 *history;

#ifdef FLAC__OVERFLOW_DETECT_VERBOSE
	fprintf(stderr,"FLAC__lpc_compute_residual_from_qlp_coefficients_wide: data_len=%d, order=%u, lpq=%d",data_len,order,lp_quantization);
	for(i=0;i<order;i++)
		fprintf(stderr,", q[%u]=%d",i,qlp_coeff[i]);
	fprintf(stderr,"\n");
#endif
	FLAC__ASSERT(order > 0);

	for(i = 0; i < data_len; i++) {
		sum = 0;
		history = data;
		for(j = 0; j < order; j++)
			sum += (FLAC__int64)qlp_coeff[j] * (FLAC__int64)(*(--history));
		if(FLAC__bitmath_silog2_wide(sum >> lp_quantization) > 32) {
#if defined _MSC_VER
			fprintf(stderr,"FLAC__lpc_compute_residual_from_qlp_coefficients_wide: OVERFLOW, i=%u, sum=%I64d\n", i, sum >> lp_quantization);
#else
			fprintf(stderr,"FLAC__lpc_compute_residual_from_qlp_coefficients_wide: OVERFLOW, i=%u, sum=%lld\n", i, (long long)(sum >> lp_quantization));
#endif
			break;
		}
		if(FLAC__bitmath_silog2_wide((FLAC__int64)(*data) - (sum >> lp_quantization)) > 32) {
#if defined _MSC_VER
			fprintf(stderr,"FLAC__lpc_compute_residual_from_qlp_coefficients_wide: OVERFLOW, i=%u, data=%d, sum=%I64d, residual=%I64d\n", i, *data, sum >> lp_quantization, (FLAC__int64)(*data) - (sum >> lp_quantization));
#else
			fprintf(stderr,"FLAC__lpc_compute_residual_from_qlp_coefficients_wide: OVERFLOW, i=%u, data=%d, sum=%lld, residual=%lld\n", i, *data, (long long)(sum >> lp_quantization), (long long)((FLAC__int64)(*data) - (sum >> lp_quantization)));
#endif
			break;
		}
		*(residual++) = *(data++) - (FLAC__int32)(sum >> lp_quantization);
	}
}
#else /* fully unrolled version for normal use */
{
	int i;
	FLAC__int64 sum;

	FLAC__ASSERT(order > 0);
	FLAC__ASSERT(order <= 32);

	/*
	 * We do unique versions up to 12th order since that's the subset limit.
	 * Also they are roughly ordered to match frequency of occurrence to
	 * minimize branching.
	 */
	if(order <= 12) {
		if(order > 8) {
			if(order > 10) {
				if(order == 12) {
					for(i = 0; i < (int)data_len; i++) {
						sum = 0;
						sum += qlp_coeff[11] * (FLAC__int64)data[i-12];
						sum += qlp_coeff[10] * (FLAC__int64)data[i-11];
						sum += qlp_coeff[9] * (FLAC__int64)data[i-10];
						sum += qlp_coeff[8] * (FLAC__int64)data[i-9];
						sum += qlp_coeff[7] * (FLAC__int64)data[i-8];
						sum += qlp_coeff[6] * (FLAC__int64)data[i-7];
						sum += qlp_coeff[5] * (FLAC__int64)data[i-6];
						sum += qlp_coeff[4] * (FLAC__int64)data[i-5];
						sum += qlp_coeff[3] * (FLAC__int64)data[i-4];
						sum += qlp_coeff[2] * (FLAC__int64)data[i-3];
						sum += qlp_coeff[1] * (FLAC__int64)data[i-2];
						sum += qlp_coeff[0] * (FLAC__int64)data[i-1];
						residual[i] = data[i] - (FLAC__int32)(sum >> lp_quantization);
					}
				}
				else { /* order == 11 */
					for(i = 0; i < (int)data_len; i++) {
						sum = 0;
						sum += qlp_coeff[10] * (FLAC__int64)data[i-11];
						sum += qlp_coeff[9] * (FLAC__int64)data[i-10];
						sum += qlp_coeff[8] * (FLAC__int64)data[i-9];
						sum += qlp_coeff[7] * (FLAC__int64)data[i-8];
						sum += qlp_coeff[6] * (FLAC__int64)data[i-7];
						sum += qlp_coeff[5] * (FLAC__int64)data[i-6];
						sum += qlp_coeff[4] * (FLAC__int64)data[i-5];
						sum += qlp_coeff[3] * (FLAC__int64)data[i-4];
						sum += qlp_coeff[2] * (FLAC__int64)data[i-3];
						sum += qlp_coeff[1] * (FLAC__int64)data[i-2];
						sum += qlp_coeff[0] * (FLAC__int64)data[i-1];
						residual[i] = data[i] - (FLAC__int32)(sum >> lp_quantization);
					}
				}
			}
			else {
				if(order == 10) {
					for(i = 0; i < (int)data_len; i++) {
						sum = 0;
						sum += qlp_coeff[9] * (FLAC__int64)data[i-10];
						sum += qlp_coeff[8] * (FLAC__int64)data[i-9];
						sum += qlp_coeff[7] * (FLAC__int64)data[i-8];
						sum += qlp_coeff[6] * (FLAC__int64)data[i-7];
						sum += qlp_coeff[5] * (FLAC__int64)data[i-6];
						sum += qlp_coeff[4] * (FLAC__int64)data[i-5];
						sum += qlp_coeff[3] * (FLAC__int64)data[i-4];
						sum += qlp_coeff[2] * (FLAC__int64)data[i-3];
						sum += qlp_coeff[1] * (FLAC__int64)data[i-2];
						sum += qlp_coeff[0] * (FLAC__int64)data[i-1];
						residual[i] = data[i] - (FLAC__int32)(sum >> lp_quantization);
					}
				}
				else { /* order == 9 */
					for(i = 0; i < (int)data_len; i++) {
						sum = 0;
						sum += qlp_coeff[8] * (FLAC__int64)data[i-9];
						sum += qlp_coeff[7] * (FLAC__int64)data[i-8];
						sum += qlp_coeff[6] * (FLAC__int64)data[i-7];
						sum += qlp_coeff[5] * (FLAC__int64)data[i-6];
						sum += qlp_coeff[4] * (FLAC__int64)data[i-5];
						sum += qlp_coeff[3] * (FLAC__int64)data[i-4];
						sum += qlp_coeff[2] * (FLAC__int64)data[i-3];
						sum += qlp_coeff[1] * (FLAC__int64)data[i-2];
						sum += qlp_coeff[0] * (FLAC__int64)data[i-1];
						residual[i] = data[i] - (FLAC__int32)(sum >> lp_quantization);
					}
				}
			}
		}
		else if(order > 4) {
			if(order > 6) {
				if(order == 8) {
					for(i = 0; i < (int)data_len; i++) {
						sum = 0;
						sum += qlp_coeff[7] * (FLAC__int64)data[i-8];
						sum += qlp_coeff[6] * (FLAC__int64)data[i-7];
						sum += qlp_coeff[5] * (FLAC__int64)data[i-6];
						sum += qlp_coeff[4] * (FLAC__int64)data[i-5];
						sum += qlp_coeff[3] * (FLAC__int64)data[i-4];
						sum += qlp_coeff[2] * (FLAC__int64)data[i-3];
						sum += qlp_coeff[1] * (FLAC__int64)data[i-2];
						sum += qlp_coeff[0] * (FLAC__int64)data[i-1];
						residual[i] = data[i] - (FLAC__int32)(sum >> lp_quantization);
					}
				}
				else { /* order == 7 */
					for(i = 0; i < (int)data_len; i++) {
						sum = 0;
						sum += qlp_coeff[6] * (FLAC__int64)data[i-7];
						sum += qlp_coeff[5] * (FLAC__int64)data[i-6];
						sum += qlp_coeff[4] * (FLAC__int64)data[i-5];
						sum += qlp_coeff[3] * (FLAC__int64)data[i-4];
						sum += qlp_coeff[2] * (FLAC__int64)data[i-3];
						sum += qlp_coeff[1] * (FLAC__int64)data[i-2];
						sum += qlp_coeff[0] * (FLAC__int64)data[i-1];
						residual[i] = data[i] - (FLAC__int32)(sum >> lp_quantization);
					}
				}
			}
			else {
				if(order == 6) {
					for(i = 0; i < (int)data_len; i++) {
						sum = 0;
						sum += qlp_coeff[5] * (FLAC__int64)data[i-6];
						sum += qlp_coeff[4] * (FLAC__int64)data[i-5];
						sum += qlp_coeff[3] * (FLAC__int64)data[i-4];
						sum += qlp_coeff[2] * (FLAC__int64)data[i-3];
						sum += qlp_coeff[1] * (FLAC__int64)data[i-2];
						sum += qlp_coeff[0] * (FLAC__int64)data[i-1];
						residual[i] = data[i] - (FLAC__int32)(sum >> lp_quantization);
					}
				}
				else { /* order == 5 */
					for(i = 0; i < (int)data_len; i++) {
						sum = 0;
						sum += qlp_coeff[4] * (FLAC__int64)data[i-5];
						sum += qlp_coeff[3] * (FLAC__int64)data[i-4];
						sum += qlp_coeff[2] * (FLAC__int64)data[i-3];
						sum += qlp_coeff[1] * (FLAC__int64)data[i-2];
						sum += qlp_coeff[0] * (FLAC__int64)data[i-1];
						residual[i] = data[i] - (FLAC__int32)(sum >> lp_quantization);
					}
				}
			}
		}
		else {
			if(order > 2) {
				if(order == 4) {
					for(i = 0; i < (int)data_len; i++) {
						sum = 0;
						sum += qlp_coeff[3] * (FLAC__int64)data[i-4];
						sum += qlp_coeff[2] * (FLAC__int64)data[i-3];
						sum += qlp_coeff[1] * (FLAC__int64)data[i-2];
						sum += qlp_coeff[0] * (FLAC__int64)data[i-1];
						residual[i] = data[i] - (FLAC__int32)(sum >> lp_quantization);
					}
				}
				else { /* order == 3 */
					for(i = 0; i < (int)data_len; i++) {
						sum = 0;
						sum += qlp_coeff[2] * (FLAC__int64)data[i-3];
						sum += qlp_coeff[1] * (FLAC__int64)data[i-2];
						sum += qlp_coeff[0] * (FLAC__int64)data[i-1];
						residual[i] = data[i] - (FLAC__int32)(sum >> lp_quantization);
					}
				}
			}
			else {
				if(order == 2) {
					for(i = 0; i < (int)data_len; i++) {
						sum = 0;
						sum += qlp_coeff[1] * (FLAC__int64)data[i-2];
						sum += qlp_coeff[0] * (FLAC__int64)data[i-1];
						residual[i] = data[i] - (FLAC__int32)(sum >> lp_quantization);
					}
				}
				else { /* order == 1 */
					for(i = 0; i < (int)data_len; i++)
						residual[i] = data[i] - (FLAC__int32)((qlp_coeff[0] * (FLAC__int64)data[i-1]) >> lp_quantization);
				}
			}
		}
	}
	else { /* order > 12 */
		for(i = 0; i < (int)data_len; i++) {
			sum = 0;
			switch(order) {
				case 32: sum += qlp_coeff[31] * (FLAC__int64)data[i-32];
				case 31: sum += qlp_coeff[30] * (FLAC__int64)data[i-31];
				case 30: sum += qlp_coeff[29] * (FLAC__int64)data[i-30];
				case 29: sum += qlp_coeff[28] * (FLAC__int64)data[i-29];
				case 28: sum += qlp_coeff[27] * (FLAC__int64)data[i-28];
				case 27: sum += qlp_coeff[26] * (FLAC__int64)data[i-27];
				case 26: sum += qlp_coeff[25] * (FLAC__int64)data[i-26];
				case 25: sum += qlp_coeff[24] * (FLAC__int64)data[i-25];
				case 24: sum += qlp_coeff[23] * (FLAC__int64)data[i-24];
				case 23: sum += qlp_coeff[22] * (FLAC__int64)data[i-23];
				case 22: sum += qlp_coeff[21] * (FLAC__int64)data[i-22];
				case 21: sum += qlp_coeff[20] * (FLAC__int64)data[i-21];
				case 20: sum += qlp_coeff[19] * (FLAC__int64)data[i-20];
				case 19: sum += qlp_coeff[18] * (FLAC__int64)data[i-19];
				case 18: sum += qlp_coeff[17] * (FLAC__int64)data[i-18];
				case 17: sum += qlp_coeff[16] * (FLAC__int64)data[i-17];
				case 16: sum += qlp_coeff[15] * (FLAC__int64)data[i-16];
				case 15: sum += qlp_coeff[14] * (FLAC__int64)data[i-15];
				case 14: sum += qlp_coeff[13] * (FLAC__int64)data[i-14];
				case 13: sum += qlp_coeff[12] * (FLAC__int64)data[i-13];
				         sum += qlp_coeff[11] * (FLAC__int64)data[i-12];
				         sum += qlp_coeff[10] * (FLAC__int64)data[i-11];
				         sum += qlp_coeff[ 9] * (FLAC__int64)data[i-10];
				         sum += qlp_coeff[ 8] * (FLAC__int64)data[i- 9];
				         sum += qlp_coeff[ 7] * (FLAC__int64)data[i- 8];
				         sum += qlp_coeff[ 6] * (FLAC__int64)data[i- 7];
				         sum += qlp_coeff[ 5] * (FLAC__int64)data[i- 6];
				         sum += qlp_coeff[ 4] * (FLAC__int64)data[i- 5];
				         sum += qlp_coeff[ 3] * (FLAC__int64)data[i- 4];
				         sum += qlp_coeff[ 2] * (FLAC__int64)data[i- 3];
				         sum += qlp_coeff[ 1] * (FLAC__int64)data[i- 2];
				         sum += qlp_coeff[ 0] * (FLAC__int64)data[i- 1];
			}
			residual[i] = data[i] - (FLAC__int32)(sum >> lp_quantization);
		}
	}
}
#endif

#endif /* !defined FLAC__INTEGER_ONLY_LIBRARY */

void FLAC__lpc_restore_signal(const FLAC__int32 residual[], unsigned data_len, const FLAC__int32 qlp_coeff[], unsigned order, int lp_quantization, FLAC__int32 data[])
#if defined(FLAC__OVERFLOW_DETECT) || !defined(FLAC__LPC_UNROLLED_FILTER_LOOPS)
{
	FLAC__int64 sumo;
	unsigned i, j;
	FLAC__int32 sum;
	const FLAC__int32 *r = residual, *history;

#ifdef FLAC__OVERFLOW_DETECT_VERBOSE
	fprintf(stderr,"FLAC__lpc_restore_signal: data_len=%d, order=%u, lpq=%d",data_len,order,lp_quantization);
	for(i=0;i<order;i++)
		fprintf(stderr,", q[%u]=%d",i,qlp_coeff[i]);
	fprintf(stderr,"\n");
#endif
	FLAC__ASSERT(order > 0);

	for(i = 0; i < data_len; i++) {
		sumo = 0;
		sum = 0;
		history = data;
		for(j = 0; j < order; j++) {
			sum += qlp_coeff[j] * (*(--history));
			sumo += (FLAC__int64)qlp_coeff[j] * (FLAC__int64)(*history);
#if defined _MSC_VER
			if(sumo > 2147483647I64 || sumo < -2147483648I64)
				fprintf(stderr,"FLAC__lpc_restore_signal: OVERFLOW, i=%u, j=%u, c=%d, d=%d, sumo=%I64d\n",i,j,qlp_coeff[j],*history,sumo);
#else
			if(sumo > 2147483647ll || sumo < -2147483648ll)
				fprintf(stderr,"FLAC__lpc_restore_signal: OVERFLOW, i=%u, j=%u, c=%d, d=%d, sumo=%lld\n",i,j,qlp_coeff[j],*history,(long long)sumo);
#endif
		}
		*(data++) = *(r++) + (sum >> lp_quantization);
	}

	/* Here's a slower but clearer version:
	for(i = 0; i < data_len; i++) {
		sum = 0;
		for(j = 0; j < order; j++)
			sum += qlp_coeff[j] * data[i-j-1];
		data[i] = residual[i] + (sum >> lp_quantization);
	}
	*/
}
#else /* fully unrolled version for normal use */
{
	int i;
	FLAC__int32 sum;

	FLAC__ASSERT(order > 0);
	FLAC__ASSERT(order <= 32);

	/*
	 * We do unique versions up to 12th order since that's the subset limit.
	 * Also they are roughly ordered to match frequency of occurrence to
	 * minimize branching.
	 */
	if(order <= 12) {
		if(order > 8) {
			if(order > 10) {
				if(order == 12) {
					for(i = 0; i < (int)data_len; i++) {
						sum = 0;
						sum += qlp_coeff[11] * data[i-12];
						sum += qlp_coeff[10] * data[i-11];
						sum += qlp_coeff[9] * data[i-10];
						sum += qlp_coeff[8] * data[i-9];
						sum += qlp_coeff[7] * data[i-8];
						sum += qlp_coeff[6] * data[i-7];
						sum += qlp_coeff[5] * data[i-6];
						sum += qlp_coeff[4] * data[i-5];
						sum += qlp_coeff[3] * data[i-4];
						sum += qlp_coeff[2] * data[i-3];
						sum += qlp_coeff[1] * data[i-2];
						sum += qlp_coeff[0] * data[i-1];
						data[i] = residual[i] + (sum >> lp_quantization);
					}
				}
				else { /* order == 11 */
					for(i = 0; i < (int)data_len; i++) {
						sum = 0;
						sum += qlp_coeff[10] * data[i-11];
						sum += qlp_coeff[9] * data[i-10];
						sum += qlp_coeff[8] * data[i-9];
						sum += qlp_coeff[7] * data[i-8];
						sum += qlp_coeff[6] * data[i-7];
						sum += qlp_coeff[5] * data[i-6];
						sum += qlp_coeff[4] * data[i-5];
						sum += qlp_coeff[3] * data[i-4];
						sum += qlp_coeff[2] * data[i-3];
						sum += qlp_coeff[1] * data[i-2];
						sum += qlp_coeff[0] * data[i-1];
						data[i] = residual[i] + (sum >> lp_quantization);
					}
				}
			}
			else {
				if(order == 10) {
					for(i = 0; i < (int)data_len; i++) {
						sum = 0;
						sum += qlp_coeff[9] * data[i-10];
						sum += qlp_coeff[8] * data[i-9];
						sum += qlp_coeff[7] * data[i-8];
						sum += qlp_coeff[6] * data[i-7];
						sum += qlp_coeff[5] * data[i-6];
						sum += qlp_coeff[4] * data[i-5];
						sum += qlp_coeff[3] * data[i-4];
						sum += qlp_coeff[2] * data[i-3];
						sum += qlp_coeff[1] * data[i-2];
						sum += qlp_coeff[0] * data[i-1];
						data[i] = residual[i] + (sum >> lp_quantization);
					}
				}
				else { /* order == 9 */
					for(i = 0; i < (int)data_len; i++) {
						sum = 0;
						sum += qlp_coeff[8] * data[i-9];
						sum += qlp_coeff[7] * data[i-8];
						sum += qlp_coeff[6] * data[i-7];
						sum += qlp_coeff[5] * data[i-6];
						sum += qlp_coeff[4] * data[i-5];
						sum += qlp_coeff[3] * data[i-4];
						sum += qlp_coeff[2] * data[i-3];
						sum += qlp_coeff[1] * data[i-2];
						sum += qlp_coeff[0] * data[i-1];
						data[i] = residual[i] + (sum >> lp_quantization);
					}
				}
			}
		}
		else if(order > 4) {
			if(order > 6) {
				if(order == 8) {
					for(i = 0; i < (int)data_len; i++) {
						sum = 0;
						sum += qlp_coeff[7] * data[i-8];
						sum += qlp_coeff[6] * data[i-7];
						sum += qlp_coeff[5] * data[i-6];
						sum += qlp_coeff[4] * data[i-5];
						sum += qlp_coeff[3] * data[i-4];
						sum += qlp_coeff[2] * data[i-3];
						sum += qlp_coeff[1] * data[i-2];
						sum += qlp_coeff[0] * data[i-1];
						data[i] = residual[i] + (sum >> lp_quantization);
					}
				}
				else { /* order == 7 */
					for(i = 0; i < (int)data_len; i++) {
						sum = 0;
						sum += qlp_coeff[6] * data[i-7];
						sum += qlp_coeff[5] * data[i-6];
						sum += qlp_coeff[4] * data[i-5];
						sum += qlp_coeff[3] * data[i-4];
						sum += qlp_coeff[2] * data[i-3];
						sum += qlp_coeff[1] * data[i-2];
						sum += qlp_coeff[0] * data[i-1];
						data[i] = residual[i] + (sum >> lp_quantization);
					}
				}
			}
			else {
				if(order == 6) {
					for(i = 0; i < (int)data_len; i++) {
						sum = 0;
						sum += qlp_coeff[5] * data[i-6];
						sum += qlp_coeff[4] * data[i-5];
						sum += qlp_coeff[3] * data[i-4];
						sum += qlp_coeff[2] * data[i-3];
						sum += qlp_coeff[1] * data[i-2];
						sum += qlp_coeff[0] * data[i-1];
						data[i] = residual[i] + (sum >> lp_quantization);
					}
				}
				else { /* order == 5 */
					for(i = 0; i < (int)data_len; i++) {
						sum = 0;
						sum += qlp_coeff[4] * data[i-5];
						sum += qlp_coeff[3] * data[i-4];
						sum += qlp_coeff[2] * data[i-3];
						sum += qlp_coeff[1] * data[i-2];
						sum += qlp_coeff[0] * data[i-1];
						data[i] = residual[i] + (sum >> lp_quantization);
					}
				}
			}
		}
		else {
			if(order > 2) {
				if(order == 4) {
					for(i = 0; i < (int)data_len; i++) {
						sum = 0;
						sum += qlp_coeff[3] * data[i-4];
						sum += qlp_coeff[2] * data[i-3];
						sum += qlp_coeff[1] * data[i-2];
						sum += qlp_coeff[0] * data[i-1];
						data[i] = residual[i] + (sum >> lp_quantization);
					}
				}
				else { /* order == 3 */
					for(i = 0; i < (int)data_len; i++) {
						sum = 0;
						sum += qlp_coeff[2] * data[i-3];
						sum += qlp_coeff[1] * data[i-2];
						sum += qlp_coeff[0] * data[i-1];
						data[i] = residual[i] + (sum >> lp_quantization);
					}
				}
			}
			else {
				if(order == 2) {
					for(i = 0; i < (int)data_len; i++) {
						sum = 0;
						sum += qlp_coeff[1] * data[i-2];
						sum += qlp_coeff[0] * data[i-1];
						data[i] = residual[i] + (sum >> lp_quantization);
					}
				}
				else { /* order == 1 */
					for(i = 0; i < (int)data_len; i++)
						data[i] = residual[i] + ((qlp_coeff[0] * data[i-1]) >> lp_quantization);
				}
			}
		}
	}
	else { /* order > 12 */
		for(i = 0; i < (int)data_len; i++) {
			sum = 0;
			switch(order) {
				case 32: sum += qlp_coeff[31] * data[i-32];
				case 31: sum += qlp_coeff[30] * data[i-31];
				case 30: sum += qlp_coeff[29] * data[i-30];
				case 29: sum += qlp_coeff[28] * data[i-29];
				case 28: sum += qlp_coeff[27] * data[i-28];
				case 27: sum += qlp_coeff[26] * data[i-27];
				case 26: sum += qlp_coeff[25] * data[i-26];
				case 25: sum += qlp_coeff[24] * data[i-25];
				case 24: sum += qlp_coeff[23] * data[i-24];
				case 23: sum += qlp_coeff[22] * data[i-23];
				case 22: sum += qlp_coeff[21] * data[i-22];
				case 21: sum += qlp_coeff[20] * data[i-21];
				case 20: sum += qlp_coeff[19] * data[i-20];
				case 19: sum += qlp_coeff[18] * data[i-19];
				case 18: sum += qlp_coeff[17] * data[i-18];
				case 17: sum += qlp_coeff[16] * data[i-17];
				case 16: sum += qlp_coeff[15] * data[i-16];
				case 15: sum += qlp_coeff[14] * data[i-15];
				case 14: sum += qlp_coeff[13] * data[i-14];
				case 13: sum += qlp_coeff[12] * data[i-13];
				         sum += qlp_coeff[11] * data[i-12];
				         sum += qlp_coeff[10] * data[i-11];
				         sum += qlp_coeff[ 9] * data[i-10];
				         sum += qlp_coeff[ 8] * data[i- 9];
				         sum += qlp_coeff[ 7] * data[i- 8];
				         sum += qlp_coeff[ 6] * data[i- 7];
				         sum += qlp_coeff[ 5] * data[i- 6];
				         sum += qlp_coeff[ 4] * data[i- 5];
				         sum += qlp_coeff[ 3] * data[i- 4];
				         sum += qlp_coeff[ 2] * data[i- 3];
				         sum += qlp_coeff[ 1] * data[i- 2];
				         sum += qlp_coeff[ 0] * data[i- 1];
			}
			data[i] = residual[i] + (sum >> lp_quantization);
		}
	}
}
#endif

void FLAC__lpc_restore_signal_wide(const FLAC__int32 residual[], unsigned data_len, const FLAC__int32 qlp_coeff[], unsigned order, int lp_quantization, FLAC__int32 data[])
#if defined(FLAC__OVERFLOW_DETECT) || !defined(FLAC__LPC_UNROLLED_FILTER_LOOPS)
{
	unsigned i, j;
	FLAC__int64 sum;
	const FLAC__int32 *r = residual, *history;

#ifdef FLAC__OVERFLOW_DETECT_VERBOSE
	fprintf(stderr,"FLAC__lpc_restore_signal_wide: data_len=%d, order=%u, lpq=%d",data_len,order,lp_quantization);
	for(i=0;i<order;i++)
		fprintf(stderr,", q[%u]=%d",i,qlp_coeff[i]);
	fprintf(stderr,"\n");
#endif
	FLAC__ASSERT(order > 0);

	for(i = 0; i < data_len; i++) {
		sum = 0;
		history = data;
		for(j = 0; j < order; j++)
			sum += (FLAC__int64)qlp_coeff[j] * (FLAC__int64)(*(--history));
		if(FLAC__bitmath_silog2_wide(sum >> lp_quantization) > 32) {
#ifdef _MSC_VER
			fprintf(stderr,"FLAC__lpc_restore_signal_wide: OVERFLOW, i=%u, sum=%I64d\n", i, sum >> lp_quantization);
#else
			fprintf(stderr,"FLAC__lpc_restore_signal_wide: OVERFLOW, i=%u, sum=%lld\n", i, (long long)(sum >> lp_quantization));
#endif
			break;
		}
		if(FLAC__bitmath_silog2_wide((FLAC__int64)(*r) + (sum >> lp_quantization)) > 32) {
#ifdef _MSC_VER
			fprintf(stderr,"FLAC__lpc_restore_signal_wide: OVERFLOW, i=%u, residual=%d, sum=%I64d, data=%I64d\n", i, *r, sum >> lp_quantization, (FLAC__int64)(*r) + (sum >> lp_quantization));
#else
			fprintf(stderr,"FLAC__lpc_restore_signal_wide: OVERFLOW, i=%u, residual=%d, sum=%lld, data=%lld\n", i, *r, (long long)(sum >> lp_quantization), (long long)((FLAC__int64)(*r) + (sum >> lp_quantization)));
#endif
			break;
		}
		*(data++) = *(r++) + (FLAC__int32)(sum >> lp_quantization);
	}
}
#else /* fully unrolled version for normal use */
{
	int i;
	FLAC__int64 sum;

	FLAC__ASSERT(order > 0);
	FLAC__ASSERT(order <= 32);

	/*
	 * We do unique versions up to 12th order since that's the subset limit.
	 * Also they are roughly ordered to match frequency of occurrence to
	 * minimize branching.
	 */
	if(order <= 12) {
		if(order > 8) {
			if(order > 10) {
				if(order == 12) {
					for(i = 0; i < (int)data_len; i++) {
						sum = 0;
						sum += qlp_coeff[11] * (FLAC__int64)data[i-12];
						sum += qlp_coeff[10] * (FLAC__int64)data[i-11];
						sum += qlp_coeff[9] * (FLAC__int64)data[i-10];
						sum += qlp_coeff[8] * (FLAC__int64)data[i-9];
						sum += qlp_coeff[7] * (FLAC__int64)data[i-8];
						sum += qlp_coeff[6] * (FLAC__int64)data[i-7];
						sum += qlp_coeff[5] * (FLAC__int64)data[i-6];
						sum += qlp_coeff[4] * (FLAC__int64)data[i-5];
						sum += qlp_coeff[3] * (FLAC__int64)data[i-4];
						sum += qlp_coeff[2] * (FLAC__int64)data[i-3];
						sum += qlp_coeff[1] * (FLAC__int64)data[i-2];
						sum += qlp_coeff[0] * (FLAC__int64)data[i-1];
						data[i] = residual[i] + (FLAC__int32)(sum >> lp_quantization);
					}
				}
				else { /* order == 11 */
					for(i = 0; i < (int)data_len; i++) {
						sum = 0;
						sum += qlp_coeff[10] * (FLAC__int64)data[i-11];
						sum += qlp_coeff[9] * (FLAC__int64)data[i-10];
						sum += qlp_coeff[8] * (FLAC__int64)data[i-9];
						sum += qlp_coeff[7] * (FLAC__int64)data[i-8];
						sum += qlp_coeff[6] * (FLAC__int64)data[i-7];
						sum += qlp_coeff[5] * (FLAC__int64)data[i-6];
						sum += qlp_coeff[4] * (FLAC__int64)data[i-5];
						sum += qlp_coeff[3] * (FLAC__int64)data[i-4];
						sum += qlp_coeff[2] * (FLAC__int64)data[i-3];
						sum += qlp_coeff[1] * (FLAC__int64)data[i-2];
						sum += qlp_coeff[0] * (FLAC__int64)data[i-1];
						data[i] = residual[i] + (FLAC__int32)(sum >> lp_quantization);
					}
				}
			}
			else {
				if(order == 10) {
					for(i = 0; i < (int)data_len; i++) {
						sum = 0;
						sum += qlp_coeff[9] * (FLAC__int64)data[i-10];
						sum += qlp_coeff[8] * (FLAC__int64)data[i-9];
						sum += qlp_coeff[7] * (FLAC__int64)data[i-8];
						sum += qlp_coeff[6] * (FLAC__int64)data[i-7];
						sum += qlp_coeff[5] * (FLAC__int64)data[i-6];
						sum += qlp_coeff[4] * (FLAC__int64)data[i-5];
						sum += qlp_coeff[3] * (FLAC__int64)data[i-4];
						sum += qlp_coeff[2] * (FLAC__int64)data[i-3];
						sum += qlp_coeff[1] * (FLAC__int64)data[i-2];
						sum += qlp_coeff[0] * (FLAC__int64)data[i-1];
						data[i] = residual[i] + (FLAC__int32)(sum >> lp_quantization);
					}
				}
				else { /* order == 9 */
					for(i = 0; i < (int)data_len; i++) {
						sum = 0;
						sum += qlp_coeff[8] * (FLAC__int64)data[i-9];
						sum += qlp_coeff[7] * (FLAC__int64)data[i-8];
						sum += qlp_coeff[6] * (FLAC__int64)data[i-7];
						sum += qlp_coeff[5] * (FLAC__int64)data[i-6];
						sum += qlp_coeff[4] * (FLAC__int64)data[i-5];
						sum += qlp_coeff[3] * (FLAC__int64)data[i-4];
						sum += qlp_coeff[2] * (FLAC__int64)data[i-3];
						sum += qlp_coeff[1] * (FLAC__int64)data[i-2];
						sum += qlp_coeff[0] * (FLAC__int64)data[i-1];
						data[i] = residual[i] + (FLAC__int32)(sum >> lp_quantization);
					}
				}
			}
		}
		else if(order > 4) {
			if(order > 6) {
				if(order == 8) {
					for(i = 0; i < (int)data_len; i++) {
						sum = 0;
						sum += qlp_coeff[7] * (FLAC__int64)data[i-8];
						sum += qlp_coeff[6] * (FLAC__int64)data[i-7];
						sum += qlp_coeff[5] * (FLAC__int64)data[i-6];
						sum += qlp_coeff[4] * (FLAC__int64)data[i-5];
						sum += qlp_coeff[3] * (FLAC__int64)data[i-4];
						sum += qlp_coeff[2] * (FLAC__int64)data[i-3];
						sum += qlp_coeff[1] * (FLAC__int64)data[i-2];
						sum += qlp_coeff[0] * (FLAC__int64)data[i-1];
						data[i] = residual[i] + (FLAC__int32)(sum >> lp_quantization);
					}
				}
				else { /* order == 7 */
					for(i = 0; i < (int)data_len; i++) {
						sum = 0;
						sum += qlp_coeff[6] * (FLAC__int64)data[i-7];
						sum += qlp_coeff[5] * (FLAC__int64)data[i-6];
						sum += qlp_coeff[4] * (FLAC__int64)data[i-5];
						sum += qlp_coeff[3] * (FLAC__int64)data[i-4];
						sum += qlp_coeff[2] * (FLAC__int64)data[i-3];
						sum += qlp_coeff[1] * (FLAC__int64)data[i-2];
						sum += qlp_coeff[0] * (FLAC__int64)data[i-1];
						data[i] = residual[i] + (FLAC__int32)(sum >> lp_quantization);
					}
				}
			}
			else {
				if(order == 6) {
					for(i = 0; i < (int)data_len; i++) {
						sum = 0;
						sum += qlp_coeff[5] * (FLAC__int64)data[i-6];
						sum += qlp_coeff[4] * (FLAC__int64)data[i-5];
						sum += qlp_coeff[3] * (FLAC__int64)data[i-4];
						sum += qlp_coeff[2] * (FLAC__int64)data[i-3];
						sum += qlp_coeff[1] * (FLAC__int64)data[i-2];
						sum += qlp_coeff[0] * (FLAC__int64)data[i-1];
						data[i] = residual[i] + (FLAC__int32)(sum >> lp_quantization);
					}
				}
				else { /* order == 5 */
					for(i = 0; i < (int)data_len; i++) {
						sum = 0;
						sum += qlp_coeff[4] * (FLAC__int64)data[i-5];
						sum += qlp_coeff[3] * (FLAC__int64)data[i-4];
						sum += qlp_coeff[2] * (FLAC__int64)data[i-3];
						sum += qlp_coeff[1] * (FLAC__int64)data[i-2];
						sum += qlp_coeff[0] * (FLAC__int64)data[i-1];
						data[i] = residual[i] + (FLAC__int32)(sum >> lp_quantization);
					}
				}
			}
		}
		else {
			if(order > 2) {
				if(order == 4) {
					for(i = 0; i < (int)data_len; i++) {
						sum = 0;
						sum += qlp_coeff[3] * (FLAC__int64)data[i-4];
						sum += qlp_coeff[2] * (FLAC__int64)data[i-3];
						sum += qlp_coeff[1] * (FLAC__int64)data[i-2];
						sum += qlp_coeff[0] * (FLAC__int64)data[i-1];
						data[i] = residual[i] + (FLAC__int32)(sum >> lp_quantization);
					}
				}
				else { /* order == 3 */
					for(i = 0; i < (int)data_len; i++) {
						sum = 0;
						sum += qlp_coeff[2] * (FLAC__int64)data[i-3];
						sum += qlp_coeff[1] * (FLAC__int64)data[i-2];
						sum += qlp_coeff[0] * (FLAC__int64)data[i-1];
						data[i] = residual[i] + (FLAC__int32)(sum >> lp_quantization);
					}
				}
			}
			else {
				if(order == 2) {
					for(i = 0; i < (int)data_len; i++) {
						sum = 0;
						sum += qlp_coeff[1] * (FLAC__int64)data[i-2];
						sum += qlp_coeff[0] * (FLAC__int64)data[i-1];
						data[i] = residual[i] + (FLAC__int32)(sum >> lp_quantization);
					}
				}
				else { /* order == 1 */
					for(i = 0; i < (int)data_len; i++)
						data[i] = residual[i] + (FLAC__int32)((qlp_coeff[0] * (FLAC__int64)data[i-1]) >> lp_quantization);
				}
			}
		}
	}
	else { /* order > 12 */
		for(i = 0; i < (int)data_len; i++) {
			sum = 0;
			switch(order) {
				case 32: sum += qlp_coeff[31] * (FLAC__int64)data[i-32];
				case 31: sum += qlp_coeff[30] * (FLAC__int64)data[i-31];
				case 30: sum += qlp_coeff[29] * (FLAC__int64)data[i-30];
				case 29: sum += qlp_coeff[28] * (FLAC__int64)data[i-29];
				case 28: sum += qlp_coeff[27] * (FLAC__int64)data[i-28];
				case 27: sum += qlp_coeff[26] * (FLAC__int64)data[i-27];
				case 26: sum += qlp_coeff[25] * (FLAC__int64)data[i-26];
				case 25: sum += qlp_coeff[24] * (FLAC__int64)data[i-25];
				case 24: sum += qlp_coeff[23] * (FLAC__int64)data[i-24];
				case 23: sum += qlp_coeff[22] * (FLAC__int64)data[i-23];
				case 22: sum += qlp_coeff[21] * (FLAC__int64)data[i-22];
				case 21: sum += qlp_coeff[20] * (FLAC__int64)data[i-21];
				case 20: sum += qlp_coeff[19] * (FLAC__int64)data[i-20];
				case 19: sum += qlp_coeff[18] * (FLAC__int64)data[i-19];
				case 18: sum += qlp_coeff[17] * (FLAC__int64)data[i-18];
				case 17: sum += qlp_coeff[16] * (FLAC__int64)data[i-17];
				case 16: sum += qlp_coeff[15] * (FLAC__int64)data[i-16];
				case 15: sum += qlp_coeff[14] * (FLAC__int64)data[i-15];
				case 14: sum += qlp_coeff[13] * (FLAC__int64)data[i-14];
				case 13: sum += qlp_coeff[12] * (FLAC__int64)data[i-13];
				         sum += qlp_coeff[11] * (FLAC__int64)data[i-12];
				         sum += qlp_coeff[10] * (FLAC__int64)data[i-11];
				         sum += qlp_coeff[ 9] * (FLAC__int64)data[i-10];
				         sum += qlp_coeff[ 8] * (FLAC__int64)data[i- 9];
				         sum += qlp_coeff[ 7] * (FLAC__int64)data[i- 8];
				         sum += qlp_coeff[ 6] * (FLAC__int64)data[i- 7];
				         sum += qlp_coeff[ 5] * (FLAC__int64)data[i- 6];
				         sum += qlp_coeff[ 4] * (FLAC__int64)data[i- 5];
				         sum += qlp_coeff[ 3] * (FLAC__int64)data[i- 4];
				         sum += qlp_coeff[ 2] * (FLAC__int64)data[i- 3];
				         sum += qlp_coeff[ 1] * (FLAC__int64)data[i- 2];
				         sum += qlp_coeff[ 0] * (FLAC__int64)data[i- 1];
			}
			data[i] = residual[i] + (FLAC__int32)(sum >> lp_quantization);
		}
	}
}
#endif

#ifndef FLAC__INTEGER_ONLY_LIBRARY

FLAC__double FLAC__lpc_compute_expected_bits_per_residual_sample(FLAC__double lpc_error, unsigned total_samples)
{
	FLAC__double error_scale;

	FLAC__ASSERT(total_samples > 0);

	error_scale = 0.5 * M_LN2 * M_LN2 / (FLAC__double)total_samples;

	return FLAC__lpc_compute_expected_bits_per_residual_sample_with_error_scale(lpc_error, error_scale);
}

FLAC__double FLAC__lpc_compute_expected_bits_per_residual_sample_with_error_scale(FLAC__double lpc_error, FLAC__double error_scale)
{
	if(lpc_error > 0.0) {
		FLAC__double bps = (FLAC__double)0.5 * log(error_scale * lpc_error) / M_LN2;
		if(bps >= 0.0)
			return bps;
		else
			return 0.0;
	}
	else if(lpc_error < 0.0) { /* error should not be negative but can happen due to inadequate floating-point resolution */
		return 1e32;
	}
	else {
		return 0.0;
	}
}

unsigned FLAC__lpc_compute_best_order(const FLAC__double lpc_error[], unsigned max_order, unsigned total_samples, unsigned overhead_bits_per_order)
{
	unsigned order, index, best_index; /* 'index' the index into lpc_error; index==order-1 since lpc_error[0] is for order==1, lpc_error[1] is for order==2, etc */
	FLAC__double bits, best_bits, error_scale;

	FLAC__ASSERT(max_order > 0);
	FLAC__ASSERT(total_samples > 0);

	error_scale = 0.5 * M_LN2 * M_LN2 / (FLAC__double)total_samples;

	best_index = 0;
	best_bits = (unsigned)(-1);

	for(index = 0, order = 1; index < max_order; index++, order++) {
		bits = FLAC__lpc_compute_expected_bits_per_residual_sample_with_error_scale(lpc_error[index], error_scale) * (FLAC__double)(total_samples - order) + (FLAC__double)(order * overhead_bits_per_order);
		if(bits < best_bits) {
			best_index = index;
			best_bits = bits;
		}
	}

	return best_index+1; /* +1 since index of lpc_error[] is order-1 */
}

#endif /* !defined FLAC__INTEGER_ONLY_LIBRARY */

/*** End of inlined file: lpc_flac.c ***/


/*** Start of inlined file: md5.c ***/
#if HAVE_CONFIG_H
#  include <config.h>
#endif

#include <stdlib.h>		/* for malloc() */
#include <string.h>		/* for memcpy() */


/*** Start of inlined file: md5.h ***/
#ifndef FLAC__PRIVATE__MD5_H
#define FLAC__PRIVATE__MD5_H

/*
 * This is the header file for the MD5 message-digest algorithm.
 * The algorithm is due to Ron Rivest.  This code was
 * written by Colin Plumb in 1993, no copyright is claimed.
 * This code is in the public domain; do with it what you wish.
 *
 * Equivalent code is available from RSA Data Security, Inc.
 * This code has been tested against that, and is equivalent,
 * except that you don't need to include two pages of legalese
 * with every copy.
 *
 * To compute the message digest of a chunk of bytes, declare an
 * MD5Context structure, pass it to MD5Init, call MD5Update as
 * needed on buffers full of bytes, and then call MD5Final, which
 * will fill a supplied 16-byte array with the digest.
 *
 * Changed so as no longer to depend on Colin Plumb's `usual.h'
 * header definitions; now uses stuff from dpkg's config.h
 *  - Ian Jackson <ijackson@nyx.cs.du.edu>.
 * Still in the public domain.
 *
 * Josh Coalson: made some changes to integrate with libFLAC.
 * Still in the public domain, with no warranty.
 */

typedef struct {
	FLAC__uint32 in[16];
	FLAC__uint32 buf[4];
	FLAC__uint32 bytes[2];
	FLAC__byte *internal_buf;
	size_t capacity;
} FLAC__MD5Context;

void FLAC__MD5Init(FLAC__MD5Context *context);
void FLAC__MD5Final(FLAC__byte digest[16], FLAC__MD5Context *context);

FLAC__bool FLAC__MD5Accumulate(FLAC__MD5Context *ctx, const FLAC__int32 * const signal[], unsigned channels, unsigned samples, unsigned bytes_per_sample);

#endif

/*** End of inlined file: md5.h ***/

#ifndef FLaC__INLINE
#define FLaC__INLINE
#endif

/*
 * This code implements the MD5 message-digest algorithm.
 * The algorithm is due to Ron Rivest.  This code was
 * written by Colin Plumb in 1993, no copyright is claimed.
 * This code is in the public domain; do with it what you wish.
 *
 * Equivalent code is available from RSA Data Security, Inc.
 * This code has been tested against that, and is equivalent,
 * except that you don't need to include two pages of legalese
 * with every copy.
 *
 * To compute the message digest of a chunk of bytes, declare an
 * MD5Context structure, pass it to MD5Init, call MD5Update as
 * needed on buffers full of bytes, and then call MD5Final, which
 * will fill a supplied 16-byte array with the digest.
 *
 * Changed so as no longer to depend on Colin Plumb's `usual.h' header
 * definitions; now uses stuff from dpkg's config.h.
 *  - Ian Jackson <ijackson@nyx.cs.du.edu>.
 * Still in the public domain.
 *
 * Josh Coalson: made some changes to integrate with libFLAC.
 * Still in the public domain.
 */

/* The four core functions - F1 is optimized somewhat */

/* #define F1(x, y, z) (x & y | ~x & z) */
#define F1(x, y, z) (z ^ (x & (y ^ z)))
#define F2(x, y, z) F1(z, x, y)
#define F3(x, y, z) (x ^ y ^ z)
#define F4(x, y, z) (y ^ (x | ~z))

/* This is the central step in the MD5 algorithm. */
#define MD5STEP(f,w,x,y,z,in,s) \
	 (w += f(x,y,z) + in, w = (w<<s | w>>(32-s)) + x)

/*
 * The core of the MD5 algorithm, this alters an existing MD5 hash to
 * reflect the addition of 16 longwords of new data.  MD5Update blocks
 * the data and converts bytes into longwords for this routine.
 */
static void FLAC__MD5Transform(FLAC__uint32 buf[4], FLAC__uint32 const in[16])
{
	register FLAC__uint32 a, b, c, d;

	a = buf[0];
	b = buf[1];
	c = buf[2];
	d = buf[3];

	MD5STEP(F1, a, b, c, d, in[0] + 0xd76aa478, 7);
	MD5STEP(F1, d, a, b, c, in[1] + 0xe8c7b756, 12);
	MD5STEP(F1, c, d, a, b, in[2] + 0x242070db, 17);
	MD5STEP(F1, b, c, d, a, in[3] + 0xc1bdceee, 22);
	MD5STEP(F1, a, b, c, d, in[4] + 0xf57c0faf, 7);
	MD5STEP(F1, d, a, b, c, in[5] + 0x4787c62a, 12);
	MD5STEP(F1, c, d, a, b, in[6] + 0xa8304613, 17);
	MD5STEP(F1, b, c, d, a, in[7] + 0xfd469501, 22);
	MD5STEP(F1, a, b, c, d, in[8] + 0x698098d8, 7);
	MD5STEP(F1, d, a, b, c, in[9] + 0x8b44f7af, 12);
	MD5STEP(F1, c, d, a, b, in[10] + 0xffff5bb1, 17);
	MD5STEP(F1, b, c, d, a, in[11] + 0x895cd7be, 22);
	MD5STEP(F1, a, b, c, d, in[12] + 0x6b901122, 7);
	MD5STEP(F1, d, a, b, c, in[13] + 0xfd987193, 12);
	MD5STEP(F1, c, d, a, b, in[14] + 0xa679438e, 17);
	MD5STEP(F1, b, c, d, a, in[15] + 0x49b40821, 22);

	MD5STEP(F2, a, b, c, d, in[1] + 0xf61e2562, 5);
	MD5STEP(F2, d, a, b, c, in[6] + 0xc040b340, 9);
	MD5STEP(F2, c, d, a, b, in[11] + 0x265e5a51, 14);
	MD5STEP(F2, b, c, d, a, in[0] + 0xe9b6c7aa, 20);
	MD5STEP(F2, a, b, c, d, in[5] + 0xd62f105d, 5);
	MD5STEP(F2, d, a, b, c, in[10] + 0x02441453, 9);
	MD5STEP(F2, c, d, a, b, in[15] + 0xd8a1e681, 14);
	MD5STEP(F2, b, c, d, a, in[4] + 0xe7d3fbc8, 20);
	MD5STEP(F2, a, b, c, d, in[9] + 0x21e1cde6, 5);
	MD5STEP(F2, d, a, b, c, in[14] + 0xc33707d6, 9);
	MD5STEP(F2, c, d, a, b, in[3] + 0xf4d50d87, 14);
	MD5STEP(F2, b, c, d, a, in[8] + 0x455a14ed, 20);
	MD5STEP(F2, a, b, c, d, in[13] + 0xa9e3e905, 5);
	MD5STEP(F2, d, a, b, c, in[2] + 0xfcefa3f8, 9);
	MD5STEP(F2, c, d, a, b, in[7] + 0x676f02d9, 14);
	MD5STEP(F2, b, c, d, a, in[12] + 0x8d2a4c8a, 20);

	MD5STEP(F3, a, b, c, d, in[5] + 0xfffa3942, 4);
	MD5STEP(F3, d, a, b, c, in[8] + 0x8771f681, 11);
	MD5STEP(F3, c, d, a, b, in[11] + 0x6d9d6122, 16);
	MD5STEP(F3, b, c, d, a, in[14] + 0xfde5380c, 23);
	MD5STEP(F3, a, b, c, d, in[1] + 0xa4beea44, 4);
	MD5STEP(F3, d, a, b, c, in[4] + 0x4bdecfa9, 11);
	MD5STEP(F3, c, d, a, b, in[7] + 0xf6bb4b60, 16);
	MD5STEP(F3, b, c, d, a, in[10] + 0xbebfbc70, 23);
	MD5STEP(F3, a, b, c, d, in[13] + 0x289b7ec6, 4);
	MD5STEP(F3, d, a, b, c, in[0] + 0xeaa127fa, 11);
	MD5STEP(F3, c, d, a, b, in[3] + 0xd4ef3085, 16);
	MD5STEP(F3, b, c, d, a, in[6] + 0x04881d05, 23);
	MD5STEP(F3, a, b, c, d, in[9] + 0xd9d4d039, 4);
	MD5STEP(F3, d, a, b, c, in[12] + 0xe6db99e5, 11);
	MD5STEP(F3, c, d, a, b, in[15] + 0x1fa27cf8, 16);
	MD5STEP(F3, b, c, d, a, in[2] + 0xc4ac5665, 23);

	MD5STEP(F4, a, b, c, d, in[0] + 0xf4292244, 6);
	MD5STEP(F4, d, a, b, c, in[7] + 0x432aff97, 10);
	MD5STEP(F4, c, d, a, b, in[14] + 0xab9423a7, 15);
	MD5STEP(F4, b, c, d, a, in[5] + 0xfc93a039, 21);
	MD5STEP(F4, a, b, c, d, in[12] + 0x655b59c3, 6);
	MD5STEP(F4, d, a, b, c, in[3] + 0x8f0ccc92, 10);
	MD5STEP(F4, c, d, a, b, in[10] + 0xffeff47d, 15);
	MD5STEP(F4, b, c, d, a, in[1] + 0x85845dd1, 21);
	MD5STEP(F4, a, b, c, d, in[8] + 0x6fa87e4f, 6);
	MD5STEP(F4, d, a, b, c, in[15] + 0xfe2ce6e0, 10);
	MD5STEP(F4, c, d, a, b, in[6] + 0xa3014314, 15);
	MD5STEP(F4, b, c, d, a, in[13] + 0x4e0811a1, 21);
	MD5STEP(F4, a, b, c, d, in[4] + 0xf7537e82, 6);
	MD5STEP(F4, d, a, b, c, in[11] + 0xbd3af235, 10);
	MD5STEP(F4, c, d, a, b, in[2] + 0x2ad7d2bb, 15);
	MD5STEP(F4, b, c, d, a, in[9] + 0xeb86d391, 21);

	buf[0] += a;
	buf[1] += b;
	buf[2] += c;
	buf[3] += d;
}

#if WORDS_BIGENDIAN
//@@@@@@ OPT: use bswap/intrinsics
static void byteSwap(FLAC__uint32 *buf, unsigned words)
{
	register FLAC__uint32 x;
	do {
		x = *buf;
		x = ((x << 8) & 0xff00ff00) | ((x >> 8) & 0x00ff00ff);
		*buf++ = (x >> 16) | (x << 16);
	} while (--words);
}
static void byteSwapX16(FLAC__uint32 *buf)
{
	register FLAC__uint32 x;

	x = *buf; x = ((x << 8) & 0xff00ff00) | ((x >> 8) & 0x00ff00ff); *buf++ = (x >> 16) | (x << 16);
	x = *buf; x = ((x << 8) & 0xff00ff00) | ((x >> 8) & 0x00ff00ff); *buf++ = (x >> 16) | (x << 16);
	x = *buf; x = ((x << 8) & 0xff00ff00) | ((x >> 8) & 0x00ff00ff); *buf++ = (x >> 16) | (x << 16);
	x = *buf; x = ((x << 8) & 0xff00ff00) | ((x >> 8) & 0x00ff00ff); *buf++ = (x >> 16) | (x << 16);
	x = *buf; x = ((x << 8) & 0xff00ff00) | ((x >> 8) & 0x00ff00ff); *buf++ = (x >> 16) | (x << 16);
	x = *buf; x = ((x << 8) & 0xff00ff00) | ((x >> 8) & 0x00ff00ff); *buf++ = (x >> 16) | (x << 16);
	x = *buf; x = ((x << 8) & 0xff00ff00) | ((x >> 8) & 0x00ff00ff); *buf++ = (x >> 16) | (x << 16);
	x = *buf; x = ((x << 8) & 0xff00ff00) | ((x >> 8) & 0x00ff00ff); *buf++ = (x >> 16) | (x << 16);
	x = *buf; x = ((x << 8) & 0xff00ff00) | ((x >> 8) & 0x00ff00ff); *buf++ = (x >> 16) | (x << 16);
	x = *buf; x = ((x << 8) & 0xff00ff00) | ((x >> 8) & 0x00ff00ff); *buf++ = (x >> 16) | (x << 16);
	x = *buf; x = ((x << 8) & 0xff00ff00) | ((x >> 8) & 0x00ff00ff); *buf++ = (x >> 16) | (x << 16);
	x = *buf; x = ((x << 8) & 0xff00ff00) | ((x >> 8) & 0x00ff00ff); *buf++ = (x >> 16) | (x << 16);
	x = *buf; x = ((x << 8) & 0xff00ff00) | ((x >> 8) & 0x00ff00ff); *buf++ = (x >> 16) | (x << 16);
	x = *buf; x = ((x << 8) & 0xff00ff00) | ((x >> 8) & 0x00ff00ff); *buf++ = (x >> 16) | (x << 16);
	x = *buf; x = ((x << 8) & 0xff00ff00) | ((x >> 8) & 0x00ff00ff); *buf++ = (x >> 16) | (x << 16);
	x = *buf; x = ((x << 8) & 0xff00ff00) | ((x >> 8) & 0x00ff00ff); *buf   = (x >> 16) | (x << 16);
}
#else
#define byteSwap(buf, words)
#define byteSwapX16(buf)
#endif

/*
 * Update context to reflect the concatenation of another buffer full
 * of bytes.
 */
static void FLAC__MD5Update(FLAC__MD5Context *ctx, FLAC__byte const *buf, unsigned len)
{
	FLAC__uint32 t;

	/* Update byte count */

	t = ctx->bytes[0];
	if ((ctx->bytes[0] = t + len) < t)
		ctx->bytes[1]++;	/* Carry from low to high */

	t = 64 - (t & 0x3f);	/* Space available in ctx->in (at least 1) */
	if (t > len) {
		memcpy((FLAC__byte *)ctx->in + 64 - t, buf, len);
		return;
	}
	/* First chunk is an odd size */
	memcpy((FLAC__byte *)ctx->in + 64 - t, buf, t);
	byteSwapX16(ctx->in);
	FLAC__MD5Transform(ctx->buf, ctx->in);
	buf += t;
	len -= t;

	/* Process data in 64-byte chunks */
	while (len >= 64) {
		memcpy(ctx->in, buf, 64);
		byteSwapX16(ctx->in);
		FLAC__MD5Transform(ctx->buf, ctx->in);
		buf += 64;
		len -= 64;
	}

	/* Handle any remaining bytes of data. */
	memcpy(ctx->in, buf, len);
}

/*
 * Start MD5 accumulation.  Set bit count to 0 and buffer to mysterious
 * initialization constants.
 */
void FLAC__MD5Init(FLAC__MD5Context *ctx)
{
	ctx->buf[0] = 0x67452301;
	ctx->buf[1] = 0xefcdab89;
	ctx->buf[2] = 0x98badcfe;
	ctx->buf[3] = 0x10325476;

	ctx->bytes[0] = 0;
	ctx->bytes[1] = 0;

	ctx->internal_buf = 0;
	ctx->capacity = 0;
}

/*
 * Final wrapup - pad to 64-byte boundary with the bit pattern
 * 1 0* (64-bit count of bits processed, MSB-first)
 */
void FLAC__MD5Final(FLAC__byte digest[16], FLAC__MD5Context *ctx)
{
	int count = ctx->bytes[0] & 0x3f;	/* Number of bytes in ctx->in */
	FLAC__byte *p = (FLAC__byte *)ctx->in + count;

	/* Set the first char of padding to 0x80.  There is always room. */
	*p++ = 0x80;

	/* Bytes of padding needed to make 56 bytes (-8..55) */
	count = 56 - 1 - count;

	if (count < 0) {	/* Padding forces an extra block */
		memset(p, 0, count + 8);
		byteSwapX16(ctx->in);
		FLAC__MD5Transform(ctx->buf, ctx->in);
		p = (FLAC__byte *)ctx->in;
		count = 56;
	}
	memset(p, 0, count);
	byteSwap(ctx->in, 14);

	/* Append length in bits and transform */
	ctx->in[14] = ctx->bytes[0] << 3;
	ctx->in[15] = ctx->bytes[1] << 3 | ctx->bytes[0] >> 29;
	FLAC__MD5Transform(ctx->buf, ctx->in);

	byteSwap(ctx->buf, 4);
	memcpy(digest, ctx->buf, 16);
	//memset(ctx, 0, sizeof(ctx));	/* In case it's sensitive */
	if(0 != ctx->internal_buf) {
		free(ctx->internal_buf);
		ctx->internal_buf = 0;
		ctx->capacity = 0;
	}
}

/*
 * Convert the incoming audio signal to a byte stream
 */
static void format_input_(FLAC__byte *buf, const FLAC__int32 * const signal[], unsigned channels, unsigned samples, unsigned bytes_per_sample)
{
	unsigned channel, sample;
	register FLAC__int32 a_word;
	register FLAC__byte *buf_ = buf;

#if WORDS_BIGENDIAN
#else
	if(channels == 2 && bytes_per_sample == 2) {
		FLAC__int16 *buf1_ = ((FLAC__int16*)buf_) + 1;
		memcpy(buf_, signal[0], sizeof(FLAC__int32) * samples);
		for(sample = 0; sample < samples; sample++, buf1_+=2)
			*buf1_ = (FLAC__int16)signal[1][sample];
	}
	else if(channels == 1 && bytes_per_sample == 2) {
		FLAC__int16 *buf1_ = (FLAC__int16*)buf_;
		for(sample = 0; sample < samples; sample++)
			*buf1_++ = (FLAC__int16)signal[0][sample];
	}
	else
#endif
	if(bytes_per_sample == 2) {
		if(channels == 2) {
			for(sample = 0; sample < samples; sample++) {
				a_word = signal[0][sample];
				*buf_++ = (FLAC__byte)a_word; a_word >>= 8;
				*buf_++ = (FLAC__byte)a_word;
				a_word = signal[1][sample];
				*buf_++ = (FLAC__byte)a_word; a_word >>= 8;
				*buf_++ = (FLAC__byte)a_word;
			}
		}
		else if(channels == 1) {
			for(sample = 0; sample < samples; sample++) {
				a_word = signal[0][sample];
				*buf_++ = (FLAC__byte)a_word; a_word >>= 8;
				*buf_++ = (FLAC__byte)a_word;
			}
		}
		else {
			for(sample = 0; sample < samples; sample++) {
				for(channel = 0; channel < channels; channel++) {
					a_word = signal[channel][sample];
					*buf_++ = (FLAC__byte)a_word; a_word >>= 8;
					*buf_++ = (FLAC__byte)a_word;
				}
			}
		}
	}
	else if(bytes_per_sample == 3) {
		if(channels == 2) {
			for(sample = 0; sample < samples; sample++) {
				a_word = signal[0][sample];
				*buf_++ = (FLAC__byte)a_word; a_word >>= 8;
				*buf_++ = (FLAC__byte)a_word; a_word >>= 8;
				*buf_++ = (FLAC__byte)a_word;
				a_word = signal[1][sample];
				*buf_++ = (FLAC__byte)a_word; a_word >>= 8;
				*buf_++ = (FLAC__byte)a_word; a_word >>= 8;
				*buf_++ = (FLAC__byte)a_word;
			}
		}
		else if(channels == 1) {
			for(sample = 0; sample < samples; sample++) {
				a_word = signal[0][sample];
				*buf_++ = (FLAC__byte)a_word; a_word >>= 8;
				*buf_++ = (FLAC__byte)a_word; a_word >>= 8;
				*buf_++ = (FLAC__byte)a_word;
			}
		}
		else {
			for(sample = 0; sample < samples; sample++) {
				for(channel = 0; channel < channels; channel++) {
					a_word = signal[channel][sample];
					*buf_++ = (FLAC__byte)a_word; a_word >>= 8;
					*buf_++ = (FLAC__byte)a_word; a_word >>= 8;
					*buf_++ = (FLAC__byte)a_word;
				}
			}
		}
	}
	else if(bytes_per_sample == 1) {
		if(channels == 2) {
			for(sample = 0; sample < samples; sample++) {
				a_word = signal[0][sample];
				*buf_++ = (FLAC__byte)a_word;
				a_word = signal[1][sample];
				*buf_++ = (FLAC__byte)a_word;
			}
		}
		else if(channels == 1) {
			for(sample = 0; sample < samples; sample++) {
				a_word = signal[0][sample];
				*buf_++ = (FLAC__byte)a_word;
			}
		}
		else {
			for(sample = 0; sample < samples; sample++) {
				for(channel = 0; channel < channels; channel++) {
					a_word = signal[channel][sample];
					*buf_++ = (FLAC__byte)a_word;
				}
			}
		}
	}
	else { /* bytes_per_sample == 4, maybe optimize more later */
		for(sample = 0; sample < samples; sample++) {
			for(channel = 0; channel < channels; channel++) {
				a_word = signal[channel][sample];
				*buf_++ = (FLAC__byte)a_word; a_word >>= 8;
				*buf_++ = (FLAC__byte)a_word; a_word >>= 8;
				*buf_++ = (FLAC__byte)a_word; a_word >>= 8;
				*buf_++ = (FLAC__byte)a_word;
			}
		}
	}
}

/*
 * Convert the incoming audio signal to a byte stream and FLAC__MD5Update it.
 */
FLAC__bool FLAC__MD5Accumulate(FLAC__MD5Context *ctx, const FLAC__int32 * const signal[], unsigned channels, unsigned samples, unsigned bytes_per_sample)
{
	const size_t bytes_needed = (size_t)channels * (size_t)samples * (size_t)bytes_per_sample;

	/* overflow check */
	if((size_t)channels > SIZE_MAX / (size_t)bytes_per_sample)
		return false;
	if((size_t)channels * (size_t)bytes_per_sample > SIZE_MAX / (size_t)samples)
		return false;

	if(ctx->capacity < bytes_needed) {
		FLAC__byte *tmp = (FLAC__byte*)realloc(ctx->internal_buf, bytes_needed);
		if(0 == tmp) {
			free(ctx->internal_buf);
			if(0 == (ctx->internal_buf = (FLAC__byte*)safe_malloc_(bytes_needed)))
				return false;
		}
		ctx->internal_buf = tmp;
		ctx->capacity = bytes_needed;
	}

	format_input_(ctx->internal_buf, signal, channels, samples, bytes_per_sample);

	FLAC__MD5Update(ctx, ctx->internal_buf, bytes_needed);

	return true;
}

/*** End of inlined file: md5.c ***/


/*** Start of inlined file: memory.c ***/
#if HAVE_CONFIG_H
#  include <config.h>
#endif


/*** Start of inlined file: memory.h ***/
#ifndef FLAC__PRIVATE__MEMORY_H
#define FLAC__PRIVATE__MEMORY_H

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include <stdlib.h> /* for size_t */

/* Returns the unaligned address returned by malloc.
 * Use free() on this address to deallocate.
 */
void *FLAC__memory_alloc_aligned(size_t bytes, void **aligned_address);
FLAC__bool FLAC__memory_alloc_aligned_int32_array(unsigned elements, FLAC__int32 **unaligned_pointer, FLAC__int32 **aligned_pointer);
FLAC__bool FLAC__memory_alloc_aligned_uint32_array(unsigned elements, FLAC__uint32 **unaligned_pointer, FLAC__uint32 **aligned_pointer);
FLAC__bool FLAC__memory_alloc_aligned_uint64_array(unsigned elements, FLAC__uint64 **unaligned_pointer, FLAC__uint64 **aligned_pointer);
FLAC__bool FLAC__memory_alloc_aligned_unsigned_array(unsigned elements, unsigned **unaligned_pointer, unsigned **aligned_pointer);
#ifndef FLAC__INTEGER_ONLY_LIBRARY
FLAC__bool FLAC__memory_alloc_aligned_real_array(unsigned elements, FLAC__real **unaligned_pointer, FLAC__real **aligned_pointer);
#endif

#endif

/*** End of inlined file: memory.h ***/

void *FLAC__memory_alloc_aligned(size_t bytes, void **aligned_address)
{
	void *x;

	FLAC__ASSERT(0 != aligned_address);

#ifdef FLAC__ALIGN_MALLOC_DATA
	/* align on 32-byte (256-bit) boundary */
	x = safe_malloc_add_2op_(bytes, /*+*/31);
#ifdef SIZEOF_VOIDP
#if SIZEOF_VOIDP == 4
		/* could do  *aligned_address = x + ((unsigned) (32 - (((unsigned)x) & 31))) & 31; */
		*aligned_address = (void*)(((unsigned)x + 31) & -32);
#elif SIZEOF_VOIDP == 8
		*aligned_address = (void*)(((FLAC__uint64)x + 31) & (FLAC__uint64)(-((FLAC__int64)32)));
#else
# error  Unsupported sizeof(void*)
#endif
#else
	/* there's got to be a better way to do this right for all archs */
	if(sizeof(void*) == sizeof(unsigned))
		*aligned_address = (void*)(((unsigned)x + 31) & -32);
	else if(sizeof(void*) == sizeof(FLAC__uint64))
		*aligned_address = (void*)(((FLAC__uint64)x + 31) & (FLAC__uint64)(-((FLAC__int64)32)));
	else
		return 0;
#endif
#else
	x = safe_malloc_(bytes);
	*aligned_address = x;
#endif
	return x;
}

FLAC__bool FLAC__memory_alloc_aligned_int32_array(unsigned elements, FLAC__int32 **unaligned_pointer, FLAC__int32 **aligned_pointer)
{
	FLAC__int32 *pu; /* unaligned pointer */
	union { /* union needed to comply with C99 pointer aliasing rules */
		FLAC__int32 *pa; /* aligned pointer */
		void        *pv; /* aligned pointer alias */
	} u;

	FLAC__ASSERT(elements > 0);
	FLAC__ASSERT(0 != unaligned_pointer);
	FLAC__ASSERT(0 != aligned_pointer);
	FLAC__ASSERT(unaligned_pointer != aligned_pointer);

	pu = (FLAC__int32*)FLAC__memory_alloc_aligned(sizeof(*pu) * (size_t)elements, &u.pv);
	if(0 == pu) {
		return false;
	}
	else {
		if(*unaligned_pointer != 0)
			free(*unaligned_pointer);
		*unaligned_pointer = pu;
		*aligned_pointer = u.pa;
		return true;
	}
}

FLAC__bool FLAC__memory_alloc_aligned_uint32_array(unsigned elements, FLAC__uint32 **unaligned_pointer, FLAC__uint32 **aligned_pointer)
{
	FLAC__uint32 *pu; /* unaligned pointer */
	union { /* union needed to comply with C99 pointer aliasing rules */
		FLAC__uint32 *pa; /* aligned pointer */
		void         *pv; /* aligned pointer alias */
	} u;

	FLAC__ASSERT(elements > 0);
	FLAC__ASSERT(0 != unaligned_pointer);
	FLAC__ASSERT(0 != aligned_pointer);
	FLAC__ASSERT(unaligned_pointer != aligned_pointer);

	pu = (FLAC__uint32*)FLAC__memory_alloc_aligned(sizeof(*pu) * elements, &u.pv);
	if(0 == pu) {
		return false;
	}
	else {
		if(*unaligned_pointer != 0)
			free(*unaligned_pointer);
		*unaligned_pointer = pu;
		*aligned_pointer = u.pa;
		return true;
	}
}

FLAC__bool FLAC__memory_alloc_aligned_uint64_array(unsigned elements, FLAC__uint64 **unaligned_pointer, FLAC__uint64 **aligned_pointer)
{
	FLAC__uint64 *pu; /* unaligned pointer */
	union { /* union needed to comply with C99 pointer aliasing rules */
		FLAC__uint64 *pa; /* aligned pointer */
		void         *pv; /* aligned pointer alias */
	} u;

	FLAC__ASSERT(elements > 0);
	FLAC__ASSERT(0 != unaligned_pointer);
	FLAC__ASSERT(0 != aligned_pointer);
	FLAC__ASSERT(unaligned_pointer != aligned_pointer);

	pu = (FLAC__uint64*)FLAC__memory_alloc_aligned(sizeof(*pu) * elements, &u.pv);
	if(0 == pu) {
		return false;
	}
	else {
		if(*unaligned_pointer != 0)
			free(*unaligned_pointer);
		*unaligned_pointer = pu;
		*aligned_pointer = u.pa;
		return true;
	}
}

FLAC__bool FLAC__memory_alloc_aligned_unsigned_array(unsigned elements, unsigned **unaligned_pointer, unsigned **aligned_pointer)
{
	unsigned *pu; /* unaligned pointer */
	union { /* union needed to comply with C99 pointer aliasing rules */
		unsigned *pa; /* aligned pointer */
		void     *pv; /* aligned pointer alias */
	} u;

	FLAC__ASSERT(elements > 0);
	FLAC__ASSERT(0 != unaligned_pointer);
	FLAC__ASSERT(0 != aligned_pointer);
	FLAC__ASSERT(unaligned_pointer != aligned_pointer);

	pu = (unsigned*)FLAC__memory_alloc_aligned(sizeof(*pu) * elements, &u.pv);
	if(0 == pu) {
		return false;
	}
	else {
		if(*unaligned_pointer != 0)
			free(*unaligned_pointer);
		*unaligned_pointer = pu;
		*aligned_pointer = u.pa;
		return true;
	}
}

#ifndef FLAC__INTEGER_ONLY_LIBRARY

FLAC__bool FLAC__memory_alloc_aligned_real_array(unsigned elements, FLAC__real **unaligned_pointer, FLAC__real **aligned_pointer)
{
	FLAC__real *pu; /* unaligned pointer */
	union { /* union needed to comply with C99 pointer aliasing rules */
		FLAC__real *pa; /* aligned pointer */
		void       *pv; /* aligned pointer alias */
	} u;

	FLAC__ASSERT(elements > 0);
	FLAC__ASSERT(0 != unaligned_pointer);
	FLAC__ASSERT(0 != aligned_pointer);
	FLAC__ASSERT(unaligned_pointer != aligned_pointer);

	pu = (FLAC__real*)FLAC__memory_alloc_aligned(sizeof(*pu) * elements, &u.pv);
	if(0 == pu) {
		return false;
	}
	else {
		if(*unaligned_pointer != 0)
			free(*unaligned_pointer);
		*unaligned_pointer = pu;
		*aligned_pointer = u.pa;
		return true;
	}
}

#endif

/*** End of inlined file: memory.c ***/


/*** Start of inlined file: stream_decoder.c ***/
#if HAVE_CONFIG_H
#  include <config.h>
#endif

#if defined _MSC_VER || defined __MINGW32__
#include <io.h> /* for _setmode() */
#include <fcntl.h> /* for _O_BINARY */
#endif
#if defined __CYGWIN__ || defined __EMX__
#include <io.h> /* for setmode(), O_BINARY */
#include <fcntl.h> /* for _O_BINARY */
#endif
#include <stdio.h>
#include <stdlib.h> /* for malloc() */
#include <string.h> /* for memset/memcpy() */
#include <sys/stat.h> /* for stat() */
#include <sys/types.h> /* for off_t */
#if defined _MSC_VER || defined __BORLANDC__ || defined __MINGW32__
#if _MSC_VER <= 1700 || defined __BORLANDC__ /* @@@ [2G limit] */
#define fseeko fseek
#define ftello ftell
#endif
#endif


/*** Start of inlined file: stream_decoder.h ***/
#ifndef FLAC__PROTECTED__STREAM_DECODER_H
#define FLAC__PROTECTED__STREAM_DECODER_H

#if FLAC__HAS_OGG
#include "include/private/ogg_decoder_aspect.h"
#endif

typedef struct FLAC__StreamDecoderProtected {
	FLAC__StreamDecoderState state;
	unsigned channels;
	FLAC__ChannelAssignment channel_assignment;
	unsigned bits_per_sample;
	unsigned sample_rate; /* in Hz */
	unsigned blocksize; /* in samples (per channel) */
	FLAC__bool md5_checking; /* if true, generate MD5 signature of decoded data and compare against signature in the STREAMINFO metadata block */
#if FLAC__HAS_OGG
	FLAC__OggDecoderAspect ogg_decoder_aspect;
#endif
} FLAC__StreamDecoderProtected;

/*
 * return the number of input bytes consumed
 */
unsigned FLAC__stream_decoder_get_input_bytes_unconsumed(const FLAC__StreamDecoder *decoder);

#endif

/*** End of inlined file: stream_decoder.h ***/

#ifdef max
#undef max
#endif
#define max(a,b) ((a)>(b)?(a):(b))

/* adjust for compilers that can't understand using LLU suffix for uint64_t literals */
#ifdef _MSC_VER
#define FLAC__U64L(x) x
#else
#define FLAC__U64L(x) x##LLU
#endif

/* technically this should be in an "export.c" but this is convenient enough */
FLAC_API int FLAC_API_SUPPORTS_OGG_FLAC =
#if FLAC__HAS_OGG
	1
#else
	0
#endif
;

/***********************************************************************
 *
 * Private static data
 *
 ***********************************************************************/

static FLAC__byte ID3V2_TAG_[3] = { 'I', 'D', '3' };

/***********************************************************************
 *
 * Private class method prototypes
 *
 ***********************************************************************/

static void set_defaults_dec(FLAC__StreamDecoder *decoder);
static FILE *get_binary_stdin_(void);
static FLAC__bool allocate_output_(FLAC__StreamDecoder *decoder, unsigned size, unsigned channels);
static FLAC__bool has_id_filtered_(FLAC__StreamDecoder *decoder, FLAC__byte *id);
static FLAC__bool find_metadata_(FLAC__StreamDecoder *decoder);
static FLAC__bool read_metadata_(FLAC__StreamDecoder *decoder);
static FLAC__bool read_metadata_streaminfo_(FLAC__StreamDecoder *decoder, FLAC__bool is_last, unsigned length);
static FLAC__bool read_metadata_seektable_(FLAC__StreamDecoder *decoder, FLAC__bool is_last, unsigned length);
static FLAC__bool read_metadata_vorbiscomment_(FLAC__StreamDecoder *decoder, FLAC__StreamMetadata_VorbisComment *obj);
static FLAC__bool read_metadata_cuesheet_(FLAC__StreamDecoder *decoder, FLAC__StreamMetadata_CueSheet *obj);
static FLAC__bool read_metadata_picture_(FLAC__StreamDecoder *decoder, FLAC__StreamMetadata_Picture *obj);
static FLAC__bool skip_id3v2_tag_(FLAC__StreamDecoder *decoder);
static FLAC__bool frame_sync_(FLAC__StreamDecoder *decoder);
static FLAC__bool read_frame_(FLAC__StreamDecoder *decoder, FLAC__bool *got_a_frame, FLAC__bool do_full_decode);
static FLAC__bool read_frame_header_(FLAC__StreamDecoder *decoder);
static FLAC__bool read_subframe_(FLAC__StreamDecoder *decoder, unsigned channel, unsigned bps, FLAC__bool do_full_decode);
static FLAC__bool read_subframe_constant_(FLAC__StreamDecoder *decoder, unsigned channel, unsigned bps, FLAC__bool do_full_decode);
static FLAC__bool read_subframe_fixed_(FLAC__StreamDecoder *decoder, unsigned channel, unsigned bps, const unsigned order, FLAC__bool do_full_decode);
static FLAC__bool read_subframe_lpc_(FLAC__StreamDecoder *decoder, unsigned channel, unsigned bps, const unsigned order, FLAC__bool do_full_decode);
static FLAC__bool read_subframe_verbatim_(FLAC__StreamDecoder *decoder, unsigned channel, unsigned bps, FLAC__bool do_full_decode);
static FLAC__bool read_residual_partitioned_rice_(FLAC__StreamDecoder *decoder, unsigned predictor_order, unsigned partition_order, FLAC__EntropyCodingMethod_PartitionedRiceContents *partitioned_rice_contents, FLAC__int32 *residual, FLAC__bool is_extended);
static FLAC__bool read_zero_padding_(FLAC__StreamDecoder *decoder);
static FLAC__bool read_callback_(FLAC__byte buffer[], size_t *bytes, void *client_data);
#if FLAC__HAS_OGG
static FLAC__StreamDecoderReadStatus read_callback_ogg_aspect_(const FLAC__StreamDecoder *decoder, FLAC__byte buffer[], size_t *bytes);
static FLAC__OggDecoderAspectReadStatus read_callback_proxy_(const void *void_decoder, FLAC__byte buffer[], size_t *bytes, void *client_data);
#endif
static FLAC__StreamDecoderWriteStatus write_audio_frame_to_client_(FLAC__StreamDecoder *decoder, const FLAC__Frame *frame, const FLAC__int32 * const buffer[]);
static void send_error_to_client_(const FLAC__StreamDecoder *decoder, FLAC__StreamDecoderErrorStatus status);
static FLAC__bool seek_to_absolute_sample_(FLAC__StreamDecoder *decoder, FLAC__uint64 stream_length, FLAC__uint64 target_sample);
#if FLAC__HAS_OGG
static FLAC__bool seek_to_absolute_sample_ogg_(FLAC__StreamDecoder *decoder, FLAC__uint64 stream_length, FLAC__uint64 target_sample);
#endif
static FLAC__StreamDecoderReadStatus file_read_callback_dec (const FLAC__StreamDecoder *decoder, FLAC__byte buffer[], size_t *bytes, void *client_data);
static FLAC__StreamDecoderSeekStatus file_seek_callback_dec (const FLAC__StreamDecoder *decoder, FLAC__uint64 absolute_byte_offset, void *client_data);
static FLAC__StreamDecoderTellStatus file_tell_callback_dec (const FLAC__StreamDecoder *decoder, FLAC__uint64 *absolute_byte_offset, void *client_data);
static FLAC__StreamDecoderLengthStatus file_length_callback_(const FLAC__StreamDecoder *decoder, FLAC__uint64 *stream_length, void *client_data);
static FLAC__bool file_eof_callback_(const FLAC__StreamDecoder *decoder, void *client_data);

/***********************************************************************
 *
 * Private class data
 *
 ***********************************************************************/

typedef struct FLAC__StreamDecoderPrivate {
#if FLAC__HAS_OGG
	FLAC__bool is_ogg;
#endif
	FLAC__StreamDecoderReadCallback read_callback;
	FLAC__StreamDecoderSeekCallback seek_callback;
	FLAC__StreamDecoderTellCallback tell_callback;
	FLAC__StreamDecoderLengthCallback length_callback;
	FLAC__StreamDecoderEofCallback eof_callback;
	FLAC__StreamDecoderWriteCallback write_callback;
	FLAC__StreamDecoderMetadataCallback metadata_callback;
	FLAC__StreamDecoderErrorCallback error_callback;
	/* generic 32-bit datapath: */
	void (*local_lpc_restore_signal)(const FLAC__int32 residual[], unsigned data_len, const FLAC__int32 qlp_coeff[], unsigned order, int lp_quantization, FLAC__int32 data[]);
	/* generic 64-bit datapath: */
	void (*local_lpc_restore_signal_64bit)(const FLAC__int32 residual[], unsigned data_len, const FLAC__int32 qlp_coeff[], unsigned order, int lp_quantization, FLAC__int32 data[]);
	/* for use when the signal is <= 16 bits-per-sample, or <= 15 bits-per-sample on a side channel (which requires 1 extra bit): */
	void (*local_lpc_restore_signal_16bit)(const FLAC__int32 residual[], unsigned data_len, const FLAC__int32 qlp_coeff[], unsigned order, int lp_quantization, FLAC__int32 data[]);
	/* for use when the signal is <= 16 bits-per-sample, or <= 15 bits-per-sample on a side channel (which requires 1 extra bit), AND order <= 8: */
	void (*local_lpc_restore_signal_16bit_order8)(const FLAC__int32 residual[], unsigned data_len, const FLAC__int32 qlp_coeff[], unsigned order, int lp_quantization, FLAC__int32 data[]);
	FLAC__bool (*local_bitreader_read_rice_signed_block)(FLAC__BitReader *br, int* vals, unsigned nvals, unsigned parameter);
	void *client_data;
	FILE *file; /* only used if FLAC__stream_decoder_init_file()/FLAC__stream_decoder_init_file() called, else NULL */
	FLAC__BitReader *input;
	FLAC__int32 *output[FLAC__MAX_CHANNELS];
	FLAC__int32 *residual[FLAC__MAX_CHANNELS]; /* WATCHOUT: these are the aligned pointers; the real pointers that should be free()'d are residual_unaligned[] below */
	FLAC__EntropyCodingMethod_PartitionedRiceContents partitioned_rice_contents[FLAC__MAX_CHANNELS];
	unsigned output_capacity, output_channels;
	FLAC__uint32 fixed_block_size, next_fixed_block_size;
	FLAC__uint64 samples_decoded;
	FLAC__bool has_stream_info, has_seek_table;
	FLAC__StreamMetadata stream_info;
	FLAC__StreamMetadata seek_table;
	FLAC__bool metadata_filter[128]; /* MAGIC number 128 == total number of metadata block types == 1 << 7 */
	FLAC__byte *metadata_filter_ids;
	size_t metadata_filter_ids_count, metadata_filter_ids_capacity; /* units for both are IDs, not bytes */
	FLAC__Frame frame;
	FLAC__bool cached; /* true if there is a byte in lookahead */
	FLAC__CPUInfo cpuinfo;
	FLAC__byte header_warmup[2]; /* contains the sync code and reserved bits */
	FLAC__byte lookahead; /* temp storage when we need to look ahead one byte in the stream */
	/* unaligned (original) pointers to allocated data */
	FLAC__int32 *residual_unaligned[FLAC__MAX_CHANNELS];
	FLAC__bool do_md5_checking; /* initially gets protected_->md5_checking but is turned off after a seek or if the metadata has a zero MD5 */
	FLAC__bool internal_reset_hack; /* used only during init() so we can call reset to set up the decoder without rewinding the input */
	FLAC__bool is_seeking;
	FLAC__MD5Context md5context;
	FLAC__byte computed_md5sum[16]; /* this is the sum we computed from the decoded data */
	/* (the rest of these are only used for seeking) */
	FLAC__Frame last_frame; /* holds the info of the last frame we seeked to */
	FLAC__uint64 first_frame_offset; /* hint to the seek routine of where in the stream the first audio frame starts */
	FLAC__uint64 target_sample;
	unsigned unparseable_frame_count; /* used to tell whether we're decoding a future version of FLAC or just got a bad sync */
#if FLAC__HAS_OGG
	FLAC__bool got_a_frame; /* hack needed in Ogg FLAC seek routine to check when process_single() actually writes a frame */
#endif
} FLAC__StreamDecoderPrivate;

/***********************************************************************
 *
 * Public static class data
 *
 ***********************************************************************/

FLAC_API const char * const FLAC__StreamDecoderStateString[] = {
	"FLAC__STREAM_DECODER_SEARCH_FOR_METADATA",
	"FLAC__STREAM_DECODER_READ_METADATA",
	"FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC",
	"FLAC__STREAM_DECODER_READ_FRAME",
	"FLAC__STREAM_DECODER_END_OF_STREAM",
	"FLAC__STREAM_DECODER_OGG_ERROR",
	"FLAC__STREAM_DECODER_SEEK_ERROR",
	"FLAC__STREAM_DECODER_ABORTED",
	"FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR",
	"FLAC__STREAM_DECODER_UNINITIALIZED"
};

FLAC_API const char * const FLAC__StreamDecoderInitStatusString[] = {
	"FLAC__STREAM_DECODER_INIT_STATUS_OK",
	"FLAC__STREAM_DECODER_INIT_STATUS_UNSUPPORTED_CONTAINER",
	"FLAC__STREAM_DECODER_INIT_STATUS_INVALID_CALLBACKS",
	"FLAC__STREAM_DECODER_INIT_STATUS_MEMORY_ALLOCATION_ERROR",
	"FLAC__STREAM_DECODER_INIT_STATUS_ERROR_OPENING_FILE",
	"FLAC__STREAM_DECODER_INIT_STATUS_ALREADY_INITIALIZED"
};

FLAC_API const char * const FLAC__StreamDecoderReadStatusString[] = {
	"FLAC__STREAM_DECODER_READ_STATUS_CONTINUE",
	"FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM",
	"FLAC__STREAM_DECODER_READ_STATUS_ABORT"
};

FLAC_API const char * const FLAC__StreamDecoderSeekStatusString[] = {
	"FLAC__STREAM_DECODER_SEEK_STATUS_OK",
	"FLAC__STREAM_DECODER_SEEK_STATUS_ERROR",
	"FLAC__STREAM_DECODER_SEEK_STATUS_UNSUPPORTED"
};

FLAC_API const char * const FLAC__StreamDecoderTellStatusString[] = {
	"FLAC__STREAM_DECODER_TELL_STATUS_OK",
	"FLAC__STREAM_DECODER_TELL_STATUS_ERROR",
	"FLAC__STREAM_DECODER_TELL_STATUS_UNSUPPORTED"
};

FLAC_API const char * const FLAC__StreamDecoderLengthStatusString[] = {
	"FLAC__STREAM_DECODER_LENGTH_STATUS_OK",
	"FLAC__STREAM_DECODER_LENGTH_STATUS_ERROR",
	"FLAC__STREAM_DECODER_LENGTH_STATUS_UNSUPPORTED"
};

FLAC_API const char * const FLAC__StreamDecoderWriteStatusString[] = {
	"FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE",
	"FLAC__STREAM_DECODER_WRITE_STATUS_ABORT"
};

FLAC_API const char * const FLAC__StreamDecoderErrorStatusString[] = {
	"FLAC__STREAM_DECODER_ERROR_STATUS_LOST_SYNC",
	"FLAC__STREAM_DECODER_ERROR_STATUS_BAD_HEADER",
	"FLAC__STREAM_DECODER_ERROR_STATUS_FRAME_CRC_MISMATCH",
	"FLAC__STREAM_DECODER_ERROR_STATUS_UNPARSEABLE_STREAM"
};

/***********************************************************************
 *
 * Class constructor/destructor
 *
 ***********************************************************************/
FLAC_API FLAC__StreamDecoder *FLAC__stream_decoder_new(void)
{
	FLAC__StreamDecoder *decoder;
	unsigned i;

	FLAC__ASSERT(sizeof(int) >= 4); /* we want to die right away if this is not true */

	decoder = (FLAC__StreamDecoder*)calloc(1, sizeof(FLAC__StreamDecoder));
	if(decoder == 0) {
		return 0;
	}

	decoder->protected_ = (FLAC__StreamDecoderProtected*)calloc(1, sizeof(FLAC__StreamDecoderProtected));
	if(decoder->protected_ == 0) {
		free(decoder);
		return 0;
	}

	decoder->private_ = (FLAC__StreamDecoderPrivate*)calloc(1, sizeof(FLAC__StreamDecoderPrivate));
	if(decoder->private_ == 0) {
		free(decoder->protected_);
		free(decoder);
		return 0;
	}

	decoder->private_->input = FLAC__bitreader_new();
	if(decoder->private_->input == 0) {
		free(decoder->private_);
		free(decoder->protected_);
		free(decoder);
		return 0;
	}

	decoder->private_->metadata_filter_ids_capacity = 16;
	if(0 == (decoder->private_->metadata_filter_ids = (FLAC__byte*)malloc((FLAC__STREAM_METADATA_APPLICATION_ID_LEN/8) * decoder->private_->metadata_filter_ids_capacity))) {
		FLAC__bitreader_delete(decoder->private_->input);
		free(decoder->private_);
		free(decoder->protected_);
		free(decoder);
		return 0;
	}

	for(i = 0; i < FLAC__MAX_CHANNELS; i++) {
		decoder->private_->output[i] = 0;
		decoder->private_->residual_unaligned[i] = decoder->private_->residual[i] = 0;
	}

	decoder->private_->output_capacity = 0;
	decoder->private_->output_channels = 0;
	decoder->private_->has_seek_table = false;

	for(i = 0; i < FLAC__MAX_CHANNELS; i++)
		FLAC__format_entropy_coding_method_partitioned_rice_contents_init(&decoder->private_->partitioned_rice_contents[i]);

	decoder->private_->file = 0;

	set_defaults_dec(decoder);

	decoder->protected_->state = FLAC__STREAM_DECODER_UNINITIALIZED;

	return decoder;
}

FLAC_API void FLAC__stream_decoder_delete(FLAC__StreamDecoder *decoder)
{
	unsigned i;

	FLAC__ASSERT(0 != decoder);
	FLAC__ASSERT(0 != decoder->protected_);
	FLAC__ASSERT(0 != decoder->private_);
	FLAC__ASSERT(0 != decoder->private_->input);

	(void)FLAC__stream_decoder_finish(decoder);

	if(0 != decoder->private_->metadata_filter_ids)
		free(decoder->private_->metadata_filter_ids);

	FLAC__bitreader_delete(decoder->private_->input);

	for(i = 0; i < FLAC__MAX_CHANNELS; i++)
		FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(&decoder->private_->partitioned_rice_contents[i]);

	free(decoder->private_);
	free(decoder->protected_);
	free(decoder);
}

/***********************************************************************
 *
 * Public class methods
 *
 ***********************************************************************/

static FLAC__StreamDecoderInitStatus init_stream_internal_dec(
	FLAC__StreamDecoder *decoder,
	FLAC__StreamDecoderReadCallback read_callback,
	FLAC__StreamDecoderSeekCallback seek_callback,
	FLAC__StreamDecoderTellCallback tell_callback,
	FLAC__StreamDecoderLengthCallback length_callback,
	FLAC__StreamDecoderEofCallback eof_callback,
	FLAC__StreamDecoderWriteCallback write_callback,
	FLAC__StreamDecoderMetadataCallback metadata_callback,
	FLAC__StreamDecoderErrorCallback error_callback,
	void *client_data,
	FLAC__bool is_ogg
)
{
	FLAC__ASSERT(0 != decoder);

	if(decoder->protected_->state != FLAC__STREAM_DECODER_UNINITIALIZED)
		return FLAC__STREAM_DECODER_INIT_STATUS_ALREADY_INITIALIZED;

#if !FLAC__HAS_OGG
	if(is_ogg)
		return FLAC__STREAM_DECODER_INIT_STATUS_UNSUPPORTED_CONTAINER;
#endif

	if(
		0 == read_callback ||
		0 == write_callback ||
		0 == error_callback ||
		(seek_callback && (0 == tell_callback || 0 == length_callback || 0 == eof_callback))
	)
		return FLAC__STREAM_DECODER_INIT_STATUS_INVALID_CALLBACKS;

#if FLAC__HAS_OGG
	decoder->private_->is_ogg = is_ogg;
	if(is_ogg && !FLAC__ogg_decoder_aspect_init(&decoder->protected_->ogg_decoder_aspect))
		return decoder->protected_->state = FLAC__STREAM_DECODER_OGG_ERROR;
#endif

	/*
	 * get the CPU info and set the function pointers
	 */
	FLAC__cpu_info(&decoder->private_->cpuinfo);
	/* first default to the non-asm routines */
	decoder->private_->local_lpc_restore_signal = FLAC__lpc_restore_signal;
	decoder->private_->local_lpc_restore_signal_64bit = FLAC__lpc_restore_signal_wide;
	decoder->private_->local_lpc_restore_signal_16bit = FLAC__lpc_restore_signal;
	decoder->private_->local_lpc_restore_signal_16bit_order8 = FLAC__lpc_restore_signal;
	decoder->private_->local_bitreader_read_rice_signed_block = FLAC__bitreader_read_rice_signed_block;
	/* now override with asm where appropriate */
#ifndef FLAC__NO_ASM
	if(decoder->private_->cpuinfo.use_asm) {
#ifdef FLAC__CPU_IA32
		FLAC__ASSERT(decoder->private_->cpuinfo.type == FLAC__CPUINFO_TYPE_IA32);
#ifdef FLAC__HAS_NASM
#if 1 /*@@@@@@ OPT: not clearly faster, needs more testing */
		if(decoder->private_->cpuinfo.data.ia32.bswap)
			decoder->private_->local_bitreader_read_rice_signed_block = FLAC__bitreader_read_rice_signed_block_asm_ia32_bswap;
#endif
		if(decoder->private_->cpuinfo.data.ia32.mmx) {
			decoder->private_->local_lpc_restore_signal = FLAC__lpc_restore_signal_asm_ia32;
			decoder->private_->local_lpc_restore_signal_16bit = FLAC__lpc_restore_signal_asm_ia32_mmx;
			decoder->private_->local_lpc_restore_signal_16bit_order8 = FLAC__lpc_restore_signal_asm_ia32_mmx;
		}
		else {
			decoder->private_->local_lpc_restore_signal = FLAC__lpc_restore_signal_asm_ia32;
			decoder->private_->local_lpc_restore_signal_16bit = FLAC__lpc_restore_signal_asm_ia32;
			decoder->private_->local_lpc_restore_signal_16bit_order8 = FLAC__lpc_restore_signal_asm_ia32;
		}
#endif
#elif defined FLAC__CPU_PPC
		FLAC__ASSERT(decoder->private_->cpuinfo.type == FLAC__CPUINFO_TYPE_PPC);
		if(decoder->private_->cpuinfo.data.ppc.altivec) {
			decoder->private_->local_lpc_restore_signal_16bit = FLAC__lpc_restore_signal_asm_ppc_altivec_16;
			decoder->private_->local_lpc_restore_signal_16bit_order8 = FLAC__lpc_restore_signal_asm_ppc_altivec_16_order8;
		}
#endif
	}
#endif

	/* from here on, errors are fatal */

	if(!FLAC__bitreader_init(decoder->private_->input, decoder->private_->cpuinfo, read_callback_, decoder)) {
		decoder->protected_->state = FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR;
		return FLAC__STREAM_DECODER_INIT_STATUS_MEMORY_ALLOCATION_ERROR;
	}

	decoder->private_->read_callback = read_callback;
	decoder->private_->seek_callback = seek_callback;
	decoder->private_->tell_callback = tell_callback;
	decoder->private_->length_callback = length_callback;
	decoder->private_->eof_callback = eof_callback;
	decoder->private_->write_callback = write_callback;
	decoder->private_->metadata_callback = metadata_callback;
	decoder->private_->error_callback = error_callback;
	decoder->private_->client_data = client_data;
	decoder->private_->fixed_block_size = decoder->private_->next_fixed_block_size = 0;
	decoder->private_->samples_decoded = 0;
	decoder->private_->has_stream_info = false;
	decoder->private_->cached = false;

	decoder->private_->do_md5_checking = decoder->protected_->md5_checking;
	decoder->private_->is_seeking = false;

	decoder->private_->internal_reset_hack = true; /* so the following reset does not try to rewind the input */
	if(!FLAC__stream_decoder_reset(decoder)) {
		/* above call sets the state for us */
		return FLAC__STREAM_DECODER_INIT_STATUS_MEMORY_ALLOCATION_ERROR;
	}

	return FLAC__STREAM_DECODER_INIT_STATUS_OK;
}

FLAC_API FLAC__StreamDecoderInitStatus FLAC__stream_decoder_init_stream(
	FLAC__StreamDecoder *decoder,
	FLAC__StreamDecoderReadCallback read_callback,
	FLAC__StreamDecoderSeekCallback seek_callback,
	FLAC__StreamDecoderTellCallback tell_callback,
	FLAC__StreamDecoderLengthCallback length_callback,
	FLAC__StreamDecoderEofCallback eof_callback,
	FLAC__StreamDecoderWriteCallback write_callback,
	FLAC__StreamDecoderMetadataCallback metadata_callback,
	FLAC__StreamDecoderErrorCallback error_callback,
	void *client_data
)
{
	return init_stream_internal_dec(
		decoder,
		read_callback,
		seek_callback,
		tell_callback,
		length_callback,
		eof_callback,
		write_callback,
		metadata_callback,
		error_callback,
		client_data,
		/*is_ogg=*/false
	);
}

FLAC_API FLAC__StreamDecoderInitStatus FLAC__stream_decoder_init_ogg_stream(
	FLAC__StreamDecoder *decoder,
	FLAC__StreamDecoderReadCallback read_callback,
	FLAC__StreamDecoderSeekCallback seek_callback,
	FLAC__StreamDecoderTellCallback tell_callback,
	FLAC__StreamDecoderLengthCallback length_callback,
	FLAC__StreamDecoderEofCallback eof_callback,
	FLAC__StreamDecoderWriteCallback write_callback,
	FLAC__StreamDecoderMetadataCallback metadata_callback,
	FLAC__StreamDecoderErrorCallback error_callback,
	void *client_data
)
{
	return init_stream_internal_dec(
		decoder,
		read_callback,
		seek_callback,
		tell_callback,
		length_callback,
		eof_callback,
		write_callback,
		metadata_callback,
		error_callback,
		client_data,
		/*is_ogg=*/true
	);
}

static FLAC__StreamDecoderInitStatus init_FILE_internal_(
	FLAC__StreamDecoder *decoder,
	FILE *file,
	FLAC__StreamDecoderWriteCallback write_callback,
	FLAC__StreamDecoderMetadataCallback metadata_callback,
	FLAC__StreamDecoderErrorCallback error_callback,
	void *client_data,
	FLAC__bool is_ogg
)
{
	FLAC__ASSERT(0 != decoder);
	FLAC__ASSERT(0 != file);

	if(decoder->protected_->state != FLAC__STREAM_DECODER_UNINITIALIZED)
		return (FLAC__StreamDecoderInitStatus) (decoder->protected_->state = (FLAC__StreamDecoderState) FLAC__STREAM_DECODER_INIT_STATUS_ALREADY_INITIALIZED);

	if(0 == write_callback || 0 == error_callback)
		return (FLAC__StreamDecoderInitStatus) (decoder->protected_->state = (FLAC__StreamDecoderState) FLAC__STREAM_DECODER_INIT_STATUS_INVALID_CALLBACKS);

	/*
	 * To make sure that our file does not go unclosed after an error, we
	 * must assign the FILE pointer before any further error can occur in
	 * this routine.
	 */
	if(file == stdin)
		file = get_binary_stdin_(); /* just to be safe */

	decoder->private_->file = file;

	return init_stream_internal_dec(
		decoder,
		file_read_callback_dec,
		decoder->private_->file == stdin? 0: file_seek_callback_dec,
		decoder->private_->file == stdin? 0: file_tell_callback_dec,
		decoder->private_->file == stdin? 0: file_length_callback_,
		file_eof_callback_,
		write_callback,
		metadata_callback,
		error_callback,
		client_data,
		is_ogg
	);
}

FLAC_API FLAC__StreamDecoderInitStatus FLAC__stream_decoder_init_FILE(
	FLAC__StreamDecoder *decoder,
	FILE *file,
	FLAC__StreamDecoderWriteCallback write_callback,
	FLAC__StreamDecoderMetadataCallback metadata_callback,
	FLAC__StreamDecoderErrorCallback error_callback,
	void *client_data
)
{
	return init_FILE_internal_(decoder, file, write_callback, metadata_callback, error_callback, client_data, /*is_ogg=*/false);
}

FLAC_API FLAC__StreamDecoderInitStatus FLAC__stream_decoder_init_ogg_FILE(
	FLAC__StreamDecoder *decoder,
	FILE *file,
	FLAC__StreamDecoderWriteCallback write_callback,
	FLAC__StreamDecoderMetadataCallback metadata_callback,
	FLAC__StreamDecoderErrorCallback error_callback,
	void *client_data
)
{
	return init_FILE_internal_(decoder, file, write_callback, metadata_callback, error_callback, client_data, /*is_ogg=*/true);
}

static FLAC__StreamDecoderInitStatus init_file_internal_(
	FLAC__StreamDecoder *decoder,
	const char *filename,
	FLAC__StreamDecoderWriteCallback write_callback,
	FLAC__StreamDecoderMetadataCallback metadata_callback,
	FLAC__StreamDecoderErrorCallback error_callback,
	void *client_data,
	FLAC__bool is_ogg
)
{
	FILE *file;

	FLAC__ASSERT(0 != decoder);

	/*
	 * To make sure that our file does not go unclosed after an error, we
	 * have to do the same entrance checks here that are later performed
	 * in FLAC__stream_decoder_init_FILE() before the FILE* is assigned.
	 */
	if(decoder->protected_->state != FLAC__STREAM_DECODER_UNINITIALIZED)
		return (FLAC__StreamDecoderInitStatus) (decoder->protected_->state = (FLAC__StreamDecoderState) FLAC__STREAM_DECODER_INIT_STATUS_ALREADY_INITIALIZED);

	if(0 == write_callback || 0 == error_callback)
		return (FLAC__StreamDecoderInitStatus) (decoder->protected_->state = (FLAC__StreamDecoderState) FLAC__STREAM_DECODER_INIT_STATUS_INVALID_CALLBACKS);

	file = filename? fopen(filename, "rb") : stdin;

	if(0 == file)
		return FLAC__STREAM_DECODER_INIT_STATUS_ERROR_OPENING_FILE;

	return init_FILE_internal_(decoder, file, write_callback, metadata_callback, error_callback, client_data, is_ogg);
}

FLAC_API FLAC__StreamDecoderInitStatus FLAC__stream_decoder_init_file(
	FLAC__StreamDecoder *decoder,
	const char *filename,
	FLAC__StreamDecoderWriteCallback write_callback,
	FLAC__StreamDecoderMetadataCallback metadata_callback,
	FLAC__StreamDecoderErrorCallback error_callback,
	void *client_data
)
{
	return init_file_internal_(decoder, filename, write_callback, metadata_callback, error_callback, client_data, /*is_ogg=*/false);
}

FLAC_API FLAC__StreamDecoderInitStatus FLAC__stream_decoder_init_ogg_file(
	FLAC__StreamDecoder *decoder,
	const char *filename,
	FLAC__StreamDecoderWriteCallback write_callback,
	FLAC__StreamDecoderMetadataCallback metadata_callback,
	FLAC__StreamDecoderErrorCallback error_callback,
	void *client_data
)
{
	return init_file_internal_(decoder, filename, write_callback, metadata_callback, error_callback, client_data, /*is_ogg=*/true);
}

FLAC_API FLAC__bool FLAC__stream_decoder_finish(FLAC__StreamDecoder *decoder)
{
	FLAC__bool md5_failed = false;
	unsigned i;

	FLAC__ASSERT(0 != decoder);
	FLAC__ASSERT(0 != decoder->private_);
	FLAC__ASSERT(0 != decoder->protected_);

	if(decoder->protected_->state == FLAC__STREAM_DECODER_UNINITIALIZED)
		return true;

	/* see the comment in FLAC__seekable_stream_decoder_reset() as to why we
	 * always call FLAC__MD5Final()
	 */
	FLAC__MD5Final(decoder->private_->computed_md5sum, &decoder->private_->md5context);

	if(decoder->private_->has_seek_table && 0 != decoder->private_->seek_table.data.seek_table.points) {
		free(decoder->private_->seek_table.data.seek_table.points);
		decoder->private_->seek_table.data.seek_table.points = 0;
		decoder->private_->has_seek_table = false;
	}
	FLAC__bitreader_free(decoder->private_->input);
	for(i = 0; i < FLAC__MAX_CHANNELS; i++) {
		/* WATCHOUT:
		 * FLAC__lpc_restore_signal_asm_ia32_mmx() requires that the
		 * output arrays have a buffer of up to 3 zeroes in front
		 * (at negative indices) for alignment purposes; we use 4
		 * to keep the data well-aligned.
		 */
		if(0 != decoder->private_->output[i]) {
			free(decoder->private_->output[i]-4);
			decoder->private_->output[i] = 0;
		}
		if(0 != decoder->private_->residual_unaligned[i]) {
			free(decoder->private_->residual_unaligned[i]);
			decoder->private_->residual_unaligned[i] = decoder->private_->residual[i] = 0;
		}
	}
	decoder->private_->output_capacity = 0;
	decoder->private_->output_channels = 0;

#if FLAC__HAS_OGG
	if(decoder->private_->is_ogg)
		FLAC__ogg_decoder_aspect_finish(&decoder->protected_->ogg_decoder_aspect);
#endif

	if(0 != decoder->private_->file) {
		if(decoder->private_->file != stdin)
			fclose(decoder->private_->file);
		decoder->private_->file = 0;
	}

	if(decoder->private_->do_md5_checking) {
		if(memcmp(decoder->private_->stream_info.data.stream_info.md5sum, decoder->private_->computed_md5sum, 16))
			md5_failed = true;
	}
	decoder->private_->is_seeking = false;

	set_defaults_dec(decoder);

	decoder->protected_->state = FLAC__STREAM_DECODER_UNINITIALIZED;

	return !md5_failed;
}

FLAC_API FLAC__bool FLAC__stream_decoder_set_ogg_serial_number(FLAC__StreamDecoder *decoder, long value)
{
	FLAC__ASSERT(0 != decoder);
	FLAC__ASSERT(0 != decoder->private_);
	FLAC__ASSERT(0 != decoder->protected_);
	if(decoder->protected_->state != FLAC__STREAM_DECODER_UNINITIALIZED)
		return false;
#if FLAC__HAS_OGG
	/* can't check decoder->private_->is_ogg since that's not set until init time */
	FLAC__ogg_decoder_aspect_set_serial_number(&decoder->protected_->ogg_decoder_aspect, value);
	return true;
#else
	(void)value;
	return false;
#endif
}

FLAC_API FLAC__bool FLAC__stream_decoder_set_md5_checking(FLAC__StreamDecoder *decoder, FLAC__bool value)
{
	FLAC__ASSERT(0 != decoder);
	FLAC__ASSERT(0 != decoder->protected_);
	if(decoder->protected_->state != FLAC__STREAM_DECODER_UNINITIALIZED)
		return false;
	decoder->protected_->md5_checking = value;
	return true;
}

FLAC_API FLAC__bool FLAC__stream_decoder_set_metadata_respond(FLAC__StreamDecoder *decoder, FLAC__MetadataType type)
{
	FLAC__ASSERT(0 != decoder);
	FLAC__ASSERT(0 != decoder->private_);
	FLAC__ASSERT(0 != decoder->protected_);
	FLAC__ASSERT((unsigned)type <= FLAC__MAX_METADATA_TYPE_CODE);
	/* double protection */
	if((unsigned)type > FLAC__MAX_METADATA_TYPE_CODE)
		return false;
	if(decoder->protected_->state != FLAC__STREAM_DECODER_UNINITIALIZED)
		return false;
	decoder->private_->metadata_filter[type] = true;
	if(type == FLAC__METADATA_TYPE_APPLICATION)
		decoder->private_->metadata_filter_ids_count = 0;
	return true;
}

FLAC_API FLAC__bool FLAC__stream_decoder_set_metadata_respond_application(FLAC__StreamDecoder *decoder, const FLAC__byte id[4])
{
	FLAC__ASSERT(0 != decoder);
	FLAC__ASSERT(0 != decoder->private_);
	FLAC__ASSERT(0 != decoder->protected_);
	FLAC__ASSERT(0 != id);
	if(decoder->protected_->state != FLAC__STREAM_DECODER_UNINITIALIZED)
		return false;

	if(decoder->private_->metadata_filter[FLAC__METADATA_TYPE_APPLICATION])
		return true;

	FLAC__ASSERT(0 != decoder->private_->metadata_filter_ids);

	if(decoder->private_->metadata_filter_ids_count == decoder->private_->metadata_filter_ids_capacity) {
		if(0 == (decoder->private_->metadata_filter_ids = (FLAC__byte*)safe_realloc_mul_2op_(decoder->private_->metadata_filter_ids, decoder->private_->metadata_filter_ids_capacity, /*times*/2))) {
			decoder->protected_->state = FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR;
			return false;
		}
		decoder->private_->metadata_filter_ids_capacity *= 2;
	}

	memcpy(decoder->private_->metadata_filter_ids + decoder->private_->metadata_filter_ids_count * (FLAC__STREAM_METADATA_APPLICATION_ID_LEN/8), id, (FLAC__STREAM_METADATA_APPLICATION_ID_LEN/8));
	decoder->private_->metadata_filter_ids_count++;

	return true;
}

FLAC_API FLAC__bool FLAC__stream_decoder_set_metadata_respond_all(FLAC__StreamDecoder *decoder)
{
	unsigned i;
	FLAC__ASSERT(0 != decoder);
	FLAC__ASSERT(0 != decoder->private_);
	FLAC__ASSERT(0 != decoder->protected_);
	if(decoder->protected_->state != FLAC__STREAM_DECODER_UNINITIALIZED)
		return false;
	for(i = 0; i < sizeof(decoder->private_->metadata_filter) / sizeof(decoder->private_->metadata_filter[0]); i++)
		decoder->private_->metadata_filter[i] = true;
	decoder->private_->metadata_filter_ids_count = 0;
	return true;
}

FLAC_API FLAC__bool FLAC__stream_decoder_set_metadata_ignore(FLAC__StreamDecoder *decoder, FLAC__MetadataType type)
{
	FLAC__ASSERT(0 != decoder);
	FLAC__ASSERT(0 != decoder->private_);
	FLAC__ASSERT(0 != decoder->protected_);
	FLAC__ASSERT((unsigned)type <= FLAC__MAX_METADATA_TYPE_CODE);
	/* double protection */
	if((unsigned)type > FLAC__MAX_METADATA_TYPE_CODE)
		return false;
	if(decoder->protected_->state != FLAC__STREAM_DECODER_UNINITIALIZED)
		return false;
	decoder->private_->metadata_filter[type] = false;
	if(type == FLAC__METADATA_TYPE_APPLICATION)
		decoder->private_->metadata_filter_ids_count = 0;
	return true;
}

FLAC_API FLAC__bool FLAC__stream_decoder_set_metadata_ignore_application(FLAC__StreamDecoder *decoder, const FLAC__byte id[4])
{
	FLAC__ASSERT(0 != decoder);
	FLAC__ASSERT(0 != decoder->private_);
	FLAC__ASSERT(0 != decoder->protected_);
	FLAC__ASSERT(0 != id);
	if(decoder->protected_->state != FLAC__STREAM_DECODER_UNINITIALIZED)
		return false;

	if(!decoder->private_->metadata_filter[FLAC__METADATA_TYPE_APPLICATION])
		return true;

	FLAC__ASSERT(0 != decoder->private_->metadata_filter_ids);

	if(decoder->private_->metadata_filter_ids_count == decoder->private_->metadata_filter_ids_capacity) {
		if(0 == (decoder->private_->metadata_filter_ids = (FLAC__byte*)safe_realloc_mul_2op_(decoder->private_->metadata_filter_ids, decoder->private_->metadata_filter_ids_capacity, /*times*/2))) {
			decoder->protected_->state = FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR;
			return false;
		}
		decoder->private_->metadata_filter_ids_capacity *= 2;
	}

	memcpy(decoder->private_->metadata_filter_ids + decoder->private_->metadata_filter_ids_count * (FLAC__STREAM_METADATA_APPLICATION_ID_LEN/8), id, (FLAC__STREAM_METADATA_APPLICATION_ID_LEN/8));
	decoder->private_->metadata_filter_ids_count++;

	return true;
}

FLAC_API FLAC__bool FLAC__stream_decoder_set_metadata_ignore_all(FLAC__StreamDecoder *decoder)
{
	FLAC__ASSERT(0 != decoder);
	FLAC__ASSERT(0 != decoder->private_);
	FLAC__ASSERT(0 != decoder->protected_);
	if(decoder->protected_->state != FLAC__STREAM_DECODER_UNINITIALIZED)
		return false;
	memset(decoder->private_->metadata_filter, 0, sizeof(decoder->private_->metadata_filter));
	decoder->private_->metadata_filter_ids_count = 0;
	return true;
}

FLAC_API FLAC__StreamDecoderState FLAC__stream_decoder_get_state(const FLAC__StreamDecoder *decoder)
{
	FLAC__ASSERT(0 != decoder);
	FLAC__ASSERT(0 != decoder->protected_);
	return decoder->protected_->state;
}

FLAC_API const char *FLAC__stream_decoder_get_resolved_state_string(const FLAC__StreamDecoder *decoder)
{
	return FLAC__StreamDecoderStateString[decoder->protected_->state];
}

FLAC_API FLAC__bool FLAC__stream_decoder_get_md5_checking(const FLAC__StreamDecoder *decoder)
{
	FLAC__ASSERT(0 != decoder);
	FLAC__ASSERT(0 != decoder->protected_);
	return decoder->protected_->md5_checking;
}

FLAC_API FLAC__uint64 FLAC__stream_decoder_get_total_samples(const FLAC__StreamDecoder *decoder)
{
	FLAC__ASSERT(0 != decoder);
	FLAC__ASSERT(0 != decoder->protected_);
	return decoder->private_->has_stream_info? decoder->private_->stream_info.data.stream_info.total_samples : 0;
}

FLAC_API unsigned FLAC__stream_decoder_get_channels(const FLAC__StreamDecoder *decoder)
{
	FLAC__ASSERT(0 != decoder);
	FLAC__ASSERT(0 != decoder->protected_);
	return decoder->protected_->channels;
}

FLAC_API FLAC__ChannelAssignment FLAC__stream_decoder_get_channel_assignment(const FLAC__StreamDecoder *decoder)
{
	FLAC__ASSERT(0 != decoder);
	FLAC__ASSERT(0 != decoder->protected_);
	return decoder->protected_->channel_assignment;
}

FLAC_API unsigned FLAC__stream_decoder_get_bits_per_sample(const FLAC__StreamDecoder *decoder)
{
	FLAC__ASSERT(0 != decoder);
	FLAC__ASSERT(0 != decoder->protected_);
	return decoder->protected_->bits_per_sample;
}

FLAC_API unsigned FLAC__stream_decoder_get_sample_rate(const FLAC__StreamDecoder *decoder)
{
	FLAC__ASSERT(0 != decoder);
	FLAC__ASSERT(0 != decoder->protected_);
	return decoder->protected_->sample_rate;
}

FLAC_API unsigned FLAC__stream_decoder_get_blocksize(const FLAC__StreamDecoder *decoder)
{
	FLAC__ASSERT(0 != decoder);
	FLAC__ASSERT(0 != decoder->protected_);
	return decoder->protected_->blocksize;
}

FLAC_API FLAC__bool FLAC__stream_decoder_get_decode_position(const FLAC__StreamDecoder *decoder, FLAC__uint64 *position)
{
	FLAC__ASSERT(0 != decoder);
	FLAC__ASSERT(0 != decoder->private_);
	FLAC__ASSERT(0 != position);

#if FLAC__HAS_OGG
	if(decoder->private_->is_ogg)
		return false;
#endif
	if(0 == decoder->private_->tell_callback)
		return false;
	if(decoder->private_->tell_callback(decoder, position, decoder->private_->client_data) != FLAC__STREAM_DECODER_TELL_STATUS_OK)
		return false;
	/* should never happen since all FLAC frames and metadata blocks are byte aligned, but check just in case */
	if(!FLAC__bitreader_is_consumed_byte_aligned(decoder->private_->input))
		return false;
	FLAC__ASSERT(*position >= FLAC__stream_decoder_get_input_bytes_unconsumed(decoder));
	*position -= FLAC__stream_decoder_get_input_bytes_unconsumed(decoder);
	return true;
}

FLAC_API FLAC__bool FLAC__stream_decoder_flush(FLAC__StreamDecoder *decoder)
{
	FLAC__ASSERT(0 != decoder);
	FLAC__ASSERT(0 != decoder->private_);
	FLAC__ASSERT(0 != decoder->protected_);

	decoder->private_->samples_decoded = 0;
	decoder->private_->do_md5_checking = false;

#if FLAC__HAS_OGG
	if(decoder->private_->is_ogg)
		FLAC__ogg_decoder_aspect_flush(&decoder->protected_->ogg_decoder_aspect);
#endif

	if(!FLAC__bitreader_clear(decoder->private_->input)) {
		decoder->protected_->state = FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR;
		return false;
	}
	decoder->protected_->state = FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC;

	return true;
}

FLAC_API FLAC__bool FLAC__stream_decoder_reset(FLAC__StreamDecoder *decoder)
{
	FLAC__ASSERT(0 != decoder);
	FLAC__ASSERT(0 != decoder->private_);
	FLAC__ASSERT(0 != decoder->protected_);

	if(!FLAC__stream_decoder_flush(decoder)) {
		/* above call sets the state for us */
		return false;
	}

#if FLAC__HAS_OGG
	/*@@@ could go in !internal_reset_hack block below */
	if(decoder->private_->is_ogg)
		FLAC__ogg_decoder_aspect_reset(&decoder->protected_->ogg_decoder_aspect);
#endif

	/* Rewind if necessary.  If FLAC__stream_decoder_init() is calling us,
	 * (internal_reset_hack) don't try to rewind since we are already at
	 * the beginning of the stream and don't want to fail if the input is
	 * not seekable.
	 */
	if(!decoder->private_->internal_reset_hack) {
		if(decoder->private_->file == stdin)
			return false; /* can't rewind stdin, reset fails */
		if(decoder->private_->seek_callback && decoder->private_->seek_callback(decoder, 0, decoder->private_->client_data) == FLAC__STREAM_DECODER_SEEK_STATUS_ERROR)
			return false; /* seekable and seek fails, reset fails */
	}
	else
		decoder->private_->internal_reset_hack = false;

	decoder->protected_->state = FLAC__STREAM_DECODER_SEARCH_FOR_METADATA;

	decoder->private_->has_stream_info = false;
	if(decoder->private_->has_seek_table && 0 != decoder->private_->seek_table.data.seek_table.points) {
		free(decoder->private_->seek_table.data.seek_table.points);
		decoder->private_->seek_table.data.seek_table.points = 0;
		decoder->private_->has_seek_table = false;
	}
	decoder->private_->do_md5_checking = decoder->protected_->md5_checking;
	/*
	 * This goes in reset() and not flush() because according to the spec, a
	 * fixed-blocksize stream must stay that way through the whole stream.
	 */
	decoder->private_->fixed_block_size = decoder->private_->next_fixed_block_size = 0;

	/* We initialize the FLAC__MD5Context even though we may never use it.  This
	 * is because md5 checking may be turned on to start and then turned off if
	 * a seek occurs.  So we init the context here and finalize it in
	 * FLAC__stream_decoder_finish() to make sure things are always cleaned up
	 * properly.
	 */
	FLAC__MD5Init(&decoder->private_->md5context);

	decoder->private_->first_frame_offset = 0;
	decoder->private_->unparseable_frame_count = 0;

	return true;
}

FLAC_API FLAC__bool FLAC__stream_decoder_process_single(FLAC__StreamDecoder *decoder)
{
	FLAC__bool got_a_frame;
	FLAC__ASSERT(0 != decoder);
	FLAC__ASSERT(0 != decoder->protected_);

	while(1) {
		switch(decoder->protected_->state) {
			case FLAC__STREAM_DECODER_SEARCH_FOR_METADATA:
				if(!find_metadata_(decoder))
					return false; /* above function sets the status for us */
				break;
			case FLAC__STREAM_DECODER_READ_METADATA:
				if(!read_metadata_(decoder))
					return false; /* above function sets the status for us */
				else
					return true;
			case FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC:
				if(!frame_sync_(decoder))
					return true; /* above function sets the status for us */
				break;
			case FLAC__STREAM_DECODER_READ_FRAME:
				if(!read_frame_(decoder, &got_a_frame, /*do_full_decode=*/true))
					return false; /* above function sets the status for us */
				if(got_a_frame)
					return true; /* above function sets the status for us */
				break;
			case FLAC__STREAM_DECODER_END_OF_STREAM:
			case FLAC__STREAM_DECODER_ABORTED:
				return true;
			default:
				FLAC__ASSERT(0);
				return false;
		}
	}
}

FLAC_API FLAC__bool FLAC__stream_decoder_process_until_end_of_metadata(FLAC__StreamDecoder *decoder)
{
	FLAC__ASSERT(0 != decoder);
	FLAC__ASSERT(0 != decoder->protected_);

	while(1) {
		switch(decoder->protected_->state) {
			case FLAC__STREAM_DECODER_SEARCH_FOR_METADATA:
				if(!find_metadata_(decoder))
					return false; /* above function sets the status for us */
				break;
			case FLAC__STREAM_DECODER_READ_METADATA:
				if(!read_metadata_(decoder))
					return false; /* above function sets the status for us */
				break;
			case FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC:
			case FLAC__STREAM_DECODER_READ_FRAME:
			case FLAC__STREAM_DECODER_END_OF_STREAM:
			case FLAC__STREAM_DECODER_ABORTED:
				return true;
			default:
				FLAC__ASSERT(0);
				return false;
		}
	}
}

FLAC_API FLAC__bool FLAC__stream_decoder_process_until_end_of_stream(FLAC__StreamDecoder *decoder)
{
	FLAC__bool dummy;
	FLAC__ASSERT(0 != decoder);
	FLAC__ASSERT(0 != decoder->protected_);

	while(1) {
		switch(decoder->protected_->state) {
			case FLAC__STREAM_DECODER_SEARCH_FOR_METADATA:
				if(!find_metadata_(decoder))
					return false; /* above function sets the status for us */
				break;
			case FLAC__STREAM_DECODER_READ_METADATA:
				if(!read_metadata_(decoder))
					return false; /* above function sets the status for us */
				break;
			case FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC:
				if(!frame_sync_(decoder))
					return true; /* above function sets the status for us */
				break;
			case FLAC__STREAM_DECODER_READ_FRAME:
				if(!read_frame_(decoder, &dummy, /*do_full_decode=*/true))
					return false; /* above function sets the status for us */
				break;
			case FLAC__STREAM_DECODER_END_OF_STREAM:
			case FLAC__STREAM_DECODER_ABORTED:
				return true;
			default:
				FLAC__ASSERT(0);
				return false;
		}
	}
}

FLAC_API FLAC__bool FLAC__stream_decoder_skip_single_frame(FLAC__StreamDecoder *decoder)
{
	FLAC__bool got_a_frame;
	FLAC__ASSERT(0 != decoder);
	FLAC__ASSERT(0 != decoder->protected_);

	while(1) {
		switch(decoder->protected_->state) {
			case FLAC__STREAM_DECODER_SEARCH_FOR_METADATA:
			case FLAC__STREAM_DECODER_READ_METADATA:
				return false; /* above function sets the status for us */
			case FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC:
				if(!frame_sync_(decoder))
					return true; /* above function sets the status for us */
				break;
			case FLAC__STREAM_DECODER_READ_FRAME:
				if(!read_frame_(decoder, &got_a_frame, /*do_full_decode=*/false))
					return false; /* above function sets the status for us */
				if(got_a_frame)
					return true; /* above function sets the status for us */
				break;
			case FLAC__STREAM_DECODER_END_OF_STREAM:
			case FLAC__STREAM_DECODER_ABORTED:
				return true;
			default:
				FLAC__ASSERT(0);
				return false;
		}
	}
}

FLAC_API FLAC__bool FLAC__stream_decoder_seek_absolute(FLAC__StreamDecoder *decoder, FLAC__uint64 sample)
{
	FLAC__uint64 length;

	FLAC__ASSERT(0 != decoder);

	if(
		decoder->protected_->state != FLAC__STREAM_DECODER_SEARCH_FOR_METADATA &&
		decoder->protected_->state != FLAC__STREAM_DECODER_READ_METADATA &&
		decoder->protected_->state != FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC &&
		decoder->protected_->state != FLAC__STREAM_DECODER_READ_FRAME &&
		decoder->protected_->state != FLAC__STREAM_DECODER_END_OF_STREAM
	)
		return false;

	if(0 == decoder->private_->seek_callback)
		return false;

	FLAC__ASSERT(decoder->private_->seek_callback);
	FLAC__ASSERT(decoder->private_->tell_callback);
	FLAC__ASSERT(decoder->private_->length_callback);
	FLAC__ASSERT(decoder->private_->eof_callback);

	if(FLAC__stream_decoder_get_total_samples(decoder) > 0 && sample >= FLAC__stream_decoder_get_total_samples(decoder))
		return false;

	decoder->private_->is_seeking = true;

	/* turn off md5 checking if a seek is attempted */
	decoder->private_->do_md5_checking = false;

	/* get the file length (currently our algorithm needs to know the length so it's also an error to get FLAC__STREAM_DECODER_LENGTH_STATUS_UNSUPPORTED) */
	if(decoder->private_->length_callback(decoder, &length, decoder->private_->client_data) != FLAC__STREAM_DECODER_LENGTH_STATUS_OK) {
		decoder->private_->is_seeking = false;
		return false;
	}

	/* if we haven't finished processing the metadata yet, do that so we have the STREAMINFO, SEEK_TABLE, and first_frame_offset */
	if(
		decoder->protected_->state == FLAC__STREAM_DECODER_SEARCH_FOR_METADATA ||
		decoder->protected_->state == FLAC__STREAM_DECODER_READ_METADATA
	) {
		if(!FLAC__stream_decoder_process_until_end_of_metadata(decoder)) {
			/* above call sets the state for us */
			decoder->private_->is_seeking = false;
			return false;
		}
		/* check this again in case we didn't know total_samples the first time */
		if(FLAC__stream_decoder_get_total_samples(decoder) > 0 && sample >= FLAC__stream_decoder_get_total_samples(decoder)) {
			decoder->private_->is_seeking = false;
			return false;
		}
	}

	{
		const FLAC__bool ok =
#if FLAC__HAS_OGG
			decoder->private_->is_ogg?
			seek_to_absolute_sample_ogg_(decoder, length, sample) :
#endif
			seek_to_absolute_sample_(decoder, length, sample)
		;
		decoder->private_->is_seeking = false;
		return ok;
	}
}

/***********************************************************************
 *
 * Protected class methods
 *
 ***********************************************************************/

unsigned FLAC__stream_decoder_get_input_bytes_unconsumed(const FLAC__StreamDecoder *decoder)
{
	FLAC__ASSERT(0 != decoder);
	FLAC__ASSERT(FLAC__bitreader_is_consumed_byte_aligned(decoder->private_->input));
	FLAC__ASSERT(!(FLAC__bitreader_get_input_bits_unconsumed(decoder->private_->input) & 7));
	return FLAC__bitreader_get_input_bits_unconsumed(decoder->private_->input) / 8;
}

/***********************************************************************
 *
 * Private class methods
 *
 ***********************************************************************/

void set_defaults_dec(FLAC__StreamDecoder *decoder)
{
#if FLAC__HAS_OGG
	decoder->private_->is_ogg = false;
#endif
	decoder->private_->read_callback = 0;
	decoder->private_->seek_callback = 0;
	decoder->private_->tell_callback = 0;
	decoder->private_->length_callback = 0;
	decoder->private_->eof_callback = 0;
	decoder->private_->write_callback = 0;
	decoder->private_->metadata_callback = 0;
	decoder->private_->error_callback = 0;
	decoder->private_->client_data = 0;

	memset(decoder->private_->metadata_filter, 0, sizeof(decoder->private_->metadata_filter));
	decoder->private_->metadata_filter[FLAC__METADATA_TYPE_STREAMINFO] = true;
	decoder->private_->metadata_filter_ids_count = 0;

	decoder->protected_->md5_checking = false;

#if FLAC__HAS_OGG
	FLAC__ogg_decoder_aspect_set_defaults(&decoder->protected_->ogg_decoder_aspect);
#endif
}

/*
 * This will forcibly set stdin to binary mode (for OSes that require it)
 */
FILE *get_binary_stdin_(void)
{
	/* if something breaks here it is probably due to the presence or
	 * absence of an underscore before the identifiers 'setmode',
	 * 'fileno', and/or 'O_BINARY'; check your system header files.
	 */
#if defined _MSC_VER || defined __MINGW32__
	_setmode(_fileno(stdin), _O_BINARY);
#elif defined __CYGWIN__
	/* almost certainly not needed for any modern Cygwin, but let's be safe... */
	setmode(_fileno(stdin), _O_BINARY);
#elif defined __EMX__
	setmode(fileno(stdin), O_BINARY);
#endif

	return stdin;
}

FLAC__bool allocate_output_(FLAC__StreamDecoder *decoder, unsigned size, unsigned channels)
{
	unsigned i;
	FLAC__int32 *tmp;

	if(size <= decoder->private_->output_capacity && channels <= decoder->private_->output_channels)
		return true;

	/* simply using realloc() is not practical because the number of channels may change mid-stream */

	for(i = 0; i < FLAC__MAX_CHANNELS; i++) {
		if(0 != decoder->private_->output[i]) {
			free(decoder->private_->output[i]-4);
			decoder->private_->output[i] = 0;
		}
		if(0 != decoder->private_->residual_unaligned[i]) {
			free(decoder->private_->residual_unaligned[i]);
			decoder->private_->residual_unaligned[i] = decoder->private_->residual[i] = 0;
		}
	}

	for(i = 0; i < channels; i++) {
		/* WATCHOUT:
		 * FLAC__lpc_restore_signal_asm_ia32_mmx() requires that the
		 * output arrays have a buffer of up to 3 zeroes in front
		 * (at negative indices) for alignment purposes; we use 4
		 * to keep the data well-aligned.
		 */
		tmp = (FLAC__int32*)safe_malloc_muladd2_(sizeof(FLAC__int32), /*times (*/size, /*+*/4/*)*/);
		if(tmp == 0) {
			decoder->protected_->state = FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR;
			return false;
		}
		memset(tmp, 0, sizeof(FLAC__int32)*4);
		decoder->private_->output[i] = tmp + 4;

		/* WATCHOUT:
		 * minimum of quadword alignment for PPC vector optimizations is REQUIRED:
		 */
		if(!FLAC__memory_alloc_aligned_int32_array(size, &decoder->private_->residual_unaligned[i], &decoder->private_->residual[i])) {
			decoder->protected_->state = FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR;
			return false;
		}
	}

	decoder->private_->output_capacity = size;
	decoder->private_->output_channels = channels;

	return true;
}

FLAC__bool has_id_filtered_(FLAC__StreamDecoder *decoder, FLAC__byte *id)
{
	size_t i;

	FLAC__ASSERT(0 != decoder);
	FLAC__ASSERT(0 != decoder->private_);

	for(i = 0; i < decoder->private_->metadata_filter_ids_count; i++)
		if(0 == memcmp(decoder->private_->metadata_filter_ids + i * (FLAC__STREAM_METADATA_APPLICATION_ID_LEN/8), id, (FLAC__STREAM_METADATA_APPLICATION_ID_LEN/8)))
			return true;

	return false;
}

FLAC__bool find_metadata_(FLAC__StreamDecoder *decoder)
{
	FLAC__uint32 x;
	unsigned i, id_;
	FLAC__bool first = true;

	FLAC__ASSERT(FLAC__bitreader_is_consumed_byte_aligned(decoder->private_->input));

	for(i = id_ = 0; i < 4; ) {
		if(decoder->private_->cached) {
			x = (FLAC__uint32)decoder->private_->lookahead;
			decoder->private_->cached = false;
		}
		else {
			if(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, 8))
				return false; /* read_callback_ sets the state for us */
		}
		if(x == FLAC__STREAM_SYNC_STRING[i]) {
			first = true;
			i++;
			id_ = 0;
			continue;
		}
		if(x == ID3V2_TAG_[id_]) {
			id_++;
			i = 0;
			if(id_ == 3) {
				if(!skip_id3v2_tag_(decoder))
					return false; /* skip_id3v2_tag_ sets the state for us */
			}
			continue;
		}
		id_ = 0;
		if(x == 0xff) { /* MAGIC NUMBER for the first 8 frame sync bits */
			decoder->private_->header_warmup[0] = (FLAC__byte)x;
			if(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, 8))
				return false; /* read_callback_ sets the state for us */

			/* we have to check if we just read two 0xff's in a row; the second may actually be the beginning of the sync code */
			/* else we have to check if the second byte is the end of a sync code */
			if(x == 0xff) { /* MAGIC NUMBER for the first 8 frame sync bits */
				decoder->private_->lookahead = (FLAC__byte)x;
				decoder->private_->cached = true;
			}
			else if(x >> 2 == 0x3e) { /* MAGIC NUMBER for the last 6 sync bits */
				decoder->private_->header_warmup[1] = (FLAC__byte)x;
				decoder->protected_->state = FLAC__STREAM_DECODER_READ_FRAME;
				return true;
			}
		}
		i = 0;
		if(first) {
			send_error_to_client_(decoder, FLAC__STREAM_DECODER_ERROR_STATUS_LOST_SYNC);
			first = false;
		}
	}

	decoder->protected_->state = FLAC__STREAM_DECODER_READ_METADATA;
	return true;
}

FLAC__bool read_metadata_(FLAC__StreamDecoder *decoder)
{
	FLAC__bool is_last;
	FLAC__uint32 i, x, type, length;

	FLAC__ASSERT(FLAC__bitreader_is_consumed_byte_aligned(decoder->private_->input));

	if(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, FLAC__STREAM_METADATA_IS_LAST_LEN))
		return false; /* read_callback_ sets the state for us */
	is_last = x? true : false;

	if(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &type, FLAC__STREAM_METADATA_TYPE_LEN))
		return false; /* read_callback_ sets the state for us */

	if(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &length, FLAC__STREAM_METADATA_LENGTH_LEN))
		return false; /* read_callback_ sets the state for us */

	if(type == FLAC__METADATA_TYPE_STREAMINFO) {
		if(!read_metadata_streaminfo_(decoder, is_last, length))
			return false;

		decoder->private_->has_stream_info = true;
		if(0 == memcmp(decoder->private_->stream_info.data.stream_info.md5sum, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 16))
			decoder->private_->do_md5_checking = false;
		if(!decoder->private_->is_seeking && decoder->private_->metadata_filter[FLAC__METADATA_TYPE_STREAMINFO] && decoder->private_->metadata_callback)
			decoder->private_->metadata_callback(decoder, &decoder->private_->stream_info, decoder->private_->client_data);
	}
	else if(type == FLAC__METADATA_TYPE_SEEKTABLE) {
		if(!read_metadata_seektable_(decoder, is_last, length))
			return false;

		decoder->private_->has_seek_table = true;
		if(!decoder->private_->is_seeking && decoder->private_->metadata_filter[FLAC__METADATA_TYPE_SEEKTABLE] && decoder->private_->metadata_callback)
			decoder->private_->metadata_callback(decoder, &decoder->private_->seek_table, decoder->private_->client_data);
	}
	else {
		FLAC__bool skip_it = !decoder->private_->metadata_filter[type];
		unsigned real_length = length;
		FLAC__StreamMetadata block;

		block.is_last = is_last;
		block.type = (FLAC__MetadataType)type;
		block.length = length;

		if(type == FLAC__METADATA_TYPE_APPLICATION) {
			if(!FLAC__bitreader_read_byte_block_aligned_no_crc(decoder->private_->input, block.data.application.id, FLAC__STREAM_METADATA_APPLICATION_ID_LEN/8))
				return false; /* read_callback_ sets the state for us */

			if(real_length < FLAC__STREAM_METADATA_APPLICATION_ID_LEN/8) { /* underflow check */
				decoder->protected_->state = FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR;/*@@@@@@ maybe wrong error? need to resync?*/
				return false;
			}

			real_length -= FLAC__STREAM_METADATA_APPLICATION_ID_LEN/8;

			if(decoder->private_->metadata_filter_ids_count > 0 && has_id_filtered_(decoder, block.data.application.id))
				skip_it = !skip_it;
		}

		if(skip_it) {
			if(!FLAC__bitreader_skip_byte_block_aligned_no_crc(decoder->private_->input, real_length))
				return false; /* read_callback_ sets the state for us */
		}
		else {
			switch(type) {
				case FLAC__METADATA_TYPE_PADDING:
					/* skip the padding bytes */
					if(!FLAC__bitreader_skip_byte_block_aligned_no_crc(decoder->private_->input, real_length))
						return false; /* read_callback_ sets the state for us */
					break;
				case FLAC__METADATA_TYPE_APPLICATION:
					/* remember, we read the ID already */
					if(real_length > 0) {
						if(0 == (block.data.application.data = (FLAC__byte*)malloc(real_length))) {
							decoder->protected_->state = FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR;
							return false;
						}
						if(!FLAC__bitreader_read_byte_block_aligned_no_crc(decoder->private_->input, block.data.application.data, real_length))
							return false; /* read_callback_ sets the state for us */
					}
					else
						block.data.application.data = 0;
					break;
				case FLAC__METADATA_TYPE_VORBIS_COMMENT:
					if(!read_metadata_vorbiscomment_(decoder, &block.data.vorbis_comment))
						return false;
					break;
				case FLAC__METADATA_TYPE_CUESHEET:
					if(!read_metadata_cuesheet_(decoder, &block.data.cue_sheet))
						return false;
					break;
				case FLAC__METADATA_TYPE_PICTURE:
					if(!read_metadata_picture_(decoder, &block.data.picture))
						return false;
					break;
				case FLAC__METADATA_TYPE_STREAMINFO:
				case FLAC__METADATA_TYPE_SEEKTABLE:
					FLAC__ASSERT(0);
					break;
				default:
					if(real_length > 0) {
						if(0 == (block.data.unknown.data = (FLAC__byte*)malloc(real_length))) {
							decoder->protected_->state = FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR;
							return false;
						}
						if(!FLAC__bitreader_read_byte_block_aligned_no_crc(decoder->private_->input, block.data.unknown.data, real_length))
							return false; /* read_callback_ sets the state for us */
					}
					else
						block.data.unknown.data = 0;
					break;
			}
			if(!decoder->private_->is_seeking && decoder->private_->metadata_callback)
				decoder->private_->metadata_callback(decoder, &block, decoder->private_->client_data);

			/* now we have to free any malloc()ed data in the block */
			switch(type) {
				case FLAC__METADATA_TYPE_PADDING:
					break;
				case FLAC__METADATA_TYPE_APPLICATION:
					if(0 != block.data.application.data)
						free(block.data.application.data);
					break;
				case FLAC__METADATA_TYPE_VORBIS_COMMENT:
					if(0 != block.data.vorbis_comment.vendor_string.entry)
						free(block.data.vorbis_comment.vendor_string.entry);
					if(block.data.vorbis_comment.num_comments > 0)
						for(i = 0; i < block.data.vorbis_comment.num_comments; i++)
							if(0 != block.data.vorbis_comment.comments[i].entry)
								free(block.data.vorbis_comment.comments[i].entry);
					if(0 != block.data.vorbis_comment.comments)
						free(block.data.vorbis_comment.comments);
					break;
				case FLAC__METADATA_TYPE_CUESHEET:
					if(block.data.cue_sheet.num_tracks > 0)
						for(i = 0; i < block.data.cue_sheet.num_tracks; i++)
							if(0 != block.data.cue_sheet.tracks[i].indices)
								free(block.data.cue_sheet.tracks[i].indices);
					if(0 != block.data.cue_sheet.tracks)
						free(block.data.cue_sheet.tracks);
					break;
				case FLAC__METADATA_TYPE_PICTURE:
					if(0 != block.data.picture.mime_type)
						free(block.data.picture.mime_type);
					if(0 != block.data.picture.description)
						free(block.data.picture.description);
					if(0 != block.data.picture.data)
						free(block.data.picture.data);
					break;
				case FLAC__METADATA_TYPE_STREAMINFO:
				case FLAC__METADATA_TYPE_SEEKTABLE:
					FLAC__ASSERT(0);
				default:
					if(0 != block.data.unknown.data)
						free(block.data.unknown.data);
					break;
			}
		}
	}

	if(is_last) {
		/* if this fails, it's OK, it's just a hint for the seek routine */
		if(!FLAC__stream_decoder_get_decode_position(decoder, &decoder->private_->first_frame_offset))
			decoder->private_->first_frame_offset = 0;
		decoder->protected_->state = FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC;
	}

	return true;
}

FLAC__bool read_metadata_streaminfo_(FLAC__StreamDecoder *decoder, FLAC__bool is_last, unsigned length)
{
	FLAC__uint32 x;
	unsigned bits, used_bits = 0;

	FLAC__ASSERT(FLAC__bitreader_is_consumed_byte_aligned(decoder->private_->input));

	decoder->private_->stream_info.type = FLAC__METADATA_TYPE_STREAMINFO;
	decoder->private_->stream_info.is_last = is_last;
	decoder->private_->stream_info.length = length;

	bits = FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN;
	if(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, bits))
		return false; /* read_callback_ sets the state for us */
	decoder->private_->stream_info.data.stream_info.min_blocksize = x;
	used_bits += bits;

	bits = FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN;
	if(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN))
		return false; /* read_callback_ sets the state for us */
	decoder->private_->stream_info.data.stream_info.max_blocksize = x;
	used_bits += bits;

	bits = FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN;
	if(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN))
		return false; /* read_callback_ sets the state for us */
	decoder->private_->stream_info.data.stream_info.min_framesize = x;
	used_bits += bits;

	bits = FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN;
	if(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN))
		return false; /* read_callback_ sets the state for us */
	decoder->private_->stream_info.data.stream_info.max_framesize = x;
	used_bits += bits;

	bits = FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN;
	if(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN))
		return false; /* read_callback_ sets the state for us */
	decoder->private_->stream_info.data.stream_info.sample_rate = x;
	used_bits += bits;

	bits = FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN;
	if(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN))
		return false; /* read_callback_ sets the state for us */
	decoder->private_->stream_info.data.stream_info.channels = x+1;
	used_bits += bits;

	bits = FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN;
	if(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN))
		return false; /* read_callback_ sets the state for us */
	decoder->private_->stream_info.data.stream_info.bits_per_sample = x+1;
	used_bits += bits;

	bits = FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN;
	if(!FLAC__bitreader_read_raw_uint64(decoder->private_->input, &decoder->private_->stream_info.data.stream_info.total_samples, FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN))
		return false; /* read_callback_ sets the state for us */
	used_bits += bits;

	if(!FLAC__bitreader_read_byte_block_aligned_no_crc(decoder->private_->input, decoder->private_->stream_info.data.stream_info.md5sum, 16))
		return false; /* read_callback_ sets the state for us */
	used_bits += 16*8;

	/* skip the rest of the block */
	FLAC__ASSERT(used_bits % 8 == 0);
	length -= (used_bits / 8);
	if(!FLAC__bitreader_skip_byte_block_aligned_no_crc(decoder->private_->input, length))
		return false; /* read_callback_ sets the state for us */

	return true;
}

FLAC__bool read_metadata_seektable_(FLAC__StreamDecoder *decoder, FLAC__bool is_last, unsigned length)
{
	FLAC__uint32 i, x;
	FLAC__uint64 xx;

	FLAC__ASSERT(FLAC__bitreader_is_consumed_byte_aligned(decoder->private_->input));

	decoder->private_->seek_table.type = FLAC__METADATA_TYPE_SEEKTABLE;
	decoder->private_->seek_table.is_last = is_last;
	decoder->private_->seek_table.length = length;

	decoder->private_->seek_table.data.seek_table.num_points = length / FLAC__STREAM_METADATA_SEEKPOINT_LENGTH;

	/* use realloc since we may pass through here several times (e.g. after seeking) */
	if(0 == (decoder->private_->seek_table.data.seek_table.points = (FLAC__StreamMetadata_SeekPoint*)safe_realloc_mul_2op_(decoder->private_->seek_table.data.seek_table.points, decoder->private_->seek_table.data.seek_table.num_points, /*times*/sizeof(FLAC__StreamMetadata_SeekPoint)))) {
		decoder->protected_->state = FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR;
		return false;
	}
	for(i = 0; i < decoder->private_->seek_table.data.seek_table.num_points; i++) {
		if(!FLAC__bitreader_read_raw_uint64(decoder->private_->input, &xx, FLAC__STREAM_METADATA_SEEKPOINT_SAMPLE_NUMBER_LEN))
			return false; /* read_callback_ sets the state for us */
		decoder->private_->seek_table.data.seek_table.points[i].sample_number = xx;

		if(!FLAC__bitreader_read_raw_uint64(decoder->private_->input, &xx, FLAC__STREAM_METADATA_SEEKPOINT_STREAM_OFFSET_LEN))
			return false; /* read_callback_ sets the state for us */
		decoder->private_->seek_table.data.seek_table.points[i].stream_offset = xx;

		if(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, FLAC__STREAM_METADATA_SEEKPOINT_FRAME_SAMPLES_LEN))
			return false; /* read_callback_ sets the state for us */
		decoder->private_->seek_table.data.seek_table.points[i].frame_samples = x;
	}
	length -= (decoder->private_->seek_table.data.seek_table.num_points * FLAC__STREAM_METADATA_SEEKPOINT_LENGTH);
	/* if there is a partial point left, skip over it */
	if(length > 0) {
		/*@@@ do a send_error_to_client_() here?  there's an argument for either way */
		if(!FLAC__bitreader_skip_byte_block_aligned_no_crc(decoder->private_->input, length))
			return false; /* read_callback_ sets the state for us */
	}

	return true;
}

FLAC__bool read_metadata_vorbiscomment_(FLAC__StreamDecoder *decoder, FLAC__StreamMetadata_VorbisComment *obj)
{
	FLAC__uint32 i;

	FLAC__ASSERT(FLAC__bitreader_is_consumed_byte_aligned(decoder->private_->input));

	/* read vendor string */
	FLAC__ASSERT(FLAC__STREAM_METADATA_VORBIS_COMMENT_ENTRY_LENGTH_LEN == 32);
	if(!FLAC__bitreader_read_uint32_little_endian(decoder->private_->input, &obj->vendor_string.length))
		return false; /* read_callback_ sets the state for us */
	if(obj->vendor_string.length > 0) {
		if(0 == (obj->vendor_string.entry = (FLAC__byte*)safe_malloc_add_2op_(obj->vendor_string.length, /*+*/1))) {
			decoder->protected_->state = FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR;
			return false;
		}
		if(!FLAC__bitreader_read_byte_block_aligned_no_crc(decoder->private_->input, obj->vendor_string.entry, obj->vendor_string.length))
			return false; /* read_callback_ sets the state for us */
		obj->vendor_string.entry[obj->vendor_string.length] = '\0';
	}
	else
		obj->vendor_string.entry = 0;

	/* read num comments */
	FLAC__ASSERT(FLAC__STREAM_METADATA_VORBIS_COMMENT_NUM_COMMENTS_LEN == 32);
	if(!FLAC__bitreader_read_uint32_little_endian(decoder->private_->input, &obj->num_comments))
		return false; /* read_callback_ sets the state for us */

	/* read comments */
	if(obj->num_comments > 0) {
		if(0 == (obj->comments = (FLAC__StreamMetadata_VorbisComment_Entry*)safe_malloc_mul_2op_(obj->num_comments, /*times*/sizeof(FLAC__StreamMetadata_VorbisComment_Entry)))) {
			decoder->protected_->state = FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR;
			return false;
		}
		for(i = 0; i < obj->num_comments; i++) {
			FLAC__ASSERT(FLAC__STREAM_METADATA_VORBIS_COMMENT_ENTRY_LENGTH_LEN == 32);
			if(!FLAC__bitreader_read_uint32_little_endian(decoder->private_->input, &obj->comments[i].length))
				return false; /* read_callback_ sets the state for us */
			if(obj->comments[i].length > 0) {
				if(0 == (obj->comments[i].entry = (FLAC__byte*)safe_malloc_add_2op_(obj->comments[i].length, /*+*/1))) {
					decoder->protected_->state = FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR;
					return false;
				}
				if(!FLAC__bitreader_read_byte_block_aligned_no_crc(decoder->private_->input, obj->comments[i].entry, obj->comments[i].length))
					return false; /* read_callback_ sets the state for us */
				obj->comments[i].entry[obj->comments[i].length] = '\0';
			}
			else
				obj->comments[i].entry = 0;
		}
	}
	else {
		obj->comments = 0;
	}

	return true;
}

FLAC__bool read_metadata_cuesheet_(FLAC__StreamDecoder *decoder, FLAC__StreamMetadata_CueSheet *obj)
{
	FLAC__uint32 i, j, x;

	FLAC__ASSERT(FLAC__bitreader_is_consumed_byte_aligned(decoder->private_->input));

	memset(obj, 0, sizeof(FLAC__StreamMetadata_CueSheet));

	FLAC__ASSERT(FLAC__STREAM_METADATA_CUESHEET_MEDIA_CATALOG_NUMBER_LEN % 8 == 0);
	if(!FLAC__bitreader_read_byte_block_aligned_no_crc(decoder->private_->input, (FLAC__byte*)obj->media_catalog_number, FLAC__STREAM_METADATA_CUESHEET_MEDIA_CATALOG_NUMBER_LEN/8))
		return false; /* read_callback_ sets the state for us */

	if(!FLAC__bitreader_read_raw_uint64(decoder->private_->input, &obj->lead_in, FLAC__STREAM_METADATA_CUESHEET_LEAD_IN_LEN))
		return false; /* read_callback_ sets the state for us */

	if(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, FLAC__STREAM_METADATA_CUESHEET_IS_CD_LEN))
		return false; /* read_callback_ sets the state for us */
	obj->is_cd = x? true : false;

	if(!FLAC__bitreader_skip_bits_no_crc(decoder->private_->input, FLAC__STREAM_METADATA_CUESHEET_RESERVED_LEN))
		return false; /* read_callback_ sets the state for us */

	if(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, FLAC__STREAM_METADATA_CUESHEET_NUM_TRACKS_LEN))
		return false; /* read_callback_ sets the state for us */
	obj->num_tracks = x;

	if(obj->num_tracks > 0) {
		if(0 == (obj->tracks = (FLAC__StreamMetadata_CueSheet_Track*)safe_calloc_(obj->num_tracks, sizeof(FLAC__StreamMetadata_CueSheet_Track)))) {
			decoder->protected_->state = FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR;
			return false;
		}
		for(i = 0; i < obj->num_tracks; i++) {
			FLAC__StreamMetadata_CueSheet_Track *track = &obj->tracks[i];
			if(!FLAC__bitreader_read_raw_uint64(decoder->private_->input, &track->offset, FLAC__STREAM_METADATA_CUESHEET_TRACK_OFFSET_LEN))
				return false; /* read_callback_ sets the state for us */

			if(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, FLAC__STREAM_METADATA_CUESHEET_TRACK_NUMBER_LEN))
				return false; /* read_callback_ sets the state for us */
			track->number = (FLAC__byte)x;

			FLAC__ASSERT(FLAC__STREAM_METADATA_CUESHEET_TRACK_ISRC_LEN % 8 == 0);
			if(!FLAC__bitreader_read_byte_block_aligned_no_crc(decoder->private_->input, (FLAC__byte*)track->isrc, FLAC__STREAM_METADATA_CUESHEET_TRACK_ISRC_LEN/8))
				return false; /* read_callback_ sets the state for us */

			if(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, FLAC__STREAM_METADATA_CUESHEET_TRACK_TYPE_LEN))
				return false; /* read_callback_ sets the state for us */
			track->type = x;

			if(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, FLAC__STREAM_METADATA_CUESHEET_TRACK_PRE_EMPHASIS_LEN))
				return false; /* read_callback_ sets the state for us */
			track->pre_emphasis = x;

			if(!FLAC__bitreader_skip_bits_no_crc(decoder->private_->input, FLAC__STREAM_METADATA_CUESHEET_TRACK_RESERVED_LEN))
				return false; /* read_callback_ sets the state for us */

			if(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, FLAC__STREAM_METADATA_CUESHEET_TRACK_NUM_INDICES_LEN))
				return false; /* read_callback_ sets the state for us */
			track->num_indices = (FLAC__byte)x;

			if(track->num_indices > 0) {
				if(0 == (track->indices = (FLAC__StreamMetadata_CueSheet_Index*)safe_calloc_(track->num_indices, sizeof(FLAC__StreamMetadata_CueSheet_Index)))) {
					decoder->protected_->state = FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR;
					return false;
				}
				for(j = 0; j < track->num_indices; j++) {
					FLAC__StreamMetadata_CueSheet_Index *index = &track->indices[j];
					if(!FLAC__bitreader_read_raw_uint64(decoder->private_->input, &index->offset, FLAC__STREAM_METADATA_CUESHEET_INDEX_OFFSET_LEN))
						return false; /* read_callback_ sets the state for us */

					if(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, FLAC__STREAM_METADATA_CUESHEET_INDEX_NUMBER_LEN))
						return false; /* read_callback_ sets the state for us */
					index->number = (FLAC__byte)x;

					if(!FLAC__bitreader_skip_bits_no_crc(decoder->private_->input, FLAC__STREAM_METADATA_CUESHEET_INDEX_RESERVED_LEN))
						return false; /* read_callback_ sets the state for us */
				}
			}
		}
	}

	return true;
}

FLAC__bool read_metadata_picture_(FLAC__StreamDecoder *decoder, FLAC__StreamMetadata_Picture *obj)
{
	FLAC__uint32 x;

	FLAC__ASSERT(FLAC__bitreader_is_consumed_byte_aligned(decoder->private_->input));

	/* read type */
	if(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, FLAC__STREAM_METADATA_PICTURE_TYPE_LEN))
		return false; /* read_callback_ sets the state for us */
	obj->type = (FLAC__StreamMetadata_Picture_Type) x;

	/* read MIME type */
	if(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, FLAC__STREAM_METADATA_PICTURE_MIME_TYPE_LENGTH_LEN))
		return false; /* read_callback_ sets the state for us */
	if(0 == (obj->mime_type = (char*)safe_malloc_add_2op_(x, /*+*/1))) {
		decoder->protected_->state = FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR;
		return false;
	}
	if(x > 0) {
		if(!FLAC__bitreader_read_byte_block_aligned_no_crc(decoder->private_->input, (FLAC__byte*)obj->mime_type, x))
			return false; /* read_callback_ sets the state for us */
	}
	obj->mime_type[x] = '\0';

	/* read description */
	if(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, FLAC__STREAM_METADATA_PICTURE_DESCRIPTION_LENGTH_LEN))
		return false; /* read_callback_ sets the state for us */
	if(0 == (obj->description = (FLAC__byte*)safe_malloc_add_2op_(x, /*+*/1))) {
		decoder->protected_->state = FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR;
		return false;
	}
	if(x > 0) {
		if(!FLAC__bitreader_read_byte_block_aligned_no_crc(decoder->private_->input, obj->description, x))
			return false; /* read_callback_ sets the state for us */
	}
	obj->description[x] = '\0';

	/* read width */
	if(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &obj->width, FLAC__STREAM_METADATA_PICTURE_WIDTH_LEN))
		return false; /* read_callback_ sets the state for us */

	/* read height */
	if(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &obj->height, FLAC__STREAM_METADATA_PICTURE_HEIGHT_LEN))
		return false; /* read_callback_ sets the state for us */

	/* read depth */
	if(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &obj->depth, FLAC__STREAM_METADATA_PICTURE_DEPTH_LEN))
		return false; /* read_callback_ sets the state for us */

	/* read colors */
	if(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &obj->colors, FLAC__STREAM_METADATA_PICTURE_COLORS_LEN))
		return false; /* read_callback_ sets the state for us */

	/* read data */
	if(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &(obj->data_length), FLAC__STREAM_METADATA_PICTURE_DATA_LENGTH_LEN))
		return false; /* read_callback_ sets the state for us */
	if(0 == (obj->data = (FLAC__byte*)safe_malloc_(obj->data_length))) {
		decoder->protected_->state = FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR;
		return false;
	}
	if(obj->data_length > 0) {
		if(!FLAC__bitreader_read_byte_block_aligned_no_crc(decoder->private_->input, obj->data, obj->data_length))
			return false; /* read_callback_ sets the state for us */
	}

	return true;
}

FLAC__bool skip_id3v2_tag_(FLAC__StreamDecoder *decoder)
{
	FLAC__uint32 x;
	unsigned i, skip;

	/* skip the version and flags bytes */
	if(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, 24))
		return false; /* read_callback_ sets the state for us */
	/* get the size (in bytes) to skip */
	skip = 0;
	for(i = 0; i < 4; i++) {
		if(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, 8))
			return false; /* read_callback_ sets the state for us */
		skip <<= 7;
		skip |= (x & 0x7f);
	}
	/* skip the rest of the tag */
	if(!FLAC__bitreader_skip_byte_block_aligned_no_crc(decoder->private_->input, skip))
		return false; /* read_callback_ sets the state for us */
	return true;
}

FLAC__bool frame_sync_(FLAC__StreamDecoder *decoder)
{
	FLAC__uint32 x;
	FLAC__bool first = true;

	/* If we know the total number of samples in the stream, stop if we've read that many. */
	/* This will stop us, for example, from wasting time trying to sync on an ID3V1 tag. */
	if(FLAC__stream_decoder_get_total_samples(decoder) > 0) {
		if(decoder->private_->samples_decoded >= FLAC__stream_decoder_get_total_samples(decoder)) {
			decoder->protected_->state = FLAC__STREAM_DECODER_END_OF_STREAM;
			return true;
		}
	}

	/* make sure we're byte aligned */
	if(!FLAC__bitreader_is_consumed_byte_aligned(decoder->private_->input)) {
		if(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, FLAC__bitreader_bits_left_for_byte_alignment(decoder->private_->input)))
			return false; /* read_callback_ sets the state for us */
	}

	while(1) {
		if(decoder->private_->cached) {
			x = (FLAC__uint32)decoder->private_->lookahead;
			decoder->private_->cached = false;
		}
		else {
			if(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, 8))
				return false; /* read_callback_ sets the state for us */
		}
		if(x == 0xff) { /* MAGIC NUMBER for the first 8 frame sync bits */
			decoder->private_->header_warmup[0] = (FLAC__byte)x;
			if(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, 8))
				return false; /* read_callback_ sets the state for us */

			/* we have to check if we just read two 0xff's in a row; the second may actually be the beginning of the sync code */
			/* else we have to check if the second byte is the end of a sync code */
			if(x == 0xff) { /* MAGIC NUMBER for the first 8 frame sync bits */
				decoder->private_->lookahead = (FLAC__byte)x;
				decoder->private_->cached = true;
			}
			else if(x >> 2 == 0x3e) { /* MAGIC NUMBER for the last 6 sync bits */
				decoder->private_->header_warmup[1] = (FLAC__byte)x;
				decoder->protected_->state = FLAC__STREAM_DECODER_READ_FRAME;
				return true;
			}
		}
		if(first) {
			send_error_to_client_(decoder, FLAC__STREAM_DECODER_ERROR_STATUS_LOST_SYNC);
			first = false;
		}
	}

	return true;
}

FLAC__bool read_frame_(FLAC__StreamDecoder *decoder, FLAC__bool *got_a_frame, FLAC__bool do_full_decode)
{
	unsigned channel;
	unsigned i;
	FLAC__int32 mid, side;
	unsigned frame_crc; /* the one we calculate from the input stream */
	FLAC__uint32 x;

	*got_a_frame = false;

	/* init the CRC */
	frame_crc = 0;
	frame_crc = FLAC__CRC16_UPDATE(decoder->private_->header_warmup[0], frame_crc);
	frame_crc = FLAC__CRC16_UPDATE(decoder->private_->header_warmup[1], frame_crc);
	FLAC__bitreader_reset_read_crc16(decoder->private_->input, (FLAC__uint16)frame_crc);

	if(!read_frame_header_(decoder))
		return false;
	if(decoder->protected_->state == FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC) /* means we didn't sync on a valid header */
		return true;
	if(!allocate_output_(decoder, decoder->private_->frame.header.blocksize, decoder->private_->frame.header.channels))
		return false;
	for(channel = 0; channel < decoder->private_->frame.header.channels; channel++) {
		/*
		 * first figure the correct bits-per-sample of the subframe
		 */
		unsigned bps = decoder->private_->frame.header.bits_per_sample;
		switch(decoder->private_->frame.header.channel_assignment) {
			case FLAC__CHANNEL_ASSIGNMENT_INDEPENDENT:
				/* no adjustment needed */
				break;
			case FLAC__CHANNEL_ASSIGNMENT_LEFT_SIDE:
				FLAC__ASSERT(decoder->private_->frame.header.channels == 2);
				if(channel == 1)
					bps++;
				break;
			case FLAC__CHANNEL_ASSIGNMENT_RIGHT_SIDE:
				FLAC__ASSERT(decoder->private_->frame.header.channels == 2);
				if(channel == 0)
					bps++;
				break;
			case FLAC__CHANNEL_ASSIGNMENT_MID_SIDE:
				FLAC__ASSERT(decoder->private_->frame.header.channels == 2);
				if(channel == 1)
					bps++;
				break;
			default:
				FLAC__ASSERT(0);
		}
		/*
		 * now read it
		 */
		if(!read_subframe_(decoder, channel, bps, do_full_decode))
			return false;
		if(decoder->protected_->state == FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC) /* means bad sync or got corruption */
			return true;
	}
	if(!read_zero_padding_(decoder))
		return false;
	if(decoder->protected_->state == FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC) /* means bad sync or got corruption (i.e. "zero bits" were not all zeroes) */
		return true;

	/*
	 * Read the frame CRC-16 from the footer and check
	 */
	frame_crc = FLAC__bitreader_get_read_crc16(decoder->private_->input);
	if(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, FLAC__FRAME_FOOTER_CRC_LEN))
		return false; /* read_callback_ sets the state for us */
	if(frame_crc == x) {
		if(do_full_decode) {
			/* Undo any special channel coding */
			switch(decoder->private_->frame.header.channel_assignment) {
				case FLAC__CHANNEL_ASSIGNMENT_INDEPENDENT:
					/* do nothing */
					break;
				case FLAC__CHANNEL_ASSIGNMENT_LEFT_SIDE:
					FLAC__ASSERT(decoder->private_->frame.header.channels == 2);
					for(i = 0; i < decoder->private_->frame.header.blocksize; i++)
						decoder->private_->output[1][i] = decoder->private_->output[0][i] - decoder->private_->output[1][i];
					break;
				case FLAC__CHANNEL_ASSIGNMENT_RIGHT_SIDE:
					FLAC__ASSERT(decoder->private_->frame.header.channels == 2);
					for(i = 0; i < decoder->private_->frame.header.blocksize; i++)
						decoder->private_->output[0][i] += decoder->private_->output[1][i];
					break;
				case FLAC__CHANNEL_ASSIGNMENT_MID_SIDE:
					FLAC__ASSERT(decoder->private_->frame.header.channels == 2);
					for(i = 0; i < decoder->private_->frame.header.blocksize; i++) {
#if 1
						mid = decoder->private_->output[0][i];
						side = decoder->private_->output[1][i];
						mid <<= 1;
						mid |= (side & 1); /* i.e. if 'side' is odd... */
						decoder->private_->output[0][i] = (mid + side) >> 1;
						decoder->private_->output[1][i] = (mid - side) >> 1;
#else
						/* OPT: without 'side' temp variable */
						mid = (decoder->private_->output[0][i] << 1) | (decoder->private_->output[1][i] & 1); /* i.e. if 'side' is odd... */
						decoder->private_->output[0][i] = (mid + decoder->private_->output[1][i]) >> 1;
						decoder->private_->output[1][i] = (mid - decoder->private_->output[1][i]) >> 1;
#endif
					}
					break;
				default:
					FLAC__ASSERT(0);
					break;
			}
		}
	}
	else {
		/* Bad frame, emit error and zero the output signal */
		send_error_to_client_(decoder, FLAC__STREAM_DECODER_ERROR_STATUS_FRAME_CRC_MISMATCH);
		if(do_full_decode) {
			for(channel = 0; channel < decoder->private_->frame.header.channels; channel++) {
				memset(decoder->private_->output[channel], 0, sizeof(FLAC__int32) * decoder->private_->frame.header.blocksize);
			}
		}
	}

	*got_a_frame = true;

	/* we wait to update fixed_block_size until here, when we're sure we've got a proper frame and hence a correct blocksize */
	if(decoder->private_->next_fixed_block_size)
		decoder->private_->fixed_block_size = decoder->private_->next_fixed_block_size;

	/* put the latest values into the public section of the decoder instance */
	decoder->protected_->channels = decoder->private_->frame.header.channels;
	decoder->protected_->channel_assignment = decoder->private_->frame.header.channel_assignment;
	decoder->protected_->bits_per_sample = decoder->private_->frame.header.bits_per_sample;
	decoder->protected_->sample_rate = decoder->private_->frame.header.sample_rate;
	decoder->protected_->blocksize = decoder->private_->frame.header.blocksize;

	FLAC__ASSERT(decoder->private_->frame.header.number_type == FLAC__FRAME_NUMBER_TYPE_SAMPLE_NUMBER);
	decoder->private_->samples_decoded = decoder->private_->frame.header.number.sample_number + decoder->private_->frame.header.blocksize;

	/* write it */
	if(do_full_decode) {
		if(write_audio_frame_to_client_(decoder, &decoder->private_->frame, (const FLAC__int32 * const *)decoder->private_->output) != FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE)
			return false;
	}

	decoder->protected_->state = FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC;
	return true;
}

FLAC__bool read_frame_header_(FLAC__StreamDecoder *decoder)
{
	FLAC__uint32 x;
	FLAC__uint64 xx;
	unsigned i, blocksize_hint = 0, sample_rate_hint = 0;
	FLAC__byte crc8, raw_header[16]; /* MAGIC NUMBER based on the maximum frame header size, including CRC */
	unsigned raw_header_len;
	FLAC__bool is_unparseable = false;

	FLAC__ASSERT(FLAC__bitreader_is_consumed_byte_aligned(decoder->private_->input));

	/* init the raw header with the saved bits from synchronization */
	raw_header[0] = decoder->private_->header_warmup[0];
	raw_header[1] = decoder->private_->header_warmup[1];
	raw_header_len = 2;

	/* check to make sure that reserved bit is 0 */
	if(raw_header[1] & 0x02) /* MAGIC NUMBER */
		is_unparseable = true;

	/*
	 * Note that along the way as we read the header, we look for a sync
	 * code inside.  If we find one it would indicate that our original
	 * sync was bad since there cannot be a sync code in a valid header.
	 *
	 * Three kinds of things can go wrong when reading the frame header:
	 *  1) We may have sync'ed incorrectly and not landed on a frame header.
	 *     If we don't find a sync code, it can end up looking like we read
	 *     a valid but unparseable header, until getting to the frame header
	 *     CRC.  Even then we could get a false positive on the CRC.
	 *  2) We may have sync'ed correctly but on an unparseable frame (from a
	 *     future encoder).
	 *  3) We may be on a damaged frame which appears valid but unparseable.
	 *
	 * For all these reasons, we try and read a complete frame header as
	 * long as it seems valid, even if unparseable, up until the frame
	 * header CRC.
	 */

	/*
	 * read in the raw header as bytes so we can CRC it, and parse it on the way
	 */
	for(i = 0; i < 2; i++) {
		if(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, 8))
			return false; /* read_callback_ sets the state for us */
		if(x == 0xff) { /* MAGIC NUMBER for the first 8 frame sync bits */
			/* if we get here it means our original sync was erroneous since the sync code cannot appear in the header */
			decoder->private_->lookahead = (FLAC__byte)x;
			decoder->private_->cached = true;
			send_error_to_client_(decoder, FLAC__STREAM_DECODER_ERROR_STATUS_BAD_HEADER);
			decoder->protected_->state = FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC;
			return true;
		}
		raw_header[raw_header_len++] = (FLAC__byte)x;
	}

	switch(x = raw_header[2] >> 4) {
		case 0:
			is_unparseable = true;
			break;
		case 1:
			decoder->private_->frame.header.blocksize = 192;
			break;
		case 2:
		case 3:
		case 4:
		case 5:
			decoder->private_->frame.header.blocksize = 576 << (x-2);
			break;
		case 6:
		case 7:
			blocksize_hint = x;
			break;
		case 8:
		case 9:
		case 10:
		case 11:
		case 12:
		case 13:
		case 14:
		case 15:
			decoder->private_->frame.header.blocksize = 256 << (x-8);
			break;
		default:
			FLAC__ASSERT(0);
			break;
	}

	switch(x = raw_header[2] & 0x0f) {
		case 0:
			if(decoder->private_->has_stream_info)
				decoder->private_->frame.header.sample_rate = decoder->private_->stream_info.data.stream_info.sample_rate;
			else
				is_unparseable = true;
			break;
		case 1:
			decoder->private_->frame.header.sample_rate = 88200;
			break;
		case 2:
			decoder->private_->frame.header.sample_rate = 176400;
			break;
		case 3:
			decoder->private_->frame.header.sample_rate = 192000;
			break;
		case 4:
			decoder->private_->frame.header.sample_rate = 8000;
			break;
		case 5:
			decoder->private_->frame.header.sample_rate = 16000;
			break;
		case 6:
			decoder->private_->frame.header.sample_rate = 22050;
			break;
		case 7:
			decoder->private_->frame.header.sample_rate = 24000;
			break;
		case 8:
			decoder->private_->frame.header.sample_rate = 32000;
			break;
		case 9:
			decoder->private_->frame.header.sample_rate = 44100;
			break;
		case 10:
			decoder->private_->frame.header.sample_rate = 48000;
			break;
		case 11:
			decoder->private_->frame.header.sample_rate = 96000;
			break;
		case 12:
		case 13:
		case 14:
			sample_rate_hint = x;
			break;
		case 15:
			send_error_to_client_(decoder, FLAC__STREAM_DECODER_ERROR_STATUS_BAD_HEADER);
			decoder->protected_->state = FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC;
			return true;
		default:
			FLAC__ASSERT(0);
	}

	x = (unsigned)(raw_header[3] >> 4);
	if(x & 8) {
		decoder->private_->frame.header.channels = 2;
		switch(x & 7) {
			case 0:
				decoder->private_->frame.header.channel_assignment = FLAC__CHANNEL_ASSIGNMENT_LEFT_SIDE;
				break;
			case 1:
				decoder->private_->frame.header.channel_assignment = FLAC__CHANNEL_ASSIGNMENT_RIGHT_SIDE;
				break;
			case 2:
				decoder->private_->frame.header.channel_assignment = FLAC__CHANNEL_ASSIGNMENT_MID_SIDE;
				break;
			default:
				is_unparseable = true;
				break;
		}
	}
	else {
		decoder->private_->frame.header.channels = (unsigned)x + 1;
		decoder->private_->frame.header.channel_assignment = FLAC__CHANNEL_ASSIGNMENT_INDEPENDENT;
	}

	switch(x = (unsigned)(raw_header[3] & 0x0e) >> 1) {
		case 0:
			if(decoder->private_->has_stream_info)
				decoder->private_->frame.header.bits_per_sample = decoder->private_->stream_info.data.stream_info.bits_per_sample;
			else
				is_unparseable = true;
			break;
		case 1:
			decoder->private_->frame.header.bits_per_sample = 8;
			break;
		case 2:
			decoder->private_->frame.header.bits_per_sample = 12;
			break;
		case 4:
			decoder->private_->frame.header.bits_per_sample = 16;
			break;
		case 5:
			decoder->private_->frame.header.bits_per_sample = 20;
			break;
		case 6:
			decoder->private_->frame.header.bits_per_sample = 24;
			break;
		case 3:
		case 7:
			is_unparseable = true;
			break;
		default:
			FLAC__ASSERT(0);
			break;
	}

	/* check to make sure that reserved bit is 0 */
	if(raw_header[3] & 0x01) /* MAGIC NUMBER */
		is_unparseable = true;

	/* read the frame's starting sample number (or frame number as the case may be) */
	if(
		raw_header[1] & 0x01 ||
		/*@@@ this clause is a concession to the old way of doing variable blocksize; the only known implementation is flake and can probably be removed without inconveniencing anyone */
		(decoder->private_->has_stream_info && decoder->private_->stream_info.data.stream_info.min_blocksize != decoder->private_->stream_info.data.stream_info.max_blocksize)
	) { /* variable blocksize */
		if(!FLAC__bitreader_read_utf8_uint64(decoder->private_->input, &xx, raw_header, &raw_header_len))
			return false; /* read_callback_ sets the state for us */
		if(xx == FLAC__U64L(0xffffffffffffffff)) { /* i.e. non-UTF8 code... */
			decoder->private_->lookahead = raw_header[raw_header_len-1]; /* back up as much as we can */
			decoder->private_->cached = true;
			send_error_to_client_(decoder, FLAC__STREAM_DECODER_ERROR_STATUS_BAD_HEADER);
			decoder->protected_->state = FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC;
			return true;
		}
		decoder->private_->frame.header.number_type = FLAC__FRAME_NUMBER_TYPE_SAMPLE_NUMBER;
		decoder->private_->frame.header.number.sample_number = xx;
	}
	else { /* fixed blocksize */
		if(!FLAC__bitreader_read_utf8_uint32(decoder->private_->input, &x, raw_header, &raw_header_len))
			return false; /* read_callback_ sets the state for us */
		if(x == 0xffffffff) { /* i.e. non-UTF8 code... */
			decoder->private_->lookahead = raw_header[raw_header_len-1]; /* back up as much as we can */
			decoder->private_->cached = true;
			send_error_to_client_(decoder, FLAC__STREAM_DECODER_ERROR_STATUS_BAD_HEADER);
			decoder->protected_->state = FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC;
			return true;
		}
		decoder->private_->frame.header.number_type = FLAC__FRAME_NUMBER_TYPE_FRAME_NUMBER;
		decoder->private_->frame.header.number.frame_number = x;
	}

	if(blocksize_hint) {
		if(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, 8))
			return false; /* read_callback_ sets the state for us */
		raw_header[raw_header_len++] = (FLAC__byte)x;
		if(blocksize_hint == 7) {
			FLAC__uint32 _x;
			if(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &_x, 8))
				return false; /* read_callback_ sets the state for us */
			raw_header[raw_header_len++] = (FLAC__byte)_x;
			x = (x << 8) | _x;
		}
		decoder->private_->frame.header.blocksize = x+1;
	}

	if(sample_rate_hint) {
		if(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, 8))
			return false; /* read_callback_ sets the state for us */
		raw_header[raw_header_len++] = (FLAC__byte)x;
		if(sample_rate_hint != 12) {
			FLAC__uint32 _x;
			if(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &_x, 8))
				return false; /* read_callback_ sets the state for us */
			raw_header[raw_header_len++] = (FLAC__byte)_x;
			x = (x << 8) | _x;
		}
		if(sample_rate_hint == 12)
			decoder->private_->frame.header.sample_rate = x*1000;
		else if(sample_rate_hint == 13)
			decoder->private_->frame.header.sample_rate = x;
		else
			decoder->private_->frame.header.sample_rate = x*10;
	}

	/* read the CRC-8 byte */
	if(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, 8))
		return false; /* read_callback_ sets the state for us */
	crc8 = (FLAC__byte)x;

	if(FLAC__crc8(raw_header, raw_header_len) != crc8) {
		send_error_to_client_(decoder, FLAC__STREAM_DECODER_ERROR_STATUS_BAD_HEADER);
		decoder->protected_->state = FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC;
		return true;
	}

	/* calculate the sample number from the frame number if needed */
	decoder->private_->next_fixed_block_size = 0;
	if(decoder->private_->frame.header.number_type == FLAC__FRAME_NUMBER_TYPE_FRAME_NUMBER) {
		x = decoder->private_->frame.header.number.frame_number;
		decoder->private_->frame.header.number_type = FLAC__FRAME_NUMBER_TYPE_SAMPLE_NUMBER;
		if(decoder->private_->fixed_block_size)
			decoder->private_->frame.header.number.sample_number = (FLAC__uint64)decoder->private_->fixed_block_size * (FLAC__uint64)x;
		else if(decoder->private_->has_stream_info) {
			if(decoder->private_->stream_info.data.stream_info.min_blocksize == decoder->private_->stream_info.data.stream_info.max_blocksize) {
				decoder->private_->frame.header.number.sample_number = (FLAC__uint64)decoder->private_->stream_info.data.stream_info.min_blocksize * (FLAC__uint64)x;
				decoder->private_->next_fixed_block_size = decoder->private_->stream_info.data.stream_info.max_blocksize;
			}
			else
				is_unparseable = true;
		}
		else if(x == 0) {
			decoder->private_->frame.header.number.sample_number = 0;
			decoder->private_->next_fixed_block_size = decoder->private_->frame.header.blocksize;
		}
		else {
			/* can only get here if the stream has invalid frame numbering and no STREAMINFO, so assume it's not the last (possibly short) frame */
			decoder->private_->frame.header.number.sample_number = (FLAC__uint64)decoder->private_->frame.header.blocksize * (FLAC__uint64)x;
		}
	}

	if(is_unparseable) {
		send_error_to_client_(decoder, FLAC__STREAM_DECODER_ERROR_STATUS_UNPARSEABLE_STREAM);
		decoder->protected_->state = FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC;
		return true;
	}

	return true;
}

FLAC__bool read_subframe_(FLAC__StreamDecoder *decoder, unsigned channel, unsigned bps, FLAC__bool do_full_decode)
{
	FLAC__uint32 x;
	FLAC__bool wasted_bits;
	unsigned i;

	if(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &x, 8)) /* MAGIC NUMBER */
		return false; /* read_callback_ sets the state for us */

	wasted_bits = (x & 1);
	x &= 0xfe;

	if(wasted_bits) {
		unsigned u;
		if(!FLAC__bitreader_read_unary_unsigned(decoder->private_->input, &u))
			return false; /* read_callback_ sets the state for us */
		decoder->private_->frame.subframes[channel].wasted_bits = u+1;
		bps -= decoder->private_->frame.subframes[channel].wasted_bits;
	}
	else
		decoder->private_->frame.subframes[channel].wasted_bits = 0;

	/*
	 * Lots of magic numbers here
	 */
	if(x & 0x80) {
		send_error_to_client_(decoder, FLAC__STREAM_DECODER_ERROR_STATUS_LOST_SYNC);
		decoder->protected_->state = FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC;
		return true;
	}
	else if(x == 0) {
		if(!read_subframe_constant_(decoder, channel, bps, do_full_decode))
			return false;
	}
	else if(x == 2) {
		if(!read_subframe_verbatim_(decoder, channel, bps, do_full_decode))
			return false;
	}
	else if(x < 16) {
		send_error_to_client_(decoder, FLAC__STREAM_DECODER_ERROR_STATUS_UNPARSEABLE_STREAM);
		decoder->protected_->state = FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC;
		return true;
	}
	else if(x <= 24) {
		if(!read_subframe_fixed_(decoder, channel, bps, (x>>1)&7, do_full_decode))
			return false;
		if(decoder->protected_->state == FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC) /* means bad sync or got corruption */
			return true;
	}
	else if(x < 64) {
		send_error_to_client_(decoder, FLAC__STREAM_DECODER_ERROR_STATUS_UNPARSEABLE_STREAM);
		decoder->protected_->state = FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC;
		return true;
	}
	else {
		if(!read_subframe_lpc_(decoder, channel, bps, ((x>>1)&31)+1, do_full_decode))
			return false;
		if(decoder->protected_->state == FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC) /* means bad sync or got corruption */
			return true;
	}

	if(wasted_bits && do_full_decode) {
		x = decoder->private_->frame.subframes[channel].wasted_bits;
		for(i = 0; i < decoder->private_->frame.header.blocksize; i++)
			decoder->private_->output[channel][i] <<= x;
	}

	return true;
}

FLAC__bool read_subframe_constant_(FLAC__StreamDecoder *decoder, unsigned channel, unsigned bps, FLAC__bool do_full_decode)
{
	FLAC__Subframe_Constant *subframe = &decoder->private_->frame.subframes[channel].data.constant;
	FLAC__int32 x;
	unsigned i;
	FLAC__int32 *output = decoder->private_->output[channel];

	decoder->private_->frame.subframes[channel].type = FLAC__SUBFRAME_TYPE_CONSTANT;

	if(!FLAC__bitreader_read_raw_int32(decoder->private_->input, &x, bps))
		return false; /* read_callback_ sets the state for us */

	subframe->value = x;

	/* decode the subframe */
	if(do_full_decode) {
		for(i = 0; i < decoder->private_->frame.header.blocksize; i++)
			output[i] = x;
	}

	return true;
}

FLAC__bool read_subframe_fixed_(FLAC__StreamDecoder *decoder, unsigned channel, unsigned bps, const unsigned order, FLAC__bool do_full_decode)
{
	FLAC__Subframe_Fixed *subframe = &decoder->private_->frame.subframes[channel].data.fixed;
	FLAC__int32 i32;
	FLAC__uint32 u32;
	unsigned u;

	decoder->private_->frame.subframes[channel].type = FLAC__SUBFRAME_TYPE_FIXED;

	subframe->residual = decoder->private_->residual[channel];
	subframe->order = order;

	/* read warm-up samples */
	for(u = 0; u < order; u++) {
		if(!FLAC__bitreader_read_raw_int32(decoder->private_->input, &i32, bps))
			return false; /* read_callback_ sets the state for us */
		subframe->warmup[u] = i32;
	}

	/* read entropy coding method info */
	if(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &u32, FLAC__ENTROPY_CODING_METHOD_TYPE_LEN))
		return false; /* read_callback_ sets the state for us */
	subframe->entropy_coding_method.type = (FLAC__EntropyCodingMethodType)u32;
	switch(subframe->entropy_coding_method.type) {
		case FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE:
		case FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2:
			if(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &u32, FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_ORDER_LEN))
				return false; /* read_callback_ sets the state for us */
			subframe->entropy_coding_method.data.partitioned_rice.order = u32;
			subframe->entropy_coding_method.data.partitioned_rice.contents = &decoder->private_->partitioned_rice_contents[channel];
			break;
		default:
			send_error_to_client_(decoder, FLAC__STREAM_DECODER_ERROR_STATUS_UNPARSEABLE_STREAM);
			decoder->protected_->state = FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC;
			return true;
	}

	/* read residual */
	switch(subframe->entropy_coding_method.type) {
		case FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE:
		case FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2:
			if(!read_residual_partitioned_rice_(decoder, order, subframe->entropy_coding_method.data.partitioned_rice.order, &decoder->private_->partitioned_rice_contents[channel], decoder->private_->residual[channel], /*is_extended=*/subframe->entropy_coding_method.type == FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2))
				return false;
			break;
		default:
			FLAC__ASSERT(0);
	}

	/* decode the subframe */
	if(do_full_decode) {
		memcpy(decoder->private_->output[channel], subframe->warmup, sizeof(FLAC__int32) * order);
		FLAC__fixed_restore_signal(decoder->private_->residual[channel], decoder->private_->frame.header.blocksize-order, order, decoder->private_->output[channel]+order);
	}

	return true;
}

FLAC__bool read_subframe_lpc_(FLAC__StreamDecoder *decoder, unsigned channel, unsigned bps, const unsigned order, FLAC__bool do_full_decode)
{
	FLAC__Subframe_LPC *subframe = &decoder->private_->frame.subframes[channel].data.lpc;
	FLAC__int32 i32;
	FLAC__uint32 u32;
	unsigned u;

	decoder->private_->frame.subframes[channel].type = FLAC__SUBFRAME_TYPE_LPC;

	subframe->residual = decoder->private_->residual[channel];
	subframe->order = order;

	/* read warm-up samples */
	for(u = 0; u < order; u++) {
		if(!FLAC__bitreader_read_raw_int32(decoder->private_->input, &i32, bps))
			return false; /* read_callback_ sets the state for us */
		subframe->warmup[u] = i32;
	}

	/* read qlp coeff precision */
	if(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &u32, FLAC__SUBFRAME_LPC_QLP_COEFF_PRECISION_LEN))
		return false; /* read_callback_ sets the state for us */
	if(u32 == (1u << FLAC__SUBFRAME_LPC_QLP_COEFF_PRECISION_LEN) - 1) {
		send_error_to_client_(decoder, FLAC__STREAM_DECODER_ERROR_STATUS_LOST_SYNC);
		decoder->protected_->state = FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC;
		return true;
	}
	subframe->qlp_coeff_precision = u32+1;

	/* read qlp shift */
	if(!FLAC__bitreader_read_raw_int32(decoder->private_->input, &i32, FLAC__SUBFRAME_LPC_QLP_SHIFT_LEN))
		return false; /* read_callback_ sets the state for us */
	subframe->quantization_level = i32;

	/* read quantized lp coefficiencts */
	for(u = 0; u < order; u++) {
		if(!FLAC__bitreader_read_raw_int32(decoder->private_->input, &i32, subframe->qlp_coeff_precision))
			return false; /* read_callback_ sets the state for us */
		subframe->qlp_coeff[u] = i32;
	}

	/* read entropy coding method info */
	if(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &u32, FLAC__ENTROPY_CODING_METHOD_TYPE_LEN))
		return false; /* read_callback_ sets the state for us */
	subframe->entropy_coding_method.type = (FLAC__EntropyCodingMethodType)u32;
	switch(subframe->entropy_coding_method.type) {
		case FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE:
		case FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2:
			if(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &u32, FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_ORDER_LEN))
				return false; /* read_callback_ sets the state for us */
			subframe->entropy_coding_method.data.partitioned_rice.order = u32;
			subframe->entropy_coding_method.data.partitioned_rice.contents = &decoder->private_->partitioned_rice_contents[channel];
			break;
		default:
			send_error_to_client_(decoder, FLAC__STREAM_DECODER_ERROR_STATUS_UNPARSEABLE_STREAM);
			decoder->protected_->state = FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC;
			return true;
	}

	/* read residual */
	switch(subframe->entropy_coding_method.type) {
		case FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE:
		case FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2:
			if(!read_residual_partitioned_rice_(decoder, order, subframe->entropy_coding_method.data.partitioned_rice.order, &decoder->private_->partitioned_rice_contents[channel], decoder->private_->residual[channel], /*is_extended=*/subframe->entropy_coding_method.type == FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2))
				return false;
			break;
		default:
			FLAC__ASSERT(0);
	}

	/* decode the subframe */
	if(do_full_decode) {
		memcpy(decoder->private_->output[channel], subframe->warmup, sizeof(FLAC__int32) * order);
		/*@@@@@@ technically not pessimistic enough, should be more like
		if( (FLAC__uint64)order * ((((FLAC__uint64)1)<<bps)-1) * ((1<<subframe->qlp_coeff_precision)-1) < (((FLAC__uint64)-1) << 32) )
		*/
		if(bps + subframe->qlp_coeff_precision + FLAC__bitmath_ilog2(order) <= 32)
			if(bps <= 16 && subframe->qlp_coeff_precision <= 16) {
				if(order <= 8)
					decoder->private_->local_lpc_restore_signal_16bit_order8(decoder->private_->residual[channel], decoder->private_->frame.header.blocksize-order, subframe->qlp_coeff, order, subframe->quantization_level, decoder->private_->output[channel]+order);
				else
					decoder->private_->local_lpc_restore_signal_16bit(decoder->private_->residual[channel], decoder->private_->frame.header.blocksize-order, subframe->qlp_coeff, order, subframe->quantization_level, decoder->private_->output[channel]+order);
			}
			else
				decoder->private_->local_lpc_restore_signal(decoder->private_->residual[channel], decoder->private_->frame.header.blocksize-order, subframe->qlp_coeff, order, subframe->quantization_level, decoder->private_->output[channel]+order);
		else
			decoder->private_->local_lpc_restore_signal_64bit(decoder->private_->residual[channel], decoder->private_->frame.header.blocksize-order, subframe->qlp_coeff, order, subframe->quantization_level, decoder->private_->output[channel]+order);
	}

	return true;
}

FLAC__bool read_subframe_verbatim_(FLAC__StreamDecoder *decoder, unsigned channel, unsigned bps, FLAC__bool do_full_decode)
{
	FLAC__Subframe_Verbatim *subframe = &decoder->private_->frame.subframes[channel].data.verbatim;
	FLAC__int32 x, *residual = decoder->private_->residual[channel];
	unsigned i;

	decoder->private_->frame.subframes[channel].type = FLAC__SUBFRAME_TYPE_VERBATIM;

	subframe->data = residual;

	for(i = 0; i < decoder->private_->frame.header.blocksize; i++) {
		if(!FLAC__bitreader_read_raw_int32(decoder->private_->input, &x, bps))
			return false; /* read_callback_ sets the state for us */
		residual[i] = x;
	}

	/* decode the subframe */
	if(do_full_decode)
		memcpy(decoder->private_->output[channel], subframe->data, sizeof(FLAC__int32) * decoder->private_->frame.header.blocksize);

	return true;
}

FLAC__bool read_residual_partitioned_rice_(FLAC__StreamDecoder *decoder, unsigned predictor_order, unsigned partition_order, FLAC__EntropyCodingMethod_PartitionedRiceContents *partitioned_rice_contents, FLAC__int32 *residual, FLAC__bool is_extended)
{
	FLAC__uint32 rice_parameter;
	int i;
	unsigned partition, sample, u;
	const unsigned partitions = 1u << partition_order;
	const unsigned partition_samples = partition_order > 0? decoder->private_->frame.header.blocksize >> partition_order : decoder->private_->frame.header.blocksize - predictor_order;
	const unsigned plen = is_extended? FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2_PARAMETER_LEN : FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_PARAMETER_LEN;
	const unsigned pesc = is_extended? FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2_ESCAPE_PARAMETER : FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_ESCAPE_PARAMETER;

	/* sanity checks */
	if(partition_order == 0) {
		if(decoder->private_->frame.header.blocksize < predictor_order) {
			send_error_to_client_(decoder, FLAC__STREAM_DECODER_ERROR_STATUS_LOST_SYNC);
			decoder->protected_->state = FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC;
			return true;
		}
	}
	else {
		if(partition_samples < predictor_order) {
			send_error_to_client_(decoder, FLAC__STREAM_DECODER_ERROR_STATUS_LOST_SYNC);
			decoder->protected_->state = FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC;
			return true;
		}
	}

	if(!FLAC__format_entropy_coding_method_partitioned_rice_contents_ensure_size(partitioned_rice_contents, max(6, partition_order))) {
		decoder->protected_->state = FLAC__STREAM_DECODER_MEMORY_ALLOCATION_ERROR;
		return false;
	}

	sample = 0;
	for(partition = 0; partition < partitions; partition++) {
		if(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &rice_parameter, plen))
			return false; /* read_callback_ sets the state for us */
		partitioned_rice_contents->parameters[partition] = rice_parameter;
		if(rice_parameter < pesc) {
			partitioned_rice_contents->raw_bits[partition] = 0;
			u = (partition_order == 0 || partition > 0)? partition_samples : partition_samples - predictor_order;
			if(!decoder->private_->local_bitreader_read_rice_signed_block(decoder->private_->input, (int*) residual + sample, u, rice_parameter))
				return false; /* read_callback_ sets the state for us */
			sample += u;
		}
		else {
			if(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &rice_parameter, FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_RAW_LEN))
				return false; /* read_callback_ sets the state for us */
			partitioned_rice_contents->raw_bits[partition] = rice_parameter;
			for(u = (partition_order == 0 || partition > 0)? 0 : predictor_order; u < partition_samples; u++, sample++) {
				if(!FLAC__bitreader_read_raw_int32(decoder->private_->input, (FLAC__int32*) &i, rice_parameter))
					return false; /* read_callback_ sets the state for us */
				residual[sample] = i;
			}
		}
	}

	return true;
}

FLAC__bool read_zero_padding_(FLAC__StreamDecoder *decoder)
{
	if(!FLAC__bitreader_is_consumed_byte_aligned(decoder->private_->input)) {
		FLAC__uint32 zero = 0;
		if(!FLAC__bitreader_read_raw_uint32(decoder->private_->input, &zero, FLAC__bitreader_bits_left_for_byte_alignment(decoder->private_->input)))
			return false; /* read_callback_ sets the state for us */
		if(zero != 0) {
			send_error_to_client_(decoder, FLAC__STREAM_DECODER_ERROR_STATUS_LOST_SYNC);
			decoder->protected_->state = FLAC__STREAM_DECODER_SEARCH_FOR_FRAME_SYNC;
		}
	}
	return true;
}

FLAC__bool read_callback_(FLAC__byte buffer[], size_t *bytes, void *client_data)
{
	FLAC__StreamDecoder *decoder = (FLAC__StreamDecoder *)client_data;

	if(
#if FLAC__HAS_OGG
		/* see [1] HACK NOTE below for why we don't call the eof_callback when decoding Ogg FLAC */
		!decoder->private_->is_ogg &&
#endif
		decoder->private_->eof_callback && decoder->private_->eof_callback(decoder, decoder->private_->client_data)
	) {
		*bytes = 0;
		decoder->protected_->state = FLAC__STREAM_DECODER_END_OF_STREAM;
		return false;
	}
	else if(*bytes > 0) {
		/* While seeking, it is possible for our seek to land in the
		 * middle of audio data that looks exactly like a frame header
		 * from a future version of an encoder.  When that happens, our
		 * error callback will get an
		 * FLAC__STREAM_DECODER_UNPARSEABLE_STREAM and increment its
		 * unparseable_frame_count.  But there is a remote possibility
		 * that it is properly synced at such a "future-codec frame",
		 * so to make sure, we wait to see many "unparseable" errors in
		 * a row before bailing out.
		 */
		if(decoder->private_->is_seeking && decoder->private_->unparseable_frame_count > 20) {
			decoder->protected_->state = FLAC__STREAM_DECODER_ABORTED;
			return false;
		}
		else {
			const FLAC__StreamDecoderReadStatus status =
#if FLAC__HAS_OGG
				decoder->private_->is_ogg?
				read_callback_ogg_aspect_(decoder, buffer, bytes) :
#endif
				decoder->private_->read_callback(decoder, buffer, bytes, decoder->private_->client_data)
			;
			if(status == FLAC__STREAM_DECODER_READ_STATUS_ABORT) {
				decoder->protected_->state = FLAC__STREAM_DECODER_ABORTED;
				return false;
			}
			else if(*bytes == 0) {
				if(
					status == FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM ||
					(
#if FLAC__HAS_OGG
						/* see [1] HACK NOTE below for why we don't call the eof_callback when decoding Ogg FLAC */
						!decoder->private_->is_ogg &&
#endif
						decoder->private_->eof_callback && decoder->private_->eof_callback(decoder, decoder->private_->client_data)
					)
				) {
					decoder->protected_->state = FLAC__STREAM_DECODER_END_OF_STREAM;
					return false;
				}
				else
					return true;
			}
			else
				return true;
		}
	}
	else {
		/* abort to avoid a deadlock */
		decoder->protected_->state = FLAC__STREAM_DECODER_ABORTED;
		return false;
	}
	/* [1] @@@ HACK NOTE: The end-of-stream checking has to be hacked around
	 * for Ogg FLAC.  This is because the ogg decoder aspect can lose sync
	 * and at the same time hit the end of the stream (for example, seeking
	 * to a point that is after the beginning of the last Ogg page).  There
	 * is no way to report an Ogg sync loss through the callbacks (see note
	 * in read_callback_ogg_aspect_()) so it returns CONTINUE with *bytes==0.
	 * So to keep the decoder from stopping at this point we gate the call
	 * to the eof_callback and let the Ogg decoder aspect set the
	 * end-of-stream state when it is needed.
	 */
}

#if FLAC__HAS_OGG
FLAC__StreamDecoderReadStatus read_callback_ogg_aspect_(const FLAC__StreamDecoder *decoder, FLAC__byte buffer[], size_t *bytes)
{
	switch(FLAC__ogg_decoder_aspect_read_callback_wrapper(&decoder->protected_->ogg_decoder_aspect, buffer, bytes, read_callback_proxy_, decoder, decoder->private_->client_data)) {
		case FLAC__OGG_DECODER_ASPECT_READ_STATUS_OK:
			return FLAC__STREAM_DECODER_READ_STATUS_CONTINUE;
		/* we don't really have a way to handle lost sync via read
		 * callback so we'll let it pass and let the underlying
		 * FLAC decoder catch the error
		 */
		case FLAC__OGG_DECODER_ASPECT_READ_STATUS_LOST_SYNC:
			return FLAC__STREAM_DECODER_READ_STATUS_CONTINUE;
		case FLAC__OGG_DECODER_ASPECT_READ_STATUS_END_OF_STREAM:
			return FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM;
		case FLAC__OGG_DECODER_ASPECT_READ_STATUS_NOT_FLAC:
		case FLAC__OGG_DECODER_ASPECT_READ_STATUS_UNSUPPORTED_MAPPING_VERSION:
		case FLAC__OGG_DECODER_ASPECT_READ_STATUS_ABORT:
		case FLAC__OGG_DECODER_ASPECT_READ_STATUS_ERROR:
		case FLAC__OGG_DECODER_ASPECT_READ_STATUS_MEMORY_ALLOCATION_ERROR:
			return FLAC__STREAM_DECODER_READ_STATUS_ABORT;
		default:
			FLAC__ASSERT(0);
			/* double protection */
			return FLAC__STREAM_DECODER_READ_STATUS_ABORT;
	}
}

FLAC__OggDecoderAspectReadStatus read_callback_proxy_(const void *void_decoder, FLAC__byte buffer[], size_t *bytes, void *client_data)
{
	FLAC__StreamDecoder *decoder = (FLAC__StreamDecoder*)void_decoder;

	switch(decoder->private_->read_callback(decoder, buffer, bytes, client_data)) {
		case FLAC__STREAM_DECODER_READ_STATUS_CONTINUE:
			return FLAC__OGG_DECODER_ASPECT_READ_STATUS_OK;
		case FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM:
			return FLAC__OGG_DECODER_ASPECT_READ_STATUS_END_OF_STREAM;
		case FLAC__STREAM_DECODER_READ_STATUS_ABORT:
			return FLAC__OGG_DECODER_ASPECT_READ_STATUS_ABORT;
		default:
			/* double protection: */
			FLAC__ASSERT(0);
			return FLAC__OGG_DECODER_ASPECT_READ_STATUS_ABORT;
	}
}
#endif

FLAC__StreamDecoderWriteStatus write_audio_frame_to_client_(FLAC__StreamDecoder *decoder, const FLAC__Frame *frame, const FLAC__int32 * const buffer[])
{
	if(decoder->private_->is_seeking) {
		FLAC__uint64 this_frame_sample = frame->header.number.sample_number;
		FLAC__uint64 next_frame_sample = this_frame_sample + (FLAC__uint64)frame->header.blocksize;
		FLAC__uint64 target_sample = decoder->private_->target_sample;

		FLAC__ASSERT(frame->header.number_type == FLAC__FRAME_NUMBER_TYPE_SAMPLE_NUMBER);

#if FLAC__HAS_OGG
		decoder->private_->got_a_frame = true;
#endif
		decoder->private_->last_frame = *frame; /* save the frame */
		if(this_frame_sample <= target_sample && target_sample < next_frame_sample) { /* we hit our target frame */
			unsigned delta = (unsigned)(target_sample - this_frame_sample);
			/* kick out of seek mode */
			decoder->private_->is_seeking = false;
			/* shift out the samples before target_sample */
			if(delta > 0) {
				unsigned channel;
				const FLAC__int32 *newbuffer[FLAC__MAX_CHANNELS];
				for(channel = 0; channel < frame->header.channels; channel++)
					newbuffer[channel] = buffer[channel] + delta;
				decoder->private_->last_frame.header.blocksize -= delta;
				decoder->private_->last_frame.header.number.sample_number += (FLAC__uint64)delta;
				/* write the relevant samples */
				return decoder->private_->write_callback(decoder, &decoder->private_->last_frame, newbuffer, decoder->private_->client_data);
			}
			else {
				/* write the relevant samples */
				return decoder->private_->write_callback(decoder, frame, buffer, decoder->private_->client_data);
			}
		}

		return FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE;
	}

	/*
	 * If we never got STREAMINFO, turn off MD5 checking to save
	 * cycles since we don't have a sum to compare to anyway
	 */
	if(!decoder->private_->has_stream_info)
		decoder->private_->do_md5_checking = false;
	if(decoder->private_->do_md5_checking) {
		if(!FLAC__MD5Accumulate(&decoder->private_->md5context, buffer, frame->header.channels, frame->header.blocksize, (frame->header.bits_per_sample+7) / 8))
			return FLAC__STREAM_DECODER_WRITE_STATUS_ABORT;
	}

	return decoder->private_->write_callback(decoder, frame, buffer, decoder->private_->client_data);
}

void send_error_to_client_(const FLAC__StreamDecoder *decoder, FLAC__StreamDecoderErrorStatus status)
{
	if(!decoder->private_->is_seeking)
		decoder->private_->error_callback(decoder, status, decoder->private_->client_data);
	else if(status == FLAC__STREAM_DECODER_ERROR_STATUS_UNPARSEABLE_STREAM)
		decoder->private_->unparseable_frame_count++;
}

FLAC__bool seek_to_absolute_sample_(FLAC__StreamDecoder *decoder, FLAC__uint64 stream_length, FLAC__uint64 target_sample)
{
	FLAC__uint64 first_frame_offset = decoder->private_->first_frame_offset, lower_bound, upper_bound, lower_bound_sample, upper_bound_sample, this_frame_sample;
	FLAC__int64 pos = -1;
	int i;
	unsigned approx_bytes_per_frame;
	FLAC__bool first_seek = true;
	const FLAC__uint64 total_samples = FLAC__stream_decoder_get_total_samples(decoder);
	const unsigned min_blocksize = decoder->private_->stream_info.data.stream_info.min_blocksize;
	const unsigned max_blocksize = decoder->private_->stream_info.data.stream_info.max_blocksize;
	const unsigned max_framesize = decoder->private_->stream_info.data.stream_info.max_framesize;
	const unsigned min_framesize = decoder->private_->stream_info.data.stream_info.min_framesize;
	/* take these from the current frame in case they've changed mid-stream */
	unsigned channels = FLAC__stream_decoder_get_channels(decoder);
	unsigned bps = FLAC__stream_decoder_get_bits_per_sample(decoder);
	const FLAC__StreamMetadata_SeekTable *seek_table = decoder->private_->has_seek_table? &decoder->private_->seek_table.data.seek_table : 0;

	/* use values from stream info if we didn't decode a frame */
	if(channels == 0)
		channels = decoder->private_->stream_info.data.stream_info.channels;
	if(bps == 0)
		bps = decoder->private_->stream_info.data.stream_info.bits_per_sample;

	/* we are just guessing here */
	if(max_framesize > 0)
		approx_bytes_per_frame = (max_framesize + min_framesize) / 2 + 1;
	/*
	 * Check if it's a known fixed-blocksize stream.  Note that though
	 * the spec doesn't allow zeroes in the STREAMINFO block, we may
	 * never get a STREAMINFO block when decoding so the value of
	 * min_blocksize might be zero.
	 */
	else if(min_blocksize == max_blocksize && min_blocksize > 0) {
		/* note there are no () around 'bps/8' to keep precision up since it's an integer calulation */
		approx_bytes_per_frame = min_blocksize * channels * bps/8 + 64;
	}
	else
		approx_bytes_per_frame = 4096 * channels * bps/8 + 64;

	/*
	 * First, we set an upper and lower bound on where in the
	 * stream we will search.  For now we assume the worst case
	 * scenario, which is our best guess at the beginning of
	 * the first frame and end of the stream.
	 */
	lower_bound = first_frame_offset;
	lower_bound_sample = 0;
	upper_bound = stream_length;
	upper_bound_sample = total_samples > 0 ? total_samples : target_sample /*estimate it*/;

	/*
	 * Now we refine the bounds if we have a seektable with
	 * suitable points.  Note that according to the spec they
	 * must be ordered by ascending sample number.
	 *
	 * Note: to protect against invalid seek tables we will ignore points
	 * that have frame_samples==0 or sample_number>=total_samples
	 */
	if(seek_table) {
		FLAC__uint64 new_lower_bound = lower_bound;
		FLAC__uint64 new_upper_bound = upper_bound;
		FLAC__uint64 new_lower_bound_sample = lower_bound_sample;
		FLAC__uint64 new_upper_bound_sample = upper_bound_sample;

		/* find the closest seek point <= target_sample, if it exists */
		for(i = (int)seek_table->num_points - 1; i >= 0; i--) {
			if(
				seek_table->points[i].sample_number != FLAC__STREAM_METADATA_SEEKPOINT_PLACEHOLDER &&
				seek_table->points[i].frame_samples > 0 && /* defense against bad seekpoints */
				(total_samples <= 0 || seek_table->points[i].sample_number < total_samples) && /* defense against bad seekpoints */
				seek_table->points[i].sample_number <= target_sample
			)
				break;
		}
		if(i >= 0) { /* i.e. we found a suitable seek point... */
			new_lower_bound = first_frame_offset + seek_table->points[i].stream_offset;
			new_lower_bound_sample = seek_table->points[i].sample_number;
		}

		/* find the closest seek point > target_sample, if it exists */
		for(i = 0; i < (int)seek_table->num_points; i++) {
			if(
				seek_table->points[i].sample_number != FLAC__STREAM_METADATA_SEEKPOINT_PLACEHOLDER &&
				seek_table->points[i].frame_samples > 0 && /* defense against bad seekpoints */
				(total_samples <= 0 || seek_table->points[i].sample_number < total_samples) && /* defense against bad seekpoints */
				seek_table->points[i].sample_number > target_sample
			)
				break;
		}
		if(i < (int)seek_table->num_points) { /* i.e. we found a suitable seek point... */
			new_upper_bound = first_frame_offset + seek_table->points[i].stream_offset;
			new_upper_bound_sample = seek_table->points[i].sample_number;
		}
		/* final protection against unsorted seek tables; keep original values if bogus */
		if(new_upper_bound >= new_lower_bound) {
			lower_bound = new_lower_bound;
			upper_bound = new_upper_bound;
			lower_bound_sample = new_lower_bound_sample;
			upper_bound_sample = new_upper_bound_sample;
		}
	}

	FLAC__ASSERT(upper_bound_sample >= lower_bound_sample);
	/* there are 2 insidious ways that the following equality occurs, which
	 * we need to fix:
	 *  1) total_samples is 0 (unknown) and target_sample is 0
	 *  2) total_samples is 0 (unknown) and target_sample happens to be
	 *     exactly equal to the last seek point in the seek table; this
	 *     means there is no seek point above it, and upper_bound_samples
	 *     remains equal to the estimate (of target_samples) we made above
	 * in either case it does not hurt to move upper_bound_sample up by 1
	 */
	if(upper_bound_sample == lower_bound_sample)
		upper_bound_sample++;

	decoder->private_->target_sample = target_sample;
	while(1) {
		/* check if the bounds are still ok */
		if (lower_bound_sample >= upper_bound_sample || lower_bound > upper_bound) {
			decoder->protected_->state = FLAC__STREAM_DECODER_SEEK_ERROR;
			return false;
		}
#ifndef FLAC__INTEGER_ONLY_LIBRARY
#if defined _MSC_VER || defined __MINGW32__
		/* with VC++ you have to spoon feed it the casting */
		pos = (FLAC__int64)lower_bound + (FLAC__int64)((FLAC__double)(FLAC__int64)(target_sample - lower_bound_sample) / (FLAC__double)(FLAC__int64)(upper_bound_sample - lower_bound_sample) * (FLAC__double)(FLAC__int64)(upper_bound - lower_bound)) - approx_bytes_per_frame;
#else
		pos = (FLAC__int64)lower_bound + (FLAC__int64)((FLAC__double)(target_sample - lower_bound_sample) / (FLAC__double)(upper_bound_sample - lower_bound_sample) * (FLAC__double)(upper_bound - lower_bound)) - approx_bytes_per_frame;
#endif
#else
		/* a little less accurate: */
		if(upper_bound - lower_bound < 0xffffffff)
			pos = (FLAC__int64)lower_bound + (FLAC__int64)(((target_sample - lower_bound_sample) * (upper_bound - lower_bound)) / (upper_bound_sample - lower_bound_sample)) - approx_bytes_per_frame;
		else /* @@@ WATCHOUT, ~2TB limit */
			pos = (FLAC__int64)lower_bound + (FLAC__int64)((((target_sample - lower_bound_sample)>>8) * ((upper_bound - lower_bound)>>8)) / ((upper_bound_sample - lower_bound_sample)>>16)) - approx_bytes_per_frame;
#endif
		if(pos >= (FLAC__int64)upper_bound)
			pos = (FLAC__int64)upper_bound - 1;
		if(pos < (FLAC__int64)lower_bound)
			pos = (FLAC__int64)lower_bound;
		if(decoder->private_->seek_callback(decoder, (FLAC__uint64)pos, decoder->private_->client_data) != FLAC__STREAM_DECODER_SEEK_STATUS_OK) {
			decoder->protected_->state = FLAC__STREAM_DECODER_SEEK_ERROR;
			return false;
		}
		if(!FLAC__stream_decoder_flush(decoder)) {
			/* above call sets the state for us */
			return false;
		}
		/* Now we need to get a frame.  First we need to reset our
		 * unparseable_frame_count; if we get too many unparseable
		 * frames in a row, the read callback will return
		 * FLAC__STREAM_DECODER_READ_STATUS_ABORT, causing
		 * FLAC__stream_decoder_process_single() to return false.
		 */
		decoder->private_->unparseable_frame_count = 0;
		if(!FLAC__stream_decoder_process_single(decoder)) {
			decoder->protected_->state = FLAC__STREAM_DECODER_SEEK_ERROR;
			return false;
		}
		/* our write callback will change the state when it gets to the target frame */
		/* actually, we could have got_a_frame if our decoder is at FLAC__STREAM_DECODER_END_OF_STREAM so we need to check for that also */
#if 0
		/*@@@@@@ used to be the following; not clear if the check for end of stream is needed anymore */
		if(decoder->protected_->state != FLAC__SEEKABLE_STREAM_DECODER_SEEKING && decoder->protected_->state != FLAC__STREAM_DECODER_END_OF_STREAM)
			break;
#endif
		if(!decoder->private_->is_seeking)
			break;

		FLAC__ASSERT(decoder->private_->last_frame.header.number_type == FLAC__FRAME_NUMBER_TYPE_SAMPLE_NUMBER);
		this_frame_sample = decoder->private_->last_frame.header.number.sample_number;

		if (0 == decoder->private_->samples_decoded || (this_frame_sample + decoder->private_->last_frame.header.blocksize >= upper_bound_sample && !first_seek)) {
			if (pos == (FLAC__int64)lower_bound) {
				/* can't move back any more than the first frame, something is fatally wrong */
				decoder->protected_->state = FLAC__STREAM_DECODER_SEEK_ERROR;
				return false;
			}
			/* our last move backwards wasn't big enough, try again */
			approx_bytes_per_frame = approx_bytes_per_frame? approx_bytes_per_frame * 2 : 16;
			continue;
		}
		/* allow one seek over upper bound, so we can get a correct upper_bound_sample for streams with unknown total_samples */
		first_seek = false;

		/* make sure we are not seeking in corrupted stream */
		if (this_frame_sample < lower_bound_sample) {
			decoder->protected_->state = FLAC__STREAM_DECODER_SEEK_ERROR;
			return false;
		}

		/* we need to narrow the search */
		if(target_sample < this_frame_sample) {
			upper_bound_sample = this_frame_sample + decoder->private_->last_frame.header.blocksize;
/*@@@@@@ what will decode position be if at end of stream? */
			if(!FLAC__stream_decoder_get_decode_position(decoder, &upper_bound)) {
				decoder->protected_->state = FLAC__STREAM_DECODER_SEEK_ERROR;
				return false;
			}
			approx_bytes_per_frame = (unsigned)(2 * (upper_bound - pos) / 3 + 16);
		}
		else { /* target_sample >= this_frame_sample + this frame's blocksize */
			lower_bound_sample = this_frame_sample + decoder->private_->last_frame.header.blocksize;
			if(!FLAC__stream_decoder_get_decode_position(decoder, &lower_bound)) {
				decoder->protected_->state = FLAC__STREAM_DECODER_SEEK_ERROR;
				return false;
			}
			approx_bytes_per_frame = (unsigned)(2 * (lower_bound - pos) / 3 + 16);
		}
	}

	return true;
}

#if FLAC__HAS_OGG
FLAC__bool seek_to_absolute_sample_ogg_(FLAC__StreamDecoder *decoder, FLAC__uint64 stream_length, FLAC__uint64 target_sample)
{
	FLAC__uint64 left_pos = 0, right_pos = stream_length;
	FLAC__uint64 left_sample = 0, right_sample = FLAC__stream_decoder_get_total_samples(decoder);
	FLAC__uint64 this_frame_sample = (FLAC__uint64)0 - 1;
	FLAC__uint64 pos = 0; /* only initialized to avoid compiler warning */
	FLAC__bool did_a_seek;
	unsigned iteration = 0;

	/* In the first iterations, we will calculate the target byte position
	 * by the distance from the target sample to left_sample and
	 * right_sample (let's call it "proportional search").  After that, we
	 * will switch to binary search.
	 */
	unsigned BINARY_SEARCH_AFTER_ITERATION = 2;

	/* We will switch to a linear search once our current sample is less
	 * than this number of samples ahead of the target sample
	 */
	static const FLAC__uint64 LINEAR_SEARCH_WITHIN_SAMPLES = FLAC__MAX_BLOCK_SIZE * 2;

	/* If the total number of samples is unknown, use a large value, and
	 * force binary search immediately.
	 */
	if(right_sample == 0) {
		right_sample = (FLAC__uint64)(-1);
		BINARY_SEARCH_AFTER_ITERATION = 0;
	}

	decoder->private_->target_sample = target_sample;
	for( ; ; iteration++) {
		if (iteration == 0 || this_frame_sample > target_sample || target_sample - this_frame_sample > LINEAR_SEARCH_WITHIN_SAMPLES) {
			if (iteration >= BINARY_SEARCH_AFTER_ITERATION) {
				pos = (right_pos + left_pos) / 2;
			}
			else {
#ifndef FLAC__INTEGER_ONLY_LIBRARY
#if defined _MSC_VER || defined __MINGW32__
				/* with MSVC you have to spoon feed it the casting */
				pos = (FLAC__uint64)((FLAC__double)(FLAC__int64)(target_sample - left_sample) / (FLAC__double)(FLAC__int64)(right_sample - left_sample) * (FLAC__double)(FLAC__int64)(right_pos - left_pos));
#else
				pos = (FLAC__uint64)((FLAC__double)(target_sample - left_sample) / (FLAC__double)(right_sample - left_sample) * (FLAC__double)(right_pos - left_pos));
#endif
#else
				/* a little less accurate: */
				if ((target_sample-left_sample <= 0xffffffff) && (right_pos-left_pos <= 0xffffffff))
					pos = (FLAC__int64)(((target_sample-left_sample) * (right_pos-left_pos)) / (right_sample-left_sample));
				else /* @@@ WATCHOUT, ~2TB limit */
					pos = (FLAC__int64)((((target_sample-left_sample)>>8) * ((right_pos-left_pos)>>8)) / ((right_sample-left_sample)>>16));
#endif
				/* @@@ TODO: might want to limit pos to some distance
				 * before EOF, to make sure we land before the last frame,
				 * thereby getting a this_frame_sample and so having a better
				 * estimate.
				 */
			}

			/* physical seek */
			if(decoder->private_->seek_callback((FLAC__StreamDecoder*)decoder, (FLAC__uint64)pos, decoder->private_->client_data) != FLAC__STREAM_DECODER_SEEK_STATUS_OK) {
				decoder->protected_->state = FLAC__STREAM_DECODER_SEEK_ERROR;
				return false;
			}
			if(!FLAC__stream_decoder_flush(decoder)) {
				/* above call sets the state for us */
				return false;
			}
			did_a_seek = true;
		}
		else
			did_a_seek = false;

		decoder->private_->got_a_frame = false;
		if(!FLAC__stream_decoder_process_single(decoder)) {
			decoder->protected_->state = FLAC__STREAM_DECODER_SEEK_ERROR;
			return false;
		}
		if(!decoder->private_->got_a_frame) {
			if(did_a_seek) {
				/* this can happen if we seek to a point after the last frame; we drop
				 * to binary search right away in this case to avoid any wasted
				 * iterations of proportional search.
				 */
				right_pos = pos;
				BINARY_SEARCH_AFTER_ITERATION = 0;
			}
			else {
				/* this can probably only happen if total_samples is unknown and the
				 * target_sample is past the end of the stream
				 */
				decoder->protected_->state = FLAC__STREAM_DECODER_SEEK_ERROR;
				return false;
			}
		}
		/* our write callback will change the state when it gets to the target frame */
		else if(!decoder->private_->is_seeking) {
			break;
		}
		else {
			this_frame_sample = decoder->private_->last_frame.header.number.sample_number;
			FLAC__ASSERT(decoder->private_->last_frame.header.number_type == FLAC__FRAME_NUMBER_TYPE_SAMPLE_NUMBER);

			if (did_a_seek) {
				if (this_frame_sample <= target_sample) {
					/* The 'equal' case should not happen, since
					 * FLAC__stream_decoder_process_single()
					 * should recognize that it has hit the
					 * target sample and we would exit through
					 * the 'break' above.
					 */
					FLAC__ASSERT(this_frame_sample != target_sample);

					left_sample = this_frame_sample;
					/* sanity check to avoid infinite loop */
					if (left_pos == pos) {
						decoder->protected_->state = FLAC__STREAM_DECODER_SEEK_ERROR;
						return false;
					}
					left_pos = pos;
				}
				else if(this_frame_sample > target_sample) {
					right_sample = this_frame_sample;
					/* sanity check to avoid infinite loop */
					if (right_pos == pos) {
						decoder->protected_->state = FLAC__STREAM_DECODER_SEEK_ERROR;
						return false;
					}
					right_pos = pos;
				}
			}
		}
	}

	return true;
}
#endif

FLAC__StreamDecoderReadStatus file_read_callback_dec(const FLAC__StreamDecoder *decoder, FLAC__byte buffer[], size_t *bytes, void *client_data)
{
	(void)client_data;

	if(*bytes > 0) {
		*bytes = fread(buffer, sizeof(FLAC__byte), *bytes, decoder->private_->file);
		if(ferror(decoder->private_->file))
			return FLAC__STREAM_DECODER_READ_STATUS_ABORT;
		else if(*bytes == 0)
			return FLAC__STREAM_DECODER_READ_STATUS_END_OF_STREAM;
		else
			return FLAC__STREAM_DECODER_READ_STATUS_CONTINUE;
	}
	else
		return FLAC__STREAM_DECODER_READ_STATUS_ABORT; /* abort to avoid a deadlock */
}

FLAC__StreamDecoderSeekStatus file_seek_callback_dec(const FLAC__StreamDecoder *decoder, FLAC__uint64 absolute_byte_offset, void *client_data)
{
	(void)client_data;

	if(decoder->private_->file == stdin)
		return FLAC__STREAM_DECODER_SEEK_STATUS_UNSUPPORTED;
	else if(fseeko(decoder->private_->file, (off_t)absolute_byte_offset, SEEK_SET) < 0)
		return FLAC__STREAM_DECODER_SEEK_STATUS_ERROR;
	else
		return FLAC__STREAM_DECODER_SEEK_STATUS_OK;
}

FLAC__StreamDecoderTellStatus file_tell_callback_dec(const FLAC__StreamDecoder *decoder, FLAC__uint64 *absolute_byte_offset, void *client_data)
{
	off_t pos;
	(void)client_data;

	if(decoder->private_->file == stdin)
		return FLAC__STREAM_DECODER_TELL_STATUS_UNSUPPORTED;
	else if((pos = ftello(decoder->private_->file)) < 0)
		return FLAC__STREAM_DECODER_TELL_STATUS_ERROR;
	else {
		*absolute_byte_offset = (FLAC__uint64)pos;
		return FLAC__STREAM_DECODER_TELL_STATUS_OK;
	}
}

FLAC__StreamDecoderLengthStatus file_length_callback_(const FLAC__StreamDecoder *decoder, FLAC__uint64 *stream_length, void *client_data)
{
	struct stat filestats;
	(void)client_data;

	if(decoder->private_->file == stdin)
		return FLAC__STREAM_DECODER_LENGTH_STATUS_UNSUPPORTED;
	else if(fstat(fileno(decoder->private_->file), &filestats) != 0)
		return FLAC__STREAM_DECODER_LENGTH_STATUS_ERROR;
	else {
		*stream_length = (FLAC__uint64)filestats.st_size;
		return FLAC__STREAM_DECODER_LENGTH_STATUS_OK;
	}
}

FLAC__bool file_eof_callback_(const FLAC__StreamDecoder *decoder, void *client_data)
{
	(void)client_data;

	return feof(decoder->private_->file)? true : false;
}

/*** End of inlined file: stream_decoder.c ***/


/*** Start of inlined file: stream_encoder.c ***/
#if HAVE_CONFIG_H
#  include <config.h>
#endif

#if defined _MSC_VER || defined __MINGW32__
#include <io.h> /* for _setmode() */
#include <fcntl.h> /* for _O_BINARY */
#endif
#if defined __CYGWIN__ || defined __EMX__
#include <io.h> /* for setmode(), O_BINARY */
#include <fcntl.h> /* for _O_BINARY */
#endif
#include <limits.h>
#include <stdio.h>
#include <stdlib.h> /* for malloc() */
#include <string.h> /* for memcpy() */
#include <sys/types.h> /* for off_t */
#if defined _MSC_VER || defined __BORLANDC__ || defined __MINGW32__
#if _MSC_VER <= 1600 || defined __BORLANDC__ /* @@@ [2G limit] */
#define fseeko fseek
#define ftello ftell
#endif
#endif


/*** Start of inlined file: stream_encoder.h ***/
#ifndef FLAC__PROTECTED__STREAM_ENCODER_H
#define FLAC__PROTECTED__STREAM_ENCODER_H

#if FLAC__HAS_OGG
#include "private/ogg_encoder_aspect.h"
#endif

#ifndef FLAC__INTEGER_ONLY_LIBRARY

#define FLAC__MAX_APODIZATION_FUNCTIONS 32

typedef enum {
	FLAC__APODIZATION_BARTLETT,
	FLAC__APODIZATION_BARTLETT_HANN,
	FLAC__APODIZATION_BLACKMAN,
	FLAC__APODIZATION_BLACKMAN_HARRIS_4TERM_92DB_SIDELOBE,
	FLAC__APODIZATION_CONNES,
	FLAC__APODIZATION_FLATTOP,
	FLAC__APODIZATION_GAUSS,
	FLAC__APODIZATION_HAMMING,
	FLAC__APODIZATION_HANN,
	FLAC__APODIZATION_KAISER_BESSEL,
	FLAC__APODIZATION_NUTTALL,
	FLAC__APODIZATION_RECTANGLE,
	FLAC__APODIZATION_TRIANGLE,
	FLAC__APODIZATION_TUKEY,
	FLAC__APODIZATION_WELCH
} FLAC__ApodizationFunction;

typedef struct {
	FLAC__ApodizationFunction type;
	union {
		struct {
			FLAC__real stddev;
		} gauss;
		struct {
			FLAC__real p;
		} tukey;
	} parameters;
} FLAC__ApodizationSpecification;

#endif // #ifndef FLAC__INTEGER_ONLY_LIBRARY

typedef struct FLAC__StreamEncoderProtected {
	FLAC__StreamEncoderState state;
	FLAC__bool verify;
	FLAC__bool streamable_subset;
	FLAC__bool do_md5;
	FLAC__bool do_mid_side_stereo;
	FLAC__bool loose_mid_side_stereo;
	unsigned channels;
	unsigned bits_per_sample;
	unsigned sample_rate;
	unsigned blocksize;
#ifndef FLAC__INTEGER_ONLY_LIBRARY
	unsigned num_apodizations;
	FLAC__ApodizationSpecification apodizations[FLAC__MAX_APODIZATION_FUNCTIONS];
#endif
	unsigned max_lpc_order;
	unsigned qlp_coeff_precision;
	FLAC__bool do_qlp_coeff_prec_search;
	FLAC__bool do_exhaustive_model_search;
	FLAC__bool do_escape_coding;
	unsigned min_residual_partition_order;
	unsigned max_residual_partition_order;
	unsigned rice_parameter_search_dist;
	FLAC__uint64 total_samples_estimate;
	FLAC__StreamMetadata **metadata;
	unsigned num_metadata_blocks;
	FLAC__uint64 streaminfo_offset, seektable_offset, audio_offset;
#if FLAC__HAS_OGG
	FLAC__OggEncoderAspect ogg_encoder_aspect;
#endif
} FLAC__StreamEncoderProtected;

#endif

/*** End of inlined file: stream_encoder.h ***/

#if FLAC__HAS_OGG
#include "include/private/ogg_helper.h"
#include "include/private/ogg_mapping.h"
#endif

/*** Start of inlined file: stream_encoder_framing.h ***/
#ifndef FLAC__PRIVATE__STREAM_ENCODER_FRAMING_H
#define FLAC__PRIVATE__STREAM_ENCODER_FRAMING_H

FLAC__bool FLAC__add_metadata_block(const FLAC__StreamMetadata *metadata, FLAC__BitWriter *bw);
FLAC__bool FLAC__frame_add_header(const FLAC__FrameHeader *header, FLAC__BitWriter *bw);
FLAC__bool FLAC__subframe_add_constant(const FLAC__Subframe_Constant *subframe, unsigned subframe_bps, unsigned wasted_bits, FLAC__BitWriter *bw);
FLAC__bool FLAC__subframe_add_fixed(const FLAC__Subframe_Fixed *subframe, unsigned residual_samples, unsigned subframe_bps, unsigned wasted_bits, FLAC__BitWriter *bw);
FLAC__bool FLAC__subframe_add_lpc(const FLAC__Subframe_LPC *subframe, unsigned residual_samples, unsigned subframe_bps, unsigned wasted_bits, FLAC__BitWriter *bw);
FLAC__bool FLAC__subframe_add_verbatim(const FLAC__Subframe_Verbatim *subframe, unsigned samples, unsigned subframe_bps, unsigned wasted_bits, FLAC__BitWriter *bw);

#endif

/*** End of inlined file: stream_encoder_framing.h ***/



/*** Start of inlined file: window.h ***/
#ifndef FLAC__PRIVATE__WINDOW_H
#define FLAC__PRIVATE__WINDOW_H

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#ifndef FLAC__INTEGER_ONLY_LIBRARY

/*
 *	FLAC__window_*()
 *	--------------------------------------------------------------------
 *	Calculates window coefficients according to different apodization
 *	functions.
 *
 *	OUT window[0,L-1]
 *	IN L (number of points in window)
 */
void FLAC__window_bartlett(FLAC__real *window, const FLAC__int32 L);
void FLAC__window_bartlett_hann(FLAC__real *window, const FLAC__int32 L);
void FLAC__window_blackman(FLAC__real *window, const FLAC__int32 L);
void FLAC__window_blackman_harris_4term_92db_sidelobe(FLAC__real *window, const FLAC__int32 L);
void FLAC__window_connes(FLAC__real *window, const FLAC__int32 L);
void FLAC__window_flattop(FLAC__real *window, const FLAC__int32 L);
void FLAC__window_gauss(FLAC__real *window, const FLAC__int32 L, const FLAC__real stddev); /* 0.0 < stddev <= 0.5 */
void FLAC__window_hamming(FLAC__real *window, const FLAC__int32 L);
void FLAC__window_hann(FLAC__real *window, const FLAC__int32 L);
void FLAC__window_kaiser_bessel(FLAC__real *window, const FLAC__int32 L);
void FLAC__window_nuttall(FLAC__real *window, const FLAC__int32 L);
void FLAC__window_rectangle(FLAC__real *window, const FLAC__int32 L);
void FLAC__window_triangle(FLAC__real *window, const FLAC__int32 L);
void FLAC__window_tukey(FLAC__real *window, const FLAC__int32 L, const FLAC__real p);
void FLAC__window_welch(FLAC__real *window, const FLAC__int32 L);

#endif /* !defined FLAC__INTEGER_ONLY_LIBRARY */

#endif

/*** End of inlined file: window.h ***/

#ifndef FLaC__INLINE
#define FLaC__INLINE
#endif

#ifdef min
#undef min
#endif
#define min(x,y) ((x)<(y)?(x):(y))

#ifdef max
#undef max
#endif
#define max(x,y) ((x)>(y)?(x):(y))

/* Exact Rice codeword length calculation is off by default.  The simple
 * (and fast) estimation (of how many bits a residual value will be
 * encoded with) in this encoder is very good, almost always yielding
 * compression within 0.1% of exact calculation.
 */
#undef EXACT_RICE_BITS_CALCULATION
/* Rice parameter searching is off by default.  The simple (and fast)
 * parameter estimation in this encoder is very good, almost always
 * yielding compression within 0.1% of the optimal parameters.
 */
#undef ENABLE_RICE_PARAMETER_SEARCH

typedef struct {
	FLAC__int32 *data[FLAC__MAX_CHANNELS];
	unsigned size; /* of each data[] in samples */
	unsigned tail;
} verify_input_fifo;

typedef struct {
	const FLAC__byte *data;
	unsigned capacity;
	unsigned bytes;
} verify_output;

typedef enum {
	ENCODER_IN_MAGIC = 0,
	ENCODER_IN_METADATA = 1,
	ENCODER_IN_AUDIO = 2
} EncoderStateHint;

static struct CompressionLevels {
	FLAC__bool do_mid_side_stereo;
	FLAC__bool loose_mid_side_stereo;
	unsigned max_lpc_order;
	unsigned qlp_coeff_precision;
	FLAC__bool do_qlp_coeff_prec_search;
	FLAC__bool do_escape_coding;
	FLAC__bool do_exhaustive_model_search;
	unsigned min_residual_partition_order;
	unsigned max_residual_partition_order;
	unsigned rice_parameter_search_dist;
} compression_levels_[] = {
	{ false, false,  0, 0, false, false, false, 0, 3, 0 },
	{ true , true ,  0, 0, false, false, false, 0, 3, 0 },
	{ true , false,  0, 0, false, false, false, 0, 3, 0 },
	{ false, false,  6, 0, false, false, false, 0, 4, 0 },
	{ true , true ,  8, 0, false, false, false, 0, 4, 0 },
	{ true , false,  8, 0, false, false, false, 0, 5, 0 },
	{ true , false,  8, 0, false, false, false, 0, 6, 0 },
	{ true , false,  8, 0, false, false, true , 0, 6, 0 },
	{ true , false, 12, 0, false, false, true , 0, 6, 0 }
};

/***********************************************************************
 *
 * Private class method prototypes
 *
 ***********************************************************************/

static void set_defaults_enc(FLAC__StreamEncoder *encoder);
static void free_(FLAC__StreamEncoder *encoder);
static FLAC__bool resize_buffers_(FLAC__StreamEncoder *encoder, unsigned new_blocksize);
static FLAC__bool write_bitbuffer_(FLAC__StreamEncoder *encoder, unsigned samples, FLAC__bool is_last_block);
static FLAC__StreamEncoderWriteStatus write_frame_(FLAC__StreamEncoder *encoder, const FLAC__byte buffer[], size_t bytes, unsigned samples, FLAC__bool is_last_block);
static void update_metadata_(const FLAC__StreamEncoder *encoder);
#if FLAC__HAS_OGG
static void update_ogg_metadata_(FLAC__StreamEncoder *encoder);
#endif
static FLAC__bool process_frame_(FLAC__StreamEncoder *encoder, FLAC__bool is_fractional_block, FLAC__bool is_last_block);
static FLAC__bool process_subframes_(FLAC__StreamEncoder *encoder, FLAC__bool is_fractional_block);

static FLAC__bool process_subframe_(
	FLAC__StreamEncoder *encoder,
	unsigned min_partition_order,
	unsigned max_partition_order,
	const FLAC__FrameHeader *frame_header,
	unsigned subframe_bps,
	const FLAC__int32 integer_signal[],
	FLAC__Subframe *subframe[2],
	FLAC__EntropyCodingMethod_PartitionedRiceContents *partitioned_rice_contents[2],
	FLAC__int32 *residual[2],
	unsigned *best_subframe,
	unsigned *best_bits
);

static FLAC__bool add_subframe_(
	FLAC__StreamEncoder *encoder,
	unsigned blocksize,
	unsigned subframe_bps,
	const FLAC__Subframe *subframe,
	FLAC__BitWriter *frame
);

static unsigned evaluate_constant_subframe_(
	FLAC__StreamEncoder *encoder,
	const FLAC__int32 signal,
	unsigned blocksize,
	unsigned subframe_bps,
	FLAC__Subframe *subframe
);

static unsigned evaluate_fixed_subframe_(
	FLAC__StreamEncoder *encoder,
	const FLAC__int32 signal[],
	FLAC__int32 residual[],
	FLAC__uint64 abs_residual_partition_sums[],
	unsigned raw_bits_per_partition[],
	unsigned blocksize,
	unsigned subframe_bps,
	unsigned order,
	unsigned rice_parameter,
	unsigned rice_parameter_limit,
	unsigned min_partition_order,
	unsigned max_partition_order,
	FLAC__bool do_escape_coding,
	unsigned rice_parameter_search_dist,
	FLAC__Subframe *subframe,
	FLAC__EntropyCodingMethod_PartitionedRiceContents *partitioned_rice_contents
);

#ifndef FLAC__INTEGER_ONLY_LIBRARY
static unsigned evaluate_lpc_subframe_(
	FLAC__StreamEncoder *encoder,
	const FLAC__int32 signal[],
	FLAC__int32 residual[],
	FLAC__uint64 abs_residual_partition_sums[],
	unsigned raw_bits_per_partition[],
	const FLAC__real lp_coeff[],
	unsigned blocksize,
	unsigned subframe_bps,
	unsigned order,
	unsigned qlp_coeff_precision,
	unsigned rice_parameter,
	unsigned rice_parameter_limit,
	unsigned min_partition_order,
	unsigned max_partition_order,
	FLAC__bool do_escape_coding,
	unsigned rice_parameter_search_dist,
	FLAC__Subframe *subframe,
	FLAC__EntropyCodingMethod_PartitionedRiceContents *partitioned_rice_contents
);
#endif

static unsigned evaluate_verbatim_subframe_(
	FLAC__StreamEncoder *encoder,
	const FLAC__int32 signal[],
	unsigned blocksize,
	unsigned subframe_bps,
	FLAC__Subframe *subframe
);

static unsigned find_best_partition_order_(
	struct FLAC__StreamEncoderPrivate *private_,
	const FLAC__int32 residual[],
	FLAC__uint64 abs_residual_partition_sums[],
	unsigned raw_bits_per_partition[],
	unsigned residual_samples,
	unsigned predictor_order,
	unsigned rice_parameter,
	unsigned rice_parameter_limit,
	unsigned min_partition_order,
	unsigned max_partition_order,
	unsigned bps,
	FLAC__bool do_escape_coding,
	unsigned rice_parameter_search_dist,
	FLAC__EntropyCodingMethod *best_ecm
);

static void precompute_partition_info_sums_(
	const FLAC__int32 residual[],
	FLAC__uint64 abs_residual_partition_sums[],
	unsigned residual_samples,
	unsigned predictor_order,
	unsigned min_partition_order,
	unsigned max_partition_order,
	unsigned bps
);

static void precompute_partition_info_escapes_(
	const FLAC__int32 residual[],
	unsigned raw_bits_per_partition[],
	unsigned residual_samples,
	unsigned predictor_order,
	unsigned min_partition_order,
	unsigned max_partition_order
);

static FLAC__bool set_partitioned_rice_(
#ifdef EXACT_RICE_BITS_CALCULATION
	const FLAC__int32 residual[],
#endif
	const FLAC__uint64 abs_residual_partition_sums[],
	const unsigned raw_bits_per_partition[],
	const unsigned residual_samples,
	const unsigned predictor_order,
	const unsigned suggested_rice_parameter,
	const unsigned rice_parameter_limit,
	const unsigned rice_parameter_search_dist,
	const unsigned partition_order,
	const FLAC__bool search_for_escapes,
	FLAC__EntropyCodingMethod_PartitionedRiceContents *partitioned_rice_contents,
	unsigned *bits
);

static unsigned get_wasted_bits_(FLAC__int32 signal[], unsigned samples);

/* verify-related routines: */
static void append_to_verify_fifo_(
	verify_input_fifo *fifo,
	const FLAC__int32 * const input[],
	unsigned input_offset,
	unsigned channels,
	unsigned wide_samples
);

static void append_to_verify_fifo_interleaved_(
	verify_input_fifo *fifo,
	const FLAC__int32 input[],
	unsigned input_offset,
	unsigned channels,
	unsigned wide_samples
);

static FLAC__StreamDecoderReadStatus verify_read_callback_(const FLAC__StreamDecoder *decoder, FLAC__byte buffer[], size_t *bytes, void *client_data);
static FLAC__StreamDecoderWriteStatus verify_write_callback_(const FLAC__StreamDecoder *decoder, const FLAC__Frame *frame, const FLAC__int32 * const buffer[], void *client_data);
static void verify_metadata_callback_(const FLAC__StreamDecoder *decoder, const FLAC__StreamMetadata *metadata, void *client_data);
static void verify_error_callback_(const FLAC__StreamDecoder *decoder, FLAC__StreamDecoderErrorStatus status, void *client_data);

static FLAC__StreamEncoderReadStatus file_read_callback_enc(const FLAC__StreamEncoder *encoder, FLAC__byte buffer[], size_t *bytes, void *client_data);
static FLAC__StreamEncoderSeekStatus file_seek_callback_enc(const FLAC__StreamEncoder *encoder, FLAC__uint64 absolute_byte_offset, void *client_data);
static FLAC__StreamEncoderTellStatus file_tell_callback_enc(const FLAC__StreamEncoder *encoder, FLAC__uint64 *absolute_byte_offset, void *client_data);
static FLAC__StreamEncoderWriteStatus file_write_callback_(const FLAC__StreamEncoder *encoder, const FLAC__byte buffer[], size_t bytes, unsigned samples, unsigned current_frame, void *client_data);
static FILE *get_binary_stdout_(void);

/***********************************************************************
 *
 * Private class data
 *
 ***********************************************************************/

typedef struct FLAC__StreamEncoderPrivate {
	unsigned input_capacity;                          /* current size (in samples) of the signal and residual buffers */
	FLAC__int32 *integer_signal[FLAC__MAX_CHANNELS];  /* the integer version of the input signal */
	FLAC__int32 *integer_signal_mid_side[2];          /* the integer version of the mid-side input signal (stereo only) */
#ifndef FLAC__INTEGER_ONLY_LIBRARY
	FLAC__real *real_signal[FLAC__MAX_CHANNELS];      /* (@@@ currently unused) the floating-point version of the input signal */
	FLAC__real *real_signal_mid_side[2];              /* (@@@ currently unused) the floating-point version of the mid-side input signal (stereo only) */
	FLAC__real *window[FLAC__MAX_APODIZATION_FUNCTIONS]; /* the pre-computed floating-point window for each apodization function */
	FLAC__real *windowed_signal;                      /* the integer_signal[] * current window[] */
#endif
	unsigned subframe_bps[FLAC__MAX_CHANNELS];        /* the effective bits per sample of the input signal (stream bps - wasted bits) */
	unsigned subframe_bps_mid_side[2];                /* the effective bits per sample of the mid-side input signal (stream bps - wasted bits + 0/1) */
	FLAC__int32 *residual_workspace[FLAC__MAX_CHANNELS][2]; /* each channel has a candidate and best workspace where the subframe residual signals will be stored */
	FLAC__int32 *residual_workspace_mid_side[2][2];
	FLAC__Subframe subframe_workspace[FLAC__MAX_CHANNELS][2];
	FLAC__Subframe subframe_workspace_mid_side[2][2];
	FLAC__Subframe *subframe_workspace_ptr[FLAC__MAX_CHANNELS][2];
	FLAC__Subframe *subframe_workspace_ptr_mid_side[2][2];
	FLAC__EntropyCodingMethod_PartitionedRiceContents partitioned_rice_contents_workspace[FLAC__MAX_CHANNELS][2];
	FLAC__EntropyCodingMethod_PartitionedRiceContents partitioned_rice_contents_workspace_mid_side[FLAC__MAX_CHANNELS][2];
	FLAC__EntropyCodingMethod_PartitionedRiceContents *partitioned_rice_contents_workspace_ptr[FLAC__MAX_CHANNELS][2];
	FLAC__EntropyCodingMethod_PartitionedRiceContents *partitioned_rice_contents_workspace_ptr_mid_side[FLAC__MAX_CHANNELS][2];
	unsigned best_subframe[FLAC__MAX_CHANNELS];       /* index (0 or 1) into 2nd dimension of the above workspaces */
	unsigned best_subframe_mid_side[2];
	unsigned best_subframe_bits[FLAC__MAX_CHANNELS];  /* size in bits of the best subframe for each channel */
	unsigned best_subframe_bits_mid_side[2];
	FLAC__uint64 *abs_residual_partition_sums;        /* workspace where the sum of abs(candidate residual) for each partition is stored */
	unsigned *raw_bits_per_partition;                 /* workspace where the sum of silog2(candidate residual) for each partition is stored */
	FLAC__BitWriter *frame;                           /* the current frame being worked on */
	unsigned loose_mid_side_stereo_frames;            /* rounded number of frames the encoder will use before trying both independent and mid/side frames again */
	unsigned loose_mid_side_stereo_frame_count;       /* number of frames using the current channel assignment */
	FLAC__ChannelAssignment last_channel_assignment;
	FLAC__StreamMetadata streaminfo;                  /* scratchpad for STREAMINFO as it is built */
	FLAC__StreamMetadata_SeekTable *seek_table;       /* pointer into encoder->protected_->metadata_ where the seek table is */
	unsigned current_sample_number;
	unsigned current_frame_number;
	FLAC__MD5Context md5context;
	FLAC__CPUInfo cpuinfo;
#ifndef FLAC__INTEGER_ONLY_LIBRARY
	unsigned (*local_fixed_compute_best_predictor)(const FLAC__int32 data[], unsigned data_len, FLAC__float residual_bits_per_sample[FLAC__MAX_FIXED_ORDER+1]);
#else
	unsigned (*local_fixed_compute_best_predictor)(const FLAC__int32 data[], unsigned data_len, FLAC__fixedpoint residual_bits_per_sample[FLAC__MAX_FIXED_ORDER+1]);
#endif
#ifndef FLAC__INTEGER_ONLY_LIBRARY
	void (*local_lpc_compute_autocorrelation)(const FLAC__real data[], unsigned data_len, unsigned lag, FLAC__real autoc[]);
	void (*local_lpc_compute_residual_from_qlp_coefficients)(const FLAC__int32 *data, unsigned data_len, const FLAC__int32 qlp_coeff[], unsigned order, int lp_quantization, FLAC__int32 residual[]);
	void (*local_lpc_compute_residual_from_qlp_coefficients_64bit)(const FLAC__int32 *data, unsigned data_len, const FLAC__int32 qlp_coeff[], unsigned order, int lp_quantization, FLAC__int32 residual[]);
	void (*local_lpc_compute_residual_from_qlp_coefficients_16bit)(const FLAC__int32 *data, unsigned data_len, const FLAC__int32 qlp_coeff[], unsigned order, int lp_quantization, FLAC__int32 residual[]);
#endif
	FLAC__bool use_wide_by_block;          /* use slow 64-bit versions of some functions because of the block size */
	FLAC__bool use_wide_by_partition;      /* use slow 64-bit versions of some functions because of the min partition order and blocksize */
	FLAC__bool use_wide_by_order;          /* use slow 64-bit versions of some functions because of the lpc order */
	FLAC__bool disable_constant_subframes;
	FLAC__bool disable_fixed_subframes;
	FLAC__bool disable_verbatim_subframes;
#if FLAC__HAS_OGG
	FLAC__bool is_ogg;
#endif
	FLAC__StreamEncoderReadCallback read_callback; /* currently only needed for Ogg FLAC */
	FLAC__StreamEncoderSeekCallback seek_callback;
	FLAC__StreamEncoderTellCallback tell_callback;
	FLAC__StreamEncoderWriteCallback write_callback;
	FLAC__StreamEncoderMetadataCallback metadata_callback;
	FLAC__StreamEncoderProgressCallback progress_callback;
	void *client_data;
	unsigned first_seekpoint_to_check;
	FILE *file;                            /* only used when encoding to a file */
	FLAC__uint64 bytes_written;
	FLAC__uint64 samples_written;
	unsigned frames_written;
	unsigned total_frames_estimate;
	/* unaligned (original) pointers to allocated data */
	FLAC__int32 *integer_signal_unaligned[FLAC__MAX_CHANNELS];
	FLAC__int32 *integer_signal_mid_side_unaligned[2];
#ifndef FLAC__INTEGER_ONLY_LIBRARY
	FLAC__real *real_signal_unaligned[FLAC__MAX_CHANNELS]; /* (@@@ currently unused) */
	FLAC__real *real_signal_mid_side_unaligned[2]; /* (@@@ currently unused) */
	FLAC__real *window_unaligned[FLAC__MAX_APODIZATION_FUNCTIONS];
	FLAC__real *windowed_signal_unaligned;
#endif
	FLAC__int32 *residual_workspace_unaligned[FLAC__MAX_CHANNELS][2];
	FLAC__int32 *residual_workspace_mid_side_unaligned[2][2];
	FLAC__uint64 *abs_residual_partition_sums_unaligned;
	unsigned *raw_bits_per_partition_unaligned;
	/*
	 * These fields have been moved here from private function local
	 * declarations merely to save stack space during encoding.
	 */
#ifndef FLAC__INTEGER_ONLY_LIBRARY
	FLAC__real lp_coeff[FLAC__MAX_LPC_ORDER][FLAC__MAX_LPC_ORDER]; /* from process_subframe_() */
#endif
	FLAC__EntropyCodingMethod_PartitionedRiceContents partitioned_rice_contents_extra[2]; /* from find_best_partition_order_() */
	/*
	 * The data for the verify section
	 */
	struct {
		FLAC__StreamDecoder *decoder;
		EncoderStateHint state_hint;
		FLAC__bool needs_magic_hack;
		verify_input_fifo input_fifo;
		verify_output output;
		struct {
			FLAC__uint64 absolute_sample;
			unsigned frame_number;
			unsigned channel;
			unsigned sample;
			FLAC__int32 expected;
			FLAC__int32 got;
		} error_stats;
	} verify;
	FLAC__bool is_being_deleted; /* if true, call to ..._finish() from ..._delete() will not call the callbacks */
} FLAC__StreamEncoderPrivate;

/***********************************************************************
 *
 * Public static class data
 *
 ***********************************************************************/

FLAC_API const char * const FLAC__StreamEncoderStateString[] = {
	"FLAC__STREAM_ENCODER_OK",
	"FLAC__STREAM_ENCODER_UNINITIALIZED",
	"FLAC__STREAM_ENCODER_OGG_ERROR",
	"FLAC__STREAM_ENCODER_VERIFY_DECODER_ERROR",
	"FLAC__STREAM_ENCODER_VERIFY_MISMATCH_IN_AUDIO_DATA",
	"FLAC__STREAM_ENCODER_CLIENT_ERROR",
	"FLAC__STREAM_ENCODER_IO_ERROR",
	"FLAC__STREAM_ENCODER_FRAMING_ERROR",
	"FLAC__STREAM_ENCODER_MEMORY_ALLOCATION_ERROR"
};

FLAC_API const char * const FLAC__StreamEncoderInitStatusString[] = {
	"FLAC__STREAM_ENCODER_INIT_STATUS_OK",
	"FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR",
	"FLAC__STREAM_ENCODER_INIT_STATUS_UNSUPPORTED_CONTAINER",
	"FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_CALLBACKS",
	"FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_NUMBER_OF_CHANNELS",
	"FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_BITS_PER_SAMPLE",
	"FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_SAMPLE_RATE",
	"FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_BLOCK_SIZE",
	"FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_MAX_LPC_ORDER",
	"FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_QLP_COEFF_PRECISION",
	"FLAC__STREAM_ENCODER_INIT_STATUS_BLOCK_SIZE_TOO_SMALL_FOR_LPC_ORDER",
	"FLAC__STREAM_ENCODER_INIT_STATUS_NOT_STREAMABLE",
	"FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_METADATA",
	"FLAC__STREAM_ENCODER_INIT_STATUS_ALREADY_INITIALIZED"
};

FLAC_API const char * const FLAC__treamEncoderReadStatusString[] = {
	"FLAC__STREAM_ENCODER_READ_STATUS_CONTINUE",
	"FLAC__STREAM_ENCODER_READ_STATUS_END_OF_STREAM",
	"FLAC__STREAM_ENCODER_READ_STATUS_ABORT",
	"FLAC__STREAM_ENCODER_READ_STATUS_UNSUPPORTED"
};

FLAC_API const char * const FLAC__StreamEncoderWriteStatusString[] = {
	"FLAC__STREAM_ENCODER_WRITE_STATUS_OK",
	"FLAC__STREAM_ENCODER_WRITE_STATUS_FATAL_ERROR"
};

FLAC_API const char * const FLAC__StreamEncoderSeekStatusString[] = {
	"FLAC__STREAM_ENCODER_SEEK_STATUS_OK",
	"FLAC__STREAM_ENCODER_SEEK_STATUS_ERROR",
	"FLAC__STREAM_ENCODER_SEEK_STATUS_UNSUPPORTED"
};

FLAC_API const char * const FLAC__StreamEncoderTellStatusString[] = {
	"FLAC__STREAM_ENCODER_TELL_STATUS_OK",
	"FLAC__STREAM_ENCODER_TELL_STATUS_ERROR",
	"FLAC__STREAM_ENCODER_TELL_STATUS_UNSUPPORTED"
};

/* Number of samples that will be overread to watch for end of stream.  By
 * 'overread', we mean that the FLAC__stream_encoder_process*() calls will
 * always try to read blocksize+1 samples before encoding a block, so that
 * even if the stream has a total sample count that is an integral multiple
 * of the blocksize, we will still notice when we are encoding the last
 * block.  This is needed, for example, to correctly set the end-of-stream
 * marker in Ogg FLAC.
 *
 * WATCHOUT: some parts of the code assert that OVERREAD_ == 1 and there's
 * not really any reason to change it.
 */
static const unsigned OVERREAD_ = 1;

/***********************************************************************
 *
 * Class constructor/destructor
 *
 */
FLAC_API FLAC__StreamEncoder *FLAC__stream_encoder_new(void)
{
	FLAC__StreamEncoder *encoder;
	unsigned i;

	FLAC__ASSERT(sizeof(int) >= 4); /* we want to die right away if this is not true */

	encoder = (FLAC__StreamEncoder*)calloc(1, sizeof(FLAC__StreamEncoder));
	if(encoder == 0) {
		return 0;
	}

	encoder->protected_ = (FLAC__StreamEncoderProtected*)calloc(1, sizeof(FLAC__StreamEncoderProtected));
	if(encoder->protected_ == 0) {
		free(encoder);
		return 0;
	}

	encoder->private_ = (FLAC__StreamEncoderPrivate*)calloc(1, sizeof(FLAC__StreamEncoderPrivate));
	if(encoder->private_ == 0) {
		free(encoder->protected_);
		free(encoder);
		return 0;
	}

	encoder->private_->frame = FLAC__bitwriter_new();
	if(encoder->private_->frame == 0) {
		free(encoder->private_);
		free(encoder->protected_);
		free(encoder);
		return 0;
	}

	encoder->private_->file = 0;

	set_defaults_enc(encoder);

	encoder->private_->is_being_deleted = false;

	for(i = 0; i < FLAC__MAX_CHANNELS; i++) {
		encoder->private_->subframe_workspace_ptr[i][0] = &encoder->private_->subframe_workspace[i][0];
		encoder->private_->subframe_workspace_ptr[i][1] = &encoder->private_->subframe_workspace[i][1];
	}
	for(i = 0; i < 2; i++) {
		encoder->private_->subframe_workspace_ptr_mid_side[i][0] = &encoder->private_->subframe_workspace_mid_side[i][0];
		encoder->private_->subframe_workspace_ptr_mid_side[i][1] = &encoder->private_->subframe_workspace_mid_side[i][1];
	}
	for(i = 0; i < FLAC__MAX_CHANNELS; i++) {
		encoder->private_->partitioned_rice_contents_workspace_ptr[i][0] = &encoder->private_->partitioned_rice_contents_workspace[i][0];
		encoder->private_->partitioned_rice_contents_workspace_ptr[i][1] = &encoder->private_->partitioned_rice_contents_workspace[i][1];
	}
	for(i = 0; i < 2; i++) {
		encoder->private_->partitioned_rice_contents_workspace_ptr_mid_side[i][0] = &encoder->private_->partitioned_rice_contents_workspace_mid_side[i][0];
		encoder->private_->partitioned_rice_contents_workspace_ptr_mid_side[i][1] = &encoder->private_->partitioned_rice_contents_workspace_mid_side[i][1];
	}

	for(i = 0; i < FLAC__MAX_CHANNELS; i++) {
		FLAC__format_entropy_coding_method_partitioned_rice_contents_init(&encoder->private_->partitioned_rice_contents_workspace[i][0]);
		FLAC__format_entropy_coding_method_partitioned_rice_contents_init(&encoder->private_->partitioned_rice_contents_workspace[i][1]);
	}
	for(i = 0; i < 2; i++) {
		FLAC__format_entropy_coding_method_partitioned_rice_contents_init(&encoder->private_->partitioned_rice_contents_workspace_mid_side[i][0]);
		FLAC__format_entropy_coding_method_partitioned_rice_contents_init(&encoder->private_->partitioned_rice_contents_workspace_mid_side[i][1]);
	}
	for(i = 0; i < 2; i++)
		FLAC__format_entropy_coding_method_partitioned_rice_contents_init(&encoder->private_->partitioned_rice_contents_extra[i]);

	encoder->protected_->state = FLAC__STREAM_ENCODER_UNINITIALIZED;

	return encoder;
}

FLAC_API void FLAC__stream_encoder_delete(FLAC__StreamEncoder *encoder)
{
	unsigned i;

	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->protected_);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->private_->frame);

	encoder->private_->is_being_deleted = true;

	(void)FLAC__stream_encoder_finish(encoder);

	if(0 != encoder->private_->verify.decoder)
		FLAC__stream_decoder_delete(encoder->private_->verify.decoder);

	for(i = 0; i < FLAC__MAX_CHANNELS; i++) {
		FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(&encoder->private_->partitioned_rice_contents_workspace[i][0]);
		FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(&encoder->private_->partitioned_rice_contents_workspace[i][1]);
	}
	for(i = 0; i < 2; i++) {
		FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(&encoder->private_->partitioned_rice_contents_workspace_mid_side[i][0]);
		FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(&encoder->private_->partitioned_rice_contents_workspace_mid_side[i][1]);
	}
	for(i = 0; i < 2; i++)
		FLAC__format_entropy_coding_method_partitioned_rice_contents_clear(&encoder->private_->partitioned_rice_contents_extra[i]);

	FLAC__bitwriter_delete(encoder->private_->frame);
	free(encoder->private_);
	free(encoder->protected_);
	free(encoder);
}

/***********************************************************************
 *
 * Public class methods
 *
 ***********************************************************************/

static FLAC__StreamEncoderInitStatus init_stream_internal_enc(
	FLAC__StreamEncoder *encoder,
	FLAC__StreamEncoderReadCallback read_callback,
	FLAC__StreamEncoderWriteCallback write_callback,
	FLAC__StreamEncoderSeekCallback seek_callback,
	FLAC__StreamEncoderTellCallback tell_callback,
	FLAC__StreamEncoderMetadataCallback metadata_callback,
	void *client_data,
	FLAC__bool is_ogg
)
{
	unsigned i;
	FLAC__bool metadata_has_seektable, metadata_has_vorbis_comment, metadata_picture_has_type1, metadata_picture_has_type2;

	FLAC__ASSERT(0 != encoder);

	if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
		return FLAC__STREAM_ENCODER_INIT_STATUS_ALREADY_INITIALIZED;

#if !FLAC__HAS_OGG
	if(is_ogg)
		return FLAC__STREAM_ENCODER_INIT_STATUS_UNSUPPORTED_CONTAINER;
#endif

	if(0 == write_callback || (seek_callback && 0 == tell_callback))
		return FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_CALLBACKS;

	if(encoder->protected_->channels == 0 || encoder->protected_->channels > FLAC__MAX_CHANNELS)
		return FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_NUMBER_OF_CHANNELS;

	if(encoder->protected_->channels != 2) {
		encoder->protected_->do_mid_side_stereo = false;
		encoder->protected_->loose_mid_side_stereo = false;
	}
	else if(!encoder->protected_->do_mid_side_stereo)
		encoder->protected_->loose_mid_side_stereo = false;

	if(encoder->protected_->bits_per_sample >= 32)
		encoder->protected_->do_mid_side_stereo = false; /* since we currenty do 32-bit math, the side channel would have 33 bps and overflow */

	if(encoder->protected_->bits_per_sample < FLAC__MIN_BITS_PER_SAMPLE || encoder->protected_->bits_per_sample > FLAC__REFERENCE_CODEC_MAX_BITS_PER_SAMPLE)
		return FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_BITS_PER_SAMPLE;

	if(!FLAC__format_sample_rate_is_valid(encoder->protected_->sample_rate))
		return FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_SAMPLE_RATE;

	if(encoder->protected_->blocksize == 0) {
		if(encoder->protected_->max_lpc_order == 0)
			encoder->protected_->blocksize = 1152;
		else
			encoder->protected_->blocksize = 4096;
	}

	if(encoder->protected_->blocksize < FLAC__MIN_BLOCK_SIZE || encoder->protected_->blocksize > FLAC__MAX_BLOCK_SIZE)
		return FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_BLOCK_SIZE;

	if(encoder->protected_->max_lpc_order > FLAC__MAX_LPC_ORDER)
		return FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_MAX_LPC_ORDER;

	if(encoder->protected_->blocksize < encoder->protected_->max_lpc_order)
		return FLAC__STREAM_ENCODER_INIT_STATUS_BLOCK_SIZE_TOO_SMALL_FOR_LPC_ORDER;

	if(encoder->protected_->qlp_coeff_precision == 0) {
		if(encoder->protected_->bits_per_sample < 16) {
			/* @@@ need some data about how to set this here w.r.t. blocksize and sample rate */
			/* @@@ until then we'll make a guess */
			encoder->protected_->qlp_coeff_precision = max(FLAC__MIN_QLP_COEFF_PRECISION, 2 + encoder->protected_->bits_per_sample / 2);
		}
		else if(encoder->protected_->bits_per_sample == 16) {
			if(encoder->protected_->blocksize <= 192)
				encoder->protected_->qlp_coeff_precision = 7;
			else if(encoder->protected_->blocksize <= 384)
				encoder->protected_->qlp_coeff_precision = 8;
			else if(encoder->protected_->blocksize <= 576)
				encoder->protected_->qlp_coeff_precision = 9;
			else if(encoder->protected_->blocksize <= 1152)
				encoder->protected_->qlp_coeff_precision = 10;
			else if(encoder->protected_->blocksize <= 2304)
				encoder->protected_->qlp_coeff_precision = 11;
			else if(encoder->protected_->blocksize <= 4608)
				encoder->protected_->qlp_coeff_precision = 12;
			else
				encoder->protected_->qlp_coeff_precision = 13;
		}
		else {
			if(encoder->protected_->blocksize <= 384)
				encoder->protected_->qlp_coeff_precision = FLAC__MAX_QLP_COEFF_PRECISION-2;
			else if(encoder->protected_->blocksize <= 1152)
				encoder->protected_->qlp_coeff_precision = FLAC__MAX_QLP_COEFF_PRECISION-1;
			else
				encoder->protected_->qlp_coeff_precision = FLAC__MAX_QLP_COEFF_PRECISION;
		}
		FLAC__ASSERT(encoder->protected_->qlp_coeff_precision <= FLAC__MAX_QLP_COEFF_PRECISION);
	}
	else if(encoder->protected_->qlp_coeff_precision < FLAC__MIN_QLP_COEFF_PRECISION || encoder->protected_->qlp_coeff_precision > FLAC__MAX_QLP_COEFF_PRECISION)
		return FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_QLP_COEFF_PRECISION;

	if(encoder->protected_->streamable_subset) {
		if(
			encoder->protected_->blocksize != 192 &&
			encoder->protected_->blocksize != 576 &&
			encoder->protected_->blocksize != 1152 &&
			encoder->protected_->blocksize != 2304 &&
			encoder->protected_->blocksize != 4608 &&
			encoder->protected_->blocksize != 256 &&
			encoder->protected_->blocksize != 512 &&
			encoder->protected_->blocksize != 1024 &&
			encoder->protected_->blocksize != 2048 &&
			encoder->protected_->blocksize != 4096 &&
			encoder->protected_->blocksize != 8192 &&
			encoder->protected_->blocksize != 16384
		)
			return FLAC__STREAM_ENCODER_INIT_STATUS_NOT_STREAMABLE;
		if(!FLAC__format_sample_rate_is_subset(encoder->protected_->sample_rate))
			return FLAC__STREAM_ENCODER_INIT_STATUS_NOT_STREAMABLE;
		if(
			encoder->protected_->bits_per_sample != 8 &&
			encoder->protected_->bits_per_sample != 12 &&
			encoder->protected_->bits_per_sample != 16 &&
			encoder->protected_->bits_per_sample != 20 &&
			encoder->protected_->bits_per_sample != 24
		)
			return FLAC__STREAM_ENCODER_INIT_STATUS_NOT_STREAMABLE;
		if(encoder->protected_->max_residual_partition_order > FLAC__SUBSET_MAX_RICE_PARTITION_ORDER)
			return FLAC__STREAM_ENCODER_INIT_STATUS_NOT_STREAMABLE;
		if(
			encoder->protected_->sample_rate <= 48000 &&
			(
				encoder->protected_->blocksize > FLAC__SUBSET_MAX_BLOCK_SIZE_48000HZ ||
				encoder->protected_->max_lpc_order > FLAC__SUBSET_MAX_LPC_ORDER_48000HZ
			)
		) {
			return FLAC__STREAM_ENCODER_INIT_STATUS_NOT_STREAMABLE;
		}
	}

	if(encoder->protected_->max_residual_partition_order >= (1u << FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_ORDER_LEN))
		encoder->protected_->max_residual_partition_order = (1u << FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_ORDER_LEN) - 1;
	if(encoder->protected_->min_residual_partition_order >= encoder->protected_->max_residual_partition_order)
		encoder->protected_->min_residual_partition_order = encoder->protected_->max_residual_partition_order;

#if FLAC__HAS_OGG
	/* reorder metadata if necessary to ensure that any VORBIS_COMMENT is the first, according to the mapping spec */
	if(is_ogg && 0 != encoder->protected_->metadata && encoder->protected_->num_metadata_blocks > 1) {
		unsigned i;
		for(i = 1; i < encoder->protected_->num_metadata_blocks; i++) {
			if(0 != encoder->protected_->metadata[i] && encoder->protected_->metadata[i]->type == FLAC__METADATA_TYPE_VORBIS_COMMENT) {
				FLAC__StreamMetadata *vc = encoder->protected_->metadata[i];
				for( ; i > 0; i--)
					encoder->protected_->metadata[i] = encoder->protected_->metadata[i-1];
				encoder->protected_->metadata[0] = vc;
				break;
			}
		}
	}
#endif
	/* keep track of any SEEKTABLE block */
	if(0 != encoder->protected_->metadata && encoder->protected_->num_metadata_blocks > 0) {
		unsigned i;
		for(i = 0; i < encoder->protected_->num_metadata_blocks; i++) {
			if(0 != encoder->protected_->metadata[i] && encoder->protected_->metadata[i]->type == FLAC__METADATA_TYPE_SEEKTABLE) {
				encoder->private_->seek_table = &encoder->protected_->metadata[i]->data.seek_table;
				break; /* take only the first one */
			}
		}
	}

	/* validate metadata */
	if(0 == encoder->protected_->metadata && encoder->protected_->num_metadata_blocks > 0)
		return FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_METADATA;
	metadata_has_seektable = false;
	metadata_has_vorbis_comment = false;
	metadata_picture_has_type1 = false;
	metadata_picture_has_type2 = false;
	for(i = 0; i < encoder->protected_->num_metadata_blocks; i++) {
		const FLAC__StreamMetadata *m = encoder->protected_->metadata[i];
		if(m->type == FLAC__METADATA_TYPE_STREAMINFO)
			return FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_METADATA;
		else if(m->type == FLAC__METADATA_TYPE_SEEKTABLE) {
			if(metadata_has_seektable) /* only one is allowed */
				return FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_METADATA;
			metadata_has_seektable = true;
			if(!FLAC__format_seektable_is_legal(&m->data.seek_table))
				return FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_METADATA;
		}
		else if(m->type == FLAC__METADATA_TYPE_VORBIS_COMMENT) {
			if(metadata_has_vorbis_comment) /* only one is allowed */
				return FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_METADATA;
			metadata_has_vorbis_comment = true;
		}
		else if(m->type == FLAC__METADATA_TYPE_CUESHEET) {
			if(!FLAC__format_cuesheet_is_legal(&m->data.cue_sheet, m->data.cue_sheet.is_cd, /*violation=*/0))
				return FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_METADATA;
		}
		else if(m->type == FLAC__METADATA_TYPE_PICTURE) {
			if(!FLAC__format_picture_is_legal(&m->data.picture, /*violation=*/0))
				return FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_METADATA;
			if(m->data.picture.type == FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON_STANDARD) {
				if(metadata_picture_has_type1) /* there should only be 1 per stream */
					return FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_METADATA;
				metadata_picture_has_type1 = true;
				/* standard icon must be 32x32 pixel PNG */
				if(
					m->data.picture.type == FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON_STANDARD &&
					(
						(strcmp(m->data.picture.mime_type, "image/png") && strcmp(m->data.picture.mime_type, "-->")) ||
						m->data.picture.width != 32 ||
						m->data.picture.height != 32
					)
				)
					return FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_METADATA;
			}
			else if(m->data.picture.type == FLAC__STREAM_METADATA_PICTURE_TYPE_FILE_ICON) {
				if(metadata_picture_has_type2) /* there should only be 1 per stream */
					return FLAC__STREAM_ENCODER_INIT_STATUS_INVALID_METADATA;
				metadata_picture_has_type2 = true;
			}
		}
	}

	encoder->private_->input_capacity = 0;
	for(i = 0; i < encoder->protected_->channels; i++) {
		encoder->private_->integer_signal_unaligned[i] = encoder->private_->integer_signal[i] = 0;
#ifndef FLAC__INTEGER_ONLY_LIBRARY
		encoder->private_->real_signal_unaligned[i] = encoder->private_->real_signal[i] = 0;
#endif
	}
	for(i = 0; i < 2; i++) {
		encoder->private_->integer_signal_mid_side_unaligned[i] = encoder->private_->integer_signal_mid_side[i] = 0;
#ifndef FLAC__INTEGER_ONLY_LIBRARY
		encoder->private_->real_signal_mid_side_unaligned[i] = encoder->private_->real_signal_mid_side[i] = 0;
#endif
	}
#ifndef FLAC__INTEGER_ONLY_LIBRARY
	for(i = 0; i < encoder->protected_->num_apodizations; i++)
		encoder->private_->window_unaligned[i] = encoder->private_->window[i] = 0;
	encoder->private_->windowed_signal_unaligned = encoder->private_->windowed_signal = 0;
#endif
	for(i = 0; i < encoder->protected_->channels; i++) {
		encoder->private_->residual_workspace_unaligned[i][0] = encoder->private_->residual_workspace[i][0] = 0;
		encoder->private_->residual_workspace_unaligned[i][1] = encoder->private_->residual_workspace[i][1] = 0;
		encoder->private_->best_subframe[i] = 0;
	}
	for(i = 0; i < 2; i++) {
		encoder->private_->residual_workspace_mid_side_unaligned[i][0] = encoder->private_->residual_workspace_mid_side[i][0] = 0;
		encoder->private_->residual_workspace_mid_side_unaligned[i][1] = encoder->private_->residual_workspace_mid_side[i][1] = 0;
		encoder->private_->best_subframe_mid_side[i] = 0;
	}
	encoder->private_->abs_residual_partition_sums_unaligned = encoder->private_->abs_residual_partition_sums = 0;
	encoder->private_->raw_bits_per_partition_unaligned = encoder->private_->raw_bits_per_partition = 0;
#ifndef FLAC__INTEGER_ONLY_LIBRARY
	encoder->private_->loose_mid_side_stereo_frames = (unsigned)((FLAC__double)encoder->protected_->sample_rate * 0.4 / (FLAC__double)encoder->protected_->blocksize + 0.5);
#else
	/* 26214 is the approximate fixed-point equivalent to 0.4 (0.4 * 2^16) */
	/* sample rate can be up to 655350 Hz, and thus use 20 bits, so we do the multiply&divide by hand */
	FLAC__ASSERT(FLAC__MAX_SAMPLE_RATE <= 655350);
	FLAC__ASSERT(FLAC__MAX_BLOCK_SIZE <= 65535);
	FLAC__ASSERT(encoder->protected_->sample_rate <= 655350);
	FLAC__ASSERT(encoder->protected_->blocksize <= 65535);
	encoder->private_->loose_mid_side_stereo_frames = (unsigned)FLAC__fixedpoint_trunc((((FLAC__uint64)(encoder->protected_->sample_rate) * (FLAC__uint64)(26214)) << 16) / (encoder->protected_->blocksize<<16) + FLAC__FP_ONE_HALF);
#endif
	if(encoder->private_->loose_mid_side_stereo_frames == 0)
		encoder->private_->loose_mid_side_stereo_frames = 1;
	encoder->private_->loose_mid_side_stereo_frame_count = 0;
	encoder->private_->current_sample_number = 0;
	encoder->private_->current_frame_number = 0;

	encoder->private_->use_wide_by_block = (encoder->protected_->bits_per_sample + FLAC__bitmath_ilog2(encoder->protected_->blocksize)+1 > 30);
	encoder->private_->use_wide_by_order = (encoder->protected_->bits_per_sample + FLAC__bitmath_ilog2(max(encoder->protected_->max_lpc_order, FLAC__MAX_FIXED_ORDER))+1 > 30); /*@@@ need to use this? */
	encoder->private_->use_wide_by_partition = (false); /*@@@ need to set this */

	/*
	 * get the CPU info and set the function pointers
	 */
	FLAC__cpu_info(&encoder->private_->cpuinfo);
	/* first default to the non-asm routines */
#ifndef FLAC__INTEGER_ONLY_LIBRARY
	encoder->private_->local_lpc_compute_autocorrelation = FLAC__lpc_compute_autocorrelation;
#endif
	encoder->private_->local_fixed_compute_best_predictor = FLAC__fixed_compute_best_predictor;
#ifndef FLAC__INTEGER_ONLY_LIBRARY
	encoder->private_->local_lpc_compute_residual_from_qlp_coefficients = FLAC__lpc_compute_residual_from_qlp_coefficients;
	encoder->private_->local_lpc_compute_residual_from_qlp_coefficients_64bit = FLAC__lpc_compute_residual_from_qlp_coefficients_wide;
	encoder->private_->local_lpc_compute_residual_from_qlp_coefficients_16bit = FLAC__lpc_compute_residual_from_qlp_coefficients;
#endif
	/* now override with asm where appropriate */
#ifndef FLAC__INTEGER_ONLY_LIBRARY
# ifndef FLAC__NO_ASM
	if(encoder->private_->cpuinfo.use_asm) {
#  ifdef FLAC__CPU_IA32
		FLAC__ASSERT(encoder->private_->cpuinfo.type == FLAC__CPUINFO_TYPE_IA32);
#   ifdef FLAC__HAS_NASM
		if(encoder->private_->cpuinfo.data.ia32.sse) {
			if(encoder->protected_->max_lpc_order < 4)
				encoder->private_->local_lpc_compute_autocorrelation = FLAC__lpc_compute_autocorrelation_asm_ia32_sse_lag_4;
			else if(encoder->protected_->max_lpc_order < 8)
				encoder->private_->local_lpc_compute_autocorrelation = FLAC__lpc_compute_autocorrelation_asm_ia32_sse_lag_8;
			else if(encoder->protected_->max_lpc_order < 12)
				encoder->private_->local_lpc_compute_autocorrelation = FLAC__lpc_compute_autocorrelation_asm_ia32_sse_lag_12;
			else
				encoder->private_->local_lpc_compute_autocorrelation = FLAC__lpc_compute_autocorrelation_asm_ia32;
		}
		else if(encoder->private_->cpuinfo.data.ia32._3dnow)
			encoder->private_->local_lpc_compute_autocorrelation = FLAC__lpc_compute_autocorrelation_asm_ia32_3dnow;
		else
			encoder->private_->local_lpc_compute_autocorrelation = FLAC__lpc_compute_autocorrelation_asm_ia32;
		if(encoder->private_->cpuinfo.data.ia32.mmx) {
			encoder->private_->local_lpc_compute_residual_from_qlp_coefficients = FLAC__lpc_compute_residual_from_qlp_coefficients_asm_ia32;
			encoder->private_->local_lpc_compute_residual_from_qlp_coefficients_16bit = FLAC__lpc_compute_residual_from_qlp_coefficients_asm_ia32_mmx;
		}
		else {
			encoder->private_->local_lpc_compute_residual_from_qlp_coefficients = FLAC__lpc_compute_residual_from_qlp_coefficients_asm_ia32;
			encoder->private_->local_lpc_compute_residual_from_qlp_coefficients_16bit = FLAC__lpc_compute_residual_from_qlp_coefficients_asm_ia32;
		}
		if(encoder->private_->cpuinfo.data.ia32.mmx && encoder->private_->cpuinfo.data.ia32.cmov)
			encoder->private_->local_fixed_compute_best_predictor = FLAC__fixed_compute_best_predictor_asm_ia32_mmx_cmov;
#   endif /* FLAC__HAS_NASM */
#  endif /* FLAC__CPU_IA32 */
	}
# endif /* !FLAC__NO_ASM */
#endif /* !FLAC__INTEGER_ONLY_LIBRARY */
	/* finally override based on wide-ness if necessary */
	if(encoder->private_->use_wide_by_block) {
		encoder->private_->local_fixed_compute_best_predictor = FLAC__fixed_compute_best_predictor_wide;
	}

	/* set state to OK; from here on, errors are fatal and we'll override the state then */
	encoder->protected_->state = FLAC__STREAM_ENCODER_OK;

#if FLAC__HAS_OGG
	encoder->private_->is_ogg = is_ogg;
	if(is_ogg && !FLAC__ogg_encoder_aspect_init(&encoder->protected_->ogg_encoder_aspect)) {
		encoder->protected_->state = FLAC__STREAM_ENCODER_OGG_ERROR;
		return FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;
	}
#endif

	encoder->private_->read_callback = read_callback;
	encoder->private_->write_callback = write_callback;
	encoder->private_->seek_callback = seek_callback;
	encoder->private_->tell_callback = tell_callback;
	encoder->private_->metadata_callback = metadata_callback;
	encoder->private_->client_data = client_data;

	if(!resize_buffers_(encoder, encoder->protected_->blocksize)) {
		/* the above function sets the state for us in case of an error */
		return FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;
	}

	if(!FLAC__bitwriter_init(encoder->private_->frame)) {
		encoder->protected_->state = FLAC__STREAM_ENCODER_MEMORY_ALLOCATION_ERROR;
		return FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;
	}

	/*
	 * Set up the verify stuff if necessary
	 */
	if(encoder->protected_->verify) {
		/*
		 * First, set up the fifo which will hold the
		 * original signal to compare against
		 */
		encoder->private_->verify.input_fifo.size = encoder->protected_->blocksize+OVERREAD_;
		for(i = 0; i < encoder->protected_->channels; i++) {
			if(0 == (encoder->private_->verify.input_fifo.data[i] = (FLAC__int32*)safe_malloc_mul_2op_(sizeof(FLAC__int32), /*times*/encoder->private_->verify.input_fifo.size))) {
				encoder->protected_->state = FLAC__STREAM_ENCODER_MEMORY_ALLOCATION_ERROR;
				return FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;
			}
		}
		encoder->private_->verify.input_fifo.tail = 0;

		/*
		 * Now set up a stream decoder for verification
		 */
		encoder->private_->verify.decoder = FLAC__stream_decoder_new();
		if(0 == encoder->private_->verify.decoder) {
			encoder->protected_->state = FLAC__STREAM_ENCODER_VERIFY_DECODER_ERROR;
			return FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;
		}

		if(FLAC__stream_decoder_init_stream(encoder->private_->verify.decoder, verify_read_callback_, /*seek_callback=*/0, /*tell_callback=*/0, /*length_callback=*/0, /*eof_callback=*/0, verify_write_callback_, verify_metadata_callback_, verify_error_callback_, /*client_data=*/encoder) != FLAC__STREAM_DECODER_INIT_STATUS_OK) {
			encoder->protected_->state = FLAC__STREAM_ENCODER_VERIFY_DECODER_ERROR;
			return FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;
		}
	}
	encoder->private_->verify.error_stats.absolute_sample = 0;
	encoder->private_->verify.error_stats.frame_number = 0;
	encoder->private_->verify.error_stats.channel = 0;
	encoder->private_->verify.error_stats.sample = 0;
	encoder->private_->verify.error_stats.expected = 0;
	encoder->private_->verify.error_stats.got = 0;

	/*
	 * These must be done before we write any metadata, because that
	 * calls the write_callback, which uses these values.
	 */
	encoder->private_->first_seekpoint_to_check = 0;
	encoder->private_->samples_written = 0;
	encoder->protected_->streaminfo_offset = 0;
	encoder->protected_->seektable_offset = 0;
	encoder->protected_->audio_offset = 0;

	/*
	 * write the stream header
	 */
	if(encoder->protected_->verify)
		encoder->private_->verify.state_hint = ENCODER_IN_MAGIC;
	if(!FLAC__bitwriter_write_raw_uint32(encoder->private_->frame, FLAC__STREAM_SYNC, FLAC__STREAM_SYNC_LEN)) {
		encoder->protected_->state = FLAC__STREAM_ENCODER_FRAMING_ERROR;
		return FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;
	}
	if(!write_bitbuffer_(encoder, 0, /*is_last_block=*/false)) {
		/* the above function sets the state for us in case of an error */
		return FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;
	}

	/*
	 * write the STREAMINFO metadata block
	 */
	if(encoder->protected_->verify)
		encoder->private_->verify.state_hint = ENCODER_IN_METADATA;
	encoder->private_->streaminfo.type = FLAC__METADATA_TYPE_STREAMINFO;
	encoder->private_->streaminfo.is_last = false; /* we will have at a minimum a VORBIS_COMMENT afterwards */
	encoder->private_->streaminfo.length = FLAC__STREAM_METADATA_STREAMINFO_LENGTH;
	encoder->private_->streaminfo.data.stream_info.min_blocksize = encoder->protected_->blocksize; /* this encoder uses the same blocksize for the whole stream */
	encoder->private_->streaminfo.data.stream_info.max_blocksize = encoder->protected_->blocksize;
	encoder->private_->streaminfo.data.stream_info.min_framesize = 0; /* we don't know this yet; have to fill it in later */
	encoder->private_->streaminfo.data.stream_info.max_framesize = 0; /* we don't know this yet; have to fill it in later */
	encoder->private_->streaminfo.data.stream_info.sample_rate = encoder->protected_->sample_rate;
	encoder->private_->streaminfo.data.stream_info.channels = encoder->protected_->channels;
	encoder->private_->streaminfo.data.stream_info.bits_per_sample = encoder->protected_->bits_per_sample;
	encoder->private_->streaminfo.data.stream_info.total_samples = encoder->protected_->total_samples_estimate; /* we will replace this later with the real total */
	memset(encoder->private_->streaminfo.data.stream_info.md5sum, 0, 16); /* we don't know this yet; have to fill it in later */
	if(encoder->protected_->do_md5)
		FLAC__MD5Init(&encoder->private_->md5context);
	if(!FLAC__add_metadata_block(&encoder->private_->streaminfo, encoder->private_->frame)) {
		encoder->protected_->state = FLAC__STREAM_ENCODER_FRAMING_ERROR;
		return FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;
	}
	if(!write_bitbuffer_(encoder, 0, /*is_last_block=*/false)) {
		/* the above function sets the state for us in case of an error */
		return FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;
	}

	/*
	 * Now that the STREAMINFO block is written, we can init this to an
	 * absurdly-high value...
	 */
	encoder->private_->streaminfo.data.stream_info.min_framesize = (1u << FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN) - 1;
	/* ... and clear this to 0 */
	encoder->private_->streaminfo.data.stream_info.total_samples = 0;

	/*
	 * Check to see if the supplied metadata contains a VORBIS_COMMENT;
	 * if not, we will write an empty one (FLAC__add_metadata_block()
	 * automatically supplies the vendor string).
	 *
	 * WATCHOUT: the Ogg FLAC mapping requires us to write this block after
	 * the STREAMINFO.  (In the case that metadata_has_vorbis_comment is
	 * true it will have already insured that the metadata list is properly
	 * ordered.)
	 */
	if(!metadata_has_vorbis_comment) {
		FLAC__StreamMetadata vorbis_comment;
		vorbis_comment.type = FLAC__METADATA_TYPE_VORBIS_COMMENT;
		vorbis_comment.is_last = (encoder->protected_->num_metadata_blocks == 0);
		vorbis_comment.length = 4 + 4; /* MAGIC NUMBER */
		vorbis_comment.data.vorbis_comment.vendor_string.length = 0;
		vorbis_comment.data.vorbis_comment.vendor_string.entry = 0;
		vorbis_comment.data.vorbis_comment.num_comments = 0;
		vorbis_comment.data.vorbis_comment.comments = 0;
		if(!FLAC__add_metadata_block(&vorbis_comment, encoder->private_->frame)) {
			encoder->protected_->state = FLAC__STREAM_ENCODER_FRAMING_ERROR;
			return FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;
		}
		if(!write_bitbuffer_(encoder, 0, /*is_last_block=*/false)) {
			/* the above function sets the state for us in case of an error */
			return FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;
		}
	}

	/*
	 * write the user's metadata blocks
	 */
	for(i = 0; i < encoder->protected_->num_metadata_blocks; i++) {
		encoder->protected_->metadata[i]->is_last = (i == encoder->protected_->num_metadata_blocks - 1);
		if(!FLAC__add_metadata_block(encoder->protected_->metadata[i], encoder->private_->frame)) {
			encoder->protected_->state = FLAC__STREAM_ENCODER_FRAMING_ERROR;
			return FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;
		}
		if(!write_bitbuffer_(encoder, 0, /*is_last_block=*/false)) {
			/* the above function sets the state for us in case of an error */
			return FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;
		}
	}

	/* now that all the metadata is written, we save the stream offset */
	if(encoder->private_->tell_callback && encoder->private_->tell_callback(encoder, &encoder->protected_->audio_offset, encoder->private_->client_data) == FLAC__STREAM_ENCODER_TELL_STATUS_ERROR) { /* FLAC__STREAM_ENCODER_TELL_STATUS_UNSUPPORTED just means we didn't get the offset; no error */
		encoder->protected_->state = FLAC__STREAM_ENCODER_CLIENT_ERROR;
		return FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;
	}

	if(encoder->protected_->verify)
		encoder->private_->verify.state_hint = ENCODER_IN_AUDIO;

	return FLAC__STREAM_ENCODER_INIT_STATUS_OK;
}

FLAC_API FLAC__StreamEncoderInitStatus FLAC__stream_encoder_init_stream(
	FLAC__StreamEncoder *encoder,
	FLAC__StreamEncoderWriteCallback write_callback,
	FLAC__StreamEncoderSeekCallback seek_callback,
	FLAC__StreamEncoderTellCallback tell_callback,
	FLAC__StreamEncoderMetadataCallback metadata_callback,
	void *client_data
)
{
	return init_stream_internal_enc(
		encoder,
		/*read_callback=*/0,
		write_callback,
		seek_callback,
		tell_callback,
		metadata_callback,
		client_data,
		/*is_ogg=*/false
	);
}

FLAC_API FLAC__StreamEncoderInitStatus FLAC__stream_encoder_init_ogg_stream(
	FLAC__StreamEncoder *encoder,
	FLAC__StreamEncoderReadCallback read_callback,
	FLAC__StreamEncoderWriteCallback write_callback,
	FLAC__StreamEncoderSeekCallback seek_callback,
	FLAC__StreamEncoderTellCallback tell_callback,
	FLAC__StreamEncoderMetadataCallback metadata_callback,
	void *client_data
)
{
	return init_stream_internal_enc(
		encoder,
		read_callback,
		write_callback,
		seek_callback,
		tell_callback,
		metadata_callback,
		client_data,
		/*is_ogg=*/true
	);
}

static FLAC__StreamEncoderInitStatus init_FILE_internal_enc(
	FLAC__StreamEncoder *encoder,
	FILE *file,
	FLAC__StreamEncoderProgressCallback progress_callback,
	void *client_data,
	FLAC__bool is_ogg
)
{
	FLAC__StreamEncoderInitStatus init_status;

	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != file);

	if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
		return FLAC__STREAM_ENCODER_INIT_STATUS_ALREADY_INITIALIZED;

	/* double protection */
	if(file == 0) {
		encoder->protected_->state = FLAC__STREAM_ENCODER_IO_ERROR;
		return FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;
	}

	/*
	 * To make sure that our file does not go unclosed after an error, we
	 * must assign the FILE pointer before any further error can occur in
	 * this routine.
	 */
	if(file == stdout)
		file = get_binary_stdout_(); /* just to be safe */

	encoder->private_->file = file;

	encoder->private_->progress_callback = progress_callback;
	encoder->private_->bytes_written = 0;
	encoder->private_->samples_written = 0;
	encoder->private_->frames_written = 0;

	init_status = init_stream_internal_enc(
		encoder,
		encoder->private_->file == stdout? 0 : is_ogg? file_read_callback_enc : 0,
		file_write_callback_,
		encoder->private_->file == stdout? 0 : file_seek_callback_enc,
		encoder->private_->file == stdout? 0 : file_tell_callback_enc,
		/*metadata_callback=*/0,
		client_data,
		is_ogg
	);
	if(init_status != FLAC__STREAM_ENCODER_INIT_STATUS_OK) {
		/* the above function sets the state for us in case of an error */
		return init_status;
	}

	{
		unsigned blocksize = FLAC__stream_encoder_get_blocksize(encoder);

		FLAC__ASSERT(blocksize != 0);
		encoder->private_->total_frames_estimate = (unsigned)((FLAC__stream_encoder_get_total_samples_estimate(encoder) + blocksize - 1) / blocksize);
	}

	return init_status;
}

FLAC_API FLAC__StreamEncoderInitStatus FLAC__stream_encoder_init_FILE(
	FLAC__StreamEncoder *encoder,
	FILE *file,
	FLAC__StreamEncoderProgressCallback progress_callback,
	void *client_data
)
{
	return init_FILE_internal_enc(encoder, file, progress_callback, client_data, /*is_ogg=*/false);
}

FLAC_API FLAC__StreamEncoderInitStatus FLAC__stream_encoder_init_ogg_FILE(
	FLAC__StreamEncoder *encoder,
	FILE *file,
	FLAC__StreamEncoderProgressCallback progress_callback,
	void *client_data
)
{
	return init_FILE_internal_enc(encoder, file, progress_callback, client_data, /*is_ogg=*/true);
}

static FLAC__StreamEncoderInitStatus init_file_internal_enc(
	FLAC__StreamEncoder *encoder,
	const char *filename,
	FLAC__StreamEncoderProgressCallback progress_callback,
	void *client_data,
	FLAC__bool is_ogg
)
{
	FILE *file;

	FLAC__ASSERT(0 != encoder);

	/*
	 * To make sure that our file does not go unclosed after an error, we
	 * have to do the same entrance checks here that are later performed
	 * in FLAC__stream_encoder_init_FILE() before the FILE* is assigned.
	 */
	if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
		return FLAC__STREAM_ENCODER_INIT_STATUS_ALREADY_INITIALIZED;

	file = filename? fopen(filename, "w+b") : stdout;

	if(file == 0) {
		encoder->protected_->state = FLAC__STREAM_ENCODER_IO_ERROR;
		return FLAC__STREAM_ENCODER_INIT_STATUS_ENCODER_ERROR;
	}

	return init_FILE_internal_enc(encoder, file, progress_callback, client_data, is_ogg);
}

FLAC_API FLAC__StreamEncoderInitStatus FLAC__stream_encoder_init_file(
	FLAC__StreamEncoder *encoder,
	const char *filename,
	FLAC__StreamEncoderProgressCallback progress_callback,
	void *client_data
)
{
	return init_file_internal_enc(encoder, filename, progress_callback, client_data, /*is_ogg=*/false);
}

FLAC_API FLAC__StreamEncoderInitStatus FLAC__stream_encoder_init_ogg_file(
	FLAC__StreamEncoder *encoder,
	const char *filename,
	FLAC__StreamEncoderProgressCallback progress_callback,
	void *client_data
)
{
	return init_file_internal_enc(encoder, filename, progress_callback, client_data, /*is_ogg=*/true);
}

FLAC_API FLAC__bool FLAC__stream_encoder_finish(FLAC__StreamEncoder *encoder)
{
	FLAC__bool error = false;

	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);

	if(encoder->protected_->state == FLAC__STREAM_ENCODER_UNINITIALIZED)
		return true;

	if(encoder->protected_->state == FLAC__STREAM_ENCODER_OK && !encoder->private_->is_being_deleted) {
		if(encoder->private_->current_sample_number != 0) {
			const FLAC__bool is_fractional_block = encoder->protected_->blocksize != encoder->private_->current_sample_number;
			encoder->protected_->blocksize = encoder->private_->current_sample_number;
			if(!process_frame_(encoder, is_fractional_block, /*is_last_block=*/true))
				error = true;
		}
	}

	if(encoder->protected_->do_md5)
		FLAC__MD5Final(encoder->private_->streaminfo.data.stream_info.md5sum, &encoder->private_->md5context);

	if(!encoder->private_->is_being_deleted) {
		if(encoder->protected_->state == FLAC__STREAM_ENCODER_OK) {
			if(encoder->private_->seek_callback) {
#if FLAC__HAS_OGG
				if(encoder->private_->is_ogg)
					update_ogg_metadata_(encoder);
				else
#endif
				update_metadata_(encoder);

				/* check if an error occurred while updating metadata */
				if(encoder->protected_->state != FLAC__STREAM_ENCODER_OK)
					error = true;
			}
			if(encoder->private_->metadata_callback)
				encoder->private_->metadata_callback(encoder, &encoder->private_->streaminfo, encoder->private_->client_data);
		}

		if(encoder->protected_->verify && 0 != encoder->private_->verify.decoder && !FLAC__stream_decoder_finish(encoder->private_->verify.decoder)) {
			if(!error)
				encoder->protected_->state = FLAC__STREAM_ENCODER_VERIFY_MISMATCH_IN_AUDIO_DATA;
			error = true;
		}
	}

	if(0 != encoder->private_->file) {
		if(encoder->private_->file != stdout)
			fclose(encoder->private_->file);
		encoder->private_->file = 0;
	}

#if FLAC__HAS_OGG
	if(encoder->private_->is_ogg)
		FLAC__ogg_encoder_aspect_finish(&encoder->protected_->ogg_encoder_aspect);
#endif

	free_(encoder);
	set_defaults_enc(encoder);

	if(!error)
		encoder->protected_->state = FLAC__STREAM_ENCODER_UNINITIALIZED;

	return !error;
}

FLAC_API FLAC__bool FLAC__stream_encoder_set_ogg_serial_number(FLAC__StreamEncoder *encoder, long value)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
		return false;
#if FLAC__HAS_OGG
	/* can't check encoder->private_->is_ogg since that's not set until init time */
	FLAC__ogg_encoder_aspect_set_serial_number(&encoder->protected_->ogg_encoder_aspect, value);
	return true;
#else
	(void)value;
	return false;
#endif
}

FLAC_API FLAC__bool FLAC__stream_encoder_set_verify(FLAC__StreamEncoder *encoder, FLAC__bool value)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
		return false;
#ifndef FLAC__MANDATORY_VERIFY_WHILE_ENCODING
	encoder->protected_->verify = value;
#endif
	return true;
}

FLAC_API FLAC__bool FLAC__stream_encoder_set_streamable_subset(FLAC__StreamEncoder *encoder, FLAC__bool value)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
		return false;
	encoder->protected_->streamable_subset = value;
	return true;
}

FLAC_API FLAC__bool FLAC__stream_encoder_set_do_md5(FLAC__StreamEncoder *encoder, FLAC__bool value)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
		return false;
	encoder->protected_->do_md5 = value;
	return true;
}

FLAC_API FLAC__bool FLAC__stream_encoder_set_channels(FLAC__StreamEncoder *encoder, unsigned value)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
		return false;
	encoder->protected_->channels = value;
	return true;
}

FLAC_API FLAC__bool FLAC__stream_encoder_set_bits_per_sample(FLAC__StreamEncoder *encoder, unsigned value)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
		return false;
	encoder->protected_->bits_per_sample = value;
	return true;
}

FLAC_API FLAC__bool FLAC__stream_encoder_set_sample_rate(FLAC__StreamEncoder *encoder, unsigned value)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
		return false;
	encoder->protected_->sample_rate = value;
	return true;
}

FLAC_API FLAC__bool FLAC__stream_encoder_set_compression_level(FLAC__StreamEncoder *encoder, unsigned value)
{
	FLAC__bool ok = true;
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
		return false;
	if(value >= sizeof(compression_levels_)/sizeof(compression_levels_[0]))
		value = sizeof(compression_levels_)/sizeof(compression_levels_[0]) - 1;
	ok &= FLAC__stream_encoder_set_do_mid_side_stereo          (encoder, compression_levels_[value].do_mid_side_stereo);
	ok &= FLAC__stream_encoder_set_loose_mid_side_stereo       (encoder, compression_levels_[value].loose_mid_side_stereo);
#ifndef FLAC__INTEGER_ONLY_LIBRARY
#if 0
	/* was: */
	ok &= FLAC__stream_encoder_set_apodization                 (encoder, compression_levels_[value].apodization);
	/* but it's too hard to specify the string in a locale-specific way */
#else
	encoder->protected_->num_apodizations = 1;
	encoder->protected_->apodizations[0].type = FLAC__APODIZATION_TUKEY;
	encoder->protected_->apodizations[0].parameters.tukey.p = 0.5;
#endif
#endif
	ok &= FLAC__stream_encoder_set_max_lpc_order               (encoder, compression_levels_[value].max_lpc_order);
	ok &= FLAC__stream_encoder_set_qlp_coeff_precision         (encoder, compression_levels_[value].qlp_coeff_precision);
	ok &= FLAC__stream_encoder_set_do_qlp_coeff_prec_search    (encoder, compression_levels_[value].do_qlp_coeff_prec_search);
	ok &= FLAC__stream_encoder_set_do_escape_coding            (encoder, compression_levels_[value].do_escape_coding);
	ok &= FLAC__stream_encoder_set_do_exhaustive_model_search  (encoder, compression_levels_[value].do_exhaustive_model_search);
	ok &= FLAC__stream_encoder_set_min_residual_partition_order(encoder, compression_levels_[value].min_residual_partition_order);
	ok &= FLAC__stream_encoder_set_max_residual_partition_order(encoder, compression_levels_[value].max_residual_partition_order);
	ok &= FLAC__stream_encoder_set_rice_parameter_search_dist  (encoder, compression_levels_[value].rice_parameter_search_dist);
	return ok;
}

FLAC_API FLAC__bool FLAC__stream_encoder_set_blocksize(FLAC__StreamEncoder *encoder, unsigned value)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
		return false;
	encoder->protected_->blocksize = value;
	return true;
}

FLAC_API FLAC__bool FLAC__stream_encoder_set_do_mid_side_stereo(FLAC__StreamEncoder *encoder, FLAC__bool value)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
		return false;
	encoder->protected_->do_mid_side_stereo = value;
	return true;
}

FLAC_API FLAC__bool FLAC__stream_encoder_set_loose_mid_side_stereo(FLAC__StreamEncoder *encoder, FLAC__bool value)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
		return false;
	encoder->protected_->loose_mid_side_stereo = value;
	return true;
}

/*@@@@add to tests*/
FLAC_API FLAC__bool FLAC__stream_encoder_set_apodization(FLAC__StreamEncoder *encoder, const char *specification)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	FLAC__ASSERT(0 != specification);
	if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
		return false;
#ifdef FLAC__INTEGER_ONLY_LIBRARY
	(void)specification; /* silently ignore since we haven't integerized; will always use a rectangular window */
#else
	encoder->protected_->num_apodizations = 0;
	while(1) {
		const char *s = strchr(specification, ';');
		const size_t n = s? (size_t)(s - specification) : strlen(specification);
		if     (n==8  && 0 == strncmp("bartlett"     , specification, n))
			encoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_BARTLETT;
		else if(n==13 && 0 == strncmp("bartlett_hann", specification, n))
			encoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_BARTLETT_HANN;
		else if(n==8  && 0 == strncmp("blackman"     , specification, n))
			encoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_BLACKMAN;
		else if(n==26 && 0 == strncmp("blackman_harris_4term_92db", specification, n))
			encoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_BLACKMAN_HARRIS_4TERM_92DB_SIDELOBE;
		else if(n==6  && 0 == strncmp("connes"       , specification, n))
			encoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_CONNES;
		else if(n==7  && 0 == strncmp("flattop"      , specification, n))
			encoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_FLATTOP;
		else if(n>7   && 0 == strncmp("gauss("       , specification, 6)) {
			FLAC__real stddev = (FLAC__real)strtod(specification+6, 0);
			if (stddev > 0.0 && stddev <= 0.5) {
				encoder->protected_->apodizations[encoder->protected_->num_apodizations].parameters.gauss.stddev = stddev;
				encoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_GAUSS;
			}
		}
		else if(n==7  && 0 == strncmp("hamming"      , specification, n))
			encoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_HAMMING;
		else if(n==4  && 0 == strncmp("hann"         , specification, n))
			encoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_HANN;
		else if(n==13 && 0 == strncmp("kaiser_bessel", specification, n))
			encoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_KAISER_BESSEL;
		else if(n==7  && 0 == strncmp("nuttall"      , specification, n))
			encoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_NUTTALL;
		else if(n==9  && 0 == strncmp("rectangle"    , specification, n))
			encoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_RECTANGLE;
		else if(n==8  && 0 == strncmp("triangle"     , specification, n))
			encoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_TRIANGLE;
		else if(n>7   && 0 == strncmp("tukey("       , specification, 6)) {
			FLAC__real p = (FLAC__real)strtod(specification+6, 0);
			if (p >= 0.0 && p <= 1.0) {
				encoder->protected_->apodizations[encoder->protected_->num_apodizations].parameters.tukey.p = p;
				encoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_TUKEY;
			}
		}
		else if(n==5  && 0 == strncmp("welch"        , specification, n))
			encoder->protected_->apodizations[encoder->protected_->num_apodizations++].type = FLAC__APODIZATION_WELCH;
		if (encoder->protected_->num_apodizations == 32)
			break;
		if (s)
			specification = s+1;
		else
			break;
	}
	if(encoder->protected_->num_apodizations == 0) {
		encoder->protected_->num_apodizations = 1;
		encoder->protected_->apodizations[0].type = FLAC__APODIZATION_TUKEY;
		encoder->protected_->apodizations[0].parameters.tukey.p = 0.5;
	}
#endif
	return true;
}

FLAC_API FLAC__bool FLAC__stream_encoder_set_max_lpc_order(FLAC__StreamEncoder *encoder, unsigned value)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
		return false;
	encoder->protected_->max_lpc_order = value;
	return true;
}

FLAC_API FLAC__bool FLAC__stream_encoder_set_qlp_coeff_precision(FLAC__StreamEncoder *encoder, unsigned value)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
		return false;
	encoder->protected_->qlp_coeff_precision = value;
	return true;
}

FLAC_API FLAC__bool FLAC__stream_encoder_set_do_qlp_coeff_prec_search(FLAC__StreamEncoder *encoder, FLAC__bool value)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
		return false;
	encoder->protected_->do_qlp_coeff_prec_search = value;
	return true;
}

FLAC_API FLAC__bool FLAC__stream_encoder_set_do_escape_coding(FLAC__StreamEncoder *encoder, FLAC__bool value)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
		return false;
#if 0
	/*@@@ deprecated: */
	encoder->protected_->do_escape_coding = value;
#else
	(void)value;
#endif
	return true;
}

FLAC_API FLAC__bool FLAC__stream_encoder_set_do_exhaustive_model_search(FLAC__StreamEncoder *encoder, FLAC__bool value)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
		return false;
	encoder->protected_->do_exhaustive_model_search = value;
	return true;
}

FLAC_API FLAC__bool FLAC__stream_encoder_set_min_residual_partition_order(FLAC__StreamEncoder *encoder, unsigned value)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
		return false;
	encoder->protected_->min_residual_partition_order = value;
	return true;
}

FLAC_API FLAC__bool FLAC__stream_encoder_set_max_residual_partition_order(FLAC__StreamEncoder *encoder, unsigned value)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
		return false;
	encoder->protected_->max_residual_partition_order = value;
	return true;
}

FLAC_API FLAC__bool FLAC__stream_encoder_set_rice_parameter_search_dist(FLAC__StreamEncoder *encoder, unsigned value)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
		return false;
#if 0
	/*@@@ deprecated: */
	encoder->protected_->rice_parameter_search_dist = value;
#else
	(void)value;
#endif
	return true;
}

FLAC_API FLAC__bool FLAC__stream_encoder_set_total_samples_estimate(FLAC__StreamEncoder *encoder, FLAC__uint64 value)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
		return false;
	encoder->protected_->total_samples_estimate = value;
	return true;
}

FLAC_API FLAC__bool FLAC__stream_encoder_set_metadata(FLAC__StreamEncoder *encoder, FLAC__StreamMetadata **metadata, unsigned num_blocks)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
		return false;
	if(0 == metadata)
		num_blocks = 0;
	if(0 == num_blocks)
		metadata = 0;
	/* realloc() does not do exactly what we want so... */
	if(encoder->protected_->metadata) {
		free(encoder->protected_->metadata);
		encoder->protected_->metadata = 0;
		encoder->protected_->num_metadata_blocks = 0;
	}
	if(num_blocks) {
		FLAC__StreamMetadata **m;
		if(0 == (m = (FLAC__StreamMetadata**)safe_malloc_mul_2op_(sizeof(m[0]), /*times*/num_blocks)))
			return false;
		memcpy(m, metadata, sizeof(m[0]) * num_blocks);
		encoder->protected_->metadata = m;
		encoder->protected_->num_metadata_blocks = num_blocks;
	}
#if FLAC__HAS_OGG
	if(!FLAC__ogg_encoder_aspect_set_num_metadata(&encoder->protected_->ogg_encoder_aspect, num_blocks))
		return false;
#endif
	return true;
}

/*
 * These three functions are not static, but not publically exposed in
 * include/FLAC/ either.  They are used by the test suite.
 */
FLAC_API FLAC__bool FLAC__stream_encoder_disable_constant_subframes(FLAC__StreamEncoder *encoder, FLAC__bool value)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
		return false;
	encoder->private_->disable_constant_subframes = value;
	return true;
}

FLAC_API FLAC__bool FLAC__stream_encoder_disable_fixed_subframes(FLAC__StreamEncoder *encoder, FLAC__bool value)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
		return false;
	encoder->private_->disable_fixed_subframes = value;
	return true;
}

FLAC_API FLAC__bool FLAC__stream_encoder_disable_verbatim_subframes(FLAC__StreamEncoder *encoder, FLAC__bool value)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
		return false;
	encoder->private_->disable_verbatim_subframes = value;
	return true;
}

FLAC_API FLAC__StreamEncoderState FLAC__stream_encoder_get_state(const FLAC__StreamEncoder *encoder)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	return encoder->protected_->state;
}

FLAC_API FLAC__StreamDecoderState FLAC__stream_encoder_get_verify_decoder_state(const FLAC__StreamEncoder *encoder)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	if(encoder->protected_->verify)
		return FLAC__stream_decoder_get_state(encoder->private_->verify.decoder);
	else
		return FLAC__STREAM_DECODER_UNINITIALIZED;
}

FLAC_API const char *FLAC__stream_encoder_get_resolved_state_string(const FLAC__StreamEncoder *encoder)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	if(encoder->protected_->state != FLAC__STREAM_ENCODER_VERIFY_DECODER_ERROR)
		return FLAC__StreamEncoderStateString[encoder->protected_->state];
	else
		return FLAC__stream_decoder_get_resolved_state_string(encoder->private_->verify.decoder);
}

FLAC_API void FLAC__stream_encoder_get_verify_decoder_error_stats(const FLAC__StreamEncoder *encoder, FLAC__uint64 *absolute_sample, unsigned *frame_number, unsigned *channel, unsigned *sample, FLAC__int32 *expected, FLAC__int32 *got)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	if(0 != absolute_sample)
		*absolute_sample = encoder->private_->verify.error_stats.absolute_sample;
	if(0 != frame_number)
		*frame_number = encoder->private_->verify.error_stats.frame_number;
	if(0 != channel)
		*channel = encoder->private_->verify.error_stats.channel;
	if(0 != sample)
		*sample = encoder->private_->verify.error_stats.sample;
	if(0 != expected)
		*expected = encoder->private_->verify.error_stats.expected;
	if(0 != got)
		*got = encoder->private_->verify.error_stats.got;
}

FLAC_API FLAC__bool FLAC__stream_encoder_get_verify(const FLAC__StreamEncoder *encoder)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	return encoder->protected_->verify;
}

FLAC_API FLAC__bool FLAC__stream_encoder_get_streamable_subset(const FLAC__StreamEncoder *encoder)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	return encoder->protected_->streamable_subset;
}

FLAC_API FLAC__bool FLAC__stream_encoder_get_do_md5(const FLAC__StreamEncoder *encoder)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	return encoder->protected_->do_md5;
}

FLAC_API unsigned FLAC__stream_encoder_get_channels(const FLAC__StreamEncoder *encoder)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	return encoder->protected_->channels;
}

FLAC_API unsigned FLAC__stream_encoder_get_bits_per_sample(const FLAC__StreamEncoder *encoder)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	return encoder->protected_->bits_per_sample;
}

FLAC_API unsigned FLAC__stream_encoder_get_sample_rate(const FLAC__StreamEncoder *encoder)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	return encoder->protected_->sample_rate;
}

FLAC_API unsigned FLAC__stream_encoder_get_blocksize(const FLAC__StreamEncoder *encoder)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	return encoder->protected_->blocksize;
}

FLAC_API FLAC__bool FLAC__stream_encoder_get_do_mid_side_stereo(const FLAC__StreamEncoder *encoder)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	return encoder->protected_->do_mid_side_stereo;
}

FLAC_API FLAC__bool FLAC__stream_encoder_get_loose_mid_side_stereo(const FLAC__StreamEncoder *encoder)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	return encoder->protected_->loose_mid_side_stereo;
}

FLAC_API unsigned FLAC__stream_encoder_get_max_lpc_order(const FLAC__StreamEncoder *encoder)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	return encoder->protected_->max_lpc_order;
}

FLAC_API unsigned FLAC__stream_encoder_get_qlp_coeff_precision(const FLAC__StreamEncoder *encoder)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	return encoder->protected_->qlp_coeff_precision;
}

FLAC_API FLAC__bool FLAC__stream_encoder_get_do_qlp_coeff_prec_search(const FLAC__StreamEncoder *encoder)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	return encoder->protected_->do_qlp_coeff_prec_search;
}

FLAC_API FLAC__bool FLAC__stream_encoder_get_do_escape_coding(const FLAC__StreamEncoder *encoder)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	return encoder->protected_->do_escape_coding;
}

FLAC_API FLAC__bool FLAC__stream_encoder_get_do_exhaustive_model_search(const FLAC__StreamEncoder *encoder)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	return encoder->protected_->do_exhaustive_model_search;
}

FLAC_API unsigned FLAC__stream_encoder_get_min_residual_partition_order(const FLAC__StreamEncoder *encoder)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	return encoder->protected_->min_residual_partition_order;
}

FLAC_API unsigned FLAC__stream_encoder_get_max_residual_partition_order(const FLAC__StreamEncoder *encoder)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	return encoder->protected_->max_residual_partition_order;
}

FLAC_API unsigned FLAC__stream_encoder_get_rice_parameter_search_dist(const FLAC__StreamEncoder *encoder)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	return encoder->protected_->rice_parameter_search_dist;
}

FLAC_API FLAC__uint64 FLAC__stream_encoder_get_total_samples_estimate(const FLAC__StreamEncoder *encoder)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	return encoder->protected_->total_samples_estimate;
}

FLAC_API FLAC__bool FLAC__stream_encoder_process(FLAC__StreamEncoder *encoder, const FLAC__int32 * const buffer[], unsigned samples)
{
	unsigned i, j = 0, channel;
	const unsigned channels = encoder->protected_->channels, blocksize = encoder->protected_->blocksize;

	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	FLAC__ASSERT(encoder->protected_->state == FLAC__STREAM_ENCODER_OK);

	do {
		const unsigned n = min(blocksize+OVERREAD_-encoder->private_->current_sample_number, samples-j);

		if(encoder->protected_->verify)
			append_to_verify_fifo_(&encoder->private_->verify.input_fifo, buffer, j, channels, n);

		for(channel = 0; channel < channels; channel++)
			memcpy(&encoder->private_->integer_signal[channel][encoder->private_->current_sample_number], &buffer[channel][j], sizeof(buffer[channel][0]) * n);

		if(encoder->protected_->do_mid_side_stereo) {
			FLAC__ASSERT(channels == 2);
			/* "i <= blocksize" to overread 1 sample; see comment in OVERREAD_ decl */
			for(i = encoder->private_->current_sample_number; i <= blocksize && j < samples; i++, j++) {
				encoder->private_->integer_signal_mid_side[1][i] = buffer[0][j] - buffer[1][j];
				encoder->private_->integer_signal_mid_side[0][i] = (buffer[0][j] + buffer[1][j]) >> 1; /* NOTE: not the same as 'mid = (buffer[0][j] + buffer[1][j]) / 2' ! */
			}
		}
		else
			j += n;

		encoder->private_->current_sample_number += n;

		/* we only process if we have a full block + 1 extra sample; final block is always handled by FLAC__stream_encoder_finish() */
		if(encoder->private_->current_sample_number > blocksize) {
			FLAC__ASSERT(encoder->private_->current_sample_number == blocksize+OVERREAD_);
			FLAC__ASSERT(OVERREAD_ == 1); /* assert we only overread 1 sample which simplifies the rest of the code below */
			if(!process_frame_(encoder, /*is_fractional_block=*/false, /*is_last_block=*/false))
				return false;
			/* move unprocessed overread samples to beginnings of arrays */
			for(channel = 0; channel < channels; channel++)
				encoder->private_->integer_signal[channel][0] = encoder->private_->integer_signal[channel][blocksize];
			if(encoder->protected_->do_mid_side_stereo) {
				encoder->private_->integer_signal_mid_side[0][0] = encoder->private_->integer_signal_mid_side[0][blocksize];
				encoder->private_->integer_signal_mid_side[1][0] = encoder->private_->integer_signal_mid_side[1][blocksize];
			}
			encoder->private_->current_sample_number = 1;
		}
	} while(j < samples);

	return true;
}

FLAC_API FLAC__bool FLAC__stream_encoder_process_interleaved(FLAC__StreamEncoder *encoder, const FLAC__int32 buffer[], unsigned samples)
{
	unsigned i, j, k, channel;
	FLAC__int32 x, mid, side;
	const unsigned channels = encoder->protected_->channels, blocksize = encoder->protected_->blocksize;

	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	FLAC__ASSERT(encoder->protected_->state == FLAC__STREAM_ENCODER_OK);

	j = k = 0;
	/*
	 * we have several flavors of the same basic loop, optimized for
	 * different conditions:
	 */
	if(encoder->protected_->do_mid_side_stereo && channels == 2) {
		/*
		 * stereo coding: unroll channel loop
		 */
		do {
			if(encoder->protected_->verify)
				append_to_verify_fifo_interleaved_(&encoder->private_->verify.input_fifo, buffer, j, channels, min(blocksize+OVERREAD_-encoder->private_->current_sample_number, samples-j));

			/* "i <= blocksize" to overread 1 sample; see comment in OVERREAD_ decl */
			for(i = encoder->private_->current_sample_number; i <= blocksize && j < samples; i++, j++) {
				encoder->private_->integer_signal[0][i] = mid = side = buffer[k++];
				x = buffer[k++];
				encoder->private_->integer_signal[1][i] = x;
				mid += x;
				side -= x;
				mid >>= 1; /* NOTE: not the same as 'mid = (left + right) / 2' ! */
				encoder->private_->integer_signal_mid_side[1][i] = side;
				encoder->private_->integer_signal_mid_side[0][i] = mid;
			}
			encoder->private_->current_sample_number = i;
			/* we only process if we have a full block + 1 extra sample; final block is always handled by FLAC__stream_encoder_finish() */
			if(i > blocksize) {
				if(!process_frame_(encoder, /*is_fractional_block=*/false, /*is_last_block=*/false))
					return false;
				/* move unprocessed overread samples to beginnings of arrays */
				FLAC__ASSERT(i == blocksize+OVERREAD_);
				FLAC__ASSERT(OVERREAD_ == 1); /* assert we only overread 1 sample which simplifies the rest of the code below */
				encoder->private_->integer_signal[0][0] = encoder->private_->integer_signal[0][blocksize];
				encoder->private_->integer_signal[1][0] = encoder->private_->integer_signal[1][blocksize];
				encoder->private_->integer_signal_mid_side[0][0] = encoder->private_->integer_signal_mid_side[0][blocksize];
				encoder->private_->integer_signal_mid_side[1][0] = encoder->private_->integer_signal_mid_side[1][blocksize];
				encoder->private_->current_sample_number = 1;
			}
		} while(j < samples);
	}
	else {
		/*
		 * independent channel coding: buffer each channel in inner loop
		 */
		do {
			if(encoder->protected_->verify)
				append_to_verify_fifo_interleaved_(&encoder->private_->verify.input_fifo, buffer, j, channels, min(blocksize+OVERREAD_-encoder->private_->current_sample_number, samples-j));

			/* "i <= blocksize" to overread 1 sample; see comment in OVERREAD_ decl */
			for(i = encoder->private_->current_sample_number; i <= blocksize && j < samples; i++, j++) {
				for(channel = 0; channel < channels; channel++)
					encoder->private_->integer_signal[channel][i] = buffer[k++];
			}
			encoder->private_->current_sample_number = i;
			/* we only process if we have a full block + 1 extra sample; final block is always handled by FLAC__stream_encoder_finish() */
			if(i > blocksize) {
				if(!process_frame_(encoder, /*is_fractional_block=*/false, /*is_last_block=*/false))
					return false;
				/* move unprocessed overread samples to beginnings of arrays */
				FLAC__ASSERT(i == blocksize+OVERREAD_);
				FLAC__ASSERT(OVERREAD_ == 1); /* assert we only overread 1 sample which simplifies the rest of the code below */
				for(channel = 0; channel < channels; channel++)
					encoder->private_->integer_signal[channel][0] = encoder->private_->integer_signal[channel][blocksize];
				encoder->private_->current_sample_number = 1;
			}
		} while(j < samples);
	}

	return true;
}

/***********************************************************************
 *
 * Private class methods
 *
 ***********************************************************************/

void set_defaults_enc(FLAC__StreamEncoder *encoder)
{
	FLAC__ASSERT(0 != encoder);

#ifdef FLAC__MANDATORY_VERIFY_WHILE_ENCODING
	encoder->protected_->verify = true;
#else
	encoder->protected_->verify = false;
#endif
	encoder->protected_->streamable_subset = true;
	encoder->protected_->do_md5 = true;
	encoder->protected_->do_mid_side_stereo = false;
	encoder->protected_->loose_mid_side_stereo = false;
	encoder->protected_->channels = 2;
	encoder->protected_->bits_per_sample = 16;
	encoder->protected_->sample_rate = 44100;
	encoder->protected_->blocksize = 0;
#ifndef FLAC__INTEGER_ONLY_LIBRARY
	encoder->protected_->num_apodizations = 1;
	encoder->protected_->apodizations[0].type = FLAC__APODIZATION_TUKEY;
	encoder->protected_->apodizations[0].parameters.tukey.p = 0.5;
#endif
	encoder->protected_->max_lpc_order = 0;
	encoder->protected_->qlp_coeff_precision = 0;
	encoder->protected_->do_qlp_coeff_prec_search = false;
	encoder->protected_->do_exhaustive_model_search = false;
	encoder->protected_->do_escape_coding = false;
	encoder->protected_->min_residual_partition_order = 0;
	encoder->protected_->max_residual_partition_order = 0;
	encoder->protected_->rice_parameter_search_dist = 0;
	encoder->protected_->total_samples_estimate = 0;
	encoder->protected_->metadata = 0;
	encoder->protected_->num_metadata_blocks = 0;

	encoder->private_->seek_table = 0;
	encoder->private_->disable_constant_subframes = false;
	encoder->private_->disable_fixed_subframes = false;
	encoder->private_->disable_verbatim_subframes = false;
#if FLAC__HAS_OGG
	encoder->private_->is_ogg = false;
#endif
	encoder->private_->read_callback = 0;
	encoder->private_->write_callback = 0;
	encoder->private_->seek_callback = 0;
	encoder->private_->tell_callback = 0;
	encoder->private_->metadata_callback = 0;
	encoder->private_->progress_callback = 0;
	encoder->private_->client_data = 0;

#if FLAC__HAS_OGG
	FLAC__ogg_encoder_aspect_set_defaults(&encoder->protected_->ogg_encoder_aspect);
#endif
}

void free_(FLAC__StreamEncoder *encoder)
{
	unsigned i, channel;

	FLAC__ASSERT(0 != encoder);
	if(encoder->protected_->metadata) {
		free(encoder->protected_->metadata);
		encoder->protected_->metadata = 0;
		encoder->protected_->num_metadata_blocks = 0;
	}
	for(i = 0; i < encoder->protected_->channels; i++) {
		if(0 != encoder->private_->integer_signal_unaligned[i]) {
			free(encoder->private_->integer_signal_unaligned[i]);
			encoder->private_->integer_signal_unaligned[i] = 0;
		}
#ifndef FLAC__INTEGER_ONLY_LIBRARY
		if(0 != encoder->private_->real_signal_unaligned[i]) {
			free(encoder->private_->real_signal_unaligned[i]);
			encoder->private_->real_signal_unaligned[i] = 0;
		}
#endif
	}
	for(i = 0; i < 2; i++) {
		if(0 != encoder->private_->integer_signal_mid_side_unaligned[i]) {
			free(encoder->private_->integer_signal_mid_side_unaligned[i]);
			encoder->private_->integer_signal_mid_side_unaligned[i] = 0;
		}
#ifndef FLAC__INTEGER_ONLY_LIBRARY
		if(0 != encoder->private_->real_signal_mid_side_unaligned[i]) {
			free(encoder->private_->real_signal_mid_side_unaligned[i]);
			encoder->private_->real_signal_mid_side_unaligned[i] = 0;
		}
#endif
	}
#ifndef FLAC__INTEGER_ONLY_LIBRARY
	for(i = 0; i < encoder->protected_->num_apodizations; i++) {
		if(0 != encoder->private_->window_unaligned[i]) {
			free(encoder->private_->window_unaligned[i]);
			encoder->private_->window_unaligned[i] = 0;
		}
	}
	if(0 != encoder->private_->windowed_signal_unaligned) {
		free(encoder->private_->windowed_signal_unaligned);
		encoder->private_->windowed_signal_unaligned = 0;
	}
#endif
	for(channel = 0; channel < encoder->protected_->channels; channel++) {
		for(i = 0; i < 2; i++) {
			if(0 != encoder->private_->residual_workspace_unaligned[channel][i]) {
				free(encoder->private_->residual_workspace_unaligned[channel][i]);
				encoder->private_->residual_workspace_unaligned[channel][i] = 0;
			}
		}
	}
	for(channel = 0; channel < 2; channel++) {
		for(i = 0; i < 2; i++) {
			if(0 != encoder->private_->residual_workspace_mid_side_unaligned[channel][i]) {
				free(encoder->private_->residual_workspace_mid_side_unaligned[channel][i]);
				encoder->private_->residual_workspace_mid_side_unaligned[channel][i] = 0;
			}
		}
	}
	if(0 != encoder->private_->abs_residual_partition_sums_unaligned) {
		free(encoder->private_->abs_residual_partition_sums_unaligned);
		encoder->private_->abs_residual_partition_sums_unaligned = 0;
	}
	if(0 != encoder->private_->raw_bits_per_partition_unaligned) {
		free(encoder->private_->raw_bits_per_partition_unaligned);
		encoder->private_->raw_bits_per_partition_unaligned = 0;
	}
	if(encoder->protected_->verify) {
		for(i = 0; i < encoder->protected_->channels; i++) {
			if(0 != encoder->private_->verify.input_fifo.data[i]) {
				free(encoder->private_->verify.input_fifo.data[i]);
				encoder->private_->verify.input_fifo.data[i] = 0;
			}
		}
	}
	FLAC__bitwriter_free(encoder->private_->frame);
}

FLAC__bool resize_buffers_(FLAC__StreamEncoder *encoder, unsigned new_blocksize)
{
	FLAC__bool ok;
	unsigned i, channel;

	FLAC__ASSERT(new_blocksize > 0);
	FLAC__ASSERT(encoder->protected_->state == FLAC__STREAM_ENCODER_OK);
	FLAC__ASSERT(encoder->private_->current_sample_number == 0);

	/* To avoid excessive malloc'ing, we only grow the buffer; no shrinking. */
	if(new_blocksize <= encoder->private_->input_capacity)
		return true;

	ok = true;

	/* WATCHOUT: FLAC__lpc_compute_residual_from_qlp_coefficients_asm_ia32_mmx()
	 * requires that the input arrays (in our case the integer signals)
	 * have a buffer of up to 3 zeroes in front (at negative indices) for
	 * alignment purposes; we use 4 in front to keep the data well-aligned.
	 */

	for(i = 0; ok && i < encoder->protected_->channels; i++) {
		ok = ok && FLAC__memory_alloc_aligned_int32_array(new_blocksize+4+OVERREAD_, &encoder->private_->integer_signal_unaligned[i], &encoder->private_->integer_signal[i]);
		memset(encoder->private_->integer_signal[i], 0, sizeof(FLAC__int32)*4);
		encoder->private_->integer_signal[i] += 4;
#ifndef FLAC__INTEGER_ONLY_LIBRARY
#if 0 /* @@@ currently unused */
		if(encoder->protected_->max_lpc_order > 0)
			ok = ok && FLAC__memory_alloc_aligned_real_array(new_blocksize+OVERREAD_, &encoder->private_->real_signal_unaligned[i], &encoder->private_->real_signal[i]);
#endif
#endif
	}
	for(i = 0; ok && i < 2; i++) {
		ok = ok && FLAC__memory_alloc_aligned_int32_array(new_blocksize+4+OVERREAD_, &encoder->private_->integer_signal_mid_side_unaligned[i], &encoder->private_->integer_signal_mid_side[i]);
		memset(encoder->private_->integer_signal_mid_side[i], 0, sizeof(FLAC__int32)*4);
		encoder->private_->integer_signal_mid_side[i] += 4;
#ifndef FLAC__INTEGER_ONLY_LIBRARY
#if 0 /* @@@ currently unused */
		if(encoder->protected_->max_lpc_order > 0)
			ok = ok && FLAC__memory_alloc_aligned_real_array(new_blocksize+OVERREAD_, &encoder->private_->real_signal_mid_side_unaligned[i], &encoder->private_->real_signal_mid_side[i]);
#endif
#endif
	}
#ifndef FLAC__INTEGER_ONLY_LIBRARY
	if(ok && encoder->protected_->max_lpc_order > 0) {
		for(i = 0; ok && i < encoder->protected_->num_apodizations; i++)
			ok = ok && FLAC__memory_alloc_aligned_real_array(new_blocksize, &encoder->private_->window_unaligned[i], &encoder->private_->window[i]);
		ok = ok && FLAC__memory_alloc_aligned_real_array(new_blocksize, &encoder->private_->windowed_signal_unaligned, &encoder->private_->windowed_signal);
	}
#endif
	for(channel = 0; ok && channel < encoder->protected_->channels; channel++) {
		for(i = 0; ok && i < 2; i++) {
			ok = ok && FLAC__memory_alloc_aligned_int32_array(new_blocksize, &encoder->private_->residual_workspace_unaligned[channel][i], &encoder->private_->residual_workspace[channel][i]);
		}
	}
	for(channel = 0; ok && channel < 2; channel++) {
		for(i = 0; ok && i < 2; i++) {
			ok = ok && FLAC__memory_alloc_aligned_int32_array(new_blocksize, &encoder->private_->residual_workspace_mid_side_unaligned[channel][i], &encoder->private_->residual_workspace_mid_side[channel][i]);
		}
	}
	/* the *2 is an approximation to the series 1 + 1/2 + 1/4 + ... that sums tree occupies in a flat array */
	/*@@@ new_blocksize*2 is too pessimistic, but to fix, we need smarter logic because a smaller new_blocksize can actually increase the # of partitions; would require moving this out into a separate function, then checking its capacity against the need of the current blocksize&min/max_partition_order (and maybe predictor order) */
	ok = ok && FLAC__memory_alloc_aligned_uint64_array(new_blocksize * 2, &encoder->private_->abs_residual_partition_sums_unaligned, &encoder->private_->abs_residual_partition_sums);
	if(encoder->protected_->do_escape_coding)
		ok = ok && FLAC__memory_alloc_aligned_unsigned_array(new_blocksize * 2, &encoder->private_->raw_bits_per_partition_unaligned, &encoder->private_->raw_bits_per_partition);

	/* now adjust the windows if the blocksize has changed */
#ifndef FLAC__INTEGER_ONLY_LIBRARY
	if(ok && new_blocksize != encoder->private_->input_capacity && encoder->protected_->max_lpc_order > 0) {
		for(i = 0; ok && i < encoder->protected_->num_apodizations; i++) {
			switch(encoder->protected_->apodizations[i].type) {
				case FLAC__APODIZATION_BARTLETT:
					FLAC__window_bartlett(encoder->private_->window[i], new_blocksize);
					break;
				case FLAC__APODIZATION_BARTLETT_HANN:
					FLAC__window_bartlett_hann(encoder->private_->window[i], new_blocksize);
					break;
				case FLAC__APODIZATION_BLACKMAN:
					FLAC__window_blackman(encoder->private_->window[i], new_blocksize);
					break;
				case FLAC__APODIZATION_BLACKMAN_HARRIS_4TERM_92DB_SIDELOBE:
					FLAC__window_blackman_harris_4term_92db_sidelobe(encoder->private_->window[i], new_blocksize);
					break;
				case FLAC__APODIZATION_CONNES:
					FLAC__window_connes(encoder->private_->window[i], new_blocksize);
					break;
				case FLAC__APODIZATION_FLATTOP:
					FLAC__window_flattop(encoder->private_->window[i], new_blocksize);
					break;
				case FLAC__APODIZATION_GAUSS:
					FLAC__window_gauss(encoder->private_->window[i], new_blocksize, encoder->protected_->apodizations[i].parameters.gauss.stddev);
					break;
				case FLAC__APODIZATION_HAMMING:
					FLAC__window_hamming(encoder->private_->window[i], new_blocksize);
					break;
				case FLAC__APODIZATION_HANN:
					FLAC__window_hann(encoder->private_->window[i], new_blocksize);
					break;
				case FLAC__APODIZATION_KAISER_BESSEL:
					FLAC__window_kaiser_bessel(encoder->private_->window[i], new_blocksize);
					break;
				case FLAC__APODIZATION_NUTTALL:
					FLAC__window_nuttall(encoder->private_->window[i], new_blocksize);
					break;
				case FLAC__APODIZATION_RECTANGLE:
					FLAC__window_rectangle(encoder->private_->window[i], new_blocksize);
					break;
				case FLAC__APODIZATION_TRIANGLE:
					FLAC__window_triangle(encoder->private_->window[i], new_blocksize);
					break;
				case FLAC__APODIZATION_TUKEY:
					FLAC__window_tukey(encoder->private_->window[i], new_blocksize, encoder->protected_->apodizations[i].parameters.tukey.p);
					break;
				case FLAC__APODIZATION_WELCH:
					FLAC__window_welch(encoder->private_->window[i], new_blocksize);
					break;
				default:
					FLAC__ASSERT(0);
					/* double protection */
					FLAC__window_hann(encoder->private_->window[i], new_blocksize);
					break;
			}
		}
	}
#endif

	if(ok)
		encoder->private_->input_capacity = new_blocksize;
	else
		encoder->protected_->state = FLAC__STREAM_ENCODER_MEMORY_ALLOCATION_ERROR;

	return ok;
}

FLAC__bool write_bitbuffer_(FLAC__StreamEncoder *encoder, unsigned samples, FLAC__bool is_last_block)
{
	const FLAC__byte *buffer;
	size_t bytes;

	FLAC__ASSERT(FLAC__bitwriter_is_byte_aligned(encoder->private_->frame));

	if(!FLAC__bitwriter_get_buffer(encoder->private_->frame, &buffer, &bytes)) {
		encoder->protected_->state = FLAC__STREAM_ENCODER_MEMORY_ALLOCATION_ERROR;
		return false;
	}

	if(encoder->protected_->verify) {
		encoder->private_->verify.output.data = buffer;
		encoder->private_->verify.output.bytes = bytes;
		if(encoder->private_->verify.state_hint == ENCODER_IN_MAGIC) {
			encoder->private_->verify.needs_magic_hack = true;
		}
		else {
			if(!FLAC__stream_decoder_process_single(encoder->private_->verify.decoder)) {
				FLAC__bitwriter_release_buffer(encoder->private_->frame);
				FLAC__bitwriter_clear(encoder->private_->frame);
				if(encoder->protected_->state != FLAC__STREAM_ENCODER_VERIFY_MISMATCH_IN_AUDIO_DATA)
					encoder->protected_->state = FLAC__STREAM_ENCODER_VERIFY_DECODER_ERROR;
				return false;
			}
		}
	}

	if(write_frame_(encoder, buffer, bytes, samples, is_last_block) != FLAC__STREAM_ENCODER_WRITE_STATUS_OK) {
		FLAC__bitwriter_release_buffer(encoder->private_->frame);
		FLAC__bitwriter_clear(encoder->private_->frame);
		encoder->protected_->state = FLAC__STREAM_ENCODER_CLIENT_ERROR;
		return false;
	}

	FLAC__bitwriter_release_buffer(encoder->private_->frame);
	FLAC__bitwriter_clear(encoder->private_->frame);

	if(samples > 0) {
		encoder->private_->streaminfo.data.stream_info.min_framesize = min(bytes, encoder->private_->streaminfo.data.stream_info.min_framesize);
		encoder->private_->streaminfo.data.stream_info.max_framesize = max(bytes, encoder->private_->streaminfo.data.stream_info.max_framesize);
	}

	return true;
}

FLAC__StreamEncoderWriteStatus write_frame_(FLAC__StreamEncoder *encoder, const FLAC__byte buffer[], size_t bytes, unsigned samples, FLAC__bool is_last_block)
{
	FLAC__StreamEncoderWriteStatus status;
	FLAC__uint64 output_position = 0;

	/* FLAC__STREAM_ENCODER_TELL_STATUS_UNSUPPORTED just means we didn't get the offset; no error */
	if(encoder->private_->tell_callback && encoder->private_->tell_callback(encoder, &output_position, encoder->private_->client_data) == FLAC__STREAM_ENCODER_TELL_STATUS_ERROR) {
		encoder->protected_->state = FLAC__STREAM_ENCODER_CLIENT_ERROR;
		return FLAC__STREAM_ENCODER_WRITE_STATUS_FATAL_ERROR;
	}

	/*
	 * Watch for the STREAMINFO block and first SEEKTABLE block to go by and store their offsets.
	 */
	if(samples == 0) {
		FLAC__MetadataType type = (FLAC__MetadataType) (buffer[0] & 0x7f);
		if(type == FLAC__METADATA_TYPE_STREAMINFO)
			encoder->protected_->streaminfo_offset = output_position;
		else if(type == FLAC__METADATA_TYPE_SEEKTABLE && encoder->protected_->seektable_offset == 0)
			encoder->protected_->seektable_offset = output_position;
	}

	/*
	 * Mark the current seek point if hit (if audio_offset == 0 that
	 * means we're still writing metadata and haven't hit the first
	 * frame yet)
	 */
	if(0 != encoder->private_->seek_table && encoder->protected_->audio_offset > 0 && encoder->private_->seek_table->num_points > 0) {
		const unsigned blocksize = FLAC__stream_encoder_get_blocksize(encoder);
		const FLAC__uint64 frame_first_sample = encoder->private_->samples_written;
		const FLAC__uint64 frame_last_sample = frame_first_sample + (FLAC__uint64)blocksize - 1;
		FLAC__uint64 test_sample;
		unsigned i;
		for(i = encoder->private_->first_seekpoint_to_check; i < encoder->private_->seek_table->num_points; i++) {
			test_sample = encoder->private_->seek_table->points[i].sample_number;
			if(test_sample > frame_last_sample) {
				break;
			}
			else if(test_sample >= frame_first_sample) {
				encoder->private_->seek_table->points[i].sample_number = frame_first_sample;
				encoder->private_->seek_table->points[i].stream_offset = output_position - encoder->protected_->audio_offset;
				encoder->private_->seek_table->points[i].frame_samples = blocksize;
				encoder->private_->first_seekpoint_to_check++;
				/* DO NOT: "break;" and here's why:
				 * The seektable template may contain more than one target
				 * sample for any given frame; we will keep looping, generating
				 * duplicate seekpoints for them, and we'll clean it up later,
				 * just before writing the seektable back to the metadata.
				 */
			}
			else {
				encoder->private_->first_seekpoint_to_check++;
			}
		}
	}

#if FLAC__HAS_OGG
	if(encoder->private_->is_ogg) {
		status = FLAC__ogg_encoder_aspect_write_callback_wrapper(
			&encoder->protected_->ogg_encoder_aspect,
			buffer,
			bytes,
			samples,
			encoder->private_->current_frame_number,
			is_last_block,
			(FLAC__OggEncoderAspectWriteCallbackProxy)encoder->private_->write_callback,
			encoder,
			encoder->private_->client_data
		);
	}
	else
#endif
	status = encoder->private_->write_callback(encoder, buffer, bytes, samples, encoder->private_->current_frame_number, encoder->private_->client_data);

	if(status == FLAC__STREAM_ENCODER_WRITE_STATUS_OK) {
		encoder->private_->bytes_written += bytes;
		encoder->private_->samples_written += samples;
		/* we keep a high watermark on the number of frames written because
		 * when the encoder goes back to write metadata, 'current_frame'
		 * will drop back to 0.
		 */
		encoder->private_->frames_written = max(encoder->private_->frames_written, encoder->private_->current_frame_number+1);
	}
	else
		encoder->protected_->state = FLAC__STREAM_ENCODER_CLIENT_ERROR;

	return status;
}

/* Gets called when the encoding process has finished so that we can update the STREAMINFO and SEEKTABLE blocks.  */
void update_metadata_(const FLAC__StreamEncoder *encoder)
{
	FLAC__byte b[max(6, FLAC__STREAM_METADATA_SEEKPOINT_LENGTH)];
	const FLAC__StreamMetadata *metadata = &encoder->private_->streaminfo;
	const FLAC__uint64 samples = metadata->data.stream_info.total_samples;
	const unsigned min_framesize = metadata->data.stream_info.min_framesize;
	const unsigned max_framesize = metadata->data.stream_info.max_framesize;
	const unsigned bps = metadata->data.stream_info.bits_per_sample;
	FLAC__StreamEncoderSeekStatus seek_status;

	FLAC__ASSERT(metadata->type == FLAC__METADATA_TYPE_STREAMINFO);

	/* All this is based on intimate knowledge of the stream header
	 * layout, but a change to the header format that would break this
	 * would also break all streams encoded in the previous format.
	 */

	/*
	 * Write MD5 signature
	 */
	{
		const unsigned md5_offset =
			FLAC__STREAM_METADATA_HEADER_LENGTH +
			(
				FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN +
				FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN +
				FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN +
				FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN +
				FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN +
				FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN +
				FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN +
				FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN
			) / 8;

		if((seek_status = encoder->private_->seek_callback(encoder, encoder->protected_->streaminfo_offset + md5_offset, encoder->private_->client_data)) != FLAC__STREAM_ENCODER_SEEK_STATUS_OK) {
			if(seek_status == FLAC__STREAM_ENCODER_SEEK_STATUS_ERROR)
				encoder->protected_->state = FLAC__STREAM_ENCODER_CLIENT_ERROR;
			return;
		}
		if(encoder->private_->write_callback(encoder, metadata->data.stream_info.md5sum, 16, 0, 0, encoder->private_->client_data) != FLAC__STREAM_ENCODER_WRITE_STATUS_OK) {
			encoder->protected_->state = FLAC__STREAM_ENCODER_CLIENT_ERROR;
			return;
		}
	}

	/*
	 * Write total samples
	 */
	{
		const unsigned total_samples_byte_offset =
			FLAC__STREAM_METADATA_HEADER_LENGTH +
			(
				FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN +
				FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN +
				FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN +
				FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN +
				FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN +
				FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN +
				FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN
				- 4
			) / 8;

		b[0] = ((FLAC__byte)(bps-1) << 4) | (FLAC__byte)((samples >> 32) & 0x0F);
		b[1] = (FLAC__byte)((samples >> 24) & 0xFF);
		b[2] = (FLAC__byte)((samples >> 16) & 0xFF);
		b[3] = (FLAC__byte)((samples >> 8) & 0xFF);
		b[4] = (FLAC__byte)(samples & 0xFF);
		if((seek_status = encoder->private_->seek_callback(encoder, encoder->protected_->streaminfo_offset + total_samples_byte_offset, encoder->private_->client_data)) != FLAC__STREAM_ENCODER_SEEK_STATUS_OK) {
			if(seek_status == FLAC__STREAM_ENCODER_SEEK_STATUS_ERROR)
				encoder->protected_->state = FLAC__STREAM_ENCODER_CLIENT_ERROR;
			return;
		}
		if(encoder->private_->write_callback(encoder, b, 5, 0, 0, encoder->private_->client_data) != FLAC__STREAM_ENCODER_WRITE_STATUS_OK) {
			encoder->protected_->state = FLAC__STREAM_ENCODER_CLIENT_ERROR;
			return;
		}
	}

	/*
	 * Write min/max framesize
	 */
	{
		const unsigned min_framesize_offset =
			FLAC__STREAM_METADATA_HEADER_LENGTH +
			(
				FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN +
				FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN
			) / 8;

		b[0] = (FLAC__byte)((min_framesize >> 16) & 0xFF);
		b[1] = (FLAC__byte)((min_framesize >> 8) & 0xFF);
		b[2] = (FLAC__byte)(min_framesize & 0xFF);
		b[3] = (FLAC__byte)((max_framesize >> 16) & 0xFF);
		b[4] = (FLAC__byte)((max_framesize >> 8) & 0xFF);
		b[5] = (FLAC__byte)(max_framesize & 0xFF);
		if((seek_status = encoder->private_->seek_callback(encoder, encoder->protected_->streaminfo_offset + min_framesize_offset, encoder->private_->client_data)) != FLAC__STREAM_ENCODER_SEEK_STATUS_OK) {
			if(seek_status == FLAC__STREAM_ENCODER_SEEK_STATUS_ERROR)
				encoder->protected_->state = FLAC__STREAM_ENCODER_CLIENT_ERROR;
			return;
		}
		if(encoder->private_->write_callback(encoder, b, 6, 0, 0, encoder->private_->client_data) != FLAC__STREAM_ENCODER_WRITE_STATUS_OK) {
			encoder->protected_->state = FLAC__STREAM_ENCODER_CLIENT_ERROR;
			return;
		}
	}

	/*
	 * Write seektable
	 */
	if(0 != encoder->private_->seek_table && encoder->private_->seek_table->num_points > 0 && encoder->protected_->seektable_offset > 0) {
		unsigned i;

		FLAC__format_seektable_sort(encoder->private_->seek_table);

		FLAC__ASSERT(FLAC__format_seektable_is_legal(encoder->private_->seek_table));

		if((seek_status = encoder->private_->seek_callback(encoder, encoder->protected_->seektable_offset + FLAC__STREAM_METADATA_HEADER_LENGTH, encoder->private_->client_data)) != FLAC__STREAM_ENCODER_SEEK_STATUS_OK) {
			if(seek_status == FLAC__STREAM_ENCODER_SEEK_STATUS_ERROR)
				encoder->protected_->state = FLAC__STREAM_ENCODER_CLIENT_ERROR;
			return;
		}

		for(i = 0; i < encoder->private_->seek_table->num_points; i++) {
			FLAC__uint64 xx;
			unsigned x;
			xx = encoder->private_->seek_table->points[i].sample_number;
			b[7] = (FLAC__byte)xx; xx >>= 8;
			b[6] = (FLAC__byte)xx; xx >>= 8;
			b[5] = (FLAC__byte)xx; xx >>= 8;
			b[4] = (FLAC__byte)xx; xx >>= 8;
			b[3] = (FLAC__byte)xx; xx >>= 8;
			b[2] = (FLAC__byte)xx; xx >>= 8;
			b[1] = (FLAC__byte)xx; xx >>= 8;
			b[0] = (FLAC__byte)xx; xx >>= 8;
			xx = encoder->private_->seek_table->points[i].stream_offset;
			b[15] = (FLAC__byte)xx; xx >>= 8;
			b[14] = (FLAC__byte)xx; xx >>= 8;
			b[13] = (FLAC__byte)xx; xx >>= 8;
			b[12] = (FLAC__byte)xx; xx >>= 8;
			b[11] = (FLAC__byte)xx; xx >>= 8;
			b[10] = (FLAC__byte)xx; xx >>= 8;
			b[9] = (FLAC__byte)xx; xx >>= 8;
			b[8] = (FLAC__byte)xx; xx >>= 8;
			x = encoder->private_->seek_table->points[i].frame_samples;
			b[17] = (FLAC__byte)x; x >>= 8;
			b[16] = (FLAC__byte)x; x >>= 8;
			if(encoder->private_->write_callback(encoder, b, 18, 0, 0, encoder->private_->client_data) != FLAC__STREAM_ENCODER_WRITE_STATUS_OK) {
				encoder->protected_->state = FLAC__STREAM_ENCODER_CLIENT_ERROR;
				return;
			}
		}
	}
}

#if FLAC__HAS_OGG
/* Gets called when the encoding process has finished so that we can update the STREAMINFO and SEEKTABLE blocks.  */
void update_ogg_metadata_(FLAC__StreamEncoder *encoder)
{
	/* the # of bytes in the 1st packet that precede the STREAMINFO */
	static const unsigned FIRST_OGG_PACKET_STREAMINFO_PREFIX_LENGTH =
		FLAC__OGG_MAPPING_PACKET_TYPE_LENGTH +
		FLAC__OGG_MAPPING_MAGIC_LENGTH +
		FLAC__OGG_MAPPING_VERSION_MAJOR_LENGTH +
		FLAC__OGG_MAPPING_VERSION_MINOR_LENGTH +
		FLAC__OGG_MAPPING_NUM_HEADERS_LENGTH +
		FLAC__STREAM_SYNC_LENGTH
	;
	FLAC__byte b[max(6, FLAC__STREAM_METADATA_SEEKPOINT_LENGTH)];
	const FLAC__StreamMetadata *metadata = &encoder->private_->streaminfo;
	const FLAC__uint64 samples = metadata->data.stream_info.total_samples;
	const unsigned min_framesize = metadata->data.stream_info.min_framesize;
	const unsigned max_framesize = metadata->data.stream_info.max_framesize;
	ogg_page page;

	FLAC__ASSERT(metadata->type == FLAC__METADATA_TYPE_STREAMINFO);
	FLAC__ASSERT(0 != encoder->private_->seek_callback);

	/* Pre-check that client supports seeking, since we don't want the
	 * ogg_helper code to ever have to deal with this condition.
	 */
	if(encoder->private_->seek_callback(encoder, 0, encoder->private_->client_data) == FLAC__STREAM_ENCODER_SEEK_STATUS_UNSUPPORTED)
		return;

	/* All this is based on intimate knowledge of the stream header
	 * layout, but a change to the header format that would break this
	 * would also break all streams encoded in the previous format.
	 */

	/**
	 ** Write STREAMINFO stats
	 **/
	simple_ogg_page__init(&page);
	if(!simple_ogg_page__get_at(encoder, encoder->protected_->streaminfo_offset, &page, encoder->private_->seek_callback, encoder->private_->read_callback, encoder->private_->client_data)) {
		simple_ogg_page__clear(&page);
		return; /* state already set */
	}

	/*
	 * Write MD5 signature
	 */
	{
		const unsigned md5_offset =
			FIRST_OGG_PACKET_STREAMINFO_PREFIX_LENGTH +
			FLAC__STREAM_METADATA_HEADER_LENGTH +
			(
				FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN +
				FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN +
				FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN +
				FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN +
				FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN +
				FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN +
				FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN +
				FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN
			) / 8;

		if(md5_offset + 16 > (unsigned)page.body_len) {
			encoder->protected_->state = FLAC__STREAM_ENCODER_OGG_ERROR;
			simple_ogg_page__clear(&page);
			return;
		}
		memcpy(page.body + md5_offset, metadata->data.stream_info.md5sum, 16);
	}

	/*
	 * Write total samples
	 */
	{
		const unsigned total_samples_byte_offset =
			FIRST_OGG_PACKET_STREAMINFO_PREFIX_LENGTH +
			FLAC__STREAM_METADATA_HEADER_LENGTH +
			(
				FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN +
				FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN +
				FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN +
				FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN +
				FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN +
				FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN +
				FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN
				- 4
			) / 8;

		if(total_samples_byte_offset + 5 > (unsigned)page.body_len) {
			encoder->protected_->state = FLAC__STREAM_ENCODER_OGG_ERROR;
			simple_ogg_page__clear(&page);
			return;
		}
		b[0] = (FLAC__byte)page.body[total_samples_byte_offset] & 0xF0;
		b[0] |= (FLAC__byte)((samples >> 32) & 0x0F);
		b[1] = (FLAC__byte)((samples >> 24) & 0xFF);
		b[2] = (FLAC__byte)((samples >> 16) & 0xFF);
		b[3] = (FLAC__byte)((samples >> 8) & 0xFF);
		b[4] = (FLAC__byte)(samples & 0xFF);
		memcpy(page.body + total_samples_byte_offset, b, 5);
	}

	/*
	 * Write min/max framesize
	 */
	{
		const unsigned min_framesize_offset =
			FIRST_OGG_PACKET_STREAMINFO_PREFIX_LENGTH +
			FLAC__STREAM_METADATA_HEADER_LENGTH +
			(
				FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN +
				FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN
			) / 8;

		if(min_framesize_offset + 6 > (unsigned)page.body_len) {
			encoder->protected_->state = FLAC__STREAM_ENCODER_OGG_ERROR;
			simple_ogg_page__clear(&page);
			return;
		}
		b[0] = (FLAC__byte)((min_framesize >> 16) & 0xFF);
		b[1] = (FLAC__byte)((min_framesize >> 8) & 0xFF);
		b[2] = (FLAC__byte)(min_framesize & 0xFF);
		b[3] = (FLAC__byte)((max_framesize >> 16) & 0xFF);
		b[4] = (FLAC__byte)((max_framesize >> 8) & 0xFF);
		b[5] = (FLAC__byte)(max_framesize & 0xFF);
		memcpy(page.body + min_framesize_offset, b, 6);
	}
	if(!simple_ogg_page__set_at(encoder, encoder->protected_->streaminfo_offset, &page, encoder->private_->seek_callback, encoder->private_->write_callback, encoder->private_->client_data)) {
		simple_ogg_page__clear(&page);
		return; /* state already set */
	}
	simple_ogg_page__clear(&page);

	/*
	 * Write seektable
	 */
	if(0 != encoder->private_->seek_table && encoder->private_->seek_table->num_points > 0 && encoder->protected_->seektable_offset > 0) {
		unsigned i;
		FLAC__byte *p;

		FLAC__format_seektable_sort(encoder->private_->seek_table);

		FLAC__ASSERT(FLAC__format_seektable_is_legal(encoder->private_->seek_table));

		simple_ogg_page__init(&page);
		if(!simple_ogg_page__get_at(encoder, encoder->protected_->seektable_offset, &page, encoder->private_->seek_callback, encoder->private_->read_callback, encoder->private_->client_data)) {
			simple_ogg_page__clear(&page);
			return; /* state already set */
		}

		if((FLAC__STREAM_METADATA_HEADER_LENGTH + 18*encoder->private_->seek_table->num_points) != (unsigned)page.body_len) {
			encoder->protected_->state = FLAC__STREAM_ENCODER_OGG_ERROR;
			simple_ogg_page__clear(&page);
			return;
		}

		for(i = 0, p = page.body + FLAC__STREAM_METADATA_HEADER_LENGTH; i < encoder->private_->seek_table->num_points; i++, p += 18) {
			FLAC__uint64 xx;
			unsigned x;
			xx = encoder->private_->seek_table->points[i].sample_number;
			b[7] = (FLAC__byte)xx; xx >>= 8;
			b[6] = (FLAC__byte)xx; xx >>= 8;
			b[5] = (FLAC__byte)xx; xx >>= 8;
			b[4] = (FLAC__byte)xx; xx >>= 8;
			b[3] = (FLAC__byte)xx; xx >>= 8;
			b[2] = (FLAC__byte)xx; xx >>= 8;
			b[1] = (FLAC__byte)xx; xx >>= 8;
			b[0] = (FLAC__byte)xx; xx >>= 8;
			xx = encoder->private_->seek_table->points[i].stream_offset;
			b[15] = (FLAC__byte)xx; xx >>= 8;
			b[14] = (FLAC__byte)xx; xx >>= 8;
			b[13] = (FLAC__byte)xx; xx >>= 8;
			b[12] = (FLAC__byte)xx; xx >>= 8;
			b[11] = (FLAC__byte)xx; xx >>= 8;
			b[10] = (FLAC__byte)xx; xx >>= 8;
			b[9] = (FLAC__byte)xx; xx >>= 8;
			b[8] = (FLAC__byte)xx; xx >>= 8;
			x = encoder->private_->seek_table->points[i].frame_samples;
			b[17] = (FLAC__byte)x; x >>= 8;
			b[16] = (FLAC__byte)x; x >>= 8;
			memcpy(p, b, 18);
		}

		if(!simple_ogg_page__set_at(encoder, encoder->protected_->seektable_offset, &page, encoder->private_->seek_callback, encoder->private_->write_callback, encoder->private_->client_data)) {
			simple_ogg_page__clear(&page);
			return; /* state already set */
		}
		simple_ogg_page__clear(&page);
	}
}
#endif

FLAC__bool process_frame_(FLAC__StreamEncoder *encoder, FLAC__bool is_fractional_block, FLAC__bool is_last_block)
{
	FLAC__uint16 crc;
	FLAC__ASSERT(encoder->protected_->state == FLAC__STREAM_ENCODER_OK);

	/*
	 * Accumulate raw signal to the MD5 signature
	 */
	if(encoder->protected_->do_md5 && !FLAC__MD5Accumulate(&encoder->private_->md5context, (const FLAC__int32 * const *)encoder->private_->integer_signal, encoder->protected_->channels, encoder->protected_->blocksize, (encoder->protected_->bits_per_sample+7) / 8)) {
		encoder->protected_->state = FLAC__STREAM_ENCODER_MEMORY_ALLOCATION_ERROR;
		return false;
	}

	/*
	 * Process the frame header and subframes into the frame bitbuffer
	 */
	if(!process_subframes_(encoder, is_fractional_block)) {
		/* the above function sets the state for us in case of an error */
		return false;
	}

	/*
	 * Zero-pad the frame to a byte_boundary
	 */
	if(!FLAC__bitwriter_zero_pad_to_byte_boundary(encoder->private_->frame)) {
		encoder->protected_->state = FLAC__STREAM_ENCODER_MEMORY_ALLOCATION_ERROR;
		return false;
	}

	/*
	 * CRC-16 the whole thing
	 */
	FLAC__ASSERT(FLAC__bitwriter_is_byte_aligned(encoder->private_->frame));
	if(
		!FLAC__bitwriter_get_write_crc16(encoder->private_->frame, &crc) ||
		!FLAC__bitwriter_write_raw_uint32(encoder->private_->frame, crc, FLAC__FRAME_FOOTER_CRC_LEN)
	) {
		encoder->protected_->state = FLAC__STREAM_ENCODER_MEMORY_ALLOCATION_ERROR;
		return false;
	}

	/*
	 * Write it
	 */
	if(!write_bitbuffer_(encoder, encoder->protected_->blocksize, is_last_block)) {
		/* the above function sets the state for us in case of an error */
		return false;
	}

	/*
	 * Get ready for the next frame
	 */
	encoder->private_->current_sample_number = 0;
	encoder->private_->current_frame_number++;
	encoder->private_->streaminfo.data.stream_info.total_samples += (FLAC__uint64)encoder->protected_->blocksize;

	return true;
}

FLAC__bool process_subframes_(FLAC__StreamEncoder *encoder, FLAC__bool is_fractional_block)
{
	FLAC__FrameHeader frame_header;
	unsigned channel, min_partition_order = encoder->protected_->min_residual_partition_order, max_partition_order;
	FLAC__bool do_independent, do_mid_side;

	/*
	 * Calculate the min,max Rice partition orders
	 */
	if(is_fractional_block) {
		max_partition_order = 0;
	}
	else {
		max_partition_order = FLAC__format_get_max_rice_partition_order_from_blocksize(encoder->protected_->blocksize);
		max_partition_order = min(max_partition_order, encoder->protected_->max_residual_partition_order);
	}
	min_partition_order = min(min_partition_order, max_partition_order);

	/*
	 * Setup the frame
	 */
	frame_header.blocksize = encoder->protected_->blocksize;
	frame_header.sample_rate = encoder->protected_->sample_rate;
	frame_header.channels = encoder->protected_->channels;
	frame_header.channel_assignment = FLAC__CHANNEL_ASSIGNMENT_INDEPENDENT; /* the default unless the encoder determines otherwise */
	frame_header.bits_per_sample = encoder->protected_->bits_per_sample;
	frame_header.number_type = FLAC__FRAME_NUMBER_TYPE_FRAME_NUMBER;
	frame_header.number.frame_number = encoder->private_->current_frame_number;

	/*
	 * Figure out what channel assignments to try
	 */
	if(encoder->protected_->do_mid_side_stereo) {
		if(encoder->protected_->loose_mid_side_stereo) {
			if(encoder->private_->loose_mid_side_stereo_frame_count == 0) {
				do_independent = true;
				do_mid_side = true;
			}
			else {
				do_independent = (encoder->private_->last_channel_assignment == FLAC__CHANNEL_ASSIGNMENT_INDEPENDENT);
				do_mid_side = !do_independent;
			}
		}
		else {
			do_independent = true;
			do_mid_side = true;
		}
	}
	else {
		do_independent = true;
		do_mid_side = false;
	}

	FLAC__ASSERT(do_independent || do_mid_side);

	/*
	 * Check for wasted bits; set effective bps for each subframe
	 */
	if(do_independent) {
		for(channel = 0; channel < encoder->protected_->channels; channel++) {
			const unsigned w = get_wasted_bits_(encoder->private_->integer_signal[channel], encoder->protected_->blocksize);
			encoder->private_->subframe_workspace[channel][0].wasted_bits = encoder->private_->subframe_workspace[channel][1].wasted_bits = w;
			encoder->private_->subframe_bps[channel] = encoder->protected_->bits_per_sample - w;
		}
	}
	if(do_mid_side) {
		FLAC__ASSERT(encoder->protected_->channels == 2);
		for(channel = 0; channel < 2; channel++) {
			const unsigned w = get_wasted_bits_(encoder->private_->integer_signal_mid_side[channel], encoder->protected_->blocksize);
			encoder->private_->subframe_workspace_mid_side[channel][0].wasted_bits = encoder->private_->subframe_workspace_mid_side[channel][1].wasted_bits = w;
			encoder->private_->subframe_bps_mid_side[channel] = encoder->protected_->bits_per_sample - w + (channel==0? 0:1);
		}
	}

	/*
	 * First do a normal encoding pass of each independent channel
	 */
	if(do_independent) {
		for(channel = 0; channel < encoder->protected_->channels; channel++) {
			if(!
				process_subframe_(
					encoder,
					min_partition_order,
					max_partition_order,
					&frame_header,
					encoder->private_->subframe_bps[channel],
					encoder->private_->integer_signal[channel],
					encoder->private_->subframe_workspace_ptr[channel],
					encoder->private_->partitioned_rice_contents_workspace_ptr[channel],
					encoder->private_->residual_workspace[channel],
					encoder->private_->best_subframe+channel,
					encoder->private_->best_subframe_bits+channel
				)
			)
				return false;
		}
	}

	/*
	 * Now do mid and side channels if requested
	 */
	if(do_mid_side) {
		FLAC__ASSERT(encoder->protected_->channels == 2);

		for(channel = 0; channel < 2; channel++) {
			if(!
				process_subframe_(
					encoder,
					min_partition_order,
					max_partition_order,
					&frame_header,
					encoder->private_->subframe_bps_mid_side[channel],
					encoder->private_->integer_signal_mid_side[channel],
					encoder->private_->subframe_workspace_ptr_mid_side[channel],
					encoder->private_->partitioned_rice_contents_workspace_ptr_mid_side[channel],
					encoder->private_->residual_workspace_mid_side[channel],
					encoder->private_->best_subframe_mid_side+channel,
					encoder->private_->best_subframe_bits_mid_side+channel
				)
			)
				return false;
		}
	}

	/*
	 * Compose the frame bitbuffer
	 */
	if(do_mid_side) {
		unsigned left_bps = 0, right_bps = 0; /* initialized only to prevent superfluous compiler warning */
		FLAC__Subframe *left_subframe = 0, *right_subframe = 0; /* initialized only to prevent superfluous compiler warning */
		FLAC__ChannelAssignment channel_assignment;

		FLAC__ASSERT(encoder->protected_->channels == 2);

		if(encoder->protected_->loose_mid_side_stereo && encoder->private_->loose_mid_side_stereo_frame_count > 0) {
			channel_assignment = (encoder->private_->last_channel_assignment == FLAC__CHANNEL_ASSIGNMENT_INDEPENDENT? FLAC__CHANNEL_ASSIGNMENT_INDEPENDENT : FLAC__CHANNEL_ASSIGNMENT_MID_SIDE);
		}
		else {
			unsigned bits[4]; /* WATCHOUT - indexed by FLAC__ChannelAssignment */
			unsigned min_bits;
			int ca;

			FLAC__ASSERT(FLAC__CHANNEL_ASSIGNMENT_INDEPENDENT == 0);
			FLAC__ASSERT(FLAC__CHANNEL_ASSIGNMENT_LEFT_SIDE   == 1);
			FLAC__ASSERT(FLAC__CHANNEL_ASSIGNMENT_RIGHT_SIDE  == 2);
			FLAC__ASSERT(FLAC__CHANNEL_ASSIGNMENT_MID_SIDE    == 3);
			FLAC__ASSERT(do_independent && do_mid_side);

			/* We have to figure out which channel assignent results in the smallest frame */
			bits[FLAC__CHANNEL_ASSIGNMENT_INDEPENDENT] = encoder->private_->best_subframe_bits         [0] + encoder->private_->best_subframe_bits         [1];
			bits[FLAC__CHANNEL_ASSIGNMENT_LEFT_SIDE  ] = encoder->private_->best_subframe_bits         [0] + encoder->private_->best_subframe_bits_mid_side[1];
			bits[FLAC__CHANNEL_ASSIGNMENT_RIGHT_SIDE ] = encoder->private_->best_subframe_bits         [1] + encoder->private_->best_subframe_bits_mid_side[1];
			bits[FLAC__CHANNEL_ASSIGNMENT_MID_SIDE   ] = encoder->private_->best_subframe_bits_mid_side[0] + encoder->private_->best_subframe_bits_mid_side[1];

			channel_assignment = FLAC__CHANNEL_ASSIGNMENT_INDEPENDENT;
			min_bits = bits[channel_assignment];
			for(ca = 1; ca <= 3; ca++) {
				if(bits[ca] < min_bits) {
					min_bits = bits[ca];
					channel_assignment = (FLAC__ChannelAssignment)ca;
				}
			}
		}

		frame_header.channel_assignment = channel_assignment;

		if(!FLAC__frame_add_header(&frame_header, encoder->private_->frame)) {
			encoder->protected_->state = FLAC__STREAM_ENCODER_FRAMING_ERROR;
			return false;
		}

		switch(channel_assignment) {
			case FLAC__CHANNEL_ASSIGNMENT_INDEPENDENT:
				left_subframe  = &encoder->private_->subframe_workspace         [0][encoder->private_->best_subframe         [0]];
				right_subframe = &encoder->private_->subframe_workspace         [1][encoder->private_->best_subframe         [1]];
				break;
			case FLAC__CHANNEL_ASSIGNMENT_LEFT_SIDE:
				left_subframe  = &encoder->private_->subframe_workspace         [0][encoder->private_->best_subframe         [0]];
				right_subframe = &encoder->private_->subframe_workspace_mid_side[1][encoder->private_->best_subframe_mid_side[1]];
				break;
			case FLAC__CHANNEL_ASSIGNMENT_RIGHT_SIDE:
				left_subframe  = &encoder->private_->subframe_workspace_mid_side[1][encoder->private_->best_subframe_mid_side[1]];
				right_subframe = &encoder->private_->subframe_workspace         [1][encoder->private_->best_subframe         [1]];
				break;
			case FLAC__CHANNEL_ASSIGNMENT_MID_SIDE:
				left_subframe  = &encoder->private_->subframe_workspace_mid_side[0][encoder->private_->best_subframe_mid_side[0]];
				right_subframe = &encoder->private_->subframe_workspace_mid_side[1][encoder->private_->best_subframe_mid_side[1]];
				break;
			default:
				FLAC__ASSERT(0);
		}

		switch(channel_assignment) {
			case FLAC__CHANNEL_ASSIGNMENT_INDEPENDENT:
				left_bps  = encoder->private_->subframe_bps         [0];
				right_bps = encoder->private_->subframe_bps         [1];
				break;
			case FLAC__CHANNEL_ASSIGNMENT_LEFT_SIDE:
				left_bps  = encoder->private_->subframe_bps         [0];
				right_bps = encoder->private_->subframe_bps_mid_side[1];
				break;
			case FLAC__CHANNEL_ASSIGNMENT_RIGHT_SIDE:
				left_bps  = encoder->private_->subframe_bps_mid_side[1];
				right_bps = encoder->private_->subframe_bps         [1];
				break;
			case FLAC__CHANNEL_ASSIGNMENT_MID_SIDE:
				left_bps  = encoder->private_->subframe_bps_mid_side[0];
				right_bps = encoder->private_->subframe_bps_mid_side[1];
				break;
			default:
				FLAC__ASSERT(0);
		}

		/* note that encoder_add_subframe_ sets the state for us in case of an error */
		if(!add_subframe_(encoder, frame_header.blocksize, left_bps , left_subframe , encoder->private_->frame))
			return false;
		if(!add_subframe_(encoder, frame_header.blocksize, right_bps, right_subframe, encoder->private_->frame))
			return false;
	}
	else {
		if(!FLAC__frame_add_header(&frame_header, encoder->private_->frame)) {
			encoder->protected_->state = FLAC__STREAM_ENCODER_FRAMING_ERROR;
			return false;
		}

		for(channel = 0; channel < encoder->protected_->channels; channel++) {
			if(!add_subframe_(encoder, frame_header.blocksize, encoder->private_->subframe_bps[channel], &encoder->private_->subframe_workspace[channel][encoder->private_->best_subframe[channel]], encoder->private_->frame)) {
				/* the above function sets the state for us in case of an error */
				return false;
			}
		}
	}

	if(encoder->protected_->loose_mid_side_stereo) {
		encoder->private_->loose_mid_side_stereo_frame_count++;
		if(encoder->private_->loose_mid_side_stereo_frame_count >= encoder->private_->loose_mid_side_stereo_frames)
			encoder->private_->loose_mid_side_stereo_frame_count = 0;
	}

	encoder->private_->last_channel_assignment = frame_header.channel_assignment;

	return true;
}

FLAC__bool process_subframe_(
	FLAC__StreamEncoder *encoder,
	unsigned min_partition_order,
	unsigned max_partition_order,
	const FLAC__FrameHeader *frame_header,
	unsigned subframe_bps,
	const FLAC__int32 integer_signal[],
	FLAC__Subframe *subframe[2],
	FLAC__EntropyCodingMethod_PartitionedRiceContents *partitioned_rice_contents[2],
	FLAC__int32 *residual[2],
	unsigned *best_subframe,
	unsigned *best_bits
)
{
#ifndef FLAC__INTEGER_ONLY_LIBRARY
	FLAC__float fixed_residual_bits_per_sample[FLAC__MAX_FIXED_ORDER+1];
#else
	FLAC__fixedpoint fixed_residual_bits_per_sample[FLAC__MAX_FIXED_ORDER+1];
#endif
#ifndef FLAC__INTEGER_ONLY_LIBRARY
	FLAC__double lpc_residual_bits_per_sample;
	FLAC__real autoc[FLAC__MAX_LPC_ORDER+1]; /* WATCHOUT: the size is important even though encoder->protected_->max_lpc_order might be less; some asm routines need all the space */
	FLAC__double lpc_error[FLAC__MAX_LPC_ORDER];
	unsigned min_lpc_order, max_lpc_order, lpc_order;
	unsigned min_qlp_coeff_precision, max_qlp_coeff_precision, qlp_coeff_precision;
#endif
	unsigned min_fixed_order, max_fixed_order, guess_fixed_order, fixed_order;
	unsigned rice_parameter;
	unsigned _candidate_bits, _best_bits;
	unsigned _best_subframe;
	/* only use RICE2 partitions if stream bps > 16 */
	const unsigned rice_parameter_limit = FLAC__stream_encoder_get_bits_per_sample(encoder) > 16? FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2_ESCAPE_PARAMETER : FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_ESCAPE_PARAMETER;

	FLAC__ASSERT(frame_header->blocksize > 0);

	/* verbatim subframe is the baseline against which we measure other compressed subframes */
	_best_subframe = 0;
	if(encoder->private_->disable_verbatim_subframes && frame_header->blocksize >= FLAC__MAX_FIXED_ORDER)
		_best_bits = UINT_MAX;
	else
		_best_bits = evaluate_verbatim_subframe_(encoder, integer_signal, frame_header->blocksize, subframe_bps, subframe[_best_subframe]);

	if(frame_header->blocksize >= FLAC__MAX_FIXED_ORDER) {
		unsigned signal_is_constant = false;
		guess_fixed_order = encoder->private_->local_fixed_compute_best_predictor(integer_signal+FLAC__MAX_FIXED_ORDER, frame_header->blocksize-FLAC__MAX_FIXED_ORDER, fixed_residual_bits_per_sample);
		/* check for constant subframe */
		if(
			!encoder->private_->disable_constant_subframes &&
#ifndef FLAC__INTEGER_ONLY_LIBRARY
			fixed_residual_bits_per_sample[1] == 0.0
#else
			fixed_residual_bits_per_sample[1] == FLAC__FP_ZERO
#endif
		) {
			/* the above means it's possible all samples are the same value; now double-check it: */
			unsigned i;
			signal_is_constant = true;
			for(i = 1; i < frame_header->blocksize; i++) {
				if(integer_signal[0] != integer_signal[i]) {
					signal_is_constant = false;
					break;
				}
			}
		}
		if(signal_is_constant) {
			_candidate_bits = evaluate_constant_subframe_(encoder, integer_signal[0], frame_header->blocksize, subframe_bps, subframe[!_best_subframe]);
			if(_candidate_bits < _best_bits) {
				_best_subframe = !_best_subframe;
				_best_bits = _candidate_bits;
			}
		}
		else {
			if(!encoder->private_->disable_fixed_subframes || (encoder->protected_->max_lpc_order == 0 && _best_bits == UINT_MAX)) {
				/* encode fixed */
				if(encoder->protected_->do_exhaustive_model_search) {
					min_fixed_order = 0;
					max_fixed_order = FLAC__MAX_FIXED_ORDER;
				}
				else {
					min_fixed_order = max_fixed_order = guess_fixed_order;
				}
				if(max_fixed_order >= frame_header->blocksize)
					max_fixed_order = frame_header->blocksize - 1;
				for(fixed_order = min_fixed_order; fixed_order <= max_fixed_order; fixed_order++) {
#ifndef FLAC__INTEGER_ONLY_LIBRARY
					if(fixed_residual_bits_per_sample[fixed_order] >= (FLAC__float)subframe_bps)
						continue; /* don't even try */
					rice_parameter = (fixed_residual_bits_per_sample[fixed_order] > 0.0)? (unsigned)(fixed_residual_bits_per_sample[fixed_order]+0.5) : 0; /* 0.5 is for rounding */
#else
					if(FLAC__fixedpoint_trunc(fixed_residual_bits_per_sample[fixed_order]) >= (int)subframe_bps)
						continue; /* don't even try */
					rice_parameter = (fixed_residual_bits_per_sample[fixed_order] > FLAC__FP_ZERO)? (unsigned)FLAC__fixedpoint_trunc(fixed_residual_bits_per_sample[fixed_order]+FLAC__FP_ONE_HALF) : 0; /* 0.5 is for rounding */
#endif
					rice_parameter++; /* to account for the signed->unsigned conversion during rice coding */
					if(rice_parameter >= rice_parameter_limit) {
#ifdef DEBUG_VERBOSE
						fprintf(stderr, "clipping rice_parameter (%u -> %u) @0\n", rice_parameter, rice_parameter_limit - 1);
#endif
						rice_parameter = rice_parameter_limit - 1;
					}
					_candidate_bits =
						evaluate_fixed_subframe_(
							encoder,
							integer_signal,
							residual[!_best_subframe],
							encoder->private_->abs_residual_partition_sums,
							encoder->private_->raw_bits_per_partition,
							frame_header->blocksize,
							subframe_bps,
							fixed_order,
							rice_parameter,
							rice_parameter_limit,
							min_partition_order,
							max_partition_order,
							encoder->protected_->do_escape_coding,
							encoder->protected_->rice_parameter_search_dist,
							subframe[!_best_subframe],
							partitioned_rice_contents[!_best_subframe]
						);
					if(_candidate_bits < _best_bits) {
						_best_subframe = !_best_subframe;
						_best_bits = _candidate_bits;
					}
				}
			}

#ifndef FLAC__INTEGER_ONLY_LIBRARY
			/* encode lpc */
			if(encoder->protected_->max_lpc_order > 0) {
				if(encoder->protected_->max_lpc_order >= frame_header->blocksize)
					max_lpc_order = frame_header->blocksize-1;
				else
					max_lpc_order = encoder->protected_->max_lpc_order;
				if(max_lpc_order > 0) {
					unsigned a;
					for (a = 0; a < encoder->protected_->num_apodizations; a++) {
						FLAC__lpc_window_data(integer_signal, encoder->private_->window[a], encoder->private_->windowed_signal, frame_header->blocksize);
						encoder->private_->local_lpc_compute_autocorrelation(encoder->private_->windowed_signal, frame_header->blocksize, max_lpc_order+1, autoc);
						/* if autoc[0] == 0.0, the signal is constant and we usually won't get here, but it can happen */
						if(autoc[0] != 0.0) {
							FLAC__lpc_compute_lp_coefficients(autoc, &max_lpc_order, encoder->private_->lp_coeff, lpc_error);
							if(encoder->protected_->do_exhaustive_model_search) {
								min_lpc_order = 1;
							}
							else {
								const unsigned guess_lpc_order =
									FLAC__lpc_compute_best_order(
										lpc_error,
										max_lpc_order,
										frame_header->blocksize,
										subframe_bps + (
											encoder->protected_->do_qlp_coeff_prec_search?
												FLAC__MIN_QLP_COEFF_PRECISION : /* have to guess; use the min possible size to avoid accidentally favoring lower orders */
												encoder->protected_->qlp_coeff_precision
										)
									);
								min_lpc_order = max_lpc_order = guess_lpc_order;
							}
							if(max_lpc_order >= frame_header->blocksize)
								max_lpc_order = frame_header->blocksize - 1;
							for(lpc_order = min_lpc_order; lpc_order <= max_lpc_order; lpc_order++) {
								lpc_residual_bits_per_sample = FLAC__lpc_compute_expected_bits_per_residual_sample(lpc_error[lpc_order-1], frame_header->blocksize-lpc_order);
								if(lpc_residual_bits_per_sample >= (FLAC__double)subframe_bps)
									continue; /* don't even try */
								rice_parameter = (lpc_residual_bits_per_sample > 0.0)? (unsigned)(lpc_residual_bits_per_sample+0.5) : 0; /* 0.5 is for rounding */
								rice_parameter++; /* to account for the signed->unsigned conversion during rice coding */
								if(rice_parameter >= rice_parameter_limit) {
#ifdef DEBUG_VERBOSE
									fprintf(stderr, "clipping rice_parameter (%u -> %u) @1\n", rice_parameter, rice_parameter_limit - 1);
#endif
									rice_parameter = rice_parameter_limit - 1;
								}
								if(encoder->protected_->do_qlp_coeff_prec_search) {
									min_qlp_coeff_precision = FLAC__MIN_QLP_COEFF_PRECISION;
									/* try to ensure a 32-bit datapath throughout for 16bps(+1bps for side channel) or less */
									if(subframe_bps <= 17) {
										max_qlp_coeff_precision = min(32 - subframe_bps - lpc_order, FLAC__MAX_QLP_COEFF_PRECISION);
										max_qlp_coeff_precision = max(max_qlp_coeff_precision, min_qlp_coeff_precision);
									}
									else
										max_qlp_coeff_precision = FLAC__MAX_QLP_COEFF_PRECISION;
								}
								else {
									min_qlp_coeff_precision = max_qlp_coeff_precision = encoder->protected_->qlp_coeff_precision;
								}
								for(qlp_coeff_precision = min_qlp_coeff_precision; qlp_coeff_precision <= max_qlp_coeff_precision; qlp_coeff_precision++) {
									_candidate_bits =
										evaluate_lpc_subframe_(
											encoder,
											integer_signal,
											residual[!_best_subframe],
											encoder->private_->abs_residual_partition_sums,
											encoder->private_->raw_bits_per_partition,
											encoder->private_->lp_coeff[lpc_order-1],
											frame_header->blocksize,
											subframe_bps,
											lpc_order,
											qlp_coeff_precision,
											rice_parameter,
											rice_parameter_limit,
											min_partition_order,
											max_partition_order,
											encoder->protected_->do_escape_coding,
											encoder->protected_->rice_parameter_search_dist,
											subframe[!_best_subframe],
											partitioned_rice_contents[!_best_subframe]
										);
									if(_candidate_bits > 0) { /* if == 0, there was a problem quantizing the lpcoeffs */
										if(_candidate_bits < _best_bits) {
											_best_subframe = !_best_subframe;
											_best_bits = _candidate_bits;
										}
									}
								}
							}
						}
					}
				}
			}
#endif /* !defined FLAC__INTEGER_ONLY_LIBRARY */
		}
	}

	/* under rare circumstances this can happen when all but lpc subframe types are disabled: */
	if(_best_bits == UINT_MAX) {
		FLAC__ASSERT(_best_subframe == 0);
		_best_bits = evaluate_verbatim_subframe_(encoder, integer_signal, frame_header->blocksize, subframe_bps, subframe[_best_subframe]);
	}

	*best_subframe = _best_subframe;
	*best_bits = _best_bits;

	return true;
}

FLAC__bool add_subframe_(
	FLAC__StreamEncoder *encoder,
	unsigned blocksize,
	unsigned subframe_bps,
	const FLAC__Subframe *subframe,
	FLAC__BitWriter *frame
)
{
	switch(subframe->type) {
		case FLAC__SUBFRAME_TYPE_CONSTANT:
			if(!FLAC__subframe_add_constant(&(subframe->data.constant), subframe_bps, subframe->wasted_bits, frame)) {
				encoder->protected_->state = FLAC__STREAM_ENCODER_FRAMING_ERROR;
				return false;
			}
			break;
		case FLAC__SUBFRAME_TYPE_FIXED:
			if(!FLAC__subframe_add_fixed(&(subframe->data.fixed), blocksize - subframe->data.fixed.order, subframe_bps, subframe->wasted_bits, frame)) {
				encoder->protected_->state = FLAC__STREAM_ENCODER_FRAMING_ERROR;
				return false;
			}
			break;
		case FLAC__SUBFRAME_TYPE_LPC:
			if(!FLAC__subframe_add_lpc(&(subframe->data.lpc), blocksize - subframe->data.lpc.order, subframe_bps, subframe->wasted_bits, frame)) {
				encoder->protected_->state = FLAC__STREAM_ENCODER_FRAMING_ERROR;
				return false;
			}
			break;
		case FLAC__SUBFRAME_TYPE_VERBATIM:
			if(!FLAC__subframe_add_verbatim(&(subframe->data.verbatim), blocksize, subframe_bps, subframe->wasted_bits, frame)) {
				encoder->protected_->state = FLAC__STREAM_ENCODER_FRAMING_ERROR;
				return false;
			}
			break;
		default:
			FLAC__ASSERT(0);
	}

	return true;
}

#define SPOTCHECK_ESTIMATE 0
#if SPOTCHECK_ESTIMATE
static void spotcheck_subframe_estimate_(
	FLAC__StreamEncoder *encoder,
	unsigned blocksize,
	unsigned subframe_bps,
	const FLAC__Subframe *subframe,
	unsigned estimate
)
{
	FLAC__bool ret;
	FLAC__BitWriter *frame = FLAC__bitwriter_new();
	if(frame == 0) {
		fprintf(stderr, "EST: can't allocate frame\n");
		return;
	}
	if(!FLAC__bitwriter_init(frame)) {
		fprintf(stderr, "EST: can't init frame\n");
		return;
	}
	ret = add_subframe_(encoder, blocksize, subframe_bps, subframe, frame);
	FLAC__ASSERT(ret);
	{
		const unsigned actual = FLAC__bitwriter_get_input_bits_unconsumed(frame);
		if(estimate != actual)
			fprintf(stderr, "EST: bad, frame#%u sub#%%d type=%8s est=%u, actual=%u, delta=%d\n", encoder->private_->current_frame_number, FLAC__SubframeTypeString[subframe->type], estimate, actual, (int)actual-(int)estimate);
	}
	FLAC__bitwriter_delete(frame);
}
#endif

unsigned evaluate_constant_subframe_(
	FLAC__StreamEncoder *encoder,
	const FLAC__int32 signal,
	unsigned blocksize,
	unsigned subframe_bps,
	FLAC__Subframe *subframe
)
{
	unsigned estimate;
	subframe->type = FLAC__SUBFRAME_TYPE_CONSTANT;
	subframe->data.constant.value = signal;

	estimate = FLAC__SUBFRAME_ZERO_PAD_LEN + FLAC__SUBFRAME_TYPE_LEN + FLAC__SUBFRAME_WASTED_BITS_FLAG_LEN + subframe->wasted_bits + subframe_bps;

#if SPOTCHECK_ESTIMATE
	spotcheck_subframe_estimate_(encoder, blocksize, subframe_bps, subframe, estimate);
#else
	(void)encoder, (void)blocksize;
#endif

	return estimate;
}

unsigned evaluate_fixed_subframe_(
	FLAC__StreamEncoder *encoder,
	const FLAC__int32 signal[],
	FLAC__int32 residual[],
	FLAC__uint64 abs_residual_partition_sums[],
	unsigned raw_bits_per_partition[],
	unsigned blocksize,
	unsigned subframe_bps,
	unsigned order,
	unsigned rice_parameter,
	unsigned rice_parameter_limit,
	unsigned min_partition_order,
	unsigned max_partition_order,
	FLAC__bool do_escape_coding,
	unsigned rice_parameter_search_dist,
	FLAC__Subframe *subframe,
	FLAC__EntropyCodingMethod_PartitionedRiceContents *partitioned_rice_contents
)
{
	unsigned i, residual_bits, estimate;
	const unsigned residual_samples = blocksize - order;

	FLAC__fixed_compute_residual(signal+order, residual_samples, order, residual);

	subframe->type = FLAC__SUBFRAME_TYPE_FIXED;

	subframe->data.fixed.entropy_coding_method.type = FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE;
	subframe->data.fixed.entropy_coding_method.data.partitioned_rice.contents = partitioned_rice_contents;
	subframe->data.fixed.residual = residual;

	residual_bits =
		find_best_partition_order_(
			encoder->private_,
			residual,
			abs_residual_partition_sums,
			raw_bits_per_partition,
			residual_samples,
			order,
			rice_parameter,
			rice_parameter_limit,
			min_partition_order,
			max_partition_order,
			subframe_bps,
			do_escape_coding,
			rice_parameter_search_dist,
			&subframe->data.fixed.entropy_coding_method
		);

	subframe->data.fixed.order = order;
	for(i = 0; i < order; i++)
		subframe->data.fixed.warmup[i] = signal[i];

	estimate = FLAC__SUBFRAME_ZERO_PAD_LEN + FLAC__SUBFRAME_TYPE_LEN + FLAC__SUBFRAME_WASTED_BITS_FLAG_LEN + subframe->wasted_bits + (order * subframe_bps) + residual_bits;

#if SPOTCHECK_ESTIMATE
	spotcheck_subframe_estimate_(encoder, blocksize, subframe_bps, subframe, estimate);
#endif

	return estimate;
}

#ifndef FLAC__INTEGER_ONLY_LIBRARY
unsigned evaluate_lpc_subframe_(
	FLAC__StreamEncoder *encoder,
	const FLAC__int32 signal[],
	FLAC__int32 residual[],
	FLAC__uint64 abs_residual_partition_sums[],
	unsigned raw_bits_per_partition[],
	const FLAC__real lp_coeff[],
	unsigned blocksize,
	unsigned subframe_bps,
	unsigned order,
	unsigned qlp_coeff_precision,
	unsigned rice_parameter,
	unsigned rice_parameter_limit,
	unsigned min_partition_order,
	unsigned max_partition_order,
	FLAC__bool do_escape_coding,
	unsigned rice_parameter_search_dist,
	FLAC__Subframe *subframe,
	FLAC__EntropyCodingMethod_PartitionedRiceContents *partitioned_rice_contents
)
{
	FLAC__int32 qlp_coeff[FLAC__MAX_LPC_ORDER];
	unsigned i, residual_bits, estimate;
	int quantization, ret;
	const unsigned residual_samples = blocksize - order;

	/* try to keep qlp coeff precision such that only 32-bit math is required for decode of <=16bps streams */
	if(subframe_bps <= 16) {
		FLAC__ASSERT(order > 0);
		FLAC__ASSERT(order <= FLAC__MAX_LPC_ORDER);
		qlp_coeff_precision = min(qlp_coeff_precision, 32 - subframe_bps - FLAC__bitmath_ilog2(order));
	}

	ret = FLAC__lpc_quantize_coefficients(lp_coeff, order, qlp_coeff_precision, qlp_coeff, &quantization);
	if(ret != 0)
		return 0; /* this is a hack to indicate to the caller that we can't do lp at this order on this subframe */

	if(subframe_bps + qlp_coeff_precision + FLAC__bitmath_ilog2(order) <= 32)
		if(subframe_bps <= 16 && qlp_coeff_precision <= 16)
			encoder->private_->local_lpc_compute_residual_from_qlp_coefficients_16bit(signal+order, residual_samples, qlp_coeff, order, quantization, residual);
		else
			encoder->private_->local_lpc_compute_residual_from_qlp_coefficients(signal+order, residual_samples, qlp_coeff, order, quantization, residual);
	else
		encoder->private_->local_lpc_compute_residual_from_qlp_coefficients_64bit(signal+order, residual_samples, qlp_coeff, order, quantization, residual);

	subframe->type = FLAC__SUBFRAME_TYPE_LPC;

	subframe->data.lpc.entropy_coding_method.type = FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE;
	subframe->data.lpc.entropy_coding_method.data.partitioned_rice.contents = partitioned_rice_contents;
	subframe->data.lpc.residual = residual;

	residual_bits =
		find_best_partition_order_(
			encoder->private_,
			residual,
			abs_residual_partition_sums,
			raw_bits_per_partition,
			residual_samples,
			order,
			rice_parameter,
			rice_parameter_limit,
			min_partition_order,
			max_partition_order,
			subframe_bps,
			do_escape_coding,
			rice_parameter_search_dist,
			&subframe->data.lpc.entropy_coding_method
		);

	subframe->data.lpc.order = order;
	subframe->data.lpc.qlp_coeff_precision = qlp_coeff_precision;
	subframe->data.lpc.quantization_level = quantization;
	memcpy(subframe->data.lpc.qlp_coeff, qlp_coeff, sizeof(FLAC__int32)*FLAC__MAX_LPC_ORDER);
	for(i = 0; i < order; i++)
		subframe->data.lpc.warmup[i] = signal[i];

	estimate = FLAC__SUBFRAME_ZERO_PAD_LEN + FLAC__SUBFRAME_TYPE_LEN + FLAC__SUBFRAME_WASTED_BITS_FLAG_LEN + subframe->wasted_bits + FLAC__SUBFRAME_LPC_QLP_COEFF_PRECISION_LEN + FLAC__SUBFRAME_LPC_QLP_SHIFT_LEN + (order * (qlp_coeff_precision + subframe_bps)) + residual_bits;

#if SPOTCHECK_ESTIMATE
	spotcheck_subframe_estimate_(encoder, blocksize, subframe_bps, subframe, estimate);
#endif

	return estimate;
}
#endif

unsigned evaluate_verbatim_subframe_(
	FLAC__StreamEncoder *encoder,
	const FLAC__int32 signal[],
	unsigned blocksize,
	unsigned subframe_bps,
	FLAC__Subframe *subframe
)
{
	unsigned estimate;

	subframe->type = FLAC__SUBFRAME_TYPE_VERBATIM;

	subframe->data.verbatim.data = signal;

	estimate = FLAC__SUBFRAME_ZERO_PAD_LEN + FLAC__SUBFRAME_TYPE_LEN + FLAC__SUBFRAME_WASTED_BITS_FLAG_LEN + subframe->wasted_bits + (blocksize * subframe_bps);

#if SPOTCHECK_ESTIMATE
	spotcheck_subframe_estimate_(encoder, blocksize, subframe_bps, subframe, estimate);
#else
	(void)encoder;
#endif

	return estimate;
}

unsigned find_best_partition_order_(
	FLAC__StreamEncoderPrivate *private_,
	const FLAC__int32 residual[],
	FLAC__uint64 abs_residual_partition_sums[],
	unsigned raw_bits_per_partition[],
	unsigned residual_samples,
	unsigned predictor_order,
	unsigned rice_parameter,
	unsigned rice_parameter_limit,
	unsigned min_partition_order,
	unsigned max_partition_order,
	unsigned bps,
	FLAC__bool do_escape_coding,
	unsigned rice_parameter_search_dist,
	FLAC__EntropyCodingMethod *best_ecm
)
{
	unsigned residual_bits, best_residual_bits = 0;
	unsigned best_parameters_index = 0;
	unsigned best_partition_order = 0;
	const unsigned blocksize = residual_samples + predictor_order;

	max_partition_order = FLAC__format_get_max_rice_partition_order_from_blocksize_limited_max_and_predictor_order(max_partition_order, blocksize, predictor_order);
	min_partition_order = min(min_partition_order, max_partition_order);

	precompute_partition_info_sums_(residual, abs_residual_partition_sums, residual_samples, predictor_order, min_partition_order, max_partition_order, bps);

	if(do_escape_coding)
		precompute_partition_info_escapes_(residual, raw_bits_per_partition, residual_samples, predictor_order, min_partition_order, max_partition_order);

	{
		int partition_order;
		unsigned sum;

		for(partition_order = (int)max_partition_order, sum = 0; partition_order >= (int)min_partition_order; partition_order--) {
			if(!
				set_partitioned_rice_(
#ifdef EXACT_RICE_BITS_CALCULATION
					residual,
#endif
					abs_residual_partition_sums+sum,
					raw_bits_per_partition+sum,
					residual_samples,
					predictor_order,
					rice_parameter,
					rice_parameter_limit,
					rice_parameter_search_dist,
					(unsigned)partition_order,
					do_escape_coding,
					&private_->partitioned_rice_contents_extra[!best_parameters_index],
					&residual_bits
				)
			)
			{
				FLAC__ASSERT(best_residual_bits != 0);
				break;
			}
			sum += 1u << partition_order;
			if(best_residual_bits == 0 || residual_bits < best_residual_bits) {
				best_residual_bits = residual_bits;
				best_parameters_index = !best_parameters_index;
				best_partition_order = partition_order;
			}
		}
	}

	best_ecm->data.partitioned_rice.order = best_partition_order;

	{
		/*
		 * We are allowed to de-const the pointer based on our special
		 * knowledge; it is const to the outside world.
		 */
		FLAC__EntropyCodingMethod_PartitionedRiceContents* prc = (FLAC__EntropyCodingMethod_PartitionedRiceContents*)best_ecm->data.partitioned_rice.contents;
		unsigned partition;

		/* save best parameters and raw_bits */
		FLAC__format_entropy_coding_method_partitioned_rice_contents_ensure_size(prc, max(6, best_partition_order));
		memcpy(prc->parameters, private_->partitioned_rice_contents_extra[best_parameters_index].parameters, sizeof(unsigned)*(1<<(best_partition_order)));
		if(do_escape_coding)
			memcpy(prc->raw_bits, private_->partitioned_rice_contents_extra[best_parameters_index].raw_bits, sizeof(unsigned)*(1<<(best_partition_order)));
		/*
		 * Now need to check if the type should be changed to
		 * FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2 based on the
		 * size of the rice parameters.
		 */
		for(partition = 0; partition < (1u<<best_partition_order); partition++) {
			if(prc->parameters[partition] >= FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_ESCAPE_PARAMETER) {
				best_ecm->type = FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2;
				break;
			}
		}
	}

	return best_residual_bits;
}

#if defined(FLAC__CPU_IA32) && !defined FLAC__NO_ASM && defined FLAC__HAS_NASM
extern void precompute_partition_info_sums_32bit_asm_ia32_(
	const FLAC__int32 residual[],
	FLAC__uint64 abs_residual_partition_sums[],
	unsigned blocksize,
	unsigned predictor_order,
	unsigned min_partition_order,
	unsigned max_partition_order
);
#endif

void precompute_partition_info_sums_(
	const FLAC__int32 residual[],
	FLAC__uint64 abs_residual_partition_sums[],
	unsigned residual_samples,
	unsigned predictor_order,
	unsigned min_partition_order,
	unsigned max_partition_order,
	unsigned bps
)
{
	const unsigned default_partition_samples = (residual_samples + predictor_order) >> max_partition_order;
	unsigned partitions = 1u << max_partition_order;

	FLAC__ASSERT(default_partition_samples > predictor_order);

#if defined(FLAC__CPU_IA32) && !defined FLAC__NO_ASM && defined FLAC__HAS_NASM
	/* slightly pessimistic but still catches all common cases */
	/* WATCHOUT: "+ bps" is an assumption that the average residual magnitude will not be more than "bps" bits */
	if(FLAC__bitmath_ilog2(default_partition_samples) + bps < 32) {
		precompute_partition_info_sums_32bit_asm_ia32_(residual, abs_residual_partition_sums, residual_samples + predictor_order, predictor_order, min_partition_order, max_partition_order);
		return;
	}
#endif

	/* first do max_partition_order */
	{
		unsigned partition, residual_sample, end = (unsigned)(-(int)predictor_order);
		/* slightly pessimistic but still catches all common cases */
		/* WATCHOUT: "+ bps" is an assumption that the average residual magnitude will not be more than "bps" bits */
		if(FLAC__bitmath_ilog2(default_partition_samples) + bps < 32) {
			FLAC__uint32 abs_residual_partition_sum;

			for(partition = residual_sample = 0; partition < partitions; partition++) {
				end += default_partition_samples;
				abs_residual_partition_sum = 0;
				for( ; residual_sample < end; residual_sample++)
					abs_residual_partition_sum += abs(residual[residual_sample]); /* abs(INT_MIN) is undefined, but if the residual is INT_MIN we have bigger problems */
				abs_residual_partition_sums[partition] = abs_residual_partition_sum;
			}
		}
		else { /* have to pessimistically use 64 bits for accumulator */
			FLAC__uint64 abs_residual_partition_sum;

			for(partition = residual_sample = 0; partition < partitions; partition++) {
				end += default_partition_samples;
				abs_residual_partition_sum = 0;
				for( ; residual_sample < end; residual_sample++)
					abs_residual_partition_sum += abs(residual[residual_sample]); /* abs(INT_MIN) is undefined, but if the residual is INT_MIN we have bigger problems */
				abs_residual_partition_sums[partition] = abs_residual_partition_sum;
			}
		}
	}

	/* now merge partitions for lower orders */
	{
		unsigned from_partition = 0, to_partition = partitions;
		int partition_order;
		for(partition_order = (int)max_partition_order - 1; partition_order >= (int)min_partition_order; partition_order--) {
			unsigned i;
			partitions >>= 1;
			for(i = 0; i < partitions; i++) {
				abs_residual_partition_sums[to_partition++] =
					abs_residual_partition_sums[from_partition  ] +
					abs_residual_partition_sums[from_partition+1];
				from_partition += 2;
			}
		}
	}
}

void precompute_partition_info_escapes_(
	const FLAC__int32 residual[],
	unsigned raw_bits_per_partition[],
	unsigned residual_samples,
	unsigned predictor_order,
	unsigned min_partition_order,
	unsigned max_partition_order
)
{
	int partition_order;
	unsigned from_partition, to_partition = 0;
	const unsigned blocksize = residual_samples + predictor_order;

	/* first do max_partition_order */
	for(partition_order = (int)max_partition_order; partition_order >= 0; partition_order--) {
		FLAC__int32 r;
		FLAC__uint32 rmax;
		unsigned partition, partition_sample, partition_samples, residual_sample;
		const unsigned partitions = 1u << partition_order;
		const unsigned default_partition_samples = blocksize >> partition_order;

		FLAC__ASSERT(default_partition_samples > predictor_order);

		for(partition = residual_sample = 0; partition < partitions; partition++) {
			partition_samples = default_partition_samples;
			if(partition == 0)
				partition_samples -= predictor_order;
			rmax = 0;
			for(partition_sample = 0; partition_sample < partition_samples; partition_sample++) {
				r = residual[residual_sample++];
				/* OPT: maybe faster: rmax |= r ^ (r>>31) */
				if(r < 0)
					rmax |= ~r;
				else
					rmax |= r;
			}
			/* now we know all residual values are in the range [-rmax-1,rmax] */
			raw_bits_per_partition[partition] = rmax? FLAC__bitmath_ilog2(rmax) + 2 : 1;
		}
		to_partition = partitions;
		break; /*@@@ yuck, should remove the 'for' loop instead */
	}

	/* now merge partitions for lower orders */
	for(from_partition = 0, --partition_order; partition_order >= (int)min_partition_order; partition_order--) {
		unsigned m;
		unsigned i;
		const unsigned partitions = 1u << partition_order;
		for(i = 0; i < partitions; i++) {
			m = raw_bits_per_partition[from_partition];
			from_partition++;
			raw_bits_per_partition[to_partition] = max(m, raw_bits_per_partition[from_partition]);
			from_partition++;
			to_partition++;
		}
	}
}

#ifdef EXACT_RICE_BITS_CALCULATION
static FLaC__INLINE unsigned count_rice_bits_in_partition_(
	const unsigned rice_parameter,
	const unsigned partition_samples,
	const FLAC__int32 *residual
)
{
	unsigned i, partition_bits =
		FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_PARAMETER_LEN + /* actually could end up being FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2_PARAMETER_LEN but err on side of 16bps */
		(1+rice_parameter) * partition_samples /* 1 for unary stop bit + rice_parameter for the binary portion */
	;
	for(i = 0; i < partition_samples; i++)
		partition_bits += ( (FLAC__uint32)((residual[i]<<1)^(residual[i]>>31)) >> rice_parameter );
	return partition_bits;
}
#else
static FLaC__INLINE unsigned count_rice_bits_in_partition_(
	const unsigned rice_parameter,
	const unsigned partition_samples,
	const FLAC__uint64 abs_residual_partition_sum
)
{
	return
		FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_PARAMETER_LEN + /* actually could end up being FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2_PARAMETER_LEN but err on side of 16bps */
		(1+rice_parameter) * partition_samples + /* 1 for unary stop bit + rice_parameter for the binary portion */
		(
			rice_parameter?
				(unsigned)(abs_residual_partition_sum >> (rice_parameter-1)) /* rice_parameter-1 because the real coder sign-folds instead of using a sign bit */
				: (unsigned)(abs_residual_partition_sum << 1) /* can't shift by negative number, so reverse */
		)
		- (partition_samples >> 1)
		/* -(partition_samples>>1) to subtract out extra contributions to the abs_residual_partition_sum.
		 * The actual number of bits used is closer to the sum(for all i in the partition) of  abs(residual[i])>>(rice_parameter-1)
		 * By using the abs_residual_partition sum, we also add in bits in the LSBs that would normally be shifted out.
		 * So the subtraction term tries to guess how many extra bits were contributed.
		 * If the LSBs are randomly distributed, this should average to 0.5 extra bits per sample.
		 */
	;
}
#endif

FLAC__bool set_partitioned_rice_(
#ifdef EXACT_RICE_BITS_CALCULATION
	const FLAC__int32 residual[],
#endif
	const FLAC__uint64 abs_residual_partition_sums[],
	const unsigned raw_bits_per_partition[],
	const unsigned residual_samples,
	const unsigned predictor_order,
	const unsigned suggested_rice_parameter,
	const unsigned rice_parameter_limit,
	const unsigned rice_parameter_search_dist,
	const unsigned partition_order,
	const FLAC__bool search_for_escapes,
	FLAC__EntropyCodingMethod_PartitionedRiceContents *partitioned_rice_contents,
	unsigned *bits
)
{
	unsigned rice_parameter, partition_bits;
	unsigned best_partition_bits, best_rice_parameter = 0;
	unsigned bits_ = FLAC__ENTROPY_CODING_METHOD_TYPE_LEN + FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_ORDER_LEN;
	unsigned *parameters, *raw_bits;
#ifdef ENABLE_RICE_PARAMETER_SEARCH
	unsigned min_rice_parameter, max_rice_parameter;
#else
	(void)rice_parameter_search_dist;
#endif

	FLAC__ASSERT(suggested_rice_parameter < FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2_ESCAPE_PARAMETER);
	FLAC__ASSERT(rice_parameter_limit <= FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2_ESCAPE_PARAMETER);

	FLAC__format_entropy_coding_method_partitioned_rice_contents_ensure_size(partitioned_rice_contents, max(6, partition_order));
	parameters = partitioned_rice_contents->parameters;
	raw_bits = partitioned_rice_contents->raw_bits;

	if(partition_order == 0) {
		best_partition_bits = (unsigned)(-1);
#ifdef ENABLE_RICE_PARAMETER_SEARCH
		if(rice_parameter_search_dist) {
			if(suggested_rice_parameter < rice_parameter_search_dist)
				min_rice_parameter = 0;
			else
				min_rice_parameter = suggested_rice_parameter - rice_parameter_search_dist;
			max_rice_parameter = suggested_rice_parameter + rice_parameter_search_dist;
			if(max_rice_parameter >= rice_parameter_limit) {
#ifdef DEBUG_VERBOSE
				fprintf(stderr, "clipping rice_parameter (%u -> %u) @5\n", max_rice_parameter, rice_parameter_limit - 1);
#endif
				max_rice_parameter = rice_parameter_limit - 1;
			}
		}
		else
			min_rice_parameter = max_rice_parameter = suggested_rice_parameter;

		for(rice_parameter = min_rice_parameter; rice_parameter <= max_rice_parameter; rice_parameter++) {
#else
			rice_parameter = suggested_rice_parameter;
#endif
#ifdef EXACT_RICE_BITS_CALCULATION
			partition_bits = count_rice_bits_in_partition_(rice_parameter, residual_samples, residual);
#else
			partition_bits = count_rice_bits_in_partition_(rice_parameter, residual_samples, abs_residual_partition_sums[0]);
#endif
			if(partition_bits < best_partition_bits) {
				best_rice_parameter = rice_parameter;
				best_partition_bits = partition_bits;
			}
#ifdef ENABLE_RICE_PARAMETER_SEARCH
		}
#endif
		if(search_for_escapes) {
			partition_bits = FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2_PARAMETER_LEN + FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_RAW_LEN + raw_bits_per_partition[0] * residual_samples;
			if(partition_bits <= best_partition_bits) {
				raw_bits[0] = raw_bits_per_partition[0];
				best_rice_parameter = 0; /* will be converted to appropriate escape parameter later */
				best_partition_bits = partition_bits;
			}
			else
				raw_bits[0] = 0;
		}
		parameters[0] = best_rice_parameter;
		bits_ += best_partition_bits;
	}
	else {
		unsigned partition, residual_sample;
		unsigned partition_samples;
		FLAC__uint64 mean, k;
		const unsigned partitions = 1u << partition_order;
		for(partition = residual_sample = 0; partition < partitions; partition++) {
			partition_samples = (residual_samples+predictor_order) >> partition_order;
			if(partition == 0) {
				if(partition_samples <= predictor_order)
					return false;
				else
					partition_samples -= predictor_order;
			}
			mean = abs_residual_partition_sums[partition];
			/* we are basically calculating the size in bits of the
			 * average residual magnitude in the partition:
			 *   rice_parameter = floor(log2(mean/partition_samples))
			 * 'mean' is not a good name for the variable, it is
			 * actually the sum of magnitudes of all residual values
			 * in the partition, so the actual mean is
			 * mean/partition_samples
			 */
			for(rice_parameter = 0, k = partition_samples; k < mean; rice_parameter++, k <<= 1)
				;
			if(rice_parameter >= rice_parameter_limit) {
#ifdef DEBUG_VERBOSE
				fprintf(stderr, "clipping rice_parameter (%u -> %u) @6\n", rice_parameter, rice_parameter_limit - 1);
#endif
				rice_parameter = rice_parameter_limit - 1;
			}

			best_partition_bits = (unsigned)(-1);
#ifdef ENABLE_RICE_PARAMETER_SEARCH
			if(rice_parameter_search_dist) {
				if(rice_parameter < rice_parameter_search_dist)
					min_rice_parameter = 0;
				else
					min_rice_parameter = rice_parameter - rice_parameter_search_dist;
				max_rice_parameter = rice_parameter + rice_parameter_search_dist;
				if(max_rice_parameter >= rice_parameter_limit) {
#ifdef DEBUG_VERBOSE
					fprintf(stderr, "clipping rice_parameter (%u -> %u) @7\n", max_rice_parameter, rice_parameter_limit - 1);
#endif
					max_rice_parameter = rice_parameter_limit - 1;
				}
			}
			else
				min_rice_parameter = max_rice_parameter = rice_parameter;

			for(rice_parameter = min_rice_parameter; rice_parameter <= max_rice_parameter; rice_parameter++) {
#endif
#ifdef EXACT_RICE_BITS_CALCULATION
				partition_bits = count_rice_bits_in_partition_(rice_parameter, partition_samples, residual+residual_sample);
#else
				partition_bits = count_rice_bits_in_partition_(rice_parameter, partition_samples, abs_residual_partition_sums[partition]);
#endif
				if(partition_bits < best_partition_bits) {
					best_rice_parameter = rice_parameter;
					best_partition_bits = partition_bits;
				}
#ifdef ENABLE_RICE_PARAMETER_SEARCH
			}
#endif
			if(search_for_escapes) {
				partition_bits = FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2_PARAMETER_LEN + FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_RAW_LEN + raw_bits_per_partition[partition] * partition_samples;
				if(partition_bits <= best_partition_bits) {
					raw_bits[partition] = raw_bits_per_partition[partition];
					best_rice_parameter = 0; /* will be converted to appropriate escape parameter later */
					best_partition_bits = partition_bits;
				}
				else
					raw_bits[partition] = 0;
			}
			parameters[partition] = best_rice_parameter;
			bits_ += best_partition_bits;
			residual_sample += partition_samples;
		}
	}

	*bits = bits_;
	return true;
}

unsigned get_wasted_bits_(FLAC__int32 signal[], unsigned samples)
{
	unsigned i, shift;
	FLAC__int32 x = 0;

	for(i = 0; i < samples && !(x&1); i++)
		x |= signal[i];

	if(x == 0) {
		shift = 0;
	}
	else {
		for(shift = 0; !(x&1); shift++)
			x >>= 1;
	}

	if(shift > 0) {
		for(i = 0; i < samples; i++)
			 signal[i] >>= shift;
	}

	return shift;
}

void append_to_verify_fifo_(verify_input_fifo *fifo, const FLAC__int32 * const input[], unsigned input_offset, unsigned channels, unsigned wide_samples)
{
	unsigned channel;

	for(channel = 0; channel < channels; channel++)
		memcpy(&fifo->data[channel][fifo->tail], &input[channel][input_offset], sizeof(FLAC__int32) * wide_samples);

	fifo->tail += wide_samples;

	FLAC__ASSERT(fifo->tail <= fifo->size);
}

void append_to_verify_fifo_interleaved_(verify_input_fifo *fifo, const FLAC__int32 input[], unsigned input_offset, unsigned channels, unsigned wide_samples)
{
	unsigned channel;
	unsigned sample, wide_sample;
	unsigned tail = fifo->tail;

	sample = input_offset * channels;
	for(wide_sample = 0; wide_sample < wide_samples; wide_sample++) {
		for(channel = 0; channel < channels; channel++)
			fifo->data[channel][tail] = input[sample++];
		tail++;
	}
	fifo->tail = tail;

	FLAC__ASSERT(fifo->tail <= fifo->size);
}

FLAC__StreamDecoderReadStatus verify_read_callback_(const FLAC__StreamDecoder *decoder, FLAC__byte buffer[], size_t *bytes, void *client_data)
{
	FLAC__StreamEncoder *encoder = (FLAC__StreamEncoder*)client_data;
	const size_t encoded_bytes = encoder->private_->verify.output.bytes;
	(void)decoder;

	if(encoder->private_->verify.needs_magic_hack) {
		FLAC__ASSERT(*bytes >= FLAC__STREAM_SYNC_LENGTH);
		*bytes = FLAC__STREAM_SYNC_LENGTH;
		memcpy(buffer, FLAC__STREAM_SYNC_STRING, *bytes);
		encoder->private_->verify.needs_magic_hack = false;
	}
	else {
		if(encoded_bytes == 0) {
			/*
			 * If we get here, a FIFO underflow has occurred,
			 * which means there is a bug somewhere.
			 */
			FLAC__ASSERT(0);
			return FLAC__STREAM_DECODER_READ_STATUS_ABORT;
		}
		else if(encoded_bytes < *bytes)
			*bytes = encoded_bytes;
		memcpy(buffer, encoder->private_->verify.output.data, *bytes);
		encoder->private_->verify.output.data += *bytes;
		encoder->private_->verify.output.bytes -= *bytes;
	}

	return FLAC__STREAM_DECODER_READ_STATUS_CONTINUE;
}

FLAC__StreamDecoderWriteStatus verify_write_callback_(const FLAC__StreamDecoder *decoder, const FLAC__Frame *frame, const FLAC__int32 * const buffer[], void *client_data)
{
	FLAC__StreamEncoder *encoder = (FLAC__StreamEncoder *)client_data;
	unsigned channel;
	const unsigned channels = frame->header.channels;
	const unsigned blocksize = frame->header.blocksize;
	const unsigned bytes_per_block = sizeof(FLAC__int32) * blocksize;

	(void)decoder;

	for(channel = 0; channel < channels; channel++) {
		if(0 != memcmp(buffer[channel], encoder->private_->verify.input_fifo.data[channel], bytes_per_block)) {
			unsigned i, sample = 0;
			FLAC__int32 expect = 0, got = 0;

			for(i = 0; i < blocksize; i++) {
				if(buffer[channel][i] != encoder->private_->verify.input_fifo.data[channel][i]) {
					sample = i;
					expect = (FLAC__int32)encoder->private_->verify.input_fifo.data[channel][i];
					got = (FLAC__int32)buffer[channel][i];
					break;
				}
			}
			FLAC__ASSERT(i < blocksize);
			FLAC__ASSERT(frame->header.number_type == FLAC__FRAME_NUMBER_TYPE_SAMPLE_NUMBER);
			encoder->private_->verify.error_stats.absolute_sample = frame->header.number.sample_number + sample;
			encoder->private_->verify.error_stats.frame_number = (unsigned)(frame->header.number.sample_number / blocksize);
			encoder->private_->verify.error_stats.channel = channel;
			encoder->private_->verify.error_stats.sample = sample;
			encoder->private_->verify.error_stats.expected = expect;
			encoder->private_->verify.error_stats.got = got;
			encoder->protected_->state = FLAC__STREAM_ENCODER_VERIFY_MISMATCH_IN_AUDIO_DATA;
			return FLAC__STREAM_DECODER_WRITE_STATUS_ABORT;
		}
	}
	/* dequeue the frame from the fifo */
	encoder->private_->verify.input_fifo.tail -= blocksize;
	FLAC__ASSERT(encoder->private_->verify.input_fifo.tail <= OVERREAD_);
	for(channel = 0; channel < channels; channel++)
		memmove(&encoder->private_->verify.input_fifo.data[channel][0], &encoder->private_->verify.input_fifo.data[channel][blocksize], encoder->private_->verify.input_fifo.tail * sizeof(encoder->private_->verify.input_fifo.data[0][0]));
	return FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE;
}

void verify_metadata_callback_(const FLAC__StreamDecoder *decoder, const FLAC__StreamMetadata *metadata, void *client_data)
{
	(void)decoder, (void)metadata, (void)client_data;
}

void verify_error_callback_(const FLAC__StreamDecoder *decoder, FLAC__StreamDecoderErrorStatus status, void *client_data)
{
	FLAC__StreamEncoder *encoder = (FLAC__StreamEncoder*)client_data;
	(void)decoder, (void)status;
	encoder->protected_->state = FLAC__STREAM_ENCODER_VERIFY_DECODER_ERROR;
}

FLAC__StreamEncoderReadStatus file_read_callback_enc(const FLAC__StreamEncoder *encoder, FLAC__byte buffer[], size_t *bytes, void *client_data)
{
	(void)client_data;

	*bytes = fread(buffer, 1, *bytes, encoder->private_->file);
	if (*bytes == 0) {
		if (feof(encoder->private_->file))
			return FLAC__STREAM_ENCODER_READ_STATUS_END_OF_STREAM;
		else if (ferror(encoder->private_->file))
			return FLAC__STREAM_ENCODER_READ_STATUS_ABORT;
	}
	return FLAC__STREAM_ENCODER_READ_STATUS_CONTINUE;
}

FLAC__StreamEncoderSeekStatus file_seek_callback_enc(const FLAC__StreamEncoder *encoder, FLAC__uint64 absolute_byte_offset, void *client_data)
{
	(void)client_data;

	if(fseeko(encoder->private_->file, (off_t)absolute_byte_offset, SEEK_SET) < 0)
		return FLAC__STREAM_ENCODER_SEEK_STATUS_ERROR;
	else
		return FLAC__STREAM_ENCODER_SEEK_STATUS_OK;
}

FLAC__StreamEncoderTellStatus file_tell_callback_enc(const FLAC__StreamEncoder *encoder, FLAC__uint64 *absolute_byte_offset, void *client_data)
{
	off_t offset;

	(void)client_data;

	offset = ftello(encoder->private_->file);

	if(offset < 0) {
		return FLAC__STREAM_ENCODER_TELL_STATUS_ERROR;
	}
	else {
		*absolute_byte_offset = (FLAC__uint64)offset;
		return FLAC__STREAM_ENCODER_TELL_STATUS_OK;
	}
}

#ifdef FLAC__VALGRIND_TESTING
static size_t local__fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream)
{
	size_t ret = fwrite(ptr, size, nmemb, stream);
	if(!ferror(stream))
		fflush(stream);
	return ret;
}
#else
#define local__fwrite fwrite
#endif

FLAC__StreamEncoderWriteStatus file_write_callback_(const FLAC__StreamEncoder *encoder, const FLAC__byte buffer[], size_t bytes, unsigned samples, unsigned current_frame, void *client_data)
{
	(void)client_data, (void)current_frame;

	if(local__fwrite(buffer, sizeof(FLAC__byte), bytes, encoder->private_->file) == bytes) {
		FLAC__bool call_it = 0 != encoder->private_->progress_callback && (
#if FLAC__HAS_OGG
			/* We would like to be able to use 'samples > 0' in the
			 * clause here but currently because of the nature of our
			 * Ogg writing implementation, 'samples' is always 0 (see
			 * ogg_encoder_aspect.c).  The downside is extra progress
			 * callbacks.
			 */
			encoder->private_->is_ogg? true :
#endif
			samples > 0
		);
		if(call_it) {
			/* NOTE: We have to add +bytes, +samples, and +1 to the stats
			 * because at this point in the callback chain, the stats
			 * have not been updated.  Only after we return and control
			 * gets back to write_frame_() are the stats updated
			 */
			encoder->private_->progress_callback(encoder, encoder->private_->bytes_written+bytes, encoder->private_->samples_written+samples, encoder->private_->frames_written+(samples?1:0), encoder->private_->total_frames_estimate, encoder->private_->client_data);
		}
		return FLAC__STREAM_ENCODER_WRITE_STATUS_OK;
	}
	else
		return FLAC__STREAM_ENCODER_WRITE_STATUS_FATAL_ERROR;
}

/*
 * This will forcibly set stdout to binary mode (for OSes that require it)
 */
FILE *get_binary_stdout_(void)
{
	/* if something breaks here it is probably due to the presence or
	 * absence of an underscore before the identifiers 'setmode',
	 * 'fileno', and/or 'O_BINARY'; check your system header files.
	 */
#if defined _MSC_VER || defined __MINGW32__
	_setmode(_fileno(stdout), _O_BINARY);
#elif defined __CYGWIN__
	/* almost certainly not needed for any modern Cygwin, but let's be safe... */
	setmode(_fileno(stdout), _O_BINARY);
#elif defined __EMX__
	setmode(fileno(stdout), O_BINARY);
#endif

	return stdout;
}

/*** End of inlined file: stream_encoder.c ***/


/*** Start of inlined file: stream_encoder_framing.c ***/
#if HAVE_CONFIG_H
#  include <config.h>
#endif

#include <stdio.h>
#include <string.h> /* for strlen() */

#ifdef max
#undef max
#endif
#define max(x,y) ((x)>(y)?(x):(y))

static FLAC__bool add_entropy_coding_method_(FLAC__BitWriter *bw, const FLAC__EntropyCodingMethod *method);
static FLAC__bool add_residual_partitioned_rice_(FLAC__BitWriter *bw, const FLAC__int32 residual[], const unsigned residual_samples, const unsigned predictor_order, const unsigned rice_parameters[], const unsigned raw_bits[], const unsigned partition_order, const FLAC__bool is_extended);

FLAC__bool FLAC__add_metadata_block(const FLAC__StreamMetadata *metadata, FLAC__BitWriter *bw)
{
	unsigned i, j;
	const unsigned vendor_string_length = (unsigned)strlen(FLAC__VENDOR_STRING);

	if(!FLAC__bitwriter_write_raw_uint32(bw, metadata->is_last, FLAC__STREAM_METADATA_IS_LAST_LEN))
		return false;

	if(!FLAC__bitwriter_write_raw_uint32(bw, metadata->type, FLAC__STREAM_METADATA_TYPE_LEN))
		return false;

	/*
	 * First, for VORBIS_COMMENTs, adjust the length to reflect our vendor string
	 */
	i = metadata->length;
	if(metadata->type == FLAC__METADATA_TYPE_VORBIS_COMMENT) {
		FLAC__ASSERT(metadata->data.vorbis_comment.vendor_string.length == 0 || 0 != metadata->data.vorbis_comment.vendor_string.entry);
		i -= metadata->data.vorbis_comment.vendor_string.length;
		i += vendor_string_length;
	}
	FLAC__ASSERT(i < (1u << FLAC__STREAM_METADATA_LENGTH_LEN));
	if(!FLAC__bitwriter_write_raw_uint32(bw, i, FLAC__STREAM_METADATA_LENGTH_LEN))
		return false;

	switch(metadata->type) {
		case FLAC__METADATA_TYPE_STREAMINFO:
			FLAC__ASSERT(metadata->data.stream_info.min_blocksize < (1u << FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN));
			if(!FLAC__bitwriter_write_raw_uint32(bw, metadata->data.stream_info.min_blocksize, FLAC__STREAM_METADATA_STREAMINFO_MIN_BLOCK_SIZE_LEN))
				return false;
			FLAC__ASSERT(metadata->data.stream_info.max_blocksize < (1u << FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN));
			if(!FLAC__bitwriter_write_raw_uint32(bw, metadata->data.stream_info.max_blocksize, FLAC__STREAM_METADATA_STREAMINFO_MAX_BLOCK_SIZE_LEN))
				return false;
			FLAC__ASSERT(metadata->data.stream_info.min_framesize < (1u << FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN));
			if(!FLAC__bitwriter_write_raw_uint32(bw, metadata->data.stream_info.min_framesize, FLAC__STREAM_METADATA_STREAMINFO_MIN_FRAME_SIZE_LEN))
				return false;
			FLAC__ASSERT(metadata->data.stream_info.max_framesize < (1u << FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN));
			if(!FLAC__bitwriter_write_raw_uint32(bw, metadata->data.stream_info.max_framesize, FLAC__STREAM_METADATA_STREAMINFO_MAX_FRAME_SIZE_LEN))
				return false;
			FLAC__ASSERT(FLAC__format_sample_rate_is_valid(metadata->data.stream_info.sample_rate));
			if(!FLAC__bitwriter_write_raw_uint32(bw, metadata->data.stream_info.sample_rate, FLAC__STREAM_METADATA_STREAMINFO_SAMPLE_RATE_LEN))
				return false;
			FLAC__ASSERT(metadata->data.stream_info.channels > 0);
			FLAC__ASSERT(metadata->data.stream_info.channels <= (1u << FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN));
			if(!FLAC__bitwriter_write_raw_uint32(bw, metadata->data.stream_info.channels-1, FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN))
				return false;
			FLAC__ASSERT(metadata->data.stream_info.bits_per_sample > 0);
			FLAC__ASSERT(metadata->data.stream_info.bits_per_sample <= (1u << FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN));
			if(!FLAC__bitwriter_write_raw_uint32(bw, metadata->data.stream_info.bits_per_sample-1, FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN))
				return false;
			if(!FLAC__bitwriter_write_raw_uint64(bw, metadata->data.stream_info.total_samples, FLAC__STREAM_METADATA_STREAMINFO_TOTAL_SAMPLES_LEN))
				return false;
			if(!FLAC__bitwriter_write_byte_block(bw, metadata->data.stream_info.md5sum, 16))
				return false;
			break;
		case FLAC__METADATA_TYPE_PADDING:
			if(!FLAC__bitwriter_write_zeroes(bw, metadata->length * 8))
				return false;
			break;
		case FLAC__METADATA_TYPE_APPLICATION:
			if(!FLAC__bitwriter_write_byte_block(bw, metadata->data.application.id, FLAC__STREAM_METADATA_APPLICATION_ID_LEN / 8))
				return false;
			if(!FLAC__bitwriter_write_byte_block(bw, metadata->data.application.data, metadata->length - (FLAC__STREAM_METADATA_APPLICATION_ID_LEN / 8)))
				return false;
			break;
		case FLAC__METADATA_TYPE_SEEKTABLE:
			for(i = 0; i < metadata->data.seek_table.num_points; i++) {
				if(!FLAC__bitwriter_write_raw_uint64(bw, metadata->data.seek_table.points[i].sample_number, FLAC__STREAM_METADATA_SEEKPOINT_SAMPLE_NUMBER_LEN))
					return false;
				if(!FLAC__bitwriter_write_raw_uint64(bw, metadata->data.seek_table.points[i].stream_offset, FLAC__STREAM_METADATA_SEEKPOINT_STREAM_OFFSET_LEN))
					return false;
				if(!FLAC__bitwriter_write_raw_uint32(bw, metadata->data.seek_table.points[i].frame_samples, FLAC__STREAM_METADATA_SEEKPOINT_FRAME_SAMPLES_LEN))
					return false;
			}
			break;
		case FLAC__METADATA_TYPE_VORBIS_COMMENT:
			if(!FLAC__bitwriter_write_raw_uint32_little_endian(bw, vendor_string_length))
				return false;
			if(!FLAC__bitwriter_write_byte_block(bw, (const FLAC__byte*)FLAC__VENDOR_STRING, vendor_string_length))
				return false;
			if(!FLAC__bitwriter_write_raw_uint32_little_endian(bw, metadata->data.vorbis_comment.num_comments))
				return false;
			for(i = 0; i < metadata->data.vorbis_comment.num_comments; i++) {
				if(!FLAC__bitwriter_write_raw_uint32_little_endian(bw, metadata->data.vorbis_comment.comments[i].length))
					return false;
				if(!FLAC__bitwriter_write_byte_block(bw, metadata->data.vorbis_comment.comments[i].entry, metadata->data.vorbis_comment.comments[i].length))
					return false;
			}
			break;
		case FLAC__METADATA_TYPE_CUESHEET:
			FLAC__ASSERT(FLAC__STREAM_METADATA_CUESHEET_MEDIA_CATALOG_NUMBER_LEN % 8 == 0);
			if(!FLAC__bitwriter_write_byte_block(bw, (const FLAC__byte*)metadata->data.cue_sheet.media_catalog_number, FLAC__STREAM_METADATA_CUESHEET_MEDIA_CATALOG_NUMBER_LEN/8))
				return false;
			if(!FLAC__bitwriter_write_raw_uint64(bw, metadata->data.cue_sheet.lead_in, FLAC__STREAM_METADATA_CUESHEET_LEAD_IN_LEN))
				return false;
			if(!FLAC__bitwriter_write_raw_uint32(bw, metadata->data.cue_sheet.is_cd? 1 : 0, FLAC__STREAM_METADATA_CUESHEET_IS_CD_LEN))
				return false;
			if(!FLAC__bitwriter_write_zeroes(bw, FLAC__STREAM_METADATA_CUESHEET_RESERVED_LEN))
				return false;
			if(!FLAC__bitwriter_write_raw_uint32(bw, metadata->data.cue_sheet.num_tracks, FLAC__STREAM_METADATA_CUESHEET_NUM_TRACKS_LEN))
				return false;
			for(i = 0; i < metadata->data.cue_sheet.num_tracks; i++) {
				const FLAC__StreamMetadata_CueSheet_Track *track = metadata->data.cue_sheet.tracks + i;

				if(!FLAC__bitwriter_write_raw_uint64(bw, track->offset, FLAC__STREAM_METADATA_CUESHEET_TRACK_OFFSET_LEN))
					return false;
				if(!FLAC__bitwriter_write_raw_uint32(bw, track->number, FLAC__STREAM_METADATA_CUESHEET_TRACK_NUMBER_LEN))
					return false;
				FLAC__ASSERT(FLAC__STREAM_METADATA_CUESHEET_TRACK_ISRC_LEN % 8 == 0);
				if(!FLAC__bitwriter_write_byte_block(bw, (const FLAC__byte*)track->isrc, FLAC__STREAM_METADATA_CUESHEET_TRACK_ISRC_LEN/8))
					return false;
				if(!FLAC__bitwriter_write_raw_uint32(bw, track->type, FLAC__STREAM_METADATA_CUESHEET_TRACK_TYPE_LEN))
					return false;
				if(!FLAC__bitwriter_write_raw_uint32(bw, track->pre_emphasis, FLAC__STREAM_METADATA_CUESHEET_TRACK_PRE_EMPHASIS_LEN))
					return false;
				if(!FLAC__bitwriter_write_zeroes(bw, FLAC__STREAM_METADATA_CUESHEET_TRACK_RESERVED_LEN))
					return false;
				if(!FLAC__bitwriter_write_raw_uint32(bw, track->num_indices, FLAC__STREAM_METADATA_CUESHEET_TRACK_NUM_INDICES_LEN))
					return false;
				for(j = 0; j < track->num_indices; j++) {
					const FLAC__StreamMetadata_CueSheet_Index *index = track->indices + j;

					if(!FLAC__bitwriter_write_raw_uint64(bw, index->offset, FLAC__STREAM_METADATA_CUESHEET_INDEX_OFFSET_LEN))
						return false;
					if(!FLAC__bitwriter_write_raw_uint32(bw, index->number, FLAC__STREAM_METADATA_CUESHEET_INDEX_NUMBER_LEN))
						return false;
					if(!FLAC__bitwriter_write_zeroes(bw, FLAC__STREAM_METADATA_CUESHEET_INDEX_RESERVED_LEN))
						return false;
				}
			}
			break;
		case FLAC__METADATA_TYPE_PICTURE:
			{
				size_t len;
				if(!FLAC__bitwriter_write_raw_uint32(bw, metadata->data.picture.type, FLAC__STREAM_METADATA_PICTURE_TYPE_LEN))
					return false;
				len = strlen(metadata->data.picture.mime_type);
				if(!FLAC__bitwriter_write_raw_uint32(bw, len, FLAC__STREAM_METADATA_PICTURE_MIME_TYPE_LENGTH_LEN))
					return false;
				if(!FLAC__bitwriter_write_byte_block(bw, (const FLAC__byte*)metadata->data.picture.mime_type, len))
					return false;
				len = strlen((const char *)metadata->data.picture.description);
				if(!FLAC__bitwriter_write_raw_uint32(bw, len, FLAC__STREAM_METADATA_PICTURE_DESCRIPTION_LENGTH_LEN))
					return false;
				if(!FLAC__bitwriter_write_byte_block(bw, metadata->data.picture.description, len))
					return false;
				if(!FLAC__bitwriter_write_raw_uint32(bw, metadata->data.picture.width, FLAC__STREAM_METADATA_PICTURE_WIDTH_LEN))
					return false;
				if(!FLAC__bitwriter_write_raw_uint32(bw, metadata->data.picture.height, FLAC__STREAM_METADATA_PICTURE_HEIGHT_LEN))
					return false;
				if(!FLAC__bitwriter_write_raw_uint32(bw, metadata->data.picture.depth, FLAC__STREAM_METADATA_PICTURE_DEPTH_LEN))
					return false;
				if(!FLAC__bitwriter_write_raw_uint32(bw, metadata->data.picture.colors, FLAC__STREAM_METADATA_PICTURE_COLORS_LEN))
					return false;
				if(!FLAC__bitwriter_write_raw_uint32(bw, metadata->data.picture.data_length, FLAC__STREAM_METADATA_PICTURE_DATA_LENGTH_LEN))
					return false;
				if(!FLAC__bitwriter_write_byte_block(bw, metadata->data.picture.data, metadata->data.picture.data_length))
					return false;
			}
			break;
		default:
			if(!FLAC__bitwriter_write_byte_block(bw, metadata->data.unknown.data, metadata->length))
				return false;
			break;
	}

	FLAC__ASSERT(FLAC__bitwriter_is_byte_aligned(bw));
	return true;
}

FLAC__bool FLAC__frame_add_header(const FLAC__FrameHeader *header, FLAC__BitWriter *bw)
{
	unsigned u, blocksize_hint, sample_rate_hint;
	FLAC__byte crc;

	FLAC__ASSERT(FLAC__bitwriter_is_byte_aligned(bw));

	if(!FLAC__bitwriter_write_raw_uint32(bw, FLAC__FRAME_HEADER_SYNC, FLAC__FRAME_HEADER_SYNC_LEN))
		return false;

	if(!FLAC__bitwriter_write_raw_uint32(bw, 0, FLAC__FRAME_HEADER_RESERVED_LEN))
		return false;

	if(!FLAC__bitwriter_write_raw_uint32(bw, (header->number_type == FLAC__FRAME_NUMBER_TYPE_FRAME_NUMBER)? 0 : 1, FLAC__FRAME_HEADER_BLOCKING_STRATEGY_LEN))
		return false;

	FLAC__ASSERT(header->blocksize > 0 && header->blocksize <= FLAC__MAX_BLOCK_SIZE);
	/* when this assertion holds true, any legal blocksize can be expressed in the frame header */
	FLAC__ASSERT(FLAC__MAX_BLOCK_SIZE <= 65535u);
	blocksize_hint = 0;
	switch(header->blocksize) {
		case   192: u = 1; break;
		case   576: u = 2; break;
		case  1152: u = 3; break;
		case  2304: u = 4; break;
		case  4608: u = 5; break;
		case   256: u = 8; break;
		case   512: u = 9; break;
		case  1024: u = 10; break;
		case  2048: u = 11; break;
		case  4096: u = 12; break;
		case  8192: u = 13; break;
		case 16384: u = 14; break;
		case 32768: u = 15; break;
		default:
			if(header->blocksize <= 0x100)
				blocksize_hint = u = 6;
			else
				blocksize_hint = u = 7;
			break;
	}
	if(!FLAC__bitwriter_write_raw_uint32(bw, u, FLAC__FRAME_HEADER_BLOCK_SIZE_LEN))
		return false;

	FLAC__ASSERT(FLAC__format_sample_rate_is_valid(header->sample_rate));
	sample_rate_hint = 0;
	switch(header->sample_rate) {
		case  88200: u = 1; break;
		case 176400: u = 2; break;
		case 192000: u = 3; break;
		case   8000: u = 4; break;
		case  16000: u = 5; break;
		case  22050: u = 6; break;
		case  24000: u = 7; break;
		case  32000: u = 8; break;
		case  44100: u = 9; break;
		case  48000: u = 10; break;
		case  96000: u = 11; break;
		default:
			if(header->sample_rate <= 255000 && header->sample_rate % 1000 == 0)
				sample_rate_hint = u = 12;
			else if(header->sample_rate % 10 == 0)
				sample_rate_hint = u = 14;
			else if(header->sample_rate <= 0xffff)
				sample_rate_hint = u = 13;
			else
				u = 0;
			break;
	}
	if(!FLAC__bitwriter_write_raw_uint32(bw, u, FLAC__FRAME_HEADER_SAMPLE_RATE_LEN))
		return false;

	FLAC__ASSERT(header->channels > 0 && header->channels <= (1u << FLAC__STREAM_METADATA_STREAMINFO_CHANNELS_LEN) && header->channels <= FLAC__MAX_CHANNELS);
	switch(header->channel_assignment) {
		case FLAC__CHANNEL_ASSIGNMENT_INDEPENDENT:
			u = header->channels - 1;
			break;
		case FLAC__CHANNEL_ASSIGNMENT_LEFT_SIDE:
			FLAC__ASSERT(header->channels == 2);
			u = 8;
			break;
		case FLAC__CHANNEL_ASSIGNMENT_RIGHT_SIDE:
			FLAC__ASSERT(header->channels == 2);
			u = 9;
			break;
		case FLAC__CHANNEL_ASSIGNMENT_MID_SIDE:
			FLAC__ASSERT(header->channels == 2);
			u = 10;
			break;
		default:
			FLAC__ASSERT(0);
	}
	if(!FLAC__bitwriter_write_raw_uint32(bw, u, FLAC__FRAME_HEADER_CHANNEL_ASSIGNMENT_LEN))
		return false;

	FLAC__ASSERT(header->bits_per_sample > 0 && header->bits_per_sample <= (1u << FLAC__STREAM_METADATA_STREAMINFO_BITS_PER_SAMPLE_LEN));
	switch(header->bits_per_sample) {
		case 8 : u = 1; break;
		case 12: u = 2; break;
		case 16: u = 4; break;
		case 20: u = 5; break;
		case 24: u = 6; break;
		default: u = 0; break;
	}
	if(!FLAC__bitwriter_write_raw_uint32(bw, u, FLAC__FRAME_HEADER_BITS_PER_SAMPLE_LEN))
		return false;

	if(!FLAC__bitwriter_write_raw_uint32(bw, 0, FLAC__FRAME_HEADER_ZERO_PAD_LEN))
		return false;

	if(header->number_type == FLAC__FRAME_NUMBER_TYPE_FRAME_NUMBER) {
		if(!FLAC__bitwriter_write_utf8_uint32(bw, header->number.frame_number))
			return false;
	}
	else {
		if(!FLAC__bitwriter_write_utf8_uint64(bw, header->number.sample_number))
			return false;
	}

	if(blocksize_hint)
		if(!FLAC__bitwriter_write_raw_uint32(bw, header->blocksize-1, (blocksize_hint==6)? 8:16))
			return false;

	switch(sample_rate_hint) {
		case 12:
			if(!FLAC__bitwriter_write_raw_uint32(bw, header->sample_rate / 1000, 8))
				return false;
			break;
		case 13:
			if(!FLAC__bitwriter_write_raw_uint32(bw, header->sample_rate, 16))
				return false;
			break;
		case 14:
			if(!FLAC__bitwriter_write_raw_uint32(bw, header->sample_rate / 10, 16))
				return false;
			break;
	}

	/* write the CRC */
	if(!FLAC__bitwriter_get_write_crc8(bw, &crc))
		return false;
	if(!FLAC__bitwriter_write_raw_uint32(bw, crc, FLAC__FRAME_HEADER_CRC_LEN))
		return false;

	return true;
}

FLAC__bool FLAC__subframe_add_constant(const FLAC__Subframe_Constant *subframe, unsigned subframe_bps, unsigned wasted_bits, FLAC__BitWriter *bw)
{
	FLAC__bool ok;

	ok =
		FLAC__bitwriter_write_raw_uint32(bw, FLAC__SUBFRAME_TYPE_CONSTANT_BYTE_ALIGNED_MASK | (wasted_bits? 1:0), FLAC__SUBFRAME_ZERO_PAD_LEN + FLAC__SUBFRAME_TYPE_LEN + FLAC__SUBFRAME_WASTED_BITS_FLAG_LEN) &&
		(wasted_bits? FLAC__bitwriter_write_unary_unsigned(bw, wasted_bits-1) : true) &&
		FLAC__bitwriter_write_raw_int32(bw, subframe->value, subframe_bps)
	;

	return ok;
}

FLAC__bool FLAC__subframe_add_fixed(const FLAC__Subframe_Fixed *subframe, unsigned residual_samples, unsigned subframe_bps, unsigned wasted_bits, FLAC__BitWriter *bw)
{
	unsigned i;

	if(!FLAC__bitwriter_write_raw_uint32(bw, FLAC__SUBFRAME_TYPE_FIXED_BYTE_ALIGNED_MASK | (subframe->order<<1) | (wasted_bits? 1:0), FLAC__SUBFRAME_ZERO_PAD_LEN + FLAC__SUBFRAME_TYPE_LEN + FLAC__SUBFRAME_WASTED_BITS_FLAG_LEN))
		return false;
	if(wasted_bits)
		if(!FLAC__bitwriter_write_unary_unsigned(bw, wasted_bits-1))
			return false;

	for(i = 0; i < subframe->order; i++)
		if(!FLAC__bitwriter_write_raw_int32(bw, subframe->warmup[i], subframe_bps))
			return false;

	if(!add_entropy_coding_method_(bw, &subframe->entropy_coding_method))
		return false;
	switch(subframe->entropy_coding_method.type) {
		case FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE:
		case FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2:
			if(!add_residual_partitioned_rice_(
				bw,
				subframe->residual,
				residual_samples,
				subframe->order,
				subframe->entropy_coding_method.data.partitioned_rice.contents->parameters,
				subframe->entropy_coding_method.data.partitioned_rice.contents->raw_bits,
				subframe->entropy_coding_method.data.partitioned_rice.order,
				/*is_extended=*/subframe->entropy_coding_method.type == FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2
			))
				return false;
			break;
		default:
			FLAC__ASSERT(0);
	}

	return true;
}

FLAC__bool FLAC__subframe_add_lpc(const FLAC__Subframe_LPC *subframe, unsigned residual_samples, unsigned subframe_bps, unsigned wasted_bits, FLAC__BitWriter *bw)
{
	unsigned i;

	if(!FLAC__bitwriter_write_raw_uint32(bw, FLAC__SUBFRAME_TYPE_LPC_BYTE_ALIGNED_MASK | ((subframe->order-1)<<1) | (wasted_bits? 1:0), FLAC__SUBFRAME_ZERO_PAD_LEN + FLAC__SUBFRAME_TYPE_LEN + FLAC__SUBFRAME_WASTED_BITS_FLAG_LEN))
		return false;
	if(wasted_bits)
		if(!FLAC__bitwriter_write_unary_unsigned(bw, wasted_bits-1))
			return false;

	for(i = 0; i < subframe->order; i++)
		if(!FLAC__bitwriter_write_raw_int32(bw, subframe->warmup[i], subframe_bps))
			return false;

	if(!FLAC__bitwriter_write_raw_uint32(bw, subframe->qlp_coeff_precision-1, FLAC__SUBFRAME_LPC_QLP_COEFF_PRECISION_LEN))
		return false;
	if(!FLAC__bitwriter_write_raw_int32(bw, subframe->quantization_level, FLAC__SUBFRAME_LPC_QLP_SHIFT_LEN))
		return false;
	for(i = 0; i < subframe->order; i++)
		if(!FLAC__bitwriter_write_raw_int32(bw, subframe->qlp_coeff[i], subframe->qlp_coeff_precision))
			return false;

	if(!add_entropy_coding_method_(bw, &subframe->entropy_coding_method))
		return false;
	switch(subframe->entropy_coding_method.type) {
		case FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE:
		case FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2:
			if(!add_residual_partitioned_rice_(
				bw,
				subframe->residual,
				residual_samples,
				subframe->order,
				subframe->entropy_coding_method.data.partitioned_rice.contents->parameters,
				subframe->entropy_coding_method.data.partitioned_rice.contents->raw_bits,
				subframe->entropy_coding_method.data.partitioned_rice.order,
				/*is_extended=*/subframe->entropy_coding_method.type == FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2
			))
				return false;
			break;
		default:
			FLAC__ASSERT(0);
	}

	return true;
}

FLAC__bool FLAC__subframe_add_verbatim(const FLAC__Subframe_Verbatim *subframe, unsigned samples, unsigned subframe_bps, unsigned wasted_bits, FLAC__BitWriter *bw)
{
	unsigned i;
	const FLAC__int32 *signal = subframe->data;

	if(!FLAC__bitwriter_write_raw_uint32(bw, FLAC__SUBFRAME_TYPE_VERBATIM_BYTE_ALIGNED_MASK | (wasted_bits? 1:0), FLAC__SUBFRAME_ZERO_PAD_LEN + FLAC__SUBFRAME_TYPE_LEN + FLAC__SUBFRAME_WASTED_BITS_FLAG_LEN))
		return false;
	if(wasted_bits)
		if(!FLAC__bitwriter_write_unary_unsigned(bw, wasted_bits-1))
			return false;

	for(i = 0; i < samples; i++)
		if(!FLAC__bitwriter_write_raw_int32(bw, signal[i], subframe_bps))
			return false;

	return true;
}

FLAC__bool add_entropy_coding_method_(FLAC__BitWriter *bw, const FLAC__EntropyCodingMethod *method)
{
	if(!FLAC__bitwriter_write_raw_uint32(bw, method->type, FLAC__ENTROPY_CODING_METHOD_TYPE_LEN))
		return false;
	switch(method->type) {
		case FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE:
		case FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2:
			if(!FLAC__bitwriter_write_raw_uint32(bw, method->data.partitioned_rice.order, FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_ORDER_LEN))
				return false;
			break;
		default:
			FLAC__ASSERT(0);
	}
	return true;
}

FLAC__bool add_residual_partitioned_rice_(FLAC__BitWriter *bw, const FLAC__int32 residual[], const unsigned residual_samples, const unsigned predictor_order, const unsigned rice_parameters[], const unsigned raw_bits[], const unsigned partition_order, const FLAC__bool is_extended)
{
	const unsigned plen = is_extended? FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2_PARAMETER_LEN : FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_PARAMETER_LEN;
	const unsigned pesc = is_extended? FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE2_ESCAPE_PARAMETER : FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_ESCAPE_PARAMETER;

	if(partition_order == 0) {
		unsigned i;

		if(raw_bits[0] == 0) {
			if(!FLAC__bitwriter_write_raw_uint32(bw, rice_parameters[0], plen))
				return false;
			if(!FLAC__bitwriter_write_rice_signed_block(bw, residual, residual_samples, rice_parameters[0]))
				return false;
		}
		else {
			FLAC__ASSERT(rice_parameters[0] == 0);
			if(!FLAC__bitwriter_write_raw_uint32(bw, pesc, plen))
				return false;
			if(!FLAC__bitwriter_write_raw_uint32(bw, raw_bits[0], FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_RAW_LEN))
				return false;
			for(i = 0; i < residual_samples; i++) {
				if(!FLAC__bitwriter_write_raw_int32(bw, residual[i], raw_bits[0]))
					return false;
			}
		}
		return true;
	}
	else {
		unsigned i, j, k = 0, k_last = 0;
		unsigned partition_samples;
		const unsigned default_partition_samples = (residual_samples+predictor_order) >> partition_order;
		for(i = 0; i < (1u<<partition_order); i++) {
			partition_samples = default_partition_samples;
			if(i == 0)
				partition_samples -= predictor_order;
			k += partition_samples;
			if(raw_bits[i] == 0) {
				if(!FLAC__bitwriter_write_raw_uint32(bw, rice_parameters[i], plen))
					return false;
				if(!FLAC__bitwriter_write_rice_signed_block(bw, residual+k_last, k-k_last, rice_parameters[i]))
					return false;
			}
			else {
				if(!FLAC__bitwriter_write_raw_uint32(bw, pesc, plen))
					return false;
				if(!FLAC__bitwriter_write_raw_uint32(bw, raw_bits[i], FLAC__ENTROPY_CODING_METHOD_PARTITIONED_RICE_RAW_LEN))
					return false;
				for(j = k_last; j < k; j++) {
					if(!FLAC__bitwriter_write_raw_int32(bw, residual[j], raw_bits[i]))
						return false;
				}
			}
			k_last = k;
		}
		return true;
	}
}

/*** End of inlined file: stream_encoder_framing.c ***/


/*** Start of inlined file: window_flac.c ***/
#if HAVE_CONFIG_H
#  include <config.h>
#endif

#include <math.h>

#ifndef FLAC__INTEGER_ONLY_LIBRARY

#ifndef M_PI
/* math.h in VC++ doesn't seem to have this (how Microsoft is that?) */
#define M_PI 3.14159265358979323846
#endif

void FLAC__window_bartlett(FLAC__real *window, const FLAC__int32 L)
{
	const FLAC__int32 N = L - 1;
	FLAC__int32 n;

	if (L & 1) {
		for (n = 0; n <= N/2; n++)
			window[n] = 2.0f * n / (float)N;
		for (; n <= N; n++)
			window[n] = 2.0f - 2.0f * n / (float)N;
	}
	else {
		for (n = 0; n <= L/2-1; n++)
			window[n] = 2.0f * n / (float)N;
		for (; n <= N; n++)
			window[n] = 2.0f - 2.0f * (N-n) / (float)N;
	}
}

void FLAC__window_bartlett_hann(FLAC__real *window, const FLAC__int32 L)
{
	const FLAC__int32 N = L - 1;
	FLAC__int32 n;

	for (n = 0; n < L; n++)
		window[n] = (FLAC__real)(0.62f - 0.48f * fabs((float)n/(float)N+0.5f) + 0.38f * cos(2.0f * M_PI * ((float)n/(float)N+0.5f)));
}

void FLAC__window_blackman(FLAC__real *window, const FLAC__int32 L)
{
	const FLAC__int32 N = L - 1;
	FLAC__int32 n;

	for (n = 0; n < L; n++)
		window[n] = (FLAC__real)(0.42f - 0.5f * cos(2.0f * M_PI * n / N) + 0.08f * cos(4.0f * M_PI * n / N));
}

/* 4-term -92dB side-lobe */
void FLAC__window_blackman_harris_4term_92db_sidelobe(FLAC__real *window, const FLAC__int32 L)
{
	const FLAC__int32 N = L - 1;
	FLAC__int32 n;

	for (n = 0; n <= N; n++)
		window[n] = (FLAC__real)(0.35875f - 0.48829f * cos(2.0f * M_PI * n / N) + 0.14128f * cos(4.0f * M_PI * n / N) - 0.01168f * cos(6.0f * M_PI * n / N));
}

void FLAC__window_connes(FLAC__real *window, const FLAC__int32 L)
{
	const FLAC__int32 N = L - 1;
	const double N2 = (double)N / 2.;
	FLAC__int32 n;

	for (n = 0; n <= N; n++) {
		double k = ((double)n - N2) / N2;
		k = 1.0f - k * k;
		window[n] = (FLAC__real)(k * k);
	}
}

void FLAC__window_flattop(FLAC__real *window, const FLAC__int32 L)
{
	const FLAC__int32 N = L - 1;
	FLAC__int32 n;

	for (n = 0; n < L; n++)
		window[n] = (FLAC__real)(1.0f - 1.93f * cos(2.0f * M_PI * n / N) + 1.29f * cos(4.0f * M_PI * n / N) - 0.388f * cos(6.0f * M_PI * n / N) + 0.0322f * cos(8.0f * M_PI * n / N));
}

void FLAC__window_gauss(FLAC__real *window, const FLAC__int32 L, const FLAC__real stddev)
{
	const FLAC__int32 N = L - 1;
	const double N2 = (double)N / 2.;
	FLAC__int32 n;

	for (n = 0; n <= N; n++) {
		const double k = ((double)n - N2) / (stddev * N2);
		window[n] = (FLAC__real)exp(-0.5f * k * k);
	}
}

void FLAC__window_hamming(FLAC__real *window, const FLAC__int32 L)
{
	const FLAC__int32 N = L - 1;
	FLAC__int32 n;

	for (n = 0; n < L; n++)
		window[n] = (FLAC__real)(0.54f - 0.46f * cos(2.0f * M_PI * n / N));
}

void FLAC__window_hann(FLAC__real *window, const FLAC__int32 L)
{
	const FLAC__int32 N = L - 1;
	FLAC__int32 n;

	for (n = 0; n < L; n++)
		window[n] = (FLAC__real)(0.5f - 0.5f * cos(2.0f * M_PI * n / N));
}

void FLAC__window_kaiser_bessel(FLAC__real *window, const FLAC__int32 L)
{
	const FLAC__int32 N = L - 1;
	FLAC__int32 n;

	for (n = 0; n < L; n++)
		window[n] = (FLAC__real)(0.402f - 0.498f * cos(2.0f * M_PI * n / N) + 0.098f * cos(4.0f * M_PI * n / N) - 0.001f * cos(6.0f * M_PI * n / N));
}

void FLAC__window_nuttall(FLAC__real *window, const FLAC__int32 L)
{
	const FLAC__int32 N = L - 1;
	FLAC__int32 n;

	for (n = 0; n < L; n++)
		window[n] = (FLAC__real)(0.3635819f - 0.4891775f*cos(2.0f*M_PI*n/N) + 0.1365995f*cos(4.0f*M_PI*n/N) - 0.0106411f*cos(6.0f*M_PI*n/N));
}

void FLAC__window_rectangle(FLAC__real *window, const FLAC__int32 L)
{
	FLAC__int32 n;

	for (n = 0; n < L; n++)
		window[n] = 1.0f;
}

void FLAC__window_triangle(FLAC__real *window, const FLAC__int32 L)
{
	FLAC__int32 n;

	if (L & 1) {
		for (n = 1; n <= L+1/2; n++)
			window[n-1] = 2.0f * n / ((float)L + 1.0f);
		for (; n <= L; n++)
			window[n-1] = - (float)(2 * (L - n + 1)) / ((float)L + 1.0f);
	}
	else {
		for (n = 1; n <= L/2; n++)
			window[n-1] = 2.0f * n / (float)L;
		for (; n <= L; n++)
			window[n-1] = ((float)(2 * (L - n)) + 1.0f) / (float)L;
	}
}

void FLAC__window_tukey(FLAC__real *window, const FLAC__int32 L, const FLAC__real p)
{
	if (p <= 0.0)
		FLAC__window_rectangle(window, L);
	else if (p >= 1.0)
		FLAC__window_hann(window, L);
	else {
		const FLAC__int32 Np = (FLAC__int32)(p / 2.0f * L) - 1;
		FLAC__int32 n;
		/* start with rectangle... */
		FLAC__window_rectangle(window, L);
		/* ...replace ends with hann */
		if (Np > 0) {
			for (n = 0; n <= Np; n++) {
				window[n] = (FLAC__real)(0.5f - 0.5f * cos(M_PI * n / Np));
				window[L-Np-1+n] = (FLAC__real)(0.5f - 0.5f * cos(M_PI * (n+Np) / Np));
			}
		}
	}
}

void FLAC__window_welch(FLAC__real *window, const FLAC__int32 L)
{
	const FLAC__int32 N = L - 1;
	const double N2 = (double)N / 2.;
	FLAC__int32 n;

	for (n = 0; n <= N; n++) {
		const double k = ((double)n - N2) / N2;
		window[n] = (FLAC__real)(1.0f - k * k);
	}
}

#endif /* !defined FLAC__INTEGER_ONLY_LIBRARY */

/*** End of inlined file: window_flac.c ***/

 #undef VERSION
#else
 #include <FLAC/all.h>
#endif
}

#undef max
#undef min

static const char* const flacFormatName = "FLAC file";
static const char* const flacExtensions[] = { ".flac", 0 };

class FlacReader  : public AudioFormatReader
{
public:

	FlacReader (InputStream* const in)
		: AudioFormatReader (in, TRANS (flacFormatName)),
		  reservoir (2, 0),
		  reservoirStart (0),
		  samplesInReservoir (0),
		  scanningForLength (false)
	{
		using namespace FlacNamespace;
		lengthInSamples = 0;

		decoder = FLAC__stream_decoder_new();

		ok = FLAC__stream_decoder_init_stream (decoder,
											   readCallback_, seekCallback_, tellCallback_, lengthCallback_,
											   eofCallback_, writeCallback_, metadataCallback_, errorCallback_,
											   this) == FLAC__STREAM_DECODER_INIT_STATUS_OK;

		if (ok)
		{
			FLAC__stream_decoder_process_until_end_of_metadata (decoder);

			if (lengthInSamples == 0 && sampleRate > 0)
			{
				// the length hasn't been stored in the metadata, so we'll need to
				// work it out the length the hard way, by scanning the whole file..
				scanningForLength = true;
				FLAC__stream_decoder_process_until_end_of_stream (decoder);
				scanningForLength = false;
				const int64 tempLength = lengthInSamples;

				FLAC__stream_decoder_reset (decoder);
				FLAC__stream_decoder_process_until_end_of_metadata (decoder);
				lengthInSamples = tempLength;
			}
		}
	}

	~FlacReader()
	{
		FlacNamespace::FLAC__stream_decoder_delete (decoder);
	}

	void useMetadata (const FlacNamespace::FLAC__StreamMetadata_StreamInfo& info)
	{
		sampleRate = info.sample_rate;
		bitsPerSample = info.bits_per_sample;
		lengthInSamples = (unsigned int) info.total_samples;
		numChannels = info.channels;

		reservoir.setSize ((int) numChannels, 2 * info.max_blocksize, false, false, true);
	}

	// returns the number of samples read
	bool readSamples (int** destSamples, int numDestChannels, int startOffsetInDestBuffer,
					  int64 startSampleInFile, int numSamples)
	{
		using namespace FlacNamespace;

		if (! ok)
			return false;

		while (numSamples > 0)
		{
			if (startSampleInFile >= reservoirStart
				 && startSampleInFile < reservoirStart + samplesInReservoir)
			{
				const int num = (int) jmin ((int64) numSamples,
											reservoirStart + samplesInReservoir - startSampleInFile);

				jassert (num > 0);

				for (int i = jmin (numDestChannels, reservoir.getNumChannels()); --i >= 0;)
					if (destSamples[i] != nullptr)
						memcpy (destSamples[i] + startOffsetInDestBuffer,
								reservoir.getSampleData (i, (int) (startSampleInFile - reservoirStart)),
								sizeof (int) * num);

				startOffsetInDestBuffer += num;
				startSampleInFile += num;
				numSamples -= num;
			}
			else
			{
				if (startSampleInFile >= (int) lengthInSamples)
				{
					samplesInReservoir = 0;
				}
				else if (startSampleInFile < reservoirStart
						  || startSampleInFile > reservoirStart + jmax (samplesInReservoir, 511))
				{
					// had some problems with flac crashing if the read pos is aligned more
					// accurately than this. Probably fixed in newer versions of the library, though.
					reservoirStart = (int) (startSampleInFile & ~511);
					samplesInReservoir = 0;
					FLAC__stream_decoder_seek_absolute (decoder, (FLAC__uint64) reservoirStart);
				}
				else
				{
					reservoirStart += samplesInReservoir;
					samplesInReservoir = 0;
					FLAC__stream_decoder_process_single (decoder);
				}

				if (samplesInReservoir == 0)
					break;
			}
		}

		if (numSamples > 0)
		{
			for (int i = numDestChannels; --i >= 0;)
				if (destSamples[i] != nullptr)
					zeromem (destSamples[i] + startOffsetInDestBuffer, sizeof (int) * numSamples);
		}

		return true;
	}

	void useSamples (const FlacNamespace::FLAC__int32* const buffer[], int numSamples)
	{
		if (scanningForLength)
		{
			lengthInSamples += numSamples;
		}
		else
		{
			if (numSamples > reservoir.getNumSamples())
				reservoir.setSize ((int) numChannels, numSamples, false, false, true);

			const unsigned int bitsToShift = 32 - bitsPerSample;

			for (int i = 0; i < (int) numChannels; ++i)
			{
				const FlacNamespace::FLAC__int32* src = buffer[i];

				int n = i;
				while (src == 0 && n > 0)
					src = buffer [--n];

				if (src != nullptr)
				{
					int* const dest = reinterpret_cast<int*> (reservoir.getSampleData(i));

					for (int j = 0; j < numSamples; ++j)
						dest[j] = src[j] << bitsToShift;
				}
			}

			samplesInReservoir = numSamples;
		}
	}

	static FlacNamespace::FLAC__StreamDecoderReadStatus readCallback_ (const FlacNamespace::FLAC__StreamDecoder*, FlacNamespace::FLAC__byte buffer[], size_t* bytes, void* client_data)
	{
		using namespace FlacNamespace;
		*bytes = (size_t) static_cast <const FlacReader*> (client_data)->input->read (buffer, (int) *bytes);
		return FLAC__STREAM_DECODER_READ_STATUS_CONTINUE;
	}

	static FlacNamespace::FLAC__StreamDecoderSeekStatus seekCallback_ (const FlacNamespace::FLAC__StreamDecoder*, FlacNamespace::FLAC__uint64 absolute_byte_offset, void* client_data)
	{
		using namespace FlacNamespace;
		static_cast <const FlacReader*> (client_data)->input->setPosition ((int) absolute_byte_offset);
		return FLAC__STREAM_DECODER_SEEK_STATUS_OK;
	}

	static FlacNamespace::FLAC__StreamDecoderTellStatus tellCallback_ (const FlacNamespace::FLAC__StreamDecoder*, FlacNamespace::FLAC__uint64* absolute_byte_offset, void* client_data)
	{
		using namespace FlacNamespace;
		*absolute_byte_offset = static_cast <const FlacReader*> (client_data)->input->getPosition();
		return FLAC__STREAM_DECODER_TELL_STATUS_OK;
	}

	static FlacNamespace::FLAC__StreamDecoderLengthStatus lengthCallback_ (const FlacNamespace::FLAC__StreamDecoder*, FlacNamespace::FLAC__uint64* stream_length, void* client_data)
	{
		using namespace FlacNamespace;
		*stream_length = static_cast <const FlacReader*> (client_data)->input->getTotalLength();
		return FLAC__STREAM_DECODER_LENGTH_STATUS_OK;
	}

	static FlacNamespace::FLAC__bool eofCallback_ (const FlacNamespace::FLAC__StreamDecoder*, void* client_data)
	{
		return static_cast <const FlacReader*> (client_data)->input->isExhausted();
	}

	static FlacNamespace::FLAC__StreamDecoderWriteStatus writeCallback_ (const FlacNamespace::FLAC__StreamDecoder*,
																		 const FlacNamespace::FLAC__Frame* frame,
																		 const FlacNamespace::FLAC__int32* const buffer[],
																		 void* client_data)
	{
		using namespace FlacNamespace;
		static_cast <FlacReader*> (client_data)->useSamples (buffer, frame->header.blocksize);
		return FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE;
	}

	static void metadataCallback_ (const FlacNamespace::FLAC__StreamDecoder*,
								   const FlacNamespace::FLAC__StreamMetadata* metadata,
								   void* client_data)
	{
		static_cast <FlacReader*> (client_data)->useMetadata (metadata->data.stream_info);
	}

	static void errorCallback_ (const FlacNamespace::FLAC__StreamDecoder*, FlacNamespace::FLAC__StreamDecoderErrorStatus, void*)
	{
	}

private:
	FlacNamespace::FLAC__StreamDecoder* decoder;
	AudioSampleBuffer reservoir;
	int reservoirStart, samplesInReservoir;
	bool ok, scanningForLength;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (FlacReader);
};

class FlacWriter  : public AudioFormatWriter
{
public:

	FlacWriter (OutputStream* const out, double sampleRate_,
				int numChannels_, int bitsPerSample_, int qualityOptionIndex)
		: AudioFormatWriter (out, TRANS (flacFormatName),
							 sampleRate_, numChannels_, bitsPerSample_)
	{
		using namespace FlacNamespace;
		encoder = FLAC__stream_encoder_new();

		if (qualityOptionIndex > 0)
			FLAC__stream_encoder_set_compression_level (encoder, jmin (8, qualityOptionIndex));

		FLAC__stream_encoder_set_do_mid_side_stereo (encoder, numChannels == 2);
		FLAC__stream_encoder_set_loose_mid_side_stereo (encoder, numChannels == 2);
		FLAC__stream_encoder_set_channels (encoder, numChannels);
		FLAC__stream_encoder_set_bits_per_sample (encoder, jmin ((unsigned int) 24, bitsPerSample));
		FLAC__stream_encoder_set_sample_rate (encoder, (unsigned int) sampleRate);
		FLAC__stream_encoder_set_blocksize (encoder, 0);
		FLAC__stream_encoder_set_do_escape_coding (encoder, true);

		ok = FLAC__stream_encoder_init_stream (encoder,
											   encodeWriteCallback, encodeSeekCallback,
											   encodeTellCallback, encodeMetadataCallback,
											   this) == FLAC__STREAM_ENCODER_INIT_STATUS_OK;
	}

	~FlacWriter()
	{
		if (ok)
		{
			FlacNamespace::FLAC__stream_encoder_finish (encoder);
			output->flush();
		}
		else
		{
			output = nullptr; // to stop the base class deleting this, as it needs to be returned
							  // to the caller of createWriter()
		}

		FlacNamespace::FLAC__stream_encoder_delete (encoder);
	}

	bool write (const int** samplesToWrite, int numSamples)
	{
		using namespace FlacNamespace;
		if (! ok)
			return false;

		HeapBlock<int*> channels;
		HeapBlock<int> temp;
		const int bitsToShift = 32 - bitsPerSample;

		if (bitsToShift > 0)
		{
			temp.malloc (numSamples * numChannels);
			channels.calloc (numChannels + 1);

			for (unsigned int i = 0; i < numChannels; ++i)
			{
				if (samplesToWrite[i] == nullptr)
					break;

				int* const destData = temp.getData() + i * numSamples;
				channels[i] = destData;

				for (int j = 0; j < numSamples; ++j)
					destData[j] = (samplesToWrite[i][j] >> bitsToShift);
			}

			samplesToWrite = const_cast <const int**> (channels.getData());
		}

		return FLAC__stream_encoder_process (encoder, (const FLAC__int32**) samplesToWrite, numSamples) != 0;
	}

	bool writeData (const void* const data, const int size) const
	{
		return output->write (data, size);
	}

	static void packUint32 (FlacNamespace::FLAC__uint32 val, FlacNamespace::FLAC__byte* b, const int bytes)
	{
		b += bytes;

		for (int i = 0; i < bytes; ++i)
		{
			*(--b) = (FlacNamespace::FLAC__byte) (val & 0xff);
			val >>= 8;
		}
	}

	void writeMetaData (const FlacNamespace::FLAC__StreamMetadata* metadata)
	{
		using namespace FlacNamespace;
		const FLAC__StreamMetadata_StreamInfo& info = metadata->data.stream_info;

		unsigned char buffer [FLAC__STREAM_METADATA_STREAMINFO_LENGTH];
		const unsigned int channelsMinus1 = info.channels - 1;
		const unsigned int bitsMinus1 = info.bits_per_sample - 1;

		packUint32 (info.min_blocksize, buffer, 2);
		packUint32 (info.max_blocksize, buffer + 2, 2);
		packUint32 (info.min_framesize, buffer + 4, 3);
		packUint32 (info.max_framesize, buffer + 7, 3);
		buffer[10] = (uint8) ((info.sample_rate >> 12) & 0xff);
		buffer[11] = (uint8) ((info.sample_rate >> 4) & 0xff);
		buffer[12] = (uint8) (((info.sample_rate & 0x0f) << 4) | (channelsMinus1 << 1) | (bitsMinus1 >> 4));
		buffer[13] = (FLAC__byte) (((bitsMinus1 & 0x0f) << 4) | (unsigned int) ((info.total_samples >> 32) & 0x0f));
		packUint32 ((FLAC__uint32) info.total_samples, buffer + 14, 4);
		memcpy (buffer + 18, info.md5sum, 16);

		const bool seekOk = output->setPosition (4);
		(void) seekOk;

		// if this fails, you've given it an output stream that can't seek! It needs
		// to be able to seek back to write the header
		jassert (seekOk);

		output->writeIntBigEndian (FLAC__STREAM_METADATA_STREAMINFO_LENGTH);
		output->write (buffer, FLAC__STREAM_METADATA_STREAMINFO_LENGTH);
	}

	static FlacNamespace::FLAC__StreamEncoderWriteStatus encodeWriteCallback (const FlacNamespace::FLAC__StreamEncoder*,
																			  const FlacNamespace::FLAC__byte buffer[],
																			  size_t bytes,
																			  unsigned int /*samples*/,
																			  unsigned int /*current_frame*/,
																			  void* client_data)
	{
		using namespace FlacNamespace;
		return static_cast <FlacWriter*> (client_data)->writeData (buffer, (int) bytes)
				? FLAC__STREAM_ENCODER_WRITE_STATUS_OK
				: FLAC__STREAM_ENCODER_WRITE_STATUS_FATAL_ERROR;
	}

	static FlacNamespace::FLAC__StreamEncoderSeekStatus encodeSeekCallback (const FlacNamespace::FLAC__StreamEncoder*, FlacNamespace::FLAC__uint64, void*)
	{
		using namespace FlacNamespace;
		return FLAC__STREAM_ENCODER_SEEK_STATUS_UNSUPPORTED;
	}

	static FlacNamespace::FLAC__StreamEncoderTellStatus encodeTellCallback (const FlacNamespace::FLAC__StreamEncoder*, FlacNamespace::FLAC__uint64* absolute_byte_offset, void* client_data)
	{
		using namespace FlacNamespace;
		if (client_data == nullptr)
			return FLAC__STREAM_ENCODER_TELL_STATUS_UNSUPPORTED;

		*absolute_byte_offset = (FLAC__uint64) static_cast <FlacWriter*> (client_data)->output->getPosition();
		return FLAC__STREAM_ENCODER_TELL_STATUS_OK;
	}

	static void encodeMetadataCallback (const FlacNamespace::FLAC__StreamEncoder*, const FlacNamespace::FLAC__StreamMetadata* metadata, void* client_data)
	{
		static_cast <FlacWriter*> (client_data)->writeMetaData (metadata);
	}

	bool ok;

private:
	FlacNamespace::FLAC__StreamEncoder* encoder;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (FlacWriter);
};

FlacAudioFormat::FlacAudioFormat()
	: AudioFormat (TRANS (flacFormatName), StringArray (flacExtensions))
{
}

FlacAudioFormat::~FlacAudioFormat()
{
}

Array<int> FlacAudioFormat::getPossibleSampleRates()
{
	const int rates[] = { 22050, 32000, 44100, 48000, 88200, 96000, 176400, 192000, 352800, 384000, 0 };
	return Array <int> (rates);
}

Array<int> FlacAudioFormat::getPossibleBitDepths()
{
	const int depths[] = { 16, 24, 0 };
	return Array <int> (depths);
}

bool FlacAudioFormat::canDoStereo()     { return true; }
bool FlacAudioFormat::canDoMono()       { return true; }
bool FlacAudioFormat::isCompressed()    { return true; }

AudioFormatReader* FlacAudioFormat::createReaderFor (InputStream* in, const bool deleteStreamIfOpeningFails)
{
	ScopedPointer<FlacReader> r (new FlacReader (in));

	if (r->sampleRate > 0)
		return r.release();

	if (! deleteStreamIfOpeningFails)
		r->input = nullptr;

	return nullptr;
}

AudioFormatWriter* FlacAudioFormat::createWriterFor (OutputStream* out,
													 double sampleRate,
													 unsigned int numberOfChannels,
													 int bitsPerSample,
													 const StringPairArray& /*metadataValues*/,
													 int qualityOptionIndex)
{
	if (getPossibleBitDepths().contains (bitsPerSample))
	{
		ScopedPointer<FlacWriter> w (new FlacWriter (out, sampleRate, numberOfChannels, bitsPerSample, qualityOptionIndex));

		if (w->ok)
			return w.release();
	}

	return nullptr;
}

StringArray FlacAudioFormat::getQualityOptions()
{
	const char* options[] = { "0 (Fastest)", "1", "2", "3", "4", "5 (Default)","6", "7", "8 (Highest quality)", 0 };
	return StringArray (options);
}

#endif

/*** End of inlined file: juce_FlacAudioFormat.cpp ***/


/*** Start of inlined file: juce_MP3AudioFormat.cpp ***/
/*
	IMPORTANT DISCLAIMER: By choosing to enable the JUCE_USE_MP3AUDIOFORMAT flag and
	to compile this MP3 code into your software, you do so AT YOUR OWN RISK! By doing so,
	you are agreeing that Raw Material Software is in no way responsible for any patent,
	copyright, or other legal issues that you may suffer as a result.

	The code in juce_MP3AudioFormat.cpp is NOT guaranteed to be free from infringements of 3rd-party
	intellectual property. If you wish to use it, please seek your own independent advice about the
	legality of doing so. If you are not willing to accept full responsibility for the consequences
	of using this code, then do not enable the JUCE_USE_MP3AUDIOFORMAT setting.
*/
#if JUCE_USE_MP3AUDIOFORMAT

namespace MP3Decoder
{

struct AllocationTable  { int16 bits, d; };

const struct AllocationTable allocTable0[] =
{
	{4, 0}, {5, 3}, {3, -3}, {4, -7}, {5, -15}, {6, -31}, {7, -63}, {8, -127}, {9, -255}, {10, -511}, {11, -1023}, {12, -2047}, {13, -4095}, {14, -8191}, {15, -16383}, {16, -32767},
	{4, 0}, {5, 3}, {3, -3}, {4, -7}, {5, -15}, {6, -31}, {7, -63}, {8, -127}, {9, -255}, {10, -511}, {11, -1023}, {12, -2047}, {13, -4095}, {14, -8191}, {15, -16383}, {16, -32767},
	{4, 0}, {5, 3}, {3, -3}, {4, -7}, {5, -15}, {6, -31}, {7, -63}, {8, -127}, {9, -255}, {10, -511}, {11, -1023}, {12, -2047}, {13, -4095}, {14, -8191}, {15, -16383}, {16, -32767},
	{4, 0}, {5, 3}, {7, 5}, {3, -3}, {10, 9}, {4, -7}, {5, -15}, {6, -31}, {7, -63}, {8, -127}, {9, -255}, {10, -511}, {11, -1023}, {12, -2047}, {13, -4095}, {16, -32767},
	{4, 0}, {5, 3}, {7, 5}, {3, -3}, {10, 9}, {4, -7}, {5, -15}, {6, -31}, {7, -63}, {8, -127}, {9, -255}, {10, -511}, {11, -1023}, {12, -2047}, {13, -4095}, {16, -32767},
	{4, 0}, {5, 3}, {7, 5}, {3, -3}, {10, 9}, {4, -7}, {5, -15}, {6, -31}, {7, -63}, {8, -127}, {9, -255}, {10, -511}, {11, -1023}, {12, -2047}, {13, -4095}, {16, -32767},
	{4, 0}, {5, 3}, {7, 5}, {3, -3}, {10, 9}, {4, -7}, {5, -15}, {6, -31}, {7, -63}, {8, -127}, {9, -255}, {10, -511}, {11, -1023}, {12, -2047}, {13, -4095}, {16, -32767},
	{4, 0}, {5, 3}, {7, 5}, {3, -3}, {10, 9}, {4, -7}, {5, -15}, {6, -31}, {7, -63}, {8, -127}, {9, -255}, {10, -511}, {11, -1023}, {12, -2047}, {13, -4095}, {16, -32767},
	{4, 0}, {5, 3}, {7, 5}, {3, -3}, {10, 9}, {4, -7}, {5, -15}, {6, -31}, {7, -63}, {8, -127}, {9, -255}, {10, -511}, {11, -1023}, {12, -2047}, {13, -4095}, {16, -32767},
	{4, 0}, {5, 3}, {7, 5}, {3, -3}, {10, 9}, {4, -7}, {5, -15}, {6, -31}, {7, -63}, {8, -127}, {9, -255}, {10, -511}, {11, -1023}, {12, -2047}, {13, -4095}, {16, -32767},
	{4, 0}, {5, 3}, {7, 5}, {3, -3}, {10, 9}, {4, -7}, {5, -15}, {6, -31}, {7, -63}, {8, -127}, {9, -255}, {10, -511}, {11, -1023}, {12, -2047}, {13, -4095}, {16, -32767},
	{3, 0}, {5, 3}, {7, 5}, {3, -3}, {10, 9}, {4, -7}, {5, -15}, {16, -32767},  {3, 0}, {5, 3}, {7, 5}, {3, -3}, {10, 9}, {4, -7}, {5, -15}, {16, -32767},
	{3, 0}, {5, 3}, {7, 5}, {3, -3}, {10, 9}, {4, -7}, {5, -15}, {16, -32767},  {3, 0}, {5, 3}, {7, 5}, {3, -3}, {10, 9}, {4, -7}, {5, -15}, {16, -32767},
	{3, 0}, {5, 3}, {7, 5}, {3, -3}, {10, 9}, {4, -7}, {5, -15}, {16, -32767},  {3, 0}, {5, 3}, {7, 5}, {3, -3}, {10, 9}, {4, -7}, {5, -15}, {16, -32767},
	{3, 0}, {5, 3}, {7, 5}, {3, -3}, {10, 9}, {4, -7}, {5, -15}, {16, -32767},  {3, 0}, {5, 3}, {7, 5}, {3, -3}, {10, 9}, {4, -7}, {5, -15}, {16, -32767},
	{3, 0}, {5, 3}, {7, 5}, {3, -3}, {10, 9}, {4, -7}, {5, -15}, {16, -32767},  {3, 0}, {5, 3}, {7, 5}, {3, -3}, {10, 9}, {4, -7}, {5, -15}, {16, -32767},
	{3, 0}, {5, 3}, {7, 5}, {3, -3}, {10, 9}, {4, -7}, {5, -15}, {16, -32767},  {3, 0}, {5, 3}, {7, 5}, {3, -3}, {10, 9}, {4, -7}, {5, -15}, {16, -32767},
	{2, 0}, {5, 3}, {7, 5}, {16, -32767}, {2, 0}, {5, 3}, {7, 5}, {16, -32767}, {2, 0}, {5, 3}, {7, 5}, {16, -32767}, {2, 0}, {5, 3}, {7, 5}, {16, -32767}
};

const struct AllocationTable allocTable1[] =
{
	{4, 0}, {5, 3}, {3, -3}, {4, -7}, {5, -15}, {6, -31}, {7, -63}, {8, -127}, {9, -255}, {10, -511}, {11, -1023}, {12, -2047}, {13, -4095}, {14, -8191}, {15, -16383}, {16, -32767},
	{4, 0}, {5, 3}, {3, -3}, {4, -7}, {5, -15}, {6, -31}, {7, -63}, {8, -127}, {9, -255}, {10, -511}, {11, -1023}, {12, -2047}, {13, -4095}, {14, -8191}, {15, -16383}, {16, -32767},
	{4, 0}, {5, 3}, {3, -3}, {4, -7}, {5, -15}, {6, -31}, {7, -63}, {8, -127}, {9, -255}, {10, -511}, {11, -1023}, {12, -2047}, {13, -4095}, {14, -8191}, {15, -16383}, {16, -32767},
	{4, 0}, {5, 3}, {7, 5}, {3, -3}, {10, 9}, {4, -7}, {5, -15}, {6, -31}, {7, -63}, {8, -127}, {9, -255}, {10, -511}, {11, -1023}, {12, -2047}, {13, -4095}, {16, -32767},
	{4, 0}, {5, 3}, {7, 5}, {3, -3}, {10, 9}, {4, -7}, {5, -15}, {6, -31}, {7, -63}, {8, -127}, {9, -255}, {10, -511}, {11, -1023}, {12, -2047}, {13, -4095}, {16, -32767},
	{4, 0}, {5, 3}, {7, 5}, {3, -3}, {10, 9}, {4, -7}, {5, -15}, {6, -31}, {7, -63}, {8, -127}, {9, -255}, {10, -511}, {11, -1023}, {12, -2047}, {13, -4095}, {16, -32767},
	{4, 0}, {5, 3}, {7, 5}, {3, -3}, {10, 9}, {4, -7}, {5, -15}, {6, -31}, {7, -63}, {8, -127}, {9, -255}, {10, -511}, {11, -1023}, {12, -2047}, {13, -4095}, {16, -32767},
	{4, 0}, {5, 3}, {7, 5}, {3, -3}, {10, 9}, {4, -7}, {5, -15}, {6, -31}, {7, -63}, {8, -127}, {9, -255}, {10, -511}, {11, -1023}, {12, -2047}, {13, -4095}, {16, -32767},
	{4, 0}, {5, 3}, {7, 5}, {3, -3}, {10, 9}, {4, -7}, {5, -15}, {6, -31}, {7, -63}, {8, -127}, {9, -255}, {10, -511}, {11, -1023}, {12, -2047}, {13, -4095}, {16, -32767},
	{4, 0}, {5, 3}, {7, 5}, {3, -3}, {10, 9}, {4, -7}, {5, -15}, {6, -31}, {7, -63}, {8, -127}, {9, -255}, {10, -511}, {11, -1023}, {12, -2047}, {13, -4095}, {16, -32767},
	{4, 0}, {5, 3}, {7, 5}, {3, -3}, {10, 9}, {4, -7}, {5, -15}, {6, -31}, {7, -63}, {8, -127}, {9, -255}, {10, -511}, {11, -1023}, {12, -2047}, {13, -4095}, {16, -32767},
	{3, 0}, {5, 3}, {7, 5}, {3, -3}, {10, 9}, {4, -7}, {5, -15}, {16, -32767}, {3, 0}, {5, 3}, {7, 5}, {3, -3}, {10, 9}, {4, -7}, {5, -15}, {16, -32767},
	{3, 0}, {5, 3}, {7, 5}, {3, -3}, {10, 9}, {4, -7}, {5, -15}, {16, -32767}, {3, 0}, {5, 3}, {7, 5}, {3, -3}, {10, 9}, {4, -7}, {5, -15}, {16, -32767},
	{3, 0}, {5, 3}, {7, 5}, {3, -3}, {10, 9}, {4, -7}, {5, -15}, {16, -32767}, {3, 0}, {5, 3}, {7, 5}, {3, -3}, {10, 9}, {4, -7}, {5, -15}, {16, -32767},
	{3, 0}, {5, 3}, {7, 5}, {3, -3}, {10, 9}, {4, -7}, {5, -15}, {16, -32767}, {3, 0}, {5, 3}, {7, 5}, {3, -3}, {10, 9}, {4, -7}, {5, -15}, {16, -32767},
	{3, 0}, {5, 3}, {7, 5}, {3, -3}, {10, 9}, {4, -7}, {5, -15}, {16, -32767}, {3, 0}, {5, 3}, {7, 5}, {3, -3}, {10, 9}, {4, -7}, {5, -15}, {16, -32767},
	{3, 0}, {5, 3}, {7, 5}, {3, -3}, {10, 9}, {4, -7}, {5, -15}, {16, -32767}, {3, 0}, {5, 3}, {7, 5}, {3, -3}, {10, 9}, {4, -7}, {5, -15}, {16, -32767},
	{2, 0}, {5, 3}, {7, 5}, {16, -32767}, {2, 0}, {5, 3}, {7, 5}, {16, -32767}, {2, 0}, {5, 3}, {7, 5}, {16, -32767}, {2, 0}, {5, 3}, {7, 5}, {16, -32767},
	{2, 0}, {5, 3}, {7, 5}, {16, -32767}, {2, 0}, {5, 3}, {7, 5}, {16, -32767}, {2, 0}, {5, 3}, {7, 5}, {16, -32767}
};

const struct AllocationTable allocTable2[] =
{
	{4, 0}, {5, 3}, {7, 5}, {10, 9}, {4, -7}, {5, -15}, {6, -31}, {7, -63}, {8, -127}, {9, -255}, {10, -511}, {11, -1023}, {12, -2047}, {13, -4095}, {14, -8191}, {15, -16383},
	{4, 0}, {5, 3}, {7, 5}, {10, 9}, {4, -7}, {5, -15}, {6, -31}, {7, -63}, {8, -127}, {9, -255}, {10, -511}, {11, -1023}, {12, -2047}, {13, -4095}, {14, -8191}, {15, -16383},
	{3, 0}, {5, 3}, {7, 5}, {10, 9}, {4, -7}, {5, -15}, {6, -31}, {7, -63}, {3, 0}, {5, 3}, {7, 5}, {10, 9}, {4, -7}, {5, -15}, {6, -31}, {7, -63},
	{3, 0}, {5, 3}, {7, 5}, {10, 9}, {4, -7}, {5, -15}, {6, -31}, {7, -63}, {3, 0}, {5, 3}, {7, 5}, {10, 9}, {4, -7}, {5, -15}, {6, -31}, {7, -63},
	{3, 0}, {5, 3}, {7, 5}, {10, 9}, {4, -7}, {5, -15}, {6, -31}, {7, -63}, {3, 0}, {5, 3}, {7, 5}, {10, 9}, {4, -7}, {5, -15}, {6, -31}, {7, -63}
};

const struct AllocationTable allocTable3[] =
{
	{4, 0}, {5, 3}, {7, 5}, {10, 9}, {4, -7}, {5, -15}, {6, -31}, {7, -63}, {8, -127}, {9, -255}, {10, -511}, {11, -1023}, {12, -2047}, {13, -4095}, {14, -8191}, {15, -16383},
	{4, 0}, {5, 3}, {7, 5}, {10, 9}, {4, -7}, {5, -15}, {6, -31}, {7, -63}, {8, -127}, {9, -255}, {10, -511}, {11, -1023}, {12, -2047}, {13, -4095}, {14, -8191}, {15, -16383},
	{3, 0}, {5, 3}, {7, 5}, {10, 9}, {4, -7}, {5, -15}, {6, -31}, {7, -63}, {3, 0}, {5, 3}, {7, 5}, {10, 9}, {4, -7}, {5, -15}, {6, -31}, {7, -63},
	{3, 0}, {5, 3}, {7, 5}, {10, 9}, {4, -7}, {5, -15}, {6, -31}, {7, -63}, {3, 0}, {5, 3}, {7, 5}, {10, 9}, {4, -7}, {5, -15}, {6, -31}, {7, -63},
	{3, 0}, {5, 3}, {7, 5}, {10, 9}, {4, -7}, {5, -15}, {6, -31}, {7, -63}, {3, 0}, {5, 3}, {7, 5}, {10, 9}, {4, -7}, {5, -15}, {6, -31}, {7, -63},
	{3, 0}, {5, 3}, {7, 5}, {10, 9}, {4, -7}, {5, -15}, {6, -31}, {7, -63}, {3, 0}, {5, 3}, {7, 5}, {10, 9}, {4, -7}, {5, -15}, {6, -31}, {7, -63},
	{3, 0}, {5, 3}, {7, 5}, {10, 9}, {4, -7}, {5, -15}, {6, -31}, {7, -63}, {3, 0}, {5, 3}, {7, 5}, {10, 9}, {4, -7}, {5, -15}, {6, -31}, {7, -63}
};

const struct AllocationTable allocTable4[] =
{
	{4, 0}, {5, 3}, {7, 5}, {3, -3}, {10, 9}, {4, -7}, {5, -15}, {6, -31}, {7, -63}, {8, -127}, {9, -255}, {10, -511}, {11, -1023}, {12, -2047}, {13, -4095}, {14, -8191},
	{4, 0}, {5, 3}, {7, 5}, {3, -3}, {10, 9}, {4, -7}, {5, -15}, {6, -31}, {7, -63}, {8, -127}, {9, -255}, {10, -511}, {11, -1023}, {12, -2047}, {13, -4095}, {14, -8191},
	{4, 0}, {5, 3}, {7, 5}, {3, -3}, {10, 9}, {4, -7}, {5, -15}, {6, -31}, {7, -63}, {8, -127}, {9, -255}, {10, -511}, {11, -1023}, {12, -2047}, {13, -4095}, {14, -8191},
	{4, 0}, {5, 3}, {7, 5}, {3, -3}, {10, 9}, {4, -7}, {5, -15}, {6, -31}, {7, -63}, {8, -127}, {9, -255}, {10, -511}, {11, -1023}, {12, -2047}, {13, -4095}, {14, -8191},
	{3, 0}, {5, 3}, {7, 5}, {10, 9}, {4, -7}, {5, -15}, {6, -31}, {7, -63}, {3, 0}, {5, 3}, {7, 5}, {10, 9}, {4, -7}, {5, -15}, {6, -31}, {7, -63},
	{3, 0}, {5, 3}, {7, 5}, {10, 9}, {4, -7}, {5, -15}, {6, -31}, {7, -63}, {3, 0}, {5, 3}, {7, 5}, {10, 9}, {4, -7}, {5, -15}, {6, -31}, {7, -63},
	{3, 0}, {5, 3}, {7, 5}, {10, 9}, {4, -7}, {5, -15}, {6, -31}, {7, -63}, {3, 0}, {5, 3}, {7, 5}, {10, 9}, {4, -7}, {5, -15}, {6, -31}, {7, -63},
	{3, 0}, {5, 3}, {7, 5}, {10, 9}, {4, -7}, {5, -15}, {6, -31}, {7, -63}, {2, 0}, {5, 3}, {7, 5}, {10, 9}, {2, 0}, {5, 3}, {7, 5}, {10, 9},
	{2, 0}, {5, 3}, {7, 5}, {10, 9}, {2, 0}, {5, 3}, {7, 5}, {10, 9}, {2, 0}, {5, 3}, {7, 5}, {10, 9}, {2, 0}, {5, 3}, {7, 5}, {10, 9},
	{2, 0}, {5, 3}, {7, 5}, {10, 9}, {2, 0}, {5, 3}, {7, 5}, {10, 9}, {2, 0}, {5, 3}, {7, 5}, {10, 9}, {2, 0}, {5, 3}, {7, 5}, {10, 9},
	{2, 0}, {5, 3}, {7, 5}, {10, 9}, {2, 0}, {5, 3}, {7, 5}, {10, 9}, {2, 0}, {5, 3}, {7, 5}, {10, 9}, {2, 0}, {5, 3}, {7, 5}, {10, 9},
	{2, 0}, {5, 3}, {7, 5}, {10, 9}, {2, 0}, {5, 3}, {7, 5}, {10, 9}, {2, 0}, {5, 3}, {7, 5}, {10, 9}, {2, 0}, {5, 3}, {7, 5}, {10, 9},
	{2, 0}, {5, 3}, {7, 5}, {10, 9}
};

struct BandInfoStruct
{
	int16 longIndex[23];
	int16 longDiff[22];
	int16 shortIndex[14];
	int16 shortDiff[13];
};

const BandInfoStruct bandInfo[9] =
{
  { {0, 4, 8, 12, 16, 20, 24, 30, 36, 44, 52, 62, 74, 90, 110, 134, 162, 196, 238, 288, 342, 418, 576},
	{4, 4, 4, 4, 4, 4, 6, 6, 8, 8, 10, 12, 16, 20, 24, 28, 34, 42, 50, 54, 76, 158},
	{0, 4 * 3, 8 * 3, 12 * 3, 16 * 3, 22 * 3, 30 * 3, 40 * 3, 52 * 3, 66 * 3, 84 * 3, 106 * 3, 136 * 3, 192 * 3},
	{4, 4, 4, 4, 6, 8, 10, 12, 14, 18, 22, 30, 56} },

  { {0, 4, 8, 12, 16, 20, 24, 30, 36, 42, 50, 60, 72, 88, 106, 128, 156, 190, 230, 276, 330, 384, 576},
	{4, 4, 4, 4, 4, 4, 6, 6, 6, 8, 10, 12, 16, 18, 22, 28, 34, 40, 46, 54, 54, 192},
	{0, 4 * 3, 8 * 3, 12 * 3, 16 * 3, 22 * 3, 28 * 3, 38 * 3, 50 * 3, 64 * 3, 80 * 3, 100 * 3, 126 * 3, 192 * 3},
	{4, 4, 4, 4, 6, 6, 10, 12, 14, 16, 20, 26, 66} },

  { {0, 4, 8, 12, 16, 20, 24, 30, 36, 44, 54, 66, 82, 102, 126, 156, 194, 240, 296, 364, 448, 550, 576},
	{4, 4, 4, 4, 4, 4, 6, 6, 8, 10, 12, 16, 20, 24, 30, 38, 46, 56, 68, 84, 102, 26},
	{0, 4 * 3, 8 * 3, 12 * 3, 16 * 3, 22 * 3, 30 * 3, 42 * 3, 58 * 3, 78 * 3, 104 * 3, 138 * 3, 180 * 3, 192 * 3},
	{4, 4, 4, 4, 6, 8, 12, 16, 20, 26, 34, 42, 12} },

  { {0, 6, 12, 18, 24, 30, 36, 44, 54, 66, 80, 96, 116, 140, 168, 200, 238, 284, 336, 396, 464, 522, 576},
	{6, 6, 6, 6, 6, 6, 8, 10, 12, 14, 16, 20, 24, 28, 32, 38, 46, 52, 60, 68, 58, 54 },
	{0, 4 * 3, 8 * 3, 12 * 3, 18 * 3, 24 * 3, 32 * 3, 42 * 3, 56 * 3, 74 * 3, 100 * 3, 132 * 3, 174 * 3, 192 * 3},
	{4, 4, 4, 6, 6, 8, 10, 14, 18, 26, 32, 42, 18 } },

  { {0, 6, 12, 18, 24, 30, 36, 44, 54, 66, 80, 96, 114, 136, 162, 194, 232, 278, 332, 394, 464, 540, 576},
	{6, 6, 6, 6, 6, 6, 8, 10, 12, 14, 16, 18, 22, 26, 32, 38, 46, 54, 62, 70, 76, 36 },
	{0, 4 * 3, 8 * 3, 12 * 3, 18 * 3, 26 * 3, 36 * 3, 48 * 3, 62 * 3, 80 * 3, 104 * 3, 136 * 3, 180 * 3, 192 * 3},
	{4, 4, 4, 6, 8, 10, 12, 14, 18, 24, 32, 44, 12 } },

  { {0, 6, 12, 18, 24, 30, 36, 44, 54, 66, 80, 96, 116, 140, 168, 200, 238, 284, 336, 396, 464, 522, 576},
	{6, 6, 6, 6, 6, 6, 8, 10, 12, 14, 16, 20, 24, 28, 32, 38, 46, 52, 60, 68, 58, 54 },
	{0, 4 * 3, 8 * 3, 12 * 3, 18 * 3, 26 * 3, 36 * 3, 48 * 3, 62 * 3, 80 * 3, 104 * 3, 134 * 3, 174 * 3, 192 * 3},
	{4, 4, 4, 6, 8, 10, 12, 14, 18, 24, 30, 40, 18 } },

  { {0, 6, 12, 18, 24, 30, 36, 44, 54, 66, 80, 96, 116, 140, 168, 200, 238, 284, 336, 396, 464, 522, 576},
	{6, 6, 6, 6, 6, 6, 8, 10, 12, 14, 16, 20, 24, 28, 32, 38, 46, 52, 60, 68, 58, 54},
	{0, 12, 24, 36, 54, 78, 108, 144, 186, 240, 312, 402, 522, 576},
	{4, 4, 4, 6, 8, 10, 12, 14, 18, 24, 30, 40, 18} },

  { {0, 6, 12, 18, 24, 30, 36, 44, 54, 66, 80, 96, 116, 140, 168, 200, 238, 284, 336, 396, 464, 522, 576},
	{6, 6, 6, 6, 6, 6, 8, 10, 12, 14, 16, 20, 24, 28, 32, 38, 46, 52, 60, 68, 58, 54},
	{0, 12, 24, 36, 54, 78, 108, 144, 186, 240, 312, 402, 522, 576},
	{4, 4, 4, 6, 8, 10, 12, 14, 18, 24, 30, 40, 18} },

  { {0, 12, 24, 36, 48, 60, 72, 88, 108, 132, 160, 192, 232, 280, 336, 400, 476, 566, 568, 570, 572, 574, 576},
	{12, 12, 12, 12, 12, 12, 16, 20, 24, 28, 32, 40, 48, 56, 64, 76, 90, 2, 2, 2, 2, 2},
	{0, 24, 48, 72, 108, 156, 216, 288, 372, 480, 486, 492, 498, 576},
	{8, 8, 8, 12, 16, 20, 24, 28, 36, 2, 2, 2, 26} }
};

const double decodeWindow[] =
{
	0.000000000, -0.000015259, -0.000015259, -0.000015259, -0.000015259, -0.000015259, -0.000015259, -0.000030518,
   -0.000030518, -0.000030518, -0.000030518, -0.000045776, -0.000045776, -0.000061035, -0.000061035, -0.000076294,
   -0.000076294, -0.000091553, -0.000106812, -0.000106812, -0.000122070, -0.000137329, -0.000152588, -0.000167847,
   -0.000198364, -0.000213623, -0.000244141, -0.000259399, -0.000289917, -0.000320435, -0.000366211, -0.000396729,
   -0.000442505, -0.000473022, -0.000534058, -0.000579834, -0.000625610, -0.000686646, -0.000747681, -0.000808716,
   -0.000885010, -0.000961304, -0.001037598, -0.001113892, -0.001205444, -0.001296997, -0.001388550, -0.001480103,
   -0.001586914, -0.001693726, -0.001785278, -0.001907349, -0.002014160, -0.002120972, -0.002243042, -0.002349854,
   -0.002456665, -0.002578735, -0.002685547, -0.002792358, -0.002899170, -0.002990723, -0.003082275, -0.003173828,
   -0.003250122, -0.003326416, -0.003387451, -0.003433228, -0.003463745, -0.003479004, -0.003479004, -0.003463745,
   -0.003417969, -0.003372192, -0.003280640, -0.003173828, -0.003051758, -0.002883911, -0.002700806, -0.002487183,
   -0.002227783, -0.001937866, -0.001617432, -0.001266479, -0.000869751, -0.000442505,  0.000030518,  0.000549316,
	0.001098633,  0.001693726,  0.002334595,  0.003005981,  0.003723145,  0.004486084,  0.005294800,  0.006118774,
	0.007003784,  0.007919312,  0.008865356,  0.009841919,  0.010848999,  0.011886597,  0.012939453,  0.014022827,
	0.015121460,  0.016235352,  0.017349243,  0.018463135,  0.019577026,  0.020690918,  0.021789551,  0.022857666,
	0.023910522,  0.024932861,  0.025909424,  0.026840210,  0.027725220,  0.028533936,  0.029281616,  0.029937744,
	0.030532837,  0.031005859,  0.031387329,  0.031661987,  0.031814575,  0.031845093,  0.031738281,  0.031478882,
	0.031082153,  0.030517578,  0.029785156,  0.028884888,  0.027801514,  0.026535034,  0.025085449,  0.023422241,
	0.021575928,  0.019531250,  0.017257690,  0.014801025,  0.012115479,  0.009231567,  0.006134033,  0.002822876,
   -0.000686646, -0.004394531, -0.008316040, -0.012420654, -0.016708374, -0.021179199, -0.025817871, -0.030609131,
   -0.035552979, -0.040634155, -0.045837402, -0.051132202, -0.056533813, -0.061996460, -0.067520142, -0.073059082,
   -0.078628540, -0.084182739, -0.089706421, -0.095169067, -0.100540161, -0.105819702, -0.110946655, -0.115921021,
   -0.120697021, -0.125259399, -0.129562378, -0.133590698, -0.137298584, -0.140670776, -0.143676758, -0.146255493,
   -0.148422241, -0.150115967, -0.151306152, -0.151962280, -0.152069092, -0.151596069, -0.150497437, -0.148773193,
   -0.146362305, -0.143264771, -0.139450073, -0.134887695, -0.129577637, -0.123474121, -0.116577148, -0.108856201,
   -0.100311279, -0.090927124, -0.080688477, -0.069595337, -0.057617187, -0.044784546, -0.031082153, -0.016510010,
   -0.001068115,  0.015228271,  0.032379150,  0.050354004,  0.069168091,  0.088775635,  0.109161377,  0.130310059,
	0.152206421,  0.174789429,  0.198059082,  0.221984863,  0.246505737,  0.271591187,  0.297210693,  0.323318481,
	0.349868774,  0.376800537,  0.404083252,  0.431655884,  0.459472656,  0.487472534,  0.515609741,  0.543823242,
	0.572036743,  0.600219727,  0.628295898,  0.656219482,  0.683914185,  0.711318970,  0.738372803,  0.765029907,
	0.791213989,  0.816864014,  0.841949463,  0.866363525,  0.890090942,  0.913055420,  0.935195923,  0.956481934,
	0.976852417,  0.996246338,  1.014617920,  1.031936646,  1.048156738,  1.063217163,  1.077117920,  1.089782715,
	1.101211548,  1.111373901,  1.120223999,  1.127746582,  1.133926392,  1.138763428,  1.142211914,  1.144287109,
	1.144989014
};

const int16 huffmanTab0[] = { 0 };
const int16 huffmanTab1[] = { -5,-3,-1,17,1,16,0 };
const int16 huffmanTab2[] = { -15,-11,-9,-5,-3,-1,34,2,18,-1,33,32,17,-1,1,16,0 };
const int16 huffmanTab3[] = { -13,-11,-9,-5,-3,-1,34,2,18,-1,33,32,16,17,-1,1,0 };
const int16 huffmanTab5[] = { -29,-25,-23,-15,-7,-5,-3,-1,51,35,50,49,-3,-1,19,3,-1,48,34,-3,-1,18,33,-1,2,32,17,-1,1,16,0 };
const int16 huffmanTab6[] = { -25,-19,-13,-9,-5,-3,-1,51,3,35,-1,50,48,-1,19,49,-3,-1,34,2,18,-3,-1,33,32,1,-1,17,-1,16,0 };

const int16 huffmanTab7[] =
{
	-69,-65,-57,-39,-29,-17,-11,-7,-3,-1,85,69,-1,84,83,-1,53,68,-3,-1,37,82,21,-5,-1,81,-1,5,52,-1,80,-1,67,51,
	-5,-3,-1,36,66,20,-1,65,64,-11,-7,-3,-1,4,35,-1,50,3,-1,19,49,-3,-1,48,34,18,-5,-1,33,-1,2,32,17,-1,1,16,0
};

const int16 huffmanTab8[] =
{
	-65,-63,-59,-45,-31,-19,-13,-7,-5,-3,-1,85,84,69,83,-3,-1,53,68,37,-3,-1,82,5,21,-5,-1,81,-1,52,67,-3,-1,80,
	51,36,-5,-3,-1,66,20,65,-3,-1,4,64,-1,35,50,-9,-7,-3,-1,19,49,-1,3,48,34,-1,2,32,-1,18,33,17,-3,-1,1,16,0
};

const int16 huffmanTab9[] =
{
	-63,-53,-41,-29,-19,-11,-5,-3,-1,85,69,53,-1,83,-1,84,5,-3,-1,68,37,-1,82,21,-3,-1,81,52,-1,67,-1,80,4,-7,-3,
	-1,36,66,-1,51,64,-1,20,65,-5,-3,-1,35,50,19,-1,49,-1,3,48,-5,-3,-1,34,2,18,-1,33,32,-3,-1,17,1,-1,16,0
};

const int16 huffmanTab10[] =
{
	-125,-121,-111,-83,-55,-35,-21,-13,-7,-3,-1,119,103,-1,118,87,-3,-1,117,102,71,-3,-1,116,86,-1,101,55,-9,-3,
	-1,115,70,-3,-1,85,84,99,-1,39,114,-11,-5,-3,-1,100,7,112,-1,98,-1,69,53,-5,-1,6,-1,83,68,23,-17,-5,-1,113,
	-1,54,38,-5,-3,-1,37,82,21,-1,81,-1,52,67,-3,-1,22,97,-1,96,-1,5,80,-19,-11,-7,-3,-1,36,66,-1,51,4,-1,20,
	65,-3,-1,64,35,-1,50,3,-3,-1,19,49,-1,48,34,-7,-3,-1,18,33,-1,2,32,17,-1,1,16,0
};

const int16 huffmanTab11[] =
{
	-121,-113,-89,-59,-43,-27,-17,-7,-3,-1,119,103,-1,118,117,-3,-1,102,71,-1,116,-1,87,85,-5,-3,-1,86,101,55,
	-1,115,70,-9,-7,-3,-1,69,84,-1,53,83,39,-1,114,-1,100,7,-5,-1,113,-1,23,112,-3,-1,54,99,-1,96,-1,68,37,-13,
	-7,-5,-3,-1,82,5,21,98,-3,-1,38,6,22,-5,-1,97,-1,81,52,-5,-1,80,-1,67,51,-1,36,66,-15,-11,-7,-3,-1,20,65,
	-1,4,64,-1,35,50,-1,19,49,-5,-3,-1,3,48,34,33,-5,-1,18,-1,2,32,17,-3,-1,1,16,0
};

const int16 huffmanTab12[] =
{
	-115,-99,-73,-45,-27,-17,-9,-5,-3,-1,119,103,118,-1,87,117,-3,-1,102,71,-1,116,101,-3,-1,86,55,-3,-1,115,
	85,39,-7,-3,-1,114,70,-1,100,23,-5,-1,113,-1,7,112,-1,54,99,-13,-9,-3,-1,69,84,-1,68,-1,6,5,-1,38,98,-5,
	-1,97,-1,22,96,-3,-1,53,83,-1,37,82,-17,-7,-3,-1,21,81,-1,52,67,-5,-3,-1,80,4,36,-1,66,20,-3,-1,51,65,-1,
	35,50,-11,-7,-5,-3,-1,64,3,48,19,-1,49,34,-1,18,33,-7,-5,-3,-1,2,32,0,17,-1,1,16
};

const int16 huffmanTab13[] =
{
	-509,-503,-475,-405,-333,-265,-205,-153,-115,-83,-53,-35,-21,-13,-9,-7,-5,-3,-1,254,252,253,237,255,-1,239,223,
	-3,-1,238,207,-1,222,191,-9,-3,-1,251,206,-1,220,-1,175,233,-1,236,221,-9,-5,-3,-1,250,205,190,-1,235,159,-3,
	-1,249,234,-1,189,219,-17,-9,-3,-1,143,248,-1,204,-1,174,158,-5,-1,142,-1,127,126,247,-5,-1,218,-1,173,188,-3,
	-1,203,246,111,-15,-7,-3,-1,232,95,-1,157,217,-3,-1,245,231,-1,172,187,-9,-3,-1,79,244,-3,-1,202,230,243,-1,
	63,-1,141,216,-21,-9,-3,-1,47,242,-3,-1,110,156,15,-5,-3,-1,201,94,171,-3,-1,125,215,78,-11,-5,-3,-1,200,214,
	62,-1,185,-1,155,170,-1,31,241,-23,-13,-5,-1,240,-1,186,229,-3,-1,228,140,-1,109,227,-5,-1,226,-1,46,14,-1,30,
	225,-15,-7,-3,-1,224,93,-1,213,124,-3,-1,199,77,-1,139,184,-7,-3,-1,212,154,-1,169,108,-1,198,61,-37,-21,-9,-5,
	-3,-1,211,123,45,-1,210,29,-5,-1,183,-1,92,197,-3,-1,153,122,195,-7,-5,-3,-1,167,151,75,209,-3,-1,13,208,-1,
	138,168,-11,-7,-3,-1,76,196,-1,107,182,-1,60,44,-3,-1,194,91,-3,-1,181,137,28,-43,-23,-11,-5,-1,193,-1,152,12,
	-1,192,-1,180,106,-5,-3,-1,166,121,59,-1,179,-1,136,90,-11,-5,-1,43,-1,165,105,-1,164,-1,120,135,-5,-1,148,-1,
	119,118,178,-11,-3,-1,27,177,-3,-1,11,176,-1,150,74,-7,-3,-1,58,163,-1,89,149,-1,42,162,-47,-23,-9,-3,-1,26,
	161,-3,-1,10,104,160,-5,-3,-1,134,73,147,-3,-1,57,88,-1,133,103,-9,-3,-1,41,146,-3,-1,87,117,56,-5,-1,131,-1,
	102,71,-3,-1,116,86,-1,101,115,-11,-3,-1,25,145,-3,-1,9,144,-1,72,132,-7,-5,-1,114,-1,70,100,40,-1,130,24,-41,
	-27,-11,-5,-3,-1,55,39,23,-1,113,-1,85,7,-7,-3,-1,112,54,-1,99,69,-3,-1,84,38,-1,98,53,-5,-1,129,-1,8,128,-3,
	-1,22,97,-1,6,96,-13,-9,-5,-3,-1,83,68,37,-1,82,5,-1,21,81,-7,-3,-1,52,67,-1,80,36,-3,-1,66,51,20,-19,-11,
	-5,-1,65,-1,4,64,-3,-1,35,50,19,-3,-1,49,3,-1,48,34,-3,-1,18,33,-1,2,32,-3,-1,17,1,16,0
};

const int16 huffmanTab15[] =
{
	-495,-445,-355,-263,-183,-115,-77,-43,-27,-13,-7,-3,-1,255,239,-1,254,223,-1,238,-1,253,207,-7,-3,-1,252,222,-1,
	237,191,-1,251,-1,206,236,-7,-3,-1,221,175,-1,250,190,-3,-1,235,205,-1,220,159,-15,-7,-3,-1,249,234,-1,189,219,
	-3,-1,143,248,-1,204,158,-7,-3,-1,233,127,-1,247,173,-3,-1,218,188,-1,111,-1,174,15,-19,-11,-3,-1,203,246,
	-3,-1,142,232,-1,95,157,-3,-1,245,126,-1,231,172,-9,-3,-1,202,187,-3,-1,217,141,79,-3,-1,244,63,-1,243,216,
	-33,-17,-9,-3,-1,230,47,-1,242,-1,110,240,-3,-1,31,241,-1,156,201,-7,-3,-1,94,171,-1,186,229,-3,-1,125,215,
	-1,78,228,-15,-7,-3,-1,140,200,-1,62,109,-3,-1,214,227,-1,155,185,-7,-3,-1,46,170,-1,226,30,-5,-1,225,-1,14,
	224,-1,93,213,-45,-25,-13,-7,-3,-1,124,199,-1,77,139,-1,212,-1,184,154,-7,-3,-1,169,108,-1,198,61,-1,211,210,
	-9,-5,-3,-1,45,13,29,-1,123,183,-5,-1,209,-1,92,208,-1,197,138,-17,-7,-3,-1,168,76,-1,196,107,-5,-1,182,-1,
	153,12,-1,60,195,-9,-3,-1,122,167,-1,166,-1,192,11,-1,194,-1,44,91,-55,-29,-15,-7,-3,-1,181,28,-1,137,152,-3,
	-1,193,75,-1,180,106,-5,-3,-1,59,121,179,-3,-1,151,136,-1,43,90,-11,-5,-1,178,-1,165,27,-1,177,-1,176,105,-7,
	-3,-1,150,74,-1,164,120,-3,-1,135,58,163,-17,-7,-3,-1,89,149,-1,42,162,-3,-1,26,161,-3,-1,10,160,104,-7,-3,
	-1,134,73,-1,148,57,-5,-1,147,-1,119,9,-1,88,133,-53,-29,-13,-7,-3,-1,41,103,-1,118,146,-1,145,-1,25,144,-7,
	-3,-1,72,132,-1,87,117,-3,-1,56,131,-1,102,71,-7,-3,-1,40,130,-1,24,129,-7,-3,-1,116,8,-1,128,86,-3,-1,101,
	55,-1,115,70,-17,-7,-3,-1,39,114,-1,100,23,-3,-1,85,113,-3,-1,7,112,54,-7,-3,-1,99,69,-1,84,38,-3,-1,98,22,
	-3,-1,6,96,53,-33,-19,-9,-5,-1,97,-1,83,68,-1,37,82,-3,-1,21,81,-3,-1,5,80,52,-7,-3,-1,67,36,-1,66,51,-1,
	65,-1,20,4,-9,-3,-1,35,50,-3,-1,64,3,19,-3,-1,49,48,34,-9,-7,-3,-1,18,33,-1,2,32,17,-3,-1,1,16,0
};

const int16 huffmanTab16[] =
{
	-509,-503,-461,-323,-103,-37,-27,-15,-7,-3,-1,239,254,-1,223,253,-3,-1,207,252,-1,191,251,-5,-1,175,-1,250,159,
	-3,-1,249,248,143,-7,-3,-1,127,247,-1,111,246,255,-9,-5,-3,-1,95,245,79,-1,244,243,-53,-1,240,-1,63,-29,-19,
	-13,-7,-5,-1,206,-1,236,221,222,-1,233,-1,234,217,-1,238,-1,237,235,-3,-1,190,205,-3,-1,220,219,174,-11,-5,
	-1,204,-1,173,218,-3,-1,126,172,202,-5,-3,-1,201,125,94,189,242,-93,-5,-3,-1,47,15,31,-1,241,-49,-25,-13,
	-5,-1,158,-1,188,203,-3,-1,142,232,-1,157,231,-7,-3,-1,187,141,-1,216,110,-1,230,156,-13,-7,-3,-1,171,186,
	-1,229,215,-1,78,-1,228,140,-3,-1,200,62,-1,109,-1,214,155,-19,-11,-5,-3,-1,185,170,225,-1,212,-1,184,169,
	-5,-1,123,-1,183,208,227,-7,-3,-1,14,224,-1,93,213,-3,-1,124,199,-1,77,139,-75,-45,-27,-13,-7,-3,-1,154,
	108,-1,198,61,-3,-1,92,197,13,-7,-3,-1,138,168,-1,153,76,-3,-1,182,122,60,-11,-5,-3,-1,91,137,28,-1,192,-1,
	152,121,-1,226,-1,46,30,-15,-7,-3,-1,211,45,-1,210,209,-5,-1,59,-1,151,136,29,-7,-3,-1,196,107,-1,195,167,-1,
	44,-1,194,181,-23,-13,-7,-3,-1,193,12,-1,75,180,-3,-1,106,166,179,-5,-3,-1,90,165,43,-1,178,27,-13,-5,-1,177,
	-1,11,176,-3,-1,105,150,-1,74,164,-5,-3,-1,120,135,163,-3,-1,58,89,42,-97,-57,-33,-19,-11,-5,-3,-1,149,104,161,
	-3,-1,134,119,148,-5,-3,-1,73,87,103,162,-5,-1,26,-1,10,160,-3,-1,57,147,-1,88,133,-9,-3,-1,41,146,-3,-1,118,
	9,25,-5,-1,145,-1,144,72,-3,-1,132,117,-1,56,131,-21,-11,-5,-3,-1,102,40,130,-3,-1,71,116,24,-3,-1,129,128,-3,
	-1,8,86,55,-9,-5,-1,115,-1,101,70,-1,39,114,-5,-3,-1,100,85,7,23,-23,-13,-5,-1,113,-1,112,54,-3,-1,99,69,-1,
	84,38,-3,-1,98,22,-1,97,-1,6,96,-9,-5,-1,83,-1,53,68,-1,37,82,-1,81,-1,21,5,-33,-23,-13,-7,-3,-1,52,67,-1,80,
	36,-3,-1,66,51,20,-5,-1,65,-1,4,64,-1,35,50,-3,-1,19,49,-3,-1,3,48,34,-3,-1,18,33,-1,2,32,-3,-1,17,1,16,0
};

const int16 huffmanTab24[] =
{
	-451,-117,-43,-25,-15,-7,-3,-1,239,254,-1,223,253,-3,-1,207,252,-1,191,251,-5,-1,250,-1,175,159,-1,249,248,-9,
	-5,-3,-1,143,127,247,-1,111,246,-3,-1,95,245,-1,79,244,-71,-7,-3,-1,63,243,-1,47,242,-5,-1,241,-1,31,240,-25,-9,
	-1,15,-3,-1,238,222,-1,237,206,-7,-3,-1,236,221,-1,190,235,-3,-1,205,220,-1,174,234,-15,-7,-3,-1,189,219,-1,204,
	158,-3,-1,233,173,-1,218,188,-7,-3,-1,203,142,-1,232,157,-3,-1,217,126,-1,231,172,255,-235,-143,-77,-45,-25,-15,
	-7,-3,-1,202,187,-1,141,216,-5,-3,-1,14,224,13,230,-5,-3,-1,110,156,201,-1,94,186,-9,-5,-1,229,-1,171,125,-1,215,
	228,-3,-1,140,200,-3,-1,78,46,62,-15,-7,-3,-1,109,214,-1,227,155,-3,-1,185,170,-1,226,30,-7,-3,-1,225,93,-1,213,124,
	-3,-1,199,77,-1,139,184,-31,-15,-7,-3,-1,212,154,-1,169,108,-3,-1,198,61,-1,211,45,-7,-3,-1,210,29,-1,123,183,-3,-1,
	209,92,-1,197,138,-17,-7,-3,-1,168,153,-1,76,196,-3,-1,107,182,-3,-1,208,12,60,-7,-3,-1,195,122,-1,167,44,-3,-1,194,
	91,-1,181,28,-57,-35,-19,-7,-3,-1,137,152,-1,193,75,-5,-3,-1,192,11,59,-3,-1,176,10,26,-5,-1,180,-1,106,166,-3,-1,121,
	151,-3,-1,160,9,144,-9,-3,-1,179,136,-3,-1,43,90,178,-7,-3,-1,165,27,-1,177,105,-1,150,164,-17,-9,-5,-3,-1,74,120,135,
	-1,58,163,-3,-1,89,149,-1,42,162,-7,-3,-1,161,104,-1,134,119,-3,-1,73,148,-1,57,147,-63,-31,-15,-7,-3,-1,88,133,-1,41,
	103,-3,-1,118,146,-1,25,145,-7,-3,-1,72,132,-1,87,117,-3,-1,56,131,-1,102,40,-17,-7,-3,-1,130,24,-1,71,116,-5,-1,129,
	-1,8,128,-1,86,101,-7,-5,-1,23,-1,7,112,115,-3,-1,55,39,114,-15,-7,-3,-1,70,100,-1,85,113,-3,-1,54,99,-1,69,84,-7,-3,
	-1,38,98,-1,22,97,-5,-3,-1,6,96,53,-1,83,68,-51,-37,-23,-15,-9,-3,-1,37,82,-1,21,-1,5,80,-1,81,-1,52,67,-3,-1,36,66,
	-1,51,20,-9,-5,-1,65,-1,4,64,-1,35,50,-1,19,49,-7,-5,-3,-1,3,48,34,18,-1,33,-1,2,32,-3,-1,17,1,-1,16,0
};

struct BitsToTableMap
{
	uint32 bits;
	const int16* table;
};

const BitsToTableMap huffmanTables1[] =
{
	{ 0, huffmanTab0  }, { 0, huffmanTab1  }, { 0,  huffmanTab2  }, { 0,  huffmanTab3  },
	{ 0, huffmanTab0  }, { 0, huffmanTab5  }, { 0,  huffmanTab6  }, { 0,  huffmanTab7  },
	{ 0, huffmanTab8  }, { 0, huffmanTab9  }, { 0,  huffmanTab10 }, { 0,  huffmanTab11 },
	{ 0, huffmanTab12 }, { 0, huffmanTab13 }, { 0,  huffmanTab0  }, { 0,  huffmanTab15 },
	{ 1, huffmanTab16 }, { 2, huffmanTab16 }, { 3,  huffmanTab16 }, { 4,  huffmanTab16 },
	{ 6, huffmanTab16 }, { 8, huffmanTab16 }, { 10, huffmanTab16 }, { 13, huffmanTab16 },
	{ 4, huffmanTab24 }, { 5, huffmanTab24 }, { 6,  huffmanTab24 }, { 7,  huffmanTab24 },
	{ 8, huffmanTab24 }, { 9, huffmanTab24 }, { 11, huffmanTab24 }, { 13, huffmanTab24 }
};

const int16 huffmanTabC0[] = { -29,-21,-13,-7,-3,-1,11,15,-1,13,14,-3,-1,7,5,9,-3,-1,6,3,-1,10,12,-3,-1,2,1,-1,4,8,0 };
const int16 huffmanTabC1[] = { -15,-7,-3,-1,15,14,-1,13,12,-3,-1,11,10,-1,9,8,-7,-3,-1,7,6,-1,5,4,-3,-1,3,2,-1,1,0 };

const BitsToTableMap huffmanTables2[] = { { 0, huffmanTabC0 }, { 0, huffmanTabC1 } };

struct VBRTagData
{
	bool read (const uint8* data) noexcept
	{
		flags = 0;

		const int layer = (data[1] >> 1) & 3;
		if (layer != 1)
			return false;

		const int type = (data[1] >> 3) & 1;
		const int sampleRateIndex = (data[2] >> 2) & 3;
		const int mode = (data[3] >> 6) & 3;

		static const int bitRates[3][16] =
		{
			{ 0, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160, -1 }, // MPEG2
			{ 0, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, -1 }, // MPEG1
			{ 0, 8, 16, 24, 32, 40, 48, 56, 64, -1, -1, -1, -1, -1, -1, -1 }, // MPEG 2.5
		};

		const int bitrate = bitRates[type][((data[2] >> 4) & 15)];

		const int sampleRates[3][4] =
		{
			{ 22050, 24000, 16000, -1 }, // MPEG2
			{ 44100, 48000, 32000, -1 }, // MPEG1
			{ 11025, 12000, 8000,  -1 }, // MPEG2.5
		};

		if ((data[1] >> 4) == 0xe)
			sampleRate = sampleRates[2][sampleRateIndex];
		else
			sampleRate = sampleRates[type][sampleRateIndex];

		data += type != 0 ? (mode != 3 ? (32 + 4) : (17 + 4))
						  : (mode != 3 ? (17 + 4) : (9 + 4));

		if (! isVbrTag (data))
			return false;

		data += 4;
		flags = ByteOrder::bigEndianInt (data);
		data += 4;

		if (flags & 1)
		{
			frames = ByteOrder::bigEndianInt (data);
			data += 4;
		}

		if (flags & 2)
		{
			bytes = ByteOrder::bigEndianInt (data);
			data += 4;
		}

		if (flags & 4)
		{
			if (toc != nullptr)
				for (int i = 0; i < 100; ++i)
					toc[i] = data[i];

			data += 100;
		}

		vbrScale = -1;

		if (flags & 8)
		{
			vbrScale = ByteOrder::bigEndianInt (data);
			data += 4;
		}

		headersize = ((type + 1) * 72000 * bitrate) / sampleRate;
		return true;
	}

	uint8 toc[100];
	int sampleRate, flags, frames, bytes, vbrScale, headersize;

private:
	static bool isVbrTag (const uint8* const d) noexcept
	{
		return (d[0] == 'X' && d[1] == 'i' && d[2] == 'n' && d[3] == 'g')
			|| (d[0] == 'I' && d[1] == 'n' && d[2] == 'f' && d[3] == 'o');
	}
};

struct MP3Frame
{
	MP3Frame()
	{
		zeromem (this, sizeof (MP3Frame));
		single = -1;
	}

	void selectLayer2Table()
	{
		static const int translate[3][2][16] =
		{
			{ { 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 1, 1, 1, 1, 1, 0 }, { 0, 2, 2, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0 } },
			{ { 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } },
			{ { 0, 3, 3, 3, 3, 3, 3, 0, 0, 0, 1, 1, 1, 1, 1, 0 }, { 0, 3, 3, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0 } }
		};

		static const AllocationTable* const tables[] = { allocTable0, allocTable1, allocTable2, allocTable3, allocTable4 };
		static const int limits[] = { 27, 30, 8, 12, 30 };

		const int index = lsf ? 4 : translate[sampleRateIndex][2 - numChannels][bitrateIndex];
		layer2SubBandLimit = limits [index];
		allocationTable = tables [index];
	}

	int getFrequency() const noexcept
	{
		const int frequencies[] = { 44100, 48000, 32000, 22050, 24000, 16000, 11025, 12000, 8000 };
		return frequencies [sampleRateIndex];
	}

	void decodeHeader (const uint32 header)
	{
		jassert (((header >> 10) & 3) != 3);

		mpeg25              = (header & (1 << 20)) == 0;
		lsf                 = mpeg25 ? 1 : ((header & (1 << 19)) ? 0 : 1);
		layer               = 4 - ((header >> 17) & 3);
		sampleRateIndex     = mpeg25 ? (6 + ((header >> 10) & 3)) : (((header >> 10) & 3) + (lsf * 3));
		crc16FollowsHeader  = ((header >> 16) & 1) == 0;
		bitrateIndex        = (header >> 12) & 15;
		padding             = (header >> 9) & 1;
		mode                = (header >> 6) & 3;
		modeExt             = (header >> 4) & 3;
		//extension           = (header >> 8) & 1;
		//copyright         = (header >> 3) & 1;
		//original          = (header >> 2) & 1;
		//emphasis          = header & 3;
		numChannels         = (mode == 3) ? 1 : 2;

		static const int frameSizes [2][3][16] =
		{
			{ { 0, 32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448 },
			  { 0, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384 },
			  { 0, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320 } },

			{ { 0, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256 },
			  { 0, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160 },
			  { 0, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160 } }
		};

		switch (layer)
		{
			case 1: frameSize = (((frameSizes[lsf][0][bitrateIndex] * 12000) / getFrequency() + padding) * 4) - 4; break;
			case 2: frameSize = (frameSizes[lsf][1][bitrateIndex] * 144000)  / getFrequency() + (padding - 4); break;
			case 3: frameSize = (bitrateIndex == 0) ? 0 : ((frameSizes[lsf][2][bitrateIndex] * 144000) / (getFrequency() << lsf) + (padding - 4)); break;
			default: break;
		}
	}

	int layer, frameSize, numChannels, single;
	int lsf;     // 0 = mpeg-1, 1 = mpeg-2/LSF
	bool mpeg25; // true = mpeg-2.5, false = mpeg-1/2
	bool crc16FollowsHeader;
	int bitrateIndex, sampleRateIndex, padding;
	int mode, modeExt, layer2SubBandLimit;
	enum { downSampleLimit = 32 };
	const AllocationTable* allocationTable;
};

struct Constants
{
	Constants()
	{
		cosTables[0] = cos64; cosTables[1] = cos32; cosTables[2] = cos16; cosTables[3] = cos8; cosTables[4] = cos4;
		initDecodeTables();
		initLayer2Tables();
		initLayer3Tables();
	}

	const uint8* getGroupTable (const int16 d1, const int index) const noexcept
	{
		switch (d1)
		{
			case 3:   return &group3tab [3 * jmin (index, 3 * 3 * 3)];
			case 5:   return &group5tab [3 * jmin (index, 5 * 5 * 5)];
			case 9:   return &group9tab [3 * jmin (index, 9 * 9 * 9)];
			default:  break;
		}

		static const uint8 dummy[] = { 0, 0, 0 };
		return dummy;
	}

	float muls[27][64];
	float nToThe4Over3[8207];
	float antiAliasingCa[8], antiAliasingCs[8];
	float win[4][36];
	float win1[4][36];
	float powToGains[256 + 118 + 4];
	int longLimit[9][23];
	int shortLimit[9][14];
	float tan1_1[16], tan2_1[16], tan1_2[16], tan2_2[16];
	float pow1_1[2][16], pow2_1[2][16], pow1_2[2][16], pow2_2[2][16];
	int* map[9][3];
	int* mapEnd[9][3];
	uint32 nLength2[512];
	uint32 iLength2[256];
	float decodeWin[512 + 32];
	float* cosTables[5];

private:
	int mapbuf0[9][152];
	int mapbuf1[9][156];
	int mapbuf2[9][44];
	float cos64[16], cos32[8], cos16[4], cos8[2], cos4[1];
	uint8 group3tab [32 * 3];
	uint8 group5tab [128 * 3];
	uint8 group9tab [1024 * 3];

	void initDecodeTables()
	{
		int i, j, scaleval = -1;
		float* table = decodeWin;

		for (i = 0; i < 5; ++i)
		{
			int kr = 0x10 >> i;
			int divv = 0x40 >> i;
			float* costab = cosTables[i];

			for (int k = 0; k < kr; ++k)
				costab[k] = (float) (1.0 / (2.0 * cos (double_Pi * (k * 2 + 1) / divv)));
		}

		for (i = 0, j = 0; i < 256; ++i, ++j, table += 32)
		{
			if (table < decodeWin + 512 + 16)
				table[16] = table[0] = (float) (decodeWindow[j] * scaleval);
			if (i % 32 == 31)
				table -= 1023;
			if (i % 64 == 63)
				scaleval = -scaleval;
		}

		for (; i < 512; ++i, --j, table += 32)
		{
			if (table < decodeWin + 512 + 16)
				table[16] = table[0] = (float) (decodeWindow[j] * scaleval);

			if (i % 32 == 31) table -= 1023;
			if (i % 64 == 63) scaleval = -scaleval;
		}
	}

	void initLayer2Tables()
	{
		static const uint8 base[3][9] =
		{
			{ 1, 0, 2 },
			{ 17, 18, 0, 19, 20 },
			{ 21, 1, 22, 23, 0, 24, 25, 2, 26 }
		};

		static const int tableLengths[] = { 3, 5, 9 };
		static uint8* tables[] = { group3tab, group5tab, group9tab };

		for (int i = 0; i < 3; ++i)
		{
			uint8* table = tables[i];
			const int len = tableLengths[i];

			for (int j = 0; j < len; ++j)
				for (int k = 0; k < len; ++k)
					for (int l = 0; l < len; ++l)
					{
						*table++ = base[i][l];
						*table++ = base[i][k];
						*table++ = base[i][j];
					}
		}

		for (int k = 0; k < 27; ++k)
		{
			static const double multipliers[] =
			{
				0, -2.0 / 3.0, 2.0 / 3.0, 2.0 / 7.0, 2.0 / 15.0, 2.0 / 31.0, 2.0 / 63.0, 2.0 / 127.0, 2.0 / 255.0,
				2.0 / 511.0, 2.0 / 1023.0, 2.0 / 2047.0, 2.0 / 4095.0, 2.0 / 8191.0, 2.0 / 16383.0, 2.0 / 32767.0, 2.0 / 65535.0,
				-4.0 / 5.0, -2.0 / 5.0, 2.0 / 5.0, 4.0 / 5.0, -8.0 / 9.0, -4.0 / 9.0, -2.0 / 9.0, 2.0 / 9.0, 4.0 / 9.0, 8.0 / 9.0
			};

			float* table = muls[k];
			for (int j = 3, i = 0; i < 63; ++i, --j)
				*table++ = (float) (multipliers[k] * pow (2.0, j / 3.0));
			*table++ = 0;
		}
	}

	void initLayer3Tables()
	{
		int i, j;
		for (i = -256; i < 118 + 4; ++i)
			powToGains[i + 256] = pow (2.0, -0.25 * (i + 210));

		for (i = 0; i < 8207; ++i)
			nToThe4Over3[i] = pow ((double) i, 4.0 / 3.0);

		for (i = 0; i < 8; ++i)
		{
			static double Ci[] = { -0.6, -0.535, -0.33, -0.185, -0.095, -0.041, -0.0142, -0.0037 };
			const double sq = sqrt (1.0 + Ci[i] * Ci[i]);
			antiAliasingCs[i] = 1.0 / sq;
			antiAliasingCa[i] = Ci[i] / sq;
		}

		for (i = 0; i < 18; ++i)
		{
			win[0][i] = win[1][i] = 0.5 * sin (double_Pi / 72.0 * (2 * i + 1)) / cos (double_Pi * (2 * i + 19) / 72.0);
			win[0][i + 18] = win[3][i + 18] = 0.5 * sin (double_Pi / 72.0 * (2 * (i + 18) + 1)) / cos (double_Pi * (2 * (i + 18) + 19) / 72.0);
		}

		const double piOver72 = double_Pi;

		for (i = 0; i < 6; ++i)
		{
			win[1][i + 18] = 0.5 / cos (piOver72 * (2 * (i + 18) + 19));
			win[3][i + 12] = 0.5 / cos (piOver72 * (2 * (i + 12) + 19));
			win[1][i + 24] = 0.5 * sin (double_Pi / 24.0 * (2 * i + 13)) / cos (piOver72 * (2 * (i + 24) + 19));
			win[1][i + 30] = win[3][i] = 0;
			win[3][i + 6] = 0.5 * sin (double_Pi / 24.0 * (2 * i + 1)) / cos (piOver72 * (2 * (i + 6) + 19));
		}

		for (i = 0; i < 12; ++i)
			win[2][i] = 0.5 * sin (double_Pi / 24.0 * (2 * i + 1)) / cos (double_Pi * (2 * i + 7) / 24.0);

		for (j = 0; j < 4; ++j)
		{
			static const int len[4] = { 36, 36, 12, 36 };
			for (i = 0; i < len[j]; i += 2)   win1[j][i] =  win[j][i];
			for (i = 1; i < len[j]; i += 2)   win1[j][i] = -win[j][i];
		}

		const double sqrt2 = 1.41421356237309504880168872420969808;

		for (i = 0; i < 16; ++i)
		{
			const double t = tan (i * double_Pi / 12.0);
			tan1_1[i] = t / (1.0 + t);
			tan2_1[i] = 1.0 / (1.0 + t);
			tan1_2[i] = sqrt2 * t / (1.0 + t);
			tan2_2[i] = sqrt2 / (1.0 + t);

			for (j = 0; j < 2; ++j)
			{
				double p1 = 1.0, p2 = 1.0;

				if (i > 0)
				{
					const double base = pow (2.0, -0.25 * (j + 1));

					if (i & 1)
						p1 = pow (base, (i + 1) * 0.5);
					else
						p2 = pow (base, i * 0.5);
				}

				pow1_1[j][i] = p1;
				pow2_1[j][i] = p2;
				pow1_2[j][i] = sqrt2 * p1;
				pow2_2[j][i] = sqrt2 * p2;
			}
		}

		for (j = 0; j < 9; ++j)
		{
			const BandInfoStruct& bi = bandInfo[j];
			int cb;
			int* mp = map[j][0] = mapbuf0[j];
			const int16* bdf = bi.longDiff;

			for (i = 0, cb = 0; cb < 8; ++cb, i += *bdf++)
			{
				*mp++ = (*bdf) >> 1;
				*mp++ = i;
				*mp++ = 3;
				*mp++ = cb;
			}
			bdf = bi.shortDiff + 3;

			for (cb = 3; cb < 13; ++cb)
			{
				const int l = (*bdf++) >> 1;

				for (int lwin = 0; lwin < 3; ++lwin)
				{
					*mp++ = l;
					*mp++ = i + lwin;
					*mp++ = lwin;
					*mp++ = cb;
				}
				i += 6 * l;
			}

			mapEnd[j][0] = mp;
			mp = map[j][1] = mapbuf1[j];
			bdf = bi.shortDiff;

			for (i = 0, cb = 0; cb < 13; ++cb)
			{
				const int l = (*bdf++) >> 1;
				for (int lwin = 0; lwin < 3; ++lwin)
				{
					*mp++ = l;
					*mp++ = i + lwin;
					*mp++ = lwin;
					*mp++ = cb;
				}
				i += 6 * l;
			}
			mapEnd[j][1] = mp;

			mp = map[j][2] = mapbuf2[j];
			bdf = bi.longDiff;
			for (cb = 0; cb < 22; ++cb)
			{
				*mp++ = (*bdf++) >> 1;
				*mp++ = cb;
			}
			mapEnd[j][2] = mp;

		}

		for (j = 0; j < 9; ++j)
		{
			for (i = 0; i < 23; ++i)    longLimit[j][i]  = jmin (32, (bandInfo[j].longIndex[i] - 1 + 8) / 18 + 1);
			for (i = 0; i < 14; ++i)    shortLimit[j][i] = jmin (32, (bandInfo[j].shortIndex[i] - 1) / 18 + 1);
		}

		for (i = 0; i < 5; ++i)
			for (j = 0; j < 6; ++j)
				for (int k = 0; k < 6; ++k)
				{
					const int n = k + j * 6 + i * 36;
					iLength2[n] = i | (j << 3) | (k << 6) | (3 << 12);
				}

		for (i = 0; i < 4; ++i)
			for (j = 0; j < 4; ++j)
				for (int k = 0; k < 4; ++k)
				{
					const int n = k + j * 4 + i * 16;
					iLength2[n + 180] = i | (j << 3) | (k << 6) | (4 << 12);
				}

		for (i = 0; i < 4; ++i)
			for (j = 0; j < 3; ++j)
			{
				const int n = j + i * 3;
				iLength2[n + 244] = i | (j << 3) | (5 << 12);
				nLength2[n + 500] = i | (j << 3) | (2 << 12) | (1 << 15);
			}

		for (i = 0; i < 5; ++i)
			for (j = 0; j < 5; ++j)
				for (int k = 0; k < 4; ++k)
					for (int l = 0; l < 4; ++l)
					{
						const int n = l + k * 4 + j * 16 + i * 80;
						nLength2[n] = i | (j << 3) | (k << 6) | (l << 9) | (0 << 12);
					}

		for (i = 0; i < 5; ++i)
			for (j = 0; j < 5; ++j)
				for (int k = 0; k < 4; ++k)
				{
					const int n = k + j * 4 + i * 20;
					nLength2[n + 400] = i | (j << 3) | (k << 6) | (1 << 12);
				}
	}
};

static const Constants constants;

struct Layer3SideInfo
{
	struct Info
	{
		void doAntialias (float xr[32][18]) const noexcept
		{
			float* xr1 = xr[1];
			int sb;

			if (blockType == 2)
			{
				if (mixedBlockFlag == 0)
					return;

				sb = 1;
			}
			else
				sb = maxb - 1;

			for (; sb != 0; --sb, xr1 += 10)
			{
				const float* cs = constants.antiAliasingCs;
				const float* ca = constants.antiAliasingCa;
				float* xr2 = xr1;

				for (int ss = 7; ss >= 0; --ss)
				{
					const float bu = *--xr2, bd = *xr1;
					*xr2   = (bu * *cs)   - (bd * *ca);
					*xr1++ = (bd * *cs++) + (bu * *ca++);
				}
			}
		}

		void doIStereo (float xrBuffer[2][32][18], const int* const scaleFactors,
						const int sampleRate, const bool msStereo, const int lsf) const noexcept
		{
			float (*xr) [32 * 18] = (float (*) [32 * 18]) xrBuffer;
			const BandInfoStruct& bi = bandInfo[sampleRate];
			const float* tabl1, *tabl2;

			if (lsf != 0)
			{
				const int p = scaleFactorCompression & 1;
				if (msStereo)
				{
					tabl1 = constants.pow1_2[p];
					tabl2 = constants.pow2_2[p];
				}
				else
				{
					tabl1 = constants.pow1_1[p];
					tabl2 = constants.pow2_1[p];
				}
			}
			else
			{
				if (msStereo)
				{
					tabl1 = constants.tan1_2;
					tabl2 = constants.tan2_2;
				}
				else
				{
					tabl1 = constants.tan1_1;
					tabl2 = constants.tan2_1;
				}
			}

			if (blockType == 2)
			{
				bool doL = mixedBlockFlag != 0;

				for (int lwin = 0; lwin < 3; ++lwin)
				{
					int sfb = maxBand[lwin];
					doL = doL && (sfb <= 3);

					for (; sfb < 12; ++sfb)
					{
						const int p = scaleFactors[sfb * 3 + lwin - mixedBlockFlag];
						if (p != 7)
						{
							const float t1 = tabl1[p];
							const float t2 = tabl2[p];
							int sb = bi.shortDiff[sfb];
							int index = sb + lwin;

							for (; sb > 0; --sb, index += 3)
							{
								float v = xr[0][index];
								xr[0][index] = v * t1;
								xr[1][index] = v * t2;
							}
						}
					}

					const int p = scaleFactors[11 * 3 + lwin - mixedBlockFlag];

					if (p != 7)
					{
						const float t1 = tabl1[p];
						const float t2 = tabl2[p];
						int sb = bi.shortDiff[12];
						int index = sb + lwin;

						for (; sb > 0; --sb, index += 3)
						{
							float v = xr[0][index];
							xr[0][index] = v * t1;
							xr[1][index] = v * t2;
						}
					}
				}

				if (doL)
				{
					int index = bi.longIndex[maxBandl];

					for (int sfb = maxBandl; sfb < 8; ++sfb)
					{
						int sb = bi.longDiff[sfb];
						const int p = scaleFactors[sfb];

						if (p != 7)
						{
							const float t1 = tabl1[p];
							const float t2 = tabl2[p];

							for (; sb > 0; --sb, ++index)
							{
								float v = xr[0][index];
								xr[0][index] = v * t1;
								xr[1][index] = v * t2;
							}
						}
						else
							index += sb;
					}
				}
			}
			else
			{
				int index = bi.longIndex[maxBandl];

				for (int sfb = maxBandl; sfb < 21; ++sfb)
				{
					int sb = bi.longDiff[sfb];
					const int p = scaleFactors[sfb];

					if (p != 7)
					{
						const float t1 = tabl1[p];
						const float t2 = tabl2[p];

						for (; sb > 0; --sb, ++index)
						{
							const float v = xr[0][index];
							xr[0][index] = v * t1;
							xr[1][index] = v * t2;
						}
					}
					else
						index += sb;
				}

				const int p = scaleFactors[20];
				if (p != 7)
				{
					const float t1 = tabl1[p], t2 = tabl2[p];

					for (int sb = bi.longDiff[21]; sb > 0; --sb, ++index)
					{
						const float v = xr[0][index];
						xr[0][index] = v * t1;
						xr[1][index] = v * t2;
					}
				}
			}
		}

		int scfsi;
		uint32 part2_3Length, bigValues;
		uint32 scaleFactorCompression, blockType, mixedBlockFlag;
		uint32 tableSelect[3];
		uint32 maxBand[3];
		uint32 maxBandl, maxb, region1Start, region2Start;
		uint32 preflag, scaleFactorScale, count1TableSelect;
		const float* fullGain[3];
		const float* pow2gain;
	};

	struct InfoPair { Info gr[2]; };
	InfoPair ch[2];

	uint32 mainDataStart, privateBits;
};

namespace DCT
{
	enum { SBLIMIT = 32 };
	static const float cos6_1  = 0.866025388f;
	static const float cos6_2  = 0.5f;
	static const float cos9[]  = { 1.0f, 0.98480773f, 0.939692616f, 0.866025388f, 0.766044438f, 0.642787635f, 0.5f, 0.342020154f, 0.173648179f };
	static const float cos36[] = { 0.501909912f, 0.517638087f, 0.551688969f, 0.610387266f, 0.707106769f, 0.871723413f, 1.18310082f, 1.93185163f, 5.73685646f };
	static const float cos12[] = { 0.517638087f, 0.707106769f, 1.93185163f };

	inline void dct36_0 (const int v, float* const ts, float* const out1, float* const out2,
						 const float* const wintab, float sum0, const float sum1) noexcept
	{
		const float tmp = sum0 + sum1;
		out2[9 + v] = tmp * wintab[27 + v];
		out2[8 - v] = tmp * wintab[26 - v];
		sum0 -= sum1;
		ts[SBLIMIT * (8 - v)] = out1[8 - v] + sum0 * wintab[8 - v];
		ts[SBLIMIT * (9 + v)] = out1[9 + v] + sum0 * wintab[9 + v];
	}

	inline void dct36_1 (const int v, float* const ts, float* const out1, float* const out2, const float* const wintab,
						 const float tmp1a, const float tmp1b, const float tmp2a, const float tmp2b) noexcept
	{
		dct36_0 (v, ts, out1, out2, wintab, tmp1a + tmp2a, (tmp1b + tmp2b) * cos36[v]);
	}

	inline void dct36_2 (const int v, float* const ts, float* const out1, float* const out2, const float* const wintab,
						 const float tmp1a, const float tmp1b, const float tmp2a, const float tmp2b) noexcept
	{
		dct36_0 (v, ts, out1, out2, wintab, tmp2a - tmp1a, (tmp2b - tmp1b) * cos36[v]);
	}

	void dct36 (float* const in, float* const out1, float* const out2, const float* const wintab, float* const ts) noexcept
	{
		in[17] += in[16]; in[16] += in[15]; in[15] += in[14]; in[14] += in[13]; in[13] += in[12];
		in[12] += in[11]; in[11] += in[10]; in[10] += in[9];  in[9]  += in[8];  in[8]  += in[7];
		in[7]  += in[6];  in[6]  += in[5];  in[5]  += in[4];  in[4]  += in[3];  in[3]  += in[2];
		in[2]  += in[1];  in[1]  += in[0];  in[17] += in[15]; in[15] += in[13]; in[13] += in[11];
		in[11] += in[9];  in[9]  += in[7];  in[7]  += in[5];  in[5]  += in[3];  in[3]  += in[1];

		const float ta33 = in[6]  * cos9[3];
		const float ta66 = in[12] * cos9[6];
		const float tb33 = in[7]  * cos9[3];
		const float tb66 = in[13] * cos9[6];

		{
			const float tmp1a = in[2] * cos9[1] + ta33 + in[10] * cos9[5] + in[14] * cos9[7];
			const float tmp1b = in[3] * cos9[1] + tb33 + in[11] * cos9[5] + in[15] * cos9[7];
			const float tmp2a = in[0] + in[4] * cos9[2] + in[8] * cos9[4] + ta66 + in[16] * cos9[8];
			const float tmp2b = in[1] + in[5] * cos9[2] + in[9] * cos9[4] + tb66 + in[17] * cos9[8];
			dct36_1 (0, ts, out1, out2, wintab, tmp1a, tmp1b, tmp2a, tmp2b);
			dct36_2 (8, ts, out1, out2, wintab, tmp1a, tmp1b, tmp2a, tmp2b);
		}

		{
			const float tmp1a = (in[2] - in[10] - in[14]) * cos9[3];
			const float tmp1b = (in[3] - in[11] - in[15]) * cos9[3];
			const float tmp2a = (in[4] - in[8] - in[16]) * cos9[6] - in[12] + in[0];
			const float tmp2b = (in[5] - in[9] - in[17]) * cos9[6] - in[13] + in[1];
			dct36_1 (1, ts, out1, out2, wintab, tmp1a, tmp1b, tmp2a, tmp2b);
			dct36_2 (7, ts, out1, out2, wintab, tmp1a, tmp1b, tmp2a, tmp2b);
		}

		{
			const float tmp1a = in[2] * cos9[5] - ta33 - in[10] * cos9[7] + in[14] * cos9[1];
			const float tmp1b = in[3] * cos9[5] - tb33 - in[11] * cos9[7] + in[15] * cos9[1];
			const float tmp2a = in[0] - in[4] * cos9[8] - in[8] * cos9[2] + ta66 + in[16] * cos9[4];
			const float tmp2b = in[1] - in[5] * cos9[8] - in[9] * cos9[2] + tb66 + in[17] * cos9[4];
			dct36_1 (2, ts, out1, out2, wintab, tmp1a, tmp1b, tmp2a, tmp2b);
			dct36_2 (6, ts, out1, out2, wintab, tmp1a, tmp1b, tmp2a, tmp2b);
		}

		{
			const float tmp1a = in[2] * cos9[7] - ta33 + in[10] * cos9[1] - in[14] * cos9[5];
			const float tmp1b = in[3] * cos9[7] - tb33 + in[11] * cos9[1] - in[15] * cos9[5];
			const float tmp2a = in[0] - in[4] * cos9[4] + in[8] * cos9[8] + ta66 - in[16] * cos9[2];
			const float tmp2b = in[1] - in[5] * cos9[4] + in[9] * cos9[8] + tb66 - in[17] * cos9[2];
			dct36_1 (3, ts, out1, out2, wintab, tmp1a, tmp1b, tmp2a, tmp2b);
			dct36_2 (5, ts, out1, out2, wintab, tmp1a, tmp1b, tmp2a, tmp2b);
		}

		const float sum0 =  in[0] - in[4] + in[8] - in[12] + in[16];
		const float sum1 = (in[1] - in[5] + in[9] - in[13] + in[17]) * cos36[4];
		dct36_0 (4, ts, out1, out2, wintab, sum0, sum1);
	}

	struct DCT12Inputs
	{
		float in0, in1, in2, in3, in4, in5;

		inline DCT12Inputs (const float* const in) noexcept
		{
			in5 = in[5*3] + (in4 = in[4*3]);
			in4 += (in3 = in[3*3]);
			in3 += (in2 = in[2*3]);
			in2 += (in1 = in[1*3]);
			in1 += (in0 = in[0*3]);
			in5 += in3; in3 += in1;
			in2 *= cos6_1;
			in3 *= cos6_1;
		}

		inline void process() noexcept
		{
			in0 += in4 * cos6_2;
			in4 = in0 + in2; in0 -= in2;
			in1 += in5 * cos6_2;
			in5 = (in1 + in3) * cos12[0];
			in1 = (in1 - in3) * cos12[2];
			in3 = in4 + in5; in4 -= in5;
			in2 = in0 + in1; in0 -= in1;
		}
	};

	void dct12 (const float* in, float* const out1, float* const out2, const float* wi, float* ts) noexcept
	{
		{
			ts[0] = out1[0];
			ts[SBLIMIT * 1] = out1[1];
			ts[SBLIMIT * 2] = out1[2];
			ts[SBLIMIT * 3] = out1[3];
			ts[SBLIMIT * 4] = out1[4];
			ts[SBLIMIT * 5] = out1[5];

			DCT12Inputs inputs (in);

			{
				float tmp1 = (inputs.in0 - inputs.in4);
				const float tmp2 = (inputs.in1 - inputs.in5) * cos12[1];
				const float tmp0 = tmp1 + tmp2;
				tmp1 -= tmp2;

				ts[16 * SBLIMIT] = out1[16] + tmp0 * wi[10];
				ts[13 * SBLIMIT] = out1[13] + tmp0 * wi[7];
				ts[7  * SBLIMIT] = out1[7]  + tmp1 * wi[1];
				ts[10 * SBLIMIT] = out1[10] + tmp1 * wi[4];
			}

			inputs.process();

			ts[17 * SBLIMIT] = out1[17] + inputs.in2 * wi[11];
			ts[12 * SBLIMIT] = out1[12] + inputs.in2 * wi[6];
			ts[14 * SBLIMIT] = out1[14] + inputs.in3 * wi[8];
			ts[15 * SBLIMIT] = out1[15] + inputs.in3 * wi[9];

			ts[6  * SBLIMIT] = out1[6]  + inputs.in0 * wi[0];
			ts[11 * SBLIMIT] = out1[11] + inputs.in0 * wi[5];
			ts[8  * SBLIMIT] = out1[8]  + inputs.in4 * wi[2];
			ts[9  * SBLIMIT] = out1[9]  + inputs.in4 * wi[3];
		}

		{
			DCT12Inputs inputs (++in);
			float tmp1 = (inputs.in0 - inputs.in4);
			const float tmp2 = (inputs.in1 - inputs.in5) * cos12[1];
			const float tmp0 = tmp1 + tmp2;
			tmp1 -= tmp2;
			out2[4] = tmp0 * wi[10];
			out2[1] = tmp0 * wi[7];
			ts[13 * SBLIMIT] += tmp1 * wi[1];
			ts[16 * SBLIMIT] += tmp1 * wi[4];

			inputs.process();

			out2[5] = inputs.in2 * wi[11];
			out2[0] = inputs.in2 * wi[6];
			out2[2] = inputs.in3 * wi[8];
			out2[3] = inputs.in3 * wi[9];
			ts[12 * SBLIMIT] += inputs.in0 * wi[0];
			ts[17 * SBLIMIT] += inputs.in0 * wi[5];
			ts[14 * SBLIMIT] += inputs.in4 * wi[2];
			ts[15 * SBLIMIT] += inputs.in4 * wi[5 - 2];
		}

		{
			DCT12Inputs inputs (++in);
			out2[12] = out2[13] = out2[14] = out2[15] = out2[16] = out2[17] = 0;

			float tmp1 = (inputs.in0 - inputs.in4);
			const float tmp2 = (inputs.in1 - inputs.in5) * cos12[1];
			const float tmp0 = tmp1 + tmp2;
			tmp1 -= tmp2;

			out2[10] = tmp0 * wi[10];
			out2[7]  = tmp0 * wi[7];
			out2[1] += tmp1 * wi[1];
			out2[4] += tmp1 * wi[4];

			inputs.process();

			out2[11] = inputs.in2 * wi[11];
			out2[6]  = inputs.in2 * wi[6];
			out2[8]  = inputs.in3 * wi[8];
			out2[9]  = inputs.in3 * wi[9];
			out2[0] += inputs.in0 * wi[0];
			out2[5] += inputs.in0 * wi[5];
			out2[2] += inputs.in4 * wi[2];
			out2[3] += inputs.in4 * wi[3];
		}
	}

	void dct64 (float* const out0, float* const out1, float* const b1, float* const b2, const float* const samples) noexcept
	{
		{
			const float* const costab = constants.cosTables[0];
			b1[0x00] = samples[0x00] + samples[0x1F];   b1[0x1F] = (samples[0x00] - samples[0x1F]) * costab[0x0];
			b1[0x01] = samples[0x01] + samples[0x1E];   b1[0x1E] = (samples[0x01] - samples[0x1E]) * costab[0x1];
			b1[0x02] = samples[0x02] + samples[0x1D];   b1[0x1D] = (samples[0x02] - samples[0x1D]) * costab[0x2];
			b1[0x03] = samples[0x03] + samples[0x1C];   b1[0x1C] = (samples[0x03] - samples[0x1C]) * costab[0x3];
			b1[0x04] = samples[0x04] + samples[0x1B];   b1[0x1B] = (samples[0x04] - samples[0x1B]) * costab[0x4];
			b1[0x05] = samples[0x05] + samples[0x1A];   b1[0x1A] = (samples[0x05] - samples[0x1A]) * costab[0x5];
			b1[0x06] = samples[0x06] + samples[0x19];   b1[0x19] = (samples[0x06] - samples[0x19]) * costab[0x6];
			b1[0x07] = samples[0x07] + samples[0x18];   b1[0x18] = (samples[0x07] - samples[0x18]) * costab[0x7];
			b1[0x08] = samples[0x08] + samples[0x17];   b1[0x17] = (samples[0x08] - samples[0x17]) * costab[0x8];
			b1[0x09] = samples[0x09] + samples[0x16];   b1[0x16] = (samples[0x09] - samples[0x16]) * costab[0x9];
			b1[0x0A] = samples[0x0A] + samples[0x15];   b1[0x15] = (samples[0x0A] - samples[0x15]) * costab[0xA];
			b1[0x0B] = samples[0x0B] + samples[0x14];   b1[0x14] = (samples[0x0B] - samples[0x14]) * costab[0xB];
			b1[0x0C] = samples[0x0C] + samples[0x13];   b1[0x13] = (samples[0x0C] - samples[0x13]) * costab[0xC];
			b1[0x0D] = samples[0x0D] + samples[0x12];   b1[0x12] = (samples[0x0D] - samples[0x12]) * costab[0xD];
			b1[0x0E] = samples[0x0E] + samples[0x11];   b1[0x11] = (samples[0x0E] - samples[0x11]) * costab[0xE];
			b1[0x0F] = samples[0x0F] + samples[0x10];   b1[0x10] = (samples[0x0F] - samples[0x10]) * costab[0xF];
		}

		{
			const float* const costab = constants.cosTables[1];
			b2[0x00] = b1[0x00] + b1[0x0F];   b2[0x0F] = (b1[0x00] - b1[0x0F]) * costab[0];
			b2[0x01] = b1[0x01] + b1[0x0E];   b2[0x0E] = (b1[0x01] - b1[0x0E]) * costab[1];
			b2[0x02] = b1[0x02] + b1[0x0D];   b2[0x0D] = (b1[0x02] - b1[0x0D]) * costab[2];
			b2[0x03] = b1[0x03] + b1[0x0C];   b2[0x0C] = (b1[0x03] - b1[0x0C]) * costab[3];
			b2[0x04] = b1[0x04] + b1[0x0B];   b2[0x0B] = (b1[0x04] - b1[0x0B]) * costab[4];
			b2[0x05] = b1[0x05] + b1[0x0A];   b2[0x0A] = (b1[0x05] - b1[0x0A]) * costab[5];
			b2[0x06] = b1[0x06] + b1[0x09];   b2[0x09] = (b1[0x06] - b1[0x09]) * costab[6];
			b2[0x07] = b1[0x07] + b1[0x08];   b2[0x08] = (b1[0x07] - b1[0x08]) * costab[7];
			b2[0x10] = b1[0x10] + b1[0x1F];   b2[0x1F] = (b1[0x1F] - b1[0x10]) * costab[0];
			b2[0x11] = b1[0x11] + b1[0x1E];   b2[0x1E] = (b1[0x1E] - b1[0x11]) * costab[1];
			b2[0x12] = b1[0x12] + b1[0x1D];   b2[0x1D] = (b1[0x1D] - b1[0x12]) * costab[2];
			b2[0x13] = b1[0x13] + b1[0x1C];   b2[0x1C] = (b1[0x1C] - b1[0x13]) * costab[3];
			b2[0x14] = b1[0x14] + b1[0x1B];   b2[0x1B] = (b1[0x1B] - b1[0x14]) * costab[4];
			b2[0x15] = b1[0x15] + b1[0x1A];   b2[0x1A] = (b1[0x1A] - b1[0x15]) * costab[5];
			b2[0x16] = b1[0x16] + b1[0x19];   b2[0x19] = (b1[0x19] - b1[0x16]) * costab[6];
			b2[0x17] = b1[0x17] + b1[0x18];   b2[0x18] = (b1[0x18] - b1[0x17]) * costab[7];
		}

		{
			const float* const costab = constants.cosTables[2];
			b1[0x00] = b2[0x00] + b2[0x07];   b1[0x07] = (b2[0x00] - b2[0x07]) * costab[0];
			b1[0x01] = b2[0x01] + b2[0x06];   b1[0x06] = (b2[0x01] - b2[0x06]) * costab[1];
			b1[0x02] = b2[0x02] + b2[0x05];   b1[0x05] = (b2[0x02] - b2[0x05]) * costab[2];
			b1[0x03] = b2[0x03] + b2[0x04];   b1[0x04] = (b2[0x03] - b2[0x04]) * costab[3];
			b1[0x08] = b2[0x08] + b2[0x0F];   b1[0x0F] = (b2[0x0F] - b2[0x08]) * costab[0];
			b1[0x09] = b2[0x09] + b2[0x0E];   b1[0x0E] = (b2[0x0E] - b2[0x09]) * costab[1];
			b1[0x0A] = b2[0x0A] + b2[0x0D];   b1[0x0D] = (b2[0x0D] - b2[0x0A]) * costab[2];
			b1[0x0B] = b2[0x0B] + b2[0x0C];   b1[0x0C] = (b2[0x0C] - b2[0x0B]) * costab[3];
			b1[0x10] = b2[0x10] + b2[0x17];   b1[0x17] = (b2[0x10] - b2[0x17]) * costab[0];
			b1[0x11] = b2[0x11] + b2[0x16];   b1[0x16] = (b2[0x11] - b2[0x16]) * costab[1];
			b1[0x12] = b2[0x12] + b2[0x15];   b1[0x15] = (b2[0x12] - b2[0x15]) * costab[2];
			b1[0x13] = b2[0x13] + b2[0x14];   b1[0x14] = (b2[0x13] - b2[0x14]) * costab[3];
			b1[0x18] = b2[0x18] + b2[0x1F];   b1[0x1F] = (b2[0x1F] - b2[0x18]) * costab[0];
			b1[0x19] = b2[0x19] + b2[0x1E];   b1[0x1E] = (b2[0x1E] - b2[0x19]) * costab[1];
			b1[0x1A] = b2[0x1A] + b2[0x1D];   b1[0x1D] = (b2[0x1D] - b2[0x1A]) * costab[2];
			b1[0x1B] = b2[0x1B] + b2[0x1C];   b1[0x1C] = (b2[0x1C] - b2[0x1B]) * costab[3];
		}

		{
			const float cos0 = constants.cosTables[3][0];
			const float cos1 = constants.cosTables[3][1];
			b2[0x00] = b1[0x00] + b1[0x03];   b2[0x03] = (b1[0x00] - b1[0x03]) * cos0;
			b2[0x01] = b1[0x01] + b1[0x02];   b2[0x02] = (b1[0x01] - b1[0x02]) * cos1;
			b2[0x04] = b1[0x04] + b1[0x07];   b2[0x07] = (b1[0x07] - b1[0x04]) * cos0;
			b2[0x05] = b1[0x05] + b1[0x06];   b2[0x06] = (b1[0x06] - b1[0x05]) * cos1;
			b2[0x08] = b1[0x08] + b1[0x0B];   b2[0x0B] = (b1[0x08] - b1[0x0B]) * cos0;
			b2[0x09] = b1[0x09] + b1[0x0A];   b2[0x0A] = (b1[0x09] - b1[0x0A]) * cos1;
			b2[0x0C] = b1[0x0C] + b1[0x0F];   b2[0x0F] = (b1[0x0F] - b1[0x0C]) * cos0;
			b2[0x0D] = b1[0x0D] + b1[0x0E];   b2[0x0E] = (b1[0x0E] - b1[0x0D]) * cos1;
			b2[0x10] = b1[0x10] + b1[0x13];   b2[0x13] = (b1[0x10] - b1[0x13]) * cos0;
			b2[0x11] = b1[0x11] + b1[0x12];   b2[0x12] = (b1[0x11] - b1[0x12]) * cos1;
			b2[0x14] = b1[0x14] + b1[0x17];   b2[0x17] = (b1[0x17] - b1[0x14]) * cos0;
			b2[0x15] = b1[0x15] + b1[0x16];   b2[0x16] = (b1[0x16] - b1[0x15]) * cos1;
			b2[0x18] = b1[0x18] + b1[0x1B];   b2[0x1B] = (b1[0x18] - b1[0x1B]) * cos0;
			b2[0x19] = b1[0x19] + b1[0x1A];   b2[0x1A] = (b1[0x19] - b1[0x1A]) * cos1;
			b2[0x1C] = b1[0x1C] + b1[0x1F];   b2[0x1F] = (b1[0x1F] - b1[0x1C]) * cos0;
			b2[0x1D] = b1[0x1D] + b1[0x1E];   b2[0x1E] = (b1[0x1E] - b1[0x1D]) * cos1;
		}

		{
			const float cos0 = constants.cosTables[4][0];
			b1[0x00] = b2[0x00] + b2[0x01];   b1[0x01] = (b2[0x00] - b2[0x01]) * cos0;
			b1[0x02] = b2[0x02] + b2[0x03];   b1[0x03] = (b2[0x03] - b2[0x02]) * cos0;  b1[0x02] += b1[0x03];
			b1[0x04] = b2[0x04] + b2[0x05];   b1[0x05] = (b2[0x04] - b2[0x05]) * cos0;
			b1[0x06] = b2[0x06] + b2[0x07];   b1[0x07] = (b2[0x07] - b2[0x06]) * cos0;
			b1[0x06] += b1[0x07];   b1[0x04] += b1[0x06];  b1[0x06] += b1[0x05]; b1[0x05] += b1[0x07];
			b1[0x08] = b2[0x08] + b2[0x09];   b1[0x09] = (b2[0x08] - b2[0x09]) * cos0;
			b1[0x0A] = b2[0x0A] + b2[0x0B];   b1[0x0B] = (b2[0x0B] - b2[0x0A]) * cos0;  b1[0x0A] += b1[0x0B];
			b1[0x0C] = b2[0x0C] + b2[0x0D];   b1[0x0D] = (b2[0x0C] - b2[0x0D]) * cos0;
			b1[0x0E] = b2[0x0E] + b2[0x0F];   b1[0x0F] = (b2[0x0F] - b2[0x0E]) * cos0;
			b1[0x0E] += b1[0x0F];   b1[0x0C] += b1[0x0E];  b1[0x0E] += b1[0x0D]; b1[0x0D] += b1[0x0F];
			b1[0x10] = b2[0x10] + b2[0x11];   b1[0x11] = (b2[0x10] - b2[0x11]) * cos0;
			b1[0x12] = b2[0x12] + b2[0x13];   b1[0x13] = (b2[0x13] - b2[0x12]) * cos0;  b1[0x12] += b1[0x13];
			b1[0x14] = b2[0x14] + b2[0x15];   b1[0x15] = (b2[0x14] - b2[0x15]) * cos0;
			b1[0x16] = b2[0x16] + b2[0x17];   b1[0x17] = (b2[0x17] - b2[0x16]) * cos0;
			b1[0x16] += b1[0x17];    b1[0x14] += b1[0x16]; b1[0x16] += b1[0x15];  b1[0x15] += b1[0x17];
			b1[0x18] = b2[0x18] + b2[0x19];   b1[0x19] = (b2[0x18] - b2[0x19]) * cos0;
			b1[0x1A] = b2[0x1A] + b2[0x1B];   b1[0x1B] = (b2[0x1B] - b2[0x1A]) * cos0;  b1[0x1A] += b1[0x1B];
			b1[0x1C] = b2[0x1C] + b2[0x1D];   b1[0x1D] = (b2[0x1C] - b2[0x1D]) * cos0;
			b1[0x1E] = b2[0x1E] + b2[0x1F];   b1[0x1F] = (b2[0x1F] - b2[0x1E]) * cos0;
			b1[0x1E] += b1[0x1F];    b1[0x1C] += b1[0x1E]; b1[0x1E] += b1[0x1D];  b1[0x1D] += b1[0x1F];
		}

		out0[0x10 * 16] = b1[0x00];  out0[0x10 * 12] = b1[0x04]; out0[0x10 * 8]  = b1[0x02];  out0[0x10 * 4]  = b1[0x06];
		out0[0] = b1[0x01];  out1[0]  = b1[0x01]; out1[0x10 * 4]  = b1[0x05];  out1[0x10 * 8]  = b1[0x03];
		out1[0x10 * 12] = b1[0x07];

		b1[0x08] += b1[0x0C];  out0[0x10 * 14] = b1[0x08];  b1[0x0C] += b1[0x0a];  out0[0x10 * 10] = b1[0x0C];
		b1[0x0A] += b1[0x0E];  out0[0x10 * 6]  = b1[0x0A];  b1[0x0E] += b1[0x09];  out0[0x10 * 2]  = b1[0x0E];
		b1[0x09] += b1[0x0D];  out1[0x10 * 2]  = b1[0x09];  b1[0x0D] += b1[0x0B];  out1[0x10 * 6]  = b1[0x0D];
		b1[0x0B] += b1[0x0F];  out1[0x10 * 10] = b1[0x0B];  out1[0x10 * 14] = b1[0x0F];

		b1[0x18] += b1[0x1C];  out0[0x10 * 15] = b1[0x10] + b1[0x18];   out0[0x10 * 13] = b1[0x18] + b1[0x14];
		b1[0x1C] += b1[0x1a];  out0[0x10 * 11] = b1[0x14] + b1[0x1C];   out0[0x10 * 9]  = b1[0x1C] + b1[0x12];
		b1[0x1A] += b1[0x1E];  out0[0x10 * 7]  = b1[0x12] + b1[0x1A];   out0[0x10 * 5]  = b1[0x1A] + b1[0x16];
		b1[0x1E] += b1[0x19];  out0[0x10 * 3]  = b1[0x16] + b1[0x1E];   out0[0x10 * 1]  = b1[0x1E] + b1[0x11];
		b1[0x19] += b1[0x1D];  out1[0x10 * 1]  = b1[0x11] + b1[0x19];   out1[0x10 * 3]  = b1[0x19] + b1[0x15];
		b1[0x1D] += b1[0x1B];  out1[0x10 * 5]  = b1[0x15] + b1[0x1D];   out1[0x10 * 7]  = b1[0x1D] + b1[0x13];
		b1[0x1B] += b1[0x1F];  out1[0x10 * 9]  = b1[0x13] + b1[0x1B];   out1[0x10 * 11] = b1[0x1B] + b1[0x17];
		out1[0x10 * 13] = b1[0x17] + b1[0x1F];  out1[0x10 * 15] = b1[0x1F];
	}

	void dct64 (float* const a, float* const b, const float* const c) noexcept
	{
		float temp[64];
		dct64 (a, b, temp, temp + 32, c);
	}
}

struct MP3Stream
{
	MP3Stream (InputStream& source)
		: stream (source, 8192),
		  numFrames (0), currentFrameIndex (0), vbrHeaderFound (false)
	{
		reset();
	}

	int decodeNextBlock (float* const out0, float* const out1, int& done)
	{
		if (! headerParsed)
		{
			int nextFrameOffset = scanForNextFrameHeader (false);

			if (lastFrameSize == -1 || needToSyncBitStream)
			{
				needToSyncBitStream = false;
				readVBRHeader();

				if (vbrHeaderFound)
					return 1;
			}

			if (nextFrameOffset < 0)
				return -1;

			if (nextFrameOffset > 0)
			{
				int size;
				wasFreeFormat = false;
				needToSyncBitStream = true;
				size = (int) (bufferPointer - (bufferSpace[bufferSpaceIndex] + 512));

				if (size > 2880)
				{
					size = 0;
					bufferPointer = bufferSpace[bufferSpaceIndex] + 512;
				}

				const int toSkip = (size + nextFrameOffset) - 2880;

				if (toSkip > 0)
				{
					stream.skipNextBytes (toSkip);
					nextFrameOffset -= toSkip;
				}

				stream.read (bufferPointer, nextFrameOffset);
				lastFrameSize += nextFrameOffset;
			}

			frame.decodeHeader (stream.readIntBigEndian());
			headerParsed = true;
			frameSize = frame.frameSize;
			isFreeFormat = (frameSize == 0);
			sideInfoSize = frame.lsf != 0 ? ((frame.numChannels == 1) ? 9 : 17)
										  : ((frame.numChannels == 1) ? 17 : 32);

			if (frame.crc16FollowsHeader)
				sideInfoSize += 2;

			bufferSpaceIndex = 1 - bufferSpaceIndex;
			bufferPointer = bufferSpace[bufferSpaceIndex] + 512;
			bitIndex = 0;

			if (lastFrameSize == -1)
				return 1;
		}

		if (! sideParsed)
		{
			if (frame.layer == 3)
			{
				stream.read (bufferPointer, sideInfoSize);

				if (frame.crc16FollowsHeader)
					getBits (16);

				const int bits = jmax (0, decodeLayer3SideInfo());
				dataSize = (bits + 7) / 8;

				if (! isFreeFormat)
					dataSize = jmin (dataSize, frame.frameSize - sideInfoSize);
			}
			else
			{
				dataSize = frame.frameSize;
				sideInfoSize = 0;
			}

			sideParsed = true;
		}

		int result = 1;

		if (! dataParsed)
		{
			stream.read (bufferPointer, dataSize);

			if (out0 != nullptr)
			{
				if (frame.layer < 3 && frame.crc16FollowsHeader)
					getBits (16);

				switch (frame.layer)
				{
					case 1:  decodeLayer1Frame (out0, out1, done); break;
					case 2:  decodeLayer2Frame (out0, out1, done); break;
					case 3:  decodeLayer3Frame (out0, out1, done); break;
					default: break;
				}
			}

			bufferPointer = bufferSpace[bufferSpaceIndex] + 512 + sideInfoSize + dataSize;
			dataParsed = true;
			result = 0;
		}

		if (isFreeFormat)
		{
			if (wasFreeFormat)
			{
				frameSize = lastFrameSizeNoPadding + frame.padding;
			}
			else
			{
				const int nextFrameOffset = scanForNextFrameHeader (true);
				if (nextFrameOffset < 0)
					return result;

				frameSize = nextFrameOffset + sideInfoSize + dataSize;
				lastFrameSizeNoPadding = frameSize - frame.padding;
			}
		}

		if (result == 0)
			return result;

		int bytes = frameSize - (sideInfoSize + dataSize);

		if (bytes > 0)
		{
			const int toSkip = bytes - 512;

			if (toSkip > 0)
			{
				stream.skipNextBytes (toSkip);
				bytes -= toSkip;
				frameSize -= toSkip;
			}

			stream.read (bufferPointer, bytes);
			bufferPointer += bytes;
		}

		lastFrameSize = frameSize;
		wasFreeFormat = isFreeFormat;
		frameSize = 0;
		headerParsed = sideParsed = dataParsed = false;
		return result;
	}

	bool seek (int frameIndex)
	{
		frameIndex = jmax (0, frameIndex);

		while (frameIndex >= frameStreamPositions.size() * storedStartPosInterval)
		{
			int dummy = 0;
			const int result = decodeNextBlock (nullptr, nullptr, dummy);

			if (result < 0)
				return false;
			else if (result > 0)
				break;
		}

		frameIndex = jmin (frameIndex & ~(storedStartPosInterval - 1),
						   frameStreamPositions.size() * storedStartPosInterval - 1);
		stream.setPosition (frameStreamPositions.getUnchecked (frameIndex / storedStartPosInterval));
		currentFrameIndex = frameIndex;
		reset();
		return true;
	}

	MP3Frame frame;
	VBRTagData vbrTagData;
	BufferedInputStream stream;
	int numFrames, currentFrameIndex;
	bool vbrHeaderFound;

private:
	bool headerParsed, sideParsed, dataParsed, needToSyncBitStream;
	bool isFreeFormat, wasFreeFormat;
	int sideInfoSize, dataSize;
	int frameSize, lastFrameSize, lastFrameSizeNoPadding;
	int bufferSpaceIndex;
	Layer3SideInfo sideinfo;
	uint8 bufferSpace[2][2880 + 1024];
	uint8* bufferPointer;
	int bitIndex, synthBo;
	float hybridBlock[2][2][32 * 18];
	int hybridBlockIndex[2];
	float synthBuffers[2][2][0x110];
	float hybridIn[2][32][18];
	float hybridOut[2][18][32];

	void reset() noexcept
	{
		headerParsed = sideParsed = dataParsed = isFreeFormat = wasFreeFormat = false;
		lastFrameSize = -1;
		needToSyncBitStream = true;
		frameSize = sideInfoSize = dataSize = frameSize = bitIndex = 0;
		lastFrameSizeNoPadding = bufferSpaceIndex = 0;
		bufferPointer = bufferSpace[bufferSpaceIndex] + 512;
		synthBo = 1;

		zerostruct (sideinfo);
		zeromem (bufferSpace, sizeof (bufferSpace));
		zeromem (hybridBlock, sizeof (hybridBlock));
		zeromem (hybridBlockIndex, sizeof (hybridBlockIndex));
		zeromem (synthBuffers, sizeof (synthBuffers));
	}

	enum { storedStartPosInterval = 4 };
	Array<int64> frameStreamPositions;

	struct SideInfoLayer1
	{
		uint8 allocation[32][2];
		uint8 scaleFactor[32][2];
	};

	struct SideInfoLayer2
	{
		uint8 allocation[32][2];
		uint8 scaleFactor[32][2][3];
	};

	static bool isValidHeader (const uint32 header, const int oldLayer) noexcept
	{
		const int newLayer = 4 - ((header >> 17) & 3);

		return (header & 0xffe00000) == 0xffe00000
				&& newLayer != 4
				&& (oldLayer <= 0 || newLayer == oldLayer)
				&& ((header >> 12) & 15) != 15
				&& ((header >> 10) & 3) != 3
				&& (header & 3) != 2;
	}

	bool rollBackBufferPointer (int backstep) noexcept
	{
		if (lastFrameSize < 0 && backstep > 0)
			return false;

		const uint8* oldBuffer = bufferSpace[1 - bufferSpaceIndex] + 512;
		bufferPointer -= backstep;

		if (backstep != 0)
			memcpy (bufferPointer, oldBuffer + lastFrameSize - backstep, (size_t) backstep);

		bitIndex = 0;
		return true;
	}

	uint32 getBits (const int numBits) noexcept
	{
		if (numBits <= 0 || bufferPointer == nullptr)
			return 0;

		const uint32 result = ((((((bufferPointer[0] << 8) | bufferPointer[1]) << 8)
							   | bufferPointer[2]) << bitIndex) & 0xffffff) >> (24 - numBits);
		bitIndex += numBits;
		bufferPointer += (bitIndex >> 3);
		bitIndex &= 7;
		return result;
	}

	uint32 getOneBit() noexcept
	{
		const uint8 result = *bufferPointer << bitIndex;
		++bitIndex;
		bufferPointer += (bitIndex >> 3);
		bitIndex &= 7;
		return result >> 7;
	}

	uint32 getBitsUnchecked (const int numBits) noexcept
	{
		const uint32 result = ((((bufferPointer[0] << 8) | bufferPointer[1]) << bitIndex) & 0xffff) >> (16 - numBits);
		bitIndex += numBits;
		bufferPointer += (bitIndex >> 3);
		bitIndex &= 7;
		return result;
	}

	inline uint8  getBitsUint8  (const int numBits) noexcept  { return (uint8)  getBitsUnchecked (numBits); }
	inline uint16 getBitsUint16 (const int numBits) noexcept  { return (uint16) getBitsUnchecked (numBits); }

	int scanForNextFrameHeader (const bool checkTypeAgainstLastFrame) noexcept
	{
		const int64 oldPos = stream.getPosition();
		int offset = -3;
		uint32 header = 0;

		for (;;)
		{
			if (stream.isExhausted() || stream.getPosition() > oldPos + 32768)
			{
				offset = -1;
				break;
			}

			header = (header << 8) | (uint8) stream.readByte();

			if (offset >= 0 && isValidHeader (header, frame.layer))
			{
				if (! checkTypeAgainstLastFrame)
					break;

				const bool mpeg25         = (header & (1 << 20)) == 0;
				const int lsf             = mpeg25 ? 1 : ((header & (1 << 19)) ? 0 : 1);
				const int sampleRateIndex = mpeg25 ? (6 + ((header >> 10) & 3)) : (((header >> 10) & 3) + (lsf * 3));
				const int mode            = (header >> 6) & 3;
				const int numChannels     = (mode == 3) ? 1 : 2;

				if (numChannels == frame.numChannels && lsf == frame.lsf
					  && mpeg25 == frame.mpeg25 && sampleRateIndex == frame.sampleRateIndex)
					break;
			}

			++offset;
		}

		if (offset >= 0)
		{
			if ((currentFrameIndex & (storedStartPosInterval - 1)) == 0)
				frameStreamPositions.set (currentFrameIndex / storedStartPosInterval, oldPos + offset);

			++currentFrameIndex;
		}

		stream.setPosition (oldPos);
		return offset;
	}

	void readVBRHeader()
	{
		int64 oldPos = stream.getPosition();
		uint8 xing[194];
		stream.read (xing, sizeof (xing));

		vbrHeaderFound = vbrTagData.read (xing);

		if (vbrHeaderFound)
		{
			numFrames = vbrTagData.frames;
			oldPos += jmax (vbrTagData.headersize, 1);
		}

		stream.setPosition (oldPos);
	}

	void decodeLayer1Frame (float* const pcm0, float* const pcm1, int& samplesDone) noexcept
	{
		float fraction[2][32];
		SideInfoLayer1 si;
		layer1Step1 (si);
		const int single = (frame.numChannels == 1 || frame.single == 3) ? 0 : frame.single;

		if (single >= 0)
		{
			for (int i = 0; i < 12; ++i)
			{
				layer1Step2 (si, fraction);
				synthesise (fraction[single], 0, pcm0, samplesDone);
			}
		}
		else
		{
			for (int i = 0; i < 12; ++i)
			{
				layer1Step2 (si, fraction);
				synthesiseStereo (fraction[0], fraction[1], pcm0, pcm1, samplesDone);
			}
		}
	}

	void decodeLayer2Frame (float* const pcm0, float* const pcm1, int& samplesDone)
	{
		float fraction[2][4][32];
		frame.selectLayer2Table();
		SideInfoLayer2 si;
		layer2Step1 (si);
		const int single = (frame.numChannels == 1 || frame.single == 3) ? 0 : frame.single;

		if (single >= 0)
		{
			for (int i = 0; i < 12; ++i)
			{
				layer2Step2 (si, i >> 2, fraction);
				for (int j = 0; j < 3; ++j)
					synthesise (fraction[single][j], 0, pcm0, samplesDone);
			}
		}
		else
		{
			for (int i = 0; i < 12; ++i)
			{
				layer2Step2 (si, i >> 2, fraction);
				for (int j = 0; j < 3; ++j)
					synthesiseStereo (fraction[0][j], fraction[1][j], pcm0, pcm1, samplesDone);
			}
		}
	}

	void decodeLayer3Frame (float* const pcm0, float* const pcm1, int& samplesDone) noexcept
	{
		if (! rollBackBufferPointer ((int) sideinfo.mainDataStart))
			return;

		const int single = frame.numChannels == 1 ? 0 : frame.single;
		const int numChans = (frame.numChannels == 1 || single >= 0) ? 1 : 2;
		const bool msStereo = (frame.mode == 1) && (frame.modeExt & 2) != 0;
		const bool iStereo  = (frame.mode == 1) && (frame.modeExt & 1) != 0;
		const int granules = frame.lsf ? 1 : 2;
		int scaleFactors[2][39];

		for (int gr = 0; gr < granules; ++gr)
		{
			{
				Layer3SideInfo::Info& granule = sideinfo.ch[0].gr[gr];
				const int part2bits = frame.lsf ? getLayer3ScaleFactors2 (scaleFactors[0], granule, 0)
												: getLayer3ScaleFactors1 (scaleFactors[0], granule);

				if (layer3DequantizeSample (hybridIn[0], scaleFactors[0], granule, frame.sampleRateIndex, part2bits))
					return;
			}

			if (frame.numChannels == 2)
			{
				Layer3SideInfo::Info& granule = sideinfo.ch[1].gr[gr];
				const int part2bits = frame.lsf ? getLayer3ScaleFactors2 (scaleFactors[1], granule, iStereo)
												: getLayer3ScaleFactors1 (scaleFactors[1], granule);

				if (layer3DequantizeSample (hybridIn[1], scaleFactors[1], granule, frame.sampleRateIndex, part2bits))
					return;

				if (msStereo)
				{
					for (int i = 0; i < 32 * 18; ++i)
					{
						const float tmp0 = ((const float*) hybridIn[0]) [i];
						const float tmp1 = ((const float*) hybridIn[1]) [i];
						((float*) hybridIn[1]) [i] = tmp0 - tmp1;
						((float*) hybridIn[0]) [i] = tmp0 + tmp1;
					}
				}

				if (iStereo)
					granule.doIStereo (hybridIn, scaleFactors[1], frame.sampleRateIndex, msStereo, frame.lsf);

				if (msStereo || iStereo || single == 3)
				{
					if (granule.maxb > sideinfo.ch[0].gr[gr].maxb)
						sideinfo.ch[0].gr[gr].maxb = granule.maxb;
					else
						granule.maxb = sideinfo.ch[0].gr[gr].maxb;
				}

				switch (single)
				{
					case 3:
					{
						float* in0 = (float*) hybridIn[0];
						const float* in1 = (const float*) hybridIn[1];
						for (int i = 0; i < (int) (18 * granule.maxb); ++i, ++in0)
							*in0 = (*in0 + *in1++);
					}
					break;

					case 1:
					{
						float* in0 = (float*) hybridIn[0];
						const float* in1 = (const float*) hybridIn[1];
						for (int i = 0; i < (int) (18 * granule.maxb); ++i)
							*in0++ = *in1++;
					}
					break;
				}
			}

			for (int ch = 0; ch < numChans; ++ch)
			{
				const Layer3SideInfo::Info& granule = sideinfo.ch[ch].gr[gr];
				granule.doAntialias (hybridIn[ch]);
				layer3Hybrid (hybridIn[ch], hybridOut[ch], ch, granule);
			}

			for (int ss = 0; ss < 18; ++ss)
			{
				if (single >= 0)
					synthesise (hybridOut[0][ss], 0, pcm0, samplesDone);
				else
					synthesiseStereo (hybridOut[0][ss], hybridOut[1][ss], pcm0, pcm1, samplesDone);
			}
		}
	}

	int decodeLayer3SideInfo() noexcept
	{
		const int numChannels = frame.numChannels;
		const int sampleRate = frame.sampleRateIndex;
		const int single = (numChannels == 1) ? 0 : frame.single;
		const bool msStereo = (frame.mode == 1) && (frame.modeExt & 2) != 0;
		const int granules = frame.lsf ? 1 : 2;

		if (frame.lsf == 0)
			getLayer3SideInfo1 (numChannels, msStereo, sampleRate, single);
		else
			getLayer3SideInfo2 (numChannels, msStereo, sampleRate, single);

		int databits = 0;
		for (int gr = 0; gr < granules; ++gr)
			for (int ch = 0; ch < numChannels; ++ch)
				databits += sideinfo.ch[ch].gr[gr].part2_3Length;

		return databits - 8 * sideinfo.mainDataStart;
	}

	void layer1Step1 (SideInfoLayer1& si) noexcept
	{
		zerostruct (si);
		int i, jsbound = (frame.mode == 1) ? (frame.modeExt << 2) + 4 : 32;

		if (frame.numChannels == 2)
		{
			for (i = 0; i < jsbound; ++i)
			{
				si.allocation[i][0] = getBitsUint8 (4);
				si.allocation[i][1] = getBitsUint8 (4);
			}

			for (i = jsbound; i < 32; ++i)
				si.allocation[i][0] = si.allocation[i][1] = getBitsUint8 (4);

			for (i = 0; i < 32; ++i)
			{
				si.scaleFactor[i][0] = si.allocation[i][0] ? getBitsUint8 (6) : 0;
				si.scaleFactor[i][1] = si.allocation[i][1] ? getBitsUint8 (6) : 0;
			}
		}
		else
		{
			for (i = 0; i < 32; ++i)
				si.allocation[i][0] = getBitsUint8 (4);

			for (i = 0; i < 32; ++i)
				si.scaleFactor[i][0] = si.allocation[i][0] ? getBitsUint8 (6) : 0;
		}
	}

	void layer1Step2 (SideInfoLayer1& si, float fraction[2][32]) noexcept
	{
		if (frame.numChannels == 2)
		{
			int i, jsbound = (frame.mode == 1) ? (frame.modeExt << 2) + 4 : 32;

			for (i = 0; i < jsbound; ++i)
			{
				const uint8 n0 = si.allocation[i][0];
				const uint8 n1 = si.allocation[i][1];
				fraction[0][i] = n0 > 0 ? (float) (((-1 << n0) + getBitsUint16 (n0 + 1) + 1) * constants.muls[n0 + 1][si.scaleFactor[i][0]]) : 0;
				fraction[1][i] = n1 > 0 ? (float) (((-1 << n1) + getBitsUint16 (n1 + 1) + 1) * constants.muls[n1 + 1][si.scaleFactor[i][1]]) : 0;
			}

			for (i = jsbound; i < 32; ++i)
			{
				const uint8 n = si.allocation[i][0];

				if (n > 0)
				{
					const uint32 w = ((-1 << n) + getBitsUint16 (n + 1) + 1);
					fraction[0][i] = (float) (w * constants.muls[n + 1][si.scaleFactor[i][0]]);
					fraction[1][i] = (float) (w * constants.muls[n + 1][si.scaleFactor[i][1]]);
				}
				else
					fraction[0][i] = fraction[1][i] = 0;
			}
		}
		else
		{
			for (int i = 0; i < 32; ++i)
			{
				const uint8 n = si.allocation[i][0];
				const uint8 j = si.scaleFactor[i][0];

				if (n > 0)
					fraction[0][i] = (float) (((-1 << n) + getBitsUint16 (n + 1) + 1) * constants.muls[n + 1][j]);
				else
					fraction[0][i] = 0;
			}
		}
	}

	void layer2Step1 (SideInfoLayer2& si) noexcept
	{
		zerostruct (si);
		const int sblimit = frame.layer2SubBandLimit;
		const int jsbound = (frame.mode == 1) ? (frame.modeExt << 2) + 4 : frame.layer2SubBandLimit;
		const AllocationTable* allocTable = frame.allocationTable;
		uint8 scfsi[32][2];
		int i;

		if (frame.numChannels == 2)
		{
			for (i = 0; i < jsbound; ++i)
			{
				const int16 step = allocTable->bits;
				allocTable += (1 << step);
				si.allocation[i][0] = getBitsUint8 (step);
				si.allocation[i][1] = getBitsUint8 (step);
			}

			for (i = jsbound; i < sblimit; ++i)
			{
				const int16 step = allocTable->bits;
				const uint8 b0 = getBitsUint8 (step);
				allocTable += (1 << step);
				si.allocation[i][0] = b0;
				si.allocation[i][1] = b0;
			}

			for (i = 0; i < sblimit; ++i)
			{
				scfsi[i][0] = si.allocation[i][0] ? getBitsUint8 (2) : 0;
				scfsi[i][1] = si.allocation[i][1] ? getBitsUint8 (2) : 0;
			}
		}
		else
		{
			for (i = 0; i < sblimit; ++i)
			{
				const int16 step = allocTable->bits;
				allocTable += (1 << step);
				si.allocation[i][0] = getBitsUint8 (step);
			}

			for (i = 0; i < sblimit; ++i)
				scfsi[i][0] = si.allocation[i][0] ? getBitsUint8 (2) : 0;
		}

		for (i = 0; i < sblimit; ++i)
		{
			for (int ch = 0; ch < frame.numChannels; ++ch)
			{
				uint8 s0 = 0, s1 = 0, s2 = 0;

				if (si.allocation[i][ch])
				{
					switch (scfsi[i][ch])
					{
						case 0:
							s0 = getBitsUint8 (6);
							s1 = getBitsUint8 (6);
							s2 = getBitsUint8 (6);
							break;
						case 1:
							s1 = s0 = getBitsUint8 (6);
							s2 = getBitsUint8 (6);
							break;
						case 2:
							s2 = s1 = s0 = getBitsUint8 (6);
							break;
						case 3:
							s0 = getBitsUint8 (6);
							s2 = s1 = getBitsUint8 (6);
							break;
						default:
							break;
					}
				}

				si.scaleFactor[i][ch][0] = s0;
				si.scaleFactor[i][ch][1] = s1;
				si.scaleFactor[i][ch][2] = s2;
			}
		}
	}

	void layer2Step2 (SideInfoLayer2& si, const int gr, float fraction[2][4][32]) noexcept
	{
		const AllocationTable* allocTable = frame.allocationTable;
		const int jsbound = (frame.mode == 1) ? (frame.modeExt << 2) + 4 : frame.layer2SubBandLimit;
		int i;

		for (i = 0; i < jsbound; ++i)
		{
			const int16 step = allocTable->bits;

			for (int ch = 0; ch < frame.numChannels; ++ch)
			{
				const uint8 ba = si.allocation[i][ch];
				if (ba != 0)
				{
					const uint8 x1 = jmin ((uint8) 63, si.scaleFactor[i][ch][gr]);
					const AllocationTable* const alloc2 = allocTable + ba;
					const int16 k = jmin ((int16) 16, alloc2->bits);
					const int16 d1 = alloc2->d;

					if (d1 < 0)
					{
						const double cm = constants.muls[k][x1];
						fraction[ch][0][i] = (float) ((getBits (k) + d1) * cm);
						fraction[ch][1][i] = (float) ((getBits (k) + d1) * cm);
						fraction[ch][2][i] = (float) ((getBits (k) + d1) * cm);
					}
					else
					{
						const uint8* const tab = constants.getGroupTable (d1, getBits (k));
						fraction[ch][0][i] = (float) constants.muls[tab[0]][x1];
						fraction[ch][1][i] = (float) constants.muls[tab[1]][x1];
						fraction[ch][2][i] = (float) constants.muls[tab[2]][x1];
					}
				}
				else
				{
					fraction[ch][0][i] = fraction[ch][1][i] = fraction[ch][2][i] = 0;
				}
			}

			allocTable += (1 << step);
		}

		for (i = jsbound; i < frame.layer2SubBandLimit; ++i)
		{
			const int16 step = allocTable->bits;
			const uint8 ba = si.allocation[i][0];

			if (ba != 0)
			{
				const AllocationTable* const alloc2 = allocTable + ba;
				int16 k = alloc2->bits;
				int16 d1 = alloc2->d;
				k = (k <= 16) ? k : 16;

				if (d1 < 0)
				{
					const int v0 = getBits (k);
					const int v1 = getBits (k);
					const int v2 = getBits (k);

					for (int ch = 0; ch < frame.numChannels; ++ch)
					{
						const uint8 x1 = jmin ((uint8) 63, si.scaleFactor[i][ch][gr]);
						const double cm = constants.muls[k][x1];
						fraction[ch][0][i] = (float) ((v0 + d1) * cm);
						fraction[ch][1][i] = (float) ((v1 + d1) * cm);
						fraction[ch][2][i] = (float) ((v2 + d1) * cm);
					}
				}
				else
				{
					const uint8* const tab = constants.getGroupTable (d1, getBits (k));
					const uint8 k0 = tab[0];
					const uint8 k1 = tab[1];
					const uint8 k2 = tab[2];

					for (int ch = 0; ch < frame.numChannels; ++ch)
					{
						const uint8 x1 = jmin ((uint8) 63, si.scaleFactor[i][ch][gr]);
						fraction[ch][0][i] = (float) constants.muls[k0][x1];
						fraction[ch][1][i] = (float) constants.muls[k1][x1];
						fraction[ch][2][i] = (float) constants.muls[k2][x1];
					}
				}
			}
			else
			{
				fraction[0][0][i] = fraction[0][1][i] = fraction[0][2][i] = 0;
				fraction[1][0][i] = fraction[1][1][i] = fraction[1][2][i] = 0;
			}
			allocTable += (1 << step);
		}

		for (int ch = 0; ch < frame.numChannels; ++ch)
			for (i = frame.layer2SubBandLimit; i < 32; ++i)
				fraction[ch][0][i] = fraction[ch][1][i] = fraction[ch][2][i] = 0;
	}

	void getLayer3SideInfo1 (const int stereo, const bool msStereo, const int sampleRate, const int single) noexcept
	{
		const int powdiff = (single == 3) ? 4 : 0;
		sideinfo.mainDataStart = getBits (9);
		sideinfo.privateBits = getBitsUnchecked (stereo == 1 ? 5 : 3);

		for (int ch = 0; ch < stereo; ++ch)
		{
			sideinfo.ch[ch].gr[0].scfsi = -1;
			sideinfo.ch[ch].gr[1].scfsi = getBitsUnchecked (4);
		}

		for (int gr = 0; gr < 2; ++gr)
		{
			for (int ch = 0; ch < stereo; ++ch)
			{
				Layer3SideInfo::Info& granule = sideinfo.ch[ch].gr[gr];

				granule.part2_3Length = getBits (12);
				granule.bigValues = jmin (288, (int) getBitsUnchecked (9));

				const int qss = getBitsUnchecked (8);
				granule.pow2gain = constants.powToGains + 256 - qss + powdiff;

				if (msStereo)
					granule.pow2gain += 2;

				granule.scaleFactorCompression = getBitsUnchecked (4);

				if (getOneBit())
				{
					granule.blockType = getBitsUnchecked (2);
					granule.mixedBlockFlag = getOneBit();
					granule.tableSelect[0] = getBitsUnchecked (5);
					granule.tableSelect[1] = getBitsUnchecked (5);
					granule.tableSelect[2] = 0;

					for (int i = 0; i < 3; ++i)
					{
						const int sbg = (getBitsUnchecked (3) << 3);
						granule.fullGain[i] = granule.pow2gain + sbg;
					}

					granule.region1Start = 36 >> 1;
					granule.region2Start = 576 >> 1;
				}
				else
				{
					for (int i = 0; i < 3; ++i)
						granule.tableSelect[i] = getBitsUnchecked (5);

					const int r0c = getBitsUnchecked (4);
					const int r1c = getBitsUnchecked (3);
					const int region0index = jmin (22, r0c + 1);
					const int region1index = jmin (22, r0c + 1 + r1c + 1);

					granule.region1Start = bandInfo[sampleRate].longIndex[region0index] >> 1;
					granule.region2Start = bandInfo[sampleRate].longIndex[region1index] >> 1;
					granule.blockType = 0;
					granule.mixedBlockFlag = 0;
				}

				granule.preflag = getOneBit();
				granule.scaleFactorScale = getOneBit();
				granule.count1TableSelect = getOneBit();
			}
		}
	}

	void getLayer3SideInfo2 (const int stereo, const bool msStereo, const int sampleRate, const int single) noexcept
	{
		const int powdiff = (single == 3) ? 4 : 0;
		sideinfo.mainDataStart = getBits (8);
		sideinfo.privateBits = stereo == 1 ? getOneBit() : getBitsUnchecked (2);

		for (int ch = 0; ch < stereo; ++ch)
		{
			Layer3SideInfo::Info& granule = sideinfo.ch[ch].gr[0];

			granule.part2_3Length = getBits (12);
			granule.bigValues = jmin (288, (int) getBitsUnchecked (9));

			const uint32 qss = getBitsUnchecked (8);
			granule.pow2gain = constants.powToGains + 256 - qss + powdiff;

			if (msStereo)
				granule.pow2gain += 2;

			granule.scaleFactorCompression = getBits (9);

			if (getOneBit())
			{
				granule.blockType = getBitsUnchecked (2);
				granule.mixedBlockFlag = getOneBit();
				granule.tableSelect[0] = getBitsUnchecked (5);
				granule.tableSelect[1] = getBitsUnchecked (5);
				granule.tableSelect[2] = 0;

				for (int i = 0; i < 3; ++i)
				{
					const uint32 sbg = (getBitsUnchecked (3) << 3);
					granule.fullGain[i] = granule.pow2gain + sbg;
				}

				if (granule.blockType == 0)
				{}

				if (granule.blockType == 2)
					granule.region1Start = sampleRate == 8 ? 36 : (36 >> 1);
				else
					granule.region1Start = sampleRate == 8 ? (108 >> 1) : (54 >> 1);

				granule.region2Start = 576 >> 1;
			}
			else
			{
				for (int i = 0; i < 3; ++i)
					granule.tableSelect[i] = getBitsUnchecked (5);

				const int r0c = getBitsUnchecked (4);
				const int r1c = getBitsUnchecked (3);
				const int region0index = jmin (22, r0c + 1);
				const int region1index = jmin (22, r0c + 1 + r1c + 1);

				granule.region1Start = bandInfo[sampleRate].longIndex[region0index] >> 1;
				granule.region2Start = bandInfo[sampleRate].longIndex[region1index] >> 1;
				granule.blockType = 0;
				granule.mixedBlockFlag = 0;
			}
			granule.scaleFactorScale = getOneBit();
			granule.count1TableSelect = getOneBit();
		}
	}

	int getLayer3ScaleFactors1 (int* scf, const Layer3SideInfo::Info& granule) noexcept
	{
		static const uint8 lengths[2][16] =
		{
			{ 0, 0, 0, 0, 3, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4 },
			{ 0, 1, 2, 3, 0, 1, 2, 3, 1, 2, 3, 1, 2, 3, 2, 3 }
		};

		int numBits;
		const int num0 = lengths[0][granule.scaleFactorCompression];
		const int num1 = lengths[1][granule.scaleFactorCompression];

		if (granule.blockType == 2)
		{
			int i = 18;
			numBits = (num0 + num1) * 18;

			if (granule.mixedBlockFlag)
			{
				for (int j = 8; --j >= 0;)  *scf++ = getBitsUnchecked (num0);
				numBits -= num0;
				i = 9;
			}

			for (; --i >= 0;)       *scf++ = getBitsUnchecked (num0);
			for (i = 18; --i >= 0;) *scf++ = getBitsUnchecked (num1);

			*scf++ = 0;
			*scf++ = 0;
			*scf++ = 0;
		}
		else
		{
			const int scfsi = granule.scfsi;

			if (scfsi < 0)
			{
				for (int i = 11; --i >= 0;)   *scf++ = getBitsUnchecked (num0);
				for (int j = 10; --j >= 0;)   *scf++ = getBitsUnchecked (num1);
				numBits = (num0 + num1) * 10 + num0;
			}
			else
			{
				numBits = 0;
				if ((scfsi & 8) == 0)
				{
					for (int i = 6; --i >= 0;)  *scf++ = getBitsUnchecked (num0);
					numBits += num0 * 6;
				}
				else
					scf += 6;

				if ((scfsi & 4) == 0)
				{
					for (int i = 5; --i >= 0;)  *scf++ = getBitsUnchecked (num0);
					numBits += num0 * 5;
				}
				else
					scf += 5;

				if ((scfsi & 2) == 0)
				{
					for (int i = 5; --i >= 0;)  *scf++ = getBitsUnchecked (num1);
					numBits += num1 * 5;
				}
				else
					scf += 5;

				if ((scfsi & 1) == 0)
				{
					for (int i = 5; --i >= 0;)  *scf++ = getBitsUnchecked (num1);
					numBits += num1 * 5;
				}
				else
					scf += 5;
			}

			*scf = 0;
		}

		return numBits;
	}

	int getLayer3ScaleFactors2 (int* scf, Layer3SideInfo::Info& granule, const bool iStereo) noexcept
	{
		static const uint8 scaleTable[3][6][4] =
		{
			{ { 6, 5, 5, 5 }, { 6, 5, 7, 3 },  { 11, 10, 0, 0 }, { 7, 7, 7, 0 },    { 6, 6, 6, 3 },  { 8, 8, 5, 0 } },
			{ { 9, 9, 9, 9 }, { 9, 9, 12, 6 }, { 18, 18, 0, 0 }, { 12, 12, 12, 0 }, { 12, 9, 9, 6 }, { 15, 12, 9, 0 } },
			{ { 6, 9, 9, 9 }, { 6, 9, 12, 6 }, { 15, 18, 0, 0 }, { 6, 15, 12, 0 },  { 6, 12, 9, 6 }, { 6, 18, 9, 0 } }
		};

		uint32 len = iStereo ? constants.iLength2 [granule.scaleFactorCompression >> 1]
							 : constants.nLength2 [granule.scaleFactorCompression];

		granule.preflag = (len >> 15) & 1;

		int n = 0;
		if (granule.blockType == 2)
		{
			++n;
			if (granule.mixedBlockFlag)
				++n;
		}

		const uint8* const data = scaleTable[n][(len >> 12) & 7];
		int i, numBits = 0;

		for (i = 0; i < 4; ++i)
		{
			int num = len & 7;
			len >>= 3;

			if (num)
			{
				for (int j = 0; j < (int) (data[i]); ++j)
					*scf++ = getBitsUnchecked (num);

				numBits += data[i] * num;
			}
			else
			{
				for (int j = 0; j < (int) (data[i]); ++j)
					*scf++ = 0;
			}
		}

		n = (n << 1) + 1;
		for (i = 0; i < n; ++i)
			*scf++ = 0;

		return numBits;
	}

	bool layer3DequantizeSample (float xr[32][18], int* scf, Layer3SideInfo::Info& granule, int sampleRate, int part2bits) noexcept
	{
		const int shift = 1 + granule.scaleFactorScale;
		float* xrpnt = (float*) xr;
		int i, part2remain = granule.part2_3Length - part2bits;

		zeromem (xrpnt, sizeof (float) * (&xr[32][0] - xrpnt));

		const int bv = granule.bigValues;
		const int region1 = granule.region1Start;
		const int region2 = granule.region2Start;
		int l3 = ((576 >> 1) - bv) >> 1;
		int l[3];

		if (bv <= region1)
		{
			l[0] = bv;
			l[1] = 0;
			l[2] = 0;
		}
		else
		{
			l[0] = region1;
			if (bv <= region2)
			{
				l[1] = bv - l[0];
				l[2] = 0;
			}
			else
			{
				l[1] = region2 - l[0];
				l[2] = bv - region2;
			}
		}

		for (i = 0; i < 3; ++i)
			if (l[i] < 0)
				l[i] = 0;

		if (granule.blockType == 2)
		{
			int max[4];
			int step = 0, lwin = 0, cb = 0, mc = 0;
			float v = 0;
			int* map;
			int* mapEnd;

			if (granule.mixedBlockFlag)
			{
				max[3] = -1;
				max[0] = max[1] = max[2] = 2;
				map = constants.map [sampleRate][0];
				mapEnd = constants.mapEnd [sampleRate][0];
			}
			else
			{
				max[0] = max[1] = max[2] = max[3] = -1;
				map = constants.map [sampleRate][1];
				mapEnd = constants.mapEnd [sampleRate][1];
			}

			for (i = 0; i < 2; ++i)
			{
				const BitsToTableMap* h = huffmanTables1 + granule.tableSelect[i];

				for (int lp = l[i]; lp != 0; --lp, --mc)
				{
					int x, y;
					if (mc == 0)
					{
						mc = *map++;
						xrpnt = ((float*) xr) + (*map++);
						lwin = *map++;
						cb = *map++;

						if (lwin == 3)
						{
							v = granule.pow2gain[ (*scf++) << shift];
							step = 1;
						}
						else
						{
							v = granule.fullGain[lwin][ (*scf++) << shift];
							step = 3;
						}
					}

					const int16* val = h->table;

					while ((y = *val++) < 0)
					{
						if (getOneBit())
							val -= y;

						--part2remain;
					}

					x = y >> 4;
					y &= 15;

					if (x == 15)
					{
						max[lwin] = cb;
						part2remain -= h->bits + 1;
						x += getBits ((int) h->bits);
						*xrpnt = constants.nToThe4Over3[x] * (getOneBit() ? -v : v);
					}
					else if (x)
					{
						max[lwin] = cb;
						*xrpnt = constants.nToThe4Over3[x] * (getOneBit() ? -v : v);
						--part2remain;
					}
					else
						*xrpnt = 0;

					xrpnt += step;

					if (y == 15)
					{
						max[lwin] = cb;
						part2remain -= h->bits + 1;
						y += getBits ((int) h->bits);
						*xrpnt = constants.nToThe4Over3[y] * (getOneBit() ? -v : v);
					}
					else if (y)
					{
						max[lwin] = cb;
						*xrpnt = constants.nToThe4Over3[y] * (getOneBit() ? -v : v);
						--part2remain;
					}
					else
						*xrpnt = 0;

					xrpnt += step;
				}
			}

			for (; l3 && (part2remain > 0); --l3)
			{
				const BitsToTableMap* h = huffmanTables2 + granule.count1TableSelect;
				const int16* val = h->table;
				int16 a;

				while ((a = *val++) < 0)
				{
					if (part2remain <= 0)
					{
						a = 0;
						break;
					}

					--part2remain;
					if (getOneBit())
						val -= a;
				}

				for (i = 0; i < 4; ++i)
				{
					if ((i & 1) == 0)
					{
						if (mc == 0)
						{
							mc = *map++;
							xrpnt = ((float*) xr) + (*map++);
							lwin = *map++;
							cb = *map++;

							if (lwin == 3)
							{
								v = granule.pow2gain[ (*scf++) << shift];
								step = 1;
							}
							else
							{
								v = granule.fullGain[lwin][ (*scf++) << shift];
								step = 3;
							}
						}

						--mc;
					}

					if ((a & (8 >> i)))
					{
						max[lwin] = cb;
						if (part2remain == 0)
							break;

						--part2remain;
						*xrpnt = getOneBit() ? -v : v;
					}
					else
						*xrpnt = 0;

					xrpnt += step;
				}
			}

			while (map < mapEnd)
			{
				if (mc == 0)
				{
					mc = *map++;
					xrpnt = ((float*) xr) + *map++;
					step = (*map++ == 3) ? 1 : 3;
					++map;
				}

				--mc;
				*xrpnt = 0;  xrpnt += step;
				*xrpnt = 0;  xrpnt += step;
			}

			granule.maxBand[0] = max[0] + 1;
			granule.maxBand[1] = max[1] + 1;
			granule.maxBand[2] = max[2] + 1;
			granule.maxBandl   = max[3] + 1;

			const int rmax = jmax (max[0], max[1], max[3]) + 1;
			granule.maxb = rmax ? constants.shortLimit[sampleRate][rmax]
								: constants.longLimit[sampleRate][max[3] + 1];
		}
		else
		{
			static const int pretab1[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 3, 3, 3, 2, 0 };
			static const int pretab2[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };

			const int* pretab = (const int*) (granule.preflag ? pretab1 : pretab2);
			int i, max = -1, cb = 0, mc = 0;
			int* map = constants.map [sampleRate][2];
			float v = 0;

			for (i = 0; i < 3; ++i)
			{
				const BitsToTableMap* h = huffmanTables1 + granule.tableSelect[i];

				for (int lp = l[i]; lp != 0; --lp, --mc)
				{
					if (mc == 0)
					{
						mc = *map++;
						v = granule.pow2gain [((*scf++) + (*pretab++)) << shift];
						cb = *map++;
					}

					const int16* val = h->table;
					int y;

					while ((y = *val++) < 0)
					{
						if (getOneBit()) val -= y;
						--part2remain;
					}

					int x = y >> 4;
					y &= 15;

					if (x == 15)
					{
						max = cb;
						part2remain -= h->bits + 1;
						x += getBits ((int) h->bits);
						*xrpnt++ = constants.nToThe4Over3[x] * (getOneBit() ? -v : v);
					}
					else if (x)
					{
						max = cb;
						*xrpnt++ = constants.nToThe4Over3[x] * (getOneBit() ? -v : v);
						--part2remain;
					}
					else
						*xrpnt++ = 0;

					if (y == 15)
					{
						max = cb;
						part2remain -= h->bits + 1;
						y += getBits ((int) h->bits);
						*xrpnt++ = constants.nToThe4Over3[y] * (getOneBit() ? -v : v);
					}
					else if (y)
					{
						max = cb;
						*xrpnt++ = constants.nToThe4Over3[y] * (getOneBit() ? -v : v);
						--part2remain;
					}
					else
						*xrpnt++ = 0;
				}
			}

			for (; l3 && part2remain > 0; --l3)
			{
				const BitsToTableMap* h = huffmanTables2 + granule.count1TableSelect;
				const int16* values = h->table;
				int16 a;

				while ((a = *values++) < 0)
				{
					if (part2remain <= 0)
					{
						a = 0;
						break;
					}

					--part2remain;
					if (getOneBit())
						values -= a;
				}

				for (i = 0; i < 4; ++i)
				{
					if ((i & 1) == 0)
					{
						if (mc == 0)
						{
							mc = *map++;
							cb = *map++;
							v = granule.pow2gain [((*scf++) + (*pretab++)) << shift];
						}
						--mc;
					}

					if ((a & (0x8 >> i)))
					{
						max = cb;

						if (part2remain <= 0)
							break;

						--part2remain;
						*xrpnt++ = getOneBit() ? -v : v;
					}
					else
						*xrpnt++ = 0;
				}
			}

			zeromem (xrpnt, sizeof (float) * (&xr[32][0] - xrpnt));

			granule.maxBandl = max + 1;
			granule.maxb = constants.longLimit[sampleRate][granule.maxBandl];
		}

		while (part2remain > 16)
		{
			getBits (16);
			part2remain -= 16;
		}

		if (part2remain > 0)
			getBits (part2remain);
		else if (part2remain < 0)
			return true;

		return false;
	}

	void layer3Hybrid (float fsIn[32][18], float tsOut[18][32], int ch, const Layer3SideInfo::Info& granule) noexcept
	{
		float* ts = (float*) tsOut;
		float* rawout1, *rawout2;
		int sb = 0;

		{
			int b = hybridBlockIndex[ch];
			rawout1 = hybridBlock[b][ch];
			b = 1 - b;
			rawout2 = hybridBlock[b][ch];
			hybridBlockIndex[ch] = b;
		}

		if (granule.mixedBlockFlag)
		{
			sb = 2;
			DCT::dct36 (fsIn[0], rawout1, rawout2, constants.win[0], ts);
			DCT::dct36 (fsIn[1], rawout1 + 18, rawout2 + 18, constants.win1[0], ts + 1);
			rawout1 += 36;
			rawout2 += 36;
			ts += 2;
		}

		int bt = granule.blockType;
		if (bt == 2)
		{
			for (; sb < (int) granule.maxb; sb += 2, ts += 2, rawout1 += 36, rawout2 += 36)
			{
				DCT::dct12 (fsIn[sb], rawout1, rawout2, constants.win[2], ts);
				DCT::dct12 (fsIn[sb + 1], rawout1 + 18, rawout2 + 18, constants.win1[2], ts + 1);
			}
		}
		else
		{
			for (; sb < (int) granule.maxb; sb += 2, ts += 2, rawout1 += 36, rawout2 += 36)
			{
				DCT::dct36 (fsIn[sb], rawout1, rawout2, constants.win[bt], ts);
				DCT::dct36 (fsIn[sb + 1], rawout1 + 18, rawout2 + 18, constants.win1[bt], ts + 1);
			}
		}

		for (; sb < 32; ++sb, ++ts)
		{
			for (int i = 0; i < 18; ++i)
			{
				ts[i * 32] = *rawout1++;
				*rawout2++ = 0;
			}
		}
	}

	void synthesiseStereo (const float* bandPtr0, const float* bandPtr1, float* out0, float* out1, int& samplesDone) noexcept
	{
		int dummy = samplesDone;
		synthesise (bandPtr0, 0, out0, dummy);
		synthesise (bandPtr1, 1, out1, samplesDone);
	}

	void synthesise (const float* bandPtr, const int channel, float* out, int& samplesDone)
	{
		out += samplesDone;
		const int bo = channel == 0 ? ((synthBo - 1) & 15) : synthBo;
		float (*buf)[0x110] = synthBuffers[channel];
		float* b0;
		int j, bo1 = bo;

		if (bo & 1)
		{
			b0 = buf[0];
			DCT::dct64 (buf[1] + ((bo + 1) & 15), buf[0] + bo, bandPtr);
		}
		else
		{
			++bo1;
			b0 = buf[1];
			DCT::dct64 (buf[0] + bo, buf[1] + bo1, bandPtr);
		}

		synthBo = bo;
		const float* window = constants.decodeWin + 16 - bo1;

		for (j = 16; j != 0; --j, b0 += 16, window += 32)
		{
			float sum = window[0] * b0[0];  sum -= window[1] * b0[1];
			sum += window[2]  * b0[2];   sum -= window[3]  * b0[3];
			sum += window[4]  * b0[4];   sum -= window[5]  * b0[5];
			sum += window[6]  * b0[6];   sum -= window[7]  * b0[7];
			sum += window[8]  * b0[8];   sum -= window[9]  * b0[9];
			sum += window[10] * b0[10];  sum -= window[11] * b0[11];
			sum += window[12] * b0[12];  sum -= window[13] * b0[13];
			sum += window[14] * b0[14];  sum -= window[15] * b0[15];
			*out++ = sum;
		}

		{
			float sum = window[0] * b0[0];   sum += window[2] * b0[2];
			sum += window[4]  * b0[4];   sum += window[6]  * b0[6];
			sum += window[8]  * b0[8];   sum += window[10] * b0[10];
			sum += window[12] * b0[12];  sum += window[14] * b0[14];
			*out++ = sum;
			b0 -= 16; window -= 32;
			window += bo1 << 1;
		}

		for (j = 15; j != 0; --j, b0 -= 16, window -= 32)
		{
			float sum = -window[-1] * b0[0];  sum -= window[-2] * b0[1];
			sum -= window[-3]  * b0[2];   sum -= window[-4]  * b0[3];
			sum -= window[-5]  * b0[4];   sum -= window[-6]  * b0[5];
			sum -= window[-7]  * b0[6];   sum -= window[-8]  * b0[7];
			sum -= window[-9]  * b0[8];   sum -= window[-10] * b0[9];
			sum -= window[-11] * b0[10];  sum -= window[-12] * b0[11];
			sum -= window[-13] * b0[12];  sum -= window[-14] * b0[13];
			sum -= window[-15] * b0[14];  sum -= window[0]   * b0[15];
			*out++ = sum;
		}

		samplesDone += 32;
	}

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (MP3Stream);
};

static const char* const mp3FormatName = "MP3 file";
static const char* const mp3Extensions[] = { ".mp3", nullptr };

class MP3Reader : public AudioFormatReader
{
public:
	MP3Reader (InputStream* const in)
		: AudioFormatReader (in, TRANS (mp3FormatName)),
		  stream (*in), currentPosition (0),
		  decodedStart (0), decodedEnd (0)
	{
		skipID3();
		const int64 streamPos = stream.stream.getPosition();

		if (readNextBlock())
		{
			bitsPerSample = 32;
			usesFloatingPointData = true;
			sampleRate = stream.frame.getFrequency();
			numChannels = stream.frame.numChannels;
			lengthInSamples = findLength (streamPos);
		}
	}

	bool readSamples (int** destSamples, int numDestChannels, int startOffsetInDestBuffer,
					  int64 startSampleInFile, int numSamples)
	{
		jassert (destSamples != nullptr);

		if (currentPosition != startSampleInFile)
		{
			if (! stream.seek (startSampleInFile / 1152 - 1))
			{
				currentPosition = -1;
				createEmptyDecodedData();
			}
			else
			{
				decodedStart = decodedEnd = 0;
				const int64 streamPos = stream.currentFrameIndex * 1152;
				int toSkip = startSampleInFile - streamPos;
				jassert (toSkip >= 0);

				while (toSkip > 0)
				{
					if (! readNextBlock())
					{
						createEmptyDecodedData();
						break;
					}

					const int numReady = decodedEnd - decodedStart;

					if (numReady > toSkip)
					{
						decodedStart += toSkip;
						break;
					}

					toSkip -= numReady;
				}

				currentPosition = startSampleInFile;
			}
		}

		while (numSamples > 0)
		{
			if (decodedEnd <= decodedStart && ! readNextBlock())
			{
				for (int i = 2; --i >= 0;)
					if (destSamples[i] != nullptr)
						zeromem (destSamples[i] + startOffsetInDestBuffer, sizeof (float) * numSamples);

				return false;
			}

			const int numToCopy = jmin (decodedEnd - decodedStart, numSamples);
			float* const* const dst = reinterpret_cast <float**> (destSamples);
			memcpy (dst[0] + startOffsetInDestBuffer, decoded0 + decodedStart, sizeof (float) * numToCopy);

			if (dst[1] != nullptr)
				memcpy (dst[1] + startOffsetInDestBuffer, (numChannels < 2 ? decoded0 : decoded1) + decodedStart, sizeof (float) * numToCopy);

			startOffsetInDestBuffer += numToCopy;
			decodedStart += numToCopy;
			currentPosition += numToCopy;
			numSamples -= numToCopy;
		}

		return true;
	}

private:
	MP3Stream stream;
	int64 currentPosition;
	enum { decodedDataSize = 1152 };
	float decoded0 [decodedDataSize], decoded1 [decodedDataSize];
	int decodedStart, decodedEnd;

	void createEmptyDecodedData() noexcept
	{
		zeromem (decoded0, sizeof (decoded0));
		zeromem (decoded1, sizeof (decoded1));
		decodedStart = 0;
		decodedEnd = decodedDataSize;
	}

	bool readNextBlock()
	{
		for (int attempts = 10; --attempts >= 0;)
		{
			int samplesDone = 0;
			const int result = stream.decodeNextBlock (decoded0, decoded1, samplesDone);

			if (result > 0 && stream.stream.isExhausted())
			{
				createEmptyDecodedData();
				return true;
			}
			else if (result <= 0)
			{
				decodedStart = 0;
				decodedEnd = samplesDone;
				return result == 0;
			}
		}

		return false;
	}

	void skipID3()
	{
		const int64 originalPosition = stream.stream.getPosition();
		const uint32 firstWord = stream.stream.readInt();

		if ((firstWord & 0xffffff) == 0x334449)
		{
			uint8 buffer[6];

			if (stream.stream.read (buffer, 6) == 6
				 && buffer[0] != 0xff
				 && ((buffer[2] | buffer[3] | buffer[4] | buffer[5]) & 0x80) == 0)
			{
				const int length = (((uint32) buffer[2]) << 21)
								 | (((uint32) buffer[3]) << 14)
								 | (((uint32) buffer[4]) << 7)
								 |  ((uint32) buffer[5]);

				stream.stream.skipNextBytes (length);
				return;
			}
		}

		stream.stream.setPosition (originalPosition);
	}

	int64 findLength (int64 streamStartPos)
	{
		int64 numFrames = stream.numFrames;

		if (numFrames <= 0)
		{
			const int64 streamSize = stream.stream.getTotalLength();

			if (streamSize > 0)
				numFrames = (streamSize - streamStartPos) / (stream.frame.frameSize);
		}

		return numFrames * 1152;
	}

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (MP3Reader);
};

}

MP3AudioFormat::MP3AudioFormat()
	: AudioFormat (MP3Decoder::mp3FormatName, StringArray (MP3Decoder::mp3Extensions))
{}

MP3AudioFormat::~MP3AudioFormat() {}

Array<int> MP3AudioFormat::getPossibleSampleRates() { return Array<int>(); }
Array<int> MP3AudioFormat::getPossibleBitDepths()   { return Array<int>(); }
bool MP3AudioFormat::canDoStereo()                  { return true; }
bool MP3AudioFormat::canDoMono()                    { return true; }
bool MP3AudioFormat::isCompressed()                 { return true; }
StringArray MP3AudioFormat::getQualityOptions()     { return StringArray(); }

AudioFormatReader* MP3AudioFormat::createReaderFor (InputStream* sourceStream, const bool deleteStreamIfOpeningFails)
{
	ScopedPointer<MP3Decoder::MP3Reader> r (new MP3Decoder::MP3Reader (sourceStream));

	if (r->lengthInSamples > 0)
		return r.release();

	if (! deleteStreamIfOpeningFails)
		r->input = nullptr;

	return nullptr;
}

AudioFormatWriter* MP3AudioFormat::createWriterFor (OutputStream*, double /*sampleRateToUse*/,
													unsigned int /*numberOfChannels*/, int /*bitsPerSample*/,
													const StringPairArray& /*metadataValues*/, int /*qualityOptionIndex*/)
{
	return nullptr;
}

#endif

/*** End of inlined file: juce_MP3AudioFormat.cpp ***/


/*** Start of inlined file: juce_OggVorbisAudioFormat.cpp ***/
#if JUCE_USE_OGGVORBIS

#if JUCE_MAC && ! defined (__MACOSX__)
 #define __MACOSX__ 1
#endif

namespace OggVorbisNamespace
{
#if JUCE_INCLUDE_OGGVORBIS_CODE || ! defined (JUCE_INCLUDE_OGGVORBIS_CODE)
 #if JUCE_MSVC
  #pragma warning (push)
  #pragma warning (disable: 4267 4127 4244 4996 4100 4701 4702 4013 4133 4206 4305 4189 4706 4995 4365)
 #endif


/*** Start of inlined file: vorbisenc.h ***/
/** \file
 * Libvorbisenc is a convenient API for setting up an encoding
 * environment using libvorbis. Libvorbisenc encapsulates the
 * actions needed to set up the encoder properly.
 */

#ifndef _OV_ENC_H_
#define _OV_ENC_H_

#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */


/*** Start of inlined file: codec.h ***/
#ifndef _vorbis_codec_h_
#define _vorbis_codec_h_

#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */


/*** Start of inlined file: ogg.h ***/
#ifndef _OGG_H
#define _OGG_H

#ifdef __cplusplus
extern "C" {
#endif


/*** Start of inlined file: os_types.h ***/
#ifndef _OS_TYPES_H
#define _OS_TYPES_H

/* make it easy on the folks that want to compile the libs with a
   different malloc than stdlib */
#define _ogg_malloc  malloc
#define _ogg_calloc  calloc
#define _ogg_realloc realloc
#define _ogg_free    free

#if defined(_WIN32)

#  if defined(__CYGWIN__)
#    include <_G_config.h>
	 typedef _G_int64_t ogg_int64_t;
	 typedef _G_int32_t ogg_int32_t;
	 typedef _G_uint32_t ogg_uint32_t;
	 typedef _G_int16_t ogg_int16_t;
	 typedef _G_uint16_t ogg_uint16_t;
#  elif defined(__MINGW32__)
	 typedef short ogg_int16_t;
	 typedef unsigned short ogg_uint16_t;
	 typedef int ogg_int32_t;
	 typedef unsigned int ogg_uint32_t;
	 typedef long long ogg_int64_t;
	 typedef unsigned long long ogg_uint64_t;
#  elif defined(__MWERKS__)
	 typedef long long ogg_int64_t;
	 typedef int ogg_int32_t;
	 typedef unsigned int ogg_uint32_t;
	 typedef short ogg_int16_t;
	 typedef unsigned short ogg_uint16_t;
#  else
	 /* MSVC/Borland */
	 typedef __int64 ogg_int64_t;
	 typedef __int32 ogg_int32_t;
	 typedef unsigned __int32 ogg_uint32_t;
	 typedef __int16 ogg_int16_t;
	 typedef unsigned __int16 ogg_uint16_t;
#  endif

#elif defined(__MACOS__)

#  include <sys/types.h>
   typedef SInt16 ogg_int16_t;
   typedef UInt16 ogg_uint16_t;
   typedef SInt32 ogg_int32_t;
   typedef UInt32 ogg_uint32_t;
   typedef SInt64 ogg_int64_t;

#elif defined(__MACOSX__) /* MacOS X Framework build */

#  include <sys/types.h>
   typedef int16_t ogg_int16_t;
   typedef u_int16_t ogg_uint16_t;
   typedef int32_t ogg_int32_t;
   typedef u_int32_t ogg_uint32_t;
   typedef int64_t ogg_int64_t;

#elif defined(__BEOS__)

   /* Be */
#  include <inttypes.h>
   typedef int16_t ogg_int16_t;
   typedef u_int16_t ogg_uint16_t;
   typedef int32_t ogg_int32_t;
   typedef u_int32_t ogg_uint32_t;
   typedef int64_t ogg_int64_t;

#elif defined (__EMX__)

   /* OS/2 GCC */
   typedef short ogg_int16_t;
   typedef unsigned short ogg_uint16_t;
   typedef int ogg_int32_t;
   typedef unsigned int ogg_uint32_t;
   typedef long long ogg_int64_t;

#elif defined (DJGPP)

   /* DJGPP */
   typedef short ogg_int16_t;
   typedef int ogg_int32_t;
   typedef unsigned int ogg_uint32_t;
   typedef long long ogg_int64_t;

#elif defined(R5900)

   /* PS2 EE */
   typedef long ogg_int64_t;
   typedef int ogg_int32_t;
   typedef unsigned ogg_uint32_t;
   typedef short ogg_int16_t;

#elif defined(__SYMBIAN32__)

   /* Symbian GCC */
   typedef signed short ogg_int16_t;
   typedef unsigned short ogg_uint16_t;
   typedef signed int ogg_int32_t;
   typedef unsigned int ogg_uint32_t;
   typedef long long int ogg_int64_t;

#else

#  include <sys/types.h>

/*** Start of inlined file: config_types.h ***/
#ifndef __CONFIG_TYPES_H__
#define __CONFIG_TYPES_H__

typedef int16_t ogg_int16_t;
typedef unsigned short ogg_uint16_t;
typedef int32_t ogg_int32_t;
typedef unsigned int ogg_uint32_t;
typedef int64_t ogg_int64_t;

#endif

/*** End of inlined file: config_types.h ***/


#endif

#endif  /* _OS_TYPES_H */

/*** End of inlined file: os_types.h ***/

typedef struct {
  long endbyte;
  int  endbit;

  unsigned char *buffer;
  unsigned char *ptr;
  long storage;
} oggpack_buffer;

/* ogg_page is used to encapsulate the data in one Ogg bitstream page *****/

typedef struct {
  unsigned char *header;
  long header_len;
  unsigned char *body;
  long body_len;
} ogg_page;

ogg_uint32_t ogg_bitreverse(ogg_uint32_t x){
  x=    ((x>>16)&0x0000ffffUL) | ((x<<16)&0xffff0000UL);
  x=    ((x>> 8)&0x00ff00ffUL) | ((x<< 8)&0xff00ff00UL);
  x=    ((x>> 4)&0x0f0f0f0fUL) | ((x<< 4)&0xf0f0f0f0UL);
  x=    ((x>> 2)&0x33333333UL) | ((x<< 2)&0xccccccccUL);
  return((x>> 1)&0x55555555UL) | ((x<< 1)&0xaaaaaaaaUL);
}

/* ogg_stream_state contains the current encode/decode state of a logical
   Ogg bitstream **********************************************************/

typedef struct {
  unsigned char   *body_data;    /* bytes from packet bodies */
  long    body_storage;          /* storage elements allocated */
  long    body_fill;             /* elements stored; fill mark */
  long    body_returned;         /* elements of fill returned */

  int     *lacing_vals;      /* The values that will go to the segment table */
  ogg_int64_t *granule_vals; /* granulepos values for headers. Not compact
				this way, but it is simple coupled to the
				lacing fifo */
  long    lacing_storage;
  long    lacing_fill;
  long    lacing_packet;
  long    lacing_returned;

  unsigned char    header[282];      /* working space for header encode */
  int              header_fill;

  int     e_o_s;          /* set when we have buffered the last packet in the
							 logical bitstream */
  int     b_o_s;          /* set after we've written the initial page
							 of a logical bitstream */
  long    serialno;
  long    pageno;
  ogg_int64_t  packetno;      /* sequence number for decode; the framing
							 knows where there's a hole in the data,
							 but we need coupling so that the codec
							 (which is in a seperate abstraction
							 layer) also knows about the gap */
  ogg_int64_t   granulepos;

} ogg_stream_state;

/* ogg_packet is used to encapsulate the data and metadata belonging
   to a single raw Ogg/Vorbis packet *************************************/

typedef struct {
  unsigned char *packet;
  long  bytes;
  long  b_o_s;
  long  e_o_s;

  ogg_int64_t  granulepos;

  ogg_int64_t  packetno;     /* sequence number for decode; the framing
				knows where there's a hole in the data,
				but we need coupling so that the codec
				(which is in a seperate abstraction
				layer) also knows about the gap */
} ogg_packet;

typedef struct {
  unsigned char *data;
  int storage;
  int fill;
  int returned;

  int unsynced;
  int headerbytes;
  int bodybytes;
} ogg_sync_state;

/* Ogg BITSTREAM PRIMITIVES: bitstream ************************/

extern void  oggpack_writeinit(oggpack_buffer *b);
extern void  oggpack_writetrunc(oggpack_buffer *b,long bits);
extern void  oggpack_writealign(oggpack_buffer *b);
extern void  oggpack_writecopy(oggpack_buffer *b,void *source,long bits);
extern void  oggpack_reset(oggpack_buffer *b);
extern void  oggpack_writeclear(oggpack_buffer *b);
extern void  oggpack_readinit(oggpack_buffer *b,unsigned char *buf,int bytes);
extern void  oggpack_write(oggpack_buffer *b,unsigned long value,int bits);
extern long  oggpack_look(oggpack_buffer *b,int bits);
extern long  oggpack_look1(oggpack_buffer *b);
extern void  oggpack_adv(oggpack_buffer *b,int bits);
extern void  oggpack_adv1(oggpack_buffer *b);
extern long  oggpack_read(oggpack_buffer *b,int bits);
extern long  oggpack_read1(oggpack_buffer *b);
extern long  oggpack_bytes(oggpack_buffer *b);
extern long  oggpack_bits(oggpack_buffer *b);
extern unsigned char *oggpack_get_buffer(oggpack_buffer *b);

extern void  oggpackB_writeinit(oggpack_buffer *b);
extern void  oggpackB_writetrunc(oggpack_buffer *b,long bits);
extern void  oggpackB_writealign(oggpack_buffer *b);
extern void  oggpackB_writecopy(oggpack_buffer *b,void *source,long bits);
extern void  oggpackB_reset(oggpack_buffer *b);
extern void  oggpackB_writeclear(oggpack_buffer *b);
extern void  oggpackB_readinit(oggpack_buffer *b,unsigned char *buf,int bytes);
extern void  oggpackB_write(oggpack_buffer *b,unsigned long value,int bits);
extern long  oggpackB_look(oggpack_buffer *b,int bits);
extern long  oggpackB_look1(oggpack_buffer *b);
extern void  oggpackB_adv(oggpack_buffer *b,int bits);
extern void  oggpackB_adv1(oggpack_buffer *b);
extern long  oggpackB_read(oggpack_buffer *b,int bits);
extern long  oggpackB_read1(oggpack_buffer *b);
extern long  oggpackB_bytes(oggpack_buffer *b);
extern long  oggpackB_bits(oggpack_buffer *b);
extern unsigned char *oggpackB_get_buffer(oggpack_buffer *b);

/* Ogg BITSTREAM PRIMITIVES: encoding **************************/

extern int      ogg_stream_packetin(ogg_stream_state *os, ogg_packet *op);
extern int      ogg_stream_pageout(ogg_stream_state *os, ogg_page *og);
extern int      ogg_stream_flush(ogg_stream_state *os, ogg_page *og);

/* Ogg BITSTREAM PRIMITIVES: decoding **************************/

extern int      ogg_sync_init(ogg_sync_state *oy);
extern int      ogg_sync_clear(ogg_sync_state *oy);
extern int      ogg_sync_reset(ogg_sync_state *oy);
extern int	ogg_sync_destroy(ogg_sync_state *oy);

extern char    *ogg_sync_buffer(ogg_sync_state *oy, long size);
extern int      ogg_sync_wrote(ogg_sync_state *oy, long bytes);
extern long     ogg_sync_pageseek(ogg_sync_state *oy,ogg_page *og);
extern int      ogg_sync_pageout(ogg_sync_state *oy, ogg_page *og);
extern int      ogg_stream_pagein(ogg_stream_state *os, ogg_page *og);
extern int      ogg_stream_packetout(ogg_stream_state *os,ogg_packet *op);
extern int      ogg_stream_packetpeek(ogg_stream_state *os,ogg_packet *op);

/* Ogg BITSTREAM PRIMITIVES: general ***************************/

extern int      ogg_stream_init(ogg_stream_state *os,int serialno);
extern int      ogg_stream_clear(ogg_stream_state *os);
extern int      ogg_stream_reset(ogg_stream_state *os);
extern int      ogg_stream_reset_serialno(ogg_stream_state *os,int serialno);
extern int      ogg_stream_destroy(ogg_stream_state *os);
extern int      ogg_stream_eos(ogg_stream_state *os);

extern void     ogg_page_checksum_set(ogg_page *og);

extern int      ogg_page_version(ogg_page *og);
extern int      ogg_page_continued(ogg_page *og);
extern int      ogg_page_bos(ogg_page *og);
extern int      ogg_page_eos(ogg_page *og);
extern ogg_int64_t  ogg_page_granulepos(ogg_page *og);
extern int      ogg_page_serialno(ogg_page *og);
extern long     ogg_page_pageno(ogg_page *og);
extern int      ogg_page_packets(ogg_page *og);

extern void     ogg_packet_clear(ogg_packet *op);

#ifdef __cplusplus
}
#endif

#endif  /* _OGG_H */

/*** End of inlined file: ogg.h ***/

typedef struct vorbis_info{
  int version;
  int channels;
  long rate;

  /* The below bitrate declarations are *hints*.
	 Combinations of the three values carry the following implications:

	 all three set to the same value:
	   implies a fixed rate bitstream
	 only nominal set:
	   implies a VBR stream that averages the nominal bitrate.  No hard
	   upper/lower limit
	 upper and or lower set:
	   implies a VBR bitstream that obeys the bitrate limits. nominal
	   may also be set to give a nominal rate.
	 none set:
	   the coder does not care to speculate.
  */

  long bitrate_upper;
  long bitrate_nominal;
  long bitrate_lower;
  long bitrate_window;

  void *codec_setup;
} vorbis_info;

/* vorbis_dsp_state buffers the current vorbis audio
   analysis/synthesis state.  The DSP state belongs to a specific
   logical bitstream ****************************************************/
typedef struct vorbis_dsp_state{
  int analysisp;
  vorbis_info *vi;

  float **pcm;
  float **pcmret;
  int      pcm_storage;
  int      pcm_current;
  int      pcm_returned;

  int  preextrapolate;
  int  eofflag;

  long lW;
  long W;
  long nW;
  long centerW;

  ogg_int64_t granulepos;
  ogg_int64_t sequence;

  ogg_int64_t glue_bits;
  ogg_int64_t time_bits;
  ogg_int64_t floor_bits;
  ogg_int64_t res_bits;

  void       *backend_state;
} vorbis_dsp_state;

typedef struct vorbis_block{
  /* necessary stream state for linking to the framing abstraction */
  float  **pcm;       /* this is a pointer into local storage */
  oggpack_buffer opb;

  long  lW;
  long  W;
  long  nW;
  int   pcmend;
  int   mode;

  int         eofflag;
  ogg_int64_t granulepos;
  ogg_int64_t sequence;
  vorbis_dsp_state *vd; /* For read-only access of configuration */

  /* local storage to avoid remallocing; it's up to the mapping to
	 structure it */
  void               *localstore;
  long                localtop;
  long                localalloc;
  long                totaluse;
  struct alloc_chain *reap;

  /* bitmetrics for the frame */
  long glue_bits;
  long time_bits;
  long floor_bits;
  long res_bits;

  void *internal;

} vorbis_block;

/* vorbis_block is a single block of data to be processed as part of
the analysis/synthesis stream; it belongs to a specific logical
bitstream, but is independent from other vorbis_blocks belonging to
that logical bitstream. *************************************************/

struct alloc_chain{
  void *ptr;
  struct alloc_chain *next;
};

/* vorbis_info contains all the setup information specific to the
   specific compression/decompression mode in progress (eg,
   psychoacoustic settings, channel setup, options, codebook
   etc). vorbis_info and substructures are in backends.h.
*********************************************************************/

/* the comments are not part of vorbis_info so that vorbis_info can be
   static storage */
typedef struct vorbis_comment{
  /* unlimited user comment fields.  libvorbis writes 'libvorbis'
	 whatever vendor is set to in encode */
  char **user_comments;
  int   *comment_lengths;
  int    comments;
  char  *vendor;

} vorbis_comment;

/* libvorbis encodes in two abstraction layers; first we perform DSP
   and produce a packet (see docs/analysis.txt).  The packet is then
   coded into a framed OggSquish bitstream by the second layer (see
   docs/framing.txt).  Decode is the reverse process; we sync/frame
   the bitstream and extract individual packets, then decode the
   packet back into PCM audio.

   The extra framing/packetizing is used in streaming formats, such as
   files.  Over the net (such as with UDP), the framing and
   packetization aren't necessary as they're provided by the transport
   and the streaming layer is not used */

/* Vorbis PRIMITIVES: general ***************************************/

extern void     vorbis_info_init(vorbis_info *vi);
extern void     vorbis_info_clear(vorbis_info *vi);
extern int      vorbis_info_blocksize(vorbis_info *vi,int zo);
extern void     vorbis_comment_init(vorbis_comment *vc);
extern void     vorbis_comment_add(vorbis_comment *vc, const char *comment);
extern void     vorbis_comment_add_tag(vorbis_comment *vc,
									   const char *tag, const char *contents);
extern char    *vorbis_comment_query(vorbis_comment *vc, const char *tag, int count);
extern int      vorbis_comment_query_count(vorbis_comment *vc, const char *tag);
extern void     vorbis_comment_clear(vorbis_comment *vc);

extern int      vorbis_block_init(vorbis_dsp_state *v, vorbis_block *vb);
extern int      vorbis_block_clear(vorbis_block *vb);
extern void     vorbis_dsp_clear(vorbis_dsp_state *v);
extern double   vorbis_granule_time(vorbis_dsp_state *v,
									ogg_int64_t granulepos);

extern const char *vorbis_version_string(void);

/* Vorbis PRIMITIVES: analysis/DSP layer ****************************/

extern int      vorbis_analysis_init(vorbis_dsp_state *v,vorbis_info *vi);
extern int      vorbis_commentheader_out(vorbis_comment *vc, ogg_packet *op);
extern int      vorbis_analysis_headerout(vorbis_dsp_state *v,
										  vorbis_comment *vc,
										  ogg_packet *op,
										  ogg_packet *op_comm,
										  ogg_packet *op_code);
extern float  **vorbis_analysis_buffer(vorbis_dsp_state *v,int vals);
extern int      vorbis_analysis_wrote(vorbis_dsp_state *v,int vals);
extern int      vorbis_analysis_blockout(vorbis_dsp_state *v,vorbis_block *vb);
extern int      vorbis_analysis(vorbis_block *vb,ogg_packet *op);

extern int      vorbis_bitrate_addblock(vorbis_block *vb);
extern int      vorbis_bitrate_flushpacket(vorbis_dsp_state *vd,
										   ogg_packet *op);

/* Vorbis PRIMITIVES: synthesis layer *******************************/
extern int      vorbis_synthesis_idheader(ogg_packet *op);
extern int      vorbis_synthesis_headerin(vorbis_info *vi,vorbis_comment *vc,
										  ogg_packet *op);

extern int      vorbis_synthesis_init(vorbis_dsp_state *v,vorbis_info *vi);
extern int      vorbis_synthesis_restart(vorbis_dsp_state *v);
extern int      vorbis_synthesis(vorbis_block *vb,ogg_packet *op);
extern int      vorbis_synthesis_trackonly(vorbis_block *vb,ogg_packet *op);
extern int      vorbis_synthesis_blockin(vorbis_dsp_state *v,vorbis_block *vb);
extern int      vorbis_synthesis_pcmout(vorbis_dsp_state *v,float ***pcm);
extern int      vorbis_synthesis_lapout(vorbis_dsp_state *v,float ***pcm);
extern int      vorbis_synthesis_read(vorbis_dsp_state *v,int samples);
extern long     vorbis_packet_blocksize(vorbis_info *vi,ogg_packet *op);

extern int      vorbis_synthesis_halfrate(vorbis_info *v,int flag);
extern int      vorbis_synthesis_halfrate_p(vorbis_info *v);

/* Vorbis ERRORS and return codes ***********************************/

#define OV_FALSE      -1
#define OV_EOF        -2
#define OV_HOLE       -3

#define OV_EREAD      -128
#define OV_EFAULT     -129
#define OV_EIMPL      -130
#define OV_EINVAL     -131
#define OV_ENOTVORBIS -132
#define OV_EBADHEADER -133
#define OV_EVERSION   -134
#define OV_ENOTAUDIO  -135
#define OV_EBADPACKET -136
#define OV_EBADLINK   -137
#define OV_ENOSEEK    -138

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif

/*** End of inlined file: codec.h ***/

/**
 * This is the primary function within libvorbisenc for setting up managed
 * bitrate modes.
 *
 * Before this function is called, the \ref vorbis_info
 * struct should be initialized by using vorbis_info_init() from the libvorbis
 * API.  After encoding, vorbis_info_clear() should be called.
 *
 * The max_bitrate, nominal_bitrate, and min_bitrate settings are used to set
 * constraints for the encoded file.  This function uses these settings to
 * select the appropriate encoding mode and set it up.
 *
 * \param vi               Pointer to an initialized \ref vorbis_info struct.
 * \param channels         The number of channels to be encoded.
 * \param rate             The sampling rate of the source audio.
 * \param max_bitrate      Desired maximum bitrate (limit). -1 indicates unset.
 * \param nominal_bitrate  Desired average, or central, bitrate. -1 indicates unset.
 * \param min_bitrate      Desired minimum bitrate. -1 indicates unset.
 *
 * \return Zero for success, and negative values for failure.
 *
 * \retval 0          Success.
 * \retval OV_EFAULT  Internal logic fault; indicates a bug or heap/stack corruption.
 * \retval OV_EINVAL  Invalid setup request, eg, out of range argument.
 * \retval OV_EIMPL   Unimplemented mode; unable to comply with bitrate request.
 */
extern int vorbis_encode_init(vorbis_info *vi,
							  long channels,
							  long rate,

							  long max_bitrate,
							  long nominal_bitrate,
							  long min_bitrate);

/**
 * This function performs step-one of a three-step bitrate-managed encode
 * setup.  It functions similarly to the one-step setup performed by \ref
 * vorbis_encode_init but allows an application to make further encode setup
 * tweaks using \ref vorbis_encode_ctl before finally calling \ref
 * vorbis_encode_setup_init to complete the setup process.
 *
 * Before this function is called, the \ref vorbis_info struct should be
 * initialized by using vorbis_info_init() from the libvorbis API.  After
 * encoding, vorbis_info_clear() should be called.
 *
 * The max_bitrate, nominal_bitrate, and min_bitrate settings are used to set
 * constraints for the encoded file.  This function uses these settings to
 * select the appropriate encoding mode and set it up.
 *
 * \param vi                Pointer to an initialized vorbis_info struct.
 * \param channels          The number of channels to be encoded.
 * \param rate              The sampling rate of the source audio.
 * \param max_bitrate       Desired maximum bitrate (limit). -1 indicates unset.
 * \param nominal_bitrate   Desired average, or central, bitrate. -1 indicates unset.
 * \param min_bitrate       Desired minimum bitrate. -1 indicates unset.
 *
 * \return Zero for success, and negative for failure.
 *
 * \retval 0           Success
 * \retval OV_EFAULT   Internal logic fault; indicates a bug or heap/stack corruption.
 * \retval OV_EINVAL   Invalid setup request, eg, out of range argument.
 * \retval OV_EIMPL    Unimplemented mode; unable to comply with bitrate request.
 */
extern int vorbis_encode_setup_managed(vorbis_info *vi,
									   long channels,
									   long rate,

									   long max_bitrate,
									   long nominal_bitrate,
									   long min_bitrate);

/**
 * This function performs step-one of a three-step variable bitrate
 * (quality-based) encode setup.  It functions similarly to the one-step setup
 * performed by \ref vorbis_encode_init_vbr() but allows an application to
 * make further encode setup tweaks using \ref vorbis_encode_ctl() before
 * finally calling \ref vorbis_encode_setup_init to complete the setup
 * process.
 *
 * Before this function is called, the \ref vorbis_info struct should be
 * initialized by using \ref vorbis_info_init() from the libvorbis API.  After
 * encoding, vorbis_info_clear() should be called.
 *
 * \param vi        Pointer to an initialized vorbis_info struct.
 * \param channels  The number of channels to be encoded.
 * \param rate      The sampling rate of the source audio.
 * \param quality   Desired quality level, currently from -0.1 to 1.0 (lo to hi).
 *
 * \return Zero for success, and negative values for failure.
 *
 * \retval  0          Success
 * \retval  OV_EFAULT  Internal logic fault; indicates a bug or heap/stack corruption.
 * \retval  OV_EINVAL  Invalid setup request, eg, out of range argument.
 * \retval  OV_EIMPL   Unimplemented mode; unable to comply with quality level request.
 */
extern int vorbis_encode_setup_vbr(vorbis_info *vi,
								  long channels,
								  long rate,

								  float quality
								  );

/**
 * This is the primary function within libvorbisenc for setting up variable
 * bitrate ("quality" based) modes.
 *
 *
 * Before this function is called, the vorbis_info struct should be
 * initialized by using vorbis_info_init() from the libvorbis API. After
 * encoding, vorbis_info_clear() should be called.
 *
 * \param vi           Pointer to an initialized vorbis_info struct.
 * \param channels     The number of channels to be encoded.
 * \param rate         The sampling rate of the source audio.
 * \param base_quality Desired quality level, currently from -0.1 to 1.0 (lo to hi).
 *
 *
 * \return Zero for success, or a negative number for failure.
 *
 * \retval 0           Success
 * \retval OV_EFAULT   Internal logic fault; indicates a bug or heap/stack corruption.
 * \retval OV_EINVAL   Invalid setup request, eg, out of range argument.
 * \retval OV_EIMPL    Unimplemented mode; unable to comply with quality level request.
 */
extern int vorbis_encode_init_vbr(vorbis_info *vi,
								  long channels,
								  long rate,

								  float base_quality
								  );

/**
 * This function performs the last stage of three-step encoding setup, as
 * described in the API overview under managed bitrate modes.
 *
 * Before this function is called, the \ref vorbis_info struct should be
 * initialized by using vorbis_info_init() from the libvorbis API, one of
 * \ref vorbis_encode_setup_managed() or \ref vorbis_encode_setup_vbr() called to
 * initialize the high-level encoding setup, and \ref vorbis_encode_ctl()
 * called if necessary to make encoding setup changes.
 * vorbis_encode_setup_init() finalizes the highlevel encoding structure into
 * a complete encoding setup after which the application may make no further
 * setup changes.
 *
 * After encoding, vorbis_info_clear() should be called.
 *
 * \param vi Pointer to an initialized \ref vorbis_info struct.
 *
 * \return Zero for success, and negative values for failure.
 *
 * \retval  0           Success.
 * \retval  OV_EFAULT  Internal logic fault; indicates a bug or heap/stack corruption.
 *
 * \retval OV_EINVAL   Attempt to use vorbis_encode_setup_init() without first
 * calling one of vorbis_encode_setup_managed() or vorbis_encode_setup_vbr() to
 * initialize the high-level encoding setup
 *
 */
extern int vorbis_encode_setup_init(vorbis_info *vi);

/**
 * This function implements a generic interface to miscellaneous encoder
 * settings similar to the classic UNIX 'ioctl()' system call.  Applications
 * may use vorbis_encode_ctl() to query or set bitrate management or quality
 * mode details by using one of several \e request arguments detailed below.
 * vorbis_encode_ctl() must be called after one of
 * vorbis_encode_setup_managed() or vorbis_encode_setup_vbr().  When used
 * to modify settings, \ref vorbis_encode_ctl() must be called before \ref
 * vorbis_encode_setup_init().
 *
 * \param vi      Pointer to an initialized vorbis_info struct.
 *
 * \param number Specifies the desired action; See \ref encctlcodes "the list
 * of available requests".
 *
 * \param arg void * pointing to a data structure matching the request
 * argument.
 *
 * \retval 0          Success. Any further return information (such as the result of a
 * query) is placed into the storage pointed to by *arg.
 *
 * \retval OV_EINVAL  Invalid argument, or an attempt to modify a setting after
 * calling vorbis_encode_setup_init().
 *
 * \retval OV_EIMPL   Unimplemented or unknown request
 */
extern int vorbis_encode_ctl(vorbis_info *vi,int number,void *arg);

/**
 * \deprecated This is a deprecated interface. Please use vorbis_encode_ctl()
 * with the \ref ovectl_ratemanage2_arg struct and \ref
 * OV_ECTL_RATEMANAGE2_GET and \ref OV_ECTL_RATEMANAGE2_SET calls in new code.
 *
 * The \ref ovectl_ratemanage_arg structure is used with vorbis_encode_ctl()
 * and the \ref OV_ECTL_RATEMANAGE_GET, \ref OV_ECTL_RATEMANAGE_SET, \ref
 * OV_ECTL_RATEMANAGE_AVG, \ref OV_ECTL_RATEMANAGE_HARD calls in order to
 * query and modify specifics of the encoder's bitrate management
 * configuration.
*/
struct ovectl_ratemanage_arg {
  int    management_active; /**< nonzero if bitrate management is active*/
/** hard lower limit (in kilobits per second) below which the stream bitrate
	will never be allowed for any given bitrate_hard_window seconds of time.*/
  long   bitrate_hard_min;
/** hard upper limit (in kilobits per second) above which the stream bitrate
	will never be allowed for any given bitrate_hard_window seconds of time.*/
  long   bitrate_hard_max;
/** the window period (in seconds) used to regulate the hard bitrate minimum
	and maximum*/
  double bitrate_hard_window;
/** soft lower limit (in kilobits per second) below which the average bitrate
	tracker will start nudging the bitrate higher.*/
  long   bitrate_av_lo;
/** soft upper limit (in kilobits per second) above which the average bitrate
	tracker will start nudging the bitrate lower.*/
  long   bitrate_av_hi;
/** the window period (in seconds) used to regulate the average bitrate
	minimum and maximum.*/
  double bitrate_av_window;
/** Regulates the relative centering of the average and hard windows; in
	libvorbis 1.0 and 1.0.1, the hard window regulation overlapped but
	followed the average window regulation. In libvorbis 1.1 a bit-reservoir
	interface replaces the old windowing interface; the older windowing
	interface is simulated and this field has no effect.*/
  double bitrate_av_window_center;
};

/**
 * \name struct ovectl_ratemanage2_arg
 *
 * The ovectl_ratemanage2_arg structure is used with vorbis_encode_ctl() and
 * the OV_ECTL_RATEMANAGE2_GET and OV_ECTL_RATEMANAGE2_SET calls in order to
 * query and modify specifics of the encoder's bitrate management
 * configuration.
 *
*/
struct ovectl_ratemanage2_arg {
  int    management_active; /**< nonzero if bitrate management is active */
/** Lower allowed bitrate limit in kilobits per second */
  long   bitrate_limit_min_kbps;
/** Upper allowed bitrate limit in kilobits per second */
  long   bitrate_limit_max_kbps;
  long   bitrate_limit_reservoir_bits; /**<Size of the bitrate reservoir in bits */
/** Regulates the bitrate reservoir's preferred fill level in a range from 0.0
 * to 1.0; 0.0 tries to bank bits to buffer against future bitrate spikes, 1.0
 * buffers against future sudden drops in instantaneous bitrate. Default is
 * 0.1
 */
  double bitrate_limit_reservoir_bias;
/** Average bitrate setting in kilobits per second */
  long   bitrate_average_kbps;
/** Slew rate limit setting for average bitrate adjustment; sets the minimum
 *  time in seconds the bitrate tracker may swing from one extreme to the
 *  other when boosting or damping average bitrate.
 */
  double bitrate_average_damping;
};

/**
 * \name vorbis_encode_ctl() codes
 *
 * \anchor encctlcodes
 *
 * These values are passed as the \c number parameter of vorbis_encode_ctl().
 * The type of the referent of that function's \c arg pointer depends on these
 * codes.
 */
/*@{*/

/**
 * Query the current encoder bitrate management setting.
 *
 *Argument: <tt>struct ovectl_ratemanage2_arg *</tt>
 *
 * Used to query the current encoder bitrate management setting. Also used to
 * initialize fields of an ovectl_ratemanage2_arg structure for use with
 * \ref OV_ECTL_RATEMANAGE2_SET.
 */
#define OV_ECTL_RATEMANAGE2_GET      0x14

/**
 * Set the current encoder bitrate management settings.
 *
 * Argument: <tt>struct ovectl_ratemanage2_arg *</tt>
 *
 * Used to set the current encoder bitrate management settings to the values
 * listed in the ovectl_ratemanage2_arg. Passing a NULL pointer will disable
 * bitrate management.
*/
#define OV_ECTL_RATEMANAGE2_SET      0x15

/**
 * Returns the current encoder hard-lowpass setting (kHz) in the double
 * pointed to by arg.
 *
 * Argument: <tt>double *</tt>
*/
#define OV_ECTL_LOWPASS_GET          0x20

/**
 *  Sets the encoder hard-lowpass to the value (kHz) pointed to by arg. Valid
 *  lowpass settings range from 2 to 99.
 *
 * Argument: <tt>double *</tt>
*/
#define OV_ECTL_LOWPASS_SET          0x21

/**
 *  Returns the current encoder impulse block setting in the double pointed
 *  to by arg.
 *
 * Argument: <tt>double *</tt>
*/
#define OV_ECTL_IBLOCK_GET           0x30

/**
 *  Sets the impulse block bias to the the value pointed to by arg.
 *
 * Argument: <tt>double *</tt>
 *
 *  Valid range is -15.0 to 0.0 [default]. A negative impulse block bias will
 *  direct to encoder to use more bits when incoding short blocks that contain
 *  strong impulses, thus improving the accuracy of impulse encoding.
 */
#define OV_ECTL_IBLOCK_SET           0x31

/**
 *  Returns the current encoder coupling setting in the int pointed
 *  to by arg.
 *
 * Argument: <tt>int *</tt>
*/
#define OV_ECTL_COUPLING_GET         0x40

/**
 *  Enables/disables channel coupling in multichannel encoding according to arg.
 *
 * Argument: <tt>int *</tt>
 *
 *  Zero disables channel coupling for multichannel inputs, nonzer enables
 *  channel coupling.  Setting has no effect on monophonic encoding or
 *  multichannel counts that do not offer coupling.  At present, coupling is
 *  available for stereo and 5.1 encoding.
 */
#define OV_ECTL_COUPLING_SET         0x41

  /* deprecated rate management supported only for compatibility */

/**
 * Old interface to querying bitrate management settings.
 *
 * Deprecated after move to bit-reservoir style management in 1.1 rendered
 * this interface partially obsolete.

 * \deprecated Please use \ref OV_ECTL_RATEMANAGE2_GET instead.
 *
 * Argument: <tt>struct ovectl_ratemanage_arg *</tt>
 */
#define OV_ECTL_RATEMANAGE_GET       0x10
/**
 * Old interface to modifying bitrate management settings.
 *
 *  deprecated after move to bit-reservoir style management in 1.1 rendered
 *  this interface partially obsolete.
 *
 * \deprecated Please use \ref OV_ECTL_RATEMANAGE2_SET instead.
 *
 * Argument: <tt>struct ovectl_ratemanage_arg *</tt>
 */
#define OV_ECTL_RATEMANAGE_SET       0x11
/**
 * Old interface to setting average-bitrate encoding mode.
 *
 * Deprecated after move to bit-reservoir style management in 1.1 rendered
 * this interface partially obsolete.
 *
 *  \deprecated Please use \ref OV_ECTL_RATEMANAGE2_SET instead.
 *
 * Argument: <tt>struct ovectl_ratemanage_arg *</tt>
 */
#define OV_ECTL_RATEMANAGE_AVG       0x12
/**
 * Old interface to setting bounded-bitrate encoding modes.
 *
 * deprecated after move to bit-reservoir style management in 1.1 rendered
 * this interface partially obsolete.
 *
 *  \deprecated Please use \ref OV_ECTL_RATEMANAGE2_SET instead.
 *
 * Argument: <tt>struct ovectl_ratemanage_arg *</tt>
 */
#define OV_ECTL_RATEMANAGE_HARD      0x13

/*@}*/

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif

/*** End of inlined file: vorbisenc.h ***/


/*** Start of inlined file: vorbisfile.h ***/
#ifndef _OV_FILE_H_
#define _OV_FILE_H_

#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */

#include <stdio.h>

/* The function prototypes for the callbacks are basically the same as for
 * the stdio functions fread, fseek, fclose, ftell.
 * The one difference is that the FILE * arguments have been replaced with
 * a void * - this is to be used as a pointer to whatever internal data these
 * functions might need. In the stdio case, it's just a FILE * cast to a void *
 *
 * If you use other functions, check the docs for these functions and return
 * the right values. For seek_func(), you *MUST* return -1 if the stream is
 * unseekable
 */
typedef struct {
  size_t (*read_func)  (void *ptr, size_t size, size_t nmemb, void *datasource);
  int    (*seek_func)  (void *datasource, ogg_int64_t offset, int whence);
  int    (*close_func) (void *datasource);
  long   (*tell_func)  (void *datasource);
} ov_callbacks;

#ifndef OV_EXCLUDE_STATIC_CALLBACKS

/* a few sets of convenient callbacks, especially for use under
 * Windows where ov_open_callbacks() should always be used instead of
 * ov_open() to avoid problems with incompatible crt.o version linking
 * issues. */

/*static int _ov_header_fseek_wrap(FILE *f,ogg_int64_t off,int whence){
  if(f==NULL)return(-1);

#ifdef __MINGW32__
  return fseeko64(f,off,whence);
#elif defined (_WIN32)
  return _fseeki64(f,off,whence);
#else
  return fseek(f,off,whence);
#endif
}*/

/* These structs below (OV_CALLBACKS_DEFAULT etc) are defined here as
 * static data. That means that every file which includes this header
 * will get its own copy of these structs whether it uses them or
 * not unless it #defines OV_EXCLUDE_STATIC_CALLBACKS.
 * These static symbols are essential on platforms such as Windows on
 * which several different versions of stdio support may be linked to
 * by different DLLs, and we need to be certain we know which one
 * we're using (the same one as the main application).
 */

/*static ov_callbacks OV_CALLBACKS_DEFAULT = {
  (size_t (*)(void *, size_t, size_t, void *))  fread,
  (int (*)(void *, ogg_int64_t, int))           _ov_header_fseek_wrap,
  (int (*)(void *))                             fclose,
  (long (*)(void *))                            ftell
};

static ov_callbacks OV_CALLBACKS_NOCLOSE = {
  (size_t (*)(void *, size_t, size_t, void *))  fread,
  (int (*)(void *, ogg_int64_t, int))           _ov_header_fseek_wrap,
  (int (*)(void *))                             NULL,
  (long (*)(void *))                            ftell
};

static ov_callbacks OV_CALLBACKS_STREAMONLY = {
  (size_t (*)(void *, size_t, size_t, void *))  fread,
  (int (*)(void *, ogg_int64_t, int))           NULL,
  (int (*)(void *))                             fclose,
  (long (*)(void *))                            NULL
};

static ov_callbacks OV_CALLBACKS_STREAMONLY_NOCLOSE = {
  (size_t (*)(void *, size_t, size_t, void *))  fread,
  (int (*)(void *, ogg_int64_t, int))           NULL,
  (int (*)(void *))                             NULL,
  (long (*)(void *))                            NULL
};*/

#endif

#define  NOTOPEN   0
#define  PARTOPEN  1
#define  OPENED    2
#define  STREAMSET 3
#define  INITSET   4

typedef struct OggVorbis_File {
  void            *datasource; /* Pointer to a FILE *, etc. */
  int              seekable;
  ogg_int64_t      offset;
  ogg_int64_t      end;
  ogg_sync_state   oy;

  /* If the FILE handle isn't seekable (eg, a pipe), only the current
	 stream appears */
  int              links;
  ogg_int64_t     *offsets;
  ogg_int64_t     *dataoffsets;
  long            *serialnos;
  ogg_int64_t     *pcmlengths; /* overloaded to maintain binary
								  compatibility; x2 size, stores both
								  beginning and end values */
  vorbis_info     *vi;
  vorbis_comment  *vc;

  /* Decoding working state local storage */
  ogg_int64_t      pcm_offset;
  int              ready_state;
  long             current_serialno;
  int              current_link;

  double           bittrack;
  double           samptrack;

  ogg_stream_state os; /* take physical pages, weld into a logical
						  stream of packets */
  vorbis_dsp_state vd; /* central working state for the packet->PCM decoder */
  vorbis_block     vb; /* local working space for packet->PCM decode */

  ov_callbacks callbacks;

} OggVorbis_File;

extern int ov_clear(OggVorbis_File *vf);
extern int ov_fopen(const char *path,OggVorbis_File *vf);
extern int ov_open(FILE *f,OggVorbis_File *vf,const char *initial,long ibytes);
extern int ov_open_callbacks(void *datasource, OggVorbis_File *vf,
				const char *initial, long ibytes, ov_callbacks callbacks);

extern int ov_test(FILE *f,OggVorbis_File *vf,const char *initial,long ibytes);
extern int ov_test_callbacks(void *datasource, OggVorbis_File *vf,
				const char *initial, long ibytes, ov_callbacks callbacks);
extern int ov_test_open(OggVorbis_File *vf);

extern long ov_bitrate(OggVorbis_File *vf,int i);
extern long ov_bitrate_instant(OggVorbis_File *vf);
extern long ov_streams(OggVorbis_File *vf);
extern long ov_seekable(OggVorbis_File *vf);
extern long ov_serialnumber(OggVorbis_File *vf,int i);

extern ogg_int64_t ov_raw_total(OggVorbis_File *vf,int i);
extern ogg_int64_t ov_pcm_total(OggVorbis_File *vf,int i);
extern double ov_time_total(OggVorbis_File *vf,int i);

extern int ov_raw_seek(OggVorbis_File *vf,ogg_int64_t pos);
extern int ov_pcm_seek(OggVorbis_File *vf,ogg_int64_t pos);
extern int ov_pcm_seek_page(OggVorbis_File *vf,ogg_int64_t pos);
extern int ov_time_seek(OggVorbis_File *vf,double pos);
extern int ov_time_seek_page(OggVorbis_File *vf,double pos);

extern int ov_raw_seek_lap(OggVorbis_File *vf,ogg_int64_t pos);
extern int ov_pcm_seek_lap(OggVorbis_File *vf,ogg_int64_t pos);
extern int ov_pcm_seek_page_lap(OggVorbis_File *vf,ogg_int64_t pos);
extern int ov_time_seek_lap(OggVorbis_File *vf,double pos);
extern int ov_time_seek_page_lap(OggVorbis_File *vf,double pos);

extern ogg_int64_t ov_raw_tell(OggVorbis_File *vf);
extern ogg_int64_t ov_pcm_tell(OggVorbis_File *vf);
extern double ov_time_tell(OggVorbis_File *vf);

extern vorbis_info *ov_info(OggVorbis_File *vf,int link);
extern vorbis_comment *ov_comment(OggVorbis_File *vf,int link);

extern long ov_read_float(OggVorbis_File *vf,float ***pcm_channels,int samples,
						  int *bitstream);
extern long ov_read_filter(OggVorbis_File *vf,char *buffer,int length,
						  int bigendianp,int word,int sgned,int *bitstream,
						  void (*filter)(float **pcm,long channels,long samples,void *filter_param),void *filter_param);
extern long ov_read(OggVorbis_File *vf,char *buffer,int length,
					int bigendianp,int word,int sgned,int *bitstream);
extern int ov_crosslap(OggVorbis_File *vf1,OggVorbis_File *vf2);

extern int ov_halfrate(OggVorbis_File *vf,int flag);
extern int ov_halfrate_p(OggVorbis_File *vf);

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif

/*** End of inlined file: vorbisfile.h ***/


/*** Start of inlined file: bitwise.c ***/
/* We're 'LSb' endian; if we write a word but read individual bits,
   then we'll read the lsb first */

#include <string.h>
#include <stdlib.h>

#define BUFFER_INCREMENT 256

static const unsigned long mask[]=
{0x00000000,0x00000001,0x00000003,0x00000007,0x0000000f,
 0x0000001f,0x0000003f,0x0000007f,0x000000ff,0x000001ff,
 0x000003ff,0x000007ff,0x00000fff,0x00001fff,0x00003fff,
 0x00007fff,0x0000ffff,0x0001ffff,0x0003ffff,0x0007ffff,
 0x000fffff,0x001fffff,0x003fffff,0x007fffff,0x00ffffff,
 0x01ffffff,0x03ffffff,0x07ffffff,0x0fffffff,0x1fffffff,
 0x3fffffff,0x7fffffff,0xffffffff };

static const unsigned int mask8B[]=
{0x00,0x80,0xc0,0xe0,0xf0,0xf8,0xfc,0xfe,0xff};

void oggpack_writeinit(oggpack_buffer *b){
  memset(b,0,sizeof(*b));
  b->ptr=b->buffer=(unsigned char*) _ogg_malloc(BUFFER_INCREMENT);
  b->buffer[0]='\0';
  b->storage=BUFFER_INCREMENT;
}

void oggpackB_writeinit(oggpack_buffer *b){
  oggpack_writeinit(b);
}

void oggpack_writetrunc(oggpack_buffer *b,long bits){
  long bytes=bits>>3;
  bits-=bytes*8;
  b->ptr=b->buffer+bytes;
  b->endbit=bits;
  b->endbyte=bytes;
  *b->ptr&=mask[bits];
}

void oggpackB_writetrunc(oggpack_buffer *b,long bits){
  long bytes=bits>>3;
  bits-=bytes*8;
  b->ptr=b->buffer+bytes;
  b->endbit=bits;
  b->endbyte=bytes;
  *b->ptr&=mask8B[bits];
}

/* Takes only up to 32 bits. */
void oggpack_write(oggpack_buffer *b,unsigned long value,int bits){
  if(b->endbyte+4>=b->storage){
	b->buffer=(unsigned char*) _ogg_realloc(b->buffer,b->storage+BUFFER_INCREMENT);
	b->storage+=BUFFER_INCREMENT;
	b->ptr=b->buffer+b->endbyte;
  }

  value&=mask[bits];
  bits+=b->endbit;

  b->ptr[0]|=value<<b->endbit;

  if(bits>=8){
	b->ptr[1]=(unsigned char)(value>>(8-b->endbit));
	if(bits>=16){
	  b->ptr[2]=(unsigned char)(value>>(16-b->endbit));
	  if(bits>=24){
	b->ptr[3]=(unsigned char)(value>>(24-b->endbit));
	if(bits>=32){
	  if(b->endbit)
	    b->ptr[4]=(unsigned char)(value>>(32-b->endbit));
	  else
	    b->ptr[4]=0;
	}
	  }
	}
  }

  b->endbyte+=bits/8;
  b->ptr+=bits/8;
  b->endbit=bits&7;
}

/* Takes only up to 32 bits. */
void oggpackB_write(oggpack_buffer *b,unsigned long value,int bits){
  if(b->endbyte+4>=b->storage){
	b->buffer=(unsigned char*) _ogg_realloc(b->buffer,b->storage+BUFFER_INCREMENT);
	b->storage+=BUFFER_INCREMENT;
	b->ptr=b->buffer+b->endbyte;
  }

  value=(value&mask[bits])<<(32-bits);
  bits+=b->endbit;

  b->ptr[0]|=value>>(24+b->endbit);

  if(bits>=8){
	b->ptr[1]=(unsigned char)(value>>(16+b->endbit));
	if(bits>=16){
	  b->ptr[2]=(unsigned char)(value>>(8+b->endbit));
	  if(bits>=24){
	b->ptr[3]=(unsigned char)(value>>(b->endbit));
	if(bits>=32){
	  if(b->endbit)
	    b->ptr[4]=(unsigned char)(value<<(8-b->endbit));
	  else
	    b->ptr[4]=0;
	}
	  }
	}
  }

  b->endbyte+=bits/8;
  b->ptr+=bits/8;
  b->endbit=bits&7;
}

void oggpack_writealign(oggpack_buffer *b){
  int bits=8-b->endbit;
  if(bits<8)
	oggpack_write(b,0,bits);
}

void oggpackB_writealign(oggpack_buffer *b){
  int bits=8-b->endbit;
  if(bits<8)
	oggpackB_write(b,0,bits);
}

static void oggpack_writecopy_helper(oggpack_buffer *b,
				     void *source,
				     long bits,
				     void (*w)(oggpack_buffer *,
					       unsigned long,
					       int),
				     int msb){
  unsigned char *ptr=(unsigned char *)source;

  long bytes=bits/8;
  bits-=bytes*8;

  if(b->endbit){
	int i;
	/* unaligned copy.  Do it the hard way. */
	for(i=0;i<bytes;i++)
	  w(b,(unsigned long)(ptr[i]),8);
  }else{
	/* aligned block copy */
	if(b->endbyte+bytes+1>=b->storage){
	  b->storage=b->endbyte+bytes+BUFFER_INCREMENT;
	  b->buffer=(unsigned char*) _ogg_realloc(b->buffer,b->storage);
	  b->ptr=b->buffer+b->endbyte;
	}

	memmove(b->ptr,source,bytes);
	b->ptr+=bytes;
	b->endbyte+=bytes;
	*b->ptr=0;

  }
  if(bits){
	if(msb)
	  w(b,(unsigned long)(ptr[bytes]>>(8-bits)),bits);
	else
	  w(b,(unsigned long)(ptr[bytes]),bits);
  }
}

void oggpack_writecopy(oggpack_buffer *b,void *source,long bits){
  oggpack_writecopy_helper(b,source,bits,oggpack_write,0);
}

void oggpackB_writecopy(oggpack_buffer *b,void *source,long bits){
  oggpack_writecopy_helper(b,source,bits,oggpackB_write,1);
}

void oggpack_reset(oggpack_buffer *b){
  b->ptr=b->buffer;
  b->buffer[0]=0;
  b->endbit=b->endbyte=0;
}

void oggpackB_reset(oggpack_buffer *b){
  oggpack_reset(b);
}

void oggpack_writeclear(oggpack_buffer *b){
  _ogg_free(b->buffer);
  memset(b,0,sizeof(*b));
}

void oggpackB_writeclear(oggpack_buffer *b){
  oggpack_writeclear(b);
}

void oggpack_readinit(oggpack_buffer *b,unsigned char *buf,int bytes){
  memset(b,0,sizeof(*b));
  b->buffer=b->ptr=buf;
  b->storage=bytes;
}

void oggpackB_readinit(oggpack_buffer *b,unsigned char *buf,int bytes){
  oggpack_readinit(b,buf,bytes);
}

/* Read in bits without advancing the bitptr; bits <= 32 */
long oggpack_look(oggpack_buffer *b,int bits){
  unsigned long ret;
  unsigned long m=mask[bits];

  bits+=b->endbit;

  if(b->endbyte+4>=b->storage){
	/* not the main path */
	if(b->endbyte*8+bits>b->storage*8)return(-1);
  }

  ret=b->ptr[0]>>b->endbit;
  if(bits>8){
	ret|=b->ptr[1]<<(8-b->endbit);
	if(bits>16){
	  ret|=b->ptr[2]<<(16-b->endbit);
	  if(bits>24){
	ret|=b->ptr[3]<<(24-b->endbit);
	if(bits>32 && b->endbit)
	  ret|=b->ptr[4]<<(32-b->endbit);
	  }
	}
  }
  return(m&ret);
}

/* Read in bits without advancing the bitptr; bits <= 32 */
long oggpackB_look(oggpack_buffer *b,int bits){
  unsigned long ret;
  int m=32-bits;

  bits+=b->endbit;

  if(b->endbyte+4>=b->storage){
	/* not the main path */
	if(b->endbyte*8+bits>b->storage*8)return(-1);
  }

  ret=b->ptr[0]<<(24+b->endbit);
  if(bits>8){
	ret|=b->ptr[1]<<(16+b->endbit);
	if(bits>16){
	  ret|=b->ptr[2]<<(8+b->endbit);
	  if(bits>24){
	ret|=b->ptr[3]<<(b->endbit);
	if(bits>32 && b->endbit)
	  ret|=b->ptr[4]>>(8-b->endbit);
	  }
	}
  }
  return ((ret&0xffffffff)>>(m>>1))>>((m+1)>>1);
}

long oggpack_look1(oggpack_buffer *b){
  if(b->endbyte>=b->storage)return(-1);
  return((b->ptr[0]>>b->endbit)&1);
}

long oggpackB_look1(oggpack_buffer *b){
  if(b->endbyte>=b->storage)return(-1);
  return((b->ptr[0]>>(7-b->endbit))&1);
}

void oggpack_adv(oggpack_buffer *b,int bits){
  bits+=b->endbit;
  b->ptr+=bits/8;
  b->endbyte+=bits/8;
  b->endbit=bits&7;
}

void oggpackB_adv(oggpack_buffer *b,int bits){
  oggpack_adv(b,bits);
}

void oggpack_adv1(oggpack_buffer *b){
  if(++(b->endbit)>7){
	b->endbit=0;
	b->ptr++;
	b->endbyte++;
  }
}

void oggpackB_adv1(oggpack_buffer *b){
  oggpack_adv1(b);
}

/* bits <= 32 */
long oggpack_read(oggpack_buffer *b,int bits){
  long ret;
  unsigned long m=mask[bits];

  bits+=b->endbit;

  if(b->endbyte+4>=b->storage){
	/* not the main path */
	ret=-1L;
	if(b->endbyte*8+bits>b->storage*8)goto overflow;
  }

  ret=b->ptr[0]>>b->endbit;
  if(bits>8){
	ret|=b->ptr[1]<<(8-b->endbit);
	if(bits>16){
	  ret|=b->ptr[2]<<(16-b->endbit);
	  if(bits>24){
	ret|=b->ptr[3]<<(24-b->endbit);
	if(bits>32 && b->endbit){
	  ret|=b->ptr[4]<<(32-b->endbit);
	}
	  }
	}
  }
  ret&=m;

 overflow:

  b->ptr+=bits/8;
  b->endbyte+=bits/8;
  b->endbit=bits&7;
  return(ret);
}

/* bits <= 32 */
long oggpackB_read(oggpack_buffer *b,int bits){
  long ret;
  long m=32-bits;

  bits+=b->endbit;

  if(b->endbyte+4>=b->storage){
	/* not the main path */
	ret=-1L;
	if(b->endbyte*8+bits>b->storage*8)goto overflow;
  }

  ret=b->ptr[0]<<(24+b->endbit);
  if(bits>8){
	ret|=b->ptr[1]<<(16+b->endbit);
	if(bits>16){
	  ret|=b->ptr[2]<<(8+b->endbit);
	  if(bits>24){
	ret|=b->ptr[3]<<(b->endbit);
	if(bits>32 && b->endbit)
	  ret|=b->ptr[4]>>(8-b->endbit);
	  }
	}
  }
  ret=((ret&0xffffffffUL)>>(m>>1))>>((m+1)>>1);

 overflow:

  b->ptr+=bits/8;
  b->endbyte+=bits/8;
  b->endbit=bits&7;
  return(ret);
}

long oggpack_read1(oggpack_buffer *b){
  long ret;

  if(b->endbyte>=b->storage){
	/* not the main path */
	ret=-1L;
	goto overflow;
  }

  ret=(b->ptr[0]>>b->endbit)&1;

 overflow:

  b->endbit++;
  if(b->endbit>7){
	b->endbit=0;
	b->ptr++;
	b->endbyte++;
  }
  return(ret);
}

long oggpackB_read1(oggpack_buffer *b){
  long ret;

  if(b->endbyte>=b->storage){
	/* not the main path */
	ret=-1L;
	goto overflow;
  }

  ret=(b->ptr[0]>>(7-b->endbit))&1;

 overflow:

  b->endbit++;
  if(b->endbit>7){
	b->endbit=0;
	b->ptr++;
	b->endbyte++;
  }
  return(ret);
}

long oggpack_bytes(oggpack_buffer *b){
  return(b->endbyte+(b->endbit+7)/8);
}

long oggpack_bits(oggpack_buffer *b){
  return(b->endbyte*8+b->endbit);
}

long oggpackB_bytes(oggpack_buffer *b){
  return oggpack_bytes(b);
}

long oggpackB_bits(oggpack_buffer *b){
  return oggpack_bits(b);
}

unsigned char *oggpack_get_buffer(oggpack_buffer *b){
  return(b->buffer);
}

unsigned char *oggpackB_get_buffer(oggpack_buffer *b){
  return oggpack_get_buffer(b);
}

/* Self test of the bitwise routines; everything else is based on
   them, so they damned well better be solid. */

#ifdef _V_SELFTEST
#include <stdio.h>

static int ilog(unsigned int v){
  int ret=0;
  while(v){
	ret++;
	v>>=1;
  }
  return(ret);
}

oggpack_buffer o;
oggpack_buffer r;

void report(char *in){
  fprintf(stderr,"%s",in);
  exit(1);
}

void cliptest(unsigned long *b,int vals,int bits,int *comp,int compsize){
  long bytes,i;
  unsigned char *buffer;

  oggpack_reset(&o);
  for(i=0;i<vals;i++)
	oggpack_write(&o,b[i],bits?bits:ilog(b[i]));
  buffer=oggpack_get_buffer(&o);
  bytes=oggpack_bytes(&o);
  if(bytes!=compsize)report("wrong number of bytes!\n");
  for(i=0;i<bytes;i++)if(buffer[i]!=comp[i]){
	for(i=0;i<bytes;i++)fprintf(stderr,"%x %x\n",(int)buffer[i],(int)comp[i]);
	report("wrote incorrect value!\n");
  }
  oggpack_readinit(&r,buffer,bytes);
  for(i=0;i<vals;i++){
	int tbit=bits?bits:ilog(b[i]);
	if(oggpack_look(&r,tbit)==-1)
	  report("out of data!\n");
	if(oggpack_look(&r,tbit)!=(b[i]&mask[tbit]))
	  report("looked at incorrect value!\n");
	if(tbit==1)
	  if(oggpack_look1(&r)!=(b[i]&mask[tbit]))
	report("looked at single bit incorrect value!\n");
	if(tbit==1){
	  if(oggpack_read1(&r)!=(b[i]&mask[tbit]))
	report("read incorrect single bit value!\n");
	}else{
	if(oggpack_read(&r,tbit)!=(b[i]&mask[tbit]))
	  report("read incorrect value!\n");
	}
  }
  if(oggpack_bytes(&r)!=bytes)report("leftover bytes after read!\n");
}

void cliptestB(unsigned long *b,int vals,int bits,int *comp,int compsize){
  long bytes,i;
  unsigned char *buffer;

  oggpackB_reset(&o);
  for(i=0;i<vals;i++)
	oggpackB_write(&o,b[i],bits?bits:ilog(b[i]));
  buffer=oggpackB_get_buffer(&o);
  bytes=oggpackB_bytes(&o);
  if(bytes!=compsize)report("wrong number of bytes!\n");
  for(i=0;i<bytes;i++)if(buffer[i]!=comp[i]){
	for(i=0;i<bytes;i++)fprintf(stderr,"%x %x\n",(int)buffer[i],(int)comp[i]);
	report("wrote incorrect value!\n");
  }
  oggpackB_readinit(&r,buffer,bytes);
  for(i=0;i<vals;i++){
	int tbit=bits?bits:ilog(b[i]);
	if(oggpackB_look(&r,tbit)==-1)
	  report("out of data!\n");
	if(oggpackB_look(&r,tbit)!=(b[i]&mask[tbit]))
	  report("looked at incorrect value!\n");
	if(tbit==1)
	  if(oggpackB_look1(&r)!=(b[i]&mask[tbit]))
	report("looked at single bit incorrect value!\n");
	if(tbit==1){
	  if(oggpackB_read1(&r)!=(b[i]&mask[tbit]))
	report("read incorrect single bit value!\n");
	}else{
	if(oggpackB_read(&r,tbit)!=(b[i]&mask[tbit]))
	  report("read incorrect value!\n");
	}
  }
  if(oggpackB_bytes(&r)!=bytes)report("leftover bytes after read!\n");
}

int main(void){
  unsigned char *buffer;
  long bytes,i;
  static unsigned long testbuffer1[]=
	{18,12,103948,4325,543,76,432,52,3,65,4,56,32,42,34,21,1,23,32,546,456,7,
	   567,56,8,8,55,3,52,342,341,4,265,7,67,86,2199,21,7,1,5,1,4};
  int test1size=43;

  static unsigned long testbuffer2[]=
	{216531625L,1237861823,56732452,131,3212421,12325343,34547562,12313212,
	   1233432,534,5,346435231,14436467,7869299,76326614,167548585,
	   85525151,0,12321,1,349528352};
  int test2size=21;

  static unsigned long testbuffer3[]=
	{1,0,14,0,1,0,12,0,1,0,0,0,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,1,0,0,1,
	   0,1,30,1,1,1,0,0,1,0,0,0,12,0,11,0,1,0,0,1};
  int test3size=56;

  static unsigned long large[]=
	{2136531625L,2137861823,56732452,131,3212421,12325343,34547562,12313212,
	   1233432,534,5,2146435231,14436467,7869299,76326614,167548585,
	   85525151,0,12321,1,2146528352};

  int onesize=33;
  static int one[33]={146,25,44,151,195,15,153,176,233,131,196,65,85,172,47,40,
					34,242,223,136,35,222,211,86,171,50,225,135,214,75,172,
					223,4};
  static int oneB[33]={150,101,131,33,203,15,204,216,105,193,156,65,84,85,222,
		       8,139,145,227,126,34,55,244,171,85,100,39,195,173,18,
		       245,251,128};

  int twosize=6;
  static int two[6]={61,255,255,251,231,29};
  static int twoB[6]={247,63,255,253,249,120};

  int threesize=54;
  static int three[54]={169,2,232,252,91,132,156,36,89,13,123,176,144,32,254,
					  142,224,85,59,121,144,79,124,23,67,90,90,216,79,23,83,
					  58,135,196,61,55,129,183,54,101,100,170,37,127,126,10,
					  100,52,4,14,18,86,77,1};
  static int threeB[54]={206,128,42,153,57,8,183,251,13,89,36,30,32,144,183,
			 130,59,240,121,59,85,223,19,228,180,134,33,107,74,98,
			 233,253,196,135,63,2,110,114,50,155,90,127,37,170,104,
			 200,20,254,4,58,106,176,144,0};

  int foursize=38;
  static int four[38]={18,6,163,252,97,194,104,131,32,1,7,82,137,42,129,11,72,
					 132,60,220,112,8,196,109,64,179,86,9,137,195,208,122,169,
					 28,2,133,0,1};
  static int fourB[38]={36,48,102,83,243,24,52,7,4,35,132,10,145,21,2,93,2,41,
			1,219,184,16,33,184,54,149,170,132,18,30,29,98,229,67,
			129,10,4,32};

  int fivesize=45;
  static int five[45]={169,2,126,139,144,172,30,4,80,72,240,59,130,218,73,62,
					 241,24,210,44,4,20,0,248,116,49,135,100,110,130,181,169,
					 84,75,159,2,1,0,132,192,8,0,0,18,22};
  static int fiveB[45]={1,84,145,111,245,100,128,8,56,36,40,71,126,78,213,226,
			124,105,12,0,133,128,0,162,233,242,67,152,77,205,77,
			172,150,169,129,79,128,0,6,4,32,0,27,9,0};

  int sixsize=7;
  static int six[7]={17,177,170,242,169,19,148};
  static int sixB[7]={136,141,85,79,149,200,41};

  /* Test read/write together */
  /* Later we test against pregenerated bitstreams */
  oggpack_writeinit(&o);

  fprintf(stderr,"\nSmall preclipped packing (LSb): ");
  cliptest(testbuffer1,test1size,0,one,onesize);
  fprintf(stderr,"ok.");

  fprintf(stderr,"\nNull bit call (LSb): ");
  cliptest(testbuffer3,test3size,0,two,twosize);
  fprintf(stderr,"ok.");

  fprintf(stderr,"\nLarge preclipped packing (LSb): ");
  cliptest(testbuffer2,test2size,0,three,threesize);
  fprintf(stderr,"ok.");

  fprintf(stderr,"\n32 bit preclipped packing (LSb): ");
  oggpack_reset(&o);
  for(i=0;i<test2size;i++)
	oggpack_write(&o,large[i],32);
  buffer=oggpack_get_buffer(&o);
  bytes=oggpack_bytes(&o);
  oggpack_readinit(&r,buffer,bytes);
  for(i=0;i<test2size;i++){
	if(oggpack_look(&r,32)==-1)report("out of data. failed!");
	if(oggpack_look(&r,32)!=large[i]){
	  fprintf(stderr,"%ld != %ld (%lx!=%lx):",oggpack_look(&r,32),large[i],
	      oggpack_look(&r,32),large[i]);
	  report("read incorrect value!\n");
	}
	oggpack_adv(&r,32);
  }
  if(oggpack_bytes(&r)!=bytes)report("leftover bytes after read!\n");
  fprintf(stderr,"ok.");

  fprintf(stderr,"\nSmall unclipped packing (LSb): ");
  cliptest(testbuffer1,test1size,7,four,foursize);
  fprintf(stderr,"ok.");

  fprintf(stderr,"\nLarge unclipped packing (LSb): ");
  cliptest(testbuffer2,test2size,17,five,fivesize);
  fprintf(stderr,"ok.");

  fprintf(stderr,"\nSingle bit unclipped packing (LSb): ");
  cliptest(testbuffer3,test3size,1,six,sixsize);
  fprintf(stderr,"ok.");

  fprintf(stderr,"\nTesting read past end (LSb): ");
  oggpack_readinit(&r,"\0\0\0\0\0\0\0\0",8);
  for(i=0;i<64;i++){
	if(oggpack_read(&r,1)!=0){
	  fprintf(stderr,"failed; got -1 prematurely.\n");
	  exit(1);
	}
  }
  if(oggpack_look(&r,1)!=-1 ||
	 oggpack_read(&r,1)!=-1){
	  fprintf(stderr,"failed; read past end without -1.\n");
	  exit(1);
  }
  oggpack_readinit(&r,"\0\0\0\0\0\0\0\0",8);
  if(oggpack_read(&r,30)!=0 || oggpack_read(&r,16)!=0){
	  fprintf(stderr,"failed 2; got -1 prematurely.\n");
	  exit(1);
  }

  if(oggpack_look(&r,18)!=0 ||
	 oggpack_look(&r,18)!=0){
	fprintf(stderr,"failed 3; got -1 prematurely.\n");
	  exit(1);
  }
  if(oggpack_look(&r,19)!=-1 ||
	 oggpack_look(&r,19)!=-1){
	fprintf(stderr,"failed; read past end without -1.\n");
	  exit(1);
  }
  if(oggpack_look(&r,32)!=-1 ||
	 oggpack_look(&r,32)!=-1){
	fprintf(stderr,"failed; read past end without -1.\n");
	  exit(1);
  }
  oggpack_writeclear(&o);
  fprintf(stderr,"ok.\n");

  /********** lazy, cut-n-paste retest with MSb packing ***********/

  /* Test read/write together */
  /* Later we test against pregenerated bitstreams */
  oggpackB_writeinit(&o);

  fprintf(stderr,"\nSmall preclipped packing (MSb): ");
  cliptestB(testbuffer1,test1size,0,oneB,onesize);
  fprintf(stderr,"ok.");

  fprintf(stderr,"\nNull bit call (MSb): ");
  cliptestB(testbuffer3,test3size,0,twoB,twosize);
  fprintf(stderr,"ok.");

  fprintf(stderr,"\nLarge preclipped packing (MSb): ");
  cliptestB(testbuffer2,test2size,0,threeB,threesize);
  fprintf(stderr,"ok.");

  fprintf(stderr,"\n32 bit preclipped packing (MSb): ");
  oggpackB_reset(&o);
  for(i=0;i<test2size;i++)
	oggpackB_write(&o,large[i],32);
  buffer=oggpackB_get_buffer(&o);
  bytes=oggpackB_bytes(&o);
  oggpackB_readinit(&r,buffer,bytes);
  for(i=0;i<test2size;i++){
	if(oggpackB_look(&r,32)==-1)report("out of data. failed!");
	if(oggpackB_look(&r,32)!=large[i]){
	  fprintf(stderr,"%ld != %ld (%lx!=%lx):",oggpackB_look(&r,32),large[i],
	      oggpackB_look(&r,32),large[i]);
	  report("read incorrect value!\n");
	}
	oggpackB_adv(&r,32);
  }
  if(oggpackB_bytes(&r)!=bytes)report("leftover bytes after read!\n");
  fprintf(stderr,"ok.");

  fprintf(stderr,"\nSmall unclipped packing (MSb): ");
  cliptestB(testbuffer1,test1size,7,fourB,foursize);
  fprintf(stderr,"ok.");

  fprintf(stderr,"\nLarge unclipped packing (MSb): ");
  cliptestB(testbuffer2,test2size,17,fiveB,fivesize);
  fprintf(stderr,"ok.");

  fprintf(stderr,"\nSingle bit unclipped packing (MSb): ");
  cliptestB(testbuffer3,test3size,1,sixB,sixsize);
  fprintf(stderr,"ok.");

  fprintf(stderr,"\nTesting read past end (MSb): ");
  oggpackB_readinit(&r,"\0\0\0\0\0\0\0\0",8);
  for(i=0;i<64;i++){
	if(oggpackB_read(&r,1)!=0){
	  fprintf(stderr,"failed; got -1 prematurely.\n");
	  exit(1);
	}
  }
  if(oggpackB_look(&r,1)!=-1 ||
	 oggpackB_read(&r,1)!=-1){
	  fprintf(stderr,"failed; read past end without -1.\n");
	  exit(1);
  }
  oggpackB_readinit(&r,"\0\0\0\0\0\0\0\0",8);
  if(oggpackB_read(&r,30)!=0 || oggpackB_read(&r,16)!=0){
	  fprintf(stderr,"failed 2; got -1 prematurely.\n");
	  exit(1);
  }

  if(oggpackB_look(&r,18)!=0 ||
	 oggpackB_look(&r,18)!=0){
	fprintf(stderr,"failed 3; got -1 prematurely.\n");
	  exit(1);
  }
  if(oggpackB_look(&r,19)!=-1 ||
	 oggpackB_look(&r,19)!=-1){
	fprintf(stderr,"failed; read past end without -1.\n");
	  exit(1);
  }
  if(oggpackB_look(&r,32)!=-1 ||
	 oggpackB_look(&r,32)!=-1){
	fprintf(stderr,"failed; read past end without -1.\n");
	  exit(1);
  }
  oggpackB_writeclear(&o);
  fprintf(stderr,"ok.\n\n");

  return(0);
}
#endif  /* _V_SELFTEST */

#undef BUFFER_INCREMENT

/*** End of inlined file: bitwise.c ***/


/*** Start of inlined file: framing.c ***/
#include <stdlib.h>
#include <string.h>

/* A complete description of Ogg framing exists in docs/framing.html */

int ogg_page_version(ogg_page *og){
  return((int)(og->header[4]));
}

int ogg_page_continued(ogg_page *og){
  return((int)(og->header[5]&0x01));
}

int ogg_page_bos(ogg_page *og){
  return((int)(og->header[5]&0x02));
}

int ogg_page_eos(ogg_page *og){
  return((int)(og->header[5]&0x04));
}

ogg_int64_t ogg_page_granulepos(ogg_page *og){
  unsigned char *page=og->header;
  ogg_int64_t granulepos=page[13]&(0xff);
  granulepos= (granulepos<<8)|(page[12]&0xff);
  granulepos= (granulepos<<8)|(page[11]&0xff);
  granulepos= (granulepos<<8)|(page[10]&0xff);
  granulepos= (granulepos<<8)|(page[9]&0xff);
  granulepos= (granulepos<<8)|(page[8]&0xff);
  granulepos= (granulepos<<8)|(page[7]&0xff);
  granulepos= (granulepos<<8)|(page[6]&0xff);
  return(granulepos);
}

int ogg_page_serialno(ogg_page *og){
  return(og->header[14] |
	 (og->header[15]<<8) |
	 (og->header[16]<<16) |
	 (og->header[17]<<24));
}

long ogg_page_pageno(ogg_page *og){
  return(og->header[18] |
	 (og->header[19]<<8) |
	 (og->header[20]<<16) |
	 (og->header[21]<<24));
}

/* returns the number of packets that are completed on this page (if
   the leading packet is begun on a previous page, but ends on this
   page, it's counted */

/* NOTE:
If a page consists of a packet begun on a previous page, and a new
packet begun (but not completed) on this page, the return will be:
  ogg_page_packets(page)   ==1,
  ogg_page_continued(page) !=0

If a page happens to be a single packet that was begun on a
previous page, and spans to the next page (in the case of a three or
more page packet), the return will be:
  ogg_page_packets(page)   ==0,
  ogg_page_continued(page) !=0
*/

int ogg_page_packets(ogg_page *og){
  int i,n=og->header[26],count=0;
  for(i=0;i<n;i++)
	if(og->header[27+i]<255)count++;
  return(count);
}

#if 0
/* helper to initialize lookup for direct-table CRC (illustrative; we
   use the static init below) */

static ogg_uint32_t _ogg_crc_entry(unsigned long index){
  int           i;
  unsigned long r;

  r = index << 24;
  for (i=0; i<8; i++)
	if (r & 0x80000000UL)
	  r = (r << 1) ^ 0x04c11db7; /* The same as the ethernet generator
				    polynomial, although we use an
				    unreflected alg and an init/final
				    of 0, not 0xffffffff */
	else
	   r<<=1;
 return (r & 0xffffffffUL);
}
#endif

static const ogg_uint32_t crc_lookup[256]={
  0x00000000,0x04c11db7,0x09823b6e,0x0d4326d9,
  0x130476dc,0x17c56b6b,0x1a864db2,0x1e475005,
  0x2608edb8,0x22c9f00f,0x2f8ad6d6,0x2b4bcb61,
  0x350c9b64,0x31cd86d3,0x3c8ea00a,0x384fbdbd,
  0x4c11db70,0x48d0c6c7,0x4593e01e,0x4152fda9,
  0x5f15adac,0x5bd4b01b,0x569796c2,0x52568b75,
  0x6a1936c8,0x6ed82b7f,0x639b0da6,0x675a1011,
  0x791d4014,0x7ddc5da3,0x709f7b7a,0x745e66cd,
  0x9823b6e0,0x9ce2ab57,0x91a18d8e,0x95609039,
  0x8b27c03c,0x8fe6dd8b,0x82a5fb52,0x8664e6e5,
  0xbe2b5b58,0xbaea46ef,0xb7a96036,0xb3687d81,
  0xad2f2d84,0xa9ee3033,0xa4ad16ea,0xa06c0b5d,
  0xd4326d90,0xd0f37027,0xddb056fe,0xd9714b49,
  0xc7361b4c,0xc3f706fb,0xceb42022,0xca753d95,
  0xf23a8028,0xf6fb9d9f,0xfbb8bb46,0xff79a6f1,
  0xe13ef6f4,0xe5ffeb43,0xe8bccd9a,0xec7dd02d,
  0x34867077,0x30476dc0,0x3d044b19,0x39c556ae,
  0x278206ab,0x23431b1c,0x2e003dc5,0x2ac12072,
  0x128e9dcf,0x164f8078,0x1b0ca6a1,0x1fcdbb16,
  0x018aeb13,0x054bf6a4,0x0808d07d,0x0cc9cdca,
  0x7897ab07,0x7c56b6b0,0x71159069,0x75d48dde,
  0x6b93dddb,0x6f52c06c,0x6211e6b5,0x66d0fb02,
  0x5e9f46bf,0x5a5e5b08,0x571d7dd1,0x53dc6066,
  0x4d9b3063,0x495a2dd4,0x44190b0d,0x40d816ba,
  0xaca5c697,0xa864db20,0xa527fdf9,0xa1e6e04e,
  0xbfa1b04b,0xbb60adfc,0xb6238b25,0xb2e29692,
  0x8aad2b2f,0x8e6c3698,0x832f1041,0x87ee0df6,
  0x99a95df3,0x9d684044,0x902b669d,0x94ea7b2a,
  0xe0b41de7,0xe4750050,0xe9362689,0xedf73b3e,
  0xf3b06b3b,0xf771768c,0xfa325055,0xfef34de2,
  0xc6bcf05f,0xc27dede8,0xcf3ecb31,0xcbffd686,
  0xd5b88683,0xd1799b34,0xdc3abded,0xd8fba05a,
  0x690ce0ee,0x6dcdfd59,0x608edb80,0x644fc637,
  0x7a089632,0x7ec98b85,0x738aad5c,0x774bb0eb,
  0x4f040d56,0x4bc510e1,0x46863638,0x42472b8f,
  0x5c007b8a,0x58c1663d,0x558240e4,0x51435d53,
  0x251d3b9e,0x21dc2629,0x2c9f00f0,0x285e1d47,
  0x36194d42,0x32d850f5,0x3f9b762c,0x3b5a6b9b,
  0x0315d626,0x07d4cb91,0x0a97ed48,0x0e56f0ff,
  0x1011a0fa,0x14d0bd4d,0x19939b94,0x1d528623,
  0xf12f560e,0xf5ee4bb9,0xf8ad6d60,0xfc6c70d7,
  0xe22b20d2,0xe6ea3d65,0xeba91bbc,0xef68060b,
  0xd727bbb6,0xd3e6a601,0xdea580d8,0xda649d6f,
  0xc423cd6a,0xc0e2d0dd,0xcda1f604,0xc960ebb3,
  0xbd3e8d7e,0xb9ff90c9,0xb4bcb610,0xb07daba7,
  0xae3afba2,0xaafbe615,0xa7b8c0cc,0xa379dd7b,
  0x9b3660c6,0x9ff77d71,0x92b45ba8,0x9675461f,
  0x8832161a,0x8cf30bad,0x81b02d74,0x857130c3,
  0x5d8a9099,0x594b8d2e,0x5408abf7,0x50c9b640,
  0x4e8ee645,0x4a4ffbf2,0x470cdd2b,0x43cdc09c,
  0x7b827d21,0x7f436096,0x7200464f,0x76c15bf8,
  0x68860bfd,0x6c47164a,0x61043093,0x65c52d24,
  0x119b4be9,0x155a565e,0x18197087,0x1cd86d30,
  0x029f3d35,0x065e2082,0x0b1d065b,0x0fdc1bec,
  0x3793a651,0x3352bbe6,0x3e119d3f,0x3ad08088,
  0x2497d08d,0x2056cd3a,0x2d15ebe3,0x29d4f654,
  0xc5a92679,0xc1683bce,0xcc2b1d17,0xc8ea00a0,
  0xd6ad50a5,0xd26c4d12,0xdf2f6bcb,0xdbee767c,
  0xe3a1cbc1,0xe760d676,0xea23f0af,0xeee2ed18,
  0xf0a5bd1d,0xf464a0aa,0xf9278673,0xfde69bc4,
  0x89b8fd09,0x8d79e0be,0x803ac667,0x84fbdbd0,
  0x9abc8bd5,0x9e7d9662,0x933eb0bb,0x97ffad0c,
  0xafb010b1,0xab710d06,0xa6322bdf,0xa2f33668,
  0xbcb4666d,0xb8757bda,0xb5365d03,0xb1f740b4};

/* init the encode/decode logical stream state */

int ogg_stream_init(ogg_stream_state *os,int serialno){
  if(os){
	memset(os,0,sizeof(*os));
	os->body_storage=16*1024;
	os->body_data=(unsigned char*) _ogg_malloc(os->body_storage*sizeof(*os->body_data));

	os->lacing_storage=1024;
	os->lacing_vals=(int*) _ogg_malloc(os->lacing_storage*sizeof(*os->lacing_vals));
	os->granule_vals=(ogg_int64_t*) _ogg_malloc(os->lacing_storage*sizeof(*os->granule_vals));

	os->serialno=serialno;

	return(0);
  }
  return(-1);
}

/* _clear does not free os, only the non-flat storage within */
int ogg_stream_clear(ogg_stream_state *os){
  if(os){
	if(os->body_data)_ogg_free(os->body_data);
	if(os->lacing_vals)_ogg_free(os->lacing_vals);
	if(os->granule_vals)_ogg_free(os->granule_vals);

	memset(os,0,sizeof(*os));
  }
  return(0);
}

int ogg_stream_destroy(ogg_stream_state *os){
  if(os){
	ogg_stream_clear(os);
	_ogg_free(os);
  }
  return(0);
}

/* Helpers for ogg_stream_encode; this keeps the structure and
   what's happening fairly clear */

static void _os_body_expand(ogg_stream_state *os,int needed){
  if(os->body_storage<=os->body_fill+needed){
	os->body_storage+=(needed+1024);
	os->body_data=(unsigned char*) _ogg_realloc(os->body_data,os->body_storage*sizeof(*os->body_data));
  }
}

static void _os_lacing_expand(ogg_stream_state *os,int needed){
  if(os->lacing_storage<=os->lacing_fill+needed){
	os->lacing_storage+=(needed+32);
	os->lacing_vals=(int*)_ogg_realloc(os->lacing_vals,os->lacing_storage*sizeof(*os->lacing_vals));
	os->granule_vals=(ogg_int64_t*)_ogg_realloc(os->granule_vals,os->lacing_storage*sizeof(*os->granule_vals));
  }
}

/* checksum the page */
/* Direct table CRC; note that this will be faster in the future if we
   perform the checksum silmultaneously with other copies */

void ogg_page_checksum_set(ogg_page *og){
  if(og){
	ogg_uint32_t crc_reg=0;
	int i;

	/* safety; needed for API behavior, but not framing code */
	og->header[22]=0;
	og->header[23]=0;
	og->header[24]=0;
	og->header[25]=0;

	for(i=0;i<og->header_len;i++)
	  crc_reg=(crc_reg<<8)^crc_lookup[((crc_reg >> 24)&0xff)^og->header[i]];
	for(i=0;i<og->body_len;i++)
	  crc_reg=(crc_reg<<8)^crc_lookup[((crc_reg >> 24)&0xff)^og->body[i]];

	og->header[22]=(unsigned char)(crc_reg&0xff);
	og->header[23]=(unsigned char)((crc_reg>>8)&0xff);
	og->header[24]=(unsigned char)((crc_reg>>16)&0xff);
	og->header[25]=(unsigned char)((crc_reg>>24)&0xff);
  }
}

/* submit data to the internal buffer of the framing engine */
int ogg_stream_packetin(ogg_stream_state *os,ogg_packet *op){
  int lacing_vals=op->bytes/255+1,i;

  if(os->body_returned){
	/* advance packet data according to the body_returned pointer. We
	   had to keep it around to return a pointer into the buffer last
	   call */

	os->body_fill-=os->body_returned;
	if(os->body_fill)
	  memmove(os->body_data,os->body_data+os->body_returned,
	      os->body_fill);
	os->body_returned=0;
  }

  /* make sure we have the buffer storage */
  _os_body_expand(os,op->bytes);
  _os_lacing_expand(os,lacing_vals);

  /* Copy in the submitted packet.  Yes, the copy is a waste; this is
	 the liability of overly clean abstraction for the time being.  It
	 will actually be fairly easy to eliminate the extra copy in the
	 future */

  memcpy(os->body_data+os->body_fill,op->packet,op->bytes);
  os->body_fill+=op->bytes;

  /* Store lacing vals for this packet */
  for(i=0;i<lacing_vals-1;i++){
	os->lacing_vals[os->lacing_fill+i]=255;
	os->granule_vals[os->lacing_fill+i]=os->granulepos;
  }
  os->lacing_vals[os->lacing_fill+i]=(op->bytes)%255;
  os->granulepos=os->granule_vals[os->lacing_fill+i]=op->granulepos;

  /* flag the first segment as the beginning of the packet */
  os->lacing_vals[os->lacing_fill]|= 0x100;

  os->lacing_fill+=lacing_vals;

  /* for the sake of completeness */
  os->packetno++;

  if(op->e_o_s)os->e_o_s=1;

  return(0);
}

/* This will flush remaining packets into a page (returning nonzero),
   even if there is not enough data to trigger a flush normally
   (undersized page). If there are no packets or partial packets to
   flush, ogg_stream_flush returns 0.  Note that ogg_stream_flush will
   try to flush a normal sized page like ogg_stream_pageout; a call to
   ogg_stream_flush does not guarantee that all packets have flushed.
   Only a return value of 0 from ogg_stream_flush indicates all packet
   data is flushed into pages.

   since ogg_stream_flush will flush the last page in a stream even if
   it's undersized, you almost certainly want to use ogg_stream_pageout
   (and *not* ogg_stream_flush) unless you specifically need to flush
   an page regardless of size in the middle of a stream. */

int ogg_stream_flush(ogg_stream_state *os,ogg_page *og){
  int i;
  int vals=0;
  int maxvals=(os->lacing_fill>255?255:os->lacing_fill);
  int bytes=0;
  long acc=0;
  ogg_int64_t granule_pos=-1;

  if(maxvals==0)return(0);

  /* construct a page */
  /* decide how many segments to include */

  /* If this is the initial header case, the first page must only include
	 the initial header packet */
  if(os->b_o_s==0){  /* 'initial header page' case */
	granule_pos=0;
	for(vals=0;vals<maxvals;vals++){
	  if((os->lacing_vals[vals]&0x0ff)<255){
	vals++;
	break;
	  }
	}
  }else{
	for(vals=0;vals<maxvals;vals++){
	  if(acc>4096)break;
	  acc+=os->lacing_vals[vals]&0x0ff;
	  if((os->lacing_vals[vals]&0xff)<255)
		granule_pos=os->granule_vals[vals];
	}
  }

  /* construct the header in temp storage */
  memcpy(os->header,"OggS",4);

  /* stream structure version */
  os->header[4]=0x00;

  /* continued packet flag? */
  os->header[5]=0x00;
  if((os->lacing_vals[0]&0x100)==0)os->header[5]|=0x01;
  /* first page flag? */
  if(os->b_o_s==0)os->header[5]|=0x02;
  /* last page flag? */
  if(os->e_o_s && os->lacing_fill==vals)os->header[5]|=0x04;
  os->b_o_s=1;

  /* 64 bits of PCM position */
  for(i=6;i<14;i++){
	os->header[i]=(unsigned char)(granule_pos&0xff);
	granule_pos>>=8;
  }

  /* 32 bits of stream serial number */
  {
	long serialno=os->serialno;
	for(i=14;i<18;i++){
	  os->header[i]=(unsigned char)(serialno&0xff);
	  serialno>>=8;
	}
  }

  /* 32 bits of page counter (we have both counter and page header
	 because this val can roll over) */
  if(os->pageno==-1)os->pageno=0; /* because someone called
				     stream_reset; this would be a
				     strange thing to do in an
				     encode stream, but it has
				     plausible uses */
  {
	long pageno=os->pageno++;
	for(i=18;i<22;i++){
	  os->header[i]=(unsigned char)(pageno&0xff);
	  pageno>>=8;
	}
  }

  /* zero for computation; filled in later */
  os->header[22]=0;
  os->header[23]=0;
  os->header[24]=0;
  os->header[25]=0;

  /* segment table */
  os->header[26]=(unsigned char)(vals&0xff);
  for(i=0;i<vals;i++)
	bytes+=os->header[i+27]=(unsigned char)(os->lacing_vals[i]&0xff);

  /* set pointers in the ogg_page struct */
  og->header=os->header;
  og->header_len=os->header_fill=vals+27;
  og->body=os->body_data+os->body_returned;
  og->body_len=bytes;

  /* advance the lacing data and set the body_returned pointer */

  os->lacing_fill-=vals;
  memmove(os->lacing_vals,os->lacing_vals+vals,os->lacing_fill*sizeof(*os->lacing_vals));
  memmove(os->granule_vals,os->granule_vals+vals,os->lacing_fill*sizeof(*os->granule_vals));
  os->body_returned+=bytes;

  /* calculate the checksum */

  ogg_page_checksum_set(og);

  /* done */
  return(1);
}

/* This constructs pages from buffered packet segments.  The pointers
returned are to static buffers; do not free. The returned buffers are
good only until the next call (using the same ogg_stream_state) */

int ogg_stream_pageout(ogg_stream_state *os, ogg_page *og){

  if((os->e_o_s&&os->lacing_fill) ||          /* 'were done, now flush' case */
	 os->body_fill-os->body_returned > 4096 ||/* 'page nominal size' case */
	 os->lacing_fill>=255 ||                  /* 'segment table full' case */
	 (os->lacing_fill&&!os->b_o_s)){          /* 'initial header page' case */

	return(ogg_stream_flush(os,og));
  }

  /* not enough data to construct a page and not end of stream */
  return(0);
}

int ogg_stream_eos(ogg_stream_state *os){
  return os->e_o_s;
}

/* DECODING PRIMITIVES: packet streaming layer **********************/

/* This has two layers to place more of the multi-serialno and paging
   control in the application's hands.  First, we expose a data buffer
   using ogg_sync_buffer().  The app either copies into the
   buffer, or passes it directly to read(), etc.  We then call
   ogg_sync_wrote() to tell how many bytes we just added.

   Pages are returned (pointers into the buffer in ogg_sync_state)
   by ogg_sync_pageout().  The page is then submitted to
   ogg_stream_pagein() along with the appropriate
   ogg_stream_state* (ie, matching serialno).  We then get raw
   packets out calling ogg_stream_packetout() with a
   ogg_stream_state. */

/* initialize the struct to a known state */
int ogg_sync_init(ogg_sync_state *oy){
  if(oy){
	memset(oy,0,sizeof(*oy));
  }
  return(0);
}

/* clear non-flat storage within */
int ogg_sync_clear(ogg_sync_state *oy){
  if(oy){
	if(oy->data)_ogg_free(oy->data);
	ogg_sync_init(oy);
  }
  return(0);
}

int ogg_sync_destroy(ogg_sync_state *oy){
  if(oy){
	ogg_sync_clear(oy);
	_ogg_free(oy);
  }
  return(0);
}

char *ogg_sync_buffer(ogg_sync_state *oy, long size){

  /* first, clear out any space that has been previously returned */
  if(oy->returned){
	oy->fill-=oy->returned;
	if(oy->fill>0)
	  memmove(oy->data,oy->data+oy->returned,oy->fill);
	oy->returned=0;
  }

  if(size>oy->storage-oy->fill){
	/* We need to extend the internal buffer */
	long newsize=size+oy->fill+4096; /* an extra page to be nice */

	if(oy->data)
	  oy->data=(unsigned char*) _ogg_realloc(oy->data,newsize);
	else
	  oy->data=(unsigned char*) _ogg_malloc(newsize);
	oy->storage=newsize;
  }

  /* expose a segment at least as large as requested at the fill mark */
  return((char *)oy->data+oy->fill);
}

int ogg_sync_wrote(ogg_sync_state *oy, long bytes){
  if(oy->fill+bytes>oy->storage)return(-1);
  oy->fill+=bytes;
  return(0);
}

/* sync the stream.  This is meant to be useful for finding page
   boundaries.

   return values for this:
  -n) skipped n bytes
   0) page not ready; more data (no bytes skipped)
   n) page synced at current location; page length n bytes

*/

long ogg_sync_pageseek(ogg_sync_state *oy,ogg_page *og){
  unsigned char *page=oy->data+oy->returned;
  unsigned char *next;
  long bytes=oy->fill-oy->returned;

  if(oy->headerbytes==0){
	int headerbytes,i;
	if(bytes<27)return(0); /* not enough for a header */

	/* verify capture pattern */
	if(memcmp(page,"OggS",4))goto sync_fail;

	headerbytes=page[26]+27;
	if(bytes<headerbytes)return(0); /* not enough for header + seg table */

	/* count up body length in the segment table */

	for(i=0;i<page[26];i++)
	  oy->bodybytes+=page[27+i];
	oy->headerbytes=headerbytes;
  }

  if(oy->bodybytes+oy->headerbytes>bytes)return(0);

  /* The whole test page is buffered.  Verify the checksum */
  {
	/* Grab the checksum bytes, set the header field to zero */
	char chksum[4];
	ogg_page log;

	memcpy(chksum,page+22,4);
	memset(page+22,0,4);

	/* set up a temp page struct and recompute the checksum */
	log.header=page;
	log.header_len=oy->headerbytes;
	log.body=page+oy->headerbytes;
	log.body_len=oy->bodybytes;
	ogg_page_checksum_set(&log);

	/* Compare */
	if(memcmp(chksum,page+22,4)){
	  /* D'oh.  Mismatch! Corrupt page (or miscapture and not a page
	 at all) */
	  /* replace the computed checksum with the one actually read in */
	  memcpy(page+22,chksum,4);

	  /* Bad checksum. Lose sync */
	  goto sync_fail;
	}
  }

  /* yes, have a whole page all ready to go */
  {
	unsigned char *page=oy->data+oy->returned;
	long bytes;

	if(og){
	  og->header=page;
	  og->header_len=oy->headerbytes;
	  og->body=page+oy->headerbytes;
	  og->body_len=oy->bodybytes;
	}

	oy->unsynced=0;
	oy->returned+=(bytes=oy->headerbytes+oy->bodybytes);
	oy->headerbytes=0;
	oy->bodybytes=0;
	return(bytes);
  }

 sync_fail:

  oy->headerbytes=0;
  oy->bodybytes=0;

  /* search for possible capture */
  next=(unsigned char*)memchr(page+1,'O',bytes-1);
  if(!next)
	next=oy->data+oy->fill;

  oy->returned=next-oy->data;
  return(-(next-page));
}

/* sync the stream and get a page.  Keep trying until we find a page.
   Supress 'sync errors' after reporting the first.

   return values:
   -1) recapture (hole in data)
	0) need more data
	1) page returned

   Returns pointers into buffered data; invalidated by next call to
   _stream, _clear, _init, or _buffer */

int ogg_sync_pageout(ogg_sync_state *oy, ogg_page *og){

  /* all we need to do is verify a page at the head of the stream
	 buffer.  If it doesn't verify, we look for the next potential
	 frame */

  for(;;){
	long ret=ogg_sync_pageseek(oy,og);
	if(ret>0){
	  /* have a page */
	  return(1);
	}
	if(ret==0){
	  /* need more data */
	  return(0);
	}

	/* head did not start a synced page... skipped some bytes */
	if(!oy->unsynced){
	  oy->unsynced=1;
	  return(-1);
	}

	/* loop. keep looking */

  }
}

/* add the incoming page to the stream state; we decompose the page
   into packet segments here as well. */

int ogg_stream_pagein(ogg_stream_state *os, ogg_page *og){
  unsigned char *header=og->header;
  unsigned char *body=og->body;
  long           bodysize=og->body_len;
  int            segptr=0;

  int version=ogg_page_version(og);
  int continued=ogg_page_continued(og);
  int bos=ogg_page_bos(og);
  int eos=ogg_page_eos(og);
  ogg_int64_t granulepos=ogg_page_granulepos(og);
  int serialno=ogg_page_serialno(og);
  long pageno=ogg_page_pageno(og);
  int segments=header[26];

  /* clean up 'returned data' */
  {
	long lr=os->lacing_returned;
	long br=os->body_returned;

	/* body data */
	if(br){
	  os->body_fill-=br;
	  if(os->body_fill)
	memmove(os->body_data,os->body_data+br,os->body_fill);
	  os->body_returned=0;
	}

	if(lr){
	  /* segment table */
	  if(os->lacing_fill-lr){
	memmove(os->lacing_vals,os->lacing_vals+lr,
		(os->lacing_fill-lr)*sizeof(*os->lacing_vals));
	memmove(os->granule_vals,os->granule_vals+lr,
		(os->lacing_fill-lr)*sizeof(*os->granule_vals));
	  }
	  os->lacing_fill-=lr;
	  os->lacing_packet-=lr;
	  os->lacing_returned=0;
	}
  }

  /* check the serial number */
  if(serialno!=os->serialno)return(-1);
  if(version>0)return(-1);

  _os_lacing_expand(os,segments+1);

  /* are we in sequence? */
  if(pageno!=os->pageno){
	int i;

	/* unroll previous partial packet (if any) */
	for(i=os->lacing_packet;i<os->lacing_fill;i++)
	  os->body_fill-=os->lacing_vals[i]&0xff;
	os->lacing_fill=os->lacing_packet;

	/* make a note of dropped data in segment table */
	if(os->pageno!=-1){
	  os->lacing_vals[os->lacing_fill++]=0x400;
	  os->lacing_packet++;
	}
  }

  /* are we a 'continued packet' page?  If so, we may need to skip
	 some segments */
  if(continued){
	if(os->lacing_fill<1 ||
	   os->lacing_vals[os->lacing_fill-1]==0x400){
	  bos=0;
	  for(;segptr<segments;segptr++){
	int val=header[27+segptr];
	body+=val;
	bodysize-=val;
	if(val<255){
	  segptr++;
	  break;
	}
	  }
	}
  }

  if(bodysize){
	_os_body_expand(os,bodysize);
	memcpy(os->body_data+os->body_fill,body,bodysize);
	os->body_fill+=bodysize;
  }

  {
	int saved=-1;
	while(segptr<segments){
	  int val=header[27+segptr];
	  os->lacing_vals[os->lacing_fill]=val;
	  os->granule_vals[os->lacing_fill]=-1;

	  if(bos){
	os->lacing_vals[os->lacing_fill]|=0x100;
	bos=0;
	  }

	  if(val<255)saved=os->lacing_fill;

	  os->lacing_fill++;
	  segptr++;

	  if(val<255)os->lacing_packet=os->lacing_fill;
	}

	/* set the granulepos on the last granuleval of the last full packet */
	if(saved!=-1){
	  os->granule_vals[saved]=granulepos;
	}

  }

  if(eos){
	os->e_o_s=1;
	if(os->lacing_fill>0)
	  os->lacing_vals[os->lacing_fill-1]|=0x200;
  }

  os->pageno=pageno+1;

  return(0);
}

/* clear things to an initial state.  Good to call, eg, before seeking */
int ogg_sync_reset(ogg_sync_state *oy){
  oy->fill=0;
  oy->returned=0;
  oy->unsynced=0;
  oy->headerbytes=0;
  oy->bodybytes=0;
  return(0);
}

int ogg_stream_reset(ogg_stream_state *os){
  os->body_fill=0;
  os->body_returned=0;

  os->lacing_fill=0;
  os->lacing_packet=0;
  os->lacing_returned=0;

  os->header_fill=0;

  os->e_o_s=0;
  os->b_o_s=0;
  os->pageno=-1;
  os->packetno=0;
  os->granulepos=0;

  return(0);
}

int ogg_stream_reset_serialno(ogg_stream_state *os,int serialno){
  ogg_stream_reset(os);
  os->serialno=serialno;
  return(0);
}

static int _packetout(ogg_stream_state *os,ogg_packet *op,int adv){

  /* The last part of decode. We have the stream broken into packet
	 segments.  Now we need to group them into packets (or return the
	 out of sync markers) */

  int ptr=os->lacing_returned;

  if(os->lacing_packet<=ptr)return(0);

  if(os->lacing_vals[ptr]&0x400){
	/* we need to tell the codec there's a gap; it might need to
	   handle previous packet dependencies. */
	os->lacing_returned++;
	os->packetno++;
	return(-1);
  }

  if(!op && !adv)return(1); /* just using peek as an inexpensive way
							   to ask if there's a whole packet
							   waiting */

  /* Gather the whole packet. We'll have no holes or a partial packet */
  {
	int size=os->lacing_vals[ptr]&0xff;
	int bytes=size;
	int eos=os->lacing_vals[ptr]&0x200; /* last packet of the stream? */
	int bos=os->lacing_vals[ptr]&0x100; /* first packet of the stream? */

	while(size==255){
	  int val=os->lacing_vals[++ptr];
	  size=val&0xff;
	  if(val&0x200)eos=0x200;
	  bytes+=size;
	}

	if(op){
	  op->e_o_s=eos;
	  op->b_o_s=bos;
	  op->packet=os->body_data+os->body_returned;
	  op->packetno=os->packetno;
	  op->granulepos=os->granule_vals[ptr];
	  op->bytes=bytes;
	}

	if(adv){
	  os->body_returned+=bytes;
	  os->lacing_returned=ptr+1;
	  os->packetno++;
	}
  }
  return(1);
}

int ogg_stream_packetout(ogg_stream_state *os,ogg_packet *op){
  return _packetout(os,op,1);
}

int ogg_stream_packetpeek(ogg_stream_state *os,ogg_packet *op){
  return _packetout(os,op,0);
}

void ogg_packet_clear(ogg_packet *op) {
  _ogg_free(op->packet);
  memset(op, 0, sizeof(*op));
}

#ifdef _V_SELFTEST
#include <stdio.h>

ogg_stream_state os_en, os_de;
ogg_sync_state oy;

void checkpacket(ogg_packet *op,int len, int no, int pos){
  long j;
  static int sequence=0;
  static int lastno=0;

  if(op->bytes!=len){
	fprintf(stderr,"incorrect packet length!\n");
	exit(1);
  }
  if(op->granulepos!=pos){
	fprintf(stderr,"incorrect packet position!\n");
	exit(1);
  }

  /* packet number just follows sequence/gap; adjust the input number
	 for that */
  if(no==0){
	sequence=0;
  }else{
	sequence++;
	if(no>lastno+1)
	  sequence++;
  }
  lastno=no;
  if(op->packetno!=sequence){
	fprintf(stderr,"incorrect packet sequence %ld != %d\n",
	    (long)(op->packetno),sequence);
	exit(1);
  }

  /* Test data */
  for(j=0;j<op->bytes;j++)
	if(op->packet[j]!=((j+no)&0xff)){
	  fprintf(stderr,"body data mismatch (1) at pos %ld: %x!=%lx!\n\n",
	      j,op->packet[j],(j+no)&0xff);
	  exit(1);
	}
}

void check_page(unsigned char *data,const int *header,ogg_page *og){
  long j;
  /* Test data */
  for(j=0;j<og->body_len;j++)
	if(og->body[j]!=data[j]){
	  fprintf(stderr,"body data mismatch (2) at pos %ld: %x!=%x!\n\n",
	      j,data[j],og->body[j]);
	  exit(1);
	}

  /* Test header */
  for(j=0;j<og->header_len;j++){
	if(og->header[j]!=header[j]){
	  fprintf(stderr,"header content mismatch at pos %ld:\n",j);
	  for(j=0;j<header[26]+27;j++)
	fprintf(stderr," (%ld)%02x:%02x",j,header[j],og->header[j]);
	  fprintf(stderr,"\n");
	  exit(1);
	}
  }
  if(og->header_len!=header[26]+27){
	fprintf(stderr,"header length incorrect! (%ld!=%d)\n",
	    og->header_len,header[26]+27);
	exit(1);
  }
}

void print_header(ogg_page *og){
  int j;
  fprintf(stderr,"\nHEADER:\n");
  fprintf(stderr,"  capture: %c %c %c %c  version: %d  flags: %x\n",
	  og->header[0],og->header[1],og->header[2],og->header[3],
	  (int)og->header[4],(int)og->header[5]);

  fprintf(stderr,"  granulepos: %d  serialno: %d  pageno: %ld\n",
	  (og->header[9]<<24)|(og->header[8]<<16)|
	  (og->header[7]<<8)|og->header[6],
	  (og->header[17]<<24)|(og->header[16]<<16)|
	  (og->header[15]<<8)|og->header[14],
	  ((long)(og->header[21])<<24)|(og->header[20]<<16)|
	  (og->header[19]<<8)|og->header[18]);

  fprintf(stderr,"  checksum: %02x:%02x:%02x:%02x\n  segments: %d (",
	  (int)og->header[22],(int)og->header[23],
	  (int)og->header[24],(int)og->header[25],
	  (int)og->header[26]);

  for(j=27;j<og->header_len;j++)
	fprintf(stderr,"%d ",(int)og->header[j]);
  fprintf(stderr,")\n\n");
}

void copy_page(ogg_page *og){
  unsigned char *temp=_ogg_malloc(og->header_len);
  memcpy(temp,og->header,og->header_len);
  og->header=temp;

  temp=_ogg_malloc(og->body_len);
  memcpy(temp,og->body,og->body_len);
  og->body=temp;
}

void free_page(ogg_page *og){
  _ogg_free (og->header);
  _ogg_free (og->body);
}

void error(void){
  fprintf(stderr,"error!\n");
  exit(1);
}

/* 17 only */
const int head1_0[] = {0x4f,0x67,0x67,0x53,0,0x06,
		       0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		       0x01,0x02,0x03,0x04,0,0,0,0,
		       0x15,0xed,0xec,0x91,
		       1,
		       17};

/* 17, 254, 255, 256, 500, 510, 600 byte, pad */
const int head1_1[] = {0x4f,0x67,0x67,0x53,0,0x02,
		       0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		       0x01,0x02,0x03,0x04,0,0,0,0,
		       0x59,0x10,0x6c,0x2c,
		       1,
		       17};
const int head2_1[] = {0x4f,0x67,0x67,0x53,0,0x04,
		       0x07,0x18,0x00,0x00,0x00,0x00,0x00,0x00,
		       0x01,0x02,0x03,0x04,1,0,0,0,
		       0x89,0x33,0x85,0xce,
		       13,
		       254,255,0,255,1,255,245,255,255,0,
		       255,255,90};

/* nil packets; beginning,middle,end */
const int head1_2[] = {0x4f,0x67,0x67,0x53,0,0x02,
		       0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		       0x01,0x02,0x03,0x04,0,0,0,0,
		       0xff,0x7b,0x23,0x17,
		       1,
		       0};
const int head2_2[] = {0x4f,0x67,0x67,0x53,0,0x04,
		       0x07,0x28,0x00,0x00,0x00,0x00,0x00,0x00,
		       0x01,0x02,0x03,0x04,1,0,0,0,
		       0x5c,0x3f,0x66,0xcb,
		       17,
		       17,254,255,0,0,255,1,0,255,245,255,255,0,
		       255,255,90,0};

/* large initial packet */
const int head1_3[] = {0x4f,0x67,0x67,0x53,0,0x02,
		       0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		       0x01,0x02,0x03,0x04,0,0,0,0,
		       0x01,0x27,0x31,0xaa,
		       18,
		       255,255,255,255,255,255,255,255,
		       255,255,255,255,255,255,255,255,255,10};

const int head2_3[] = {0x4f,0x67,0x67,0x53,0,0x04,
		       0x07,0x08,0x00,0x00,0x00,0x00,0x00,0x00,
		       0x01,0x02,0x03,0x04,1,0,0,0,
		       0x7f,0x4e,0x8a,0xd2,
		       4,
		       255,4,255,0};

/* continuing packet test */
const int head1_4[] = {0x4f,0x67,0x67,0x53,0,0x02,
		       0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		       0x01,0x02,0x03,0x04,0,0,0,0,
		       0xff,0x7b,0x23,0x17,
		       1,
		       0};

const int head2_4[] = {0x4f,0x67,0x67,0x53,0,0x00,
		       0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
		       0x01,0x02,0x03,0x04,1,0,0,0,
		       0x54,0x05,0x51,0xc8,
		       17,
		       255,255,255,255,255,255,255,255,
		       255,255,255,255,255,255,255,255,255};

const int head3_4[] = {0x4f,0x67,0x67,0x53,0,0x05,
		       0x07,0x0c,0x00,0x00,0x00,0x00,0x00,0x00,
		       0x01,0x02,0x03,0x04,2,0,0,0,
		       0xc8,0xc3,0xcb,0xed,
		       5,
		       10,255,4,255,0};

/* page with the 255 segment limit */
const int head1_5[] = {0x4f,0x67,0x67,0x53,0,0x02,
		       0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		       0x01,0x02,0x03,0x04,0,0,0,0,
		       0xff,0x7b,0x23,0x17,
		       1,
		       0};

const int head2_5[] = {0x4f,0x67,0x67,0x53,0,0x00,
		       0x07,0xfc,0x03,0x00,0x00,0x00,0x00,0x00,
		       0x01,0x02,0x03,0x04,1,0,0,0,
		       0xed,0x2a,0x2e,0xa7,
		       255,
		       10,10,10,10,10,10,10,10,
		       10,10,10,10,10,10,10,10,
		       10,10,10,10,10,10,10,10,
		       10,10,10,10,10,10,10,10,
		       10,10,10,10,10,10,10,10,
		       10,10,10,10,10,10,10,10,
		       10,10,10,10,10,10,10,10,
		       10,10,10,10,10,10,10,10,
		       10,10,10,10,10,10,10,10,
		       10,10,10,10,10,10,10,10,
		       10,10,10,10,10,10,10,10,
		       10,10,10,10,10,10,10,10,
		       10,10,10,10,10,10,10,10,
		       10,10,10,10,10,10,10,10,
		       10,10,10,10,10,10,10,10,
		       10,10,10,10,10,10,10,10,
		       10,10,10,10,10,10,10,10,
		       10,10,10,10,10,10,10,10,
		       10,10,10,10,10,10,10,10,
		       10,10,10,10,10,10,10,10,
		       10,10,10,10,10,10,10,10,
		       10,10,10,10,10,10,10,10,
		       10,10,10,10,10,10,10,10,
		       10,10,10,10,10,10,10,10,
		       10,10,10,10,10,10,10,10,
		       10,10,10,10,10,10,10,10,
		       10,10,10,10,10,10,10,10,
		       10,10,10,10,10,10,10,10,
		       10,10,10,10,10,10,10,10,
		       10,10,10,10,10,10,10,10,
		       10,10,10,10,10,10,10,10,
		       10,10,10,10,10,10,10};

const int head3_5[] = {0x4f,0x67,0x67,0x53,0,0x04,
		       0x07,0x00,0x04,0x00,0x00,0x00,0x00,0x00,
		       0x01,0x02,0x03,0x04,2,0,0,0,
		       0x6c,0x3b,0x82,0x3d,
		       1,
		       50};

/* packet that overspans over an entire page */
const int head1_6[] = {0x4f,0x67,0x67,0x53,0,0x02,
		       0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		       0x01,0x02,0x03,0x04,0,0,0,0,
		       0xff,0x7b,0x23,0x17,
		       1,
		       0};

const int head2_6[] = {0x4f,0x67,0x67,0x53,0,0x00,
		       0x07,0x04,0x00,0x00,0x00,0x00,0x00,0x00,
		       0x01,0x02,0x03,0x04,1,0,0,0,
		       0x3c,0xd9,0x4d,0x3f,
		       17,
		       100,255,255,255,255,255,255,255,255,
		       255,255,255,255,255,255,255,255};

const int head3_6[] = {0x4f,0x67,0x67,0x53,0,0x01,
		       0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
		       0x01,0x02,0x03,0x04,2,0,0,0,
		       0x01,0xd2,0xe5,0xe5,
		       17,
		       255,255,255,255,255,255,255,255,
		       255,255,255,255,255,255,255,255,255};

const int head4_6[] = {0x4f,0x67,0x67,0x53,0,0x05,
		       0x07,0x10,0x00,0x00,0x00,0x00,0x00,0x00,
		       0x01,0x02,0x03,0x04,3,0,0,0,
		       0xef,0xdd,0x88,0xde,
		       7,
		       255,255,75,255,4,255,0};

/* packet that overspans over an entire page */
const int head1_7[] = {0x4f,0x67,0x67,0x53,0,0x02,
		       0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
		       0x01,0x02,0x03,0x04,0,0,0,0,
		       0xff,0x7b,0x23,0x17,
		       1,
		       0};

const int head2_7[] = {0x4f,0x67,0x67,0x53,0,0x00,
		       0x07,0x04,0x00,0x00,0x00,0x00,0x00,0x00,
		       0x01,0x02,0x03,0x04,1,0,0,0,
		       0x3c,0xd9,0x4d,0x3f,
		       17,
		       100,255,255,255,255,255,255,255,255,
		       255,255,255,255,255,255,255,255};

const int head3_7[] = {0x4f,0x67,0x67,0x53,0,0x05,
		       0x07,0x08,0x00,0x00,0x00,0x00,0x00,0x00,
		       0x01,0x02,0x03,0x04,2,0,0,0,
		       0xd4,0xe0,0x60,0xe5,
		       1,0};

void test_pack(const int *pl, const int **headers, int byteskip,
	       int pageskip, int packetskip){
  unsigned char *data=_ogg_malloc(1024*1024); /* for scripted test cases only */
  long inptr=0;
  long outptr=0;
  long deptr=0;
  long depacket=0;
  long granule_pos=7,pageno=0;
  int i,j,packets,pageout=pageskip;
  int eosflag=0;
  int bosflag=0;

  int byteskipcount=0;

  ogg_stream_reset(&os_en);
  ogg_stream_reset(&os_de);
  ogg_sync_reset(&oy);

  for(packets=0;packets<packetskip;packets++)
	depacket+=pl[packets];

  for(packets=0;;packets++)if(pl[packets]==-1)break;

  for(i=0;i<packets;i++){
	/* construct a test packet */
	ogg_packet op;
	int len=pl[i];

	op.packet=data+inptr;
	op.bytes=len;
	op.e_o_s=(pl[i+1]<0?1:0);
	op.granulepos=granule_pos;

	granule_pos+=1024;

	for(j=0;j<len;j++)data[inptr++]=i+j;

	/* submit the test packet */
	ogg_stream_packetin(&os_en,&op);

	/* retrieve any finished pages */
	{
	  ogg_page og;

	  while(ogg_stream_pageout(&os_en,&og)){
	/* We have a page.  Check it carefully */

	fprintf(stderr,"%ld, ",pageno);

	if(headers[pageno]==NULL){
	  fprintf(stderr,"coded too many pages!\n");
	  exit(1);
	}

	check_page(data+outptr,headers[pageno],&og);

	outptr+=og.body_len;
	pageno++;
	if(pageskip){
	  bosflag=1;
	  pageskip--;
	  deptr+=og.body_len;
	}

	/* have a complete page; submit it to sync/decode */

	{
	  ogg_page og_de;
	  ogg_packet op_de,op_de2;
	  char *buf=ogg_sync_buffer(&oy,og.header_len+og.body_len);
	  char *next=buf;
	  byteskipcount+=og.header_len;
	  if(byteskipcount>byteskip){
	    memcpy(next,og.header,byteskipcount-byteskip);
	    next+=byteskipcount-byteskip;
	    byteskipcount=byteskip;
	  }

	  byteskipcount+=og.body_len;
	  if(byteskipcount>byteskip){
	    memcpy(next,og.body,byteskipcount-byteskip);
	    next+=byteskipcount-byteskip;
	    byteskipcount=byteskip;
	  }

	  ogg_sync_wrote(&oy,next-buf);

	  while(1){
	    int ret=ogg_sync_pageout(&oy,&og_de);
	    if(ret==0)break;
	    if(ret<0)continue;
	    /* got a page.  Happy happy.  Verify that it's good. */

	    fprintf(stderr,"(%ld), ",pageout);

	    check_page(data+deptr,headers[pageout],&og_de);
	    deptr+=og_de.body_len;
	    pageout++;

	    /* submit it to deconstitution */
	    ogg_stream_pagein(&os_de,&og_de);

	    /* packets out? */
	    while(ogg_stream_packetpeek(&os_de,&op_de2)>0){
	      ogg_stream_packetpeek(&os_de,NULL);
	      ogg_stream_packetout(&os_de,&op_de); /* just catching them all */

	      /* verify peek and out match */
	      if(memcmp(&op_de,&op_de2,sizeof(op_de))){
		fprintf(stderr,"packetout != packetpeek! pos=%ld\n",
			depacket);
		exit(1);
	      }

	      /* verify the packet! */
	      /* check data */
	      if(memcmp(data+depacket,op_de.packet,op_de.bytes)){
		fprintf(stderr,"packet data mismatch in decode! pos=%ld\n",
			depacket);
		exit(1);
	      }
	      /* check bos flag */
	      if(bosflag==0 && op_de.b_o_s==0){
		fprintf(stderr,"b_o_s flag not set on packet!\n");
		exit(1);
	      }
	      if(bosflag && op_de.b_o_s){
		fprintf(stderr,"b_o_s flag incorrectly set on packet!\n");
		exit(1);
	      }
	      bosflag=1;
	      depacket+=op_de.bytes;

	      /* check eos flag */
	      if(eosflag){
		fprintf(stderr,"Multiple decoded packets with eos flag!\n");
		exit(1);
	      }

	      if(op_de.e_o_s)eosflag=1;

	      /* check granulepos flag */
	      if(op_de.granulepos!=-1){
		fprintf(stderr," granule:%ld ",(long)op_de.granulepos);
	      }
	    }
	  }
	}
	  }
	}
  }
  _ogg_free(data);
  if(headers[pageno]!=NULL){
	fprintf(stderr,"did not write last page!\n");
	exit(1);
  }
  if(headers[pageout]!=NULL){
	fprintf(stderr,"did not decode last page!\n");
	exit(1);
  }
  if(inptr!=outptr){
	fprintf(stderr,"encoded page data incomplete!\n");
	exit(1);
  }
  if(inptr!=deptr){
	fprintf(stderr,"decoded page data incomplete!\n");
	exit(1);
  }
  if(inptr!=depacket){
	fprintf(stderr,"decoded packet data incomplete!\n");
	exit(1);
  }
  if(!eosflag){
	fprintf(stderr,"Never got a packet with EOS set!\n");
	exit(1);
  }
  fprintf(stderr,"ok.\n");
}

int main(void){

  ogg_stream_init(&os_en,0x04030201);
  ogg_stream_init(&os_de,0x04030201);
  ogg_sync_init(&oy);

  /* Exercise each code path in the framing code.  Also verify that
	 the checksums are working.  */

  {
	/* 17 only */
	const int packets[]={17, -1};
	const int *headret[]={head1_0,NULL};

	fprintf(stderr,"testing single page encoding... ");
	test_pack(packets,headret,0,0,0);
  }

  {
	/* 17, 254, 255, 256, 500, 510, 600 byte, pad */
	const int packets[]={17, 254, 255, 256, 500, 510, 600, -1};
	const int *headret[]={head1_1,head2_1,NULL};

	fprintf(stderr,"testing basic page encoding... ");
	test_pack(packets,headret,0,0,0);
  }

  {
	/* nil packets; beginning,middle,end */
	const int packets[]={0,17, 254, 255, 0, 256, 0, 500, 510, 600, 0, -1};
	const int *headret[]={head1_2,head2_2,NULL};

	fprintf(stderr,"testing basic nil packets... ");
	test_pack(packets,headret,0,0,0);
  }

  {
	/* large initial packet */
	const int packets[]={4345,259,255,-1};
	const int *headret[]={head1_3,head2_3,NULL};

	fprintf(stderr,"testing initial-packet lacing > 4k... ");
	test_pack(packets,headret,0,0,0);
  }

  {
	/* continuing packet test */
	const int packets[]={0,4345,259,255,-1};
	const int *headret[]={head1_4,head2_4,head3_4,NULL};

	fprintf(stderr,"testing single packet page span... ");
	test_pack(packets,headret,0,0,0);
  }

  /* page with the 255 segment limit */
  {

	const int packets[]={0,10,10,10,10,10,10,10,10,
		   10,10,10,10,10,10,10,10,
		   10,10,10,10,10,10,10,10,
		   10,10,10,10,10,10,10,10,
		   10,10,10,10,10,10,10,10,
		   10,10,10,10,10,10,10,10,
		   10,10,10,10,10,10,10,10,
		   10,10,10,10,10,10,10,10,
		   10,10,10,10,10,10,10,10,
		   10,10,10,10,10,10,10,10,
		   10,10,10,10,10,10,10,10,
		   10,10,10,10,10,10,10,10,
		   10,10,10,10,10,10,10,10,
		   10,10,10,10,10,10,10,10,
		   10,10,10,10,10,10,10,10,
		   10,10,10,10,10,10,10,10,
		   10,10,10,10,10,10,10,10,
		   10,10,10,10,10,10,10,10,
		   10,10,10,10,10,10,10,10,
		   10,10,10,10,10,10,10,10,
		   10,10,10,10,10,10,10,10,
		   10,10,10,10,10,10,10,10,
		   10,10,10,10,10,10,10,10,
		   10,10,10,10,10,10,10,10,
		   10,10,10,10,10,10,10,10,
		   10,10,10,10,10,10,10,10,
		   10,10,10,10,10,10,10,10,
		   10,10,10,10,10,10,10,10,
		   10,10,10,10,10,10,10,10,
		   10,10,10,10,10,10,10,10,
		   10,10,10,10,10,10,10,10,
		   10,10,10,10,10,10,10,50,-1};
	const int *headret[]={head1_5,head2_5,head3_5,NULL};

	fprintf(stderr,"testing max packet segments... ");
	test_pack(packets,headret,0,0,0);
  }

  {
	/* packet that overspans over an entire page */
	const int packets[]={0,100,9000,259,255,-1};
	const int *headret[]={head1_6,head2_6,head3_6,head4_6,NULL};

	fprintf(stderr,"testing very large packets... ");
	test_pack(packets,headret,0,0,0);
  }

  {
	/* test for the libogg 1.1.1 resync in large continuation bug
	   found by Josh Coalson)  */
	const int packets[]={0,100,9000,259,255,-1};
	const int *headret[]={head1_6,head2_6,head3_6,head4_6,NULL};

	fprintf(stderr,"testing continuation resync in very large packets... ");
	test_pack(packets,headret,100,2,3);
  }

  {
	/* term only page.  why not? */
	const int packets[]={0,100,4080,-1};
	const int *headret[]={head1_7,head2_7,head3_7,NULL};

	fprintf(stderr,"testing zero data page (1 nil packet)... ");
	test_pack(packets,headret,0,0,0);
  }

  {
	/* build a bunch of pages for testing */
	unsigned char *data=_ogg_malloc(1024*1024);
	int pl[]={0,100,4079,2956,2057,76,34,912,0,234,1000,1000,1000,300,-1};
	int inptr=0,i,j;
	ogg_page og[5];

	ogg_stream_reset(&os_en);

	for(i=0;pl[i]!=-1;i++){
	  ogg_packet op;
	  int len=pl[i];

	  op.packet=data+inptr;
	  op.bytes=len;
	  op.e_o_s=(pl[i+1]<0?1:0);
	  op.granulepos=(i+1)*1000;

	  for(j=0;j<len;j++)data[inptr++]=i+j;
	  ogg_stream_packetin(&os_en,&op);
	}

	_ogg_free(data);

	/* retrieve finished pages */
	for(i=0;i<5;i++){
	  if(ogg_stream_pageout(&os_en,&og[i])==0){
	fprintf(stderr,"Too few pages output building sync tests!\n");
	exit(1);
	  }
	  copy_page(&og[i]);
	}

	/* Test lost pages on pagein/packetout: no rollback */
	{
	  ogg_page temp;
	  ogg_packet test;

	  fprintf(stderr,"Testing loss of pages... ");

	  ogg_sync_reset(&oy);
	  ogg_stream_reset(&os_de);
	  for(i=0;i<5;i++){
	memcpy(ogg_sync_buffer(&oy,og[i].header_len),og[i].header,
	       og[i].header_len);
	ogg_sync_wrote(&oy,og[i].header_len);
	memcpy(ogg_sync_buffer(&oy,og[i].body_len),og[i].body,og[i].body_len);
	ogg_sync_wrote(&oy,og[i].body_len);
	  }

	  ogg_sync_pageout(&oy,&temp);
	  ogg_stream_pagein(&os_de,&temp);
	  ogg_sync_pageout(&oy,&temp);
	  ogg_stream_pagein(&os_de,&temp);
	  ogg_sync_pageout(&oy,&temp);
	  /* skip */
	  ogg_sync_pageout(&oy,&temp);
	  ogg_stream_pagein(&os_de,&temp);

	  /* do we get the expected results/packets? */

	  if(ogg_stream_packetout(&os_de,&test)!=1)error();
	  checkpacket(&test,0,0,0);
	  if(ogg_stream_packetout(&os_de,&test)!=1)error();
	  checkpacket(&test,100,1,-1);
	  if(ogg_stream_packetout(&os_de,&test)!=1)error();
	  checkpacket(&test,4079,2,3000);
	  if(ogg_stream_packetout(&os_de,&test)!=-1){
	fprintf(stderr,"Error: loss of page did not return error\n");
	exit(1);
	  }
	  if(ogg_stream_packetout(&os_de,&test)!=1)error();
	  checkpacket(&test,76,5,-1);
	  if(ogg_stream_packetout(&os_de,&test)!=1)error();
	  checkpacket(&test,34,6,-1);
	  fprintf(stderr,"ok.\n");
	}

	/* Test lost pages on pagein/packetout: rollback with continuation */
	{
	  ogg_page temp;
	  ogg_packet test;

	  fprintf(stderr,"Testing loss of pages (rollback required)... ");

	  ogg_sync_reset(&oy);
	  ogg_stream_reset(&os_de);
	  for(i=0;i<5;i++){
	memcpy(ogg_sync_buffer(&oy,og[i].header_len),og[i].header,
	       og[i].header_len);
	ogg_sync_wrote(&oy,og[i].header_len);
	memcpy(ogg_sync_buffer(&oy,og[i].body_len),og[i].body,og[i].body_len);
	ogg_sync_wrote(&oy,og[i].body_len);
	  }

	  ogg_sync_pageout(&oy,&temp);
	  ogg_stream_pagein(&os_de,&temp);
	  ogg_sync_pageout(&oy,&temp);
	  ogg_stream_pagein(&os_de,&temp);
	  ogg_sync_pageout(&oy,&temp);
	  ogg_stream_pagein(&os_de,&temp);
	  ogg_sync_pageout(&oy,&temp);
	  /* skip */
	  ogg_sync_pageout(&oy,&temp);
	  ogg_stream_pagein(&os_de,&temp);

	  /* do we get the expected results/packets? */

	  if(ogg_stream_packetout(&os_de,&test)!=1)error();
	  checkpacket(&test,0,0,0);
	  if(ogg_stream_packetout(&os_de,&test)!=1)error();
	  checkpacket(&test,100,1,-1);
	  if(ogg_stream_packetout(&os_de,&test)!=1)error();
	  checkpacket(&test,4079,2,3000);
	  if(ogg_stream_packetout(&os_de,&test)!=1)error();
	  checkpacket(&test,2956,3,4000);
	  if(ogg_stream_packetout(&os_de,&test)!=-1){
	fprintf(stderr,"Error: loss of page did not return error\n");
	exit(1);
	  }
	  if(ogg_stream_packetout(&os_de,&test)!=1)error();
	  checkpacket(&test,300,13,14000);
	  fprintf(stderr,"ok.\n");
	}

	/* the rest only test sync */
	{
	  ogg_page og_de;
	  /* Test fractional page inputs: incomplete capture */
	  fprintf(stderr,"Testing sync on partial inputs... ");
	  ogg_sync_reset(&oy);
	  memcpy(ogg_sync_buffer(&oy,og[1].header_len),og[1].header,
	     3);
	  ogg_sync_wrote(&oy,3);
	  if(ogg_sync_pageout(&oy,&og_de)>0)error();

	  /* Test fractional page inputs: incomplete fixed header */
	  memcpy(ogg_sync_buffer(&oy,og[1].header_len),og[1].header+3,
	     20);
	  ogg_sync_wrote(&oy,20);
	  if(ogg_sync_pageout(&oy,&og_de)>0)error();

	  /* Test fractional page inputs: incomplete header */
	  memcpy(ogg_sync_buffer(&oy,og[1].header_len),og[1].header+23,
	     5);
	  ogg_sync_wrote(&oy,5);
	  if(ogg_sync_pageout(&oy,&og_de)>0)error();

	  /* Test fractional page inputs: incomplete body */

	  memcpy(ogg_sync_buffer(&oy,og[1].header_len),og[1].header+28,
	     og[1].header_len-28);
	  ogg_sync_wrote(&oy,og[1].header_len-28);
	  if(ogg_sync_pageout(&oy,&og_de)>0)error();

	  memcpy(ogg_sync_buffer(&oy,og[1].body_len),og[1].body,1000);
	  ogg_sync_wrote(&oy,1000);
	  if(ogg_sync_pageout(&oy,&og_de)>0)error();

	  memcpy(ogg_sync_buffer(&oy,og[1].body_len),og[1].body+1000,
	     og[1].body_len-1000);
	  ogg_sync_wrote(&oy,og[1].body_len-1000);
	  if(ogg_sync_pageout(&oy,&og_de)<=0)error();

	  fprintf(stderr,"ok.\n");
	}

	/* Test fractional page inputs: page + incomplete capture */
	{
	  ogg_page og_de;
	  fprintf(stderr,"Testing sync on 1+partial inputs... ");
	  ogg_sync_reset(&oy);

	  memcpy(ogg_sync_buffer(&oy,og[1].header_len),og[1].header,
	     og[1].header_len);
	  ogg_sync_wrote(&oy,og[1].header_len);

	  memcpy(ogg_sync_buffer(&oy,og[1].body_len),og[1].body,
	     og[1].body_len);
	  ogg_sync_wrote(&oy,og[1].body_len);

	  memcpy(ogg_sync_buffer(&oy,og[1].header_len),og[1].header,
	     20);
	  ogg_sync_wrote(&oy,20);
	  if(ogg_sync_pageout(&oy,&og_de)<=0)error();
	  if(ogg_sync_pageout(&oy,&og_de)>0)error();

	  memcpy(ogg_sync_buffer(&oy,og[1].header_len),og[1].header+20,
	     og[1].header_len-20);
	  ogg_sync_wrote(&oy,og[1].header_len-20);
	  memcpy(ogg_sync_buffer(&oy,og[1].body_len),og[1].body,
	     og[1].body_len);
	  ogg_sync_wrote(&oy,og[1].body_len);
	  if(ogg_sync_pageout(&oy,&og_de)<=0)error();

	  fprintf(stderr,"ok.\n");
	}

	/* Test recapture: garbage + page */
	{
	  ogg_page og_de;
	  fprintf(stderr,"Testing search for capture... ");
	  ogg_sync_reset(&oy);

	  /* 'garbage' */
	  memcpy(ogg_sync_buffer(&oy,og[1].body_len),og[1].body,
	     og[1].body_len);
	  ogg_sync_wrote(&oy,og[1].body_len);

	  memcpy(ogg_sync_buffer(&oy,og[1].header_len),og[1].header,
	     og[1].header_len);
	  ogg_sync_wrote(&oy,og[1].header_len);

	  memcpy(ogg_sync_buffer(&oy,og[1].body_len),og[1].body,
	     og[1].body_len);
	  ogg_sync_wrote(&oy,og[1].body_len);

	  memcpy(ogg_sync_buffer(&oy,og[2].header_len),og[2].header,
	     20);
	  ogg_sync_wrote(&oy,20);
	  if(ogg_sync_pageout(&oy,&og_de)>0)error();
	  if(ogg_sync_pageout(&oy,&og_de)<=0)error();
	  if(ogg_sync_pageout(&oy,&og_de)>0)error();

	  memcpy(ogg_sync_buffer(&oy,og[2].header_len),og[2].header+20,
	     og[2].header_len-20);
	  ogg_sync_wrote(&oy,og[2].header_len-20);
	  memcpy(ogg_sync_buffer(&oy,og[2].body_len),og[2].body,
	     og[2].body_len);
	  ogg_sync_wrote(&oy,og[2].body_len);
	  if(ogg_sync_pageout(&oy,&og_de)<=0)error();

	  fprintf(stderr,"ok.\n");
	}

	/* Test recapture: page + garbage + page */
	{
	  ogg_page og_de;
	  fprintf(stderr,"Testing recapture... ");
	  ogg_sync_reset(&oy);

	  memcpy(ogg_sync_buffer(&oy,og[1].header_len),og[1].header,
	     og[1].header_len);
	  ogg_sync_wrote(&oy,og[1].header_len);

	  memcpy(ogg_sync_buffer(&oy,og[1].body_len),og[1].body,
	     og[1].body_len);
	  ogg_sync_wrote(&oy,og[1].body_len);

	  memcpy(ogg_sync_buffer(&oy,og[2].header_len),og[2].header,
	     og[2].header_len);
	  ogg_sync_wrote(&oy,og[2].header_len);

	  memcpy(ogg_sync_buffer(&oy,og[2].header_len),og[2].header,
	     og[2].header_len);
	  ogg_sync_wrote(&oy,og[2].header_len);

	  if(ogg_sync_pageout(&oy,&og_de)<=0)error();

	  memcpy(ogg_sync_buffer(&oy,og[2].body_len),og[2].body,
	     og[2].body_len-5);
	  ogg_sync_wrote(&oy,og[2].body_len-5);

	  memcpy(ogg_sync_buffer(&oy,og[3].header_len),og[3].header,
	     og[3].header_len);
	  ogg_sync_wrote(&oy,og[3].header_len);

	  memcpy(ogg_sync_buffer(&oy,og[3].body_len),og[3].body,
	     og[3].body_len);
	  ogg_sync_wrote(&oy,og[3].body_len);

	  if(ogg_sync_pageout(&oy,&og_de)>0)error();
	  if(ogg_sync_pageout(&oy,&og_de)<=0)error();

	  fprintf(stderr,"ok.\n");
	}

	/* Free page data that was previously copied */
	{
	  for(i=0;i<5;i++){
	free_page(&og[i]);
	  }
	}
  }

  return(0);
}

#endif

/*** End of inlined file: framing.c ***/


/*** Start of inlined file: analysis.c ***/
#include <stdio.h>
#include <string.h>
#include <math.h>


/*** Start of inlined file: codec_internal.h ***/
#ifndef _V_CODECI_H_
#define _V_CODECI_H_


/*** Start of inlined file: envelope.h ***/
#ifndef _V_ENVELOPE_
#define _V_ENVELOPE_


/*** Start of inlined file: mdct.h ***/
#ifndef _OGG_mdct_H_
#define _OGG_mdct_H_

/*#define MDCT_INTEGERIZED  <- be warned there could be some hurt left here*/
#ifdef MDCT_INTEGERIZED

#define DATA_TYPE int
#define REG_TYPE  register int
#define TRIGBITS 14
#define cPI3_8 6270
#define cPI2_8 11585
#define cPI1_8 15137

#define FLOAT_CONV(x) ((int)((x)*(1<<TRIGBITS)+.5))
#define MULT_NORM(x) ((x)>>TRIGBITS)
#define HALVE(x) ((x)>>1)

#else

#define DATA_TYPE float
#define REG_TYPE  float
#define cPI3_8 .38268343236508977175F
#define cPI2_8 .70710678118654752441F
#define cPI1_8 .92387953251128675613F

#define FLOAT_CONV(x) (x)
#define MULT_NORM(x) (x)
#define HALVE(x) ((x)*.5f)

#endif

typedef struct {
  int n;
  int log2n;

  DATA_TYPE *trig;
  int       *bitrev;

  DATA_TYPE scale;
} mdct_lookup;

extern void mdct_init(mdct_lookup *lookup,int n);
extern void mdct_clear(mdct_lookup *l);
extern void mdct_forward(mdct_lookup *init, DATA_TYPE *in, DATA_TYPE *out);
extern void mdct_backward(mdct_lookup *init, DATA_TYPE *in, DATA_TYPE *out);

#endif

/*** End of inlined file: mdct.h ***/

#define VE_PRE    16
#define VE_WIN    4
#define VE_POST   2
#define VE_AMP    (VE_PRE+VE_POST-1)

#define VE_BANDS  7
#define VE_NEARDC 15

#define VE_MINSTRETCH 2   /* a bit less than short block */
#define VE_MAXSTRETCH 12  /* one-third full block */

typedef struct {
  float ampbuf[VE_AMP];
  int   ampptr;

  float nearDC[VE_NEARDC];
  float nearDC_acc;
  float nearDC_partialacc;
  int   nearptr;

} envelope_filter_state;

typedef struct {
  int begin;
  int end;
  float *window;
  float total;
} envelope_band;

typedef struct {
  int ch;
  int winlength;
  int searchstep;
  float minenergy;

  mdct_lookup  mdct;
  float       *mdct_win;

  envelope_band          band[VE_BANDS];
  envelope_filter_state *filter;
  int   stretch;

  int                   *mark;

  long storage;
  long current;
  long curmark;
  long cursor;
} envelope_lookup;

extern void _ve_envelope_init(envelope_lookup *e,vorbis_info *vi);
extern void _ve_envelope_clear(envelope_lookup *e);
extern long _ve_envelope_search(vorbis_dsp_state *v);
extern void _ve_envelope_shift(envelope_lookup *e,long shift);
extern int  _ve_envelope_mark(vorbis_dsp_state *v);

#endif

/*** End of inlined file: envelope.h ***/


/*** Start of inlined file: codebook.h ***/
#ifndef _V_CODEBOOK_H_
#define _V_CODEBOOK_H_

/* This structure encapsulates huffman and VQ style encoding books; it
   doesn't do anything specific to either.

   valuelist/quantlist are nonNULL (and q_* significant) only if
   there's entry->value mapping to be done.

   If encode-side mapping must be done (and thus the entry needs to be
   hunted), the auxiliary encode pointer will point to a decision
   tree.  This is true of both VQ and huffman, but is mostly useful
   with VQ.

*/

typedef struct static_codebook{
  long   dim;            /* codebook dimensions (elements per vector) */
  long   entries;        /* codebook entries */
  long  *lengthlist;     /* codeword lengths in bits */

  /* mapping ***************************************************************/
  int    maptype;        /* 0=none
							1=implicitly populated values from map column
							2=listed arbitrary values */

  /* The below does a linear, single monotonic sequence mapping. */
  long     q_min;       /* packed 32 bit float; quant value 0 maps to minval */
  long     q_delta;     /* packed 32 bit float; val 1 - val 0 == delta */
  int      q_quant;     /* bits: 0 < quant <= 16 */
  int      q_sequencep; /* bitflag */

  long     *quantlist;  /* map == 1: (int)(entries^(1/dim)) element column map
						   map == 2: list of dim*entries quantized entry vals
						*/
  int allocedp;
} static_codebook;

typedef struct codebook{
  long dim;           /* codebook dimensions (elements per vector) */
  long entries;       /* codebook entries */
  long used_entries;  /* populated codebook entries */
  const static_codebook *c;

  /* for encode, the below are entry-ordered, fully populated */
  /* for decode, the below are ordered by bitreversed codeword and only
	 used entries are populated */
  float        *valuelist;  /* list of dim*entries actual entry values */
  ogg_uint32_t *codelist;   /* list of bitstream codewords for each entry */

  int          *dec_index;  /* only used if sparseness collapsed */
  char         *dec_codelengths;
  ogg_uint32_t *dec_firsttable;
  int           dec_firsttablen;
  int           dec_maxlength;

  /* The current encoder uses only centered, integer-only lattice books. */
  int           quantvals;
  int           minval;
  int           delta;
} codebook;

extern void vorbis_staticbook_destroy(static_codebook *b);
extern int vorbis_book_init_encode(codebook *dest,const static_codebook *source);
extern int vorbis_book_init_decode(codebook *dest,const static_codebook *source);
extern void vorbis_book_clear(codebook *b);

extern float *_book_unquantize(const static_codebook *b,int n,int *map);
extern float *_book_logdist(const static_codebook *b,float *vals);
extern float _float32_unpack(long val);
extern long   _float32_pack(float val);
extern int  _best(codebook *book, float *a, int step);
extern int _ilog(unsigned int v);
extern long _book_maptype1_quantvals(const static_codebook *b);

extern int vorbis_book_besterror(codebook *book,float *a,int step,int addmul);
extern long vorbis_book_codeword(codebook *book,int entry);
extern long vorbis_book_codelen(codebook *book,int entry);

extern int vorbis_staticbook_pack(const static_codebook *c,oggpack_buffer *b);
extern static_codebook *vorbis_staticbook_unpack(oggpack_buffer *b);

extern int vorbis_book_encode(codebook *book, int a, oggpack_buffer *b);

extern long vorbis_book_decode(codebook *book, oggpack_buffer *b);
extern long vorbis_book_decodevs_add(codebook *book, float *a,
									 oggpack_buffer *b,int n);
extern long vorbis_book_decodev_set(codebook *book, float *a,
									oggpack_buffer *b,int n);
extern long vorbis_book_decodev_add(codebook *book, float *a,
									oggpack_buffer *b,int n);
extern long vorbis_book_decodevv_add(codebook *book, float **a,
									 long off,int ch,
									oggpack_buffer *b,int n);

#endif

/*** End of inlined file: codebook.h ***/

#define BLOCKTYPE_IMPULSE    0
#define BLOCKTYPE_PADDING    1
#define BLOCKTYPE_TRANSITION 0
#define BLOCKTYPE_LONG       1

#define PACKETBLOBS 15

typedef struct vorbis_block_internal{
  float  **pcmdelay;  /* this is a pointer into local storage */
  float  ampmax;
  int    blocktype;

  oggpack_buffer *packetblob[PACKETBLOBS]; /* initialized, must be freed;
											  blob [PACKETBLOBS/2] points to
											  the oggpack_buffer in the
											  main vorbis_block */
} vorbis_block_internal;

typedef void vorbis_look_floor;
typedef void vorbis_look_residue;
typedef void vorbis_look_transform;

/* mode ************************************************************/
typedef struct {
  int blockflag;
  int windowtype;
  int transformtype;
  int mapping;
} vorbis_info_mode;

typedef void vorbis_info_floor;
typedef void vorbis_info_residue;
typedef void vorbis_info_mapping;


/*** Start of inlined file: psy.h ***/
#ifndef _V_PSY_H_
#define _V_PSY_H_

/*** Start of inlined file: smallft.h ***/
#ifndef _V_SMFT_H_
#define _V_SMFT_H_

typedef struct {
  int n;
  float *trigcache;
  int *splitcache;
} drft_lookup;

extern void drft_forward(drft_lookup *l,float *data);
extern void drft_backward(drft_lookup *l,float *data);
extern void drft_init(drft_lookup *l,int n);
extern void drft_clear(drft_lookup *l);

#endif

/*** End of inlined file: smallft.h ***/



/*** Start of inlined file: backends.h ***/
/* this is exposed up here because we need it for static modes.
   Lookups for each backend aren't exposed because there's no reason
   to do so */

#ifndef _vorbis_backend_h_
#define _vorbis_backend_h_

/* this would all be simpler/shorter with templates, but.... */
/* Floor backend generic *****************************************/
typedef struct{
  void                   (*pack)  (vorbis_info_floor *,oggpack_buffer *);
  vorbis_info_floor     *(*unpack)(vorbis_info *,oggpack_buffer *);
  vorbis_look_floor     *(*look)  (vorbis_dsp_state *,vorbis_info_floor *);
  void (*free_info) (vorbis_info_floor *);
  void (*free_look) (vorbis_look_floor *);
  void *(*inverse1)  (struct vorbis_block *,vorbis_look_floor *);
  int   (*inverse2)  (struct vorbis_block *,vorbis_look_floor *,
					 void *buffer,float *);
} vorbis_func_floor;

typedef struct{
  int   order;
  long  rate;
  long  barkmap;

  int   ampbits;
  int   ampdB;

  int   numbooks; /* <= 16 */
  int   books[16];

  float lessthan;     /* encode-only config setting hacks for libvorbis */
  float greaterthan;  /* encode-only config setting hacks for libvorbis */

} vorbis_info_floor0;

#define VIF_POSIT 63
#define VIF_CLASS 16
#define VIF_PARTS 31
typedef struct{
  int   partitions;                /* 0 to 31 */
  int   partitionclass[VIF_PARTS]; /* 0 to 15 */

  int   class_dim[VIF_CLASS];        /* 1 to 8 */
  int   class_subs[VIF_CLASS];       /* 0,1,2,3 (bits: 1<<n poss) */
  int   class_book[VIF_CLASS];       /* subs ^ dim entries */
  int   class_subbook[VIF_CLASS][8]; /* [VIF_CLASS][subs] */

  int   mult;                      /* 1 2 3 or 4 */
  int   postlist[VIF_POSIT+2];    /* first two implicit */

  /* encode side analysis parameters */
  float maxover;
  float maxunder;
  float maxerr;

  float twofitweight;
  float twofitatten;

  int   n;

} vorbis_info_floor1;

/* Residue backend generic *****************************************/
typedef struct{
  void                 (*pack)  (vorbis_info_residue *,oggpack_buffer *);
  vorbis_info_residue *(*unpack)(vorbis_info *,oggpack_buffer *);
  vorbis_look_residue *(*look)  (vorbis_dsp_state *,
								 vorbis_info_residue *);
  void (*free_info)    (vorbis_info_residue *);
  void (*free_look)    (vorbis_look_residue *);
  long **(*classx)      (struct vorbis_block *,vorbis_look_residue *,
			int **,int *,int);
  int  (*forward)      (oggpack_buffer *,struct vorbis_block *,
						vorbis_look_residue *,
						int **,int *,int,long **,int);
  int  (*inverse)      (struct vorbis_block *,vorbis_look_residue *,
						float **,int *,int);
} vorbis_func_residue;

typedef struct vorbis_info_residue0{
/* block-partitioned VQ coded straight residue */
  long  begin;
  long  end;

  /* first stage (lossless partitioning) */
  int    grouping;         /* group n vectors per partition */
  int    partitions;       /* possible codebooks for a partition */
  int    partvals;         /* partitions ^ groupbook dim */
  int    groupbook;        /* huffbook for partitioning */
  int    secondstages[64]; /* expanded out to pointers in lookup */
  int    booklist[512];    /* list of second stage books */

  /*const*/ int classmetric1[64];
  /*const*/ int classmetric2[64];
} vorbis_info_residue0;

/* Mapping backend generic *****************************************/
typedef struct{
  void                 (*pack)  (vorbis_info *,vorbis_info_mapping *,
								 oggpack_buffer *);
  vorbis_info_mapping *(*unpack)(vorbis_info *,oggpack_buffer *);
  void (*free_info)    (vorbis_info_mapping *);
  int  (*forward)      (struct vorbis_block *vb);
  int  (*inverse)      (struct vorbis_block *vb,vorbis_info_mapping *);
} vorbis_func_mapping;

typedef struct vorbis_info_mapping0{
  int   submaps;  /* <= 16 */
  int   chmuxlist[256];   /* up to 256 channels in a Vorbis stream */

  int   floorsubmap[16];   /* [mux] submap to floors */
  int   residuesubmap[16]; /* [mux] submap to residue */

  int   coupling_steps;
  int   coupling_mag[256];
  int   coupling_ang[256];

} vorbis_info_mapping0;

#endif

/*** End of inlined file: backends.h ***/

#ifndef EHMER_MAX
#define EHMER_MAX 56
#endif

/* psychoacoustic setup ********************************************/
#define P_BANDS 17      /* 62Hz to 16kHz */
#define P_LEVELS 8      /* 30dB to 100dB */
#define P_LEVEL_0 30.    /* 30 dB */
#define P_NOISECURVES 3

#define NOISE_COMPAND_LEVELS 40
typedef struct vorbis_info_psy{
  int   blockflag;

  float ath_adjatt;
  float ath_maxatt;

  float tone_masteratt[P_NOISECURVES];
  float tone_centerboost;
  float tone_decay;
  float tone_abs_limit;
  float toneatt[P_BANDS];

  int noisemaskp;
  float noisemaxsupp;
  float noisewindowlo;
  float noisewindowhi;
  int   noisewindowlomin;
  int   noisewindowhimin;
  int   noisewindowfixed;
  float noiseoff[P_NOISECURVES][P_BANDS];
  float noisecompand[NOISE_COMPAND_LEVELS];

  float max_curve_dB;

  int normal_p;
  int normal_start;
  int normal_partition;
  double normal_thresh;
} vorbis_info_psy;

typedef struct{
  int   eighth_octave_lines;

  /* for block long/short tuning; encode only */
  float preecho_thresh[VE_BANDS];
  float postecho_thresh[VE_BANDS];
  float stretch_penalty;
  float preecho_minenergy;

  float ampmax_att_per_sec;

  /* channel coupling config */
  int   coupling_pkHz[PACKETBLOBS];
  int   coupling_pointlimit[2][PACKETBLOBS];
  int   coupling_prepointamp[PACKETBLOBS];
  int   coupling_postpointamp[PACKETBLOBS];
  int   sliding_lowpass[2][PACKETBLOBS];

} vorbis_info_psy_global;

typedef struct {
  float ampmax;
  int   channels;

  vorbis_info_psy_global *gi;
  int   coupling_pointlimit[2][P_NOISECURVES];
} vorbis_look_psy_global;

typedef struct {
  int n;
  struct vorbis_info_psy *vi;

  float ***tonecurves;
  float **noiseoffset;

  float *ath;
  long  *octave;             /* in n.ocshift format */
  long  *bark;

  long  firstoc;
  long  shiftoc;
  int   eighth_octave_lines; /* power of two, please */
  int   total_octave_lines;
  long  rate; /* cache it */

  float m_val; /* Masking compensation value */

} vorbis_look_psy;

extern void   _vp_psy_init(vorbis_look_psy *p,vorbis_info_psy *vi,
						   vorbis_info_psy_global *gi,int n,long rate);
extern void   _vp_psy_clear(vorbis_look_psy *p);
extern void  *_vi_psy_dup(void *source);

extern void   _vi_psy_free(vorbis_info_psy *i);
extern vorbis_info_psy *_vi_psy_copy(vorbis_info_psy *i);

extern void _vp_noisemask(vorbis_look_psy *p,
						  float *logmdct,
						  float *logmask);

extern void _vp_tonemask(vorbis_look_psy *p,
						 float *logfft,
						 float *logmask,
						 float global_specmax,
						 float local_specmax);

extern void _vp_offset_and_mix(vorbis_look_psy *p,
							   float *noise,
							   float *tone,
							   int offset_select,
							   float *logmask,
							   float *mdct,
							   float *logmdct);

extern float _vp_ampmax_decay(float amp,vorbis_dsp_state *vd);

extern void _vp_couple_quantize_normalize(int blobno,
										  vorbis_info_psy_global *g,
										  vorbis_look_psy *p,
										  vorbis_info_mapping0 *vi,
										  float **mdct,
										  int   **iwork,
										  int    *nonzero,
										  int     sliding_lowpass,
										  int     ch);

#endif

/*** End of inlined file: psy.h ***/


/*** Start of inlined file: bitrate.h ***/
#ifndef _V_BITRATE_H_
#define _V_BITRATE_H_


/*** Start of inlined file: os.h ***/
#ifndef _OS_H
#define _OS_H
/********************************************************************
 *                                                                  *
 * THIS FILE IS PART OF THE OggVorbis SOFTWARE CODEC SOURCE CODE.   *
 * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS     *
 * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE *
 * IN 'COPYING'. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.       *
 *                                                                  *
 * THE OggVorbis SOURCE CODE IS (C) COPYRIGHT 1994-2009             *
 * by the Xiph.Org Foundation http://www.xiph.org/                  *
 *                                                                  *
 ********************************************************************

 function: #ifdef jail to whip a few platforms into the UNIX ideal.
 last mod: $Id: os.h 16227 2009-07-08 06:58:46Z xiphmont $

 ********************************************************************/

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <math.h>


/*** Start of inlined file: misc.h ***/
#ifndef _V_RANDOM_H_
#define _V_RANDOM_H_

extern void *_vorbis_block_alloc(vorbis_block *vb,long bytes);
extern void _vorbis_block_ripcord(vorbis_block *vb);

#ifdef ANALYSIS
extern int analysis_noisy;
extern void _analysis_output(char *base,int i,float *v,int n,int bark,int dB,
							 ogg_int64_t off);
extern void _analysis_output_always(char *base,int i,float *v,int n,int bark,int dB,
							 ogg_int64_t off);
#endif

#ifdef DEBUG_MALLOC

#define _VDBG_GRAPHFILE "malloc.m"
#undef _VDBG_GRAPHFILE
extern void *_VDBG_malloc(void *ptr,long bytes,char *file,long line);
extern void _VDBG_free(void *ptr,char *file,long line);

#ifndef MISC_C
#undef _ogg_malloc
#undef _ogg_calloc
#undef _ogg_realloc
#undef _ogg_free

#define _ogg_malloc(x) _VDBG_malloc(NULL,(x),__FILE__,__LINE__)
#define _ogg_calloc(x,y) _VDBG_malloc(NULL,(x)*(y),__FILE__,__LINE__)
#define _ogg_realloc(x,y) _VDBG_malloc((x),(y),__FILE__,__LINE__)
#define _ogg_free(x) _VDBG_free((x),__FILE__,__LINE__)
#endif
#endif

#endif

/*** End of inlined file: misc.h ***/

#ifndef _V_IFDEFJAIL_H_
#  define _V_IFDEFJAIL_H_

#  ifdef __GNUC__
#    define STIN static __inline__
#  elif _WIN32
#    define STIN static __inline
#  else
#    define STIN static
#  endif

#ifdef DJGPP
#  define rint(x)   (floor((x)+0.5f))
#endif

#ifndef M_PI
#  define M_PI (3.1415926536f)
#endif

#if defined(_WIN32) && !defined(__SYMBIAN32__)
#  include <malloc.h>
#  define rint(x)   (floor((x)+0.5f))
#  define NO_FLOAT_MATH_LIB
#  define FAST_HYPOT(a, b) sqrt((a)*(a) + (b)*(b))
#endif

#if defined(__SYMBIAN32__) && defined(__WINS__)
void *_alloca(size_t size);
#  define alloca _alloca
#endif

#ifndef FAST_HYPOT
#  define FAST_HYPOT hypot
#endif

#endif

#ifdef HAVE_ALLOCA_H
#  include <alloca.h>
#endif

#ifdef USE_MEMORY_H
#  include <memory.h>
#endif

#ifndef min
#  define min(x,y)  ((x)>(y)?(y):(x))
#endif

#ifndef max
#  define max(x,y)  ((x)<(y)?(y):(x))
#endif

/* Special i386 GCC implementation */
#if defined(__i386__) && defined(__GNUC__) && !defined(__BEOS__)
#  define VORBIS_FPU_CONTROL
/* both GCC and MSVC are kinda stupid about rounding/casting to int.
   Because of encapsulation constraints (GCC can't see inside the asm
   block and so we end up doing stupid things like a store/load that
   is collectively a noop), we do it this way */

/* we must set up the fpu before this works!! */

typedef ogg_int16_t vorbis_fpu_control;

static inline void vorbis_fpu_setround(vorbis_fpu_control *fpu){
  ogg_int16_t ret;
  ogg_int16_t temp;
  __asm__ __volatile__("fnstcw %0\n\t"
		  "movw %0,%%dx\n\t"
		  "andw $62463,%%dx\n\t"
		  "movw %%dx,%1\n\t"
		  "fldcw %1\n\t":"=m"(ret):"m"(temp): "dx");
  *fpu=ret;
}

static inline void vorbis_fpu_restore(vorbis_fpu_control fpu){
  __asm__ __volatile__("fldcw %0":: "m"(fpu));
}

/* assumes the FPU is in round mode! */
static inline int vorbis_ftoi(double f){  /* yes, double!  Otherwise,
											 we get extra fst/fld to
											 truncate precision */
  int i;
  __asm__("fistl %0": "=m"(i) : "t"(f));
  return(i);
}
#endif /* Special i386 GCC implementation */

/* MSVC inline assembly. 32 bit only; inline ASM isn't implemented in the
 * 64 bit compiler */
#if defined(_MSC_VER) && !defined(_WIN64) && !defined(_WIN32_WCE)
#  define VORBIS_FPU_CONTROL

typedef ogg_int16_t vorbis_fpu_control;

static __inline int vorbis_ftoi(double f){
		int i;
		__asm{
				fld f
				fistp i
		}
		return i;
}

static __inline void vorbis_fpu_setround(vorbis_fpu_control *fpu){
}

static __inline void vorbis_fpu_restore(vorbis_fpu_control fpu){
}

#endif /* Special MSVC 32 bit implementation */

/* Optimized code path for x86_64 builds. Uses SSE2 intrinsics. This can be
   done safely because all x86_64 CPUs supports SSE2. */
#if (defined(_MSC_VER) && defined(_WIN64)) || (defined(__GNUC__) && defined (__x86_64__))
#  define VORBIS_FPU_CONTROL

typedef ogg_int16_t vorbis_fpu_control;

#include <emmintrin.h>
static __inline int vorbis_ftoi(double f){
		return _mm_cvtsd_si32(_mm_load_sd(&f));
}

static __inline void vorbis_fpu_setround(vorbis_fpu_control *fpu){
}

static __inline void vorbis_fpu_restore(vorbis_fpu_control fpu){
}

#endif /* Special MSVC x64 implementation */

/* If no special implementation was found for the current compiler / platform,
   use the default implementation here: */
#ifndef VORBIS_FPU_CONTROL

typedef int vorbis_fpu_control;

static int vorbis_ftoi(double f){
		/* Note: MSVC and GCC (at least on some systems) round towards zero, thus,
		   the floor() call is required to ensure correct roudning of
		   negative numbers */
		return (int)floor(f+.5);
}

/* We don't have special code for this compiler/arch, so do it the slow way */
#  define vorbis_fpu_setround(vorbis_fpu_control) {}
#  define vorbis_fpu_restore(vorbis_fpu_control) {}

#endif /* default implementation */

#endif /* _OS_H */

/*** End of inlined file: os.h ***/

/* encode side bitrate tracking */
typedef struct bitrate_manager_state {
  int            managed;

  long           avg_reservoir;
  long           minmax_reservoir;
  long           avg_bitsper;
  long           min_bitsper;
  long           max_bitsper;

  long           short_per_long;
  double         avgfloat;

  vorbis_block  *vb;
  int            choice;
} bitrate_manager_state;

typedef struct bitrate_manager_info{
  long           avg_rate;
  long           min_rate;
  long           max_rate;
  long           reservoir_bits;
  double         reservoir_bias;

  double         slew_damp;

} bitrate_manager_info;

extern void vorbis_bitrate_init(vorbis_info *vi,bitrate_manager_state *bs);
extern void vorbis_bitrate_clear(bitrate_manager_state *bs);
extern int vorbis_bitrate_managed(vorbis_block *vb);
extern int vorbis_bitrate_addblock(vorbis_block *vb);
extern int vorbis_bitrate_flushpacket(vorbis_dsp_state *vd, ogg_packet *op);

#endif

/*** End of inlined file: bitrate.h ***/

static int ilog(unsigned int v){
  int ret=0;
  while(v){
	ret++;
	v>>=1;
  }
  return(ret);
}

static int ilog2(unsigned int v){
  int ret=0;
  if(v)--v;
  while(v){
	ret++;
	v>>=1;
  }
  return(ret);
}

typedef struct private_state {
  /* local lookup storage */
  envelope_lookup        *ve; /* envelope lookup */
  int                     window[2];
  vorbis_look_transform **transform[2];    /* block, type */
  drft_lookup             fft_look[2];

  int                     modebits;
  vorbis_look_floor     **flr;
  vorbis_look_residue   **residue;
  vorbis_look_psy        *psy;
  vorbis_look_psy_global *psy_g_look;

  /* local storage, only used on the encoding side.  This way the
	 application does not need to worry about freeing some packets'
	 memory and not others'; packet storage is always tracked.
	 Cleared next call to a _dsp_ function */
  unsigned char *header;
  unsigned char *header1;
  unsigned char *header2;

  bitrate_manager_state bms;

  ogg_int64_t sample_count;
} private_state;

/* codec_setup_info contains all the setup information specific to the
   specific compression/decompression mode in progress (eg,
   psychoacoustic settings, channel setup, options, codebook
   etc).
*********************************************************************/


/*** Start of inlined file: highlevel.h ***/
typedef struct highlevel_byblocktype {
  double tone_mask_setting;
  double tone_peaklimit_setting;
  double noise_bias_setting;
  double noise_compand_setting;
} highlevel_byblocktype;

typedef struct highlevel_encode_setup {
  int   set_in_stone;
  const void *setup;
  double base_setting;

  double impulse_noisetune;

  /* bitrate management below all settable */
  float  req;
  int    managed;
  long   bitrate_min;
  long   bitrate_av;
  double bitrate_av_damp;
  long   bitrate_max;
  long   bitrate_reservoir;
  double bitrate_reservoir_bias;

  int impulse_block_p;
  int noise_normalize_p;
  int coupling_p;

  double stereo_point_setting;
  double lowpass_kHz;
  int    lowpass_altered;

  double ath_floating_dB;
  double ath_absolute_dB;

  double amplitude_track_dBpersec;
  double trigger_setting;

  highlevel_byblocktype block[4]; /* padding, impulse, transition, long */

} highlevel_encode_setup;

/*** End of inlined file: highlevel.h ***/

typedef struct codec_setup_info {

  /* Vorbis supports only short and long blocks, but allows the
	 encoder to choose the sizes */

  long blocksizes[2];

  /* modes are the primary means of supporting on-the-fly different
	 blocksizes, different channel mappings (LR or M/A),
	 different residue backends, etc.  Each mode consists of a
	 blocksize flag and a mapping (along with the mapping setup */

  int        modes;
  int        maps;
  int        floors;
  int        residues;
  int        books;
  int        psys;     /* encode only */

  vorbis_info_mode       *mode_param[64];
  int                     map_type[64];
  vorbis_info_mapping    *map_param[64];
  int                     floor_type[64];
  vorbis_info_floor      *floor_param[64];
  int                     residue_type[64];
  vorbis_info_residue    *residue_param[64];
  static_codebook        *book_param[256];
  codebook               *fullbooks;

  vorbis_info_psy        *psy_param[4]; /* encode only */
  vorbis_info_psy_global psy_g_param;

  bitrate_manager_info   bi;
  highlevel_encode_setup hi; /* used only by vorbisenc.c.  It's a
								highly redundant structure, but
								improves clarity of program flow. */
  int         halfrate_flag; /* painless downsample for decode */
} codec_setup_info;

extern vorbis_look_psy_global *_vp_global_look(vorbis_info *vi);
extern void _vp_global_free(vorbis_look_psy_global *look);

typedef struct {
  int sorted_index[VIF_POSIT+2];
  int forward_index[VIF_POSIT+2];
  int reverse_index[VIF_POSIT+2];

  int hineighbor[VIF_POSIT];
  int loneighbor[VIF_POSIT];
  int posts;

  int n;
  int quant_q;
  vorbis_info_floor1 *vi;

  long phrasebits;
  long postbits;
  long frames;
} vorbis_look_floor1;

extern int *floor1_fit(vorbis_block *vb,vorbis_look_floor1 *look,
						  const float *logmdct,   /* in */
						  const float *logmask);
extern int *floor1_interpolate_fit(vorbis_block *vb,vorbis_look_floor1 *look,
						  int *A,int *B,
						  int del);
extern int floor1_encode(oggpack_buffer *opb,vorbis_block *vb,
				  vorbis_look_floor1 *look,
				  int *post,int *ilogmask);
#endif

/*** End of inlined file: codec_internal.h ***/


/*** Start of inlined file: registry.h ***/
#ifndef _V_REG_H_
#define _V_REG_H_

#define VI_TRANSFORMB 1
#define VI_WINDOWB 1
#define VI_TIMEB 1
#define VI_FLOORB 2
#define VI_RESB 3
#define VI_MAPB 1

extern const vorbis_func_floor     *const _floor_P[];
extern const vorbis_func_residue   *const _residue_P[];
extern const vorbis_func_mapping   *const _mapping_P[];

#endif

/*** End of inlined file: registry.h ***/


/*** Start of inlined file: scales.h ***/
#ifndef _V_SCALES_H_
#define _V_SCALES_H_

#include <math.h>

#ifdef _MSC_VER
/* MS Visual Studio doesn't have C99 inline keyword. */
#define inline __inline
#endif

/* 20log10(x) */
#define VORBIS_IEEE_FLOAT32 1
#ifdef VORBIS_IEEE_FLOAT32

static inline float unitnorm(float x){
  union {
	ogg_uint32_t i;
	float f;
  } ix;
  ix.f = x;
  ix.i = (ix.i & 0x80000000U) | (0x3f800000U);
  return ix.f;
}

/* Segher was off (too high) by ~ .3 decibel.  Center the conversion correctly. */
static inline float todB(const float *x){
  union {
	ogg_uint32_t i;
	float f;
  } ix;
  ix.f = *x;
  ix.i = ix.i&0x7fffffff;
  return (float)(ix.i * 7.17711438e-7f -764.6161886f);
}

#define todB_nn(x) todB(x)

#else

static float unitnorm(float x){
  if(x<0)return(-1.f);
  return(1.f);
}

#define todB(x)   (*(x)==0?-400.f:log(*(x)**(x))*4.34294480f)
#define todB_nn(x)   (*(x)==0.f?-400.f:log(*(x))*8.6858896f)

#endif

#define fromdB(x) (exp((x)*.11512925f))

/* The bark scale equations are approximations, since the original
   table was somewhat hand rolled.  The below are chosen to have the
   best possible fit to the rolled tables, thus their somewhat odd
   appearance (these are more accurate and over a longer range than
   the oft-quoted bark equations found in the texts I have).  The
   approximations are valid from 0 - 30kHz (nyquist) or so.

   all f in Hz, z in Bark */

#define toBARK(n)   (13.1f*atan(.00074f*(n))+2.24f*atan((n)*(n)*1.85e-8f)+1e-4f*(n))
#define fromBARK(z) (102.f*(z)-2.f*pow(z,2.f)+.4f*pow(z,3.f)+pow(1.46f,z)-1.f)
#define toMEL(n)    (log(1.f+(n)*.001f)*1442.695f)
#define fromMEL(m)  (1000.f*exp((m)/1442.695f)-1000.f)

/* Frequency to octave.  We arbitrarily declare 63.5 Hz to be octave
   0.0 */

#define toOC(n)     (log(n)*1.442695f-5.965784f)
#define fromOC(o)   (exp(((o)+5.965784f)*.693147f))

#endif

/*** End of inlined file: scales.h ***/

/* decides between modes, dispatches to the appropriate mapping. */
int vorbis_analysis(vorbis_block *vb, ogg_packet *op){
  int ret,i;
  vorbis_block_internal *vbi=(vorbis_block_internal *)vb->internal;

  vb->glue_bits=0;
  vb->time_bits=0;
  vb->floor_bits=0;
  vb->res_bits=0;

  /* first things first.  Make sure encode is ready */
  for(i=0;i<PACKETBLOBS;i++)
	oggpack_reset(vbi->packetblob[i]);

  /* we only have one mapping type (0), and we let the mapping code
	 itself figure out what soft mode to use.  This allows easier
	 bitrate management */

  if((ret=_mapping_P[0]->forward(vb)))
	return(ret);

  if(op){
	if(vorbis_bitrate_managed(vb))
	  /* The app is using a bitmanaged mode... but not using the
		 bitrate management interface. */
	  return(OV_EINVAL);

	op->packet=oggpack_get_buffer(&vb->opb);
	op->bytes=oggpack_bytes(&vb->opb);
	op->b_o_s=0;
	op->e_o_s=vb->eofflag;
	op->granulepos=vb->granulepos;
	op->packetno=vb->sequence; /* for sake of completeness */
  }
  return(0);
}

#ifdef ANALYSIS
int analysis_noisy=1;

/* there was no great place to put this.... */
void _analysis_output_always(char *base,int i,float *v,int n,int bark,int dB,ogg_int64_t off){
  int j;
  FILE *of;
  char buffer[80];

  sprintf(buffer,"%s_%d.m",base,i);
  of=fopen(buffer,"w");

  if(!of)perror("failed to open data dump file");

  for(j=0;j<n;j++){
	if(bark){
	  float b=toBARK((4000.f*j/n)+.25);
	  fprintf(of,"%f ",b);
	}else
	  if(off!=0)
		fprintf(of,"%f ",(double)(j+off)/8000.);
	  else
		fprintf(of,"%f ",(double)j);

	if(dB){
	  float val;
	  if(v[j]==0.)
		val=-140.;
	  else
		val=todB(v+j);
	  fprintf(of,"%f\n",val);
	}else{
	  fprintf(of,"%f\n",v[j]);
	}
  }
  fclose(of);
}

void _analysis_output(char *base,int i,float *v,int n,int bark,int dB,
					  ogg_int64_t off){
  if(analysis_noisy)_analysis_output_always(base,i,v,n,bark,dB,off);
}

#endif

/*** End of inlined file: analysis.c ***/


/*** Start of inlined file: bitrate.c ***/
#include <stdlib.h>
#include <string.h>
#include <math.h>

/* compute bitrate tracking setup  */
void vorbis_bitrate_init(vorbis_info *vi,bitrate_manager_state *bm){
  codec_setup_info *ci=(codec_setup_info *)vi->codec_setup;
  bitrate_manager_info *bi=&ci->bi;

  memset(bm,0,sizeof(*bm));

  if(bi && (bi->reservoir_bits>0)){
	long ratesamples=vi->rate;
	int  halfsamples=ci->blocksizes[0]>>1;

	bm->short_per_long=ci->blocksizes[1]/ci->blocksizes[0];
	bm->managed=1;

	bm->avg_bitsper= rint(1.*bi->avg_rate*halfsamples/ratesamples);
	bm->min_bitsper= rint(1.*bi->min_rate*halfsamples/ratesamples);
	bm->max_bitsper= rint(1.*bi->max_rate*halfsamples/ratesamples);

	bm->avgfloat=PACKETBLOBS/2;

	/* not a necessary fix, but one that leads to a more balanced
	   typical initialization */
	{
	  long desired_fill=bi->reservoir_bits*bi->reservoir_bias;
	  bm->minmax_reservoir=desired_fill;
	  bm->avg_reservoir=desired_fill;
	}

  }
}

void vorbis_bitrate_clear(bitrate_manager_state *bm){
  memset(bm,0,sizeof(*bm));
  return;
}

int vorbis_bitrate_managed(vorbis_block *vb){
  vorbis_dsp_state      *vd=vb->vd;
  private_state         *b=(private_state*)vd->backend_state;
  bitrate_manager_state *bm=&b->bms;

  if(bm && bm->managed)return(1);
  return(0);
}

/* finish taking in the block we just processed */
int vorbis_bitrate_addblock(vorbis_block *vb){
  vorbis_block_internal *vbi=(vorbis_block_internal*)vb->internal;
  vorbis_dsp_state      *vd=vb->vd;
  private_state         *b=(private_state*)vd->backend_state;
  bitrate_manager_state *bm=&b->bms;
  vorbis_info           *vi=vd->vi;
  codec_setup_info      *ci=(codec_setup_info*)vi->codec_setup;
  bitrate_manager_info  *bi=&ci->bi;

  int  choice=rint(bm->avgfloat);
  long this_bits=oggpack_bytes(vbi->packetblob[choice])*8;
  long min_target_bits=(vb->W?bm->min_bitsper*bm->short_per_long:bm->min_bitsper);
  long max_target_bits=(vb->W?bm->max_bitsper*bm->short_per_long:bm->max_bitsper);
  int  samples=ci->blocksizes[vb->W]>>1;
  long desired_fill=bi->reservoir_bits*bi->reservoir_bias;
  if(!bm->managed){
	/* not a bitrate managed stream, but for API simplicity, we'll
	   buffer the packet to keep the code path clean */

	if(bm->vb)return(-1); /* one has been submitted without
							 being claimed */
	bm->vb=vb;
	return(0);
  }

  bm->vb=vb;

  /* look ahead for avg floater */
  if(bm->avg_bitsper>0){
	double slew=0.;
	long avg_target_bits=(vb->W?bm->avg_bitsper*bm->short_per_long:bm->avg_bitsper);
	double slewlimit= 15./bi->slew_damp;

	/* choosing a new floater:
	   if we're over target, we slew down
	   if we're under target, we slew up

	   choose slew as follows: look through packetblobs of this frame
	   and set slew as the first in the appropriate direction that
	   gives us the slew we want.  This may mean no slew if delta is
	   already favorable.

	   Then limit slew to slew max */

	if(bm->avg_reservoir+(this_bits-avg_target_bits)>desired_fill){
	  while(choice>0 && this_bits>avg_target_bits &&
			bm->avg_reservoir+(this_bits-avg_target_bits)>desired_fill){
		choice--;
		this_bits=oggpack_bytes(vbi->packetblob[choice])*8;
	  }
	}else if(bm->avg_reservoir+(this_bits-avg_target_bits)<desired_fill){
	  while(choice+1<PACKETBLOBS && this_bits<avg_target_bits &&
			bm->avg_reservoir+(this_bits-avg_target_bits)<desired_fill){
		choice++;
		this_bits=oggpack_bytes(vbi->packetblob[choice])*8;
	  }
	}

	slew=rint(choice-bm->avgfloat)/samples*vi->rate;
	if(slew<-slewlimit)slew=-slewlimit;
	if(slew>slewlimit)slew=slewlimit;
	choice=rint(bm->avgfloat+= slew/vi->rate*samples);
	this_bits=oggpack_bytes(vbi->packetblob[choice])*8;
  }

  /* enforce min(if used) on the current floater (if used) */
  if(bm->min_bitsper>0){
	/* do we need to force the bitrate up? */
	if(this_bits<min_target_bits){
	  while(bm->minmax_reservoir-(min_target_bits-this_bits)<0){
		choice++;
		if(choice>=PACKETBLOBS)break;
		this_bits=oggpack_bytes(vbi->packetblob[choice])*8;
	  }
	}
  }

  /* enforce max (if used) on the current floater (if used) */
  if(bm->max_bitsper>0){
	/* do we need to force the bitrate down? */
	if(this_bits>max_target_bits){
	  while(bm->minmax_reservoir+(this_bits-max_target_bits)>bi->reservoir_bits){
		choice--;
		if(choice<0)break;
		this_bits=oggpack_bytes(vbi->packetblob[choice])*8;
	  }
	}
  }

  /* Choice of packetblobs now made based on floater, and min/max
	 requirements. Now boundary check extreme choices */

  if(choice<0){
	/* choosing a smaller packetblob is insufficient to trim bitrate.
	   frame will need to be truncated */
	long maxsize=(max_target_bits+(bi->reservoir_bits-bm->minmax_reservoir))/8;
	bm->choice=choice=0;

	if(oggpack_bytes(vbi->packetblob[choice])>maxsize){

	  oggpack_writetrunc(vbi->packetblob[choice],maxsize*8);
	  this_bits=oggpack_bytes(vbi->packetblob[choice])*8;
	}
  }else{
	long minsize=(min_target_bits-bm->minmax_reservoir+7)/8;
	if(choice>=PACKETBLOBS)
	  choice=PACKETBLOBS-1;

	bm->choice=choice;

	/* prop up bitrate according to demand. pad this frame out with zeroes */
	minsize-=oggpack_bytes(vbi->packetblob[choice]);
	while(minsize-->0)oggpack_write(vbi->packetblob[choice],0,8);
	this_bits=oggpack_bytes(vbi->packetblob[choice])*8;

  }

  /* now we have the final packet and the final packet size.  Update statistics */
  /* min and max reservoir */
  if(bm->min_bitsper>0 || bm->max_bitsper>0){

	if(max_target_bits>0 && this_bits>max_target_bits){
	  bm->minmax_reservoir+=(this_bits-max_target_bits);
	}else if(min_target_bits>0 && this_bits<min_target_bits){
	  bm->minmax_reservoir+=(this_bits-min_target_bits);
	}else{
	  /* inbetween; we want to take reservoir toward but not past desired_fill */
	  if(bm->minmax_reservoir>desired_fill){
		if(max_target_bits>0){ /* logical bulletproofing against initialization state */
		  bm->minmax_reservoir+=(this_bits-max_target_bits);
		  if(bm->minmax_reservoir<desired_fill)bm->minmax_reservoir=desired_fill;
		}else{
		  bm->minmax_reservoir=desired_fill;
		}
	  }else{
		if(min_target_bits>0){ /* logical bulletproofing against initialization state */
		  bm->minmax_reservoir+=(this_bits-min_target_bits);
		  if(bm->minmax_reservoir>desired_fill)bm->minmax_reservoir=desired_fill;
		}else{
		  bm->minmax_reservoir=desired_fill;
		}
	  }
	}
  }

  /* avg reservoir */
  if(bm->avg_bitsper>0){
	long avg_target_bits=(vb->W?bm->avg_bitsper*bm->short_per_long:bm->avg_bitsper);
	bm->avg_reservoir+=this_bits-avg_target_bits;
  }

  return(0);
}

int vorbis_bitrate_flushpacket(vorbis_dsp_state *vd,ogg_packet *op){
  private_state         *b=(private_state*)vd->backend_state;
  bitrate_manager_state *bm=&b->bms;
  vorbis_block          *vb=bm->vb;
  int                    choice=PACKETBLOBS/2;
  if(!vb)return 0;

  if(op){
	vorbis_block_internal *vbi=(vorbis_block_internal*)vb->internal;

	if(vorbis_bitrate_managed(vb))
	  choice=bm->choice;

	op->packet=oggpack_get_buffer(vbi->packetblob[choice]);
	op->bytes=oggpack_bytes(vbi->packetblob[choice]);
	op->b_o_s=0;
	op->e_o_s=vb->eofflag;
	op->granulepos=vb->granulepos;
	op->packetno=vb->sequence; /* for sake of completeness */
  }

  bm->vb=0;
  return(1);
}

/*** End of inlined file: bitrate.c ***/


/*** Start of inlined file: block.c ***/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


/*** Start of inlined file: window.h ***/
#ifndef _V_WINDOW_
#define _V_WINDOW_

extern float *_vorbis_window_get(int n);
extern void _vorbis_apply_window(float *d,int *winno,long *blocksizes,
						  int lW,int W,int nW);

#endif

/*** End of inlined file: window.h ***/


/*** Start of inlined file: lpc.h ***/
#ifndef _V_LPC_H_
#define _V_LPC_H_

/* simple linear scale LPC code */
extern float vorbis_lpc_from_data(float *data,float *lpc,int n,int m);

extern void vorbis_lpc_predict(float *coeff,float *prime,int m,
							   float *data,long n);

#endif

/*** End of inlined file: lpc.h ***/

/* pcm accumulator examples (not exhaustive):

 <-------------- lW ---------------->
				   <--------------- W ---------------->
:            .....|.....       _______________         |
:        .'''     |     '''_---      |       |\        |
:.....'''         |_____--- '''......|       | \_______|
:.................|__________________|_______|__|______|
				  |<------ Sl ------>|      > Sr <     |endW
				  |beginSl           |endSl  |  |endSr
				  |beginW            |endlW  |beginSr

					  |< lW >|
				   <--------------- W ---------------->
				  |   |  ..  ______________            |
				  |   | '  `/        |     ---_        |
				  |___.'___/`.       |         ---_____|
				  |_______|__|_______|_________________|
				  |      >|Sl|<      |<------ Sr ----->|endW
				  |       |  |endSl  |beginSr          |endSr
				  |beginW |  |endlW
				  mult[0] |beginSl                     mult[n]

 <-------------- lW ----------------->
						  |<--W-->|
:            ..............  ___  |   |
:        .'''             |`/   \ |   |
:.....'''                 |/`....\|...|
:.........................|___|___|___|
						  |Sl |Sr |endW
						  |   |   |endSr
						  |   |beginSr
						  |   |endSl
						  |beginSl
						  |beginW
*/

/* block abstraction setup *********************************************/

#ifndef WORD_ALIGN
#define WORD_ALIGN 8
#endif

int vorbis_block_init(vorbis_dsp_state *v, vorbis_block *vb){
  int i;
  memset(vb,0,sizeof(*vb));
  vb->vd=v;
  vb->localalloc=0;
  vb->localstore=NULL;
  if(v->analysisp){
	vorbis_block_internal *vbi=(vorbis_block_internal*)
	  (vb->internal=(vorbis_block_internal*)_ogg_calloc(1,sizeof(vorbis_block_internal)));
	vbi->ampmax=-9999;

	for(i=0;i<PACKETBLOBS;i++){
	  if(i==PACKETBLOBS/2){
		vbi->packetblob[i]=&vb->opb;
	  }else{
		vbi->packetblob[i]=
	  (oggpack_buffer*) _ogg_calloc(1,sizeof(oggpack_buffer));
	  }
	  oggpack_writeinit(vbi->packetblob[i]);
	}
  }

  return(0);
}

void *_vorbis_block_alloc(vorbis_block *vb,long bytes){
  bytes=(bytes+(WORD_ALIGN-1)) & ~(WORD_ALIGN-1);
  if(bytes+vb->localtop>vb->localalloc){
	/* can't just _ogg_realloc... there are outstanding pointers */
	if(vb->localstore){
	  struct alloc_chain *link=(struct alloc_chain*)_ogg_malloc(sizeof(*link));
	  vb->totaluse+=vb->localtop;
	  link->next=vb->reap;
	  link->ptr=vb->localstore;
	  vb->reap=link;
	}
	/* highly conservative */
	vb->localalloc=bytes;
	vb->localstore=_ogg_malloc(vb->localalloc);
	vb->localtop=0;
  }
  {
	void *ret=(void *)(((char *)vb->localstore)+vb->localtop);
	vb->localtop+=bytes;
	return ret;
  }
}

/* reap the chain, pull the ripcord */
void _vorbis_block_ripcord(vorbis_block *vb){
  /* reap the chain */
  struct alloc_chain *reap=vb->reap;
  while(reap){
	struct alloc_chain *next=reap->next;
	_ogg_free(reap->ptr);
	memset(reap,0,sizeof(*reap));
	_ogg_free(reap);
	reap=next;
  }
  /* consolidate storage */
  if(vb->totaluse){
	vb->localstore=_ogg_realloc(vb->localstore,vb->totaluse+vb->localalloc);
	vb->localalloc+=vb->totaluse;
	vb->totaluse=0;
  }

  /* pull the ripcord */
  vb->localtop=0;
  vb->reap=NULL;
}

int vorbis_block_clear(vorbis_block *vb){
  int i;
  vorbis_block_internal *vbi=(vorbis_block_internal*)vb->internal;

  _vorbis_block_ripcord(vb);
  if(vb->localstore)_ogg_free(vb->localstore);

  if(vbi){
	for(i=0;i<PACKETBLOBS;i++){
	  oggpack_writeclear(vbi->packetblob[i]);
	  if(i!=PACKETBLOBS/2)_ogg_free(vbi->packetblob[i]);
	}
	_ogg_free(vbi);
  }
  memset(vb,0,sizeof(*vb));
  return(0);
}

/* Analysis side code, but directly related to blocking.  Thus it's
   here and not in analysis.c (which is for analysis transforms only).
   The init is here because some of it is shared */

static int _vds_shared_init(vorbis_dsp_state *v,vorbis_info *vi,int encp){
  int i;
  codec_setup_info *ci=(codec_setup_info*)vi->codec_setup;
  private_state *b=NULL;
  int hs;

  if(ci==NULL) return 1;
  hs=ci->halfrate_flag;

  memset(v,0,sizeof(*v));
  b=(private_state*) (v->backend_state=(private_state*)_ogg_calloc(1,sizeof(*b)));

  v->vi=vi;
  b->modebits=ilog2(ci->modes);

  b->transform[0]=(vorbis_look_transform**)_ogg_calloc(VI_TRANSFORMB,sizeof(*b->transform[0]));
  b->transform[1]=(vorbis_look_transform**)_ogg_calloc(VI_TRANSFORMB,sizeof(*b->transform[1]));

  /* MDCT is tranform 0 */

  b->transform[0][0]=_ogg_calloc(1,sizeof(mdct_lookup));
  b->transform[1][0]=_ogg_calloc(1,sizeof(mdct_lookup));
  mdct_init((mdct_lookup*)b->transform[0][0],ci->blocksizes[0]>>hs);
  mdct_init((mdct_lookup*)b->transform[1][0],ci->blocksizes[1]>>hs);

  /* Vorbis I uses only window type 0 */
  b->window[0]=ilog2(ci->blocksizes[0])-6;
  b->window[1]=ilog2(ci->blocksizes[1])-6;

  if(encp){ /* encode/decode differ here */

	/* analysis always needs an fft */
	drft_init(&b->fft_look[0],ci->blocksizes[0]);
	drft_init(&b->fft_look[1],ci->blocksizes[1]);

	/* finish the codebooks */
	if(!ci->fullbooks){
	  ci->fullbooks=(codebook*) _ogg_calloc(ci->books,sizeof(*ci->fullbooks));
	  for(i=0;i<ci->books;i++)
		vorbis_book_init_encode(ci->fullbooks+i,ci->book_param[i]);
	}

	b->psy=(vorbis_look_psy*)_ogg_calloc(ci->psys,sizeof(*b->psy));
	for(i=0;i<ci->psys;i++){
	  _vp_psy_init(b->psy+i,
				   ci->psy_param[i],
				   &ci->psy_g_param,
				   ci->blocksizes[ci->psy_param[i]->blockflag]/2,
				   vi->rate);
	}

	v->analysisp=1;
  }else{
	/* finish the codebooks */
	if(!ci->fullbooks){
	  ci->fullbooks=(codebook*) _ogg_calloc(ci->books,sizeof(*ci->fullbooks));
	  for(i=0;i<ci->books;i++){
		if(ci->book_param[i]==NULL)
		  goto abort_books;
		if(vorbis_book_init_decode(ci->fullbooks+i,ci->book_param[i]))
		  goto abort_books;
		/* decode codebooks are now standalone after init */
		vorbis_staticbook_destroy(ci->book_param[i]);
		ci->book_param[i]=NULL;
	  }
	}
  }

  /* initialize the storage vectors. blocksize[1] is small for encode,
	 but the correct size for decode */
  v->pcm_storage=ci->blocksizes[1];
  v->pcm=(float**)_ogg_malloc(vi->channels*sizeof(*v->pcm));
  v->pcmret=(float**)_ogg_malloc(vi->channels*sizeof(*v->pcmret));
  {
	int i;
	for(i=0;i<vi->channels;i++)
	  v->pcm[i]=(float*)_ogg_calloc(v->pcm_storage,sizeof(*v->pcm[i]));
  }

  /* all 1 (large block) or 0 (small block) */
  /* explicitly set for the sake of clarity */
  v->lW=0; /* previous window size */
  v->W=0;  /* current window size */

  /* all vector indexes */
  v->centerW=ci->blocksizes[1]/2;

  v->pcm_current=v->centerW;

  /* initialize all the backend lookups */
  b->flr=(vorbis_look_floor**)_ogg_calloc(ci->floors,sizeof(*b->flr));
  b->residue=(vorbis_look_residue**)_ogg_calloc(ci->residues,sizeof(*b->residue));

  for(i=0;i<ci->floors;i++)
	b->flr[i]=_floor_P[ci->floor_type[i]]->
	  look(v,ci->floor_param[i]);

  for(i=0;i<ci->residues;i++)
	b->residue[i]=_residue_P[ci->residue_type[i]]->
	  look(v,ci->residue_param[i]);

  return 0;
 abort_books:
  for(i=0;i<ci->books;i++){
	if(ci->book_param[i]!=NULL){
	  vorbis_staticbook_destroy(ci->book_param[i]);
	  ci->book_param[i]=NULL;
	}
  }
  vorbis_dsp_clear(v);
  return -1;
}

/* arbitrary settings and spec-mandated numbers get filled in here */
int vorbis_analysis_init(vorbis_dsp_state *v,vorbis_info *vi){
  private_state *b=NULL;

  if(_vds_shared_init(v,vi,1))return 1;
  b=(private_state*)v->backend_state;
  b->psy_g_look=_vp_global_look(vi);

  /* Initialize the envelope state storage */
  b->ve=(envelope_lookup*)_ogg_calloc(1,sizeof(*b->ve));
  _ve_envelope_init(b->ve,vi);

  vorbis_bitrate_init(vi,&b->bms);

  /* compressed audio packets start after the headers
	 with sequence number 3 */
  v->sequence=3;

  return(0);
}

void vorbis_dsp_clear(vorbis_dsp_state *v){
  int i;
  if(v){
	vorbis_info *vi=v->vi;
	codec_setup_info *ci=(codec_setup_info*)(vi?vi->codec_setup:NULL);
	private_state *b=(private_state*)v->backend_state;

	if(b){

	  if(b->ve){
		_ve_envelope_clear(b->ve);
		_ogg_free(b->ve);
	  }

	  if(b->transform[0]){
	mdct_clear((mdct_lookup*) b->transform[0][0]);
		_ogg_free(b->transform[0][0]);
		_ogg_free(b->transform[0]);
	  }
	  if(b->transform[1]){
	mdct_clear((mdct_lookup*) b->transform[1][0]);
		_ogg_free(b->transform[1][0]);
		_ogg_free(b->transform[1]);
	  }

	  if(b->flr){
		if(ci)
		  for(i=0;i<ci->floors;i++)
			_floor_P[ci->floor_type[i]]->
			  free_look(b->flr[i]);
		_ogg_free(b->flr);
	  }
	  if(b->residue){
		if(ci)
		  for(i=0;i<ci->residues;i++)
			_residue_P[ci->residue_type[i]]->
			  free_look(b->residue[i]);
		_ogg_free(b->residue);
	  }
	  if(b->psy){
		if(ci)
		  for(i=0;i<ci->psys;i++)
			_vp_psy_clear(b->psy+i);
		_ogg_free(b->psy);
	  }

	  if(b->psy_g_look)_vp_global_free(b->psy_g_look);
	  vorbis_bitrate_clear(&b->bms);

	  drft_clear(&b->fft_look[0]);
	  drft_clear(&b->fft_look[1]);

	}

	if(v->pcm){
	  if(vi)
		for(i=0;i<vi->channels;i++)
		  if(v->pcm[i])_ogg_free(v->pcm[i]);
	  _ogg_free(v->pcm);
	  if(v->pcmret)_ogg_free(v->pcmret);
	}

	if(b){
	  /* free header, header1, header2 */
	  if(b->header)_ogg_free(b->header);
	  if(b->header1)_ogg_free(b->header1);
	  if(b->header2)_ogg_free(b->header2);
	  _ogg_free(b);
	}

	memset(v,0,sizeof(*v));
  }
}

float **vorbis_analysis_buffer(vorbis_dsp_state *v, int vals){
  int i;
  vorbis_info *vi=v->vi;
  private_state *b=(private_state*)v->backend_state;

  /* free header, header1, header2 */
  if(b->header)_ogg_free(b->header);b->header=NULL;
  if(b->header1)_ogg_free(b->header1);b->header1=NULL;
  if(b->header2)_ogg_free(b->header2);b->header2=NULL;

  /* Do we have enough storage space for the requested buffer? If not,
	 expand the PCM (and envelope) storage */

  if(v->pcm_current+vals>=v->pcm_storage){
	v->pcm_storage=v->pcm_current+vals*2;

	for(i=0;i<vi->channels;i++){
	  v->pcm[i]=(float*)_ogg_realloc(v->pcm[i],v->pcm_storage*sizeof(*v->pcm[i]));
	}
  }

  for(i=0;i<vi->channels;i++)
	v->pcmret[i]=v->pcm[i]+v->pcm_current;

  return(v->pcmret);
}

static void _preextrapolate_helper(vorbis_dsp_state *v){
  int i;
  int order=32;
  float *lpc=(float*)alloca(order*sizeof(*lpc));
  float *work=(float*)alloca(v->pcm_current*sizeof(*work));
  long j;
  v->preextrapolate=1;

  if(v->pcm_current-v->centerW>order*2){ /* safety */
	for(i=0;i<v->vi->channels;i++){
	  /* need to run the extrapolation in reverse! */
	  for(j=0;j<v->pcm_current;j++)
		work[j]=v->pcm[i][v->pcm_current-j-1];

	  /* prime as above */
	  vorbis_lpc_from_data(work,lpc,v->pcm_current-v->centerW,order);

#if 0
	  if(v->vi->channels==2){
		if(i==0)
		  _analysis_output("predataL",0,work,v->pcm_current-v->centerW,0,0,0);
		else
		  _analysis_output("predataR",0,work,v->pcm_current-v->centerW,0,0,0);
	  }else{
		_analysis_output("predata",0,work,v->pcm_current-v->centerW,0,0,0);
	  }
#endif

	  /* run the predictor filter */
	  vorbis_lpc_predict(lpc,work+v->pcm_current-v->centerW-order,
						 order,
						 work+v->pcm_current-v->centerW,
						 v->centerW);

	  for(j=0;j<v->pcm_current;j++)
		v->pcm[i][v->pcm_current-j-1]=work[j];

	}
  }
}

/* call with val<=0 to set eof */

int vorbis_analysis_wrote(vorbis_dsp_state *v, int vals){
  vorbis_info *vi=v->vi;
  codec_setup_info *ci=(codec_setup_info*)vi->codec_setup;

  if(vals<=0){
	int order=32;
	int i;
	float *lpc=(float*) alloca(order*sizeof(*lpc));

	/* if it wasn't done earlier (very short sample) */
	if(!v->preextrapolate)
	  _preextrapolate_helper(v);

	/* We're encoding the end of the stream.  Just make sure we have
	   [at least] a few full blocks of zeroes at the end. */
	/* actually, we don't want zeroes; that could drop a large
	   amplitude off a cliff, creating spread spectrum noise that will
	   suck to encode.  Extrapolate for the sake of cleanliness. */

	vorbis_analysis_buffer(v,ci->blocksizes[1]*3);
	v->eofflag=v->pcm_current;
	v->pcm_current+=ci->blocksizes[1]*3;

	for(i=0;i<vi->channels;i++){
	  if(v->eofflag>order*2){
		/* extrapolate with LPC to fill in */
		long n;

		/* make a predictor filter */
		n=v->eofflag;
		if(n>ci->blocksizes[1])n=ci->blocksizes[1];
		vorbis_lpc_from_data(v->pcm[i]+v->eofflag-n,lpc,n,order);

		/* run the predictor filter */
		vorbis_lpc_predict(lpc,v->pcm[i]+v->eofflag-order,order,
						   v->pcm[i]+v->eofflag,v->pcm_current-v->eofflag);
	  }else{
		/* not enough data to extrapolate (unlikely to happen due to
		   guarding the overlap, but bulletproof in case that
		   assumtion goes away). zeroes will do. */
		memset(v->pcm[i]+v->eofflag,0,
			   (v->pcm_current-v->eofflag)*sizeof(*v->pcm[i]));

	  }
	}
  }else{

	if(v->pcm_current+vals>v->pcm_storage)
	  return(OV_EINVAL);

	v->pcm_current+=vals;

	/* we may want to reverse extrapolate the beginning of a stream
	   too... in case we're beginning on a cliff! */
	/* clumsy, but simple.  It only runs once, so simple is good. */
	if(!v->preextrapolate && v->pcm_current-v->centerW>ci->blocksizes[1])
	  _preextrapolate_helper(v);

  }
  return(0);
}

/* do the deltas, envelope shaping, pre-echo and determine the size of
   the next block on which to continue analysis */
int vorbis_analysis_blockout(vorbis_dsp_state *v,vorbis_block *vb){
  int i;
  vorbis_info *vi=v->vi;
  codec_setup_info *ci=(codec_setup_info*)vi->codec_setup;
  private_state *b=(private_state*)v->backend_state;
  vorbis_look_psy_global *g=b->psy_g_look;
  long beginW=v->centerW-ci->blocksizes[v->W]/2,centerNext;
  vorbis_block_internal *vbi=(vorbis_block_internal *)vb->internal;

  /* check to see if we're started... */
  if(!v->preextrapolate)return(0);

  /* check to see if we're done... */
  if(v->eofflag==-1)return(0);

  /* By our invariant, we have lW, W and centerW set.  Search for
	 the next boundary so we can determine nW (the next window size)
	 which lets us compute the shape of the current block's window */

  /* we do an envelope search even on a single blocksize; we may still
	 be throwing more bits at impulses, and envelope search handles
	 marking impulses too. */
  {
	long bp=_ve_envelope_search(v);
	if(bp==-1){

	  if(v->eofflag==0)return(0); /* not enough data currently to search for a
									 full long block */
	  v->nW=0;
	}else{

	  if(ci->blocksizes[0]==ci->blocksizes[1])
		v->nW=0;
	  else
		v->nW=bp;
	}
  }

  centerNext=v->centerW+ci->blocksizes[v->W]/4+ci->blocksizes[v->nW]/4;

  {
	/* center of next block + next block maximum right side. */

	long blockbound=centerNext+ci->blocksizes[v->nW]/2;
	if(v->pcm_current<blockbound)return(0); /* not enough data yet;
											   although this check is
											   less strict that the
											   _ve_envelope_search,
											   the search is not run
											   if we only use one
											   block size */

  }

  /* fill in the block.  Note that for a short window, lW and nW are *short*
	 regardless of actual settings in the stream */

  _vorbis_block_ripcord(vb);
  vb->lW=v->lW;
  vb->W=v->W;
  vb->nW=v->nW;

  if(v->W){
	if(!v->lW || !v->nW){
	  vbi->blocktype=BLOCKTYPE_TRANSITION;
	  /*fprintf(stderr,"-");*/
	}else{
	  vbi->blocktype=BLOCKTYPE_LONG;
	  /*fprintf(stderr,"_");*/
	}
  }else{
	if(_ve_envelope_mark(v)){
	  vbi->blocktype=BLOCKTYPE_IMPULSE;
	  /*fprintf(stderr,"|");*/

	}else{
	  vbi->blocktype=BLOCKTYPE_PADDING;
	  /*fprintf(stderr,".");*/

	}
  }

  vb->vd=v;
  vb->sequence=v->sequence++;
  vb->granulepos=v->granulepos;
  vb->pcmend=ci->blocksizes[v->W];

  /* copy the vectors; this uses the local storage in vb */

  /* this tracks 'strongest peak' for later psychoacoustics */
  /* moved to the global psy state; clean this mess up */
  if(vbi->ampmax>g->ampmax)g->ampmax=vbi->ampmax;
  g->ampmax=_vp_ampmax_decay(g->ampmax,v);
  vbi->ampmax=g->ampmax;

  vb->pcm=(float**)_vorbis_block_alloc(vb,sizeof(*vb->pcm)*vi->channels);
  vbi->pcmdelay=(float**)_vorbis_block_alloc(vb,sizeof(*vbi->pcmdelay)*vi->channels);
  for(i=0;i<vi->channels;i++){
	vbi->pcmdelay[i]=
	  (float*) _vorbis_block_alloc(vb,(vb->pcmend+beginW)*sizeof(*vbi->pcmdelay[i]));
	memcpy(vbi->pcmdelay[i],v->pcm[i],(vb->pcmend+beginW)*sizeof(*vbi->pcmdelay[i]));
	vb->pcm[i]=vbi->pcmdelay[i]+beginW;

	/* before we added the delay
	   vb->pcm[i]=_vorbis_block_alloc(vb,vb->pcmend*sizeof(*vb->pcm[i]));
	   memcpy(vb->pcm[i],v->pcm[i]+beginW,ci->blocksizes[v->W]*sizeof(*vb->pcm[i]));
	*/

  }

  /* handle eof detection: eof==0 means that we've not yet received EOF
						   eof>0  marks the last 'real' sample in pcm[]
						   eof<0  'no more to do'; doesn't get here */

  if(v->eofflag){
	if(v->centerW>=v->eofflag){
	  v->eofflag=-1;
	  vb->eofflag=1;
	  return(1);
	}
  }

  /* advance storage vectors and clean up */
  {
	int new_centerNext=ci->blocksizes[1]/2;
	int movementW=centerNext-new_centerNext;

	if(movementW>0){

	  _ve_envelope_shift(b->ve,movementW);
	  v->pcm_current-=movementW;

	  for(i=0;i<vi->channels;i++)
		memmove(v->pcm[i],v->pcm[i]+movementW,
				v->pcm_current*sizeof(*v->pcm[i]));

	  v->lW=v->W;
	  v->W=v->nW;
	  v->centerW=new_centerNext;

	  if(v->eofflag){
		v->eofflag-=movementW;
		if(v->eofflag<=0)v->eofflag=-1;
		/* do not add padding to end of stream! */
		if(v->centerW>=v->eofflag){
		  v->granulepos+=movementW-(v->centerW-v->eofflag);
		}else{
		  v->granulepos+=movementW;
		}
	  }else{
		v->granulepos+=movementW;
	  }
	}
  }

  /* done */
  return(1);
}

int vorbis_synthesis_restart(vorbis_dsp_state *v){
  vorbis_info *vi=v->vi;
  codec_setup_info *ci;
  int hs;

  if(!v->backend_state)return -1;
  if(!vi)return -1;
  ci=(codec_setup_info*) vi->codec_setup;
  if(!ci)return -1;
  hs=ci->halfrate_flag;

  v->centerW=ci->blocksizes[1]>>(hs+1);
  v->pcm_current=v->centerW>>hs;

  v->pcm_returned=-1;
  v->granulepos=-1;
  v->sequence=-1;
  v->eofflag=0;
  ((private_state *)(v->backend_state))->sample_count=-1;

  return(0);
}

int vorbis_synthesis_init(vorbis_dsp_state *v,vorbis_info *vi){
  if(_vds_shared_init(v,vi,0)){
	vorbis_dsp_clear(v);
	return 1;
  }
  vorbis_synthesis_restart(v);
  return 0;
}

/* Unlike in analysis, the window is only partially applied for each
   block.  The time domain envelope is not yet handled at the point of
   calling (as it relies on the previous block). */

int vorbis_synthesis_blockin(vorbis_dsp_state *v,vorbis_block *vb){
  vorbis_info *vi=v->vi;
  codec_setup_info *ci=(codec_setup_info*)vi->codec_setup;
  private_state *b=(private_state*)v->backend_state;
  int hs=ci->halfrate_flag;
  int i,j;

  if(!vb)return(OV_EINVAL);
  if(v->pcm_current>v->pcm_returned  && v->pcm_returned!=-1)return(OV_EINVAL);

  v->lW=v->W;
  v->W=vb->W;
  v->nW=-1;

  if((v->sequence==-1)||
	 (v->sequence+1 != vb->sequence)){
	v->granulepos=-1; /* out of sequence; lose count */
	b->sample_count=-1;
  }

  v->sequence=vb->sequence;

  if(vb->pcm){  /* no pcm to process if vorbis_synthesis_trackonly
				   was called on block */
	int n=ci->blocksizes[v->W]>>(hs+1);
	int n0=ci->blocksizes[0]>>(hs+1);
	int n1=ci->blocksizes[1]>>(hs+1);

	int thisCenter;
	int prevCenter;

	v->glue_bits+=vb->glue_bits;
	v->time_bits+=vb->time_bits;
	v->floor_bits+=vb->floor_bits;
	v->res_bits+=vb->res_bits;

	if(v->centerW){
	  thisCenter=n1;
	  prevCenter=0;
	}else{
	  thisCenter=0;
	  prevCenter=n1;
	}

	/* v->pcm is now used like a two-stage double buffer.  We don't want
	   to have to constantly shift *or* adjust memory usage.  Don't
	   accept a new block until the old is shifted out */

	for(j=0;j<vi->channels;j++){
	  /* the overlap/add section */
	  if(v->lW){
		if(v->W){
		  /* large/large */
		  const float *w=_vorbis_window_get(b->window[1]-hs);
		  float *pcm=v->pcm[j]+prevCenter;
		  float *p=vb->pcm[j];
		  for(i=0;i<n1;i++)
			pcm[i]=pcm[i]*w[n1-i-1] + p[i]*w[i];
		}else{
		  /* large/small */
		  const float *w=_vorbis_window_get(b->window[0]-hs);
		  float *pcm=v->pcm[j]+prevCenter+n1/2-n0/2;
		  float *p=vb->pcm[j];
		  for(i=0;i<n0;i++)
			pcm[i]=pcm[i]*w[n0-i-1] +p[i]*w[i];
		}
	  }else{
		if(v->W){
		  /* small/large */
		  const float *w=_vorbis_window_get(b->window[0]-hs);
		  float *pcm=v->pcm[j]+prevCenter;
		  float *p=vb->pcm[j]+n1/2-n0/2;
		  for(i=0;i<n0;i++)
			pcm[i]=pcm[i]*w[n0-i-1] +p[i]*w[i];
		  for(;i<n1/2+n0/2;i++)
			pcm[i]=p[i];
		}else{
		  /* small/small */
		  const float *w=_vorbis_window_get(b->window[0]-hs);
		  float *pcm=v->pcm[j]+prevCenter;
		  float *p=vb->pcm[j];
		  for(i=0;i<n0;i++)
			pcm[i]=pcm[i]*w[n0-i-1] +p[i]*w[i];
		}
	  }

	  /* the copy section */
	  {
		float *pcm=v->pcm[j]+thisCenter;
		float *p=vb->pcm[j]+n;
		for(i=0;i<n;i++)
		  pcm[i]=p[i];
	  }
	}

	if(v->centerW)
	  v->centerW=0;
	else
	  v->centerW=n1;

	/* deal with initial packet state; we do this using the explicit
	   pcm_returned==-1 flag otherwise we're sensitive to first block
	   being short or long */

	if(v->pcm_returned==-1){
	  v->pcm_returned=thisCenter;
	  v->pcm_current=thisCenter;
	}else{
	  v->pcm_returned=prevCenter;
	  v->pcm_current=prevCenter+
		((ci->blocksizes[v->lW]/4+
		ci->blocksizes[v->W]/4)>>hs);
	}

  }

  /* track the frame number... This is for convenience, but also
	 making sure our last packet doesn't end with added padding.  If
	 the last packet is partial, the number of samples we'll have to
	 return will be past the vb->granulepos.

	 This is not foolproof!  It will be confused if we begin
	 decoding at the last page after a seek or hole.  In that case,
	 we don't have a starting point to judge where the last frame
	 is.  For this reason, vorbisfile will always try to make sure
	 it reads the last two marked pages in proper sequence */

  if(b->sample_count==-1){
	b->sample_count=0;
  }else{
	b->sample_count+=ci->blocksizes[v->lW]/4+ci->blocksizes[v->W]/4;
  }

  if(v->granulepos==-1){
	if(vb->granulepos!=-1){ /* only set if we have a position to set to */

	  v->granulepos=vb->granulepos;

	  /* is this a short page? */
	  if(b->sample_count>v->granulepos){
		/* corner case; if this is both the first and last audio page,
		   then spec says the end is cut, not beginning */
	   long extra=b->sample_count-vb->granulepos;

		/* we use ogg_int64_t for granule positions because a
		   uint64 isn't universally available.  Unfortunately,
		   that means granposes can be 'negative' and result in
		   extra being negative */
		if(extra<0)
		  extra=0;

		if(vb->eofflag){
		  /* trim the end */
		  /* no preceding granulepos; assume we started at zero (we'd
			 have to in a short single-page stream) */
		  /* granulepos could be -1 due to a seek, but that would result
			 in a long count, not short count */

		  /* Guard against corrupt/malicious frames that set EOP and
			 a backdated granpos; don't rewind more samples than we
			 actually have */
		  if(extra > (v->pcm_current - v->pcm_returned)<<hs)
			extra = (v->pcm_current - v->pcm_returned)<<hs;

		  v->pcm_current-=extra>>hs;
		}else{
		  /* trim the beginning */
		  v->pcm_returned+=extra>>hs;
		  if(v->pcm_returned>v->pcm_current)
			v->pcm_returned=v->pcm_current;
		}

	  }

	}
  }else{
	v->granulepos+=ci->blocksizes[v->lW]/4+ci->blocksizes[v->W]/4;
	if(vb->granulepos!=-1 && v->granulepos!=vb->granulepos){

	  if(v->granulepos>vb->granulepos){
		long extra=v->granulepos-vb->granulepos;

		if(extra)
		  if(vb->eofflag){
			/* partial last frame.  Strip the extra samples off */

			/* Guard against corrupt/malicious frames that set EOP and
			   a backdated granpos; don't rewind more samples than we
			   actually have */
			if(extra > (v->pcm_current - v->pcm_returned)<<hs)
			  extra = (v->pcm_current - v->pcm_returned)<<hs;

			/* we use ogg_int64_t for granule positions because a
			   uint64 isn't universally available.  Unfortunately,
			   that means granposes can be 'negative' and result in
			   extra being negative */
			if(extra<0)
			  extra=0;

			v->pcm_current-=extra>>hs;
		  } /* else {Shouldn't happen *unless* the bitstream is out of
			   spec.  Either way, believe the bitstream } */
	  } /* else {Shouldn't happen *unless* the bitstream is out of
		   spec.  Either way, believe the bitstream } */
	  v->granulepos=vb->granulepos;
	}
  }

  /* Update, cleanup */

  if(vb->eofflag)v->eofflag=1;
  return(0);

}

/* pcm==NULL indicates we just want the pending samples, no more */
int vorbis_synthesis_pcmout(vorbis_dsp_state *v,float ***pcm){
  vorbis_info *vi=v->vi;

  if(v->pcm_returned>-1 && v->pcm_returned<v->pcm_current){
	if(pcm){
	  int i;
	  for(i=0;i<vi->channels;i++)
		v->pcmret[i]=v->pcm[i]+v->pcm_returned;
	  *pcm=v->pcmret;
	}
	return(v->pcm_current-v->pcm_returned);
  }
  return(0);
}

int vorbis_synthesis_read(vorbis_dsp_state *v,int n){
  if(n && v->pcm_returned+n>v->pcm_current)return(OV_EINVAL);
  v->pcm_returned+=n;
  return(0);
}

/* intended for use with a specific vorbisfile feature; we want access
   to the [usually synthetic/postextrapolated] buffer and lapping at
   the end of a decode cycle, specifically, a half-short-block worth.
   This funtion works like pcmout above, except it will also expose
   this implicit buffer data not normally decoded. */
int vorbis_synthesis_lapout(vorbis_dsp_state *v,float ***pcm){
  vorbis_info *vi=v->vi;
  codec_setup_info *ci=(codec_setup_info *)vi->codec_setup;
  int hs=ci->halfrate_flag;

  int n=ci->blocksizes[v->W]>>(hs+1);
  int n0=ci->blocksizes[0]>>(hs+1);
  int n1=ci->blocksizes[1]>>(hs+1);
  int i,j;

  if(v->pcm_returned<0)return 0;

  /* our returned data ends at pcm_returned; because the synthesis pcm
	 buffer is a two-fragment ring, that means our data block may be
	 fragmented by buffering, wrapping or a short block not filling
	 out a buffer.  To simplify things, we unfragment if it's at all
	 possibly needed. Otherwise, we'd need to call lapout more than
	 once as well as hold additional dsp state.  Opt for
	 simplicity. */

  /* centerW was advanced by blockin; it would be the center of the
	 *next* block */
  if(v->centerW==n1){
	/* the data buffer wraps; swap the halves */
	/* slow, sure, small */
	for(j=0;j<vi->channels;j++){
	  float *p=v->pcm[j];
	  for(i=0;i<n1;i++){
		float temp=p[i];
		p[i]=p[i+n1];
		p[i+n1]=temp;
	  }
	}

	v->pcm_current-=n1;
	v->pcm_returned-=n1;
	v->centerW=0;
  }

  /* solidify buffer into contiguous space */
  if((v->lW^v->W)==1){
	/* long/short or short/long */
	for(j=0;j<vi->channels;j++){
	  float *s=v->pcm[j];
	  float *d=v->pcm[j]+(n1-n0)/2;
	  for(i=(n1+n0)/2-1;i>=0;--i)
		d[i]=s[i];
	}
	v->pcm_returned+=(n1-n0)/2;
	v->pcm_current+=(n1-n0)/2;
  }else{
	if(v->lW==0){
	  /* short/short */
	  for(j=0;j<vi->channels;j++){
		float *s=v->pcm[j];
		float *d=v->pcm[j]+n1-n0;
		for(i=n0-1;i>=0;--i)
		  d[i]=s[i];
	  }
	  v->pcm_returned+=n1-n0;
	  v->pcm_current+=n1-n0;
	}
  }

  if(pcm){
	int i;
	for(i=0;i<vi->channels;i++)
	  v->pcmret[i]=v->pcm[i]+v->pcm_returned;
	*pcm=v->pcmret;
  }

  return(n1+n-v->pcm_returned);

}

float *vorbis_window(vorbis_dsp_state *v,int W){
  vorbis_info *vi=v->vi;
  codec_setup_info *ci=(codec_setup_info*) vi->codec_setup;
  int hs=ci->halfrate_flag;
  private_state *b=(private_state*)v->backend_state;

  if(b->window[W]-1<0)return NULL;
  return _vorbis_window_get(b->window[W]-hs);
}

/*** End of inlined file: block.c ***/


/*** Start of inlined file: codebook.c ***/
#include <stdlib.h>
#include <string.h>
#include <math.h>

/* packs the given codebook into the bitstream **************************/

int vorbis_staticbook_pack(const static_codebook *c,oggpack_buffer *opb){
  long i,j;
  int ordered=0;

  /* first the basic parameters */
  oggpack_write(opb,0x564342,24);
  oggpack_write(opb,c->dim,16);
  oggpack_write(opb,c->entries,24);

  /* pack the codewords.  There are two packings; length ordered and
	 length random.  Decide between the two now. */

  for(i=1;i<c->entries;i++)
	if(c->lengthlist[i-1]==0 || c->lengthlist[i]<c->lengthlist[i-1])break;
  if(i==c->entries)ordered=1;

  if(ordered){
	/* length ordered.  We only need to say how many codewords of
	   each length.  The actual codewords are generated
	   deterministically */

	long count=0;
	oggpack_write(opb,1,1);  /* ordered */
	oggpack_write(opb,c->lengthlist[0]-1,5); /* 1 to 32 */

	for(i=1;i<c->entries;i++){
	  long thisx=c->lengthlist[i];
	  long last=c->lengthlist[i-1];
	  if(thisx>last){
	for(j=last;j<thisx;j++){
		  oggpack_write(opb,i-count,_ilog(c->entries-count));
		  count=i;
		}
	  }
	}
	oggpack_write(opb,i-count,_ilog(c->entries-count));

  }else{
	/* length random.  Again, we don't code the codeword itself, just
	   the length.  This time, though, we have to encode each length */
	oggpack_write(opb,0,1);   /* unordered */

	/* algortihmic mapping has use for 'unused entries', which we tag
	   here.  The algorithmic mapping happens as usual, but the unused
	   entry has no codeword. */
	for(i=0;i<c->entries;i++)
	  if(c->lengthlist[i]==0)break;

	if(i==c->entries){
	  oggpack_write(opb,0,1); /* no unused entries */
	  for(i=0;i<c->entries;i++)
		oggpack_write(opb,c->lengthlist[i]-1,5);
	}else{
	  oggpack_write(opb,1,1); /* we have unused entries; thus we tag */
	  for(i=0;i<c->entries;i++){
		if(c->lengthlist[i]==0){
		  oggpack_write(opb,0,1);
		}else{
		  oggpack_write(opb,1,1);
		  oggpack_write(opb,c->lengthlist[i]-1,5);
		}
	  }
	}
  }

  /* is the entry number the desired return value, or do we have a
	 mapping? If we have a mapping, what type? */
  oggpack_write(opb,c->maptype,4);
  switch(c->maptype){
  case 0:
	/* no mapping */
	break;
  case 1:case 2:
	/* implicitly populated value mapping */
	/* explicitly populated value mapping */

	if(!c->quantlist){
	  /* no quantlist?  error */
	  return(-1);
	}

	/* values that define the dequantization */
	oggpack_write(opb,c->q_min,32);
	oggpack_write(opb,c->q_delta,32);
	oggpack_write(opb,c->q_quant-1,4);
	oggpack_write(opb,c->q_sequencep,1);

	{
	  int quantvals;
	  switch(c->maptype){
	  case 1:
		/* a single column of (c->entries/c->dim) quantized values for
		   building a full value list algorithmically (square lattice) */
		quantvals=_book_maptype1_quantvals(c);
		break;
	  case 2:
		/* every value (c->entries*c->dim total) specified explicitly */
		quantvals=c->entries*c->dim;
		break;
	  default: /* NOT_REACHABLE */
		quantvals=-1;
	  }

	  /* quantized values */
	  for(i=0;i<quantvals;i++)
		oggpack_write(opb,labs(c->quantlist[i]),c->q_quant);

	}
	break;
  default:
	/* error case; we don't have any other map types now */
	return(-1);
  }

  return(0);
}

/* unpacks a codebook from the packet buffer into the codebook struct,
   readies the codebook auxiliary structures for decode *************/
static_codebook *vorbis_staticbook_unpack(oggpack_buffer *opb){
  long i,j;
  static_codebook *s=(static_codebook*)_ogg_calloc(1,sizeof(*s));
  s->allocedp=1;

  /* make sure alignment is correct */
  if(oggpack_read(opb,24)!=0x564342)goto _eofout;

  /* first the basic parameters */
  s->dim=oggpack_read(opb,16);
  s->entries=oggpack_read(opb,24);
  if(s->entries==-1)goto _eofout;

  if(_ilog(s->dim)+_ilog(s->entries)>24)goto _eofout;

  /* codeword ordering.... length ordered or unordered? */
  switch((int)oggpack_read(opb,1)){
  case 0:{
	long unused;
	/* allocated but unused entries? */
	unused=oggpack_read(opb,1);
	if((s->entries*(unused?1:5)+7)>>3>opb->storage-oggpack_bytes(opb))
	  goto _eofout;
	/* unordered */
	s->lengthlist=(long*)_ogg_malloc(sizeof(*s->lengthlist)*s->entries);

	/* allocated but unused entries? */
	if(unused){
	  /* yes, unused entries */

	  for(i=0;i<s->entries;i++){
		if(oggpack_read(opb,1)){
		  long num=oggpack_read(opb,5);
		  if(num==-1)goto _eofout;
		  s->lengthlist[i]=num+1;
		}else
		  s->lengthlist[i]=0;
	  }
	}else{
	  /* all entries used; no tagging */
	  for(i=0;i<s->entries;i++){
		long num=oggpack_read(opb,5);
		if(num==-1)goto _eofout;
		s->lengthlist[i]=num+1;
	  }
	}

	break;
  }
  case 1:
	/* ordered */
	{
	  long length=oggpack_read(opb,5)+1;
	  if(length==0)goto _eofout;
	  s->lengthlist=(long*)_ogg_malloc(sizeof(*s->lengthlist)*s->entries);

	  for(i=0;i<s->entries;){
		long num=oggpack_read(opb,_ilog(s->entries-i));
		if(num==-1)goto _eofout;
		if(length>32 || num>s->entries-i ||
		   (num>0 && (num-1)>>(length-1)>1)){
		  goto _errout;
		}
		if(length>32)goto _errout;
		for(j=0;j<num;j++,i++)
		  s->lengthlist[i]=length;
		length++;
	  }
	}
	break;
  default:
	/* EOF */
	goto _eofout;
  }

  /* Do we have a mapping to unpack? */
  switch((s->maptype=oggpack_read(opb,4))){
  case 0:
	/* no mapping */
	break;
  case 1: case 2:
	/* implicitly populated value mapping */
	/* explicitly populated value mapping */

	s->q_min=oggpack_read(opb,32);
	s->q_delta=oggpack_read(opb,32);
	s->q_quant=oggpack_read(opb,4)+1;
	s->q_sequencep=oggpack_read(opb,1);
	if(s->q_sequencep==-1)goto _eofout;

	{
	  int quantvals=0;
	  switch(s->maptype){
	  case 1:
		quantvals=(s->dim==0?0:_book_maptype1_quantvals(s));
		break;
	  case 2:
		quantvals=s->entries*s->dim;
		break;
	  }

	  /* quantized values */
	  if(((quantvals * s->q_quant + 7) >> 3) > opb->storage-oggpack_bytes(opb))
		goto _eofout;
	  s->quantlist=(long*)_ogg_malloc(sizeof(*s->quantlist)*quantvals);
	  for(i=0;i<quantvals;i++)
		s->quantlist[i]=oggpack_read(opb,s->q_quant);

	  if(quantvals&&s->quantlist[quantvals-1]==-1)goto _eofout;
	}
	break;
  default:
	goto _errout;
  }

  /* all set */
  return(s);

 _errout:
 _eofout:
  vorbis_staticbook_destroy(s);
  return(NULL);
}

/* returns the number of bits ************************************************/
int vorbis_book_encode(codebook *book, int a, oggpack_buffer *b){
  if(a<0 || a>=book->c->entries)return(0);
  oggpack_write(b,book->codelist[a],book->c->lengthlist[a]);
  return(book->c->lengthlist[a]);
}

/* the 'eliminate the decode tree' optimization actually requires the
   codewords to be MSb first, not LSb.  This is an annoying inelegancy
   (and one of the first places where carefully thought out design
   turned out to be wrong; Vorbis II and future Ogg codecs should go
   to an MSb bitpacker), but not actually the huge hit it appears to
   be.  The first-stage decode table catches most words so that
   bitreverse is not in the main execution path. */

static ogg_uint32_t bitreverse(ogg_uint32_t x){
  x=    ((x>>16)&0x0000ffff) | ((x<<16)&0xffff0000);
  x=    ((x>> 8)&0x00ff00ff) | ((x<< 8)&0xff00ff00);
  x=    ((x>> 4)&0x0f0f0f0f) | ((x<< 4)&0xf0f0f0f0);
  x=    ((x>> 2)&0x33333333) | ((x<< 2)&0xcccccccc);
  return((x>> 1)&0x55555555) | ((x<< 1)&0xaaaaaaaa);
}

STIN long decode_packed_entry_number(codebook *book, oggpack_buffer *b){
  int  read=book->dec_maxlength;
  long lo,hi;
  long lok = oggpack_look(b,book->dec_firsttablen);

  if (lok >= 0) {
	long entry = book->dec_firsttable[lok];
	if(entry&0x80000000UL){
	  lo=(entry>>15)&0x7fff;
	  hi=book->used_entries-(entry&0x7fff);
	}else{
	  oggpack_adv(b, book->dec_codelengths[entry-1]);
	  return(entry-1);
	}
  }else{
	lo=0;
	hi=book->used_entries;
  }

  lok = oggpack_look(b, read);

  while(lok<0 && read>1)
	lok = oggpack_look(b, --read);
  if(lok<0)return -1;

  /* bisect search for the codeword in the ordered list */
  {
	ogg_uint32_t testword=bitreverse((ogg_uint32_t)lok);

	while(hi-lo>1){
	  long p=(hi-lo)>>1;
	  long test=book->codelist[lo+p]>testword;
	  lo+=p&(test-1);
	  hi-=p&(-test);
	  }

	if(book->dec_codelengths[lo]<=read){
	  oggpack_adv(b, book->dec_codelengths[lo]);
	  return(lo);
	}
  }

  oggpack_adv(b, read);

  return(-1);
}

/* Decode side is specced and easier, because we don't need to find
   matches using different criteria; we simply read and map.  There are
   two things we need to do 'depending':

   We may need to support interleave.  We don't really, but it's
   convenient to do it here rather than rebuild the vector later.

   Cascades may be additive or multiplicitive; this is not inherent in
   the codebook, but set in the code using the codebook.  Like
   interleaving, it's easiest to do it here.
   addmul==0 -> declarative (set the value)
   addmul==1 -> additive
   addmul==2 -> multiplicitive */

/* returns the [original, not compacted] entry number or -1 on eof *********/
long vorbis_book_decode(codebook *book, oggpack_buffer *b){
  if(book->used_entries>0){
	long packed_entry=decode_packed_entry_number(book,b);
	if(packed_entry>=0)
	  return(book->dec_index[packed_entry]);
  }

  /* if there's no dec_index, the codebook unpacking isn't collapsed */
  return(-1);
}

/* returns 0 on OK or -1 on eof *************************************/
long vorbis_book_decodevs_add(codebook *book,float *a,oggpack_buffer *b,int n){
  if(book->used_entries>0){
	int step=n/book->dim;
	long *entry = (long*)alloca(sizeof(*entry)*step);
	float **t = (float**)alloca(sizeof(*t)*step);
	int i,j,o;

	for (i = 0; i < step; i++) {
	  entry[i]=decode_packed_entry_number(book,b);
	  if(entry[i]==-1)return(-1);
	  t[i] = book->valuelist+entry[i]*book->dim;
	}
	for(i=0,o=0;i<book->dim;i++,o+=step)
	  for (j=0;j<step;j++)
		a[o+j]+=t[j][i];
  }
  return(0);
}

long vorbis_book_decodev_add(codebook *book,float *a,oggpack_buffer *b,int n){
  if(book->used_entries>0){
	int i,j,entry;
	float *t;

	if(book->dim>8){
	  for(i=0;i<n;){
		entry = decode_packed_entry_number(book,b);
		if(entry==-1)return(-1);
		t     = book->valuelist+entry*book->dim;
		for (j=0;j<book->dim;)
		  a[i++]+=t[j++];
	  }
	}else{
	  for(i=0;i<n;){
		entry = decode_packed_entry_number(book,b);
		if(entry==-1)return(-1);
		t     = book->valuelist+entry*book->dim;
		j=0;
		switch((int)book->dim){
		case 8:
		  a[i++]+=t[j++];
		case 7:
		  a[i++]+=t[j++];
		case 6:
		  a[i++]+=t[j++];
		case 5:
		  a[i++]+=t[j++];
		case 4:
		  a[i++]+=t[j++];
		case 3:
		  a[i++]+=t[j++];
		case 2:
		  a[i++]+=t[j++];
		case 1:
		  a[i++]+=t[j++];
		case 0:
		  break;
		}
	  }
	}
  }
  return(0);
}

long vorbis_book_decodev_set(codebook *book,float *a,oggpack_buffer *b,int n){
  if(book->used_entries>0){
	int i,j,entry;
	float *t;

	for(i=0;i<n;){
	  entry = decode_packed_entry_number(book,b);
	  if(entry==-1)return(-1);
	  t     = book->valuelist+entry*book->dim;
	  for (j=0;j<book->dim;)
		a[i++]=t[j++];
	}
  }else{
	int i,j;

	for(i=0;i<n;){
	  for (j=0;j<book->dim;)
		a[i++]=0.f;
	}
  }
  return(0);
}

long vorbis_book_decodevv_add(codebook *book,float **a,long offset,int ch,
							  oggpack_buffer *b,int n){

  long i,j,entry;
  int chptr=0;
  if(book->used_entries>0){
	for(i=offset/ch;i<(offset+n)/ch;){
	  entry = decode_packed_entry_number(book,b);
	  if(entry==-1)return(-1);
	  {
		const float *t = book->valuelist+entry*book->dim;
		for (j=0;j<book->dim;j++){
		  a[chptr++][i]+=t[j];
		  if(chptr==ch){
			chptr=0;
			i++;
		  }
		}
	  }
	}
  }
  return(0);
}

/*** End of inlined file: codebook.c ***/


/*** Start of inlined file: envelope.c ***/
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <math.h>

void _ve_envelope_init(envelope_lookup *e,vorbis_info *vi){
  codec_setup_info *ci=(codec_setup_info*)vi->codec_setup;
  vorbis_info_psy_global *gi=&ci->psy_g_param;
  int ch=vi->channels;
  int i,j;
  int n=e->winlength=128;
  e->searchstep=64; /* not random */

  e->minenergy=gi->preecho_minenergy;
  e->ch=ch;
  e->storage=128;
  e->cursor=ci->blocksizes[1]/2;
  e->mdct_win=(float*)_ogg_calloc(n,sizeof(*e->mdct_win));
  mdct_init(&e->mdct,n);

  for(i=0;i<n;i++){
	e->mdct_win[i]=sin(i/(n-1.)*M_PI);
	e->mdct_win[i]*=e->mdct_win[i];
  }

  /* magic follows */
  e->band[0].begin=2;  e->band[0].end=4;
  e->band[1].begin=4;  e->band[1].end=5;
  e->band[2].begin=6;  e->band[2].end=6;
  e->band[3].begin=9;  e->band[3].end=8;
  e->band[4].begin=13;  e->band[4].end=8;
  e->band[5].begin=17;  e->band[5].end=8;
  e->band[6].begin=22;  e->band[6].end=8;

  for(j=0;j<VE_BANDS;j++){
	n=e->band[j].end;
	e->band[j].window=(float*)_ogg_malloc(n*sizeof(*e->band[0].window));
	for(i=0;i<n;i++){
	  e->band[j].window[i]=sin((i+.5)/n*M_PI);
	  e->band[j].total+=e->band[j].window[i];
	}
	e->band[j].total=1./e->band[j].total;
  }

  e->filter=(envelope_filter_state*)_ogg_calloc(VE_BANDS*ch,sizeof(*e->filter));
  e->mark=(int*)_ogg_calloc(e->storage,sizeof(*e->mark));

}

void _ve_envelope_clear(envelope_lookup *e){
  int i;
  mdct_clear(&e->mdct);
  for(i=0;i<VE_BANDS;i++)
	_ogg_free(e->band[i].window);
  _ogg_free(e->mdct_win);
  _ogg_free(e->filter);
  _ogg_free(e->mark);
  memset(e,0,sizeof(*e));
}

/* fairly straight threshhold-by-band based until we find something
   that works better and isn't patented. */

static int _ve_amp(envelope_lookup *ve,
				   vorbis_info_psy_global *gi,
				   float *data,
				   envelope_band *bands,
				   envelope_filter_state *filters){
  long n=ve->winlength;
  int ret=0;
  long i,j;
  float decay;

  /* we want to have a 'minimum bar' for energy, else we're just
	 basing blocks on quantization noise that outweighs the signal
	 itself (for low power signals) */

  float minV=ve->minenergy;
  float *vec=(float*) alloca(n*sizeof(*vec));

  /* stretch is used to gradually lengthen the number of windows
	 considered prevoius-to-potential-trigger */
  int stretch=max(VE_MINSTRETCH,ve->stretch/2);
  float penalty=gi->stretch_penalty-(ve->stretch/2-VE_MINSTRETCH);
  if(penalty<0.f)penalty=0.f;
  if(penalty>gi->stretch_penalty)penalty=gi->stretch_penalty;

  /*_analysis_output_always("lpcm",seq2,data,n,0,0,
	totalshift+pos*ve->searchstep);*/

 /* window and transform */
  for(i=0;i<n;i++)
	vec[i]=data[i]*ve->mdct_win[i];
  mdct_forward(&ve->mdct,vec,vec);

  /*_analysis_output_always("mdct",seq2,vec,n/2,0,1,0); */

  /* near-DC spreading function; this has nothing to do with
	 psychoacoustics, just sidelobe leakage and window size */
  {
	float temp=vec[0]*vec[0]+.7*vec[1]*vec[1]+.2*vec[2]*vec[2];
	int ptr=filters->nearptr;

	/* the accumulation is regularly refreshed from scratch to avoid
	   floating point creep */
	if(ptr==0){
	  decay=filters->nearDC_acc=filters->nearDC_partialacc+temp;
	  filters->nearDC_partialacc=temp;
	}else{
	  decay=filters->nearDC_acc+=temp;
	  filters->nearDC_partialacc+=temp;
	}
	filters->nearDC_acc-=filters->nearDC[ptr];
	filters->nearDC[ptr]=temp;

	decay*=(1./(VE_NEARDC+1));
	filters->nearptr++;
	if(filters->nearptr>=VE_NEARDC)filters->nearptr=0;
	decay=todB(&decay)*.5-15.f;
  }

  /* perform spreading and limiting, also smooth the spectrum.  yes,
	 the MDCT results in all real coefficients, but it still *behaves*
	 like real/imaginary pairs */
  for(i=0;i<n/2;i+=2){
	float val=vec[i]*vec[i]+vec[i+1]*vec[i+1];
	val=todB(&val)*.5f;
	if(val<decay)val=decay;
	if(val<minV)val=minV;
	vec[i>>1]=val;
	decay-=8.;
  }

  /*_analysis_output_always("spread",seq2++,vec,n/4,0,0,0);*/

  /* perform preecho/postecho triggering by band */
  for(j=0;j<VE_BANDS;j++){
	float acc=0.;
	float valmax,valmin;

	/* accumulate amplitude */
	for(i=0;i<bands[j].end;i++)
	  acc+=vec[i+bands[j].begin]*bands[j].window[i];

	acc*=bands[j].total;

	/* convert amplitude to delta */
	{
	  int p,thisx=filters[j].ampptr;
	  float postmax,postmin,premax=-99999.f,premin=99999.f;

	  p=thisx;
	  p--;
	  if(p<0)p+=VE_AMP;
	  postmax=max(acc,filters[j].ampbuf[p]);
	  postmin=min(acc,filters[j].ampbuf[p]);

	  for(i=0;i<stretch;i++){
		p--;
		if(p<0)p+=VE_AMP;
		premax=max(premax,filters[j].ampbuf[p]);
		premin=min(premin,filters[j].ampbuf[p]);
	  }

	  valmin=postmin-premin;
	  valmax=postmax-premax;

	  /*filters[j].markers[pos]=valmax;*/
	  filters[j].ampbuf[thisx]=acc;
	  filters[j].ampptr++;
	  if(filters[j].ampptr>=VE_AMP)filters[j].ampptr=0;
	}

	/* look at min/max, decide trigger */
	if(valmax>gi->preecho_thresh[j]+penalty){
	  ret|=1;
	  ret|=4;
	}
	if(valmin<gi->postecho_thresh[j]-penalty)ret|=2;
  }

  return(ret);
}

#if 0
static int seq=0;
static ogg_int64_t totalshift=-1024;
#endif

long _ve_envelope_search(vorbis_dsp_state *v){
  vorbis_info *vi=v->vi;
  codec_setup_info *ci=(codec_setup_info *)vi->codec_setup;
  vorbis_info_psy_global *gi=&ci->psy_g_param;
  envelope_lookup *ve=((private_state *)(v->backend_state))->ve;
  long i,j;

  int first=ve->current/ve->searchstep;
  int last=v->pcm_current/ve->searchstep-VE_WIN;
  if(first<0)first=0;

  /* make sure we have enough storage to match the PCM */
  if(last+VE_WIN+VE_POST>ve->storage){
	ve->storage=last+VE_WIN+VE_POST; /* be sure */
	ve->mark=(int*)_ogg_realloc(ve->mark,ve->storage*sizeof(*ve->mark));
  }

  for(j=first;j<last;j++){
	int ret=0;

	ve->stretch++;
	if(ve->stretch>VE_MAXSTRETCH*2)
	  ve->stretch=VE_MAXSTRETCH*2;

	for(i=0;i<ve->ch;i++){
	  float *pcm=v->pcm[i]+ve->searchstep*(j);
	  ret|=_ve_amp(ve,gi,pcm,ve->band,ve->filter+i*VE_BANDS);
	}

	ve->mark[j+VE_POST]=0;
	if(ret&1){
	  ve->mark[j]=1;
	  ve->mark[j+1]=1;
	}

	if(ret&2){
	  ve->mark[j]=1;
	  if(j>0)ve->mark[j-1]=1;
	}

	if(ret&4)ve->stretch=-1;
  }

  ve->current=last*ve->searchstep;

  {
	long centerW=v->centerW;
	long testW=
	  centerW+
	  ci->blocksizes[v->W]/4+
	  ci->blocksizes[1]/2+
	  ci->blocksizes[0]/4;

	j=ve->cursor;

	while(j<ve->current-(ve->searchstep)){/* account for postecho
											 working back one window */
	  if(j>=testW)return(1);

	  ve->cursor=j;

	  if(ve->mark[j/ve->searchstep]){
		if(j>centerW){

#if 0
		  if(j>ve->curmark){
			float *marker=(float*)alloca(v->pcm_current*sizeof(*marker));
			int l,m;
			memset(marker,0,sizeof(*marker)*v->pcm_current);
			fprintf(stderr,"mark! seq=%d, cursor:%fs time:%fs\n",
					seq,
					(totalshift+ve->cursor)/44100.,
					(totalshift+j)/44100.);
			_analysis_output_always("pcmL",seq,v->pcm[0],v->pcm_current,0,0,totalshift);
			_analysis_output_always("pcmR",seq,v->pcm[1],v->pcm_current,0,0,totalshift);

			_analysis_output_always("markL",seq,v->pcm[0],j,0,0,totalshift);
			_analysis_output_always("markR",seq,v->pcm[1],j,0,0,totalshift);

			for(m=0;m<VE_BANDS;m++){
			  char buf[80];
			  sprintf(buf,"delL%d",m);
			  for(l=0;l<last;l++)marker[l*ve->searchstep]=ve->filter[m].markers[l]*.1;
			  _analysis_output_always(buf,seq,marker,v->pcm_current,0,0,totalshift);
			}

			for(m=0;m<VE_BANDS;m++){
			  char buf[80];
			  sprintf(buf,"delR%d",m);
			  for(l=0;l<last;l++)marker[l*ve->searchstep]=ve->filter[m+VE_BANDS].markers[l]*.1;
			  _analysis_output_always(buf,seq,marker,v->pcm_current,0,0,totalshift);
			}

			for(l=0;l<last;l++)marker[l*ve->searchstep]=ve->mark[l]*.4;
			_analysis_output_always("mark",seq,marker,v->pcm_current,0,0,totalshift);

			seq++;

		  }
#endif

		  ve->curmark=j;
		  if(j>=testW)return(1);
		  return(0);
		}
	  }
	  j+=ve->searchstep;
	}
  }

  return(-1);
}

int _ve_envelope_mark(vorbis_dsp_state *v){
  envelope_lookup *ve=((private_state *)(v->backend_state))->ve;
  vorbis_info *vi=v->vi;
  codec_setup_info *ci=(codec_setup_info*)vi->codec_setup;
  long centerW=v->centerW;
  long beginW=centerW-ci->blocksizes[v->W]/4;
  long endW=centerW+ci->blocksizes[v->W]/4;
  if(v->W){
	beginW-=ci->blocksizes[v->lW]/4;
	endW+=ci->blocksizes[v->nW]/4;
  }else{
	beginW-=ci->blocksizes[0]/4;
	endW+=ci->blocksizes[0]/4;
  }

  if(ve->curmark>=beginW && ve->curmark<endW)return(1);
  {
	long first=beginW/ve->searchstep;
	long last=endW/ve->searchstep;
	long i;
	for(i=first;i<last;i++)
	  if(ve->mark[i])return(1);
  }
  return(0);
}

void _ve_envelope_shift(envelope_lookup *e,long shift){
  int smallsize=e->current/e->searchstep+VE_POST; /* adjust for placing marks
													 ahead of ve->current */
  int smallshift=shift/e->searchstep;

  memmove(e->mark,e->mark+smallshift,(smallsize-smallshift)*sizeof(*e->mark));

#if 0
  for(i=0;i<VE_BANDS*e->ch;i++)
	memmove(e->filter[i].markers,
			e->filter[i].markers+smallshift,
			(1024-smallshift)*sizeof(*(*e->filter).markers));
  totalshift+=shift;
#endif

  e->current-=shift;
  if(e->curmark>=0)
	e->curmark-=shift;
  e->cursor-=shift;
}

/*** End of inlined file: envelope.c ***/


/*** Start of inlined file: floor0.c ***/
#include <stdlib.h>
#include <string.h>
#include <math.h>


/*** Start of inlined file: lsp.h ***/
#ifndef _V_LSP_H_
#define _V_LSP_H_

extern int vorbis_lpc_to_lsp(float *lpc,float *lsp,int m);

extern void vorbis_lsp_to_curve(float *curve,int *map,int n,int ln,
								float *lsp,int m,
								float amp,float ampoffset);

#endif

/*** End of inlined file: lsp.h ***/

#include <stdio.h>

typedef struct {
  int ln;
  int  m;
  int **linearmap;
  int  n[2];

  vorbis_info_floor0 *vi;

  long bits;
  long frames;
} vorbis_look_floor0;

/***********************************************/

static void floor0_free_info(vorbis_info_floor *i){
  vorbis_info_floor0 *info=(vorbis_info_floor0 *)i;
  if(info){
	memset(info,0,sizeof(*info));
	_ogg_free(info);
  }
}

static void floor0_free_look(vorbis_look_floor *i){
  vorbis_look_floor0 *look=(vorbis_look_floor0 *)i;
  if(look){

	if(look->linearmap){

	  if(look->linearmap[0])_ogg_free(look->linearmap[0]);
	  if(look->linearmap[1])_ogg_free(look->linearmap[1]);

	  _ogg_free(look->linearmap);
	}
	memset(look,0,sizeof(*look));
	_ogg_free(look);
  }
}

static vorbis_info_floor *floor0_unpack (vorbis_info *vi,oggpack_buffer *opb){
  codec_setup_info     *ci=(codec_setup_info*)vi->codec_setup;
  int j;

  vorbis_info_floor0 *info=(vorbis_info_floor0*)_ogg_malloc(sizeof(*info));
  info->order=oggpack_read(opb,8);
  info->rate=oggpack_read(opb,16);
  info->barkmap=oggpack_read(opb,16);
  info->ampbits=oggpack_read(opb,6);
  info->ampdB=oggpack_read(opb,8);
  info->numbooks=oggpack_read(opb,4)+1;

  if(info->order<1)goto err_out;
  if(info->rate<1)goto err_out;
  if(info->barkmap<1)goto err_out;
  if(info->numbooks<1)goto err_out;

  for(j=0;j<info->numbooks;j++){
	info->books[j]=oggpack_read(opb,8);
	if(info->books[j]<0 || info->books[j]>=ci->books)goto err_out;
	if(ci->book_param[info->books[j]]->maptype==0)goto err_out;
	if(ci->book_param[info->books[j]]->dim<1)goto err_out;
  }
  return(info);

 err_out:
  floor0_free_info(info);
  return(NULL);
}

/* initialize Bark scale and normalization lookups.  We could do this
   with static tables, but Vorbis allows a number of possible
   combinations, so it's best to do it computationally.

   The below is authoritative in terms of defining scale mapping.
   Note that the scale depends on the sampling rate as well as the
   linear block and mapping sizes */

static void floor0_map_lazy_init(vorbis_block      *vb,
								 vorbis_info_floor *infoX,
								 vorbis_look_floor0 *look){
  if(!look->linearmap[vb->W]){
	vorbis_dsp_state   *vd=vb->vd;
	vorbis_info        *vi=vd->vi;
	codec_setup_info   *ci=(codec_setup_info*)vi->codec_setup;
	vorbis_info_floor0 *info=(vorbis_info_floor0 *)infoX;
	int W=vb->W;
	int n=ci->blocksizes[W]/2,j;

	/* we choose a scaling constant so that:
	   floor(bark(rate/2-1)*C)=mapped-1
	 floor(bark(rate/2)*C)=mapped */
	float scale=look->ln/toBARK(info->rate/2.f);

	/* the mapping from a linear scale to a smaller bark scale is
	   straightforward.  We do *not* make sure that the linear mapping
	   does not skip bark-scale bins; the decoder simply skips them and
	   the encoder may do what it wishes in filling them.  They're
	   necessary in some mapping combinations to keep the scale spacing
	   accurate */
	look->linearmap[W]=(int*)_ogg_malloc((n+1)*sizeof(**look->linearmap));
	for(j=0;j<n;j++){
	  int val=floor( toBARK((info->rate/2.f)/n*j)
					 *scale); /* bark numbers represent band edges */
	  if(val>=look->ln)val=look->ln-1; /* guard against the approximation */
	  look->linearmap[W][j]=val;
	}
	look->linearmap[W][j]=-1;
	look->n[W]=n;
  }
}

static vorbis_look_floor *floor0_look(vorbis_dsp_state *vd,
									  vorbis_info_floor *i){
  vorbis_info_floor0 *info=(vorbis_info_floor0 *)i;
  vorbis_look_floor0 *look=(vorbis_look_floor0*)_ogg_calloc(1,sizeof(*look));
  look->m=info->order;
  look->ln=info->barkmap;
  look->vi=info;

  look->linearmap=(int**)_ogg_calloc(2,sizeof(*look->linearmap));

  return look;
}

static void *floor0_inverse1(vorbis_block *vb,vorbis_look_floor *i){
  vorbis_look_floor0 *look=(vorbis_look_floor0 *)i;
  vorbis_info_floor0 *info=look->vi;
  int j,k;

  int ampraw=oggpack_read(&vb->opb,info->ampbits);
  if(ampraw>0){ /* also handles the -1 out of data case */
	long maxval=(1<<info->ampbits)-1;
	float amp=(float)ampraw/maxval*info->ampdB;
	int booknum=oggpack_read(&vb->opb,_ilog(info->numbooks));

	if(booknum!=-1 && booknum<info->numbooks){ /* be paranoid */
	  codec_setup_info  *ci=(codec_setup_info *)vb->vd->vi->codec_setup;
	  codebook *b=ci->fullbooks+info->books[booknum];
	  float last=0.f;

	  /* the additional b->dim is a guard against any possible stack
		 smash; b->dim is provably more than we can overflow the
		 vector */
	  float *lsp=(float*)_vorbis_block_alloc(vb,sizeof(*lsp)*(look->m+b->dim+1));

	  for(j=0;j<look->m;j+=b->dim)
		if(vorbis_book_decodev_set(b,lsp+j,&vb->opb,b->dim)==-1)goto eop;
	  for(j=0;j<look->m;){
		for(k=0;k<b->dim;k++,j++)lsp[j]+=last;
		last=lsp[j-1];
	  }

	  lsp[look->m]=amp;
	  return(lsp);
	}
  }
 eop:
  return(NULL);
}

static int floor0_inverse2(vorbis_block *vb,vorbis_look_floor *i,
						   void *memo,float *out){
  vorbis_look_floor0 *look=(vorbis_look_floor0 *)i;
  vorbis_info_floor0 *info=look->vi;

  floor0_map_lazy_init(vb,info,look);

  if(memo){
	float *lsp=(float *)memo;
	float amp=lsp[look->m];

	/* take the coefficients back to a spectral envelope curve */
	vorbis_lsp_to_curve(out,
						look->linearmap[vb->W],
						look->n[vb->W],
						look->ln,
						lsp,look->m,amp,(float)info->ampdB);
	return(1);
  }
  memset(out,0,sizeof(*out)*look->n[vb->W]);
  return(0);
}

/* export hooks */
const vorbis_func_floor floor0_exportbundle={
  NULL,&floor0_unpack,&floor0_look,&floor0_free_info,
  &floor0_free_look,&floor0_inverse1,&floor0_inverse2
};

/*** End of inlined file: floor0.c ***/


/*** Start of inlined file: floor1.c ***/
#include <stdlib.h>
#include <string.h>
#include <math.h>

#include <stdio.h>

#define floor1_rangedB 140 /* floor 1 fixed at -140dB to 0dB range */

typedef struct lsfit_acc{
  int x0;
  int x1;

  int xa;
  int ya;
  int x2a;
  int y2a;
  int xya;
  int an;

  int xb;
  int yb;
  int x2b;
  int y2b;
  int xyb;
  int bn;
} lsfit_acc;

/***********************************************/

static void floor1_free_info(vorbis_info_floor *i){
  vorbis_info_floor1 *info=(vorbis_info_floor1 *)i;
  if(info){
	memset(info,0,sizeof(*info));
	_ogg_free(info);
  }
}

static void floor1_free_look(vorbis_look_floor *i){
  vorbis_look_floor1 *look=(vorbis_look_floor1 *)i;
  if(look){
	/*fprintf(stderr,"floor 1 bit usage %f:%f (%f total)\n",
			(float)look->phrasebits/look->frames,
			(float)look->postbits/look->frames,
			(float)(look->postbits+look->phrasebits)/look->frames);*/

	memset(look,0,sizeof(*look));
	_ogg_free(look);
  }
}

static void floor1_pack (vorbis_info_floor *i,oggpack_buffer *opb){
  vorbis_info_floor1 *info=(vorbis_info_floor1 *)i;
  int j,k;
  int count=0;
  int rangebits;
  int maxposit=info->postlist[1];
  int maxclass=-1;

  /* save out partitions */
  oggpack_write(opb,info->partitions,5); /* only 0 to 31 legal */
  for(j=0;j<info->partitions;j++){
	oggpack_write(opb,info->partitionclass[j],4); /* only 0 to 15 legal */
	if(maxclass<info->partitionclass[j])maxclass=info->partitionclass[j];
  }

  /* save out partition classes */
  for(j=0;j<maxclass+1;j++){
	oggpack_write(opb,info->class_dim[j]-1,3); /* 1 to 8 */
	oggpack_write(opb,info->class_subs[j],2); /* 0 to 3 */
	if(info->class_subs[j])oggpack_write(opb,info->class_book[j],8);
	for(k=0;k<(1<<info->class_subs[j]);k++)
	  oggpack_write(opb,info->class_subbook[j][k]+1,8);
  }

  /* save out the post list */
  oggpack_write(opb,info->mult-1,2);     /* only 1,2,3,4 legal now */
  oggpack_write(opb,ilog2(maxposit),4);
  rangebits=ilog2(maxposit);

  for(j=0,k=0;j<info->partitions;j++){
	count+=info->class_dim[info->partitionclass[j]];
	for(;k<count;k++)
	  oggpack_write(opb,info->postlist[k+2],rangebits);
  }
}

static int icomp(const void *a,const void *b){
  return(**(int **)a-**(int **)b);
}

static vorbis_info_floor *floor1_unpack (vorbis_info *vi,oggpack_buffer *opb){
  codec_setup_info     *ci=(codec_setup_info*)vi->codec_setup;
  int j,k,count=0,maxclass=-1,rangebits;

  vorbis_info_floor1 *info=(vorbis_info_floor1*)_ogg_calloc(1,sizeof(*info));
  /* read partitions */
  info->partitions=oggpack_read(opb,5); /* only 0 to 31 legal */
  for(j=0;j<info->partitions;j++){
	info->partitionclass[j]=oggpack_read(opb,4); /* only 0 to 15 legal */
	if(info->partitionclass[j]<0)goto err_out;
	if(maxclass<info->partitionclass[j])maxclass=info->partitionclass[j];
  }

  /* read partition classes */
  for(j=0;j<maxclass+1;j++){
	info->class_dim[j]=oggpack_read(opb,3)+1; /* 1 to 8 */
	info->class_subs[j]=oggpack_read(opb,2); /* 0,1,2,3 bits */
	if(info->class_subs[j]<0)
	  goto err_out;
	if(info->class_subs[j])info->class_book[j]=oggpack_read(opb,8);
	if(info->class_book[j]<0 || info->class_book[j]>=ci->books)
	  goto err_out;
	for(k=0;k<(1<<info->class_subs[j]);k++){
	  info->class_subbook[j][k]=oggpack_read(opb,8)-1;
	  if(info->class_subbook[j][k]<-1 || info->class_subbook[j][k]>=ci->books)
		goto err_out;
	}
  }

  /* read the post list */
  info->mult=oggpack_read(opb,2)+1;     /* only 1,2,3,4 legal now */
  rangebits=oggpack_read(opb,4);
  if(rangebits<0)goto err_out;

  for(j=0,k=0;j<info->partitions;j++){
	count+=info->class_dim[info->partitionclass[j]];
	for(;k<count;k++){
	  int t=info->postlist[k+2]=oggpack_read(opb,rangebits);
	  if(t<0 || t>=(1<<rangebits))
		goto err_out;
	}
  }
  info->postlist[0]=0;
  info->postlist[1]=1<<rangebits;

  /* don't allow repeated values in post list as they'd result in
	 zero-length segments */
  {
	int *sortpointer[VIF_POSIT+2];
	for(j=0;j<count+2;j++)sortpointer[j]=info->postlist+j;
	qsort(sortpointer,count+2,sizeof(*sortpointer),icomp);

	for(j=1;j<count+2;j++)
	  if(*sortpointer[j-1]==*sortpointer[j])goto err_out;
  }

  return(info);

 err_out:
  floor1_free_info(info);
  return(NULL);
}

static vorbis_look_floor *floor1_look(vorbis_dsp_state *vd,
									  vorbis_info_floor *in){

  int *sortpointer[VIF_POSIT+2];
  vorbis_info_floor1 *info=(vorbis_info_floor1 *)in;
  vorbis_look_floor1 *look=(vorbis_look_floor1*)_ogg_calloc(1,sizeof(*look));
  int i,j,n=0;

  look->vi=info;
  look->n=info->postlist[1];

  /* we drop each position value in-between already decoded values,
	 and use linear interpolation to predict each new value past the
	 edges.  The positions are read in the order of the position
	 list... we precompute the bounding positions in the lookup.  Of
	 course, the neighbors can change (if a position is declined), but
	 this is an initial mapping */

  for(i=0;i<info->partitions;i++)n+=info->class_dim[info->partitionclass[i]];
  n+=2;
  look->posts=n;

  /* also store a sorted position index */
  for(i=0;i<n;i++)sortpointer[i]=info->postlist+i;
  qsort(sortpointer,n,sizeof(*sortpointer),icomp);

  /* points from sort order back to range number */
  for(i=0;i<n;i++)look->forward_index[i]=sortpointer[i]-info->postlist;
  /* points from range order to sorted position */
  for(i=0;i<n;i++)look->reverse_index[look->forward_index[i]]=i;
  /* we actually need the post values too */
  for(i=0;i<n;i++)look->sorted_index[i]=info->postlist[look->forward_index[i]];

  /* quantize values to multiplier spec */
  switch(info->mult){
  case 1: /* 1024 -> 256 */
	look->quant_q=256;
	break;
  case 2: /* 1024 -> 128 */
	look->quant_q=128;
	break;
  case 3: /* 1024 -> 86 */
	look->quant_q=86;
	break;
  case 4: /* 1024 -> 64 */
	look->quant_q=64;
	break;
  }

  /* discover our neighbors for decode where we don't use fit flags
	 (that would push the neighbors outward) */
  for(i=0;i<n-2;i++){
	int lo=0;
	int hi=1;
	int lx=0;
	int hx=look->n;
	int currentx=info->postlist[i+2];
	for(j=0;j<i+2;j++){
	  int x=info->postlist[j];
	  if(x>lx && x<currentx){
		lo=j;
		lx=x;
	  }
	  if(x<hx && x>currentx){
		hi=j;
		hx=x;
	  }
	}
	look->loneighbor[i]=lo;
	look->hineighbor[i]=hi;
  }

  return(look);
}

static int render_point(int x0,int x1,int y0,int y1,int x){
  y0&=0x7fff; /* mask off flag */
  y1&=0x7fff;

  {
	int dy=y1-y0;
	int adx=x1-x0;
	int ady=abs(dy);
	int err=ady*(x-x0);

	int off=err/adx;
	if(dy<0)return(y0-off);
	return(y0+off);
  }
}

static int vorbis_dBquant(const float *x){
  int i= *x*7.3142857f+1023.5f;
  if(i>1023)return(1023);
  if(i<0)return(0);
  return i;
}

static const float FLOOR1_fromdB_LOOKUP[256]={
  1.0649863e-07F, 1.1341951e-07F, 1.2079015e-07F, 1.2863978e-07F,
  1.3699951e-07F, 1.4590251e-07F, 1.5538408e-07F, 1.6548181e-07F,
  1.7623575e-07F, 1.8768855e-07F, 1.9988561e-07F, 2.128753e-07F,
  2.2670913e-07F, 2.4144197e-07F, 2.5713223e-07F, 2.7384213e-07F,
  2.9163793e-07F, 3.1059021e-07F, 3.3077411e-07F, 3.5226968e-07F,
  3.7516214e-07F, 3.9954229e-07F, 4.2550680e-07F, 4.5315863e-07F,
  4.8260743e-07F, 5.1396998e-07F, 5.4737065e-07F, 5.8294187e-07F,
  6.2082472e-07F, 6.6116941e-07F, 7.0413592e-07F, 7.4989464e-07F,
  7.9862701e-07F, 8.5052630e-07F, 9.0579828e-07F, 9.6466216e-07F,
  1.0273513e-06F, 1.0941144e-06F, 1.1652161e-06F, 1.2409384e-06F,
  1.3215816e-06F, 1.4074654e-06F, 1.4989305e-06F, 1.5963394e-06F,
  1.7000785e-06F, 1.8105592e-06F, 1.9282195e-06F, 2.0535261e-06F,
  2.1869758e-06F, 2.3290978e-06F, 2.4804557e-06F, 2.6416497e-06F,
  2.8133190e-06F, 2.9961443e-06F, 3.1908506e-06F, 3.3982101e-06F,
  3.6190449e-06F, 3.8542308e-06F, 4.1047004e-06F, 4.3714470e-06F,
  4.6555282e-06F, 4.9580707e-06F, 5.2802740e-06F, 5.6234160e-06F,
  5.9888572e-06F, 6.3780469e-06F, 6.7925283e-06F, 7.2339451e-06F,
  7.7040476e-06F, 8.2047000e-06F, 8.7378876e-06F, 9.3057248e-06F,
  9.9104632e-06F, 1.0554501e-05F, 1.1240392e-05F, 1.1970856e-05F,
  1.2748789e-05F, 1.3577278e-05F, 1.4459606e-05F, 1.5399272e-05F,
  1.6400004e-05F, 1.7465768e-05F, 1.8600792e-05F, 1.9809576e-05F,
  2.1096914e-05F, 2.2467911e-05F, 2.3928002e-05F, 2.5482978e-05F,
  2.7139006e-05F, 2.8902651e-05F, 3.0780908e-05F, 3.2781225e-05F,
  3.4911534e-05F, 3.7180282e-05F, 3.9596466e-05F, 4.2169667e-05F,
  4.4910090e-05F, 4.7828601e-05F, 5.0936773e-05F, 5.4246931e-05F,
  5.7772202e-05F, 6.1526565e-05F, 6.5524908e-05F, 6.9783085e-05F,
  7.4317983e-05F, 7.9147585e-05F, 8.4291040e-05F, 8.9768747e-05F,
  9.5602426e-05F, 0.00010181521F, 0.00010843174F, 0.00011547824F,
  0.00012298267F, 0.00013097477F, 0.00013948625F, 0.00014855085F,
  0.00015820453F, 0.00016848555F, 0.00017943469F, 0.00019109536F,
  0.00020351382F, 0.00021673929F, 0.00023082423F, 0.00024582449F,
  0.00026179955F, 0.00027881276F, 0.00029693158F, 0.00031622787F,
  0.00033677814F, 0.00035866388F, 0.00038197188F, 0.00040679456F,
  0.00043323036F, 0.00046138411F, 0.00049136745F, 0.00052329927F,
  0.00055730621F, 0.00059352311F, 0.00063209358F, 0.00067317058F,
  0.00071691700F, 0.00076350630F, 0.00081312324F, 0.00086596457F,
  0.00092223983F, 0.00098217216F, 0.0010459992F, 0.0011139742F,
  0.0011863665F, 0.0012634633F, 0.0013455702F, 0.0014330129F,
  0.0015261382F, 0.0016253153F, 0.0017309374F, 0.0018434235F,
  0.0019632195F, 0.0020908006F, 0.0022266726F, 0.0023713743F,
  0.0025254795F, 0.0026895994F, 0.0028643847F, 0.0030505286F,
  0.0032487691F, 0.0034598925F, 0.0036847358F, 0.0039241906F,
  0.0041792066F, 0.0044507950F, 0.0047400328F, 0.0050480668F,
  0.0053761186F, 0.0057254891F, 0.0060975636F, 0.0064938176F,
  0.0069158225F, 0.0073652516F, 0.0078438871F, 0.0083536271F,
  0.0088964928F, 0.009474637F, 0.010090352F, 0.010746080F,
  0.011444421F, 0.012188144F, 0.012980198F, 0.013823725F,
  0.014722068F, 0.015678791F, 0.016697687F, 0.017782797F,
  0.018938423F, 0.020169149F, 0.021479854F, 0.022875735F,
  0.024362330F, 0.025945531F, 0.027631618F, 0.029427276F,
  0.031339626F, 0.033376252F, 0.035545228F, 0.037855157F,
  0.040315199F, 0.042935108F, 0.045725273F, 0.048696758F,
  0.051861348F, 0.055231591F, 0.058820850F, 0.062643361F,
  0.066714279F, 0.071049749F, 0.075666962F, 0.080584227F,
  0.085821044F, 0.091398179F, 0.097337747F, 0.10366330F,
  0.11039993F, 0.11757434F, 0.12521498F, 0.13335215F,
  0.14201813F, 0.15124727F, 0.16107617F, 0.17154380F,
  0.18269168F, 0.19456402F, 0.20720788F, 0.22067342F,
  0.23501402F, 0.25028656F, 0.26655159F, 0.28387361F,
  0.30232132F, 0.32196786F, 0.34289114F, 0.36517414F,
  0.38890521F, 0.41417847F, 0.44109412F, 0.46975890F,
  0.50028648F, 0.53279791F, 0.56742212F, 0.60429640F,
  0.64356699F, 0.68538959F, 0.72993007F, 0.77736504F,
  0.82788260F, 0.88168307F, 0.9389798F, 1.F,
};

static void render_line(int n, int x0,int x1,int y0,int y1,float *d){
  int dy=y1-y0;
  int adx=x1-x0;
  int ady=abs(dy);
  int base=dy/adx;
  int sy=(dy<0?base-1:base+1);
  int x=x0;
  int y=y0;
  int err=0;

  ady-=abs(base*adx);

  if(n>x1)n=x1;

  if(x<n)
	d[x]*=FLOOR1_fromdB_LOOKUP[y];

  while(++x<n){
	err=err+ady;
	if(err>=adx){
	  err-=adx;
	  y+=sy;
	}else{
	  y+=base;
	}
	d[x]*=FLOOR1_fromdB_LOOKUP[y];
  }
}

static void render_line0(int n, int x0,int x1,int y0,int y1,int *d){
  int dy=y1-y0;
  int adx=x1-x0;
  int ady=abs(dy);
  int base=dy/adx;
  int sy=(dy<0?base-1:base+1);
  int x=x0;
  int y=y0;
  int err=0;

  ady-=abs(base*adx);

  if(n>x1)n=x1;

  if(x<n)
	d[x]=y;

  while(++x<n){
	err=err+ady;
	if(err>=adx){
	  err-=adx;
	  y+=sy;
	}else{
	  y+=base;
	}
	d[x]=y;
  }
}

/* the floor has already been filtered to only include relevant sections */
static int accumulate_fit(const float *flr,const float *mdct,
						  int x0, int x1,lsfit_acc *a,
						  int n,vorbis_info_floor1 *info){
  long i;

  int xa=0,ya=0,x2a=0,y2a=0,xya=0,na=0, xb=0,yb=0,x2b=0,y2b=0,xyb=0,nb=0;

  memset(a,0,sizeof(*a));
  a->x0=x0;
  a->x1=x1;
  if(x1>=n)x1=n-1;

  for(i=x0;i<=x1;i++){
	int quantized=vorbis_dBquant(flr+i);
	if(quantized){
	  if(mdct[i]+info->twofitatten>=flr[i]){
		xa  += i;
		ya  += quantized;
		x2a += i*i;
		y2a += quantized*quantized;
		xya += i*quantized;
		na++;
	  }else{
		xb  += i;
		yb  += quantized;
		x2b += i*i;
		y2b += quantized*quantized;
		xyb += i*quantized;
		nb++;
	  }
	}
  }

  a->xa=xa;
  a->ya=ya;
  a->x2a=x2a;
  a->y2a=y2a;
  a->xya=xya;
  a->an=na;

  a->xb=xb;
  a->yb=yb;
  a->x2b=x2b;
  a->y2b=y2b;
  a->xyb=xyb;
  a->bn=nb;

  return(na);
}

static int fit_line(lsfit_acc *a,int fits,int *y0,int *y1,
					vorbis_info_floor1 *info){
  double xb=0,yb=0,x2b=0,y2b=0,xyb=0,bn=0;
  int i;
  int x0=a[0].x0;
  int x1=a[fits-1].x1;

  for(i=0;i<fits;i++){
	double weight = (a[i].bn+a[i].an)*info->twofitweight/(a[i].an+1)+1.;

	xb+=a[i].xb + a[i].xa * weight;
	yb+=a[i].yb + a[i].ya * weight;
	x2b+=a[i].x2b + a[i].x2a * weight;
	y2b+=a[i].y2b + a[i].y2a * weight;
	xyb+=a[i].xyb + a[i].xya * weight;
	bn+=a[i].bn + a[i].an * weight;
  }

  if(*y0>=0){
	xb+=   x0;
	yb+=  *y0;
	x2b+=  x0 *  x0;
	y2b+= *y0 * *y0;
	xyb+= *y0 *  x0;
	bn++;
  }

  if(*y1>=0){
	xb+=   x1;
	yb+=  *y1;
	x2b+=  x1 *  x1;
	y2b+= *y1 * *y1;
	xyb+= *y1 *  x1;
	bn++;
  }

  {
	double denom=(bn*x2b-xb*xb);

	if(denom>0.){
	  double a=(yb*x2b-xyb*xb)/denom;
	  double b=(bn*xyb-xb*yb)/denom;
	  *y0=rint(a+b*x0);
	  *y1=rint(a+b*x1);

	  /* limit to our range! */
	  if(*y0>1023)*y0=1023;
	  if(*y1>1023)*y1=1023;
	  if(*y0<0)*y0=0;
	  if(*y1<0)*y1=0;

	  return 0;
	}else{
	  *y0=0;
	  *y1=0;
	  return 1;
	}
  }
}

static int inspect_error(int x0,int x1,int y0,int y1,const float *mask,
						 const float *mdct,
						 vorbis_info_floor1 *info){
  int dy=y1-y0;
  int adx=x1-x0;
  int ady=abs(dy);
  int base=dy/adx;
  int sy=(dy<0?base-1:base+1);
  int x=x0;
  int y=y0;
  int err=0;
  int val=vorbis_dBquant(mask+x);
  int mse=0;
  int n=0;

  ady-=abs(base*adx);

  mse=(y-val);
  mse*=mse;
  n++;
  if(mdct[x]+info->twofitatten>=mask[x]){
	if(y+info->maxover<val)return(1);
	if(y-info->maxunder>val)return(1);
  }

  while(++x<x1){
	err=err+ady;
	if(err>=adx){
	  err-=adx;
	  y+=sy;
	}else{
	  y+=base;
	}

	val=vorbis_dBquant(mask+x);
	mse+=((y-val)*(y-val));
	n++;
	if(mdct[x]+info->twofitatten>=mask[x]){
	  if(val){
		if(y+info->maxover<val)return(1);
		if(y-info->maxunder>val)return(1);
	  }
	}
  }

  if(info->maxover*info->maxover/n>info->maxerr)return(0);
  if(info->maxunder*info->maxunder/n>info->maxerr)return(0);
  if(mse/n>info->maxerr)return(1);
  return(0);
}

static int post_Y(int *A,int *B,int pos){
  if(A[pos]<0)
	return B[pos];
  if(B[pos]<0)
	return A[pos];

  return (A[pos]+B[pos])>>1;
}

int *floor1_fit(vorbis_block *vb,vorbis_look_floor1 *look,
						  const float *logmdct,   /* in */
						  const float *logmask){
  long i,j;
  vorbis_info_floor1 *info=look->vi;
  long n=look->n;
  long posts=look->posts;
  long nonzero=0;
  lsfit_acc fits[VIF_POSIT+1];
  int fit_valueA[VIF_POSIT+2]; /* index by range list position */
  int fit_valueB[VIF_POSIT+2]; /* index by range list position */

  int loneighbor[VIF_POSIT+2]; /* sorted index of range list position (+2) */
  int hineighbor[VIF_POSIT+2];
  int *output=NULL;
  int memo[VIF_POSIT+2];

  for(i=0;i<posts;i++)fit_valueA[i]=-200; /* mark all unused */
  for(i=0;i<posts;i++)fit_valueB[i]=-200; /* mark all unused */
  for(i=0;i<posts;i++)loneighbor[i]=0; /* 0 for the implicit 0 post */
  for(i=0;i<posts;i++)hineighbor[i]=1; /* 1 for the implicit post at n */
  for(i=0;i<posts;i++)memo[i]=-1;      /* no neighbor yet */

  /* quantize the relevant floor points and collect them into line fit
	 structures (one per minimal division) at the same time */
  if(posts==0){
	nonzero+=accumulate_fit(logmask,logmdct,0,n,fits,n,info);
  }else{
	for(i=0;i<posts-1;i++)
	  nonzero+=accumulate_fit(logmask,logmdct,look->sorted_index[i],
							  look->sorted_index[i+1],fits+i,
							  n,info);
  }

  if(nonzero){
	/* start by fitting the implicit base case.... */
	int y0=-200;
	int y1=-200;
	fit_line(fits,posts-1,&y0,&y1,info);

	fit_valueA[0]=y0;
	fit_valueB[0]=y0;
	fit_valueB[1]=y1;
	fit_valueA[1]=y1;

	/* Non degenerate case */
	/* start progressive splitting.  This is a greedy, non-optimal
	   algorithm, but simple and close enough to the best
	   answer. */
	for(i=2;i<posts;i++){
	  int sortpos=look->reverse_index[i];
	  int ln=loneighbor[sortpos];
	  int hn=hineighbor[sortpos];

	  /* eliminate repeat searches of a particular range with a memo */
	  if(memo[ln]!=hn){
		/* haven't performed this error search yet */
		int lsortpos=look->reverse_index[ln];
		int hsortpos=look->reverse_index[hn];
		memo[ln]=hn;

		{
		  /* A note: we want to bound/minimize *local*, not global, error */
		  int lx=info->postlist[ln];
		  int hx=info->postlist[hn];
		  int ly=post_Y(fit_valueA,fit_valueB,ln);
		  int hy=post_Y(fit_valueA,fit_valueB,hn);

		  if(ly==-1 || hy==-1){
			exit(1);
		  }

		  if(inspect_error(lx,hx,ly,hy,logmask,logmdct,info)){
			/* outside error bounds/begin search area.  Split it. */
			int ly0=-200;
			int ly1=-200;
			int hy0=-200;
			int hy1=-200;
			int ret0=fit_line(fits+lsortpos,sortpos-lsortpos,&ly0,&ly1,info);
			int ret1=fit_line(fits+sortpos,hsortpos-sortpos,&hy0,&hy1,info);

			if(ret0){
			  ly0=ly;
			  ly1=hy0;
			}
			if(ret1){
			  hy0=ly1;
			  hy1=hy;
			}

			if(ret0 && ret1){
			  fit_valueA[i]=-200;
			  fit_valueB[i]=-200;
			}else{
			  /* store new edge values */
			  fit_valueB[ln]=ly0;
			  if(ln==0)fit_valueA[ln]=ly0;
			  fit_valueA[i]=ly1;
			  fit_valueB[i]=hy0;
			  fit_valueA[hn]=hy1;
			  if(hn==1)fit_valueB[hn]=hy1;

			  if(ly1>=0 || hy0>=0){
				/* store new neighbor values */
				for(j=sortpos-1;j>=0;j--)
				  if(hineighbor[j]==hn)
					hineighbor[j]=i;
				  else
					break;
				for(j=sortpos+1;j<posts;j++)
				  if(loneighbor[j]==ln)
					loneighbor[j]=i;
				  else
					break;
			  }
			}
		  }else{
			fit_valueA[i]=-200;
			fit_valueB[i]=-200;
		  }
		}
	  }
	}

	output=(int*)_vorbis_block_alloc(vb,sizeof(*output)*posts);

	output[0]=post_Y(fit_valueA,fit_valueB,0);
	output[1]=post_Y(fit_valueA,fit_valueB,1);

	/* fill in posts marked as not using a fit; we will zero
	   back out to 'unused' when encoding them so long as curve
	   interpolation doesn't force them into use */
	for(i=2;i<posts;i++){
	  int ln=look->loneighbor[i-2];
	  int hn=look->hineighbor[i-2];
	  int x0=info->postlist[ln];
	  int x1=info->postlist[hn];
	  int y0=output[ln];
	  int y1=output[hn];

	  int predicted=render_point(x0,x1,y0,y1,info->postlist[i]);
	  int vx=post_Y(fit_valueA,fit_valueB,i);

	  if(vx>=0 && predicted!=vx){
		output[i]=vx;
	  }else{
		output[i]= predicted|0x8000;
	  }
	}
  }

  return(output);

}

int *floor1_interpolate_fit(vorbis_block *vb,vorbis_look_floor1 *look,
						  int *A,int *B,
						  int del){

  long i;
  long posts=look->posts;
  int *output=NULL;

  if(A && B){
	output=(int*)_vorbis_block_alloc(vb,sizeof(*output)*posts);

	/* overly simpleminded--- look again post 1.2 */
	for(i=0;i<posts;i++){
	  output[i]=((65536-del)*(A[i]&0x7fff)+del*(B[i]&0x7fff)+32768)>>16;
	  if(A[i]&0x8000 && B[i]&0x8000)output[i]|=0x8000;
	}
  }

  return(output);
}

int floor1_encode(oggpack_buffer *opb,vorbis_block *vb,
				  vorbis_look_floor1 *look,
				  int *post,int *ilogmask){

  long i,j;
  vorbis_info_floor1 *info=look->vi;
  long posts=look->posts;
  codec_setup_info *ci=(codec_setup_info*)vb->vd->vi->codec_setup;
  int out[VIF_POSIT+2];
  static_codebook **sbooks=ci->book_param;
  codebook *books=ci->fullbooks;

  /* quantize values to multiplier spec */
  if(post){
	for(i=0;i<posts;i++){
	  int val=post[i]&0x7fff;
	  switch(info->mult){
	  case 1: /* 1024 -> 256 */
		val>>=2;
		break;
	  case 2: /* 1024 -> 128 */
		val>>=3;
		break;
	  case 3: /* 1024 -> 86 */
		val/=12;
		break;
	  case 4: /* 1024 -> 64 */
		val>>=4;
		break;
	  }
	  post[i]=val | (post[i]&0x8000);
	}

	out[0]=post[0];
	out[1]=post[1];

	/* find prediction values for each post and subtract them */
	for(i=2;i<posts;i++){
	  int ln=look->loneighbor[i-2];
	  int hn=look->hineighbor[i-2];
	  int x0=info->postlist[ln];
	  int x1=info->postlist[hn];
	  int y0=post[ln];
	  int y1=post[hn];

	  int predicted=render_point(x0,x1,y0,y1,info->postlist[i]);

	  if((post[i]&0x8000) || (predicted==post[i])){
		post[i]=predicted|0x8000; /* in case there was roundoff jitter
									 in interpolation */
		out[i]=0;
	  }else{
		int headroom=(look->quant_q-predicted<predicted?
					  look->quant_q-predicted:predicted);

		int val=post[i]-predicted;

		/* at this point the 'deviation' value is in the range +/- max
		   range, but the real, unique range can always be mapped to
		   only [0-maxrange).  So we want to wrap the deviation into
		   this limited range, but do it in the way that least screws
		   an essentially gaussian probability distribution. */

		if(val<0)
		  if(val<-headroom)
			val=headroom-val-1;
		  else
			val=-1-(val<<1);
		else
		  if(val>=headroom)
			val= val+headroom;
		  else
			val<<=1;

		out[i]=val;
		post[ln]&=0x7fff;
		post[hn]&=0x7fff;
	  }
	}

	/* we have everything we need. pack it out */
	/* mark nontrivial floor */
	oggpack_write(opb,1,1);

	/* beginning/end post */
	look->frames++;
	look->postbits+=ilog(look->quant_q-1)*2;
	oggpack_write(opb,out[0],ilog(look->quant_q-1));
	oggpack_write(opb,out[1],ilog(look->quant_q-1));

	/* partition by partition */
	for(i=0,j=2;i<info->partitions;i++){
	  int classx=info->partitionclass[i];
	  int cdim=info->class_dim[classx];
	  int csubbits=info->class_subs[classx];
	  int csub=1<<csubbits;
	  int bookas[8]={0,0,0,0,0,0,0,0};
	  int cval=0;
	  int cshift=0;
	  int k,l;

	  /* generate the partition's first stage cascade value */
	  if(csubbits){
		int maxval[8];
		for(k=0;k<csub;k++){
	  int booknum=info->class_subbook[classx][k];
		  if(booknum<0){
			maxval[k]=1;
		  }else{
	    maxval[k]=sbooks[info->class_subbook[classx][k]]->entries;
		  }
		}
		for(k=0;k<cdim;k++){
		  for(l=0;l<csub;l++){
			int val=out[j+k];
			if(val<maxval[l]){
			  bookas[k]=l;
			  break;
			}
		  }
		  cval|= bookas[k]<<cshift;
		  cshift+=csubbits;
		}
		/* write it */
		look->phrasebits+=
	  vorbis_book_encode(books+info->class_book[classx],cval,opb);

#ifdef TRAIN_FLOOR1
		{
		  FILE *of;
		  char buffer[80];
		  sprintf(buffer,"line_%dx%ld_class%d.vqd",
				  vb->pcmend/2,posts-2,class);
		  of=fopen(buffer,"a");
		  fprintf(of,"%d\n",cval);
		  fclose(of);
		}
#endif
	  }

	  /* write post values */
	  for(k=0;k<cdim;k++){
	int book=info->class_subbook[classx][bookas[k]];
		if(book>=0){
		  /* hack to allow training with 'bad' books */
		  if(out[j+k]<(books+book)->entries)
			look->postbits+=vorbis_book_encode(books+book,
											   out[j+k],opb);
		  /*else
			fprintf(stderr,"+!");*/

#ifdef TRAIN_FLOOR1
		  {
			FILE *of;
			char buffer[80];
			sprintf(buffer,"line_%dx%ld_%dsub%d.vqd",
					vb->pcmend/2,posts-2,class,bookas[k]);
			of=fopen(buffer,"a");
			fprintf(of,"%d\n",out[j+k]);
			fclose(of);
		  }
#endif
		}
	  }
	  j+=cdim;
	}

	{
	  /* generate quantized floor equivalent to what we'd unpack in decode */
	  /* render the lines */
	  int hx=0;
	  int lx=0;
	  int ly=post[0]*info->mult;
	  int n=ci->blocksizes[vb->W]/2;

	  for(j=1;j<look->posts;j++){
		int current=look->forward_index[j];
		int hy=post[current]&0x7fff;
		if(hy==post[current]){

		  hy*=info->mult;
		  hx=info->postlist[current];

		  render_line0(n,lx,hx,ly,hy,ilogmask);

		  lx=hx;
		  ly=hy;
		}
	  }
	  for(j=hx;j<vb->pcmend/2;j++)ilogmask[j]=ly; /* be certain */
	  return(1);
	}
  }else{
	oggpack_write(opb,0,1);
	memset(ilogmask,0,vb->pcmend/2*sizeof(*ilogmask));
	return(0);
  }
}

static void *floor1_inverse1(vorbis_block *vb,vorbis_look_floor *in){
  vorbis_look_floor1 *look=(vorbis_look_floor1 *)in;
  vorbis_info_floor1 *info=look->vi;
  codec_setup_info   *ci=(codec_setup_info*)vb->vd->vi->codec_setup;

  int i,j,k;
  codebook *books=ci->fullbooks;

  /* unpack wrapped/predicted values from stream */
  if(oggpack_read(&vb->opb,1)==1){
	int *fit_value=(int*)_vorbis_block_alloc(vb,(look->posts)*sizeof(*fit_value));

	fit_value[0]=oggpack_read(&vb->opb,ilog(look->quant_q-1));
	fit_value[1]=oggpack_read(&vb->opb,ilog(look->quant_q-1));

	/* partition by partition */
	for(i=0,j=2;i<info->partitions;i++){
	  int classx=info->partitionclass[i];
	  int cdim=info->class_dim[classx];
	  int csubbits=info->class_subs[classx];
	  int csub=1<<csubbits;
	  int cval=0;

	  /* decode the partition's first stage cascade value */
	  if(csubbits){
	cval=vorbis_book_decode(books+info->class_book[classx],&vb->opb);

		if(cval==-1)goto eop;
	  }

	  for(k=0;k<cdim;k++){
	int book=info->class_subbook[classx][cval&(csub-1)];
		cval>>=csubbits;
		if(book>=0){
		  if((fit_value[j+k]=vorbis_book_decode(books+book,&vb->opb))==-1)
			goto eop;
		}else{
		  fit_value[j+k]=0;
		}
	  }
	  j+=cdim;
	}

	/* unwrap positive values and reconsitute via linear interpolation */
	for(i=2;i<look->posts;i++){
	  int predicted=render_point(info->postlist[look->loneighbor[i-2]],
								 info->postlist[look->hineighbor[i-2]],
								 fit_value[look->loneighbor[i-2]],
								 fit_value[look->hineighbor[i-2]],
								 info->postlist[i]);
	  int hiroom=look->quant_q-predicted;
	  int loroom=predicted;
	  int room=(hiroom<loroom?hiroom:loroom)<<1;
	  int val=fit_value[i];

	  if(val){
		if(val>=room){
		  if(hiroom>loroom){
			val = val-loroom;
		  }else{
			val = -1-(val-hiroom);
		  }
		}else{
		  if(val&1){
			val= -((val+1)>>1);
		  }else{
			val>>=1;
		  }
		}

		fit_value[i]=val+predicted&0x7fff;
		fit_value[look->loneighbor[i-2]]&=0x7fff;
		fit_value[look->hineighbor[i-2]]&=0x7fff;

	  }else{
		fit_value[i]=predicted|0x8000;
	  }

	}

	return(fit_value);
  }
 eop:
  return(NULL);
}

static int floor1_inverse2(vorbis_block *vb,vorbis_look_floor *in,void *memo,
						  float *out){
  vorbis_look_floor1 *look=(vorbis_look_floor1 *)in;
  vorbis_info_floor1 *info=look->vi;

  codec_setup_info   *ci=(codec_setup_info*)vb->vd->vi->codec_setup;
  int                  n=ci->blocksizes[vb->W]/2;
  int j;

  if(memo){
	/* render the lines */
	int *fit_value=(int *)memo;
	int hx=0;
	int lx=0;
	int ly=fit_value[0]*info->mult;
	/* guard lookup against out-of-range values */
	ly=(ly<0?0:ly>255?255:ly);

	for(j=1;j<look->posts;j++){
	  int current=look->forward_index[j];
	  int hy=fit_value[current]&0x7fff;
	  if(hy==fit_value[current]){

		hx=info->postlist[current];
		hy*=info->mult;
		/* guard lookup against out-of-range values */
		hy=(hy<0?0:hy>255?255:hy);

		render_line(n,lx,hx,ly,hy,out);

		lx=hx;
		ly=hy;
	  }
	}
	for(j=hx;j<n;j++)out[j]*=FLOOR1_fromdB_LOOKUP[ly]; /* be certain */
	return(1);
  }
  memset(out,0,sizeof(*out)*n);
  return(0);
}

/* export hooks */
const vorbis_func_floor floor1_exportbundle={
  &floor1_pack,&floor1_unpack,&floor1_look,&floor1_free_info,
  &floor1_free_look,&floor1_inverse1,&floor1_inverse2
};

/*** End of inlined file: floor1.c ***/


/*** Start of inlined file: info.c ***/
/* general handling of the header and the vorbis_info structure (and
   substructures) */

#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define GENERAL_VENDOR_STRING "Xiph.Org libVorbis 1.3.2"
#define ENCODE_VENDOR_STRING "Xiph.Org libVorbis I 20101101 (Schaufenugget)"

/* helpers */

static void _v_writestring(oggpack_buffer *o,const char *s, int bytes){

  while(bytes--){
	oggpack_write(o,*s++,8);
  }
}

static void _v_readstring(oggpack_buffer *o,char *buf,int bytes){
  while(bytes--){
	*buf++=oggpack_read(o,8);
  }
}

void vorbis_comment_init(vorbis_comment *vc){
  memset(vc,0,sizeof(*vc));
}

void vorbis_comment_add(vorbis_comment *vc,const char *comment){
  vc->user_comments=(char**)_ogg_realloc(vc->user_comments,
							(vc->comments+2)*sizeof(*vc->user_comments));
  vc->comment_lengths=(int*)_ogg_realloc(vc->comment_lengths,
								  (vc->comments+2)*sizeof(*vc->comment_lengths));
  vc->comment_lengths[vc->comments]=strlen(comment);
  vc->user_comments[vc->comments]=(char*)_ogg_malloc(vc->comment_lengths[vc->comments]+1);
  strcpy(vc->user_comments[vc->comments], comment);
  vc->comments++;
  vc->user_comments[vc->comments]=NULL;
}

void vorbis_comment_add_tag(vorbis_comment *vc, const char *tag, const char *contents){
  char *comment=(char*)alloca(strlen(tag)+strlen(contents)+2); /* +2 for = and \0 */
  strcpy(comment, tag);
  strcat(comment, "=");
  strcat(comment, contents);
  vorbis_comment_add(vc, comment);
}

/* This is more or less the same as strncasecmp - but that doesn't exist
 * everywhere, and this is a fairly trivial function, so we include it */
static int tagcompare(const char *s1, const char *s2, int n){
  int c=0;
  while(c < n){
	if(toupper(s1[c]) != toupper(s2[c]))
	  return !0;
	c++;
  }
  return 0;
}

char *vorbis_comment_query(vorbis_comment *vc, const char *tag, int count){
  long i;
  int found = 0;
  int taglen = strlen(tag)+1; /* +1 for the = we append */
  char *fulltag = (char*)alloca(taglen+ 1);

  strcpy(fulltag, tag);
  strcat(fulltag, "=");

  for(i=0;i<vc->comments;i++){
	if(!tagcompare(vc->user_comments[i], fulltag, taglen)){
	  if(count == found)
		/* We return a pointer to the data, not a copy */
			  return vc->user_comments[i] + taglen;
	  else
		found++;
	}
  }
  return NULL; /* didn't find anything */
}

int vorbis_comment_query_count(vorbis_comment *vc, const char *tag){
  int i,count=0;
  int taglen = strlen(tag)+1; /* +1 for the = we append */
  char *fulltag = (char*)alloca(taglen+1);
  strcpy(fulltag,tag);
  strcat(fulltag, "=");

  for(i=0;i<vc->comments;i++){
	if(!tagcompare(vc->user_comments[i], fulltag, taglen))
	  count++;
  }

  return count;
}

void vorbis_comment_clear(vorbis_comment *vc){
  if(vc){
	long i;
	if(vc->user_comments){
	  for(i=0;i<vc->comments;i++)
		if(vc->user_comments[i])_ogg_free(vc->user_comments[i]);
	  _ogg_free(vc->user_comments);
	}
	if(vc->comment_lengths)_ogg_free(vc->comment_lengths);
	if(vc->vendor)_ogg_free(vc->vendor);
	memset(vc,0,sizeof(*vc));
  }
}

/* blocksize 0 is guaranteed to be short, 1 is guaranteed to be long.
   They may be equal, but short will never ge greater than long */
int vorbis_info_blocksize(vorbis_info *vi,int zo){
  codec_setup_info *ci = (codec_setup_info*)vi->codec_setup;
  return ci ? ci->blocksizes[zo] : -1;
}

/* used by synthesis, which has a full, alloced vi */
void vorbis_info_init(vorbis_info *vi){
  memset(vi,0,sizeof(*vi));
  vi->codec_setup=_ogg_calloc(1,sizeof(codec_setup_info));
}

void vorbis_info_clear(vorbis_info *vi){
  codec_setup_info     *ci=(codec_setup_info*)vi->codec_setup;
  int i;

  if(ci){

	for(i=0;i<ci->modes;i++)
	  if(ci->mode_param[i])_ogg_free(ci->mode_param[i]);

	for(i=0;i<ci->maps;i++) /* unpack does the range checking */
	  if(ci->map_param[i]) /* this may be cleaning up an aborted
							  unpack, in which case the below type
							  cannot be trusted */
		_mapping_P[ci->map_type[i]]->free_info(ci->map_param[i]);

	for(i=0;i<ci->floors;i++) /* unpack does the range checking */
	  if(ci->floor_param[i]) /* this may be cleaning up an aborted
								unpack, in which case the below type
								cannot be trusted */
		_floor_P[ci->floor_type[i]]->free_info(ci->floor_param[i]);

	for(i=0;i<ci->residues;i++) /* unpack does the range checking */
	  if(ci->residue_param[i]) /* this may be cleaning up an aborted
								  unpack, in which case the below type
								  cannot be trusted */
		_residue_P[ci->residue_type[i]]->free_info(ci->residue_param[i]);

	for(i=0;i<ci->books;i++){
	  if(ci->book_param[i]){
		/* knows if the book was not alloced */
		vorbis_staticbook_destroy(ci->book_param[i]);
	  }
	  if(ci->fullbooks)
		vorbis_book_clear(ci->fullbooks+i);
	}
	if(ci->fullbooks)
		_ogg_free(ci->fullbooks);

	for(i=0;i<ci->psys;i++)
	  _vi_psy_free(ci->psy_param[i]);

	_ogg_free(ci);
  }

  memset(vi,0,sizeof(*vi));
}

/* Header packing/unpacking ********************************************/

static int _vorbis_unpack_info(vorbis_info *vi,oggpack_buffer *opb){
  codec_setup_info     *ci=(codec_setup_info*)vi->codec_setup;
  if(!ci)return(OV_EFAULT);

  vi->version=oggpack_read(opb,32);
  if(vi->version!=0)return(OV_EVERSION);

  vi->channels=oggpack_read(opb,8);
  vi->rate=oggpack_read(opb,32);

  vi->bitrate_upper=oggpack_read(opb,32);
  vi->bitrate_nominal=oggpack_read(opb,32);
  vi->bitrate_lower=oggpack_read(opb,32);

  ci->blocksizes[0]=1<<oggpack_read(opb,4);
  ci->blocksizes[1]=1<<oggpack_read(opb,4);

  if(vi->rate<1)goto err_out;
  if(vi->channels<1)goto err_out;
  if(ci->blocksizes[0]<64)goto err_out;
  if(ci->blocksizes[1]<ci->blocksizes[0])goto err_out;
  if(ci->blocksizes[1]>8192)goto err_out;

  if(oggpack_read(opb,1)!=1)goto err_out; /* EOP check */

  return(0);
 err_out:
  vorbis_info_clear(vi);
  return(OV_EBADHEADER);
}

static int _vorbis_unpack_comment(vorbis_comment *vc,oggpack_buffer *opb){
  int i;
  int vendorlen=oggpack_read(opb,32);
  if(vendorlen<0)goto err_out;
  if(vendorlen>opb->storage-8)goto err_out;
  vc->vendor=(char*)_ogg_calloc(vendorlen+1,1);
  _v_readstring(opb,vc->vendor,vendorlen);
  i=oggpack_read(opb,32);
  if(i<0)goto err_out;
  if(i>((opb->storage-oggpack_bytes(opb))>>2))goto err_out;
  vc->comments=i;
  vc->user_comments=(char**)_ogg_calloc(vc->comments+1,sizeof(*vc->user_comments));
  vc->comment_lengths=(int*)_ogg_calloc(vc->comments+1, sizeof(*vc->comment_lengths));

  for(i=0;i<vc->comments;i++){
	int len=oggpack_read(opb,32);
	if(len<0)goto err_out;
	if(len>opb->storage-oggpack_bytes(opb))goto err_out;
	vc->comment_lengths[i]=len;
	vc->user_comments[i]=(char*)_ogg_calloc(len+1,1);
	_v_readstring(opb,vc->user_comments[i],len);
  }
  if(oggpack_read(opb,1)!=1)goto err_out; /* EOP check */

  return(0);
 err_out:
  vorbis_comment_clear(vc);
  return(OV_EBADHEADER);
}

/* all of the real encoding details are here.  The modes, books,
   everything */
static int _vorbis_unpack_books(vorbis_info *vi,oggpack_buffer *opb){
  codec_setup_info     *ci=(codec_setup_info*)vi->codec_setup;
  int i;
  if(!ci)return(OV_EFAULT);

  /* codebooks */
  ci->books=oggpack_read(opb,8)+1;
  if(ci->books<=0)goto err_out;
  for(i=0;i<ci->books;i++){
	ci->book_param[i]=vorbis_staticbook_unpack(opb);
	if(!ci->book_param[i])goto err_out;
  }

  /* time backend settings; hooks are unused */
  {
	int times=oggpack_read(opb,6)+1;
	if(times<=0)goto err_out;
	for(i=0;i<times;i++){
	  int test=oggpack_read(opb,16);
	  if(test<0 || test>=VI_TIMEB)goto err_out;
	}
  }

  /* floor backend settings */
  ci->floors=oggpack_read(opb,6)+1;
  if(ci->floors<=0)goto err_out;
  for(i=0;i<ci->floors;i++){
	ci->floor_type[i]=oggpack_read(opb,16);
	if(ci->floor_type[i]<0 || ci->floor_type[i]>=VI_FLOORB)goto err_out;
	ci->floor_param[i]=_floor_P[ci->floor_type[i]]->unpack(vi,opb);
	if(!ci->floor_param[i])goto err_out;
  }

  /* residue backend settings */
  ci->residues=oggpack_read(opb,6)+1;
  if(ci->residues<=0)goto err_out;
  for(i=0;i<ci->residues;i++){
	ci->residue_type[i]=oggpack_read(opb,16);
	if(ci->residue_type[i]<0 || ci->residue_type[i]>=VI_RESB)goto err_out;
	ci->residue_param[i]=_residue_P[ci->residue_type[i]]->unpack(vi,opb);
	if(!ci->residue_param[i])goto err_out;
  }

  /* map backend settings */
  ci->maps=oggpack_read(opb,6)+1;
  if(ci->maps<=0)goto err_out;
  for(i=0;i<ci->maps;i++){
	ci->map_type[i]=oggpack_read(opb,16);
	if(ci->map_type[i]<0 || ci->map_type[i]>=VI_MAPB)goto err_out;
	ci->map_param[i]=_mapping_P[ci->map_type[i]]->unpack(vi,opb);
	if(!ci->map_param[i])goto err_out;
  }

  /* mode settings */
  ci->modes=oggpack_read(opb,6)+1;
  if(ci->modes<=0)goto err_out;
  for(i=0;i<ci->modes;i++){
	ci->mode_param[i]=(vorbis_info_mode*)_ogg_calloc(1,sizeof(*ci->mode_param[i]));
	ci->mode_param[i]->blockflag=oggpack_read(opb,1);
	ci->mode_param[i]->windowtype=oggpack_read(opb,16);
	ci->mode_param[i]->transformtype=oggpack_read(opb,16);
	ci->mode_param[i]->mapping=oggpack_read(opb,8);

	if(ci->mode_param[i]->windowtype>=VI_WINDOWB)goto err_out;
	if(ci->mode_param[i]->transformtype>=VI_WINDOWB)goto err_out;
	if(ci->mode_param[i]->mapping>=ci->maps)goto err_out;
	if(ci->mode_param[i]->mapping<0)goto err_out;
  }

  if(oggpack_read(opb,1)!=1)goto err_out; /* top level EOP check */

  return(0);
 err_out:
  vorbis_info_clear(vi);
  return(OV_EBADHEADER);
}

/* Is this packet a vorbis ID header? */
int vorbis_synthesis_idheader(ogg_packet *op){
  oggpack_buffer opb;
  char buffer[6];

  if(op){
	oggpack_readinit(&opb,op->packet,op->bytes);

	if(!op->b_o_s)
	  return(0); /* Not the initial packet */

	if(oggpack_read(&opb,8) != 1)
	  return 0; /* not an ID header */

	memset(buffer,0,6);
	_v_readstring(&opb,buffer,6);
	if(memcmp(buffer,"vorbis",6))
	  return 0; /* not vorbis */

	return 1;
  }

  return 0;
}

/* The Vorbis header is in three packets; the initial small packet in
   the first page that identifies basic parameters, a second packet
   with bitstream comments and a third packet that holds the
   codebook. */

int vorbis_synthesis_headerin(vorbis_info *vi,vorbis_comment *vc,ogg_packet *op){
  oggpack_buffer opb;

  if(op){
	oggpack_readinit(&opb,op->packet,op->bytes);

	/* Which of the three types of header is this? */
	/* Also verify header-ness, vorbis */
	{
	  char buffer[6];
	  int packtype=oggpack_read(&opb,8);
	  memset(buffer,0,6);
	  _v_readstring(&opb,buffer,6);
	  if(memcmp(buffer,"vorbis",6)){
		/* not a vorbis header */
		return(OV_ENOTVORBIS);
	  }
	  switch(packtype){
	  case 0x01: /* least significant *bit* is read first */
		if(!op->b_o_s){
		  /* Not the initial packet */
		  return(OV_EBADHEADER);
		}
		if(vi->rate!=0){
		  /* previously initialized info header */
		  return(OV_EBADHEADER);
		}

		return(_vorbis_unpack_info(vi,&opb));

	  case 0x03: /* least significant *bit* is read first */
		if(vi->rate==0){
		  /* um... we didn't get the initial header */
		  return(OV_EBADHEADER);
		}

		return(_vorbis_unpack_comment(vc,&opb));

	  case 0x05: /* least significant *bit* is read first */
		if(vi->rate==0 || vc->vendor==NULL){
		  /* um... we didn;t get the initial header or comments yet */
		  return(OV_EBADHEADER);
		}

		return(_vorbis_unpack_books(vi,&opb));

	  default:
		/* Not a valid vorbis header type */
		return(OV_EBADHEADER);
		break;
	  }
	}
  }
  return(OV_EBADHEADER);
}

/* pack side **********************************************************/

static int _vorbis_pack_info(oggpack_buffer *opb,vorbis_info *vi){
  codec_setup_info     *ci=(codec_setup_info*)vi->codec_setup;
  if(!ci)return(OV_EFAULT);

  /* preamble */
  oggpack_write(opb,0x01,8);
  _v_writestring(opb,"vorbis", 6);

  /* basic information about the stream */
  oggpack_write(opb,0x00,32);
  oggpack_write(opb,vi->channels,8);
  oggpack_write(opb,vi->rate,32);

  oggpack_write(opb,vi->bitrate_upper,32);
  oggpack_write(opb,vi->bitrate_nominal,32);
  oggpack_write(opb,vi->bitrate_lower,32);

  oggpack_write(opb,ilog2(ci->blocksizes[0]),4);
  oggpack_write(opb,ilog2(ci->blocksizes[1]),4);
  oggpack_write(opb,1,1);

  return(0);
}

static int _vorbis_pack_comment(oggpack_buffer *opb,vorbis_comment *vc){
  int bytes = strlen(ENCODE_VENDOR_STRING);

  /* preamble */
  oggpack_write(opb,0x03,8);
  _v_writestring(opb,"vorbis", 6);

  /* vendor */
  oggpack_write(opb,bytes,32);
  _v_writestring(opb,ENCODE_VENDOR_STRING, bytes);

  /* comments */

  oggpack_write(opb,vc->comments,32);
  if(vc->comments){
	int i;
	for(i=0;i<vc->comments;i++){
	  if(vc->user_comments[i]){
		oggpack_write(opb,vc->comment_lengths[i],32);
		_v_writestring(opb,vc->user_comments[i], vc->comment_lengths[i]);
	  }else{
		oggpack_write(opb,0,32);
	  }
	}
  }
  oggpack_write(opb,1,1);

  return(0);
}

static int _vorbis_pack_books(oggpack_buffer *opb,vorbis_info *vi){
  codec_setup_info     *ci=(codec_setup_info*)vi->codec_setup;
  int i;
  if(!ci)return(OV_EFAULT);

  oggpack_write(opb,0x05,8);
  _v_writestring(opb,"vorbis", 6);

  /* books */
  oggpack_write(opb,ci->books-1,8);
  for(i=0;i<ci->books;i++)
	if(vorbis_staticbook_pack(ci->book_param[i],opb))goto err_out;

  /* times; hook placeholders */
  oggpack_write(opb,0,6);
  oggpack_write(opb,0,16);

  /* floors */
  oggpack_write(opb,ci->floors-1,6);
  for(i=0;i<ci->floors;i++){
	oggpack_write(opb,ci->floor_type[i],16);
	if(_floor_P[ci->floor_type[i]]->pack)
	  _floor_P[ci->floor_type[i]]->pack(ci->floor_param[i],opb);
	else
	  goto err_out;
  }

  /* residues */
  oggpack_write(opb,ci->residues-1,6);
  for(i=0;i<ci->residues;i++){
	oggpack_write(opb,ci->residue_type[i],16);
	_residue_P[ci->residue_type[i]]->pack(ci->residue_param[i],opb);
  }

  /* maps */
  oggpack_write(opb,ci->maps-1,6);
  for(i=0;i<ci->maps;i++){
	oggpack_write(opb,ci->map_type[i],16);
	_mapping_P[ci->map_type[i]]->pack(vi,ci->map_param[i],opb);
  }

  /* modes */
  oggpack_write(opb,ci->modes-1,6);
  for(i=0;i<ci->modes;i++){
	oggpack_write(opb,ci->mode_param[i]->blockflag,1);
	oggpack_write(opb,ci->mode_param[i]->windowtype,16);
	oggpack_write(opb,ci->mode_param[i]->transformtype,16);
	oggpack_write(opb,ci->mode_param[i]->mapping,8);
  }
  oggpack_write(opb,1,1);

  return(0);
err_out:
  return(-1);
}

int vorbis_commentheader_out(vorbis_comment *vc,
										  ogg_packet *op){

  oggpack_buffer opb;

  oggpack_writeinit(&opb);
  if(_vorbis_pack_comment(&opb,vc)) return OV_EIMPL;

  op->packet = (unsigned char*) _ogg_malloc(oggpack_bytes(&opb));
  memcpy(op->packet, opb.buffer, oggpack_bytes(&opb));

  op->bytes=oggpack_bytes(&opb);
  op->b_o_s=0;
  op->e_o_s=0;
  op->granulepos=0;
  op->packetno=1;

  return 0;
}

int vorbis_analysis_headerout(vorbis_dsp_state *v,
							  vorbis_comment *vc,
							  ogg_packet *op,
							  ogg_packet *op_comm,
							  ogg_packet *op_code){
  int ret=OV_EIMPL;
  vorbis_info *vi=v->vi;
  oggpack_buffer opb;
  private_state *b=(private_state*)v->backend_state;

  if(!b){
	ret=OV_EFAULT;
	goto err_out;
  }

  /* first header packet **********************************************/

  oggpack_writeinit(&opb);
  if(_vorbis_pack_info(&opb,vi))goto err_out;

  /* build the packet */
  if(b->header)_ogg_free(b->header);
  b->header=(unsigned char*) _ogg_malloc(oggpack_bytes(&opb));
  memcpy(b->header,opb.buffer,oggpack_bytes(&opb));
  op->packet=b->header;
  op->bytes=oggpack_bytes(&opb);
  op->b_o_s=1;
  op->e_o_s=0;
  op->granulepos=0;
  op->packetno=0;

  /* second header packet (comments) **********************************/

  oggpack_reset(&opb);
  if(_vorbis_pack_comment(&opb,vc))goto err_out;

  if(b->header1)_ogg_free(b->header1);
  b->header1=(unsigned char*) _ogg_malloc(oggpack_bytes(&opb));
  memcpy(b->header1,opb.buffer,oggpack_bytes(&opb));
  op_comm->packet=b->header1;
  op_comm->bytes=oggpack_bytes(&opb);
  op_comm->b_o_s=0;
  op_comm->e_o_s=0;
  op_comm->granulepos=0;
  op_comm->packetno=1;

  /* third header packet (modes/codebooks) ****************************/

  oggpack_reset(&opb);
  if(_vorbis_pack_books(&opb,vi))goto err_out;

  if(b->header2)_ogg_free(b->header2);
  b->header2=(unsigned char*) _ogg_malloc(oggpack_bytes(&opb));
  memcpy(b->header2,opb.buffer,oggpack_bytes(&opb));
  op_code->packet=b->header2;
  op_code->bytes=oggpack_bytes(&opb);
  op_code->b_o_s=0;
  op_code->e_o_s=0;
  op_code->granulepos=0;
  op_code->packetno=2;

  oggpack_writeclear(&opb);
  return(0);
 err_out:
  memset(op,0,sizeof(*op));
  memset(op_comm,0,sizeof(*op_comm));
  memset(op_code,0,sizeof(*op_code));

  if(b){
	oggpack_writeclear(&opb);
	if(b->header)_ogg_free(b->header);
	if(b->header1)_ogg_free(b->header1);
	if(b->header2)_ogg_free(b->header2);
	b->header=NULL;
	b->header1=NULL;
	b->header2=NULL;
  }
  return(ret);
}

double vorbis_granule_time(vorbis_dsp_state *v,ogg_int64_t granulepos){
  if(granulepos == -1) return -1;

  /* We're not guaranteed a 64 bit unsigned type everywhere, so we
	 have to put the unsigned granpo in a signed type. */
  if(granulepos>=0){
	return((double)granulepos/v->vi->rate);
  }else{
	ogg_int64_t granuleoff=0xffffffff;
	granuleoff<<=31;

#ifdef __GNUC__
	granuleoff |= 0x7ffffffffLL;
#else
	granuleoff |= 0x7ffffffff;
#endif
	return(((double)granulepos+2+granuleoff+granuleoff)/v->vi->rate);
  }
}

const char *vorbis_version_string(void){
  return GENERAL_VENDOR_STRING;
}

/*** End of inlined file: info.c ***/


/*** Start of inlined file: lpc.c ***/
/* Some of these routines (autocorrelator, LPC coefficient estimator)
   are derived from code written by Jutta Degener and Carsten Bormann;
   thus we include their copyright below.  The entirety of this file
   is freely redistributable on the condition that both of these
   copyright notices are preserved without modification.  */

/* Preserved Copyright: *********************************************/

/* Copyright 1992, 1993, 1994 by Jutta Degener and Carsten Bormann,
Technische Universita"t Berlin

Any use of this software is permitted provided that this notice is not
removed and that neither the authors nor the Technische Universita"t
Berlin are deemed to have made any representations as to the
suitability of this software for any purpose nor are held responsible
for any defects of this software. THERE IS ABSOLUTELY NO WARRANTY FOR
THIS SOFTWARE.

As a matter of courtesy, the authors request to be informed about uses
this software has found, about bugs in this software, and about any
improvements that may be of general interest.

Berlin, 28.11.1994
Jutta Degener
Carsten Bormann

*********************************************************************/

#include <stdlib.h>
#include <string.h>
#include <math.h>

/* Autocorrelation LPC coeff generation algorithm invented by
   N. Levinson in 1947, modified by J. Durbin in 1959. */

/* Input : n elements of time doamin data
   Output: m lpc coefficients, excitation energy */

float vorbis_lpc_from_data(float *data,float *lpci,int n,int m){
  double *aut=(double*)alloca(sizeof(*aut)*(m+1));
  double *lpc=(double*)alloca(sizeof(*lpc)*(m));
  double error;
  double epsilon;
  int i,j;

  /* autocorrelation, p+1 lag coefficients */
  j=m+1;
  while(j--){
	double d=0; /* double needed for accumulator depth */
	for(i=j;i<n;i++)d+=(double)data[i]*data[i-j];
	aut[j]=d;
  }

  /* Generate lpc coefficients from autocorr values */

  /* set our noise floor to about -100dB */
  error=aut[0] * (1. + 1e-10);
  epsilon=1e-9*aut[0]+1e-10;

  for(i=0;i<m;i++){
	double r= -aut[i+1];

	if(error<epsilon){
	  memset(lpc+i,0,(m-i)*sizeof(*lpc));
	  goto done;
	}

	/* Sum up this iteration's reflection coefficient; note that in
	   Vorbis we don't save it.  If anyone wants to recycle this code
	   and needs reflection coefficients, save the results of 'r' from
	   each iteration. */

	for(j=0;j<i;j++)r-=lpc[j]*aut[i-j];
	r/=error;

	/* Update LPC coefficients and total error */

	lpc[i]=r;
	for(j=0;j<i/2;j++){
	  double tmp=lpc[j];

	  lpc[j]+=r*lpc[i-1-j];
	  lpc[i-1-j]+=r*tmp;
	}
	if(i&1)lpc[j]+=lpc[j]*r;

	error*=1.-r*r;

  }

 done:

  /* slightly damp the filter */
  {
	double g = .99;
	double damp = g;
	for(j=0;j<m;j++){
	  lpc[j]*=damp;
	  damp*=g;
	}
  }

  for(j=0;j<m;j++)lpci[j]=(float)lpc[j];

  /* we need the error value to know how big an impulse to hit the
	 filter with later */

  return error;
}

void vorbis_lpc_predict(float *coeff,float *prime,int m,
					 float *data,long n){

  /* in: coeff[0...m-1] LPC coefficients
		 prime[0...m-1] initial values (allocated size of n+m-1)
	out: data[0...n-1] data samples */

  long i,j,o,p;
  float y;
  float *work=(float*)alloca(sizeof(*work)*(m+n));

  if(!prime)
	for(i=0;i<m;i++)
	  work[i]=0.f;
  else
	for(i=0;i<m;i++)
	  work[i]=prime[i];

  for(i=0;i<n;i++){
	y=0;
	o=i;
	p=m;
	for(j=0;j<m;j++)
	  y-=work[o++]*coeff[--p];

	data[i]=work[o]=y;
  }
}

/*** End of inlined file: lpc.c ***/


/*** Start of inlined file: lsp.c ***/
/* Note that the lpc-lsp conversion finds the roots of polynomial with
   an iterative root polisher (CACM algorithm 283).  It *is* possible
   to confuse this algorithm into not converging; that should only
   happen with absurdly closely spaced roots (very sharp peaks in the
   LPC f response) which in turn should be impossible in our use of
   the code.  If this *does* happen anyway, it's a bug in the floor
   finder; find the cause of the confusion (probably a single bin
   spike or accidental near-float-limit resolution problems) and
   correct it. */

#include <math.h>
#include <string.h>
#include <stdlib.h>


/*** Start of inlined file: lookup.h ***/
#ifndef _V_LOOKUP_H_

#ifdef FLOAT_LOOKUP
extern float vorbis_coslook(float a);
extern float vorbis_invsqlook(float a);
extern float vorbis_invsq2explook(int a);
extern float vorbis_fromdBlook(float a);
#endif
#ifdef INT_LOOKUP
extern long vorbis_invsqlook_i(long a,long e);
extern long vorbis_coslook_i(long a);
extern float vorbis_fromdBlook_i(long a);
#endif

#endif

/*** End of inlined file: lookup.h ***/

/* three possible LSP to f curve functions; the exact computation
   (float), a lookup based float implementation, and an integer
   implementation.  The float lookup is likely the optimal choice on
   any machine with an FPU.  The integer implementation is *not* fixed
   point (due to the need for a large dynamic range and thus a
   separately tracked exponent) and thus much more complex than the
   relatively simple float implementations. It's mostly for future
   work on a fully fixed point implementation for processors like the
   ARM family. */

/* define either of these (preferably FLOAT_LOOKUP) to have faster
   but less precise implementation. */
#undef FLOAT_LOOKUP
#undef INT_LOOKUP

#ifdef FLOAT_LOOKUP

/*** Start of inlined file: lookup.c ***/
#include <math.h>

/*** Start of inlined file: lookup.h ***/
#ifndef _V_LOOKUP_H_

#ifdef FLOAT_LOOKUP
extern float vorbis_coslook(float a);
extern float vorbis_invsqlook(float a);
extern float vorbis_invsq2explook(int a);
extern float vorbis_fromdBlook(float a);
#endif
#ifdef INT_LOOKUP
extern long vorbis_invsqlook_i(long a,long e);
extern long vorbis_coslook_i(long a);
extern float vorbis_fromdBlook_i(long a);
#endif

#endif

/*** End of inlined file: lookup.h ***/



/*** Start of inlined file: lookup_data.h ***/
#ifndef _V_LOOKUP_DATA_H_

#ifdef FLOAT_LOOKUP
#define COS_LOOKUP_SZ 128
static const float COS_LOOKUP[COS_LOOKUP_SZ+1]={
		+1.0000000000000f,+0.9996988186962f,+0.9987954562052f,+0.9972904566787f,
		+0.9951847266722f,+0.9924795345987f,+0.9891765099648f,+0.9852776423889f,
		+0.9807852804032f,+0.9757021300385f,+0.9700312531945f,+0.9637760657954f,
		+0.9569403357322f,+0.9495281805930f,+0.9415440651830f,+0.9329927988347f,
		+0.9238795325113f,+0.9142097557035f,+0.9039892931234f,+0.8932243011955f,
		+0.8819212643484f,+0.8700869911087f,+0.8577286100003f,+0.8448535652497f,
		+0.8314696123025f,+0.8175848131516f,+0.8032075314806f,+0.7883464276266f,
		+0.7730104533627f,+0.7572088465065f,+0.7409511253550f,+0.7242470829515f,
		+0.7071067811865f,+0.6895405447371f,+0.6715589548470f,+0.6531728429538f,
		+0.6343932841636f,+0.6152315905806f,+0.5956993044924f,+0.5758081914178f,
		+0.5555702330196f,+0.5349976198871f,+0.5141027441932f,+0.4928981922298f,
		+0.4713967368260f,+0.4496113296546f,+0.4275550934303f,+0.4052413140050f,
		+0.3826834323651f,+0.3598950365350f,+0.3368898533922f,+0.3136817403989f,
		+0.2902846772545f,+0.2667127574749f,+0.2429801799033f,+0.2191012401569f,
		+0.1950903220161f,+0.1709618887603f,+0.1467304744554f,+0.1224106751992f,
		+0.0980171403296f,+0.0735645635997f,+0.0490676743274f,+0.0245412285229f,
		+0.0000000000000f,-0.0245412285229f,-0.0490676743274f,-0.0735645635997f,
		-0.0980171403296f,-0.1224106751992f,-0.1467304744554f,-0.1709618887603f,
		-0.1950903220161f,-0.2191012401569f,-0.2429801799033f,-0.2667127574749f,
		-0.2902846772545f,-0.3136817403989f,-0.3368898533922f,-0.3598950365350f,
		-0.3826834323651f,-0.4052413140050f,-0.4275550934303f,-0.4496113296546f,
		-0.4713967368260f,-0.4928981922298f,-0.5141027441932f,-0.5349976198871f,
		-0.5555702330196f,-0.5758081914178f,-0.5956993044924f,-0.6152315905806f,
		-0.6343932841636f,-0.6531728429538f,-0.6715589548470f,-0.6895405447371f,
		-0.7071067811865f,-0.7242470829515f,-0.7409511253550f,-0.7572088465065f,
		-0.7730104533627f,-0.7883464276266f,-0.8032075314806f,-0.8175848131516f,
		-0.8314696123025f,-0.8448535652497f,-0.8577286100003f,-0.8700869911087f,
		-0.8819212643484f,-0.8932243011955f,-0.9039892931234f,-0.9142097557035f,
		-0.9238795325113f,-0.9329927988347f,-0.9415440651830f,-0.9495281805930f,
		-0.9569403357322f,-0.9637760657954f,-0.9700312531945f,-0.9757021300385f,
		-0.9807852804032f,-0.9852776423889f,-0.9891765099648f,-0.9924795345987f,
		-0.9951847266722f,-0.9972904566787f,-0.9987954562052f,-0.9996988186962f,
		-1.0000000000000f,
};

#define INVSQ_LOOKUP_SZ 32
static const float INVSQ_LOOKUP[INVSQ_LOOKUP_SZ+1]={
		1.414213562373f,1.392621247646f,1.371988681140f,1.352246807566f,
		1.333333333333f,1.315191898443f,1.297771369046f,1.281025230441f,
		1.264911064067f,1.249390095109f,1.234426799697f,1.219988562661f,
		1.206045378311f,1.192569588000f,1.179535649239f,1.166919931983f,
		1.154700538379f,1.142857142857f,1.131370849898f,1.120224067222f,
		1.109400392450f,1.098884511590f,1.088662107904f,1.078719779941f,
		1.069044967650f,1.059625885652f,1.050451462878f,1.041511287847f,
		1.032795558989f,1.024295039463f,1.016001016002f,1.007905261358f,
		1.000000000000f,
};

#define INVSQ2EXP_LOOKUP_MIN (-32)
#define INVSQ2EXP_LOOKUP_MAX 32
static const float INVSQ2EXP_LOOKUP[INVSQ2EXP_LOOKUP_MAX-\
							  INVSQ2EXP_LOOKUP_MIN+1]={
				 65536.f,    46340.95001f,         32768.f,    23170.47501f,
				 16384.f,     11585.2375f,          8192.f,    5792.618751f,
				  4096.f,    2896.309376f,          2048.f,    1448.154688f,
				  1024.f,    724.0773439f,           512.f,     362.038672f,
				   256.f,     181.019336f,           128.f,    90.50966799f,
					64.f,      45.254834f,            32.f,      22.627417f,
					16.f,     11.3137085f,             8.f,    5.656854249f,
					 4.f,    2.828427125f,             2.f,    1.414213562f,
					 1.f,   0.7071067812f,            0.5f,   0.3535533906f,
				   0.25f,   0.1767766953f,          0.125f,  0.08838834765f,
				 0.0625f,  0.04419417382f,        0.03125f,  0.02209708691f,
			   0.015625f,  0.01104854346f,      0.0078125f, 0.005524271728f,
			 0.00390625f, 0.002762135864f,    0.001953125f, 0.001381067932f,
		   0.0009765625f, 0.000690533966f,  0.00048828125f, 0.000345266983f,
		 0.000244140625f,0.0001726334915f,0.0001220703125f,8.631674575e-05f,
		6.103515625e-05f,4.315837288e-05f,3.051757812e-05f,2.157918644e-05f,
		1.525878906e-05f,
};

#endif

#define FROMdB_LOOKUP_SZ 35
#define FROMdB2_LOOKUP_SZ 32
#define FROMdB_SHIFT 5
#define FROMdB2_SHIFT 3
#define FROMdB2_MASK 31

#ifdef FLOAT_LOOKUP
static const float FROMdB_LOOKUP[FROMdB_LOOKUP_SZ]={
					 1.f,   0.6309573445f,   0.3981071706f,   0.2511886432f,
		   0.1584893192f,            0.1f,  0.06309573445f,  0.03981071706f,
		  0.02511886432f,  0.01584893192f,           0.01f, 0.006309573445f,
		 0.003981071706f, 0.002511886432f, 0.001584893192f,          0.001f,
		0.0006309573445f,0.0003981071706f,0.0002511886432f,0.0001584893192f,
				 0.0001f,6.309573445e-05f,3.981071706e-05f,2.511886432e-05f,
		1.584893192e-05f,          1e-05f,6.309573445e-06f,3.981071706e-06f,
		2.511886432e-06f,1.584893192e-06f,          1e-06f,6.309573445e-07f,
		3.981071706e-07f,2.511886432e-07f,1.584893192e-07f,
};

static const float FROMdB2_LOOKUP[FROMdB2_LOOKUP_SZ]={
		   0.9928302478f,   0.9786445908f,   0.9646616199f,   0.9508784391f,
		   0.9372921937f,     0.92390007f,   0.9106992942f,   0.8976871324f,
		   0.8848608897f,   0.8722179097f,   0.8597555737f,   0.8474713009f,
			0.835362547f,   0.8234268041f,   0.8116616003f,   0.8000644989f,
		   0.7886330981f,   0.7773650302f,   0.7662579617f,    0.755309592f,
		   0.7445176537f,   0.7338799116f,   0.7233941627f,   0.7130582353f,
		   0.7028699885f,   0.6928273125f,   0.6829281272f,   0.6731703824f,
		   0.6635520573f,   0.6540711597f,   0.6447257262f,   0.6355138211f,
};
#endif

#ifdef INT_LOOKUP

#define INVSQ_LOOKUP_I_SHIFT 10
#define INVSQ_LOOKUP_I_MASK 1023
static const long INVSQ_LOOKUP_I[64+1]={
		   92682l,   91966l,   91267l,   90583l,
		   89915l,   89261l,   88621l,   87995l,
		   87381l,   86781l,   86192l,   85616l,
		   85051l,   84497l,   83953l,   83420l,
		   82897l,   82384l,   81880l,   81385l,
		   80899l,   80422l,   79953l,   79492l,
		   79039l,   78594l,   78156l,   77726l,
		   77302l,   76885l,   76475l,   76072l,
		   75674l,   75283l,   74898l,   74519l,
		   74146l,   73778l,   73415l,   73058l,
		   72706l,   72359l,   72016l,   71679l,
		   71347l,   71019l,   70695l,   70376l,
		   70061l,   69750l,   69444l,   69141l,
		   68842l,   68548l,   68256l,   67969l,
		   67685l,   67405l,   67128l,   66855l,
		   66585l,   66318l,   66054l,   65794l,
		   65536l,
};

#define COS_LOOKUP_I_SHIFT 9
#define COS_LOOKUP_I_MASK 511
#define COS_LOOKUP_I_SZ 128
static const long COS_LOOKUP_I[COS_LOOKUP_I_SZ+1]={
		   16384l,   16379l,   16364l,   16340l,
		   16305l,   16261l,   16207l,   16143l,
		   16069l,   15986l,   15893l,   15791l,
		   15679l,   15557l,   15426l,   15286l,
		   15137l,   14978l,   14811l,   14635l,
		   14449l,   14256l,   14053l,   13842l,
		   13623l,   13395l,   13160l,   12916l,
		   12665l,   12406l,   12140l,   11866l,
		   11585l,   11297l,   11003l,   10702l,
		   10394l,   10080l,    9760l,    9434l,
			9102l,    8765l,    8423l,    8076l,
			7723l,    7366l,    7005l,    6639l,
			6270l,    5897l,    5520l,    5139l,
			4756l,    4370l,    3981l,    3590l,
			3196l,    2801l,    2404l,    2006l,
			1606l,    1205l,     804l,     402l,
			   0l,    -401l,    -803l,   -1204l,
		   -1605l,   -2005l,   -2403l,   -2800l,
		   -3195l,   -3589l,   -3980l,   -4369l,
		   -4755l,   -5138l,   -5519l,   -5896l,
		   -6269l,   -6638l,   -7004l,   -7365l,
		   -7722l,   -8075l,   -8422l,   -8764l,
		   -9101l,   -9433l,   -9759l,  -10079l,
		  -10393l,  -10701l,  -11002l,  -11296l,
		  -11584l,  -11865l,  -12139l,  -12405l,
		  -12664l,  -12915l,  -13159l,  -13394l,
		  -13622l,  -13841l,  -14052l,  -14255l,
		  -14448l,  -14634l,  -14810l,  -14977l,
		  -15136l,  -15285l,  -15425l,  -15556l,
		  -15678l,  -15790l,  -15892l,  -15985l,
		  -16068l,  -16142l,  -16206l,  -16260l,
		  -16304l,  -16339l,  -16363l,  -16378l,
		  -16383l,
};

#endif

#endif

/*** End of inlined file: lookup_data.h ***/

#ifdef FLOAT_LOOKUP

/* interpolated lookup based cos function, domain 0 to PI only */
float vorbis_coslook(float a){
  double d=a*(.31830989*(float)COS_LOOKUP_SZ);
  int i=vorbis_ftoi(d-.5);

  return COS_LOOKUP[i]+ (d-i)*(COS_LOOKUP[i+1]-COS_LOOKUP[i]);
}

/* interpolated 1./sqrt(p) where .5 <= p < 1. */
float vorbis_invsqlook(float a){
  double d=a*(2.f*(float)INVSQ_LOOKUP_SZ)-(float)INVSQ_LOOKUP_SZ;
  int i=vorbis_ftoi(d-.5f);
  return INVSQ_LOOKUP[i]+ (d-i)*(INVSQ_LOOKUP[i+1]-INVSQ_LOOKUP[i]);
}

/* interpolated 1./sqrt(p) where .5 <= p < 1. */
float vorbis_invsq2explook(int a){
  return INVSQ2EXP_LOOKUP[a-INVSQ2EXP_LOOKUP_MIN];
}

#include <stdio.h>
/* interpolated lookup based fromdB function, domain -140dB to 0dB only */
float vorbis_fromdBlook(float a){
  int i=vorbis_ftoi(a*((float)(-(1<<FROMdB2_SHIFT)))-.5f);
  return (i<0)?1.f:
	((i>=(FROMdB_LOOKUP_SZ<<FROMdB_SHIFT))?0.f:
	 FROMdB_LOOKUP[i>>FROMdB_SHIFT]*FROMdB2_LOOKUP[i&FROMdB2_MASK]);
}

#endif

#ifdef INT_LOOKUP
/* interpolated 1./sqrt(p) where .5 <= a < 1. (.100000... to .111111...) in
   16.16 format

   returns in m.8 format */
long vorbis_invsqlook_i(long a,long e){
  long i=(a&0x7fff)>>(INVSQ_LOOKUP_I_SHIFT-1);
  long d=(a&INVSQ_LOOKUP_I_MASK)<<(16-INVSQ_LOOKUP_I_SHIFT); /*  0.16 */
  long val=INVSQ_LOOKUP_I[i]-                                /*  1.16 */
	(((INVSQ_LOOKUP_I[i]-INVSQ_LOOKUP_I[i+1])*               /*  0.16 */
	  d)>>16);                                               /* result 1.16 */

  e+=32;
  if(e&1)val=(val*5792)>>13; /* multiply val by 1/sqrt(2) */
  e=(e>>1)-8;

  return(val>>e);
}

/* interpolated lookup based fromdB function, domain -140dB to 0dB only */
/* a is in n.12 format */
float vorbis_fromdBlook_i(long a){
  int i=(-a)>>(12-FROMdB2_SHIFT);
  return (i<0)?1.f:
	((i>=(FROMdB_LOOKUP_SZ<<FROMdB_SHIFT))?0.f:
	 FROMdB_LOOKUP[i>>FROMdB_SHIFT]*FROMdB2_LOOKUP[i&FROMdB2_MASK]);
}

/* interpolated lookup based cos function, domain 0 to PI only */
/* a is in 0.16 format, where 0==0, 2^^16-1==PI, return 0.14 */
long vorbis_coslook_i(long a){
  int i=a>>COS_LOOKUP_I_SHIFT;
  int d=a&COS_LOOKUP_I_MASK;
  return COS_LOOKUP_I[i]- ((d*(COS_LOOKUP_I[i]-COS_LOOKUP_I[i+1]))>>
						   COS_LOOKUP_I_SHIFT);
}

#endif

/*** End of inlined file: lookup.c ***/


					   compilers (like gcc) that can't inline across
					   modules */

/* side effect: changes *lsp to cosines of lsp */
void vorbis_lsp_to_curve(float *curve,int *map,int n,int ln,float *lsp,int m,
							float amp,float ampoffset){
  int i;
  float wdel=M_PI/ln;
  vorbis_fpu_control fpu;

  vorbis_fpu_setround(&fpu);
  for(i=0;i<m;i++)lsp[i]=vorbis_coslook(lsp[i]);

  i=0;
  while(i<n){
	int k=map[i];
	int qexp;
	float p=.7071067812f;
	float q=.7071067812f;
	float w=vorbis_coslook(wdel*k);
	float *ftmp=lsp;
	int c=m>>1;

	while(c--){
	  q*=ftmp[0]-w;
	  p*=ftmp[1]-w;
	  ftmp+=2;
	}

	if(m&1){
	  /* odd order filter; slightly assymetric */
	  /* the last coefficient */
	  q*=ftmp[0]-w;
	  q*=q;
	  p*=p*(1.f-w*w);
	}else{
	  /* even order filter; still symmetric */
	  q*=q*(1.f+w);
	  p*=p*(1.f-w);
	}

	q=frexp(p+q,&qexp);
	q=vorbis_fromdBlook(amp*
						vorbis_invsqlook(q)*
						vorbis_invsq2explook(qexp+m)-
						ampoffset);

	do{
	  curve[i++]*=q;
	}while(map[i]==k);
  }
  vorbis_fpu_restore(fpu);
}

#else

#ifdef INT_LOOKUP

/*** Start of inlined file: lookup.c ***/
#include <math.h>

/*** Start of inlined file: lookup.h ***/
#ifndef _V_LOOKUP_H_

#ifdef FLOAT_LOOKUP
extern float vorbis_coslook(float a);
extern float vorbis_invsqlook(float a);
extern float vorbis_invsq2explook(int a);
extern float vorbis_fromdBlook(float a);
#endif
#ifdef INT_LOOKUP
extern long vorbis_invsqlook_i(long a,long e);
extern long vorbis_coslook_i(long a);
extern float vorbis_fromdBlook_i(long a);
#endif

#endif

/*** End of inlined file: lookup.h ***/



/*** Start of inlined file: lookup_data.h ***/
#ifndef _V_LOOKUP_DATA_H_

#ifdef FLOAT_LOOKUP
#define COS_LOOKUP_SZ 128
static const float COS_LOOKUP[COS_LOOKUP_SZ+1]={
		+1.0000000000000f,+0.9996988186962f,+0.9987954562052f,+0.9972904566787f,
		+0.9951847266722f,+0.9924795345987f,+0.9891765099648f,+0.9852776423889f,
		+0.9807852804032f,+0.9757021300385f,+0.9700312531945f,+0.9637760657954f,
		+0.9569403357322f,+0.9495281805930f,+0.9415440651830f,+0.9329927988347f,
		+0.9238795325113f,+0.9142097557035f,+0.9039892931234f,+0.8932243011955f,
		+0.8819212643484f,+0.8700869911087f,+0.8577286100003f,+0.8448535652497f,
		+0.8314696123025f,+0.8175848131516f,+0.8032075314806f,+0.7883464276266f,
		+0.7730104533627f,+0.7572088465065f,+0.7409511253550f,+0.7242470829515f,
		+0.7071067811865f,+0.6895405447371f,+0.6715589548470f,+0.6531728429538f,
		+0.6343932841636f,+0.6152315905806f,+0.5956993044924f,+0.5758081914178f,
		+0.5555702330196f,+0.5349976198871f,+0.5141027441932f,+0.4928981922298f,
		+0.4713967368260f,+0.4496113296546f,+0.4275550934303f,+0.4052413140050f,
		+0.3826834323651f,+0.3598950365350f,+0.3368898533922f,+0.3136817403989f,
		+0.2902846772545f,+0.2667127574749f,+0.2429801799033f,+0.2191012401569f,
		+0.1950903220161f,+0.1709618887603f,+0.1467304744554f,+0.1224106751992f,
		+0.0980171403296f,+0.0735645635997f,+0.0490676743274f,+0.0245412285229f,
		+0.0000000000000f,-0.0245412285229f,-0.0490676743274f,-0.0735645635997f,
		-0.0980171403296f,-0.1224106751992f,-0.1467304744554f,-0.1709618887603f,
		-0.1950903220161f,-0.2191012401569f,-0.2429801799033f,-0.2667127574749f,
		-0.2902846772545f,-0.3136817403989f,-0.3368898533922f,-0.3598950365350f,
		-0.3826834323651f,-0.4052413140050f,-0.4275550934303f,-0.4496113296546f,
		-0.4713967368260f,-0.4928981922298f,-0.5141027441932f,-0.5349976198871f,
		-0.5555702330196f,-0.5758081914178f,-0.5956993044924f,-0.6152315905806f,
		-0.6343932841636f,-0.6531728429538f,-0.6715589548470f,-0.6895405447371f,
		-0.7071067811865f,-0.7242470829515f,-0.7409511253550f,-0.7572088465065f,
		-0.7730104533627f,-0.7883464276266f,-0.8032075314806f,-0.8175848131516f,
		-0.8314696123025f,-0.8448535652497f,-0.8577286100003f,-0.8700869911087f,
		-0.8819212643484f,-0.8932243011955f,-0.9039892931234f,-0.9142097557035f,
		-0.9238795325113f,-0.9329927988347f,-0.9415440651830f,-0.9495281805930f,
		-0.9569403357322f,-0.9637760657954f,-0.9700312531945f,-0.9757021300385f,
		-0.9807852804032f,-0.9852776423889f,-0.9891765099648f,-0.9924795345987f,
		-0.9951847266722f,-0.9972904566787f,-0.9987954562052f,-0.9996988186962f,
		-1.0000000000000f,
};

#define INVSQ_LOOKUP_SZ 32
static const float INVSQ_LOOKUP[INVSQ_LOOKUP_SZ+1]={
		1.414213562373f,1.392621247646f,1.371988681140f,1.352246807566f,
		1.333333333333f,1.315191898443f,1.297771369046f,1.281025230441f,
		1.264911064067f,1.249390095109f,1.234426799697f,1.219988562661f,
		1.206045378311f,1.192569588000f,1.179535649239f,1.166919931983f,
		1.154700538379f,1.142857142857f,1.131370849898f,1.120224067222f,
		1.109400392450f,1.098884511590f,1.088662107904f,1.078719779941f,
		1.069044967650f,1.059625885652f,1.050451462878f,1.041511287847f,
		1.032795558989f,1.024295039463f,1.016001016002f,1.007905261358f,
		1.000000000000f,
};

#define INVSQ2EXP_LOOKUP_MIN (-32)
#define INVSQ2EXP_LOOKUP_MAX 32
static const float INVSQ2EXP_LOOKUP[INVSQ2EXP_LOOKUP_MAX-\
							  INVSQ2EXP_LOOKUP_MIN+1]={
				 65536.f,    46340.95001f,         32768.f,    23170.47501f,
				 16384.f,     11585.2375f,          8192.f,    5792.618751f,
				  4096.f,    2896.309376f,          2048.f,    1448.154688f,
				  1024.f,    724.0773439f,           512.f,     362.038672f,
				   256.f,     181.019336f,           128.f,    90.50966799f,
					64.f,      45.254834f,            32.f,      22.627417f,
					16.f,     11.3137085f,             8.f,    5.656854249f,
					 4.f,    2.828427125f,             2.f,    1.414213562f,
					 1.f,   0.7071067812f,            0.5f,   0.3535533906f,
				   0.25f,   0.1767766953f,          0.125f,  0.08838834765f,
				 0.0625f,  0.04419417382f,        0.03125f,  0.02209708691f,
			   0.015625f,  0.01104854346f,      0.0078125f, 0.005524271728f,
			 0.00390625f, 0.002762135864f,    0.001953125f, 0.001381067932f,
		   0.0009765625f, 0.000690533966f,  0.00048828125f, 0.000345266983f,
		 0.000244140625f,0.0001726334915f,0.0001220703125f,8.631674575e-05f,
		6.103515625e-05f,4.315837288e-05f,3.051757812e-05f,2.157918644e-05f,
		1.525878906e-05f,
};

#endif

#define FROMdB_LOOKUP_SZ 35
#define FROMdB2_LOOKUP_SZ 32
#define FROMdB_SHIFT 5
#define FROMdB2_SHIFT 3
#define FROMdB2_MASK 31

#ifdef FLOAT_LOOKUP
static const float FROMdB_LOOKUP[FROMdB_LOOKUP_SZ]={
					 1.f,   0.6309573445f,   0.3981071706f,   0.2511886432f,
		   0.1584893192f,            0.1f,  0.06309573445f,  0.03981071706f,
		  0.02511886432f,  0.01584893192f,           0.01f, 0.006309573445f,
		 0.003981071706f, 0.002511886432f, 0.001584893192f,          0.001f,
		0.0006309573445f,0.0003981071706f,0.0002511886432f,0.0001584893192f,
				 0.0001f,6.309573445e-05f,3.981071706e-05f,2.511886432e-05f,
		1.584893192e-05f,          1e-05f,6.309573445e-06f,3.981071706e-06f,
		2.511886432e-06f,1.584893192e-06f,          1e-06f,6.309573445e-07f,
		3.981071706e-07f,2.511886432e-07f,1.584893192e-07f,
};

static const float FROMdB2_LOOKUP[FROMdB2_LOOKUP_SZ]={
		   0.9928302478f,   0.9786445908f,   0.9646616199f,   0.9508784391f,
		   0.9372921937f,     0.92390007f,   0.9106992942f,   0.8976871324f,
		   0.8848608897f,   0.8722179097f,   0.8597555737f,   0.8474713009f,
			0.835362547f,   0.8234268041f,   0.8116616003f,   0.8000644989f,
		   0.7886330981f,   0.7773650302f,   0.7662579617f,    0.755309592f,
		   0.7445176537f,   0.7338799116f,   0.7233941627f,   0.7130582353f,
		   0.7028699885f,   0.6928273125f,   0.6829281272f,   0.6731703824f,
		   0.6635520573f,   0.6540711597f,   0.6447257262f,   0.6355138211f,
};
#endif

#ifdef INT_LOOKUP

#define INVSQ_LOOKUP_I_SHIFT 10
#define INVSQ_LOOKUP_I_MASK 1023
static const long INVSQ_LOOKUP_I[64+1]={
		   92682l,   91966l,   91267l,   90583l,
		   89915l,   89261l,   88621l,   87995l,
		   87381l,   86781l,   86192l,   85616l,
		   85051l,   84497l,   83953l,   83420l,
		   82897l,   82384l,   81880l,   81385l,
		   80899l,   80422l,   79953l,   79492l,
		   79039l,   78594l,   78156l,   77726l,
		   77302l,   76885l,   76475l,   76072l,
		   75674l,   75283l,   74898l,   74519l,
		   74146l,   73778l,   73415l,   73058l,
		   72706l,   72359l,   72016l,   71679l,
		   71347l,   71019l,   70695l,   70376l,
		   70061l,   69750l,   69444l,   69141l,
		   68842l,   68548l,   68256l,   67969l,
		   67685l,   67405l,   67128l,   66855l,
		   66585l,   66318l,   66054l,   65794l,
		   65536l,
};

#define COS_LOOKUP_I_SHIFT 9
#define COS_LOOKUP_I_MASK 511
#define COS_LOOKUP_I_SZ 128
static const long COS_LOOKUP_I[COS_LOOKUP_I_SZ+1]={
		   16384l,   16379l,   16364l,   16340l,
		   16305l,   16261l,   16207l,   16143l,
		   16069l,   15986l,   15893l,   15791l,
		   15679l,   15557l,   15426l,   15286l,
		   15137l,   14978l,   14811l,   14635l,
		   14449l,   14256l,   14053l,   13842l,
		   13623l,   13395l,   13160l,   12916l,
		   12665l,   12406l,   12140l,   11866l,
		   11585l,   11297l,   11003l,   10702l,
		   10394l,   10080l,    9760l,    9434l,
			9102l,    8765l,    8423l,    8076l,
			7723l,    7366l,    7005l,    6639l,
			6270l,    5897l,    5520l,    5139l,
			4756l,    4370l,    3981l,    3590l,
			3196l,    2801l,    2404l,    2006l,
			1606l,    1205l,     804l,     402l,
			   0l,    -401l,    -803l,   -1204l,
		   -1605l,   -2005l,   -2403l,   -2800l,
		   -3195l,   -3589l,   -3980l,   -4369l,
		   -4755l,   -5138l,   -5519l,   -5896l,
		   -6269l,   -6638l,   -7004l,   -7365l,
		   -7722l,   -8075l,   -8422l,   -8764l,
		   -9101l,   -9433l,   -9759l,  -10079l,
		  -10393l,  -10701l,  -11002l,  -11296l,
		  -11584l,  -11865l,  -12139l,  -12405l,
		  -12664l,  -12915l,  -13159l,  -13394l,
		  -13622l,  -13841l,  -14052l,  -14255l,
		  -14448l,  -14634l,  -14810l,  -14977l,
		  -15136l,  -15285l,  -15425l,  -15556l,
		  -15678l,  -15790l,  -15892l,  -15985l,
		  -16068l,  -16142l,  -16206l,  -16260l,
		  -16304l,  -16339l,  -16363l,  -16378l,
		  -16383l,
};

#endif

#endif

/*** End of inlined file: lookup_data.h ***/

#ifdef FLOAT_LOOKUP

/* interpolated lookup based cos function, domain 0 to PI only */
float vorbis_coslook(float a){
  double d=a*(.31830989*(float)COS_LOOKUP_SZ);
  int i=vorbis_ftoi(d-.5);

  return COS_LOOKUP[i]+ (d-i)*(COS_LOOKUP[i+1]-COS_LOOKUP[i]);
}

/* interpolated 1./sqrt(p) where .5 <= p < 1. */
float vorbis_invsqlook(float a){
  double d=a*(2.f*(float)INVSQ_LOOKUP_SZ)-(float)INVSQ_LOOKUP_SZ;
  int i=vorbis_ftoi(d-.5f);
  return INVSQ_LOOKUP[i]+ (d-i)*(INVSQ_LOOKUP[i+1]-INVSQ_LOOKUP[i]);
}

/* interpolated 1./sqrt(p) where .5 <= p < 1. */
float vorbis_invsq2explook(int a){
  return INVSQ2EXP_LOOKUP[a-INVSQ2EXP_LOOKUP_MIN];
}

#include <stdio.h>
/* interpolated lookup based fromdB function, domain -140dB to 0dB only */
float vorbis_fromdBlook(float a){
  int i=vorbis_ftoi(a*((float)(-(1<<FROMdB2_SHIFT)))-.5f);
  return (i<0)?1.f:
	((i>=(FROMdB_LOOKUP_SZ<<FROMdB_SHIFT))?0.f:
	 FROMdB_LOOKUP[i>>FROMdB_SHIFT]*FROMdB2_LOOKUP[i&FROMdB2_MASK]);
}

#endif

#ifdef INT_LOOKUP
/* interpolated 1./sqrt(p) where .5 <= a < 1. (.100000... to .111111...) in
   16.16 format

   returns in m.8 format */
long vorbis_invsqlook_i(long a,long e){
  long i=(a&0x7fff)>>(INVSQ_LOOKUP_I_SHIFT-1);
  long d=(a&INVSQ_LOOKUP_I_MASK)<<(16-INVSQ_LOOKUP_I_SHIFT); /*  0.16 */
  long val=INVSQ_LOOKUP_I[i]-                                /*  1.16 */
	(((INVSQ_LOOKUP_I[i]-INVSQ_LOOKUP_I[i+1])*               /*  0.16 */
	  d)>>16);                                               /* result 1.16 */

  e+=32;
  if(e&1)val=(val*5792)>>13; /* multiply val by 1/sqrt(2) */
  e=(e>>1)-8;

  return(val>>e);
}

/* interpolated lookup based fromdB function, domain -140dB to 0dB only */
/* a is in n.12 format */
float vorbis_fromdBlook_i(long a){
  int i=(-a)>>(12-FROMdB2_SHIFT);
  return (i<0)?1.f:
	((i>=(FROMdB_LOOKUP_SZ<<FROMdB_SHIFT))?0.f:
	 FROMdB_LOOKUP[i>>FROMdB_SHIFT]*FROMdB2_LOOKUP[i&FROMdB2_MASK]);
}

/* interpolated lookup based cos function, domain 0 to PI only */
/* a is in 0.16 format, where 0==0, 2^^16-1==PI, return 0.14 */
long vorbis_coslook_i(long a){
  int i=a>>COS_LOOKUP_I_SHIFT;
  int d=a&COS_LOOKUP_I_MASK;
  return COS_LOOKUP_I[i]- ((d*(COS_LOOKUP_I[i]-COS_LOOKUP_I[i+1]))>>
						   COS_LOOKUP_I_SHIFT);
}

#endif

/*** End of inlined file: lookup.c ***/


					   compilers (like gcc) that can't inline across
					   modules */

static const int MLOOP_1[64]={
   0,10,11,11, 12,12,12,12, 13,13,13,13, 13,13,13,13,
  14,14,14,14, 14,14,14,14, 14,14,14,14, 14,14,14,14,
  15,15,15,15, 15,15,15,15, 15,15,15,15, 15,15,15,15,
  15,15,15,15, 15,15,15,15, 15,15,15,15, 15,15,15,15,
};

static const int MLOOP_2[64]={
  0,4,5,5, 6,6,6,6, 7,7,7,7, 7,7,7,7,
  8,8,8,8, 8,8,8,8, 8,8,8,8, 8,8,8,8,
  9,9,9,9, 9,9,9,9, 9,9,9,9, 9,9,9,9,
  9,9,9,9, 9,9,9,9, 9,9,9,9, 9,9,9,9,
};

static const int MLOOP_3[8]={0,1,2,2,3,3,3,3};

/* side effect: changes *lsp to cosines of lsp */
void vorbis_lsp_to_curve(float *curve,int *map,int n,int ln,float *lsp,int m,
							float amp,float ampoffset){

  /* 0 <= m < 256 */

  /* set up for using all int later */
  int i;
  int ampoffseti=rint(ampoffset*4096.f);
  int ampi=rint(amp*16.f);
  long *ilsp=(long*)alloca(m*sizeof(*ilsp));
  for(i=0;i<m;i++)ilsp[i]=vorbis_coslook_i(lsp[i]/M_PI*65536.f+.5f);

  i=0;
  while(i<n){
	int j,k=map[i];
	unsigned long pi=46341; /* 2**-.5 in 0.16 */
	unsigned long qi=46341;
	int qexp=0,shift;
	long wi=vorbis_coslook_i(k*65536/ln);

	qi*=labs(ilsp[0]-wi);
	pi*=labs(ilsp[1]-wi);

	for(j=3;j<m;j+=2){
	  if(!(shift=MLOOP_1[(pi|qi)>>25]))
		if(!(shift=MLOOP_2[(pi|qi)>>19]))
		  shift=MLOOP_3[(pi|qi)>>16];
	  qi=(qi>>shift)*labs(ilsp[j-1]-wi);
	  pi=(pi>>shift)*labs(ilsp[j]-wi);
	  qexp+=shift;
	}
	if(!(shift=MLOOP_1[(pi|qi)>>25]))
	  if(!(shift=MLOOP_2[(pi|qi)>>19]))
		shift=MLOOP_3[(pi|qi)>>16];

	/* pi,qi normalized collectively, both tracked using qexp */

	if(m&1){
	  /* odd order filter; slightly assymetric */
	  /* the last coefficient */
	  qi=(qi>>shift)*labs(ilsp[j-1]-wi);
	  pi=(pi>>shift)<<14;
	  qexp+=shift;

	  if(!(shift=MLOOP_1[(pi|qi)>>25]))
		if(!(shift=MLOOP_2[(pi|qi)>>19]))
		  shift=MLOOP_3[(pi|qi)>>16];

	  pi>>=shift;
	  qi>>=shift;
	  qexp+=shift-14*((m+1)>>1);

	  pi=((pi*pi)>>16);
	  qi=((qi*qi)>>16);
	  qexp=qexp*2+m;

	  pi*=(1<<14)-((wi*wi)>>14);
	  qi+=pi>>14;

	}else{
	  /* even order filter; still symmetric */

	  /* p*=p(1-w), q*=q(1+w), let normalization drift because it isn't
		 worth tracking step by step */

	  pi>>=shift;
	  qi>>=shift;
	  qexp+=shift-7*m;

	  pi=((pi*pi)>>16);
	  qi=((qi*qi)>>16);
	  qexp=qexp*2+m;

	  pi*=(1<<14)-wi;
	  qi*=(1<<14)+wi;
	  qi=(qi+pi)>>14;

	}

	/* we've let the normalization drift because it wasn't important;
	   however, for the lookup, things must be normalized again.  We
	   need at most one right shift or a number of left shifts */

	if(qi&0xffff0000){ /* checks for 1.xxxxxxxxxxxxxxxx */
	  qi>>=1; qexp++;
	}else
	  while(qi && !(qi&0x8000)){ /* checks for 0.0xxxxxxxxxxxxxxx or less*/
		qi<<=1; qexp--;
	  }

	amp=vorbis_fromdBlook_i(ampi*                     /*  n.4         */
							vorbis_invsqlook_i(qi,qexp)-
													  /*  m.8, m+n<=8 */
							ampoffseti);              /*  8.12[0]     */

	curve[i]*=amp;
	while(map[++i]==k)curve[i]*=amp;
  }
}

#else

/* old, nonoptimized but simple version for any poor sap who needs to
   figure out what the hell this code does, or wants the other
   fraction of a dB precision */

/* side effect: changes *lsp to cosines of lsp */
void vorbis_lsp_to_curve(float *curve,int *map,int n,int ln,float *lsp,int m,
							float amp,float ampoffset){
  int i;
  float wdel=M_PI/ln;
  for(i=0;i<m;i++)lsp[i]=2.f*cos(lsp[i]);

  i=0;
  while(i<n){
	int j,k=map[i];
	float p=.5f;
	float q=.5f;
	float w=2.f*cos(wdel*k);
	for(j=1;j<m;j+=2){
	  q *= w-lsp[j-1];
	  p *= w-lsp[j];
	}
	if(j==m){
	  /* odd order filter; slightly assymetric */
	  /* the last coefficient */
	  q*=w-lsp[j-1];
	  p*=p*(4.f-w*w);
	  q*=q;
	}else{
	  /* even order filter; still symmetric */
	  p*=p*(2.f-w);
	  q*=q*(2.f+w);
	}

	q=fromdB(amp/sqrt(p+q)-ampoffset);

	curve[i]*=q;
	while(map[++i]==k)curve[i]*=q;
  }
}

#endif
#endif

static void cheby(float *g, int ord) {
  int i, j;

  g[0] *= .5f;
  for(i=2; i<= ord; i++) {
	for(j=ord; j >= i; j--) {
	  g[j-2] -= g[j];
	  g[j] += g[j];
	}
  }
}

static int JUCE_CDECL comp(const void *a,const void *b){
  return (*(float *)a<*(float *)b)-(*(float *)a>*(float *)b);
}

/* Newton-Raphson-Maehly actually functioned as a decent root finder,
   but there are root sets for which it gets into limit cycles
   (exacerbated by zero suppression) and fails.  We can't afford to
   fail, even if the failure is 1 in 100,000,000, so we now use
   Laguerre and later polish with Newton-Raphson (which can then
   afford to fail) */

#define EPSILON 10e-7
static int Laguerre_With_Deflation(float *a,int ord,float *r){
  int i,m;
  double lastdelta=0.f;
  double *defl=(double*)alloca(sizeof(*defl)*(ord+1));
  for(i=0;i<=ord;i++)defl[i]=a[i];

  for(m=ord;m>0;m--){
	double newx=0.f,delta;

	/* iterate a root */
	while(1){
	  double p=defl[m],pp=0.f,ppp=0.f,denom;

	  /* eval the polynomial and its first two derivatives */
	  for(i=m;i>0;i--){
	ppp = newx*ppp + pp;
	pp  = newx*pp  + p;
	p   = newx*p   + defl[i-1];
	  }

	  /* Laguerre's method */
	  denom=(m-1) * ((m-1)*pp*pp - m*p*ppp);
	  if(denom<0)
		return(-1);  /* complex root!  The LPC generator handed us a bad filter */

	  if(pp>0){
		denom = pp + sqrt(denom);
		if(denom<EPSILON)denom=EPSILON;
	  }else{
		denom = pp - sqrt(denom);
		if(denom>-(EPSILON))denom=-(EPSILON);
	  }

	  delta  = m*p/denom;
	  newx   -= delta;

	  if(delta<0.f)delta*=-1;

	  if(fabs(delta/newx)<10e-12)break;
	  lastdelta=delta;
	}

	r[m-1]=newx;

	/* forward deflation */

	for(i=m;i>0;i--)
	  defl[i-1]+=newx*defl[i];
	defl++;

  }
  return(0);
}

/* for spit-and-polish only */
static int Newton_Raphson(float *a,int ord,float *r){
  int i, k, count=0;
  double error=1.f;
  double *root=(double*)alloca(ord*sizeof(*root));

  for(i=0; i<ord;i++) root[i] = r[i];

  while(error>1e-20){
	error=0;

	for(i=0; i<ord; i++) { /* Update each point. */
	  double pp=0.,delta;
	  double rooti=root[i];
	  double p=a[ord];
	  for(k=ord-1; k>= 0; k--) {

		pp= pp* rooti + p;
		p = p * rooti + a[k];
	  }

	  delta = p/pp;
	  root[i] -= delta;
	  error+= delta*delta;
	}

	if(count>40)return(-1);

	count++;
  }

  /* Replaced the original bubble sort with a real sort.  With your
	 help, we can eliminate the bubble sort in our lifetime. --Monty */

  for(i=0; i<ord;i++) r[i] = root[i];
  return(0);
}

/* Convert lpc coefficients to lsp coefficients */
int vorbis_lpc_to_lsp(float *lpc,float *lsp,int m){
  int order2=(m+1)>>1;
  int g1_order,g2_order;
  float *g1=(float*)alloca(sizeof(*g1)*(order2+1));
  float *g2=(float*)alloca(sizeof(*g2)*(order2+1));
  float *g1r=(float*)alloca(sizeof(*g1r)*(order2+1));
  float *g2r=(float*)alloca(sizeof(*g2r)*(order2+1));
  int i;

  /* even and odd are slightly different base cases */
  g1_order=(m+1)>>1;
  g2_order=(m)  >>1;

  /* Compute the lengths of the x polynomials. */
  /* Compute the first half of K & R F1 & F2 polynomials. */
  /* Compute half of the symmetric and antisymmetric polynomials. */
  /* Remove the roots at +1 and -1. */

  g1[g1_order] = 1.f;
  for(i=1;i<=g1_order;i++) g1[g1_order-i] = lpc[i-1]+lpc[m-i];
  g2[g2_order] = 1.f;
  for(i=1;i<=g2_order;i++) g2[g2_order-i] = lpc[i-1]-lpc[m-i];

  if(g1_order>g2_order){
	for(i=2; i<=g2_order;i++) g2[g2_order-i] += g2[g2_order-i+2];
  }else{
	for(i=1; i<=g1_order;i++) g1[g1_order-i] -= g1[g1_order-i+1];
	for(i=1; i<=g2_order;i++) g2[g2_order-i] += g2[g2_order-i+1];
  }

  /* Convert into polynomials in cos(alpha) */
  cheby(g1,g1_order);
  cheby(g2,g2_order);

  /* Find the roots of the 2 even polynomials.*/
  if(Laguerre_With_Deflation(g1,g1_order,g1r) ||
	 Laguerre_With_Deflation(g2,g2_order,g2r))
	return(-1);

  Newton_Raphson(g1,g1_order,g1r); /* if it fails, it leaves g1r alone */
  Newton_Raphson(g2,g2_order,g2r); /* if it fails, it leaves g2r alone */

  qsort(g1r,g1_order,sizeof(*g1r),comp);
  qsort(g2r,g2_order,sizeof(*g2r),comp);

  for(i=0;i<g1_order;i++)
	lsp[i*2] = acos(g1r[i]);

  for(i=0;i<g2_order;i++)
	lsp[i*2+1] = acos(g2r[i]);
  return(0);
}

/*** End of inlined file: lsp.c ***/


/*** Start of inlined file: mapping0.c ***/
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>

/* simplistic, wasteful way of doing this (unique lookup for each
   mode/submapping); there should be a central repository for
   identical lookups.  That will require minor work, so I'm putting it
   off as low priority.

   Why a lookup for each backend in a given mode?  Because the
   blocksize is set by the mode, and low backend lookups may require
   parameters from other areas of the mode/mapping */

static void mapping0_free_info(vorbis_info_mapping *i){
  vorbis_info_mapping0 *info=(vorbis_info_mapping0 *)i;
  if(info){
	memset(info,0,sizeof(*info));
	_ogg_free(info);
  }
}

static int ilog3(unsigned int v){
  int ret=0;
  if(v)--v;
  while(v){
	ret++;
	v>>=1;
  }
  return(ret);
}

static void mapping0_pack(vorbis_info *vi,vorbis_info_mapping *vm,
						  oggpack_buffer *opb){
  int i;
  vorbis_info_mapping0 *info=(vorbis_info_mapping0 *)vm;

  /* another 'we meant to do it this way' hack...  up to beta 4, we
	 packed 4 binary zeros here to signify one submapping in use.  We
	 now redefine that to mean four bitflags that indicate use of
	 deeper features; bit0:submappings, bit1:coupling,
	 bit2,3:reserved. This is backward compatable with all actual uses
	 of the beta code. */

  if(info->submaps>1){
	oggpack_write(opb,1,1);
	oggpack_write(opb,info->submaps-1,4);
  }else
	oggpack_write(opb,0,1);

  if(info->coupling_steps>0){
	oggpack_write(opb,1,1);
	oggpack_write(opb,info->coupling_steps-1,8);

	for(i=0;i<info->coupling_steps;i++){
	  oggpack_write(opb,info->coupling_mag[i],ilog3(vi->channels));
	  oggpack_write(opb,info->coupling_ang[i],ilog3(vi->channels));
	}
  }else
	oggpack_write(opb,0,1);

  oggpack_write(opb,0,2); /* 2,3:reserved */

  /* we don't write the channel submappings if we only have one... */
  if(info->submaps>1){
	for(i=0;i<vi->channels;i++)
	  oggpack_write(opb,info->chmuxlist[i],4);
  }
  for(i=0;i<info->submaps;i++){
	oggpack_write(opb,0,8); /* time submap unused */
	oggpack_write(opb,info->floorsubmap[i],8);
	oggpack_write(opb,info->residuesubmap[i],8);
  }
}

/* also responsible for range checking */
static vorbis_info_mapping *mapping0_unpack(vorbis_info *vi,oggpack_buffer *opb){
  int i,b;
  vorbis_info_mapping0 *info=(vorbis_info_mapping0*)_ogg_calloc(1,sizeof(*info));
  codec_setup_info     *ci=(codec_setup_info*)vi->codec_setup;
  memset(info,0,sizeof(*info));

  b=oggpack_read(opb,1);
  if(b<0)goto err_out;
  if(b){
	info->submaps=oggpack_read(opb,4)+1;
	if(info->submaps<=0)goto err_out;
  }else
	info->submaps=1;

  b=oggpack_read(opb,1);
  if(b<0)goto err_out;
  if(b){
	info->coupling_steps=oggpack_read(opb,8)+1;
	if(info->coupling_steps<=0)goto err_out;
	for(i=0;i<info->coupling_steps;i++){
	  int testM=info->coupling_mag[i]=oggpack_read(opb,ilog3(vi->channels));
	  int testA=info->coupling_ang[i]=oggpack_read(opb,ilog3(vi->channels));

	  if(testM<0 ||
		 testA<0 ||
		 testM==testA ||
		 testM>=vi->channels ||
		 testA>=vi->channels) goto err_out;
	}

  }

  if(oggpack_read(opb,2)!=0)goto err_out; /* 2,3:reserved */

  if(info->submaps>1){
	for(i=0;i<vi->channels;i++){
	  info->chmuxlist[i]=oggpack_read(opb,4);
	  if(info->chmuxlist[i]>=info->submaps || info->chmuxlist[i]<0)goto err_out;
	}
  }
  for(i=0;i<info->submaps;i++){
	oggpack_read(opb,8); /* time submap unused */
	info->floorsubmap[i]=oggpack_read(opb,8);
	if(info->floorsubmap[i]>=ci->floors || info->floorsubmap[i]<0)goto err_out;
	info->residuesubmap[i]=oggpack_read(opb,8);
	if(info->residuesubmap[i]>=ci->residues || info->residuesubmap[i]<0)goto err_out;
  }

  return info;

 err_out:
  mapping0_free_info(info);
  return(NULL);
}

#if 0
static long seq=0;
static ogg_int64_t total=0;
static float FLOOR1_fromdB_LOOKUP[256]={
  1.0649863e-07F, 1.1341951e-07F, 1.2079015e-07F, 1.2863978e-07F,
  1.3699951e-07F, 1.4590251e-07F, 1.5538408e-07F, 1.6548181e-07F,
  1.7623575e-07F, 1.8768855e-07F, 1.9988561e-07F, 2.128753e-07F,
  2.2670913e-07F, 2.4144197e-07F, 2.5713223e-07F, 2.7384213e-07F,
  2.9163793e-07F, 3.1059021e-07F, 3.3077411e-07F, 3.5226968e-07F,
  3.7516214e-07F, 3.9954229e-07F, 4.2550680e-07F, 4.5315863e-07F,
  4.8260743e-07F, 5.1396998e-07F, 5.4737065e-07F, 5.8294187e-07F,
  6.2082472e-07F, 6.6116941e-07F, 7.0413592e-07F, 7.4989464e-07F,
  7.9862701e-07F, 8.5052630e-07F, 9.0579828e-07F, 9.6466216e-07F,
  1.0273513e-06F, 1.0941144e-06F, 1.1652161e-06F, 1.2409384e-06F,
  1.3215816e-06F, 1.4074654e-06F, 1.4989305e-06F, 1.5963394e-06F,
  1.7000785e-06F, 1.8105592e-06F, 1.9282195e-06F, 2.0535261e-06F,
  2.1869758e-06F, 2.3290978e-06F, 2.4804557e-06F, 2.6416497e-06F,
  2.8133190e-06F, 2.9961443e-06F, 3.1908506e-06F, 3.3982101e-06F,
  3.6190449e-06F, 3.8542308e-06F, 4.1047004e-06F, 4.3714470e-06F,
  4.6555282e-06F, 4.9580707e-06F, 5.2802740e-06F, 5.6234160e-06F,
  5.9888572e-06F, 6.3780469e-06F, 6.7925283e-06F, 7.2339451e-06F,
  7.7040476e-06F, 8.2047000e-06F, 8.7378876e-06F, 9.3057248e-06F,
  9.9104632e-06F, 1.0554501e-05F, 1.1240392e-05F, 1.1970856e-05F,
  1.2748789e-05F, 1.3577278e-05F, 1.4459606e-05F, 1.5399272e-05F,
  1.6400004e-05F, 1.7465768e-05F, 1.8600792e-05F, 1.9809576e-05F,
  2.1096914e-05F, 2.2467911e-05F, 2.3928002e-05F, 2.5482978e-05F,
  2.7139006e-05F, 2.8902651e-05F, 3.0780908e-05F, 3.2781225e-05F,
  3.4911534e-05F, 3.7180282e-05F, 3.9596466e-05F, 4.2169667e-05F,
  4.4910090e-05F, 4.7828601e-05F, 5.0936773e-05F, 5.4246931e-05F,
  5.7772202e-05F, 6.1526565e-05F, 6.5524908e-05F, 6.9783085e-05F,
  7.4317983e-05F, 7.9147585e-05F, 8.4291040e-05F, 8.9768747e-05F,
  9.5602426e-05F, 0.00010181521F, 0.00010843174F, 0.00011547824F,
  0.00012298267F, 0.00013097477F, 0.00013948625F, 0.00014855085F,
  0.00015820453F, 0.00016848555F, 0.00017943469F, 0.00019109536F,
  0.00020351382F, 0.00021673929F, 0.00023082423F, 0.00024582449F,
  0.00026179955F, 0.00027881276F, 0.00029693158F, 0.00031622787F,
  0.00033677814F, 0.00035866388F, 0.00038197188F, 0.00040679456F,
  0.00043323036F, 0.00046138411F, 0.00049136745F, 0.00052329927F,
  0.00055730621F, 0.00059352311F, 0.00063209358F, 0.00067317058F,
  0.00071691700F, 0.00076350630F, 0.00081312324F, 0.00086596457F,
  0.00092223983F, 0.00098217216F, 0.0010459992F, 0.0011139742F,
  0.0011863665F, 0.0012634633F, 0.0013455702F, 0.0014330129F,
  0.0015261382F, 0.0016253153F, 0.0017309374F, 0.0018434235F,
  0.0019632195F, 0.0020908006F, 0.0022266726F, 0.0023713743F,
  0.0025254795F, 0.0026895994F, 0.0028643847F, 0.0030505286F,
  0.0032487691F, 0.0034598925F, 0.0036847358F, 0.0039241906F,
  0.0041792066F, 0.0044507950F, 0.0047400328F, 0.0050480668F,
  0.0053761186F, 0.0057254891F, 0.0060975636F, 0.0064938176F,
  0.0069158225F, 0.0073652516F, 0.0078438871F, 0.0083536271F,
  0.0088964928F, 0.009474637F, 0.010090352F, 0.010746080F,
  0.011444421F, 0.012188144F, 0.012980198F, 0.013823725F,
  0.014722068F, 0.015678791F, 0.016697687F, 0.017782797F,
  0.018938423F, 0.020169149F, 0.021479854F, 0.022875735F,
  0.024362330F, 0.025945531F, 0.027631618F, 0.029427276F,
  0.031339626F, 0.033376252F, 0.035545228F, 0.037855157F,
  0.040315199F, 0.042935108F, 0.045725273F, 0.048696758F,
  0.051861348F, 0.055231591F, 0.058820850F, 0.062643361F,
  0.066714279F, 0.071049749F, 0.075666962F, 0.080584227F,
  0.085821044F, 0.091398179F, 0.097337747F, 0.10366330F,
  0.11039993F, 0.11757434F, 0.12521498F, 0.13335215F,
  0.14201813F, 0.15124727F, 0.16107617F, 0.17154380F,
  0.18269168F, 0.19456402F, 0.20720788F, 0.22067342F,
  0.23501402F, 0.25028656F, 0.26655159F, 0.28387361F,
  0.30232132F, 0.32196786F, 0.34289114F, 0.36517414F,
  0.38890521F, 0.41417847F, 0.44109412F, 0.46975890F,
  0.50028648F, 0.53279791F, 0.56742212F, 0.60429640F,
  0.64356699F, 0.68538959F, 0.72993007F, 0.77736504F,
  0.82788260F, 0.88168307F, 0.9389798F, 1.F,
};

#endif

static int mapping0_forward(vorbis_block *vb){
  vorbis_dsp_state      *vd=vb->vd;
  vorbis_info           *vi=vd->vi;
  codec_setup_info      *ci=(codec_setup_info*)vi->codec_setup;
  private_state         *b=(private_state*)vb->vd->backend_state;
  vorbis_block_internal *vbi=(vorbis_block_internal *)vb->internal;
  int                    n=vb->pcmend;
  int i,j,k;

  int    *nonzero    = (int*)alloca(sizeof(*nonzero)*vi->channels);
  float  **gmdct     = (float**)_vorbis_block_alloc(vb,vi->channels*sizeof(*gmdct));
  int    **iwork      = (int**)_vorbis_block_alloc(vb,vi->channels*sizeof(*iwork));
  int ***floor_posts = (int***)_vorbis_block_alloc(vb,vi->channels*sizeof(*floor_posts));

  float global_ampmax=vbi->ampmax;
  float *local_ampmax=(float*)alloca(sizeof(*local_ampmax)*vi->channels);
  int blocktype=vbi->blocktype;

  int modenumber=vb->W;
  vorbis_info_mapping0 *info=(vorbis_info_mapping0*)ci->map_param[modenumber];
  vorbis_look_psy *psy_look=b->psy+blocktype+(vb->W?2:0);

  vb->mode=modenumber;

  for(i=0;i<vi->channels;i++){
	float scale=4.f/n;
	float scale_dB;

	float *pcm     =vb->pcm[i];
	float *logfft  =pcm;

	iwork[i]=(int*)_vorbis_block_alloc(vb,n/2*sizeof(**iwork));
	gmdct[i]=(float*)_vorbis_block_alloc(vb,n/2*sizeof(**gmdct));

	scale_dB=todB(&scale) + .345; /* + .345 is a hack; the original
									 todB estimation used on IEEE 754
									 compliant machines had a bug that
									 returned dB values about a third
									 of a decibel too high.  The bug
									 was harmless because tunings
									 implicitly took that into
									 account.  However, fixing the bug
									 in the estimator requires
									 changing all the tunings as well.
									 For now, it's easier to sync
									 things back up here, and
									 recalibrate the tunings in the
									 next major model upgrade. */

#if 0
	if(vi->channels==2){
	  if(i==0)
		_analysis_output("pcmL",seq,pcm,n,0,0,total-n/2);
	  else
		_analysis_output("pcmR",seq,pcm,n,0,0,total-n/2);
	}else{
	  _analysis_output("pcm",seq,pcm,n,0,0,total-n/2);
	}
#endif

	/* window the PCM data */
	_vorbis_apply_window(pcm,b->window,ci->blocksizes,vb->lW,vb->W,vb->nW);

#if 0
	if(vi->channels==2){
	  if(i==0)
		_analysis_output("windowedL",seq,pcm,n,0,0,total-n/2);
	  else
		_analysis_output("windowedR",seq,pcm,n,0,0,total-n/2);
	}else{
	  _analysis_output("windowed",seq,pcm,n,0,0,total-n/2);
	}
#endif

	/* transform the PCM data */
	/* only MDCT right now.... */
	mdct_forward((mdct_lookup*) b->transform[vb->W][0],pcm,gmdct[i]);

	/* FFT yields more accurate tonal estimation (not phase sensitive) */
	drft_forward(&b->fft_look[vb->W],pcm);
	logfft[0]=scale_dB+todB(pcm)  + .345; /* + .345 is a hack; the
									 original todB estimation used on
									 IEEE 754 compliant machines had a
									 bug that returned dB values about
									 a third of a decibel too high.
									 The bug was harmless because
									 tunings implicitly took that into
									 account.  However, fixing the bug
									 in the estimator requires
									 changing all the tunings as well.
									 For now, it's easier to sync
									 things back up here, and
									 recalibrate the tunings in the
									 next major model upgrade. */
	local_ampmax[i]=logfft[0];
	for(j=1;j<n-1;j+=2){
	  float temp=pcm[j]*pcm[j]+pcm[j+1]*pcm[j+1];
	  temp=logfft[(j+1)>>1]=scale_dB+.5f*todB(&temp)  + .345; /* +
									 .345 is a hack; the original todB
									 estimation used on IEEE 754
									 compliant machines had a bug that
									 returned dB values about a third
									 of a decibel too high.  The bug
									 was harmless because tunings
									 implicitly took that into
									 account.  However, fixing the bug
									 in the estimator requires
									 changing all the tunings as well.
									 For now, it's easier to sync
									 things back up here, and
									 recalibrate the tunings in the
									 next major model upgrade. */
	  if(temp>local_ampmax[i])local_ampmax[i]=temp;
	}

	if(local_ampmax[i]>0.f)local_ampmax[i]=0.f;
	if(local_ampmax[i]>global_ampmax)global_ampmax=local_ampmax[i];

#if 0
	if(vi->channels==2){
	  if(i==0){
		_analysis_output("fftL",seq,logfft,n/2,1,0,0);
	  }else{
		_analysis_output("fftR",seq,logfft,n/2,1,0,0);
	  }
	}else{
	  _analysis_output("fft",seq,logfft,n/2,1,0,0);
	}
#endif

  }

  {
	float   *noise        = (float*)_vorbis_block_alloc(vb,n/2*sizeof(*noise));
	float   *tone         = (float*)_vorbis_block_alloc(vb,n/2*sizeof(*tone));

	for(i=0;i<vi->channels;i++){
	  /* the encoder setup assumes that all the modes used by any
		 specific bitrate tweaking use the same floor */

	  int submap=info->chmuxlist[i];

	  /* the following makes things clearer to *me* anyway */
	  float *mdct    =gmdct[i];
	  float *logfft  =vb->pcm[i];

	  float *logmdct =logfft+n/2;
	  float *logmask =logfft;

	  vb->mode=modenumber;

	  floor_posts[i]=(int**)_vorbis_block_alloc(vb,PACKETBLOBS*sizeof(**floor_posts));
	  memset(floor_posts[i],0,sizeof(**floor_posts)*PACKETBLOBS);

	  for(j=0;j<n/2;j++)
		logmdct[j]=todB(mdct+j)  + .345; /* + .345 is a hack; the original
									 todB estimation used on IEEE 754
									 compliant machines had a bug that
									 returned dB values about a third
									 of a decibel too high.  The bug
									 was harmless because tunings
									 implicitly took that into
									 account.  However, fixing the bug
									 in the estimator requires
									 changing all the tunings as well.
									 For now, it's easier to sync
									 things back up here, and
									 recalibrate the tunings in the
									 next major model upgrade. */

#if 0
	  if(vi->channels==2){
		if(i==0)
		  _analysis_output("mdctL",seq,logmdct,n/2,1,0,0);
		else
		  _analysis_output("mdctR",seq,logmdct,n/2,1,0,0);
	  }else{
		_analysis_output("mdct",seq,logmdct,n/2,1,0,0);
	  }
#endif

	  /* first step; noise masking.  Not only does 'noise masking'
		 give us curves from which we can decide how much resolution
		 to give noise parts of the spectrum, it also implicitly hands
		 us a tonality estimate (the larger the value in the
		 'noise_depth' vector, the more tonal that area is) */

	  _vp_noisemask(psy_look,
					logmdct,
					noise); /* noise does not have by-frequency offset
							   bias applied yet */
#if 0
	  if(vi->channels==2){
		if(i==0)
		  _analysis_output("noiseL",seq,noise,n/2,1,0,0);
		else
		  _analysis_output("noiseR",seq,noise,n/2,1,0,0);
	  }else{
		_analysis_output("noise",seq,noise,n/2,1,0,0);
	  }
#endif

	  /* second step: 'all the other crap'; all the stuff that isn't
		 computed/fit for bitrate management goes in the second psy
		 vector.  This includes tone masking, peak limiting and ATH */

	  _vp_tonemask(psy_look,
				   logfft,
				   tone,
				   global_ampmax,
				   local_ampmax[i]);

#if 0
	  if(vi->channels==2){
		if(i==0)
		  _analysis_output("toneL",seq,tone,n/2,1,0,0);
		else
		  _analysis_output("toneR",seq,tone,n/2,1,0,0);
	  }else{
		_analysis_output("tone",seq,tone,n/2,1,0,0);
	  }
#endif

	  /* third step; we offset the noise vectors, overlay tone
		 masking.  We then do a floor1-specific line fit.  If we're
		 performing bitrate management, the line fit is performed
		 multiple times for up/down tweakage on demand. */

#if 0
	  {
	  float aotuv[psy_look->n];
#endif

		_vp_offset_and_mix(psy_look,
						   noise,
						   tone,
						   1,
						   logmask,
						   mdct,
						   logmdct);

#if 0
		if(vi->channels==2){
		  if(i==0)
			_analysis_output("aotuvM1_L",seq,aotuv,psy_look->n,1,1,0);
		  else
			_analysis_output("aotuvM1_R",seq,aotuv,psy_look->n,1,1,0);
		}else{
		  _analysis_output("aotuvM1",seq,aotuv,psy_look->n,1,1,0);
		}
	  }
#endif

#if 0
	  if(vi->channels==2){
		if(i==0)
		  _analysis_output("mask1L",seq,logmask,n/2,1,0,0);
		else
		  _analysis_output("mask1R",seq,logmask,n/2,1,0,0);
	  }else{
		_analysis_output("mask1",seq,logmask,n/2,1,0,0);
	  }
#endif

	  /* this algorithm is hardwired to floor 1 for now; abort out if
		 we're *not* floor1.  This won't happen unless someone has
		 broken the encode setup lib.  Guard it anyway. */
	  if(ci->floor_type[info->floorsubmap[submap]]!=1)return(-1);

	  floor_posts[i][PACKETBLOBS/2]=
		floor1_fit(vb,(vorbis_look_floor1*)(b->flr[info->floorsubmap[submap]]),
				   logmdct,
				   logmask);

	  /* are we managing bitrate?  If so, perform two more fits for
		 later rate tweaking (fits represent hi/lo) */
	  if(vorbis_bitrate_managed(vb) && floor_posts[i][PACKETBLOBS/2]){
		/* higher rate by way of lower noise curve */

		_vp_offset_and_mix(psy_look,
						   noise,
						   tone,
						   2,
						   logmask,
						   mdct,
						   logmdct);

#if 0
		if(vi->channels==2){
		  if(i==0)
			_analysis_output("mask2L",seq,logmask,n/2,1,0,0);
		  else
			_analysis_output("mask2R",seq,logmask,n/2,1,0,0);
		}else{
		  _analysis_output("mask2",seq,logmask,n/2,1,0,0);
		}
#endif

		floor_posts[i][PACKETBLOBS-1]=
		  floor1_fit(vb,(vorbis_look_floor1*)(b->flr[info->floorsubmap[submap]]),
					 logmdct,
					 logmask);

		/* lower rate by way of higher noise curve */
		_vp_offset_and_mix(psy_look,
						   noise,
						   tone,
						   0,
						   logmask,
						   mdct,
						   logmdct);

#if 0
		if(vi->channels==2){
		  if(i==0)
			_analysis_output("mask0L",seq,logmask,n/2,1,0,0);
		  else
			_analysis_output("mask0R",seq,logmask,n/2,1,0,0);
		}else{
		  _analysis_output("mask0",seq,logmask,n/2,1,0,0);
		}
#endif

		floor_posts[i][0]=
		  floor1_fit(vb,(vorbis_look_floor1*)(b->flr[info->floorsubmap[submap]]),
					 logmdct,
					 logmask);

		/* we also interpolate a range of intermediate curves for
		   intermediate rates */
		for(k=1;k<PACKETBLOBS/2;k++)
		  floor_posts[i][k]=
			floor1_interpolate_fit(vb,(vorbis_look_floor1*)(b->flr[info->floorsubmap[submap]]),
								   floor_posts[i][0],
								   floor_posts[i][PACKETBLOBS/2],
								   k*65536/(PACKETBLOBS/2));
		for(k=PACKETBLOBS/2+1;k<PACKETBLOBS-1;k++)
		  floor_posts[i][k]=
			floor1_interpolate_fit(vb,(vorbis_look_floor1*)(b->flr[info->floorsubmap[submap]]),
								   floor_posts[i][PACKETBLOBS/2],
								   floor_posts[i][PACKETBLOBS-1],
								   (k-PACKETBLOBS/2)*65536/(PACKETBLOBS/2));
	  }
	}
  }
  vbi->ampmax=global_ampmax;

  /*
	the next phases are performed once for vbr-only and PACKETBLOB
	times for bitrate managed modes.

	1) encode actual mode being used
	2) encode the floor for each channel, compute coded mask curve/res
	3) normalize and couple.
	4) encode residue
	5) save packet bytes to the packetblob vector

  */

  /* iterate over the many masking curve fits we've created */

  {
	int **couple_bundle=(int**)alloca(sizeof(*couple_bundle)*vi->channels);
	int *zerobundle=(int*)alloca(sizeof(*zerobundle)*vi->channels);

	for(k=(vorbis_bitrate_managed(vb)?0:PACKETBLOBS/2);
		k<=(vorbis_bitrate_managed(vb)?PACKETBLOBS-1:PACKETBLOBS/2);
		k++){
	  oggpack_buffer *opb=vbi->packetblob[k];

	  /* start out our new packet blob with packet type and mode */
	  /* Encode the packet type */
	  oggpack_write(opb,0,1);
	  /* Encode the modenumber */
	  /* Encode frame mode, pre,post windowsize, then dispatch */
	  oggpack_write(opb,modenumber,b->modebits);
	  if(vb->W){
		oggpack_write(opb,vb->lW,1);
		oggpack_write(opb,vb->nW,1);
	  }

	  /* encode floor, compute masking curve, sep out residue */
	  for(i=0;i<vi->channels;i++){
		int submap=info->chmuxlist[i];
		int *ilogmask=iwork[i];

		nonzero[i]=floor1_encode(opb,vb,(vorbis_look_floor1*)(b->flr[info->floorsubmap[submap]]),
								 floor_posts[i][k],
								 ilogmask);
#if 0
		{
		  char buf[80];
		  sprintf(buf,"maskI%c%d",i?'R':'L',k);
		  float work[n/2];
		  for(j=0;j<n/2;j++)
			work[j]=FLOOR1_fromdB_LOOKUP[iwork[i][j]];
		  _analysis_output(buf,seq,work,n/2,1,1,0);
		}
#endif
	  }

	  /* our iteration is now based on masking curve, not prequant and
		 coupling.  Only one prequant/coupling step */

	  /* quantize/couple */
	  /* incomplete implementation that assumes the tree is all depth
		 one, or no tree at all */
	  _vp_couple_quantize_normalize(k,
									&ci->psy_g_param,
									psy_look,
									info,
									gmdct,
									iwork,
									nonzero,
									ci->psy_g_param.sliding_lowpass[vb->W][k],
									vi->channels);

#if 0
	  for(i=0;i<vi->channels;i++){
		char buf[80];
		sprintf(buf,"res%c%d",i?'R':'L',k);
		float work[n/2];
		for(j=0;j<n/2;j++)
		  work[j]=iwork[i][j];
		_analysis_output(buf,seq,work,n/2,1,0,0);
	  }
#endif

	  /* classify and encode by submap */
	  for(i=0;i<info->submaps;i++){
		int ch_in_bundle=0;
		long **classifications;
		int resnum=info->residuesubmap[i];

		for(j=0;j<vi->channels;j++){
		  if(info->chmuxlist[j]==i){
			zerobundle[ch_in_bundle]=0;
			if(nonzero[j])zerobundle[ch_in_bundle]=1;
			couple_bundle[ch_in_bundle++]=iwork[j];
		  }
		}

		classifications=_residue_P[ci->residue_type[resnum]]->
		  classx(vb,b->residue[resnum],couple_bundle,zerobundle,ch_in_bundle);

		ch_in_bundle=0;
		for(j=0;j<vi->channels;j++)
		  if(info->chmuxlist[j]==i)
			couple_bundle[ch_in_bundle++]=iwork[j];

		_residue_P[ci->residue_type[resnum]]->
		  forward(opb,vb,b->residue[resnum],
				  couple_bundle,zerobundle,ch_in_bundle,classifications,i);
	  }

	  /* ok, done encoding.  Next protopacket. */
	}

  }

#if 0
  seq++;
  total+=ci->blocksizes[vb->W]/4+ci->blocksizes[vb->nW]/4;
#endif
  return(0);
}

static int mapping0_inverse(vorbis_block *vb,vorbis_info_mapping *l){
  vorbis_dsp_state     *vd=vb->vd;
  vorbis_info          *vi=vd->vi;
  codec_setup_info     *ci=(codec_setup_info*)vi->codec_setup;
  private_state        *b=(private_state*)vd->backend_state;
  vorbis_info_mapping0 *info=(vorbis_info_mapping0 *)l;

  int                   i,j;
  long                  n=vb->pcmend=ci->blocksizes[vb->W];

  float **pcmbundle=(float**) alloca(sizeof(*pcmbundle)*vi->channels);
  int    *zerobundle=(int*) alloca(sizeof(*zerobundle)*vi->channels);

  int   *nonzero  =(int*) alloca(sizeof(*nonzero)*vi->channels);
  void **floormemo=(void**) alloca(sizeof(*floormemo)*vi->channels);

  /* recover the spectral envelope; store it in the PCM vector for now */
  for(i=0;i<vi->channels;i++){
	int submap=info->chmuxlist[i];
	floormemo[i]=_floor_P[ci->floor_type[info->floorsubmap[submap]]]->
	  inverse1(vb,b->flr[info->floorsubmap[submap]]);
	if(floormemo[i])
	  nonzero[i]=1;
	else
	  nonzero[i]=0;
	memset(vb->pcm[i],0,sizeof(*vb->pcm[i])*n/2);
  }

  /* channel coupling can 'dirty' the nonzero listing */
  for(i=0;i<info->coupling_steps;i++){
	if(nonzero[info->coupling_mag[i]] ||
	   nonzero[info->coupling_ang[i]]){
	  nonzero[info->coupling_mag[i]]=1;
	  nonzero[info->coupling_ang[i]]=1;
	}
  }

  /* recover the residue into our working vectors */
  for(i=0;i<info->submaps;i++){
	int ch_in_bundle=0;
	for(j=0;j<vi->channels;j++){
	  if(info->chmuxlist[j]==i){
		if(nonzero[j])
		  zerobundle[ch_in_bundle]=1;
		else
		  zerobundle[ch_in_bundle]=0;
		pcmbundle[ch_in_bundle++]=vb->pcm[j];
	  }
	}

	_residue_P[ci->residue_type[info->residuesubmap[i]]]->
	  inverse(vb,b->residue[info->residuesubmap[i]],
			  pcmbundle,zerobundle,ch_in_bundle);
  }

  /* channel coupling */
  for(i=info->coupling_steps-1;i>=0;i--){
	float *pcmM=vb->pcm[info->coupling_mag[i]];
	float *pcmA=vb->pcm[info->coupling_ang[i]];

	for(j=0;j<n/2;j++){
	  float mag=pcmM[j];
	  float ang=pcmA[j];

	  if(mag>0)
		if(ang>0){
		  pcmM[j]=mag;
		  pcmA[j]=mag-ang;
		}else{
		  pcmA[j]=mag;
		  pcmM[j]=mag+ang;
		}
	  else
		if(ang>0){
		  pcmM[j]=mag;
		  pcmA[j]=mag+ang;
		}else{
		  pcmA[j]=mag;
		  pcmM[j]=mag-ang;
		}
	}
  }

  /* compute and apply spectral envelope */
  for(i=0;i<vi->channels;i++){
	float *pcm=vb->pcm[i];
	int submap=info->chmuxlist[i];
	_floor_P[ci->floor_type[info->floorsubmap[submap]]]->
	  inverse2(vb,b->flr[info->floorsubmap[submap]],
			   floormemo[i],pcm);
  }

  /* transform the PCM data; takes PCM vector, vb; modifies PCM vector */
  /* only MDCT right now.... */
  for(i=0;i<vi->channels;i++){
	float *pcm=vb->pcm[i];
	mdct_backward((mdct_lookup*) b->transform[vb->W][0],pcm,pcm);
  }

  /* all done! */
  return(0);
}

/* export hooks */
const vorbis_func_mapping mapping0_exportbundle={
  &mapping0_pack,
  &mapping0_unpack,
  &mapping0_free_info,
  &mapping0_forward,
  &mapping0_inverse
};

/*** End of inlined file: mapping0.c ***/


/*** Start of inlined file: mdct.c ***/
/* this can also be run as an integer transform by uncommenting a
   define in mdct.h; the integerization is a first pass and although
   it's likely stable for Vorbis, the dynamic range is constrained and
   roundoff isn't done (so it's noisy).  Consider it functional, but
   only a starting point.  There's no point on a machine with an FPU */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

/* build lookups for trig functions; also pre-figure scaling and
   some window function algebra. */

void mdct_init(mdct_lookup *lookup,int n){
  int   *bitrev=(int*) _ogg_malloc(sizeof(*bitrev)*(n/4));
  DATA_TYPE *T=(DATA_TYPE*) _ogg_malloc(sizeof(*T)*(n+n/4));

  int i;
  int n2=n>>1;
  int log2n=lookup->log2n=rint(log((float)n)/log(2.f));
  lookup->n=n;
  lookup->trig=T;
  lookup->bitrev=bitrev;

/* trig lookups... */

  for(i=0;i<n/4;i++){
	T[i*2]=FLOAT_CONV(cos((M_PI/n)*(4*i)));
	T[i*2+1]=FLOAT_CONV(-sin((M_PI/n)*(4*i)));
	T[n2+i*2]=FLOAT_CONV(cos((M_PI/(2*n))*(2*i+1)));
	T[n2+i*2+1]=FLOAT_CONV(sin((M_PI/(2*n))*(2*i+1)));
  }
  for(i=0;i<n/8;i++){
	T[n+i*2]=FLOAT_CONV(cos((M_PI/n)*(4*i+2))*.5);
	T[n+i*2+1]=FLOAT_CONV(-sin((M_PI/n)*(4*i+2))*.5);
  }

  /* bitreverse lookup... */

  {
	int mask=(1<<(log2n-1))-1,i,j;
	int msb=1<<(log2n-2);
	for(i=0;i<n/8;i++){
	  int acc=0;
	  for(j=0;msb>>j;j++)
		if((msb>>j)&i)acc|=1<<j;
	  bitrev[i*2]=((~acc)&mask)-1;
	  bitrev[i*2+1]=acc;

	}
  }
  lookup->scale=FLOAT_CONV(4.f/n);
}

/* 8 point butterfly (in place, 4 register) */
STIN void mdct_butterfly_8(DATA_TYPE *x){
  REG_TYPE r0   = x[6] + x[2];
  REG_TYPE r1   = x[6] - x[2];
  REG_TYPE r2   = x[4] + x[0];
  REG_TYPE r3   = x[4] - x[0];

		   x[6] = r0   + r2;
		   x[4] = r0   - r2;

		   r0   = x[5] - x[1];
		   r2   = x[7] - x[3];
		   x[0] = r1   + r0;
		   x[2] = r1   - r0;

		   r0   = x[5] + x[1];
		   r1   = x[7] + x[3];
		   x[3] = r2   + r3;
		   x[1] = r2   - r3;
		   x[7] = r1   + r0;
		   x[5] = r1   - r0;

}

/* 16 point butterfly (in place, 4 register) */
STIN void mdct_butterfly_16(DATA_TYPE *x){
  REG_TYPE r0     = x[1]  - x[9];
  REG_TYPE r1     = x[0]  - x[8];

		   x[8]  += x[0];
		   x[9]  += x[1];
		   x[0]   = MULT_NORM((r0   + r1) * cPI2_8);
		   x[1]   = MULT_NORM((r0   - r1) * cPI2_8);

		   r0     = x[3]  - x[11];
		   r1     = x[10] - x[2];
		   x[10] += x[2];
		   x[11] += x[3];
		   x[2]   = r0;
		   x[3]   = r1;

		   r0     = x[12] - x[4];
		   r1     = x[13] - x[5];
		   x[12] += x[4];
		   x[13] += x[5];
		   x[4]   = MULT_NORM((r0   - r1) * cPI2_8);
		   x[5]   = MULT_NORM((r0   + r1) * cPI2_8);

		   r0     = x[14] - x[6];
		   r1     = x[15] - x[7];
		   x[14] += x[6];
		   x[15] += x[7];
		   x[6]  = r0;
		   x[7]  = r1;

		   mdct_butterfly_8(x);
		   mdct_butterfly_8(x+8);
}

/* 32 point butterfly (in place, 4 register) */
STIN void mdct_butterfly_32(DATA_TYPE *x){
  REG_TYPE r0     = x[30] - x[14];
  REG_TYPE r1     = x[31] - x[15];

		   x[30] +=         x[14];
		   x[31] +=         x[15];
		   x[14]  =         r0;
		   x[15]  =         r1;

		   r0     = x[28] - x[12];
		   r1     = x[29] - x[13];
		   x[28] +=         x[12];
		   x[29] +=         x[13];
		   x[12]  = MULT_NORM( r0 * cPI1_8  -  r1 * cPI3_8 );
		   x[13]  = MULT_NORM( r0 * cPI3_8  +  r1 * cPI1_8 );

		   r0     = x[26] - x[10];
		   r1     = x[27] - x[11];
		   x[26] +=         x[10];
		   x[27] +=         x[11];
		   x[10]  = MULT_NORM(( r0  - r1 ) * cPI2_8);
		   x[11]  = MULT_NORM(( r0  + r1 ) * cPI2_8);

		   r0     = x[24] - x[8];
		   r1     = x[25] - x[9];
		   x[24] += x[8];
		   x[25] += x[9];
		   x[8]   = MULT_NORM( r0 * cPI3_8  -  r1 * cPI1_8 );
		   x[9]   = MULT_NORM( r1 * cPI3_8  +  r0 * cPI1_8 );

		   r0     = x[22] - x[6];
		   r1     = x[7]  - x[23];
		   x[22] += x[6];
		   x[23] += x[7];
		   x[6]   = r1;
		   x[7]   = r0;

		   r0     = x[4]  - x[20];
		   r1     = x[5]  - x[21];
		   x[20] += x[4];
		   x[21] += x[5];
		   x[4]   = MULT_NORM( r1 * cPI1_8  +  r0 * cPI3_8 );
		   x[5]   = MULT_NORM( r1 * cPI3_8  -  r0 * cPI1_8 );

		   r0     = x[2]  - x[18];
		   r1     = x[3]  - x[19];
		   x[18] += x[2];
		   x[19] += x[3];
		   x[2]   = MULT_NORM(( r1  + r0 ) * cPI2_8);
		   x[3]   = MULT_NORM(( r1  - r0 ) * cPI2_8);

		   r0     = x[0]  - x[16];
		   r1     = x[1]  - x[17];
		   x[16] += x[0];
		   x[17] += x[1];
		   x[0]   = MULT_NORM( r1 * cPI3_8  +  r0 * cPI1_8 );
		   x[1]   = MULT_NORM( r1 * cPI1_8  -  r0 * cPI3_8 );

		   mdct_butterfly_16(x);
		   mdct_butterfly_16(x+16);

}

/* N point first stage butterfly (in place, 2 register) */
STIN void mdct_butterfly_first(DATA_TYPE *T,
										DATA_TYPE *x,
										int points){

  DATA_TYPE *x1        = x          + points      - 8;
  DATA_TYPE *x2        = x          + (points>>1) - 8;
  REG_TYPE   r0;
  REG_TYPE   r1;

  do{

			   r0      = x1[6]      -  x2[6];
			   r1      = x1[7]      -  x2[7];
			   x1[6]  += x2[6];
			   x1[7]  += x2[7];
			   x2[6]   = MULT_NORM(r1 * T[1]  +  r0 * T[0]);
			   x2[7]   = MULT_NORM(r1 * T[0]  -  r0 * T[1]);

			   r0      = x1[4]      -  x2[4];
			   r1      = x1[5]      -  x2[5];
			   x1[4]  += x2[4];
			   x1[5]  += x2[5];
			   x2[4]   = MULT_NORM(r1 * T[5]  +  r0 * T[4]);
			   x2[5]   = MULT_NORM(r1 * T[4]  -  r0 * T[5]);

			   r0      = x1[2]      -  x2[2];
			   r1      = x1[3]      -  x2[3];
			   x1[2]  += x2[2];
			   x1[3]  += x2[3];
			   x2[2]   = MULT_NORM(r1 * T[9]  +  r0 * T[8]);
			   x2[3]   = MULT_NORM(r1 * T[8]  -  r0 * T[9]);

			   r0      = x1[0]      -  x2[0];
			   r1      = x1[1]      -  x2[1];
			   x1[0]  += x2[0];
			   x1[1]  += x2[1];
			   x2[0]   = MULT_NORM(r1 * T[13] +  r0 * T[12]);
			   x2[1]   = MULT_NORM(r1 * T[12] -  r0 * T[13]);

	x1-=8;
	x2-=8;
	T+=16;

  }while(x2>=x);
}

/* N/stage point generic N stage butterfly (in place, 2 register) */
STIN void mdct_butterfly_generic(DATA_TYPE *T,
										  DATA_TYPE *x,
										  int points,
										  int trigint){

  DATA_TYPE *x1        = x          + points      - 8;
  DATA_TYPE *x2        = x          + (points>>1) - 8;
  REG_TYPE   r0;
  REG_TYPE   r1;

  do{

			   r0      = x1[6]      -  x2[6];
			   r1      = x1[7]      -  x2[7];
			   x1[6]  += x2[6];
			   x1[7]  += x2[7];
			   x2[6]   = MULT_NORM(r1 * T[1]  +  r0 * T[0]);
			   x2[7]   = MULT_NORM(r1 * T[0]  -  r0 * T[1]);

			   T+=trigint;

			   r0      = x1[4]      -  x2[4];
			   r1      = x1[5]      -  x2[5];
			   x1[4]  += x2[4];
			   x1[5]  += x2[5];
			   x2[4]   = MULT_NORM(r1 * T[1]  +  r0 * T[0]);
			   x2[5]   = MULT_NORM(r1 * T[0]  -  r0 * T[1]);

			   T+=trigint;

			   r0      = x1[2]      -  x2[2];
			   r1      = x1[3]      -  x2[3];
			   x1[2]  += x2[2];
			   x1[3]  += x2[3];
			   x2[2]   = MULT_NORM(r1 * T[1]  +  r0 * T[0]);
			   x2[3]   = MULT_NORM(r1 * T[0]  -  r0 * T[1]);

			   T+=trigint;

			   r0      = x1[0]      -  x2[0];
			   r1      = x1[1]      -  x2[1];
			   x1[0]  += x2[0];
			   x1[1]  += x2[1];
			   x2[0]   = MULT_NORM(r1 * T[1]  +  r0 * T[0]);
			   x2[1]   = MULT_NORM(r1 * T[0]  -  r0 * T[1]);

			   T+=trigint;
	x1-=8;
	x2-=8;

  }while(x2>=x);
}

STIN void mdct_butterflies(mdct_lookup *init,
							 DATA_TYPE *x,
							 int points){

  DATA_TYPE *T=init->trig;
  int stages=init->log2n-5;
  int i,j;

  if(--stages>0){
	mdct_butterfly_first(T,x,points);
  }

  for(i=1;--stages>0;i++){
	for(j=0;j<(1<<i);j++)
	  mdct_butterfly_generic(T,x+(points>>i)*j,points>>i,4<<i);
  }

  for(j=0;j<points;j+=32)
	mdct_butterfly_32(x+j);

}

void mdct_clear(mdct_lookup *l){
  if(l){
	if(l->trig)_ogg_free(l->trig);
	if(l->bitrev)_ogg_free(l->bitrev);
	memset(l,0,sizeof(*l));
  }
}

STIN void mdct_bitreverse(mdct_lookup *init,
							DATA_TYPE *x){
  int        n       = init->n;
  int       *bit     = init->bitrev;
  DATA_TYPE *w0      = x;
  DATA_TYPE *w1      = x = w0+(n>>1);
  DATA_TYPE *T       = init->trig+n;

  do{
	DATA_TYPE *x0    = x+bit[0];
	DATA_TYPE *x1    = x+bit[1];

	REG_TYPE  r0     = x0[1]  - x1[1];
	REG_TYPE  r1     = x0[0]  + x1[0];
	REG_TYPE  r2     = MULT_NORM(r1     * T[0]   + r0 * T[1]);
	REG_TYPE  r3     = MULT_NORM(r1     * T[1]   - r0 * T[0]);

			  w1    -= 4;

			  r0     = HALVE(x0[1] + x1[1]);
			  r1     = HALVE(x0[0] - x1[0]);

			  w0[0]  = r0     + r2;
			  w1[2]  = r0     - r2;
			  w0[1]  = r1     + r3;
			  w1[3]  = r3     - r1;

			  x0     = x+bit[2];
			  x1     = x+bit[3];

			  r0     = x0[1]  - x1[1];
			  r1     = x0[0]  + x1[0];
			  r2     = MULT_NORM(r1     * T[2]   + r0 * T[3]);
			  r3     = MULT_NORM(r1     * T[3]   - r0 * T[2]);

			  r0     = HALVE(x0[1] + x1[1]);
			  r1     = HALVE(x0[0] - x1[0]);

			  w0[2]  = r0     + r2;
			  w1[0]  = r0     - r2;
			  w0[3]  = r1     + r3;
			  w1[1]  = r3     - r1;

			  T     += 4;
			  bit   += 4;
			  w0    += 4;

  }while(w0<w1);
}

void mdct_backward(mdct_lookup *init, DATA_TYPE *in, DATA_TYPE *out){
  int n=init->n;
  int n2=n>>1;
  int n4=n>>2;

  /* rotate */

  DATA_TYPE *iX = in+n2-7;
  DATA_TYPE *oX = out+n2+n4;
  DATA_TYPE *T  = init->trig+n4;

  do{
	oX         -= 4;
	oX[0]       = MULT_NORM(-iX[2] * T[3] - iX[0]  * T[2]);
	oX[1]       = MULT_NORM (iX[0] * T[3] - iX[2]  * T[2]);
	oX[2]       = MULT_NORM(-iX[6] * T[1] - iX[4]  * T[0]);
	oX[3]       = MULT_NORM (iX[4] * T[1] - iX[6]  * T[0]);
	iX         -= 8;
	T          += 4;
  }while(iX>=in);

  iX            = in+n2-8;
  oX            = out+n2+n4;
  T             = init->trig+n4;

  do{
	T          -= 4;
	oX[0]       =  MULT_NORM (iX[4] * T[3] + iX[6] * T[2]);
	oX[1]       =  MULT_NORM (iX[4] * T[2] - iX[6] * T[3]);
	oX[2]       =  MULT_NORM (iX[0] * T[1] + iX[2] * T[0]);
	oX[3]       =  MULT_NORM (iX[0] * T[0] - iX[2] * T[1]);
	iX         -= 8;
	oX         += 4;
  }while(iX>=in);

  mdct_butterflies(init,out+n2,n2);
  mdct_bitreverse(init,out);

  /* roatate + window */

  {
	DATA_TYPE *oX1=out+n2+n4;
	DATA_TYPE *oX2=out+n2+n4;
	DATA_TYPE *iX =out;
	T             =init->trig+n2;

	do{
	  oX1-=4;

	  oX1[3]  =  MULT_NORM (iX[0] * T[1] - iX[1] * T[0]);
	  oX2[0]  = -MULT_NORM (iX[0] * T[0] + iX[1] * T[1]);

	  oX1[2]  =  MULT_NORM (iX[2] * T[3] - iX[3] * T[2]);
	  oX2[1]  = -MULT_NORM (iX[2] * T[2] + iX[3] * T[3]);

	  oX1[1]  =  MULT_NORM (iX[4] * T[5] - iX[5] * T[4]);
	  oX2[2]  = -MULT_NORM (iX[4] * T[4] + iX[5] * T[5]);

	  oX1[0]  =  MULT_NORM (iX[6] * T[7] - iX[7] * T[6]);
	  oX2[3]  = -MULT_NORM (iX[6] * T[6] + iX[7] * T[7]);

	  oX2+=4;
	  iX    +=   8;
	  T     +=   8;
	}while(iX<oX1);

	iX=out+n2+n4;
	oX1=out+n4;
	oX2=oX1;

	do{
	  oX1-=4;
	  iX-=4;

	  oX2[0] = -(oX1[3] = iX[3]);
	  oX2[1] = -(oX1[2] = iX[2]);
	  oX2[2] = -(oX1[1] = iX[1]);
	  oX2[3] = -(oX1[0] = iX[0]);

	  oX2+=4;
	}while(oX2<iX);

	iX=out+n2+n4;
	oX1=out+n2+n4;
	oX2=out+n2;
	do{
	  oX1-=4;
	  oX1[0]= iX[3];
	  oX1[1]= iX[2];
	  oX1[2]= iX[1];
	  oX1[3]= iX[0];
	  iX+=4;
	}while(oX1>oX2);
  }
}

void mdct_forward(mdct_lookup *init, DATA_TYPE *in, DATA_TYPE *out){
  int n=init->n;
  int n2=n>>1;
  int n4=n>>2;
  int n8=n>>3;
  DATA_TYPE *w=(DATA_TYPE*) alloca(n*sizeof(*w)); /* forward needs working space */
  DATA_TYPE *w2=w+n2;

  /* rotate */

  /* window + rotate + step 1 */

  REG_TYPE r0;
  REG_TYPE r1;
  DATA_TYPE *x0=in+n2+n4;
  DATA_TYPE *x1=x0+1;
  DATA_TYPE *T=init->trig+n2;

  int i=0;

  for(i=0;i<n8;i+=2){
	x0 -=4;
	T-=2;
	r0= x0[2] + x1[0];
	r1= x0[0] + x1[2];
	w2[i]=   MULT_NORM(r1*T[1] + r0*T[0]);
	w2[i+1]= MULT_NORM(r1*T[0] - r0*T[1]);
	x1 +=4;
  }

  x1=in+1;

  for(;i<n2-n8;i+=2){
	T-=2;
	x0 -=4;
	r0= x0[2] - x1[0];
	r1= x0[0] - x1[2];
	w2[i]=   MULT_NORM(r1*T[1] + r0*T[0]);
	w2[i+1]= MULT_NORM(r1*T[0] - r0*T[1]);
	x1 +=4;
  }

  x0=in+n;

  for(;i<n2;i+=2){
	T-=2;
	x0 -=4;
	r0= -x0[2] - x1[0];
	r1= -x0[0] - x1[2];
	w2[i]=   MULT_NORM(r1*T[1] + r0*T[0]);
	w2[i+1]= MULT_NORM(r1*T[0] - r0*T[1]);
	x1 +=4;
  }

  mdct_butterflies(init,w+n2,n2);
  mdct_bitreverse(init,w);

  /* roatate + window */

  T=init->trig+n2;
  x0=out+n2;

  for(i=0;i<n4;i++){
	x0--;
	out[i] =MULT_NORM((w[0]*T[0]+w[1]*T[1])*init->scale);
	x0[0]  =MULT_NORM((w[0]*T[1]-w[1]*T[0])*init->scale);
	w+=2;
	T+=2;
  }
}

/*** End of inlined file: mdct.c ***/


/*** Start of inlined file: psy.c ***/
#include <stdlib.h>
#include <math.h>
#include <string.h>


/*** Start of inlined file: masking.h ***/
#ifndef _V_MASKING_H_
#define _V_MASKING_H_

/* more detailed ATH; the bass if flat to save stressing the floor
   overly for only a bin or two of savings. */

#define MAX_ATH 88
static const float ATH[]={
  /*15*/  -51, -52, -53, -54, -55, -56, -57, -58,
  /*31*/  -59, -60, -61, -62, -63, -64, -65, -66,
  /*63*/  -67, -68, -69, -70, -71, -72, -73, -74,
  /*125*/ -75, -76, -77, -78, -80, -81, -82, -83,
  /*250*/ -84, -85, -86, -87, -88, -88, -89, -89,
  /*500*/ -90, -91, -91, -92, -93, -94, -95, -96,
  /*1k*/  -96, -97, -98, -98, -99, -99,-100,-100,
  /*2k*/ -101,-102,-103,-104,-106,-107,-107,-107,
  /*4k*/ -107,-105,-103,-102,-101, -99, -98, -96,
  /*8k*/  -95, -95, -96, -97, -96, -95, -93, -90,
  /*16k*/ -80, -70, -50, -40, -30, -30, -30, -30
};

/* The tone masking curves from Ehmer's and Fielder's papers have been
   replaced by an empirically collected data set.  The previously
   published values were, far too often, simply on crack. */

#define EHMER_OFFSET 16
#define EHMER_MAX 56

/* masking tones from -50 to 0dB, 62.5 through 16kHz at half octaves
   test tones from -2 octaves to +5 octaves sampled at eighth octaves */
/* (Vorbis 0dB, the loudest possible tone, is assumed to be ~100dB SPL
   for collection of these curves) */

static const float tonemasks[P_BANDS][6][EHMER_MAX]={
  /* 62.5 Hz */
  {{ -60,  -60,  -60,  -60,  -60,  -60,  -60,  -60,
	 -60,  -60,  -60,  -60,  -62,  -62,  -65,  -73,
	 -69,  -68,  -68,  -67,  -70,  -70,  -72,  -74,
	 -75,  -79,  -79,  -80,  -83,  -88,  -93, -100,
	 -110, -999, -999, -999, -999, -999, -999, -999,
	 -999, -999, -999, -999, -999, -999, -999, -999,
	 -999, -999, -999, -999, -999, -999, -999, -999},
   { -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,
	 -48,  -48,  -48,  -48,  -48,  -53,  -61,  -66,
	 -66,  -68,  -67,  -70,  -76,  -76,  -72,  -73,
	 -75,  -76,  -78,  -79,  -83,  -88,  -93, -100,
	 -110, -999, -999, -999, -999, -999, -999, -999,
	 -999, -999, -999, -999, -999, -999, -999, -999,
	 -999, -999, -999, -999, -999, -999, -999, -999},
   { -37,  -37,  -37,  -37,  -37,  -37,  -37,  -37,
	 -38,  -40,  -42,  -46,  -48,  -53,  -55,  -62,
	 -65,  -58,  -56,  -56,  -61,  -60,  -65,  -67,
	 -69,  -71,  -77,  -77,  -78,  -80,  -82,  -84,
	 -88,  -93,  -98, -106, -112, -999, -999, -999,
	 -999, -999, -999, -999, -999, -999, -999, -999,
	 -999, -999, -999, -999, -999, -999, -999, -999},
   { -25,  -25,  -25,  -25,  -25,  -25,  -25,  -25,
	 -25,  -26,  -27,  -29,  -32,  -38,  -48,  -52,
	 -52,  -50,  -48,  -48,  -51,  -52,  -54,  -60,
	 -67,  -67,  -66,  -68,  -69,  -73,  -73,  -76,
	 -80,  -81,  -81,  -85,  -85,  -86,  -88,  -93,
	 -100, -110, -999, -999, -999, -999, -999, -999,
	 -999, -999, -999, -999, -999, -999, -999, -999},
   { -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,
	 -17,  -19,  -20,  -22,  -26,  -28,  -31,  -40,
	 -47,  -39,  -39,  -40,  -42,  -43,  -47,  -51,
	 -57,  -52,  -55,  -55,  -60,  -58,  -62,  -63,
	 -70,  -67,  -69,  -72,  -73,  -77,  -80,  -82,
	 -83,  -87,  -90,  -94,  -98, -104, -115, -999,
	 -999, -999, -999, -999, -999, -999, -999, -999},
   {  -8,   -8,   -8,   -8,   -8,   -8,   -8,   -8,
	  -8,   -8,  -10,  -11,  -15,  -19,  -25,  -30,
	  -34,  -31,  -30,  -31,  -29,  -32,  -35,  -42,
	  -48,  -42,  -44,  -46,  -50,  -50,  -51,  -52,
	  -59,  -54,  -55,  -55,  -58,  -62,  -63,  -66,
	  -72,  -73,  -76,  -75,  -78,  -80,  -80,  -81,
	  -84,  -88,  -90,  -94,  -98, -101, -106, -110}},
  /* 88Hz */
  {{ -66,  -66,  -66,  -66,  -66,  -66,  -66,  -66,
	 -66,  -66,  -66,  -66,  -66,  -67,  -67,  -67,
	 -76,  -72,  -71,  -74,  -76,  -76,  -75,  -78,
	 -79,  -79,  -81,  -83,  -86,  -89,  -93,  -97,
	 -100, -105, -110, -999, -999, -999, -999, -999,
	 -999, -999, -999, -999, -999, -999, -999, -999,
	 -999, -999, -999, -999, -999, -999, -999, -999},
   { -47,  -47,  -47,  -47,  -47,  -47,  -47,  -47,
	 -47,  -47,  -47,  -48,  -51,  -55,  -59,  -66,
	 -66,  -66,  -67,  -66,  -68,  -69,  -70,  -74,
	 -79,  -77,  -77,  -78,  -80,  -81,  -82,  -84,
	 -86,  -88,  -91,  -95, -100, -108, -116, -999,
	 -999, -999, -999, -999, -999, -999, -999, -999,
	 -999, -999, -999, -999, -999, -999, -999, -999},
   { -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,
	 -36,  -37,  -37,  -41,  -44,  -48,  -51,  -58,
	 -62,  -60,  -57,  -59,  -59,  -60,  -63,  -65,
	 -72,  -71,  -70,  -72,  -74,  -77,  -76,  -78,
	 -81,  -81,  -80,  -83,  -86,  -91,  -96, -100,
	 -105, -110, -999, -999, -999, -999, -999, -999,
	 -999, -999, -999, -999, -999, -999, -999, -999},
   { -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,
	 -28,  -30,  -32,  -32,  -33,  -35,  -41,  -49,
	 -50,  -49,  -47,  -48,  -48,  -52,  -51,  -57,
	 -65,  -61,  -59,  -61,  -64,  -69,  -70,  -74,
	 -77,  -77,  -78,  -81,  -84,  -85,  -87,  -90,
	 -92,  -96, -100, -107, -112, -999, -999, -999,
	 -999, -999, -999, -999, -999, -999, -999, -999},
   { -19,  -19,  -19,  -19,  -19,  -19,  -19,  -19,
	 -20,  -21,  -23,  -27,  -30,  -35,  -36,  -41,
	 -46,  -44,  -42,  -40,  -41,  -41,  -43,  -48,
	 -55,  -53,  -52,  -53,  -56,  -59,  -58,  -60,
	 -67,  -66,  -69,  -71,  -72,  -75,  -79,  -81,
	 -84,  -87,  -90,  -93,  -97, -101, -107, -114,
	 -999, -999, -999, -999, -999, -999, -999, -999},
   {  -9,   -9,   -9,   -9,   -9,   -9,   -9,   -9,
	  -11,  -12,  -12,  -15,  -16,  -20,  -23,  -30,
	  -37,  -34,  -33,  -34,  -31,  -32,  -32,  -38,
	  -47,  -44,  -41,  -40,  -47,  -49,  -46,  -46,
	  -58,  -50,  -50,  -54,  -58,  -62,  -64,  -67,
	  -67,  -70,  -72,  -76,  -79,  -83,  -87,  -91,
	  -96, -100, -104, -110, -999, -999, -999, -999}},
  /* 125 Hz */
  {{ -62,  -62,  -62,  -62,  -62,  -62,  -62,  -62,
	 -62,  -62,  -63,  -64,  -66,  -67,  -66,  -68,
	 -75,  -72,  -76,  -75,  -76,  -78,  -79,  -82,
	 -84,  -85,  -90,  -94, -101, -110, -999, -999,
	 -999, -999, -999, -999, -999, -999, -999, -999,
	 -999, -999, -999, -999, -999, -999, -999, -999,
	 -999, -999, -999, -999, -999, -999, -999, -999},
   { -59,  -59,  -59,  -59,  -59,  -59,  -59,  -59,
	 -59,  -59,  -59,  -60,  -60,  -61,  -63,  -66,
	 -71,  -68,  -70,  -70,  -71,  -72,  -72,  -75,
	 -81,  -78,  -79,  -82,  -83,  -86,  -90,  -97,
	 -103, -113, -999, -999, -999, -999, -999, -999,
	 -999, -999, -999, -999, -999, -999, -999, -999,
	 -999, -999, -999, -999, -999, -999, -999, -999},
   { -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,
	 -53,  -54,  -55,  -57,  -56,  -57,  -55,  -61,
	 -65,  -60,  -60,  -62,  -63,  -63,  -66,  -68,
	 -74,  -73,  -75,  -75,  -78,  -80,  -80,  -82,
	 -85,  -90,  -96, -101, -108, -999, -999, -999,
	 -999, -999, -999, -999, -999, -999, -999, -999,
	 -999, -999, -999, -999, -999, -999, -999, -999},
   { -46,  -46,  -46,  -46,  -46,  -46,  -46,  -46,
	 -46,  -46,  -47,  -47,  -47,  -47,  -48,  -51,
	 -57,  -51,  -49,  -50,  -51,  -53,  -54,  -59,
	 -66,  -60,  -62,  -67,  -67,  -70,  -72,  -75,
	 -76,  -78,  -81,  -85,  -88,  -94,  -97, -104,
	 -112, -999, -999, -999, -999, -999, -999, -999,
	 -999, -999, -999, -999, -999, -999, -999, -999},
   { -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,
	 -39,  -41,  -42,  -42,  -39,  -38,  -41,  -43,
	 -52,  -44,  -40,  -39,  -37,  -37,  -40,  -47,
	 -54,  -50,  -48,  -50,  -55,  -61,  -59,  -62,
	 -66,  -66,  -66,  -69,  -69,  -73,  -74,  -74,
	 -75,  -77,  -79,  -82,  -87,  -91,  -95, -100,
	 -108, -115, -999, -999, -999, -999, -999, -999},
   { -28,  -26,  -24,  -22,  -20,  -20,  -23,  -29,
	 -30,  -31,  -28,  -27,  -28,  -28,  -28,  -35,
	 -40,  -33,  -32,  -29,  -30,  -30,  -30,  -37,
	 -45,  -41,  -37,  -38,  -45,  -47,  -47,  -48,
	 -53,  -49,  -48,  -50,  -49,  -49,  -51,  -52,
	 -58,  -56,  -57,  -56,  -60,  -61,  -62,  -70,
	 -72,  -74,  -78,  -83,  -88,  -93, -100, -106}},
  /* 177 Hz */
  {{-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -110, -105, -100,  -95,  -91,  -87,  -83,
	-80,  -78,  -76,  -78,  -78,  -81,  -83,  -85,
	-86,  -85,  -86,  -87,  -90,  -97, -107, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -110, -105, -100,  -95,  -90,
	-85,  -81,  -77,  -73,  -70,  -67,  -67,  -68,
	-75,  -73,  -70,  -69,  -70,  -72,  -75,  -79,
	-84,  -83,  -84,  -86,  -88,  -89,  -89,  -93,
	-98, -105, -112, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-105, -100,  -95,  -90,  -85,  -80,  -76,  -71,
	-68,  -68,  -65,  -63,  -63,  -62,  -62,  -64,
	-65,  -64,  -61,  -62,  -63,  -64,  -66,  -68,
	-73,  -73,  -74,  -75,  -76,  -81,  -83,  -85,
	-88,  -89,  -92,  -95, -100, -108, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   { -80,  -75,  -71,  -68,  -65,  -63,  -62,  -61,
	 -61,  -61,  -61,  -59,  -56,  -57,  -53,  -50,
	 -58,  -52,  -50,  -50,  -52,  -53,  -54,  -58,
	 -67,  -63,  -67,  -68,  -72,  -75,  -78,  -80,
	 -81,  -81,  -82,  -85,  -89,  -90,  -93,  -97,
	 -101, -107, -114, -999, -999, -999, -999, -999,
	 -999, -999, -999, -999, -999, -999, -999, -999},
   { -65,  -61,  -59,  -57,  -56,  -55,  -55,  -56,
	 -56,  -57,  -55,  -53,  -52,  -47,  -44,  -44,
	 -50,  -44,  -41,  -39,  -39,  -42,  -40,  -46,
	 -51,  -49,  -50,  -53,  -54,  -63,  -60,  -61,
	 -62,  -66,  -66,  -66,  -70,  -73,  -74,  -75,
	 -76,  -75,  -79,  -85,  -89,  -91,  -96, -102,
	 -110, -999, -999, -999, -999, -999, -999, -999},
   { -52,  -50,  -49,  -49,  -48,  -48,  -48,  -49,
	 -50,  -50,  -49,  -46,  -43,  -39,  -35,  -33,
	 -38,  -36,  -32,  -29,  -32,  -32,  -32,  -35,
	 -44,  -39,  -38,  -38,  -46,  -50,  -45,  -46,
	 -53,  -50,  -50,  -50,  -54,  -54,  -53,  -53,
	 -56,  -57,  -59,  -66,  -70,  -72,  -74,  -79,
	 -83,  -85,  -90, -97, -114, -999, -999, -999}},
  /* 250 Hz */
  {{-999, -999, -999, -999, -999, -999, -110, -105,
	-100,  -95,  -90,  -86,  -80,  -75,  -75,  -79,
	-80,  -79,  -80,  -81,  -82,  -88,  -95, -103,
	-110, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -999, -108, -103,  -98,  -93,
	-88,  -83,  -79,  -78,  -75,  -71,  -67,  -68,
	-73,  -73,  -72,  -73,  -75,  -77,  -80,  -82,
	-88,  -93, -100, -107, -114, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -110, -105, -101,  -96,  -90,
	-86,  -81,  -77,  -73,  -69,  -66,  -61,  -62,
	-66,  -64,  -62,  -65,  -66,  -70,  -72,  -76,
	-81,  -80,  -84,  -90,  -95, -102, -110, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -107, -103,  -97,  -92,  -88,
	-83,  -79,  -74,  -70,  -66,  -59,  -53,  -58,
	-62,  -55,  -54,  -54,  -54,  -58,  -61,  -62,
	-72,  -70,  -72,  -75,  -78,  -80,  -81,  -80,
	-83,  -83,  -88,  -93, -100, -107, -115, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -105, -100,  -95,  -90,  -85,
	-80,  -75,  -70,  -66,  -62,  -56,  -48,  -44,
	-48,  -46,  -46,  -43,  -46,  -48,  -48,  -51,
	-58,  -58,  -59,  -60,  -62,  -62,  -61,  -61,
	-65,  -64,  -65,  -68,  -70,  -74,  -75,  -78,
	-81,  -86,  -95, -110, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999,  -999, -105, -100,  -95,  -90,  -85,  -80,
	-75,  -70,  -65,  -61,  -55,  -49,  -39,  -33,
	-40,  -35,  -32,  -38,  -40,  -33,  -35,  -37,
	-46,  -41,  -45,  -44,  -46,  -42,  -45,  -46,
	-52,  -50,  -50,  -50,  -54,  -54,  -55,  -57,
	-62,  -64,  -66,  -68,  -70,  -76,  -81,  -90,
	-100, -110, -999, -999, -999, -999, -999, -999}},
  /* 354 hz */
  {{-999, -999, -999, -999, -999, -999, -999, -999,
	-105,  -98,  -90,  -85,  -82,  -83,  -80,  -78,
	-84,  -79,  -80,  -83,  -87,  -89,  -91,  -93,
	-99, -106, -117, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -999, -999, -999, -999, -999,
	-105,  -98,  -90,  -85,  -80,  -75,  -70,  -68,
	-74,  -72,  -74,  -77,  -80,  -82,  -85,  -87,
	-92,  -89,  -91,  -95, -100, -106, -112, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -999, -999, -999, -999, -999,
	-105,  -98,  -90,  -83,  -75,  -71,  -63,  -64,
	-67,  -62,  -64,  -67,  -70,  -73,  -77,  -81,
	-84,  -83,  -85,  -89,  -90,  -93,  -98, -104,
	-109, -114, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -999, -999, -999, -999, -999,
	-103,  -96,  -88,  -81,  -75,  -68,  -58,  -54,
	-56,  -54,  -56,  -56,  -58,  -60,  -63,  -66,
	-74,  -69,  -72,  -72,  -75,  -74,  -77,  -81,
	-81,  -82,  -84,  -87,  -93,  -96,  -99, -104,
	-110, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -999, -999, -108, -102,  -96,
	-91,  -85,  -80,  -74,  -68,  -60,  -51,  -46,
	-48,  -46,  -43,  -45,  -47,  -47,  -49,  -48,
	-56,  -53,  -55,  -58,  -57,  -63,  -58,  -60,
	-66,  -64,  -67,  -70,  -70,  -74,  -77,  -84,
	-86,  -89,  -91,  -93,  -94, -101, -109, -118,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -108, -103,  -98,  -93,  -88,
	-83,  -78,  -73,  -68,  -60,  -53,  -44,  -35,
	-38,  -38,  -34,  -34,  -36,  -40,  -41,  -44,
	-51,  -45,  -46,  -47,  -46,  -54,  -50,  -49,
	-50,  -50,  -50,  -51,  -54,  -57,  -58,  -60,
	-66,  -66,  -66,  -64,  -65,  -68,  -77,  -82,
	-87,  -95, -110, -999, -999, -999, -999, -999}},
  /* 500 Hz */
  {{-999, -999, -999, -999, -999, -999, -999, -999,
	-107, -102,  -97,  -92,  -87,  -83,  -78,  -75,
	-82,  -79,  -83,  -85,  -89,  -92,  -95,  -98,
	-101, -105, -109, -113, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -999, -999, -999, -999, -106,
	-100,  -95,  -90,  -86,  -81,  -78,  -74,  -69,
	-74,  -74,  -76,  -79,  -83,  -84,  -86,  -89,
	-92,  -97,  -93, -100, -103, -107, -110, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -999, -999, -999, -106, -100,
	-95, -90, -87, -83, -80, -75, -69, -60,
	-66, -66, -68, -70, -74, -78, -79, -81,
	-81, -83, -84, -87, -93, -96, -99, -103,
	-107, -110, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -999, -999, -108, -103, -98,
	-93, -89, -85, -82, -78, -71, -62, -55,
	-58, -58, -54, -54, -55, -59, -61, -62,
	-70, -66, -66, -67, -70, -72, -75, -78,
	-84, -84, -84, -88, -91, -90, -95, -98,
	-102, -103, -106, -110, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -999, -108, -103,  -98,  -94,
	-90,  -87,  -82,  -79,  -73,  -67,  -58,  -47,
	-50,  -45,  -41,  -45,  -48,  -44,  -44,  -49,
	-54,  -51,  -48,  -47,  -49,  -50,  -51,  -57,
	-58,  -60,  -63,  -69,  -70,  -69,  -71,  -74,
	-78,  -82,  -90,  -95, -101, -105, -110, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -105, -101, -97, -93, -90,
	-85, -80, -77, -72, -65, -56, -48, -37,
	-40, -36, -34, -40, -50, -47, -38, -41,
	-47, -38, -35, -39, -38, -43, -40, -45,
	-50, -45, -44, -47, -50, -55, -48, -48,
	-52, -66, -70, -76, -82, -90, -97, -105,
	-110, -999, -999, -999, -999, -999, -999, -999}},
  /* 707 Hz */
  {{-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -108, -103,  -98,  -93,  -86,  -79,  -76,
	-83,  -81,  -85,  -87,  -89,  -93,  -98, -102,
	-107, -112, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -108, -103,  -98,  -93,  -86,  -79,  -71,
	-77,  -74,  -77,  -79,  -81,  -84,  -85,  -90,
	-92,  -93,  -92,  -98, -101, -108, -112, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -999, -999, -999, -999, -999,
	-108, -103,  -98,  -93,  -87,  -78,  -68,  -65,
	-66,  -62,  -65,  -67,  -70,  -73,  -75,  -78,
	-82,  -82,  -83,  -84,  -91,  -93,  -98, -102,
	-106, -110, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -999, -999, -999, -999, -999,
	-105, -100, -95, -90, -82, -74, -62, -57,
	-58, -56, -51, -52, -52, -54, -54, -58,
	-66, -59, -60, -63, -66, -69, -73, -79,
	-83, -84, -80, -81, -81, -82, -88, -92,
	-98, -105, -113, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -999, -999, -999, -999, -107,
	-102,  -97,  -92,  -84,  -79,  -69,  -57,  -47,
	-52,  -47,  -44,  -45,  -50,  -52,  -42,  -42,
	-53,  -43,  -43,  -48,  -51,  -56,  -55,  -52,
	-57,  -59,  -61,  -62,  -67,  -71,  -78,  -83,
	-86,  -94,  -98, -103, -110, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -999, -999, -999, -105, -100,
	-95,  -90,  -84,  -78,  -70,  -61,  -51,  -41,
	-40,  -38,  -40,  -46,  -52,  -51,  -41,  -40,
	-46,  -40,  -38,  -38,  -41,  -46,  -41,  -46,
	-47,  -43,  -43,  -45,  -41,  -45,  -56,  -67,
	-68,  -83,  -87,  -90,  -95, -102, -107, -113,
	-999, -999, -999, -999, -999, -999, -999, -999}},
  /* 1000 Hz */
  {{-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -109, -105, -101,  -96,  -91,  -84,  -77,
	-82,  -82,  -85,  -89,  -94, -100, -106, -110,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -106, -103,  -98,  -92,  -85,  -80,  -71,
	-75,  -72,  -76,  -80,  -84,  -86,  -89,  -93,
	-100, -107, -113, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -999, -999, -999, -999, -107,
	-104, -101,  -97,  -92,  -88,  -84,  -80,  -64,
	-66,  -63,  -64,  -66,  -69,  -73,  -77,  -83,
	-83,  -86,  -91,  -98, -104, -111, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -999, -999, -999, -999, -107,
	-104, -101,  -97,  -92,  -90,  -84,  -74,  -57,
	-58,  -52,  -55,  -54,  -50,  -52,  -50,  -52,
	-63,  -62,  -69,  -76,  -77,  -78,  -78,  -79,
	-82,  -88,  -94, -100, -106, -111, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -999, -999, -999, -106, -102,
	-98,  -95,  -90,  -85,  -83,  -78,  -70,  -50,
	-50,  -41,  -44,  -49,  -47,  -50,  -50,  -44,
	-55,  -46,  -47,  -48,  -48,  -54,  -49,  -49,
	-58,  -62,  -71,  -81,  -87,  -92,  -97, -102,
	-108, -114, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -999, -999, -999, -106, -102,
	-98,  -95,  -90,  -85,  -83,  -78,  -70,  -45,
	-43,  -41,  -47,  -50,  -51,  -50,  -49,  -45,
	-47,  -41,  -44,  -41,  -39,  -43,  -38,  -37,
	-40,  -41,  -44,  -50,  -58,  -65,  -73,  -79,
	-85,  -92,  -97, -101, -105, -109, -113, -999,
	-999, -999, -999, -999, -999, -999, -999, -999}},
  /* 1414 Hz */
  {{-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -107, -100,  -95,  -87,  -81,
	-85,  -83,  -88,  -93, -100, -107, -114, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -107, -101,  -95,  -88,  -83,  -76,
	-73,  -72,  -79,  -84,  -90,  -95, -100, -105,
	-110, -115, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -104,  -98,  -92,  -87,  -81,  -70,
	-65,  -62,  -67,  -71,  -74,  -80,  -85,  -91,
	-95,  -99, -103, -108, -111, -114, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -103,  -97,  -90,  -85,  -76,  -60,
	-56,  -54,  -60,  -62,  -61,  -56,  -63,  -65,
	-73,  -74,  -77,  -75,  -78,  -81,  -86,  -87,
	-88,  -91,  -94,  -98, -103, -110, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -999, -999, -999, -999, -105,
	-100,  -97,  -92,  -86,  -81,  -79,  -70,  -57,
	-51,  -47,  -51,  -58,  -60,  -56,  -53,  -50,
	-58,  -52,  -50,  -50,  -53,  -55,  -64,  -69,
	-71,  -85,  -82,  -78,  -81,  -85,  -95, -102,
	-112, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -999, -999, -999, -999, -105,
	-100,  -97,  -92,  -85,  -83,  -79,  -72,  -49,
	-40,  -43,  -43,  -54,  -56,  -51,  -50,  -40,
	-43,  -38,  -36,  -35,  -37,  -38,  -37,  -44,
	-54,  -60,  -57,  -60,  -70,  -75,  -84,  -92,
	-103, -112, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999}},
  /* 2000 Hz */
  {{-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -110, -102,  -95,  -89,  -82,
	-83,  -84,  -90,  -92,  -99, -107, -113, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -107, -101,  -95,  -89,  -83,  -72,
	-74,  -78,  -85,  -88,  -88,  -90,  -92,  -98,
	-105, -111, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -109, -103, -97, -93, -87, -81, -70,
	-70, -67, -75, -73, -76, -79, -81, -83,
	-88, -89, -97, -103, -110, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -107, -100,  -94,  -88,  -83,  -75,  -63,
	-59,  -59,  -63,  -66,  -60,  -62,  -67,  -67,
	-77,  -76,  -81,  -88,  -86,  -92,  -96, -102,
	-109, -116, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -105,  -98,  -92,  -86,  -81,  -73,  -56,
	-52,  -47,  -55,  -60,  -58,  -52,  -51,  -45,
	-49,  -50,  -53,  -54,  -61,  -71,  -70,  -69,
	-78,  -79,  -87,  -90,  -96, -104, -112, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -103,  -96,  -90,  -86,  -78,  -70,  -51,
	-42,  -47,  -48,  -55,  -54,  -54,  -53,  -42,
	-35,  -28,  -33,  -38,  -37,  -44,  -47,  -49,
	-54,  -63,  -68,  -78,  -82,  -89,  -94,  -99,
	-104, -109, -114, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999}},
  /* 2828 Hz */
  {{-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -110, -100,  -90,  -79,
	-85,  -81,  -82,  -82,  -89,  -94,  -99, -103,
	-109, -115, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -105,  -97,  -85,  -72,
	-74,  -70,  -70,  -70,  -76,  -85,  -91,  -93,
	-97, -103, -109, -115, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -112,  -93,  -81,  -68,
	-62,  -60,  -60,  -57,  -63,  -70,  -77,  -82,
	-90,  -93,  -98, -104, -109, -113, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -113, -100,  -93,  -84,  -63,
	-58,  -48,  -53,  -54,  -52,  -52,  -57,  -64,
	-66,  -76,  -83,  -81,  -85,  -85,  -90,  -95,
	-98, -101, -103, -106, -108, -111, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -105,  -95,  -86,  -74,  -53,
	-50,  -38,  -43,  -49,  -43,  -42,  -39,  -39,
	-46,  -52,  -57,  -56,  -72,  -69,  -74,  -81,
	-87,  -92,  -94,  -97,  -99, -102, -105, -108,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -108,  -99,  -90,  -76,  -66,  -45,
	-43,  -41,  -44,  -47,  -43,  -47,  -40,  -30,
	-31,  -31,  -39,  -33,  -40,  -41,  -43,  -53,
	-59,  -70,  -73,  -77,  -79,  -82,  -84,  -87,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999}},
  /* 4000 Hz */
  {{-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -110,  -91,  -76,
	-75,  -85,  -93,  -98, -104, -110, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -110,  -91,  -70,
	-70,  -75,  -86,  -89,  -94,  -98, -101, -106,
	-110, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -110,  -95,  -80,  -60,
	-65,  -64,  -74,  -83,  -88,  -91,  -95,  -99,
	-103, -107, -110, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -110,  -95,  -80,  -58,
	-55,  -49,  -66,  -68,  -71,  -78,  -78,  -80,
	-88,  -85,  -89,  -97, -100, -105, -110, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -110,  -95,  -80,  -53,
	-52,  -41,  -59,  -59,  -49,  -58,  -56,  -63,
	-86,  -79,  -90,  -93,  -98, -103, -107, -112,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -110,  -97,  -91,  -73,  -45,
	-40,  -33,  -53,  -61,  -49,  -54,  -50,  -50,
	-60,  -52,  -67,  -74,  -81,  -92,  -96, -100,
	-105, -110, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999}},
  /* 5657 Hz */
  {{-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -113, -106,  -99,  -92,  -77,
	-80,  -88,  -97, -106, -115, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -116, -109, -102,  -95,  -89,  -74,
	-72,  -88,  -87,  -95, -102, -109, -116, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -116, -109, -102,  -95,  -89,  -75,
	-66,  -74,  -77,  -78,  -86,  -87,  -90,  -96,
	-105, -115, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -115, -108, -101,  -94,  -88,  -66,
	-56,  -61,  -70,  -65,  -78,  -72,  -83,  -84,
	-93,  -98, -105, -110, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -110, -105,  -95,  -89,  -82,  -57,
	-52,  -52,  -59,  -56,  -59,  -58,  -69,  -67,
	-88,  -82,  -82,  -89,  -94, -100, -108, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -110, -101,  -96,  -90,  -83,  -77,  -54,
	-43,  -38,  -50,  -48,  -52,  -48,  -42,  -42,
	-51,  -52,  -53,  -59,  -65,  -71,  -78,  -85,
	-95, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999}},
  /* 8000 Hz */
  {{-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -120, -105,  -86,  -68,
	-78,  -79,  -90, -100, -110, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -120, -105,  -86,  -66,
	-73,  -77,  -88,  -96, -105, -115, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -120, -105,  -92,  -80,  -61,
	-64,  -68,  -80,  -87,  -92, -100, -110, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -120, -104,  -91,  -79,  -52,
	-60,  -54,  -64,  -69,  -77,  -80,  -82,  -84,
	-85,  -87,  -88,  -90, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -118, -100,  -87,  -77,  -49,
	-50,  -44,  -58,  -61,  -61,  -67,  -65,  -62,
	-62,  -62,  -65,  -68, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -115,  -98,  -84,  -62,  -49,
	-44,  -38,  -46,  -49,  -49,  -46,  -39,  -37,
	-39,  -40,  -42,  -43, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999}},
  /* 11314 Hz */
  {{-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -110,  -88,  -74,
	-77,  -82,  -82,  -85,  -90,  -94,  -99, -104,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -110,  -88,  -66,
	-70,  -81,  -80,  -81,  -84,  -88,  -91,  -93,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -110,  -88,  -61,
	-63,  -70,  -71,  -74,  -77,  -80,  -83,  -85,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -110, -86, -62,
	-63,  -62,  -62,  -58,  -52,  -50,  -50,  -52,
	-54, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -118, -108,  -84,  -53,
	-50,  -50,  -50,  -55,  -47,  -45,  -40,  -40,
	-40, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -118, -100,  -73,  -43,
	-37,  -42,  -43,  -53,  -38,  -37,  -35,  -35,
	-38, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999}},
  /* 16000 Hz */
  {{-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -110, -100,  -91,  -84,  -74,
	-80,  -80,  -80,  -80,  -80, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -110, -100,  -91,  -84,  -74,
	-68,  -68,  -68,  -68,  -68, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -110, -100,  -86,  -78,  -70,
	-60,  -45,  -30,  -21, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -110, -100,  -87,  -78,  -67,
	-48,  -38,  -29,  -21, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -110, -100,  -86,  -69,  -56,
	-45,  -35,  -33,  -29, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999},
   {-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -110, -100,  -83,  -71,  -48,
	-27,  -38,  -37,  -34, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999,
	-999, -999, -999, -999, -999, -999, -999, -999}}
};

#endif

/*** End of inlined file: masking.h ***/

#define NEGINF -9999.f
static const double stereo_threshholds[]={0.0, .5, 1.0, 1.5, 2.5, 4.5, 8.5, 16.5, 9e10};
static const double stereo_threshholds_limited[]={0.0, .5, 1.0, 1.5, 2.0, 2.5, 4.5, 8.5, 9e10};

vorbis_look_psy_global *_vp_global_look(vorbis_info *vi){
  codec_setup_info *ci=(codec_setup_info*)vi->codec_setup;
  vorbis_info_psy_global *gi=&ci->psy_g_param;
  vorbis_look_psy_global *look=(vorbis_look_psy_global*)_ogg_calloc(1,sizeof(*look));

  look->channels=vi->channels;

  look->ampmax=-9999.;
  look->gi=gi;
  return(look);
}

void _vp_global_free(vorbis_look_psy_global *look){
  if(look){
	memset(look,0,sizeof(*look));
	_ogg_free(look);
  }
}

void _vi_gpsy_free(vorbis_info_psy_global *i){
  if(i){
	memset(i,0,sizeof(*i));
	_ogg_free(i);
  }
}

void _vi_psy_free(vorbis_info_psy *i){
  if(i){
	memset(i,0,sizeof(*i));
	_ogg_free(i);
  }
}

static void min_curve(float *c,
					   float *c2){
  int i;
  for(i=0;i<EHMER_MAX;i++)if(c2[i]<c[i])c[i]=c2[i];
}
static void max_curve(float *c,
					   float *c2){
  int i;
  for(i=0;i<EHMER_MAX;i++)if(c2[i]>c[i])c[i]=c2[i];
}

static void attenuate_curve(float *c,float att){
  int i;
  for(i=0;i<EHMER_MAX;i++)
	c[i]+=att;
}

static float ***setup_tone_curves(float curveatt_dB[P_BANDS],float binHz,int n,
								  float center_boost, float center_decay_rate){
  int i,j,k,m;
  float ath[EHMER_MAX];
  float workc[P_BANDS][P_LEVELS][EHMER_MAX];
  float athc[P_LEVELS][EHMER_MAX];
  float *brute_buffer=(float*) alloca(n*sizeof(*brute_buffer));

  float ***ret=(float***) _ogg_malloc(sizeof(*ret)*P_BANDS);

  memset(workc,0,sizeof(workc));

  for(i=0;i<P_BANDS;i++){
	/* we add back in the ATH to avoid low level curves falling off to
	   -infinity and unnecessarily cutting off high level curves in the
	   curve limiting (last step). */

	/* A half-band's settings must be valid over the whole band, and
	   it's better to mask too little than too much */
	int ath_offset=i*4;
	for(j=0;j<EHMER_MAX;j++){
	  float min=999.;
	  for(k=0;k<4;k++)
		if(j+k+ath_offset<MAX_ATH){
		  if(min>ATH[j+k+ath_offset])min=ATH[j+k+ath_offset];
		}else{
		  if(min>ATH[MAX_ATH-1])min=ATH[MAX_ATH-1];
		}
	  ath[j]=min;
	}

	/* copy curves into working space, replicate the 50dB curve to 30
	   and 40, replicate the 100dB curve to 110 */
	for(j=0;j<6;j++)
	  memcpy(workc[i][j+2],tonemasks[i][j],EHMER_MAX*sizeof(*tonemasks[i][j]));
	memcpy(workc[i][0],tonemasks[i][0],EHMER_MAX*sizeof(*tonemasks[i][0]));
	memcpy(workc[i][1],tonemasks[i][0],EHMER_MAX*sizeof(*tonemasks[i][0]));

	/* apply centered curve boost/decay */
	for(j=0;j<P_LEVELS;j++){
	  for(k=0;k<EHMER_MAX;k++){
		float adj=center_boost+abs(EHMER_OFFSET-k)*center_decay_rate;
		if(adj<0. && center_boost>0)adj=0.;
		if(adj>0. && center_boost<0)adj=0.;
		workc[i][j][k]+=adj;
	  }
	}

	/* normalize curves so the driving amplitude is 0dB */
	/* make temp curves with the ATH overlayed */
	for(j=0;j<P_LEVELS;j++){
	  attenuate_curve(workc[i][j],curveatt_dB[i]+100.-(j<2?2:j)*10.-P_LEVEL_0);
	  memcpy(athc[j],ath,EHMER_MAX*sizeof(**athc));
	  attenuate_curve(athc[j],+100.-j*10.f-P_LEVEL_0);
	  max_curve(athc[j],workc[i][j]);
	}

	/* Now limit the louder curves.

	   the idea is this: We don't know what the playback attenuation
	   will be; 0dB SL moves every time the user twiddles the volume
	   knob. So that means we have to use a single 'most pessimal' curve
	   for all masking amplitudes, right?  Wrong.  The *loudest* sound
	   can be in (we assume) a range of ...+100dB] SL.  However, sounds
	   20dB down will be in a range ...+80], 40dB down is from ...+60],
	   etc... */

	for(j=1;j<P_LEVELS;j++){
	  min_curve(athc[j],athc[j-1]);
	  min_curve(workc[i][j],athc[j]);
	}
  }

  for(i=0;i<P_BANDS;i++){
	int hi_curve,lo_curve,bin;
	ret[i]=(float**)_ogg_malloc(sizeof(**ret)*P_LEVELS);

	/* low frequency curves are measured with greater resolution than
	   the MDCT/FFT will actually give us; we want the curve applied
	   to the tone data to be pessimistic and thus apply the minimum
	   masking possible for a given bin.  That means that a single bin
	   could span more than one octave and that the curve will be a
	   composite of multiple octaves.  It also may mean that a single
	   bin may span > an eighth of an octave and that the eighth
	   octave values may also be composited. */

	/* which octave curves will we be compositing? */
	bin=floor(fromOC(i*.5)/binHz);
	lo_curve=  ceil(toOC(bin*binHz+1)*2);
	hi_curve=  floor(toOC((bin+1)*binHz)*2);
	if(lo_curve>i)lo_curve=i;
	if(lo_curve<0)lo_curve=0;
	if(hi_curve>=P_BANDS)hi_curve=P_BANDS-1;

	for(m=0;m<P_LEVELS;m++){
	  ret[i][m]=(float*)_ogg_malloc(sizeof(***ret)*(EHMER_MAX+2));

	  for(j=0;j<n;j++)brute_buffer[j]=999.;

	  /* render the curve into bins, then pull values back into curve.
		 The point is that any inherent subsampling aliasing results in
		 a safe minimum */
	  for(k=lo_curve;k<=hi_curve;k++){
		int l=0;

		for(j=0;j<EHMER_MAX;j++){
		  int lo_bin= fromOC(j*.125+k*.5-2.0625)/binHz;
		  int hi_bin= fromOC(j*.125+k*.5-1.9375)/binHz+1;

		  if(lo_bin<0)lo_bin=0;
		  if(lo_bin>n)lo_bin=n;
		  if(lo_bin<l)l=lo_bin;
		  if(hi_bin<0)hi_bin=0;
		  if(hi_bin>n)hi_bin=n;

		  for(;l<hi_bin && l<n;l++)
			if(brute_buffer[l]>workc[k][m][j])
			  brute_buffer[l]=workc[k][m][j];
		}

		for(;l<n;l++)
		  if(brute_buffer[l]>workc[k][m][EHMER_MAX-1])
			brute_buffer[l]=workc[k][m][EHMER_MAX-1];

	  }

	  /* be equally paranoid about being valid up to next half ocatve */
	  if(i+1<P_BANDS){
		int l=0;
		k=i+1;
		for(j=0;j<EHMER_MAX;j++){
		  int lo_bin= fromOC(j*.125+i*.5-2.0625)/binHz;
		  int hi_bin= fromOC(j*.125+i*.5-1.9375)/binHz+1;

		  if(lo_bin<0)lo_bin=0;
		  if(lo_bin>n)lo_bin=n;
		  if(lo_bin<l)l=lo_bin;
		  if(hi_bin<0)hi_bin=0;
		  if(hi_bin>n)hi_bin=n;

		  for(;l<hi_bin && l<n;l++)
			if(brute_buffer[l]>workc[k][m][j])
			  brute_buffer[l]=workc[k][m][j];
		}

		for(;l<n;l++)
		  if(brute_buffer[l]>workc[k][m][EHMER_MAX-1])
			brute_buffer[l]=workc[k][m][EHMER_MAX-1];

	  }

	  for(j=0;j<EHMER_MAX;j++){
		int bin=fromOC(j*.125+i*.5-2.)/binHz;
		if(bin<0){
		  ret[i][m][j+2]=-999.;
		}else{
		  if(bin>=n){
			ret[i][m][j+2]=-999.;
		  }else{
			ret[i][m][j+2]=brute_buffer[bin];
		  }
		}
	  }

	  /* add fenceposts */
	  for(j=0;j<EHMER_OFFSET;j++)
		if(ret[i][m][j+2]>-200.f)break;
	  ret[i][m][0]=j;

	  for(j=EHMER_MAX-1;j>EHMER_OFFSET+1;j--)
		if(ret[i][m][j+2]>-200.f)
		  break;
	  ret[i][m][1]=j;

	}
  }

  return(ret);
}

void _vp_psy_init(vorbis_look_psy *p,vorbis_info_psy *vi,
				  vorbis_info_psy_global *gi,int n,long rate){
  long i,j,lo=-99,hi=1;
  long maxoc;
  memset(p,0,sizeof(*p));

  p->eighth_octave_lines=gi->eighth_octave_lines;
  p->shiftoc=rint(log(gi->eighth_octave_lines*8.f)/log(2.f))-1;

  p->firstoc=toOC(.25f*rate*.5/n)*(1<<(p->shiftoc+1))-gi->eighth_octave_lines;
  maxoc=toOC((n+.25f)*rate*.5/n)*(1<<(p->shiftoc+1))+.5f;
  p->total_octave_lines=maxoc-p->firstoc+1;
  p->ath=(float*)_ogg_malloc(n*sizeof(*p->ath));

  p->octave=(long*)_ogg_malloc(n*sizeof(*p->octave));
  p->bark=(long*)_ogg_malloc(n*sizeof(*p->bark));
  p->vi=vi;
  p->n=n;
  p->rate=rate;

  /* AoTuV HF weighting */
  p->m_val = 1.;
  if(rate < 26000) p->m_val = 0;
  else if(rate < 38000) p->m_val = .94;   /* 32kHz */
  else if(rate > 46000) p->m_val = 1.275; /* 48kHz */

  /* set up the lookups for a given blocksize and sample rate */

  for(i=0,j=0;i<MAX_ATH-1;i++){
	int endpos=rint(fromOC((i+1)*.125-2.)*2*n/rate);
	float base=ATH[i];
	if(j<endpos){
	  float delta=(ATH[i+1]-base)/(endpos-j);
	  for(;j<endpos && j<n;j++){
		p->ath[j]=base+100.;
		base+=delta;
	  }
	}
  }

  for(;j<n;j++){
	p->ath[j]=p->ath[j-1];
  }

  for(i=0;i<n;i++){
	float bark=toBARK(rate/(2*n)*i);

	for(;lo+vi->noisewindowlomin<i &&
		  toBARK(rate/(2*n)*lo)<(bark-vi->noisewindowlo);lo++);

	for(;hi<=n && (hi<i+vi->noisewindowhimin ||
		  toBARK(rate/(2*n)*hi)<(bark+vi->noisewindowhi));hi++);

	p->bark[i]=((lo-1)<<16)+(hi-1);

  }

  for(i=0;i<n;i++)
	p->octave[i]=toOC((i+.25f)*.5*rate/n)*(1<<(p->shiftoc+1))+.5f;

  p->tonecurves=setup_tone_curves(vi->toneatt,rate*.5/n,n,
								  vi->tone_centerboost,vi->tone_decay);

  /* set up rolling noise median */
  p->noiseoffset=(float**)_ogg_malloc(P_NOISECURVES*sizeof(*p->noiseoffset));
  for(i=0;i<P_NOISECURVES;i++)
	p->noiseoffset[i]=(float*)_ogg_malloc(n*sizeof(**p->noiseoffset));

  for(i=0;i<n;i++){
	float halfoc=toOC((i+.5)*rate/(2.*n))*2.;
	int inthalfoc;
	float del;

	if(halfoc<0)halfoc=0;
	if(halfoc>=P_BANDS-1)halfoc=P_BANDS-1;
	inthalfoc=(int)halfoc;
	del=halfoc-inthalfoc;

	for(j=0;j<P_NOISECURVES;j++)
	  p->noiseoffset[j][i]=
		p->vi->noiseoff[j][inthalfoc]*(1.-del) +
		p->vi->noiseoff[j][inthalfoc+1]*del;

  }
#if 0
  {
	static int ls=0;
	_analysis_output_always("noiseoff0",ls,p->noiseoffset[0],n,1,0,0);
	_analysis_output_always("noiseoff1",ls,p->noiseoffset[1],n,1,0,0);
	_analysis_output_always("noiseoff2",ls++,p->noiseoffset[2],n,1,0,0);
  }
#endif
}

void _vp_psy_clear(vorbis_look_psy *p){
  int i,j;
  if(p){
	if(p->ath)_ogg_free(p->ath);
	if(p->octave)_ogg_free(p->octave);
	if(p->bark)_ogg_free(p->bark);
	if(p->tonecurves){
	  for(i=0;i<P_BANDS;i++){
		for(j=0;j<P_LEVELS;j++){
		  _ogg_free(p->tonecurves[i][j]);
		}
		_ogg_free(p->tonecurves[i]);
	  }
	  _ogg_free(p->tonecurves);
	}
	if(p->noiseoffset){
	  for(i=0;i<P_NOISECURVES;i++){
		_ogg_free(p->noiseoffset[i]);
	  }
	  _ogg_free(p->noiseoffset);
	}
	memset(p,0,sizeof(*p));
  }
}

/* octave/(8*eighth_octave_lines) x scale and dB y scale */
static void seed_curve(float *seed,
					   const float **curves,
					   float amp,
					   int oc, int n,
					   int linesper,float dBoffset){
  int i,post1;
  int seedptr;
  const float *posts,*curve;

  int choice=(int)((amp+dBoffset-P_LEVEL_0)*.1f);
  choice=max(choice,0);
  choice=min(choice,P_LEVELS-1);
  posts=curves[choice];
  curve=posts+2;
  post1=(int)posts[1];
  seedptr=oc+(posts[0]-EHMER_OFFSET)*linesper-(linesper>>1);

  for(i=posts[0];i<post1;i++){
	if(seedptr>0){
	  float lin=amp+curve[i];
	  if(seed[seedptr]<lin)seed[seedptr]=lin;
	}
	seedptr+=linesper;
	if(seedptr>=n)break;
  }
}

static void seed_loop(vorbis_look_psy *p,
					  const float ***curves,
					  const float *f,
					  const float *flr,
					  float *seed,
					  float specmax){
  vorbis_info_psy *vi=p->vi;
  long n=p->n,i;
  float dBoffset=vi->max_curve_dB-specmax;

  /* prime the working vector with peak values */

  for(i=0;i<n;i++){
	float max=f[i];
	long oc=p->octave[i];
	while(i+1<n && p->octave[i+1]==oc){
	  i++;
	  if(f[i]>max)max=f[i];
	}

	if(max+6.f>flr[i]){
	  oc=oc>>p->shiftoc;

	  if(oc>=P_BANDS)oc=P_BANDS-1;
	  if(oc<0)oc=0;

	  seed_curve(seed,
				 curves[oc],
				 max,
				 p->octave[i]-p->firstoc,
				 p->total_octave_lines,
				 p->eighth_octave_lines,
				 dBoffset);
	}
  }
}

static void seed_chase(float *seeds, int linesper, long n){
  long  *posstack=(long*)alloca(n*sizeof(*posstack));
  float *ampstack=(float*)alloca(n*sizeof(*ampstack));
  long   stack=0;
  long   pos=0;
  long   i;

  for(i=0;i<n;i++){
	if(stack<2){
	  posstack[stack]=i;
	  ampstack[stack++]=seeds[i];
	}else{
	  while(1){
		if(seeds[i]<ampstack[stack-1]){
		  posstack[stack]=i;
		  ampstack[stack++]=seeds[i];
		  break;
		}else{
		  if(i<posstack[stack-1]+linesper){
			if(stack>1 && ampstack[stack-1]<=ampstack[stack-2] &&
			   i<posstack[stack-2]+linesper){
			  /* we completely overlap, making stack-1 irrelevant.  pop it */
			  stack--;
			  continue;
			}
		  }
		  posstack[stack]=i;
		  ampstack[stack++]=seeds[i];
		  break;

		}
	  }
	}
  }

  /* the stack now contains only the positions that are relevant. Scan
	 'em straight through */

  for(i=0;i<stack;i++){
	long endpos;
	if(i<stack-1 && ampstack[i+1]>ampstack[i]){
	  endpos=posstack[i+1];
	}else{
	  endpos=posstack[i]+linesper+1; /* +1 is important, else bin 0 is
										discarded in short frames */
	}
	if(endpos>n)endpos=n;
	for(;pos<endpos;pos++)
	  seeds[pos]=ampstack[i];
  }

  /* there.  Linear time.  I now remember this was on a problem set I
	 had in Grad Skool... I didn't solve it at the time ;-) */

}

/* bleaugh, this is more complicated than it needs to be */
#include<stdio.h>
static void max_seeds(vorbis_look_psy *p,
					  float *seed,
					  float *flr){
  long   n=p->total_octave_lines;
  int    linesper=p->eighth_octave_lines;
  long   linpos=0;
  long   pos;

  seed_chase(seed,linesper,n); /* for masking */

  pos=p->octave[0]-p->firstoc-(linesper>>1);

  while(linpos+1<p->n){
	float minV=seed[pos];
	long end=((p->octave[linpos]+p->octave[linpos+1])>>1)-p->firstoc;
	if(minV>p->vi->tone_abs_limit)minV=p->vi->tone_abs_limit;
	while(pos+1<=end){
	  pos++;
	  if((seed[pos]>NEGINF && seed[pos]<minV) || minV==NEGINF)
		minV=seed[pos];
	}

	end=pos+p->firstoc;
	for(;linpos<p->n && p->octave[linpos]<=end;linpos++)
	  if(flr[linpos]<minV)flr[linpos]=minV;
  }

  {
	float minV=seed[p->total_octave_lines-1];
	for(;linpos<p->n;linpos++)
	  if(flr[linpos]<minV)flr[linpos]=minV;
  }

}

static void bark_noise_hybridmp(int n,const long *b,
								const float *f,
								float *noise,
								const float offset,
								const int fixed){

  float *N=(float*) alloca(n*sizeof(*N));
  float *X=(float*) alloca(n*sizeof(*N));
  float *XX=(float*) alloca(n*sizeof(*N));
  float *Y=(float*) alloca(n*sizeof(*N));
  float *XY=(float*) alloca(n*sizeof(*N));

  float tN, tX, tXX, tY, tXY;
  int i;

  int lo, hi;
  float R=0.f;
  float A=0.f;
  float B=0.f;
  float D=1.f;
  float w, x, y;

  tN = tX = tXX = tY = tXY = 0.f;

  y = f[0] + offset;
  if (y < 1.f) y = 1.f;

  w = y * y * .5;

  tN += w;
  tX += w;
  tY += w * y;

  N[0] = tN;
  X[0] = tX;
  XX[0] = tXX;
  Y[0] = tY;
  XY[0] = tXY;

  for (i = 1, x = 1.f; i < n; i++, x += 1.f) {

	y = f[i] + offset;
	if (y < 1.f) y = 1.f;

	w = y * y;

	tN += w;
	tX += w * x;
	tXX += w * x * x;
	tY += w * y;
	tXY += w * x * y;

	N[i] = tN;
	X[i] = tX;
	XX[i] = tXX;
	Y[i] = tY;
	XY[i] = tXY;
  }

  for (i = 0, x = 0.f;; i++, x += 1.f) {

	lo = b[i] >> 16;
	if( lo>=0 ) break;
	hi = b[i] & 0xffff;

	tN = N[hi] + N[-lo];
	tX = X[hi] - X[-lo];
	tXX = XX[hi] + XX[-lo];
	tY = Y[hi] + Y[-lo];
	tXY = XY[hi] - XY[-lo];

	A = tY * tXX - tX * tXY;
	B = tN * tXY - tX * tY;
	D = tN * tXX - tX * tX;
	R = (A + x * B) / D;
	if (R < 0.f)
	  R = 0.f;

	noise[i] = R - offset;
  }

  for ( ;; i++, x += 1.f) {

	lo = b[i] >> 16;
	hi = b[i] & 0xffff;
	if(hi>=n)break;

	tN = N[hi] - N[lo];
	tX = X[hi] - X[lo];
	tXX = XX[hi] - XX[lo];
	tY = Y[hi] - Y[lo];
	tXY = XY[hi] - XY[lo];

	A = tY * tXX - tX * tXY;
	B = tN * tXY - tX * tY;
	D = tN * tXX - tX * tX;
	R = (A + x * B) / D;
	if (R < 0.f) R = 0.f;

	noise[i] = R - offset;
  }
  for ( ; i < n; i++, x += 1.f) {

	R = (A + x * B) / D;
	if (R < 0.f) R = 0.f;

	noise[i] = R - offset;
  }

  if (fixed <= 0) return;

  for (i = 0, x = 0.f;; i++, x += 1.f) {
	hi = i + fixed / 2;
	lo = hi - fixed;
	if(lo>=0)break;

	tN = N[hi] + N[-lo];
	tX = X[hi] - X[-lo];
	tXX = XX[hi] + XX[-lo];
	tY = Y[hi] + Y[-lo];
	tXY = XY[hi] - XY[-lo];

	A = tY * tXX - tX * tXY;
	B = tN * tXY - tX * tY;
	D = tN * tXX - tX * tX;
	R = (A + x * B) / D;

	if (R - offset < noise[i]) noise[i] = R - offset;
  }
  for ( ;; i++, x += 1.f) {

	hi = i + fixed / 2;
	lo = hi - fixed;
	if(hi>=n)break;

	tN = N[hi] - N[lo];
	tX = X[hi] - X[lo];
	tXX = XX[hi] - XX[lo];
	tY = Y[hi] - Y[lo];
	tXY = XY[hi] - XY[lo];

	A = tY * tXX - tX * tXY;
	B = tN * tXY - tX * tY;
	D = tN * tXX - tX * tX;
	R = (A + x * B) / D;

	if (R - offset < noise[i]) noise[i] = R - offset;
  }
  for ( ; i < n; i++, x += 1.f) {
	R = (A + x * B) / D;
	if (R - offset < noise[i]) noise[i] = R - offset;
  }
}

void _vp_noisemask(vorbis_look_psy *p,
				   float *logmdct,
				   float *logmask){

  int i,n=p->n;
  float *work=(float*) alloca(n*sizeof(*work));

  bark_noise_hybridmp(n,p->bark,logmdct,logmask,
					  140.,-1);

  for(i=0;i<n;i++)work[i]=logmdct[i]-logmask[i];

  bark_noise_hybridmp(n,p->bark,work,logmask,0.,
					  p->vi->noisewindowfixed);

  for(i=0;i<n;i++)work[i]=logmdct[i]-work[i];

#if 0
  {
	static int seq=0;

	float work2[n];
	for(i=0;i<n;i++){
	  work2[i]=logmask[i]+work[i];
	}

	if(seq&1)
	  _analysis_output("median2R",seq/2,work,n,1,0,0);
	else
	  _analysis_output("median2L",seq/2,work,n,1,0,0);

	if(seq&1)
	  _analysis_output("envelope2R",seq/2,work2,n,1,0,0);
	else
	  _analysis_output("envelope2L",seq/2,work2,n,1,0,0);
	seq++;
  }
#endif

  for(i=0;i<n;i++){
	int dB=logmask[i]+.5;
	if(dB>=NOISE_COMPAND_LEVELS)dB=NOISE_COMPAND_LEVELS-1;
	if(dB<0)dB=0;
	logmask[i]= work[i]+p->vi->noisecompand[dB];
  }

}

void _vp_tonemask(vorbis_look_psy *p,
				  float *logfft,
				  float *logmask,
				  float global_specmax,
				  float local_specmax){

  int i,n=p->n;

  float *seed=(float*) alloca(sizeof(*seed)*p->total_octave_lines);
  float att=local_specmax+p->vi->ath_adjatt;
  for(i=0;i<p->total_octave_lines;i++)seed[i]=NEGINF;

  /* set the ATH (floating below localmax, not global max by a
	 specified att) */
  if(att<p->vi->ath_maxatt)att=p->vi->ath_maxatt;

  for(i=0;i<n;i++)
	logmask[i]=p->ath[i]+att;

  /* tone masking */
  seed_loop(p,(const float ***)p->tonecurves,logfft,logmask,seed,global_specmax);
  max_seeds(p,seed,logmask);

}

void _vp_offset_and_mix(vorbis_look_psy *p,
						float *noise,
						float *tone,
						int offset_select,
						float *logmask,
						float *mdct,
						float *logmdct){
  int i,n=p->n;
  float de, coeffi, cx;/* AoTuV */
  float toneatt=p->vi->tone_masteratt[offset_select];

  cx = p->m_val;

  for(i=0;i<n;i++){
	float val= noise[i]+p->noiseoffset[offset_select][i];
	if(val>p->vi->noisemaxsupp)val=p->vi->noisemaxsupp;
	logmask[i]=max(val,tone[i]+toneatt);

	/* AoTuV */
	/** @ M1 **
		The following codes improve a noise problem.
		A fundamental idea uses the value of masking and carries out
		the relative compensation of the MDCT.
		However, this code is not perfect and all noise problems cannot be solved.
		by Aoyumi @ 2004/04/18
	*/

	if(offset_select == 1) {
	  coeffi = -17.2;       /* coeffi is a -17.2dB threshold */
	  val = val - logmdct[i];  /* val == mdct line value relative to floor in dB */

	  if(val > coeffi){
		/* mdct value is > -17.2 dB below floor */

		de = 1.0-((val-coeffi)*0.005*cx);
		/* pro-rated attenuation:
		   -0.00 dB boost if mdct value is -17.2dB (relative to floor)
		   -0.77 dB boost if mdct value is 0dB (relative to floor)
		   -1.64 dB boost if mdct value is +17.2dB (relative to floor)
		   etc... */

		if(de < 0) de = 0.0001;
	  }else
		/* mdct value is <= -17.2 dB below floor */

		de = 1.0-((val-coeffi)*0.0003*cx);
	  /* pro-rated attenuation:
		 +0.00 dB atten if mdct value is -17.2dB (relative to floor)
		 +0.45 dB atten if mdct value is -34.4dB (relative to floor)
		 etc... */

	  mdct[i] *= de;

	}
  }
}

float _vp_ampmax_decay(float amp,vorbis_dsp_state *vd){
  vorbis_info *vi=vd->vi;
  codec_setup_info *ci=(codec_setup_info*)vi->codec_setup;
  vorbis_info_psy_global *gi=&ci->psy_g_param;

  int n=ci->blocksizes[vd->W]/2;
  float secs=(float)n/vi->rate;

  amp+=secs*gi->ampmax_att_per_sec;
  if(amp<-9999)amp=-9999;
  return(amp);
}

#if 0
static float FLOOR1_fromdB_LOOKUP[256]={
  1.0649863e-07F, 1.1341951e-07F, 1.2079015e-07F, 1.2863978e-07F,
  1.3699951e-07F, 1.4590251e-07F, 1.5538408e-07F, 1.6548181e-07F,
  1.7623575e-07F, 1.8768855e-07F, 1.9988561e-07F, 2.128753e-07F,
  2.2670913e-07F, 2.4144197e-07F, 2.5713223e-07F, 2.7384213e-07F,
  2.9163793e-07F, 3.1059021e-07F, 3.3077411e-07F, 3.5226968e-07F,
  3.7516214e-07F, 3.9954229e-07F, 4.2550680e-07F, 4.5315863e-07F,
  4.8260743e-07F, 5.1396998e-07F, 5.4737065e-07F, 5.8294187e-07F,
  6.2082472e-07F, 6.6116941e-07F, 7.0413592e-07F, 7.4989464e-07F,
  7.9862701e-07F, 8.5052630e-07F, 9.0579828e-07F, 9.6466216e-07F,
  1.0273513e-06F, 1.0941144e-06F, 1.1652161e-06F, 1.2409384e-06F,
  1.3215816e-06F, 1.4074654e-06F, 1.4989305e-06F, 1.5963394e-06F,
  1.7000785e-06F, 1.8105592e-06F, 1.9282195e-06F, 2.0535261e-06F,
  2.1869758e-06F, 2.3290978e-06F, 2.4804557e-06F, 2.6416497e-06F,
  2.8133190e-06F, 2.9961443e-06F, 3.1908506e-06F, 3.3982101e-06F,
  3.6190449e-06F, 3.8542308e-06F, 4.1047004e-06F, 4.3714470e-06F,
  4.6555282e-06F, 4.9580707e-06F, 5.2802740e-06F, 5.6234160e-06F,
  5.9888572e-06F, 6.3780469e-06F, 6.7925283e-06F, 7.2339451e-06F,
  7.7040476e-06F, 8.2047000e-06F, 8.7378876e-06F, 9.3057248e-06F,
  9.9104632e-06F, 1.0554501e-05F, 1.1240392e-05F, 1.1970856e-05F,
  1.2748789e-05F, 1.3577278e-05F, 1.4459606e-05F, 1.5399272e-05F,
  1.6400004e-05F, 1.7465768e-05F, 1.8600792e-05F, 1.9809576e-05F,
  2.1096914e-05F, 2.2467911e-05F, 2.3928002e-05F, 2.5482978e-05F,
  2.7139006e-05F, 2.8902651e-05F, 3.0780908e-05F, 3.2781225e-05F,
  3.4911534e-05F, 3.7180282e-05F, 3.9596466e-05F, 4.2169667e-05F,
  4.4910090e-05F, 4.7828601e-05F, 5.0936773e-05F, 5.4246931e-05F,
  5.7772202e-05F, 6.1526565e-05F, 6.5524908e-05F, 6.9783085e-05F,
  7.4317983e-05F, 7.9147585e-05F, 8.4291040e-05F, 8.9768747e-05F,
  9.5602426e-05F, 0.00010181521F, 0.00010843174F, 0.00011547824F,
  0.00012298267F, 0.00013097477F, 0.00013948625F, 0.00014855085F,
  0.00015820453F, 0.00016848555F, 0.00017943469F, 0.00019109536F,
  0.00020351382F, 0.00021673929F, 0.00023082423F, 0.00024582449F,
  0.00026179955F, 0.00027881276F, 0.00029693158F, 0.00031622787F,
  0.00033677814F, 0.00035866388F, 0.00038197188F, 0.00040679456F,
  0.00043323036F, 0.00046138411F, 0.00049136745F, 0.00052329927F,
  0.00055730621F, 0.00059352311F, 0.00063209358F, 0.00067317058F,
  0.00071691700F, 0.00076350630F, 0.00081312324F, 0.00086596457F,
  0.00092223983F, 0.00098217216F, 0.0010459992F, 0.0011139742F,
  0.0011863665F, 0.0012634633F, 0.0013455702F, 0.0014330129F,
  0.0015261382F, 0.0016253153F, 0.0017309374F, 0.0018434235F,
  0.0019632195F, 0.0020908006F, 0.0022266726F, 0.0023713743F,
  0.0025254795F, 0.0026895994F, 0.0028643847F, 0.0030505286F,
  0.0032487691F, 0.0034598925F, 0.0036847358F, 0.0039241906F,
  0.0041792066F, 0.0044507950F, 0.0047400328F, 0.0050480668F,
  0.0053761186F, 0.0057254891F, 0.0060975636F, 0.0064938176F,
  0.0069158225F, 0.0073652516F, 0.0078438871F, 0.0083536271F,
  0.0088964928F, 0.009474637F, 0.010090352F, 0.010746080F,
  0.011444421F, 0.012188144F, 0.012980198F, 0.013823725F,
  0.014722068F, 0.015678791F, 0.016697687F, 0.017782797F,
  0.018938423F, 0.020169149F, 0.021479854F, 0.022875735F,
  0.024362330F, 0.025945531F, 0.027631618F, 0.029427276F,
  0.031339626F, 0.033376252F, 0.035545228F, 0.037855157F,
  0.040315199F, 0.042935108F, 0.045725273F, 0.048696758F,
  0.051861348F, 0.055231591F, 0.058820850F, 0.062643361F,
  0.066714279F, 0.071049749F, 0.075666962F, 0.080584227F,
  0.085821044F, 0.091398179F, 0.097337747F, 0.10366330F,
  0.11039993F, 0.11757434F, 0.12521498F, 0.13335215F,
  0.14201813F, 0.15124727F, 0.16107617F, 0.17154380F,
  0.18269168F, 0.19456402F, 0.20720788F, 0.22067342F,
  0.23501402F, 0.25028656F, 0.26655159F, 0.28387361F,
  0.30232132F, 0.32196786F, 0.34289114F, 0.36517414F,
  0.38890521F, 0.41417847F, 0.44109412F, 0.46975890F,
  0.50028648F, 0.53279791F, 0.56742212F, 0.60429640F,
  0.64356699F, 0.68538959F, 0.72993007F, 0.77736504F,
  0.82788260F, 0.88168307F, 0.9389798F, 1.F,
};
#endif

/* this is for per-channel noise normalization */
static int apsort(const void *a, const void *b){
  float f1=**(float**)a;
  float f2=**(float**)b;
  return (f1<f2)-(f1>f2);
}

static void flag_lossless(int limit, float prepoint, float postpoint, float *mdct,
						 float *floor, int *flag, int i, int jn){
  int j;
  for(j=0;j<jn;j++){
	float point = j>=limit-i ? postpoint : prepoint;
	float r = fabs(mdct[j])/floor[j];
	if(r<point)
	  flag[j]=0;
	else
	  flag[j]=1;
  }
}

/* Overload/Side effect: On input, the *q vector holds either the
   quantized energy (for elements with the flag set) or the absolute
   values of the *r vector (for elements with flag unset).  On output,
   *q holds the quantized energy for all elements */
static float noise_normalize(vorbis_look_psy *p, int limit, float *r, float *q, float *f, int *flags, float acc, int i, int n, int *out){

  vorbis_info_psy *vi=p->vi;
  float **sort = (float**)alloca(n*sizeof(*sort));
  int j,count=0;
  int start = (vi->normal_p ? vi->normal_start-i : n);
  if(start>n)start=n;

  /* force classic behavior where only energy in the current band is considered */
  acc=0.f;

  /* still responsible for populating *out where noise norm not in
	 effect.  There's no need to [re]populate *q in these areas */
  for(j=0;j<start;j++){
	if(!flags || !flags[j]){ /* lossless coupling already quantized.
								Don't touch; requantizing based on
								energy would be incorrect. */
	  float ve = q[j]/f[j];
	  if(r[j]<0)
		out[j] = -rint(sqrt(ve));
	  else
		out[j] = rint(sqrt(ve));
	}
  }

  /* sort magnitudes for noise norm portion of partition */
  for(;j<n;j++){
	if(!flags || !flags[j]){ /* can't noise norm elements that have
								already been loslessly coupled; we can
								only account for their energy error */
	  float ve = q[j]/f[j];
	  /* Despite all the new, more capable coupling code, for now we
		 implement noise norm as it has been up to this point. Only
		 consider promotions to unit magnitude from 0.  In addition
		 the only energy error counted is quantizations to zero. */
	  /* also-- the original point code only applied noise norm at > pointlimit */
	  if(ve<.25f && (!flags || j>=limit-i)){
		acc += ve;
		sort[count++]=q+j; /* q is fabs(r) for unflagged element */
	  }else{
		/* For now: no acc adjustment for nonzero quantization.  populate *out and q as this value is final. */
		if(r[j]<0)
		  out[j] = -rint(sqrt(ve));
		else
		  out[j] = rint(sqrt(ve));
		q[j] = out[j]*out[j]*f[j];
	  }
	}/* else{
		again, no energy adjustment for error in nonzero quant-- for now
		}*/
  }

  if(count){
	/* noise norm to do */
	qsort(sort,count,sizeof(*sort),apsort);
	for(j=0;j<count;j++){
	  int k=sort[j]-q;
	  if(acc>=vi->normal_thresh){
		out[k]=unitnorm(r[k]);
		acc-=1.f;
		q[k]=f[k];
	  }else{
		out[k]=0;
		q[k]=0.f;
	  }
	}
  }

  return acc;
}

/* Noise normalization, quantization and coupling are not wholly
   seperable processes in depth>1 coupling. */
void _vp_couple_quantize_normalize(int blobno,
								   vorbis_info_psy_global *g,
								   vorbis_look_psy *p,
								   vorbis_info_mapping0 *vi,
								   float **mdct,
								   int   **iwork,
								   int    *nonzero,
								   int     sliding_lowpass,
								   int     ch){

  int i;
  int n = p->n;
  int partition=(p->vi->normal_p ? p->vi->normal_partition : 16);
  int limit = g->coupling_pointlimit[p->vi->blockflag][blobno];
  float prepoint=stereo_threshholds[g->coupling_prepointamp[blobno]];
  float postpoint=stereo_threshholds[g->coupling_postpointamp[blobno]];
  //float de=0.1*p->m_val; /* a blend of the AoTuV M2 and M3 code here and below */

  /* mdct is our raw mdct output, floor not removed. */
  /* inout passes in the ifloor, passes back quantized result */

  /* unquantized energy (negative indicates amplitude has negative sign) */
  float **raw = (float**)alloca(ch*sizeof(*raw));

  /* dual pupose; quantized energy (if flag set), othersize fabs(raw) */
  float **quant = (float**)alloca(ch*sizeof(*quant));

  /* floor energy */
  float **floor = (float**)alloca(ch*sizeof(*floor));

  /* flags indicating raw/quantized status of elements in raw vector */
  int   **flag  = (int**)alloca(ch*sizeof(*flag));

  /* non-zero flag working vector */
  int    *nz    = (int*)alloca(ch*sizeof(*nz));

  /* energy surplus/defecit tracking */
  float  *acc   = (float*)alloca((ch+vi->coupling_steps)*sizeof(*acc));

  /* The threshold of a stereo is changed with the size of n */
  if(n > 1000)
	postpoint=stereo_threshholds_limited[g->coupling_postpointamp[blobno]];

  raw[0]   = (float*)alloca(ch*partition*sizeof(**raw));
  quant[0] = (float*)alloca(ch*partition*sizeof(**quant));
  floor[0] = (float*)alloca(ch*partition*sizeof(**floor));
  flag[0]  = (int*)alloca(ch*partition*sizeof(**flag));

  for(i=1;i<ch;i++){
	raw[i]   = &raw[0][partition*i];
	quant[i] = &quant[0][partition*i];
	floor[i] = &floor[0][partition*i];
	flag[i]  = &flag[0][partition*i];
  }
  for(i=0;i<ch+vi->coupling_steps;i++)
	acc[i]=0.f;

  for(i=0;i<n;i+=partition){
	int k,j,jn = partition > n-i ? n-i : partition;
	int step,track = 0;

	memcpy(nz,nonzero,sizeof(*nz)*ch);

	/* prefill */
	memset(flag[0],0,ch*partition*sizeof(**flag));
	for(k=0;k<ch;k++){
	  int *iout = &iwork[k][i];
	  if(nz[k]){

		for(j=0;j<jn;j++)
		  floor[k][j] = FLOOR1_fromdB_LOOKUP[iout[j]];

		flag_lossless(limit,prepoint,postpoint,&mdct[k][i],floor[k],flag[k],i,jn);

		for(j=0;j<jn;j++){
		  quant[k][j] = raw[k][j] = mdct[k][i+j]*mdct[k][i+j];
		  if(mdct[k][i+j]<0.f) raw[k][j]*=-1.f;
		  floor[k][j]*=floor[k][j];
		}

		acc[track]=noise_normalize(p,limit,raw[k],quant[k],floor[k],NULL,acc[track],i,jn,iout);

	  }else{
		for(j=0;j<jn;j++){
		  floor[k][j] = 1e-10f;
		  raw[k][j] = 0.f;
		  quant[k][j] = 0.f;
		  flag[k][j] = 0;
		  iout[j]=0;
		}
		acc[track]=0.f;
	  }
	  track++;
	}

	/* coupling */
	for(step=0;step<vi->coupling_steps;step++){
	  int Mi = vi->coupling_mag[step];
	  int Ai = vi->coupling_ang[step];
	  int *iM = &iwork[Mi][i];
	  int *iA = &iwork[Ai][i];
	  float *reM = raw[Mi];
	  float *reA = raw[Ai];
	  float *qeM = quant[Mi];
	  float *qeA = quant[Ai];
	  float *floorM = floor[Mi];
	  float *floorA = floor[Ai];
	  int *fM = flag[Mi];
	  int *fA = flag[Ai];

	  if(nz[Mi] || nz[Ai]){
		nz[Mi] = nz[Ai] = 1;

		for(j=0;j<jn;j++){

		  if(j<sliding_lowpass-i){
			if(fM[j] || fA[j]){
			  /* lossless coupling */

			  reM[j] = fabs(reM[j])+fabs(reA[j]);
			  qeM[j] = qeM[j]+qeA[j];
			  fM[j]=fA[j]=1;

			  /* couple iM/iA */
			  {
				int A = iM[j];
				int B = iA[j];

				if(abs(A)>abs(B)){
				  iA[j]=(A>0?A-B:B-A);
				}else{
				  iA[j]=(B>0?A-B:B-A);
				  iM[j]=B;
				}

				/* collapse two equivalent tuples to one */
				if(iA[j]>=abs(iM[j])*2){
				  iA[j]= -iA[j];
				  iM[j]= -iM[j];
				}

			  }

			}else{
			  /* lossy (point) coupling */
			  if(j<limit-i){
				/* dipole */
				reM[j] += reA[j];
				qeM[j] = fabs(reM[j]);
			  }else{
				/* AoTuV */
				/** @ M2 **
					The boost problem by the combination of noise normalization and point stereo is eased.
					However, this is a temporary patch.
					by Aoyumi @ 2004/04/18
				*/
				/*float derate = (1.0 - de*((float)(j-limit+i) / (float)(n-limit)));*/
				/* elliptical
				if(reM[j]+reA[j]<0){
				  reM[j] = - (qeM[j] = (fabs(reM[j])+fabs(reA[j]))*derate*derate);
				}else{
				  reM[j] =   (qeM[j] = (fabs(reM[j])+fabs(reA[j]))*derate*derate);
				  }*/

				/* elliptical */
				if(reM[j]+reA[j]<0){
				  reM[j] = - (qeM[j] = fabs(reM[j])+fabs(reA[j]));
				}else{
				  reM[j] =   (qeM[j] = fabs(reM[j])+fabs(reA[j]));
				}

			  }
			  reA[j]=qeA[j]=0.f;
			  fA[j]=1;
			  iA[j]=0;
			}
		  }
		  floorM[j]=floorA[j]=floorM[j]+floorA[j];
		}
		/* normalize the resulting mag vector */
		acc[track]=noise_normalize(p,limit,raw[Mi],quant[Mi],floor[Mi],flag[Mi],acc[track],i,jn,iM);
		track++;
	  }
	}
  }

  for(i=0;i<vi->coupling_steps;i++){
	/* make sure coupling a zero and a nonzero channel results in two
	   nonzero channels. */
	if(nonzero[vi->coupling_mag[i]] ||
	   nonzero[vi->coupling_ang[i]]){
	  nonzero[vi->coupling_mag[i]]=1;
	  nonzero[vi->coupling_ang[i]]=1;
	}
  }
}

/*** End of inlined file: psy.c ***/


/*** Start of inlined file: registry.c ***/
/* seems like major overkill now; the backend numbers will grow into
   the infrastructure soon enough */

extern const vorbis_func_floor     floor0_exportbundle;
extern const vorbis_func_floor     floor1_exportbundle;
extern const vorbis_func_residue   residue0_exportbundle;
extern const vorbis_func_residue   residue1_exportbundle;
extern const vorbis_func_residue   residue2_exportbundle;
extern const vorbis_func_mapping   mapping0_exportbundle;

const vorbis_func_floor     *const _floor_P[]={
  &floor0_exportbundle,
  &floor1_exportbundle,
};

const vorbis_func_residue   *const _residue_P[]={
  &residue0_exportbundle,
  &residue1_exportbundle,
  &residue2_exportbundle,
};

const vorbis_func_mapping   *const _mapping_P[]={
  &mapping0_exportbundle,
};

/*** End of inlined file: registry.c ***/


/*** Start of inlined file: res0.c ***/
/* Slow, slow, slow, simpleminded and did I mention it was slow?  The
   encode/decode loops are coded for clarity and performance is not
   yet even a nagging little idea lurking in the shadows.  Oh and BTW,
   it's slow. */

#include <stdlib.h>
#include <string.h>
#include <math.h>

//#define TRAIN_RES 1
//#define TRAIN_RESAUX 1

#if defined(TRAIN_RES) || defined (TRAIN_RESAUX)
#include <stdio.h>
#endif

typedef struct {
  vorbis_info_residue0 *info;

  int         parts;
  int         stages;
  codebook   *fullbooks;
  codebook   *phrasebook;
  codebook ***partbooks;

  int         partvals;
  int       **decodemap;

  long      postbits;
  long      phrasebits;
  long      frames;

#if defined(TRAIN_RES) || defined(TRAIN_RESAUX)
  int        train_seq;
  long      *training_data[8][64];
  float      training_max[8][64];
  float      training_min[8][64];
  float     tmin;
  float     tmax;
  int       submap;
#endif

} vorbis_look_residue0;

void res0_free_info(vorbis_info_residue *i){
  vorbis_info_residue0 *info=(vorbis_info_residue0 *)i;
  if(info){
	memset(info,0,sizeof(*info));
	_ogg_free(info);
  }
}

void res0_free_look(vorbis_look_residue *i){
  int j;
  if(i){

	vorbis_look_residue0 *look=(vorbis_look_residue0 *)i;

#ifdef TRAIN_RES
	{
	  int j,k,l;
	  for(j=0;j<look->parts;j++){
		/*fprintf(stderr,"partition %d: ",j);*/
		for(k=0;k<8;k++)
		  if(look->training_data[k][j]){
			char buffer[80];
			FILE *of;
			codebook *statebook=look->partbooks[j][k];

			/* long and short into the same bucket by current convention */
			sprintf(buffer,"res_sub%d_part%d_pass%d.vqd",look->submap,j,k);
			of=fopen(buffer,"a");

			for(l=0;l<statebook->entries;l++)
			  fprintf(of,"%d:%ld\n",l,look->training_data[k][j][l]);

			fclose(of);

			/*fprintf(stderr,"%d(%.2f|%.2f) ",k,
			  look->training_min[k][j],look->training_max[k][j]);*/

			_ogg_free(look->training_data[k][j]);
			look->training_data[k][j]=NULL;
		  }
		/*fprintf(stderr,"\n");*/
	  }
	}
	fprintf(stderr,"min/max residue: %g::%g\n",look->tmin,look->tmax);

	/*fprintf(stderr,"residue bit usage %f:%f (%f total)\n",
			(float)look->phrasebits/look->frames,
			(float)look->postbits/look->frames,
			(float)(look->postbits+look->phrasebits)/look->frames);*/
#endif

	/*vorbis_info_residue0 *info=look->info;

	fprintf(stderr,
			"%ld frames encoded in %ld phrasebits and %ld residue bits "
			"(%g/frame) \n",look->frames,look->phrasebits,
			look->resbitsflat,
			(look->phrasebits+look->resbitsflat)/(float)look->frames);

	for(j=0;j<look->parts;j++){
	  long acc=0;
	  fprintf(stderr,"\t[%d] == ",j);
	  for(k=0;k<look->stages;k++)
		if((info->secondstages[j]>>k)&1){
		  fprintf(stderr,"%ld,",look->resbits[j][k]);
		  acc+=look->resbits[j][k];
		}

	  fprintf(stderr,":: (%ld vals) %1.2fbits/sample\n",look->resvals[j],
			  acc?(float)acc/(look->resvals[j]*info->grouping):0);
	}
	fprintf(stderr,"\n");*/

	for(j=0;j<look->parts;j++)
	  if(look->partbooks[j])_ogg_free(look->partbooks[j]);
	_ogg_free(look->partbooks);
	for(j=0;j<look->partvals;j++)
	  _ogg_free(look->decodemap[j]);
	_ogg_free(look->decodemap);

	memset(look,0,sizeof(*look));
	_ogg_free(look);
  }
}

#if 0
static int ilog(unsigned int v){
  int ret=0;
  while(v){
	ret++;
	v>>=1;
  }
  return(ret);
}
#endif

static int icount(unsigned int v){
  int ret=0;
  while(v){
	ret+=v&1;
	v>>=1;
  }
  return(ret);
}

void res0_pack(vorbis_info_residue *vr,oggpack_buffer *opb){
  vorbis_info_residue0 *info=(vorbis_info_residue0 *)vr;
  int j,acc=0;
  oggpack_write(opb,info->begin,24);
  oggpack_write(opb,info->end,24);

  oggpack_write(opb,info->grouping-1,24);  /* residue vectors to group and
											 code with a partitioned book */
  oggpack_write(opb,info->partitions-1,6); /* possible partition choices */
  oggpack_write(opb,info->groupbook,8);  /* group huffman book */

  /* secondstages is a bitmask; as encoding progresses pass by pass, a
	 bitmask of one indicates this partition class has bits to write
	 this pass */
  for(j=0;j<info->partitions;j++){
	if(ilog(info->secondstages[j])>3){
	  /* yes, this is a minor hack due to not thinking ahead */
	  oggpack_write(opb,info->secondstages[j],3);
	  oggpack_write(opb,1,1);
	  oggpack_write(opb,info->secondstages[j]>>3,5);
	}else
	  oggpack_write(opb,info->secondstages[j],4); /* trailing zero */
	acc+=icount(info->secondstages[j]);
  }
  for(j=0;j<acc;j++)
	oggpack_write(opb,info->booklist[j],8);

}

/* vorbis_info is for range checking */
vorbis_info_residue *res0_unpack(vorbis_info *vi,oggpack_buffer *opb){
  int j,acc=0;
  vorbis_info_residue0 *info=(vorbis_info_residue0*) _ogg_calloc(1,sizeof(*info));
  codec_setup_info     *ci=(codec_setup_info*) vi->codec_setup;

  info->begin=oggpack_read(opb,24);
  info->end=oggpack_read(opb,24);
  info->grouping=oggpack_read(opb,24)+1;
  info->partitions=oggpack_read(opb,6)+1;
  info->groupbook=oggpack_read(opb,8);

  /* check for premature EOP */
  if(info->groupbook<0)goto errout;

  for(j=0;j<info->partitions;j++){
	int cascade=oggpack_read(opb,3);
	int cflag=oggpack_read(opb,1);
	if(cflag<0) goto errout;
	if(cflag){
	  int c=oggpack_read(opb,5);
	  if(c<0) goto errout;
	  cascade|=(c<<3);
	}
	info->secondstages[j]=cascade;

	acc+=icount(cascade);
  }
  for(j=0;j<acc;j++){
	int book=oggpack_read(opb,8);
	if(book<0) goto errout;
	info->booklist[j]=book;
  }

  if(info->groupbook>=ci->books)goto errout;
  for(j=0;j<acc;j++){
	if(info->booklist[j]>=ci->books)goto errout;
	if(ci->book_param[info->booklist[j]]->maptype==0)goto errout;
  }

  /* verify the phrasebook is not specifying an impossible or
	 inconsistent partitioning scheme. */
  /* modify the phrasebook ranging check from r16327; an early beta
	 encoder had a bug where it used an oversized phrasebook by
	 accident.  These files should continue to be playable, but don't
	 allow an exploit */
  {
	int entries = ci->book_param[info->groupbook]->entries;
	int dim = ci->book_param[info->groupbook]->dim;
	int partvals = 1;
	if (dim<1) goto errout;
	while(dim>0){
	  partvals *= info->partitions;
	  if(partvals > entries) goto errout;
	  dim--;
	}
	info->partvals = partvals;
  }

  return(info);
 errout:
  res0_free_info(info);
  return(NULL);
}

vorbis_look_residue *res0_look(vorbis_dsp_state *vd,
							   vorbis_info_residue *vr){
  vorbis_info_residue0 *info=(vorbis_info_residue0 *)vr;
  vorbis_look_residue0 *look=(vorbis_look_residue0 *)_ogg_calloc(1,sizeof(*look));
  codec_setup_info     *ci=(codec_setup_info*)vd->vi->codec_setup;

  int j,k,acc=0;
  int dim;
  int maxstage=0;
  look->info=info;

  look->parts=info->partitions;
  look->fullbooks=ci->fullbooks;
  look->phrasebook=ci->fullbooks+info->groupbook;
  dim=look->phrasebook->dim;

  look->partbooks=(codebook***)_ogg_calloc(look->parts,sizeof(*look->partbooks));

  for(j=0;j<look->parts;j++){
	int stages=ilog(info->secondstages[j]);
	if(stages){
	  if(stages>maxstage)maxstage=stages;
	  look->partbooks[j]=(codebook**) _ogg_calloc(stages,sizeof(*look->partbooks[j]));
	  for(k=0;k<stages;k++)
		if(info->secondstages[j]&(1<<k)){
		  look->partbooks[j][k]=ci->fullbooks+info->booklist[acc++];
#ifdef TRAIN_RES
		  look->training_data[k][j]=_ogg_calloc(look->partbooks[j][k]->entries,
										   sizeof(***look->training_data));
#endif
		}
	}
  }

  look->partvals=1;
  for(j=0;j<dim;j++)
	  look->partvals*=look->parts;

  look->stages=maxstage;
  look->decodemap=(int**)_ogg_malloc(look->partvals*sizeof(*look->decodemap));
  for(j=0;j<look->partvals;j++){
	long val=j;
	long mult=look->partvals/look->parts;
	look->decodemap[j]=(int*)_ogg_malloc(dim*sizeof(*look->decodemap[j]));
	for(k=0;k<dim;k++){
	  long deco=val/mult;
	  val-=deco*mult;
	  mult/=look->parts;
	  look->decodemap[j][k]=deco;
	}
  }
#if defined(TRAIN_RES) || defined (TRAIN_RESAUX)
  {
	static int train_seq=0;
	look->train_seq=train_seq++;
  }
#endif
  return(look);
}

/* break an abstraction and copy some code for performance purposes */
static int local_book_besterror(codebook *book,int *a){
  int dim=book->dim;
  int i,j,o;
  int minval=book->minval;
  int del=book->delta;
  int qv=book->quantvals;
  int ze=(qv>>1);
  int index=0;
  /* assumes integer/centered encoder codebook maptype 1 no more than dim 8 */
  int p[8]={0,0,0,0,0,0,0,0};

  if(del!=1){
	for(i=0,o=dim;i<dim;i++){
	  int v = (a[--o]-minval+(del>>1))/del;
	  int m = (v<ze ? ((ze-v)<<1)-1 : ((v-ze)<<1));
	  index = index*qv+ (m<0?0:(m>=qv?qv-1:m));
	  p[o]=v*del+minval;
	}
  }else{
	for(i=0,o=dim;i<dim;i++){
	  int v = a[--o]-minval;
	  int m = (v<ze ? ((ze-v)<<1)-1 : ((v-ze)<<1));
	  index = index*qv+ (m<0?0:(m>=qv?qv-1:m));
	  p[o]=v*del+minval;
	}
  }

  if(book->c->lengthlist[index]<=0){
	const static_codebook *c=book->c;
	int best=-1;
	/* assumes integer/centered encoder codebook maptype 1 no more than dim 8 */
	int e[8]={0,0,0,0,0,0,0,0};
	int maxval = book->minval + book->delta*(book->quantvals-1);
	for(i=0;i<book->entries;i++){
	  if(c->lengthlist[i]>0){
		int thisx=0;
		for(j=0;j<dim;j++){
		  int val=(e[j]-a[j]);
		  thisx+=val*val;
		}
		if(best==-1 || thisx<best){
		  memcpy(p,e,sizeof(p));
		  best=thisx;
		  index=i;
		}
	  }
	  /* assumes the value patterning created by the tools in vq/ */
	  j=0;
	  while(e[j]>=maxval)
		e[j++]=0;
	  if(e[j]>=0)
		e[j]+=book->delta;
	  e[j]= -e[j];
	}
  }

  if(index>-1){
	for(i=0;i<dim;i++)
	  *a++ -= p[i];
  }

  return(index);
}

static int _encodepart(oggpack_buffer *opb,int *vec, int n,
					   codebook *book,long *acc){
  int i,bits=0;
  int dim=book->dim;
  int step=n/dim;

  for(i=0;i<step;i++){
	int entry=local_book_besterror(book,vec+i*dim);

#ifdef TRAIN_RES
	if(entry>=0)
	  acc[entry]++;
#endif

	bits+=vorbis_book_encode(book,entry,opb);

  }

  return(bits);
}

static long **_01class(vorbis_block *vb,vorbis_look_residue *vl,
					   int **in,int ch){
  long i,j,k;
  vorbis_look_residue0 *look=(vorbis_look_residue0 *)vl;
  vorbis_info_residue0 *info=look->info;

  /* move all this setup out later */
  int samples_per_partition=info->grouping;
  int possible_partitions=info->partitions;
  int n=info->end-info->begin;

  int partvals=n/samples_per_partition;
  long **partword=(long**)_vorbis_block_alloc(vb,ch*sizeof(*partword));
  float scale=100./samples_per_partition;

  /* we find the partition type for each partition of each
	 channel.  We'll go back and do the interleaved encoding in a
	 bit.  For now, clarity */

  for(i=0;i<ch;i++){
	partword[i]=(long*)_vorbis_block_alloc(vb,n/samples_per_partition*sizeof(*partword[i]));
	memset(partword[i],0,n/samples_per_partition*sizeof(*partword[i]));
  }

  for(i=0;i<partvals;i++){
	int offset=i*samples_per_partition+info->begin;
	for(j=0;j<ch;j++){
	  int max=0;
	  int ent=0;
	  for(k=0;k<samples_per_partition;k++){
		if(abs(in[j][offset+k])>max)max=abs(in[j][offset+k]);
		ent+=abs(in[j][offset+k]);
	  }
	  ent*=scale;

	  for(k=0;k<possible_partitions-1;k++)
		if(max<=info->classmetric1[k] &&
		   (info->classmetric2[k]<0 || ent<info->classmetric2[k]))
		  break;

	  partword[j][i]=k;
	}
  }

#ifdef TRAIN_RESAUX
  {
	FILE *of;
	char buffer[80];

	for(i=0;i<ch;i++){
	  sprintf(buffer,"resaux_%d.vqd",look->train_seq);
	  of=fopen(buffer,"a");
	  for(j=0;j<partvals;j++)
		fprintf(of,"%ld, ",partword[i][j]);
	  fprintf(of,"\n");
	  fclose(of);
	}
  }
#endif
  look->frames++;

  return(partword);
}

/* designed for stereo or other modes where the partition size is an
   integer multiple of the number of channels encoded in the current
   submap */
static long **_2class(vorbis_block *vb,vorbis_look_residue *vl,int **in,
					  int ch){
  long i,j,k,l;
  vorbis_look_residue0 *look=(vorbis_look_residue0 *)vl;
  vorbis_info_residue0 *info=look->info;

  /* move all this setup out later */
  int samples_per_partition=info->grouping;
  int possible_partitions=info->partitions;
  int n=info->end-info->begin;

  int partvals=n/samples_per_partition;
  long **partword=(long**)_vorbis_block_alloc(vb,sizeof(*partword));

#if defined(TRAIN_RES) || defined (TRAIN_RESAUX)
  FILE *of;
  char buffer[80];
#endif

  partword[0]=(long*)_vorbis_block_alloc(vb,partvals*sizeof(*partword[0]));
  memset(partword[0],0,partvals*sizeof(*partword[0]));

  for(i=0,l=info->begin/ch;i<partvals;i++){
	int magmax=0;
	int angmax=0;
	for(j=0;j<samples_per_partition;j+=ch){
	  if(abs(in[0][l])>magmax)magmax=abs(in[0][l]);
	  for(k=1;k<ch;k++)
		if(abs(in[k][l])>angmax)angmax=abs(in[k][l]);
	  l++;
	}

	for(j=0;j<possible_partitions-1;j++)
	  if(magmax<=info->classmetric1[j] &&
		 angmax<=info->classmetric2[j])
		break;

	partword[0][i]=j;

  }

#ifdef TRAIN_RESAUX
  sprintf(buffer,"resaux_%d.vqd",look->train_seq);
  of=fopen(buffer,"a");
  for(i=0;i<partvals;i++)
	fprintf(of,"%ld, ",partword[0][i]);
  fprintf(of,"\n");
  fclose(of);
#endif

  look->frames++;

  return(partword);
}

static int _01forward(oggpack_buffer *opb,
					  vorbis_block *vb,vorbis_look_residue *vl,
					  int **in,int ch,
					  long **partword,
					  int (*encode)(oggpack_buffer *,int *,int,
									codebook *,long *),
					  int submap){
  long i,j,k,s;
  vorbis_look_residue0 *look=(vorbis_look_residue0 *)vl;
  vorbis_info_residue0 *info=look->info;

#ifdef TRAIN_RES
  look->submap=submap;
#endif

  /* move all this setup out later */
  int samples_per_partition=info->grouping;
  int possible_partitions=info->partitions;
  int partitions_per_word=look->phrasebook->dim;
  int n=info->end-info->begin;

  int partvals=n/samples_per_partition;
  long resbits[128];
  long resvals[128];

#ifdef TRAIN_RES
  for(i=0;i<ch;i++)
	for(j=info->begin;j<info->end;j++){
	  if(in[i][j]>look->tmax)look->tmax=in[i][j];
	  if(in[i][j]<look->tmin)look->tmin=in[i][j];
	}
#endif

  memset(resbits,0,sizeof(resbits));
  memset(resvals,0,sizeof(resvals));

  /* we code the partition words for each channel, then the residual
	 words for a partition per channel until we've written all the
	 residual words for that partition word.  Then write the next
	 partition channel words... */

  for(s=0;s<look->stages;s++){

	for(i=0;i<partvals;){

	  /* first we encode a partition codeword for each channel */
	  if(s==0){
		for(j=0;j<ch;j++){
		  long val=partword[j][i];
		  for(k=1;k<partitions_per_word;k++){
			val*=possible_partitions;
			if(i+k<partvals)
			  val+=partword[j][i+k];
		  }

		  /* training hack */
		  if(val<look->phrasebook->entries)
			look->phrasebits+=vorbis_book_encode(look->phrasebook,val,opb);
#if 0 /*def TRAIN_RES*/
		  else
			fprintf(stderr,"!");
#endif

		}
	  }

	  /* now we encode interleaved residual values for the partitions */
	  for(k=0;k<partitions_per_word && i<partvals;k++,i++){
		long offset=i*samples_per_partition+info->begin;

		for(j=0;j<ch;j++){
		  if(s==0)resvals[partword[j][i]]+=samples_per_partition;
		  if(info->secondstages[partword[j][i]]&(1<<s)){
			codebook *statebook=look->partbooks[partword[j][i]][s];
			if(statebook){
			  int ret;
			  long *accumulator=NULL;

#ifdef TRAIN_RES
			  accumulator=look->training_data[s][partword[j][i]];
			  {
				int l;
				int *samples=in[j]+offset;
				for(l=0;l<samples_per_partition;l++){
				  if(samples[l]<look->training_min[s][partword[j][i]])
					look->training_min[s][partword[j][i]]=samples[l];
				  if(samples[l]>look->training_max[s][partword[j][i]])
					look->training_max[s][partword[j][i]]=samples[l];
				}
			  }
#endif

			  ret=encode(opb,in[j]+offset,samples_per_partition,
						 statebook,accumulator);

			  look->postbits+=ret;
			  resbits[partword[j][i]]+=ret;
			}
		  }
		}
	  }
	}
  }

  /*{
	long total=0;
	long totalbits=0;
	fprintf(stderr,"%d :: ",vb->mode);
	for(k=0;k<possible_partitions;k++){
	fprintf(stderr,"%ld/%1.2g, ",resvals[k],(float)resbits[k]/resvals[k]);
	total+=resvals[k];
	totalbits+=resbits[k];
	}

	fprintf(stderr,":: %ld:%1.2g\n",total,(double)totalbits/total);
	}*/

  return(0);
}

/* a truncated packet here just means 'stop working'; it's not an error */
static int _01inverse(vorbis_block *vb,vorbis_look_residue *vl,
					  float **in,int ch,
					  long (*decodepart)(codebook *, float *,
										 oggpack_buffer *,int)){

  long i,j,k,l,s;
  vorbis_look_residue0 *look=(vorbis_look_residue0 *)vl;
  vorbis_info_residue0 *info=look->info;

  /* move all this setup out later */
  int samples_per_partition=info->grouping;
  int partitions_per_word=look->phrasebook->dim;
  int max=vb->pcmend>>1;
  int end=(info->end<max?info->end:max);
  int n=end-info->begin;

  if(n>0){
	int partvals=n/samples_per_partition;
	int partwords=(partvals+partitions_per_word-1)/partitions_per_word;
  int ***partword=(int***)alloca(ch*sizeof(*partword));

	for(j=0;j<ch;j++)
	partword[j]=(int**)_vorbis_block_alloc(vb,partwords*sizeof(*partword[j]));

	for(s=0;s<look->stages;s++){

	  /* each loop decodes on partition codeword containing
		 partitions_per_word partitions */
	  for(i=0,l=0;i<partvals;l++){
		if(s==0){
		  /* fetch the partition word for each channel */
		  for(j=0;j<ch;j++){
			int temp=vorbis_book_decode(look->phrasebook,&vb->opb);

			if(temp==-1 || temp>=info->partvals)goto eopbreak;
			partword[j][l]=look->decodemap[temp];
			if(partword[j][l]==NULL)goto errout;
		  }
		}

		/* now we decode residual values for the partitions */
		for(k=0;k<partitions_per_word && i<partvals;k++,i++)
		  for(j=0;j<ch;j++){
			long offset=info->begin+i*samples_per_partition;
			if(info->secondstages[partword[j][l][k]]&(1<<s)){
			  codebook *stagebook=look->partbooks[partword[j][l][k]][s];
			  if(stagebook){
				if(decodepart(stagebook,in[j]+offset,&vb->opb,
							  samples_per_partition)==-1)goto eopbreak;
			  }
			}
		  }
	  }
	}
  }
 errout:
 eopbreak:
  return(0);
}

int res0_inverse(vorbis_block *vb,vorbis_look_residue *vl,
				 float **in,int *nonzero,int ch){
  int i,used=0;
  for(i=0;i<ch;i++)
	if(nonzero[i])
	  in[used++]=in[i];
  if(used)
	return(_01inverse(vb,vl,in,used,vorbis_book_decodevs_add));
  else
	return(0);
}

int res1_forward(oggpack_buffer *opb,vorbis_block *vb,vorbis_look_residue *vl,
				 int **in,int *nonzero,int ch, long **partword, int submap){
  int i,used=0;
  for(i=0;i<ch;i++)
	if(nonzero[i])
	  in[used++]=in[i];

  if(used){
	return _01forward(opb,vb,vl,in,used,partword,_encodepart,submap);
  }else{
	return(0);
  }
}

long **res1_class(vorbis_block *vb,vorbis_look_residue *vl,
				  int **in,int *nonzero,int ch){
  int i,used=0;
  for(i=0;i<ch;i++)
	if(nonzero[i])
	  in[used++]=in[i];
  if(used)
	return(_01class(vb,vl,in,used));
  else
	return(0);
}

int res1_inverse(vorbis_block *vb,vorbis_look_residue *vl,
				 float **in,int *nonzero,int ch){
  int i,used=0;
  for(i=0;i<ch;i++)
	if(nonzero[i])
	  in[used++]=in[i];
  if(used)
	return(_01inverse(vb,vl,in,used,vorbis_book_decodev_add));
  else
	return(0);
}

long **res2_class(vorbis_block *vb,vorbis_look_residue *vl,
				  int **in,int *nonzero,int ch){
  int i,used=0;
  for(i=0;i<ch;i++)
	if(nonzero[i])used++;
  if(used)
	return(_2class(vb,vl,in,ch));
  else
	return(0);
}

/* res2 is slightly more different; all the channels are interleaved
   into a single vector and encoded. */

int res2_forward(oggpack_buffer *opb,
				 vorbis_block *vb,vorbis_look_residue *vl,
				 int **in,int *nonzero,int ch, long **partword,int submap){
  long i,j,k,n=vb->pcmend/2,used=0;

  /* don't duplicate the code; use a working vector hack for now and
	 reshape ourselves into a single channel res1 */
  /* ugly; reallocs for each coupling pass :-( */
  int *work=(int*)_vorbis_block_alloc(vb,ch*n*sizeof(*work));
  for(i=0;i<ch;i++){
	int *pcm=in[i];
	if(nonzero[i])used++;
	for(j=0,k=i;j<n;j++,k+=ch)
	  work[k]=pcm[j];
  }

  if(used){
	return _01forward(opb,vb,vl,&work,1,partword,_encodepart,submap);
  }else{
	return(0);
  }
}

/* duplicate code here as speed is somewhat more important */
int res2_inverse(vorbis_block *vb,vorbis_look_residue *vl,
				 float **in,int *nonzero,int ch){
  long i,k,l,s;
  vorbis_look_residue0 *look=(vorbis_look_residue0 *)vl;
  vorbis_info_residue0 *info=look->info;

  /* move all this setup out later */
  int samples_per_partition=info->grouping;
  int partitions_per_word=look->phrasebook->dim;
  int max=(vb->pcmend*ch)>>1;
  int end=(info->end<max?info->end:max);
  int n=end-info->begin;

  if(n>0){
	int partvals=n/samples_per_partition;
	int partwords=(partvals+partitions_per_word-1)/partitions_per_word;
  int **partword=(int**)_vorbis_block_alloc(vb,partwords*sizeof(*partword));

	for(i=0;i<ch;i++)if(nonzero[i])break;
	if(i==ch)return(0); /* no nonzero vectors */

	for(s=0;s<look->stages;s++){
	  for(i=0,l=0;i<partvals;l++){

		if(s==0){
		  /* fetch the partition word */
		  int temp=vorbis_book_decode(look->phrasebook,&vb->opb);
		  if(temp==-1 || temp>=info->partvals)goto eopbreak;
		  partword[l]=look->decodemap[temp];
		  if(partword[l]==NULL)goto errout;
		}

		/* now we decode residual values for the partitions */
		for(k=0;k<partitions_per_word && i<partvals;k++,i++)
		  if(info->secondstages[partword[l][k]]&(1<<s)){
			codebook *stagebook=look->partbooks[partword[l][k]][s];

			if(stagebook){
			  if(vorbis_book_decodevv_add(stagebook,in,
										  i*samples_per_partition+info->begin,ch,
										  &vb->opb,samples_per_partition)==-1)
				goto eopbreak;
			}
		  }
	  }
	}
  }
 errout:
 eopbreak:
  return(0);
}

const vorbis_func_residue residue0_exportbundle={
  NULL,
  &res0_unpack,
  &res0_look,
  &res0_free_info,
  &res0_free_look,
  NULL,
  NULL,
  &res0_inverse
};

const vorbis_func_residue residue1_exportbundle={
  &res0_pack,
  &res0_unpack,
  &res0_look,
  &res0_free_info,
  &res0_free_look,
  &res1_class,
  &res1_forward,
  &res1_inverse
};

const vorbis_func_residue residue2_exportbundle={
  &res0_pack,
  &res0_unpack,
  &res0_look,
  &res0_free_info,
  &res0_free_look,
  &res2_class,
  &res2_forward,
  &res2_inverse
};

/*** End of inlined file: res0.c ***/


/*** Start of inlined file: sharedbook.c ***/
#include <stdlib.h>
#include <math.h>
#include <string.h>

/**** pack/unpack helpers ******************************************/
int _ilog(unsigned int v){
  int ret=0;
  while(v){
	ret++;
	v>>=1;
  }
  return(ret);
}

/* 32 bit float (not IEEE; nonnormalized mantissa +
   biased exponent) : neeeeeee eeemmmmm mmmmmmmm mmmmmmmm
   Why not IEEE?  It's just not that important here. */

#define VQ_FEXP 10
#define VQ_FMAN 21
#define VQ_FEXP_BIAS 768 /* bias toward values smaller than 1. */

/* doesn't currently guard under/overflow */
long _float32_pack(float val){
  int sign=0;
  long exp;
  long mant;
  if(val<0){
	sign=0x80000000;
	val= -val;
  }
  exp= floor(log(val)/log(2.f)+.001); //+epsilon
  mant=rint(ldexp(val,(VQ_FMAN-1)-exp));
  exp=(exp+VQ_FEXP_BIAS)<<VQ_FMAN;

  return(sign|exp|mant);
}

float _float32_unpack(long val){
  double mant=val&0x1fffff;
  int    sign=val&0x80000000;
  long   exp =(val&0x7fe00000L)>>VQ_FMAN;
  if(sign)mant= -mant;
  return(ldexp(mant,exp-(VQ_FMAN-1)-VQ_FEXP_BIAS));
}

/* given a list of word lengths, generate a list of codewords.  Works
   for length ordered or unordered, always assigns the lowest valued
   codewords first.  Extended to handle unused entries (length 0) */
ogg_uint32_t *_make_words(long *l,long n,long sparsecount){
  long i,j,count=0;
  ogg_uint32_t marker[33];
  ogg_uint32_t *r=(ogg_uint32_t*)_ogg_malloc((sparsecount?sparsecount:n)*sizeof(*r));
  memset(marker,0,sizeof(marker));

  for(i=0;i<n;i++){
	long length=l[i];
	if(length>0){
	  ogg_uint32_t entry=marker[length];

	  /* when we claim a node for an entry, we also claim the nodes
		 below it (pruning off the imagined tree that may have dangled
		 from it) as well as blocking the use of any nodes directly
		 above for leaves */

	  /* update ourself */
	  if(length<32 && (entry>>length)){
		/* error condition; the lengths must specify an overpopulated tree */
		_ogg_free(r);
		return(NULL);
	  }
	  r[count++]=entry;

	  /* Look to see if the next shorter marker points to the node
		 above. if so, update it and repeat.  */
	  {
		for(j=length;j>0;j--){

		  if(marker[j]&1){
			/* have to jump branches */
			if(j==1)
			  marker[1]++;
			else
			  marker[j]=marker[j-1]<<1;
			break; /* invariant says next upper marker would already
					  have been moved if it was on the same path */
		  }
		  marker[j]++;
		}
	  }

	  /* prune the tree; the implicit invariant says all the longer
		 markers were dangling from our just-taken node.  Dangle them
		 from our *new* node. */
	  for(j=length+1;j<33;j++)
		if((marker[j]>>1) == entry){
		  entry=marker[j];
		  marker[j]=marker[j-1]<<1;
		}else
		  break;
	}else
	  if(sparsecount==0)count++;
  }

  /* sanity check the huffman tree; an underpopulated tree must be
	 rejected. The only exception is the one-node pseudo-nil tree,
	 which appears to be underpopulated because the tree doesn't
	 really exist; there's only one possible 'codeword' or zero bits,
	 but the above tree-gen code doesn't mark that. */
  if(sparsecount != 1){
	for(i=1;i<33;i++)
	  if(marker[i] & (0xffffffffUL>>(32-i))){
	_ogg_free(r);
	return(NULL);
	  }
  }

  /* bitreverse the words because our bitwise packer/unpacker is LSb
	 endian */
  for(i=0,count=0;i<n;i++){
	ogg_uint32_t temp=0;
	for(j=0;j<l[i];j++){
	  temp<<=1;
	  temp|=(r[count]>>j)&1;
	}

	if(sparsecount){
	  if(l[i])
		r[count++]=temp;
	}else
	  r[count++]=temp;
  }

  return(r);
}

/* there might be a straightforward one-line way to do the below
   that's portable and totally safe against roundoff, but I haven't
   thought of it.  Therefore, we opt on the side of caution */
long _book_maptype1_quantvals(const static_codebook *b){
  long vals=floor(pow((float)b->entries,1.f/b->dim));

  /* the above *should* be reliable, but we'll not assume that FP is
	 ever reliable when bitstream sync is at stake; verify via integer
	 means that vals really is the greatest value of dim for which
	 vals^b->bim <= b->entries */
  /* treat the above as an initial guess */
  while(1){
	long acc=1;
	long acc1=1;
	int i;
	for(i=0;i<b->dim;i++){
	  acc*=vals;
	  acc1*=vals+1;
	}
	if(acc<=b->entries && acc1>b->entries){
	  return(vals);
	}else{
	  if(acc>b->entries){
		vals--;
	  }else{
		vals++;
	  }
	}
  }
}

/* unpack the quantized list of values for encode/decode ***********/
/* we need to deal with two map types: in map type 1, the values are
   generated algorithmically (each column of the vector counts through
   the values in the quant vector). in map type 2, all the values came
   in in an explicit list.  Both value lists must be unpacked */
float *_book_unquantize(const static_codebook *b,int n,int *sparsemap){
  long j,k,count=0;
  if(b->maptype==1 || b->maptype==2){
	int quantvals;
	float mindel=_float32_unpack(b->q_min);
	float delta=_float32_unpack(b->q_delta);
	float *r=(float*)_ogg_calloc(n*b->dim,sizeof(*r));

	/* maptype 1 and 2 both use a quantized value vector, but
	   different sizes */
	switch(b->maptype){
	case 1:
	  /* most of the time, entries%dimensions == 0, but we need to be
		 well defined.  We define that the possible vales at each
		 scalar is values == entries/dim.  If entries%dim != 0, we'll
		 have 'too few' values (values*dim<entries), which means that
		 we'll have 'left over' entries; left over entries use zeroed
		 values (and are wasted).  So don't generate codebooks like
		 that */
	  quantvals=_book_maptype1_quantvals(b);
	  for(j=0;j<b->entries;j++){
		if((sparsemap && b->lengthlist[j]) || !sparsemap){
		  float last=0.f;
		  int indexdiv=1;
		  for(k=0;k<b->dim;k++){
			int index= (j/indexdiv)%quantvals;
			float val=b->quantlist[index];
			val=fabs(val)*delta+mindel+last;
			if(b->q_sequencep)last=val;
			if(sparsemap)
			  r[sparsemap[count]*b->dim+k]=val;
			else
			  r[count*b->dim+k]=val;
			indexdiv*=quantvals;
		  }
		  count++;
		}

	  }
	  break;
	case 2:
	  for(j=0;j<b->entries;j++){
		if((sparsemap && b->lengthlist[j]) || !sparsemap){
		  float last=0.f;

		  for(k=0;k<b->dim;k++){
			float val=b->quantlist[j*b->dim+k];
			val=fabs(val)*delta+mindel+last;
			if(b->q_sequencep)last=val;
			if(sparsemap)
			  r[sparsemap[count]*b->dim+k]=val;
			else
			  r[count*b->dim+k]=val;
		  }
		  count++;
		}
	  }
	  break;
	}

	return(r);
  }
  return(NULL);
}

void vorbis_staticbook_destroy(static_codebook *b){
  if(b->allocedp){
	if(b->quantlist)_ogg_free(b->quantlist);
	if(b->lengthlist)_ogg_free(b->lengthlist);
	memset(b,0,sizeof(*b));
	_ogg_free(b);
  } /* otherwise, it is in static memory */
}

void vorbis_book_clear(codebook *b){
  /* static book is not cleared; we're likely called on the lookup and
	 the static codebook belongs to the info struct */
  if(b->valuelist)_ogg_free(b->valuelist);
  if(b->codelist)_ogg_free(b->codelist);

  if(b->dec_index)_ogg_free(b->dec_index);
  if(b->dec_codelengths)_ogg_free(b->dec_codelengths);
  if(b->dec_firsttable)_ogg_free(b->dec_firsttable);

  memset(b,0,sizeof(*b));
}

int vorbis_book_init_encode(codebook *c,const static_codebook *s){

  memset(c,0,sizeof(*c));
  c->c=s;
  c->entries=s->entries;
  c->used_entries=s->entries;
  c->dim=s->dim;
  c->codelist=_make_words(s->lengthlist,s->entries,0);
  //c->valuelist=_book_unquantize(s,s->entries,NULL);
  c->quantvals=_book_maptype1_quantvals(s);
  c->minval=(int)rint(_float32_unpack(s->q_min));
  c->delta=(int)rint(_float32_unpack(s->q_delta));

  return(0);
}

#if 0
static ogg_uint32_t bitreverse(ogg_uint32_t x){
  x=    ((x>>16)&0x0000ffffUL) | ((x<<16)&0xffff0000UL);
  x=    ((x>> 8)&0x00ff00ffUL) | ((x<< 8)&0xff00ff00UL);
  x=    ((x>> 4)&0x0f0f0f0fUL) | ((x<< 4)&0xf0f0f0f0UL);
  x=    ((x>> 2)&0x33333333UL) | ((x<< 2)&0xccccccccUL);
  return((x>> 1)&0x55555555UL) | ((x<< 1)&0xaaaaaaaaUL);
}
#endif

static int JUCE_CDECL sort32a(const void *a,const void *b){
  return ( **(ogg_uint32_t **)a>**(ogg_uint32_t **)b)-
	( **(ogg_uint32_t **)a<**(ogg_uint32_t **)b);
}

/* decode codebook arrangement is more heavily optimized than encode */
int vorbis_book_init_decode(codebook *c,const static_codebook *s){
  int i,j,n=0,tabn;
  int *sortindex;
  memset(c,0,sizeof(*c));

  /* count actually used entries */
  for(i=0;i<s->entries;i++)
	if(s->lengthlist[i]>0)
	  n++;

  c->entries=s->entries;
  c->used_entries=n;
  c->dim=s->dim;

  if(n>0){

	/* two different remappings go on here.

	First, we collapse the likely sparse codebook down only to
	actually represented values/words.  This collapsing needs to be
	indexed as map-valueless books are used to encode original entry
	positions as integers.

	Second, we reorder all vectors, including the entry index above,
	by sorted bitreversed codeword to allow treeless decode. */

	/* perform sort */
	ogg_uint32_t *codes=_make_words(s->lengthlist,s->entries,c->used_entries);
	ogg_uint32_t **codep=(ogg_uint32_t**)alloca(sizeof(*codep)*n);

	if(codes==NULL)goto err_out;

	for(i=0;i<n;i++){
	  codes[i]=bitreverse(codes[i]);
	  codep[i]=codes+i;
	}

	qsort(codep,n,sizeof(*codep),sort32a);

	sortindex=(int*)alloca(n*sizeof(*sortindex));
	c->codelist=(ogg_uint32_t*)_ogg_malloc(n*sizeof(*c->codelist));
	/* the index is a reverse index */
	for(i=0;i<n;i++){
	  int position=codep[i]-codes;
	  sortindex[position]=i;
	}

	for(i=0;i<n;i++)
	  c->codelist[sortindex[i]]=codes[i];
	_ogg_free(codes);

	c->valuelist=_book_unquantize(s,n,sortindex);
  c->dec_index=(int*)_ogg_malloc(n*sizeof(*c->dec_index));

	for(n=0,i=0;i<s->entries;i++)
	  if(s->lengthlist[i]>0)
		c->dec_index[sortindex[n++]]=i;

  c->dec_codelengths=(char*)_ogg_malloc(n*sizeof(*c->dec_codelengths));
	for(n=0,i=0;i<s->entries;i++)
	  if(s->lengthlist[i]>0)
		c->dec_codelengths[sortindex[n++]]=s->lengthlist[i];

	c->dec_firsttablen=_ilog(c->used_entries)-4; /* this is magic */
	if(c->dec_firsttablen<5)c->dec_firsttablen=5;
	if(c->dec_firsttablen>8)c->dec_firsttablen=8;

	tabn=1<<c->dec_firsttablen;
  c->dec_firsttable=(ogg_uint32_t*)_ogg_calloc(tabn,sizeof(*c->dec_firsttable));
	c->dec_maxlength=0;

	for(i=0;i<n;i++){
	  if(c->dec_maxlength<c->dec_codelengths[i])
		c->dec_maxlength=c->dec_codelengths[i];
	  if(c->dec_codelengths[i]<=c->dec_firsttablen){
		ogg_uint32_t orig=bitreverse(c->codelist[i]);
		for(j=0;j<(1<<(c->dec_firsttablen-c->dec_codelengths[i]));j++)
		  c->dec_firsttable[orig|(j<<c->dec_codelengths[i])]=i+1;
	  }
	}

	/* now fill in 'unused' entries in the firsttable with hi/lo search
	   hints for the non-direct-hits */
	{
	  ogg_uint32_t mask=0xfffffffeUL<<(31-c->dec_firsttablen);
	  long lo=0,hi=0;

	  for(i=0;i<tabn;i++){
		ogg_uint32_t word=i<<(32-c->dec_firsttablen);
		if(c->dec_firsttable[bitreverse(word)]==0){
		  while((lo+1)<n && c->codelist[lo+1]<=word)lo++;
		  while(    hi<n && word>=(c->codelist[hi]&mask))hi++;

		  /* we only actually have 15 bits per hint to play with here.
			 In order to overflow gracefully (nothing breaks, efficiency
			 just drops), encode as the difference from the extremes. */
		  {
			unsigned long loval=lo;
			unsigned long hival=n-hi;

			if(loval>0x7fff)loval=0x7fff;
			if(hival>0x7fff)hival=0x7fff;
			c->dec_firsttable[bitreverse(word)]=
			  0x80000000UL | (loval<<15) | hival;
		  }
		}
	  }
	}
  }

  return(0);
 err_out:
  vorbis_book_clear(c);
  return(-1);
}

long vorbis_book_codeword(codebook *book,int entry){
  if(book->c) /* only use with encode; decode optimizations are
				 allowed to break this */
	return book->codelist[entry];
  return -1;
}

long vorbis_book_codelen(codebook *book,int entry){
  if(book->c) /* only use with encode; decode optimizations are
				 allowed to break this */
	return book->c->lengthlist[entry];
  return -1;
}

#ifdef _V_SELFTEST

/* Unit tests of the dequantizer; this stuff will be OK
   cross-platform, I simply want to be sure that special mapping cases
   actually work properly; a bug could go unnoticed for a while */

#include <stdio.h>

/* cases:

   no mapping
   full, explicit mapping
   algorithmic mapping

   nonsequential
   sequential
*/

static long full_quantlist1[]={0,1,2,3,    4,5,6,7, 8,3,6,1};
static long partial_quantlist1[]={0,7,2};

/* no mapping */
static_codebook test1={
  4,16,
  NULL,
  0,
  0,0,0,0,
  NULL,
  0
};
static float *test1_result=NULL;

/* linear, full mapping, nonsequential */
static_codebook test2={
  4,3,
  NULL,
  2,
  -533200896,1611661312,4,0,
  full_quantlist1,
  0
};
static float test2_result[]={-3,-2,-1,0, 1,2,3,4, 5,0,3,-2};

/* linear, full mapping, sequential */
static_codebook test3={
  4,3,
  NULL,
  2,
  -533200896,1611661312,4,1,
  full_quantlist1,
  0
};
static float test3_result[]={-3,-5,-6,-6, 1,3,6,10, 5,5,8,6};

/* linear, algorithmic mapping, nonsequential */
static_codebook test4={
  3,27,
  NULL,
  1,
  -533200896,1611661312,4,0,
  partial_quantlist1,
  0
};
static float test4_result[]={-3,-3,-3, 4,-3,-3, -1,-3,-3,
							  -3, 4,-3, 4, 4,-3, -1, 4,-3,
							  -3,-1,-3, 4,-1,-3, -1,-1,-3,
							  -3,-3, 4, 4,-3, 4, -1,-3, 4,
							  -3, 4, 4, 4, 4, 4, -1, 4, 4,
							  -3,-1, 4, 4,-1, 4, -1,-1, 4,
							  -3,-3,-1, 4,-3,-1, -1,-3,-1,
							  -3, 4,-1, 4, 4,-1, -1, 4,-1,
							  -3,-1,-1, 4,-1,-1, -1,-1,-1};

/* linear, algorithmic mapping, sequential */
static_codebook test5={
  3,27,
  NULL,
  1,
  -533200896,1611661312,4,1,
  partial_quantlist1,
  0
};
static float test5_result[]={-3,-6,-9, 4, 1,-2, -1,-4,-7,
							  -3, 1,-2, 4, 8, 5, -1, 3, 0,
							  -3,-4,-7, 4, 3, 0, -1,-2,-5,
							  -3,-6,-2, 4, 1, 5, -1,-4, 0,
							  -3, 1, 5, 4, 8,12, -1, 3, 7,
							  -3,-4, 0, 4, 3, 7, -1,-2, 2,
							  -3,-6,-7, 4, 1, 0, -1,-4,-5,
							  -3, 1, 0, 4, 8, 7, -1, 3, 2,
							  -3,-4,-5, 4, 3, 2, -1,-2,-3};

void run_test(static_codebook *b,float *comp){
  float *out=_book_unquantize(b,b->entries,NULL);
  int i;

  if(comp){
	if(!out){
	  fprintf(stderr,"_book_unquantize incorrectly returned NULL\n");
	  exit(1);
	}

	for(i=0;i<b->entries*b->dim;i++)
	  if(fabs(out[i]-comp[i])>.0001){
		fprintf(stderr,"disagreement in unquantized and reference data:\n"
				"position %d, %g != %g\n",i,out[i],comp[i]);
		exit(1);
	  }

  }else{
	if(out){
	  fprintf(stderr,"_book_unquantize returned a value array: \n"
			  " correct result should have been NULL\n");
	  exit(1);
	}
  }
}

int main(){
  /* run the nine dequant tests, and compare to the hand-rolled results */
  fprintf(stderr,"Dequant test 1... ");
  run_test(&test1,test1_result);
  fprintf(stderr,"OK\nDequant test 2... ");
  run_test(&test2,test2_result);
  fprintf(stderr,"OK\nDequant test 3... ");
  run_test(&test3,test3_result);
  fprintf(stderr,"OK\nDequant test 4... ");
  run_test(&test4,test4_result);
  fprintf(stderr,"OK\nDequant test 5... ");
  run_test(&test5,test5_result);
  fprintf(stderr,"OK\n\n");

  return(0);
}

#endif

/*** End of inlined file: sharedbook.c ***/


/*** Start of inlined file: smallft.c ***/
/* FFT implementation from OggSquish, minus cosine transforms,
 * minus all but radix 2/4 case.  In Vorbis we only need this
 * cut-down version.
 *
 * To do more than just power-of-two sized vectors, see the full
 * version I wrote for NetLib.
 *
 * Note that the packing is a little strange; rather than the FFT r/i
 * packing following R_0, I_n, R_1, I_1, R_2, I_2 ... R_n-1, I_n-1,
 * it follows R_0, R_1, I_1, R_2, I_2 ... R_n-1, I_n-1, I_n like the
 * FORTRAN version
 */

#include <stdlib.h>
#include <string.h>
#include <math.h>

static void drfti1(int n, float *wa, int *ifac){
  static int ntryh[4] = { 4,2,3,5 };
  static float tpi = 6.28318530717958648f;
  float arg,argh,argld,fi;
  int ntry=0,i,j=-1;
  int k1, l1, l2, ib;
  int ld, ii, ip, is, nq, nr;
  int ido, ipm, nfm1;
  int nl=n;
  int nf=0;

 L101:
  j++;
  if (j < 4)
	ntry=ntryh[j];
  else
	ntry+=2;

 L104:
  nq=nl/ntry;
  nr=nl-ntry*nq;
  if (nr!=0) goto L101;

  nf++;
  ifac[nf+1]=ntry;
  nl=nq;
  if(ntry!=2)goto L107;
  if(nf==1)goto L107;

  for (i=1;i<nf;i++){
	ib=nf-i+1;
	ifac[ib+1]=ifac[ib];
  }
  ifac[2] = 2;

 L107:
  if(nl!=1)goto L104;
  ifac[0]=n;
  ifac[1]=nf;
  argh=tpi/n;
  is=0;
  nfm1=nf-1;
  l1=1;

  if(nfm1==0)return;

  for (k1=0;k1<nfm1;k1++){
	ip=ifac[k1+2];
	ld=0;
	l2=l1*ip;
	ido=n/l2;
	ipm=ip-1;

	for (j=0;j<ipm;j++){
	  ld+=l1;
	  i=is;
	  argld=(float)ld*argh;
	  fi=0.f;
	  for (ii=2;ii<ido;ii+=2){
		fi+=1.f;
		arg=fi*argld;
		wa[i++]=cos(arg);
		wa[i++]=sin(arg);
	  }
	  is+=ido;
	}
	l1=l2;
  }
}

static void fdrffti(int n, float *wsave, int *ifac){

  if (n == 1) return;
  drfti1(n, wsave+n, ifac);
}

static void dradf2(int ido,int l1,float *cc,float *ch,float *wa1){
  int i,k;
  float ti2,tr2;
  int t0,t1,t2,t3,t4,t5,t6;

  t1=0;
  t0=(t2=l1*ido);
  t3=ido<<1;
  for(k=0;k<l1;k++){
	ch[t1<<1]=cc[t1]+cc[t2];
	ch[(t1<<1)+t3-1]=cc[t1]-cc[t2];
	t1+=ido;
	t2+=ido;
  }

  if(ido<2)return;
  if(ido==2)goto L105;

  t1=0;
  t2=t0;
  for(k=0;k<l1;k++){
	t3=t2;
	t4=(t1<<1)+(ido<<1);
	t5=t1;
	t6=t1+t1;
	for(i=2;i<ido;i+=2){
	  t3+=2;
	  t4-=2;
	  t5+=2;
	  t6+=2;
	  tr2=wa1[i-2]*cc[t3-1]+wa1[i-1]*cc[t3];
	  ti2=wa1[i-2]*cc[t3]-wa1[i-1]*cc[t3-1];
	  ch[t6]=cc[t5]+ti2;
	  ch[t4]=ti2-cc[t5];
	  ch[t6-1]=cc[t5-1]+tr2;
	  ch[t4-1]=cc[t5-1]-tr2;
	}
	t1+=ido;
	t2+=ido;
  }

  if(ido%2==1)return;

 L105:
  t3=(t2=(t1=ido)-1);
  t2+=t0;
  for(k=0;k<l1;k++){
	ch[t1]=-cc[t2];
	ch[t1-1]=cc[t3];
	t1+=ido<<1;
	t2+=ido;
	t3+=ido;
  }
}

static void dradf4(int ido,int l1,float *cc,float *ch,float *wa1,
			float *wa2,float *wa3){
  static float hsqt2 = .70710678118654752f;
  int i,k,t0,t1,t2,t3,t4,t5,t6;
  float ci2,ci3,ci4,cr2,cr3,cr4,ti1,ti2,ti3,ti4,tr1,tr2,tr3,tr4;
  t0=l1*ido;

  t1=t0;
  t4=t1<<1;
  t2=t1+(t1<<1);
  t3=0;

  for(k=0;k<l1;k++){
	tr1=cc[t1]+cc[t2];
	tr2=cc[t3]+cc[t4];

	ch[t5=t3<<2]=tr1+tr2;
	ch[(ido<<2)+t5-1]=tr2-tr1;
	ch[(t5+=(ido<<1))-1]=cc[t3]-cc[t4];
	ch[t5]=cc[t2]-cc[t1];

	t1+=ido;
	t2+=ido;
	t3+=ido;
	t4+=ido;
  }

  if(ido<2)return;
  if(ido==2)goto L105;

  t1=0;
  for(k=0;k<l1;k++){
	t2=t1;
	t4=t1<<2;
	t5=(t6=ido<<1)+t4;
	for(i=2;i<ido;i+=2){
	  t3=(t2+=2);
	  t4+=2;
	  t5-=2;

	  t3+=t0;
	  cr2=wa1[i-2]*cc[t3-1]+wa1[i-1]*cc[t3];
	  ci2=wa1[i-2]*cc[t3]-wa1[i-1]*cc[t3-1];
	  t3+=t0;
	  cr3=wa2[i-2]*cc[t3-1]+wa2[i-1]*cc[t3];
	  ci3=wa2[i-2]*cc[t3]-wa2[i-1]*cc[t3-1];
	  t3+=t0;
	  cr4=wa3[i-2]*cc[t3-1]+wa3[i-1]*cc[t3];
	  ci4=wa3[i-2]*cc[t3]-wa3[i-1]*cc[t3-1];

	  tr1=cr2+cr4;
	  tr4=cr4-cr2;
	  ti1=ci2+ci4;
	  ti4=ci2-ci4;

	  ti2=cc[t2]+ci3;
	  ti3=cc[t2]-ci3;
	  tr2=cc[t2-1]+cr3;
	  tr3=cc[t2-1]-cr3;

	  ch[t4-1]=tr1+tr2;
	  ch[t4]=ti1+ti2;

	  ch[t5-1]=tr3-ti4;
	  ch[t5]=tr4-ti3;

	  ch[t4+t6-1]=ti4+tr3;
	  ch[t4+t6]=tr4+ti3;

	  ch[t5+t6-1]=tr2-tr1;
	  ch[t5+t6]=ti1-ti2;
	}
	t1+=ido;
  }
  if(ido&1)return;

 L105:

  t2=(t1=t0+ido-1)+(t0<<1);
  t3=ido<<2;
  t4=ido;
  t5=ido<<1;
  t6=ido;

  for(k=0;k<l1;k++){
	ti1=-hsqt2*(cc[t1]+cc[t2]);
	tr1=hsqt2*(cc[t1]-cc[t2]);

	ch[t4-1]=tr1+cc[t6-1];
	ch[t4+t5-1]=cc[t6-1]-tr1;

	ch[t4]=ti1-cc[t1+t0];
	ch[t4+t5]=ti1+cc[t1+t0];

	t1+=ido;
	t2+=ido;
	t4+=t3;
	t6+=ido;
  }
}

static void dradfg(int ido,int ip,int l1,int idl1,float *cc,float *c1,
						  float *c2,float *ch,float *ch2,float *wa){

  static float tpi=6.283185307179586f;
  int idij,ipph,i,j,k,l,ic,ik,is;
  int t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,t10;
  float dc2,ai1,ai2,ar1,ar2,ds2;
  int nbd;
  float dcp,arg,dsp,ar1h,ar2h;
  int idp2,ipp2;

  arg=tpi/(float)ip;
  dcp=cos(arg);
  dsp=sin(arg);
  ipph=(ip+1)>>1;
  ipp2=ip;
  idp2=ido;
  nbd=(ido-1)>>1;
  t0=l1*ido;
  t10=ip*ido;

  if(ido==1)goto L119;
  for(ik=0;ik<idl1;ik++)ch2[ik]=c2[ik];

  t1=0;
  for(j=1;j<ip;j++){
	t1+=t0;
	t2=t1;
	for(k=0;k<l1;k++){
	  ch[t2]=c1[t2];
	  t2+=ido;
	}
  }

  is=-ido;
  t1=0;
  if(nbd>l1){
	for(j=1;j<ip;j++){
	  t1+=t0;
	  is+=ido;
	  t2= -ido+t1;
	  for(k=0;k<l1;k++){
		idij=is-1;
		t2+=ido;
		t3=t2;
		for(i=2;i<ido;i+=2){
		  idij+=2;
		  t3+=2;
		  ch[t3-1]=wa[idij-1]*c1[t3-1]+wa[idij]*c1[t3];
		  ch[t3]=wa[idij-1]*c1[t3]-wa[idij]*c1[t3-1];
		}
	  }
	}
  }else{

	for(j=1;j<ip;j++){
	  is+=ido;
	  idij=is-1;
	  t1+=t0;
	  t2=t1;
	  for(i=2;i<ido;i+=2){
		idij+=2;
		t2+=2;
		t3=t2;
		for(k=0;k<l1;k++){
		  ch[t3-1]=wa[idij-1]*c1[t3-1]+wa[idij]*c1[t3];
		  ch[t3]=wa[idij-1]*c1[t3]-wa[idij]*c1[t3-1];
		  t3+=ido;
		}
	  }
	}
  }

  t1=0;
  t2=ipp2*t0;
  if(nbd<l1){
	for(j=1;j<ipph;j++){
	  t1+=t0;
	  t2-=t0;
	  t3=t1;
	  t4=t2;
	  for(i=2;i<ido;i+=2){
		t3+=2;
		t4+=2;
		t5=t3-ido;
		t6=t4-ido;
		for(k=0;k<l1;k++){
		  t5+=ido;
		  t6+=ido;
		  c1[t5-1]=ch[t5-1]+ch[t6-1];
		  c1[t6-1]=ch[t5]-ch[t6];
		  c1[t5]=ch[t5]+ch[t6];
		  c1[t6]=ch[t6-1]-ch[t5-1];
		}
	  }
	}
  }else{
	for(j=1;j<ipph;j++){
	  t1+=t0;
	  t2-=t0;
	  t3=t1;
	  t4=t2;
	  for(k=0;k<l1;k++){
		t5=t3;
		t6=t4;
		for(i=2;i<ido;i+=2){
		  t5+=2;
		  t6+=2;
		  c1[t5-1]=ch[t5-1]+ch[t6-1];
		  c1[t6-1]=ch[t5]-ch[t6];
		  c1[t5]=ch[t5]+ch[t6];
		  c1[t6]=ch[t6-1]-ch[t5-1];
		}
		t3+=ido;
		t4+=ido;
	  }
	}
  }

L119:
  for(ik=0;ik<idl1;ik++)c2[ik]=ch2[ik];

  t1=0;
  t2=ipp2*idl1;
  for(j=1;j<ipph;j++){
	t1+=t0;
	t2-=t0;
	t3=t1-ido;
	t4=t2-ido;
	for(k=0;k<l1;k++){
	  t3+=ido;
	  t4+=ido;
	  c1[t3]=ch[t3]+ch[t4];
	  c1[t4]=ch[t4]-ch[t3];
	}
  }

  ar1=1.f;
  ai1=0.f;
  t1=0;
  t2=ipp2*idl1;
  t3=(ip-1)*idl1;
  for(l=1;l<ipph;l++){
	t1+=idl1;
	t2-=idl1;
	ar1h=dcp*ar1-dsp*ai1;
	ai1=dcp*ai1+dsp*ar1;
	ar1=ar1h;
	t4=t1;
	t5=t2;
	t6=t3;
	t7=idl1;

	for(ik=0;ik<idl1;ik++){
	  ch2[t4++]=c2[ik]+ar1*c2[t7++];
	  ch2[t5++]=ai1*c2[t6++];
	}

	dc2=ar1;
	ds2=ai1;
	ar2=ar1;
	ai2=ai1;

	t4=idl1;
	t5=(ipp2-1)*idl1;
	for(j=2;j<ipph;j++){
	  t4+=idl1;
	  t5-=idl1;

	  ar2h=dc2*ar2-ds2*ai2;
	  ai2=dc2*ai2+ds2*ar2;
	  ar2=ar2h;

	  t6=t1;
	  t7=t2;
	  t8=t4;
	  t9=t5;
	  for(ik=0;ik<idl1;ik++){
		ch2[t6++]+=ar2*c2[t8++];
		ch2[t7++]+=ai2*c2[t9++];
	  }
	}
  }

  t1=0;
  for(j=1;j<ipph;j++){
	t1+=idl1;
	t2=t1;
	for(ik=0;ik<idl1;ik++)ch2[ik]+=c2[t2++];
  }

  if(ido<l1)goto L132;

  t1=0;
  t2=0;
  for(k=0;k<l1;k++){
	t3=t1;
	t4=t2;
	for(i=0;i<ido;i++)cc[t4++]=ch[t3++];
	t1+=ido;
	t2+=t10;
  }

  goto L135;

 L132:
  for(i=0;i<ido;i++){
	t1=i;
	t2=i;
	for(k=0;k<l1;k++){
	  cc[t2]=ch[t1];
	  t1+=ido;
	  t2+=t10;
	}
  }

 L135:
  t1=0;
  t2=ido<<1;
  t3=0;
  t4=ipp2*t0;
  for(j=1;j<ipph;j++){

	t1+=t2;
	t3+=t0;
	t4-=t0;

	t5=t1;
	t6=t3;
	t7=t4;

	for(k=0;k<l1;k++){
	  cc[t5-1]=ch[t6];
	  cc[t5]=ch[t7];
	  t5+=t10;
	  t6+=ido;
	  t7+=ido;
	}
  }

  if(ido==1)return;
  if(nbd<l1)goto L141;

  t1=-ido;
  t3=0;
  t4=0;
  t5=ipp2*t0;
  for(j=1;j<ipph;j++){
	t1+=t2;
	t3+=t2;
	t4+=t0;
	t5-=t0;
	t6=t1;
	t7=t3;
	t8=t4;
	t9=t5;
	for(k=0;k<l1;k++){
	  for(i=2;i<ido;i+=2){
		ic=idp2-i;
		cc[i+t7-1]=ch[i+t8-1]+ch[i+t9-1];
		cc[ic+t6-1]=ch[i+t8-1]-ch[i+t9-1];
		cc[i+t7]=ch[i+t8]+ch[i+t9];
		cc[ic+t6]=ch[i+t9]-ch[i+t8];
	  }
	  t6+=t10;
	  t7+=t10;
	  t8+=ido;
	  t9+=ido;
	}
  }
  return;

 L141:

  t1=-ido;
  t3=0;
  t4=0;
  t5=ipp2*t0;
  for(j=1;j<ipph;j++){
	t1+=t2;
	t3+=t2;
	t4+=t0;
	t5-=t0;
	for(i=2;i<ido;i+=2){
	  t6=idp2+t1-i;
	  t7=i+t3;
	  t8=i+t4;
	  t9=i+t5;
	  for(k=0;k<l1;k++){
		cc[t7-1]=ch[t8-1]+ch[t9-1];
		cc[t6-1]=ch[t8-1]-ch[t9-1];
		cc[t7]=ch[t8]+ch[t9];
		cc[t6]=ch[t9]-ch[t8];
		t6+=t10;
		t7+=t10;
		t8+=ido;
		t9+=ido;
	  }
	}
  }
}

static void drftf1(int n,float *c,float *ch,float *wa,int *ifac){
  int i,k1,l1,l2;
  int na,kh,nf;
  int ip,iw,ido,idl1,ix2,ix3;

  nf=ifac[1];
  na=1;
  l2=n;
  iw=n;

  for(k1=0;k1<nf;k1++){
	kh=nf-k1;
	ip=ifac[kh+1];
	l1=l2/ip;
	ido=n/l2;
	idl1=ido*l1;
	iw-=(ip-1)*ido;
	na=1-na;

	if(ip!=4)goto L102;

	ix2=iw+ido;
	ix3=ix2+ido;
	if(na!=0)
	  dradf4(ido,l1,ch,c,wa+iw-1,wa+ix2-1,wa+ix3-1);
	else
	  dradf4(ido,l1,c,ch,wa+iw-1,wa+ix2-1,wa+ix3-1);
	goto L110;

 L102:
	if(ip!=2)goto L104;
	if(na!=0)goto L103;

	dradf2(ido,l1,c,ch,wa+iw-1);
	goto L110;

  L103:
	dradf2(ido,l1,ch,c,wa+iw-1);
	goto L110;

  L104:
	if(ido==1)na=1-na;
	if(na!=0)goto L109;

	dradfg(ido,ip,l1,idl1,c,c,c,ch,ch,wa+iw-1);
	na=1;
	goto L110;

  L109:
	dradfg(ido,ip,l1,idl1,ch,ch,ch,c,c,wa+iw-1);
	na=0;

  L110:
	l2=l1;
  }

  if(na==1)return;

  for(i=0;i<n;i++)c[i]=ch[i];
}

static void dradb2(int ido,int l1,float *cc,float *ch,float *wa1){
  int i,k,t0,t1,t2,t3,t4,t5,t6;
  float ti2,tr2;

  t0=l1*ido;

  t1=0;
  t2=0;
  t3=(ido<<1)-1;
  for(k=0;k<l1;k++){
	ch[t1]=cc[t2]+cc[t3+t2];
	ch[t1+t0]=cc[t2]-cc[t3+t2];
	t2=(t1+=ido)<<1;
  }

  if(ido<2)return;
  if(ido==2)goto L105;

  t1=0;
  t2=0;
  for(k=0;k<l1;k++){
	t3=t1;
	t5=(t4=t2)+(ido<<1);
	t6=t0+t1;
	for(i=2;i<ido;i+=2){
	  t3+=2;
	  t4+=2;
	  t5-=2;
	  t6+=2;
	  ch[t3-1]=cc[t4-1]+cc[t5-1];
	  tr2=cc[t4-1]-cc[t5-1];
	  ch[t3]=cc[t4]-cc[t5];
	  ti2=cc[t4]+cc[t5];
	  ch[t6-1]=wa1[i-2]*tr2-wa1[i-1]*ti2;
	  ch[t6]=wa1[i-2]*ti2+wa1[i-1]*tr2;
	}
	t2=(t1+=ido)<<1;
  }

  if(ido%2==1)return;

L105:
  t1=ido-1;
  t2=ido-1;
  for(k=0;k<l1;k++){
	ch[t1]=cc[t2]+cc[t2];
	ch[t1+t0]=-(cc[t2+1]+cc[t2+1]);
	t1+=ido;
	t2+=ido<<1;
  }
}

static void dradb3(int ido,int l1,float *cc,float *ch,float *wa1,
						  float *wa2){
  static float taur = -.5f;
  static float taui = .8660254037844386f;
  int i,k,t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,t10;
  float ci2,ci3,di2,di3,cr2,cr3,dr2,dr3,ti2,tr2;
  t0=l1*ido;

  t1=0;
  t2=t0<<1;
  t3=ido<<1;
  t4=ido+(ido<<1);
  t5=0;
  for(k=0;k<l1;k++){
	tr2=cc[t3-1]+cc[t3-1];
	cr2=cc[t5]+(taur*tr2);
	ch[t1]=cc[t5]+tr2;
	ci3=taui*(cc[t3]+cc[t3]);
	ch[t1+t0]=cr2-ci3;
	ch[t1+t2]=cr2+ci3;
	t1+=ido;
	t3+=t4;
	t5+=t4;
  }

  if(ido==1)return;

  t1=0;
  t3=ido<<1;
  for(k=0;k<l1;k++){
	t7=t1+(t1<<1);
	t6=(t5=t7+t3);
	t8=t1;
	t10=(t9=t1+t0)+t0;

	for(i=2;i<ido;i+=2){
	  t5+=2;
	  t6-=2;
	  t7+=2;
	  t8+=2;
	  t9+=2;
	  t10+=2;
	  tr2=cc[t5-1]+cc[t6-1];
	  cr2=cc[t7-1]+(taur*tr2);
	  ch[t8-1]=cc[t7-1]+tr2;
	  ti2=cc[t5]-cc[t6];
	  ci2=cc[t7]+(taur*ti2);
	  ch[t8]=cc[t7]+ti2;
	  cr3=taui*(cc[t5-1]-cc[t6-1]);
	  ci3=taui*(cc[t5]+cc[t6]);
	  dr2=cr2-ci3;
	  dr3=cr2+ci3;
	  di2=ci2+cr3;
	  di3=ci2-cr3;
	  ch[t9-1]=wa1[i-2]*dr2-wa1[i-1]*di2;
	  ch[t9]=wa1[i-2]*di2+wa1[i-1]*dr2;
	  ch[t10-1]=wa2[i-2]*dr3-wa2[i-1]*di3;
	  ch[t10]=wa2[i-2]*di3+wa2[i-1]*dr3;
	}
	t1+=ido;
  }
}

static void dradb4(int ido,int l1,float *cc,float *ch,float *wa1,
						  float *wa2,float *wa3){
  static float sqrt2=1.414213562373095f;
  int i,k,t0,t1,t2,t3,t4,t5,t6,t7,t8;
  float ci2,ci3,ci4,cr2,cr3,cr4,ti1,ti2,ti3,ti4,tr1,tr2,tr3,tr4;
  t0=l1*ido;

  t1=0;
  t2=ido<<2;
  t3=0;
  t6=ido<<1;
  for(k=0;k<l1;k++){
	t4=t3+t6;
	t5=t1;
	tr3=cc[t4-1]+cc[t4-1];
	tr4=cc[t4]+cc[t4];
	tr1=cc[t3]-cc[(t4+=t6)-1];
	tr2=cc[t3]+cc[t4-1];
	ch[t5]=tr2+tr3;
	ch[t5+=t0]=tr1-tr4;
	ch[t5+=t0]=tr2-tr3;
	ch[t5+=t0]=tr1+tr4;
	t1+=ido;
	t3+=t2;
  }

  if(ido<2)return;
  if(ido==2)goto L105;

  t1=0;
  for(k=0;k<l1;k++){
	t5=(t4=(t3=(t2=t1<<2)+t6))+t6;
	t7=t1;
	for(i=2;i<ido;i+=2){
	  t2+=2;
	  t3+=2;
	  t4-=2;
	  t5-=2;
	  t7+=2;
	  ti1=cc[t2]+cc[t5];
	  ti2=cc[t2]-cc[t5];
	  ti3=cc[t3]-cc[t4];
	  tr4=cc[t3]+cc[t4];
	  tr1=cc[t2-1]-cc[t5-1];
	  tr2=cc[t2-1]+cc[t5-1];
	  ti4=cc[t3-1]-cc[t4-1];
	  tr3=cc[t3-1]+cc[t4-1];
	  ch[t7-1]=tr2+tr3;
	  cr3=tr2-tr3;
	  ch[t7]=ti2+ti3;
	  ci3=ti2-ti3;
	  cr2=tr1-tr4;
	  cr4=tr1+tr4;
	  ci2=ti1+ti4;
	  ci4=ti1-ti4;

	  ch[(t8=t7+t0)-1]=wa1[i-2]*cr2-wa1[i-1]*ci2;
	  ch[t8]=wa1[i-2]*ci2+wa1[i-1]*cr2;
	  ch[(t8+=t0)-1]=wa2[i-2]*cr3-wa2[i-1]*ci3;
	  ch[t8]=wa2[i-2]*ci3+wa2[i-1]*cr3;
	  ch[(t8+=t0)-1]=wa3[i-2]*cr4-wa3[i-1]*ci4;
	  ch[t8]=wa3[i-2]*ci4+wa3[i-1]*cr4;
	}
	t1+=ido;
  }

  if(ido%2 == 1)return;

 L105:

  t1=ido;
  t2=ido<<2;
  t3=ido-1;
  t4=ido+(ido<<1);
  for(k=0;k<l1;k++){
	t5=t3;
	ti1=cc[t1]+cc[t4];
	ti2=cc[t4]-cc[t1];
	tr1=cc[t1-1]-cc[t4-1];
	tr2=cc[t1-1]+cc[t4-1];
	ch[t5]=tr2+tr2;
	ch[t5+=t0]=sqrt2*(tr1-ti1);
	ch[t5+=t0]=ti2+ti2;
	ch[t5+=t0]=-sqrt2*(tr1+ti1);

	t3+=ido;
	t1+=t2;
	t4+=t2;
  }
}

static void dradbg(int ido,int ip,int l1,int idl1,float *cc,float *c1,
			float *c2,float *ch,float *ch2,float *wa){
  static float tpi=6.283185307179586f;
  int idij,ipph,i,j,k,l,ik,is,t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,t10,
	  t11,t12;
  float dc2,ai1,ai2,ar1,ar2,ds2;
  int nbd;
  float dcp,arg,dsp,ar1h,ar2h;
  int ipp2;

  t10=ip*ido;
  t0=l1*ido;
  arg=tpi/(float)ip;
  dcp=cos(arg);
  dsp=sin(arg);
  nbd=(ido-1)>>1;
  ipp2=ip;
  ipph=(ip+1)>>1;
  if(ido<l1)goto L103;

  t1=0;
  t2=0;
  for(k=0;k<l1;k++){
	t3=t1;
	t4=t2;
	for(i=0;i<ido;i++){
	  ch[t3]=cc[t4];
	  t3++;
	  t4++;
	}
	t1+=ido;
	t2+=t10;
  }
  goto L106;

 L103:
  t1=0;
  for(i=0;i<ido;i++){
	t2=t1;
	t3=t1;
	for(k=0;k<l1;k++){
	  ch[t2]=cc[t3];
	  t2+=ido;
	  t3+=t10;
	}
	t1++;
  }

 L106:
  t1=0;
  t2=ipp2*t0;
  t7=(t5=ido<<1);
  for(j=1;j<ipph;j++){
	t1+=t0;
	t2-=t0;
	t3=t1;
	t4=t2;
	t6=t5;
	for(k=0;k<l1;k++){
	  ch[t3]=cc[t6-1]+cc[t6-1];
	  ch[t4]=cc[t6]+cc[t6];
	  t3+=ido;
	  t4+=ido;
	  t6+=t10;
	}
	t5+=t7;
  }

  if (ido == 1)goto L116;
  if(nbd<l1)goto L112;

  t1=0;
  t2=ipp2*t0;
  t7=0;
  for(j=1;j<ipph;j++){
	t1+=t0;
	t2-=t0;
	t3=t1;
	t4=t2;

	t7+=(ido<<1);
	t8=t7;
	for(k=0;k<l1;k++){
	  t5=t3;
	  t6=t4;
	  t9=t8;
	  t11=t8;
	  for(i=2;i<ido;i+=2){
		t5+=2;
		t6+=2;
		t9+=2;
		t11-=2;
		ch[t5-1]=cc[t9-1]+cc[t11-1];
		ch[t6-1]=cc[t9-1]-cc[t11-1];
		ch[t5]=cc[t9]-cc[t11];
		ch[t6]=cc[t9]+cc[t11];
	  }
	  t3+=ido;
	  t4+=ido;
	  t8+=t10;
	}
  }
  goto L116;

 L112:
  t1=0;
  t2=ipp2*t0;
  t7=0;
  for(j=1;j<ipph;j++){
	t1+=t0;
	t2-=t0;
	t3=t1;
	t4=t2;
	t7+=(ido<<1);
	t8=t7;
	t9=t7;
	for(i=2;i<ido;i+=2){
	  t3+=2;
	  t4+=2;
	  t8+=2;
	  t9-=2;
	  t5=t3;
	  t6=t4;
	  t11=t8;
	  t12=t9;
	  for(k=0;k<l1;k++){
		ch[t5-1]=cc[t11-1]+cc[t12-1];
		ch[t6-1]=cc[t11-1]-cc[t12-1];
		ch[t5]=cc[t11]-cc[t12];
		ch[t6]=cc[t11]+cc[t12];
		t5+=ido;
		t6+=ido;
		t11+=t10;
		t12+=t10;
	  }
	}
  }

L116:
  ar1=1.f;
  ai1=0.f;
  t1=0;
  t9=(t2=ipp2*idl1);
  t3=(ip-1)*idl1;
  for(l=1;l<ipph;l++){
	t1+=idl1;
	t2-=idl1;

	ar1h=dcp*ar1-dsp*ai1;
	ai1=dcp*ai1+dsp*ar1;
	ar1=ar1h;
	t4=t1;
	t5=t2;
	t6=0;
	t7=idl1;
	t8=t3;
	for(ik=0;ik<idl1;ik++){
	  c2[t4++]=ch2[t6++]+ar1*ch2[t7++];
	  c2[t5++]=ai1*ch2[t8++];
	}
	dc2=ar1;
	ds2=ai1;
	ar2=ar1;
	ai2=ai1;

	t6=idl1;
	t7=t9-idl1;
	for(j=2;j<ipph;j++){
	  t6+=idl1;
	  t7-=idl1;
	  ar2h=dc2*ar2-ds2*ai2;
	  ai2=dc2*ai2+ds2*ar2;
	  ar2=ar2h;
	  t4=t1;
	  t5=t2;
	  t11=t6;
	  t12=t7;
	  for(ik=0;ik<idl1;ik++){
		c2[t4++]+=ar2*ch2[t11++];
		c2[t5++]+=ai2*ch2[t12++];
	  }
	}
  }

  t1=0;
  for(j=1;j<ipph;j++){
	t1+=idl1;
	t2=t1;
	for(ik=0;ik<idl1;ik++)ch2[ik]+=ch2[t2++];
  }

  t1=0;
  t2=ipp2*t0;
  for(j=1;j<ipph;j++){
	t1+=t0;
	t2-=t0;
	t3=t1;
	t4=t2;
	for(k=0;k<l1;k++){
	  ch[t3]=c1[t3]-c1[t4];
	  ch[t4]=c1[t3]+c1[t4];
	  t3+=ido;
	  t4+=ido;
	}
  }

  if(ido==1)goto L132;
  if(nbd<l1)goto L128;

  t1=0;
  t2=ipp2*t0;
  for(j=1;j<ipph;j++){
	t1+=t0;
	t2-=t0;
	t3=t1;
	t4=t2;
	for(k=0;k<l1;k++){
	  t5=t3;
	  t6=t4;
	  for(i=2;i<ido;i+=2){
		t5+=2;
		t6+=2;
		ch[t5-1]=c1[t5-1]-c1[t6];
		ch[t6-1]=c1[t5-1]+c1[t6];
		ch[t5]=c1[t5]+c1[t6-1];
		ch[t6]=c1[t5]-c1[t6-1];
	  }
	  t3+=ido;
	  t4+=ido;
	}
  }
  goto L132;

 L128:
  t1=0;
  t2=ipp2*t0;
  for(j=1;j<ipph;j++){
	t1+=t0;
	t2-=t0;
	t3=t1;
	t4=t2;
	for(i=2;i<ido;i+=2){
	  t3+=2;
	  t4+=2;
	  t5=t3;
	  t6=t4;
	  for(k=0;k<l1;k++){
		ch[t5-1]=c1[t5-1]-c1[t6];
		ch[t6-1]=c1[t5-1]+c1[t6];
		ch[t5]=c1[t5]+c1[t6-1];
		ch[t6]=c1[t5]-c1[t6-1];
		t5+=ido;
		t6+=ido;
	  }
	}
  }

L132:
  if(ido==1)return;

  for(ik=0;ik<idl1;ik++)c2[ik]=ch2[ik];

  t1=0;
  for(j=1;j<ip;j++){
	t2=(t1+=t0);
	for(k=0;k<l1;k++){
	  c1[t2]=ch[t2];
	  t2+=ido;
	}
  }

  if(nbd>l1)goto L139;

  is= -ido-1;
  t1=0;
  for(j=1;j<ip;j++){
	is+=ido;
	t1+=t0;
	idij=is;
	t2=t1;
	for(i=2;i<ido;i+=2){
	  t2+=2;
	  idij+=2;
	  t3=t2;
	  for(k=0;k<l1;k++){
		c1[t3-1]=wa[idij-1]*ch[t3-1]-wa[idij]*ch[t3];
		c1[t3]=wa[idij-1]*ch[t3]+wa[idij]*ch[t3-1];
		t3+=ido;
	  }
	}
  }
  return;

 L139:
  is= -ido-1;
  t1=0;
  for(j=1;j<ip;j++){
	is+=ido;
	t1+=t0;
	t2=t1;
	for(k=0;k<l1;k++){
	  idij=is;
	  t3=t2;
	  for(i=2;i<ido;i+=2){
		idij+=2;
		t3+=2;
		c1[t3-1]=wa[idij-1]*ch[t3-1]-wa[idij]*ch[t3];
		c1[t3]=wa[idij-1]*ch[t3]+wa[idij]*ch[t3-1];
	  }
	  t2+=ido;
	}
  }
}

static void drftb1(int n, float *c, float *ch, float *wa, int *ifac){
  int i,k1,l1,l2;
  int na;
  int nf,ip,iw,ix2,ix3,ido,idl1;

  nf=ifac[1];
  na=0;
  l1=1;
  iw=1;

  for(k1=0;k1<nf;k1++){
	ip=ifac[k1 + 2];
	l2=ip*l1;
	ido=n/l2;
	idl1=ido*l1;
	if(ip!=4)goto L103;
	ix2=iw+ido;
	ix3=ix2+ido;

	if(na!=0)
	  dradb4(ido,l1,ch,c,wa+iw-1,wa+ix2-1,wa+ix3-1);
	else
	  dradb4(ido,l1,c,ch,wa+iw-1,wa+ix2-1,wa+ix3-1);
	na=1-na;
	goto L115;

  L103:
	if(ip!=2)goto L106;

	if(na!=0)
	  dradb2(ido,l1,ch,c,wa+iw-1);
	else
	  dradb2(ido,l1,c,ch,wa+iw-1);
	na=1-na;
	goto L115;

  L106:
	if(ip!=3)goto L109;

	ix2=iw+ido;
	if(na!=0)
	  dradb3(ido,l1,ch,c,wa+iw-1,wa+ix2-1);
	else
	  dradb3(ido,l1,c,ch,wa+iw-1,wa+ix2-1);
	na=1-na;
	goto L115;

  L109:
/*    The radix five case can be translated later..... */
/*    if(ip!=5)goto L112;

	ix2=iw+ido;
	ix3=ix2+ido;
	ix4=ix3+ido;
	if(na!=0)
	  dradb5(ido,l1,ch,c,wa+iw-1,wa+ix2-1,wa+ix3-1,wa+ix4-1);
	else
	  dradb5(ido,l1,c,ch,wa+iw-1,wa+ix2-1,wa+ix3-1,wa+ix4-1);
	na=1-na;
	goto L115;

  L112:*/
	if(na!=0)
	  dradbg(ido,ip,l1,idl1,ch,ch,ch,c,c,wa+iw-1);
	else
	  dradbg(ido,ip,l1,idl1,c,c,c,ch,ch,wa+iw-1);
	if(ido==1)na=1-na;

  L115:
	l1=l2;
	iw+=(ip-1)*ido;
  }

  if(na==0)return;

  for(i=0;i<n;i++)c[i]=ch[i];
}

void drft_forward(drft_lookup *l,float *data){
  if(l->n==1)return;
  drftf1(l->n,data,l->trigcache,l->trigcache+l->n,l->splitcache);
}

void drft_backward(drft_lookup *l,float *data){
  if (l->n==1)return;
  drftb1(l->n,data,l->trigcache,l->trigcache+l->n,l->splitcache);
}

void drft_init(drft_lookup *l,int n){
  l->n=n;
  l->trigcache=(float*)_ogg_calloc(3*n,sizeof(*l->trigcache));
  l->splitcache=(int*)_ogg_calloc(32,sizeof(*l->splitcache));
  fdrffti(n, l->trigcache, l->splitcache);
}

void drft_clear(drft_lookup *l){
  if(l){
	if(l->trigcache)_ogg_free(l->trigcache);
	if(l->splitcache)_ogg_free(l->splitcache);
	memset(l,0,sizeof(*l));
  }
}

/*** End of inlined file: smallft.c ***/


/*** Start of inlined file: synthesis.c ***/
#include <stdio.h>

int vorbis_synthesis(vorbis_block *vb,ogg_packet *op){
  vorbis_dsp_state     *vd= vb ? vb->vd : 0;
  private_state        *b= vd ? (private_state*)vd->backend_state : 0;
  vorbis_info          *vi= vd ? vd->vi : 0;
  codec_setup_info     *ci= vi ? (codec_setup_info*)vi->codec_setup : 0;
  oggpack_buffer       *opb=vb ? &vb->opb : 0;
  int                   type,mode,i;

  if (!vd || !b || !vi || !ci || !opb) {
	return OV_EBADPACKET;
  }

  /* first things first.  Make sure decode is ready */
  _vorbis_block_ripcord(vb);
  oggpack_readinit(opb,op->packet,op->bytes);

  /* Check the packet type */
  if(oggpack_read(opb,1)!=0){
	/* Oops.  This is not an audio data packet */
	return(OV_ENOTAUDIO);
  }

  /* read our mode and pre/post windowsize */
  mode=oggpack_read(opb,b->modebits);
  if(mode==-1){
	return(OV_EBADPACKET);
  }

  vb->mode=mode;
  if(!ci->mode_param[mode]){
	return(OV_EBADPACKET);
  }

  vb->W=ci->mode_param[mode]->blockflag;
  if(vb->W){

	/* this doesn;t get mapped through mode selection as it's used
	   only for window selection */
	vb->lW=oggpack_read(opb,1);
	vb->nW=oggpack_read(opb,1);
	if(vb->nW==-1){
	  return(OV_EBADPACKET);
	}
  }else{
	vb->lW=0;
	vb->nW=0;
  }

  /* more setup */
  vb->granulepos=op->granulepos;
  vb->sequence=op->packetno;
  vb->eofflag=op->e_o_s;

  /* alloc pcm passback storage */
  vb->pcmend=ci->blocksizes[vb->W];
  vb->pcm=(float**)_vorbis_block_alloc(vb,sizeof(*vb->pcm)*vi->channels);
  for(i=0;i<vi->channels;i++)
	vb->pcm[i]=(float*)_vorbis_block_alloc(vb,vb->pcmend*sizeof(*vb->pcm[i]));

  /* unpack_header enforces range checking */
  type=ci->map_type[ci->mode_param[mode]->mapping];

  return(_mapping_P[type]->inverse(vb,ci->map_param[ci->mode_param[mode]->
												   mapping]));
}

/* used to track pcm position without actually performing decode.
   Useful for sequential 'fast forward' */
int vorbis_synthesis_trackonly(vorbis_block *vb,ogg_packet *op){
  vorbis_dsp_state     *vd=vb->vd;
  private_state        *b=(private_state*)vd->backend_state;
  vorbis_info          *vi=vd->vi;
  codec_setup_info     *ci=(codec_setup_info*)vi->codec_setup;
  oggpack_buffer       *opb=&vb->opb;
  int                   mode;

  /* first things first.  Make sure decode is ready */
  _vorbis_block_ripcord(vb);
  oggpack_readinit(opb,op->packet,op->bytes);

  /* Check the packet type */
  if(oggpack_read(opb,1)!=0){
	/* Oops.  This is not an audio data packet */
	return(OV_ENOTAUDIO);
  }

  /* read our mode and pre/post windowsize */
  mode=oggpack_read(opb,b->modebits);
  if(mode==-1)return(OV_EBADPACKET);

  vb->mode=mode;
  if(!ci->mode_param[mode]){
	return(OV_EBADPACKET);
  }

  vb->W=ci->mode_param[mode]->blockflag;
  if(vb->W){
	vb->lW=oggpack_read(opb,1);
	vb->nW=oggpack_read(opb,1);
	if(vb->nW==-1)   return(OV_EBADPACKET);
  }else{
	vb->lW=0;
	vb->nW=0;
  }

  /* more setup */
  vb->granulepos=op->granulepos;
  vb->sequence=op->packetno;
  vb->eofflag=op->e_o_s;

  /* no pcm */
  vb->pcmend=0;
  vb->pcm=NULL;

  return(0);
}

long vorbis_packet_blocksize(vorbis_info *vi,ogg_packet *op){
  codec_setup_info     *ci=(codec_setup_info*)vi->codec_setup;
  oggpack_buffer       opb;
  int                  mode;

  oggpack_readinit(&opb,op->packet,op->bytes);

  /* Check the packet type */
  if(oggpack_read(&opb,1)!=0){
	/* Oops.  This is not an audio data packet */
	return(OV_ENOTAUDIO);
  }

  {
	int modebits=0;
	int v=ci->modes;
	while(v>1){
	  modebits++;
	  v>>=1;
	}

	/* read our mode and pre/post windowsize */
	mode=oggpack_read(&opb,modebits);
  }
  if(mode==-1)return(OV_EBADPACKET);
  return(ci->blocksizes[ci->mode_param[mode]->blockflag]);
}

int vorbis_synthesis_halfrate(vorbis_info *vi,int flag){
  /* set / clear half-sample-rate mode */
  codec_setup_info     *ci=(codec_setup_info*)vi->codec_setup;

  /* right now, our MDCT can't handle < 64 sample windows. */
  if(ci->blocksizes[0]<=64 && flag)return -1;
  ci->halfrate_flag=(flag?1:0);
  return 0;
}

int vorbis_synthesis_halfrate_p(vorbis_info *vi){
  codec_setup_info     *ci=(codec_setup_info*)vi->codec_setup;
  return ci->halfrate_flag;
}

/*** End of inlined file: synthesis.c ***/


/*** Start of inlined file: vorbisenc.c ***/
#include <stdlib.h>
#include <string.h>
#include <math.h>

/* careful with this; it's using static array sizing to make managing
   all the modes a little less annoying.  If we use a residue backend
   with > 12 partition types, or a different division of iteration,
   this needs to be updated. */
typedef struct {
  const static_codebook *books[12][4];
} static_bookblock;

typedef struct {
  int res_type;
  int limit_type; /* 0 lowpass limited, 1 point stereo limited */
  int grouping;
  const vorbis_info_residue0 *res;
  const static_codebook  *book_aux;
  const static_codebook  *book_aux_managed;
  const static_bookblock *books_base;
  const static_bookblock *books_base_managed;
} vorbis_residue_template;

typedef struct {
  const vorbis_info_mapping0    *map;
  const vorbis_residue_template *res;
} vorbis_mapping_template;

typedef struct vp_adjblock{
  int block[P_BANDS];
} vp_adjblock;

typedef struct {
  int data[NOISE_COMPAND_LEVELS];
} compandblock;

/* high level configuration information for setting things up
   step-by-step with the detailed vorbis_encode_ctl interface.
   There's a fair amount of redundancy such that interactive setup
   does not directly deal with any vorbis_info or codec_setup_info
   initialization; it's all stored (until full init) in this highlevel
   setup, then flushed out to the real codec setup structs later. */

typedef struct {
  int att[P_NOISECURVES];
  float boost;
  float decay;
} att3;
typedef struct { int data[P_NOISECURVES]; } adj3;

typedef struct {
  int   pre[PACKETBLOBS];
  int   post[PACKETBLOBS];
  float kHz[PACKETBLOBS];
  float lowpasskHz[PACKETBLOBS];
} adj_stereo;

typedef struct {
  int lo;
  int hi;
  int fixed;
} noiseguard;
typedef struct {
  int data[P_NOISECURVES][17];
} noise3;

typedef struct {
  int      mappings;
  const double  *rate_mapping;
  const double  *quality_mapping;
  int      coupling_restriction;
  long     samplerate_min_restriction;
  long     samplerate_max_restriction;

  const int     *blocksize_short;
  const int     *blocksize_long;

  const att3    *psy_tone_masteratt;
  const int     *psy_tone_0dB;
  const int     *psy_tone_dBsuppress;

  const vp_adjblock *psy_tone_adj_impulse;
  const vp_adjblock *psy_tone_adj_long;
  const vp_adjblock *psy_tone_adj_other;

  const noiseguard  *psy_noiseguards;
  const noise3      *psy_noise_bias_impulse;
  const noise3      *psy_noise_bias_padding;
  const noise3      *psy_noise_bias_trans;
  const noise3      *psy_noise_bias_long;
  const int         *psy_noise_dBsuppress;

  const compandblock  *psy_noise_compand;
  const double        *psy_noise_compand_short_mapping;
  const double        *psy_noise_compand_long_mapping;

  const int      *psy_noise_normal_start[2];
  const int      *psy_noise_normal_partition[2];
  const double   *psy_noise_normal_thresh;

  const int      *psy_ath_float;
  const int      *psy_ath_abs;

  const double   *psy_lowpass;

  const vorbis_info_psy_global *global_params;
  const double     *global_mapping;
  const adj_stereo *stereo_modes;

  const static_codebook *const *const * floor_books;
  const vorbis_info_floor1 *floor_params;
  int floor_mappings;
  const int **floor_mapping_list;

  const vorbis_mapping_template *maps;
} ve_setup_data_template;

/* a few static coder conventions */
static const vorbis_info_mode _mode_template[2]={
  {0,0,0,0},
  {1,0,0,1}
};

static const vorbis_info_mapping0 _map_nominal[2]={
  {1, {0,0}, {0}, {0}, 1,{0},{1}},
  {1, {0,0}, {1}, {1}, 1,{0},{1}}
};


/*** Start of inlined file: setup_44.h ***/

/*** Start of inlined file: floor_all.h ***/

/*** Start of inlined file: floor_books.h ***/
static const long _huff_lengthlist_line_256x7_0sub1[] = {
		 0, 2, 3, 3, 3, 3, 4, 3, 4,
};

static const static_codebook _huff_book_line_256x7_0sub1 = {
		1, 9,
		(long *)_huff_lengthlist_line_256x7_0sub1,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_256x7_0sub2[] = {
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 4, 3, 4, 3, 5, 3,
		 6, 3, 6, 4, 6, 4, 7, 5, 7,
};

static const static_codebook _huff_book_line_256x7_0sub2 = {
		1, 25,
		(long *)_huff_lengthlist_line_256x7_0sub2,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_256x7_0sub3[] = {
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 5, 2, 5, 3, 5, 3,
		 6, 3, 6, 4, 7, 6, 7, 8, 7, 9, 8, 9, 9, 9,10, 9,
		11,13,11,13,10,10,13,13,13,13,13,13,12,12,12,12,
};

static const static_codebook _huff_book_line_256x7_0sub3 = {
		1, 64,
		(long *)_huff_lengthlist_line_256x7_0sub3,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_256x7_1sub1[] = {
		 0, 3, 3, 3, 3, 2, 4, 3, 4,
};

static const static_codebook _huff_book_line_256x7_1sub1 = {
		1, 9,
		(long *)_huff_lengthlist_line_256x7_1sub1,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_256x7_1sub2[] = {
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 3, 4, 3, 4, 4,
		 5, 4, 6, 5, 6, 7, 6, 8, 8,
};

static const static_codebook _huff_book_line_256x7_1sub2 = {
		1, 25,
		(long *)_huff_lengthlist_line_256x7_1sub2,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_256x7_1sub3[] = {
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 2, 4, 3, 6, 3, 7,
		 3, 8, 5, 8, 6, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
		 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7,
};

static const static_codebook _huff_book_line_256x7_1sub3 = {
		1, 64,
		(long *)_huff_lengthlist_line_256x7_1sub3,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_256x7_class0[] = {
		 7, 5, 5, 9, 9, 6, 6, 9,12, 8, 7, 8,11, 8, 9,15,
		 6, 3, 3, 7, 7, 4, 3, 6, 9, 6, 5, 6, 8, 6, 8,15,
		 8, 5, 5, 9, 8, 5, 4, 6,10, 7, 5, 5,11, 8, 7,15,
		14,15,13,13,13,13, 8,11,15,10, 7, 6,11, 9,10,15,
};

static const static_codebook _huff_book_line_256x7_class0 = {
		1, 64,
		(long *)_huff_lengthlist_line_256x7_class0,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_256x7_class1[] = {
		 5, 6, 8,15, 6, 9,10,15,10,11,12,15,15,15,15,15,
		 4, 6, 7,15, 6, 7, 8,15, 9, 8, 9,15,15,15,15,15,
		 6, 8, 9,15, 7, 7, 8,15,10, 9,10,15,15,15,15,15,
		15,13,15,15,15,10,11,15,15,13,13,15,15,15,15,15,
		 4, 6, 7,15, 6, 8, 9,15,10,10,12,15,15,15,15,15,
		 2, 5, 6,15, 5, 6, 7,15, 8, 6, 7,15,15,15,15,15,
		 5, 6, 8,15, 5, 6, 7,15, 9, 6, 7,15,15,15,15,15,
		14,12,13,15,12,10,11,15,15,15,15,15,15,15,15,15,
		 7, 8, 9,15, 9,10,10,15,15,14,14,15,15,15,15,15,
		 5, 6, 7,15, 7, 8, 9,15,12, 9,10,15,15,15,15,15,
		 7, 7, 9,15, 7, 7, 8,15,12, 8, 9,15,15,15,15,15,
		13,13,14,15,12,11,12,15,15,15,15,15,15,15,15,15,
		15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
		13,13,13,15,15,15,15,15,15,15,15,15,15,15,15,15,
		15,12,13,15,15,12,13,15,15,14,15,15,15,15,15,15,
		15,15,15,15,15,15,13,15,15,15,15,15,15,15,15,15,
};

static const static_codebook _huff_book_line_256x7_class1 = {
		1, 256,
		(long *)_huff_lengthlist_line_256x7_class1,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_512x17_0sub0[] = {
		 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
		 5, 6, 5, 6, 6, 6, 6, 5, 6, 6, 7, 6, 7, 6, 7, 6,
		 7, 6, 8, 7, 8, 7, 8, 7, 8, 7, 8, 7, 9, 7, 9, 7,
		 9, 7, 9, 8, 9, 8,10, 8,10, 8,10, 7,10, 6,10, 8,
		10, 8,11, 7,10, 7,11, 8,11,11,12,12,11,11,12,11,
		13,11,13,11,13,12,15,12,13,13,14,14,14,14,14,15,
		15,15,16,14,17,19,19,18,18,18,18,18,18,18,18,18,
		18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
};

static const static_codebook _huff_book_line_512x17_0sub0 = {
		1, 128,
		(long *)_huff_lengthlist_line_512x17_0sub0,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_512x17_1sub0[] = {
		 2, 4, 5, 4, 5, 4, 5, 4, 5, 5, 5, 5, 5, 5, 6, 5,
		 6, 5, 6, 6, 7, 6, 7, 6, 8, 7, 8, 7, 8, 7, 8, 7,
};

static const static_codebook _huff_book_line_512x17_1sub0 = {
		1, 32,
		(long *)_huff_lengthlist_line_512x17_1sub0,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_512x17_1sub1[] = {
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 4, 3, 5, 3, 5, 4, 5, 4, 5, 4, 5, 5, 5, 5, 6, 5,
		 6, 5, 7, 5, 8, 6, 8, 6, 8, 6, 8, 6, 8, 7, 9, 7,
		 9, 7,11, 9,11,11,12,11,14,12,14,16,14,16,13,16,
		14,16,12,15,13,16,14,16,13,14,12,15,13,15,13,13,
		13,15,12,14,14,15,13,15,12,15,15,15,15,15,15,15,
		15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
};

static const static_codebook _huff_book_line_512x17_1sub1 = {
		1, 128,
		(long *)_huff_lengthlist_line_512x17_1sub1,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_512x17_2sub1[] = {
		 0, 4, 5, 4, 4, 4, 5, 4, 4, 4, 5, 4, 5, 4, 5, 3,
		 5, 3,
};

static const static_codebook _huff_book_line_512x17_2sub1 = {
		1, 18,
		(long *)_huff_lengthlist_line_512x17_2sub1,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_512x17_2sub2[] = {
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 4, 3, 4, 3, 4, 4, 5, 4, 5, 4, 6, 4, 6, 5,
		 6, 5, 7, 5, 7, 6, 8, 6, 8, 6, 8, 7, 8, 7, 9, 7,
		 9, 8,
};

static const static_codebook _huff_book_line_512x17_2sub2 = {
		1, 50,
		(long *)_huff_lengthlist_line_512x17_2sub2,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_512x17_2sub3[] = {
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 3, 3, 3, 3, 4, 3, 4, 4, 5, 5, 6, 6, 7, 7,
		 7, 8, 8,11, 8, 9, 9, 9,10,11,11,11, 9,10,10,11,
		11,11,11,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
};

static const static_codebook _huff_book_line_512x17_2sub3 = {
		1, 128,
		(long *)_huff_lengthlist_line_512x17_2sub3,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_512x17_3sub1[] = {
		 0, 4, 4, 4, 4, 4, 4, 3, 4, 4, 4, 4, 4, 5, 4, 5,
		 5, 5,
};

static const static_codebook _huff_book_line_512x17_3sub1 = {
		1, 18,
		(long *)_huff_lengthlist_line_512x17_3sub1,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_512x17_3sub2[] = {
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 2, 3, 3, 4, 3, 5, 4, 6, 4, 6, 5, 7, 6, 7,
		 6, 8, 6, 8, 7, 9, 8,10, 8,12, 9,13,10,15,10,15,
		11,14,
};

static const static_codebook _huff_book_line_512x17_3sub2 = {
		1, 50,
		(long *)_huff_lengthlist_line_512x17_3sub2,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_512x17_3sub3[] = {
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 4, 8, 4, 8, 4, 8, 4, 8, 5, 8, 5, 8, 6, 8,
		 4, 8, 4, 8, 5, 8, 5, 7, 7, 7, 7, 7, 7, 7, 7, 7,
		 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
		 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
		 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
};

static const static_codebook _huff_book_line_512x17_3sub3 = {
		1, 128,
		(long *)_huff_lengthlist_line_512x17_3sub3,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_512x17_class1[] = {
		 1, 2, 3, 6, 5, 4, 7, 7,
};

static const static_codebook _huff_book_line_512x17_class1 = {
		1, 8,
		(long *)_huff_lengthlist_line_512x17_class1,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_512x17_class2[] = {
		 3, 3, 3,14, 5, 4, 4,11, 8, 6, 6,10,17,12,11,17,
		 6, 5, 5,15, 5, 3, 4,11, 8, 5, 5, 8,16, 9,10,14,
		10, 8, 9,17, 8, 6, 6,13,10, 7, 7,10,16,11,13,14,
		17,17,17,17,17,16,16,16,16,15,16,16,16,16,16,16,
};

static const static_codebook _huff_book_line_512x17_class2 = {
		1, 64,
		(long *)_huff_lengthlist_line_512x17_class2,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_512x17_class3[] = {
		 2, 4, 6,17, 4, 5, 7,17, 8, 7,10,17,17,17,17,17,
		 3, 4, 6,15, 3, 3, 6,15, 7, 6, 9,17,17,17,17,17,
		 6, 8,10,17, 6, 6, 8,16, 9, 8,10,17,17,15,16,17,
		17,17,17,17,12,15,15,16,12,15,15,16,16,16,16,16,
};

static const static_codebook _huff_book_line_512x17_class3 = {
		1, 64,
		(long *)_huff_lengthlist_line_512x17_class3,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_128x4_class0[] = {
		 7, 7, 7,11, 6, 6, 7,11, 7, 6, 6,10,12,10,10,13,
		 7, 7, 8,11, 7, 7, 7,11, 7, 6, 7,10,11,10,10,13,
		10,10, 9,12, 9, 9, 9,11, 8, 8, 8,11,13,11,10,14,
		15,15,14,15,15,14,13,14,15,12,12,17,17,17,17,17,
		 7, 7, 6, 9, 6, 6, 6, 9, 7, 6, 6, 8,11,11,10,12,
		 7, 7, 7, 9, 7, 6, 6, 9, 7, 6, 6, 9,13,10,10,11,
		10, 9, 8,10, 9, 8, 8,10, 8, 8, 7, 9,13,12,10,11,
		17,14,14,13,15,14,12,13,17,13,12,15,17,17,14,17,
		 7, 6, 6, 7, 6, 6, 5, 7, 6, 6, 6, 6,11, 9, 9, 9,
		 7, 7, 6, 7, 7, 6, 6, 7, 6, 6, 6, 6,10, 9, 8, 9,
		10, 9, 8, 8, 9, 8, 7, 8, 8, 7, 6, 8,11,10, 9,10,
		17,17,12,15,15,15,12,14,14,14,10,12,15,13,12,13,
		11,10, 8,10,11,10, 8, 8,10, 9, 7, 7,10, 9, 9,11,
		11,11, 9,10,11,10, 8, 9,10, 8, 6, 8,10, 9, 9,11,
		14,13,10,12,12,11,10,10, 8, 7, 8,10,10,11,11,12,
		17,17,15,17,17,17,17,17,17,13,12,17,17,17,14,17,
};

static const static_codebook _huff_book_line_128x4_class0 = {
		1, 256,
		(long *)_huff_lengthlist_line_128x4_class0,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_128x4_0sub0[] = {
		 2, 2, 2, 2,
};

static const static_codebook _huff_book_line_128x4_0sub0 = {
		1, 4,
		(long *)_huff_lengthlist_line_128x4_0sub0,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_128x4_0sub1[] = {
		 0, 0, 0, 0, 3, 2, 3, 2, 3, 3,
};

static const static_codebook _huff_book_line_128x4_0sub1 = {
		1, 10,
		(long *)_huff_lengthlist_line_128x4_0sub1,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_128x4_0sub2[] = {
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 4, 3, 4, 3,
		 4, 4, 5, 4, 5, 4, 6, 5, 6,
};

static const static_codebook _huff_book_line_128x4_0sub2 = {
		1, 25,
		(long *)_huff_lengthlist_line_128x4_0sub2,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_128x4_0sub3[] = {
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 4, 3, 5, 3, 5, 3,
		 5, 4, 6, 5, 6, 5, 7, 6, 6, 7, 7, 9, 9,11,11,16,
		11,14,10,11,11,13,16,15,15,15,15,15,15,15,15,15,
};

static const static_codebook _huff_book_line_128x4_0sub3 = {
		1, 64,
		(long *)_huff_lengthlist_line_128x4_0sub3,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_256x4_class0[] = {
		 6, 7, 7,12, 6, 6, 7,12, 7, 6, 6,10,15,12,11,13,
		 7, 7, 8,13, 7, 7, 8,12, 7, 7, 7,11,12,12,11,13,
		10, 9, 9,11, 9, 9, 9,10,10, 8, 8,12,14,12,12,14,
		11,11,12,14,11,12,11,15,15,12,13,15,15,15,15,15,
		 6, 6, 7,10, 6, 6, 6,11, 7, 6, 6, 9,14,12,11,13,
		 7, 7, 7,10, 6, 6, 7, 9, 7, 7, 6,10,13,12,10,12,
		 9, 9, 9,11, 9, 9, 8, 9, 9, 8, 8,10,13,12,10,12,
		12,12,11,13,12,12,11,12,15,13,12,15,15,15,14,14,
		 6, 6, 6, 8, 6, 6, 5, 6, 7, 7, 6, 5,11,10, 9, 8,
		 7, 6, 6, 7, 6, 6, 5, 6, 7, 7, 6, 6,11,10, 9, 8,
		 8, 8, 8, 9, 8, 8, 7, 8, 8, 8, 6, 7,11,10, 9, 9,
		14,11,10,14,14,11,10,15,13,11, 9,11,15,12,12,11,
		11, 9, 8, 8,10, 9, 8, 9,11,10, 9, 8,12,11,12,11,
		13,10, 8, 9,11,10, 8, 9,10, 9, 8, 9,10, 8,12,12,
		15,11,10,10,13,11,10,10, 8, 8, 7,12,10, 9,11,12,
		15,12,11,15,13,11,11,15,12,14,11,13,15,15,13,13,
};

static const static_codebook _huff_book_line_256x4_class0 = {
		1, 256,
		(long *)_huff_lengthlist_line_256x4_class0,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_256x4_0sub0[] = {
		 2, 2, 2, 2,
};

static const static_codebook _huff_book_line_256x4_0sub0 = {
		1, 4,
		(long *)_huff_lengthlist_line_256x4_0sub0,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_256x4_0sub1[] = {
		 0, 0, 0, 0, 2, 2, 3, 3, 3, 3,
};

static const static_codebook _huff_book_line_256x4_0sub1 = {
		1, 10,
		(long *)_huff_lengthlist_line_256x4_0sub1,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_256x4_0sub2[] = {
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 3, 4, 3, 4, 3,
		 5, 3, 5, 4, 5, 4, 6, 4, 6,
};

static const static_codebook _huff_book_line_256x4_0sub2 = {
		1, 25,
		(long *)_huff_lengthlist_line_256x4_0sub2,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_256x4_0sub3[] = {
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 4, 3, 5, 3, 5, 3,
		 6, 4, 7, 4, 7, 5, 7, 6, 7, 6, 7, 8,10,13,13,13,
		13,13,13,13,13,13,13,13,13,13,13,12,12,12,12,12,
};

static const static_codebook _huff_book_line_256x4_0sub3 = {
		1, 64,
		(long *)_huff_lengthlist_line_256x4_0sub3,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_128x7_class0[] = {
		10, 7, 8,13, 9, 6, 7,11,10, 8, 8,12,17,17,17,17,
		 7, 5, 5, 9, 6, 4, 4, 8, 8, 5, 5, 8,16,14,13,16,
		 7, 5, 5, 7, 6, 3, 3, 5, 8, 5, 4, 7,14,12,12,15,
		10, 7, 8, 9, 7, 5, 5, 6, 9, 6, 5, 5,15,12, 9,10,
};

static const static_codebook _huff_book_line_128x7_class0 = {
		1, 64,
		(long *)_huff_lengthlist_line_128x7_class0,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_128x7_class1[] = {
		 8,13,17,17, 8,11,17,17,11,13,17,17,17,17,17,17,
		 6,10,16,17, 6,10,15,17, 8,10,16,17,17,17,17,17,
		 9,13,15,17, 8,11,17,17,10,12,17,17,17,17,17,17,
		17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,
		 6,11,15,17, 7,10,15,17, 8,10,17,17,17,15,17,17,
		 4, 8,13,17, 4, 7,13,17, 6, 8,15,17,16,15,17,17,
		 6,11,15,17, 6, 9,13,17, 8,10,17,17,15,17,17,17,
		16,17,17,17,12,14,15,17,13,14,15,17,17,17,17,17,
		 5,10,14,17, 5, 9,14,17, 7, 9,15,17,15,15,17,17,
		 3, 7,12,17, 3, 6,11,17, 5, 7,13,17,12,12,17,17,
		 5, 9,14,17, 3, 7,11,17, 5, 8,13,17,13,11,16,17,
		12,17,17,17, 9,14,15,17,10,11,14,17,16,14,17,17,
		 8,12,17,17, 8,12,17,17,10,12,17,17,17,17,17,17,
		 5,10,17,17, 5, 9,15,17, 7, 9,17,17,13,13,17,17,
		 7,11,17,17, 6,10,15,17, 7, 9,15,17,12,11,17,17,
		12,15,17,17,11,14,17,17,11,10,15,17,17,16,17,17,
};

static const static_codebook _huff_book_line_128x7_class1 = {
		1, 256,
		(long *)_huff_lengthlist_line_128x7_class1,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_128x7_0sub1[] = {
		 0, 3, 3, 3, 3, 3, 3, 3, 3,
};

static const static_codebook _huff_book_line_128x7_0sub1 = {
		1, 9,
		(long *)_huff_lengthlist_line_128x7_0sub1,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_128x7_0sub2[] = {
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 4, 4, 4, 4,
		 5, 4, 5, 4, 5, 4, 6, 4, 6,
};

static const static_codebook _huff_book_line_128x7_0sub2 = {
		1, 25,
		(long *)_huff_lengthlist_line_128x7_0sub2,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_128x7_0sub3[] = {
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 5, 3, 5, 3, 5, 4,
		 5, 4, 5, 5, 5, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5,
		 7, 8, 9,11,13,13,13,13,13,13,13,13,13,13,13,13,
};

static const static_codebook _huff_book_line_128x7_0sub3 = {
		1, 64,
		(long *)_huff_lengthlist_line_128x7_0sub3,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_128x7_1sub1[] = {
		 0, 3, 3, 2, 3, 3, 4, 3, 4,
};

static const static_codebook _huff_book_line_128x7_1sub1 = {
		1, 9,
		(long *)_huff_lengthlist_line_128x7_1sub1,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_128x7_1sub2[] = {
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 4, 3, 6, 3, 6, 3,
		 6, 3, 7, 3, 8, 4, 9, 4, 9,
};

static const static_codebook _huff_book_line_128x7_1sub2 = {
		1, 25,
		(long *)_huff_lengthlist_line_128x7_1sub2,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_128x7_1sub3[] = {
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 7, 2, 7, 3, 8, 4,
		 9, 5, 9, 8,10,11,11,12,14,14,14,14,14,14,14,14,
		14,14,14,14,14,14,14,14,14,14,14,14,13,13,13,13,
};

static const static_codebook _huff_book_line_128x7_1sub3 = {
		1, 64,
		(long *)_huff_lengthlist_line_128x7_1sub3,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_128x11_class1[] = {
		 1, 6, 3, 7, 2, 4, 5, 7,
};

static const static_codebook _huff_book_line_128x11_class1 = {
		1, 8,
		(long *)_huff_lengthlist_line_128x11_class1,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_128x11_class2[] = {
		 1, 6,12,16, 4,12,15,16, 9,15,16,16,16,16,16,16,
		 2, 5,11,16, 5,11,13,16, 9,13,16,16,16,16,16,16,
		 4, 8,12,16, 5, 9,12,16, 9,13,15,16,16,16,16,16,
		15,16,16,16,11,14,13,16,12,15,16,16,16,16,16,15,
};

static const static_codebook _huff_book_line_128x11_class2 = {
		1, 64,
		(long *)_huff_lengthlist_line_128x11_class2,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_128x11_class3[] = {
		 7, 6, 9,17, 7, 6, 8,17,12, 9,11,16,16,16,16,16,
		 5, 4, 7,16, 5, 3, 6,14, 9, 6, 8,15,16,16,16,16,
		 5, 4, 6,13, 3, 2, 4,11, 7, 4, 6,13,16,11,10,14,
		12,12,12,16, 9, 7,10,15,12, 9,11,16,16,15,15,16,
};

static const static_codebook _huff_book_line_128x11_class3 = {
		1, 64,
		(long *)_huff_lengthlist_line_128x11_class3,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_128x11_0sub0[] = {
		 5, 5, 5, 5, 5, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5,
		 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 6, 6, 6, 7, 6,
		 7, 6, 7, 6, 7, 6, 7, 6, 7, 6, 8, 6, 8, 6, 8, 7,
		 8, 7, 8, 7, 8, 7, 9, 7, 9, 8, 9, 8, 9, 8,10, 8,
		10, 9,10, 9,10, 9,11, 9,11, 9,10,10,11,10,11,10,
		11,11,11,11,11,11,12,13,14,14,14,15,15,16,16,16,
		17,15,16,15,16,16,17,17,16,17,17,17,17,17,17,17,
		17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,
};

static const static_codebook _huff_book_line_128x11_0sub0 = {
		1, 128,
		(long *)_huff_lengthlist_line_128x11_0sub0,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_128x11_1sub0[] = {
		 2, 5, 5, 5, 5, 5, 5, 4, 5, 5, 5, 5, 5, 5, 5, 5,
		 6, 5, 6, 5, 6, 5, 7, 6, 7, 6, 7, 6, 8, 6, 8, 6,
};

static const static_codebook _huff_book_line_128x11_1sub0 = {
		1, 32,
		(long *)_huff_lengthlist_line_128x11_1sub0,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_128x11_1sub1[] = {
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 5, 3, 5, 3, 6, 4, 6, 4, 7, 4, 7, 4, 7, 4, 8, 4,
		 8, 4, 9, 5, 9, 5, 9, 5, 9, 6,10, 6,10, 6,11, 7,
		10, 7,10, 8,11, 9,11, 9,11,10,11,11,12,11,11,12,
		15,15,12,14,11,14,12,14,11,14,13,14,12,14,11,14,
		11,14,12,14,11,14,11,14,13,13,14,14,14,14,14,14,
		14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,
};

static const static_codebook _huff_book_line_128x11_1sub1 = {
		1, 128,
		(long *)_huff_lengthlist_line_128x11_1sub1,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_128x11_2sub1[] = {
		 0, 4, 5, 4, 5, 4, 5, 3, 5, 3, 5, 3, 5, 4, 4, 4,
		 5, 5,
};

static const static_codebook _huff_book_line_128x11_2sub1 = {
		1, 18,
		(long *)_huff_lengthlist_line_128x11_2sub1,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_128x11_2sub2[] = {
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 3, 3, 3, 4, 4, 4, 4, 5, 4, 5, 4, 6, 5, 7,
		 5, 7, 6, 8, 6, 8, 6, 9, 7, 9, 7,10, 7, 9, 8,11,
		 8,11,
};

static const static_codebook _huff_book_line_128x11_2sub2 = {
		1, 50,
		(long *)_huff_lengthlist_line_128x11_2sub2,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_128x11_2sub3[] = {
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 4, 8, 3, 8, 4, 8, 4, 8, 6, 8, 5, 8, 4, 8,
		 4, 8, 6, 8, 7, 8, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
		 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
		 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
		 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
};

static const static_codebook _huff_book_line_128x11_2sub3 = {
		1, 128,
		(long *)_huff_lengthlist_line_128x11_2sub3,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_128x11_3sub1[] = {
		 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 4,
		 5, 4,
};

static const static_codebook _huff_book_line_128x11_3sub1 = {
		1, 18,
		(long *)_huff_lengthlist_line_128x11_3sub1,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_128x11_3sub2[] = {
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 5, 3, 5, 4, 6, 4, 6, 4, 7, 4, 7, 4, 8, 4,
		 8, 4, 9, 4, 9, 4,10, 4,10, 5,10, 5,11, 5,12, 6,
		12, 6,
};

static const static_codebook _huff_book_line_128x11_3sub2 = {
		1, 50,
		(long *)_huff_lengthlist_line_128x11_3sub2,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_128x11_3sub3[] = {
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 7, 1, 6, 3, 7, 3, 8, 4, 8, 5, 8, 8, 8, 9,
		 7, 8, 8, 7, 7, 7, 8, 9,10, 9, 9,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10, 9, 9,
};

static const static_codebook _huff_book_line_128x11_3sub3 = {
		1, 128,
		(long *)_huff_lengthlist_line_128x11_3sub3,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_128x17_class1[] = {
		 1, 3, 4, 7, 2, 5, 6, 7,
};

static const static_codebook _huff_book_line_128x17_class1 = {
		1, 8,
		(long *)_huff_lengthlist_line_128x17_class1,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_128x17_class2[] = {
		 1, 4,10,19, 3, 8,13,19, 7,12,19,19,19,19,19,19,
		 2, 6,11,19, 8,13,19,19, 9,11,19,19,19,19,19,19,
		 6, 7,13,19, 9,13,19,19,10,13,18,18,18,18,18,18,
		18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
};

static const static_codebook _huff_book_line_128x17_class2 = {
		1, 64,
		(long *)_huff_lengthlist_line_128x17_class2,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_128x17_class3[] = {
		 3, 6,10,17, 4, 8,11,20, 8,10,11,20,20,20,20,20,
		 2, 4, 8,18, 4, 6, 8,17, 7, 8,10,20,20,17,20,20,
		 3, 5, 8,17, 3, 4, 6,17, 8, 8,10,17,17,12,16,20,
		13,13,15,20,10,10,12,20,15,14,15,20,20,20,19,19,
};

static const static_codebook _huff_book_line_128x17_class3 = {
		1, 64,
		(long *)_huff_lengthlist_line_128x17_class3,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_128x17_0sub0[] = {
		 5, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5,
		 7, 5, 7, 5, 7, 5, 7, 5, 7, 5, 7, 5, 8, 5, 8, 5,
		 8, 5, 8, 5, 8, 6, 8, 6, 8, 6, 9, 6, 9, 6, 9, 6,
		 9, 6, 9, 7, 9, 7, 9, 7, 9, 7,10, 7,10, 8,10, 8,
		10, 8,10, 8,10, 8,11, 8,11, 8,11, 8,11, 8,11, 9,
		12, 9,12, 9,12, 9,12, 9,12,10,12,10,13,11,13,11,
		14,12,14,13,15,14,16,14,17,15,18,16,20,20,20,20,
		20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,
};

static const static_codebook _huff_book_line_128x17_0sub0 = {
		1, 128,
		(long *)_huff_lengthlist_line_128x17_0sub0,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_128x17_1sub0[] = {
		 2, 5, 5, 4, 5, 4, 5, 4, 5, 5, 5, 5, 5, 5, 6, 5,
		 6, 5, 6, 5, 7, 6, 7, 6, 7, 6, 8, 6, 9, 7, 9, 7,
};

static const static_codebook _huff_book_line_128x17_1sub0 = {
		1, 32,
		(long *)_huff_lengthlist_line_128x17_1sub0,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_128x17_1sub1[] = {
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 4, 3, 5, 3, 5, 3, 6, 3, 6, 4, 6, 4, 7, 4, 7, 5,
		 8, 5, 8, 6, 9, 7, 9, 7, 9, 8,10, 9,10, 9,11,10,
		11,11,11,11,11,11,12,12,12,13,12,13,12,14,12,15,
		12,14,12,16,13,17,13,17,14,17,14,16,13,17,14,17,
		14,17,15,17,15,15,16,17,17,17,17,17,17,17,17,17,
		17,17,17,17,17,17,16,16,16,16,16,16,16,16,16,16,
};

static const static_codebook _huff_book_line_128x17_1sub1 = {
		1, 128,
		(long *)_huff_lengthlist_line_128x17_1sub1,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_128x17_2sub1[] = {
		 0, 4, 5, 4, 6, 4, 8, 3, 9, 3, 9, 2, 9, 3, 8, 4,
		 9, 4,
};

static const static_codebook _huff_book_line_128x17_2sub1 = {
		1, 18,
		(long *)_huff_lengthlist_line_128x17_2sub1,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_128x17_2sub2[] = {
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 5, 1, 5, 3, 5, 3, 5, 4, 7, 5,10, 7,10, 7,
		12,10,14,10,14, 9,14,11,14,14,14,13,13,13,13,13,
		13,13,
};

static const static_codebook _huff_book_line_128x17_2sub2 = {
		1, 50,
		(long *)_huff_lengthlist_line_128x17_2sub2,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_128x17_2sub3[] = {
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
		 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6,
		 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
		 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
		 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
};

static const static_codebook _huff_book_line_128x17_2sub3 = {
		1, 128,
		(long *)_huff_lengthlist_line_128x17_2sub3,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_128x17_3sub1[] = {
		 0, 4, 4, 4, 4, 4, 4, 4, 5, 3, 5, 3, 5, 4, 6, 4,
		 6, 4,
};

static const static_codebook _huff_book_line_128x17_3sub1 = {
		1, 18,
		(long *)_huff_lengthlist_line_128x17_3sub1,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_128x17_3sub2[] = {
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 5, 3, 6, 3, 6, 4, 7, 4, 7, 4, 7, 4, 8, 4,
		 8, 4, 8, 4, 8, 4, 9, 4, 9, 5,10, 5,10, 7,10, 8,
		10, 8,
};

static const static_codebook _huff_book_line_128x17_3sub2 = {
		1, 50,
		(long *)_huff_lengthlist_line_128x17_3sub2,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_128x17_3sub3[] = {
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 3, 2, 4, 3, 4, 4, 4, 5, 4, 7, 5, 8, 5,11,
		 6,10, 6,12, 7,12, 7,12, 8,12, 8,12,10,12,12,12,
		12,12,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
};

static const static_codebook _huff_book_line_128x17_3sub3 = {
		1, 128,
		(long *)_huff_lengthlist_line_128x17_3sub3,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_1024x27_class1[] = {
		 2,10, 8,14, 7,12,11,14, 1, 5, 3, 7, 4, 9, 7,13,
};

static const static_codebook _huff_book_line_1024x27_class1 = {
		1, 16,
		(long *)_huff_lengthlist_line_1024x27_class1,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_1024x27_class2[] = {
		 1, 4, 2, 6, 3, 7, 5, 7,
};

static const static_codebook _huff_book_line_1024x27_class2 = {
		1, 8,
		(long *)_huff_lengthlist_line_1024x27_class2,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_1024x27_class3[] = {
		 1, 5, 7,21, 5, 8, 9,21,10, 9,12,20,20,16,20,20,
		 4, 8, 9,20, 6, 8, 9,20,11,11,13,20,20,15,17,20,
		 9,11,14,20, 8,10,15,20,11,13,15,20,20,20,20,20,
		20,20,20,20,13,20,20,20,18,18,20,20,20,20,20,20,
		 3, 6, 8,20, 6, 7, 9,20,10, 9,12,20,20,20,20,20,
		 5, 7, 9,20, 6, 6, 9,20,10, 9,12,20,20,20,20,20,
		 8,10,13,20, 8, 9,12,20,11,10,12,20,20,20,20,20,
		18,20,20,20,15,17,18,20,18,17,18,20,20,20,20,20,
		 7,10,12,20, 8, 9,11,20,14,13,14,20,20,20,20,20,
		 6, 9,12,20, 7, 8,11,20,12,11,13,20,20,20,20,20,
		 9,11,15,20, 8,10,14,20,12,11,14,20,20,20,20,20,
		20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,
		11,16,18,20,15,15,17,20,20,17,20,20,20,20,20,20,
		 9,14,16,20,12,12,15,20,17,15,18,20,20,20,20,20,
		16,19,18,20,15,16,20,20,17,17,20,20,20,20,20,20,
		20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,
};

static const static_codebook _huff_book_line_1024x27_class3 = {
		1, 256,
		(long *)_huff_lengthlist_line_1024x27_class3,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_1024x27_class4[] = {
		 2, 3, 7,13, 4, 4, 7,15, 8, 6, 9,17,21,16,15,21,
		 2, 5, 7,11, 5, 5, 7,14, 9, 7,10,16,17,15,16,21,
		 4, 7,10,17, 7, 7, 9,15,11, 9,11,16,21,18,15,21,
		18,21,21,21,15,17,17,19,21,19,18,20,21,21,21,20,
};

static const static_codebook _huff_book_line_1024x27_class4 = {
		1, 64,
		(long *)_huff_lengthlist_line_1024x27_class4,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_1024x27_0sub0[] = {
		 5, 5, 5, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5,
		 6, 5, 6, 5, 6, 5, 6, 5, 7, 5, 7, 5, 7, 5, 7, 5,
		 8, 6, 8, 6, 8, 6, 9, 6, 9, 6,10, 6,10, 6,11, 6,
		11, 7,11, 7,12, 7,12, 7,12, 7,12, 7,12, 7,12, 7,
		12, 7,12, 8,13, 8,12, 8,12, 8,13, 8,13, 9,13, 9,
		13, 9,13, 9,12,10,12,10,13,10,14,11,14,12,14,13,
		14,13,14,14,15,16,15,15,15,14,15,17,21,22,22,21,
		22,22,22,22,22,22,21,21,21,21,21,21,21,21,21,21,
};

static const static_codebook _huff_book_line_1024x27_0sub0 = {
		1, 128,
		(long *)_huff_lengthlist_line_1024x27_0sub0,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_1024x27_1sub0[] = {
		 2, 5, 5, 4, 5, 4, 5, 4, 5, 4, 6, 5, 6, 5, 6, 5,
		 6, 5, 7, 5, 7, 6, 8, 6, 8, 6, 8, 6, 9, 6, 9, 6,
};

static const static_codebook _huff_book_line_1024x27_1sub0 = {
		1, 32,
		(long *)_huff_lengthlist_line_1024x27_1sub0,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_1024x27_1sub1[] = {
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 8, 5, 8, 4, 9, 4, 9, 4, 9, 4, 9, 4, 9, 4, 9, 4,
		 9, 4, 9, 4, 9, 4, 8, 4, 8, 4, 9, 5, 9, 5, 9, 5,
		 9, 5, 9, 6,10, 6,10, 7,10, 8,11, 9,11,11,12,13,
		12,14,13,15,13,15,14,16,14,17,15,17,15,15,16,16,
		15,16,16,16,15,18,16,15,17,17,19,19,19,19,19,19,
		19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,
};

static const static_codebook _huff_book_line_1024x27_1sub1 = {
		1, 128,
		(long *)_huff_lengthlist_line_1024x27_1sub1,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_1024x27_2sub0[] = {
		 1, 5, 5, 5, 5, 5, 5, 5, 6, 5, 6, 5, 6, 5, 6, 5,
		 6, 6, 7, 7, 7, 7, 8, 7, 8, 8, 9, 8,10, 9,10, 9,
};

static const static_codebook _huff_book_line_1024x27_2sub0 = {
		1, 32,
		(long *)_huff_lengthlist_line_1024x27_2sub0,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_1024x27_2sub1[] = {
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 4, 3, 4, 3, 4, 4, 5, 4, 5, 4, 5, 5, 6, 5, 6, 5,
		 7, 5, 7, 6, 7, 6, 8, 7, 8, 7, 8, 7, 9, 8, 9, 9,
		 9, 9,10,10,10,11, 9,12, 9,12, 9,15,10,14, 9,13,
		10,13,10,12,10,12,10,13,10,12,11,13,11,14,12,13,
		13,14,14,13,14,15,14,16,13,13,14,16,16,16,16,16,
		16,16,16,16,16,16,16,16,16,16,16,16,16,16,15,15,
};

static const static_codebook _huff_book_line_1024x27_2sub1 = {
		1, 128,
		(long *)_huff_lengthlist_line_1024x27_2sub1,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_1024x27_3sub1[] = {
		 0, 4, 5, 4, 5, 3, 5, 3, 5, 3, 5, 4, 4, 4, 4, 5,
		 5, 5,
};

static const static_codebook _huff_book_line_1024x27_3sub1 = {
		1, 18,
		(long *)_huff_lengthlist_line_1024x27_3sub1,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_1024x27_3sub2[] = {
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 3, 3, 4, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5, 6,
		 5, 7, 5, 8, 6, 8, 6, 9, 7,10, 7,10, 8,10, 8,11,
		 9,11,
};

static const static_codebook _huff_book_line_1024x27_3sub2 = {
		1, 50,
		(long *)_huff_lengthlist_line_1024x27_3sub2,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_1024x27_3sub3[] = {
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 3, 7, 3, 8, 3,10, 3, 8, 3, 9, 3, 8, 4, 9,
		 4, 9, 5, 9, 6,10, 6, 9, 7,11, 7,12, 9,13,10,13,
		12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
		12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
		12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
};

static const static_codebook _huff_book_line_1024x27_3sub3 = {
		1, 128,
		(long *)_huff_lengthlist_line_1024x27_3sub3,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_1024x27_4sub1[] = {
		 0, 4, 5, 4, 5, 4, 5, 4, 5, 3, 5, 3, 5, 3, 5, 4,
		 5, 4,
};

static const static_codebook _huff_book_line_1024x27_4sub1 = {
		1, 18,
		(long *)_huff_lengthlist_line_1024x27_4sub1,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_1024x27_4sub2[] = {
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 4, 2, 4, 2, 5, 3, 5, 4, 6, 6, 6, 7, 7, 8,
		 7, 8, 7, 8, 7, 9, 8, 9, 8, 9, 8,10, 8,11, 9,12,
		 9,12,
};

static const static_codebook _huff_book_line_1024x27_4sub2 = {
		1, 50,
		(long *)_huff_lengthlist_line_1024x27_4sub2,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_1024x27_4sub3[] = {
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 2, 5, 2, 6, 3, 6, 4, 7, 4, 7, 5, 9, 5,11,
		 6,11, 6,11, 7,11, 6,11, 6,11, 9,11, 8,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,10,10,10,10,10,10,
};

static const static_codebook _huff_book_line_1024x27_4sub3 = {
		1, 128,
		(long *)_huff_lengthlist_line_1024x27_4sub3,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_2048x27_class1[] = {
		 2, 6, 8, 9, 7,11,13,13, 1, 3, 5, 5, 6, 6,12,10,
};

static const static_codebook _huff_book_line_2048x27_class1 = {
		1, 16,
		(long *)_huff_lengthlist_line_2048x27_class1,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_2048x27_class2[] = {
		 1, 2, 3, 6, 4, 7, 5, 7,
};

static const static_codebook _huff_book_line_2048x27_class2 = {
		1, 8,
		(long *)_huff_lengthlist_line_2048x27_class2,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_2048x27_class3[] = {
		 3, 3, 6,16, 5, 5, 7,16, 9, 8,11,16,16,16,16,16,
		 5, 5, 8,16, 5, 5, 7,16, 8, 7, 9,16,16,16,16,16,
		 9, 9,12,16, 6, 8,11,16, 9,10,11,16,16,16,16,16,
		16,16,16,16,13,16,16,16,15,16,16,16,16,16,16,16,
		 5, 4, 7,16, 6, 5, 8,16, 9, 8,10,16,16,16,16,16,
		 5, 5, 7,15, 5, 4, 6,15, 7, 6, 8,16,16,16,16,16,
		 9, 9,11,15, 7, 7, 9,16, 8, 8, 9,16,16,16,16,16,
		16,16,16,16,15,15,15,16,15,15,14,16,16,16,16,16,
		 8, 8,11,16, 8, 9,10,16,11,10,14,16,16,16,16,16,
		 6, 8,10,16, 6, 7,10,16, 8, 8,11,16,14,16,16,16,
		10,11,14,16, 9, 9,11,16,10,10,11,16,16,16,16,16,
		16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
		16,16,16,16,15,16,16,16,16,16,16,16,16,16,16,16,
		12,16,15,16,12,14,16,16,16,16,16,16,16,16,16,16,
		16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
		16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
};

static const static_codebook _huff_book_line_2048x27_class3 = {
		1, 256,
		(long *)_huff_lengthlist_line_2048x27_class3,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_2048x27_class4[] = {
		 2, 4, 7,13, 4, 5, 7,15, 8, 7,10,16,16,14,16,16,
		 2, 4, 7,16, 3, 4, 7,14, 8, 8,10,16,16,16,15,16,
		 6, 8,11,16, 7, 7, 9,16,11, 9,13,16,16,16,15,16,
		16,16,16,16,14,16,16,16,16,16,16,16,16,16,16,16,
};

static const static_codebook _huff_book_line_2048x27_class4 = {
		1, 64,
		(long *)_huff_lengthlist_line_2048x27_class4,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_2048x27_0sub0[] = {
		 5, 5, 5, 5, 5, 5, 6, 5, 6, 5, 6, 5, 6, 5, 6, 5,
		 6, 5, 7, 5, 7, 5, 7, 5, 8, 5, 8, 5, 8, 5, 9, 5,
		 9, 6,10, 6,10, 6,11, 6,11, 6,11, 6,11, 6,11, 6,
		11, 6,11, 6,12, 7,11, 7,11, 7,11, 7,11, 7,10, 7,
		11, 7,11, 7,12, 7,11, 8,11, 8,11, 8,11, 8,13, 8,
		12, 9,11, 9,11, 9,11,10,12,10,12, 9,12,10,12,11,
		14,12,16,12,12,11,14,16,17,17,17,17,17,17,17,17,
		17,17,17,17,17,17,17,17,17,17,17,17,16,16,16,16,
};

static const static_codebook _huff_book_line_2048x27_0sub0 = {
		1, 128,
		(long *)_huff_lengthlist_line_2048x27_0sub0,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_2048x27_1sub0[] = {
		 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5,
		 5, 5, 6, 6, 6, 6, 6, 6, 7, 6, 7, 6, 7, 6, 7, 6,
};

static const static_codebook _huff_book_line_2048x27_1sub0 = {
		1, 32,
		(long *)_huff_lengthlist_line_2048x27_1sub0,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_2048x27_1sub1[] = {
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 6, 5, 7, 5, 7, 4, 7, 4, 8, 4, 8, 4, 8, 4, 8, 3,
		 8, 4, 9, 4, 9, 4, 9, 4, 9, 4, 9, 5, 9, 5, 9, 6,
		 9, 7, 9, 8, 9, 9, 9,10, 9,11, 9,14, 9,15,10,15,
		10,15,10,15,10,15,11,15,10,14,12,14,11,14,13,14,
		13,15,15,15,12,15,15,15,13,15,13,15,13,15,15,15,
		15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,14,
};

static const static_codebook _huff_book_line_2048x27_1sub1 = {
		1, 128,
		(long *)_huff_lengthlist_line_2048x27_1sub1,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_2048x27_2sub0[] = {
		 2, 4, 5, 4, 5, 4, 5, 4, 5, 5, 5, 5, 5, 5, 6, 5,
		 6, 5, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8,
};

static const static_codebook _huff_book_line_2048x27_2sub0 = {
		1, 32,
		(long *)_huff_lengthlist_line_2048x27_2sub0,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_2048x27_2sub1[] = {
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 3, 4, 3, 4, 3, 4, 4, 5, 4, 5, 5, 5, 6, 6, 6, 7,
		 6, 8, 6, 8, 6, 9, 7,10, 7,10, 7,10, 7,12, 7,12,
		 7,12, 9,12,11,12,10,12,10,12,11,12,12,12,10,12,
		10,12,10,12, 9,12,11,12,12,12,12,12,11,12,11,12,
		12,12,12,12,12,12,12,12,10,10,12,12,12,12,12,10,
		12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
};

static const static_codebook _huff_book_line_2048x27_2sub1 = {
		1, 128,
		(long *)_huff_lengthlist_line_2048x27_2sub1,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_2048x27_3sub1[] = {
		 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
		 5, 5,
};

static const static_codebook _huff_book_line_2048x27_3sub1 = {
		1, 18,
		(long *)_huff_lengthlist_line_2048x27_3sub1,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_2048x27_3sub2[] = {
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 6,
		 6, 7, 6, 7, 6, 8, 6, 9, 7, 9, 7, 9, 9,11, 9,12,
		10,12,
};

static const static_codebook _huff_book_line_2048x27_3sub2 = {
		1, 50,
		(long *)_huff_lengthlist_line_2048x27_3sub2,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_2048x27_3sub3[] = {
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 3, 6, 3, 7, 3, 7, 5, 7, 7, 7, 7, 7, 6, 7,
		 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
		 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
		 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
		 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
};

static const static_codebook _huff_book_line_2048x27_3sub3 = {
		1, 128,
		(long *)_huff_lengthlist_line_2048x27_3sub3,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_2048x27_4sub1[] = {
		 0, 3, 4, 4, 4, 4, 4, 4, 4, 4, 5, 4, 5, 4, 5, 4,
		 4, 5,
};

static const static_codebook _huff_book_line_2048x27_4sub1 = {
		1, 18,
		(long *)_huff_lengthlist_line_2048x27_4sub1,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_2048x27_4sub2[] = {
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 3, 2, 4, 3, 4, 4, 4, 5, 5, 6, 5, 6, 5, 7,
		 6, 6, 6, 7, 7, 7, 8, 9, 9, 9,12,10,11,10,10,12,
		10,10,
};

static const static_codebook _huff_book_line_2048x27_4sub2 = {
		1, 50,
		(long *)_huff_lengthlist_line_2048x27_4sub2,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_2048x27_4sub3[] = {
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 3, 6, 5, 7, 5, 7, 7, 7, 7, 7, 5, 7, 5, 7,
		 5, 7, 5, 7, 7, 7, 7, 7, 4, 7, 7, 7, 7, 7, 7, 7,
		 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
		 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
		 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 6, 6,
};

static const static_codebook _huff_book_line_2048x27_4sub3 = {
		1, 128,
		(long *)_huff_lengthlist_line_2048x27_4sub3,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_256x4low_class0[] = {
		 4, 5, 6,11, 5, 5, 6,10, 7, 7, 6, 6,14,13, 9, 9,
		 6, 6, 6,10, 6, 6, 6, 9, 8, 7, 7, 9,14,12, 8,11,
		 8, 7, 7,11, 8, 8, 7,11, 9, 9, 7, 9,13,11, 9,13,
		19,19,18,19,15,16,16,19,11,11,10,13,10,10, 9,15,
		 5, 5, 6,13, 6, 6, 6,11, 8, 7, 6, 7,14,11,10,11,
		 6, 6, 6,12, 7, 6, 6,11, 8, 7, 7,11,13,11, 9,11,
		 9, 7, 6,12, 8, 7, 6,12, 9, 8, 8,11,13,10, 7,13,
		19,19,17,19,17,14,14,19,12,10, 8,12,13,10, 9,16,
		 7, 8, 7,12, 7, 7, 7,11, 8, 7, 7, 8,12,12,11,11,
		 8, 8, 7,12, 8, 7, 6,11, 8, 7, 7,10,10,11,10,11,
		 9, 8, 8,13, 9, 8, 7,12,10, 9, 7,11, 9, 8, 7,11,
		18,18,15,18,18,16,17,18,15,11,10,18,11, 9, 9,18,
		16,16,13,16,12,11,10,16,12,11, 9, 6,15,12,11,13,
		16,16,14,14,13,11,12,16,12, 9, 9,13,13,10,10,12,
		17,18,17,17,14,15,14,16,14,12,14,15,12,10,11,12,
		18,18,18,18,18,18,18,18,18,12,13,18,16,11, 9,18,
};

static const static_codebook _huff_book_line_256x4low_class0 = {
		1, 256,
		(long *)_huff_lengthlist_line_256x4low_class0,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_256x4low_0sub0[] = {
		 1, 3, 2, 3,
};

static const static_codebook _huff_book_line_256x4low_0sub0 = {
		1, 4,
		(long *)_huff_lengthlist_line_256x4low_0sub0,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_256x4low_0sub1[] = {
		 0, 0, 0, 0, 2, 3, 2, 3, 3, 3,
};

static const static_codebook _huff_book_line_256x4low_0sub1 = {
		1, 10,
		(long *)_huff_lengthlist_line_256x4low_0sub1,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_256x4low_0sub2[] = {
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 3, 4, 3, 4,
		 4, 4, 4, 4, 5, 5, 5, 6, 6,
};

static const static_codebook _huff_book_line_256x4low_0sub2 = {
		1, 25,
		(long *)_huff_lengthlist_line_256x4low_0sub2,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist_line_256x4low_0sub3[] = {
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 4, 2, 4, 3, 5, 4,
		 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 6, 9,
		 7,12,11,16,13,16,12,15,13,15,12,14,12,15,15,15,
};

static const static_codebook _huff_book_line_256x4low_0sub3 = {
		1, 64,
		(long *)_huff_lengthlist_line_256x4low_0sub3,
		0, 0, 0, 0, 0,
		NULL,
		0
};

/*** End of inlined file: floor_books.h ***/

static const static_codebook*const _floor_128x4_books[]={
  &_huff_book_line_128x4_class0,
  &_huff_book_line_128x4_0sub0,
  &_huff_book_line_128x4_0sub1,
  &_huff_book_line_128x4_0sub2,
  &_huff_book_line_128x4_0sub3,
};
static const static_codebook*const _floor_256x4_books[]={
  &_huff_book_line_256x4_class0,
  &_huff_book_line_256x4_0sub0,
  &_huff_book_line_256x4_0sub1,
  &_huff_book_line_256x4_0sub2,
  &_huff_book_line_256x4_0sub3,
};
static const static_codebook*const _floor_128x7_books[]={
  &_huff_book_line_128x7_class0,
  &_huff_book_line_128x7_class1,

  &_huff_book_line_128x7_0sub1,
  &_huff_book_line_128x7_0sub2,
  &_huff_book_line_128x7_0sub3,
  &_huff_book_line_128x7_1sub1,
  &_huff_book_line_128x7_1sub2,
  &_huff_book_line_128x7_1sub3,
};
static const static_codebook*const _floor_256x7_books[]={
  &_huff_book_line_256x7_class0,
  &_huff_book_line_256x7_class1,

  &_huff_book_line_256x7_0sub1,
  &_huff_book_line_256x7_0sub2,
  &_huff_book_line_256x7_0sub3,
  &_huff_book_line_256x7_1sub1,
  &_huff_book_line_256x7_1sub2,
  &_huff_book_line_256x7_1sub3,
};
static const static_codebook*const _floor_128x11_books[]={
  &_huff_book_line_128x11_class1,
  &_huff_book_line_128x11_class2,
  &_huff_book_line_128x11_class3,

  &_huff_book_line_128x11_0sub0,
  &_huff_book_line_128x11_1sub0,
  &_huff_book_line_128x11_1sub1,
  &_huff_book_line_128x11_2sub1,
  &_huff_book_line_128x11_2sub2,
  &_huff_book_line_128x11_2sub3,
  &_huff_book_line_128x11_3sub1,
  &_huff_book_line_128x11_3sub2,
  &_huff_book_line_128x11_3sub3,
};
static const static_codebook*const _floor_128x17_books[]={
  &_huff_book_line_128x17_class1,
  &_huff_book_line_128x17_class2,
  &_huff_book_line_128x17_class3,

  &_huff_book_line_128x17_0sub0,
  &_huff_book_line_128x17_1sub0,
  &_huff_book_line_128x17_1sub1,
  &_huff_book_line_128x17_2sub1,
  &_huff_book_line_128x17_2sub2,
  &_huff_book_line_128x17_2sub3,
  &_huff_book_line_128x17_3sub1,
  &_huff_book_line_128x17_3sub2,
  &_huff_book_line_128x17_3sub3,
};
static const static_codebook*const _floor_256x4low_books[]={
  &_huff_book_line_256x4low_class0,
  &_huff_book_line_256x4low_0sub0,
  &_huff_book_line_256x4low_0sub1,
  &_huff_book_line_256x4low_0sub2,
  &_huff_book_line_256x4low_0sub3,
};
static const static_codebook*const _floor_1024x27_books[]={
  &_huff_book_line_1024x27_class1,
  &_huff_book_line_1024x27_class2,
  &_huff_book_line_1024x27_class3,
  &_huff_book_line_1024x27_class4,

  &_huff_book_line_1024x27_0sub0,
  &_huff_book_line_1024x27_1sub0,
  &_huff_book_line_1024x27_1sub1,
  &_huff_book_line_1024x27_2sub0,
  &_huff_book_line_1024x27_2sub1,
  &_huff_book_line_1024x27_3sub1,
  &_huff_book_line_1024x27_3sub2,
  &_huff_book_line_1024x27_3sub3,
  &_huff_book_line_1024x27_4sub1,
  &_huff_book_line_1024x27_4sub2,
  &_huff_book_line_1024x27_4sub3,
};
static const static_codebook*const _floor_2048x27_books[]={
  &_huff_book_line_2048x27_class1,
  &_huff_book_line_2048x27_class2,
  &_huff_book_line_2048x27_class3,
  &_huff_book_line_2048x27_class4,

  &_huff_book_line_2048x27_0sub0,
  &_huff_book_line_2048x27_1sub0,
  &_huff_book_line_2048x27_1sub1,
  &_huff_book_line_2048x27_2sub0,
  &_huff_book_line_2048x27_2sub1,
  &_huff_book_line_2048x27_3sub1,
  &_huff_book_line_2048x27_3sub2,
  &_huff_book_line_2048x27_3sub3,
  &_huff_book_line_2048x27_4sub1,
  &_huff_book_line_2048x27_4sub2,
  &_huff_book_line_2048x27_4sub3,
};

static const static_codebook*const _floor_512x17_books[]={
  &_huff_book_line_512x17_class1,
  &_huff_book_line_512x17_class2,
  &_huff_book_line_512x17_class3,

  &_huff_book_line_512x17_0sub0,
  &_huff_book_line_512x17_1sub0,
  &_huff_book_line_512x17_1sub1,
  &_huff_book_line_512x17_2sub1,
  &_huff_book_line_512x17_2sub2,
  &_huff_book_line_512x17_2sub3,
  &_huff_book_line_512x17_3sub1,
  &_huff_book_line_512x17_3sub2,
  &_huff_book_line_512x17_3sub3,
};

static const static_codebook*const _floor_Xx0_books[]={
  0
};

static const static_codebook*const *const _floor_books[11]={
  _floor_128x4_books,
  _floor_256x4_books,
  _floor_128x7_books,
  _floor_256x7_books,
  _floor_128x11_books,
  _floor_128x17_books,
  _floor_256x4low_books,
  _floor_1024x27_books,
  _floor_2048x27_books,
  _floor_512x17_books,
  _floor_Xx0_books,
};

static const vorbis_info_floor1 _floor[11]={
  /* 0: 128 x 4 */
  {
	1,{0},{4},{2},{0},
	{{1,2,3,4}},
	4,{0,128, 33,8,16,70},

	60,30,500,   1.,18.,  128
  },
  /* 1: 256 x 4 */
  {
	1,{0},{4},{2},{0},
	{{1,2,3,4}},
	4,{0,256, 66,16,32,140},

	60,30,500,   1.,18.,  256
  },
  /* 2: 128 x 7 */
  {
	2,{0,1},{3,4},{2,2},{0,1},
	{{-1,2,3,4},{-1,5,6,7}},
	4,{0,128, 14,4,58, 2,8,28,90},

	60,30,500,   1.,18.,  128
  },
  /* 3: 256 x 7 */
  {
	2,{0,1},{3,4},{2,2},{0,1},
	{{-1,2,3,4},{-1,5,6,7}},
	4,{0,256, 28,8,116, 4,16,56,180},

	60,30,500,   1.,18.,  256
  },
  /* 4: 128 x 11 */
  {
	4,{0,1,2,3},{2,3,3,3},{0,1,2,2},{-1,0,1,2},
	{{3},{4,5},{-1,6,7,8},{-1,9,10,11}},

	2,{0,128,  8,33,  4,16,70,  2,6,12,  23,46,90},

	 60,30,500,   1,18.,  128
  },
  /* 5: 128 x 17 */
  {
	6,{0,1,1,2,3,3},{2,3,3,3},{0,1,2,2},{-1,0,1,2},
	{{3},{4,5},{-1,6,7,8},{-1,9,10,11}},
	2,{0,128,  12,46,  4,8,16,  23,33,70,  2,6,10,  14,19,28,  39,58,90},

	60,30,500,    1,18.,  128
  },
  /* 6: 256 x 4 (low bitrate version) */
  {
	1,{0},{4},{2},{0},
	{{1,2,3,4}},
	4,{0,256, 66,16,32,140},

	60,30,500,   1.,18.,  256
  },
  /* 7: 1024 x 27 */
  {
	8,{0,1,2,2,3,3,4,4},{3,4,3,4,3},{0,1,1,2,2},{-1,0,1,2,3},
	{{4},{5,6},{7,8},{-1,9,10,11},{-1,12,13,14}},
	2,{0,1024,   93,23,372, 6,46,186,750,  14,33,65, 130,260,556,
	   3,10,18,28,  39,55,79,111,  158,220,312,  464,650,850},

	60,30,500,    3,18.,  1024
  },
  /* 8: 2048 x 27 */
  {
	8,{0,1,2,2,3,3,4,4},{3,4,3,4,3},{0,1,1,2,2},{-1,0,1,2,3},
	{{4},{5,6},{7,8},{-1,9,10,11},{-1,12,13,14}},
	2,{0,2048,   186,46,744, 12,92,372,1500,  28,66,130, 260,520,1112,
	   6,20,36,56,  78,110,158,222,  316,440,624,  928,1300,1700},

	60,30,500,    3,18.,  2048
  },
  /* 9: 512 x 17 */
  {
	6,{0,1,1,2,3,3},{2,3,3,3},{0,1,2,2},{-1,0,1,2},
	{{3},{4,5},{-1,6,7,8},{-1,9,10,11}},
	2,{0,512,  46,186,  16,33,65,  93,130,278,
	   7,23,39,  55,79,110,  156,232,360},

	60,30,500,    1,18.,  512
  },

  /* 10: X x 0 (LFE floor; edge posts only) */
  {
	0,{0}, {0},{0},{-1},
	{{-1}},
	2,{0,12},
	60,30,500,   1.,18.,  10
  },

};

/*** End of inlined file: floor_all.h ***/


/*** Start of inlined file: residue_44.h ***/

/*** Start of inlined file: res_books_stereo.h ***/
static const long _vq_quantlist__16c0_s_p1_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__16c0_s_p1_0[] = {
		 1, 4, 4, 0, 0, 0, 0, 0, 0, 5, 7, 7, 0, 0, 0, 0,
		 0, 0, 5, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 5, 8, 8, 0, 0, 0, 0, 0, 0, 8, 9,10, 0, 0, 0,
		 0, 0, 0, 7, 9,10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 5, 8, 8, 0, 0, 0, 0, 0, 0, 7, 9, 9, 0, 0,
		 0, 0, 0, 0, 7, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 8, 8, 0, 0, 0, 0,
		 0, 0, 8,10,10, 0, 0, 0, 0, 0, 0, 8,10,10, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7,10,10, 0, 0, 0,
		 0, 0, 0, 9, 9,12, 0, 0, 0, 0, 0, 0,10,12,11, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7,10,10, 0, 0,
		 0, 0, 0, 0, 9,12,10, 0, 0, 0, 0, 0, 0,10,11,12,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 5, 8, 8, 0, 0, 0, 0, 0, 0, 8,10,10, 0, 0,
		 0, 0, 0, 0, 8,10,10, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 7,10,10, 0, 0, 0, 0, 0, 0,10,12,11, 0,
		 0, 0, 0, 0, 0, 9,10,12, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 7,10,10, 0, 0, 0, 0, 0, 0,10,11,12,
		 0, 0, 0, 0, 0, 0, 9,12, 9, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0,
};

static const static_codebook _16c0_s_p1_0 = {
		8, 6561,
		(long *)_vq_lengthlist__16c0_s_p1_0,
		1, -535822336, 1611661312, 2, 0,
		(long *)_vq_quantlist__16c0_s_p1_0,
		0
};

static const long _vq_quantlist__16c0_s_p3_0[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__16c0_s_p3_0[] = {
		 1, 4, 4, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 6, 6, 7, 6, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 4, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 9, 9,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 6, 6, 6, 9, 9, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0,
};

static const static_codebook _16c0_s_p3_0 = {
		4, 625,
		(long *)_vq_lengthlist__16c0_s_p3_0,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__16c0_s_p3_0,
		0
};

static const long _vq_quantlist__16c0_s_p4_0[] = {
		4,
		3,
		5,
		2,
		6,
		1,
		7,
		0,
		8,
};

static const long _vq_lengthlist__16c0_s_p4_0[] = {
		 1, 3, 2, 7, 8, 0, 0, 0, 0, 0, 0, 0, 6, 6, 0, 0,
		 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 0, 7, 7,
		 0, 0, 0, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0, 0, 0,
		 8, 8, 0, 0, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0,
		 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0,
};

static const static_codebook _16c0_s_p4_0 = {
		2, 81,
		(long *)_vq_lengthlist__16c0_s_p4_0,
		1, -531628032, 1611661312, 4, 0,
		(long *)_vq_quantlist__16c0_s_p4_0,
		0
};

static const long _vq_quantlist__16c0_s_p5_0[] = {
		4,
		3,
		5,
		2,
		6,
		1,
		7,
		0,
		8,
};

static const long _vq_lengthlist__16c0_s_p5_0[] = {
		 1, 3, 3, 6, 6, 6, 6, 8, 8, 0, 0, 0, 7, 7, 7, 7,
		 8, 8, 0, 0, 0, 7, 7, 7, 7, 8, 8, 0, 0, 0, 7, 7,
		 8, 8, 9, 9, 0, 0, 0, 7, 7, 8, 8, 9, 9, 0, 0, 0,
		 8, 9, 8, 8,10,10, 0, 0, 0, 8, 8, 8, 8,10,10, 0,
		 0, 0,10,10, 9, 9,10,10, 0, 0, 0, 0, 0, 9, 9,10,
		10,
};

static const static_codebook _16c0_s_p5_0 = {
		2, 81,
		(long *)_vq_lengthlist__16c0_s_p5_0,
		1, -531628032, 1611661312, 4, 0,
		(long *)_vq_quantlist__16c0_s_p5_0,
		0
};

static const long _vq_quantlist__16c0_s_p6_0[] = {
		8,
		7,
		9,
		6,
		10,
		5,
		11,
		4,
		12,
		3,
		13,
		2,
		14,
		1,
		15,
		0,
		16,
};

static const long _vq_lengthlist__16c0_s_p6_0[] = {
		 1, 3, 4, 6, 6, 7, 7, 8, 8, 8, 8, 9, 9,10,10,11,
		11, 0, 0, 0, 7, 7, 8, 8, 9, 9, 9, 9,10,10,10,11,
		11,11, 0, 0, 0, 6, 6, 8, 8, 9, 9, 9, 9,10,10,11,
		11,11,11, 0, 0, 0, 7, 7, 8, 8, 9, 9, 9, 9,10,10,
		11,11,12,12, 0, 0, 0, 7, 7, 8, 8, 9, 9, 9, 9,10,
		10,11,11,12,12, 0, 0, 0, 8, 8, 9, 9,10,10,10,10,
		11,11,12,12,12,12, 0, 0, 0, 8, 8, 9, 9,10,10,10,
		10,11,11,12,12,12,13, 0, 0, 0, 9, 9, 9, 9,10,10,
		10,10,11,11,12,12,13,13, 0, 0, 0, 0, 0,10,10,10,
		10,10,10,11,11,12,12,13,13, 0, 0, 0, 0, 0, 9, 9,
		10,10,11,11,12,12,13,13,13,13, 0, 0, 0, 0, 0, 9,
		 9,10,10,11,11,12,12,13,13,13,14, 0, 0, 0, 0, 0,
		10,10,10,11,11,11,12,12,13,13,13,14, 0, 0, 0, 0,
		 0, 0, 0,10,10,11,11,12,12,13,13,14,14, 0, 0, 0,
		 0, 0, 0, 0,11,11,12,12,13,13,13,13,14,14, 0, 0,
		 0, 0, 0, 0, 0,11,11,12,12,12,13,13,14,15,14, 0,
		 0, 0, 0, 0, 0, 0,12,12,12,12,13,13,13,14,14,15,
		 0, 0, 0, 0, 0, 0, 0, 0, 0,12,12,13,13,14,13,14,
		14,
};

static const static_codebook _16c0_s_p6_0 = {
		2, 289,
		(long *)_vq_lengthlist__16c0_s_p6_0,
		1, -529530880, 1611661312, 5, 0,
		(long *)_vq_quantlist__16c0_s_p6_0,
		0
};

static const long _vq_quantlist__16c0_s_p7_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__16c0_s_p7_0[] = {
		 1, 4, 4, 6, 6, 6, 7, 6, 6, 4, 7, 7,11,10,10,11,
		11,10, 4, 7, 7,10,10,10,11,10,10, 6,10,10,11,11,
		11,11,11,10, 6, 9, 9,11,12,12,11, 9, 9, 6, 9,10,
		11,12,12,11, 9,10, 7,11,11,11,11,11,12,13,12, 6,
		 9,10,11,10,10,12,13,13, 6,10, 9,11,10,10,11,12,
		13,
};

static const static_codebook _16c0_s_p7_0 = {
		4, 81,
		(long *)_vq_lengthlist__16c0_s_p7_0,
		1, -529137664, 1618345984, 2, 0,
		(long *)_vq_quantlist__16c0_s_p7_0,
		0
};

static const long _vq_quantlist__16c0_s_p7_1[] = {
		5,
		4,
		6,
		3,
		7,
		2,
		8,
		1,
		9,
		0,
		10,
};

static const long _vq_lengthlist__16c0_s_p7_1[] = {
		 1, 3, 4, 6, 6, 7, 7, 8, 8, 8, 8,10,10,10, 7, 7,
		 8, 8, 8, 9, 9, 9,10,10,10, 6, 7, 8, 8, 8, 8, 9,
		 8,10,10,10, 7, 7, 8, 8, 9, 9, 9, 9,10,10,10, 7,
		 7, 8, 8, 9, 9, 8, 9,10,10,10, 8, 8, 9, 9, 9, 9,
		 9, 9,11,11,11, 8, 8, 9, 9, 9, 9, 9,10,10,11,11,
		 9, 9, 9, 9, 9, 9, 9,10,11,11,11,10,11, 9, 9, 9,
		 9,10, 9,11,11,11,10,11,10,10, 9, 9,10,10,11,11,
		11,11,11, 9, 9, 9, 9,10,10,
};

static const static_codebook _16c0_s_p7_1 = {
		2, 121,
		(long *)_vq_lengthlist__16c0_s_p7_1,
		1, -531365888, 1611661312, 4, 0,
		(long *)_vq_quantlist__16c0_s_p7_1,
		0
};

static const long _vq_quantlist__16c0_s_p8_0[] = {
		6,
		5,
		7,
		4,
		8,
		3,
		9,
		2,
		10,
		1,
		11,
		0,
		12,
};

static const long _vq_lengthlist__16c0_s_p8_0[] = {
		 1, 4, 4, 7, 7, 7, 7, 7, 6, 8, 8,10,10, 6, 5, 6,
		 8, 8, 8, 8, 8, 8, 8, 9,10,10, 7, 6, 6, 8, 8, 8,
		 8, 8, 8, 8, 8,10,10, 0, 8, 8, 8, 8, 9, 8, 9, 9,
		 9,10,10,10, 0, 9, 8, 8, 8, 9, 9, 8, 8, 9, 9,10,
		10, 0,12,11, 8, 8, 9, 9, 9, 9,10,10,11,10, 0,12,
		13, 8, 8, 9,10, 9, 9,11,11,11,12, 0, 0, 0, 8, 8,
		 8, 8,10, 9,12,13,12,14, 0, 0, 0, 8, 8, 8, 9,10,
		10,12,12,13,14, 0, 0, 0,13,13, 9, 9,11,11, 0, 0,
		14, 0, 0, 0, 0,14,14,10,10,12,11,12,14,14,14, 0,
		 0, 0, 0, 0,11,11,13,13,14,13,14,14, 0, 0, 0, 0,
		 0,12,13,13,12,13,14,14,14,
};

static const static_codebook _16c0_s_p8_0 = {
		2, 169,
		(long *)_vq_lengthlist__16c0_s_p8_0,
		1, -526516224, 1616117760, 4, 0,
		(long *)_vq_quantlist__16c0_s_p8_0,
		0
};

static const long _vq_quantlist__16c0_s_p8_1[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__16c0_s_p8_1[] = {
		 1, 4, 3, 5, 5, 7, 7, 7, 6, 6, 7, 7, 7, 5, 5, 7,
		 7, 7, 6, 6, 7, 7, 7, 6, 6,
};

static const static_codebook _16c0_s_p8_1 = {
		2, 25,
		(long *)_vq_lengthlist__16c0_s_p8_1,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__16c0_s_p8_1,
		0
};

static const long _vq_quantlist__16c0_s_p9_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__16c0_s_p9_0[] = {
		 1, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
		 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
		 8, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
		 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
		 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
		 7,
};

static const static_codebook _16c0_s_p9_0 = {
		4, 81,
		(long *)_vq_lengthlist__16c0_s_p9_0,
		1, -518803456, 1628680192, 2, 0,
		(long *)_vq_quantlist__16c0_s_p9_0,
		0
};

static const long _vq_quantlist__16c0_s_p9_1[] = {
		7,
		6,
		8,
		5,
		9,
		4,
		10,
		3,
		11,
		2,
		12,
		1,
		13,
		0,
		14,
};

static const long _vq_lengthlist__16c0_s_p9_1[] = {
		 1, 5, 5, 5, 5, 9,11,11,10,10,10,10,10,10,10, 7,
		 6, 6, 6, 6,10,10,10,10,10,10,10,10,10,10, 7, 6,
		 6, 6, 6,10, 9,10,10,10,10,10,10,10,10,10, 7, 7,
		 8, 9,10,10,10,10,10,10,10,10,10,10,10, 8, 7,10,
		10,10, 9,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,
};

static const static_codebook _16c0_s_p9_1 = {
		2, 225,
		(long *)_vq_lengthlist__16c0_s_p9_1,
		1, -520986624, 1620377600, 4, 0,
		(long *)_vq_quantlist__16c0_s_p9_1,
		0
};

static const long _vq_quantlist__16c0_s_p9_2[] = {
		10,
		9,
		11,
		8,
		12,
		7,
		13,
		6,
		14,
		5,
		15,
		4,
		16,
		3,
		17,
		2,
		18,
		1,
		19,
		0,
		20,
};

static const long _vq_lengthlist__16c0_s_p9_2[] = {
		 1, 5, 5, 7, 8, 8, 7, 9, 9, 9,12,12,11,12,12,10,
		10,11,12,12,12,11,12,12, 8, 9, 8, 7, 9,10,10,11,
		11,10,11,12,10,12,10,12,12,12,11,12,11, 9, 8, 8,
		 9,10, 9, 8, 9,10,12,12,11,11,12,11,10,11,12,11,
		12,12, 8, 9, 9, 9,10,11,12,11,12,11,11,11,11,12,
		12,11,11,12,12,11,11, 9, 9, 8, 9, 9,11, 9, 9,10,
		 9,11,11,11,11,12,11,11,10,12,12,12, 9,12,11,10,
		11,11,11,11,12,12,12,11,11,11,12,10,12,12,12,10,
		10, 9,10, 9,10,10, 9, 9, 9,10,10,12,10,11,11, 9,
		11,11,10,11,11,11,10,10,10, 9, 9,10,10, 9, 9,10,
		11,11,10,11,10,11,10,11,11,10,11,11,11,10, 9,10,
		10, 9,10, 9, 9,11, 9, 9,11,10,10,11,11,10,10,11,
		10,11, 8, 9,11,11,10, 9,10,11,11,10,11,11,10,10,
		10,11,10, 9,10,10,11, 9,10,10, 9,11,10,10,10,10,
		11,10,11,11, 9,11,10,11,10,10,11,11,10,10,10, 9,
		10,10,11,11,11, 9,10,10,10,10,10,11,10,10,10, 9,
		10,10,11,10,10,10,10,10, 9,10,11,10,10,10,10,11,
		11,11,10,10,10,10,10,11,10,11,10,11,10,10,10, 9,
		11,11,10,10,10,11,11,10,10,10,10,10,10,10,10,11,
		11, 9,10,10,10,11,10,11,10,10,10,11, 9,10,11,10,
		11,10,10, 9,10,10,10,11,10,11,10,10,10,10,10,11,
		11,10,11,11,10,10,11,11,10, 9, 9,10,10,10,10,10,
		 9,11, 9,10,10,10,11,11,10,10,10,10,11,11,11,10,
		 9, 9,10,10,11,10,10,10,10,10,11,11,11,10,10,10,
		11,11,11, 9,10,10,10,10, 9,10, 9,10,11,10,11,10,
		10,11,11,10,11,11,11,11,11,10,11,10,10,10, 9,11,
		11,10,11,11,11,11,11,11,11,11,11,10,11,10,10,10,
		10,11,10,10,11, 9,10,10,10,
};

static const static_codebook _16c0_s_p9_2 = {
		2, 441,
		(long *)_vq_lengthlist__16c0_s_p9_2,
		1, -529268736, 1611661312, 5, 0,
		(long *)_vq_quantlist__16c0_s_p9_2,
		0
};

static const long _huff_lengthlist__16c0_s_single[] = {
		 3, 4,19, 7, 9, 7, 8,11, 9,12, 4, 1,19, 6, 7, 7,
		 8,10,11,13,18,18,18,18,18,18,18,18,18,18, 8, 6,
		18, 8, 9, 9,11,12,14,18, 9, 6,18, 9, 7, 8, 9,11,
		12,18, 7, 6,18, 8, 7, 7, 7, 9,11,17, 8, 8,18, 9,
		 7, 6, 6, 8,11,17,10,10,18,12, 9, 8, 7, 9,12,18,
		13,15,18,15,13,11,10,11,15,18,14,18,18,18,18,18,
		16,16,18,18,
};

static const static_codebook _huff_book__16c0_s_single = {
		2, 100,
		(long *)_huff_lengthlist__16c0_s_single,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist__16c1_s_long[] = {
		 2, 5,20, 7,10, 7, 8,10,11,11, 4, 2,20, 5, 8, 6,
		 7, 9,10,10,20,20,20,20,19,19,19,19,19,19, 7, 5,
		19, 6,10, 7, 9,11,13,17,11, 8,19,10, 7, 7, 8,10,
		11,15, 7, 5,19, 7, 7, 5, 6, 9,11,16, 7, 6,19, 8,
		 7, 6, 6, 7, 9,13, 9, 9,19,11, 9, 8, 6, 7, 8,13,
		12,14,19,16,13,10, 9, 8, 9,13,14,17,19,18,18,17,
		12,11,11,13,
};

static const static_codebook _huff_book__16c1_s_long = {
		2, 100,
		(long *)_huff_lengthlist__16c1_s_long,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _vq_quantlist__16c1_s_p1_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__16c1_s_p1_0[] = {
		 1, 5, 5, 0, 0, 0, 0, 0, 0, 5, 7, 7, 0, 0, 0, 0,
		 0, 0, 5, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 5, 8, 7, 0, 0, 0, 0, 0, 0, 7, 9, 9, 0, 0, 0,
		 0, 0, 0, 7, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 5, 7, 8, 0, 0, 0, 0, 0, 0, 7, 9, 8, 0, 0,
		 0, 0, 0, 0, 7, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 8, 7, 0, 0, 0, 0,
		 0, 0, 8, 9, 9, 0, 0, 0, 0, 0, 0, 7, 9, 9, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 9, 9, 0, 0, 0,
		 0, 0, 0, 9, 9,11, 0, 0, 0, 0, 0, 0, 9,11,10, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 9, 9, 0, 0,
		 0, 0, 0, 0, 8,11, 9, 0, 0, 0, 0, 0, 0, 9,10,11,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 5, 7, 8, 0, 0, 0, 0, 0, 0, 7, 9, 9, 0, 0,
		 0, 0, 0, 0, 8, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 7, 9, 9, 0, 0, 0, 0, 0, 0, 9,11,10, 0,
		 0, 0, 0, 0, 0, 8, 9,11, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 7, 9, 9, 0, 0, 0, 0, 0, 0, 9,10,11,
		 0, 0, 0, 0, 0, 0, 9,11, 9, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0,
};

static const static_codebook _16c1_s_p1_0 = {
		8, 6561,
		(long *)_vq_lengthlist__16c1_s_p1_0,
		1, -535822336, 1611661312, 2, 0,
		(long *)_vq_quantlist__16c1_s_p1_0,
		0
};

static const long _vq_quantlist__16c1_s_p3_0[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__16c1_s_p3_0[] = {
		 1, 4, 4, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 5, 5, 7, 7, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 4, 5, 5, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7, 9, 9,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 6, 7, 7, 9, 9, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0,
};

static const static_codebook _16c1_s_p3_0 = {
		4, 625,
		(long *)_vq_lengthlist__16c1_s_p3_0,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__16c1_s_p3_0,
		0
};

static const long _vq_quantlist__16c1_s_p4_0[] = {
		4,
		3,
		5,
		2,
		6,
		1,
		7,
		0,
		8,
};

static const long _vq_lengthlist__16c1_s_p4_0[] = {
		 1, 2, 3, 7, 7, 0, 0, 0, 0, 0, 0, 0, 6, 6, 0, 0,
		 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 0, 7, 7,
		 0, 0, 0, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0, 0, 0,
		 8, 8, 0, 0, 0, 0, 0, 0, 0, 8, 9, 0, 0, 0, 0, 0,
		 0, 0,10,10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0,
};

static const static_codebook _16c1_s_p4_0 = {
		2, 81,
		(long *)_vq_lengthlist__16c1_s_p4_0,
		1, -531628032, 1611661312, 4, 0,
		(long *)_vq_quantlist__16c1_s_p4_0,
		0
};

static const long _vq_quantlist__16c1_s_p5_0[] = {
		4,
		3,
		5,
		2,
		6,
		1,
		7,
		0,
		8,
};

static const long _vq_lengthlist__16c1_s_p5_0[] = {
		 1, 3, 3, 5, 5, 6, 6, 8, 8, 0, 0, 0, 7, 7, 7, 7,
		 9, 9, 0, 0, 0, 7, 7, 7, 7, 9, 9, 0, 0, 0, 8, 8,
		 8, 8, 9, 9, 0, 0, 0, 8, 8, 8, 8,10,10, 0, 0, 0,
		 9, 9, 8, 8,10,10, 0, 0, 0, 9, 9, 8, 8,10,10, 0,
		 0, 0,10,10, 9, 9,10,10, 0, 0, 0, 0, 0, 9, 9,10,
		10,
};

static const static_codebook _16c1_s_p5_0 = {
		2, 81,
		(long *)_vq_lengthlist__16c1_s_p5_0,
		1, -531628032, 1611661312, 4, 0,
		(long *)_vq_quantlist__16c1_s_p5_0,
		0
};

static const long _vq_quantlist__16c1_s_p6_0[] = {
		8,
		7,
		9,
		6,
		10,
		5,
		11,
		4,
		12,
		3,
		13,
		2,
		14,
		1,
		15,
		0,
		16,
};

static const long _vq_lengthlist__16c1_s_p6_0[] = {
		 1, 3, 3, 6, 6, 8, 8, 9, 9, 9, 9,10,10,11,11,12,
		12, 0, 0, 0, 7, 7, 8, 8, 9, 9, 9, 9,10,10,11,11,
		12,12, 0, 0, 0, 7, 7, 8, 8, 9, 9, 9, 9,10,10,11,
		11,12,12, 0, 0, 0, 8, 8, 8, 9,10, 9,10,10,10,10,
		11,11,12,12, 0, 0, 0, 8, 8, 9, 9,10,10,10,10,11,
		11,11,12,12,12, 0, 0, 0, 8, 8, 9, 9,10,10,10,10,
		11,11,12,12,12,12, 0, 0, 0, 8, 8, 9, 9,10,10,10,
		10,11,11,12,12,13,13, 0, 0, 0, 9, 9, 9, 9,10,10,
		10,10,11,11,12,12,13,13, 0, 0, 0, 0, 0, 9, 9,10,
		10,10,10,11,11,12,12,13,13, 0, 0, 0, 0, 0, 9, 9,
		10,10,11,11,12,12,12,12,13,13, 0, 0, 0, 0, 0, 9,
		 9,10,10,11,11,12,12,12,12,13,13, 0, 0, 0, 0, 0,
		10,10,11,10,11,11,12,12,13,13,13,13, 0, 0, 0, 0,
		 0, 0, 0,10,10,11,11,12,12,13,13,13,13, 0, 0, 0,
		 0, 0, 0, 0,11,11,12,12,12,12,13,13,14,14, 0, 0,
		 0, 0, 0, 0, 0,11,11,12,12,12,12,13,13,14,14, 0,
		 0, 0, 0, 0, 0, 0,12,12,12,12,13,13,13,13,14,14,
		 0, 0, 0, 0, 0, 0, 0, 0, 0,12,12,13,13,13,13,14,
		14,
};

static const static_codebook _16c1_s_p6_0 = {
		2, 289,
		(long *)_vq_lengthlist__16c1_s_p6_0,
		1, -529530880, 1611661312, 5, 0,
		(long *)_vq_quantlist__16c1_s_p6_0,
		0
};

static const long _vq_quantlist__16c1_s_p7_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__16c1_s_p7_0[] = {
		 1, 4, 4, 6, 6, 6, 7, 6, 6, 4, 7, 7,10, 9,10,10,
		10, 9, 4, 7, 7,10,10,10,11,10,10, 6,10,10,11,11,
		11,11,10,10, 6,10, 9,11,11,11,11,10,10, 6,10,10,
		11,11,11,11,10,10, 7,11,11,11,11,11,12,12,11, 6,
		10,10,11,10,10,11,11,11, 6,10,10,10,11,10,11,11,
		11,
};

static const static_codebook _16c1_s_p7_0 = {
		4, 81,
		(long *)_vq_lengthlist__16c1_s_p7_0,
		1, -529137664, 1618345984, 2, 0,
		(long *)_vq_quantlist__16c1_s_p7_0,
		0
};

static const long _vq_quantlist__16c1_s_p7_1[] = {
		5,
		4,
		6,
		3,
		7,
		2,
		8,
		1,
		9,
		0,
		10,
};

static const long _vq_lengthlist__16c1_s_p7_1[] = {
		 2, 3, 3, 5, 6, 7, 7, 7, 7, 8, 8,10,10,10, 6, 6,
		 7, 7, 8, 8, 8, 8,10,10,10, 6, 6, 7, 7, 8, 8, 8,
		 8,10,10,10, 7, 7, 7, 7, 8, 8, 8, 8,10,10,10, 7,
		 7, 7, 7, 8, 8, 8, 8,10,10,10, 7, 7, 8, 8, 8, 8,
		 8, 8,10,10,10, 7, 7, 8, 8, 8, 8, 8, 8,10,10,10,
		 8, 8, 8, 8, 8, 8, 9, 9,10,10,10,10,10, 8, 8, 8,
		 8, 9, 9,10,10,10,10,10, 9, 9, 8, 8, 9, 9,10,10,
		10,10,10, 8, 8, 8, 8, 9, 9,
};

static const static_codebook _16c1_s_p7_1 = {
		2, 121,
		(long *)_vq_lengthlist__16c1_s_p7_1,
		1, -531365888, 1611661312, 4, 0,
		(long *)_vq_quantlist__16c1_s_p7_1,
		0
};

static const long _vq_quantlist__16c1_s_p8_0[] = {
		6,
		5,
		7,
		4,
		8,
		3,
		9,
		2,
		10,
		1,
		11,
		0,
		12,
};

static const long _vq_lengthlist__16c1_s_p8_0[] = {
		 1, 4, 4, 6, 6, 7, 7, 7, 7, 8, 8, 9, 9, 6, 5, 5,
		 7, 8, 8, 9, 8, 8, 9, 9,10,11, 6, 5, 5, 8, 8, 9,
		 9, 8, 8, 9,10,10,11, 0, 8, 8, 8, 9, 9, 9, 9, 9,
		10,10,11,11, 0, 9, 9, 9, 8, 9, 9, 9, 9,10,10,11,
		11, 0,13,13, 9, 9,10,10,10,10,11,11,12,12, 0,14,
		13, 9, 9,10,10,10,10,11,11,12,12, 0, 0, 0,10,10,
		 9, 9,11,11,12,12,13,12, 0, 0, 0,10,10, 9, 9,10,
		10,12,12,13,13, 0, 0, 0,13,14,11,10,11,11,12,12,
		13,14, 0, 0, 0,14,14,10,10,11,11,12,12,13,13, 0,
		 0, 0, 0, 0,12,12,12,12,13,13,14,15, 0, 0, 0, 0,
		 0,12,12,12,12,13,13,14,15,
};

static const static_codebook _16c1_s_p8_0 = {
		2, 169,
		(long *)_vq_lengthlist__16c1_s_p8_0,
		1, -526516224, 1616117760, 4, 0,
		(long *)_vq_quantlist__16c1_s_p8_0,
		0
};

static const long _vq_quantlist__16c1_s_p8_1[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__16c1_s_p8_1[] = {
		 2, 3, 3, 5, 5, 6, 6, 6, 5, 5, 6, 6, 6, 5, 5, 6,
		 6, 6, 5, 5, 6, 6, 6, 5, 5,
};

static const static_codebook _16c1_s_p8_1 = {
		2, 25,
		(long *)_vq_lengthlist__16c1_s_p8_1,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__16c1_s_p8_1,
		0
};

static const long _vq_quantlist__16c1_s_p9_0[] = {
		6,
		5,
		7,
		4,
		8,
		3,
		9,
		2,
		10,
		1,
		11,
		0,
		12,
};

static const long _vq_lengthlist__16c1_s_p9_0[] = {
		 1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
		 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
		 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
		 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
		 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
		 9, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
		 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
		 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
		 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
		 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
		 8, 8, 8, 8, 8, 8, 8, 8, 8,
};

static const static_codebook _16c1_s_p9_0 = {
		2, 169,
		(long *)_vq_lengthlist__16c1_s_p9_0,
		1, -513964032, 1628680192, 4, 0,
		(long *)_vq_quantlist__16c1_s_p9_0,
		0
};

static const long _vq_quantlist__16c1_s_p9_1[] = {
		7,
		6,
		8,
		5,
		9,
		4,
		10,
		3,
		11,
		2,
		12,
		1,
		13,
		0,
		14,
};

static const long _vq_lengthlist__16c1_s_p9_1[] = {
		 1, 4, 4, 4, 4, 8, 8,12,13,14,14,14,14,14,14, 6,
		 6, 6, 6, 6,10, 9,14,14,14,14,14,14,14,14, 7, 6,
		 5, 6, 6,10, 9,12,13,13,13,13,13,13,13,13, 7, 7,
		 9, 9,11,11,12,13,13,13,13,13,13,13,13, 7, 7, 8,
		 8,11,12,13,13,13,13,13,13,13,13,13,12,12,10,10,
		13,12,13,13,13,13,13,13,13,13,13,12,12,10,10,13,
		13,13,13,13,13,13,13,13,13,13,13,13,13,12,13,12,
		13,13,13,13,13,13,13,13,13,13,13,13,12,13,13,13,
		13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
		13,13,13,13,13,13,13,13,13,13,13,13,12,13,13,13,
		13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
		13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
		13,13,13,13,13,13,13,13,13,12,13,13,13,13,13,13,
		13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
		13,
};

static const static_codebook _16c1_s_p9_1 = {
		2, 225,
		(long *)_vq_lengthlist__16c1_s_p9_1,
		1, -520986624, 1620377600, 4, 0,
		(long *)_vq_quantlist__16c1_s_p9_1,
		0
};

static const long _vq_quantlist__16c1_s_p9_2[] = {
		10,
		9,
		11,
		8,
		12,
		7,
		13,
		6,
		14,
		5,
		15,
		4,
		16,
		3,
		17,
		2,
		18,
		1,
		19,
		0,
		20,
};

static const long _vq_lengthlist__16c1_s_p9_2[] = {
		 1, 4, 4, 6, 6, 7, 7, 8, 7, 8, 8, 9, 9, 9, 9,10,
		10,10, 9,10,10,11,12,12, 8, 8, 8, 8, 9, 9, 9, 9,
		10,10,10,10,10,11,11,10,12,11,11,13,11, 7, 7, 8,
		 8, 8, 8, 9, 9, 9,10,10,10,10, 9,10,10,11,11,12,
		11,11, 8, 8, 8, 8, 9, 9,10,10,10,10,11,11,11,11,
		11,11,11,12,11,12,12, 8, 8, 9, 9, 9, 9, 9,10,10,
		10,10,10,10,11,11,11,11,11,11,12,11, 9, 9, 9, 9,
		10,10,10,10,11,10,11,11,11,11,11,11,12,12,12,12,
		11, 9, 9, 9, 9,10,10,10,10,11,11,11,11,11,11,11,
		11,11,12,12,12,13, 9,10,10, 9,11,10,10,10,10,11,
		11,11,11,11,10,11,12,11,12,12,11,12,11,10, 9,10,
		10,11,10,11,11,11,11,11,11,11,11,11,12,12,11,12,
		12,12,10,10,10,11,10,11,11,11,11,11,11,11,11,11,
		11,11,12,13,12,12,11, 9,10,10,11,11,10,11,11,11,
		12,11,11,11,11,11,12,12,13,13,12,13,10,10,12,10,
		11,11,11,11,11,11,11,11,11,12,12,11,13,12,12,12,
		12,13,12,11,11,11,11,11,11,12,11,12,11,11,11,11,
		12,12,13,12,11,12,12,11,11,11,11,11,12,11,11,11,
		11,12,11,11,12,11,12,13,13,12,12,12,12,11,11,11,
		11,11,12,11,11,12,11,12,11,11,11,11,13,12,12,12,
		12,13,11,11,11,12,12,11,11,11,12,11,12,12,12,11,
		12,13,12,11,11,12,12,11,12,11,11,11,12,12,11,12,
		11,11,11,12,12,12,12,13,12,13,12,12,12,12,11,11,
		12,11,11,11,11,11,11,12,12,12,13,12,11,13,13,12,
		12,11,12,10,11,11,11,11,12,11,12,12,11,12,12,13,
		12,12,13,12,12,12,12,12,11,12,12,12,11,12,11,11,
		11,12,13,12,13,13,13,13,13,12,13,13,12,12,13,11,
		11,11,11,11,12,11,11,12,11,
};

static const static_codebook _16c1_s_p9_2 = {
		2, 441,
		(long *)_vq_lengthlist__16c1_s_p9_2,
		1, -529268736, 1611661312, 5, 0,
		(long *)_vq_quantlist__16c1_s_p9_2,
		0
};

static const long _huff_lengthlist__16c1_s_short[] = {
		 5, 6,17, 8,12, 9,10,10,12,13, 5, 2,17, 4, 9, 5,
		 7, 8,11,13,16,16,16,16,16,16,16,16,16,16, 6, 4,
		16, 5,10, 5, 7,10,14,16,13, 9,16,11, 8, 7, 8, 9,
		13,16, 7, 4,16, 5, 7, 4, 6, 8,11,13, 8, 6,16, 7,
		 8, 5, 5, 7, 9,13, 9, 8,16, 9, 8, 6, 6, 7, 9,13,
		11,11,16,10,10, 7, 7, 7, 9,13,13,13,16,13,13, 9,
		 9, 9,10,13,
};

static const static_codebook _huff_book__16c1_s_short = {
		2, 100,
		(long *)_huff_lengthlist__16c1_s_short,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist__16c2_s_long[] = {
	 4, 7, 9, 9, 9, 8, 9,10,13,16, 5, 4, 5, 6, 7, 7,
	 8, 9,12,16, 6, 5, 5, 5, 7, 7, 9,10,12,15, 7, 6,
	 5, 4, 5, 6, 8, 9,10,13, 8, 7, 7, 5, 5, 5, 7, 9,
	10,12, 7, 7, 7, 6, 5, 5, 6, 7,10,12, 8, 8, 8, 7,
	 7, 5, 5, 6, 9,11, 8, 9, 9, 8, 8, 6, 6, 5, 8,11,
	10,11,12,12,11, 9, 9, 8, 9,12,13,14,15,15,14,12,
	12,11,11,13,
};

static const static_codebook _huff_book__16c2_s_long = {
	2, 100,
	(long *)_huff_lengthlist__16c2_s_long,
	0, 0, 0, 0, 0,
	NULL,
	0
};

static const long _vq_quantlist__16c2_s_p1_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__16c2_s_p1_0[] = {
	 1, 3, 3, 0, 0, 0, 0, 0, 0, 4, 5, 5, 0, 0, 0, 0,
	 0, 0, 4, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0,
};

static const static_codebook _16c2_s_p1_0 = {
	4, 81,
	(long *)_vq_lengthlist__16c2_s_p1_0,
	1, -535822336, 1611661312, 2, 0,
	(long *)_vq_quantlist__16c2_s_p1_0,
	0
};

static const long _vq_quantlist__16c2_s_p2_0[] = {
	2,
	1,
	3,
	0,
	4,
};

static const long _vq_lengthlist__16c2_s_p2_0[] = {
	 2, 4, 4, 7, 7, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0,
	 0, 0, 8, 8, 0, 0, 0, 8, 8, 4, 4, 4, 8, 7, 0, 0,
	 0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 9, 9, 0, 0, 0,
	 9, 9, 4, 4, 4, 7, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8,
	 8, 0, 0, 0, 9, 9, 0, 0, 0, 9, 9, 7, 8, 8,10, 9,
	 0, 0, 0,12,11, 0, 0, 0,11,12, 0, 0, 0,14,13, 0,
	 0, 0,14,14, 7, 8, 8, 9,10, 0, 0, 0,11,12, 0, 0,
	 0,11,11, 0, 0, 0,14,14, 0, 0, 0,14,14, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8,11,11, 0, 0, 0,
	12,11, 0, 0, 0,12,12, 0, 0, 0,13,12, 0, 0, 0,13,
	13, 8, 8, 8,11,11, 0, 0, 0,11,11, 0, 0, 0,12,12,
	 0, 0, 0,13,13, 0, 0, 0,13,13, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 8, 9, 8,12,11, 0, 0, 0,12,12, 0,
	 0, 0,12,11, 0, 0, 0,13,13, 0, 0, 0,13,13, 8, 8,
	 8,11,12, 0, 0, 0,11,12, 0, 0, 0,11,12, 0, 0, 0,
	13,14, 0, 0, 0,13,13, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 8, 9, 9,14,14, 0, 0, 0,13,13, 0, 0, 0,13,
	13, 0, 0, 0,13,12, 0, 0, 0,13,13, 8, 9, 9,14,14,
	 0, 0, 0,13,13, 0, 0, 0,13,13, 0, 0, 0,12,13, 0,
	 0, 0,13,13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8,
	 9, 9,14,14, 0, 0, 0,13,13, 0, 0, 0,13,13, 0, 0,
	 0,13,13, 0, 0, 0,13,12, 8, 9, 9,14,14, 0, 0, 0,
	13,13, 0, 0, 0,13,13, 0, 0, 0,13,13, 0, 0, 0,12,
	12,
};

static const static_codebook _16c2_s_p2_0 = {
	4, 625,
	(long *)_vq_lengthlist__16c2_s_p2_0,
	1, -533725184, 1611661312, 3, 0,
	(long *)_vq_quantlist__16c2_s_p2_0,
	0
};

static const long _vq_quantlist__16c2_s_p3_0[] = {
	4,
	3,
	5,
	2,
	6,
	1,
	7,
	0,
	8,
};

static const long _vq_lengthlist__16c2_s_p3_0[] = {
	 1, 3, 3, 5, 5, 7, 7, 8, 8, 0, 0, 0, 6, 6, 8, 8,
	 9, 9, 0, 0, 0, 6, 6, 8, 8, 9, 9, 0, 0, 0, 7, 7,
	 8, 9,10,10, 0, 0, 0, 7, 7, 9, 9,10,10, 0, 0, 0,
	 8, 8, 9, 9,11,11, 0, 0, 0, 7, 7, 9, 9,11,11, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0,
};

static const static_codebook _16c2_s_p3_0 = {
	2, 81,
	(long *)_vq_lengthlist__16c2_s_p3_0,
	1, -531628032, 1611661312, 4, 0,
	(long *)_vq_quantlist__16c2_s_p3_0,
	0
};

static const long _vq_quantlist__16c2_s_p4_0[] = {
	8,
	7,
	9,
	6,
	10,
	5,
	11,
	4,
	12,
	3,
	13,
	2,
	14,
	1,
	15,
	0,
	16,
};

static const long _vq_lengthlist__16c2_s_p4_0[] = {
	 2, 3, 3, 5, 5, 6, 6, 6, 6, 7, 7, 8, 8, 8, 8, 9,
	 9, 0, 0, 0, 6, 6, 7, 7, 8, 8, 8, 8, 9, 9,10,10,
	11,10, 0, 0, 0, 6, 6, 7, 7, 8, 8, 8, 8, 9, 9,10,
	10,10,10, 0, 0, 0, 6, 6, 8, 8, 9, 9, 9, 9,10,10,
	11,11,11,11, 0, 0, 0, 7, 6, 8, 8, 9, 9, 9, 9,10,
	10,11,11,11,11, 0, 0, 0, 7, 7, 8, 8, 9, 9,10,10,
	11,11,11,11,12,12, 0, 0, 0, 7, 7, 8, 8, 9, 9,10,
	10,11,11,11,11,12,12, 0, 0, 0, 7, 8, 8, 8, 9, 9,
	10,10,11,11,12,12,13,13, 0, 0, 0, 0, 0, 8, 8, 9,
	 9,10,10,11,11,12,12,13,13, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0,
};

static const static_codebook _16c2_s_p4_0 = {
	2, 289,
	(long *)_vq_lengthlist__16c2_s_p4_0,
	1, -529530880, 1611661312, 5, 0,
	(long *)_vq_quantlist__16c2_s_p4_0,
	0
};

static const long _vq_quantlist__16c2_s_p5_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__16c2_s_p5_0[] = {
	 1, 4, 4, 5, 7, 7, 6, 7, 7, 4, 6, 6,10,11,10,10,
	10,11, 4, 6, 6,10,10,11,10,11,10, 5,10,10, 9,12,
	11,10,12,12, 7,10,10,12,12,12,12,13,13, 7,11,10,
	11,12,12,12,13,13, 6,11,10,10,12,12,11,12,12, 7,
	11,10,12,13,13,12,12,12, 7,10,11,12,13,13,12,12,
	12,
};

static const static_codebook _16c2_s_p5_0 = {
	4, 81,
	(long *)_vq_lengthlist__16c2_s_p5_0,
	1, -529137664, 1618345984, 2, 0,
	(long *)_vq_quantlist__16c2_s_p5_0,
	0
};

static const long _vq_quantlist__16c2_s_p5_1[] = {
	5,
	4,
	6,
	3,
	7,
	2,
	8,
	1,
	9,
	0,
	10,
};

static const long _vq_lengthlist__16c2_s_p5_1[] = {
	 2, 3, 3, 6, 6, 6, 6, 7, 7, 7, 7,11,10,10, 6, 6,
	 7, 7, 8, 8, 8, 8,10,10,10, 6, 6, 7, 7, 8, 8, 8,
	 8,11,11,11, 7, 7, 8, 8, 8, 8, 9, 9,11,11,11, 6,
	 7, 8, 8, 8, 8, 9, 9,11,11,11, 7, 7, 8, 8, 8, 8,
	 8, 8,11,11,11, 7, 7, 8, 8, 8, 8, 9, 9,11,11,11,
	 8, 8, 8, 8, 8, 8, 8, 8,11,11,11,11,11, 8, 8, 8,
	 8, 8, 8,12,11,11,11,11, 8, 8, 8, 8, 8, 8,12,11,
	11,11,11, 7, 7, 8, 8, 8, 8,
};

static const static_codebook _16c2_s_p5_1 = {
	2, 121,
	(long *)_vq_lengthlist__16c2_s_p5_1,
	1, -531365888, 1611661312, 4, 0,
	(long *)_vq_quantlist__16c2_s_p5_1,
	0
};

static const long _vq_quantlist__16c2_s_p6_0[] = {
	6,
	5,
	7,
	4,
	8,
	3,
	9,
	2,
	10,
	1,
	11,
	0,
	12,
};

static const long _vq_lengthlist__16c2_s_p6_0[] = {
	 1, 4, 4, 6, 6, 8, 7, 8, 8, 9, 9,10,10, 5, 5, 5,
	 7, 7, 9, 9, 9, 9,11,11,12,12, 6, 5, 5, 7, 7, 9,
	 9,10, 9,11,11,12,12, 0, 7, 7, 7, 7, 9, 9,10,10,
	11,11,12,12, 0, 7, 7, 7, 7, 9, 9,10,10,11,11,12,
	12, 0,11,11, 8, 8,10,10,11,11,12,12,13,13, 0,12,
	12, 9, 9,10,10,11,11,12,12,13,13, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0,
};

static const static_codebook _16c2_s_p6_0 = {
	2, 169,
	(long *)_vq_lengthlist__16c2_s_p6_0,
	1, -526516224, 1616117760, 4, 0,
	(long *)_vq_quantlist__16c2_s_p6_0,
	0
};

static const long _vq_quantlist__16c2_s_p6_1[] = {
	2,
	1,
	3,
	0,
	4,
};

static const long _vq_lengthlist__16c2_s_p6_1[] = {
	 2, 3, 3, 5, 5, 6, 6, 6, 5, 5, 6, 6, 6, 5, 5, 6,
	 6, 6, 5, 5, 6, 6, 6, 5, 5,
};

static const static_codebook _16c2_s_p6_1 = {
	2, 25,
	(long *)_vq_lengthlist__16c2_s_p6_1,
	1, -533725184, 1611661312, 3, 0,
	(long *)_vq_quantlist__16c2_s_p6_1,
	0
};

static const long _vq_quantlist__16c2_s_p7_0[] = {
	6,
	5,
	7,
	4,
	8,
	3,
	9,
	2,
	10,
	1,
	11,
	0,
	12,
};

static const long _vq_lengthlist__16c2_s_p7_0[] = {
	 1, 4, 4, 7, 7, 8, 8, 8, 8,10, 9,10,10, 5, 5, 5,
	 7, 7, 9, 9,10,10,11,10,12,11, 6, 5, 5, 7, 7, 9,
	 9,10,10,11,11,12,12,20, 7, 7, 7, 7, 9, 9,10,10,
	11,11,12,12,20, 7, 7, 7, 7, 9, 9,11,10,12,11,12,
	12,20,11,11, 8, 8,10,10,11,11,12,12,13,13,20,12,
	12, 8, 8, 9, 9,11,11,12,12,13,13,20,20,21,10,10,
	10,10,11,11,12,12,13,13,21,21,21,10,10,10,10,11,
	11,12,12,13,13,21,21,21,14,14,11,11,12,12,13,13,
	13,14,21,21,21,16,15,11,11,12,11,13,13,14,14,21,
	21,21,21,21,13,13,12,12,13,13,14,14,21,21,21,21,
	21,13,13,12,12,13,13,14,14,
};

static const static_codebook _16c2_s_p7_0 = {
	2, 169,
	(long *)_vq_lengthlist__16c2_s_p7_0,
	1, -523206656, 1618345984, 4, 0,
	(long *)_vq_quantlist__16c2_s_p7_0,
	0
};

static const long _vq_quantlist__16c2_s_p7_1[] = {
	5,
	4,
	6,
	3,
	7,
	2,
	8,
	1,
	9,
	0,
	10,
};

static const long _vq_lengthlist__16c2_s_p7_1[] = {
	 2, 4, 4, 6, 6, 7, 7, 7, 7, 7, 7, 9, 9, 9, 6, 7,
	 7, 7, 7, 7, 8, 8, 9, 9, 9, 6, 6, 7, 7, 7, 7, 8,
	 8, 9, 9, 9, 7, 7, 7, 7, 8, 8, 8, 8, 9, 9, 9, 7,
	 7, 7, 7, 8, 8, 8, 8, 9, 9, 9, 7, 7, 7, 7, 8, 8,
	 8, 8, 9, 9, 9, 7, 7, 7, 7, 7, 7, 8, 8, 9, 9, 9,
	 7, 7, 8, 8, 7, 7, 8, 8, 9, 9, 9, 9, 9, 8, 8, 7,
	 7, 8, 8, 9, 9, 9, 9, 9, 8, 8, 7, 7, 8, 8, 9, 9,
	 9, 9, 9, 7, 7, 7, 7, 8, 8,
};

static const static_codebook _16c2_s_p7_1 = {
	2, 121,
	(long *)_vq_lengthlist__16c2_s_p7_1,
	1, -531365888, 1611661312, 4, 0,
	(long *)_vq_quantlist__16c2_s_p7_1,
	0
};

static const long _vq_quantlist__16c2_s_p8_0[] = {
	7,
	6,
	8,
	5,
	9,
	4,
	10,
	3,
	11,
	2,
	12,
	1,
	13,
	0,
	14,
};

static const long _vq_lengthlist__16c2_s_p8_0[] = {
	 1, 4, 4, 6, 6, 7, 7, 7, 7, 8, 8, 9, 9,10,10, 6,
	 6, 6, 8, 8, 9, 9, 8, 8, 9, 9,10,10,11,11, 6, 5,
	 5, 8, 7, 9, 9, 8, 8, 9, 9,10,10,11,11,20, 8, 8,
	 8, 8, 9, 9, 9, 9,10,10,11,10,12,11,20, 8, 8, 8,
	 8, 9, 9, 9, 9,10,10,11,11,12,12,20,12,12, 9, 9,
	10,10,10,10,11,11,12,12,13,12,20,13,13, 9, 9,10,
	10,10,10,11,11,12,12,13,13,20,20,20, 9, 9, 9, 9,
	10,10,11,11,12,12,13,12,20,20,20, 9, 9, 9, 8,10,
	10,12,11,12,12,13,13,20,20,20,13,13,10,10,11,11,
	12,12,13,13,13,13,20,20,20,13,13,10,10,11,10,12,
	11,13,13,14,14,20,20,20,20,20,11,11,11,11,12,12,
	13,13,14,14,20,20,20,20,20,11,10,11,11,13,11,13,
	13,14,14,20,20,21,21,21,14,14,11,12,13,13,13,13,
	14,14,21,21,21,21,21,15,15,12,11,13,12,14,13,15,
	14,
};

static const static_codebook _16c2_s_p8_0 = {
	2, 225,
	(long *)_vq_lengthlist__16c2_s_p8_0,
	1, -520986624, 1620377600, 4, 0,
	(long *)_vq_quantlist__16c2_s_p8_0,
	0
};

static const long _vq_quantlist__16c2_s_p8_1[] = {
	10,
	9,
	11,
	8,
	12,
	7,
	13,
	6,
	14,
	5,
	15,
	4,
	16,
	3,
	17,
	2,
	18,
	1,
	19,
	0,
	20,
};

static const long _vq_lengthlist__16c2_s_p8_1[] = {
	 2, 4, 4, 6, 6, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8,
	 8, 8, 8, 8, 8,11,11,11, 7, 7, 8, 8, 8, 8, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,10,11,10, 7, 7, 8,
	 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,11,
	11,11, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9,11,11,11, 8, 8, 8, 8, 9, 9, 9, 9, 9,
	 9, 9, 9,10, 9,10,10,10,10,11,11,11, 8, 8, 9, 9,
	 9, 9, 9, 9, 9, 9,10,10,10,10,10,10,10,10,11,11,
	11, 8, 8, 9, 9, 9, 9, 9, 9, 9,10,10,10,10,10,10,
	10,10,10,11,11,11, 9, 9, 9, 9, 9, 9, 9, 9,10,10,
	10,10,10,10,10,10,10,10,11,11,11,11,11, 9, 9, 9,
	 9, 9, 9,10,10,10,10,10,10,10,10,10,10,11,11,11,
	11,11, 9, 9, 9, 9,10,10,10,10,10,10,10,10,10,10,
	10,10,11,11,11,11,11, 9, 9, 9, 9,10,10,10,10,10,
	10,10,10,10,10,10,10,11,11,11,11,11,10, 9,10,10,
	10,10,10,10,10,10,10,10,10,10,10,10,11,11,11,11,
	11,11,11,10,10,10,10,10,10,10,10,10,10,10,10,10,
	10,11,11,11,11,11,11,11,10,10,10,10,10,10,10,10,
	10,10,10,10,10,10,11,11,11,11,11,11,11,10,10,10,
	10,10,10,10,10,10,10,10,10,10,10,11,11,11,11,11,
	11,11,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
	11,11,11,11,11,11,11,11,11,10,10,10,10,10,10,10,
	10,10,10,10,10,11,11,11,11,11,11,11,11,11,10,10,
	10,10,10,10,10,10,10,10,10,10,11,11,11,11,11,11,
	11,11,11,10,10,10,10,10,10,10,10,10,10,10,10,11,
	11,11,11,11,11,11,11,11,10,10,10,10,10,10,10,10,
	10,10,10,10,11,11,11,11,11,11,11,11,11,11,11,10,
	10,10,10,10,10,10,10,10,10,
};

static const static_codebook _16c2_s_p8_1 = {
	2, 441,
	(long *)_vq_lengthlist__16c2_s_p8_1,
	1, -529268736, 1611661312, 5, 0,
	(long *)_vq_quantlist__16c2_s_p8_1,
	0
};

static const long _vq_quantlist__16c2_s_p9_0[] = {
	8,
	7,
	9,
	6,
	10,
	5,
	11,
	4,
	12,
	3,
	13,
	2,
	14,
	1,
	15,
	0,
	16,
};

static const long _vq_lengthlist__16c2_s_p9_0[] = {
	 1, 4, 3,10, 8,10,10,10,10,10,10,10,10,10,10,10,
	10, 6,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
	10,10, 6,10, 9,10,10,10,10,10,10,10,10,10,10,10,
	10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
	10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
	10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
	10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
	10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
	10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
	10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
	10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
	10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
	10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
	10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
	10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
	10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
	10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
	10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
	10,
};

static const static_codebook _16c2_s_p9_0 = {
	2, 289,
	(long *)_vq_lengthlist__16c2_s_p9_0,
	1, -509798400, 1631393792, 5, 0,
	(long *)_vq_quantlist__16c2_s_p9_0,
	0
};

static const long _vq_quantlist__16c2_s_p9_1[] = {
	9,
	8,
	10,
	7,
	11,
	6,
	12,
	5,
	13,
	4,
	14,
	3,
	15,
	2,
	16,
	1,
	17,
	0,
	18,
};

static const long _vq_lengthlist__16c2_s_p9_1[] = {
	 1, 4, 4, 7, 7, 7, 7, 7, 7, 8, 8,10, 9,11,10,13,
	11,14,13, 6, 6, 6, 8, 8, 8, 8, 8, 7, 9, 8,11, 9,
	13,11,14,12,14,13, 5, 6, 6, 8, 8, 8, 8, 8, 8, 9,
	 9,11,11,13,11,14,13,15,15,17, 8, 8, 8, 8, 9, 9,
	 9, 8,11, 9,12,10,13,11,14,12,14,13,17, 8, 8, 8,
	 8, 9, 9, 9, 9,10,10,11,11,13,13,13,14,16,15,17,
	12,12, 8, 8, 9, 9,10,10,11,11,12,11,13,12,13,12,
	14,13,16,12,12, 8, 8, 9, 9,10,10,11,11,12,12,13,
	13,14,14,15,15,17,17,17, 9, 9, 9, 9,11,11,12,12,
	12,13,13,13,16,14,14,14,17,17,17, 9, 8, 9, 8,11,
	10,12,12,13,13,14,14,15,15,16,16,17,17,17,12,12,
	10,10,11,12,12,13,13,14,13,15,15,14,16,15,17,17,
	17,12,12,10, 8,12, 9,13,12,14,14,15,14,15,16,16,
	16,17,17,17,17,17,11,11,12,12,14,14,14,16,15,16,
	15,16,15,17,17,17,17,17,17,11, 9,12,10,13,11,15,
	14,16,16,17,16,16,15,17,17,17,17,17,15,15,12,12,
	14,14,15,16,16,15,16,16,17,17,17,17,17,17,17,14,
	14,12,10,14,11,15,12,17,16,15,16,17,16,17,17,17,
	17,17,17,17,13,13,14,14,14,16,17,17,16,17,17,17,
	17,17,17,17,17,17,17,13, 9,13,12,15,13,16,16,17,
	17,17,17,17,17,17,17,17,17,17,15,17,14,14,15,16,
	16,17,16,17,16,17,17,17,17,17,17,17,17,17,17,14,
	13,15,16,16,17,16,17,17,17,
};

static const static_codebook _16c2_s_p9_1 = {
	2, 361,
	(long *)_vq_lengthlist__16c2_s_p9_1,
	1, -518287360, 1622704128, 5, 0,
	(long *)_vq_quantlist__16c2_s_p9_1,
	0
};

static const long _vq_quantlist__16c2_s_p9_2[] = {
	24,
	23,
	25,
	22,
	26,
	21,
	27,
	20,
	28,
	19,
	29,
	18,
	30,
	17,
	31,
	16,
	32,
	15,
	33,
	14,
	34,
	13,
	35,
	12,
	36,
	11,
	37,
	10,
	38,
	9,
	39,
	8,
	40,
	7,
	41,
	6,
	42,
	5,
	43,
	4,
	44,
	3,
	45,
	2,
	46,
	1,
	47,
	0,
	48,
};

static const long _vq_lengthlist__16c2_s_p9_2[] = {
	 2, 4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6,
	 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
	 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
	 7,
};

static const static_codebook _16c2_s_p9_2 = {
	1, 49,
	(long *)_vq_lengthlist__16c2_s_p9_2,
	1, -526909440, 1611661312, 6, 0,
	(long *)_vq_quantlist__16c2_s_p9_2,
	0
};

static const long _huff_lengthlist__16c2_s_short[] = {
	 7,10,12,11,12,13,15,16,18,15,10, 8, 8, 8, 9,10,
	12,13,14,17,10, 7, 7, 7, 7, 8,10,12,15,18,10, 7,
	 7, 5, 5, 6, 8,10,13,15,10, 7, 6, 5, 4, 4, 6, 9,
	12,15,11, 7, 7, 5, 4, 3, 4, 7,11,13,12, 9, 8, 7,
	 5, 4, 4, 5,10,13,11,11,11, 9, 7, 5, 5, 5, 9,12,
	13,12,13,12,10, 8, 8, 7, 9,13,14,14,14,14,13,11,
	11,10,10,13,
};

static const static_codebook _huff_book__16c2_s_short = {
	2, 100,
	(long *)_huff_lengthlist__16c2_s_short,
	0, 0, 0, 0, 0,
	NULL,
	0
};

static const long _vq_quantlist__8c0_s_p1_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__8c0_s_p1_0[] = {
		 1, 5, 4, 0, 0, 0, 0, 0, 0, 5, 7, 7, 0, 0, 0, 0,
		 0, 0, 5, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 5, 8, 8, 0, 0, 0, 0, 0, 0, 7, 8, 9, 0, 0, 0,
		 0, 0, 0, 7, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 5, 8, 8, 0, 0, 0, 0, 0, 0, 7, 9, 9, 0, 0,
		 0, 0, 0, 0, 7, 9, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 8, 8, 0, 0, 0, 0,
		 0, 0, 8,10,10, 0, 0, 0, 0, 0, 0, 8, 9, 9, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7,10, 9, 0, 0, 0,
		 0, 0, 0, 8, 9,11, 0, 0, 0, 0, 0, 0, 9,11,11, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 9,10, 0, 0,
		 0, 0, 0, 0, 9,11,10, 0, 0, 0, 0, 0, 0, 9,11,11,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 5, 8, 8, 0, 0, 0, 0, 0, 0, 8, 9, 9, 0, 0,
		 0, 0, 0, 0, 8, 9,10, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 7, 9, 9, 0, 0, 0, 0, 0, 0, 9,11,11, 0,
		 0, 0, 0, 0, 0, 9,10,11, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 7, 9,10, 0, 0, 0, 0, 0, 0, 9,11,11,
		 0, 0, 0, 0, 0, 0, 8,11, 9, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0,
};

static const static_codebook _8c0_s_p1_0 = {
		8, 6561,
		(long *)_vq_lengthlist__8c0_s_p1_0,
		1, -535822336, 1611661312, 2, 0,
		(long *)_vq_quantlist__8c0_s_p1_0,
		0
};

static const long _vq_quantlist__8c0_s_p3_0[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__8c0_s_p3_0[] = {
		 1, 4, 4, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 5, 6, 7, 7, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 4, 5, 5, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 7, 7, 8, 8,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 6, 7, 7, 8, 8, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0,
};

static const static_codebook _8c0_s_p3_0 = {
		4, 625,
		(long *)_vq_lengthlist__8c0_s_p3_0,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__8c0_s_p3_0,
		0
};

static const long _vq_quantlist__8c0_s_p4_0[] = {
		4,
		3,
		5,
		2,
		6,
		1,
		7,
		0,
		8,
};

static const long _vq_lengthlist__8c0_s_p4_0[] = {
		 1, 2, 3, 7, 7, 0, 0, 0, 0, 0, 0, 0, 6, 6, 0, 0,
		 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 0, 7, 7,
		 0, 0, 0, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0, 0, 0,
		 8, 8, 0, 0, 0, 0, 0, 0, 0, 9, 8, 0, 0, 0, 0, 0,
		 0, 0,10,10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0,
};

static const static_codebook _8c0_s_p4_0 = {
		2, 81,
		(long *)_vq_lengthlist__8c0_s_p4_0,
		1, -531628032, 1611661312, 4, 0,
		(long *)_vq_quantlist__8c0_s_p4_0,
		0
};

static const long _vq_quantlist__8c0_s_p5_0[] = {
		4,
		3,
		5,
		2,
		6,
		1,
		7,
		0,
		8,
};

static const long _vq_lengthlist__8c0_s_p5_0[] = {
		 1, 3, 3, 5, 5, 7, 6, 8, 8, 0, 0, 0, 7, 7, 7, 7,
		 8, 8, 0, 0, 0, 7, 7, 7, 7, 8, 9, 0, 0, 0, 8, 8,
		 8, 8, 9, 9, 0, 0, 0, 8, 8, 8, 8, 9, 9, 0, 0, 0,
		 9, 9, 8, 8,10,10, 0, 0, 0, 9, 9, 8, 8,10,10, 0,
		 0, 0,10,10, 9, 9,10,10, 0, 0, 0, 0, 0, 9, 9,10,
		10,
};

static const static_codebook _8c0_s_p5_0 = {
		2, 81,
		(long *)_vq_lengthlist__8c0_s_p5_0,
		1, -531628032, 1611661312, 4, 0,
		(long *)_vq_quantlist__8c0_s_p5_0,
		0
};

static const long _vq_quantlist__8c0_s_p6_0[] = {
		8,
		7,
		9,
		6,
		10,
		5,
		11,
		4,
		12,
		3,
		13,
		2,
		14,
		1,
		15,
		0,
		16,
};

static const long _vq_lengthlist__8c0_s_p6_0[] = {
		 1, 3, 3, 6, 6, 8, 8, 9, 9, 8, 8,10, 9,10,10,11,
		11, 0, 0, 0, 7, 7, 8, 8, 9, 9, 9, 9,10,10,11,11,
		11,12, 0, 0, 0, 7, 7, 8, 8, 9, 9, 9, 9,10,10,11,
		11,12,11, 0, 0, 0, 8, 8, 9, 9,10,10, 9, 9,10,10,
		11,11,12,12, 0, 0, 0, 8, 8, 9, 9,10,10, 9, 9,11,
		10,11,11,12,12, 0, 0, 0, 9, 9, 9, 9,10,10,10,10,
		11,11,11,12,12,12, 0, 0, 0, 9, 9, 9, 9,10,10,10,
		10,11,11,12,12,13,13, 0, 0, 0,10,10,10,10,11,11,
		10,10,11,11,12,12,13,13, 0, 0, 0, 0, 0,10, 9,10,
		11,10,10,11,11,12,12,13,13, 0, 0, 0, 0, 0, 9, 9,
		10, 9,10,11,12,12,13,13,14,13, 0, 0, 0, 0, 0, 9,
		 9, 9,10,10,10,11,11,13,12,13,13, 0, 0, 0, 0, 0,
		10,10,10,10,11,11,12,12,13,13,14,14, 0, 0, 0, 0,
		 0, 0, 0,10,10,11,11,12,12,13,13,13,14, 0, 0, 0,
		 0, 0, 0, 0,11,11,11,11,12,12,13,14,14,14, 0, 0,
		 0, 0, 0, 0, 0,11,11,11,11,12,12,13,13,14,13, 0,
		 0, 0, 0, 0, 0, 0,11,11,12,12,13,13,14,14,14,14,
		 0, 0, 0, 0, 0, 0, 0, 0, 0,12,12,12,12,13,13,14,
		14,
};

static const static_codebook _8c0_s_p6_0 = {
		2, 289,
		(long *)_vq_lengthlist__8c0_s_p6_0,
		1, -529530880, 1611661312, 5, 0,
		(long *)_vq_quantlist__8c0_s_p6_0,
		0
};

static const long _vq_quantlist__8c0_s_p7_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__8c0_s_p7_0[] = {
		 1, 4, 4, 7, 6, 6, 7, 6, 6, 4, 7, 7,11, 9,10,12,
		 9,10, 4, 7, 7,10,10,10,11, 9, 9, 6,11,10,11,11,
		12,11,11,11, 6,10,10,11,11,12,11,10,10, 6, 9,10,
		11,11,11,11,10,10, 7,10,11,12,11,11,12,11,12, 6,
		 9, 9,10, 9, 9,11,10,10, 6, 9, 9,10,10,10,11,10,
		10,
};

static const static_codebook _8c0_s_p7_0 = {
		4, 81,
		(long *)_vq_lengthlist__8c0_s_p7_0,
		1, -529137664, 1618345984, 2, 0,
		(long *)_vq_quantlist__8c0_s_p7_0,
		0
};

static const long _vq_quantlist__8c0_s_p7_1[] = {
		5,
		4,
		6,
		3,
		7,
		2,
		8,
		1,
		9,
		0,
		10,
};

static const long _vq_lengthlist__8c0_s_p7_1[] = {
		 1, 3, 3, 6, 6, 8, 8, 9, 9, 9, 9,10,10,10, 7, 7,
		 8, 8, 9, 9, 9, 9,10,10, 9, 7, 7, 8, 8, 9, 9, 9,
		 9,10,10,10, 8, 8, 9, 9, 9, 9, 9, 9,10,10,10, 8,
		 8, 9, 9, 9, 9, 8, 9,10,10,10, 8, 8, 9, 9, 9,10,
		10,10,10,10,10, 9, 9, 9, 9, 9, 9,10,10,11,10,11,
		 9, 9, 9, 9,10,10,10,10,11,11,11,10,10, 9, 9,10,
		10,10, 9,11,10,10,10,10,10,10, 9, 9,10,10,11,11,
		10,10,10, 9, 9, 9,10,10,10,
};

static const static_codebook _8c0_s_p7_1 = {
		2, 121,
		(long *)_vq_lengthlist__8c0_s_p7_1,
		1, -531365888, 1611661312, 4, 0,
		(long *)_vq_quantlist__8c0_s_p7_1,
		0
};

static const long _vq_quantlist__8c0_s_p8_0[] = {
		6,
		5,
		7,
		4,
		8,
		3,
		9,
		2,
		10,
		1,
		11,
		0,
		12,
};

static const long _vq_lengthlist__8c0_s_p8_0[] = {
		 1, 4, 4, 7, 6, 7, 7, 7, 7, 8, 8, 9, 9, 7, 6, 6,
		 7, 7, 8, 8, 7, 7, 8, 9,10,10, 7, 6, 6, 7, 7, 8,
		 7, 7, 7, 9, 9,10,12, 0, 8, 8, 8, 8, 8, 9, 8, 8,
		 9, 9,10,10, 0, 8, 8, 8, 8, 8, 9, 8, 9, 9, 9,11,
		10, 0, 0,13, 9, 8, 9, 9, 9, 9,10,10,11,11, 0,13,
		 0, 9, 9, 9, 9, 9, 9,11,10,11,11, 0, 0, 0, 8, 9,
		10, 9,10,10,13,11,12,12, 0, 0, 0, 8, 9, 9, 9,10,
		10,13,12,12,13, 0, 0, 0,12, 0,10,10,12,11,10,11,
		12,12, 0, 0, 0,13,13,10,10,10,11,12, 0,13, 0, 0,
		 0, 0, 0, 0,13,11, 0,12,12,12,13,12, 0, 0, 0, 0,
		 0, 0,13,13,11,13,13,11,12,
};

static const static_codebook _8c0_s_p8_0 = {
		2, 169,
		(long *)_vq_lengthlist__8c0_s_p8_0,
		1, -526516224, 1616117760, 4, 0,
		(long *)_vq_quantlist__8c0_s_p8_0,
		0
};

static const long _vq_quantlist__8c0_s_p8_1[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__8c0_s_p8_1[] = {
		 1, 3, 4, 5, 5, 7, 6, 6, 6, 5, 7, 7, 7, 6, 6, 7,
		 7, 7, 6, 6, 7, 7, 7, 6, 6,
};

static const static_codebook _8c0_s_p8_1 = {
		2, 25,
		(long *)_vq_lengthlist__8c0_s_p8_1,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__8c0_s_p8_1,
		0
};

static const long _vq_quantlist__8c0_s_p9_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__8c0_s_p9_0[] = {
		 1, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
		 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
		 8, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
		 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
		 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
		 7,
};

static const static_codebook _8c0_s_p9_0 = {
		4, 81,
		(long *)_vq_lengthlist__8c0_s_p9_0,
		1, -518803456, 1628680192, 2, 0,
		(long *)_vq_quantlist__8c0_s_p9_0,
		0
};

static const long _vq_quantlist__8c0_s_p9_1[] = {
		7,
		6,
		8,
		5,
		9,
		4,
		10,
		3,
		11,
		2,
		12,
		1,
		13,
		0,
		14,
};

static const long _vq_lengthlist__8c0_s_p9_1[] = {
		 1, 4, 4, 5, 5,10, 8,11,11,11,11,11,11,11,11, 6,
		 6, 6, 7, 6,11,10,11,11,11,11,11,11,11,11, 7, 5,
		 6, 6, 6, 8, 7,11,11,11,11,11,11,11,11,11, 7, 8,
		 8, 8, 9, 9,11,11,11,11,11,11,11,11,11, 9, 8, 7,
		 8, 9,11,11,11,11,11,11,11,11,11,11,11,10,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,10,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,
};

static const static_codebook _8c0_s_p9_1 = {
		2, 225,
		(long *)_vq_lengthlist__8c0_s_p9_1,
		1, -520986624, 1620377600, 4, 0,
		(long *)_vq_quantlist__8c0_s_p9_1,
		0
};

static const long _vq_quantlist__8c0_s_p9_2[] = {
		10,
		9,
		11,
		8,
		12,
		7,
		13,
		6,
		14,
		5,
		15,
		4,
		16,
		3,
		17,
		2,
		18,
		1,
		19,
		0,
		20,
};

static const long _vq_lengthlist__8c0_s_p9_2[] = {
		 1, 5, 5, 7, 7, 8, 7, 8, 8,10,10, 9, 9,10,10,10,
		11,11,10,12,11,12,12,12, 9, 8, 8, 8, 8, 8, 9,10,
		10,10,10,11,11,11,10,11,11,12,12,11,12, 8, 8, 7,
		 7, 8, 9,10,10,10, 9,10,10, 9,10,10,11,11,11,11,
		11,11, 9, 9, 9, 9, 8, 9,10,10,11,10,10,11,11,12,
		10,10,12,12,11,11,10, 9, 9,10, 8, 9,10,10,10, 9,
		10,10,11,11,10,11,10,10,10,12,12,12, 9,10, 9,10,
		 9, 9,10,10,11,11,11,11,10,10,10,11,12,11,12,11,
		12,10,11,10,11, 9,10, 9,10, 9,10,10, 9,10,10,11,
		10,11,11,11,11,12,11, 9,10,10,10,10,11,11,11,11,
		11,10,11,11,11,11,10,12,10,12,12,11,12,10,10,11,
		10, 9,11,10,11, 9,10,11,10,10,10,11,11,11,11,12,
		12,10, 9, 9,11,10, 9,12,11,10,12,12,11,11,11,11,
		10,11,11,12,11,10,12, 9,11,10,11,10,10,11,10,11,
		 9,10,10,10,11,12,11,11,12,11,10,10,11,11, 9,10,
		10,12,10,11,10,10,10, 9,10,10,10,10, 9,10,10,11,
		11,11,11,12,11,10,10,10,10,11,11,10,11,11, 9,11,
		10,12,10,12,11,10,11,10,10,10,11,10,10,11,11,10,
		11,10,10,10,10,11,11,12,10,10,10,11,10,11,12,11,
		10,11,10,10,11,11,10,12,10, 9,10,10,11,11,11,10,
		12,10,10,11,11,11,10,10,11,10,10,10,11,10,11,10,
		12,11,11,10,10,10,12,10,10,11, 9,10,11,11,11,10,
		10,11,10,10, 9,11,11,12,12,11,12,11,11,11,11,11,
		11, 9,10,11,10,12,10,10,10,10,11,10,10,11,10,10,
		12,10,10,10,10,10, 9,12,10,10,10,10,12, 9,11,10,
		10,11,10,12,12,10,12,12,12,10,10,10,10, 9,10,11,
		10,10,12,10,10,12,11,10,11,10,10,12,11,10,12,10,
		10,11, 9,11,10, 9,10, 9,10,
};

static const static_codebook _8c0_s_p9_2 = {
		2, 441,
		(long *)_vq_lengthlist__8c0_s_p9_2,
		1, -529268736, 1611661312, 5, 0,
		(long *)_vq_quantlist__8c0_s_p9_2,
		0
};

static const long _huff_lengthlist__8c0_s_single[] = {
		 4, 5,18, 7,10, 6, 7, 8, 9,10, 5, 2,18, 5, 7, 5,
		 6, 7, 8,11,17,17,17,17,17,17,17,17,17,17, 7, 4,
		17, 6, 9, 6, 8,10,12,15,11, 7,17, 9, 6, 6, 7, 9,
		11,15, 6, 4,17, 6, 6, 4, 5, 8,11,16, 6, 6,17, 8,
		 6, 5, 6, 9,13,16, 8, 9,17,11, 9, 8, 8,11,13,17,
		 9,12,17,15,14,13,12,13,14,17,12,15,17,17,17,17,
		17,16,17,17,
};

static const static_codebook _huff_book__8c0_s_single = {
		2, 100,
		(long *)_huff_lengthlist__8c0_s_single,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _vq_quantlist__8c1_s_p1_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__8c1_s_p1_0[] = {
		 1, 5, 5, 0, 0, 0, 0, 0, 0, 5, 7, 7, 0, 0, 0, 0,
		 0, 0, 5, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 5, 8, 7, 0, 0, 0, 0, 0, 0, 7, 8, 9, 0, 0, 0,
		 0, 0, 0, 7, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 5, 7, 8, 0, 0, 0, 0, 0, 0, 7, 9, 8, 0, 0,
		 0, 0, 0, 0, 7, 9, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 8, 8, 0, 0, 0, 0,
		 0, 0, 8, 9, 9, 0, 0, 0, 0, 0, 0, 8, 9, 9, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 9, 9, 0, 0, 0,
		 0, 0, 0, 8, 8,10, 0, 0, 0, 0, 0, 0, 9,10,10, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 9, 9, 0, 0,
		 0, 0, 0, 0, 8,10, 9, 0, 0, 0, 0, 0, 0, 9,10,10,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 5, 8, 8, 0, 0, 0, 0, 0, 0, 8, 9, 9, 0, 0,
		 0, 0, 0, 0, 8, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 7, 9, 9, 0, 0, 0, 0, 0, 0, 9,10,10, 0,
		 0, 0, 0, 0, 0, 8, 9,10, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 7, 9, 9, 0, 0, 0, 0, 0, 0, 9,10,10,
		 0, 0, 0, 0, 0, 0, 8,10, 8, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0,
};

static const static_codebook _8c1_s_p1_0 = {
		8, 6561,
		(long *)_vq_lengthlist__8c1_s_p1_0,
		1, -535822336, 1611661312, 2, 0,
		(long *)_vq_quantlist__8c1_s_p1_0,
		0
};

static const long _vq_quantlist__8c1_s_p3_0[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__8c1_s_p3_0[] = {
		 2, 4, 4, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 6, 6, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 4, 4, 4, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 7, 7,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 6, 6, 6, 7, 7, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0,
};

static const static_codebook _8c1_s_p3_0 = {
		4, 625,
		(long *)_vq_lengthlist__8c1_s_p3_0,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__8c1_s_p3_0,
		0
};

static const long _vq_quantlist__8c1_s_p4_0[] = {
		4,
		3,
		5,
		2,
		6,
		1,
		7,
		0,
		8,
};

static const long _vq_lengthlist__8c1_s_p4_0[] = {
		 1, 2, 3, 7, 7, 0, 0, 0, 0, 0, 0, 0, 6, 6, 0, 0,
		 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 0, 7, 7,
		 0, 0, 0, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0, 0, 0,
		 8, 8, 0, 0, 0, 0, 0, 0, 0, 9, 8, 0, 0, 0, 0, 0,
		 0, 0,10,10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0,
};

static const static_codebook _8c1_s_p4_0 = {
		2, 81,
		(long *)_vq_lengthlist__8c1_s_p4_0,
		1, -531628032, 1611661312, 4, 0,
		(long *)_vq_quantlist__8c1_s_p4_0,
		0
};

static const long _vq_quantlist__8c1_s_p5_0[] = {
		4,
		3,
		5,
		2,
		6,
		1,
		7,
		0,
		8,
};

static const long _vq_lengthlist__8c1_s_p5_0[] = {
		 1, 3, 3, 4, 5, 6, 6, 8, 8, 0, 0, 0, 8, 8, 7, 7,
		 9, 9, 0, 0, 0, 8, 8, 7, 7, 9, 9, 0, 0, 0, 9,10,
		 8, 8, 9, 9, 0, 0, 0,10,10, 8, 8, 9, 9, 0, 0, 0,
		11,10, 8, 8,10,10, 0, 0, 0,11,11, 8, 8,10,10, 0,
		 0, 0,12,12, 9, 9,10,10, 0, 0, 0, 0, 0, 9, 9,10,
		10,
};

static const static_codebook _8c1_s_p5_0 = {
		2, 81,
		(long *)_vq_lengthlist__8c1_s_p5_0,
		1, -531628032, 1611661312, 4, 0,
		(long *)_vq_quantlist__8c1_s_p5_0,
		0
};

static const long _vq_quantlist__8c1_s_p6_0[] = {
		8,
		7,
		9,
		6,
		10,
		5,
		11,
		4,
		12,
		3,
		13,
		2,
		14,
		1,
		15,
		0,
		16,
};

static const long _vq_lengthlist__8c1_s_p6_0[] = {
		 1, 3, 3, 5, 5, 8, 8, 8, 8, 9, 9,10,10,11,11,11,
		11, 0, 0, 0, 8, 8, 8, 8, 9, 9, 9, 9,10,10,11,11,
		12,12, 0, 0, 0, 8, 8, 8, 8, 9, 9, 9, 9,10,10,11,
		11,12,12, 0, 0, 0, 9, 9, 8, 8,10,10,10,10,11,11,
		12,12,12,12, 0, 0, 0, 9, 9, 8, 8,10,10,10,10,11,
		11,12,12,12,12, 0, 0, 0,10,10, 9, 9,10,10,10,10,
		11,11,12,12,13,13, 0, 0, 0,10,10, 9, 9,10,10,10,
		10,11,11,12,12,13,13, 0, 0, 0,11,11, 9, 9,10,10,
		10,10,11,11,12,12,13,13, 0, 0, 0, 0, 0, 9, 9,10,
		10,10,10,11,11,12,12,13,13, 0, 0, 0, 0, 0, 9, 9,
		10,10,11,11,12,12,12,12,13,13, 0, 0, 0, 0, 0, 9,
		 9,10,10,11,11,12,11,12,12,13,13, 0, 0, 0, 0, 0,
		10,10,11,11,11,11,12,12,13,12,13,13, 0, 0, 0, 0,
		 0, 0, 0,11,10,11,11,12,12,13,13,13,13, 0, 0, 0,
		 0, 0, 0, 0,11,11,12,12,12,12,13,13,13,14, 0, 0,
		 0, 0, 0, 0, 0,11,11,12,12,12,12,13,13,14,13, 0,
		 0, 0, 0, 0, 0, 0,12,12,12,12,13,13,13,13,14,14,
		 0, 0, 0, 0, 0, 0, 0, 0, 0,12,12,13,13,13,13,14,
		14,
};

static const static_codebook _8c1_s_p6_0 = {
		2, 289,
		(long *)_vq_lengthlist__8c1_s_p6_0,
		1, -529530880, 1611661312, 5, 0,
		(long *)_vq_quantlist__8c1_s_p6_0,
		0
};

static const long _vq_quantlist__8c1_s_p7_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__8c1_s_p7_0[] = {
		 1, 4, 4, 6, 6, 6, 7, 6, 6, 4, 7, 7,10, 9, 9,10,
		 9, 9, 5, 7, 7,10, 9, 9,10, 9, 9, 6,10,10,10,10,
		10,11,10,10, 6, 9, 9,10, 9,10,11,10,10, 6, 9, 9,
		10, 9, 9,11, 9,10, 7,10,10,11,11,11,11,10,10, 6,
		 9, 9,10,10,10,11, 9, 9, 6, 9, 9,10,10,10,10, 9,
		 9,
};

static const static_codebook _8c1_s_p7_0 = {
		4, 81,
		(long *)_vq_lengthlist__8c1_s_p7_0,
		1, -529137664, 1618345984, 2, 0,
		(long *)_vq_quantlist__8c1_s_p7_0,
		0
};

static const long _vq_quantlist__8c1_s_p7_1[] = {
		5,
		4,
		6,
		3,
		7,
		2,
		8,
		1,
		9,
		0,
		10,
};

static const long _vq_lengthlist__8c1_s_p7_1[] = {
		 2, 3, 3, 5, 5, 7, 7, 7, 7, 7, 7,10,10, 9, 7, 7,
		 7, 7, 8, 8, 8, 8, 9, 9, 9, 7, 7, 7, 7, 8, 8, 8,
		 8,10,10,10, 7, 7, 7, 7, 8, 8, 8, 8,10,10,10, 7,
		 7, 7, 7, 8, 8, 8, 8,10,10,10, 8, 8, 8, 8, 8, 8,
		 8, 8,10,10,10, 8, 8, 8, 8, 8, 8, 8, 8,10,10,10,
		 8, 8, 8, 8, 8, 8, 8, 8,10,10,10,10,10, 8, 8, 8,
		 8, 8, 8,10,10,10,10,10, 8, 8, 8, 8, 8, 8,10,10,
		10,10,10, 8, 8, 8, 8, 8, 8,
};

static const static_codebook _8c1_s_p7_1 = {
		2, 121,
		(long *)_vq_lengthlist__8c1_s_p7_1,
		1, -531365888, 1611661312, 4, 0,
		(long *)_vq_quantlist__8c1_s_p7_1,
		0
};

static const long _vq_quantlist__8c1_s_p8_0[] = {
		6,
		5,
		7,
		4,
		8,
		3,
		9,
		2,
		10,
		1,
		11,
		0,
		12,
};

static const long _vq_lengthlist__8c1_s_p8_0[] = {
		 1, 4, 4, 6, 6, 8, 8, 8, 8, 9, 9,10,10, 7, 5, 5,
		 7, 7, 8, 8, 8, 8, 9,10,11,11, 7, 5, 5, 7, 7, 8,
		 8, 9, 9,10,10,11,11, 0, 8, 8, 8, 8, 9, 9, 9, 9,
		 9,10,11,11, 0, 8, 8, 8, 8, 9, 9, 9, 9,10,10,11,
		11, 0,12,12, 9, 9, 9, 9,10, 9,10,11,11,11, 0,13,
		12, 9, 8, 9, 9,10,10,11,11,12,11, 0, 0, 0, 9, 9,
		 9, 9,10,10,11,11,12,12, 0, 0, 0,10,10, 9, 9,10,
		10,11,11,12,12, 0, 0, 0,13,13,10,10,11,11,12,11,
		13,12, 0, 0, 0,14,14,10,10,11,10,11,11,12,12, 0,
		 0, 0, 0, 0,12,12,11,11,12,12,13,13, 0, 0, 0, 0,
		 0,12,12,11,10,12,11,13,12,
};

static const static_codebook _8c1_s_p8_0 = {
		2, 169,
		(long *)_vq_lengthlist__8c1_s_p8_0,
		1, -526516224, 1616117760, 4, 0,
		(long *)_vq_quantlist__8c1_s_p8_0,
		0
};

static const long _vq_quantlist__8c1_s_p8_1[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__8c1_s_p8_1[] = {
		 2, 3, 3, 5, 5, 6, 6, 6, 5, 5, 6, 6, 6, 5, 5, 6,
		 6, 6, 5, 5, 6, 6, 6, 5, 5,
};

static const static_codebook _8c1_s_p8_1 = {
		2, 25,
		(long *)_vq_lengthlist__8c1_s_p8_1,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__8c1_s_p8_1,
		0
};

static const long _vq_quantlist__8c1_s_p9_0[] = {
		6,
		5,
		7,
		4,
		8,
		3,
		9,
		2,
		10,
		1,
		11,
		0,
		12,
};

static const long _vq_lengthlist__8c1_s_p9_0[] = {
		 1, 3, 3,10,10,10,10,10,10,10,10,10,10, 5, 6, 6,
		10,10,10,10,10,10,10,10,10,10, 6, 7, 8,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10, 9, 9, 9, 9,
};

static const static_codebook _8c1_s_p9_0 = {
		2, 169,
		(long *)_vq_lengthlist__8c1_s_p9_0,
		1, -513964032, 1628680192, 4, 0,
		(long *)_vq_quantlist__8c1_s_p9_0,
		0
};

static const long _vq_quantlist__8c1_s_p9_1[] = {
		7,
		6,
		8,
		5,
		9,
		4,
		10,
		3,
		11,
		2,
		12,
		1,
		13,
		0,
		14,
};

static const long _vq_lengthlist__8c1_s_p9_1[] = {
		 1, 4, 4, 5, 5, 7, 7, 9, 9,11,11,12,12,13,13, 6,
		 5, 5, 6, 6, 9, 9,10,10,12,12,12,13,15,14, 6, 5,
		 5, 7, 7, 9, 9,10,10,12,12,12,13,14,13,17, 7, 7,
		 8, 8,10,10,11,11,12,13,13,13,13,13,17, 7, 7, 8,
		 8,10,10,11,11,13,13,13,13,14,14,17,11,11, 9, 9,
		11,11,12,12,12,13,13,14,15,13,17,12,12, 9, 9,11,
		11,12,12,13,13,13,13,14,16,17,17,17,11,12,12,12,
		13,13,13,14,15,14,15,15,17,17,17,12,12,11,11,13,
		13,14,14,15,14,15,15,17,17,17,15,15,13,13,14,14,
		15,14,15,15,16,15,17,17,17,15,15,13,13,13,14,14,
		15,15,15,15,16,17,17,17,17,16,14,15,14,14,15,14,
		14,15,15,15,17,17,17,17,17,14,14,16,14,15,15,15,
		15,15,15,17,17,17,17,17,17,16,16,15,17,15,15,14,
		17,15,17,16,17,17,17,17,16,15,14,15,15,15,15,15,
		15,
};

static const static_codebook _8c1_s_p9_1 = {
		2, 225,
		(long *)_vq_lengthlist__8c1_s_p9_1,
		1, -520986624, 1620377600, 4, 0,
		(long *)_vq_quantlist__8c1_s_p9_1,
		0
};

static const long _vq_quantlist__8c1_s_p9_2[] = {
		10,
		9,
		11,
		8,
		12,
		7,
		13,
		6,
		14,
		5,
		15,
		4,
		16,
		3,
		17,
		2,
		18,
		1,
		19,
		0,
		20,
};

static const long _vq_lengthlist__8c1_s_p9_2[] = {
		 2, 4, 4, 6, 6, 7, 7, 8, 8, 8, 8, 9, 8, 9, 9, 9,
		 9, 9, 9, 9, 9,11,11,12, 7, 7, 7, 7, 8, 8, 9, 9,
		 9, 9,10,10,10,10,10,10,10,10,11,11,11, 7, 7, 7,
		 7, 8, 8, 9, 8, 9, 9, 9, 9, 9, 9,10,10,10,10,11,
		11,12, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9,10,10,10,10,
		10,10,10,10,11,11,11, 7, 7, 8, 8, 8, 8, 9, 9, 9,
		 9,10,10,10,10,10,10,10,10,11,11,11, 8, 8, 8, 8,
		 9, 9, 9, 9, 9, 9,10,10,10,10,10,10,10,10,11,11,
		11, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9,10,10,10,10,10,
		10,10,10,11,12,11, 9, 9, 8, 9, 9, 9, 9, 9,10,10,
		10,10,10,10,10,10,10,10,11,11,11,11,11, 8, 8, 9,
		 9, 9, 9,10,10,10,10,10,10,10,10,10,10,11,12,11,
		12,11, 9, 9, 9, 9, 9,10,10,10,10,10,10,10,10,10,
		10,10,11,11,11,11,11, 9, 9, 9, 9,10,10,10,10,10,
		10,10,10,10,10,10,10,12,11,12,11,11, 9, 9, 9,10,
		10,10,10,10,10,10,10,10,10,10,10,10,12,11,11,11,
		11,11,11,10,10,10,10,10,10,10,10,10,10,10,10,10,
		11,11,11,12,11,11,12,11,10,10,10,10,10,10,10,10,
		10,10,10,10,11,10,11,11,11,11,11,11,11,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,11,11,12,11,12,
		11,11,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		11,11,12,11,12,11,11,11,11,10,10,10,10,10,10,10,
		10,10,10,10,10,11,11,12,11,11,12,11,11,12,10,10,
		11,10,10,10,10,10,10,10,10,10,11,11,11,11,11,11,
		11,11,11,10,10,10,10,10,10,10,10,10,10,10,10,12,
		12,11,12,11,11,12,12,12,11,11,10,10,10,10,10,10,
		10,10,10,11,12,12,11,12,12,11,12,11,11,11,11,10,
		10,10,10,10,10,10,10,10,10,
};

static const static_codebook _8c1_s_p9_2 = {
		2, 441,
		(long *)_vq_lengthlist__8c1_s_p9_2,
		1, -529268736, 1611661312, 5, 0,
		(long *)_vq_quantlist__8c1_s_p9_2,
		0
};

static const long _huff_lengthlist__8c1_s_single[] = {
		 4, 6,18, 8,11, 8, 8, 9, 9,10, 4, 4,18, 5, 9, 5,
		 6, 7, 8,10,18,18,18,18,17,17,17,17,17,17, 7, 5,
		17, 6,11, 6, 7, 8, 9,12,12, 9,17,12, 8, 8, 9,10,
		10,13, 7, 5,17, 6, 8, 4, 5, 6, 8,10, 6, 5,17, 6,
		 8, 5, 4, 5, 7, 9, 7, 7,17, 8, 9, 6, 5, 5, 6, 8,
		 8, 8,17, 9,11, 8, 6, 6, 6, 7, 9,10,17,12,12,10,
		 9, 7, 7, 8,
};

static const static_codebook _huff_book__8c1_s_single = {
		2, 100,
		(long *)_huff_lengthlist__8c1_s_single,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist__44c2_s_long[] = {
		 6, 6,12,10,10,10, 9,10,12,12, 6, 1,10, 5, 6, 6,
		 7, 9,11,14,12, 9, 8,11, 7, 8, 9,11,13,15,10, 5,
		12, 7, 8, 7, 9,12,14,15,10, 6, 7, 8, 5, 6, 7, 9,
		12,14, 9, 6, 8, 7, 6, 6, 7, 9,12,12, 9, 7, 9, 9,
		 7, 6, 6, 7,10,10,10, 9,10,11, 8, 7, 6, 6, 8,10,
		12,11,13,13,11,10, 8, 8, 8,10,11,13,15,15,14,13,
		10, 8, 8, 9,
};

static const static_codebook _huff_book__44c2_s_long = {
		2, 100,
		(long *)_huff_lengthlist__44c2_s_long,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _vq_quantlist__44c2_s_p1_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__44c2_s_p1_0[] = {
		 2, 4, 4, 0, 0, 0, 0, 0, 0, 5, 6, 6, 0, 0, 0, 0,
		 0, 0, 5, 6, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 5, 7, 7, 0, 0, 0, 0, 0, 0, 7, 8, 8, 0, 0, 0,
		 0, 0, 0, 6, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 5, 7, 7, 0, 0, 0, 0, 0, 0, 6, 8, 7, 0, 0,
		 0, 0, 0, 0, 7, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 7, 7, 0, 0, 0, 0,
		 0, 0, 7, 8, 8, 0, 0, 0, 0, 0, 0, 7, 8, 8, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 8, 8, 0, 0, 0,
		 0, 0, 0, 8, 9, 9, 0, 0, 0, 0, 0, 0, 8, 9, 9, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 8, 8, 0, 0,
		 0, 0, 0, 0, 8, 9, 8, 0, 0, 0, 0, 0, 0, 8, 9, 9,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 4, 7, 7, 0, 0, 0, 0, 0, 0, 7, 8, 8, 0, 0,
		 0, 0, 0, 0, 7, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 6, 8, 8, 0, 0, 0, 0, 0, 0, 8, 9, 9, 0,
		 0, 0, 0, 0, 0, 8, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 7, 8, 8, 0, 0, 0, 0, 0, 0, 8, 9, 9,
		 0, 0, 0, 0, 0, 0, 8, 9, 9, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0,
};

static const static_codebook _44c2_s_p1_0 = {
		8, 6561,
		(long *)_vq_lengthlist__44c2_s_p1_0,
		1, -535822336, 1611661312, 2, 0,
		(long *)_vq_quantlist__44c2_s_p1_0,
		0
};

static const long _vq_quantlist__44c2_s_p2_0[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__44c2_s_p2_0[] = {
		 1, 4, 4, 0, 0, 0, 7, 7, 0, 0, 0, 7, 7, 0, 0, 0,
		 8, 8, 0, 0, 0, 0, 0, 0, 0, 4, 6, 6, 0, 0, 0, 8,
		 8, 0, 0, 0, 8, 8, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0,
		 0, 0, 4, 6, 6, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0,
		 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 7, 8, 8, 0, 0, 0,11,11, 0, 0,
		 0,11,11, 0, 0, 0,12,11, 0, 0, 0, 0, 0, 0, 0, 7,
		 8, 8, 0, 0, 0,10,11, 0, 0, 0,11,11, 0, 0, 0,11,
		12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 6, 8, 8, 0, 0, 0,11,11, 0, 0, 0,11,11,
		 0, 0, 0,12,12, 0, 0, 0, 0, 0, 0, 0, 6, 8, 8, 0,
		 0, 0,10,11, 0, 0, 0,10,11, 0, 0, 0,11,11, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 8, 9, 9, 0, 0, 0,11,12, 0, 0, 0,11,12, 0, 0, 0,
		12,11, 0, 0, 0, 0, 0, 0, 0, 8,10, 9, 0, 0, 0,12,
		11, 0, 0, 0,12,11, 0, 0, 0,11,12, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0,
};

static const static_codebook _44c2_s_p2_0 = {
		4, 625,
		(long *)_vq_lengthlist__44c2_s_p2_0,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__44c2_s_p2_0,
		0
};

static const long _vq_quantlist__44c2_s_p3_0[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__44c2_s_p3_0[] = {
		 2, 4, 3, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 6, 6, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 4, 4, 4, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 9, 9,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 6, 6, 7, 9, 9, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0,
};

static const static_codebook _44c2_s_p3_0 = {
		4, 625,
		(long *)_vq_lengthlist__44c2_s_p3_0,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__44c2_s_p3_0,
		0
};

static const long _vq_quantlist__44c2_s_p4_0[] = {
		4,
		3,
		5,
		2,
		6,
		1,
		7,
		0,
		8,
};

static const long _vq_lengthlist__44c2_s_p4_0[] = {
		 1, 3, 3, 6, 6, 0, 0, 0, 0, 0, 6, 6, 6, 6, 0, 0,
		 0, 0, 0, 6, 6, 6, 6, 0, 0, 0, 0, 0, 7, 7, 6, 6,
		 0, 0, 0, 0, 0, 0, 0, 6, 7, 0, 0, 0, 0, 0, 0, 0,
		 7, 8, 0, 0, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0,
		 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0,
};

static const static_codebook _44c2_s_p4_0 = {
		2, 81,
		(long *)_vq_lengthlist__44c2_s_p4_0,
		1, -531628032, 1611661312, 4, 0,
		(long *)_vq_quantlist__44c2_s_p4_0,
		0
};

static const long _vq_quantlist__44c2_s_p5_0[] = {
		4,
		3,
		5,
		2,
		6,
		1,
		7,
		0,
		8,
};

static const long _vq_lengthlist__44c2_s_p5_0[] = {
		 1, 3, 3, 6, 6, 7, 7, 9, 9, 0, 7, 7, 7, 7, 7, 7,
		 9, 9, 0, 7, 7, 7, 7, 7, 7, 9, 9, 0, 8, 8, 7, 7,
		 8, 8,10,10, 0, 0, 0, 7, 7, 8, 8,10,10, 0, 0, 0,
		 9, 9, 8, 8,10,10, 0, 0, 0, 9, 9, 8, 8,10,10, 0,
		 0, 0,10,10, 9, 9,11,11, 0, 0, 0, 0, 0, 9, 9,11,
		11,
};

static const static_codebook _44c2_s_p5_0 = {
		2, 81,
		(long *)_vq_lengthlist__44c2_s_p5_0,
		1, -531628032, 1611661312, 4, 0,
		(long *)_vq_quantlist__44c2_s_p5_0,
		0
};

static const long _vq_quantlist__44c2_s_p6_0[] = {
		8,
		7,
		9,
		6,
		10,
		5,
		11,
		4,
		12,
		3,
		13,
		2,
		14,
		1,
		15,
		0,
		16,
};

static const long _vq_lengthlist__44c2_s_p6_0[] = {
		 1, 4, 3, 6, 6, 8, 8, 9, 9, 9, 9, 9, 9,10,10,11,
		11, 0, 7, 7, 7, 7, 8, 8, 9, 9, 9, 9,10,10,11,11,
		12,11, 0, 7, 7, 7, 7, 8, 8, 9, 9, 9, 9,10,10,11,
		11,11,12, 0, 8, 8, 7, 7, 9, 9,10,10, 9, 9,10,10,
		11,11,12,12, 0, 0, 0, 7, 7, 9, 9,10,10,10, 9,10,
		10,11,11,12,12, 0, 0, 0, 8, 8, 9, 9,10,10,10,10,
		11,11,11,11,12,12, 0, 0, 0, 8, 8, 9, 9,10,10,10,
		10,11,11,12,12,12,12, 0, 0, 0, 9, 9, 9, 9,10,10,
		10,10,11,11,12,12,12,12, 0, 0, 0, 0, 0, 9, 9,10,
		10,10,10,11,11,12,12,13,13, 0, 0, 0, 0, 0, 9, 9,
		10,10,11,11,11,11,12,12,13,13, 0, 0, 0, 0, 0, 9,
		 9,10,10,11,11,11,11,12,12,13,13, 0, 0, 0, 0, 0,
		10,10,10,10,11,11,12,12,13,12,13,13, 0, 0, 0, 0,
		 0, 0, 0,10,10,11,11,12,12,13,13,13,13, 0, 0, 0,
		 0, 0, 0, 0,11,11,12,12,12,12,13,13,13,14, 0, 0,
		 0, 0, 0, 0, 0,11,11,12,12,12,12,13,13,13,14, 0,
		 0, 0, 0, 0, 0, 0,12,12,12,12,13,13,13,13,14,14,
		 0, 0, 0, 0, 0, 0, 0, 0, 0,12,12,13,13,13,13,14,
		14,
};

static const static_codebook _44c2_s_p6_0 = {
		2, 289,
		(long *)_vq_lengthlist__44c2_s_p6_0,
		1, -529530880, 1611661312, 5, 0,
		(long *)_vq_quantlist__44c2_s_p6_0,
		0
};

static const long _vq_quantlist__44c2_s_p7_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__44c2_s_p7_0[] = {
		 1, 4, 4, 7, 6, 6, 7, 6, 6, 4, 7, 7,10, 9, 9,11,
		 9, 9, 4, 7, 7,10, 9, 9,10, 9, 9, 7,10,10,11,10,
		11,11,10,11, 6, 9, 9,11,10,10,11,10,10, 6, 9, 9,
		11,10,11,11,10,10, 7,11,10,11,11,11,12,11,11, 6,
		 9, 9,11,10,10,11,11,10, 6, 9, 9,11,10,10,12,10,
		11,
};

static const static_codebook _44c2_s_p7_0 = {
		4, 81,
		(long *)_vq_lengthlist__44c2_s_p7_0,
		1, -529137664, 1618345984, 2, 0,
		(long *)_vq_quantlist__44c2_s_p7_0,
		0
};

static const long _vq_quantlist__44c2_s_p7_1[] = {
		5,
		4,
		6,
		3,
		7,
		2,
		8,
		1,
		9,
		0,
		10,
};

static const long _vq_lengthlist__44c2_s_p7_1[] = {
		 2, 3, 4, 6, 6, 7, 7, 7, 7, 7, 7, 9, 7, 7, 6, 6,
		 7, 7, 8, 8, 8, 8, 9, 6, 6, 6, 6, 7, 7, 8, 8, 8,
		 8,10, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8,10,10,10, 7,
		 7, 7, 7, 8, 8, 8, 8,10,10,10, 7, 7, 8, 8, 8, 8,
		 8, 8,10,10,10, 7, 8, 8, 8, 8, 8, 8, 8,10,10,10,
		 8, 8, 8, 8, 8, 8, 8, 8,10,10,10,10,10, 8, 8, 8,
		 8, 8, 8,10,10,10,10,10, 9, 9, 8, 8, 8, 8,10,10,
		10,10,10, 8, 8, 8, 8, 8, 8,
};

static const static_codebook _44c2_s_p7_1 = {
		2, 121,
		(long *)_vq_lengthlist__44c2_s_p7_1,
		1, -531365888, 1611661312, 4, 0,
		(long *)_vq_quantlist__44c2_s_p7_1,
		0
};

static const long _vq_quantlist__44c2_s_p8_0[] = {
		6,
		5,
		7,
		4,
		8,
		3,
		9,
		2,
		10,
		1,
		11,
		0,
		12,
};

static const long _vq_lengthlist__44c2_s_p8_0[] = {
		 1, 4, 4, 6, 6, 7, 7, 7, 7, 8, 8, 9, 9, 6, 5, 5,
		 7, 7, 8, 8, 8, 8, 9, 9,10,10, 7, 6, 5, 7, 7, 8,
		 8, 8, 8, 9, 9,10,10, 0, 8, 8, 8, 8, 9, 9, 9, 9,
		10,10,11,11, 0, 8, 8, 8, 8, 9, 9, 9, 9,10,10,11,
		11, 0,12,12, 9, 9,10,10,10,10,11,11,11,11, 0,13,
		13, 9, 9,10,10,10,10,11,11,12,12, 0, 0, 0,10,10,
		10,10,11,11,12,12,12,13, 0, 0, 0,10,10,10,10,11,
		11,12,12,12,12, 0, 0, 0,14,14,10,11,11,11,12,12,
		13,13, 0, 0, 0,14,14,11,10,11,11,13,12,13,13, 0,
		 0, 0, 0, 0,12,12,11,12,13,12,14,14, 0, 0, 0, 0,
		 0,12,12,12,12,13,12,14,14,
};

static const static_codebook _44c2_s_p8_0 = {
		2, 169,
		(long *)_vq_lengthlist__44c2_s_p8_0,
		1, -526516224, 1616117760, 4, 0,
		(long *)_vq_quantlist__44c2_s_p8_0,
		0
};

static const long _vq_quantlist__44c2_s_p8_1[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__44c2_s_p8_1[] = {
		 2, 4, 4, 5, 4, 6, 5, 5, 5, 5, 6, 5, 5, 5, 5, 6,
		 5, 5, 5, 5, 6, 6, 6, 5, 5,
};

static const static_codebook _44c2_s_p8_1 = {
		2, 25,
		(long *)_vq_lengthlist__44c2_s_p8_1,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__44c2_s_p8_1,
		0
};

static const long _vq_quantlist__44c2_s_p9_0[] = {
		6,
		5,
		7,
		4,
		8,
		3,
		9,
		2,
		10,
		1,
		11,
		0,
		12,
};

static const long _vq_lengthlist__44c2_s_p9_0[] = {
		 1, 5, 4,12,12,12,12,12,12,12,12,12,12, 4, 9, 8,
		11,11,11,11,11,11,11,11,11,11, 2, 8, 7,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,10,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,
};

static const static_codebook _44c2_s_p9_0 = {
		2, 169,
		(long *)_vq_lengthlist__44c2_s_p9_0,
		1, -514541568, 1627103232, 4, 0,
		(long *)_vq_quantlist__44c2_s_p9_0,
		0
};

static const long _vq_quantlist__44c2_s_p9_1[] = {
		6,
		5,
		7,
		4,
		8,
		3,
		9,
		2,
		10,
		1,
		11,
		0,
		12,
};

static const long _vq_lengthlist__44c2_s_p9_1[] = {
		 1, 4, 4, 6, 6, 7, 6, 8, 8,10, 9,10,10, 6, 5, 5,
		 7, 7, 8, 7,10, 9,11,11,12,13, 6, 5, 5, 7, 7, 8,
		 8,10,10,11,11,13,13,18, 8, 8, 8, 8, 9, 9,10,10,
		12,12,12,13,18, 8, 8, 8, 8, 9, 9,10,10,12,12,13,
		13,18,11,11, 8, 8,10,10,11,11,12,11,13,12,18,11,
		11, 9, 7,10,10,11,11,11,12,12,13,17,17,17,10,10,
		11,11,12,12,12,10,12,12,17,17,17,11,10,11,10,13,
		12,11,12,12,12,17,17,17,15,14,11,11,12,11,13,10,
		13,12,17,17,17,14,14,12,10,11,11,13,13,13,13,17,
		17,16,17,16,13,13,12,10,13,10,14,13,17,16,17,16,
		17,13,12,12,10,13,11,14,14,
};

static const static_codebook _44c2_s_p9_1 = {
		2, 169,
		(long *)_vq_lengthlist__44c2_s_p9_1,
		1, -522616832, 1620115456, 4, 0,
		(long *)_vq_quantlist__44c2_s_p9_1,
		0
};

static const long _vq_quantlist__44c2_s_p9_2[] = {
		8,
		7,
		9,
		6,
		10,
		5,
		11,
		4,
		12,
		3,
		13,
		2,
		14,
		1,
		15,
		0,
		16,
};

static const long _vq_lengthlist__44c2_s_p9_2[] = {
		 2, 4, 4, 6, 6, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8,
		 8,10, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 9, 9, 9, 9,
		 9, 9,10, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9,
		 9, 9, 9,10, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9,
		 9, 9, 9, 9,10,10,10, 8, 7, 8, 8, 8, 8, 9, 9, 9,
		 9, 9, 9, 9, 9,10,11,11, 8, 8, 8, 8, 9, 9, 9, 9,
		 9, 9,10, 9, 9, 9,10,11,10, 8, 8, 8, 8, 9, 9, 9,
		 9, 9, 9, 9,10,10,10,10,11,10, 8, 8, 9, 9, 9, 9,
		 9, 9,10, 9, 9,10, 9,10,11,10,11,11,11, 8, 8, 9,
		 9, 9, 9, 9, 9, 9, 9,10,10,11,11,11,11,11, 9, 9,
		 9, 9, 9, 9,10, 9, 9, 9,10,10,11,11,11,11,11, 9,
		 9, 9, 9, 9, 9, 9, 9, 9,10, 9,10,11,11,11,11,11,
		 9, 9, 9, 9,10,10, 9, 9, 9,10,10,10,11,11,11,11,
		11,11,11, 9, 9, 9,10, 9, 9,10,10,10,10,11,11,10,
		11,11,11,11,10, 9,10,10, 9, 9, 9, 9,10,10,11,10,
		11,11,11,11,11, 9, 9, 9, 9,10, 9,10,10,10,10,11,
		10,11,11,11,11,11,10,10, 9, 9,10, 9,10,10,10,10,
		10,10,10,11,11,11,11,11,11, 9, 9,10, 9,10, 9,10,
		10,
};

static const static_codebook _44c2_s_p9_2 = {
		2, 289,
		(long *)_vq_lengthlist__44c2_s_p9_2,
		1, -529530880, 1611661312, 5, 0,
		(long *)_vq_quantlist__44c2_s_p9_2,
		0
};

static const long _huff_lengthlist__44c2_s_short[] = {
		11, 9,13,12,12,11,12,12,13,15, 8, 2,11, 4, 8, 5,
		 7,10,12,15,13, 7,10, 9, 8, 8,10,13,17,17,11, 4,
		12, 5, 9, 5, 8,11,14,16,12, 6, 8, 7, 6, 6, 8,11,
		13,16,11, 4, 9, 5, 6, 4, 6,10,13,16,11, 6,11, 7,
		 7, 6, 7,10,13,15,13, 9,12, 9, 8, 6, 8,10,12,14,
		14,10,10, 8, 6, 5, 6, 9,11,13,15,11,11, 9, 6, 5,
		 6, 8, 9,12,
};

static const static_codebook _huff_book__44c2_s_short = {
		2, 100,
		(long *)_huff_lengthlist__44c2_s_short,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist__44c3_s_long[] = {
		 5, 6,11,11,11,11,10,10,12,11, 5, 2,11, 5, 6, 6,
		 7, 9,11,13,13,10, 7,11, 6, 7, 8, 9,10,12,11, 5,
		11, 6, 8, 7, 9,11,14,15,11, 6, 6, 8, 4, 5, 7, 8,
		10,13,10, 5, 7, 7, 5, 5, 6, 8,10,11,10, 7, 7, 8,
		 6, 5, 5, 7, 9, 9,11, 8, 8,11, 8, 7, 6, 6, 7, 9,
		12,11,10,13, 9, 9, 7, 7, 7, 9,11,13,12,15,12,11,
		 9, 8, 8, 8,
};

static const static_codebook _huff_book__44c3_s_long = {
		2, 100,
		(long *)_huff_lengthlist__44c3_s_long,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _vq_quantlist__44c3_s_p1_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__44c3_s_p1_0[] = {
		 2, 4, 4, 0, 0, 0, 0, 0, 0, 5, 6, 6, 0, 0, 0, 0,
		 0, 0, 5, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 5, 7, 7, 0, 0, 0, 0, 0, 0, 7, 8, 8, 0, 0, 0,
		 0, 0, 0, 6, 7, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 5, 7, 7, 0, 0, 0, 0, 0, 0, 6, 8, 7, 0, 0,
		 0, 0, 0, 0, 7, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 7, 7, 0, 0, 0, 0,
		 0, 0, 7, 8, 8, 0, 0, 0, 0, 0, 0, 7, 8, 8, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 8, 8, 0, 0, 0,
		 0, 0, 0, 8, 8, 9, 0, 0, 0, 0, 0, 0, 8, 9, 9, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 8, 8, 0, 0,
		 0, 0, 0, 0, 7, 9, 8, 0, 0, 0, 0, 0, 0, 8, 9, 9,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 5, 7, 7, 0, 0, 0, 0, 0, 0, 7, 8, 8, 0, 0,
		 0, 0, 0, 0, 7, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 6, 8, 8, 0, 0, 0, 0, 0, 0, 8, 9, 9, 0,
		 0, 0, 0, 0, 0, 7, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 6, 8, 8, 0, 0, 0, 0, 0, 0, 8, 9, 9,
		 0, 0, 0, 0, 0, 0, 8, 9, 8, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0,
};

static const static_codebook _44c3_s_p1_0 = {
		8, 6561,
		(long *)_vq_lengthlist__44c3_s_p1_0,
		1, -535822336, 1611661312, 2, 0,
		(long *)_vq_quantlist__44c3_s_p1_0,
		0
};

static const long _vq_quantlist__44c3_s_p2_0[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__44c3_s_p2_0[] = {
		 2, 5, 5, 0, 0, 0, 5, 5, 0, 0, 0, 5, 5, 0, 0, 0,
		 7, 8, 0, 0, 0, 0, 0, 0, 0, 5, 6, 6, 0, 0, 0, 7,
		 7, 0, 0, 0, 7, 7, 0, 0, 0,10,10, 0, 0, 0, 0, 0,
		 0, 0, 5, 6, 6, 0, 0, 0, 7, 7, 0, 0, 0, 7, 7, 0,
		 0, 0,10,10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 5, 7, 7, 0, 0, 0, 7, 7, 0, 0,
		 0, 7, 7, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 5,
		 7, 7, 0, 0, 0, 7, 7, 0, 0, 0, 7, 7, 0, 0, 0, 9,
		 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 5, 7, 7, 0, 0, 0, 7, 7, 0, 0, 0, 7, 7,
		 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 5, 7, 7, 0,
		 0, 0, 7, 7, 0, 0, 0, 7, 7, 0, 0, 0, 9, 9, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 8,10,10, 0, 0, 0, 9, 9, 0, 0, 0, 9, 9, 0, 0, 0,
		10,10, 0, 0, 0, 0, 0, 0, 0, 8,10,10, 0, 0, 0, 9,
		 9, 0, 0, 0, 9, 9, 0, 0, 0,10,10, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0,
};

static const static_codebook _44c3_s_p2_0 = {
		4, 625,
		(long *)_vq_lengthlist__44c3_s_p2_0,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__44c3_s_p2_0,
		0
};

static const long _vq_quantlist__44c3_s_p3_0[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__44c3_s_p3_0[] = {
		 2, 4, 3, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 6, 6, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 4, 4, 4, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 9, 9,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 6, 6, 7, 9, 9, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0,
};

static const static_codebook _44c3_s_p3_0 = {
		4, 625,
		(long *)_vq_lengthlist__44c3_s_p3_0,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__44c3_s_p3_0,
		0
};

static const long _vq_quantlist__44c3_s_p4_0[] = {
		4,
		3,
		5,
		2,
		6,
		1,
		7,
		0,
		8,
};

static const long _vq_lengthlist__44c3_s_p4_0[] = {
		 2, 3, 3, 6, 6, 0, 0, 0, 0, 0, 4, 4, 6, 6, 0, 0,
		 0, 0, 0, 4, 4, 6, 6, 0, 0, 0, 0, 0, 5, 5, 6, 6,
		 0, 0, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 0,
		 7, 8, 0, 0, 0, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0,
		 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0,
};

static const static_codebook _44c3_s_p4_0 = {
		2, 81,
		(long *)_vq_lengthlist__44c3_s_p4_0,
		1, -531628032, 1611661312, 4, 0,
		(long *)_vq_quantlist__44c3_s_p4_0,
		0
};

static const long _vq_quantlist__44c3_s_p5_0[] = {
		4,
		3,
		5,
		2,
		6,
		1,
		7,
		0,
		8,
};

static const long _vq_lengthlist__44c3_s_p5_0[] = {
		 1, 3, 4, 6, 6, 7, 7, 9, 9, 0, 5, 5, 7, 7, 7, 8,
		 9, 9, 0, 5, 5, 7, 7, 8, 8, 9, 9, 0, 7, 7, 8, 8,
		 8, 8,10,10, 0, 0, 0, 8, 8, 8, 8,10,10, 0, 0, 0,
		 9, 9, 9, 9,10,10, 0, 0, 0, 9, 9, 9, 9,10,10, 0,
		 0, 0,10,10,10,10,11,11, 0, 0, 0, 0, 0,10,10,11,
		11,
};

static const static_codebook _44c3_s_p5_0 = {
		2, 81,
		(long *)_vq_lengthlist__44c3_s_p5_0,
		1, -531628032, 1611661312, 4, 0,
		(long *)_vq_quantlist__44c3_s_p5_0,
		0
};

static const long _vq_quantlist__44c3_s_p6_0[] = {
		8,
		7,
		9,
		6,
		10,
		5,
		11,
		4,
		12,
		3,
		13,
		2,
		14,
		1,
		15,
		0,
		16,
};

static const long _vq_lengthlist__44c3_s_p6_0[] = {
		 2, 3, 3, 6, 6, 7, 7, 8, 8, 8, 8, 9, 9,10,10,11,
		10, 0, 5, 5, 7, 7, 8, 8, 9, 9, 9, 9,10,10,10,10,
		11,11, 0, 5, 5, 7, 7, 8, 8, 9, 9, 9, 9,10,10,10,
		10,11,11, 0, 6, 6, 7, 7, 8, 8, 9, 9, 9, 9,10,10,
		11,11,11,11, 0, 0, 0, 7, 7, 8, 8, 9, 9, 9, 9,10,
		10,11,11,11,12, 0, 0, 0, 8, 8, 8, 8, 9, 9, 9, 9,
		10,10,11,11,12,12, 0, 0, 0, 8, 8, 8, 8, 9, 9, 9,
		 9,10,10,11,11,12,12, 0, 0, 0, 9, 9, 9, 9,10,10,
		10,10,11,10,11,11,12,12, 0, 0, 0, 0, 0, 9, 9,10,
		10,10,10,11,11,11,11,12,12, 0, 0, 0, 0, 0, 9, 8,
		 9, 9,10,10,11,11,12,12,12,12, 0, 0, 0, 0, 0, 8,
		 8, 9, 9,10,10,11,11,12,11,12,12, 0, 0, 0, 0, 0,
		 9,10,10,10,11,11,11,11,12,12,13,13, 0, 0, 0, 0,
		 0, 0, 0,10,10,10,10,11,11,12,12,13,13, 0, 0, 0,
		 0, 0, 0, 0,11,11,11,11,12,12,12,12,13,13, 0, 0,
		 0, 0, 0, 0, 0,11,11,11,11,12,12,12,12,13,13, 0,
		 0, 0, 0, 0, 0, 0,11,11,12,12,12,12,13,13,13,13,
		 0, 0, 0, 0, 0, 0, 0, 0, 0,12,12,12,12,13,13,13,
		13,
};

static const static_codebook _44c3_s_p6_0 = {
		2, 289,
		(long *)_vq_lengthlist__44c3_s_p6_0,
		1, -529530880, 1611661312, 5, 0,
		(long *)_vq_quantlist__44c3_s_p6_0,
		0
};

static const long _vq_quantlist__44c3_s_p7_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__44c3_s_p7_0[] = {
		 1, 4, 4, 7, 6, 6, 7, 6, 6, 4, 7, 7,10, 9, 9,11,
		 9, 9, 4, 7, 7,10, 9, 9,11, 9, 9, 7,10,10,11,11,
		10,12,11,11, 6, 9, 9,11,10,10,11,10,10, 6, 9, 9,
		11,10,10,11,10,10, 7,11,11,11,11,11,12,11,11, 6,
		 9, 9,11,10,10,11,10,10, 6, 9, 9,11,10,10,11,10,
		10,
};

static const static_codebook _44c3_s_p7_0 = {
		4, 81,
		(long *)_vq_lengthlist__44c3_s_p7_0,
		1, -529137664, 1618345984, 2, 0,
		(long *)_vq_quantlist__44c3_s_p7_0,
		0
};

static const long _vq_quantlist__44c3_s_p7_1[] = {
		5,
		4,
		6,
		3,
		7,
		2,
		8,
		1,
		9,
		0,
		10,
};

static const long _vq_lengthlist__44c3_s_p7_1[] = {
		 2, 4, 4, 6, 6, 7, 7, 7, 7, 8, 8,10, 5, 5, 6, 6,
		 7, 7, 8, 8, 8, 8,10, 5, 5, 6, 6, 7, 7, 8, 8, 8,
		 8,10, 6, 6, 7, 7, 8, 8, 8, 8, 8, 8,10,10,10, 7,
		 7, 8, 7, 8, 8, 8, 8,10,10,10, 8, 8, 8, 8, 8, 8,
		 8, 8,10,10,10, 7, 8, 8, 8, 8, 8, 8, 8,10,10,10,
		 8, 8, 8, 8, 8, 8, 8, 8,10,10,10,10,10, 8, 8, 8,
		 8, 8, 8,10,10,10,10,10, 9, 9, 8, 8, 9, 8,10,10,
		10,10,10, 8, 8, 8, 8, 8, 8,
};

static const static_codebook _44c3_s_p7_1 = {
		2, 121,
		(long *)_vq_lengthlist__44c3_s_p7_1,
		1, -531365888, 1611661312, 4, 0,
		(long *)_vq_quantlist__44c3_s_p7_1,
		0
};

static const long _vq_quantlist__44c3_s_p8_0[] = {
		6,
		5,
		7,
		4,
		8,
		3,
		9,
		2,
		10,
		1,
		11,
		0,
		12,
};

static const long _vq_lengthlist__44c3_s_p8_0[] = {
		 1, 4, 4, 6, 6, 7, 7, 8, 8, 9, 9,10,10, 6, 5, 5,
		 7, 7, 8, 8, 8, 8, 9, 9,10,10, 7, 5, 5, 7, 7, 8,
		 8, 8, 8, 9, 9,11,10, 0, 8, 8, 8, 8, 9, 9, 9, 9,
		10,10,11,11, 0, 8, 8, 8, 8, 9, 9, 9, 9,10,10,11,
		11, 0,12,12, 9, 9,10,10,10,10,11,11,11,12, 0,13,
		13, 9, 9,10,10,10,10,11,11,12,12, 0, 0, 0,10,10,
		10,10,11,11,12,12,12,12, 0, 0, 0,10,10,10,10,11,
		11,12,12,12,12, 0, 0, 0,14,14,11,11,11,11,12,12,
		13,13, 0, 0, 0,14,14,11,11,11,11,12,12,13,13, 0,
		 0, 0, 0, 0,12,12,12,12,13,13,14,13, 0, 0, 0, 0,
		 0,13,13,12,12,13,12,14,13,
};

static const static_codebook _44c3_s_p8_0 = {
		2, 169,
		(long *)_vq_lengthlist__44c3_s_p8_0,
		1, -526516224, 1616117760, 4, 0,
		(long *)_vq_quantlist__44c3_s_p8_0,
		0
};

static const long _vq_quantlist__44c3_s_p8_1[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__44c3_s_p8_1[] = {
		 2, 4, 4, 5, 5, 6, 5, 5, 5, 5, 6, 4, 5, 5, 5, 6,
		 5, 5, 5, 5, 6, 6, 6, 5, 5,
};

static const static_codebook _44c3_s_p8_1 = {
		2, 25,
		(long *)_vq_lengthlist__44c3_s_p8_1,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__44c3_s_p8_1,
		0
};

static const long _vq_quantlist__44c3_s_p9_0[] = {
		6,
		5,
		7,
		4,
		8,
		3,
		9,
		2,
		10,
		1,
		11,
		0,
		12,
};

static const long _vq_lengthlist__44c3_s_p9_0[] = {
		 1, 4, 4,12,12,12,12,12,12,12,12,12,12, 4, 9, 8,
		12,12,12,12,12,12,12,12,12,12, 2, 9, 7,12,12,12,
		12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
		12,12,12,12,12,12,11,12,12,12,12,12,12,12,12,12,
		12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
		12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
		12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
		12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
		12,12,12,12,12,12,12,12,12,12,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,
};

static const static_codebook _44c3_s_p9_0 = {
		2, 169,
		(long *)_vq_lengthlist__44c3_s_p9_0,
		1, -514332672, 1627381760, 4, 0,
		(long *)_vq_quantlist__44c3_s_p9_0,
		0
};

static const long _vq_quantlist__44c3_s_p9_1[] = {
		7,
		6,
		8,
		5,
		9,
		4,
		10,
		3,
		11,
		2,
		12,
		1,
		13,
		0,
		14,
};

static const long _vq_lengthlist__44c3_s_p9_1[] = {
		 1, 4, 4, 6, 6, 7, 7, 8, 7, 9, 9,10,10,10,10, 6,
		 5, 5, 7, 7, 8, 8,10, 8,11,10,12,12,13,13, 6, 5,
		 5, 7, 7, 8, 8,10, 9,11,11,12,12,13,12,18, 8, 8,
		 8, 8, 9, 9,10, 9,11,10,12,12,13,13,18, 8, 8, 8,
		 8, 9, 9,10,10,11,11,13,12,14,13,18,11,11, 9, 9,
		10,10,11,11,11,12,13,12,13,14,18,11,11, 9, 8,11,
		10,11,11,11,11,12,12,14,13,18,18,18,10,11,10,11,
		12,12,12,12,13,12,14,13,18,18,18,10,11,11, 9,12,
		11,12,12,12,13,13,13,18,18,17,14,14,11,11,12,12,
		13,12,14,12,14,13,18,18,18,14,14,11,10,12, 9,12,
		13,13,13,13,13,18,18,17,16,18,13,13,12,12,13,11,
		14,12,14,14,17,18,18,17,18,13,12,13,10,12,11,14,
		14,14,14,17,18,18,18,18,15,16,12,12,13,10,14,12,
		14,15,18,18,18,16,17,16,14,12,11,13,10,13,13,14,
		15,
};

static const static_codebook _44c3_s_p9_1 = {
		2, 225,
		(long *)_vq_lengthlist__44c3_s_p9_1,
		1, -522338304, 1620115456, 4, 0,
		(long *)_vq_quantlist__44c3_s_p9_1,
		0
};

static const long _vq_quantlist__44c3_s_p9_2[] = {
		8,
		7,
		9,
		6,
		10,
		5,
		11,
		4,
		12,
		3,
		13,
		2,
		14,
		1,
		15,
		0,
		16,
};

static const long _vq_lengthlist__44c3_s_p9_2[] = {
		 2, 5, 5, 6, 6, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8,
		 8,10, 6, 6, 7, 7, 8, 7, 8, 8, 8, 8, 8, 9, 9, 9,
		 9, 9,10, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 9, 9, 9,
		 9, 9, 9,10, 7, 7, 7, 7, 8, 8, 8, 8, 9, 9, 9, 9,
		 9, 9, 9, 9,10,10,10, 7, 7, 8, 8, 8, 9, 9, 9, 9,
		 9, 9, 9, 9, 9,11,11,11, 8, 8, 8, 8, 9, 9, 9, 9,
		 9, 9, 9, 9, 9, 9,10,10,10, 8, 8, 8, 8, 9, 9, 9,
		 9, 9, 9, 9, 9, 9, 9,10,10,10, 8, 9, 9, 9, 9, 9,
		 9, 9, 9, 9, 9, 9,10, 9,10,10,10,11,11, 9, 9, 9,
		 9, 9, 9, 9, 9, 9, 9, 9, 9,11,10,11,11,11, 9, 9,
		 9, 9, 9, 9,10,10, 9, 9,10, 9,11,10,11,11,11, 9,
		 9, 9, 9, 9, 9, 9, 9,10,10,10, 9,11,11,11,11,11,
		 9, 9, 9, 9,10,10, 9, 9, 9, 9,10, 9,11,11,11,11,
		11,11,11, 9, 9, 9, 9, 9, 9,10,10,10,10,11,11,11,
		11,11,11,11,10, 9,10,10, 9,10, 9, 9,10, 9,11,10,
		10,11,11,11,11, 9,10, 9, 9, 9, 9,10,10,10,10,11,
		11,11,11,11,11,10,10,10, 9, 9,10, 9,10, 9,10,10,
		10,10,11,11,11,11,11,11,11, 9, 9, 9, 9, 9,10,10,
		10,
};

static const static_codebook _44c3_s_p9_2 = {
		2, 289,
		(long *)_vq_lengthlist__44c3_s_p9_2,
		1, -529530880, 1611661312, 5, 0,
		(long *)_vq_quantlist__44c3_s_p9_2,
		0
};

static const long _huff_lengthlist__44c3_s_short[] = {
		10, 9,13,11,14,10,12,13,13,14, 7, 2,12, 5,10, 5,
		 7,10,12,14,12, 6, 9, 8, 7, 7, 9,11,13,16,10, 4,
		12, 5,10, 6, 8,12,14,16,12, 6, 8, 7, 6, 5, 7,11,
		12,16,10, 4, 8, 5, 6, 4, 6, 9,13,16,10, 6,10, 7,
		 7, 6, 7, 9,13,15,12, 9,11, 9, 8, 6, 7,10,12,14,
		14,11,10, 9, 6, 5, 6, 9,11,13,15,13,11,10, 6, 5,
		 6, 8, 9,11,
};

static const static_codebook _huff_book__44c3_s_short = {
		2, 100,
		(long *)_huff_lengthlist__44c3_s_short,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist__44c4_s_long[] = {
		 4, 7,11,11,11,11,10,11,12,11, 5, 2,11, 5, 6, 6,
		 7, 9,11,12,11, 9, 6,10, 6, 7, 8, 9,10,11,11, 5,
		11, 7, 8, 8, 9,11,13,14,11, 6, 5, 8, 4, 5, 7, 8,
		10,11,10, 6, 7, 7, 5, 5, 6, 8, 9,11,10, 7, 8, 9,
		 6, 6, 6, 7, 8, 9,11, 9, 9,11, 7, 7, 6, 6, 7, 9,
		12,12,10,13, 9, 8, 7, 7, 7, 8,11,13,11,14,11,10,
		 9, 8, 7, 7,
};

static const static_codebook _huff_book__44c4_s_long = {
		2, 100,
		(long *)_huff_lengthlist__44c4_s_long,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _vq_quantlist__44c4_s_p1_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__44c4_s_p1_0[] = {
		 2, 4, 4, 0, 0, 0, 0, 0, 0, 5, 6, 6, 0, 0, 0, 0,
		 0, 0, 5, 6, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 5, 7, 7, 0, 0, 0, 0, 0, 0, 7, 8, 8, 0, 0, 0,
		 0, 0, 0, 6, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 5, 7, 7, 0, 0, 0, 0, 0, 0, 6, 8, 7, 0, 0,
		 0, 0, 0, 0, 7, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 7, 7, 0, 0, 0, 0,
		 0, 0, 7, 8, 8, 0, 0, 0, 0, 0, 0, 7, 8, 8, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 8, 8, 0, 0, 0,
		 0, 0, 0, 8, 9, 9, 0, 0, 0, 0, 0, 0, 8, 9, 9, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 8, 8, 0, 0,
		 0, 0, 0, 0, 8, 9, 8, 0, 0, 0, 0, 0, 0, 8, 9, 9,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 4, 7, 7, 0, 0, 0, 0, 0, 0, 7, 8, 8, 0, 0,
		 0, 0, 0, 0, 7, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 6, 8, 8, 0, 0, 0, 0, 0, 0, 8, 9, 9, 0,
		 0, 0, 0, 0, 0, 8, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 7, 8, 8, 0, 0, 0, 0, 0, 0, 8, 9, 9,
		 0, 0, 0, 0, 0, 0, 8, 9, 9, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0,
};

static const static_codebook _44c4_s_p1_0 = {
		8, 6561,
		(long *)_vq_lengthlist__44c4_s_p1_0,
		1, -535822336, 1611661312, 2, 0,
		(long *)_vq_quantlist__44c4_s_p1_0,
		0
};

static const long _vq_quantlist__44c4_s_p2_0[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__44c4_s_p2_0[] = {
		 2, 5, 5, 0, 0, 0, 5, 5, 0, 0, 0, 5, 5, 0, 0, 0,
		 7, 7, 0, 0, 0, 0, 0, 0, 0, 5, 6, 6, 0, 0, 0, 7,
		 7, 0, 0, 0, 7, 7, 0, 0, 0,10,10, 0, 0, 0, 0, 0,
		 0, 0, 5, 6, 6, 0, 0, 0, 7, 7, 0, 0, 0, 7, 7, 0,
		 0, 0,10,10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 5, 8, 7, 0, 0, 0, 7, 7, 0, 0,
		 0, 7, 7, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 5,
		 7, 8, 0, 0, 0, 7, 7, 0, 0, 0, 7, 7, 0, 0, 0, 9,
		 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 5, 7, 7, 0, 0, 0, 7, 7, 0, 0, 0, 7, 7,
		 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 5, 7, 7, 0,
		 0, 0, 7, 7, 0, 0, 0, 7, 7, 0, 0, 0, 9, 9, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 7,10,10, 0, 0, 0, 9, 9, 0, 0, 0, 9, 9, 0, 0, 0,
		10,10, 0, 0, 0, 0, 0, 0, 0, 8,10,10, 0, 0, 0, 9,
		 9, 0, 0, 0, 9, 9, 0, 0, 0,10,10, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0,
};

static const static_codebook _44c4_s_p2_0 = {
		4, 625,
		(long *)_vq_lengthlist__44c4_s_p2_0,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__44c4_s_p2_0,
		0
};

static const long _vq_quantlist__44c4_s_p3_0[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__44c4_s_p3_0[] = {
		 2, 3, 3, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 5, 4, 6, 6, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 4, 4, 5, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 9, 9,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 6, 6, 7, 9, 9, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0,
};

static const static_codebook _44c4_s_p3_0 = {
		4, 625,
		(long *)_vq_lengthlist__44c4_s_p3_0,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__44c4_s_p3_0,
		0
};

static const long _vq_quantlist__44c4_s_p4_0[] = {
		4,
		3,
		5,
		2,
		6,
		1,
		7,
		0,
		8,
};

static const long _vq_lengthlist__44c4_s_p4_0[] = {
		 2, 3, 3, 6, 6, 0, 0, 0, 0, 0, 4, 4, 6, 6, 0, 0,
		 0, 0, 0, 4, 4, 6, 6, 0, 0, 0, 0, 0, 5, 5, 6, 6,
		 0, 0, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 0,
		 7, 8, 0, 0, 0, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0,
		 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0,
};

static const static_codebook _44c4_s_p4_0 = {
		2, 81,
		(long *)_vq_lengthlist__44c4_s_p4_0,
		1, -531628032, 1611661312, 4, 0,
		(long *)_vq_quantlist__44c4_s_p4_0,
		0
};

static const long _vq_quantlist__44c4_s_p5_0[] = {
		4,
		3,
		5,
		2,
		6,
		1,
		7,
		0,
		8,
};

static const long _vq_lengthlist__44c4_s_p5_0[] = {
		 2, 3, 3, 6, 6, 7, 7, 9, 9, 0, 4, 4, 6, 6, 7, 7,
		 9, 9, 0, 4, 5, 6, 6, 7, 7, 9, 9, 0, 6, 6, 7, 7,
		 8, 8,10,10, 0, 0, 0, 7, 7, 8, 8,10, 9, 0, 0, 0,
		 9, 8, 8, 8,10,10, 0, 0, 0, 8, 8, 8, 8,10,10, 0,
		 0, 0,10,10, 9, 9,11,11, 0, 0, 0, 0, 0, 9, 9,10,
		10,
};

static const static_codebook _44c4_s_p5_0 = {
		2, 81,
		(long *)_vq_lengthlist__44c4_s_p5_0,
		1, -531628032, 1611661312, 4, 0,
		(long *)_vq_quantlist__44c4_s_p5_0,
		0
};

static const long _vq_quantlist__44c4_s_p6_0[] = {
		8,
		7,
		9,
		6,
		10,
		5,
		11,
		4,
		12,
		3,
		13,
		2,
		14,
		1,
		15,
		0,
		16,
};

static const long _vq_lengthlist__44c4_s_p6_0[] = {
		 2, 4, 4, 6, 6, 8, 8, 9, 9, 8, 8, 9, 9,10,10,11,
		11, 0, 4, 4, 6, 6, 8, 8, 9, 9, 9, 9,10,10,11,11,
		11,11, 0, 4, 4, 7, 6, 8, 8, 9, 9, 9, 9,10,10,11,
		11,11,11, 0, 6, 6, 7, 7, 8, 8, 9, 9, 9, 9,10,10,
		11,11,11,12, 0, 0, 0, 7, 7, 8, 8, 9, 9, 9, 9,10,
		10,11,11,12,12, 0, 0, 0, 8, 8, 8, 8, 9, 9, 9, 9,
		10,10,11,11,12,12, 0, 0, 0, 8, 8, 8, 8, 9, 9, 9,
		 9,10,10,11,11,12,12, 0, 0, 0, 9, 9, 9, 9,10,10,
		10,10,11,11,11,11,12,12, 0, 0, 0, 0, 0, 9, 9,10,
		10,10,10,11,11,11,11,12,12, 0, 0, 0, 0, 0, 9, 9,
		 9,10,10,10,11,11,11,11,12,12, 0, 0, 0, 0, 0, 9,
		 9, 9, 9,10,10,11,11,11,12,12,12, 0, 0, 0, 0, 0,
		10,10,10,10,11,11,11,11,12,12,13,12, 0, 0, 0, 0,
		 0, 0, 0,10,10,11,11,11,11,12,12,12,12, 0, 0, 0,
		 0, 0, 0, 0,11,11,11,11,12,12,12,12,13,13, 0, 0,
		 0, 0, 0, 0, 0,11,11,11,11,12,12,12,12,13,13, 0,
		 0, 0, 0, 0, 0, 0,12,12,12,12,12,12,13,13,13,13,
		 0, 0, 0, 0, 0, 0, 0, 0, 0,12,12,12,12,12,13,13,
		13,
};

static const static_codebook _44c4_s_p6_0 = {
		2, 289,
		(long *)_vq_lengthlist__44c4_s_p6_0,
		1, -529530880, 1611661312, 5, 0,
		(long *)_vq_quantlist__44c4_s_p6_0,
		0
};

static const long _vq_quantlist__44c4_s_p7_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__44c4_s_p7_0[] = {
		 1, 4, 4, 7, 6, 6, 7, 6, 6, 4, 7, 7,10, 9, 9,11,
		 9, 9, 4, 7, 7,10, 9, 9,11, 9, 9, 7,10,10,11,11,
		10,11,11,11, 6, 9, 9,11,10,10,11,10,10, 6, 9, 9,
		11,10,10,11,10,10, 7,11,11,12,11,11,12,11,11, 6,
		 9, 9,11,10,10,11,10,10, 6, 9, 9,11,10,10,11,10,
		10,
};

static const static_codebook _44c4_s_p7_0 = {
		4, 81,
		(long *)_vq_lengthlist__44c4_s_p7_0,
		1, -529137664, 1618345984, 2, 0,
		(long *)_vq_quantlist__44c4_s_p7_0,
		0
};

static const long _vq_quantlist__44c4_s_p7_1[] = {
		5,
		4,
		6,
		3,
		7,
		2,
		8,
		1,
		9,
		0,
		10,
};

static const long _vq_lengthlist__44c4_s_p7_1[] = {
		 2, 4, 4, 6, 6, 7, 7, 7, 7, 8, 8,10, 5, 5, 6, 6,
		 7, 7, 8, 8, 8, 8,10, 5, 5, 6, 6, 7, 7, 8, 8, 8,
		 8,10, 6, 6, 7, 7, 8, 8, 8, 8, 8, 8,10,10,10, 7,
		 7, 8, 8, 8, 8, 8, 8,10,10,10, 8, 7, 8, 8, 8, 8,
		 8, 8,10,10,10, 7, 7, 8, 8, 8, 8, 8, 8,10,10,10,
		 8, 8, 8, 8, 8, 8, 8, 8,10,10,10,10,10, 8, 8, 8,
		 8, 8, 8,10,10,10,10,10, 9, 9, 8, 8, 9, 8,10,10,
		10,10,10, 8, 8, 8, 8, 9, 9,
};

static const static_codebook _44c4_s_p7_1 = {
		2, 121,
		(long *)_vq_lengthlist__44c4_s_p7_1,
		1, -531365888, 1611661312, 4, 0,
		(long *)_vq_quantlist__44c4_s_p7_1,
		0
};

static const long _vq_quantlist__44c4_s_p8_0[] = {
		6,
		5,
		7,
		4,
		8,
		3,
		9,
		2,
		10,
		1,
		11,
		0,
		12,
};

static const long _vq_lengthlist__44c4_s_p8_0[] = {
		 1, 4, 4, 6, 6, 7, 7, 8, 8, 9, 9,10,10, 6, 5, 5,
		 7, 7, 8, 8, 8, 8, 9,10,11,11, 7, 5, 5, 7, 7, 8,
		 8, 9, 9,10,10,11,11, 0, 8, 8, 8, 8, 9, 9, 9, 9,
		10,10,11,11, 0, 8, 8, 8, 8, 9, 9, 9, 9,10,10,11,
		11, 0,12,12, 9, 9, 9, 9,10,10,10,10,11,11, 0,13,
		13, 9, 9,10, 9,10,10,11,11,11,12, 0, 0, 0,10,10,
		10,10,10,10,11,11,12,12, 0, 0, 0,10,10,10,10,10,
		10,11,11,12,12, 0, 0, 0,14,14,11,11,11,11,12,12,
		12,12, 0, 0, 0,14,14,11,11,11,11,12,12,12,13, 0,
		 0, 0, 0, 0,12,12,12,12,12,12,13,13, 0, 0, 0, 0,
		 0,13,12,12,12,12,12,13,13,
};

static const static_codebook _44c4_s_p8_0 = {
		2, 169,
		(long *)_vq_lengthlist__44c4_s_p8_0,
		1, -526516224, 1616117760, 4, 0,
		(long *)_vq_quantlist__44c4_s_p8_0,
		0
};

static const long _vq_quantlist__44c4_s_p8_1[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__44c4_s_p8_1[] = {
		 2, 4, 4, 5, 5, 6, 5, 5, 5, 5, 6, 5, 4, 5, 5, 6,
		 5, 5, 5, 5, 6, 6, 6, 5, 5,
};

static const static_codebook _44c4_s_p8_1 = {
		2, 25,
		(long *)_vq_lengthlist__44c4_s_p8_1,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__44c4_s_p8_1,
		0
};

static const long _vq_quantlist__44c4_s_p9_0[] = {
		6,
		5,
		7,
		4,
		8,
		3,
		9,
		2,
		10,
		1,
		11,
		0,
		12,
};

static const long _vq_lengthlist__44c4_s_p9_0[] = {
		 1, 3, 3,12,12,12,12,12,12,12,12,12,12, 4, 7, 7,
		12,12,12,12,12,12,12,12,12,12, 3, 8, 8,12,12,12,
		12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
		12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
		12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
		12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
		12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
		12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
		12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
		12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
		12,12,12,12,12,12,12,12,12,
};

static const static_codebook _44c4_s_p9_0 = {
		2, 169,
		(long *)_vq_lengthlist__44c4_s_p9_0,
		1, -513964032, 1628680192, 4, 0,
		(long *)_vq_quantlist__44c4_s_p9_0,
		0
};

static const long _vq_quantlist__44c4_s_p9_1[] = {
		7,
		6,
		8,
		5,
		9,
		4,
		10,
		3,
		11,
		2,
		12,
		1,
		13,
		0,
		14,
};

static const long _vq_lengthlist__44c4_s_p9_1[] = {
		 1, 4, 4, 5, 5, 7, 7, 9, 8,10, 9,10,10,10,10, 6,
		 5, 5, 7, 7, 9, 8,10, 9,11,10,12,12,13,13, 6, 5,
		 5, 7, 7, 9, 9,10,10,11,11,12,12,12,13,19, 8, 8,
		 8, 8, 9, 9,10,10,12,11,12,12,13,13,19, 8, 8, 8,
		 8, 9, 9,11,11,12,12,13,13,13,13,19,12,12, 9, 9,
		11,11,11,11,12,11,13,12,13,13,18,12,12, 9, 9,11,
		10,11,11,12,12,12,13,13,14,19,18,18,11,11,11,11,
		12,12,13,12,13,13,14,14,16,18,18,11,11,11,10,12,
		11,13,13,13,13,13,14,17,18,18,14,15,11,12,12,13,
		13,13,13,14,14,14,18,18,18,15,15,12,10,13,10,13,
		13,13,13,13,14,18,17,18,17,18,12,13,12,13,13,13,
		14,14,16,14,18,17,18,18,17,13,12,13,10,12,12,14,
		14,14,14,17,18,18,18,18,14,15,12,12,13,12,14,14,
		15,15,18,18,18,17,18,15,14,12,11,12,12,14,14,14,
		15,
};

static const static_codebook _44c4_s_p9_1 = {
		2, 225,
		(long *)_vq_lengthlist__44c4_s_p9_1,
		1, -520986624, 1620377600, 4, 0,
		(long *)_vq_quantlist__44c4_s_p9_1,
		0
};

static const long _vq_quantlist__44c4_s_p9_2[] = {
		10,
		9,
		11,
		8,
		12,
		7,
		13,
		6,
		14,
		5,
		15,
		4,
		16,
		3,
		17,
		2,
		18,
		1,
		19,
		0,
		20,
};

static const long _vq_lengthlist__44c4_s_p9_2[] = {
		 2, 5, 5, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8,
		 8, 9, 9, 9, 9,11, 6, 6, 7, 7, 8, 8, 8, 8, 9, 9,
		 9, 9, 9, 9, 9, 9,10,10,10,10,11, 6, 6, 7, 7, 8,
		 8, 8, 8, 9, 9, 9, 9, 9, 9,10, 9,10,10,10,10,11,
		 7, 7, 7, 7, 8, 8, 9, 9, 9, 9, 9, 9, 9,10,10,10,
		10,10,10,10,12,11,11, 7, 7, 8, 8, 9, 9, 9, 9, 9,
		 9,10,10,10,10,10,10,10,10,12,11,12, 8, 8, 8, 8,
		 9, 9, 9, 9, 9,10,10,10,10,10,10,10,10,10,11,11,
		11, 8, 8, 8, 8, 9, 9, 9, 9,10,10,10,10,10,10,10,
		10,10,10,11,11,12, 9, 9, 9, 9, 9, 9,10, 9,10,10,
		10,10,10,10,10,10,10,10,11,11,11,11,11, 9, 9, 9,
		 9,10,10,10,10,10,10,10,10,10,10,10,10,11,12,11,
		11,11, 9, 9, 9,10,10,10,10,10,10,10,10,10,10,10,
		10,10,11,11,11,11,11, 9, 9, 9, 9,10,10,10,10,10,
		10,10,10,10,10,10,10,11,11,11,12,12,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,11,12,11,12,
		11,11,11, 9,10,10,10,10,10,10,10,10,10,10,10,10,
		10,11,12,11,11,11,11,11,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,11,11,11,12,11,11,11,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,12,11,11,12,11,
		11,11,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		11,11,11,11,11,11,11,11,11,10,10,10,10,10,10,10,
		10,10,10,10,10,11,11,11,11,12,12,11,11,11,11,11,
		11,11,10,10,10,10,10,10,10,10,12,12,12,11,11,11,
		12,11,11,11,10,10,10,10,10,10,10,10,10,10,10,12,
		11,12,12,12,12,12,11,12,11,11,10,10,10,10,10,10,
		10,10,10,10,12,12,12,12,11,11,11,11,11,11,11,10,
		10,10,10,10,10,10,10,10,10,
};

static const static_codebook _44c4_s_p9_2 = {
		2, 441,
		(long *)_vq_lengthlist__44c4_s_p9_2,
		1, -529268736, 1611661312, 5, 0,
		(long *)_vq_quantlist__44c4_s_p9_2,
		0
};

static const long _huff_lengthlist__44c4_s_short[] = {
		 4, 7,14,10,15,10,12,15,16,15, 4, 2,11, 5,10, 6,
		 8,11,14,14,14,10, 7,11, 6, 8,10,11,13,15, 9, 4,
		11, 5, 9, 6, 9,12,14,15,14, 9, 6, 9, 4, 5, 7,10,
		12,13, 9, 5, 7, 6, 5, 5, 7,10,13,13,10, 8, 9, 8,
		 7, 6, 8,10,14,14,13,11,10,10, 7, 7, 8,11,14,15,
		13,12, 9, 9, 6, 5, 7,10,14,17,15,13,11,10, 6, 6,
		 7, 9,12,17,
};

static const static_codebook _huff_book__44c4_s_short = {
		2, 100,
		(long *)_huff_lengthlist__44c4_s_short,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist__44c5_s_long[] = {
		 3, 8, 9,13,10,12,12,12,12,12, 6, 4, 6, 8, 6, 8,
		10,10,11,12, 8, 5, 4,10, 4, 7, 8, 9,10,11,13, 8,
		10, 8, 9, 9,11,12,13,14,10, 6, 4, 9, 3, 5, 6, 8,
		10,11,11, 8, 6, 9, 5, 5, 6, 7, 9,11,12, 9, 7,11,
		 6, 6, 6, 7, 8,10,12,11, 9,12, 7, 7, 6, 6, 7, 9,
		13,12,10,13, 9, 8, 7, 7, 7, 8,11,15,11,15,11,10,
		 9, 8, 7, 7,
};

static const static_codebook _huff_book__44c5_s_long = {
		2, 100,
		(long *)_huff_lengthlist__44c5_s_long,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _vq_quantlist__44c5_s_p1_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__44c5_s_p1_0[] = {
		 2, 4, 4, 0, 0, 0, 0, 0, 0, 4, 7, 7, 0, 0, 0, 0,
		 0, 0, 4, 6, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 5, 7, 7, 0, 0, 0, 0, 0, 0, 7, 9, 9, 0, 0, 0,
		 0, 0, 0, 7, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 4, 7, 7, 0, 0, 0, 0, 0, 0, 7, 9, 8, 0, 0,
		 0, 0, 0, 0, 7, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 7, 7, 0, 0, 0, 0,
		 0, 0, 7, 9, 9, 0, 0, 0, 0, 0, 0, 7, 9, 9, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 9, 9, 0, 0, 0,
		 0, 0, 0, 9,10,11, 0, 0, 0, 0, 0, 0, 9,10,10, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 9, 9, 0, 0,
		 0, 0, 0, 0, 8,10, 9, 0, 0, 0, 0, 0, 0, 9,10,11,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 4, 7, 7, 0, 0, 0, 0, 0, 0, 7, 9, 9, 0, 0,
		 0, 0, 0, 0, 7, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 7, 9, 9, 0, 0, 0, 0, 0, 0, 9,11,10, 0,
		 0, 0, 0, 0, 0, 8, 9,10, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 7, 9, 9, 0, 0, 0, 0, 0, 0, 9,10,10,
		 0, 0, 0, 0, 0, 0, 9,11,10, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0,
};

static const static_codebook _44c5_s_p1_0 = {
		8, 6561,
		(long *)_vq_lengthlist__44c5_s_p1_0,
		1, -535822336, 1611661312, 2, 0,
		(long *)_vq_quantlist__44c5_s_p1_0,
		0
};

static const long _vq_quantlist__44c5_s_p2_0[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__44c5_s_p2_0[] = {
		 2, 4, 4, 0, 0, 0, 5, 5, 0, 0, 0, 5, 5, 0, 0, 0,
		 8, 7, 0, 0, 0, 0, 0, 0, 0, 4, 6, 6, 0, 0, 0, 8,
		 8, 0, 0, 0, 8, 7, 0, 0, 0,10,10, 0, 0, 0, 0, 0,
		 0, 0, 4, 6, 6, 0, 0, 0, 8, 8, 0, 0, 0, 7, 8, 0,
		 0, 0,10,10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 5, 8, 7, 0, 0, 0, 8, 8, 0, 0,
		 0, 8, 8, 0, 0, 0,10,10, 0, 0, 0, 0, 0, 0, 0, 5,
		 7, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0,10,
		10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 5, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8,
		 0, 0, 0,10,10, 0, 0, 0, 0, 0, 0, 0, 5, 8, 8, 0,
		 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0,10,10, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 8,10,10, 0, 0, 0,10,10, 0, 0, 0, 9,10, 0, 0, 0,
		11,10, 0, 0, 0, 0, 0, 0, 0, 8,10,10, 0, 0, 0,10,
		10, 0, 0, 0,10,10, 0, 0, 0,10,11, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0,
};

static const static_codebook _44c5_s_p2_0 = {
		4, 625,
		(long *)_vq_lengthlist__44c5_s_p2_0,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__44c5_s_p2_0,
		0
};

static const long _vq_quantlist__44c5_s_p3_0[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__44c5_s_p3_0[] = {
		 2, 4, 3, 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 5, 5, 6, 6, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 3, 5, 5, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 8, 8,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 5, 6, 6, 8, 8, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0,
};

static const static_codebook _44c5_s_p3_0 = {
		4, 625,
		(long *)_vq_lengthlist__44c5_s_p3_0,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__44c5_s_p3_0,
		0
};

static const long _vq_quantlist__44c5_s_p4_0[] = {
		4,
		3,
		5,
		2,
		6,
		1,
		7,
		0,
		8,
};

static const long _vq_lengthlist__44c5_s_p4_0[] = {
		 2, 3, 3, 6, 6, 0, 0, 0, 0, 0, 4, 4, 6, 6, 0, 0,
		 0, 0, 0, 4, 4, 6, 6, 0, 0, 0, 0, 0, 5, 5, 6, 6,
		 0, 0, 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 0,
		 7, 7, 0, 0, 0, 0, 0, 0, 0, 8, 7, 0, 0, 0, 0, 0,
		 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0,
};

static const static_codebook _44c5_s_p4_0 = {
		2, 81,
		(long *)_vq_lengthlist__44c5_s_p4_0,
		1, -531628032, 1611661312, 4, 0,
		(long *)_vq_quantlist__44c5_s_p4_0,
		0
};

static const long _vq_quantlist__44c5_s_p5_0[] = {
		4,
		3,
		5,
		2,
		6,
		1,
		7,
		0,
		8,
};

static const long _vq_lengthlist__44c5_s_p5_0[] = {
		 2, 4, 3, 6, 6, 7, 7, 9, 9, 0, 4, 4, 6, 6, 7, 7,
		 9, 9, 0, 4, 4, 6, 6, 7, 7, 9, 9, 0, 6, 6, 7, 7,
		 7, 7, 9, 9, 0, 0, 0, 7, 6, 7, 7, 9, 9, 0, 0, 0,
		 8, 8, 8, 8,10,10, 0, 0, 0, 8, 8, 8, 8,10,10, 0,
		 0, 0, 9, 9, 9, 9,10,10, 0, 0, 0, 0, 0, 9, 9,10,
		10,
};

static const static_codebook _44c5_s_p5_0 = {
		2, 81,
		(long *)_vq_lengthlist__44c5_s_p5_0,
		1, -531628032, 1611661312, 4, 0,
		(long *)_vq_quantlist__44c5_s_p5_0,
		0
};

static const long _vq_quantlist__44c5_s_p6_0[] = {
		8,
		7,
		9,
		6,
		10,
		5,
		11,
		4,
		12,
		3,
		13,
		2,
		14,
		1,
		15,
		0,
		16,
};

static const long _vq_lengthlist__44c5_s_p6_0[] = {
		 2, 4, 4, 6, 6, 8, 8, 9, 9, 9, 9,10,10,10,10,11,
		11, 0, 4, 4, 6, 6, 8, 8, 9, 9, 9, 9,10,10,11,11,
		12,12, 0, 4, 4, 6, 6, 8, 8, 9, 9, 9, 9,10,10,11,
		11,12,12, 0, 6, 6, 7, 7, 8, 8, 9, 9, 9, 9,10,10,
		11,11,12,12, 0, 0, 0, 7, 7, 8, 8, 9, 9, 9, 9,10,
		10,11,11,12,12, 0, 0, 0, 7, 7, 9, 9,10,10,10,10,
		11,11,11,11,12,12, 0, 0, 0, 7, 7, 8, 9,10,10,10,
		10,11,11,11,11,12,12, 0, 0, 0, 8, 8, 9, 9,10,10,
		10,10,11,11,12,12,12,12, 0, 0, 0, 0, 0, 9, 9,10,
		10,10,10,11,11,12,12,12,12, 0, 0, 0, 0, 0, 9, 9,
		10,10,10,10,11,11,12,12,12,12, 0, 0, 0, 0, 0, 9,
		 9, 9,10,10,10,11,11,12,12,12,12, 0, 0, 0, 0, 0,
		10,10,10,10,11,11,11,12,12,12,13,13, 0, 0, 0, 0,
		 0, 0, 0,10,10,11,11,11,11,12,12,13,13, 0, 0, 0,
		 0, 0, 0, 0,11,11,11,11,12,12,12,13,13,13, 0, 0,
		 0, 0, 0, 0, 0,11,11,11,11,12,12,12,12,13,13, 0,
		 0, 0, 0, 0, 0, 0,12,12,12,12,13,12,13,13,13,13,
		 0, 0, 0, 0, 0, 0, 0, 0, 0,12,12,12,12,13,13,13,
		13,
};

static const static_codebook _44c5_s_p6_0 = {
		2, 289,
		(long *)_vq_lengthlist__44c5_s_p6_0,
		1, -529530880, 1611661312, 5, 0,
		(long *)_vq_quantlist__44c5_s_p6_0,
		0
};

static const long _vq_quantlist__44c5_s_p7_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__44c5_s_p7_0[] = {
		 1, 4, 4, 7, 6, 6, 7, 6, 6, 4, 7, 7,10, 9, 9,11,
		 9, 9, 4, 7, 7,10, 9, 9,11, 9, 9, 7,10,10,11,11,
		10,11,11,11, 6, 9, 9,11,10,10,11,10,10, 6, 9, 9,
		11,10,10,11,10,10, 7,11,11,12,11,11,12,11,11, 6,
		 9, 9,11,10,10,11,10,10, 6, 9, 9,11,10,10,11,10,
		10,
};

static const static_codebook _44c5_s_p7_0 = {
		4, 81,
		(long *)_vq_lengthlist__44c5_s_p7_0,
		1, -529137664, 1618345984, 2, 0,
		(long *)_vq_quantlist__44c5_s_p7_0,
		0
};

static const long _vq_quantlist__44c5_s_p7_1[] = {
		5,
		4,
		6,
		3,
		7,
		2,
		8,
		1,
		9,
		0,
		10,
};

static const long _vq_lengthlist__44c5_s_p7_1[] = {
		 2, 4, 4, 6, 6, 7, 7, 8, 8, 8, 8,10, 5, 5, 6, 6,
		 7, 7, 8, 8, 8, 8,10, 5, 5, 6, 6, 7, 7, 8, 8, 8,
		 8,10, 6, 6, 7, 7, 8, 8, 8, 8, 8, 8,10,10,10, 7,
		 7, 8, 8, 8, 8, 8, 8,10,10,10, 7, 7, 8, 8, 8, 8,
		 8, 8,10,10,10, 7, 7, 8, 8, 8, 8, 8, 8,10,10,10,
		 8, 8, 8, 8, 8, 8, 8, 9,10,10,10,10,10, 8, 8, 8,
		 8, 8, 8,10,10,10,10,10, 9, 9, 8, 8, 8, 8,10,10,
		10,10,10, 8, 8, 8, 8, 8, 8,
};

static const static_codebook _44c5_s_p7_1 = {
		2, 121,
		(long *)_vq_lengthlist__44c5_s_p7_1,
		1, -531365888, 1611661312, 4, 0,
		(long *)_vq_quantlist__44c5_s_p7_1,
		0
};

static const long _vq_quantlist__44c5_s_p8_0[] = {
		6,
		5,
		7,
		4,
		8,
		3,
		9,
		2,
		10,
		1,
		11,
		0,
		12,
};

static const long _vq_lengthlist__44c5_s_p8_0[] = {
		 1, 4, 4, 6, 6, 7, 7, 8, 8, 9, 9,10,10, 6, 5, 5,
		 7, 7, 8, 8, 8, 9,10,10,10,10, 7, 5, 5, 7, 7, 8,
		 8, 9, 9,10,10,10,10, 0, 8, 8, 8, 8, 9, 9, 9, 9,
		10,10,11,11, 0, 8, 8, 8, 8, 9, 9, 9, 9,10,10,11,
		11, 0,12,12, 9, 9, 9,10,10,10,10,10,11,11, 0,13,
		13, 9, 9, 9, 9,10,10,11,11,11,11, 0, 0, 0,10,10,
		10,10,10,10,11,11,11,11, 0, 0, 0,10,10,10,10,10,
		10,11,11,12,12, 0, 0, 0,14,14,11,11,11,11,12,12,
		12,12, 0, 0, 0,14,14,11,11,11,11,12,12,12,12, 0,
		 0, 0, 0, 0,12,12,12,12,12,12,13,13, 0, 0, 0, 0,
		 0,12,12,12,12,12,12,13,13,
};

static const static_codebook _44c5_s_p8_0 = {
		2, 169,
		(long *)_vq_lengthlist__44c5_s_p8_0,
		1, -526516224, 1616117760, 4, 0,
		(long *)_vq_quantlist__44c5_s_p8_0,
		0
};

static const long _vq_quantlist__44c5_s_p8_1[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__44c5_s_p8_1[] = {
		 2, 4, 4, 5, 5, 6, 5, 5, 5, 5, 6, 4, 5, 5, 5, 6,
		 5, 5, 5, 5, 6, 6, 6, 5, 5,
};

static const static_codebook _44c5_s_p8_1 = {
		2, 25,
		(long *)_vq_lengthlist__44c5_s_p8_1,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__44c5_s_p8_1,
		0
};

static const long _vq_quantlist__44c5_s_p9_0[] = {
		7,
		6,
		8,
		5,
		9,
		4,
		10,
		3,
		11,
		2,
		12,
		1,
		13,
		0,
		14,
};

static const long _vq_lengthlist__44c5_s_p9_0[] = {
		 1, 3, 3,13,13,13,13,13,13,13,13,13,13,13,13, 4,
		 7, 7,13,13,13,13,13,13,13,13,13,13,13,13, 3, 8,
		 6,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
		13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
		13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
		13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
		13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
		13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
		13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
		13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
		13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
		13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
		13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
		13,13,13,13,13,13,13,13,13,12,12,12,12,12,12,12,
		12,
};

static const static_codebook _44c5_s_p9_0 = {
		2, 225,
		(long *)_vq_lengthlist__44c5_s_p9_0,
		1, -512522752, 1628852224, 4, 0,
		(long *)_vq_quantlist__44c5_s_p9_0,
		0
};

static const long _vq_quantlist__44c5_s_p9_1[] = {
		8,
		7,
		9,
		6,
		10,
		5,
		11,
		4,
		12,
		3,
		13,
		2,
		14,
		1,
		15,
		0,
		16,
};

static const long _vq_lengthlist__44c5_s_p9_1[] = {
		 1, 4, 4, 5, 5, 7, 7, 9, 8,10, 9,10,10,11,10,11,
		11, 6, 5, 5, 7, 7, 8, 9,10,10,11,10,12,11,12,11,
		13,12, 6, 5, 5, 7, 7, 9, 9,10,10,11,11,12,12,13,
		12,13,13,18, 8, 8, 8, 8, 9, 9,10,11,11,11,12,11,
		13,11,13,12,18, 8, 8, 8, 8,10,10,11,11,12,12,13,
		13,13,13,13,14,18,12,12, 9, 9,11,11,11,11,12,12,
		13,12,13,12,13,13,20,13,12, 9, 9,11,11,11,11,12,
		12,13,13,13,14,14,13,20,18,19,11,12,11,11,12,12,
		13,13,13,13,13,13,14,13,18,19,19,12,11,11,11,12,
		12,13,12,13,13,13,14,14,13,18,17,19,14,15,12,12,
		12,13,13,13,14,14,14,14,14,14,19,19,19,16,15,12,
		11,13,12,14,14,14,13,13,14,14,14,19,18,19,18,19,
		13,13,13,13,14,14,14,13,14,14,14,14,18,17,19,19,
		19,13,13,13,11,13,11,13,14,14,14,14,14,19,17,17,
		18,18,16,16,13,13,13,13,14,13,15,15,14,14,19,19,
		17,17,18,16,16,13,11,14,10,13,12,14,14,14,14,19,
		19,19,19,19,18,17,13,14,13,11,14,13,14,14,15,15,
		19,19,19,17,19,18,18,14,13,12,11,14,11,15,15,15,
		15,
};

static const static_codebook _44c5_s_p9_1 = {
		2, 289,
		(long *)_vq_lengthlist__44c5_s_p9_1,
		1, -520814592, 1620377600, 5, 0,
		(long *)_vq_quantlist__44c5_s_p9_1,
		0
};

static const long _vq_quantlist__44c5_s_p9_2[] = {
		10,
		9,
		11,
		8,
		12,
		7,
		13,
		6,
		14,
		5,
		15,
		4,
		16,
		3,
		17,
		2,
		18,
		1,
		19,
		0,
		20,
};

static const long _vq_lengthlist__44c5_s_p9_2[] = {
		 3, 5, 5, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8,
		 8, 8, 8, 8, 9,11, 5, 6, 7, 7, 8, 7, 8, 8, 8, 8,
		 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,11, 5, 5, 7, 7, 7,
		 7, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,11,
		 7, 7, 7, 7, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9,
		 9,10, 9,10,11,11,11, 7, 7, 8, 8, 8, 8, 9, 9, 9,
		 9, 9, 9,10,10,10,10,10,10,11,11,11, 8, 8, 8, 8,
		 9, 9, 9, 9, 9, 9, 9,10,10,10,10,10,10,10,11,11,
		11, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9,10,10,10,10,10,
		10,10,10,11,11,11, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
		10,10,10,10,10,10,10,10,11,11,11,11,11, 9, 9, 9,
		 9, 9, 9,10, 9,10,10,10,10,10,10,10,10,11,11,11,
		11,11, 9, 9, 9, 9, 9, 9,10,10,10,10,10,10,10,10,
		10,10,11,11,11,11,11, 9, 9, 9, 9, 9, 9,10,10,10,
		10,10,10,10,10,10,10,11,11,11,11,11, 9, 9,10, 9,
		10,10,10,10,10,10,10,10,10,10,10,10,11,11,11,11,
		11,11,11, 9, 9,10,10,10,10,10,10,10,10,10,10,10,
		10,11,11,11,11,11,11,11,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,11,11,11,11,11,11,11,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,11,11,11,11,11,
		11,11,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		11,11,11,11,11,11,11,11,11,10,10,10,10,10,10,10,
		10,10,10,10,10,11,11,11,11,11,11,11,11,11,10,10,
		10,10,10,10,10,10,10,10,10,10,11,11,11,11,11,11,
		11,11,11,10,10,10,10,10,10,10,10,10,10,10,10,11,
		11,11,11,11,11,11,11,11,10,10,10,10,10,10,10,10,
		10,10,10,10,11,11,11,11,11,11,11,11,11,11,11,10,
		10,10,10,10,10,10,10,10,10,
};

static const static_codebook _44c5_s_p9_2 = {
		2, 441,
		(long *)_vq_lengthlist__44c5_s_p9_2,
		1, -529268736, 1611661312, 5, 0,
		(long *)_vq_quantlist__44c5_s_p9_2,
		0
};

static const long _huff_lengthlist__44c5_s_short[] = {
		 5, 8,10,14,11,11,12,16,15,17, 5, 5, 7, 9, 7, 8,
		10,13,17,17, 7, 5, 5,10, 5, 7, 8,11,13,15,10, 8,
		10, 8, 8, 8,11,15,18,18, 8, 5, 5, 8, 3, 4, 6,10,
		14,16, 9, 7, 6, 7, 4, 3, 5, 9,14,18,10, 9, 8,10,
		 6, 5, 6, 9,14,18,12,12,11,12, 8, 7, 8,11,14,18,
		14,13,12,10, 7, 5, 6, 9,14,18,14,14,13,10, 6, 5,
		 6, 8,11,16,
};

static const static_codebook _huff_book__44c5_s_short = {
		2, 100,
		(long *)_huff_lengthlist__44c5_s_short,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist__44c6_s_long[] = {
		 3, 8,11,13,14,14,13,13,16,14, 6, 3, 4, 7, 9, 9,
		10,11,14,13,10, 4, 3, 5, 7, 7, 9,10,13,15,12, 7,
		 4, 4, 6, 6, 8,10,13,15,12, 8, 6, 6, 6, 6, 8,10,
		13,14,11, 9, 7, 6, 6, 6, 7, 8,12,11,13,10, 9, 8,
		 7, 6, 6, 7,11,11,13,11,10, 9, 9, 7, 7, 6,10,11,
		13,13,13,13,13,11, 9, 8,10,12,12,15,15,16,15,12,
		11,10,10,12,
};

static const static_codebook _huff_book__44c6_s_long = {
		2, 100,
		(long *)_huff_lengthlist__44c6_s_long,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _vq_quantlist__44c6_s_p1_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__44c6_s_p1_0[] = {
		 1, 5, 5, 0, 5, 5, 0, 5, 5, 5, 8, 7, 0, 9, 9, 0,
		 9, 8, 5, 7, 8, 0, 9, 9, 0, 8, 9, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 5, 9, 8, 0, 8, 8, 0, 8, 8, 5, 8, 9,
		 0, 8, 8, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5,
		 9, 9, 0, 8, 8, 0, 8, 8, 5, 9, 9, 0, 8, 8, 0, 8,
		 8,
};
static const static_codebook _44c6_s_p1_0 = {
		4, 81,
		(long *)_vq_lengthlist__44c6_s_p1_0,
		1, -535822336, 1611661312, 2, 0,
		(long *)_vq_quantlist__44c6_s_p1_0,
		0
};

static const long _vq_quantlist__44c6_s_p2_0[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__44c6_s_p2_0[] = {
		 3, 5, 5, 8, 8, 0, 5, 5, 8, 8, 0, 5, 5, 8, 8, 0,
		 7, 7, 9, 9, 0, 0, 0, 9, 9, 5, 7, 7, 9, 9, 0, 8,
		 8,10,10, 0, 8, 7,10, 9, 0,10,10,11,11, 0, 0, 0,
		11,11, 5, 7, 7, 9, 9, 0, 8, 8,10,10, 0, 7, 8, 9,
		10, 0,10,10,11,11, 0, 0, 0,11,11, 8, 9, 9,11,11,
		 0,11,11,12,12, 0,11,10,12,12, 0,13,14,14,14, 0,
		 0, 0,14,13, 8, 9, 9,11,11, 0,11,11,12,12, 0,10,
		11,12,12, 0,14,13,14,14, 0, 0, 0,13,14, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 5, 8, 7,11,10, 0, 7, 7,10,10,
		 0, 7, 7,10,10, 0, 9, 9,11,10, 0, 0, 0,11,11, 5,
		 7, 8,10,11, 0, 7, 7,10,10, 0, 7, 7,10,10, 0, 9,
		 9,10,11, 0, 0, 0,11,11, 8,10, 9,12,12, 0,10,10,
		12,12, 0,10,10,12,12, 0,12,12,13,13, 0, 0, 0,13,
		13, 8, 9,10,12,12, 0,10,10,11,12, 0,10,10,12,12,
		 0,12,12,13,13, 0, 0, 0,13,13, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 5, 8, 8,11,11, 0, 7, 7,10,10, 0, 7, 7,
		10,10, 0, 9, 9,10,11, 0, 0, 0,11,10, 5, 8, 8,11,
		11, 0, 7, 7,10,10, 0, 7, 7,10,10, 0, 9, 9,11,11,
		 0, 0, 0,10,11, 8,10,10,12,12, 0,10,10,12,12, 0,
		10,10,12,12, 0,12,13,13,13, 0, 0, 0,14,13, 8,10,
		10,12,12, 0,10,10,12,12, 0,10,10,12,12, 0,13,12,
		13,13, 0, 0, 0,13,13, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 7,10,10,14,13, 0, 9, 9,13,12, 0, 9, 9,12,12, 0,
		10,10,12,12, 0, 0, 0,12,12, 7,10,10,13,14, 0, 9,
		 9,12,13, 0, 9, 9,12,12, 0,10,10,12,12, 0, 0, 0,
		12,12, 9,11,11,14,13, 0,11,10,14,13, 0,11,11,13,
		13, 0,12,12,13,13, 0, 0, 0,13,13, 9,11,11,13,14,
		 0,10,11,13,14, 0,11,11,13,13, 0,12,12,13,13, 0,
		 0, 0,13,13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9,
		11,11,14,14, 0,11,11,13,13, 0,11,10,13,13, 0,12,
		12,13,13, 0, 0, 0,13,13, 9,11,11,14,14, 0,11,11,
		13,13, 0,10,11,13,13, 0,12,12,14,13, 0, 0, 0,13,
		13,
};

static const static_codebook _44c6_s_p2_0 = {
		4, 625,
		(long *)_vq_lengthlist__44c6_s_p2_0,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__44c6_s_p2_0,
		0
};

static const long _vq_quantlist__44c6_s_p3_0[] = {
		4,
		3,
		5,
		2,
		6,
		1,
		7,
		0,
		8,
};

static const long _vq_lengthlist__44c6_s_p3_0[] = {
		 2, 3, 4, 6, 6, 7, 7, 9, 9, 0, 4, 4, 6, 6, 7, 7,
		 9,10, 0, 4, 4, 6, 6, 7, 7,10, 9, 0, 5, 5, 7, 7,
		 8, 8,10,10, 0, 0, 0, 7, 6, 8, 8,10,10, 0, 0, 0,
		 7, 7, 9, 9,11,11, 0, 0, 0, 7, 7, 9, 9,11,11, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0,
};

static const static_codebook _44c6_s_p3_0 = {
		2, 81,
		(long *)_vq_lengthlist__44c6_s_p3_0,
		1, -531628032, 1611661312, 4, 0,
		(long *)_vq_quantlist__44c6_s_p3_0,
		0
};

static const long _vq_quantlist__44c6_s_p4_0[] = {
		8,
		7,
		9,
		6,
		10,
		5,
		11,
		4,
		12,
		3,
		13,
		2,
		14,
		1,
		15,
		0,
		16,
};

static const long _vq_lengthlist__44c6_s_p4_0[] = {
		 2, 4, 4, 6, 6, 7, 7, 8, 8, 8, 8, 9, 9, 9,10,10,
		10, 0, 4, 4, 6, 6, 8, 8, 9, 9, 9, 9,10,10,10,10,
		11,11, 0, 4, 4, 6, 6, 8, 8, 9, 9, 9, 9,10,10,10,
		10,11,11, 0, 6, 6, 7, 7, 8, 8, 9, 9, 9, 9,10,10,
		11,11,11,11, 0, 0, 0, 7, 7, 8, 8, 9, 9, 9, 9,10,
		10,11,11,11,11, 0, 0, 0, 7, 7, 9, 9,10,10,10,10,
		11,11,11,11,12,12, 0, 0, 0, 7, 7, 9, 9,10,10,10,
		10,11,11,11,11,12,12, 0, 0, 0, 7, 7, 8, 8, 9, 9,
		10,10,11,11,12,12,12,12, 0, 0, 0, 0, 0, 8, 8, 9,
		 9,10,10,11,11,12,12,12,12, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0,
};

static const static_codebook _44c6_s_p4_0 = {
		2, 289,
		(long *)_vq_lengthlist__44c6_s_p4_0,
		1, -529530880, 1611661312, 5, 0,
		(long *)_vq_quantlist__44c6_s_p4_0,
		0
};

static const long _vq_quantlist__44c6_s_p5_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__44c6_s_p5_0[] = {
		 1, 4, 4, 5, 7, 7, 6, 7, 7, 4, 6, 6, 9, 9,10,10,
		10, 9, 4, 6, 6, 9,10, 9,10, 9,10, 6, 9, 9,10,12,
		11,10,11,11, 7,10, 9,11,12,12,12,12,12, 7,10,10,
		11,12,12,12,12,12, 6,10,10,10,12,12,11,12,12, 7,
		 9,10,11,12,12,12,12,12, 7,10, 9,12,12,12,12,12,
		12,
};

static const static_codebook _44c6_s_p5_0 = {
		4, 81,
		(long *)_vq_lengthlist__44c6_s_p5_0,
		1, -529137664, 1618345984, 2, 0,
		(long *)_vq_quantlist__44c6_s_p5_0,
		0
};

static const long _vq_quantlist__44c6_s_p5_1[] = {
		5,
		4,
		6,
		3,
		7,
		2,
		8,
		1,
		9,
		0,
		10,
};

static const long _vq_lengthlist__44c6_s_p5_1[] = {
		 3, 5, 4, 6, 6, 7, 7, 8, 8, 8, 8,11, 4, 4, 6, 6,
		 7, 7, 8, 8, 8, 8,11, 4, 4, 6, 6, 7, 7, 8, 8, 8,
		 8,11, 6, 6, 6, 6, 8, 8, 8, 8, 9, 9,11,11,11, 6,
		 6, 7, 8, 8, 8, 8, 9,11,11,11, 7, 7, 8, 8, 8, 8,
		 8, 8,11,11,11, 7, 7, 8, 8, 8, 8, 8, 8,11,11,11,
		 8, 8, 8, 8, 8, 8, 8, 8,11,11,11,10,10, 8, 8, 8,
		 8, 8, 8,11,11,11,10,10, 8, 8, 8, 8, 8, 8,11,11,
		11,10,10, 7, 7, 8, 8, 8, 8,
};

static const static_codebook _44c6_s_p5_1 = {
		2, 121,
		(long *)_vq_lengthlist__44c6_s_p5_1,
		1, -531365888, 1611661312, 4, 0,
		(long *)_vq_quantlist__44c6_s_p5_1,
		0
};

static const long _vq_quantlist__44c6_s_p6_0[] = {
		6,
		5,
		7,
		4,
		8,
		3,
		9,
		2,
		10,
		1,
		11,
		0,
		12,
};

static const long _vq_lengthlist__44c6_s_p6_0[] = {
		 1, 4, 4, 6, 6, 8, 8, 8, 8,10, 9,10,10, 6, 5, 5,
		 7, 7, 9, 9, 9, 9,10,10,11,11, 6, 5, 5, 7, 7, 9,
		 9,10, 9,11,10,11,11, 0, 6, 6, 7, 7, 9, 9,10,10,
		11,11,12,12, 0, 7, 7, 7, 7, 9, 9,10,10,11,11,12,
		12, 0,11,11, 8, 8,10,10,11,11,12,12,12,12, 0,11,
		12, 9, 8,10,10,11,11,12,12,13,13, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0,
};

static const static_codebook _44c6_s_p6_0 = {
		2, 169,
		(long *)_vq_lengthlist__44c6_s_p6_0,
		1, -526516224, 1616117760, 4, 0,
		(long *)_vq_quantlist__44c6_s_p6_0,
		0
};

static const long _vq_quantlist__44c6_s_p6_1[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__44c6_s_p6_1[] = {
		 3, 4, 4, 5, 5, 5, 4, 4, 5, 5, 5, 4, 4, 5, 5, 6,
		 5, 5, 5, 5, 6, 6, 6, 5, 5,
};

static const static_codebook _44c6_s_p6_1 = {
		2, 25,
		(long *)_vq_lengthlist__44c6_s_p6_1,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__44c6_s_p6_1,
		0
};

static const long _vq_quantlist__44c6_s_p7_0[] = {
		6,
		5,
		7,
		4,
		8,
		3,
		9,
		2,
		10,
		1,
		11,
		0,
		12,
};

static const long _vq_lengthlist__44c6_s_p7_0[] = {
		 1, 4, 4, 6, 6, 8, 8, 8, 8,10,10,11,10, 6, 5, 5,
		 7, 7, 8, 8, 9, 9,10,10,12,11, 6, 5, 5, 7, 7, 8,
		 8, 9, 9,10,10,12,11,21, 7, 7, 7, 7, 9, 9,10,10,
		11,11,12,12,21, 7, 7, 7, 7, 9, 9,10,10,11,11,12,
		12,21,12,12, 9, 9,10,10,11,11,11,11,12,12,21,12,
		12, 9, 9,10,10,11,11,12,12,12,12,21,21,21,11,11,
		10,10,11,12,12,12,13,13,21,21,21,11,11,10,10,12,
		12,12,12,13,13,21,21,21,15,15,11,11,12,12,13,13,
		13,13,21,21,21,15,16,11,11,12,12,13,13,14,14,21,
		21,21,21,20,13,13,13,13,13,13,14,14,20,20,20,20,
		20,13,13,13,13,13,13,14,14,
};

static const static_codebook _44c6_s_p7_0 = {
		2, 169,
		(long *)_vq_lengthlist__44c6_s_p7_0,
		1, -523206656, 1618345984, 4, 0,
		(long *)_vq_quantlist__44c6_s_p7_0,
		0
};

static const long _vq_quantlist__44c6_s_p7_1[] = {
		5,
		4,
		6,
		3,
		7,
		2,
		8,
		1,
		9,
		0,
		10,
};

static const long _vq_lengthlist__44c6_s_p7_1[] = {
		 3, 5, 5, 6, 6, 7, 7, 7, 7, 7, 7, 9, 5, 5, 6, 6,
		 7, 7, 7, 7, 8, 7, 8, 5, 5, 6, 6, 7, 7, 7, 7, 7,
		 7, 9, 6, 6, 7, 7, 7, 7, 8, 7, 7, 8, 9, 9, 9, 7,
		 7, 7, 7, 7, 7, 7, 8, 9, 9, 9, 7, 7, 7, 7, 8, 8,
		 8, 8, 9, 9, 9, 7, 7, 7, 7, 7, 7, 8, 8, 9, 9, 9,
		 8, 8, 8, 8, 7, 7, 8, 8, 9, 9, 9, 9, 8, 8, 8, 7,
		 7, 8, 8, 9, 9, 9, 8, 8, 8, 8, 7, 7, 8, 8, 9, 9,
		 9, 8, 8, 7, 7, 7, 7, 8, 8,
};

static const static_codebook _44c6_s_p7_1 = {
		2, 121,
		(long *)_vq_lengthlist__44c6_s_p7_1,
		1, -531365888, 1611661312, 4, 0,
		(long *)_vq_quantlist__44c6_s_p7_1,
		0
};

static const long _vq_quantlist__44c6_s_p8_0[] = {
		7,
		6,
		8,
		5,
		9,
		4,
		10,
		3,
		11,
		2,
		12,
		1,
		13,
		0,
		14,
};

static const long _vq_lengthlist__44c6_s_p8_0[] = {
		 1, 4, 4, 7, 7, 8, 8, 7, 7, 8, 7, 9, 8,10, 9, 6,
		 5, 5, 8, 8, 9, 9, 8, 8, 9, 9,11,10,11,10, 6, 5,
		 5, 8, 8, 9, 9, 8, 8, 9, 9,10,10,11,11,18, 8, 8,
		 9, 8,10,10, 9, 9,10,10,10,10,11,10,18, 8, 8, 9,
		 9,10,10, 9, 9,10,10,11,11,12,12,18,12,13, 9,10,
		10,10, 9,10,10,10,11,11,12,11,18,13,13, 9, 9,10,
		10,10,10,10,10,11,11,12,12,18,18,18,10,10, 9, 9,
		11,11,11,11,11,12,12,12,18,18,18,10, 9,10, 9,11,
		10,11,11,11,11,13,12,18,18,18,14,13,10,10,11,11,
		12,12,12,12,12,12,18,18,18,14,13,10,10,11,10,12,
		12,12,12,12,12,18,18,18,18,18,12,12,11,11,12,12,
		13,13,13,14,18,18,18,18,18,12,12,11,11,12,11,13,
		13,14,13,18,18,18,18,18,16,16,11,12,12,13,13,13,
		14,13,18,18,18,18,18,16,15,12,11,12,11,13,11,15,
		14,
};

static const static_codebook _44c6_s_p8_0 = {
		2, 225,
		(long *)_vq_lengthlist__44c6_s_p8_0,
		1, -520986624, 1620377600, 4, 0,
		(long *)_vq_quantlist__44c6_s_p8_0,
		0
};

static const long _vq_quantlist__44c6_s_p8_1[] = {
		10,
		9,
		11,
		8,
		12,
		7,
		13,
		6,
		14,
		5,
		15,
		4,
		16,
		3,
		17,
		2,
		18,
		1,
		19,
		0,
		20,
};

static const long _vq_lengthlist__44c6_s_p8_1[] = {
		 3, 5, 5, 6, 6, 7, 7, 7, 7, 8, 7, 8, 8, 8, 8, 8,
		 8, 8, 8, 8, 8,10, 6, 6, 7, 7, 8, 8, 8, 8, 8, 8,
		 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,10, 6, 6, 7, 7, 8,
		 8, 8, 8, 8, 8, 9, 8, 9, 9, 9, 9, 9, 9, 9, 9,10,
		 7, 7, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9,
		 9, 9, 9, 9,10,11,11, 8, 7, 8, 8, 8, 9, 9, 9, 9,
		 9, 9, 9, 9, 9, 9, 9, 9, 9,11,11,11, 8, 8, 8, 8,
		 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,11,11,
		11, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
		 9, 9, 9,11,11,11, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
		 9, 9, 9, 9, 9, 9, 9, 9,11,11,11,11,11, 9, 9, 9,
		 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,10,10, 9,11,11,11,
		11,11, 9, 9, 9, 9, 9, 9,10, 9, 9,10, 9,10, 9, 9,
		10, 9,11,11,11,11,11, 9, 9, 9, 9, 9, 9, 9,10,10,
		10,10, 9,10,10, 9,10,11,11,11,11,11, 9, 9, 9, 9,
		10,10,10, 9,10,10,10,10, 9,10,10, 9,11,11,11,11,
		11,11,11, 9, 9, 9, 9,10,10,10,10, 9,10,10,10,10,
		10,11,11,11,11,11,11,11,10, 9,10,10,10,10,10,10,
		10, 9,10, 9,10,10,11,11,11,11,11,11,11,10, 9,10,
		 9,10,10, 9,10,10,10,10,10,10,10,11,11,11,11,11,
		11,11,10,10,10,10,10,10,10, 9,10,10,10,10,10, 9,
		11,11,11,11,11,11,11,11,11,10,10,10,10,10,10,10,
		10,10,10,10,10,11,11,11,11,11,11,11,11,11,10,10,
		10,10,10,10,10,10,10,10,10,10,11,11,11,11,11,11,
		11,11,11,10,10,10,10,10,10,10,10,10, 9,10,10,11,
		11,11,11,11,11,11,11,11,10,10,10, 9,10,10,10,10,
		10,10,10,10,10,11,11,11,11,11,11,11,11,10,11, 9,
		10,10,10,10,10,10,10,10,10,
};

static const static_codebook _44c6_s_p8_1 = {
		2, 441,
		(long *)_vq_lengthlist__44c6_s_p8_1,
		1, -529268736, 1611661312, 5, 0,
		(long *)_vq_quantlist__44c6_s_p8_1,
		0
};

static const long _vq_quantlist__44c6_s_p9_0[] = {
		6,
		5,
		7,
		4,
		8,
		3,
		9,
		2,
		10,
		1,
		11,
		0,
		12,
};

static const long _vq_lengthlist__44c6_s_p9_0[] = {
		 1, 3, 3,11,11,11,11,11,11,11,11,11,11, 4, 7, 7,
		11,11,11,11,11,11,11,11,11,11, 5, 8, 9,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,
};

static const static_codebook _44c6_s_p9_0 = {
		2, 169,
		(long *)_vq_lengthlist__44c6_s_p9_0,
		1, -511845376, 1630791680, 4, 0,
		(long *)_vq_quantlist__44c6_s_p9_0,
		0
};

static const long _vq_quantlist__44c6_s_p9_1[] = {
		6,
		5,
		7,
		4,
		8,
		3,
		9,
		2,
		10,
		1,
		11,
		0,
		12,
};

static const long _vq_lengthlist__44c6_s_p9_1[] = {
		 1, 4, 4, 7, 7, 7, 7, 7, 6, 8, 8, 8, 8, 6, 6, 6,
		 8, 8, 8, 8, 8, 7, 9, 8,10,10, 5, 6, 6, 8, 8, 9,
		 9, 8, 8,10,10,10,10,16, 9, 9, 9, 9, 9, 9, 9, 8,
		10, 9,11,11,16, 8, 9, 9, 9, 9, 9, 9, 9,10,10,11,
		11,16,13,13, 9, 9,10, 9, 9,10,11,11,11,12,16,13,
		14, 9, 8,10, 8, 9, 9,10,10,12,11,16,14,16, 9, 9,
		 9, 9,11,11,12,11,12,11,16,16,16, 9, 7, 9, 6,11,
		11,11,10,11,11,16,16,16,11,12, 9,10,11,11,12,11,
		13,13,16,16,16,12,11,10, 7,12,10,12,12,12,12,16,
		16,15,16,16,10,11,10,11,13,13,14,12,16,16,16,15,
		15,12,10,11,11,13,11,12,13,
};

static const static_codebook _44c6_s_p9_1 = {
		2, 169,
		(long *)_vq_lengthlist__44c6_s_p9_1,
		1, -518889472, 1622704128, 4, 0,
		(long *)_vq_quantlist__44c6_s_p9_1,
		0
};

static const long _vq_quantlist__44c6_s_p9_2[] = {
		24,
		23,
		25,
		22,
		26,
		21,
		27,
		20,
		28,
		19,
		29,
		18,
		30,
		17,
		31,
		16,
		32,
		15,
		33,
		14,
		34,
		13,
		35,
		12,
		36,
		11,
		37,
		10,
		38,
		9,
		39,
		8,
		40,
		7,
		41,
		6,
		42,
		5,
		43,
		4,
		44,
		3,
		45,
		2,
		46,
		1,
		47,
		0,
		48,
};

static const long _vq_lengthlist__44c6_s_p9_2[] = {
		 2, 4, 3, 4, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6,
		 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
		 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
		 7,
};

static const static_codebook _44c6_s_p9_2 = {
		1, 49,
		(long *)_vq_lengthlist__44c6_s_p9_2,
		1, -526909440, 1611661312, 6, 0,
		(long *)_vq_quantlist__44c6_s_p9_2,
		0
};

static const long _huff_lengthlist__44c6_s_short[] = {
		 3, 9,11,11,13,14,19,17,17,19, 5, 4, 5, 8,10,10,
		13,16,18,19, 7, 4, 4, 5, 8, 9,12,14,17,19, 8, 6,
		 5, 5, 7, 7,10,13,16,18,10, 8, 7, 6, 5, 5, 8,11,
		17,19,11, 9, 7, 7, 5, 4, 5, 8,17,19,13,11, 8, 7,
		 7, 5, 5, 7,16,18,14,13, 8, 6, 6, 5, 5, 7,16,18,
		18,16,10, 8, 8, 7, 7, 9,16,18,18,18,12,10,10, 9,
		 9,10,17,18,
};

static const static_codebook _huff_book__44c6_s_short = {
		2, 100,
		(long *)_huff_lengthlist__44c6_s_short,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist__44c7_s_long[] = {
		 3, 8,11,13,15,14,14,13,15,14, 6, 4, 5, 7, 9,10,
		11,11,14,13,10, 4, 3, 5, 7, 8, 9,10,13,13,12, 7,
		 4, 4, 5, 6, 8, 9,12,14,13, 9, 6, 5, 5, 6, 8, 9,
		12,14,12, 9, 7, 6, 5, 5, 6, 8,11,11,12,11, 9, 8,
		 7, 6, 6, 7,10,11,13,11,10, 9, 8, 7, 6, 6, 9,11,
		13,13,12,12,12,10, 9, 8, 9,11,12,14,15,15,14,12,
		11,10,10,12,
};

static const static_codebook _huff_book__44c7_s_long = {
		2, 100,
		(long *)_huff_lengthlist__44c7_s_long,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _vq_quantlist__44c7_s_p1_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__44c7_s_p1_0[] = {
		 1, 5, 5, 0, 5, 5, 0, 5, 5, 5, 8, 7, 0, 9, 9, 0,
		 9, 8, 5, 7, 8, 0, 9, 9, 0, 8, 9, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 5, 9, 9, 0, 8, 8, 0, 8, 8, 5, 8, 9,
		 0, 8, 8, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5,
		 9, 9, 0, 8, 8, 0, 8, 8, 5, 8, 9, 0, 8, 8, 0, 8,
		 8,
};

static const static_codebook _44c7_s_p1_0 = {
		4, 81,
		(long *)_vq_lengthlist__44c7_s_p1_0,
		1, -535822336, 1611661312, 2, 0,
		(long *)_vq_quantlist__44c7_s_p1_0,
		0
};

static const long _vq_quantlist__44c7_s_p2_0[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__44c7_s_p2_0[] = {
		 3, 5, 5, 8, 8, 0, 5, 5, 8, 8, 0, 5, 5, 8, 8, 0,
		 7, 7, 9, 9, 0, 0, 0, 9, 9, 5, 7, 7, 9, 9, 0, 8,
		 8,10,10, 0, 8, 7,10, 9, 0,10,10,11,11, 0, 0, 0,
		11,11, 5, 7, 7, 9, 9, 0, 8, 8,10,10, 0, 7, 8, 9,
		10, 0,10,10,11,11, 0, 0, 0,11,11, 8, 9, 9,11,10,
		 0,11,11,12,12, 0,11,10,12,12, 0,13,14,14,14, 0,
		 0, 0,14,13, 8, 9, 9,10,11, 0,11,11,12,12, 0,10,
		11,12,12, 0,13,13,14,14, 0, 0, 0,13,14, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 5, 8, 7,11,10, 0, 7, 7,10,10,
		 0, 7, 7,10,10, 0, 9, 9,11,10, 0, 0, 0,11,11, 5,
		 7, 8,10,11, 0, 7, 7,10,10, 0, 7, 7,10,10, 0, 9,
		 9,10,11, 0, 0, 0,11,11, 8,10, 9,12,12, 0,10,10,
		12,12, 0,10,10,12,12, 0,12,12,13,13, 0, 0, 0,13,
		13, 8, 9,10,12,12, 0,10,10,12,12, 0,10,10,11,12,
		 0,12,12,13,13, 0, 0, 0,13,13, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 5, 8, 8,11,11, 0, 7, 7,10,10, 0, 7, 7,
		10,10, 0, 9, 9,10,11, 0, 0, 0,11,10, 5, 8, 8,10,
		11, 0, 7, 7,10,10, 0, 7, 7,10,10, 0, 9, 9,11,10,
		 0, 0, 0,10,11, 9,10,10,12,12, 0,10,10,12,12, 0,
		10,10,12,12, 0,12,13,13,13, 0, 0, 0,13,12, 9,10,
		10,12,12, 0,10,10,12,12, 0,10,10,12,12, 0,13,12,
		13,13, 0, 0, 0,12,13, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 7,10,10,14,13, 0, 9, 9,12,12, 0, 9, 9,12,12, 0,
		10,10,12,12, 0, 0, 0,12,12, 7,10,10,13,14, 0, 9,
		 9,12,13, 0, 9, 9,12,12, 0,10,10,12,12, 0, 0, 0,
		12,12, 9,11,11,14,13, 0,11,10,13,12, 0,11,11,13,
		13, 0,12,12,13,13, 0, 0, 0,13,13, 9,11,11,13,14,
		 0,10,11,12,13, 0,11,11,13,13, 0,12,12,13,13, 0,
		 0, 0,13,13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9,
		11,11,14,14, 0,10,11,13,13, 0,11,10,13,13, 0,12,
		12,13,13, 0, 0, 0,13,12, 9,11,11,14,14, 0,11,10,
		13,13, 0,10,11,13,13, 0,12,12,14,13, 0, 0, 0,13,
		13,
};

static const static_codebook _44c7_s_p2_0 = {
		4, 625,
		(long *)_vq_lengthlist__44c7_s_p2_0,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__44c7_s_p2_0,
		0
};

static const long _vq_quantlist__44c7_s_p3_0[] = {
		4,
		3,
		5,
		2,
		6,
		1,
		7,
		0,
		8,
};

static const long _vq_lengthlist__44c7_s_p3_0[] = {
		 2, 4, 4, 5, 5, 7, 7, 9, 9, 0, 4, 4, 6, 6, 7, 7,
		 9, 9, 0, 4, 4, 6, 6, 7, 7, 9, 9, 0, 5, 5, 6, 6,
		 8, 8,10,10, 0, 0, 0, 6, 6, 8, 8,10,10, 0, 0, 0,
		 7, 7, 9, 9,10,10, 0, 0, 0, 7, 7, 8, 8,10,10, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0,
};

static const static_codebook _44c7_s_p3_0 = {
		2, 81,
		(long *)_vq_lengthlist__44c7_s_p3_0,
		1, -531628032, 1611661312, 4, 0,
		(long *)_vq_quantlist__44c7_s_p3_0,
		0
};

static const long _vq_quantlist__44c7_s_p4_0[] = {
		8,
		7,
		9,
		6,
		10,
		5,
		11,
		4,
		12,
		3,
		13,
		2,
		14,
		1,
		15,
		0,
		16,
};

static const long _vq_lengthlist__44c7_s_p4_0[] = {
		 3, 4, 4, 5, 5, 7, 7, 8, 8, 8, 8, 9, 9,10,10,11,
		11, 0, 4, 4, 6, 6, 7, 7, 8, 8, 9, 9,10,10,11,11,
		12,12, 0, 4, 4, 6, 6, 7, 7, 8, 8, 9, 9,10,10,11,
		11,12,12, 0, 5, 5, 6, 6, 8, 8, 9, 9, 9, 9,10,10,
		11,12,12,12, 0, 0, 0, 6, 6, 8, 7, 9, 9, 9, 9,10,
		10,11,11,12,12, 0, 0, 0, 7, 7, 8, 8, 9, 9,10,10,
		11,11,12,12,13,12, 0, 0, 0, 7, 7, 8, 8, 9, 9,10,
		10,11,11,12,12,12,13, 0, 0, 0, 7, 7, 8, 8, 9, 9,
		10,10,11,11,12,12,13,13, 0, 0, 0, 0, 0, 8, 8, 9,
		 9,10,10,11,11,12,12,13,13, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0,
};

static const static_codebook _44c7_s_p4_0 = {
		2, 289,
		(long *)_vq_lengthlist__44c7_s_p4_0,
		1, -529530880, 1611661312, 5, 0,
		(long *)_vq_quantlist__44c7_s_p4_0,
		0
};

static const long _vq_quantlist__44c7_s_p5_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__44c7_s_p5_0[] = {
		 1, 4, 4, 5, 7, 7, 6, 7, 7, 4, 6, 7,10,10,10,10,
		10, 9, 4, 6, 6,10,10,10,10, 9,10, 5,10,10, 9,11,
		12,10,11,12, 7,10,10,11,12,12,12,12,12, 7,10,10,
		11,12,12,12,12,12, 6,10,10,10,12,12,11,12,12, 7,
		10,10,12,12,12,12,11,12, 7,10,10,11,12,12,12,12,
		12,
};

static const static_codebook _44c7_s_p5_0 = {
		4, 81,
		(long *)_vq_lengthlist__44c7_s_p5_0,
		1, -529137664, 1618345984, 2, 0,
		(long *)_vq_quantlist__44c7_s_p5_0,
		0
};

static const long _vq_quantlist__44c7_s_p5_1[] = {
		5,
		4,
		6,
		3,
		7,
		2,
		8,
		1,
		9,
		0,
		10,
};

static const long _vq_lengthlist__44c7_s_p5_1[] = {
		 3, 5, 5, 6, 6, 7, 7, 8, 8, 8, 8,11, 4, 4, 6, 6,
		 7, 7, 8, 8, 9, 9,11, 4, 4, 6, 6, 7, 7, 8, 8, 9,
		 9,12, 5, 5, 6, 6, 7, 7, 9, 9, 9, 9,12,12,12, 6,
		 6, 7, 7, 9, 9, 9, 9,11,11,11, 7, 7, 7, 7, 8, 8,
		 9, 9,11,11,11, 7, 7, 7, 7, 8, 8, 9, 9,11,11,11,
		 7, 7, 8, 8, 8, 8, 9, 9,11,11,11,11,11, 8, 8, 8,
		 8, 8, 9,11,11,11,11,11, 8, 8, 8, 8, 8, 8,11,11,
		11,11,11, 7, 7, 8, 8, 8, 8,
};

static const static_codebook _44c7_s_p5_1 = {
		2, 121,
		(long *)_vq_lengthlist__44c7_s_p5_1,
		1, -531365888, 1611661312, 4, 0,
		(long *)_vq_quantlist__44c7_s_p5_1,
		0
};

static const long _vq_quantlist__44c7_s_p6_0[] = {
		6,
		5,
		7,
		4,
		8,
		3,
		9,
		2,
		10,
		1,
		11,
		0,
		12,
};

static const long _vq_lengthlist__44c7_s_p6_0[] = {
		 1, 4, 4, 6, 6, 7, 7, 8, 7, 9, 8,10,10, 6, 5, 5,
		 7, 7, 8, 8, 9, 9, 9,10,11,11, 7, 5, 5, 7, 7, 8,
		 8, 9, 9,10,10,11,11, 0, 7, 7, 7, 7, 9, 8, 9, 9,
		10,10,11,11, 0, 8, 8, 7, 7, 8, 9, 9, 9,10,10,11,
		11, 0,11,11, 9, 9,10,10,11,10,11,11,12,12, 0,12,
		12, 9, 9,10,10,11,11,11,11,12,12, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0,
};

static const static_codebook _44c7_s_p6_0 = {
		2, 169,
		(long *)_vq_lengthlist__44c7_s_p6_0,
		1, -526516224, 1616117760, 4, 0,
		(long *)_vq_quantlist__44c7_s_p6_0,
		0
};

static const long _vq_quantlist__44c7_s_p6_1[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__44c7_s_p6_1[] = {
		 3, 4, 4, 5, 5, 5, 4, 4, 5, 5, 5, 4, 4, 5, 5, 6,
		 5, 5, 5, 5, 6, 6, 6, 5, 5,
};

static const static_codebook _44c7_s_p6_1 = {
		2, 25,
		(long *)_vq_lengthlist__44c7_s_p6_1,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__44c7_s_p6_1,
		0
};

static const long _vq_quantlist__44c7_s_p7_0[] = {
		6,
		5,
		7,
		4,
		8,
		3,
		9,
		2,
		10,
		1,
		11,
		0,
		12,
};

static const long _vq_lengthlist__44c7_s_p7_0[] = {
		 1, 4, 4, 6, 6, 7, 8, 9, 9,10,10,12,11, 6, 5, 5,
		 7, 7, 8, 8, 9,10,11,11,12,12, 7, 5, 5, 7, 7, 8,
		 8,10,10,11,11,12,12,20, 7, 7, 7, 7, 8, 9,10,10,
		11,11,12,13,20, 7, 7, 7, 7, 9, 9,10,10,11,12,13,
		13,20,11,11, 8, 8, 9, 9,11,11,12,12,13,13,20,11,
		11, 8, 8, 9, 9,11,11,12,12,13,13,20,20,20,10,10,
		10,10,12,12,13,13,13,13,20,20,20,10,10,10,10,12,
		12,13,13,13,14,20,20,20,14,14,11,11,12,12,13,13,
		14,14,20,20,20,14,14,11,11,12,12,13,13,14,14,20,
		20,20,20,19,13,13,13,13,14,14,15,14,19,19,19,19,
		19,13,13,13,13,14,14,15,15,
};

static const static_codebook _44c7_s_p7_0 = {
		2, 169,
		(long *)_vq_lengthlist__44c7_s_p7_0,
		1, -523206656, 1618345984, 4, 0,
		(long *)_vq_quantlist__44c7_s_p7_0,
		0
};

static const long _vq_quantlist__44c7_s_p7_1[] = {
		5,
		4,
		6,
		3,
		7,
		2,
		8,
		1,
		9,
		0,
		10,
};

static const long _vq_lengthlist__44c7_s_p7_1[] = {
		 4, 5, 5, 6, 6, 7, 7, 7, 7, 7, 7, 8, 6, 6, 7, 7,
		 7, 7, 7, 7, 7, 7, 8, 6, 6, 6, 7, 7, 7, 7, 7, 7,
		 7, 8, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 7,
		 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 7, 7, 7, 7, 7, 7,
		 7, 7, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8,
		 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 7, 7, 7,
		 7, 7, 7, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 8, 8,
		 8, 8, 8, 7, 7, 7, 7, 7, 7,
};

static const static_codebook _44c7_s_p7_1 = {
		2, 121,
		(long *)_vq_lengthlist__44c7_s_p7_1,
		1, -531365888, 1611661312, 4, 0,
		(long *)_vq_quantlist__44c7_s_p7_1,
		0
};

static const long _vq_quantlist__44c7_s_p8_0[] = {
		7,
		6,
		8,
		5,
		9,
		4,
		10,
		3,
		11,
		2,
		12,
		1,
		13,
		0,
		14,
};

static const long _vq_lengthlist__44c7_s_p8_0[] = {
		 1, 4, 4, 7, 7, 8, 8, 8, 7, 9, 8, 9, 9,10,10, 6,
		 5, 5, 7, 7, 9, 9, 8, 8,10, 9,11,10,12,11, 6, 5,
		 5, 8, 7, 9, 9, 8, 8,10,10,11,11,12,11,19, 8, 8,
		 8, 8,10,10, 9, 9,10,10,11,11,12,11,19, 8, 8, 8,
		 8,10,10, 9, 9,10,10,11,11,12,12,19,12,12, 9, 9,
		10,10, 9,10,10,10,11,11,12,12,19,12,12, 9, 9,10,
		10,10,10,10,10,12,12,12,12,19,19,19, 9, 9, 9, 9,
		11,10,11,11,12,11,13,13,19,19,19, 9, 9, 9, 9,11,
		10,11,11,11,12,13,13,19,19,19,13,13,10,10,11,11,
		12,12,12,12,13,12,19,19,19,14,13,10,10,11,11,12,
		12,12,13,13,13,19,19,19,19,19,12,12,12,11,12,13,
		14,13,13,13,19,19,19,19,19,12,12,12,11,12,12,13,
		14,13,14,19,19,19,19,19,16,16,12,13,12,13,13,14,
		15,14,19,18,18,18,18,16,15,12,11,12,11,14,12,14,
		14,
};

static const static_codebook _44c7_s_p8_0 = {
		2, 225,
		(long *)_vq_lengthlist__44c7_s_p8_0,
		1, -520986624, 1620377600, 4, 0,
		(long *)_vq_quantlist__44c7_s_p8_0,
		0
};

static const long _vq_quantlist__44c7_s_p8_1[] = {
		10,
		9,
		11,
		8,
		12,
		7,
		13,
		6,
		14,
		5,
		15,
		4,
		16,
		3,
		17,
		2,
		18,
		1,
		19,
		0,
		20,
};

static const long _vq_lengthlist__44c7_s_p8_1[] = {
		 3, 5, 5, 7, 6, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8,
		 8, 8, 8, 8, 8,10, 6, 6, 7, 7, 8, 8, 8, 8, 9, 9,
		 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,10, 6, 6, 7, 7, 8,
		 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,10,
		 7, 7, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
		 9, 9, 9, 9,10,10,10, 8, 8, 8, 8, 9, 9, 9, 9, 9,
		 9, 9, 9, 9, 9, 9, 9, 9, 9,10,10,10, 8, 8, 8, 9,
		 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,10,10,
		10, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
		 9, 9, 9,10,10,10, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
		 9, 9, 9, 9, 9, 9, 9, 9,10,11,10,10,10, 9, 9, 9,
		 9, 9, 9, 9, 9, 9, 9,10, 9, 9,10, 9, 9,10,11,10,
		11,10, 9, 9, 9, 9, 9, 9, 9,10,10,10, 9,10, 9, 9,
		 9, 9,11,10,11,10,10, 9, 9, 9, 9, 9, 9,10, 9, 9,
		10, 9, 9,10, 9, 9,10,11,10,10,11,10, 9, 9, 9, 9,
		 9,10,10, 9,10,10,10,10, 9,10,10,10,10,10,10,11,
		11,11,10, 9, 9, 9,10,10,10,10,10,10,10,10,10,10,
		10,10,10,11,11,10,10,10,10,10,10,10,10,10,10,10,
		10, 9,10,10, 9,10,11,11,10,11,10,11,10, 9,10,10,
		 9,10,10,10,10,10,10,10,10,10,10,11,11,11,11,10,
		11,11,10,10,10,10,10,10, 9,10, 9,10,10, 9,10, 9,
		10,10,10,11,10,11,10,11,11,10,10,10,10,10,10, 9,
		10,10,10,10,10,10,10,11,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,11,10,11,
		11,10,10,10,10, 9, 9,10,10, 9, 9,10, 9,10,10,10,
		10,11,11,10,10,10,10,10,10,10, 9, 9,10,10,10, 9,
		 9,10,10,10,10,10,11,10,11,10,10,10,10,10,10, 9,
		10,10,10,10,10,10,10,10,10,
};

static const static_codebook _44c7_s_p8_1 = {
		2, 441,
		(long *)_vq_lengthlist__44c7_s_p8_1,
		1, -529268736, 1611661312, 5, 0,
		(long *)_vq_quantlist__44c7_s_p8_1,
		0
};

static const long _vq_quantlist__44c7_s_p9_0[] = {
		6,
		5,
		7,
		4,
		8,
		3,
		9,
		2,
		10,
		1,
		11,
		0,
		12,
};

static const long _vq_lengthlist__44c7_s_p9_0[] = {
		 1, 3, 3,11,11,11,11,11,11,11,11,11,11, 4, 6, 6,
		11,11,11,11,11,11,11,11,11,11, 4, 7, 7,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,
};

static const static_codebook _44c7_s_p9_0 = {
		2, 169,
		(long *)_vq_lengthlist__44c7_s_p9_0,
		1, -511845376, 1630791680, 4, 0,
		(long *)_vq_quantlist__44c7_s_p9_0,
		0
};

static const long _vq_quantlist__44c7_s_p9_1[] = {
		6,
		5,
		7,
		4,
		8,
		3,
		9,
		2,
		10,
		1,
		11,
		0,
		12,
};

static const long _vq_lengthlist__44c7_s_p9_1[] = {
		 1, 4, 4, 7, 7, 7, 7, 7, 6, 8, 8, 8, 8, 6, 6, 6,
		 8, 8, 9, 8, 8, 7, 9, 8,11,10, 5, 6, 6, 8, 8, 9,
		 8, 8, 8,10, 9,11,11,16, 8, 8, 9, 8, 9, 9, 9, 8,
		10, 9,11,10,16, 8, 8, 9, 9,10,10, 9, 9,10,10,11,
		11,16,13,13, 9, 9,10,10, 9,10,11,11,12,11,16,13,
		13, 9, 8,10, 9,10,10,10,10,11,11,16,14,16, 8, 9,
		 9, 9,11,10,11,11,12,11,16,16,16, 9, 7,10, 7,11,
		10,11,11,12,11,16,16,16,12,12, 9,10,11,11,12,11,
		12,12,16,16,16,12,10,10, 7,11, 8,12,11,12,12,16,
		16,15,16,16,11,12,10,10,12,11,12,12,16,16,16,15,
		15,11,11,10,10,12,12,12,12,
};

static const static_codebook _44c7_s_p9_1 = {
		2, 169,
		(long *)_vq_lengthlist__44c7_s_p9_1,
		1, -518889472, 1622704128, 4, 0,
		(long *)_vq_quantlist__44c7_s_p9_1,
		0
};

static const long _vq_quantlist__44c7_s_p9_2[] = {
		24,
		23,
		25,
		22,
		26,
		21,
		27,
		20,
		28,
		19,
		29,
		18,
		30,
		17,
		31,
		16,
		32,
		15,
		33,
		14,
		34,
		13,
		35,
		12,
		36,
		11,
		37,
		10,
		38,
		9,
		39,
		8,
		40,
		7,
		41,
		6,
		42,
		5,
		43,
		4,
		44,
		3,
		45,
		2,
		46,
		1,
		47,
		0,
		48,
};

static const long _vq_lengthlist__44c7_s_p9_2[] = {
		 2, 4, 3, 4, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6,
		 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
		 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
		 7,
};

static const static_codebook _44c7_s_p9_2 = {
		1, 49,
		(long *)_vq_lengthlist__44c7_s_p9_2,
		1, -526909440, 1611661312, 6, 0,
		(long *)_vq_quantlist__44c7_s_p9_2,
		0
};

static const long _huff_lengthlist__44c7_s_short[] = {
		 4,11,12,14,15,15,17,17,18,18, 5, 6, 6, 8, 9,10,
		13,17,18,19, 7, 5, 4, 6, 8, 9,11,15,19,19, 8, 6,
		 5, 5, 6, 7,11,14,16,17, 9, 7, 7, 6, 7, 7,10,13,
		15,19,10, 8, 7, 6, 7, 6, 7, 9,14,16,12,10, 9, 7,
		 7, 6, 4, 5,10,15,14,13,11, 7, 6, 6, 4, 2, 7,13,
		16,16,15, 9, 8, 8, 8, 6, 9,13,19,19,17,12,11,10,
		10, 9,11,14,
};

static const static_codebook _huff_book__44c7_s_short = {
		2, 100,
		(long *)_huff_lengthlist__44c7_s_short,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist__44c8_s_long[] = {
		 3, 8,12,13,14,14,14,13,14,14, 6, 4, 5, 8,10,10,
		11,11,14,13, 9, 5, 4, 5, 7, 8, 9,10,13,13,12, 7,
		 5, 4, 5, 6, 8, 9,12,13,13, 9, 6, 5, 5, 5, 7, 9,
		11,14,12,10, 7, 6, 5, 4, 6, 7,10,11,12,11, 9, 8,
		 7, 5, 5, 6,10,10,13,12,10, 9, 8, 6, 6, 5, 8,10,
		14,13,12,12,11,10, 9, 7, 8,10,12,13,14,14,13,12,
		11, 9, 9,10,
};

static const static_codebook _huff_book__44c8_s_long = {
		2, 100,
		(long *)_huff_lengthlist__44c8_s_long,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _vq_quantlist__44c8_s_p1_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__44c8_s_p1_0[] = {
		 1, 5, 5, 0, 5, 5, 0, 5, 5, 5, 7, 7, 0, 9, 8, 0,
		 9, 8, 6, 7, 7, 0, 8, 9, 0, 8, 9, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 5, 9, 8, 0, 8, 8, 0, 8, 8, 5, 8, 9,
		 0, 8, 8, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5,
		 9, 8, 0, 8, 8, 0, 8, 8, 5, 8, 9, 0, 8, 8, 0, 8,
		 8,
};

static const static_codebook _44c8_s_p1_0 = {
		4, 81,
		(long *)_vq_lengthlist__44c8_s_p1_0,
		1, -535822336, 1611661312, 2, 0,
		(long *)_vq_quantlist__44c8_s_p1_0,
		0
};

static const long _vq_quantlist__44c8_s_p2_0[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__44c8_s_p2_0[] = {
		 3, 5, 5, 8, 8, 0, 5, 5, 8, 8, 0, 5, 5, 8, 8, 0,
		 7, 7, 9, 9, 0, 0, 0, 9, 9, 5, 7, 7, 9, 9, 0, 8,
		 7,10, 9, 0, 8, 7,10, 9, 0,10,10,11,11, 0, 0, 0,
		11,11, 5, 7, 7, 9, 9, 0, 7, 8, 9,10, 0, 7, 8, 9,
		10, 0,10,10,11,11, 0, 0, 0,11,11, 8, 9, 9,11,10,
		 0,11,10,12,11, 0,11,10,12,12, 0,13,13,14,14, 0,
		 0, 0,14,13, 8, 9, 9,10,11, 0,10,11,12,12, 0,10,
		11,12,12, 0,13,13,14,14, 0, 0, 0,13,14, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 5, 8, 7,11,10, 0, 7, 7,10,10,
		 0, 7, 7,10,10, 0, 9, 9,10,10, 0, 0, 0,11,10, 5,
		 7, 8,10,11, 0, 7, 7,10,10, 0, 7, 7,10,10, 0, 9,
		 9,10,10, 0, 0, 0,10,10, 8,10, 9,12,12, 0,10,10,
		12,11, 0,10,10,12,12, 0,12,12,13,12, 0, 0, 0,13,
		12, 8, 9,10,12,12, 0,10,10,11,12, 0,10,10,11,12,
		 0,12,12,13,13, 0, 0, 0,12,13, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 6, 8, 7,11,10, 0, 7, 7,10,10, 0, 7, 7,
		10,10, 0, 9, 9,10,11, 0, 0, 0,10,10, 6, 7, 8,10,
		11, 0, 7, 7,10,10, 0, 7, 7,10,10, 0, 9, 9,10,10,
		 0, 0, 0,10,10, 9,10, 9,12,12, 0,10,10,12,12, 0,
		10,10,12,11, 0,12,12,13,13, 0, 0, 0,13,12, 8, 9,
		10,12,12, 0,10,10,12,12, 0,10,10,11,12, 0,12,12,
		13,13, 0, 0, 0,12,13, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 7,10,10,13,13, 0, 9, 9,12,12, 0, 9, 9,12,12, 0,
		10,10,12,12, 0, 0, 0,12,12, 7,10,10,13,13, 0, 9,
		 9,12,12, 0, 9, 9,12,12, 0,10,10,12,12, 0, 0, 0,
		12,12, 9,11,11,14,13, 0,10,10,13,12, 0,11,10,13,
		12, 0,12,12,13,12, 0, 0, 0,13,13, 9,11,11,13,14,
		 0,10,11,12,13, 0,10,11,13,13, 0,12,12,12,13, 0,
		 0, 0,13,13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9,
		11,11,14,14, 0,10,11,13,13, 0,11,10,13,13, 0,11,
		12,13,13, 0, 0, 0,13,12, 9,11,11,14,14, 0,11,10,
		13,13, 0,10,11,13,13, 0,12,12,13,13, 0, 0, 0,12,
		13,
};

static const static_codebook _44c8_s_p2_0 = {
		4, 625,
		(long *)_vq_lengthlist__44c8_s_p2_0,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__44c8_s_p2_0,
		0
};

static const long _vq_quantlist__44c8_s_p3_0[] = {
		4,
		3,
		5,
		2,
		6,
		1,
		7,
		0,
		8,
};

static const long _vq_lengthlist__44c8_s_p3_0[] = {
		 2, 4, 4, 5, 5, 7, 7, 9, 9, 0, 4, 4, 6, 6, 7, 7,
		 9, 9, 0, 4, 4, 6, 6, 7, 7, 9, 9, 0, 5, 5, 6, 6,
		 8, 8,10,10, 0, 0, 0, 6, 6, 8, 8,10,10, 0, 0, 0,
		 7, 7, 9, 9,10,10, 0, 0, 0, 7, 7, 8, 8,10,10, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0,
};

static const static_codebook _44c8_s_p3_0 = {
		2, 81,
		(long *)_vq_lengthlist__44c8_s_p3_0,
		1, -531628032, 1611661312, 4, 0,
		(long *)_vq_quantlist__44c8_s_p3_0,
		0
};

static const long _vq_quantlist__44c8_s_p4_0[] = {
		8,
		7,
		9,
		6,
		10,
		5,
		11,
		4,
		12,
		3,
		13,
		2,
		14,
		1,
		15,
		0,
		16,
};

static const long _vq_lengthlist__44c8_s_p4_0[] = {
		 3, 4, 4, 5, 5, 7, 7, 8, 8, 8, 8, 9, 9,10,10,11,
		11, 0, 4, 4, 6, 6, 7, 7, 8, 8, 9, 8,10,10,11,11,
		11,11, 0, 4, 4, 6, 6, 7, 7, 8, 8, 9, 9,10,10,11,
		11,11,11, 0, 6, 5, 6, 6, 7, 7, 9, 9, 9, 9,10,10,
		11,11,12,12, 0, 0, 0, 6, 6, 7, 7, 9, 9, 9, 9,10,
		10,11,11,12,12, 0, 0, 0, 7, 7, 8, 8, 9, 9,10,10,
		11,11,11,12,12,12, 0, 0, 0, 7, 7, 8, 8, 9, 9,10,
		10,11,11,11,12,12,12, 0, 0, 0, 7, 7, 8, 8, 9, 9,
		10,10,11,11,12,12,13,13, 0, 0, 0, 0, 0, 8, 8, 9,
		 9,10,10,11,11,12,12,13,13, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0,
};

static const static_codebook _44c8_s_p4_0 = {
		2, 289,
		(long *)_vq_lengthlist__44c8_s_p4_0,
		1, -529530880, 1611661312, 5, 0,
		(long *)_vq_quantlist__44c8_s_p4_0,
		0
};

static const long _vq_quantlist__44c8_s_p5_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__44c8_s_p5_0[] = {
		 1, 4, 4, 5, 7, 7, 6, 7, 7, 4, 7, 6,10,10,10,10,
		10,10, 4, 6, 6,10,10,10,10, 9,10, 5,10,10, 9,11,
		11,10,11,11, 7,10,10,11,12,12,12,12,12, 7,10,10,
		11,12,12,12,12,12, 6,10,10,10,12,12,10,12,12, 7,
		10,10,11,12,12,12,12,12, 7,10,10,11,12,12,12,12,
		12,
};

static const static_codebook _44c8_s_p5_0 = {
		4, 81,
		(long *)_vq_lengthlist__44c8_s_p5_0,
		1, -529137664, 1618345984, 2, 0,
		(long *)_vq_quantlist__44c8_s_p5_0,
		0
};

static const long _vq_quantlist__44c8_s_p5_1[] = {
		5,
		4,
		6,
		3,
		7,
		2,
		8,
		1,
		9,
		0,
		10,
};

static const long _vq_lengthlist__44c8_s_p5_1[] = {
		 3, 5, 5, 6, 6, 7, 7, 8, 8, 8, 8,11, 4, 5, 6, 6,
		 7, 7, 8, 8, 8, 8,11, 5, 5, 6, 6, 7, 7, 8, 8, 8,
		 9,12, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9,12,12,12, 6,
		 6, 7, 7, 8, 8, 9, 9,11,11,11, 6, 6, 7, 7, 8, 8,
		 8, 8,11,11,11, 6, 6, 7, 7, 8, 8, 8, 8,11,11,11,
		 7, 7, 7, 8, 8, 8, 8, 8,11,11,11,11,11, 7, 7, 8,
		 8, 8, 8,11,11,11,11,11, 7, 7, 7, 7, 8, 8,11,11,
		11,11,11, 7, 7, 7, 7, 8, 8,
};

static const static_codebook _44c8_s_p5_1 = {
		2, 121,
		(long *)_vq_lengthlist__44c8_s_p5_1,
		1, -531365888, 1611661312, 4, 0,
		(long *)_vq_quantlist__44c8_s_p5_1,
		0
};

static const long _vq_quantlist__44c8_s_p6_0[] = {
		6,
		5,
		7,
		4,
		8,
		3,
		9,
		2,
		10,
		1,
		11,
		0,
		12,
};

static const long _vq_lengthlist__44c8_s_p6_0[] = {
		 1, 4, 4, 6, 6, 7, 7, 8, 8, 9, 9,10,10, 6, 5, 5,
		 7, 7, 8, 8, 9, 9,10,10,11,11, 6, 5, 5, 7, 7, 8,
		 8, 9, 9,10,10,11,11, 0, 7, 7, 7, 7, 9, 9,10,10,
		10,10,11,11, 0, 7, 7, 7, 7, 9, 9,10,10,10,10,11,
		11, 0,11,11, 9, 9,10,10,11,11,11,11,12,12, 0,12,
		12, 9, 9,10,10,11,11,12,12,12,12, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0,
};

static const static_codebook _44c8_s_p6_0 = {
		2, 169,
		(long *)_vq_lengthlist__44c8_s_p6_0,
		1, -526516224, 1616117760, 4, 0,
		(long *)_vq_quantlist__44c8_s_p6_0,
		0
};

static const long _vq_quantlist__44c8_s_p6_1[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__44c8_s_p6_1[] = {
		 3, 4, 4, 5, 5, 5, 4, 4, 5, 5, 5, 4, 4, 5, 5, 6,
		 5, 5, 5, 5, 6, 6, 6, 5, 5,
};

static const static_codebook _44c8_s_p6_1 = {
		2, 25,
		(long *)_vq_lengthlist__44c8_s_p6_1,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__44c8_s_p6_1,
		0
};

static const long _vq_quantlist__44c8_s_p7_0[] = {
		6,
		5,
		7,
		4,
		8,
		3,
		9,
		2,
		10,
		1,
		11,
		0,
		12,
};

static const long _vq_lengthlist__44c8_s_p7_0[] = {
		 1, 4, 4, 6, 6, 8, 7, 9, 9,10,10,12,12, 6, 5, 5,
		 7, 7, 8, 8,10,10,11,11,12,12, 7, 5, 5, 7, 7, 8,
		 8,10,10,11,11,12,12,21, 7, 7, 7, 7, 8, 9,10,10,
		11,11,12,12,21, 7, 7, 7, 7, 9, 9,10,10,12,12,13,
		13,21,11,11, 8, 8, 9, 9,11,11,12,12,13,13,21,11,
		11, 8, 8, 9, 9,11,11,12,12,13,13,21,21,21,10,10,
		10,10,11,11,12,13,13,13,21,21,21,10,10,10,10,11,
		11,13,13,14,13,21,21,21,13,13,11,11,12,12,13,13,
		14,14,21,21,21,14,14,11,11,12,12,13,13,14,14,21,
		21,21,21,20,13,13,13,12,14,14,16,15,20,20,20,20,
		20,13,13,13,13,14,13,15,15,
};

static const static_codebook _44c8_s_p7_0 = {
		2, 169,
		(long *)_vq_lengthlist__44c8_s_p7_0,
		1, -523206656, 1618345984, 4, 0,
		(long *)_vq_quantlist__44c8_s_p7_0,
		0
};

static const long _vq_quantlist__44c8_s_p7_1[] = {
		5,
		4,
		6,
		3,
		7,
		2,
		8,
		1,
		9,
		0,
		10,
};

static const long _vq_lengthlist__44c8_s_p7_1[] = {
		 4, 5, 6, 6, 6, 7, 7, 7, 7, 7, 7, 8, 6, 6, 6, 7,
		 7, 7, 7, 7, 7, 7, 8, 6, 6, 6, 6, 7, 7, 7, 7, 7,
		 7, 8, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 7,
		 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 7, 7, 7, 7, 7, 7,
		 7, 7, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8,
		 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 7, 7, 7,
		 7, 7, 7, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 8, 8,
		 8, 8, 8, 7, 7, 7, 7, 7, 7,
};

static const static_codebook _44c8_s_p7_1 = {
		2, 121,
		(long *)_vq_lengthlist__44c8_s_p7_1,
		1, -531365888, 1611661312, 4, 0,
		(long *)_vq_quantlist__44c8_s_p7_1,
		0
};

static const long _vq_quantlist__44c8_s_p8_0[] = {
		7,
		6,
		8,
		5,
		9,
		4,
		10,
		3,
		11,
		2,
		12,
		1,
		13,
		0,
		14,
};

static const long _vq_lengthlist__44c8_s_p8_0[] = {
		 1, 4, 4, 7, 6, 8, 8, 8, 7, 9, 8,10,10,11,10, 6,
		 5, 5, 7, 7, 9, 9, 8, 8,10,10,11,11,12,11, 6, 5,
		 5, 7, 7, 9, 9, 9, 9,10,10,11,11,12,12,20, 8, 8,
		 8, 8, 9, 9, 9, 9,10,10,11,11,12,12,20, 8, 8, 8,
		 8,10, 9, 9, 9,10,10,11,11,12,12,20,12,12, 9, 9,
		10,10,10,10,10,11,12,12,12,12,20,12,12, 9, 9,10,
		10,10,10,11,11,12,12,13,13,20,20,20, 9, 9, 9, 9,
		11,10,11,11,12,12,12,13,20,19,19, 9, 9, 9, 9,11,
		11,11,12,12,12,13,13,19,19,19,13,13,10,10,11,11,
		12,12,13,13,13,13,19,19,19,14,13,11,10,11,11,12,
		12,12,13,13,13,19,19,19,19,19,12,12,12,12,13,13,
		13,13,14,13,19,19,19,19,19,12,12,12,11,12,12,13,
		14,14,14,19,19,19,19,19,16,15,13,12,13,13,13,14,
		14,14,19,19,19,19,19,17,17,13,12,13,11,14,13,15,
		15,
};

static const static_codebook _44c8_s_p8_0 = {
		2, 225,
		(long *)_vq_lengthlist__44c8_s_p8_0,
		1, -520986624, 1620377600, 4, 0,
		(long *)_vq_quantlist__44c8_s_p8_0,
		0
};

static const long _vq_quantlist__44c8_s_p8_1[] = {
		10,
		9,
		11,
		8,
		12,
		7,
		13,
		6,
		14,
		5,
		15,
		4,
		16,
		3,
		17,
		2,
		18,
		1,
		19,
		0,
		20,
};

static const long _vq_lengthlist__44c8_s_p8_1[] = {
		 4, 5, 5, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8,
		 8, 8, 8, 8, 8,10, 6, 6, 7, 7, 8, 8, 8, 8, 9, 9,
		 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,10, 6, 6, 7, 7, 8,
		 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,10,
		 7, 7, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
		 9, 9, 9, 9,10,10,10, 8, 8, 8, 8, 9, 9, 9, 9, 9,
		 9, 9, 9, 9, 9, 9, 9, 9, 9,10,10,10, 8, 8, 8, 9,
		 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,10,10,
		10, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
		 9, 9, 9,10,10,10, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
		 9, 9, 9, 9, 9, 9, 9, 9,10,10,10,10,10, 9, 9, 9,
		 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,10,10,10,
		10,10, 9, 9, 9, 9, 9, 9, 9, 9,10, 9, 9, 9, 9, 9,
		 9, 9,10,10,10,10,10, 9, 9, 9, 9, 9, 9, 9, 9, 9,
		 9, 9, 9, 9, 9, 9, 9,10,10,10,10,10, 9, 9, 9, 9,
		 9, 9, 9, 9,10,10,10, 9, 9, 9, 9, 9,10,10,10,10,
		10,10,10, 9, 9, 9, 9, 9,10,10,10, 9, 9, 9, 9, 9,
		 9,10,10,10,10,10,10,10, 9,10,10, 9,10,10,10,10,
		 9,10, 9,10,10, 9,10,10,10,10,10,10,10, 9,10,10,
		10,10,10,10, 9, 9,10,10, 9,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10, 9, 9, 9,10, 9, 9, 9, 9,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10, 9, 9,
		10, 9,10, 9,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10, 9, 9,10, 9, 9, 9,10,10,10,10,10,10,
		10,10,10,10,10, 9, 9, 9, 9, 9, 9,10, 9, 9,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10, 9,10, 9,
		 9,10, 9, 9,10,10,10,10,10,10,10,10,10,10,10,10,
		10, 9, 9,10,10, 9,10, 9, 9,
};

static const static_codebook _44c8_s_p8_1 = {
		2, 441,
		(long *)_vq_lengthlist__44c8_s_p8_1,
		1, -529268736, 1611661312, 5, 0,
		(long *)_vq_quantlist__44c8_s_p8_1,
		0
};

static const long _vq_quantlist__44c8_s_p9_0[] = {
		8,
		7,
		9,
		6,
		10,
		5,
		11,
		4,
		12,
		3,
		13,
		2,
		14,
		1,
		15,
		0,
		16,
};

static const long _vq_lengthlist__44c8_s_p9_0[] = {
		 1, 4, 3,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11, 4, 7, 7,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11, 4, 8,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,
};

static const static_codebook _44c8_s_p9_0 = {
		2, 289,
		(long *)_vq_lengthlist__44c8_s_p9_0,
		1, -509798400, 1631393792, 5, 0,
		(long *)_vq_quantlist__44c8_s_p9_0,
		0
};

static const long _vq_quantlist__44c8_s_p9_1[] = {
		9,
		8,
		10,
		7,
		11,
		6,
		12,
		5,
		13,
		4,
		14,
		3,
		15,
		2,
		16,
		1,
		17,
		0,
		18,
};

static const long _vq_lengthlist__44c8_s_p9_1[] = {
		 1, 4, 4, 7, 6, 7, 7, 7, 7, 8, 8, 9, 9,10,10,10,
		10,11,11, 6, 6, 6, 8, 8, 9, 8, 8, 7,10, 8,11,10,
		12,11,12,12,13,13, 5, 5, 6, 8, 8, 9, 9, 8, 8,10,
		 9,11,11,12,12,13,13,13,13,17, 8, 8, 9, 9, 9, 9,
		 9, 9,10, 9,12,10,12,12,13,12,13,13,17, 9, 8, 9,
		 9, 9, 9, 9, 9,10,10,12,12,12,12,13,13,13,13,17,
		13,13, 9, 9,10,10,10,10,11,11,12,11,13,12,13,13,
		14,15,17,13,13, 9, 8,10, 9,10,10,11,11,12,12,14,
		13,15,13,14,15,17,17,17, 9,10, 9,10,11,11,12,12,
		12,12,13,13,14,14,15,15,17,17,17, 9, 8, 9, 8,11,
		11,12,12,12,12,14,13,14,14,14,15,17,17,17,12,14,
		 9,10,11,11,12,12,14,13,13,14,15,13,15,15,17,17,
		17,13,11,10, 8,11, 9,13,12,13,13,13,13,13,14,14,
		14,17,17,17,17,17,11,12,11,11,13,13,14,13,15,14,
		13,15,16,15,17,17,17,17,17,11,11,12, 8,13,12,14,
		13,17,14,15,14,15,14,17,17,17,17,17,15,15,12,12,
		12,12,13,14,14,14,15,14,17,14,17,17,17,17,17,16,
		17,12,12,13,12,13,13,14,14,14,14,14,14,17,17,17,
		17,17,17,17,14,14,13,12,13,13,15,15,14,13,15,17,
		17,17,17,17,17,17,17,13,14,13,13,13,13,14,15,15,
		15,14,15,17,17,17,17,17,17,17,16,15,13,14,13,13,
		14,14,15,14,14,16,17,17,17,17,17,17,17,16,16,13,
		14,13,13,14,14,15,14,15,14,
};

static const static_codebook _44c8_s_p9_1 = {
		2, 361,
		(long *)_vq_lengthlist__44c8_s_p9_1,
		1, -518287360, 1622704128, 5, 0,
		(long *)_vq_quantlist__44c8_s_p9_1,
		0
};

static const long _vq_quantlist__44c8_s_p9_2[] = {
		24,
		23,
		25,
		22,
		26,
		21,
		27,
		20,
		28,
		19,
		29,
		18,
		30,
		17,
		31,
		16,
		32,
		15,
		33,
		14,
		34,
		13,
		35,
		12,
		36,
		11,
		37,
		10,
		38,
		9,
		39,
		8,
		40,
		7,
		41,
		6,
		42,
		5,
		43,
		4,
		44,
		3,
		45,
		2,
		46,
		1,
		47,
		0,
		48,
};

static const long _vq_lengthlist__44c8_s_p9_2[] = {
		 2, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6,
		 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7,
		 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
		 7,
};

static const static_codebook _44c8_s_p9_2 = {
		1, 49,
		(long *)_vq_lengthlist__44c8_s_p9_2,
		1, -526909440, 1611661312, 6, 0,
		(long *)_vq_quantlist__44c8_s_p9_2,
		0
};

static const long _huff_lengthlist__44c8_s_short[] = {
		 4,11,13,14,15,15,18,17,19,17, 5, 6, 8, 9,10,10,
		12,15,19,19, 6, 6, 6, 6, 8, 8,11,14,18,19, 8, 6,
		 5, 4, 6, 7,10,13,16,17, 9, 7, 6, 5, 6, 7, 9,12,
		15,19,10, 8, 7, 6, 6, 6, 7, 9,13,15,12,10, 9, 8,
		 7, 6, 4, 5,10,15,13,13,11, 8, 6, 6, 4, 2, 7,12,
		17,15,16,10, 8, 8, 7, 6, 9,12,19,18,17,13,11,10,
		10, 9,11,14,
};

static const static_codebook _huff_book__44c8_s_short = {
		2, 100,
		(long *)_huff_lengthlist__44c8_s_short,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist__44c9_s_long[] = {
		 3, 8,12,14,15,15,15,13,15,15, 6, 5, 8,10,12,12,
		13,12,14,13,10, 6, 5, 6, 8, 9,11,11,13,13,13, 8,
		 5, 4, 5, 6, 8,10,11,13,14,10, 7, 5, 4, 5, 7, 9,
		11,12,13,11, 8, 6, 5, 4, 5, 7, 9,11,12,11,10, 8,
		 7, 5, 4, 5, 9,10,13,13,11,10, 8, 6, 5, 4, 7, 9,
		15,14,13,12,10, 9, 8, 7, 8, 9,12,12,14,13,12,11,
		10, 9, 8, 9,
};

static const static_codebook _huff_book__44c9_s_long = {
		2, 100,
		(long *)_huff_lengthlist__44c9_s_long,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _vq_quantlist__44c9_s_p1_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__44c9_s_p1_0[] = {
		 1, 5, 5, 0, 5, 5, 0, 5, 5, 6, 8, 8, 0, 9, 8, 0,
		 9, 8, 6, 8, 8, 0, 8, 9, 0, 8, 9, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 5, 8, 8, 0, 7, 7, 0, 8, 8, 5, 8, 8,
		 0, 7, 8, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5,
		 9, 8, 0, 8, 8, 0, 7, 7, 5, 8, 9, 0, 8, 8, 0, 7,
		 7,
};

static const static_codebook _44c9_s_p1_0 = {
		4, 81,
		(long *)_vq_lengthlist__44c9_s_p1_0,
		1, -535822336, 1611661312, 2, 0,
		(long *)_vq_quantlist__44c9_s_p1_0,
		0
};

static const long _vq_quantlist__44c9_s_p2_0[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__44c9_s_p2_0[] = {
		 3, 5, 5, 8, 8, 0, 5, 5, 8, 8, 0, 5, 5, 8, 8, 0,
		 7, 7, 9, 9, 0, 0, 0, 9, 9, 6, 7, 7, 9, 8, 0, 8,
		 8, 9, 9, 0, 8, 7, 9, 9, 0, 9,10,10,10, 0, 0, 0,
		11,10, 6, 7, 7, 8, 9, 0, 8, 8, 9, 9, 0, 7, 8, 9,
		 9, 0,10, 9,11,10, 0, 0, 0,10,10, 8, 9, 8,10,10,
		 0,10,10,12,11, 0,10,10,11,11, 0,12,13,13,13, 0,
		 0, 0,13,12, 8, 8, 9,10,10, 0,10,10,11,12, 0,10,
		10,11,11, 0,13,12,13,13, 0, 0, 0,13,13, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 6, 8, 7,10,10, 0, 7, 7,10, 9,
		 0, 7, 7,10,10, 0, 9, 9,10,10, 0, 0, 0,10,10, 6,
		 7, 8,10,10, 0, 7, 7, 9,10, 0, 7, 7,10,10, 0, 9,
		 9,10,10, 0, 0, 0,10,10, 8, 9, 9,11,11, 0,10,10,
		11,11, 0,10,10,11,11, 0,12,12,12,12, 0, 0, 0,12,
		12, 8, 9,10,11,11, 0, 9,10,11,11, 0,10,10,11,11,
		 0,12,12,12,12, 0, 0, 0,12,12, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 5, 8, 7,10,10, 0, 7, 7,10,10, 0, 7, 7,
		10, 9, 0, 9, 9,10,10, 0, 0, 0,10,10, 6, 7, 8,10,
		10, 0, 7, 7,10,10, 0, 7, 7, 9,10, 0, 9, 9,10,10,
		 0, 0, 0,10,10, 8,10, 9,12,11, 0,10,10,12,11, 0,
		10, 9,11,11, 0,11,12,12,12, 0, 0, 0,12,12, 8, 9,
		10,11,12, 0,10,10,11,11, 0, 9,10,11,11, 0,12,11,
		12,12, 0, 0, 0,12,12, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 7,10, 9,12,12, 0, 9, 9,12,11, 0, 9, 9,11,11, 0,
		10,10,12,11, 0, 0, 0,11,12, 7, 9,10,12,12, 0, 9,
		 9,11,12, 0, 9, 9,11,11, 0,10,10,11,12, 0, 0, 0,
		11,11, 9,11,10,13,12, 0,10,10,12,12, 0,10,10,12,
		12, 0,11,11,12,12, 0, 0, 0,13,12, 9,10,11,12,13,
		 0,10,10,12,12, 0,10,10,12,12, 0,11,12,12,12, 0,
		 0, 0,12,13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9,
		11,10,13,13, 0,10,10,12,12, 0,10,10,12,12, 0,11,
		12,12,12, 0, 0, 0,12,12, 9,10,11,13,13, 0,10,10,
		12,12, 0,10,10,12,12, 0,12,11,13,12, 0, 0, 0,12,
		12,
};

static const static_codebook _44c9_s_p2_0 = {
		4, 625,
		(long *)_vq_lengthlist__44c9_s_p2_0,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__44c9_s_p2_0,
		0
};

static const long _vq_quantlist__44c9_s_p3_0[] = {
		4,
		3,
		5,
		2,
		6,
		1,
		7,
		0,
		8,
};

static const long _vq_lengthlist__44c9_s_p3_0[] = {
		 3, 4, 4, 5, 5, 6, 6, 8, 8, 0, 4, 4, 5, 5, 6, 7,
		 8, 8, 0, 4, 4, 5, 5, 7, 7, 8, 8, 0, 5, 5, 6, 6,
		 7, 7, 9, 9, 0, 0, 0, 6, 6, 7, 7, 9, 9, 0, 0, 0,
		 7, 7, 8, 8, 9, 9, 0, 0, 0, 7, 7, 8, 8, 9, 9, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0,
};

static const static_codebook _44c9_s_p3_0 = {
		2, 81,
		(long *)_vq_lengthlist__44c9_s_p3_0,
		1, -531628032, 1611661312, 4, 0,
		(long *)_vq_quantlist__44c9_s_p3_0,
		0
};

static const long _vq_quantlist__44c9_s_p4_0[] = {
		8,
		7,
		9,
		6,
		10,
		5,
		11,
		4,
		12,
		3,
		13,
		2,
		14,
		1,
		15,
		0,
		16,
};

static const long _vq_lengthlist__44c9_s_p4_0[] = {
		 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9,10,10,10,
		10, 0, 5, 4, 5, 5, 7, 7, 8, 8, 8, 8, 9, 9,10,10,
		11,11, 0, 5, 5, 6, 6, 7, 7, 8, 8, 8, 8, 9, 9,10,
		10,11,11, 0, 6, 5, 6, 6, 7, 7, 8, 8, 9, 9,10,10,
		11,11,11,12, 0, 0, 0, 6, 6, 7, 7, 8, 8, 9, 9,10,
		10,11,11,12,12, 0, 0, 0, 7, 7, 7, 7, 9, 9, 9, 9,
		10,10,11,11,12,12, 0, 0, 0, 7, 7, 7, 8, 9, 9, 9,
		 9,10,10,11,11,12,12, 0, 0, 0, 7, 7, 8, 8, 9, 9,
		10,10,11,11,12,12,13,13, 0, 0, 0, 0, 0, 8, 8, 9,
		 9,10,10,11,11,12,12,12,12, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0,
};

static const static_codebook _44c9_s_p4_0 = {
		2, 289,
		(long *)_vq_lengthlist__44c9_s_p4_0,
		1, -529530880, 1611661312, 5, 0,
		(long *)_vq_quantlist__44c9_s_p4_0,
		0
};

static const long _vq_quantlist__44c9_s_p5_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__44c9_s_p5_0[] = {
		 1, 4, 4, 5, 7, 7, 6, 7, 7, 4, 7, 6, 9,10,10,10,
		10, 9, 4, 6, 7, 9,10,10,10, 9,10, 5, 9, 9, 9,11,
		11,10,11,11, 7,10, 9,11,12,11,12,12,12, 7, 9,10,
		11,11,12,12,12,12, 6,10,10,10,12,12,10,12,11, 7,
		10,10,11,12,12,11,12,12, 7,10,10,11,12,12,12,12,
		12,
};

static const static_codebook _44c9_s_p5_0 = {
		4, 81,
		(long *)_vq_lengthlist__44c9_s_p5_0,
		1, -529137664, 1618345984, 2, 0,
		(long *)_vq_quantlist__44c9_s_p5_0,
		0
};

static const long _vq_quantlist__44c9_s_p5_1[] = {
		5,
		4,
		6,
		3,
		7,
		2,
		8,
		1,
		9,
		0,
		10,
};

static const long _vq_lengthlist__44c9_s_p5_1[] = {
		 4, 5, 5, 6, 6, 7, 7, 7, 7, 7, 7,11, 5, 5, 6, 6,
		 7, 7, 7, 7, 8, 8,11, 5, 5, 6, 6, 7, 7, 7, 7, 8,
		 8,11, 5, 5, 6, 6, 7, 7, 8, 8, 8, 8,11,11,11, 6,
		 6, 7, 7, 7, 8, 8, 8,11,11,11, 6, 6, 7, 7, 7, 8,
		 8, 8,11,11,11, 6, 6, 7, 7, 7, 7, 8, 8,11,11,11,
		 7, 7, 7, 7, 7, 7, 8, 8,11,11,11,10,10, 7, 7, 7,
		 7, 8, 8,11,11,11,11,11, 7, 7, 7, 7, 7, 7,11,11,
		11,11,11, 7, 7, 7, 7, 7, 7,
};

static const static_codebook _44c9_s_p5_1 = {
		2, 121,
		(long *)_vq_lengthlist__44c9_s_p5_1,
		1, -531365888, 1611661312, 4, 0,
		(long *)_vq_quantlist__44c9_s_p5_1,
		0
};

static const long _vq_quantlist__44c9_s_p6_0[] = {
		6,
		5,
		7,
		4,
		8,
		3,
		9,
		2,
		10,
		1,
		11,
		0,
		12,
};

static const long _vq_lengthlist__44c9_s_p6_0[] = {
		 2, 4, 4, 6, 6, 7, 7, 7, 7, 8, 8, 9, 9, 5, 4, 4,
		 6, 6, 8, 8, 9, 9, 9, 9,10,10, 6, 4, 4, 6, 6, 8,
		 8, 9, 9, 9, 9,10,10, 0, 6, 6, 7, 7, 8, 8, 9, 9,
		10,10,11,11, 0, 6, 6, 7, 7, 8, 8, 9, 9,10,10,11,
		11, 0,10,10, 8, 8, 9, 9,10,10,11,11,12,12, 0,11,
		11, 8, 8, 9, 9,10,10,11,11,12,12, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0,
};

static const static_codebook _44c9_s_p6_0 = {
		2, 169,
		(long *)_vq_lengthlist__44c9_s_p6_0,
		1, -526516224, 1616117760, 4, 0,
		(long *)_vq_quantlist__44c9_s_p6_0,
		0
};

static const long _vq_quantlist__44c9_s_p6_1[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__44c9_s_p6_1[] = {
		 4, 4, 4, 5, 5, 5, 4, 4, 5, 5, 5, 4, 4, 5, 5, 5,
		 5, 5, 5, 5, 5, 5, 5, 5, 5,
};

static const static_codebook _44c9_s_p6_1 = {
		2, 25,
		(long *)_vq_lengthlist__44c9_s_p6_1,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__44c9_s_p6_1,
		0
};

static const long _vq_quantlist__44c9_s_p7_0[] = {
		6,
		5,
		7,
		4,
		8,
		3,
		9,
		2,
		10,
		1,
		11,
		0,
		12,
};

static const long _vq_lengthlist__44c9_s_p7_0[] = {
		 2, 4, 4, 6, 6, 7, 7, 8, 8,10,10,11,11, 6, 4, 4,
		 6, 6, 8, 8, 9, 9,10,10,12,12, 6, 4, 5, 6, 6, 8,
		 8, 9, 9,10,10,12,12,20, 6, 6, 6, 6, 8, 8, 9,10,
		11,11,12,12,20, 6, 6, 6, 6, 8, 8,10,10,11,11,12,
		12,20,10,10, 7, 7, 9, 9,10,10,11,11,12,12,20,11,
		11, 7, 7, 9, 9,10,10,11,11,12,12,20,20,20, 9, 9,
		 9, 9,11,11,12,12,13,13,20,20,20, 9, 9, 9, 9,11,
		11,12,12,13,13,20,20,20,13,13,10,10,11,11,12,13,
		13,13,20,20,20,13,13,10,10,11,11,12,13,13,13,20,
		20,20,20,19,12,12,12,12,13,13,14,15,19,19,19,19,
		19,12,12,12,12,13,13,14,14,
};

static const static_codebook _44c9_s_p7_0 = {
		2, 169,
		(long *)_vq_lengthlist__44c9_s_p7_0,
		1, -523206656, 1618345984, 4, 0,
		(long *)_vq_quantlist__44c9_s_p7_0,
		0
};

static const long _vq_quantlist__44c9_s_p7_1[] = {
		5,
		4,
		6,
		3,
		7,
		2,
		8,
		1,
		9,
		0,
		10,
};

static const long _vq_lengthlist__44c9_s_p7_1[] = {
		 5, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6,
		 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6, 7, 7, 7, 7, 7,
		 7, 8, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 8, 8, 8, 6,
		 6, 7, 7, 7, 7, 7, 7, 8, 8, 8, 7, 7, 7, 7, 7, 7,
		 7, 7, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8,
		 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 7, 7, 7,
		 7, 7, 7, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 8, 8,
		 8, 8, 8, 7, 7, 7, 7, 7, 7,
};

static const static_codebook _44c9_s_p7_1 = {
		2, 121,
		(long *)_vq_lengthlist__44c9_s_p7_1,
		1, -531365888, 1611661312, 4, 0,
		(long *)_vq_quantlist__44c9_s_p7_1,
		0
};

static const long _vq_quantlist__44c9_s_p8_0[] = {
		7,
		6,
		8,
		5,
		9,
		4,
		10,
		3,
		11,
		2,
		12,
		1,
		13,
		0,
		14,
};

static const long _vq_lengthlist__44c9_s_p8_0[] = {
		 1, 4, 4, 7, 6, 8, 8, 8, 8, 9, 9,10,10,11,10, 6,
		 5, 5, 7, 7, 9, 9, 8, 9,10,10,11,11,12,12, 6, 5,
		 5, 7, 7, 9, 9, 9, 9,10,10,11,11,12,12,21, 7, 8,
		 8, 8, 9, 9, 9, 9,10,10,11,11,12,12,21, 8, 8, 8,
		 8, 9, 9, 9, 9,10,10,11,11,12,12,21,11,12, 9, 9,
		10,10,10,10,10,11,11,12,12,12,21,12,12, 9, 8,10,
		10,10,10,11,11,12,12,13,13,21,21,21, 9, 9, 9, 9,
		11,11,11,11,12,12,12,13,21,20,20, 9, 9, 9, 9,10,
		11,11,11,12,12,13,13,20,20,20,13,13,10,10,11,11,
		12,12,13,13,13,13,20,20,20,13,13,10,10,11,11,12,
		12,13,13,13,13,20,20,20,20,20,12,12,12,12,12,12,
		13,13,14,14,20,20,20,20,20,12,12,12,11,13,12,13,
		13,14,14,20,20,20,20,20,15,16,13,12,13,13,14,13,
		14,14,20,20,20,20,20,16,15,12,12,13,12,14,13,14,
		14,
};

static const static_codebook _44c9_s_p8_0 = {
		2, 225,
		(long *)_vq_lengthlist__44c9_s_p8_0,
		1, -520986624, 1620377600, 4, 0,
		(long *)_vq_quantlist__44c9_s_p8_0,
		0
};

static const long _vq_quantlist__44c9_s_p8_1[] = {
		10,
		9,
		11,
		8,
		12,
		7,
		13,
		6,
		14,
		5,
		15,
		4,
		16,
		3,
		17,
		2,
		18,
		1,
		19,
		0,
		20,
};

static const long _vq_lengthlist__44c9_s_p8_1[] = {
		 4, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8,
		 8, 8, 8, 8, 8,10, 6, 6, 7, 7, 8, 8, 8, 8, 9, 9,
		 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,10, 6, 6, 7, 7, 8,
		 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,10,
		 7, 7, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9,
		 9, 9, 9, 9,10,10,10, 8, 8, 8, 8, 9, 9, 9, 9, 9,
		 9, 9, 9, 9, 9, 9, 9, 9, 9,10,10,10, 8, 8, 8, 8,
		 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,10,10,
		10, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
		 9, 9, 9,10,10,10, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
		 9, 9, 9, 9, 9, 9, 9, 9,10,10,10,10,10, 9, 9, 9,
		 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,10,10,10,
		10,10, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
		 9, 9,10,10,10,10,10, 9, 9, 9, 9, 9, 9, 9, 9, 9,
		 9, 9, 9, 9, 9, 9, 9,10,10,10,10,10, 9, 9, 9, 9,
		 9, 9, 9, 9, 9, 9, 9, 9,10, 9, 9, 9,10,10,10,10,
		10,10,10, 9, 9, 9, 9, 9, 9,10, 9, 9, 9, 9, 9, 9,
		 9,10,10,10,10,10,10,10, 9, 9, 9,10,10,10,10,10,
		 9, 9, 9, 9, 9, 9,10,10,10,10,10,10,10, 9, 9,10,
		 9,10, 9, 9, 9, 9, 9, 9, 9, 9,10,10,10,10,10,10,
		10,10,10,10, 9, 9,10,10, 9, 9, 9, 9, 9, 9, 9, 9,
		10,10,10,10,10,10,10,10,10,10,10,10,10, 9, 9, 9,
		 9, 9, 9, 9, 9,10,10,10,10,10,10,10,10,10,10,10,
		10,10, 9, 9,10, 9, 9, 9, 9, 9,10,10,10,10,10,10,
		10,10,10,10,10, 9, 9,10,10, 9, 9,10, 9, 9, 9,10,
		10,10,10,10,10,10,10,10,10,10, 9, 9,10, 9, 9, 9,
		 9, 9, 9, 9,10,10,10,10,10,10,10,10,10,10,10, 9,
		 9, 9, 9,10, 9, 9, 9, 9, 9,
};

static const static_codebook _44c9_s_p8_1 = {
		2, 441,
		(long *)_vq_lengthlist__44c9_s_p8_1,
		1, -529268736, 1611661312, 5, 0,
		(long *)_vq_quantlist__44c9_s_p8_1,
		0
};

static const long _vq_quantlist__44c9_s_p9_0[] = {
		9,
		8,
		10,
		7,
		11,
		6,
		12,
		5,
		13,
		4,
		14,
		3,
		15,
		2,
		16,
		1,
		17,
		0,
		18,
};

static const long _vq_lengthlist__44c9_s_p9_0[] = {
		 1, 4, 3,12,12,12,12,12,12,12,12,12,12,12,12,12,
		12,12,12, 4, 5, 6,12,12,12,12,12,12,12,12,12,12,
		12,12,12,12,12,12, 4, 6, 6,12,12,12,12,12,12,12,
		12,12,12,12,12,12,12,12,12,12,12,11,12,12,12,12,
		12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
		12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
		12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
		12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
		12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
		12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
		12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
		12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
		12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
		12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
		12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
		12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
		12,12,12,12,12,12,12,12,12,12,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,
};

static const static_codebook _44c9_s_p9_0 = {
		2, 361,
		(long *)_vq_lengthlist__44c9_s_p9_0,
		1, -508535424, 1631393792, 5, 0,
		(long *)_vq_quantlist__44c9_s_p9_0,
		0
};

static const long _vq_quantlist__44c9_s_p9_1[] = {
		9,
		8,
		10,
		7,
		11,
		6,
		12,
		5,
		13,
		4,
		14,
		3,
		15,
		2,
		16,
		1,
		17,
		0,
		18,
};

static const long _vq_lengthlist__44c9_s_p9_1[] = {
		 1, 4, 4, 7, 7, 7, 7, 8, 7, 9, 8, 9, 9,10,10,11,
		11,11,11, 6, 5, 5, 8, 8, 9, 9, 9, 8,10, 9,11,10,
		12,12,13,12,13,13, 5, 5, 5, 8, 8, 9, 9, 9, 9,10,
		10,11,11,12,12,13,12,13,13,17, 8, 8, 9, 9, 9, 9,
		 9, 9,10,10,12,11,13,12,13,13,13,13,18, 8, 8, 9,
		 9, 9, 9, 9, 9,11,11,12,12,13,13,13,13,13,13,17,
		13,12, 9, 9,10,10,10,10,11,11,12,12,12,13,13,13,
		14,14,18,13,12, 9, 9,10,10,10,10,11,11,12,12,13,
		13,13,14,14,14,17,18,18,10,10,10,10,11,11,11,12,
		12,12,14,13,14,13,13,14,18,18,18,10, 9,10, 9,11,
		11,12,12,12,12,13,13,15,14,14,14,18,18,16,13,14,
		10,11,11,11,12,13,13,13,13,14,13,13,14,14,18,18,
		18,14,12,11, 9,11,10,13,12,13,13,13,14,14,14,13,
		14,18,18,17,18,18,11,12,12,12,13,13,14,13,14,14,
		13,14,14,14,18,18,18,18,17,12,10,12, 9,13,11,13,
		14,14,14,14,14,15,14,18,18,17,17,18,14,15,12,13,
		13,13,14,13,14,14,15,14,15,14,18,17,18,18,18,15,
		15,12,10,14,10,14,14,13,13,14,14,14,14,18,16,18,
		18,18,18,17,14,14,13,14,14,13,13,14,14,14,15,15,
		18,18,18,18,17,17,17,14,14,14,12,14,13,14,14,15,
		14,15,14,18,18,18,18,18,18,18,17,16,13,13,13,14,
		14,14,14,15,16,15,18,18,18,18,18,18,18,17,17,13,
		13,13,13,14,13,14,15,15,15,
};

static const static_codebook _44c9_s_p9_1 = {
		2, 361,
		(long *)_vq_lengthlist__44c9_s_p9_1,
		1, -518287360, 1622704128, 5, 0,
		(long *)_vq_quantlist__44c9_s_p9_1,
		0
};

static const long _vq_quantlist__44c9_s_p9_2[] = {
		24,
		23,
		25,
		22,
		26,
		21,
		27,
		20,
		28,
		19,
		29,
		18,
		30,
		17,
		31,
		16,
		32,
		15,
		33,
		14,
		34,
		13,
		35,
		12,
		36,
		11,
		37,
		10,
		38,
		9,
		39,
		8,
		40,
		7,
		41,
		6,
		42,
		5,
		43,
		4,
		44,
		3,
		45,
		2,
		46,
		1,
		47,
		0,
		48,
};

static const long _vq_lengthlist__44c9_s_p9_2[] = {
		 2, 4, 4, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6,
		 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7,
		 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
		 7,
};

static const static_codebook _44c9_s_p9_2 = {
		1, 49,
		(long *)_vq_lengthlist__44c9_s_p9_2,
		1, -526909440, 1611661312, 6, 0,
		(long *)_vq_quantlist__44c9_s_p9_2,
		0
};

static const long _huff_lengthlist__44c9_s_short[] = {
		 5,13,18,16,17,17,19,18,19,19, 5, 7,10,11,12,12,
		13,16,17,18, 6, 6, 7, 7, 9, 9,10,14,17,19, 8, 7,
		 6, 5, 6, 7, 9,12,19,17, 8, 7, 7, 6, 5, 6, 8,11,
		15,19, 9, 8, 7, 6, 5, 5, 6, 8,13,15,11,10, 8, 8,
		 7, 5, 4, 4,10,14,12,13,11, 9, 7, 6, 4, 2, 6,12,
		18,16,16,13, 8, 7, 7, 5, 8,13,16,17,18,15,11, 9,
		 9, 8,10,13,
};

static const static_codebook _huff_book__44c9_s_short = {
		2, 100,
		(long *)_huff_lengthlist__44c9_s_short,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist__44c0_s_long[] = {
		 5, 4, 8, 9, 8, 9,10,12,15, 4, 1, 5, 5, 6, 8,11,
		12,12, 8, 5, 8, 9, 9,11,13,12,12, 9, 5, 8, 5, 7,
		 9,12,13,13, 8, 6, 8, 7, 7, 9,11,11,11, 9, 7, 9,
		 7, 7, 7, 7,10,12,10,10,11, 9, 8, 7, 7, 9,11,11,
		12,13,12,11, 9, 8, 9,11,13,16,16,15,15,12,10,11,
		12,
};

static const static_codebook _huff_book__44c0_s_long = {
		2, 81,
		(long *)_huff_lengthlist__44c0_s_long,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _vq_quantlist__44c0_s_p1_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__44c0_s_p1_0[] = {
		 1, 5, 5, 0, 0, 0, 0, 0, 0, 5, 7, 7, 0, 0, 0, 0,
		 0, 0, 5, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 5, 8, 7, 0, 0, 0, 0, 0, 0, 7, 9, 9, 0, 0, 0,
		 0, 0, 0, 7, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 5, 7, 7, 0, 0, 0, 0, 0, 0, 7, 9, 9, 0, 0,
		 0, 0, 0, 0, 7, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 7, 7, 0, 0, 0, 0,
		 0, 0, 8,10, 9, 0, 0, 0, 0, 0, 0, 7, 9, 9, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 9, 9, 0, 0, 0,
		 0, 0, 0, 9,10,11, 0, 0, 0, 0, 0, 0, 9,11,10, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 9, 9, 0, 0,
		 0, 0, 0, 0, 9,11, 9, 0, 0, 0, 0, 0, 0, 9,10,11,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 5, 7, 7, 0, 0, 0, 0, 0, 0, 7, 9, 9, 0, 0,
		 0, 0, 0, 0, 8, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 7, 9, 9, 0, 0, 0, 0, 0, 0, 9,11,10, 0,
		 0, 0, 0, 0, 0, 9, 9,11, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 7, 9,10, 0, 0, 0, 0, 0, 0, 9,10,11,
		 0, 0, 0, 0, 0, 0, 9,11,10, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0,
};

static const static_codebook _44c0_s_p1_0 = {
		8, 6561,
		(long *)_vq_lengthlist__44c0_s_p1_0,
		1, -535822336, 1611661312, 2, 0,
		(long *)_vq_quantlist__44c0_s_p1_0,
		0
};

static const long _vq_quantlist__44c0_s_p2_0[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__44c0_s_p2_0[] = {
		 1, 4, 4, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 5, 5, 7, 6, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 4, 5, 6, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 7, 7, 9, 9,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 6, 7, 7, 9, 9, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0,
};

static const static_codebook _44c0_s_p2_0 = {
		4, 625,
		(long *)_vq_lengthlist__44c0_s_p2_0,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__44c0_s_p2_0,
		0
};

static const long _vq_quantlist__44c0_s_p3_0[] = {
		4,
		3,
		5,
		2,
		6,
		1,
		7,
		0,
		8,
};

static const long _vq_lengthlist__44c0_s_p3_0[] = {
		 1, 3, 2, 8, 7, 0, 0, 0, 0, 0, 0, 0, 6, 6, 0, 0,
		 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 0, 7, 7,
		 0, 0, 0, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0, 0, 0,
		 8, 8, 0, 0, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0,
		 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0,
};

static const static_codebook _44c0_s_p3_0 = {
		2, 81,
		(long *)_vq_lengthlist__44c0_s_p3_0,
		1, -531628032, 1611661312, 4, 0,
		(long *)_vq_quantlist__44c0_s_p3_0,
		0
};

static const long _vq_quantlist__44c0_s_p4_0[] = {
		4,
		3,
		5,
		2,
		6,
		1,
		7,
		0,
		8,
};

static const long _vq_lengthlist__44c0_s_p4_0[] = {
		 1, 3, 3, 6, 6, 6, 6, 8, 8, 0, 0, 0, 7, 7, 7, 7,
		 9, 9, 0, 0, 0, 7, 7, 7, 7, 9, 9, 0, 0, 0, 7, 7,
		 7, 8, 9, 9, 0, 0, 0, 7, 7, 7, 7, 9, 9, 0, 0, 0,
		 9, 9, 8, 8,10,10, 0, 0, 0, 8, 9, 8, 8,10,10, 0,
		 0, 0,10,10, 9, 9,10,10, 0, 0, 0, 0, 0, 9, 9,10,
		10,
};

static const static_codebook _44c0_s_p4_0 = {
		2, 81,
		(long *)_vq_lengthlist__44c0_s_p4_0,
		1, -531628032, 1611661312, 4, 0,
		(long *)_vq_quantlist__44c0_s_p4_0,
		0
};

static const long _vq_quantlist__44c0_s_p5_0[] = {
		8,
		7,
		9,
		6,
		10,
		5,
		11,
		4,
		12,
		3,
		13,
		2,
		14,
		1,
		15,
		0,
		16,
};

static const long _vq_lengthlist__44c0_s_p5_0[] = {
		 1, 4, 3, 6, 6, 8, 7, 8, 8, 8, 8, 9, 9,10,10,11,
		11, 0, 0, 0, 7, 7, 8, 8, 9, 9, 9, 9, 9,10,10,10,
		11,11, 0, 0, 0, 7, 7, 8, 8, 9, 9, 9, 9,10,10,10,
		10,11,11, 0, 0, 0, 7, 7, 8, 8, 9, 9, 9, 9,10,10,
		11,11,11,11, 0, 0, 0, 7, 7, 8, 8, 9, 9, 9, 9,10,
		10,11,11,11,11, 0, 0, 0, 8, 8, 9, 9, 9, 9,10,10,
		10,10,11,11,12,12, 0, 0, 0, 8, 8, 9, 9, 9, 9,10,
		10,10,10,11,11,12,12, 0, 0, 0, 9, 9, 9, 9,10,10,
		10,10,11,11,11,12,12,12, 0, 0, 0, 0, 0, 9, 9,10,
		10,10,10,11,11,11,11,12,12, 0, 0, 0, 0, 0, 9, 9,
		10,10,10,10,11,11,12,12,13,13, 0, 0, 0, 0, 0, 9,
		 9,10,10,10,10,11,11,12,12,13,13, 0, 0, 0, 0, 0,
		10,10,11,11,11,11,11,12,12,12,13,13, 0, 0, 0, 0,
		 0, 0, 0,11,10,11,11,11,11,12,12,13,13, 0, 0, 0,
		 0, 0, 0, 0,11,11,12,11,12,12,12,12,13,13, 0, 0,
		 0, 0, 0, 0, 0,11,11,11,12,12,12,12,13,13,13, 0,
		 0, 0, 0, 0, 0, 0,12,12,12,12,12,13,13,13,14,14,
		 0, 0, 0, 0, 0, 0, 0, 0, 0,12,12,12,12,13,13,14,
		14,
};

static const static_codebook _44c0_s_p5_0 = {
		2, 289,
		(long *)_vq_lengthlist__44c0_s_p5_0,
		1, -529530880, 1611661312, 5, 0,
		(long *)_vq_quantlist__44c0_s_p5_0,
		0
};

static const long _vq_quantlist__44c0_s_p6_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__44c0_s_p6_0[] = {
		 1, 4, 4, 7, 6, 6, 7, 6, 6, 4, 7, 7,10, 9, 9,10,
		 9, 9, 4, 6, 7,10, 9, 9,11, 9, 9, 7,10,10,11,11,
		11,12,10,11, 6, 9, 9,11,10,11,11,10,10, 6, 9, 9,
		11,10,11,11,10,10, 7,11,10,12,11,11,11,11,11, 7,
		 9, 9,10,10,10,11,11,10, 6, 9, 9,11,10,10,11,10,
		10,
};

static const static_codebook _44c0_s_p6_0 = {
		4, 81,
		(long *)_vq_lengthlist__44c0_s_p6_0,
		1, -529137664, 1618345984, 2, 0,
		(long *)_vq_quantlist__44c0_s_p6_0,
		0
};

static const long _vq_quantlist__44c0_s_p6_1[] = {
		5,
		4,
		6,
		3,
		7,
		2,
		8,
		1,
		9,
		0,
		10,
};

static const long _vq_lengthlist__44c0_s_p6_1[] = {
		 2, 3, 3, 6, 6, 7, 7, 7, 7, 7, 8,10,10,10, 6, 6,
		 7, 7, 8, 8, 8, 8,10,10,10, 6, 6, 7, 7, 8, 8, 8,
		 8,10,10,10, 7, 7, 7, 7, 8, 8, 8, 8,10,10,10, 7,
		 7, 7, 7, 8, 8, 8, 8,10,10,10, 8, 7, 8, 8, 8, 8,
		 8, 8,10,10,10, 7, 7, 8, 8, 8, 8, 8, 8,10,10,10,
		 8, 8, 8, 8, 8, 8, 8, 8,10,10,10,10,10, 8, 8, 8,
		 8, 8, 8,10,10,10,10,10, 9, 9, 8, 8, 8, 8,10,10,
		10,10,10, 8, 8, 8, 8, 8, 8,
};

static const static_codebook _44c0_s_p6_1 = {
		2, 121,
		(long *)_vq_lengthlist__44c0_s_p6_1,
		1, -531365888, 1611661312, 4, 0,
		(long *)_vq_quantlist__44c0_s_p6_1,
		0
};

static const long _vq_quantlist__44c0_s_p7_0[] = {
		6,
		5,
		7,
		4,
		8,
		3,
		9,
		2,
		10,
		1,
		11,
		0,
		12,
};

static const long _vq_lengthlist__44c0_s_p7_0[] = {
		 1, 4, 4, 6, 6, 7, 7, 7, 7, 8, 8, 9, 9, 7, 5, 5,
		 7, 7, 8, 8, 8, 8, 9, 9,10,10, 7, 5, 6, 7, 7, 8,
		 8, 8, 8, 9, 9,10,10, 0, 8, 8, 8, 8, 9, 9, 9, 9,
		10,10,11,11, 0, 8, 8, 8, 8, 9, 9, 9, 9,10,10,11,
		11, 0,12,12, 9, 9,10,10,10,10,11,11,11,11, 0,13,
		13, 9, 9, 9, 9,10,10,11,11,11,12, 0, 0, 0,10,10,
		10,10,11,11,11,11,12,12, 0, 0, 0,10,10, 9, 9,11,
		11,11,12,12,12, 0, 0, 0,13,13,10,10,11,11,12,12,
		13,13, 0, 0, 0,14,14,10,10,11,11,12,12,13,13, 0,
		 0, 0, 0, 0,11,11,11,11,13,12,13,13, 0, 0, 0, 0,
		 0,12,12,11,11,12,12,13,13,
};

static const static_codebook _44c0_s_p7_0 = {
		2, 169,
		(long *)_vq_lengthlist__44c0_s_p7_0,
		1, -526516224, 1616117760, 4, 0,
		(long *)_vq_quantlist__44c0_s_p7_0,
		0
};

static const long _vq_quantlist__44c0_s_p7_1[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__44c0_s_p7_1[] = {
		 2, 3, 3, 5, 5, 6, 6, 6, 5, 5, 6, 6, 6, 5, 5, 6,
		 6, 6, 5, 5, 6, 6, 6, 5, 5,
};

static const static_codebook _44c0_s_p7_1 = {
		2, 25,
		(long *)_vq_lengthlist__44c0_s_p7_1,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__44c0_s_p7_1,
		0
};

static const long _vq_quantlist__44c0_s_p8_0[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__44c0_s_p8_0[] = {
		 1, 5, 5,10,10, 6, 9, 8,10,10, 6,10, 9,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10, 8,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,10,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,
};

static const static_codebook _44c0_s_p8_0 = {
		4, 625,
		(long *)_vq_lengthlist__44c0_s_p8_0,
		1, -518283264, 1627103232, 3, 0,
		(long *)_vq_quantlist__44c0_s_p8_0,
		0
};

static const long _vq_quantlist__44c0_s_p8_1[] = {
		6,
		5,
		7,
		4,
		8,
		3,
		9,
		2,
		10,
		1,
		11,
		0,
		12,
};

static const long _vq_lengthlist__44c0_s_p8_1[] = {
		 1, 4, 4, 6, 6, 7, 7, 9, 9,11,12,13,12, 6, 5, 5,
		 7, 7, 8, 8,10, 9,12,12,12,12, 6, 5, 5, 7, 7, 8,
		 8,10, 9,12,11,11,13,16, 7, 7, 8, 8, 9, 9,10,10,
		12,12,13,12,16, 7, 7, 8, 7, 9, 9,10,10,11,12,12,
		13,16,10,10, 8, 8,10,10,11,12,12,12,13,13,16,11,
		10, 8, 7,11,10,11,11,12,11,13,13,16,16,16,10,10,
		10,10,11,11,13,12,13,13,16,16,16,11, 9,11, 9,15,
		13,12,13,13,13,16,16,16,15,13,11,11,12,13,12,12,
		14,13,16,16,16,14,13,11,11,13,12,14,13,13,13,16,
		16,16,16,16,13,13,13,12,14,13,14,14,16,16,16,16,
		16,13,13,12,12,14,14,15,13,
};

static const static_codebook _44c0_s_p8_1 = {
		2, 169,
		(long *)_vq_lengthlist__44c0_s_p8_1,
		1, -522616832, 1620115456, 4, 0,
		(long *)_vq_quantlist__44c0_s_p8_1,
		0
};

static const long _vq_quantlist__44c0_s_p8_2[] = {
		8,
		7,
		9,
		6,
		10,
		5,
		11,
		4,
		12,
		3,
		13,
		2,
		14,
		1,
		15,
		0,
		16,
};

static const long _vq_lengthlist__44c0_s_p8_2[] = {
		 2, 4, 4, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8,
		 8,10,10,10, 7, 7, 7, 8, 8, 8, 9, 9, 9, 9, 9, 9,
		 9, 9,10,10,10, 7, 7, 7, 7, 8, 8, 9, 9, 9, 9, 9,
		 9, 9, 9,10,10,10, 7, 7, 8, 8, 8, 8, 9, 9, 9, 9,
		 9,10, 9, 9,10,10,10, 7, 7, 8, 8, 9, 8, 9, 9, 9,
		 9,10, 9, 9,10,10,10,10, 8, 8, 8, 8, 9, 8, 9, 9,
		 9, 9, 9,10, 9,10,10,10,10, 7, 7, 8, 8, 9, 9, 9,
		 9, 9, 9,10, 9,10,10,10,10,10, 8, 8, 8, 9, 9, 9,
		 9, 9, 9, 9,10,10,10, 9,11,10,10,10,10, 8, 8, 9,
		 9, 9, 9, 9,10, 9, 9, 9,10,10,10,10,11,11, 9, 9,
		 9, 9, 9, 9, 9, 9,10, 9, 9,10,11,10,10,11,11, 9,
		 9, 9, 9, 9, 9, 9, 9, 9, 9,10, 9,11,11,10,11,11,
		 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,10, 9,11,10,10,11,
		11,11,11, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,10,10,10,
		11,11,11,11, 9,10, 9,10, 9, 9, 9, 9,10, 9,10,11,
		10,11,10,10,10,10,10, 9, 9, 9,10, 9, 9, 9,10,11,
		11,10,11,11,10,11,10,10,10, 9, 9, 9, 9,10, 9, 9,
		10,11,10,11,11,11,11,10,11,10,10, 9,10, 9, 9, 9,
		10,
};

static const static_codebook _44c0_s_p8_2 = {
		2, 289,
		(long *)_vq_lengthlist__44c0_s_p8_2,
		1, -529530880, 1611661312, 5, 0,
		(long *)_vq_quantlist__44c0_s_p8_2,
		0
};

static const long _huff_lengthlist__44c0_s_short[] = {
		 9, 8,12,11,12,13,14,14,16, 6, 1, 5, 6, 6, 9,12,
		14,17, 9, 4, 5, 9, 7, 9,13,15,16, 8, 5, 8, 6, 8,
		10,13,17,17, 9, 6, 7, 7, 8, 9,13,15,17,11, 8, 9,
		 9, 9,10,12,16,16,13, 7, 8, 7, 7, 9,12,14,15,13,
		 6, 7, 5, 5, 7,10,13,13,14, 7, 8, 5, 6, 7, 9,10,
		12,
};

static const static_codebook _huff_book__44c0_s_short = {
		2, 81,
		(long *)_huff_lengthlist__44c0_s_short,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist__44c0_sm_long[] = {
		 5, 4, 9,10, 9,10,11,12,13, 4, 1, 5, 7, 7, 9,11,
		12,14, 8, 5, 7, 9, 8,10,13,13,13,10, 7, 9, 4, 6,
		 7,10,12,14, 9, 6, 7, 6, 6, 7,10,12,12, 9, 8, 9,
		 7, 6, 7, 8,11,12,11,11,11, 9, 8, 7, 8,10,12,12,
		13,14,12,11, 9, 9, 9,12,12,17,17,15,16,12,10,11,
		13,
};

static const static_codebook _huff_book__44c0_sm_long = {
		2, 81,
		(long *)_huff_lengthlist__44c0_sm_long,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _vq_quantlist__44c0_sm_p1_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__44c0_sm_p1_0[] = {
		 1, 5, 5, 0, 0, 0, 0, 0, 0, 5, 7, 7, 0, 0, 0, 0,
		 0, 0, 5, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 5, 8, 7, 0, 0, 0, 0, 0, 0, 7, 9, 9, 0, 0, 0,
		 0, 0, 0, 7, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 5, 7, 7, 0, 0, 0, 0, 0, 0, 7, 9, 8, 0, 0,
		 0, 0, 0, 0, 7, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 8, 7, 0, 0, 0, 0,
		 0, 0, 8, 9, 9, 0, 0, 0, 0, 0, 0, 8, 9, 9, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 9, 9, 0, 0, 0,
		 0, 0, 0, 9,10,10, 0, 0, 0, 0, 0, 0, 9,10,10, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 9, 9, 0, 0,
		 0, 0, 0, 0, 8,10, 9, 0, 0, 0, 0, 0, 0, 9,10,10,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 5, 7, 8, 0, 0, 0, 0, 0, 0, 7, 9, 9, 0, 0,
		 0, 0, 0, 0, 8, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 7, 9, 9, 0, 0, 0, 0, 0, 0, 9,10,10, 0,
		 0, 0, 0, 0, 0, 9, 9,10, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 7, 9, 9, 0, 0, 0, 0, 0, 0, 9,10,10,
		 0, 0, 0, 0, 0, 0, 9,10,10, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0,
};

static const static_codebook _44c0_sm_p1_0 = {
		8, 6561,
		(long *)_vq_lengthlist__44c0_sm_p1_0,
		1, -535822336, 1611661312, 2, 0,
		(long *)_vq_quantlist__44c0_sm_p1_0,
		0
};

static const long _vq_quantlist__44c0_sm_p2_0[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__44c0_sm_p2_0[] = {
		 1, 4, 4, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 5, 5, 7, 7, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 4, 5, 5, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 7, 7, 9, 9,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 7, 7, 7, 9, 9, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0,
};

static const static_codebook _44c0_sm_p2_0 = {
		4, 625,
		(long *)_vq_lengthlist__44c0_sm_p2_0,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__44c0_sm_p2_0,
		0
};

static const long _vq_quantlist__44c0_sm_p3_0[] = {
		4,
		3,
		5,
		2,
		6,
		1,
		7,
		0,
		8,
};

static const long _vq_lengthlist__44c0_sm_p3_0[] = {
		 1, 3, 3, 7, 7, 0, 0, 0, 0, 0, 5, 4, 7, 7, 0, 0,
		 0, 0, 0, 5, 5, 7, 7, 0, 0, 0, 0, 0, 6, 7, 8, 8,
		 0, 0, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0,
		 9,10, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0,
		 0, 0,11,11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0,
};

static const static_codebook _44c0_sm_p3_0 = {
		2, 81,
		(long *)_vq_lengthlist__44c0_sm_p3_0,
		1, -531628032, 1611661312, 4, 0,
		(long *)_vq_quantlist__44c0_sm_p3_0,
		0
};

static const long _vq_quantlist__44c0_sm_p4_0[] = {
		4,
		3,
		5,
		2,
		6,
		1,
		7,
		0,
		8,
};

static const long _vq_lengthlist__44c0_sm_p4_0[] = {
		 1, 4, 3, 6, 6, 7, 7, 9, 9, 0, 5, 5, 7, 7, 8, 7,
		 9, 9, 0, 5, 5, 7, 7, 8, 8, 9, 9, 0, 7, 7, 8, 8,
		 8, 8,10,10, 0, 0, 0, 8, 8, 8, 8,10,10, 0, 0, 0,
		 9, 9, 9, 9,11,11, 0, 0, 0, 9, 9, 9, 9,11,11, 0,
		 0, 0,10,10,10,10,11,11, 0, 0, 0, 0, 0, 9, 9,11,
		11,
};

static const static_codebook _44c0_sm_p4_0 = {
		2, 81,
		(long *)_vq_lengthlist__44c0_sm_p4_0,
		1, -531628032, 1611661312, 4, 0,
		(long *)_vq_quantlist__44c0_sm_p4_0,
		0
};

static const long _vq_quantlist__44c0_sm_p5_0[] = {
		8,
		7,
		9,
		6,
		10,
		5,
		11,
		4,
		12,
		3,
		13,
		2,
		14,
		1,
		15,
		0,
		16,
};

static const long _vq_lengthlist__44c0_sm_p5_0[] = {
		 1, 4, 4, 6, 6, 8, 8, 8, 8, 8, 8, 9, 9,10,10,11,
		11, 0, 6, 6, 7, 7, 8, 8, 9, 9, 9, 9,10,10,10,11,
		11,11, 0, 5, 6, 7, 7, 8, 8, 9, 9, 9, 9,10,10,10,
		11,11,11, 0, 7, 7, 8, 8, 8, 8, 9, 9, 9, 9,10,10,
		11,11,12,12, 0, 0, 0, 8, 8, 8, 8, 9, 9, 9, 9,10,
		10,11,11,12,12, 0, 0, 0, 8, 8, 9, 9,10,10,10,10,
		11,11,11,11,12,12, 0, 0, 0, 8, 8, 9, 9,10,10,10,
		10,11,11,11,11,12,12, 0, 0, 0, 9, 9, 9, 9,10,10,
		10,10,11,11,12,12,12,13, 0, 0, 0, 0, 0, 9, 9,10,
		10,10,10,11,11,12,12,13,13, 0, 0, 0, 0, 0, 9, 9,
		10,10,11,11,11,11,12,12,13,13, 0, 0, 0, 0, 0, 9,
		 9,10,10,11,10,11,11,12,12,13,13, 0, 0, 0, 0, 0,
		10,10,10,10,11,11,12,12,12,13,13,13, 0, 0, 0, 0,
		 0, 0, 0,10,10,11,11,12,12,12,13,13,13, 0, 0, 0,
		 0, 0, 0, 0,11,11,12,12,12,12,13,13,14,14, 0, 0,
		 0, 0, 0, 0, 0,11,11,12,11,12,12,13,13,13,13, 0,
		 0, 0, 0, 0, 0, 0,12,12,12,12,13,13,13,13,14,14,
		 0, 0, 0, 0, 0, 0, 0, 0, 0,12,12,12,12,13,13,14,
		14,
};

static const static_codebook _44c0_sm_p5_0 = {
		2, 289,
		(long *)_vq_lengthlist__44c0_sm_p5_0,
		1, -529530880, 1611661312, 5, 0,
		(long *)_vq_quantlist__44c0_sm_p5_0,
		0
};

static const long _vq_quantlist__44c0_sm_p6_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__44c0_sm_p6_0[] = {
		 1, 4, 4, 7, 6, 6, 7, 6, 6, 4, 7, 7,10, 9, 9,11,
		 9, 9, 4, 7, 7,10, 9, 9,11, 9, 9, 7,10,10,10,11,
		11,11,10,10, 6, 9, 9,11,11,10,11,10,10, 6, 9, 9,
		11,10,11,11,10,10, 7,11,10,11,11,11,11,11,11, 6,
		 9, 9,11,10,10,11,11,10, 6, 9, 9,11,10,10,11,10,
		11,
};

static const static_codebook _44c0_sm_p6_0 = {
		4, 81,
		(long *)_vq_lengthlist__44c0_sm_p6_0,
		1, -529137664, 1618345984, 2, 0,
		(long *)_vq_quantlist__44c0_sm_p6_0,
		0
};

static const long _vq_quantlist__44c0_sm_p6_1[] = {
		5,
		4,
		6,
		3,
		7,
		2,
		8,
		1,
		9,
		0,
		10,
};

static const long _vq_lengthlist__44c0_sm_p6_1[] = {
		 2, 4, 4, 6, 6, 7, 7, 7, 7, 7, 8, 9, 5, 5, 6, 6,
		 7, 7, 8, 8, 8, 8, 9, 5, 5, 6, 6, 7, 7, 8, 8, 8,
		 8,10, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8,10,10,10, 7,
		 7, 7, 7, 8, 8, 8, 8,10,10,10, 8, 8, 8, 8, 8, 8,
		 8, 8,10,10,10, 8, 8, 8, 8, 8, 8, 8, 8,10,10,10,
		 8, 8, 8, 8, 8, 8, 8, 8,10,10,10,10,10, 8, 8, 8,
		 8, 8, 8,10,10,10,10,10, 9, 9, 8, 8, 8, 8,10,10,
		10,10,10, 8, 8, 8, 8, 8, 8,
};

static const static_codebook _44c0_sm_p6_1 = {
		2, 121,
		(long *)_vq_lengthlist__44c0_sm_p6_1,
		1, -531365888, 1611661312, 4, 0,
		(long *)_vq_quantlist__44c0_sm_p6_1,
		0
};

static const long _vq_quantlist__44c0_sm_p7_0[] = {
		6,
		5,
		7,
		4,
		8,
		3,
		9,
		2,
		10,
		1,
		11,
		0,
		12,
};

static const long _vq_lengthlist__44c0_sm_p7_0[] = {
		 1, 4, 4, 6, 6, 7, 7, 7, 7, 8, 8, 9, 9, 7, 5, 5,
		 7, 7, 8, 8, 8, 8, 9, 9,10,10, 7, 6, 5, 7, 7, 8,
		 8, 8, 8, 9, 9,10,10, 0, 8, 8, 8, 8, 9, 9, 9, 9,
		10,10,11,11, 0, 8, 8, 8, 8, 9, 9, 9, 9,10,10,11,
		11, 0,12,12, 9, 9,10,10,10,10,11,11,11,11, 0,13,
		13, 9, 9, 9, 9,10,10,11,11,11,12, 0, 0, 0, 9,10,
		10,10,11,11,12,11,12,12, 0, 0, 0,10,10, 9, 9,11,
		11,12,12,12,12, 0, 0, 0,13,13,10,10,11,11,12,12,
		13,13, 0, 0, 0,14,14,10,10,11,11,12,12,13,13, 0,
		 0, 0, 0, 0,11,12,11,11,13,12,13,13, 0, 0, 0, 0,
		 0,12,12,11,11,13,12,14,14,
};

static const static_codebook _44c0_sm_p7_0 = {
		2, 169,
		(long *)_vq_lengthlist__44c0_sm_p7_0,
		1, -526516224, 1616117760, 4, 0,
		(long *)_vq_quantlist__44c0_sm_p7_0,
		0
};

static const long _vq_quantlist__44c0_sm_p7_1[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__44c0_sm_p7_1[] = {
		 2, 4, 4, 4, 4, 6, 5, 5, 5, 5, 6, 5, 5, 5, 5, 6,
		 6, 6, 5, 5, 6, 6, 6, 5, 5,
};

static const static_codebook _44c0_sm_p7_1 = {
		2, 25,
		(long *)_vq_lengthlist__44c0_sm_p7_1,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__44c0_sm_p7_1,
		0
};

static const long _vq_quantlist__44c0_sm_p8_0[] = {
		4,
		3,
		5,
		2,
		6,
		1,
		7,
		0,
		8,
};

static const long _vq_lengthlist__44c0_sm_p8_0[] = {
		 1, 3, 3,11,11,11,11,11,11, 3, 7, 6,11,11,11,11,
		11,11, 4, 8, 7,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
		12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
		12,
};

static const static_codebook _44c0_sm_p8_0 = {
		2, 81,
		(long *)_vq_lengthlist__44c0_sm_p8_0,
		1, -516186112, 1627103232, 4, 0,
		(long *)_vq_quantlist__44c0_sm_p8_0,
		0
};

static const long _vq_quantlist__44c0_sm_p8_1[] = {
		6,
		5,
		7,
		4,
		8,
		3,
		9,
		2,
		10,
		1,
		11,
		0,
		12,
};

static const long _vq_lengthlist__44c0_sm_p8_1[] = {
		 1, 4, 4, 6, 6, 7, 7, 9, 9,10,11,12,12, 6, 5, 5,
		 7, 7, 8, 8,10,10,12,11,12,12, 6, 5, 5, 7, 7, 8,
		 8,10,10,12,11,12,12,17, 7, 7, 8, 8, 9, 9,10,10,
		12,12,13,13,18, 7, 7, 8, 7, 9, 9,10,10,12,12,12,
		13,19,10,10, 8, 8,10,10,11,11,12,12,13,14,19,11,
		10, 8, 7,10,10,11,11,12,12,13,12,19,19,19,10,10,
		10,10,11,11,12,12,13,13,19,19,19,11, 9,11, 9,14,
		12,13,12,13,13,19,20,18,13,14,11,11,12,12,13,13,
		14,13,20,20,20,15,13,11,10,13,11,13,13,14,13,20,
		20,20,20,20,13,14,12,12,13,13,13,13,20,20,20,20,
		20,13,13,12,12,16,13,15,13,
};

static const static_codebook _44c0_sm_p8_1 = {
		2, 169,
		(long *)_vq_lengthlist__44c0_sm_p8_1,
		1, -522616832, 1620115456, 4, 0,
		(long *)_vq_quantlist__44c0_sm_p8_1,
		0
};

static const long _vq_quantlist__44c0_sm_p8_2[] = {
		8,
		7,
		9,
		6,
		10,
		5,
		11,
		4,
		12,
		3,
		13,
		2,
		14,
		1,
		15,
		0,
		16,
};

static const long _vq_lengthlist__44c0_sm_p8_2[] = {
		 2, 5, 5, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8,
		 8,10, 6, 6, 7, 7, 7, 7, 8, 8, 9, 9, 9, 9, 9, 9,
		 9, 9,10, 6, 6, 7, 7, 8, 7, 8, 8, 9, 9, 9, 9, 9,
		 9, 9, 9,10, 7, 7, 7, 7, 8, 8, 8, 9, 9, 9, 9, 9,
		 9, 9, 9, 9,10,10,10, 7, 7, 8, 8, 9, 8, 9, 9, 9,
		 9,10, 9, 9,10,10,10,11, 8, 8, 8, 8, 9, 9, 9, 9,
		 9, 9, 9,10, 9,10,10,10,10, 8, 8, 8, 8, 9, 9, 9,
		 9, 9, 9, 9, 9,10,10,11,10,10, 8, 8, 9, 9, 9, 9,
		 9, 9, 9, 9, 9, 9,10,10,10,10,10,11,11, 8, 8, 9,
		 9, 9, 9, 9, 9, 9, 9, 9,10,11,11,11,11,11, 9, 9,
		 9, 9, 9, 9, 9, 9,10, 9,10, 9,11,11,10,11,11, 9,
		 9, 9, 9, 9, 9, 9, 9, 9, 9,10, 9,11,11,10,11,11,
		 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,10, 9,11,10,11,11,
		11,11,11, 9, 9,10, 9, 9, 9, 9, 9, 9, 9,10,11,10,
		11,11,11,11,10,10,10,10, 9, 9, 9, 9, 9, 9,10,11,
		11,11,11,11,11, 9,10, 9, 9, 9, 9, 9, 9, 9, 9,11,
		11,10,11,11,11,10,10,10, 9, 9, 9, 9, 9, 9, 9, 9,
		10,11,10,11,11,11,11,11,11, 9, 9, 9, 9, 9, 9, 9,
		 9,
};

static const static_codebook _44c0_sm_p8_2 = {
		2, 289,
		(long *)_vq_lengthlist__44c0_sm_p8_2,
		1, -529530880, 1611661312, 5, 0,
		(long *)_vq_quantlist__44c0_sm_p8_2,
		0
};

static const long _huff_lengthlist__44c0_sm_short[] = {
		 6, 6,12,13,13,14,16,17,17, 4, 2, 5, 8, 7, 9,12,
		15,15, 9, 4, 5, 9, 7, 9,12,16,18,11, 6, 7, 4, 6,
		 8,11,14,18,10, 5, 6, 5, 5, 7,10,14,17,10, 5, 7,
		 7, 6, 7,10,13,16,11, 5, 7, 7, 7, 8,10,12,15,13,
		 6, 7, 5, 5, 7, 9,12,13,16, 8, 9, 6, 6, 7, 9,10,
		12,
};

static const static_codebook _huff_book__44c0_sm_short = {
		2, 81,
		(long *)_huff_lengthlist__44c0_sm_short,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist__44c1_s_long[] = {
		 5, 5, 9,10, 9, 9,10,11,12, 5, 1, 5, 6, 6, 7,10,
		12,14, 9, 5, 6, 8, 8,10,12,14,14,10, 5, 8, 5, 6,
		 8,11,13,14, 9, 5, 7, 6, 6, 8,10,12,11, 9, 7, 9,
		 7, 6, 6, 7,10,10,10, 9,12, 9, 8, 7, 7,10,12,11,
		11,13,12,10, 9, 8, 9,11,11,14,15,15,13,11, 9, 9,
		11,
};

static const static_codebook _huff_book__44c1_s_long = {
		2, 81,
		(long *)_huff_lengthlist__44c1_s_long,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _vq_quantlist__44c1_s_p1_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__44c1_s_p1_0[] = {
		 2, 4, 4, 0, 0, 0, 0, 0, 0, 5, 7, 6, 0, 0, 0, 0,
		 0, 0, 5, 6, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 5, 7, 7, 0, 0, 0, 0, 0, 0, 7, 8, 8, 0, 0, 0,
		 0, 0, 0, 7, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 5, 7, 7, 0, 0, 0, 0, 0, 0, 7, 8, 8, 0, 0,
		 0, 0, 0, 0, 7, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 7, 7, 0, 0, 0, 0,
		 0, 0, 7, 8, 8, 0, 0, 0, 0, 0, 0, 7, 8, 8, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 8, 8, 0, 0, 0,
		 0, 0, 0, 8, 9,10, 0, 0, 0, 0, 0, 0, 8, 9, 9, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 8, 8, 0, 0,
		 0, 0, 0, 0, 8, 9, 8, 0, 0, 0, 0, 0, 0, 8, 9, 9,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 4, 7, 7, 0, 0, 0, 0, 0, 0, 7, 8, 8, 0, 0,
		 0, 0, 0, 0, 7, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 6, 8, 8, 0, 0, 0, 0, 0, 0, 8,10, 9, 0,
		 0, 0, 0, 0, 0, 8, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 7, 8, 8, 0, 0, 0, 0, 0, 0, 8, 9, 9,
		 0, 0, 0, 0, 0, 0, 8, 9, 9, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0,
};

static const static_codebook _44c1_s_p1_0 = {
		8, 6561,
		(long *)_vq_lengthlist__44c1_s_p1_0,
		1, -535822336, 1611661312, 2, 0,
		(long *)_vq_quantlist__44c1_s_p1_0,
		0
};

static const long _vq_quantlist__44c1_s_p2_0[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__44c1_s_p2_0[] = {
		 2, 3, 4, 6, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 6, 6, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 4, 4, 5, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 8, 8,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 6, 6, 6, 8, 8, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0,
};

static const static_codebook _44c1_s_p2_0 = {
		4, 625,
		(long *)_vq_lengthlist__44c1_s_p2_0,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__44c1_s_p2_0,
		0
};

static const long _vq_quantlist__44c1_s_p3_0[] = {
		4,
		3,
		5,
		2,
		6,
		1,
		7,
		0,
		8,
};

static const long _vq_lengthlist__44c1_s_p3_0[] = {
		 1, 3, 2, 7, 7, 0, 0, 0, 0, 0,13,13, 6, 6, 0, 0,
		 0, 0, 0,12, 0, 6, 6, 0, 0, 0, 0, 0, 0, 0, 7, 7,
		 0, 0, 0, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0, 0, 0,
		 8, 9, 0, 0, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0,
		 0, 0,11,10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0,
};

static const static_codebook _44c1_s_p3_0 = {
		2, 81,
		(long *)_vq_lengthlist__44c1_s_p3_0,
		1, -531628032, 1611661312, 4, 0,
		(long *)_vq_quantlist__44c1_s_p3_0,
		0
};

static const long _vq_quantlist__44c1_s_p4_0[] = {
		4,
		3,
		5,
		2,
		6,
		1,
		7,
		0,
		8,
};

static const long _vq_lengthlist__44c1_s_p4_0[] = {
		 1, 3, 3, 6, 5, 6, 6, 8, 8, 0, 0, 0, 7, 7, 7, 7,
		 9, 9, 0, 0, 0, 7, 7, 7, 7, 9, 9, 0, 0, 0, 7, 7,
		 8, 8,10,10, 0, 0, 0, 7, 7, 8, 8,10,10, 0, 0, 0,
		 9, 9, 8, 8,10,10, 0, 0, 0, 8, 8, 8, 8,10,10, 0,
		 0, 0,10,10, 9, 9,11,11, 0, 0, 0, 0, 0, 9, 9,11,
		11,
};

static const static_codebook _44c1_s_p4_0 = {
		2, 81,
		(long *)_vq_lengthlist__44c1_s_p4_0,
		1, -531628032, 1611661312, 4, 0,
		(long *)_vq_quantlist__44c1_s_p4_0,
		0
};

static const long _vq_quantlist__44c1_s_p5_0[] = {
		8,
		7,
		9,
		6,
		10,
		5,
		11,
		4,
		12,
		3,
		13,
		2,
		14,
		1,
		15,
		0,
		16,
};

static const long _vq_lengthlist__44c1_s_p5_0[] = {
		 1, 4, 3, 6, 6, 7, 7, 8, 8, 8, 8, 9, 9,10,10,11,
		11, 0, 0, 0, 7, 7, 8, 8, 9, 9, 9, 9,10,10,10,10,
		11,11, 0, 0, 0, 7, 7, 8, 8, 9, 9, 9, 9,10,10,10,
		10,11,11, 0, 0, 0, 7, 7, 8, 8, 9, 9, 9, 9,10,10,
		11,11,11,11, 0, 0, 0, 7, 7, 8, 8, 9, 9, 9, 9,10,
		10,11,11,12,11, 0, 0, 0, 8, 8, 9, 9, 9,10,10,10,
		10,10,11,11,12,12, 0, 0, 0, 8, 8, 9, 9,10, 9,10,
		10,10,10,11,11,12,12, 0, 0, 0, 9, 9, 9, 9,10,10,
		10,10,11,11,12,12,12,12, 0, 0, 0, 0, 0, 9, 9,10,
		10,10,10,11,11,12,12,12,12, 0, 0, 0, 0, 0, 9, 9,
		10,10,10,11,11,11,12,12,13,13, 0, 0, 0, 0, 0, 9,
		 9,10,10,10,10,11,11,12,12,13,13, 0, 0, 0, 0, 0,
		10,10,10,10,11,11,12,12,12,12,13,13, 0, 0, 0, 0,
		 0, 0, 0,10,10,11,11,12,12,12,12,13,13, 0, 0, 0,
		 0, 0, 0, 0,11,11,12,12,12,12,13,13,13,13, 0, 0,
		 0, 0, 0, 0, 0,11,11,11,11,12,12,13,13,13,13, 0,
		 0, 0, 0, 0, 0, 0,12,12,12,12,12,12,13,13,14,14,
		 0, 0, 0, 0, 0, 0, 0, 0, 0,12,12,12,12,13,13,14,
		14,
};

static const static_codebook _44c1_s_p5_0 = {
		2, 289,
		(long *)_vq_lengthlist__44c1_s_p5_0,
		1, -529530880, 1611661312, 5, 0,
		(long *)_vq_quantlist__44c1_s_p5_0,
		0
};

static const long _vq_quantlist__44c1_s_p6_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__44c1_s_p6_0[] = {
		 1, 4, 4, 7, 6, 6, 7, 6, 6, 4, 7, 7,10, 9, 9,11,
		 9, 9, 4, 7, 7,10, 9, 9,11, 9, 9, 6,10,10,11,11,
		11,11,10,10, 6, 9, 9,11,10,10,11,10,10, 6, 9, 9,
		11,10,11,11,10,10, 7,11,10,11,11,11,12,11,11, 7,
		 9, 9,11,10,10,11,11,10, 6, 9, 9,10,10,10,12,10,
		11,
};

static const static_codebook _44c1_s_p6_0 = {
		4, 81,
		(long *)_vq_lengthlist__44c1_s_p6_0,
		1, -529137664, 1618345984, 2, 0,
		(long *)_vq_quantlist__44c1_s_p6_0,
		0
};

static const long _vq_quantlist__44c1_s_p6_1[] = {
		5,
		4,
		6,
		3,
		7,
		2,
		8,
		1,
		9,
		0,
		10,
};

static const long _vq_lengthlist__44c1_s_p6_1[] = {
		 2, 3, 3, 6, 6, 7, 7, 7, 7, 8, 8,10,10,10, 6, 6,
		 7, 7, 8, 8, 8, 8,10,10,10, 6, 6, 7, 7, 8, 8, 8,
		 8,10,10,10, 7, 7, 7, 7, 8, 8, 8, 8,10,10,10, 7,
		 7, 7, 7, 8, 8, 8, 8,10,10,10, 7, 7, 8, 8, 8, 8,
		 8, 8,10,10,10, 7, 7, 8, 8, 8, 8, 8, 8,10,10,10,
		 8, 8, 8, 8, 8, 8, 8, 8,10,10,10,10,10, 8, 8, 8,
		 8, 8, 8,10,10,10,10,10, 9, 9, 8, 8, 8, 8,10,10,
		10,10,10, 8, 8, 8, 8, 8, 8,
};

static const static_codebook _44c1_s_p6_1 = {
		2, 121,
		(long *)_vq_lengthlist__44c1_s_p6_1,
		1, -531365888, 1611661312, 4, 0,
		(long *)_vq_quantlist__44c1_s_p6_1,
		0
};

static const long _vq_quantlist__44c1_s_p7_0[] = {
		6,
		5,
		7,
		4,
		8,
		3,
		9,
		2,
		10,
		1,
		11,
		0,
		12,
};

static const long _vq_lengthlist__44c1_s_p7_0[] = {
		 1, 4, 4, 6, 6, 7, 7, 7, 7, 8, 8,10, 9, 7, 5, 6,
		 7, 7, 8, 8, 8, 8, 9, 9,10,10, 7, 5, 5, 7, 7, 8,
		 8, 8, 8, 9, 9,10,10, 0, 8, 8, 8, 8, 9, 9, 9, 9,
		10,10,11,10, 0, 8, 8, 8, 8, 9, 9, 9, 9,10,10,11,
		11, 0,12,12, 9, 9, 9,10,10,10,11,11,11,11, 0,13,
		13, 9, 9, 9, 9,10,10,11,11,11,11, 0, 0, 0,10,10,
		10,10,11,11,12,11,12,12, 0, 0, 0,10,10,10, 9,11,
		11,12,11,13,12, 0, 0, 0,13,13,10,10,11,11,12,12,
		13,13, 0, 0, 0,14,14,10,10,11,11,12,12,13,13, 0,
		 0, 0, 0, 0,11,12,11,11,12,12,14,13, 0, 0, 0, 0,
		 0,12,11,11,11,13,10,14,13,
};

static const static_codebook _44c1_s_p7_0 = {
		2, 169,
		(long *)_vq_lengthlist__44c1_s_p7_0,
		1, -526516224, 1616117760, 4, 0,
		(long *)_vq_quantlist__44c1_s_p7_0,
		0
};

static const long _vq_quantlist__44c1_s_p7_1[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__44c1_s_p7_1[] = {
		 2, 3, 3, 5, 5, 6, 6, 6, 5, 5, 6, 6, 6, 5, 5, 6,
		 6, 6, 5, 5, 6, 6, 6, 5, 5,
};

static const static_codebook _44c1_s_p7_1 = {
		2, 25,
		(long *)_vq_lengthlist__44c1_s_p7_1,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__44c1_s_p7_1,
		0
};

static const long _vq_quantlist__44c1_s_p8_0[] = {
		6,
		5,
		7,
		4,
		8,
		3,
		9,
		2,
		10,
		1,
		11,
		0,
		12,
};

static const long _vq_lengthlist__44c1_s_p8_0[] = {
		 1, 4, 3,10,10,10,10,10,10,10,10,10,10, 4, 8, 6,
		10,10,10,10,10,10,10,10,10,10, 4, 8, 7,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,
};

static const static_codebook _44c1_s_p8_0 = {
		2, 169,
		(long *)_vq_lengthlist__44c1_s_p8_0,
		1, -514541568, 1627103232, 4, 0,
		(long *)_vq_quantlist__44c1_s_p8_0,
		0
};

static const long _vq_quantlist__44c1_s_p8_1[] = {
		6,
		5,
		7,
		4,
		8,
		3,
		9,
		2,
		10,
		1,
		11,
		0,
		12,
};

static const long _vq_lengthlist__44c1_s_p8_1[] = {
		 1, 4, 4, 6, 5, 7, 7, 9, 9,10,10,12,12, 6, 5, 5,
		 7, 7, 8, 8,10,10,12,11,12,12, 6, 5, 5, 7, 7, 8,
		 8,10,10,11,11,12,12,15, 7, 7, 8, 8, 9, 9,11,11,
		12,12,13,12,15, 8, 8, 8, 7, 9, 9,10,10,12,12,13,
		13,16,11,10, 8, 8,10,10,11,11,12,12,13,13,16,11,
		11, 9, 8,11,10,11,11,12,12,13,12,16,16,16,10,11,
		10,11,12,12,12,12,13,13,16,16,16,11, 9,11, 9,14,
		12,12,12,13,13,16,16,16,12,14,11,12,12,12,13,13,
		14,13,16,16,16,15,13,12,10,13,10,13,14,13,13,16,
		16,16,16,16,13,14,12,13,13,12,13,13,16,16,16,16,
		16,13,12,12,11,14,12,15,13,
};

static const static_codebook _44c1_s_p8_1 = {
		2, 169,
		(long *)_vq_lengthlist__44c1_s_p8_1,
		1, -522616832, 1620115456, 4, 0,
		(long *)_vq_quantlist__44c1_s_p8_1,
		0
};

static const long _vq_quantlist__44c1_s_p8_2[] = {
		8,
		7,
		9,
		6,
		10,
		5,
		11,
		4,
		12,
		3,
		13,
		2,
		14,
		1,
		15,
		0,
		16,
};

static const long _vq_lengthlist__44c1_s_p8_2[] = {
		 2, 4, 4, 6, 6, 6, 6, 7, 7, 8, 8, 8, 8, 8, 8, 8,
		 8,10,10,10, 7, 7, 7, 7, 8, 8, 9, 9, 9, 9, 9, 9,
		 9, 9,10,10,10, 7, 7, 8, 7, 8, 8, 9, 9, 9, 9, 9,
		 9, 9, 9,10,10,10, 7, 7, 8, 8, 8, 9, 9, 9, 9, 9,
		 9,10, 9, 9,10,10,10, 7, 7, 8, 8, 9, 8, 9, 9, 9,
		 9,10, 9, 9,10,10,11,11, 8, 8, 8, 8, 9, 9, 9, 9,
		 9, 9,10, 9, 9,10,10,10,10, 8, 8, 8, 8, 9, 9, 9,
		 9, 9, 9, 9, 9,10,10,11,11,11, 8, 8, 9, 9, 9, 9,
		 9, 9, 9, 9, 9, 9,10,10,10,10,11,11,11, 8, 8, 9,
		 9, 9, 9,10, 9, 9, 9, 9, 9,11,11,11,11,11, 9, 9,
		 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,11,10,10,11,11, 9,
		 9, 9, 9, 9, 9, 9, 9, 9,10,10,10,10,11,10,11,11,
		 9, 9, 9, 9, 9, 9, 9, 9, 9,10,10, 9,10,10,11,11,
		11,11,11, 9, 9, 9,10, 9, 9, 9, 9, 9, 9,10,11,11,
		11,11,11,11,10,10,10,10, 9, 9, 9, 9, 9, 9,10,11,
		11,11,11,11,11, 9,10, 9, 9, 9, 9,10, 9, 9, 9,11,
		11,11,11,11,11,11,10,10, 9, 9, 9, 9, 9, 9,10, 9,
		11,11,10,11,11,11,11,10,11, 9, 9, 9, 9, 9, 9, 9,
		 9,
};

static const static_codebook _44c1_s_p8_2 = {
		2, 289,
		(long *)_vq_lengthlist__44c1_s_p8_2,
		1, -529530880, 1611661312, 5, 0,
		(long *)_vq_quantlist__44c1_s_p8_2,
		0
};

static const long _huff_lengthlist__44c1_s_short[] = {
		 6, 8,13,12,13,14,15,16,16, 4, 2, 4, 7, 6, 8,11,
		13,15,10, 4, 4, 8, 6, 8,11,14,17,11, 5, 6, 5, 6,
		 8,12,14,17,11, 5, 5, 6, 5, 7,10,13,16,12, 6, 7,
		 8, 7, 8,10,13,15,13, 8, 8, 7, 7, 8,10,12,15,15,
		 7, 7, 5, 5, 7, 9,12,14,15, 8, 8, 6, 6, 7, 8,10,
		11,
};

static const static_codebook _huff_book__44c1_s_short = {
		2, 81,
		(long *)_huff_lengthlist__44c1_s_short,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist__44c1_sm_long[] = {
		 5, 4, 8,10, 9, 9,10,11,12, 4, 2, 5, 6, 6, 8,10,
		11,13, 8, 4, 6, 8, 7, 9,12,12,14,10, 6, 8, 4, 5,
		 6, 9,11,12, 9, 5, 6, 5, 5, 6, 9,11,11, 9, 7, 9,
		 6, 5, 5, 7,10,10,10, 9,11, 8, 7, 6, 7, 9,11,11,
		12,13,10,10, 9, 8, 9,11,11,15,15,12,13,11, 9,10,
		11,
};

static const static_codebook _huff_book__44c1_sm_long = {
		2, 81,
		(long *)_huff_lengthlist__44c1_sm_long,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _vq_quantlist__44c1_sm_p1_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__44c1_sm_p1_0[] = {
		 1, 5, 5, 0, 0, 0, 0, 0, 0, 5, 7, 7, 0, 0, 0, 0,
		 0, 0, 5, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 5, 8, 7, 0, 0, 0, 0, 0, 0, 7, 9, 9, 0, 0, 0,
		 0, 0, 0, 7, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 5, 7, 7, 0, 0, 0, 0, 0, 0, 7, 9, 8, 0, 0,
		 0, 0, 0, 0, 7, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 8, 7, 0, 0, 0, 0,
		 0, 0, 8, 9, 9, 0, 0, 0, 0, 0, 0, 8, 9, 9, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 9, 9, 0, 0, 0,
		 0, 0, 0, 9, 9,10, 0, 0, 0, 0, 0, 0, 9,10,10, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 9, 9, 0, 0,
		 0, 0, 0, 0, 8,10, 9, 0, 0, 0, 0, 0, 0, 9,10,10,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 5, 7, 8, 0, 0, 0, 0, 0, 0, 8, 9, 9, 0, 0,
		 0, 0, 0, 0, 8, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 7, 9, 9, 0, 0, 0, 0, 0, 0, 9,10,10, 0,
		 0, 0, 0, 0, 0, 8, 9,10, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 7, 9, 9, 0, 0, 0, 0, 0, 0, 9,10,10,
		 0, 0, 0, 0, 0, 0, 9,10, 9, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0,
};

static const static_codebook _44c1_sm_p1_0 = {
		8, 6561,
		(long *)_vq_lengthlist__44c1_sm_p1_0,
		1, -535822336, 1611661312, 2, 0,
		(long *)_vq_quantlist__44c1_sm_p1_0,
		0
};

static const long _vq_quantlist__44c1_sm_p2_0[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__44c1_sm_p2_0[] = {
		 2, 3, 4, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 6, 6, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 4, 4, 4, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 9, 9,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 6, 6, 7, 9, 9, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0,
};

static const static_codebook _44c1_sm_p2_0 = {
		4, 625,
		(long *)_vq_lengthlist__44c1_sm_p2_0,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__44c1_sm_p2_0,
		0
};

static const long _vq_quantlist__44c1_sm_p3_0[] = {
		4,
		3,
		5,
		2,
		6,
		1,
		7,
		0,
		8,
};

static const long _vq_lengthlist__44c1_sm_p3_0[] = {
		 1, 3, 3, 7, 7, 0, 0, 0, 0, 0, 5, 5, 6, 6, 0, 0,
		 0, 0, 0, 5, 5, 7, 7, 0, 0, 0, 0, 0, 7, 7, 7, 7,
		 0, 0, 0, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0, 0, 0,
		 8, 9, 0, 0, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0,
		 0, 0,10,10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0,
};

static const static_codebook _44c1_sm_p3_0 = {
		2, 81,
		(long *)_vq_lengthlist__44c1_sm_p3_0,
		1, -531628032, 1611661312, 4, 0,
		(long *)_vq_quantlist__44c1_sm_p3_0,
		0
};

static const long _vq_quantlist__44c1_sm_p4_0[] = {
		4,
		3,
		5,
		2,
		6,
		1,
		7,
		0,
		8,
};

static const long _vq_lengthlist__44c1_sm_p4_0[] = {
		 1, 3, 3, 6, 6, 7, 7, 9, 9, 0, 6, 6, 7, 7, 8, 8,
		 9, 9, 0, 6, 6, 7, 7, 8, 8, 9, 9, 0, 7, 7, 8, 8,
		 8, 8,10,10, 0, 0, 0, 8, 8, 8, 8,10,10, 0, 0, 0,
		 8, 8, 9, 9,11,11, 0, 0, 0, 9, 9, 9, 9,11,11, 0,
		 0, 0,10,10,10,10,11,11, 0, 0, 0, 0, 0, 9, 9,11,
		11,
};

static const static_codebook _44c1_sm_p4_0 = {
		2, 81,
		(long *)_vq_lengthlist__44c1_sm_p4_0,
		1, -531628032, 1611661312, 4, 0,
		(long *)_vq_quantlist__44c1_sm_p4_0,
		0
};

static const long _vq_quantlist__44c1_sm_p5_0[] = {
		8,
		7,
		9,
		6,
		10,
		5,
		11,
		4,
		12,
		3,
		13,
		2,
		14,
		1,
		15,
		0,
		16,
};

static const long _vq_lengthlist__44c1_sm_p5_0[] = {
		 2, 3, 3, 6, 6, 7, 7, 8, 8, 8, 8, 9, 9,10,10,11,
		11, 0, 5, 5, 6, 6, 8, 8, 9, 9, 9, 9,10,10,10,10,
		11,11, 0, 5, 5, 6, 6, 8, 8, 9, 9, 9, 9,10,10,10,
		10,11,11, 0, 7, 7, 7, 7, 8, 8, 9, 9, 9, 9,10,10,
		11,11,12,12, 0, 0, 0, 7, 7, 8, 8, 9, 9, 9, 9,10,
		10,11,11,12,12, 0, 0, 0, 8, 8, 8, 8, 9, 9,10,10,
		10,11,11,11,12,12, 0, 0, 0, 8, 8, 8, 8, 9, 9,10,
		10,10,10,11,11,12,12, 0, 0, 0, 9, 9, 9, 9,10,10,
		10,10,11,11,12,12,12,12, 0, 0, 0, 0, 0, 9, 9,10,
		10,10,10,11,11,12,12,13,13, 0, 0, 0, 0, 0, 9, 9,
		 9, 9,10,10,11,11,12,12,13,13, 0, 0, 0, 0, 0, 9,
		 9, 9, 9,10,10,11,11,12,12,13,13, 0, 0, 0, 0, 0,
		 9, 9,10,10,11,11,12,12,12,12,13,13, 0, 0, 0, 0,
		 0, 0, 0,10,10,11,11,12,12,12,12,13,13, 0, 0, 0,
		 0, 0, 0, 0,11,11,11,11,12,12,13,13,13,13, 0, 0,
		 0, 0, 0, 0, 0,11,11,11,11,12,12,13,13,13,13, 0,
		 0, 0, 0, 0, 0, 0,11,11,12,12,12,12,13,13,14,14,
		 0, 0, 0, 0, 0, 0, 0, 0, 0,12,12,12,12,13,13,14,
		14,
};

static const static_codebook _44c1_sm_p5_0 = {
		2, 289,
		(long *)_vq_lengthlist__44c1_sm_p5_0,
		1, -529530880, 1611661312, 5, 0,
		(long *)_vq_quantlist__44c1_sm_p5_0,
		0
};

static const long _vq_quantlist__44c1_sm_p6_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__44c1_sm_p6_0[] = {
		 1, 4, 4, 7, 6, 6, 7, 6, 6, 4, 7, 7,10, 9, 9,11,
		 9, 9, 4, 7, 7,10, 9, 9,11, 9, 9, 7,10,10,10,11,
		11,11,10,10, 6, 9, 9,11,11,10,11,10,10, 6, 9, 9,
		11,10,11,11,10,10, 7,11,11,11,11,11,11,11,11, 6,
		 9, 9,11,10,10,11,11,10, 6, 9, 9,10,10,10,11,10,
		11,
};

static const static_codebook _44c1_sm_p6_0 = {
		4, 81,
		(long *)_vq_lengthlist__44c1_sm_p6_0,
		1, -529137664, 1618345984, 2, 0,
		(long *)_vq_quantlist__44c1_sm_p6_0,
		0
};

static const long _vq_quantlist__44c1_sm_p6_1[] = {
		5,
		4,
		6,
		3,
		7,
		2,
		8,
		1,
		9,
		0,
		10,
};

static const long _vq_lengthlist__44c1_sm_p6_1[] = {
		 2, 4, 4, 6, 6, 7, 7, 7, 7, 8, 8,10, 5, 5, 6, 6,
		 7, 7, 8, 8, 8, 8,10, 5, 5, 6, 6, 7, 7, 8, 8, 8,
		 8,10, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8,10,10,10, 7,
		 7, 7, 7, 8, 8, 8, 8,10,10,10, 7, 7, 8, 8, 8, 8,
		 8, 8,10,10,10, 7, 7, 8, 8, 8, 8, 8, 8,10,10,10,
		 8, 8, 8, 8, 8, 8, 9, 8,10,10,10,10,10, 8, 8, 8,
		 8, 8, 8,10,10,10,10,10, 9, 9, 8, 8, 8, 8,10,10,
		10,10,10, 8, 8, 8, 8, 8, 8,
};

static const static_codebook _44c1_sm_p6_1 = {
		2, 121,
		(long *)_vq_lengthlist__44c1_sm_p6_1,
		1, -531365888, 1611661312, 4, 0,
		(long *)_vq_quantlist__44c1_sm_p6_1,
		0
};

static const long _vq_quantlist__44c1_sm_p7_0[] = {
		6,
		5,
		7,
		4,
		8,
		3,
		9,
		2,
		10,
		1,
		11,
		0,
		12,
};

static const long _vq_lengthlist__44c1_sm_p7_0[] = {
		 1, 4, 4, 6, 6, 7, 7, 7, 7, 8, 8, 9, 9, 7, 5, 5,
		 7, 7, 8, 8, 8, 8, 9, 9,10,10, 7, 5, 6, 7, 7, 8,
		 8, 8, 8, 9, 9,11,10, 0, 8, 8, 8, 8, 9, 9, 9, 9,
		10,10,11,11, 0, 8, 8, 8, 8, 9, 9, 9, 9,10,10,11,
		11, 0,12,12, 9, 9,10,10,10,10,11,11,11,11, 0,13,
		13, 9, 9, 9, 9,10,10,11,11,12,12, 0, 0, 0, 9,10,
		 9,10,11,11,12,11,13,12, 0, 0, 0,10,10, 9, 9,11,
		11,12,12,13,12, 0, 0, 0,13,13,10,10,11,11,12,12,
		13,13, 0, 0, 0,14,14,10,10,11,11,12,12,13,13, 0,
		 0, 0, 0, 0,11,12,11,11,12,13,14,13, 0, 0, 0, 0,
		 0,12,12,11,11,13,12,14,13,
};

static const static_codebook _44c1_sm_p7_0 = {
		2, 169,
		(long *)_vq_lengthlist__44c1_sm_p7_0,
		1, -526516224, 1616117760, 4, 0,
		(long *)_vq_quantlist__44c1_sm_p7_0,
		0
};

static const long _vq_quantlist__44c1_sm_p7_1[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__44c1_sm_p7_1[] = {
		 2, 4, 4, 4, 5, 6, 5, 5, 5, 5, 6, 5, 5, 5, 5, 6,
		 5, 5, 5, 5, 6, 6, 6, 5, 5,
};

static const static_codebook _44c1_sm_p7_1 = {
		2, 25,
		(long *)_vq_lengthlist__44c1_sm_p7_1,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__44c1_sm_p7_1,
		0
};

static const long _vq_quantlist__44c1_sm_p8_0[] = {
		6,
		5,
		7,
		4,
		8,
		3,
		9,
		2,
		10,
		1,
		11,
		0,
		12,
};

static const long _vq_lengthlist__44c1_sm_p8_0[] = {
		 1, 3, 3,13,13,13,13,13,13,13,13,13,13, 3, 6, 6,
		13,13,13,13,13,13,13,13,13,13, 4, 8, 7,13,13,13,
		13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
		13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
		13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
		13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
		13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
		13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
		13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
		13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
		13,13,13,13,13,13,13,13,13,
};

static const static_codebook _44c1_sm_p8_0 = {
		2, 169,
		(long *)_vq_lengthlist__44c1_sm_p8_0,
		1, -514541568, 1627103232, 4, 0,
		(long *)_vq_quantlist__44c1_sm_p8_0,
		0
};

static const long _vq_quantlist__44c1_sm_p8_1[] = {
		6,
		5,
		7,
		4,
		8,
		3,
		9,
		2,
		10,
		1,
		11,
		0,
		12,
};

static const long _vq_lengthlist__44c1_sm_p8_1[] = {
		 1, 4, 4, 6, 6, 7, 7, 9, 9,10,11,12,12, 6, 5, 5,
		 7, 7, 8, 7,10,10,11,11,12,12, 6, 5, 5, 7, 7, 8,
		 8,10,10,11,11,12,12,16, 7, 7, 8, 8, 9, 9,11,11,
		12,12,13,13,17, 7, 7, 8, 7, 9, 9,11,10,12,12,13,
		13,19,11,10, 8, 8,10,10,11,11,12,12,13,13,19,11,
		11, 9, 7,11,10,11,11,12,12,13,12,19,19,19,10,10,
		10,10,11,12,12,12,13,14,18,19,19,11, 9,11, 9,13,
		12,12,12,13,13,19,20,19,13,15,11,11,12,12,13,13,
		14,13,18,19,20,15,13,12,10,13,10,13,13,13,14,20,
		20,20,20,20,13,14,12,12,13,12,13,13,20,20,20,20,
		20,13,12,12,12,14,12,14,13,
};

static const static_codebook _44c1_sm_p8_1 = {
		2, 169,
		(long *)_vq_lengthlist__44c1_sm_p8_1,
		1, -522616832, 1620115456, 4, 0,
		(long *)_vq_quantlist__44c1_sm_p8_1,
		0
};

static const long _vq_quantlist__44c1_sm_p8_2[] = {
		8,
		7,
		9,
		6,
		10,
		5,
		11,
		4,
		12,
		3,
		13,
		2,
		14,
		1,
		15,
		0,
		16,
};

static const long _vq_lengthlist__44c1_sm_p8_2[] = {
		 2, 5, 5, 6, 6, 7, 6, 7, 7, 8, 8, 8, 8, 8, 8, 8,
		 8,10, 6, 6, 7, 7, 7, 7, 8, 8, 9, 9, 9, 9, 9, 9,
		 9, 9,10, 6, 6, 7, 7, 8, 8, 8, 8, 9, 9, 9, 9, 9,
		 9, 9, 9,10, 7, 7, 7, 7, 8, 8, 8, 9, 9, 9, 9, 9,
		 9, 9, 9, 9,10,10,10, 7, 7, 8, 8, 9, 9, 9, 9, 9,
		 9, 9, 9, 9, 9,10,11,11, 8, 8, 8, 8, 9, 9, 9, 9,
		 9, 9,10,10, 9,10,10,10,10, 8, 8, 8, 8, 9, 9, 9,
		 9, 9, 9, 9, 9,10,10,11,10,10, 8, 8, 9, 9, 9, 9,
		 9, 9, 9, 9, 9, 9,10, 9,10,10,10,11,11, 8, 8, 9,
		 9, 9, 9, 9, 9, 9, 9, 9, 9,11,11,11,11,11, 9, 9,
		 9, 9, 9, 9, 9, 9,10, 9,10, 9,11,11,11,11,11, 9,
		 8, 9, 9, 9, 9, 9, 9, 9,10,10, 9,11,11,10,11,11,
		 9, 9, 9, 9, 9, 9, 9, 9, 9,10,10, 9,11,11,11,11,
		11,11,11, 9, 9,10, 9, 9, 9, 9,10, 9,10,10,11,10,
		11,11,11,11, 9,10,10,10, 9, 9, 9, 9, 9, 9,10,11,
		11,11,11,11,11, 9, 9, 9, 9, 9, 9, 9, 9,10, 9,11,
		11,10,11,11,11,11,10,10, 9, 9, 9, 9, 9, 9,10, 9,
		10,11,10,11,11,11,11,11,11, 9, 9,10, 9, 9, 9, 9,
		 9,
};

static const static_codebook _44c1_sm_p8_2 = {
		2, 289,
		(long *)_vq_lengthlist__44c1_sm_p8_2,
		1, -529530880, 1611661312, 5, 0,
		(long *)_vq_quantlist__44c1_sm_p8_2,
		0
};

static const long _huff_lengthlist__44c1_sm_short[] = {
		 4, 7,13,14,14,15,16,18,18, 4, 2, 5, 8, 7, 9,12,
		15,15,10, 4, 5,10, 6, 8,11,15,17,12, 5, 7, 5, 6,
		 8,11,14,17,11, 5, 6, 6, 5, 6, 9,13,17,12, 6, 7,
		 6, 5, 6, 8,12,14,14, 7, 8, 6, 6, 7, 9,11,14,14,
		 8, 9, 6, 5, 6, 9,11,13,16,10,10, 7, 6, 7, 8,10,
		11,
};

static const static_codebook _huff_book__44c1_sm_short = {
		2, 81,
		(long *)_huff_lengthlist__44c1_sm_short,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist__44cn1_s_long[] = {
		 4, 4, 7, 8, 7, 8,10,12,17, 3, 1, 6, 6, 7, 8,10,
		12,15, 7, 6, 9, 9, 9,11,12,14,17, 8, 6, 9, 6, 7,
		 9,11,13,17, 7, 6, 9, 7, 7, 8, 9,12,15, 8, 8,10,
		 8, 7, 7, 7,10,14, 9,10,12,10, 8, 8, 8,10,14,11,
		13,15,13,12,11,11,12,16,17,18,18,19,20,18,16,16,
		20,
};

static const static_codebook _huff_book__44cn1_s_long = {
		2, 81,
		(long *)_huff_lengthlist__44cn1_s_long,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _vq_quantlist__44cn1_s_p1_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__44cn1_s_p1_0[] = {
		 1, 4, 4, 0, 0, 0, 0, 0, 0, 5, 7, 7, 0, 0, 0, 0,
		 0, 0, 5, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 5, 8, 8, 0, 0, 0, 0, 0, 0, 8, 9, 9, 0, 0, 0,
		 0, 0, 0, 7, 9,10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 5, 8, 8, 0, 0, 0, 0, 0, 0, 7,10, 9, 0, 0,
		 0, 0, 0, 0, 8,10, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 8, 8, 0, 0, 0, 0,
		 0, 0, 8,10,10, 0, 0, 0, 0, 0, 0, 8, 9,10, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7,10,10, 0, 0, 0,
		 0, 0, 0, 9, 9,11, 0, 0, 0, 0, 0, 0,10,11,11, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7,10,10, 0, 0,
		 0, 0, 0, 0, 9,11, 9, 0, 0, 0, 0, 0, 0,10,11,11,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 5, 8, 8, 0, 0, 0, 0, 0, 0, 8,10,10, 0, 0,
		 0, 0, 0, 0, 8,10,10, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 7,10,10, 0, 0, 0, 0, 0, 0,10,11,11, 0,
		 0, 0, 0, 0, 0, 9, 9,11, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 7,10,10, 0, 0, 0, 0, 0, 0,10,11,11,
		 0, 0, 0, 0, 0, 0, 9,11, 9, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0,
};

static const static_codebook _44cn1_s_p1_0 = {
		8, 6561,
		(long *)_vq_lengthlist__44cn1_s_p1_0,
		1, -535822336, 1611661312, 2, 0,
		(long *)_vq_quantlist__44cn1_s_p1_0,
		0
};

static const long _vq_quantlist__44cn1_s_p2_0[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__44cn1_s_p2_0[] = {
		 1, 4, 4, 7, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 5, 5, 7, 7, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 4, 5, 5, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 7, 7, 9, 9,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 6, 7, 7, 9, 9, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0,
};

static const static_codebook _44cn1_s_p2_0 = {
		4, 625,
		(long *)_vq_lengthlist__44cn1_s_p2_0,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__44cn1_s_p2_0,
		0
};

static const long _vq_quantlist__44cn1_s_p3_0[] = {
		4,
		3,
		5,
		2,
		6,
		1,
		7,
		0,
		8,
};

static const long _vq_lengthlist__44cn1_s_p3_0[] = {
		 1, 2, 3, 7, 7, 0, 0, 0, 0, 0, 0, 0, 6, 6, 0, 0,
		 0, 0, 0, 0, 0, 6, 6, 0, 0, 0, 0, 0, 0, 0, 7, 7,
		 0, 0, 0, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0, 0, 0,
		 9, 8, 0, 0, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0,
		 0, 0,10,10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0,
};

static const static_codebook _44cn1_s_p3_0 = {
		2, 81,
		(long *)_vq_lengthlist__44cn1_s_p3_0,
		1, -531628032, 1611661312, 4, 0,
		(long *)_vq_quantlist__44cn1_s_p3_0,
		0
};

static const long _vq_quantlist__44cn1_s_p4_0[] = {
		4,
		3,
		5,
		2,
		6,
		1,
		7,
		0,
		8,
};

static const long _vq_lengthlist__44cn1_s_p4_0[] = {
		 1, 3, 3, 6, 6, 6, 6, 8, 8, 0, 0, 0, 6, 6, 7, 7,
		 9, 9, 0, 0, 0, 6, 6, 7, 7, 9, 9, 0, 0, 0, 7, 7,
		 8, 8,10,10, 0, 0, 0, 7, 7, 8, 8,10,10, 0, 0, 0,
		 9, 9, 9, 9,10,10, 0, 0, 0, 9, 9, 9, 9,10,10, 0,
		 0, 0,10,10,10,10,11,11, 0, 0, 0, 0, 0,10,10,11,
		11,
};

static const static_codebook _44cn1_s_p4_0 = {
		2, 81,
		(long *)_vq_lengthlist__44cn1_s_p4_0,
		1, -531628032, 1611661312, 4, 0,
		(long *)_vq_quantlist__44cn1_s_p4_0,
		0
};

static const long _vq_quantlist__44cn1_s_p5_0[] = {
		8,
		7,
		9,
		6,
		10,
		5,
		11,
		4,
		12,
		3,
		13,
		2,
		14,
		1,
		15,
		0,
		16,
};

static const long _vq_lengthlist__44cn1_s_p5_0[] = {
		 1, 4, 3, 6, 6, 7, 7, 8, 8, 8, 8, 9, 9,10,10,10,
		10, 0, 0, 0, 7, 7, 8, 8, 9, 9, 9, 9,10,10,10,10,
		11,11, 0, 0, 0, 7, 7, 8, 8, 9, 9, 9, 9,10,10,10,
		10,11,11, 0, 0, 0, 7, 7, 8, 8, 9, 9, 9, 9,10,10,
		11,11,11,12, 0, 0, 0, 7, 7, 8, 8, 9, 9, 9, 9,10,
		10,11,11,11,11, 0, 0, 0, 8, 8, 9, 9, 9, 9,10,10,
		10,10,11,11,12,12, 0, 0, 0, 8, 8, 9, 9, 9, 9,10,
		10,10,11,11,11,12,12, 0, 0, 0, 9, 9,10, 9,10,10,
		10,10,11,11,11,11,12,12, 0, 0, 0, 0, 0, 9, 9,10,
		10,10,10,11,11,12,12,12,12, 0, 0, 0, 0, 0, 9, 9,
		10,10,10,11,11,11,12,12,13,13, 0, 0, 0, 0, 0, 9,
		 9,10,10,10,10,11,11,12,12,13,13, 0, 0, 0, 0, 0,
		10,10,11,10,11,11,11,12,13,12,13,13, 0, 0, 0, 0,
		 0, 0, 0,11,10,11,11,12,12,12,12,13,13, 0, 0, 0,
		 0, 0, 0, 0,11,11,12,12,12,12,13,13,13,14, 0, 0,
		 0, 0, 0, 0, 0,11,11,12,12,12,12,13,13,13,14, 0,
		 0, 0, 0, 0, 0, 0,12,12,12,13,13,13,13,13,14,14,
		 0, 0, 0, 0, 0, 0, 0, 0, 0,12,12,13,12,13,13,14,
		14,
};

static const static_codebook _44cn1_s_p5_0 = {
		2, 289,
		(long *)_vq_lengthlist__44cn1_s_p5_0,
		1, -529530880, 1611661312, 5, 0,
		(long *)_vq_quantlist__44cn1_s_p5_0,
		0
};

static const long _vq_quantlist__44cn1_s_p6_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__44cn1_s_p6_0[] = {
		 1, 4, 4, 7, 6, 6, 7, 6, 6, 4, 6, 6,10, 9, 9,11,
		 9, 9, 4, 6, 6,10, 9, 9,10, 9, 9, 7,10,10,11,11,
		11,12,11,11, 7, 9, 9,11,11,10,11,10,10, 7, 9, 9,
		11,10,11,11,10,10, 7,10,10,11,11,11,12,11,11, 7,
		 9, 9,11,10,10,11,10,10, 7, 9, 9,11,10,10,11,10,
		10,
};

static const static_codebook _44cn1_s_p6_0 = {
		4, 81,
		(long *)_vq_lengthlist__44cn1_s_p6_0,
		1, -529137664, 1618345984, 2, 0,
		(long *)_vq_quantlist__44cn1_s_p6_0,
		0
};

static const long _vq_quantlist__44cn1_s_p6_1[] = {
		5,
		4,
		6,
		3,
		7,
		2,
		8,
		1,
		9,
		0,
		10,
};

static const long _vq_lengthlist__44cn1_s_p6_1[] = {
		 1, 4, 4, 6, 6, 7, 7, 8, 8, 8, 8,10,10,10, 7, 6,
		 8, 8, 8, 8, 8, 8,10,10,10, 7, 6, 7, 7, 8, 8, 8,
		 8,10,10,10, 7, 7, 8, 8, 8, 8, 8, 8,10,10,10, 7,
		 7, 8, 8, 8, 8, 8, 8,10,10,10, 8, 8, 8, 8, 9, 9,
		 9, 9,10,10,10, 8, 8, 8, 8, 9, 9, 9, 9,10,10,10,
		 9, 9, 9, 9, 9, 9, 9, 9,10,10,10,10,10, 9, 9, 9,
		 9, 9, 9,10,10,10,10,10, 9, 9, 9, 9, 9, 9,10,10,
		10,10,10, 9, 9, 9, 9, 9, 9,
};

static const static_codebook _44cn1_s_p6_1 = {
		2, 121,
		(long *)_vq_lengthlist__44cn1_s_p6_1,
		1, -531365888, 1611661312, 4, 0,
		(long *)_vq_quantlist__44cn1_s_p6_1,
		0
};

static const long _vq_quantlist__44cn1_s_p7_0[] = {
		6,
		5,
		7,
		4,
		8,
		3,
		9,
		2,
		10,
		1,
		11,
		0,
		12,
};

static const long _vq_lengthlist__44cn1_s_p7_0[] = {
		 1, 4, 4, 6, 6, 7, 7, 8, 8, 9, 9,10,10, 6, 5, 5,
		 7, 7, 8, 8, 8, 8, 9, 9,11,11, 7, 5, 5, 7, 7, 8,
		 8, 8, 8, 9,10,11,11, 0, 8, 8, 8, 8, 9, 9, 9, 9,
		10,10,11,11, 0, 8, 8, 8, 8, 9, 9, 9, 9,10,10,11,
		11, 0,12,12, 9, 9, 9,10,10,10,11,11,11,12, 0,13,
		13, 9, 9, 9, 9,10,10,11,11,11,12, 0, 0, 0,10,10,
		10,10,11,11,12,12,12,13, 0, 0, 0,10,10,10,10,11,
		11,12,12,13,12, 0, 0, 0,14,14,11,10,11,12,12,13,
		13,14, 0, 0, 0,15,15,11,11,12,11,12,12,14,13, 0,
		 0, 0, 0, 0,12,12,12,12,13,13,14,14, 0, 0, 0, 0,
		 0,13,13,12,12,13,13,13,14,
};

static const static_codebook _44cn1_s_p7_0 = {
		2, 169,
		(long *)_vq_lengthlist__44cn1_s_p7_0,
		1, -526516224, 1616117760, 4, 0,
		(long *)_vq_quantlist__44cn1_s_p7_0,
		0
};

static const long _vq_quantlist__44cn1_s_p7_1[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__44cn1_s_p7_1[] = {
		 2, 3, 3, 5, 5, 6, 6, 6, 5, 5, 6, 6, 6, 5, 5, 6,
		 6, 6, 5, 5, 6, 6, 6, 5, 5,
};

static const static_codebook _44cn1_s_p7_1 = {
		2, 25,
		(long *)_vq_lengthlist__44cn1_s_p7_1,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__44cn1_s_p7_1,
		0
};

static const long _vq_quantlist__44cn1_s_p8_0[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__44cn1_s_p8_0[] = {
		 1, 7, 7,11,11, 8,11,11,11,11, 4,11, 3,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,10,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,10,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11, 7,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,10,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,10,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11, 8,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,12,12,12,12,12,12,12,12,12,
		12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
		12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
		12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
		12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
		12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
		12,
};

static const static_codebook _44cn1_s_p8_0 = {
		4, 625,
		(long *)_vq_lengthlist__44cn1_s_p8_0,
		1, -518283264, 1627103232, 3, 0,
		(long *)_vq_quantlist__44cn1_s_p8_0,
		0
};

static const long _vq_quantlist__44cn1_s_p8_1[] = {
		6,
		5,
		7,
		4,
		8,
		3,
		9,
		2,
		10,
		1,
		11,
		0,
		12,
};

static const long _vq_lengthlist__44cn1_s_p8_1[] = {
		 1, 4, 4, 6, 6, 8, 8, 9,10,10,11,11,11, 6, 5, 5,
		 7, 7, 8, 8, 9,10, 9,11,11,12, 5, 5, 5, 7, 7, 8,
		 9,10,10,12,12,14,13,15, 7, 7, 8, 8, 9,10,11,11,
		10,12,10,11,15, 7, 8, 8, 8, 9, 9,11,11,13,12,12,
		13,15,10,10, 8, 8,10,10,12,12,11,14,10,10,15,11,
		11, 8, 8,10,10,12,13,13,14,15,13,15,15,15,10,10,
		10,10,12,12,13,12,13,10,15,15,15,10,10,11,10,13,
		11,13,13,15,13,15,15,15,13,13,10,11,11,11,12,10,
		14,11,15,15,14,14,13,10,10,12,11,13,13,14,14,15,
		15,15,15,15,11,11,11,11,12,11,15,12,15,15,15,15,
		15,12,12,11,11,14,12,13,14,
};

static const static_codebook _44cn1_s_p8_1 = {
		2, 169,
		(long *)_vq_lengthlist__44cn1_s_p8_1,
		1, -522616832, 1620115456, 4, 0,
		(long *)_vq_quantlist__44cn1_s_p8_1,
		0
};

static const long _vq_quantlist__44cn1_s_p8_2[] = {
		8,
		7,
		9,
		6,
		10,
		5,
		11,
		4,
		12,
		3,
		13,
		2,
		14,
		1,
		15,
		0,
		16,
};

static const long _vq_lengthlist__44cn1_s_p8_2[] = {
		 3, 4, 3, 6, 6, 7, 7, 8, 8, 9, 9, 9, 9, 9, 9, 9,
		 9,10,11,11, 6, 6, 7, 7, 8, 8, 9, 9, 9, 9, 9, 9,
		 9, 9,10,10,10, 6, 6, 7, 7, 8, 8, 9, 9, 9, 9, 9,
		 9, 9, 9,10,10,10, 7, 7, 7, 8, 8, 8, 9, 9, 9, 9,
		 9, 9,10, 9,10,11,10, 7, 6, 7, 7, 8, 8, 9, 9, 9,
		 9, 9, 9, 9,10,10,10,11, 7, 7, 8, 8, 8, 8, 9, 9,
		 9, 9, 9, 9, 9, 9,10,10,10, 7, 7, 8, 8, 8, 8, 9,
		 9, 9, 9, 9, 9, 9,10,11,11,11, 8, 8, 8, 8, 8, 8,
		 9, 9, 9, 9, 9, 9, 9, 9,11,10,10,11,11, 8, 8, 8,
		 9, 9, 9, 9, 9, 9,10, 9,10,10,10,10,11,11, 9, 9,
		 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,11,11,10,11,11, 9,
		 9, 9, 9, 9, 9, 9, 9, 9,10,10,10,10,11,10,11,11,
		 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,11,10,10,11,
		11,11,11, 9, 9, 9, 9, 9, 9, 9, 9,10,10,10,11,11,
		10,11,11,11, 9,10,10, 9, 9, 9, 9, 9, 9, 9,10,11,
		11,11,11,11,11, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,11,
		11,11,11,11,11,11,10,10, 9, 9, 9, 9, 9, 9, 9, 9,
		11,11,11,10,11,11,11,11,11, 9, 9, 9,10, 9, 9, 9,
		 9,
};

static const static_codebook _44cn1_s_p8_2 = {
		2, 289,
		(long *)_vq_lengthlist__44cn1_s_p8_2,
		1, -529530880, 1611661312, 5, 0,
		(long *)_vq_quantlist__44cn1_s_p8_2,
		0
};

static const long _huff_lengthlist__44cn1_s_short[] = {
		10, 9,12,15,12,13,16,14,16, 7, 1, 5,14, 7,10,13,
		16,16, 9, 4, 6,16, 8,11,16,16,16,14, 4, 7,16, 9,
		12,14,16,16,10, 5, 7,14, 9,12,14,15,15,13, 8, 9,
		14,10,12,13,14,15,13, 9, 9, 7, 6, 8,11,12,12,14,
		 8, 8, 5, 4, 5, 8,11,12,16,10,10, 6, 5, 6, 8, 9,
		10,
};

static const static_codebook _huff_book__44cn1_s_short = {
		2, 81,
		(long *)_huff_lengthlist__44cn1_s_short,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist__44cn1_sm_long[] = {
		 3, 3, 8, 8, 8, 8,10,12,14, 3, 2, 6, 7, 7, 8,10,
		12,16, 7, 6, 7, 9, 8,10,12,14,16, 8, 6, 8, 4, 5,
		 7, 9,11,13, 7, 6, 8, 5, 6, 7, 9,11,14, 8, 8,10,
		 7, 7, 6, 8,10,13, 9,11,12, 9, 9, 7, 8,10,12,10,
		13,15,11,11,10, 9,10,13,13,16,17,14,15,14,13,14,
		17,
};

static const static_codebook _huff_book__44cn1_sm_long = {
		2, 81,
		(long *)_huff_lengthlist__44cn1_sm_long,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _vq_quantlist__44cn1_sm_p1_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__44cn1_sm_p1_0[] = {
		 1, 4, 5, 0, 0, 0, 0, 0, 0, 5, 7, 7, 0, 0, 0, 0,
		 0, 0, 5, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 5, 8, 8, 0, 0, 0, 0, 0, 0, 8, 9, 9, 0, 0, 0,
		 0, 0, 0, 7, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 5, 8, 8, 0, 0, 0, 0, 0, 0, 7, 9, 8, 0, 0,
		 0, 0, 0, 0, 8, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 8, 8, 0, 0, 0, 0,
		 0, 0, 8,10, 9, 0, 0, 0, 0, 0, 0, 8, 9, 9, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7,10, 9, 0, 0, 0,
		 0, 0, 0, 9, 9,10, 0, 0, 0, 0, 0, 0, 9,10,10, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 9, 9, 0, 0,
		 0, 0, 0, 0, 8,10, 9, 0, 0, 0, 0, 0, 0, 9,10,10,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 5, 8, 8, 0, 0, 0, 0, 0, 0, 8, 9, 9, 0, 0,
		 0, 0, 0, 0, 8, 9,10, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 7, 9, 9, 0, 0, 0, 0, 0, 0, 9,10,10, 0,
		 0, 0, 0, 0, 0, 8, 9,10, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 7, 9,10, 0, 0, 0, 0, 0, 0, 9,10,10,
		 0, 0, 0, 0, 0, 0, 9,10, 9, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0,
};

static const static_codebook _44cn1_sm_p1_0 = {
		8, 6561,
		(long *)_vq_lengthlist__44cn1_sm_p1_0,
		1, -535822336, 1611661312, 2, 0,
		(long *)_vq_quantlist__44cn1_sm_p1_0,
		0
};

static const long _vq_quantlist__44cn1_sm_p2_0[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__44cn1_sm_p2_0[] = {
		 1, 4, 4, 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 5, 5, 7, 7, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 4, 5, 5, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 7, 7, 9, 9,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 7, 7, 7, 9, 9, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0,
};

static const static_codebook _44cn1_sm_p2_0 = {
		4, 625,
		(long *)_vq_lengthlist__44cn1_sm_p2_0,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__44cn1_sm_p2_0,
		0
};

static const long _vq_quantlist__44cn1_sm_p3_0[] = {
		4,
		3,
		5,
		2,
		6,
		1,
		7,
		0,
		8,
};

static const long _vq_lengthlist__44cn1_sm_p3_0[] = {
		 1, 3, 4, 7, 7, 0, 0, 0, 0, 0, 4, 4, 7, 7, 0, 0,
		 0, 0, 0, 4, 5, 7, 7, 0, 0, 0, 0, 0, 6, 7, 8, 8,
		 0, 0, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0,
		 9, 9, 0, 0, 0, 0, 0, 0, 0,10, 9, 0, 0, 0, 0, 0,
		 0, 0,11,11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		 0,
};

static const static_codebook _44cn1_sm_p3_0 = {
		2, 81,
		(long *)_vq_lengthlist__44cn1_sm_p3_0,
		1, -531628032, 1611661312, 4, 0,
		(long *)_vq_quantlist__44cn1_sm_p3_0,
		0
};

static const long _vq_quantlist__44cn1_sm_p4_0[] = {
		4,
		3,
		5,
		2,
		6,
		1,
		7,
		0,
		8,
};

static const long _vq_lengthlist__44cn1_sm_p4_0[] = {
		 1, 4, 3, 6, 6, 7, 7, 9, 9, 0, 5, 5, 7, 7, 8, 7,
		 9, 9, 0, 5, 5, 7, 7, 8, 8, 9, 9, 0, 7, 7, 8, 8,
		 8, 8,10,10, 0, 0, 0, 8, 8, 8, 8,10,10, 0, 0, 0,
		 9, 9, 9, 9,10,10, 0, 0, 0, 9, 9, 9, 9,10,10, 0,
		 0, 0,10,10,10,10,11,11, 0, 0, 0, 0, 0,10,10,11,
		11,
};

static const static_codebook _44cn1_sm_p4_0 = {
		2, 81,
		(long *)_vq_lengthlist__44cn1_sm_p4_0,
		1, -531628032, 1611661312, 4, 0,
		(long *)_vq_quantlist__44cn1_sm_p4_0,
		0
};

static const long _vq_quantlist__44cn1_sm_p5_0[] = {
		8,
		7,
		9,
		6,
		10,
		5,
		11,
		4,
		12,
		3,
		13,
		2,
		14,
		1,
		15,
		0,
		16,
};

static const long _vq_lengthlist__44cn1_sm_p5_0[] = {
		 1, 4, 4, 6, 6, 8, 8, 9, 9, 8, 8, 9, 9,10,10,11,
		11, 0, 6, 6, 7, 7, 8, 8, 9, 9, 9, 9,10,10,11,11,
		12,12, 0, 6, 5, 7, 7, 8, 8, 9, 9, 9, 9,10,10,11,
		11,12,12, 0, 7, 7, 7, 7, 8, 8, 9, 9, 9, 9,10,10,
		11,11,12,12, 0, 0, 0, 7, 7, 8, 8, 9, 9,10,10,11,
		11,11,11,12,12, 0, 0, 0, 8, 8, 9, 9,10,10,10,10,
		11,11,12,12,12,12, 0, 0, 0, 8, 8, 9, 9,10,10,10,
		10,11,11,12,12,12,12, 0, 0, 0, 9, 9, 9, 9,10,10,
		10,10,11,11,12,12,13,13, 0, 0, 0, 0, 0, 9, 9,10,
		10,10,10,11,11,12,12,13,13, 0, 0, 0, 0, 0, 9, 9,
		10,10,11,11,12,12,13,13,13,13, 0, 0, 0, 0, 0, 9,
		 9,10,10,11,11,12,12,12,13,13,13, 0, 0, 0, 0, 0,
		10,10,11,11,11,11,12,12,13,13,14,14, 0, 0, 0, 0,
		 0, 0, 0,11,11,11,11,12,12,13,13,14,14, 0, 0, 0,
		 0, 0, 0, 0,11,11,12,12,13,13,13,13,14,14, 0, 0,
		 0, 0, 0, 0, 0,11,11,12,12,13,13,13,13,14,14, 0,
		 0, 0, 0, 0, 0, 0,12,12,12,13,13,13,14,14,14,14,
		 0, 0, 0, 0, 0, 0, 0, 0, 0,12,12,13,13,14,14,14,
		14,
};

static const static_codebook _44cn1_sm_p5_0 = {
		2, 289,
		(long *)_vq_lengthlist__44cn1_sm_p5_0,
		1, -529530880, 1611661312, 5, 0,
		(long *)_vq_quantlist__44cn1_sm_p5_0,
		0
};

static const long _vq_quantlist__44cn1_sm_p6_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__44cn1_sm_p6_0[] = {
		 1, 4, 4, 7, 6, 6, 7, 6, 6, 4, 7, 6,10, 9, 9,11,
		 9, 9, 4, 6, 7,10, 9, 9,11, 9, 9, 7,10,10,10,11,
		11,11,11,10, 6, 9, 9,11,10,10,11,10,10, 6, 9, 9,
		11,10,11,11,10,10, 7,11,11,11,11,11,12,11,11, 7,
		 9, 9,11,10,10,12,10,10, 7, 9, 9,11,10,10,11,10,
		10,
};

static const static_codebook _44cn1_sm_p6_0 = {
		4, 81,
		(long *)_vq_lengthlist__44cn1_sm_p6_0,
		1, -529137664, 1618345984, 2, 0,
		(long *)_vq_quantlist__44cn1_sm_p6_0,
		0
};

static const long _vq_quantlist__44cn1_sm_p6_1[] = {
		5,
		4,
		6,
		3,
		7,
		2,
		8,
		1,
		9,
		0,
		10,
};

static const long _vq_lengthlist__44cn1_sm_p6_1[] = {
		 2, 4, 4, 5, 5, 7, 7, 7, 7, 8, 8,10, 5, 5, 6, 6,
		 7, 7, 8, 8, 8, 8,10, 5, 5, 6, 6, 7, 7, 8, 8, 8,
		 8,10, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8,10,10,10, 7,
		 7, 7, 7, 8, 8, 8, 8,10,10,10, 8, 8, 8, 8, 8, 8,
		 8, 8,10,10,10, 8, 8, 8, 8, 8, 8, 8, 8,10,10,10,
		 8, 8, 8, 8, 8, 8, 9, 9,10,10,10,10,10, 8, 8, 8,
		 8, 9, 9,10,10,10,10,10, 9, 9, 9, 9, 8, 9,10,10,
		10,10,10, 8, 9, 8, 8, 9, 8,
};

static const static_codebook _44cn1_sm_p6_1 = {
		2, 121,
		(long *)_vq_lengthlist__44cn1_sm_p6_1,
		1, -531365888, 1611661312, 4, 0,
		(long *)_vq_quantlist__44cn1_sm_p6_1,
		0
};

static const long _vq_quantlist__44cn1_sm_p7_0[] = {
		6,
		5,
		7,
		4,
		8,
		3,
		9,
		2,
		10,
		1,
		11,
		0,
		12,
};

static const long _vq_lengthlist__44cn1_sm_p7_0[] = {
		 1, 4, 4, 6, 6, 7, 7, 7, 7, 9, 9,10,10, 7, 5, 5,
		 7, 7, 8, 8, 8, 8,10, 9,11,10, 7, 5, 5, 7, 7, 8,
		 8, 8, 8, 9,10,11,11, 0, 8, 8, 8, 8, 9, 9, 9, 9,
		10,10,11,11, 0, 8, 8, 8, 8, 9, 9, 9, 9,10,10,11,
		11, 0,12,12, 9, 9, 9,10,10,10,11,11,12,12, 0,13,
		13, 9, 9, 9, 9,10,10,11,11,12,12, 0, 0, 0,10,10,
		10,10,11,11,12,12,12,13, 0, 0, 0,10,10,10,10,11,
		11,12,12,12,12, 0, 0, 0,14,14,11,11,11,11,12,13,
		13,13, 0, 0, 0,14,14,11,10,11,11,12,12,13,13, 0,
		 0, 0, 0, 0,12,12,12,12,13,13,13,14, 0, 0, 0, 0,
		 0,13,12,12,12,13,13,13,14,
};

static const static_codebook _44cn1_sm_p7_0 = {
		2, 169,
		(long *)_vq_lengthlist__44cn1_sm_p7_0,
		1, -526516224, 1616117760, 4, 0,
		(long *)_vq_quantlist__44cn1_sm_p7_0,
		0
};

static const long _vq_quantlist__44cn1_sm_p7_1[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__44cn1_sm_p7_1[] = {
		 2, 4, 4, 4, 5, 6, 5, 5, 5, 5, 6, 5, 5, 5, 5, 6,
		 5, 5, 5, 5, 6, 6, 6, 5, 5,
};

static const static_codebook _44cn1_sm_p7_1 = {
		2, 25,
		(long *)_vq_lengthlist__44cn1_sm_p7_1,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__44cn1_sm_p7_1,
		0
};

static const long _vq_quantlist__44cn1_sm_p8_0[] = {
		4,
		3,
		5,
		2,
		6,
		1,
		7,
		0,
		8,
};

static const long _vq_lengthlist__44cn1_sm_p8_0[] = {
		 1, 4, 4,12,11,13,13,14,14, 4, 7, 7,11,13,14,14,
		14,14, 3, 8, 3,14,14,14,14,14,14,14,10,12,14,14,
		14,14,14,14,14,14, 5,14, 8,14,14,14,14,14,12,14,
		13,14,14,14,14,14,14,14,13,14,10,14,14,14,14,14,
		14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,
		14,
};

static const static_codebook _44cn1_sm_p8_0 = {
		2, 81,
		(long *)_vq_lengthlist__44cn1_sm_p8_0,
		1, -516186112, 1627103232, 4, 0,
		(long *)_vq_quantlist__44cn1_sm_p8_0,
		0
};

static const long _vq_quantlist__44cn1_sm_p8_1[] = {
		6,
		5,
		7,
		4,
		8,
		3,
		9,
		2,
		10,
		1,
		11,
		0,
		12,
};

static const long _vq_lengthlist__44cn1_sm_p8_1[] = {
		 1, 4, 4, 6, 6, 8, 8, 9, 9,10,11,11,11, 6, 5, 5,
		 7, 7, 8, 8,10,10,10,11,11,11, 6, 5, 5, 7, 7, 8,
		 8,10,10,11,12,12,12,14, 7, 7, 7, 8, 9, 9,11,11,
		11,12,11,12,17, 7, 7, 8, 7, 9, 9,11,11,12,12,12,
		12,14,11,11, 8, 8,10,10,11,12,12,13,11,12,14,11,
		11, 8, 8,10,10,11,12,12,13,13,12,14,15,14,10,10,
		10,10,11,12,12,12,12,11,14,13,16,10,10,10, 9,12,
		11,12,12,13,14,14,15,14,14,13,10,10,11,11,12,11,
		13,11,14,12,15,13,14,11,10,12,10,12,12,13,13,13,
		13,14,15,15,12,12,11,11,12,11,13,12,14,14,14,14,
		17,12,12,11,10,13,11,13,13,
};

static const static_codebook _44cn1_sm_p8_1 = {
		2, 169,
		(long *)_vq_lengthlist__44cn1_sm_p8_1,
		1, -522616832, 1620115456, 4, 0,
		(long *)_vq_quantlist__44cn1_sm_p8_1,
		0
};

static const long _vq_quantlist__44cn1_sm_p8_2[] = {
		8,
		7,
		9,
		6,
		10,
		5,
		11,
		4,
		12,
		3,
		13,
		2,
		14,
		1,
		15,
		0,
		16,
};

static const long _vq_lengthlist__44cn1_sm_p8_2[] = {
		 3, 4, 4, 6, 6, 7, 7, 8, 8, 8, 8, 9, 9, 9, 9, 9,
		 9,10, 6, 6, 6, 6, 7, 7, 8, 8, 8, 9, 9, 9, 9, 9,
		 9, 9,10, 6, 6, 6, 6, 7, 7, 8, 8, 8, 8, 9, 9, 9,
		 9, 9, 9,10, 7, 7, 7, 7, 8, 8, 8, 8, 9, 9, 9, 9,
		 9, 9, 9, 9,10,10,10, 7, 7, 7, 8, 8, 8, 9, 9, 9,
		 9, 9, 9, 9, 9,10,10,10, 8, 8, 8, 8, 8, 8, 9, 9,
		 9, 9, 9, 9, 9, 9,10,10,10, 8, 8, 8, 8, 8, 8, 9,
		 9, 9, 9, 9, 9, 9, 9,11,10,11, 8, 8, 8, 8, 8, 8,
		 9, 9, 9, 9, 9, 9, 9, 9,10,10,10,11,11, 8, 8, 8,
		 8, 9, 9, 9, 9, 9, 9, 9, 9,11,10,11,11,11, 9, 9,
		 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,10,11,10,11,11, 9,
		 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,10,11,11,10,11,11,
		 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,11,10,11,11,
		11,11,11, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,10,11,11,
		11,11,11,11, 9,10,10,10, 9, 9, 9, 9, 9, 9,11,10,
		11,11,11,11,11, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,11,
		11,11,11,11,11,11,10,10, 9, 9, 9, 9, 9, 9, 9, 9,
		10,11,11,11,11,11,11,11,11, 9, 9, 9, 9, 9, 9, 9,
		 9,
};

static const static_codebook _44cn1_sm_p8_2 = {
		2, 289,
		(long *)_vq_lengthlist__44cn1_sm_p8_2,
		1, -529530880, 1611661312, 5, 0,
		(long *)_vq_quantlist__44cn1_sm_p8_2,
		0
};

static const long _huff_lengthlist__44cn1_sm_short[] = {
		 5, 6,12,14,12,14,16,17,18, 4, 2, 5,11, 7,10,12,
		14,15, 9, 4, 5,11, 7,10,13,15,18,15, 6, 7, 5, 6,
		 8,11,13,16,11, 5, 6, 5, 5, 6, 9,13,15,12, 5, 7,
		 6, 5, 6, 9,12,14,12, 6, 7, 8, 6, 7, 9,12,13,14,
		 8, 8, 7, 5, 5, 8,10,12,16, 9, 9, 8, 6, 6, 7, 9,
		 9,
};

static const static_codebook _huff_book__44cn1_sm_short = {
		2, 81,
		(long *)_huff_lengthlist__44cn1_sm_short,
		0, 0, 0, 0, 0,
		NULL,
		0
};

/*** End of inlined file: res_books_stereo.h ***/

/***** residue backends *********************************************/

static const vorbis_info_residue0 _residue_44_low={
  0,-1, -1, 9,-1,-1,
  /* 0   1   2   3   4   5   6   7  */
  {0},
  {-1},
  {  0,  1,  2,  2,  4,  8, 16, 32},
  {  0,  0,  0,999,  4,  8, 16, 32},
};

static const vorbis_info_residue0 _residue_44_mid={
  0,-1, -1, 10,-1,-1,
  /* 0   1   2   3   4   5   6   7   8  */
  {0},
  {-1},
  {  0,  1,  1,  2,  2,  4,  8, 16, 32},
  {  0,  0,999,  0,999,  4,  8, 16, 32},
};

static const vorbis_info_residue0 _residue_44_high={
  0,-1, -1, 10,-1,-1,
  /* 0   1   2   3   4   5   6   7   8  */
  {0},
  {-1},
  {  0,  1,  2,  4,  8, 16, 32, 71,157},
  {  0,  1,  2,  3,  4,  8, 16, 71,157},
};

static const static_bookblock _resbook_44s_n1={
  {
	{0},{0,0,&_44cn1_s_p1_0},{0,0,&_44cn1_s_p2_0},
	{0,0,&_44cn1_s_p3_0},{0,0,&_44cn1_s_p4_0},{0,0,&_44cn1_s_p5_0},
	{&_44cn1_s_p6_0,&_44cn1_s_p6_1},{&_44cn1_s_p7_0,&_44cn1_s_p7_1},
	{&_44cn1_s_p8_0,&_44cn1_s_p8_1,&_44cn1_s_p8_2}
   }
};
static const static_bookblock _resbook_44sm_n1={
  {
	{0},{0,0,&_44cn1_sm_p1_0},{0,0,&_44cn1_sm_p2_0},
	{0,0,&_44cn1_sm_p3_0},{0,0,&_44cn1_sm_p4_0},{0,0,&_44cn1_sm_p5_0},
	{&_44cn1_sm_p6_0,&_44cn1_sm_p6_1},{&_44cn1_sm_p7_0,&_44cn1_sm_p7_1},
	{&_44cn1_sm_p8_0,&_44cn1_sm_p8_1,&_44cn1_sm_p8_2}
   }
};

static const static_bookblock _resbook_44s_0={
  {
	{0},{0,0,&_44c0_s_p1_0},{0,0,&_44c0_s_p2_0},
	{0,0,&_44c0_s_p3_0},{0,0,&_44c0_s_p4_0},{0,0,&_44c0_s_p5_0},
	{&_44c0_s_p6_0,&_44c0_s_p6_1},{&_44c0_s_p7_0,&_44c0_s_p7_1},
	{&_44c0_s_p8_0,&_44c0_s_p8_1,&_44c0_s_p8_2}
   }
};
static const static_bookblock _resbook_44sm_0={
  {
	{0},{0,0,&_44c0_sm_p1_0},{0,0,&_44c0_sm_p2_0},
	{0,0,&_44c0_sm_p3_0},{0,0,&_44c0_sm_p4_0},{0,0,&_44c0_sm_p5_0},
	{&_44c0_sm_p6_0,&_44c0_sm_p6_1},{&_44c0_sm_p7_0,&_44c0_sm_p7_1},
	{&_44c0_sm_p8_0,&_44c0_sm_p8_1,&_44c0_sm_p8_2}
   }
};

static const static_bookblock _resbook_44s_1={
  {
	{0},{0,0,&_44c1_s_p1_0},{0,0,&_44c1_s_p2_0},
	{0,0,&_44c1_s_p3_0},{0,0,&_44c1_s_p4_0},{0,0,&_44c1_s_p5_0},
	{&_44c1_s_p6_0,&_44c1_s_p6_1},{&_44c1_s_p7_0,&_44c1_s_p7_1},
	{&_44c1_s_p8_0,&_44c1_s_p8_1,&_44c1_s_p8_2}
   }
};
static const static_bookblock _resbook_44sm_1={
  {
	{0},{0,0,&_44c1_sm_p1_0},{0,0,&_44c1_sm_p2_0},
	{0,0,&_44c1_sm_p3_0},{0,0,&_44c1_sm_p4_0},{0,0,&_44c1_sm_p5_0},
	{&_44c1_sm_p6_0,&_44c1_sm_p6_1},{&_44c1_sm_p7_0,&_44c1_sm_p7_1},
	{&_44c1_sm_p8_0,&_44c1_sm_p8_1,&_44c1_sm_p8_2}
   }
};

static const static_bookblock _resbook_44s_2={
  {
	{0},{0,0,&_44c2_s_p1_0},{0,0,&_44c2_s_p2_0},{0,0,&_44c2_s_p3_0},
	{0,0,&_44c2_s_p4_0},{0,0,&_44c2_s_p5_0},{0,0,&_44c2_s_p6_0},
	{&_44c2_s_p7_0,&_44c2_s_p7_1},{&_44c2_s_p8_0,&_44c2_s_p8_1},
	{&_44c2_s_p9_0,&_44c2_s_p9_1,&_44c2_s_p9_2}
   }
};
static const static_bookblock _resbook_44s_3={
  {
	{0},{0,0,&_44c3_s_p1_0},{0,0,&_44c3_s_p2_0},{0,0,&_44c3_s_p3_0},
	{0,0,&_44c3_s_p4_0},{0,0,&_44c3_s_p5_0},{0,0,&_44c3_s_p6_0},
	{&_44c3_s_p7_0,&_44c3_s_p7_1},{&_44c3_s_p8_0,&_44c3_s_p8_1},
	{&_44c3_s_p9_0,&_44c3_s_p9_1,&_44c3_s_p9_2}
   }
};
static const static_bookblock _resbook_44s_4={
  {
	{0},{0,0,&_44c4_s_p1_0},{0,0,&_44c4_s_p2_0},{0,0,&_44c4_s_p3_0},
	{0,0,&_44c4_s_p4_0},{0,0,&_44c4_s_p5_0},{0,0,&_44c4_s_p6_0},
	{&_44c4_s_p7_0,&_44c4_s_p7_1},{&_44c4_s_p8_0,&_44c4_s_p8_1},
	{&_44c4_s_p9_0,&_44c4_s_p9_1,&_44c4_s_p9_2}
   }
};
static const static_bookblock _resbook_44s_5={
  {
	{0},{0,0,&_44c5_s_p1_0},{0,0,&_44c5_s_p2_0},{0,0,&_44c5_s_p3_0},
	{0,0,&_44c5_s_p4_0},{0,0,&_44c5_s_p5_0},{0,0,&_44c5_s_p6_0},
	{&_44c5_s_p7_0,&_44c5_s_p7_1},{&_44c5_s_p8_0,&_44c5_s_p8_1},
	{&_44c5_s_p9_0,&_44c5_s_p9_1,&_44c5_s_p9_2}
   }
};
static const static_bookblock _resbook_44s_6={
  {
	{0},{0,0,&_44c6_s_p1_0},{0,0,&_44c6_s_p2_0},{0,0,&_44c6_s_p3_0},
	{0,0,&_44c6_s_p4_0},
	{&_44c6_s_p5_0,&_44c6_s_p5_1},
	{&_44c6_s_p6_0,&_44c6_s_p6_1},
	{&_44c6_s_p7_0,&_44c6_s_p7_1},
	{&_44c6_s_p8_0,&_44c6_s_p8_1},
	{&_44c6_s_p9_0,&_44c6_s_p9_1,&_44c6_s_p9_2}
   }
};
static const static_bookblock _resbook_44s_7={
  {
	{0},{0,0,&_44c7_s_p1_0},{0,0,&_44c7_s_p2_0},{0,0,&_44c7_s_p3_0},
	{0,0,&_44c7_s_p4_0},
	{&_44c7_s_p5_0,&_44c7_s_p5_1},
	{&_44c7_s_p6_0,&_44c7_s_p6_1},
	{&_44c7_s_p7_0,&_44c7_s_p7_1},
	{&_44c7_s_p8_0,&_44c7_s_p8_1},
	{&_44c7_s_p9_0,&_44c7_s_p9_1,&_44c7_s_p9_2}
   }
};
static const static_bookblock _resbook_44s_8={
  {
	{0},{0,0,&_44c8_s_p1_0},{0,0,&_44c8_s_p2_0},{0,0,&_44c8_s_p3_0},
	{0,0,&_44c8_s_p4_0},
	{&_44c8_s_p5_0,&_44c8_s_p5_1},
	{&_44c8_s_p6_0,&_44c8_s_p6_1},
	{&_44c8_s_p7_0,&_44c8_s_p7_1},
	{&_44c8_s_p8_0,&_44c8_s_p8_1},
	{&_44c8_s_p9_0,&_44c8_s_p9_1,&_44c8_s_p9_2}
   }
};
static const static_bookblock _resbook_44s_9={
  {
	{0},{0,0,&_44c9_s_p1_0},{0,0,&_44c9_s_p2_0},{0,0,&_44c9_s_p3_0},
	{0,0,&_44c9_s_p4_0},
	{&_44c9_s_p5_0,&_44c9_s_p5_1},
	{&_44c9_s_p6_0,&_44c9_s_p6_1},
	{&_44c9_s_p7_0,&_44c9_s_p7_1},
	{&_44c9_s_p8_0,&_44c9_s_p8_1},
	{&_44c9_s_p9_0,&_44c9_s_p9_1,&_44c9_s_p9_2}
   }
};

static const vorbis_residue_template _res_44s_n1[]={
  {2,0,32,  &_residue_44_low,
   &_huff_book__44cn1_s_short,&_huff_book__44cn1_sm_short,
   &_resbook_44s_n1,&_resbook_44sm_n1},

  {2,0,32,  &_residue_44_low,
   &_huff_book__44cn1_s_long,&_huff_book__44cn1_sm_long,
   &_resbook_44s_n1,&_resbook_44sm_n1}
};
static const vorbis_residue_template _res_44s_0[]={
  {2,0,16,  &_residue_44_low,
   &_huff_book__44c0_s_short,&_huff_book__44c0_sm_short,
   &_resbook_44s_0,&_resbook_44sm_0},

  {2,0,32,  &_residue_44_low,
   &_huff_book__44c0_s_long,&_huff_book__44c0_sm_long,
   &_resbook_44s_0,&_resbook_44sm_0}
};
static const vorbis_residue_template _res_44s_1[]={
  {2,0,16,  &_residue_44_low,
   &_huff_book__44c1_s_short,&_huff_book__44c1_sm_short,
   &_resbook_44s_1,&_resbook_44sm_1},

  {2,0,32,  &_residue_44_low,
   &_huff_book__44c1_s_long,&_huff_book__44c1_sm_long,
   &_resbook_44s_1,&_resbook_44sm_1}
};

static const vorbis_residue_template _res_44s_2[]={
  {2,0,16,  &_residue_44_mid,
   &_huff_book__44c2_s_short,&_huff_book__44c2_s_short,
   &_resbook_44s_2,&_resbook_44s_2},

  {2,0,32,  &_residue_44_mid,
   &_huff_book__44c2_s_long,&_huff_book__44c2_s_long,
   &_resbook_44s_2,&_resbook_44s_2}
};
static const vorbis_residue_template _res_44s_3[]={
  {2,0,16,  &_residue_44_mid,
   &_huff_book__44c3_s_short,&_huff_book__44c3_s_short,
   &_resbook_44s_3,&_resbook_44s_3},

  {2,0,32,  &_residue_44_mid,
   &_huff_book__44c3_s_long,&_huff_book__44c3_s_long,
   &_resbook_44s_3,&_resbook_44s_3}
};
static const vorbis_residue_template _res_44s_4[]={
  {2,0,16,  &_residue_44_mid,
   &_huff_book__44c4_s_short,&_huff_book__44c4_s_short,
   &_resbook_44s_4,&_resbook_44s_4},

  {2,0,32,  &_residue_44_mid,
   &_huff_book__44c4_s_long,&_huff_book__44c4_s_long,
   &_resbook_44s_4,&_resbook_44s_4}
};
static const vorbis_residue_template _res_44s_5[]={
  {2,0,16,  &_residue_44_mid,
   &_huff_book__44c5_s_short,&_huff_book__44c5_s_short,
   &_resbook_44s_5,&_resbook_44s_5},

  {2,0,32,  &_residue_44_mid,
   &_huff_book__44c5_s_long,&_huff_book__44c5_s_long,
   &_resbook_44s_5,&_resbook_44s_5}
};
static const vorbis_residue_template _res_44s_6[]={
  {2,0,16,  &_residue_44_high,
   &_huff_book__44c6_s_short,&_huff_book__44c6_s_short,
   &_resbook_44s_6,&_resbook_44s_6},

  {2,0,32,  &_residue_44_high,
   &_huff_book__44c6_s_long,&_huff_book__44c6_s_long,
   &_resbook_44s_6,&_resbook_44s_6}
};
static const vorbis_residue_template _res_44s_7[]={
  {2,0,16,  &_residue_44_high,
   &_huff_book__44c7_s_short,&_huff_book__44c7_s_short,
   &_resbook_44s_7,&_resbook_44s_7},

  {2,0,32,  &_residue_44_high,
   &_huff_book__44c7_s_long,&_huff_book__44c7_s_long,
   &_resbook_44s_7,&_resbook_44s_7}
};
static const vorbis_residue_template _res_44s_8[]={
  {2,0,16,  &_residue_44_high,
   &_huff_book__44c8_s_short,&_huff_book__44c8_s_short,
   &_resbook_44s_8,&_resbook_44s_8},

  {2,0,32,  &_residue_44_high,
   &_huff_book__44c8_s_long,&_huff_book__44c8_s_long,
   &_resbook_44s_8,&_resbook_44s_8}
};
static const vorbis_residue_template _res_44s_9[]={
  {2,0,16,  &_residue_44_high,
   &_huff_book__44c9_s_short,&_huff_book__44c9_s_short,
   &_resbook_44s_9,&_resbook_44s_9},

  {2,0,32,  &_residue_44_high,
   &_huff_book__44c9_s_long,&_huff_book__44c9_s_long,
   &_resbook_44s_9,&_resbook_44s_9}
};

static const vorbis_mapping_template _mapres_template_44_stereo[]={
  { _map_nominal, _res_44s_n1 }, /* -1 */
  { _map_nominal, _res_44s_0 }, /* 0 */
  { _map_nominal, _res_44s_1 }, /* 1 */
  { _map_nominal, _res_44s_2 }, /* 2 */
  { _map_nominal, _res_44s_3 }, /* 3 */
  { _map_nominal, _res_44s_4 }, /* 4 */
  { _map_nominal, _res_44s_5 }, /* 5 */
  { _map_nominal, _res_44s_6 }, /* 6 */
  { _map_nominal, _res_44s_7 }, /* 7 */
  { _map_nominal, _res_44s_8 }, /* 8 */
  { _map_nominal, _res_44s_9 }, /* 9 */
};

/*** End of inlined file: residue_44.h ***/


/*** Start of inlined file: psych_44.h ***/
/* preecho trigger settings *****************************************/

static const vorbis_info_psy_global _psy_global_44[5]={

  {8,   /* lines per eighth octave */
   {20.f,14.f,12.f,12.f,12.f,12.f,12.f},
   {-60.f,-30.f,-40.f,-40.f,-40.f,-40.f,-40.f}, 2,-75.f,
   -6.f,
   {99},{{99},{99}},{0},{0},{{0},{0}}
  },
  {8,   /* lines per eighth octave */
   {14.f,10.f,10.f,10.f,10.f,10.f,10.f},
   {-40.f,-30.f,-25.f,-25.f,-25.f,-25.f,-25.f}, 2,-80.f,
   -6.f,
   {99},{{99},{99}},{0},{0},{{0},{0}}
  },
  {8,   /* lines per eighth octave */
   {12.f,10.f,10.f,10.f,10.f,10.f,10.f},
   {-20.f,-20.f,-15.f,-15.f,-15.f,-15.f,-15.f}, 0,-80.f,
   -6.f,
   {99},{{99},{99}},{0},{0},{{0},{0}}
  },
  {8,   /* lines per eighth octave */
   {10.f,8.f,8.f,8.f,8.f,8.f,8.f},
   {-20.f,-15.f,-12.f,-12.f,-12.f,-12.f,-12.f}, 0,-80.f,
   -6.f,
   {99},{{99},{99}},{0},{0},{{0},{0}}
  },
  {8,   /* lines per eighth octave */
   {10.f,6.f,6.f,6.f,6.f,6.f,6.f},
   {-15.f,-15.f,-12.f,-12.f,-12.f,-12.f,-12.f}, 0,-85.f,
   -6.f,
   {99},{{99},{99}},{0},{0},{{0},{0}}
  },
};

/* noise compander lookups * low, mid, high quality ****************/
static const compandblock _psy_compand_44[6]={
  /* sub-mode Z short */
  {{
	0, 1, 2, 3, 4, 5, 6,  7,     /* 7dB */
	8, 9,10,11,12,13,14, 15,     /* 15dB */
	16,17,18,19,20,21,22, 23,     /* 23dB */
	24,25,26,27,28,29,30, 31,     /* 31dB */
	32,33,34,35,36,37,38, 39,     /* 39dB */
  }},
  /* mode_Z nominal short */
  {{
	 0, 1, 2, 3, 4, 5, 6,  6,     /* 7dB */
	 7, 7, 7, 7, 6, 6, 6,  7,     /* 15dB */
	 7, 8, 9,10,11,12,13, 14,     /* 23dB */
	15,16,17,17,17,18,18, 19,     /* 31dB */
	19,19,20,21,22,23,24, 25,     /* 39dB */
  }},
  /* mode A short */
  {{
	0, 1, 2, 3, 4, 5, 5,  5,     /* 7dB */
	6, 6, 6, 5, 4, 4, 4,  4,     /* 15dB */
	4, 4, 5, 5, 5, 6, 6,  6,     /* 23dB */
	7, 7, 7, 8, 8, 8, 9, 10,     /* 31dB */
	11,12,13,14,15,16,17, 18,     /* 39dB */
  }},
  /* sub-mode Z long */
  {{
	 0, 1, 2, 3, 4, 5, 6,  7,     /* 7dB */
	 8, 9,10,11,12,13,14, 15,     /* 15dB */
	16,17,18,19,20,21,22, 23,     /* 23dB */
	24,25,26,27,28,29,30, 31,     /* 31dB */
	32,33,34,35,36,37,38, 39,     /* 39dB */
  }},
  /* mode_Z nominal long */
  {{
	0, 1, 2, 3, 4, 5, 6,  7,     /* 7dB */
	8, 9,10,11,12,12,13, 13,     /* 15dB */
	13,14,14,14,15,15,15, 15,     /* 23dB */
	16,16,17,17,17,18,18, 19,     /* 31dB */
	19,19,20,21,22,23,24, 25,     /* 39dB */
  }},
  /* mode A long */
  {{
	0, 1, 2, 3, 4, 5, 6,  7,     /* 7dB */
	8, 8, 7, 6, 5, 4, 4,  4,     /* 15dB */
	4, 4, 5, 5, 5, 6, 6,  6,     /* 23dB */
	7, 7, 7, 8, 8, 8, 9, 10,     /* 31dB */
	11,12,13,14,15,16,17, 18,     /* 39dB */
  }}
};

/* tonal masking curve level adjustments *************************/

static const vp_adjblock _vp_tonemask_adj_longblock[12]={

   /* 63     125     250     500       1       2       4       8      16 */

   {{ -3, -8,-13,-15,-10,-10,-10,-10,-10,-10,-10,  0,  0,  0,  0,  0,  0}}, /* -1 */

/* {{-15,-15,-15,-15,-10, -8, -4, -2,  0,  0,  0, 10,  0,  0,  0,  0,  0}},    0 */
   {{ -4,-10,-14,-16,-15,-14,-13,-12,-12,-12,-11, -1, -1, -1, -1, -1,  0}}, /* 0 */

/* {{-15,-15,-15,-15,-15,-12,-10, -8,  0,  0,  0,  5,  0,  0,  0,  0,  0}},    1 */
   {{ -6,-12,-14,-16,-15,-15,-14,-13,-13,-12,-12, -2, -2, -1, -1, -1,  0}}, /* 1 */

/* {{-15,-15,-15,-15,-15,-12,-10, -8,  0,  0,  0,  0,  0,  0,  0,  0,  0}},    2 */
   {{-12,-13,-14,-16,-16,-16,-15,-14,-13,-12,-12, -6, -3, -1, -1, -1,  0}}, /* 2 */

/* {{-15,-15,-15,-15,-15,-12,-10, -8,  0,  0,  0,  0,  0,  0,  0,  0,  0}},    3 */
   {{-15,-15,-15,-16,-16,-16,-16,-14,-13,-13,-13,-10, -4, -2, -1, -1,  0}}, /* 3 */

/* {{-15,-15,-15,-15,-15,-12,-10, -8,  0,  0,  0,  0,  0,  0,  0,  0,  0}}, *//* 4 */
   {{-16,-16,-16,-16,-16,-16,-16,-15,-14,-14,-13,-11, -7  -3, -1, -1 , 0}}, /* 4 */

/* {{-15,-15,-15,-15,-15,-12,-10, -8,  0,  0,  0,  0,  0,  0,  0,  0,  0}},    5 */
   {{-16,-16,-16,-16,-16,-16,-16,-15,-14,-14,-13,-11, -7  -3, -1, -1 , 0}}, /* 5 */

/* {{-15,-15,-15,-15,-15,-12,-10, -8,  0,  0,  0,  0,  0,  0,  0,  0,  0}},    6 */
   {{-16,-16,-16,-16,-16,-16,-16,-15,-14,-14,-14,-12, -8, -4, -2, -2,  0}}, /* 6 */

/* {{-15,-15,-15,-15,-15,-12,-10, -8,  0,  0,  0,  0,  0,  0,  0,  0,  0}},    7 */
   {{-16,-16,-16,-16,-16,-16,-16,-15,-14,-14,-14,-12, -9, -4, -2, -2,  0}}, /* 7 */

/* {{-15,-15,-15,-15,-15,-12,-10, -8,  0,  0,  0,  0,  0,  0,  0,  0,  0}},    8 */
   {{-16,-16,-16,-16,-16,-16,-16,-15,-14,-14,-14,-12, -9, -4, -2, -2,  0}}, /* 8 */

/* {{-15,-15,-15,-15,-15,-12,-10, -8,  0,  0,  0,  0,  0,  0,  0,  0,  0}},    9 */
   {{-16,-16,-16,-16,-16,-16,-16,-15,-14,-14,-14,-12, -9, -4, -2, -2,  0}}, /* 9 */

/* {{-15,-15,-15,-15,-15,-12,-10, -8,  0,  0,  0,  0,  0,  0,  0,  0,  0}},    10 */
   {{-16,-16,-16,-16,-16,-16,-16,-15,-14,-14,-14,-12, -9, -4, -2, -2,  0}}, /* 10 */
};

static const vp_adjblock _vp_tonemask_adj_otherblock[12]={
   /* 63     125     250     500       1       2       4       8      16 */

   {{ -3, -8,-13,-15,-10,-10, -9, -9, -9, -9, -9,  1,  1,  1,  1,  1,  1}}, /* -1 */

/* {{-20,-20,-20,-20,-14,-12,-10, -8, -4,  0,  0, 10,  0,  0,  0,  0,  0}},    0 */
   {{ -4,-10,-14,-16,-14,-13,-12,-12,-11,-11,-10,  0,  0,  0,  0,  0,  0}}, /* 0 */

/* {{-20,-20,-20,-20,-20,-18,-16,-14,-10,  0,  0,  5,  0,  0,  0,  0,  0}},    1 */
   {{ -6,-12,-14,-16,-15,-15,-14,-13,-13,-12,-12, -2, -2, -1,  0,  0,  0}}, /* 1 */

/* {{-20,-20,-20,-20,-20,-18,-16,-14,-10,  0,  0,  0,  0,  0,  0,  0,  0}},    2 */
   {{-12,-13,-14,-16,-16,-16,-15,-14,-13,-12,-12, -5, -2, -1,  0,  0,  0}}, /* 2 */

/* {{-20,-20,-20,-20,-20,-18,-16,-14,-10,  0,  0,  0,  0,  0,  0,  0,  0}},    3 */
   {{-15,-15,-15,-16,-16,-16,-16,-14,-13,-13,-13,-10, -4, -2,  0,  0,  0}}, /* 3 */

/* {{-20,-20,-20,-20,-20,-18,-16,-14,-10,  0,  0,  0,  0,  0,  0,  0,  0}},    4 */
   {{-16,-16,-16,-16,-16,-16,-16,-15,-14,-14,-13,-11, -7  -3, -1, -1 , 0}}, /* 4 */

/* {{-20,-20,-20,-20,-20,-18,-16,-14,-10,  0,  0,  0,  0,  0,  0,  0,  0}},    5 */
   {{-16,-16,-16,-16,-16,-16,-16,-15,-14,-14,-13,-11, -7  -3, -1, -1 , 0}}, /* 5 */

/* {{-20,-20,-20,-20,-20,-18,-16,-14,-10,  0,  0,  0,  0,  0,  0,  0,  0}},    6 */
   {{-16,-16,-16,-16,-16,-16,-16,-15,-14,-14,-14,-12, -8, -4, -2, -2,  0}}, /* 6 */

/* {{-20,-20,-20,-20,-20,-18,-16,-14,-10,  0,  0,  0,  0,  0,  0,  0,  0}},    7 */
   {{-16,-16,-16,-16,-16,-16,-16,-15,-14,-14,-14,-12, -9, -4, -2, -2,  0}}, /* 7 */

/* {{-20,-20,-20,-20,-20,-18,-16,-14,-10,  0,  0,  0,  0,  0,  0,  0,  0}},    8 */
   {{-16,-16,-16,-16,-16,-16,-16,-15,-14,-14,-14,-12, -9, -4, -2, -2,  0}}, /* 8 */

/* {{-20,-20,-20,-20,-20,-18,-16,-14,-10,  0,  0,  0,  0,  0,  0,  0,  0}},    9 */
   {{-16,-16,-16,-16,-16,-16,-16,-15,-14,-14,-14,-12, -9, -4, -2, -2,  0}}, /* 9 */

/* {{-20,-20,-20,-20,-20,-18,-16,-14,-10,  0,  0,  0,  0,  0,  0,  0,  0}},    10 */
   {{-16,-16,-16,-16,-16,-16,-16,-15,-14,-14,-14,-12, -9, -4, -2, -2,  0}}, /* 10 */
};

/* noise bias (transition block) */
static const noise3 _psy_noisebias_trans[12]={
  /*  63     125     250     500      1k       2k      4k      8k     16k*/
  /* -1 */
  {{{-10,-10,-10,-10,-10, -4,  0,  0,  4,  8,  8,  8,  8, 10, 12, 14, 20},
	{-30,-30,-30,-30,-26,-20,-16, -8, -6, -6, -2,  2,  2,  3,  6,  6, 15},
	{-30,-30,-30,-30,-30,-24,-20,-14,-10, -6, -8, -8, -6, -6, -6, -4, -2}}},
  /* 0
  {{{-15,-15,-15,-15,-15,-12,-10, -8,  0,  2,  4,  4,  5,  5,  5,  8,  10},
	{-30,-30,-30,-30,-26,-22,-20,-14, -8, -4,  0,  0,  0,  0,  2,  4,  10},
	{-30,-30,-30,-30,-26,-22,-20,-14,-10, -6, -6, -6, -6, -4, -4, -4,  -2}}},*/
  {{{-15,-15,-15,-15,-15,-12, -6, -4,  0,  2,  4,  4,  5,  5,  5,  8,  10},
	{-30,-30,-30,-30,-26,-22,-20,-14, -8, -4,  0,  0,  0,  0,  2,  3,   6},
	{-30,-30,-30,-30,-26,-22,-20,-14,-10, -6, -6, -6, -6, -4, -4, -4,  -2}}},
  /* 1
  {{{-15,-15,-15,-15,-15,-12,-10, -8,  0,  2,  4,  4,  5,  5,  5,  8,  10},
	{-30,-30,-30,-30,-26,-22,-20,-14,-10, -4, -2, -2, -2, -2,  0,  2,  8},
	{-30,-30,-30,-30,-26,-22,-20,-14,-10, -8, -8, -8, -8, -6, -6, -6, -4}}},*/
  {{{-15,-15,-15,-15,-15,-12,-10, -8,  0,  2,  4,  4,  5,  5,  5,  8,  10},
	{-30,-30,-30,-30,-26,-22,-20,-14,-10, -4, -2, -2, -2, -2,  0,  1,   4},
	{-30,-30,-30,-30,-26,-22,-20,-14,-10, -8, -8, -8, -8, -6, -6, -6,  -4}}},
  /* 2
  {{{-15,-15,-15,-15,-15,-12,-10, -8,  0,  2,  2,  2,  4,  4,  5,  6,  10},
	{-30,-30,-30,-30,-26,-22,-20,-14,-10, -4, -2, -2, -2, -2,  0,  2,  6},
	{-30,-30,-30,-30,-26,-22,-20,-14,-10,-10,-10,-10,-10, -8, -8, -8, -4}}}, */
  {{{-15,-15,-15,-15,-15,-12,-10, -8,  0,  2,  2,  2,  4,  4,  5,  6,  10},
	{-30,-30,-30,-30,-26,-22,-20,-14,-10, -4, -3, -3, -3, -2, -1,  0,  3},
	{-30,-30,-30,-30,-26,-22,-20,-14,-10,-10,-10,-10,-10, -8, -8, -7, -4}}},
  /* 3
  {{{-15,-15,-15,-15,-15,-12,-10, -8,  0,  2,  2,  2,  4,  4,  4,  5,  8},
	{-30,-30,-30,-30,-26,-22,-20,-14,-10, -4, -3, -3, -3, -3, -1,  1,  6},
	{-30,-30,-30,-30,-26,-22,-20,-14,-10,-10,-10,-10,-10, -8, -8, -8, -4}}},*/
  {{{-15,-15,-15,-15,-15,-12,-10, -8,  0,  2,  2,  2,  4,  4,  4,  5,  8},
	{-30,-30,-30,-30,-26,-22,-20,-14,-10, -4, -3, -3, -3, -3, -2,  0,  2},
	{-30,-30,-30,-30,-26,-22,-20,-14,-10,-10,-10,-10,-10, -8, -8, -8, -4}}},
  /* 4
  {{{-20,-20,-20,-20,-20,-18,-14, -8, -1,  1,  1,  1,  2,  3,  3,  4,  7},
	{-30,-30,-30,-30,-26,-22,-20,-14,-10, -4, -3, -3, -3, -3, -1,  1,  5},
	{-30,-30,-30,-30,-26,-22,-20,-14,-10,-10,-10,-10,-10, -8, -8, -8, -4}}},*/
  {{{-20,-20,-20,-20,-20,-18,-14, -8, -1,  1,  1,  1,  2,  3,  3,  4,  7},
	{-30,-30,-30,-30,-26,-22,-20,-14,-10, -4, -3, -3, -3, -3, -2, -1,  1},
	{-30,-30,-30,-30,-26,-22,-20,-14,-10,-10,-10,-10,-10, -8, -8, -8, -4}}},
  /* 5
  {{{-24,-24,-24,-24,-20,-18,-14, -8, -1,  1,  1,  1,  2,  3,  3,  4,  7},
	{-32,-32,-32,-32,-28,-24,-22,-16,-12, -6, -4, -4, -4, -4, -2, -1,  2},
	{-34,-34,-34,-34,-30,-24,-24,-18,-14,-12,-12,-12,-12,-10,-10, -9, -5}}}, */
  {{{-24,-24,-24,-24,-20,-18,-14, -8, -1,  1,  1,  1,  2,  3,  3,  4,  7},
	{-32,-32,-32,-32,-28,-24,-22,-16,-12, -6, -4, -4, -4, -4, -3, -1,  0},
	{-34,-34,-34,-34,-30,-24,-24,-18,-14,-12,-12,-12,-12,-10,-10, -9, -5}}},
  /* 6
  {{{-24,-24,-24,-24,-20,-18,-14, -8, -1,  1,  1,  1,  2,  3,  3,  4,  7},
	{-32,-32,-32,-32,-28,-24,-24,-18,-14, -8, -6, -6, -6, -6, -4, -2,  1},
	{-34,-34,-34,-34,-30,-26,-24,-18,-17,-15,-15,-15,-15,-13,-13,-12, -8}}},*/
  {{{-24,-24,-24,-24,-20,-18,-14, -8, -1,  1,  1,  1,  2,  3,  3,  4,  7},
	{-32,-32,-32,-32,-28,-24,-24,-18,-14, -8, -6, -6, -6, -6, -5, -2,  0},
	{-34,-34,-34,-34,-30,-26,-26,-24,-22,-19,-19,-19,-19,-18,-17,-16,-12}}},
  /* 7
  {{{-24,-24,-24,-24,-20,-18,-14, -8, -1,  1,  1,  1,  2,  3,  3,  4,  7},
	{-32,-32,-32,-32,-28,-24,-24,-18,-14,-12,-10, -8, -8, -8, -6, -4,  0},
	{-34,-34,-34,-34,-30,-26,-26,-24,-22,-19,-19,-19,-19,-18,-17,-16,-12}}},*/
  {{{-24,-24,-24,-24,-20,-18,-14, -8, -1,  1,  1,  1,  2,  3,  3,  4,  7},
	{-32,-32,-32,-32,-28,-24,-24,-24,-18,-14,-12,-10,-10,-10, -8, -6, -2},
	{-34,-34,-34,-34,-30,-26,-26,-26,-24,-24,-24,-24,-24,-24,-24,-20,-16}}},
  /* 8
  {{{-24,-24,-24,-24,-22,-20,-15,-10, -8, -2,  0,  0,  0,  1,  2,  3,  7},
	{-36,-36,-36,-36,-30,-30,-30,-24,-18,-14,-12,-10,-10,-10, -8, -6, -2},
	{-36,-36,-36,-36,-34,-30,-28,-26,-24,-24,-24,-24,-24,-24,-24,-20,-16}}},*/
  {{{-24,-24,-24,-24,-22,-20,-15,-10, -8, -2,  0,  0,  0,  1,  2,  3,  7},
	{-36,-36,-36,-36,-30,-30,-30,-24,-20,-16,-16,-16,-16,-14,-12,-10, -7},
	{-36,-36,-36,-36,-34,-30,-28,-26,-24,-30,-30,-30,-30,-30,-30,-24,-20}}},
  /* 9
  {{{-28,-28,-28,-28,-28,-28,-28,-20,-14, -8, -4, -4, -4, -4, -4, -2,  2},
	{-36,-36,-36,-36,-34,-32,-32,-28,-20,-16,-16,-16,-16,-14,-12,-10, -7},
	{-40,-40,-40,-40,-40,-40,-40,-32,-30,-30,-30,-30,-30,-30,-30,-24,-20}}},*/
  {{{-28,-28,-28,-28,-28,-28,-28,-20,-14, -8, -4, -4, -4, -4, -4, -2,  2},
	{-38,-38,-38,-38,-36,-34,-34,-30,-24,-20,-20,-20,-20,-18,-16,-12,-10},
	{-40,-40,-40,-40,-40,-40,-40,-38,-35,-35,-35,-35,-35,-35,-35,-35,-30}}},
  /* 10 */
  {{{-30,-30,-30,-30,-30,-30,-30,-28,-20,-14,-14,-14,-14,-14,-14,-12,-10},
	{-40,-40,-40,-40,-40,-40,-40,-40,-35,-30,-30,-30,-30,-30,-30,-30,-20},
	{-40,-40,-40,-40,-40,-40,-40,-40,-40,-40,-40,-40,-40,-40,-40,-40,-40}}},
};

/*  noise bias (long block) */
static const noise3 _psy_noisebias_long[12]={
  /*63     125     250     500      1k       2k      4k      8k     16k*/
  /* -1 */
  {{{-10,-10,-10,-10,-10, -4,  0,  0,  0,  6,  6,  6,  6, 10, 10, 12,  20},
	{-20,-20,-20,-20,-20,-20,-10, -2,  0,  0,  0,  0,  0,  2,  4,  6,  15},
	{-20,-20,-20,-20,-20,-20,-20,-10, -6, -6, -6, -6, -6, -4, -4, -4, -2}}},

  /* 0 */
  /*  {{{-10,-10,-10,-10,-10,-10, -8,  2,  2,  2,  4,  4,  5,  5,  5,  8,  10},
	  {-20,-20,-20,-20,-20,-20,-20,-14, -6,  0,  0,  0,  0,  0,  2,  4,  10},
	  {-20,-20,-20,-20,-20,-20,-20,-14, -8, -6, -6, -6, -6, -4, -4, -4, -2}}},*/
  {{{-10,-10,-10,-10,-10,-10, -8,  2,  2,  2,  4,  4,  5,  5,  5,  8,  10},
	{-20,-20,-20,-20,-20,-20,-20,-14, -6,  0,  0,  0,  0,  0,  2,  3,  6},
	{-20,-20,-20,-20,-20,-20,-20,-14, -8, -6, -6, -6, -6, -4, -4, -4, -2}}},
  /* 1 */
  /*  {{{-10,-10,-10,-10,-10,-10, -8, -4,  0,  2,  4,  4,  5,  5,  5,  8,  10},
	  {-20,-20,-20,-20,-20,-20,-20,-14,-10, -4, -2, -2, -2, -2,  0,  2,  8},
	  {-20,-20,-20,-20,-20,-20,-20,-14,-10, -8, -8, -8, -8, -6, -6, -6, -4}}},*/
  {{{-10,-10,-10,-10,-10,-10, -8, -4,  0,  2,  4,  4,  5,  5,  5,  8,  10},
	{-20,-20,-20,-20,-20,-20,-20,-14,-10, -4, -2, -2, -2, -2,  0,  1,  4},
	{-20,-20,-20,-20,-20,-20,-20,-14,-10, -8, -8, -8, -8, -6, -6, -6, -4}}},
  /* 2 */
  /*  {{{-10,-10,-10,-10,-10,-10,-10, -8,  0,  2,  2,  2,  4,  4,  5,  6,  10},
	  {-20,-20,-20,-20,-20,-20,-20,-14,-10, -4, -2, -2, -2, -2,  0,  2,  6},
	  {-20,-20,-20,-20,-20,-20,-20,-14,-10,-10,-10,-10,-10, -8, -8, -8, -4}}},*/
  {{{-10,-10,-10,-10,-10,-10,-10, -8,  0,  2,  2,  2,  4,  4,  5,  6,  10},
	{-20,-20,-20,-20,-20,-20,-20,-14,-10, -4, -3, -3, -3, -2, -1,  0,  3},
	{-20,-20,-20,-20,-20,-20,-20,-14,-10,-10,-10,-10,-10, -8, -8, -8, -4}}},
  /* 3 */
  /*  {{{-10,-10,-10,-10,-10,-10,-10, -8,  0,  2,  2,  2,  4,  4,  4,  5,  8},
	  {-20,-20,-20,-20,-20,-20,-20,-14,-10, -4, -3, -3, -3, -3, -1,  1,  6},
	  {-20,-20,-20,-20,-20,-20,-20,-14,-10,-10,-10,-10,-10, -8, -8, -8, -4}}},*/
  {{{-10,-10,-10,-10,-10,-10,-10, -8,  0,  2,  2,  2,  4,  4,  4,  5,  8},
	{-20,-20,-20,-20,-20,-20,-20,-14,-10, -4, -3, -3, -3, -3, -2,  0,  2},
	{-20,-20,-20,-20,-20,-20,-20,-14,-10,-10,-10,-10,-10, -8, -8, -8, -5}}},
  /* 4 */
  /*  {{{-15,-15,-15,-15,-15,-15,-15,-10, -4,  1,  1,  1,  2,  3,  3,  4,  7},
	  {-20,-20,-20,-20,-20,-20,-20,-14,-10, -4, -3, -3, -3, -3, -1,  1,  5},
	  {-20,-20,-20,-20,-20,-20,-20,-14,-10,-10,-10,-10,-10, -8, -8, -8, -4}}},*/
  {{{-15,-15,-15,-15,-15,-15,-15,-10, -4,  1,  1,  1,  2,  3,  3,  4,  7},
	{-20,-20,-20,-20,-20,-20,-20,-14,-10, -4, -3, -3, -3, -3, -2, -1,  1},
	{-20,-20,-20,-20,-20,-20,-20,-14,-10,-10,-10,-10,-10, -8, -8, -8, -7}}},
  /* 5 */
  /*  {{{-15,-15,-15,-15,-15,-15,-15,-10, -4,  1,  1,  1,  2,  3,  3,  4,  7},
	  {-22,-22,-22,-22,-22,-22,-22,-16,-12, -6, -4, -4, -4, -4, -2, -1,  2},
	  {-24,-24,-24,-24,-24,-24,-24,-18,-14,-12,-12,-12,-12,-10,-10, -9, -5}}},*/
  {{{-15,-15,-15,-15,-15,-15,-15,-10, -4,  1,  1,  1,  2,  3,  3,  4,  7},
	{-22,-22,-22,-22,-22,-22,-22,-16,-12, -6, -4, -4, -4, -4, -3, -1,  0},
	{-24,-24,-24,-24,-24,-24,-24,-18,-14,-12,-12,-12,-12,-10,-10, -9, -8}}},
  /* 6 */
  /*  {{{-15,-15,-15,-15,-15,-15,-15,-10, -4,  1,  1,  1,  2,  3,  3,  4,  7},
	  {-24,-24,-24,-24,-24,-24,-24,-18,-14, -8, -6, -6, -6, -6, -4, -2,  1},
	  {-26,-26,-26,-26,-26,-26,-26,-18,-16,-15,-15,-15,-15,-13,-13,-12, -8}}},*/
  {{{-15,-15,-15,-15,-15,-15,-15,-10, -4,  1,  1,  1,  2,  3,  3,  4,  7},
	{-24,-24,-24,-24,-24,-24,-24,-18,-14, -8, -6, -6, -6, -6, -5, -2,  0},
	{-26,-26,-26,-26,-26,-26,-26,-18,-16,-15,-15,-15,-15,-13,-13,-12,-10}}},
  /* 7 */
  {{{-15,-15,-15,-15,-15,-15,-15,-10, -4,  1,  1,  1,  2,  3,  3,  4,  7},
	{-24,-24,-24,-24,-24,-24,-24,-18,-14,-10, -8, -8, -8, -8, -6, -4,  0},
	{-26,-26,-26,-26,-26,-26,-26,-22,-20,-19,-19,-19,-19,-18,-17,-16,-12}}},
  /* 8 */
  {{{-15,-15,-15,-15,-15,-15,-15,-10, -4,  0,  0,  0,  0,  1,  2,  3,  7},
	{-26,-26,-26,-26,-26,-26,-26,-20,-16,-12,-10,-10,-10,-10, -8, -6, -2},
	{-28,-28,-28,-28,-28,-28,-28,-26,-24,-24,-24,-24,-24,-24,-24,-20,-16}}},
  /* 9 */
  {{{-22,-22,-22,-22,-22,-22,-22,-18,-14, -8, -4, -4, -4, -4, -4, -2,  2},
	{-26,-26,-26,-26,-26,-26,-26,-22,-18,-16,-16,-16,-16,-14,-12,-10, -7},
	{-30,-30,-30,-30,-30,-30,-30,-30,-30,-30,-30,-30,-30,-30,-30,-24,-20}}},
  /* 10 */
  {{{-24,-24,-24,-24,-24,-24,-24,-24,-24,-18,-14,-14,-14,-14,-14,-12,-10},
	{-30,-30,-30,-30,-30,-30,-30,-30,-30,-30,-30,-30,-30,-30,-30,-30,-20},
	{-40,-40,-40,-40,-40,-40,-40,-40,-40,-40,-40,-40,-40,-40,-40,-40,-40}}},
};

/* noise bias (impulse block) */
static const noise3 _psy_noisebias_impulse[12]={
  /*  63     125     250     500      1k      2k      4k      8k     16k*/
  /* -1 */
  {{{-10,-10,-10,-10,-10, -4,  0,  0,  4,  8,  8,  8,  8, 10, 12, 14, 20},
	{-30,-30,-30,-30,-26,-20,-16, -8, -6, -6, -2,  2,  2,  3,  6,  6, 15},
	{-30,-30,-30,-30,-30,-24,-20,-14,-10, -6, -8, -8, -6, -6, -6, -4, -2}}},

  /* 0 */
  /*  {{{-10,-10,-10,-10,-10, -4,  0,  0,  4,  4,  8,  8,  8, 10, 12, 14, 20},
	  {-30,-30,-30,-30,-26,-22,-20,-14, -6, -2,  0,  0,  0,  0,  2,  4,  10},
	  {-30,-30,-30,-30,-30,-24,-20,-14,-10, -6, -8, -8, -6, -6, -6, -4, -2}}},*/
  {{{-10,-10,-10,-10,-10, -4,  0,  0,  4,  4,  8,  8,  8, 10, 12, 14, 20},
	{-30,-30,-30,-30,-26,-22,-20,-14, -6, -2,  0,  0,  0,  0,  2,  3,  6},
	{-30,-30,-30,-30,-30,-24,-20,-14,-10, -6, -8, -8, -6, -6, -6, -4, -2}}},
  /* 1 */
  {{{-12,-12,-12,-12,-12, -8, -6, -4,  0,  4,  4,  4,  4, 10, 12, 14, 20},
	{-30,-30,-30,-30,-26,-22,-20,-14,-10, -6, -4, -4, -2, -2, -2, -2,  2},
	{-30,-30,-30,-30,-26,-22,-20,-14,-10, -8,-10,-10, -8, -8, -8, -6, -4}}},
  /* 2 */
  {{{-14,-14,-14,-14,-14,-10, -8, -6, -2,  2,  2,  2,  2,  8, 10, 10, 16},
	{-30,-30,-30,-30,-26,-22,-20,-14,-10, -6, -6, -6, -4, -4, -4, -2,  0},
	{-30,-30,-30,-30,-26,-22,-20,-14,-10,-10,-10,-10,-10,-10,-10, -8, -4}}},
  /* 3 */
  {{{-14,-14,-14,-14,-14,-10, -8, -6, -2,  2,  2,  2,  2,  6,  8,  8, 14},
	{-30,-30,-30,-30,-26,-22,-20,-14,-10, -6, -6, -6, -4, -4, -4, -2,  0},
	{-30,-30,-30,-30,-26,-22,-20,-14,-10,-10,-10,-10,-10,-10,-10, -8, -4}}},
  /* 4 */
  {{{-16,-16,-16,-16,-16,-12,-10, -6, -2,  0,  0,  0,  0,  4,  6,  6, 12},
	{-30,-30,-30,-30,-26,-22,-20,-14,-10, -6, -6, -6, -4, -4, -4, -2,  0},
	{-30,-30,-30,-30,-26,-22,-20,-14,-10,-10,-10,-10,-10,-10,-10, -8, -4}}},
  /* 5 */
  {{{-20,-20,-20,-20,-20,-18,-14,-10, -4,  0,  0,  0,  0,  4,  4,  6, 11},
	{-32,-32,-32,-32,-28,-24,-22,-16,-10, -6, -8, -8, -6, -6, -6, -4, -2},
	{-34,-34,-34,-34,-30,-26,-24,-18,-14,-12,-12,-12,-12,-12,-10, -9, -5}}},
  /* 6
  {{{-20,-20,-20,-20,-20,-18,-14,-10, -4,  0,  0,  0,  0,  4,  4,  6, 11},
	  {-34,-34,-34,-34,-30,-30,-24,-20,-12,-12,-14,-14,-10, -9, -8, -6, -4},
	  {-34,-34,-34,-34,-34,-30,-26,-20,-16,-15,-15,-15,-15,-15,-13,-12, -8}}},*/
  {{{-20,-20,-20,-20,-20,-18,-14,-10, -4,  0,  0,  0,  0,  4,  4,  6, 11},
	{-34,-34,-34,-34,-30,-30,-30,-24,-16,-16,-16,-16,-16,-16,-14,-14,-12},
	{-36,-36,-36,-36,-36,-34,-28,-24,-20,-20,-20,-20,-20,-20,-20,-18,-16}}},
  /* 7 */
  /*  {{{-22,-22,-22,-22,-22,-20,-14,-10, -6,  0,  0,  0,  0,  4,  4,  6, 11},
	  {-34,-34,-34,-34,-30,-30,-24,-20,-14,-14,-16,-16,-14,-12,-10,-10,-10},
	  {-34,-34,-34,-34,-32,-32,-30,-24,-20,-19,-19,-19,-19,-19,-17,-16,-12}}},*/
  {{{-22,-22,-22,-22,-22,-20,-14,-10, -6,  0,  0,  0,  0,  4,  4,  6, 11},
	{-34,-34,-34,-34,-30,-30,-30,-30,-26,-26,-26,-26,-26,-26,-26,-24,-22},
	{-40,-40,-40,-40,-40,-40,-40,-32,-30,-30,-30,-30,-30,-30,-30,-30,-24}}},
  /* 8 */
  /*  {{{-24,-24,-24,-24,-24,-22,-14,-10, -6, -1, -1, -1, -1,  3,  3,  5, 10},
	  {-34,-34,-34,-34,-30,-30,-30,-24,-20,-20,-20,-20,-20,-18,-16,-16,-14},
	  {-36,-36,-36,-36,-36,-34,-28,-24,-24,-24,-24,-24,-24,-24,-24,-20,-16}}},*/
  {{{-24,-24,-24,-24,-24,-22,-14,-10, -6, -1, -1, -1, -1,  3,  3,  5, 10},
	{-34,-34,-34,-34,-34,-32,-32,-30,-26,-26,-26,-26,-26,-26,-26,-26,-24},
	{-40,-40,-40,-40,-40,-40,-40,-32,-30,-30,-30,-30,-30,-30,-30,-30,-24}}},
  /* 9 */
  /*  {{{-28,-28,-28,-28,-28,-28,-28,-20,-14, -8, -4, -4, -4, -4, -4, -2,  2},
	  {-36,-36,-36,-36,-34,-32,-32,-30,-26,-26,-26,-26,-26,-22,-20,-20,-18},
	  {-40,-40,-40,-40,-40,-40,-40,-32,-30,-30,-30,-30,-30,-30,-30,-24,-20}}},*/
  {{{-28,-28,-28,-28,-28,-28,-28,-20,-14, -8, -4, -4, -4, -4, -4, -2,  2},
	{-36,-36,-36,-36,-34,-32,-32,-30,-26,-26,-26,-26,-26,-26,-26,-26,-26},
	{-40,-40,-40,-40,-40,-40,-40,-32,-30,-30,-30,-30,-30,-30,-30,-24,-20}}},
  /* 10 */
  {{{-30,-30,-30,-30,-30,-26,-24,-24,-24,-20,-16,-16,-16,-16,-16,-14,-12},
	{-40,-40,-40,-40,-40,-40,-40,-40,-35,-30,-30,-30,-30,-30,-30,-30,-26},
	{-40,-40,-40,-40,-40,-40,-40,-40,-40,-40,-40,-40,-40,-40,-40,-40,-40}}},
};

/* noise bias (padding block) */
static const noise3 _psy_noisebias_padding[12]={
  /*  63     125     250     500      1k       2k      4k      8k     16k*/

  /* -1 */
  {{{-10,-10,-10,-10,-10, -4,  0,  0,  4,  8,  8,  8,  8, 10, 12, 14, 20},
	{-30,-30,-30,-30,-26,-20,-16, -8, -6, -6, -2,  2,  2,  3,  6,  6, 15},
	{-30,-30,-30,-30,-30,-24,-20,-14,-10, -6, -8, -8, -6, -6, -6, -4, -2}}},

  /* 0 */
  {{{-10,-10,-10,-10,-10, -4,  0,  0,  4,  8,  8,  8,  8, 10, 12, 14, 20},
	{-30,-30,-30,-30,-26,-22,-20,-14,-10, -4, -2,  2,  3,  6,  6,  8, 10},
	{-30,-30,-30,-30,-26,-22,-20,-14,-10, -4, -4, -4, -4, -4, -2,  0,  2}}},
  /* 1 */
  {{{-12,-12,-12,-12,-12, -8, -6, -4,  0,  4,  4,  4,  4, 10, 12, 14, 20},
	{-30,-30,-30,-30,-26,-22,-20,-14,-10, -4,  0,  0,  0,  2,  2,  4,  8},
	{-30,-30,-30,-30,-26,-22,-20,-14,-10, -6, -6, -6, -6, -6, -4, -2,  0}}},
  /* 2 */
  /*  {{{-14,-14,-14,-14,-14,-10, -8, -6, -2,  2,  2,  2,  2,  8, 10, 10, 16},
	  {-30,-30,-30,-30,-26,-22,-20,-14,-10, -4,  0,  0,  0,  2,  2,  4,  8},
	  {-30,-30,-30,-30,-26,-22,-20,-14,-10, -8, -8, -8, -8, -8, -6, -4, -2}}},*/
  {{{-14,-14,-14,-14,-14,-10, -8, -6, -2,  2,  2,  2,  2,  8, 10, 10, 16},
	{-30,-30,-30,-30,-26,-22,-20,-14,-10, -6, -1, -1, -1,  0,  0,  2,  6},
	{-30,-30,-30,-30,-26,-22,-20,-14,-10, -8, -8, -8, -8, -8, -6, -4, -2}}},
  /* 3 */
  {{{-14,-14,-14,-14,-14,-10, -8, -6, -2,  2,  2,  2,  2,  6,  8,  8, 14},
	{-30,-30,-30,-30,-26,-22,-20,-14,-10, -6, -1, -1, -1,  0,  0,  2,  6},
	{-30,-30,-30,-30,-26,-22,-20,-14,-10, -8, -8, -8, -8, -8, -6, -4, -2}}},
  /* 4 */
  {{{-16,-16,-16,-16,-16,-12,-10, -6, -2,  0,  0,  0,  0,  4,  6,  6, 12},
	{-30,-30,-30,-30,-26,-22,-20,-14,-10, -6, -1, -1, -1, -1,  0,  2,  6},
	{-30,-30,-30,-30,-26,-22,-20,-14,-10, -8, -8, -8, -8, -8, -6, -4, -2}}},
  /* 5 */
  {{{-20,-20,-20,-20,-20,-18,-14,-10, -4,  0,  0,  0,  0,  4,  6,  6, 12},
	{-32,-32,-32,-32,-28,-24,-22,-16,-12, -6, -3, -3, -3, -3, -2,  0,  4},
	{-34,-34,-34,-34,-30,-26,-24,-18,-14,-10,-10,-10,-10,-10, -8, -5, -3}}},
  /* 6 */
  {{{-20,-20,-20,-20,-20,-18,-14,-10, -4,  0,  0,  0,  0,  4,  6,  6, 12},
	{-34,-34,-34,-34,-30,-30,-24,-20,-14, -8, -4, -4, -4, -4, -3, -1,  4},
	{-34,-34,-34,-34,-34,-30,-26,-20,-16,-13,-13,-13,-13,-13,-11, -8, -6}}},
  /* 7 */
  {{{-20,-20,-20,-20,-20,-18,-14,-10, -4,  0,  0,  0,  0,  4,  6,  6, 12},
	{-34,-34,-34,-34,-30,-30,-30,-24,-16,-10, -8, -6, -6, -6, -5, -3,  1},
	{-34,-34,-34,-34,-32,-32,-28,-22,-18,-16,-16,-16,-16,-16,-14,-12,-10}}},
  /* 8 */
  {{{-22,-22,-22,-22,-22,-20,-14,-10, -4,  0,  0,  0,  0,  3,  5,  5, 11},
	{-34,-34,-34,-34,-30,-30,-30,-24,-16,-12,-10, -8, -8, -8, -7, -5, -2},
	{-36,-36,-36,-36,-36,-34,-28,-22,-20,-20,-20,-20,-20,-20,-20,-16,-14}}},
  /* 9 */
  {{{-28,-28,-28,-28,-28,-28,-28,-20,-14, -8, -2, -2, -2, -2,  0,  2,  6},
	{-36,-36,-36,-36,-34,-32,-32,-24,-16,-12,-12,-12,-12,-12,-10, -8, -5},
	{-40,-40,-40,-40,-40,-40,-40,-32,-26,-24,-24,-24,-24,-24,-24,-20,-18}}},
  /* 10 */
  {{{-30,-30,-30,-30,-30,-26,-24,-24,-24,-20,-12,-12,-12,-12,-12,-10, -8},
	{-40,-40,-40,-40,-40,-40,-40,-40,-35,-30,-25,-25,-25,-25,-25,-25,-15},
	{-40,-40,-40,-40,-40,-40,-40,-40,-40,-40,-40,-40,-40,-40,-40,-40,-40}}},
};

static const noiseguard _psy_noiseguards_44[4]={
  {3,3,15},
  {3,3,15},
  {10,10,100},
  {10,10,100},
};

static const int _psy_tone_suppress[12]={
  -20,-20,-20,-20,-20,-24,-30,-40,-40,-45,-45,-45,
};
static const int _psy_tone_0dB[12]={
  90,90,95,95,95,95,105,105,105,105,105,105,
};
static const int _psy_noise_suppress[12]={
  -20,-20,-24,-24,-24,-24,-30,-40,-40,-45,-45,-45,
};

static const vorbis_info_psy _psy_info_template={
  /* blockflag */
  -1,
  /* ath_adjatt, ath_maxatt */
  -140.,-140.,
  /* tonemask att boost/decay,suppr,curves */
  {0.f,0.f,0.f},     0.,0.,    -40.f, {0.},

  /*noisemaskp,supp, low/high window, low/hi guard, minimum */
  1,          -0.f,           .5f, .5f,         0,0,0,
  /* noiseoffset*3, noisecompand, max_curve_dB */
  {{-1},{-1},{-1}},{-1},105.f,
  /* noise normalization - noise_p, start, partition, thresh. */
  0,-1,-1,0.,
};

/* ath ****************/

static const int _psy_ath_floater[12]={
  -100,-100,-100,-100,-100,-100,-105,-105,-105,-105,-110,-120,
};
static const int _psy_ath_abs[12]={
  -130,-130,-130,-130,-140,-140,-140,-140,-140,-140,-140,-150,
};

/* stereo setup.  These don't map directly to quality level, there's
   an additional indirection as several of the below may be used in a
   single bitmanaged stream

****************/

/* various stereo possibilities */

/* stereo mode by base quality level */
static const adj_stereo _psy_stereo_modes_44[12]={
  /*  0   1   2   3   4   5   6   7   8   9  10  11  12  13  14         -1  */
  {{  4,  4,  4,  4,  4,  4,  4,  3,  2,  2,  1,  0,  0,  0,  0},
   {  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  5,  4,  3},
   {  1,  2,  3,  4,  4,  4,  4,  4,  4,  5,  6,  7,  8,  8,  8},
   { 12,12.5, 13,13.5, 14,14.5, 15, 99, 99, 99, 99, 99, 99, 99, 99}},

/*    0   1   2   3   4   5   6   7   8   9  10  11  12  13  14         0  */
  {{  4,  4,  4,  4,  4,  4,  4,  3,  2,  1,  0,  0,  0,  0,  0},
   {  8,  8,  8,  8,  6,  6,  5,  5,  5,  5,  5,  5,  5,  4,  3},
   {  1,  2,  3,  4,  4,  5,  6,  6,  6,  6,  6,  8,  8,  8,  8},
   { 12,12.5, 13,13.5, 14,14.5, 15, 99, 99, 99, 99, 99, 99, 99, 99}},

  /*  0   1   2   3   4   5   6   7   8   9  10  11  12  13  14         1  */
  {{  3,  3,  3,  3,  3,  3,  3,  3,  2,  1,  0,  0,  0,  0,  0},
   {  8,  8,  8,  8,  6,  6,  5,  5,  5,  5,  5,  5,  5,  4,  3},
   {  1,  2,  3,  4,  4,  5,  6,  6,  6,  6,  6,  8,  8,  8,  8},
   { 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99}},

  /*  0   1   2   3   4   5   6   7   8   9  10  11  12  13  14         2  */
  {{  3,  3,  3,  3,  3,  3,  3,  2,  1,  1,  0,  0,  0,  0,  0},
   {  8,  8,  6,  6,  5,  5,  4,  4,  4,  4,  4,  4,  3,  2,  1},
   {  3,  4,  4,  5,  5,  6,  6,  6,  6,  6,  6,  8,  8,  8,  8},
   { 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99}},
  /*  0   1   2   3   4   5   6   7   8   9  10  11  12  13  14         3  */
  {{  2,  2,  2,  2,  2,  1,  1,  1,  1,  0,  0,  0,  0,  0,  0},
   {  5,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  3,  2,  1},
   {  4,  4,  5,  6,  6,  6,  6,  6,  8,  8, 10, 10, 10, 10, 10},
   { 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99}},
  /*  0   1   2   3   4   5   6   7   8   9  10  11  12  13  14         4  */
  {{  2,  2,  2,  1,  1,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0},
   {  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  3,  3,  2,  1,  0},
   {  6,  6,  6,  8,  8,  8,  8,  8,  8,  8, 10, 10, 10, 10, 10},
   { 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99}},
  /*  0   1   2   3   4   5   6   7   8   9  10  11  12  13  14         5  */
  {{  2,  2,  2,  1,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
   {  3,  3,  3,  3,  3,  2,  2,  2,  2,  2,  2,  0,  0,  0,  0},
   {  6,  7,  8,  8,  8, 10, 10, 12, 12, 12, 12, 12, 12, 12, 12},
   { 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99}},
  /*  0   1   2   3   4   5   6   7   8   9  10  11  12  13  14         6  */
  {{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
   {  3,  3,  3,  2,  2,  2,  0,  0,  0,  0,  0,  0,  0,  0,  0},
   {  8,  8,  8, 10, 10, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12},
   { 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99}},
  /*  0   1   2   3   4   5   6   7   8   9  10  11  12  13  14         7  */
  {{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
   {  3,  3,  3,  2,  2,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
   {  8,  8, 10, 10, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12},
   { 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99}},
  /*  0   1   2   3   4   5   6   7   8   9  10  11  12  13  14         8  */
  {{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
   {  2,  2,  2,  2,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
   {  8, 10, 10, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12},
   { 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99}},
  /*  0   1   2   3   4   5   6   7   8   9  10  11  12  13  14         9  */
  {{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
   {  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
   {  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4},
   { 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99}},
  /*  0   1   2   3   4   5   6   7   8   9  10  11  12  13  14        10  */
  {{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
   {  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
   {  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4},
   { 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99}},
};

/* tone master attenuation by base quality mode and bitrate tweak */
static const att3 _psy_tone_masteratt_44[12]={
  {{ 35,  21,   9},  0,    0}, /* -1 */
  {{ 30,  20,   8}, -2, 1.25}, /* 0 */
  /*  {{ 25,  14,   4},  0,    0}, *//* 1 */
  {{ 25,  12,   2},  0,    0}, /* 1 */
  /*  {{ 20,  10,  -2},  0,    0}, *//* 2 */
  {{ 20,   9,  -3},  0,    0}, /* 2 */
  {{ 20,   9,  -4},  0,    0}, /* 3 */
  {{ 20,   9,  -4},  0,    0}, /* 4 */
  {{ 20,   6,  -6},  0,    0}, /* 5 */
  {{ 20,   3, -10},  0,    0}, /* 6 */
  {{ 18,   1, -14},  0,    0}, /* 7 */
  {{ 18,   0, -16},  0,    0}, /* 8 */
  {{ 18,  -2, -16},  0,    0}, /* 9 */
  {{ 12,  -2, -20},  0,    0}, /* 10 */
};

/* lowpass by mode **************/
static const double _psy_lowpass_44[12]={
  /*  15.1,15.8,16.5,17.9,20.5,48.,999.,999.,999.,999.,999. */
  13.9,15.1,15.8,16.5,17.2,18.9,20.1,48.,999.,999.,999.,999.
};

/* noise normalization **********/

static const int _noise_start_short_44[11]={
  /*  16,16,16,16,32,32,9999,9999,9999,9999 */
  32,16,16,16,32,9999,9999,9999,9999,9999,9999
};
static const int _noise_start_long_44[11]={
  /*  128,128,128,256,512,512,9999,9999,9999,9999 */
  256,128,128,256,512,9999,9999,9999,9999,9999,9999
};

static const int _noise_part_short_44[11]={
	8,8,8,8,8,8,8,8,8,8,8
};
static const int _noise_part_long_44[11]={
	32,32,32,32,32,32,32,32,32,32,32
};

static const double _noise_thresh_44[11]={
  /*  .2,.2,.3,.4,.5,.5,9999.,9999.,9999.,9999., */
   .2,.2,.2,.4,.6,9999.,9999.,9999.,9999.,9999.,9999.,
};

static const double _noise_thresh_5only[2]={
 .5,.5,
};

/*** End of inlined file: psych_44.h ***/

static const double rate_mapping_44_stereo[12]={
  22500.,32000.,40000.,48000.,56000.,64000.,
  80000.,96000.,112000.,128000.,160000.,250001.
};

static const double quality_mapping_44[12]={
  -.1,.0,.1,.2,.3,.4,.5,.6,.7,.8,.9,1.0
};

static const int blocksize_short_44[11]={
  512,256,256,256,256,256,256,256,256,256,256
};
static const int blocksize_long_44[11]={
  4096,2048,2048,2048,2048,2048,2048,2048,2048,2048,2048
};

static const double _psy_compand_short_mapping[12]={
  0.5, 1., 1., 1.3, 1.6, 2., 2., 2., 2., 2., 2., 2.
};
static const double _psy_compand_long_mapping[12]={
  3.5, 4., 4., 4.3, 4.6, 5., 5., 5., 5., 5., 5., 5.
};

static const double _global_mapping_44[12]={
  /* 1., 1., 1.5, 2., 2., 2.5, 2.7, 3.0, 3.5, 4., 4. */
 0., 1., 1., 1.5, 2., 2., 2.5, 2.7, 3.0, 3.7, 4., 4.
};

static const int _floor_mapping_44a[11]={
  1,0,0,2,2,4,5,5,5,5,5
};

static const int _floor_mapping_44b[11]={
  8,7,7,7,7,7,7,7,7,7,7
};

static const int _floor_mapping_44c[11]={
  10,10,10,10,10,10,10,10,10,10,10
};

static const int *_floor_mapping_44[]={
  _floor_mapping_44a,
  _floor_mapping_44b,
  _floor_mapping_44c,
};

static const ve_setup_data_template ve_setup_44_stereo={
  11,
  rate_mapping_44_stereo,
  quality_mapping_44,
  2,
  40000,
  50000,

  blocksize_short_44,
  blocksize_long_44,

  _psy_tone_masteratt_44,
  _psy_tone_0dB,
  _psy_tone_suppress,

  _vp_tonemask_adj_otherblock,
  _vp_tonemask_adj_longblock,
  _vp_tonemask_adj_otherblock,

  _psy_noiseguards_44,
  _psy_noisebias_impulse,
  _psy_noisebias_padding,
  _psy_noisebias_trans,
  _psy_noisebias_long,
  _psy_noise_suppress,

  _psy_compand_44,
  _psy_compand_short_mapping,
  _psy_compand_long_mapping,

  {_noise_start_short_44,_noise_start_long_44},
  {_noise_part_short_44,_noise_part_long_44},
  _noise_thresh_44,

  _psy_ath_floater,
  _psy_ath_abs,

  _psy_lowpass_44,

  _psy_global_44,
  _global_mapping_44,
  _psy_stereo_modes_44,

  _floor_books,
  _floor,
  2,
  _floor_mapping_44,

  _mapres_template_44_stereo
};

/*** End of inlined file: setup_44.h ***/


/*** Start of inlined file: setup_44u.h ***/

/*** Start of inlined file: residue_44u.h ***/

/*** Start of inlined file: res_books_uncoupled.h ***/
static const long _vq_quantlist__16u0__p1_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__16u0__p1_0[] = {
		 1, 4, 4, 5, 7, 7, 5, 7, 8, 5, 8, 8, 8,10,10, 8,
		10,11, 5, 8, 8, 8,10,10, 8,10,10, 4, 9, 9, 9,12,
		11, 8,11,11, 8,12,11,10,12,14,10,13,13, 7,11,11,
		10,14,12,11,14,14, 4, 9, 9, 8,11,11, 9,11,12, 7,
		11,11,10,13,14,10,12,14, 8,11,12,10,14,14,10,13,
		12,
};

static const static_codebook _16u0__p1_0 = {
		4, 81,
		(long *)_vq_lengthlist__16u0__p1_0,
		1, -535822336, 1611661312, 2, 0,
		(long *)_vq_quantlist__16u0__p1_0,
		0
};

static const long _vq_quantlist__16u0__p2_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__16u0__p2_0[] = {
		 2, 4, 4, 5, 6, 6, 5, 6, 6, 5, 7, 7, 7, 8, 9, 7,
		 8, 9, 5, 7, 7, 7, 9, 8, 7, 9, 7, 4, 7, 7, 7, 9,
		 9, 7, 8, 8, 6, 9, 8, 7, 8,11, 9,11,10, 6, 8, 9,
		 8,11, 8, 9,10,11, 4, 7, 7, 7, 8, 8, 7, 9, 9, 6,
		 9, 8, 9,11,10, 8, 8,11, 6, 8, 9, 9,10,11, 8,11,
		 8,
};

static const static_codebook _16u0__p2_0 = {
		4, 81,
		(long *)_vq_lengthlist__16u0__p2_0,
		1, -535822336, 1611661312, 2, 0,
		(long *)_vq_quantlist__16u0__p2_0,
		0
};

static const long _vq_quantlist__16u0__p3_0[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__16u0__p3_0[] = {
		 1, 5, 5, 7, 7, 6, 7, 7, 8, 8, 6, 7, 8, 8, 8, 8,
		 9, 9,11,11, 8, 9, 9,11,11, 6, 9, 8,10,10, 8,10,
		10,11,11, 8,10,10,11,11,10,11,10,13,12, 9,11,10,
		13,13, 6, 8, 9,10,10, 8,10,10,11,11, 8,10,10,11,
		11, 9,10,11,13,12,10,10,11,12,12, 8,11,11,14,13,
		10,12,11,15,13, 9,12,11,15,14,12,14,13,16,14,12,
		13,13,17,14, 8,11,11,13,14, 9,11,12,14,15,10,11,
		12,13,15,11,13,13,14,16,12,13,14,14,16, 5, 9, 9,
		11,11, 9,11,11,12,12, 8,11,11,12,12,11,12,12,15,
		14,10,12,12,15,15, 8,11,11,13,12,10,12,12,13,13,
		10,12,12,14,13,12,12,13,14,15,11,13,13,17,16, 7,
		11,11,13,13,10,12,12,14,13,10,12,12,13,14,12,13,
		12,15,14,11,13,13,15,14, 9,12,12,16,15,11,13,13,
		17,16,10,13,13,16,16,13,14,15,15,16,13,15,14,19,
		17, 9,12,12,14,16,11,13,13,15,16,10,13,13,17,16,
		13,14,13,17,15,12,15,15,16,17, 5, 9, 9,11,11, 8,
		11,11,13,12, 9,11,11,12,12,10,12,12,14,15,11,12,
		12,14,14, 7,11,10,13,12,10,12,12,14,13,10,11,12,
		13,13,11,13,13,15,16,12,12,13,15,15, 7,11,11,13,
		13,10,13,13,14,14,10,12,12,13,13,11,13,13,16,15,
		12,13,13,15,14, 9,12,12,15,15,10,13,13,17,16,11,
		12,13,15,15,12,15,14,18,18,13,14,14,16,17, 9,12,
		12,15,16,10,13,13,15,16,11,13,13,15,16,13,15,15,
		17,17,13,15,14,16,15, 7,11,11,15,16,10,13,12,16,
		17,10,12,13,15,17,15,16,16,18,17,13,15,15,17,18,
		 8,12,12,16,16,11,13,14,17,18,11,13,13,18,16,15,
		17,16,17,19,14,15,15,17,16, 8,12,12,16,15,11,14,
		13,18,17,11,13,14,18,17,15,16,16,18,17,13,16,16,
		18,18,11,15,14,18,17,13,14,15,18, 0,12,15,15, 0,
		17,17,16,17,17,18,14,16,18,18, 0,11,14,14,17, 0,
		12,15,14,17,19,12,15,14,18, 0,15,18,16, 0,17,14,
		18,16,18, 0, 7,11,11,16,15,10,12,12,18,16,10,13,
		13,16,15,13,15,14,17,17,14,16,16,19,18, 8,12,12,
		16,16,11,13,13,18,16,11,13,14,17,16,14,15,15,19,
		18,15,16,16, 0,19, 8,12,12,16,17,11,13,13,17,17,
		11,14,13,17,17,13,15,15,17,19,15,17,17,19, 0,11,
		14,15,19,17,12,15,16,18,18,12,14,15,19,17,14,16,
		17, 0,18,16,16,19,17, 0,11,14,14,18,19,12,15,14,
		17,17,13,16,14,17,16,14,17,16,18,18,15,18,15, 0,
		18,
};

static const static_codebook _16u0__p3_0 = {
		4, 625,
		(long *)_vq_lengthlist__16u0__p3_0,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__16u0__p3_0,
		0
};

static const long _vq_quantlist__16u0__p4_0[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__16u0__p4_0[] = {
		 3, 5, 5, 8, 8, 6, 6, 6, 9, 9, 6, 6, 6, 9, 9, 9,
		10, 9,11,11, 9, 9, 9,11,11, 6, 7, 7,10,10, 7, 7,
		 8,10,10, 7, 7, 8,10,10,10,10,10,11,12, 9,10,10,
		11,12, 6, 7, 7,10,10, 7, 8, 7,10,10, 7, 8, 7,10,
		10,10,11,10,12,11,10,10,10,13,10, 9,10,10,12,12,
		10,11,10,14,12, 9,11,11,13,13,11,12,13,13,13,11,
		12,12,15,13, 9,10,10,12,13, 9,11,10,12,13,10,10,
		11,12,13,11,12,12,12,13,11,12,12,13,13, 5, 7, 7,
		10,10, 7, 8, 8,10,10, 7, 8, 8,10,10,10,11,10,12,
		13,10,10,11,12,12, 6, 8, 8,11,10, 7, 8, 9,10,12,
		 8, 9, 9,11,11,11,10,11,11,12,10,11,11,13,12, 7,
		 8, 8,10,11, 8, 9, 8,11,10, 8, 9, 9,11,11,10,12,
		10,13,11,10,11,11,13,13,10,11,10,14,13,10,10,11,
		13,13,10,12,11,14,13,12,11,13,12,13,13,12,13,14,
		14,10,11,11,13,13,10,11,10,12,13,10,12,12,12,14,
		12,12,12,14,12,12,13,12,17,15, 5, 7, 7,10,10, 7,
		 8, 8,10,10, 7, 8, 8,11,10,10,10,11,12,12,10,11,
		11,12,13, 6, 8, 8,11,10, 8, 9, 9,11,11, 7, 8, 9,
		10,11,11,11,11,12,12,10,10,11,12,13, 6, 8, 8,10,
		11, 8, 9, 9,11,11, 7, 9, 7,11,10,10,12,12,13,13,
		11,11,10,13,11, 9,11,10,14,13,11,11,11,15,13,10,
		10,11,13,13,12,13,13,14,14,12,11,12,12,13,10,11,
		11,12,13,10,11,12,13,13,10,11,10,13,12,12,12,13,
		14, 0,12,13,11,13,11, 8,10,10,13,13,10,11,11,14,
		13,10,11,11,13,12,13,14,14,14,15,12,12,12,15,14,
		 9,11,10,13,12,10,10,11,13,14,11,11,11,15,12,13,
		12,14,15,16,13,13,13,14,13, 9,11,11,12,12,10,12,
		11,13,13,10,11,11,13,14,13,13,13,15,15,13,13,14,
		17,15,11,12,12,14,14,10,11,12,13,15,12,13,13, 0,
		15,13,11,14,12,16,14,16,14, 0,15,11,12,12,14,16,
		11,13,12,16,15,12,13,13,14,15,12,14,12,15,13,15,
		14,14,16,16, 8,10,10,13,13,10,11,10,13,14,10,11,
		11,13,13,13,13,12,14,14,14,13,13,16,17, 9,10,10,
		12,14,10,12,11,14,13,10,11,12,13,14,12,12,12,15,
		15,13,13,13,14,14, 9,10,10,13,13,10,11,12,12,14,
		10,11,10,13,13,13,13,13,14,16,13,13,13,14,14,11,
		12,13,15,13,12,14,13,14,16,12,12,13,13,14,13,14,
		14,17,15,13,12,17,13,16,11,12,13,14,15,12,13,14,
		14,17,11,12,11,14,14,13,16,14,16, 0,14,15,11,15,
		11,
};

static const static_codebook _16u0__p4_0 = {
		4, 625,
		(long *)_vq_lengthlist__16u0__p4_0,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__16u0__p4_0,
		0
};

static const long _vq_quantlist__16u0__p5_0[] = {
		4,
		3,
		5,
		2,
		6,
		1,
		7,
		0,
		8,
};

static const long _vq_lengthlist__16u0__p5_0[] = {
		 1, 4, 4, 7, 7, 7, 7, 9, 9, 4, 6, 6, 8, 8, 8, 8,
		 9, 9, 4, 6, 6, 8, 8, 8, 8, 9, 9, 7, 8, 8, 9, 9,
		 9, 9,11,10, 7, 8, 8, 9, 9, 9, 9,10,11, 7, 8, 8,
		 9, 9,10,10,11,11, 7, 8, 8, 9, 9,10,10,11,11, 9,
		 9, 9,10,10,11,11,12,12, 9, 9, 9,10,10,11,11,12,
		12,
};

static const static_codebook _16u0__p5_0 = {
		2, 81,
		(long *)_vq_lengthlist__16u0__p5_0,
		1, -531628032, 1611661312, 4, 0,
		(long *)_vq_quantlist__16u0__p5_0,
		0
};

static const long _vq_quantlist__16u0__p6_0[] = {
		6,
		5,
		7,
		4,
		8,
		3,
		9,
		2,
		10,
		1,
		11,
		0,
		12,
};

static const long _vq_lengthlist__16u0__p6_0[] = {
		 1, 4, 4, 7, 7,10,10,12,12,13,13,18,17, 3, 6, 6,
		 9, 9,11,11,13,13,14,14,18,17, 3, 6, 6, 9, 9,11,
		11,13,13,14,14,17,18, 7, 9, 9,11,11,13,13,14,14,
		15,15, 0, 0, 7, 9, 9,11,11,13,13,14,14,15,16,19,
		18,10,11,11,13,13,14,14,16,15,17,18, 0, 0,10,11,
		11,13,13,14,14,15,15,16,18, 0, 0,11,13,13,14,14,
		15,15,17,17, 0,19, 0, 0,11,13,13,14,14,14,15,16,
		18, 0,19, 0, 0,13,14,14,15,15,18,17,18,18, 0,19,
		 0, 0,13,14,14,15,16,16,16,18,18,19, 0, 0, 0,16,
		17,17, 0,17,19,19, 0,19, 0, 0, 0, 0,16,19,16,17,
		18, 0,19, 0, 0, 0, 0, 0, 0,
};

static const static_codebook _16u0__p6_0 = {
		2, 169,
		(long *)_vq_lengthlist__16u0__p6_0,
		1, -526516224, 1616117760, 4, 0,
		(long *)_vq_quantlist__16u0__p6_0,
		0
};

static const long _vq_quantlist__16u0__p6_1[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__16u0__p6_1[] = {
		 1, 4, 5, 6, 6, 4, 6, 6, 6, 6, 4, 6, 6, 6, 6, 6,
		 6, 6, 7, 7, 6, 6, 6, 7, 7,
};

static const static_codebook _16u0__p6_1 = {
		2, 25,
		(long *)_vq_lengthlist__16u0__p6_1,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__16u0__p6_1,
		0
};

static const long _vq_quantlist__16u0__p7_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__16u0__p7_0[] = {
		 1, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
		 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
		 8, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
		 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
		 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
		 7,
};

static const static_codebook _16u0__p7_0 = {
		4, 81,
		(long *)_vq_lengthlist__16u0__p7_0,
		1, -518803456, 1628680192, 2, 0,
		(long *)_vq_quantlist__16u0__p7_0,
		0
};

static const long _vq_quantlist__16u0__p7_1[] = {
		7,
		6,
		8,
		5,
		9,
		4,
		10,
		3,
		11,
		2,
		12,
		1,
		13,
		0,
		14,
};

static const long _vq_lengthlist__16u0__p7_1[] = {
		 1, 5, 5, 6, 5, 9,10,11,11,10,10,10,10,10,10, 5,
		 8, 8, 8,10,10,10,10,10,10,10,10,10,10,10, 5, 8,
		 9, 9, 9,10,10,10,10,10,10,10,10,10,10, 5,10, 8,
		10,10,10,10,10,10,10,10,10,10,10,10, 4, 8, 9,10,
		10,10,10,10,10,10,10,10,10,10,10, 9,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10, 9,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,
};

static const static_codebook _16u0__p7_1 = {
		2, 225,
		(long *)_vq_lengthlist__16u0__p7_1,
		1, -520986624, 1620377600, 4, 0,
		(long *)_vq_quantlist__16u0__p7_1,
		0
};

static const long _vq_quantlist__16u0__p7_2[] = {
		10,
		9,
		11,
		8,
		12,
		7,
		13,
		6,
		14,
		5,
		15,
		4,
		16,
		3,
		17,
		2,
		18,
		1,
		19,
		0,
		20,
};

static const long _vq_lengthlist__16u0__p7_2[] = {
		 1, 6, 6, 7, 8, 7, 7,10, 9,10, 9,11,10, 9,11,10,
		 9, 9, 9, 9,10, 6, 8, 7, 9, 9, 8, 8,10,10, 9,11,
		11,12,12,10, 9,11, 9,12,10, 9, 6, 9, 8, 9,12, 8,
		 8,11, 9,11,11,12,11,12,12,10,11,11,10,10,11, 7,
		10, 9, 9, 9, 9, 9,10, 9,10, 9,10,10,12,10,10,10,
		11,12,10,10, 7, 9, 9, 9,10, 9, 9,10,10, 9, 9, 9,
		11,11,10,10,10,10, 9, 9,12, 7, 9,10, 9,11, 9,10,
		 9,10,11,11,11,10,11,12, 9,12,11,10,10,10, 7, 9,
		 9, 9, 9,10,12,10, 9,11,12,10,11,12,12,11, 9,10,
		11,10,11, 7, 9,10,10,11,10, 9,10,11,11,11,10,12,
		12,12,11,11,10,11,11,12, 8, 9,10,12,11,10,10,12,
		12,12,12,12,10,11,11, 9,11,10,12,11,11, 8, 9,10,
		10,11,12,11,11,10,10,10,12,12,12, 9,10,12,12,12,
		12,12, 8,10,11,10,10,12, 9,11,12,12,11,12,12,12,
		12,10,12,10,10,10,10, 8,12,11,11,11,10,10,11,12,
		12,12,12,11,12,12,12,11,11,11,12,10, 9,10,10,12,
		10,12,10,12,12,10,10,10,11,12,12,12,11,12,12,12,
		11,10,11,12,12,12,11,12,12,11,12,12,11,12,12,12,
		12,11,12,12,10,10,10,10,11,11,12,11,12,12,12,12,
		12,12,12,11,12,11,10,11,11,12,11,11, 9,10,10,10,
		12,10,10,11, 9,11,12,11,12,11,12,12,10,11,10,12,
		 9, 9, 9,12,11,10,11,10,12,10,12,10,12,12,12,11,
		11,11,11,11,10, 9,10,10,11,10,11,11,12,11,10,11,
		12,12,12,11,11, 9,12,10,12, 9,10,12,10,10,11,10,
		11,11,12,11,10,11,10,11,11,11,11,12,11,11,10, 9,
		10,10,10, 9,11,11,10, 9,12,10,11,12,11,12,12,11,
		12,11,12,11,10,11,10,12,11,12,11,12,11,12,10,11,
		10,10,12,11,10,11,11,11,10,
};

static const static_codebook _16u0__p7_2 = {
		2, 441,
		(long *)_vq_lengthlist__16u0__p7_2,
		1, -529268736, 1611661312, 5, 0,
		(long *)_vq_quantlist__16u0__p7_2,
		0
};

static const long _huff_lengthlist__16u0__single[] = {
		 3, 5, 8, 7,14, 8, 9,19, 5, 2, 5, 5, 9, 6, 9,19,
		 8, 4, 5, 7, 8, 9,13,19, 7, 4, 6, 5, 9, 6, 9,19,
		12, 8, 7, 9,10,11,13,19, 8, 5, 8, 6, 9, 6, 7,19,
		 8, 8,10, 7, 7, 4, 5,19,12,17,19,15,18,13,11,18,
};

static const static_codebook _huff_book__16u0__single = {
		2, 64,
		(long *)_huff_lengthlist__16u0__single,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist__16u1__long[] = {
		 3, 6,10, 8,12, 8,14, 8,14,19, 5, 3, 5, 5, 7, 6,
		11, 7,16,19, 7, 5, 6, 7, 7, 9,11,12,19,19, 6, 4,
		 7, 5, 7, 6,10, 7,18,18, 8, 6, 7, 7, 7, 7, 8, 9,
		18,18, 7, 5, 8, 5, 7, 5, 8, 6,18,18,12, 9,10, 9,
		 9, 9, 8, 9,18,18, 8, 7,10, 6, 8, 5, 6, 4,11,18,
		11,15,16,12,11, 8, 8, 6, 9,18,14,18,18,18,16,16,
		16,13,16,18,
};

static const static_codebook _huff_book__16u1__long = {
		2, 100,
		(long *)_huff_lengthlist__16u1__long,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _vq_quantlist__16u1__p1_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__16u1__p1_0[] = {
		 1, 4, 4, 5, 7, 7, 5, 7, 7, 5, 8, 7, 7,10,10, 7,
		 9,10, 5, 7, 8, 7,10, 9, 7,10,10, 5, 8, 8, 8,10,
		10, 8,10,10, 7,10,10,10,11,12,10,12,13, 7,10,10,
		 9,13,11,10,12,13, 5, 8, 8, 8,10,10, 8,10,10, 7,
		10,10,10,12,12, 9,11,12, 7,10,11,10,12,12,10,13,
		11,
};

static const static_codebook _16u1__p1_0 = {
		4, 81,
		(long *)_vq_lengthlist__16u1__p1_0,
		1, -535822336, 1611661312, 2, 0,
		(long *)_vq_quantlist__16u1__p1_0,
		0
};

static const long _vq_quantlist__16u1__p2_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__16u1__p2_0[] = {
		 3, 4, 4, 5, 6, 6, 5, 6, 6, 5, 6, 6, 6, 7, 8, 6,
		 7, 8, 5, 6, 6, 6, 8, 7, 6, 8, 7, 5, 6, 6, 6, 8,
		 8, 6, 8, 8, 6, 8, 8, 7, 7,10, 8, 9, 9, 6, 8, 8,
		 7, 9, 8, 8, 9,10, 5, 6, 6, 6, 8, 8, 7, 8, 8, 6,
		 8, 8, 8,10, 9, 7, 8, 9, 6, 8, 8, 8, 9, 9, 7,10,
		 8,
};

static const static_codebook _16u1__p2_0 = {
		4, 81,
		(long *)_vq_lengthlist__16u1__p2_0,
		1, -535822336, 1611661312, 2, 0,
		(long *)_vq_quantlist__16u1__p2_0,
		0
};

static const long _vq_quantlist__16u1__p3_0[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__16u1__p3_0[] = {
		 1, 5, 5, 8, 8, 6, 7, 7, 9, 9, 5, 7, 7, 9, 9, 9,
		10, 9,11,11, 9, 9,10,11,11, 6, 8, 8,10,10, 8, 9,
		10,11,11, 8, 9,10,11,11,10,11,11,12,13,10,11,11,
		13,13, 6, 8, 8,10,10, 8,10, 9,11,11, 8,10, 9,11,
		11,10,11,11,13,13,10,11,11,13,12, 9,11,11,14,13,
		10,12,12,15,14,10,12,11,14,13,12,13,13,15,15,12,
		13,13,16,14, 9,11,11,13,14,10,11,12,14,14,10,12,
		12,14,15,12,13,13,14,15,12,13,14,15,16, 5, 8, 8,
		11,11, 8,10,10,12,12, 8,10,10,12,12,11,12,12,14,
		14,11,12,12,14,14, 8,10,10,12,12, 9,11,12,12,13,
		10,12,12,13,13,12,12,13,14,15,11,13,13,15,15, 7,
		10,10,12,12, 9,12,11,13,12,10,11,12,13,13,12,13,
		12,15,14,11,12,13,15,15,10,12,12,15,14,11,13,13,
		16,15,11,13,13,16,15,14,13,14,15,16,13,15,15,17,
		17,10,12,12,14,15,11,12,12,15,15,11,13,13,15,16,
		13,15,13,16,15,13,15,15,16,17, 5, 8, 8,11,11, 8,
		10,10,12,12, 8,10,10,12,12,11,12,12,14,14,11,12,
		12,14,14, 7,10,10,12,12,10,12,12,14,13, 9,11,12,
		12,13,12,13,13,15,15,12,12,13,13,15, 7,10,10,12,
		13,10,11,12,13,13,10,12,11,13,13,11,13,13,15,15,
		12,13,12,15,14, 9,12,12,15,14,11,13,13,15,15,11,
		12,13,15,15,13,14,14,17,19,13,13,14,16,16,10,12,
		12,14,15,11,13,13,15,16,11,13,12,16,15,13,15,15,
		17,18,14,15,13,16,15, 8,11,11,15,14,10,12,12,16,
		15,10,12,12,16,16,14,15,15,18,17,13,14,15,16,18,
		 9,12,12,15,15,11,12,14,16,17,11,13,13,16,15,15,
		15,15,17,18,14,15,16,17,17, 9,12,12,15,15,11,14,
		13,16,16,11,13,13,16,16,15,16,15,17,18,14,16,15,
		17,16,12,14,14,17,16,12,14,15,18,17,13,15,15,17,
		17,15,15,18,16,20,15,16,17,18,18,11,14,14,16,17,
		13,15,14,18,17,13,15,15,17,17,15,17,15,18,17,15,
		17,16,19,18, 8,11,11,14,15,10,12,12,15,15,10,12,
		12,16,16,13,14,14,17,16,14,15,15,17,17, 9,12,12,
		15,16,11,13,13,16,16,11,12,13,16,16,14,16,15,20,
		17,14,16,16,17,17, 9,12,12,15,16,11,13,13,16,17,
		11,13,13,17,16,14,15,15,17,18,15,15,15,18,18,11,
		14,14,17,16,13,15,15,17,17,13,14,14,18,17,15,16,
		16,18,19,15,15,17,17,19,11,14,14,16,17,13,15,14,
		17,19,13,15,14,18,17,15,17,16,18,18,15,17,15,18,
		16,
};

static const static_codebook _16u1__p3_0 = {
		4, 625,
		(long *)_vq_lengthlist__16u1__p3_0,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__16u1__p3_0,
		0
};

static const long _vq_quantlist__16u1__p4_0[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__16u1__p4_0[] = {
		 4, 5, 5, 8, 8, 6, 6, 7, 9, 9, 6, 6, 6, 9, 9, 9,
		10, 9,11,11, 9, 9,10,11,11, 6, 7, 7,10, 9, 7, 7,
		 8, 9,10, 7, 7, 8,10,10,10,10,10,10,12, 9, 9,10,
		11,12, 6, 7, 7, 9, 9, 7, 8, 7,10,10, 7, 8, 7,10,
		10, 9,10, 9,12,11,10,10, 9,12,10, 9,10,10,12,11,
		10,10,10,12,12, 9,10,10,12,12,12,11,12,13,13,11,
		11,12,12,13, 9,10,10,11,12, 9,10,10,12,12,10,10,
		10,12,12,11,12,11,14,13,11,12,12,14,13, 5, 7, 7,
		10,10, 7, 8, 8,10,10, 7, 8, 7,10,10,10,10,10,12,
		12,10,10,10,12,12, 6, 8, 7,10,10, 7, 7, 9,10,11,
		 8, 9, 9,11,10,10,10,11,11,13,10,10,11,12,13, 6,
		 8, 8,10,10, 7, 9, 8,11,10, 8, 9, 9,10,11,10,11,
		10,13,11,10,11,10,12,12,10,11,10,12,11,10,10,10,
		12,13,10,11,11,13,12,11,11,13,11,14,12,12,13,14,
		14, 9,10,10,12,13,10,11,10,13,12,10,11,11,12,13,
		11,12,11,14,12,12,13,13,15,14, 5, 7, 7,10,10, 7,
		 7, 8,10,10, 7, 8, 8,10,10,10,10,10,11,12,10,10,
		10,12,12, 7, 8, 8,10,10, 8, 9, 8,11,10, 7, 8, 9,
		10,11,10,11,11,12,12,10,10,11,11,13, 7, 7, 8,10,
		10, 8, 8, 9,10,11, 7, 9, 7,11,10,10,11,11,13,12,
		11,11,10,13,11, 9,10,10,12,12,10,11,11,13,12,10,
		10,11,12,12,12,13,13,14,14,11,11,12,12,14,10,10,
		11,12,12,10,11,11,12,13,10,10,10,13,12,12,13,13,
		15,14,12,13,10,14,11, 8,10,10,12,12,10,11,10,13,
		13, 9,10,10,12,12,12,13,13,15,14,11,12,12,13,13,
		 9,10,10,13,12,10,10,11,13,13,10,11,10,13,12,12,
		12,13,14,15,12,13,12,15,13, 9,10,10,12,13,10,11,
		10,13,12,10,10,11,12,13,12,14,12,15,13,12,12,13,
		14,15,11,12,11,14,13,11,11,12,14,15,12,13,12,15,
		14,13,11,15,11,16,13,14,14,16,15,11,12,12,14,14,
		11,12,11,14,13,12,12,13,14,15,13,14,12,16,12,14,
		14,14,15,15, 8,10,10,12,12, 9,10,10,12,12,10,10,
		11,13,13,11,12,12,13,13,12,13,13,14,15, 9,10,10,
		13,12,10,11,11,13,12,10,10,11,13,13,12,13,12,15,
		14,12,12,13,13,16, 9, 9,10,12,13,10,10,11,12,13,
		10,11,10,13,13,12,12,13,13,15,13,13,12,15,13,11,
		12,12,14,14,12,13,12,15,14,11,11,12,13,14,14,14,
		14,16,15,13,12,15,12,16,11,11,12,13,14,12,13,13,
		14,15,10,12,11,14,13,14,15,14,16,16,13,14,11,15,
		11,
};

static const static_codebook _16u1__p4_0 = {
		4, 625,
		(long *)_vq_lengthlist__16u1__p4_0,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__16u1__p4_0,
		0
};

static const long _vq_quantlist__16u1__p5_0[] = {
		4,
		3,
		5,
		2,
		6,
		1,
		7,
		0,
		8,
};

static const long _vq_lengthlist__16u1__p5_0[] = {
		 1, 4, 4, 7, 7, 7, 7, 9, 9, 4, 6, 6, 8, 8, 8, 8,
		10,10, 4, 5, 6, 8, 8, 8, 8,10,10, 7, 8, 8, 9, 9,
		 9, 9,11,11, 7, 8, 8, 9, 9, 9, 9,11,11, 7, 8, 8,
		10, 9,11,11,12,11, 7, 8, 8, 9, 9,11,11,12,12, 9,
		10,10,11,11,12,12,13,12, 9,10,10,11,11,12,12,12,
		13,
};

static const static_codebook _16u1__p5_0 = {
		2, 81,
		(long *)_vq_lengthlist__16u1__p5_0,
		1, -531628032, 1611661312, 4, 0,
		(long *)_vq_quantlist__16u1__p5_0,
		0
};

static const long _vq_quantlist__16u1__p6_0[] = {
		4,
		3,
		5,
		2,
		6,
		1,
		7,
		0,
		8,
};

static const long _vq_lengthlist__16u1__p6_0[] = {
		 3, 4, 4, 6, 6, 7, 7, 9, 9, 4, 4, 4, 6, 6, 8, 8,
		 9, 9, 4, 4, 4, 6, 6, 7, 7, 9, 9, 6, 6, 6, 7, 7,
		 8, 8,10, 9, 6, 6, 6, 7, 7, 8, 8, 9,10, 7, 8, 7,
		 8, 8, 9, 9,10,10, 7, 8, 8, 8, 8, 9, 9,10,10, 9,
		 9, 9,10,10,10,10,11,11, 9, 9, 9,10,10,10,10,11,
		11,
};

static const static_codebook _16u1__p6_0 = {
		2, 81,
		(long *)_vq_lengthlist__16u1__p6_0,
		1, -531628032, 1611661312, 4, 0,
		(long *)_vq_quantlist__16u1__p6_0,
		0
};

static const long _vq_quantlist__16u1__p7_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__16u1__p7_0[] = {
		 1, 4, 4, 4, 8, 8, 4, 8, 8, 5,11, 9, 8,12,11, 8,
		12,11, 5,10,11, 8,11,12, 8,11,12, 4,11,11,11,14,
		13,10,13,13, 8,14,13,12,14,16,12,16,15, 8,14,14,
		13,16,14,12,15,16, 4,11,11,10,14,13,11,14,14, 8,
		15,14,12,15,15,12,14,16, 8,14,14,11,16,15,12,15,
		13,
};

static const static_codebook _16u1__p7_0 = {
		4, 81,
		(long *)_vq_lengthlist__16u1__p7_0,
		1, -529137664, 1618345984, 2, 0,
		(long *)_vq_quantlist__16u1__p7_0,
		0
};

static const long _vq_quantlist__16u1__p7_1[] = {
		5,
		4,
		6,
		3,
		7,
		2,
		8,
		1,
		9,
		0,
		10,
};

static const long _vq_lengthlist__16u1__p7_1[] = {
		 2, 4, 4, 6, 6, 7, 7, 8, 8, 8, 8, 4, 6, 5, 7, 7,
		 8, 8, 8, 8, 8, 8, 4, 5, 6, 7, 7, 8, 8, 8, 8, 8,
		 8, 6, 7, 7, 8, 8, 8, 8, 9, 9, 9, 9, 6, 7, 7, 8,
		 8, 8, 8, 9, 9, 9, 9, 7, 8, 8, 8, 8, 9, 9, 9,10,
		 9,10, 7, 8, 8, 8, 8, 9, 9, 9, 9,10, 9, 8, 8, 8,
		 9, 9,10,10,10,10,10,10, 8, 8, 8, 9, 9, 9, 9,10,
		10,10,10, 8, 8, 8, 9, 9, 9,10,10,10,10,10, 8, 8,
		 8, 9, 9,10,10,10,10,10,10,
};

static const static_codebook _16u1__p7_1 = {
		2, 121,
		(long *)_vq_lengthlist__16u1__p7_1,
		1, -531365888, 1611661312, 4, 0,
		(long *)_vq_quantlist__16u1__p7_1,
		0
};

static const long _vq_quantlist__16u1__p8_0[] = {
		5,
		4,
		6,
		3,
		7,
		2,
		8,
		1,
		9,
		0,
		10,
};

static const long _vq_lengthlist__16u1__p8_0[] = {
		 1, 4, 4, 5, 5, 8, 8,10,10,12,12, 4, 7, 7, 8, 8,
		 9, 9,12,11,14,13, 4, 7, 7, 7, 8, 9,10,11,11,13,
		12, 5, 8, 8, 9, 9,11,11,12,13,15,14, 5, 7, 8, 9,
		 9,11,11,13,13,17,15, 8, 9,10,11,11,12,13,17,14,
		17,16, 8,10, 9,11,11,12,12,13,15,15,17,10,11,11,
		12,13,14,15,15,16,16,17, 9,11,11,12,12,14,15,17,
		15,15,16,11,14,12,14,15,16,15,16,16,16,15,11,13,
		13,14,14,15,15,16,16,15,16,
};

static const static_codebook _16u1__p8_0 = {
		2, 121,
		(long *)_vq_lengthlist__16u1__p8_0,
		1, -524582912, 1618345984, 4, 0,
		(long *)_vq_quantlist__16u1__p8_0,
		0
};

static const long _vq_quantlist__16u1__p8_1[] = {
		5,
		4,
		6,
		3,
		7,
		2,
		8,
		1,
		9,
		0,
		10,
};

static const long _vq_lengthlist__16u1__p8_1[] = {
		 2, 5, 5, 6, 6, 7, 7, 8, 8, 8, 8, 4, 6, 6, 7, 7,
		 8, 7, 8, 8, 8, 8, 4, 6, 6, 7, 7, 7, 7, 8, 8, 8,
		 8, 6, 7, 7, 7, 7, 8, 8, 8, 8, 8, 9, 6, 7, 7, 7,
		 7, 8, 8, 8, 8, 9, 9, 7, 7, 7, 8, 8, 8, 8, 9, 9,
		 9, 9, 7, 7, 7, 8, 8, 8, 8, 9, 9, 9, 9, 8, 8, 8,
		 8, 8, 9, 9, 9, 9, 9, 9, 8, 8, 8, 8, 8, 9, 9, 9,
		 9, 9, 9, 8, 8, 8, 9, 8, 9, 9, 9, 9, 9, 9, 8, 8,
		 8, 9, 9, 9, 9, 9, 9, 9, 9,
};

static const static_codebook _16u1__p8_1 = {
		2, 121,
		(long *)_vq_lengthlist__16u1__p8_1,
		1, -531365888, 1611661312, 4, 0,
		(long *)_vq_quantlist__16u1__p8_1,
		0
};

static const long _vq_quantlist__16u1__p9_0[] = {
		7,
		6,
		8,
		5,
		9,
		4,
		10,
		3,
		11,
		2,
		12,
		1,
		13,
		0,
		14,
};

static const long _vq_lengthlist__16u1__p9_0[] = {
		 1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
		 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
		 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
		 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
		 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
		 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
		 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
		 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
		 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
		 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
		 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
		 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
		 9, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
		 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
		 8,
};

static const static_codebook _16u1__p9_0 = {
		2, 225,
		(long *)_vq_lengthlist__16u1__p9_0,
		1, -514071552, 1627381760, 4, 0,
		(long *)_vq_quantlist__16u1__p9_0,
		0
};

static const long _vq_quantlist__16u1__p9_1[] = {
		7,
		6,
		8,
		5,
		9,
		4,
		10,
		3,
		11,
		2,
		12,
		1,
		13,
		0,
		14,
};

static const long _vq_lengthlist__16u1__p9_1[] = {
		 1, 6, 5, 9, 9,10,10, 6, 7, 9, 9,10,10,10,10, 5,
		10, 8,10, 8,10,10, 8, 8,10, 9,10,10,10,10, 5, 8,
		 9,10,10,10,10, 8,10,10,10,10,10,10,10, 9,10,10,
		10,10,10,10, 9, 9,10,10,10,10,10,10, 9, 9, 8, 9,
		10,10,10, 9,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10, 8,10,10,10,10,
		10,10,10,10,10,10,10,10,10, 6, 8, 8,10,10,10, 8,
		10,10,10,10,10,10,10,10, 5, 8, 8,10,10,10, 9, 9,
		10,10,10,10,10,10,10,10, 9,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10, 9, 9, 9, 9, 9, 9, 9, 9,
		 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
		 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
		 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
		 9,
};

static const static_codebook _16u1__p9_1 = {
		2, 225,
		(long *)_vq_lengthlist__16u1__p9_1,
		1, -522338304, 1620115456, 4, 0,
		(long *)_vq_quantlist__16u1__p9_1,
		0
};

static const long _vq_quantlist__16u1__p9_2[] = {
		8,
		7,
		9,
		6,
		10,
		5,
		11,
		4,
		12,
		3,
		13,
		2,
		14,
		1,
		15,
		0,
		16,
};

static const long _vq_lengthlist__16u1__p9_2[] = {
		 1, 6, 6, 7, 8, 8,11,10, 9, 9,11, 9,10, 9,11,11,
		 9, 6, 7, 6,11, 8,11, 9,10,10,11, 9,11,10,10,10,
		11, 9, 5, 7, 7, 8, 8,10,11, 8, 8,11, 9, 9,10,11,
		 9,10,11, 8, 9, 6, 8, 8, 9, 9,10,10,11,11,11, 9,
		11,10, 9,11, 8, 8, 8, 9, 8, 9,10,11, 9, 9,11,11,
		10, 9, 9,11,10, 8,11, 8, 9, 8,11, 9,10, 9,10,11,
		11,10,10, 9,10,10, 8, 8, 9,10,10,10, 9,11, 9,10,
		11,11,11,11,10, 9,11, 9, 9,11,11,10, 8,11,11,11,
		 9,10,10,11,10,11,11, 9,11,10, 9,11,10,10,10,10,
		 9,11,10,11,10, 9, 9,10,11, 9, 8,10,11,11,10,10,
		11, 9,11,10,11,11,10,11, 9, 9, 8,10, 8, 9,11, 9,
		 8,10,10, 9,11,10,11,10,11, 9,11, 8,10,11,11,11,
		11,10,10,11,11,11,11,10,11,11,10, 9, 8,10,10, 9,
		11,10,11,11,11, 9, 9, 9,11,11,11,10,10, 9, 9,10,
		 9,11,11,11,11, 8,10,11,10,11,11,10,11,11, 9, 9,
		 9,10, 9,11, 9,11,11,11,11,11,10,11,11,10,11,10,
		11,11, 9,11,10,11,10, 9,10, 9,10,10,11,11,11,11,
		 9,10, 9,10,11,11,10,11,11,11,11,11,11,10,11,11,
		10,
};

static const static_codebook _16u1__p9_2 = {
		2, 289,
		(long *)_vq_lengthlist__16u1__p9_2,
		1, -529530880, 1611661312, 5, 0,
		(long *)_vq_quantlist__16u1__p9_2,
		0
};

static const long _huff_lengthlist__16u1__short[] = {
		 5, 7,10, 9,11,10,15,11,13,16, 6, 4, 6, 6, 7, 7,
		10, 9,12,16,10, 6, 5, 6, 6, 7,10,11,16,16, 9, 6,
		 7, 6, 7, 7,10, 8,14,16,11, 6, 5, 4, 5, 6, 8, 9,
		15,16, 9, 6, 6, 5, 6, 6, 9, 8,14,16,12, 7, 6, 6,
		 5, 6, 6, 7,13,16, 8, 6, 7, 6, 5, 5, 4, 4,11,16,
		 9, 8, 9, 9, 7, 7, 6, 5,13,16,14,14,16,15,16,15,
		16,16,16,16,
};

static const static_codebook _huff_book__16u1__short = {
		2, 100,
		(long *)_huff_lengthlist__16u1__short,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist__16u2__long[] = {
	 5, 8,10,10,10,11,11,12,14,18, 7, 5, 5, 6, 8, 9,
	10,12,14,17, 9, 5, 4, 5, 6, 8,10,11,13,19, 9, 5,
	 4, 4, 5, 6, 9,10,12,17, 8, 6, 5, 4, 4, 5, 7,10,
	11,15, 8, 7, 7, 6, 5, 5, 6, 9,11,14, 8, 9, 8, 7,
	 6, 5, 6, 7,11,14, 9,11,11, 9, 7, 6, 6, 6, 9,14,
	11,14,15,13, 9, 8, 7, 7, 9,14,13,15,19,17,12,11,
	10, 9,10,14,
};

static const static_codebook _huff_book__16u2__long = {
	2, 100,
	(long *)_huff_lengthlist__16u2__long,
	0, 0, 0, 0, 0,
	NULL,
	0
};

static const long _vq_quantlist__16u2_p1_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__16u2_p1_0[] = {
	 1, 5, 5, 5, 7, 7, 5, 7, 7, 5, 7, 7, 7, 9, 9, 7,
	 9, 9, 5, 7, 7, 7, 9, 9, 8, 9, 9, 5, 7, 7, 8, 9,
	 9, 7, 9, 9, 7, 9, 9, 9,10,11, 9,10,10, 7, 9, 9,
	 9,10, 9, 9,10,11, 5, 8, 7, 7, 9, 9, 8, 9, 9, 7,
	 9, 9, 9,11,10, 9, 9,10, 7, 9, 9, 9,10,10, 9,11,
	10,
};

static const static_codebook _16u2_p1_0 = {
	4, 81,
	(long *)_vq_lengthlist__16u2_p1_0,
	1, -535822336, 1611661312, 2, 0,
	(long *)_vq_quantlist__16u2_p1_0,
	0
};

static const long _vq_quantlist__16u2_p2_0[] = {
	2,
	1,
	3,
	0,
	4,
};

static const long _vq_lengthlist__16u2_p2_0[] = {
	 3, 5, 5, 8, 8, 5, 7, 7, 9, 9, 5, 7, 7, 9, 9, 9,
	10, 9,11,11, 9, 9, 9,11,11, 5, 7, 7, 9, 9, 7, 8,
	 8,10,10, 7, 8, 8,10,10,10,10,10,12,12, 9,10,10,
	11,12, 5, 7, 7, 9, 9, 7, 8, 8,10,10, 7, 8, 8,10,
	10, 9,10,10,12,11,10,10,10,12,12, 9,10,10,12,12,
	10,10,10,12,12, 9,10,10,12,12,12,12,12,14,14,11,
	12,12,13,14, 9,10,10,12,12, 9,10,10,12,12,10,10,
	10,12,12,11,12,12,14,13,12,12,12,14,13, 5, 7, 7,
	 9, 9, 7, 8, 8,10,10, 7, 8, 8,10,10,10,10,10,12,
	12,10,10,10,12,12, 7, 8, 8,11,10, 8, 9, 9,11,11,
	 8, 9, 9,11,11,10,11,11,12,13,10,11,11,12,13, 7,
	 8, 8,10,10, 8, 9, 8,11,10, 8, 9, 9,11,11,10,11,
	10,13,12,10,11,11,13,13,10,11,10,13,12,10,11,11,
	13,13,10,11,11,13,13,12,12,13,13,14,12,13,13,14,
	14, 9,10,10,12,12,10,11,10,13,12,10,11,11,13,13,
	12,13,12,14,13,12,13,13,14,15, 5, 7, 7, 9,10, 7,
	 8, 8,10,10, 7, 8, 8,10,10,10,10,10,12,12,10,10,
	11,12,12, 7, 8, 8,10,10, 8, 9, 9,11,11, 8, 8, 9,
	10,11,10,11,11,13,13,10,10,11,12,13, 7, 8, 8,10,
	10, 8, 9, 9,11,11, 8, 9, 9,11,11,10,11,11,13,12,
	10,11,11,13,12, 9,10,10,12,12,10,11,11,13,13,10,
	10,11,12,13,12,13,13,15,14,12,12,13,12,14, 9,10,
	11,12,13,10,11,11,13,13,10,11,11,13,13,12,13,13,
	14,14,12,13,12,14,13, 8,10,10,12,12, 9,11,10,13,
	12, 9,10,10,12,13,12,13,13,14,14,12,12,12,14,14,
	 9,10,10,13,13,10,11,11,13,13,10,11,11,13,13,13,
	13,13,14,15,12,13,13,14,15, 9,10,10,12,13,10,11,
	10,13,13,10,11,11,12,13,12,13,12,15,14,12,13,13,
	14,15,11,12,12,15,14,12,12,13,14,15,12,13,13,15,
	14,13,13,15,14,16,14,14,14,16,15,11,12,12,14,14,
	11,12,12,14,14,12,13,13,14,15,13,14,13,15,13,14,
	14,14,15,16, 8, 9,10,12,12, 9,10,10,13,12, 9,10,
	11,12,13,12,12,12,14,14,12,13,13,14,14, 9,10,10,
	13,12,10,11,11,13,13,10,10,11,13,13,12,13,13,15,
	14,12,12,13,14,15, 9,10,10,13,13,10,11,11,13,13,
	10,11,11,13,13,12,13,13,14,14,13,13,13,15,15,11,
	12,12,14,13,12,13,13,15,14,11,12,12,14,14,14,14,
	14,16,15,13,13,14,13,16,11,12,12,14,14,12,13,13,
	14,15,12,13,12,14,14,14,14,14,16,16,14,15,13,16,
	14,
};

static const static_codebook _16u2_p2_0 = {
	4, 625,
	(long *)_vq_lengthlist__16u2_p2_0,
	1, -533725184, 1611661312, 3, 0,
	(long *)_vq_quantlist__16u2_p2_0,
	0
};

static const long _vq_quantlist__16u2_p3_0[] = {
	4,
	3,
	5,
	2,
	6,
	1,
	7,
	0,
	8,
};

static const long _vq_lengthlist__16u2_p3_0[] = {
	 2, 4, 4, 6, 6, 7, 7, 9, 9, 4, 5, 5, 6, 6, 8, 7,
	 9, 9, 4, 5, 5, 6, 6, 7, 8, 9, 9, 6, 6, 6, 7, 7,
	 8, 8,10,10, 6, 6, 6, 7, 7, 8, 8,10,10, 7, 8, 7,
	 8, 8, 9, 9,11,10, 7, 7, 8, 8, 8, 9, 9,10,11, 9,
	 9, 9,10,10,11,10,11,11, 9, 9, 9,10,10,10,11,11,
	11,
};

static const static_codebook _16u2_p3_0 = {
	2, 81,
	(long *)_vq_lengthlist__16u2_p3_0,
	1, -531628032, 1611661312, 4, 0,
	(long *)_vq_quantlist__16u2_p3_0,
	0
};

static const long _vq_quantlist__16u2_p4_0[] = {
	8,
	7,
	9,
	6,
	10,
	5,
	11,
	4,
	12,
	3,
	13,
	2,
	14,
	1,
	15,
	0,
	16,
};

static const long _vq_lengthlist__16u2_p4_0[] = {
	 2, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9,10,10,11,11,11,
	11, 5, 5, 5, 7, 6, 8, 7, 9, 9, 9, 9,10,10,11,11,
	12,12, 5, 5, 5, 6, 6, 7, 8, 8, 9, 9, 9,10,10,11,
	11,12,12, 6, 7, 6, 7, 7, 8, 8, 9, 9, 9, 9,10,10,
	11,11,12,12, 6, 6, 7, 7, 7, 8, 8, 9, 9, 9, 9,10,
	10,11,11,12,12, 7, 8, 8, 8, 8, 9, 9, 9, 9,10,10,
	11,11,11,11,12,12, 7, 7, 8, 8, 8, 9, 9, 9, 9,10,
	10,11,11,11,11,12,12, 8, 9, 9, 9, 9, 9, 9,10,10,
	10,10,11,11,12,12,12,12, 8, 9, 9, 9, 9, 9, 9,10,
	10,10,10,11,11,12,12,12,12, 9, 9, 9, 9, 9,10,10,
	10,10,10,11,11,11,12,12,13,13, 9, 9, 9, 9, 9,10,
	10,10,10,11,10,11,11,12,12,13,13,10,10,10,10,10,
	11,11,11,11,11,11,11,12,12,12,13,13,10,10,10,10,
	10,11,11,11,11,11,11,12,11,12,12,13,13,11,11,11,
	11,11,11,11,12,12,12,12,12,12,13,13,13,13,11,11,
	11,11,11,11,11,12,12,12,12,13,12,13,13,13,13,11,
	12,12,12,12,12,12,12,12,13,13,13,13,13,13,14,14,
	11,12,12,12,12,12,12,12,13,13,13,13,13,13,13,14,
	14,
};

static const static_codebook _16u2_p4_0 = {
	2, 289,
	(long *)_vq_lengthlist__16u2_p4_0,
	1, -529530880, 1611661312, 5, 0,
	(long *)_vq_quantlist__16u2_p4_0,
	0
};

static const long _vq_quantlist__16u2_p5_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__16u2_p5_0[] = {
	 1, 4, 4, 5, 7, 7, 5, 7, 7, 5, 8, 8, 7, 9, 9, 7,
	 9,10, 5, 8, 8, 7,10, 9, 7,10, 9, 5, 8, 8, 8,11,
	10, 8,10,10, 7,10,10, 9, 9,12,10,12,12, 7,10,10,
	 9,12,10,10,11,12, 5, 8, 8, 8,10,10, 8,11,11, 7,
	11,10,10,12,11, 9,10,12, 7,10,11,10,12,12, 9,12,
	 9,
};

static const static_codebook _16u2_p5_0 = {
	4, 81,
	(long *)_vq_lengthlist__16u2_p5_0,
	1, -529137664, 1618345984, 2, 0,
	(long *)_vq_quantlist__16u2_p5_0,
	0
};

static const long _vq_quantlist__16u2_p5_1[] = {
	5,
	4,
	6,
	3,
	7,
	2,
	8,
	1,
	9,
	0,
	10,
};

static const long _vq_lengthlist__16u2_p5_1[] = {
	 2, 5, 5, 6, 6, 7, 7, 8, 8, 8, 8, 5, 6, 6, 7, 7,
	 7, 7, 8, 8, 8, 8, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8,
	 8, 6, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 6, 7, 7, 7,
	 7, 8, 8, 8, 8, 8, 8, 7, 7, 7, 8, 8, 8, 8, 8, 8,
	 8, 8, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
	 8, 8, 8, 8, 8, 8, 9, 9, 8, 8, 8, 8, 8, 8, 8, 8,
	 8, 9, 9, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 8, 8,
	 8, 8, 8, 8, 8, 9, 9, 9, 9,
};

static const static_codebook _16u2_p5_1 = {
	2, 121,
	(long *)_vq_lengthlist__16u2_p5_1,
	1, -531365888, 1611661312, 4, 0,
	(long *)_vq_quantlist__16u2_p5_1,
	0
};

static const long _vq_quantlist__16u2_p6_0[] = {
	6,
	5,
	7,
	4,
	8,
	3,
	9,
	2,
	10,
	1,
	11,
	0,
	12,
};

static const long _vq_lengthlist__16u2_p6_0[] = {
	 1, 5, 4, 7, 7, 8, 8, 8, 8,10,10,11,11, 4, 6, 6,
	 7, 7, 9, 9, 9, 9,10,10,11,11, 4, 6, 6, 7, 7, 9,
	 9, 9, 9,10,10,11,11, 7, 8, 8, 9, 9, 9, 9,10,10,
	11,11,12,12, 7, 7, 7, 9, 8,10, 9,10,10,11,11,12,
	12, 8, 9, 9, 9,10,10,10,11,11,12,12,13,13, 8, 9,
	 9,10, 9,10,10,11,11,12,12,13,13, 8, 9, 9,10,10,
	11,11,11,11,12,12,13,13, 8, 9, 9,10,10,11,11,12,
	11,12,12,13,13,10,10,10,11,11,12,12,12,12,13,13,
	14,14,10,10,10,11,11,12,12,12,12,13,13,14,14,11,
	11,11,12,12,13,13,13,13,14,14,14,14,11,11,11,12,
	12,13,13,13,13,14,14,14,14,
};

static const static_codebook _16u2_p6_0 = {
	2, 169,
	(long *)_vq_lengthlist__16u2_p6_0,
	1, -526516224, 1616117760, 4, 0,
	(long *)_vq_quantlist__16u2_p6_0,
	0
};

static const long _vq_quantlist__16u2_p6_1[] = {
	2,
	1,
	3,
	0,
	4,
};

static const long _vq_lengthlist__16u2_p6_1[] = {
	 2, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
	 5, 5, 5, 5, 5, 5, 5, 5, 5,
};

static const static_codebook _16u2_p6_1 = {
	2, 25,
	(long *)_vq_lengthlist__16u2_p6_1,
	1, -533725184, 1611661312, 3, 0,
	(long *)_vq_quantlist__16u2_p6_1,
	0
};

static const long _vq_quantlist__16u2_p7_0[] = {
	6,
	5,
	7,
	4,
	8,
	3,
	9,
	2,
	10,
	1,
	11,
	0,
	12,
};

static const long _vq_lengthlist__16u2_p7_0[] = {
	 1, 4, 4, 7, 7, 8, 8, 8, 8, 9, 9,10,10, 4, 6, 6,
	 8, 8, 9, 9, 9, 9,10,10,11,10, 4, 6, 6, 8, 8, 9,
	 9, 9, 9,10,10,11,11, 7, 8, 8,10, 9,10,10,10,10,
	11,11,12,12, 7, 8, 8,10,10,10,10,10,10,11,11,12,
	12, 8, 9, 9,10,10,11,11,11,11,12,12,13,13, 8, 9,
	 9,10,10,11,11,11,11,12,12,13,13, 8, 9, 9,11,10,
	11,11,12,12,13,13,14,13, 8, 9, 9,10,10,11,11,12,
	12,13,13,13,13, 9,10,10,11,11,12,12,13,13,13,13,
	14,14, 9,10,10,11,11,12,12,13,13,13,13,14,14,10,
	11,11,12,12,13,13,14,13,14,14,15,14,10,11,11,12,
	12,13,13,14,13,14,14,15,14,
};

static const static_codebook _16u2_p7_0 = {
	2, 169,
	(long *)_vq_lengthlist__16u2_p7_0,
	1, -523206656, 1618345984, 4, 0,
	(long *)_vq_quantlist__16u2_p7_0,
	0
};

static const long _vq_quantlist__16u2_p7_1[] = {
	5,
	4,
	6,
	3,
	7,
	2,
	8,
	1,
	9,
	0,
	10,
};

static const long _vq_lengthlist__16u2_p7_1[] = {
	 2, 5, 5, 7, 7, 7, 7, 7, 7, 8, 8, 5, 6, 6, 7, 7,
	 7, 7, 8, 8, 8, 8, 5, 6, 6, 7, 7, 7, 7, 8, 8, 8,
	 8, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7,
	 7, 8, 8, 8, 8, 8, 8, 7, 7, 7, 8, 8, 8, 8, 8, 8,
	 8, 8, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 7, 8, 8,
	 8, 8, 8, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 8,
	 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
	 8, 8, 8, 8, 8, 8, 8, 8, 8,
};

static const static_codebook _16u2_p7_1 = {
	2, 121,
	(long *)_vq_lengthlist__16u2_p7_1,
	1, -531365888, 1611661312, 4, 0,
	(long *)_vq_quantlist__16u2_p7_1,
	0
};

static const long _vq_quantlist__16u2_p8_0[] = {
	7,
	6,
	8,
	5,
	9,
	4,
	10,
	3,
	11,
	2,
	12,
	1,
	13,
	0,
	14,
};

static const long _vq_lengthlist__16u2_p8_0[] = {
	 1, 4, 4, 7, 7, 8, 8, 7, 7, 9, 8,10, 9,11,11, 4,
	 7, 6, 9, 8, 9, 9, 9, 9,10, 9,11, 9,12, 9, 4, 6,
	 7, 8, 8, 9, 9, 9, 9,10,10,10,11,11,12, 7, 9, 8,
	10,10,11,11,10,10,11,11,12,12,13,12, 7, 8, 8,10,
	10,10,11,10,10,11,11,11,12,12,13, 8, 9, 9,11,11,
	11,11,11,11,12,12,13,13,13,13, 8, 9, 9,11,11,11,
	11,11,11,12,12,13,13,13,14, 8, 9, 9,10,10,11,11,
	12,11,13,13,14,13,14,14, 8, 9, 9,10,10,11,11,12,
	12,12,12,13,13,14,14, 9,10,10,11,11,12,12,13,12,
	13,13,14,14,15,15, 9,10,10,11,11,12,12,12,13,13,
	13,14,14,14,15,10,11,11,12,12,13,13,14,13,14,14,
	15,14,15,15,10,11,11,12,12,13,12,13,14,14,14,14,
	14,15,15,11,12,12,13,13,13,13,14,14,15,14,15,15,
	16,16,11,12,12,13,13,13,13,14,14,14,15,15,15,16,
	16,
};

static const static_codebook _16u2_p8_0 = {
	2, 225,
	(long *)_vq_lengthlist__16u2_p8_0,
	1, -520986624, 1620377600, 4, 0,
	(long *)_vq_quantlist__16u2_p8_0,
	0
};

static const long _vq_quantlist__16u2_p8_1[] = {
	10,
	9,
	11,
	8,
	12,
	7,
	13,
	6,
	14,
	5,
	15,
	4,
	16,
	3,
	17,
	2,
	18,
	1,
	19,
	0,
	20,
};

static const long _vq_lengthlist__16u2_p8_1[] = {
	 3, 5, 5, 7, 7, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 5, 6, 6, 7, 7, 8, 8, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9,10,10,10,10, 5, 6, 6, 7, 7, 8,
	 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 7,
	 7, 7, 8, 8, 9, 8, 9, 9, 9, 9, 9, 9,10,10,10,10,
	10,10,10,10, 7, 7, 7, 8, 8, 9, 9, 9, 9, 9, 9, 9,
	 9,10, 9,10,10,10, 9,10, 9, 8, 8, 8, 9, 8, 9, 9,
	 9, 9,10, 9,10,10,10,10,10,10,10,10,10,10, 8, 8,
	 8, 8, 9, 9, 9, 9, 9, 9, 9,10,10,10,10,10,10,10,
	10,10,10, 8, 9, 9, 9, 9, 9, 9, 9, 9,10,10,10,10,
	10,10,10,10,10,10,10,10, 8, 9, 9, 9, 9, 9, 9, 9,
	10,10,10,10,10,10,10,10,10,10,10,10,10, 9, 9, 9,
	 9, 9, 9, 9,10,10,10,10,10,10,10,10,10,10,10,10,
	10,10, 9, 9, 9, 9, 9, 9, 9,10,10,10,10,10,10,10,
	10,10,10,10,10,10,10, 9, 9, 9, 9, 9,10,10,10,10,
	10,10,10,10,10,10,10,10,10,10,10,10, 9, 9, 9, 9,
	 9,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
	10, 9, 9, 9,10,10,10,10,10,10,10,10,10,10,10,10,
	10,10,10,10,10,10, 9, 9, 9,10,10,10,10,10,10,10,
	10,10,10,10,10,10,10,10,10,10,10, 9, 9,10,10,10,
	10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
	 9,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
	10,10,10,10,10, 9,10,10,10,10,10,10,10,10,10,10,
	10,10,10,10,10,10,10,10,10,10, 9,10,10,10,10,10,
	10,10,10,10,10,10,10,10,10,10,10,10,10,10,10, 9,
	10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
	10,10,10,10, 9,10,10,10,10,10,10,10,10,10,10,10,
	10,10,10,10,10,10,10,10,10,
};

static const static_codebook _16u2_p8_1 = {
	2, 441,
	(long *)_vq_lengthlist__16u2_p8_1,
	1, -529268736, 1611661312, 5, 0,
	(long *)_vq_quantlist__16u2_p8_1,
	0
};

static const long _vq_quantlist__16u2_p9_0[] = {
	7,
	6,
	8,
	5,
	9,
	4,
	10,
	3,
	11,
	2,
	12,
	1,
	13,
	0,
	14,
};

static const long _vq_lengthlist__16u2_p9_0[] = {
	 1, 5, 3, 9, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 5,
	 7, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 5, 7,
	 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9,10,10,10,10,10,10,10,10,10,
	10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
	10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
	10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
	10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
	10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
	10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
	10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
	10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
	10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
	10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
	10,
};

static const static_codebook _16u2_p9_0 = {
	2, 225,
	(long *)_vq_lengthlist__16u2_p9_0,
	1, -510036736, 1631393792, 4, 0,
	(long *)_vq_quantlist__16u2_p9_0,
	0
};

static const long _vq_quantlist__16u2_p9_1[] = {
	9,
	8,
	10,
	7,
	11,
	6,
	12,
	5,
	13,
	4,
	14,
	3,
	15,
	2,
	16,
	1,
	17,
	0,
	18,
};

static const long _vq_lengthlist__16u2_p9_1[] = {
	 1, 4, 4, 7, 7, 7, 7, 7, 6, 9, 7,10, 8,12,12,13,
	13,14,14, 4, 7, 7, 9, 9, 9, 8, 9, 8,10, 9,11, 9,
	14, 9,14,10,13,11, 4, 7, 7, 9, 9, 9, 9, 8, 9,10,
	10,11,11,12,13,12,13,14,15, 7, 9, 9,10,11,10,10,
	10,10,11,12,13,13,13,14,17,14,15,16, 7, 9, 9,10,
	10,10,10,10,10,11,12,13,13,14,14,15,15,18,18, 8,
	 9, 9,11,10,11,11,11,12,13,12,14,14,16,15,15,17,
	18,15, 8, 9, 9,10,10,11,11,11,11,13,13,14,14,15,
	15,15,16,16,18, 7, 9, 8,10,10,11,11,12,12,14,14,
	15,15,16,16,15,17,16,18, 8, 9, 9,10,10,11,12,12,
	12,13,13,16,15,17,16,17,18,17,18, 9,10,10,12,11,
	13,13,14,13,14,14,15,17,16,18,17,18,17,18, 9,10,
	10,12,11,12,13,13,14,15,16,14,15,16,18,18,18,18,
	17,11,11,11,13,13,14,14,16,15,15,15,16,15,15,18,
	18,18,17,16,11,11,12,13,13,15,14,15,16,16,16,17,
	16,15,18,17,18,16,18,12,13,13,15,15,15,16,18,16,
	17,16,17,16,17,17,17,18,18,17,13,13,13,15,13,16,
	15,17,16,16,16,18,18,18,18,16,17,17,18,13,15,14,
	15,15,18,17,18,18,18,16,18,17,18,17,18,16,17,17,
	14,14,14,15,16,17,16,18,18,18,17,18,17,18,18,18,
	16,16,16,14,17,16,17,15,16,18,18,17,18,17,18,17,
	18,18,18,17,18,17,15,16,15,18,15,18,17,16,18,18,
	18,18,18,18,17,18,16,18,17,
};

static const static_codebook _16u2_p9_1 = {
	2, 361,
	(long *)_vq_lengthlist__16u2_p9_1,
	1, -518287360, 1622704128, 5, 0,
	(long *)_vq_quantlist__16u2_p9_1,
	0
};

static const long _vq_quantlist__16u2_p9_2[] = {
	24,
	23,
	25,
	22,
	26,
	21,
	27,
	20,
	28,
	19,
	29,
	18,
	30,
	17,
	31,
	16,
	32,
	15,
	33,
	14,
	34,
	13,
	35,
	12,
	36,
	11,
	37,
	10,
	38,
	9,
	39,
	8,
	40,
	7,
	41,
	6,
	42,
	5,
	43,
	4,
	44,
	3,
	45,
	2,
	46,
	1,
	47,
	0,
	48,
};

static const long _vq_lengthlist__16u2_p9_2[] = {
	 2, 3, 4, 4, 4, 5, 5, 6, 5, 6, 6, 6, 6, 6, 6, 7,
	 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
	 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 7, 8, 8, 8, 8, 8,
	 8,
};

static const static_codebook _16u2_p9_2 = {
	1, 49,
	(long *)_vq_lengthlist__16u2_p9_2,
	1, -526909440, 1611661312, 6, 0,
	(long *)_vq_quantlist__16u2_p9_2,
	0
};

static const long _huff_lengthlist__16u2__short[] = {
	 8,11,13,13,15,16,19,19,19,19,11, 8, 8, 9, 9,11,
	13,15,19,20,14, 8, 7, 7, 8, 9,12,13,15,20,15, 9,
	 6, 5, 5, 7,10,12,14,18,14, 9, 7, 5, 3, 4, 7,10,
	12,16,13,10, 8, 6, 3, 3, 5, 8,11,14,11,10, 9, 7,
	 5, 4, 4, 6,11,14,10,10,10, 8, 6, 5, 5, 6,10,14,
	10,10,10, 9, 8, 7, 7, 7,10,14,11,12,12,12,11,10,
	10,10,12,16,
};

static const static_codebook _huff_book__16u2__short = {
	2, 100,
	(long *)_huff_lengthlist__16u2__short,
	0, 0, 0, 0, 0,
	NULL,
	0
};

static const long _vq_quantlist__8u0__p1_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__8u0__p1_0[] = {
		 1, 4, 4, 5, 7, 7, 5, 7, 7, 5, 8, 8, 8,10,10, 7,
		10,10, 5, 8, 8, 7,10,10, 8,10,10, 4, 9, 8, 8,11,
		11, 8,11,11, 7,11,11,10,11,13,10,13,13, 7,11,11,
		10,13,12,10,13,13, 5, 9, 8, 8,11,11, 8,11,11, 7,
		11,11, 9,13,13,10,12,13, 7,11,11,10,13,13,10,13,
		11,
};

static const static_codebook _8u0__p1_0 = {
		4, 81,
		(long *)_vq_lengthlist__8u0__p1_0,
		1, -535822336, 1611661312, 2, 0,
		(long *)_vq_quantlist__8u0__p1_0,
		0
};

static const long _vq_quantlist__8u0__p2_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__8u0__p2_0[] = {
		 2, 4, 4, 5, 6, 6, 5, 6, 6, 5, 7, 7, 6, 7, 8, 6,
		 7, 8, 5, 7, 7, 6, 8, 8, 7, 9, 7, 5, 7, 7, 7, 9,
		 9, 7, 8, 8, 6, 9, 8, 7, 7,10, 8,10,10, 6, 8, 8,
		 8,10, 8, 8,10,10, 5, 7, 7, 7, 8, 8, 7, 8, 9, 6,
		 8, 8, 8,10,10, 8, 8,10, 6, 8, 9, 8,10,10, 7,10,
		 8,
};

static const static_codebook _8u0__p2_0 = {
		4, 81,
		(long *)_vq_lengthlist__8u0__p2_0,
		1, -535822336, 1611661312, 2, 0,
		(long *)_vq_quantlist__8u0__p2_0,
		0
};

static const long _vq_quantlist__8u0__p3_0[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__8u0__p3_0[] = {
		 1, 5, 5, 7, 7, 6, 7, 7, 9, 9, 6, 7, 7, 9, 9, 8,
		10, 9,11,11, 8, 9, 9,11,11, 6, 8, 8,10,10, 8,10,
		10,11,11, 8,10,10,11,11,10,11,11,12,12,10,11,11,
		12,13, 6, 8, 8,10,10, 8,10,10,11,11, 8,10,10,11,
		11, 9,10,11,12,12,10,11,11,12,12, 8,11,11,14,13,
		10,12,11,15,13,10,12,11,14,14,12,13,12,16,14,12,
		14,12,16,15, 8,11,11,13,14,10,11,12,13,15,10,11,
		12,13,15,11,12,13,14,15,12,12,14,14,16, 5, 8, 8,
		11,11, 9,11,11,12,12, 8,10,11,12,12,11,12,12,15,
		14,11,12,12,14,14, 7,11,10,13,12,10,11,12,13,14,
		10,12,12,14,13,12,13,13,14,15,12,13,13,15,15, 7,
		10,11,12,13,10,12,11,14,13,10,12,13,13,15,12,13,
		12,14,14,11,13,13,15,16, 9,12,12,15,14,11,13,13,
		15,16,11,13,13,16,16,13,14,15,15,15,12,14,15,17,
		16, 9,12,12,14,15,11,13,13,15,16,11,13,13,16,18,
		13,14,14,17,16,13,15,15,17,18, 5, 8, 9,11,11, 8,
		11,11,12,12, 8,10,11,12,12,11,12,12,14,14,11,12,
		12,14,15, 7,11,10,12,13,10,12,12,14,13,10,11,12,
		13,14,11,13,13,15,14,12,13,13,14,15, 7,10,11,13,
		13,10,12,12,13,14,10,12,12,13,13,11,13,13,16,16,
		12,13,13,15,14, 9,12,12,16,15,10,13,13,15,15,11,
		13,13,17,15,12,15,15,18,17,13,14,14,15,16, 9,12,
		12,15,15,11,13,13,15,16,11,13,13,15,15,12,15,15,
		16,16,13,15,14,17,15, 7,11,11,15,15,10,13,13,16,
		15,10,13,13,15,16,14,15,15,17,19,13,15,14,15,18,
		 9,12,12,16,16,11,13,14,17,16,11,13,13,17,16,15,
		15,16,17,19,13,15,16, 0,18, 9,12,12,16,15,11,14,
		13,17,17,11,13,14,16,16,15,16,16,19,18,13,15,15,
		17,19,11,14,14,19,16,12,14,15, 0,18,12,16,15,18,
		17,15,15,18,16,19,14,15,17,19,19,11,14,14,18,19,
		13,15,14,19,19,12,16,15,18,17,15,17,15, 0,16,14,
		17,16,19, 0, 7,11,11,14,14,10,12,12,15,15,10,13,
		13,16,15,13,15,15,17, 0,14,15,15,16,19, 9,12,12,
		16,16,11,14,14,16,16,11,13,13,16,16,14,17,16,19,
		 0,14,18,17,17,19, 9,12,12,15,16,11,13,13,15,17,
		12,14,13,19,16,13,15,15,17,19,15,17,16,17,19,11,
		14,14,19,16,12,15,15,19,17,13,14,15,17,19,14,16,
		17,19,19,16,15,16,17,19,11,15,14,16,16,12,15,15,
		19, 0,12,14,15,19,19,14,16,16, 0,18,15,19,14,18,
		16,
};

static const static_codebook _8u0__p3_0 = {
		4, 625,
		(long *)_vq_lengthlist__8u0__p3_0,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__8u0__p3_0,
		0
};

static const long _vq_quantlist__8u0__p4_0[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__8u0__p4_0[] = {
		 3, 5, 5, 8, 8, 5, 6, 7, 9, 9, 6, 7, 6, 9, 9, 9,
		 9, 9,10,11, 9, 9, 9,11,10, 6, 7, 7,10,10, 7, 7,
		 8,10,10, 7, 8, 8,10,10,10,10,10,10,11, 9,10,10,
		11,12, 6, 7, 7,10,10, 7, 8, 8,10,10, 7, 8, 7,10,
		10, 9,10,10,12,11,10,10,10,11,10, 9,10,10,12,11,
		10,10,10,13,11, 9,10,10,12,12,11,11,12,12,13,11,
		11,11,12,13, 9,10,10,12,12,10,10,11,12,12,10,10,
		11,12,12,11,11,11,13,13,11,12,12,13,13, 5, 7, 7,
		10,10, 7, 8, 8,10,10, 7, 8, 8,10,10,10,11,11,12,
		12,10,11,10,12,12, 7, 8, 8,11,11, 7, 8, 9,10,11,
		 8, 9, 9,11,11,11,10,11,10,12,10,11,11,12,13, 7,
		 8, 8,10,11, 8, 9, 8,12,10, 8, 9, 9,11,12,10,11,
		10,13,11,10,11,11,13,12, 9,11,10,13,12,10,10,11,
		12,12,10,11,11,13,13,12,10,13,11,14,11,12,12,15,
		13, 9,11,11,13,13,10,11,11,13,12,10,11,11,12,14,
		12,13,11,14,12,12,12,12,14,14, 5, 7, 7,10,10, 7,
		 8, 8,10,10, 7, 8, 8,11,10,10,11,11,12,12,10,11,
		10,12,12, 7, 8, 8,10,11, 8, 9, 9,12,11, 8, 8, 9,
		10,11,10,11,11,12,13,11,10,11,11,13, 6, 8, 8,10,
		11, 8, 9, 9,11,11, 7, 9, 7,11,10,10,11,11,12,12,
		10,11,10,13,10, 9,11,10,13,12,10,12,11,13,13,10,
		10,11,12,13,11,12,13,15,14,11,11,13,12,13, 9,10,
		11,12,13,10,11,11,12,13,10,11,10,13,12,12,13,13,
		13,14,12,12,11,14,11, 8,10,10,12,13,10,11,11,13,
		13,10,11,10,13,13,12,13,14,15,14,12,12,12,14,13,
		 9,10,10,13,12,10,10,12,13,13,10,11,11,15,12,12,
		12,13,15,14,12,13,13,15,13, 9,10,11,12,13,10,12,
		10,13,12,10,11,11,12,13,12,14,12,15,13,12,12,12,
		15,14,11,12,11,14,13,11,11,12,14,14,12,13,13,14,
		13,13,11,15,11,15,14,14,14,16,15,11,12,12,13,14,
		11,13,11,14,14,12,12,13,14,15,12,14,12,15,12,13,
		15,14,16,15, 8,10,10,12,12,10,10,10,12,13,10,11,
		11,13,13,12,12,12,13,14,13,13,13,15,15, 9,10,10,
		12,12,10,11,11,13,12,10,10,11,13,13,12,12,12,14,
		14,12,12,13,15,14, 9,10,10,13,12,10,10,12,12,13,
		10,11,10,13,13,12,13,13,14,14,12,13,12,14,13,11,
		12,12,14,13,12,13,12,14,14,10,12,12,14,14,14,14,
		14,16,14,13,12,14,12,15,10,12,12,14,15,12,13,13,
		14,16,11,12,11,15,14,13,14,14,14,15,13,14,11,14,
		12,
};

static const static_codebook _8u0__p4_0 = {
		4, 625,
		(long *)_vq_lengthlist__8u0__p4_0,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__8u0__p4_0,
		0
};

static const long _vq_quantlist__8u0__p5_0[] = {
		4,
		3,
		5,
		2,
		6,
		1,
		7,
		0,
		8,
};

static const long _vq_lengthlist__8u0__p5_0[] = {
		 1, 4, 4, 7, 7, 7, 7, 9, 9, 4, 6, 6, 8, 7, 8, 8,
		10,10, 4, 6, 6, 8, 8, 8, 8,10,10, 6, 8, 8, 9, 9,
		 9, 9,11,11, 7, 8, 8, 9, 9, 9, 9,11,11, 7, 8, 8,
		 9, 9,10,10,12,11, 7, 8, 8, 9, 9,10,10,11,11, 9,
		10,10,11,11,11,12,12,12, 9,10,10,11,11,12,12,12,
		12,
};

static const static_codebook _8u0__p5_0 = {
		2, 81,
		(long *)_vq_lengthlist__8u0__p5_0,
		1, -531628032, 1611661312, 4, 0,
		(long *)_vq_quantlist__8u0__p5_0,
		0
};

static const long _vq_quantlist__8u0__p6_0[] = {
		6,
		5,
		7,
		4,
		8,
		3,
		9,
		2,
		10,
		1,
		11,
		0,
		12,
};

static const long _vq_lengthlist__8u0__p6_0[] = {
		 1, 4, 4, 7, 7, 9, 9,11,11,12,12,16,16, 3, 6, 6,
		 9, 9,11,11,12,12,13,14,18,16, 3, 6, 7, 9, 9,11,
		11,13,12,14,14,17,16, 7, 9, 9,11,11,12,12,14,14,
		14,14,17,16, 7, 9, 9,11,11,13,12,13,13,14,14,17,
		 0, 9,11,11,12,13,14,14,14,13,15,14,17,17, 9,11,
		11,12,12,14,14,13,14,14,15, 0, 0,11,12,12,15,14,
		15,14,15,14,15,16,17, 0,11,12,13,13,13,14,14,15,
		14,15,15, 0, 0,12,14,14,15,15,14,16,15,15,17,16,
		 0,18,13,14,14,15,14,15,14,15,16,17,16, 0, 0,17,
		17,18, 0,16,18,16, 0, 0, 0,17, 0, 0,16, 0, 0,16,
		16, 0,15, 0,17, 0, 0, 0, 0,
};

static const static_codebook _8u0__p6_0 = {
		2, 169,
		(long *)_vq_lengthlist__8u0__p6_0,
		1, -526516224, 1616117760, 4, 0,
		(long *)_vq_quantlist__8u0__p6_0,
		0
};

static const long _vq_quantlist__8u0__p6_1[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__8u0__p6_1[] = {
		 1, 4, 4, 6, 6, 4, 6, 5, 7, 7, 4, 5, 6, 7, 7, 6,
		 7, 7, 7, 7, 6, 7, 7, 7, 7,
};

static const static_codebook _8u0__p6_1 = {
		2, 25,
		(long *)_vq_lengthlist__8u0__p6_1,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__8u0__p6_1,
		0
};

static const long _vq_quantlist__8u0__p7_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__8u0__p7_0[] = {
		 1, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
		 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
		 8, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
		 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
		 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
		 7,
};

static const static_codebook _8u0__p7_0 = {
		4, 81,
		(long *)_vq_lengthlist__8u0__p7_0,
		1, -518803456, 1628680192, 2, 0,
		(long *)_vq_quantlist__8u0__p7_0,
		0
};

static const long _vq_quantlist__8u0__p7_1[] = {
		7,
		6,
		8,
		5,
		9,
		4,
		10,
		3,
		11,
		2,
		12,
		1,
		13,
		0,
		14,
};

static const long _vq_lengthlist__8u0__p7_1[] = {
		 1, 5, 5, 5, 5,10,10,11,11,11,11,11,11,11,11, 5,
		 7, 6, 8, 8, 9,10,11,11,11,11,11,11,11,11, 6, 6,
		 7, 9, 7,11,10,11,11,11,11,11,11,11,11, 5, 6, 6,
		11, 8,11,11,11,11,11,11,11,11,11,11, 5, 6, 6, 9,
		10,11,10,11,11,11,11,11,11,11,11, 7,10,10,11,11,
		11,11,11,11,11,11,11,11,11,11, 7,11, 8,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,
};

static const static_codebook _8u0__p7_1 = {
		2, 225,
		(long *)_vq_lengthlist__8u0__p7_1,
		1, -520986624, 1620377600, 4, 0,
		(long *)_vq_quantlist__8u0__p7_1,
		0
};

static const long _vq_quantlist__8u0__p7_2[] = {
		10,
		9,
		11,
		8,
		12,
		7,
		13,
		6,
		14,
		5,
		15,
		4,
		16,
		3,
		17,
		2,
		18,
		1,
		19,
		0,
		20,
};

static const long _vq_lengthlist__8u0__p7_2[] = {
		 1, 6, 5, 7, 7, 9, 9, 9, 9,10,12,12,10,11,11,10,
		11,11,11,10,11, 6, 8, 8, 9, 9,10,10, 9,10,11,11,
		10,11,11,11,11,10,11,11,11,11, 6, 7, 8, 9, 9, 9,
		10,11,10,11,12,11,10,11,11,11,11,11,11,12,10, 8,
		 9, 9,10, 9,10,10, 9,10,10,10,10,10, 9,10,10,10,
		10, 9,10,10, 9, 9, 9, 9,10,10, 9, 9,10,10,11,10,
		 9,12,10,11,10, 9,10,10,10, 8, 9, 9,10, 9,10, 9,
		 9,10,10, 9,10, 9,11,10,10,10,10,10, 9,10, 8, 8,
		 9, 9,10, 9,11, 9, 8, 9, 9,10,11,10,10,10,11,12,
		 9, 9,11, 8, 9, 8,11,10,11,10,10, 9,11,10,10,10,
		10,10,10,10,11,11,11,11, 8, 9, 9, 9,10,10,10,11,
		11,12,11,12,11,10,10,10,12,11,11,11,10, 8,10, 9,
		11,10,10,11,12,10,11,12,11,11,12,11,12,12,10,11,
		11,10, 9, 9,10,11,12,10,10,10,11,10,11,11,10,12,
		12,10,11,10,11,12,10, 9,10,10,11,10,11,11,11,11,
		11,12,11,11,11, 9,11,10,11,10,11,10, 9, 9,10,11,
		11,11,10,10,11,12,12,11,12,11,11,11,12,12,12,12,
		11, 9,11,11,12,10,11,11,11,11,11,11,12,11,11,12,
		11,11,11,10,11,11, 9,11,10,11,11,11,10,10,10,11,
		11,11,12,10,11,10,11,11,11,11,12, 9,11,10,11,11,
		10,10,11,11, 9,11,11,12,10,10,10,10,10,11,11,10,
		 9,10,11,11,12,11,10,10,12,11,11,12,11,12,11,11,
		10,10,11,11,10,12,11,10,11,10,11,10,10,10,11,11,
		10,10,11,11,11,11,10,10,10,12,11,11,11,11,10, 9,
		10,11,11,11,12,11,11,11,12,10,11,11,11, 9,10,11,
		11,11,11,11,11,10,10,11,11,12,11,10,11,12,11,10,
		10,11, 9,10,11,11,11,11,11,10,11,11,10,12,11,11,
		11,12,11,11,11,10,10,11,11,
};

static const static_codebook _8u0__p7_2 = {
		2, 441,
		(long *)_vq_lengthlist__8u0__p7_2,
		1, -529268736, 1611661312, 5, 0,
		(long *)_vq_quantlist__8u0__p7_2,
		0
};

static const long _huff_lengthlist__8u0__single[] = {
		 4, 7,11, 9,12, 8, 7,10, 6, 4, 5, 5, 7, 5, 6,16,
		 9, 5, 5, 6, 7, 7, 9,16, 7, 4, 6, 5, 7, 5, 7,17,
		10, 7, 7, 8, 7, 7, 8,18, 7, 5, 6, 4, 5, 4, 5,15,
		 7, 6, 7, 5, 6, 4, 5,15,12,13,18,12,17,11, 9,17,
};

static const static_codebook _huff_book__8u0__single = {
		2, 64,
		(long *)_huff_lengthlist__8u0__single,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _vq_quantlist__8u1__p1_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__8u1__p1_0[] = {
		 1, 4, 4, 5, 7, 7, 5, 7, 7, 5, 8, 8, 7, 9,10, 7,
		 9, 9, 5, 8, 8, 7,10, 9, 7, 9, 9, 5, 8, 8, 8,10,
		10, 8,10,10, 7,10,10, 9,10,12,10,12,12, 7,10,10,
		 9,12,11,10,12,12, 5, 8, 8, 8,10,10, 8,10,10, 7,
		10,10,10,12,12, 9,11,12, 7,10,10,10,12,12, 9,12,
		10,
};

static const static_codebook _8u1__p1_0 = {
		4, 81,
		(long *)_vq_lengthlist__8u1__p1_0,
		1, -535822336, 1611661312, 2, 0,
		(long *)_vq_quantlist__8u1__p1_0,
		0
};

static const long _vq_quantlist__8u1__p2_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__8u1__p2_0[] = {
		 3, 4, 5, 5, 6, 6, 5, 6, 6, 5, 7, 6, 6, 7, 8, 6,
		 7, 8, 5, 6, 6, 6, 8, 7, 6, 8, 7, 5, 6, 6, 7, 8,
		 8, 6, 7, 7, 6, 8, 7, 7, 7, 9, 8, 9, 9, 6, 7, 8,
		 7, 9, 7, 8, 9, 9, 5, 6, 6, 6, 7, 7, 7, 8, 8, 6,
		 8, 7, 8, 9, 9, 7, 7, 9, 6, 7, 8, 8, 9, 9, 7, 9,
		 7,
};

static const static_codebook _8u1__p2_0 = {
		4, 81,
		(long *)_vq_lengthlist__8u1__p2_0,
		1, -535822336, 1611661312, 2, 0,
		(long *)_vq_quantlist__8u1__p2_0,
		0
};

static const long _vq_quantlist__8u1__p3_0[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__8u1__p3_0[] = {
		 1, 5, 5, 7, 7, 6, 7, 7, 9, 9, 6, 7, 7, 9, 9, 8,
		10, 9,11,11, 9, 9, 9,11,11, 6, 8, 8,10,10, 8,10,
		10,11,11, 8, 9,10,11,11,10,11,11,12,12,10,11,11,
		12,13, 6, 8, 8,10,10, 8,10, 9,11,11, 8,10, 9,11,
		11,10,11,11,12,12,10,11,11,12,12, 9,11,11,14,13,
		10,12,11,14,14,10,12,11,14,13,12,13,13,15,14,12,
		13,13,15,14, 8,11,11,13,14,10,11,12,13,15,10,11,
		12,14,14,12,13,13,14,15,12,13,13,14,15, 5, 8, 8,
		11,11, 8,10,10,12,12, 8,10,10,12,12,11,12,12,14,
		13,11,12,12,13,14, 8,10,10,12,12, 9,11,12,13,14,
		10,12,12,13,13,12,12,13,14,14,11,13,13,15,15, 7,
		10,10,12,12, 9,12,11,14,12,10,11,12,13,14,12,13,
		12,14,14,12,13,13,15,16,10,12,12,15,14,11,12,13,
		15,15,11,13,13,15,16,14,14,15,15,16,13,14,15,17,
		15, 9,12,12,14,15,11,13,12,15,15,11,13,13,15,15,
		13,14,13,15,14,13,14,14,17, 0, 5, 8, 8,11,11, 8,
		10,10,12,12, 8,10,10,12,12,11,12,12,14,14,11,12,
		12,14,14, 7,10,10,12,12,10,12,12,13,13, 9,11,12,
		12,13,11,12,13,15,15,11,12,13,14,15, 8,10,10,12,
		12,10,12,11,13,13,10,12,11,13,13,11,13,13,15,14,
		12,13,12,15,13, 9,12,12,14,14,11,13,13,16,15,11,
		12,13,16,15,13,14,15,16,16,13,13,15,15,16,10,12,
		12,15,14,11,13,13,14,16,11,13,13,15,16,13,15,15,
		16,17,13,15,14,16,15, 8,11,11,14,15,10,12,12,15,
		15,10,12,12,15,16,14,15,15,16,17,13,14,14,16,16,
		 9,12,12,15,15,11,13,14,15,17,11,13,13,15,16,14,
		15,16,19,17,13,15,15, 0,17, 9,12,12,15,15,11,14,
		13,16,15,11,13,13,15,16,15,15,15,18,17,13,15,15,
		17,17,11,15,14,18,16,12,14,15,17,17,12,15,15,18,
		18,15,15,16,15,19,14,16,16, 0, 0,11,14,14,16,17,
		12,15,14,18,17,12,15,15,18,18,15,17,15,18,16,14,
		16,16,18,18, 7,11,11,14,14,10,12,12,15,15,10,12,
		13,15,15,13,14,15,16,16,14,15,15,18,18, 9,12,12,
		15,15,11,13,13,16,15,11,12,13,16,16,14,15,15,17,
		16,15,16,16,17,17, 9,12,12,15,15,11,13,13,15,17,
		11,14,13,16,15,13,15,15,17,17,15,15,15,18,17,11,
		14,14,17,15,12,14,15,17,18,13,13,15,17,17,14,16,
		16,19,18,16,15,17,17, 0,11,14,14,17,17,12,15,15,
		18, 0,12,15,14,18,16,14,17,17,19, 0,16,18,15, 0,
		16,
};

static const static_codebook _8u1__p3_0 = {
		4, 625,
		(long *)_vq_lengthlist__8u1__p3_0,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__8u1__p3_0,
		0
};

static const long _vq_quantlist__8u1__p4_0[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__8u1__p4_0[] = {
		 4, 5, 5, 9, 9, 6, 7, 7, 9, 9, 6, 7, 7, 9, 9, 9,
		 9, 9,11,11, 9, 9, 9,11,11, 6, 7, 7, 9, 9, 7, 7,
		 8, 9,10, 7, 7, 8, 9,10, 9, 9,10,10,11, 9, 9,10,
		10,12, 6, 7, 7, 9, 9, 7, 8, 7,10, 9, 7, 8, 7,10,
		 9, 9,10, 9,12,11,10,10, 9,12,10, 9,10,10,12,11,
		 9,10,10,12,11, 9,10,10,12,12,11,11,12,12,13,11,
		11,12,12,13, 9, 9,10,12,11, 9,10,10,12,12,10,10,
		10,12,12,11,12,11,13,12,11,12,11,13,12, 6, 7, 7,
		 9, 9, 7, 8, 8,10,10, 7, 8, 7,10, 9,10,10,10,12,
		12,10,10,10,12,11, 7, 8, 7,10,10, 7, 7, 9,10,11,
		 8, 9, 9,11,10,10,10,11,10,12,10,10,11,12,12, 7,
		 8, 8,10,10, 7, 9, 8,11,10, 8, 8, 9,11,11,10,11,
		10,12,11,10,11,11,12,12, 9,10,10,12,12, 9,10,10,
		12,12,10,11,11,13,12,11,10,12,10,14,12,12,12,13,
		14, 9,10,10,12,12, 9,11,10,12,12,10,11,11,12,12,
		11,12,11,14,12,12,12,12,14,14, 5, 7, 7, 9, 9, 7,
		 7, 7, 9,10, 7, 8, 8,10,10,10,10,10,11,11,10,10,
		10,12,12, 7, 8, 8,10,10, 8, 9, 8,11,10, 7, 8, 9,
		10,11,10,10,10,11,12,10,10,11,11,13, 6, 7, 8,10,
		10, 8, 9, 9,10,10, 7, 9, 7,11,10,10,11,10,12,12,
		10,11,10,12,10, 9,10,10,12,12,10,11,11,13,12, 9,
		10,10,12,12,12,12,12,14,13,11,11,12,11,14, 9,10,
		10,11,12,10,11,11,12,13, 9,10,10,12,12,12,12,12,
		14,13,11,12,10,14,11, 9, 9,10,11,12, 9,10,10,12,
		12, 9,10,10,12,12,12,12,12,14,14,11,12,12,13,12,
		 9,10, 9,12,12, 9,10,11,12,13,10,11,10,13,11,12,
		12,13,13,14,12,12,12,13,13, 9,10,10,12,12,10,11,
		10,13,12,10,10,11,12,13,12,13,12,14,13,12,12,12,
		13,14,11,12,11,14,13,10,10,11,13,13,12,12,12,14,
		13,12,10,14,10,15,13,14,14,14,14,11,11,12,13,14,
		10,12,11,13,13,12,12,12,13,15,12,13,11,15,12,13,
		13,14,14,14, 9,10, 9,12,12, 9,10,10,12,12,10,10,
		10,12,12,11,11,12,12,13,12,12,12,14,14, 9,10,10,
		12,12,10,11,10,13,12,10,10,11,12,13,12,12,12,14,
		13,12,12,13,13,14, 9,10,10,12,13,10,10,11,11,12,
		 9,11,10,13,12,12,12,12,13,14,12,13,12,14,13,11,
		12,11,13,13,12,13,12,14,13,10,11,12,13,13,13,13,
		13,14,15,12,11,14,12,14,11,11,12,12,13,12,12,12,
		13,14,10,12,10,14,13,13,13,13,14,15,12,14,11,15,
		10,
};

static const static_codebook _8u1__p4_0 = {
		4, 625,
		(long *)_vq_lengthlist__8u1__p4_0,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__8u1__p4_0,
		0
};

static const long _vq_quantlist__8u1__p5_0[] = {
		4,
		3,
		5,
		2,
		6,
		1,
		7,
		0,
		8,
};

static const long _vq_lengthlist__8u1__p5_0[] = {
		 1, 4, 4, 7, 7, 7, 7, 9, 9, 4, 6, 5, 8, 7, 8, 8,
		10,10, 4, 6, 6, 8, 8, 8, 8,10,10, 7, 8, 8, 9, 9,
		 9, 9,11,11, 7, 8, 8, 9, 9, 9, 9,11,11, 8, 8, 8,
		 9, 9,10,10,12,11, 8, 8, 8, 9, 9,10,10,11,11, 9,
		10,10,11,11,11,11,13,12, 9,10,10,11,11,12,12,12,
		13,
};

static const static_codebook _8u1__p5_0 = {
		2, 81,
		(long *)_vq_lengthlist__8u1__p5_0,
		1, -531628032, 1611661312, 4, 0,
		(long *)_vq_quantlist__8u1__p5_0,
		0
};

static const long _vq_quantlist__8u1__p6_0[] = {
		4,
		3,
		5,
		2,
		6,
		1,
		7,
		0,
		8,
};

static const long _vq_lengthlist__8u1__p6_0[] = {
		 3, 4, 4, 6, 6, 7, 7, 9, 9, 4, 4, 5, 6, 6, 7, 7,
		 9, 9, 4, 4, 4, 6, 6, 7, 7, 9, 9, 6, 6, 6, 7, 7,
		 8, 8, 9, 9, 6, 6, 6, 7, 7, 8, 8, 9, 9, 7, 7, 7,
		 8, 8, 8, 9,10,10, 7, 7, 7, 8, 8, 9, 8,10,10, 9,
		 9, 9, 9, 9,10,10,10,10, 9, 9, 9, 9, 9,10,10,10,
		10,
};

static const static_codebook _8u1__p6_0 = {
		2, 81,
		(long *)_vq_lengthlist__8u1__p6_0,
		1, -531628032, 1611661312, 4, 0,
		(long *)_vq_quantlist__8u1__p6_0,
		0
};

static const long _vq_quantlist__8u1__p7_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__8u1__p7_0[] = {
		 1, 4, 4, 5, 7, 7, 5, 7, 7, 5, 9, 9, 8,10,10, 8,
		10,10, 5, 9, 9, 7,10,10, 8,10,10, 4,10,10, 9,12,
		12, 9,11,11, 7,12,11,10,11,13,10,13,13, 7,12,12,
		10,13,12,10,13,13, 4,10,10, 9,12,12, 9,12,12, 7,
		12,12,10,13,13,10,12,13, 7,11,12,10,13,13,10,13,
		11,
};

static const static_codebook _8u1__p7_0 = {
		4, 81,
		(long *)_vq_lengthlist__8u1__p7_0,
		1, -529137664, 1618345984, 2, 0,
		(long *)_vq_quantlist__8u1__p7_0,
		0
};

static const long _vq_quantlist__8u1__p7_1[] = {
		5,
		4,
		6,
		3,
		7,
		2,
		8,
		1,
		9,
		0,
		10,
};

static const long _vq_lengthlist__8u1__p7_1[] = {
		 2, 4, 4, 6, 6, 7, 7, 8, 8, 8, 8, 4, 5, 5, 7, 7,
		 8, 8, 9, 9, 9, 9, 4, 5, 5, 7, 7, 8, 8, 9, 9, 9,
		 9, 6, 7, 7, 8, 8, 8, 8, 9, 9, 9, 9, 6, 7, 7, 8,
		 8, 8, 8, 9, 9, 9, 9, 8, 8, 8, 8, 8, 9, 9, 9, 9,
		 9, 9, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 8, 9, 9,
		 9, 9, 9, 9,10,10,10,10, 8, 9, 9, 9, 9, 9, 9,10,
		10,10,10, 8, 9, 9, 9, 9, 9, 9,10,10,10,10, 8, 9,
		 9, 9, 9, 9, 9,10,10,10,10,
};

static const static_codebook _8u1__p7_1 = {
		2, 121,
		(long *)_vq_lengthlist__8u1__p7_1,
		1, -531365888, 1611661312, 4, 0,
		(long *)_vq_quantlist__8u1__p7_1,
		0
};

static const long _vq_quantlist__8u1__p8_0[] = {
		5,
		4,
		6,
		3,
		7,
		2,
		8,
		1,
		9,
		0,
		10,
};

static const long _vq_lengthlist__8u1__p8_0[] = {
		 1, 4, 4, 6, 6, 8, 8,10,10,11,11, 4, 6, 6, 7, 7,
		 9, 9,11,11,13,12, 4, 6, 6, 7, 7, 9, 9,11,11,12,
		12, 6, 7, 7, 9, 9,11,11,12,12,13,13, 6, 7, 7, 9,
		 9,11,11,12,12,13,13, 8, 9, 9,11,11,12,12,13,13,
		14,14, 8, 9, 9,11,11,12,12,13,13,14,14, 9,11,11,
		12,12,13,13,14,14,15,15, 9,11,11,12,12,13,13,14,
		14,15,14,11,12,12,13,13,14,14,15,15,16,16,11,12,
		12,13,13,14,14,15,15,15,15,
};

static const static_codebook _8u1__p8_0 = {
		2, 121,
		(long *)_vq_lengthlist__8u1__p8_0,
		1, -524582912, 1618345984, 4, 0,
		(long *)_vq_quantlist__8u1__p8_0,
		0
};

static const long _vq_quantlist__8u1__p8_1[] = {
		5,
		4,
		6,
		3,
		7,
		2,
		8,
		1,
		9,
		0,
		10,
};

static const long _vq_lengthlist__8u1__p8_1[] = {
		 2, 5, 5, 6, 6, 7, 7, 7, 7, 8, 8, 5, 6, 6, 7, 7,
		 7, 7, 8, 8, 8, 8, 5, 6, 6, 7, 7, 7, 7, 8, 8, 8,
		 8, 6, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 6, 7, 7, 7,
		 7, 8, 8, 8, 8, 8, 8, 7, 7, 7, 8, 8, 8, 8, 8, 8,
		 8, 8, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
		 8, 8, 8, 8, 9, 8, 9, 9, 7, 8, 8, 8, 8, 8, 8, 9,
		 8, 9, 9, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 8, 8,
		 8, 8, 8, 8, 8, 9, 9, 9, 9,
};

static const static_codebook _8u1__p8_1 = {
		2, 121,
		(long *)_vq_lengthlist__8u1__p8_1,
		1, -531365888, 1611661312, 4, 0,
		(long *)_vq_quantlist__8u1__p8_1,
		0
};

static const long _vq_quantlist__8u1__p9_0[] = {
		7,
		6,
		8,
		5,
		9,
		4,
		10,
		3,
		11,
		2,
		12,
		1,
		13,
		0,
		14,
};

static const long _vq_lengthlist__8u1__p9_0[] = {
		 1, 4, 4,11,11,11,11,11,11,11,11,11,11,11,11, 3,
		11, 8,11,11,11,11,11,11,11,11,11,11,11,11, 3, 9,
		 9,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,
};

static const static_codebook _8u1__p9_0 = {
		2, 225,
		(long *)_vq_lengthlist__8u1__p9_0,
		1, -514071552, 1627381760, 4, 0,
		(long *)_vq_quantlist__8u1__p9_0,
		0
};

static const long _vq_quantlist__8u1__p9_1[] = {
		7,
		6,
		8,
		5,
		9,
		4,
		10,
		3,
		11,
		2,
		12,
		1,
		13,
		0,
		14,
};

static const long _vq_lengthlist__8u1__p9_1[] = {
		 1, 4, 4, 7, 7, 9, 9, 7, 7, 8, 8,10,10,11,11, 4,
		 7, 7, 9, 9,10,10, 8, 8,10,10,10,11,10,11, 4, 7,
		 7, 9, 9,10,10, 8, 8,10, 9,11,11,11,11, 7, 9, 9,
		12,12,11,12,10,10,11,10,12,11,11,11, 7, 9, 9,11,
		11,13,12, 9, 9,11,10,11,11,12,11, 9,10,10,12,12,
		14,14,10,10,11,12,12,11,11,11, 9,10,11,11,13,14,
		13,10,11,11,11,12,11,12,12, 7, 8, 8,10, 9,11,10,
		11,12,12,11,12,14,12,13, 7, 8, 8, 9,10,10,11,12,
		12,12,11,12,12,12,13, 9, 9, 9,11,11,13,12,12,12,
		12,11,12,12,13,12, 8,10,10,11,10,11,12,12,12,12,
		12,12,14,12,12, 9,11,11,11,12,12,12,12,13,13,12,
		12,13,13,12,10,11,11,12,11,12,12,12,11,12,13,12,
		12,12,13,11,11,12,12,12,13,12,12,11,12,13,13,12,
		12,13,12,11,12,12,13,13,12,13,12,13,13,13,13,14,
		13,
};

static const static_codebook _8u1__p9_1 = {
		2, 225,
		(long *)_vq_lengthlist__8u1__p9_1,
		1, -522338304, 1620115456, 4, 0,
		(long *)_vq_quantlist__8u1__p9_1,
		0
};

static const long _vq_quantlist__8u1__p9_2[] = {
		8,
		7,
		9,
		6,
		10,
		5,
		11,
		4,
		12,
		3,
		13,
		2,
		14,
		1,
		15,
		0,
		16,
};

static const long _vq_lengthlist__8u1__p9_2[] = {
		 2, 5, 4, 6, 6, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9,
		 9, 5, 6, 6, 7, 7, 8, 8, 9, 8, 9, 9, 9, 9, 9, 9,
		 9, 9, 5, 6, 6, 7, 7, 8, 8, 8, 9, 9, 9, 9, 9, 9,
		 9, 9, 9, 7, 7, 7, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9,
		 9,10,10, 9, 7, 7, 7, 8, 8, 9, 9, 9, 9, 9, 9, 9,
		 9, 9, 9,10,10, 8, 8, 8, 9, 9, 9, 9,10,10,10, 9,
		10,10,10,10,10,10, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9,
		10,10,10,10,10,10,10, 9, 9, 9, 9, 9, 9, 9, 9,10,
		10,10,10,10,10,10,10,10, 9, 9, 9, 9, 9,10,10,10,
		10,10,10,10,10,10,10,10,10, 9, 9, 9, 9, 9, 9,10,
		10,10,10,10,10,10,10,10,10,10, 9, 9, 9, 9, 9,10,
		10,10,10,10,10,10,10,10,10,10,10, 9, 9, 9, 9,10,
		10,10,10,10,10,10,10,10,10,10,10,10, 9, 9, 9, 9,
		 9,10,10,10,10,10,10,10,10,10,10,10,10, 9, 9, 9,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10, 9,10,
		 9, 9, 9,10,10,10,10,10,10,10,10,10,10,10,10, 9,
		10, 9,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		 9, 9,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,
};

static const static_codebook _8u1__p9_2 = {
		2, 289,
		(long *)_vq_lengthlist__8u1__p9_2,
		1, -529530880, 1611661312, 5, 0,
		(long *)_vq_quantlist__8u1__p9_2,
		0
};

static const long _huff_lengthlist__8u1__single[] = {
		 4, 7,13, 9,15, 9,16, 8,10,13, 7, 5, 8, 6, 9, 7,
		10, 7,10,11,11, 6, 7, 8, 8, 9, 9, 9,12,16, 8, 5,
		 8, 6, 8, 6, 9, 7,10,12,11, 7, 7, 7, 6, 7, 7, 7,
		11,15, 7, 5, 8, 6, 7, 5, 7, 6, 9,13,13, 9, 9, 8,
		 6, 6, 5, 5, 9,14, 8, 6, 8, 6, 6, 4, 5, 3, 5,13,
		 9, 9,11, 8,10, 7, 8, 4, 5,12,11,16,17,15,17,12,
		13, 8, 8,15,
};

static const static_codebook _huff_book__8u1__single = {
		2, 100,
		(long *)_huff_lengthlist__8u1__single,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist__44u0__long[] = {
		 5, 8,13,10,17,11,11,15, 7, 2, 4, 5, 8, 7, 9,16,
		13, 4, 3, 5, 6, 8,11,20,10, 4, 5, 5, 7, 6, 8,18,
		15, 7, 6, 7, 8,10,14,20,10, 6, 7, 6, 9, 7, 8,17,
		 9, 8,10, 8,10, 5, 4,11,12,17,19,14,16,10, 7,12,
};

static const static_codebook _huff_book__44u0__long = {
		2, 64,
		(long *)_huff_lengthlist__44u0__long,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _vq_quantlist__44u0__p1_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__44u0__p1_0[] = {
		 1, 4, 4, 5, 8, 7, 5, 7, 8, 5, 8, 8, 8,11,11, 8,
		10,10, 5, 8, 8, 8,11,10, 8,11,11, 4, 8, 8, 8,11,
		11, 8,11,11, 8,12,11,11,13,13,11,13,14, 7,11,11,
		10,13,12,11,13,14, 4, 8, 8, 8,11,11, 8,11,12, 8,
		11,11,11,13,13,10,12,13, 8,11,11,11,14,13,11,14,
		13,
};

static const static_codebook _44u0__p1_0 = {
		4, 81,
		(long *)_vq_lengthlist__44u0__p1_0,
		1, -535822336, 1611661312, 2, 0,
		(long *)_vq_quantlist__44u0__p1_0,
		0
};

static const long _vq_quantlist__44u0__p2_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__44u0__p2_0[] = {
		 2, 4, 4, 5, 6, 6, 5, 6, 6, 5, 7, 7, 7, 8, 8, 6,
		 8, 8, 5, 7, 7, 6, 8, 8, 7, 8, 8, 4, 7, 7, 7, 8,
		 8, 7, 8, 8, 7, 8, 8, 8, 9,10, 8,10,10, 6, 8, 8,
		 8,10, 8, 8,10,10, 5, 7, 7, 7, 8, 8, 7, 8, 8, 6,
		 8, 8, 8,10,10, 8, 8,10, 6, 8, 8, 8,10,10, 8,10,
		 9,
};

static const static_codebook _44u0__p2_0 = {
		4, 81,
		(long *)_vq_lengthlist__44u0__p2_0,
		1, -535822336, 1611661312, 2, 0,
		(long *)_vq_quantlist__44u0__p2_0,
		0
};

static const long _vq_quantlist__44u0__p3_0[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__44u0__p3_0[] = {
		 1, 5, 5, 8, 8, 5, 8, 7, 9, 9, 5, 7, 8, 9, 9, 9,
		10, 9,12,12, 9, 9,10,12,12, 6, 8, 8,11,10, 8,10,
		10,11,11, 8, 9,10,11,11,10,11,11,14,13,10,11,11,
		13,13, 5, 8, 8,10,10, 8,10,10,11,11, 8,10,10,11,
		11,10,11,11,13,13,10,11,11,13,13, 9,11,11,15,14,
		10,12,12,15,14,10,12,11,15,14,13,14,14,16,16,12,
		14,13,17,15, 9,11,11,14,15,10,11,12,14,16,10,11,
		12,14,16,12,13,14,16,16,13,13,15,15,18, 5, 8, 8,
		11,11, 8,10,10,12,12, 8,10,10,12,13,11,12,12,14,
		14,11,12,12,15,15, 8,10,10,13,13,10,12,12,13,13,
		10,12,12,14,14,12,13,13,15,15,12,13,13,16,16, 7,
		10,10,12,12,10,12,11,13,13,10,12,12,13,14,12,13,
		12,15,14,12,13,13,16,16,10,12,12,17,16,12,13,13,
		16,15,11,13,13,17,17,15,15,15,16,17,14,15,15,19,
		19,10,12,12,15,16,11,13,12,15,18,11,13,13,16,16,
		14,15,15,17,17,14,15,15,17,19, 5, 8, 8,11,11, 8,
		10,10,12,12, 8,10,10,12,12,11,12,12,16,15,11,12,
		12,14,15, 7,10,10,13,13,10,12,12,14,13,10,11,12,
		13,13,12,13,13,16,16,12,12,13,15,15, 8,10,10,13,
		13,10,12,12,14,14,10,12,12,13,13,12,13,13,16,16,
		12,13,13,15,15,10,12,12,16,15,11,13,13,17,16,11,
		12,13,16,15,13,15,15,19,17,14,15,14,17,16,10,12,
		12,16,16,11,13,13,16,17,12,13,13,15,17,14,15,15,
		17,19,14,15,15,17,17, 8,11,11,16,16,10,13,12,17,
		17,10,12,13,16,16,15,17,16,20,19,14,15,17,18,19,
		 9,12,12,16,17,11,13,14,17,18,11,13,13,19,18,16,
		17,18,19,19,15,16,16,19,19, 9,12,12,16,17,11,14,
		13,18,17,11,13,13,17,17,16,17,16,20,19,14,16,16,
		18,18,12,15,15,19,17,14,15,16, 0,20,13,15,16,20,
		17,18,16,20, 0, 0,15,16,19,20, 0,12,15,14,18,19,
		13,16,15,20,19,13,16,15,20,18,17,18,17, 0,20,16,
		17,16, 0, 0, 8,11,11,16,15,10,12,12,17,17,10,13,
		13,17,16,14,16,15,18,20,15,16,16,19,19, 9,12,12,
		16,16,11,13,13,17,16,11,13,14,17,18,15,15,16,20,
		20,16,16,17,19,19, 9,13,12,16,17,11,14,13,17,17,
		11,14,14,18,17,14,16,15,18,19,16,17,18,18,19,12,
		14,15,19,18,13,15,16,18, 0,13,14,15, 0, 0,16,16,
		17,20, 0,17,17,20,20, 0,12,15,15,19,20,13,15,15,
		 0, 0,14,16,15, 0, 0,15,18,16, 0, 0,17,18,16, 0,
		19,
};

static const static_codebook _44u0__p3_0 = {
		4, 625,
		(long *)_vq_lengthlist__44u0__p3_0,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__44u0__p3_0,
		0
};

static const long _vq_quantlist__44u0__p4_0[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__44u0__p4_0[] = {
		 4, 5, 5, 9, 9, 5, 6, 6, 9, 9, 5, 6, 6, 9, 9, 9,
		10, 9,12,12, 9, 9,10,12,12, 5, 7, 7,10,10, 7, 7,
		 8,10,10, 6, 7, 8,10,10,10,10,10,11,13,10, 9,10,
		12,13, 5, 7, 7,10,10, 6, 8, 7,10,10, 7, 8, 7,10,
		10, 9,10,10,12,12,10,10,10,13,11, 9,10,10,13,13,
		10,11,10,13,13,10,10,10,13,13,12,12,13,14,14,12,
		12,13,14,14, 9,10,10,13,13,10,10,10,13,13,10,10,
		10,13,13,12,13,12,15,14,12,13,12,15,15, 5, 7, 6,
		10,10, 7, 8, 8,10,10, 7, 8, 8,10,10,10,11,10,13,
		13,10,10,10,12,12, 7, 8, 8,11,10, 8, 8, 9,10,11,
		 8, 9, 9,11,11,11,10,11,11,14,11,11,11,13,13, 6,
		 8, 8,10,10, 7, 9, 8,11,10, 8, 9, 9,11,11,10,11,
		10,14,11,10,11,11,13,13,10,11,11,14,13,10,10,11,
		14,13,10,11,11,14,14,12,11,13,12,16,13,14,14,15,
		15,10,10,11,13,14,10,11,10,14,13,10,11,11,14,14,
		12,13,12,15,13,13,13,14,15,16, 5, 7, 7,10,10, 7,
		 8, 8,10,10, 7, 8, 8,10,10,10,10,10,13,13,10,10,
		11,12,13, 6, 8, 8,11,10, 8, 9, 9,11,11, 7, 8, 9,
		10,11,10,11,11,13,13,10,10,11,11,13, 6, 8, 8,10,
		11, 8, 9, 9,11,11, 8, 9, 8,12,10,10,11,11,13,13,
		10,11,10,14,11,10,10,10,14,13,10,11,11,14,13,10,
		10,11,13,13,12,14,14,16,16,12,12,13,13,15,10,11,
		11,13,14,10,11,11,14,15,10,11,10,13,13,13,14,13,
		16,16,12,13,11,15,12, 9,10,10,13,13,10,11,11,14,
		13,10,10,11,13,14,13,14,13,16,16,13,13,13,15,16,
		 9,10,10,13,13,10,10,11,13,14,10,11,11,15,13,13,
		13,14,14,18,13,13,14,16,15, 9,10,10,13,14,10,11,
		10,14,13,10,11,11,13,14,13,14,13,16,15,13,13,14,
		15,16,12,13,12,16,14,11,11,13,15,15,13,14,13,16,
		15,15,12,16,12,17,14,15,15,17,17,12,13,13,14,16,
		11,13,11,16,15,12,13,14,15,16,14,15,13, 0,14,14,
		16,16, 0, 0, 9,10,10,13,13,10,11,10,14,14,10,11,
		11,13,13,12,13,13,14,16,13,14,14,16,16, 9,10,10,
		14,14,11,11,11,14,13,10,10,11,14,14,13,13,13,16,
		16,13,13,14,14,17, 9,10,10,13,14,10,11,11,13,15,
		10,11,10,14,14,13,13,13,14,17,13,14,13,17,14,12,
		13,13,16,14,13,14,13,16,15,12,12,13,15,16,15,15,
		16,18,16,15,13,15,14, 0,12,12,13,14,16,13,13,14,
		15,16,11,12,11,16,14,15,16,16,17,17,14,15,12,17,
		12,
};

static const static_codebook _44u0__p4_0 = {
		4, 625,
		(long *)_vq_lengthlist__44u0__p4_0,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__44u0__p4_0,
		0
};

static const long _vq_quantlist__44u0__p5_0[] = {
		4,
		3,
		5,
		2,
		6,
		1,
		7,
		0,
		8,
};

static const long _vq_lengthlist__44u0__p5_0[] = {
		 1, 4, 4, 7, 7, 7, 7, 9, 9, 4, 6, 6, 8, 8, 8, 8,
		 9, 9, 4, 6, 6, 8, 8, 8, 8, 9, 9, 7, 8, 8, 9, 9,
		 9, 9,11,10, 7, 8, 8, 9, 9, 9, 9,10,10, 7, 8, 8,
		 9, 9,10,10,11,11, 7, 8, 8, 9, 9,10,10,11,11, 9,
		 9, 9,10,10,11,11,12,12, 9, 9, 9,10,11,11,11,12,
		12,
};

static const static_codebook _44u0__p5_0 = {
		2, 81,
		(long *)_vq_lengthlist__44u0__p5_0,
		1, -531628032, 1611661312, 4, 0,
		(long *)_vq_quantlist__44u0__p5_0,
		0
};

static const long _vq_quantlist__44u0__p6_0[] = {
		6,
		5,
		7,
		4,
		8,
		3,
		9,
		2,
		10,
		1,
		11,
		0,
		12,
};

static const long _vq_lengthlist__44u0__p6_0[] = {
		 1, 4, 4, 6, 6, 8, 8,10, 9,11,10,14,13, 4, 6, 5,
		 8, 8, 9, 9,11,10,11,11,14,14, 4, 5, 6, 8, 8, 9,
		 9,10,10,11,11,14,14, 6, 8, 8, 9, 9,10,10,11,11,
		12,12,16,15, 7, 8, 8, 9, 9,10,10,11,11,12,12,15,
		15, 9,10,10,10,10,11,11,12,12,12,12,15,15, 9,10,
		 9,10,11,11,11,12,12,12,13,15,15,10,10,11,11,11,
		12,12,13,12,13,13,16,15,10,11,11,11,11,12,12,13,
		12,13,13,16,17,11,11,12,12,12,13,13,13,14,14,15,
		17,17,11,11,12,12,12,13,13,13,14,14,14,16,18,14,
		15,15,15,15,16,16,16,16,17,18, 0, 0,14,15,15,15,
		15,17,16,17,18,17,17,18, 0,
};

static const static_codebook _44u0__p6_0 = {
		2, 169,
		(long *)_vq_lengthlist__44u0__p6_0,
		1, -526516224, 1616117760, 4, 0,
		(long *)_vq_quantlist__44u0__p6_0,
		0
};

static const long _vq_quantlist__44u0__p6_1[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__44u0__p6_1[] = {
		 2, 4, 4, 5, 5, 4, 5, 5, 5, 5, 4, 5, 5, 5, 5, 5,
		 6, 6, 6, 6, 5, 6, 6, 6, 6,
};

static const static_codebook _44u0__p6_1 = {
		2, 25,
		(long *)_vq_lengthlist__44u0__p6_1,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__44u0__p6_1,
		0
};

static const long _vq_quantlist__44u0__p7_0[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__44u0__p7_0[] = {
		 1, 4, 4,11,11, 9,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11, 9,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,10,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,
};

static const static_codebook _44u0__p7_0 = {
		4, 625,
		(long *)_vq_lengthlist__44u0__p7_0,
		1, -518709248, 1626677248, 3, 0,
		(long *)_vq_quantlist__44u0__p7_0,
		0
};

static const long _vq_quantlist__44u0__p7_1[] = {
		6,
		5,
		7,
		4,
		8,
		3,
		9,
		2,
		10,
		1,
		11,
		0,
		12,
};

static const long _vq_lengthlist__44u0__p7_1[] = {
		 1, 4, 4, 6, 6, 6, 6, 7, 7, 8, 8, 9, 9, 5, 7, 7,
		 8, 7, 7, 7, 9, 8,10, 9,10,11, 5, 7, 7, 8, 8, 7,
		 7, 8, 9,10,10,11,11, 6, 8, 8, 9, 9, 9, 9,11,10,
		12,12,15,12, 6, 8, 8, 9, 9, 9, 9,11,11,12,11,14,
		12, 7, 8, 8,10,10,12,12,13,13,13,15,13,13, 7, 8,
		 8,10,10,11,11,13,12,14,15,15,15, 9,10,10,11,12,
		13,13,14,15,14,15,14,15, 8,10,10,12,12,14,14,15,
		14,14,15,15,14,10,12,12,14,14,15,14,15,15,15,14,
		15,15,10,12,12,13,14,15,14,15,15,14,15,15,15,12,
		15,13,15,14,15,15,15,15,15,15,15,15,13,13,15,15,
		15,15,15,15,15,15,15,15,15,
};

static const static_codebook _44u0__p7_1 = {
		2, 169,
		(long *)_vq_lengthlist__44u0__p7_1,
		1, -523010048, 1618608128, 4, 0,
		(long *)_vq_quantlist__44u0__p7_1,
		0
};

static const long _vq_quantlist__44u0__p7_2[] = {
		6,
		5,
		7,
		4,
		8,
		3,
		9,
		2,
		10,
		1,
		11,
		0,
		12,
};

static const long _vq_lengthlist__44u0__p7_2[] = {
		 2, 5, 4, 6, 6, 7, 7, 8, 8, 8, 8, 9, 8, 5, 5, 6,
		 7, 7, 8, 8, 8, 8, 9, 9, 9, 9, 5, 6, 5, 7, 7, 8,
		 8, 8, 8, 9, 9, 9, 9, 6, 7, 7, 8, 8, 8, 8, 9, 8,
		 9, 9, 9, 9, 6, 7, 7, 8, 7, 8, 8, 9, 9, 9, 9, 9,
		 9, 7, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 7, 8,
		 8, 9, 8, 9, 8, 9, 9, 9, 9, 9, 9, 8, 9, 8, 9, 9,
		 9, 9, 9, 9, 9, 9,10,10, 8, 8, 9, 9, 9, 9, 9, 9,
		 9, 9,10, 9,10, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
		 9, 9, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
		 9, 9, 9, 9, 9, 9, 9, 9,10,10,10, 9, 9, 9, 9, 9,
		 9, 9, 9,10, 9, 9,10,10, 9,
};

static const static_codebook _44u0__p7_2 = {
		2, 169,
		(long *)_vq_lengthlist__44u0__p7_2,
		1, -531103744, 1611661312, 4, 0,
		(long *)_vq_quantlist__44u0__p7_2,
		0
};

static const long _huff_lengthlist__44u0__short[] = {
		12,13,14,13,17,12,15,17, 5, 5, 6,10,10,11,15,16,
		 4, 3, 3, 7, 5, 7,10,16, 7, 7, 7,10, 9,11,12,16,
		 6, 5, 5, 9, 5, 6,10,16, 8, 7, 7, 9, 6, 7, 9,16,
		11, 7, 3, 6, 4, 5, 8,16,12, 9, 4, 8, 5, 7, 9,16,
};

static const static_codebook _huff_book__44u0__short = {
		2, 64,
		(long *)_huff_lengthlist__44u0__short,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist__44u1__long[] = {
		 5, 8,13,10,17,11,11,15, 7, 2, 4, 5, 8, 7, 9,16,
		13, 4, 3, 5, 6, 8,11,20,10, 4, 5, 5, 7, 6, 8,18,
		15, 7, 6, 7, 8,10,14,20,10, 6, 7, 6, 9, 7, 8,17,
		 9, 8,10, 8,10, 5, 4,11,12,17,19,14,16,10, 7,12,
};

static const static_codebook _huff_book__44u1__long = {
		2, 64,
		(long *)_huff_lengthlist__44u1__long,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _vq_quantlist__44u1__p1_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__44u1__p1_0[] = {
		 1, 4, 4, 5, 8, 7, 5, 7, 8, 5, 8, 8, 8,11,11, 8,
		10,10, 5, 8, 8, 8,11,10, 8,11,11, 4, 8, 8, 8,11,
		11, 8,11,11, 8,12,11,11,13,13,11,13,14, 7,11,11,
		10,13,12,11,13,14, 4, 8, 8, 8,11,11, 8,11,12, 8,
		11,11,11,13,13,10,12,13, 8,11,11,11,14,13,11,14,
		13,
};

static const static_codebook _44u1__p1_0 = {
		4, 81,
		(long *)_vq_lengthlist__44u1__p1_0,
		1, -535822336, 1611661312, 2, 0,
		(long *)_vq_quantlist__44u1__p1_0,
		0
};

static const long _vq_quantlist__44u1__p2_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__44u1__p2_0[] = {
		 2, 4, 4, 5, 6, 6, 5, 6, 6, 5, 7, 7, 7, 8, 8, 6,
		 8, 8, 5, 7, 7, 6, 8, 8, 7, 8, 8, 4, 7, 7, 7, 8,
		 8, 7, 8, 8, 7, 8, 8, 8, 9,10, 8,10,10, 6, 8, 8,
		 8,10, 8, 8,10,10, 5, 7, 7, 7, 8, 8, 7, 8, 8, 6,
		 8, 8, 8,10,10, 8, 8,10, 6, 8, 8, 8,10,10, 8,10,
		 9,
};

static const static_codebook _44u1__p2_0 = {
		4, 81,
		(long *)_vq_lengthlist__44u1__p2_0,
		1, -535822336, 1611661312, 2, 0,
		(long *)_vq_quantlist__44u1__p2_0,
		0
};

static const long _vq_quantlist__44u1__p3_0[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__44u1__p3_0[] = {
		 1, 5, 5, 8, 8, 5, 8, 7, 9, 9, 5, 7, 8, 9, 9, 9,
		10, 9,12,12, 9, 9,10,12,12, 6, 8, 8,11,10, 8,10,
		10,11,11, 8, 9,10,11,11,10,11,11,14,13,10,11,11,
		13,13, 5, 8, 8,10,10, 8,10,10,11,11, 8,10,10,11,
		11,10,11,11,13,13,10,11,11,13,13, 9,11,11,15,14,
		10,12,12,15,14,10,12,11,15,14,13,14,14,16,16,12,
		14,13,17,15, 9,11,11,14,15,10,11,12,14,16,10,11,
		12,14,16,12,13,14,16,16,13,13,15,15,18, 5, 8, 8,
		11,11, 8,10,10,12,12, 8,10,10,12,13,11,12,12,14,
		14,11,12,12,15,15, 8,10,10,13,13,10,12,12,13,13,
		10,12,12,14,14,12,13,13,15,15,12,13,13,16,16, 7,
		10,10,12,12,10,12,11,13,13,10,12,12,13,14,12,13,
		12,15,14,12,13,13,16,16,10,12,12,17,16,12,13,13,
		16,15,11,13,13,17,17,15,15,15,16,17,14,15,15,19,
		19,10,12,12,15,16,11,13,12,15,18,11,13,13,16,16,
		14,15,15,17,17,14,15,15,17,19, 5, 8, 8,11,11, 8,
		10,10,12,12, 8,10,10,12,12,11,12,12,16,15,11,12,
		12,14,15, 7,10,10,13,13,10,12,12,14,13,10,11,12,
		13,13,12,13,13,16,16,12,12,13,15,15, 8,10,10,13,
		13,10,12,12,14,14,10,12,12,13,13,12,13,13,16,16,
		12,13,13,15,15,10,12,12,16,15,11,13,13,17,16,11,
		12,13,16,15,13,15,15,19,17,14,15,14,17,16,10,12,
		12,16,16,11,13,13,16,17,12,13,13,15,17,14,15,15,
		17,19,14,15,15,17,17, 8,11,11,16,16,10,13,12,17,
		17,10,12,13,16,16,15,17,16,20,19,14,15,17,18,19,
		 9,12,12,16,17,11,13,14,17,18,11,13,13,19,18,16,
		17,18,19,19,15,16,16,19,19, 9,12,12,16,17,11,14,
		13,18,17,11,13,13,17,17,16,17,16,20,19,14,16,16,
		18,18,12,15,15,19,17,14,15,16, 0,20,13,15,16,20,
		17,18,16,20, 0, 0,15,16,19,20, 0,12,15,14,18,19,
		13,16,15,20,19,13,16,15,20,18,17,18,17, 0,20,16,
		17,16, 0, 0, 8,11,11,16,15,10,12,12,17,17,10,13,
		13,17,16,14,16,15,18,20,15,16,16,19,19, 9,12,12,
		16,16,11,13,13,17,16,11,13,14,17,18,15,15,16,20,
		20,16,16,17,19,19, 9,13,12,16,17,11,14,13,17,17,
		11,14,14,18,17,14,16,15,18,19,16,17,18,18,19,12,
		14,15,19,18,13,15,16,18, 0,13,14,15, 0, 0,16,16,
		17,20, 0,17,17,20,20, 0,12,15,15,19,20,13,15,15,
		 0, 0,14,16,15, 0, 0,15,18,16, 0, 0,17,18,16, 0,
		19,
};

static const static_codebook _44u1__p3_0 = {
		4, 625,
		(long *)_vq_lengthlist__44u1__p3_0,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__44u1__p3_0,
		0
};

static const long _vq_quantlist__44u1__p4_0[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__44u1__p4_0[] = {
		 4, 5, 5, 9, 9, 5, 6, 6, 9, 9, 5, 6, 6, 9, 9, 9,
		10, 9,12,12, 9, 9,10,12,12, 5, 7, 7,10,10, 7, 7,
		 8,10,10, 6, 7, 8,10,10,10,10,10,11,13,10, 9,10,
		12,13, 5, 7, 7,10,10, 6, 8, 7,10,10, 7, 8, 7,10,
		10, 9,10,10,12,12,10,10,10,13,11, 9,10,10,13,13,
		10,11,10,13,13,10,10,10,13,13,12,12,13,14,14,12,
		12,13,14,14, 9,10,10,13,13,10,10,10,13,13,10,10,
		10,13,13,12,13,12,15,14,12,13,12,15,15, 5, 7, 6,
		10,10, 7, 8, 8,10,10, 7, 8, 8,10,10,10,11,10,13,
		13,10,10,10,12,12, 7, 8, 8,11,10, 8, 8, 9,10,11,
		 8, 9, 9,11,11,11,10,11,11,14,11,11,11,13,13, 6,
		 8, 8,10,10, 7, 9, 8,11,10, 8, 9, 9,11,11,10,11,
		10,14,11,10,11,11,13,13,10,11,11,14,13,10,10,11,
		14,13,10,11,11,14,14,12,11,13,12,16,13,14,14,15,
		15,10,10,11,13,14,10,11,10,14,13,10,11,11,14,14,
		12,13,12,15,13,13,13,14,15,16, 5, 7, 7,10,10, 7,
		 8, 8,10,10, 7, 8, 8,10,10,10,10,10,13,13,10,10,
		11,12,13, 6, 8, 8,11,10, 8, 9, 9,11,11, 7, 8, 9,
		10,11,10,11,11,13,13,10,10,11,11,13, 6, 8, 8,10,
		11, 8, 9, 9,11,11, 8, 9, 8,12,10,10,11,11,13,13,
		10,11,10,14,11,10,10,10,14,13,10,11,11,14,13,10,
		10,11,13,13,12,14,14,16,16,12,12,13,13,15,10,11,
		11,13,14,10,11,11,14,15,10,11,10,13,13,13,14,13,
		16,16,12,13,11,15,12, 9,10,10,13,13,10,11,11,14,
		13,10,10,11,13,14,13,14,13,16,16,13,13,13,15,16,
		 9,10,10,13,13,10,10,11,13,14,10,11,11,15,13,13,
		13,14,14,18,13,13,14,16,15, 9,10,10,13,14,10,11,
		10,14,13,10,11,11,13,14,13,14,13,16,15,13,13,14,
		15,16,12,13,12,16,14,11,11,13,15,15,13,14,13,16,
		15,15,12,16,12,17,14,15,15,17,17,12,13,13,14,16,
		11,13,11,16,15,12,13,14,15,16,14,15,13, 0,14,14,
		16,16, 0, 0, 9,10,10,13,13,10,11,10,14,14,10,11,
		11,13,13,12,13,13,14,16,13,14,14,16,16, 9,10,10,
		14,14,11,11,11,14,13,10,10,11,14,14,13,13,13,16,
		16,13,13,14,14,17, 9,10,10,13,14,10,11,11,13,15,
		10,11,10,14,14,13,13,13,14,17,13,14,13,17,14,12,
		13,13,16,14,13,14,13,16,15,12,12,13,15,16,15,15,
		16,18,16,15,13,15,14, 0,12,12,13,14,16,13,13,14,
		15,16,11,12,11,16,14,15,16,16,17,17,14,15,12,17,
		12,
};

static const static_codebook _44u1__p4_0 = {
		4, 625,
		(long *)_vq_lengthlist__44u1__p4_0,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__44u1__p4_0,
		0
};

static const long _vq_quantlist__44u1__p5_0[] = {
		4,
		3,
		5,
		2,
		6,
		1,
		7,
		0,
		8,
};

static const long _vq_lengthlist__44u1__p5_0[] = {
		 1, 4, 4, 7, 7, 7, 7, 9, 9, 4, 6, 6, 8, 8, 8, 8,
		 9, 9, 4, 6, 6, 8, 8, 8, 8, 9, 9, 7, 8, 8, 9, 9,
		 9, 9,11,10, 7, 8, 8, 9, 9, 9, 9,10,10, 7, 8, 8,
		 9, 9,10,10,11,11, 7, 8, 8, 9, 9,10,10,11,11, 9,
		 9, 9,10,10,11,11,12,12, 9, 9, 9,10,11,11,11,12,
		12,
};

static const static_codebook _44u1__p5_0 = {
		2, 81,
		(long *)_vq_lengthlist__44u1__p5_0,
		1, -531628032, 1611661312, 4, 0,
		(long *)_vq_quantlist__44u1__p5_0,
		0
};

static const long _vq_quantlist__44u1__p6_0[] = {
		6,
		5,
		7,
		4,
		8,
		3,
		9,
		2,
		10,
		1,
		11,
		0,
		12,
};

static const long _vq_lengthlist__44u1__p6_0[] = {
		 1, 4, 4, 6, 6, 8, 8,10, 9,11,10,14,13, 4, 6, 5,
		 8, 8, 9, 9,11,10,11,11,14,14, 4, 5, 6, 8, 8, 9,
		 9,10,10,11,11,14,14, 6, 8, 8, 9, 9,10,10,11,11,
		12,12,16,15, 7, 8, 8, 9, 9,10,10,11,11,12,12,15,
		15, 9,10,10,10,10,11,11,12,12,12,12,15,15, 9,10,
		 9,10,11,11,11,12,12,12,13,15,15,10,10,11,11,11,
		12,12,13,12,13,13,16,15,10,11,11,11,11,12,12,13,
		12,13,13,16,17,11,11,12,12,12,13,13,13,14,14,15,
		17,17,11,11,12,12,12,13,13,13,14,14,14,16,18,14,
		15,15,15,15,16,16,16,16,17,18, 0, 0,14,15,15,15,
		15,17,16,17,18,17,17,18, 0,
};

static const static_codebook _44u1__p6_0 = {
		2, 169,
		(long *)_vq_lengthlist__44u1__p6_0,
		1, -526516224, 1616117760, 4, 0,
		(long *)_vq_quantlist__44u1__p6_0,
		0
};

static const long _vq_quantlist__44u1__p6_1[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__44u1__p6_1[] = {
		 2, 4, 4, 5, 5, 4, 5, 5, 5, 5, 4, 5, 5, 5, 5, 5,
		 6, 6, 6, 6, 5, 6, 6, 6, 6,
};

static const static_codebook _44u1__p6_1 = {
		2, 25,
		(long *)_vq_lengthlist__44u1__p6_1,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__44u1__p6_1,
		0
};

static const long _vq_quantlist__44u1__p7_0[] = {
		3,
		2,
		4,
		1,
		5,
		0,
		6,
};

static const long _vq_lengthlist__44u1__p7_0[] = {
		 1, 3, 2, 9, 9, 7, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
		 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
		 9, 9, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
		 8,
};

static const static_codebook _44u1__p7_0 = {
		2, 49,
		(long *)_vq_lengthlist__44u1__p7_0,
		1, -518017024, 1626677248, 3, 0,
		(long *)_vq_quantlist__44u1__p7_0,
		0
};

static const long _vq_quantlist__44u1__p7_1[] = {
		6,
		5,
		7,
		4,
		8,
		3,
		9,
		2,
		10,
		1,
		11,
		0,
		12,
};

static const long _vq_lengthlist__44u1__p7_1[] = {
		 1, 4, 4, 6, 6, 6, 6, 7, 7, 8, 8, 9, 9, 5, 7, 7,
		 8, 7, 7, 7, 9, 8,10, 9,10,11, 5, 7, 7, 8, 8, 7,
		 7, 8, 9,10,10,11,11, 6, 8, 8, 9, 9, 9, 9,11,10,
		12,12,15,12, 6, 8, 8, 9, 9, 9, 9,11,11,12,11,14,
		12, 7, 8, 8,10,10,12,12,13,13,13,15,13,13, 7, 8,
		 8,10,10,11,11,13,12,14,15,15,15, 9,10,10,11,12,
		13,13,14,15,14,15,14,15, 8,10,10,12,12,14,14,15,
		14,14,15,15,14,10,12,12,14,14,15,14,15,15,15,14,
		15,15,10,12,12,13,14,15,14,15,15,14,15,15,15,12,
		15,13,15,14,15,15,15,15,15,15,15,15,13,13,15,15,
		15,15,15,15,15,15,15,15,15,
};

static const static_codebook _44u1__p7_1 = {
		2, 169,
		(long *)_vq_lengthlist__44u1__p7_1,
		1, -523010048, 1618608128, 4, 0,
		(long *)_vq_quantlist__44u1__p7_1,
		0
};

static const long _vq_quantlist__44u1__p7_2[] = {
		6,
		5,
		7,
		4,
		8,
		3,
		9,
		2,
		10,
		1,
		11,
		0,
		12,
};

static const long _vq_lengthlist__44u1__p7_2[] = {
		 2, 5, 4, 6, 6, 7, 7, 8, 8, 8, 8, 9, 8, 5, 5, 6,
		 7, 7, 8, 8, 8, 8, 9, 9, 9, 9, 5, 6, 5, 7, 7, 8,
		 8, 8, 8, 9, 9, 9, 9, 6, 7, 7, 8, 8, 8, 8, 9, 8,
		 9, 9, 9, 9, 6, 7, 7, 8, 7, 8, 8, 9, 9, 9, 9, 9,
		 9, 7, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 7, 8,
		 8, 9, 8, 9, 8, 9, 9, 9, 9, 9, 9, 8, 9, 8, 9, 9,
		 9, 9, 9, 9, 9, 9,10,10, 8, 8, 9, 9, 9, 9, 9, 9,
		 9, 9,10, 9,10, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
		 9, 9, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
		 9, 9, 9, 9, 9, 9, 9, 9,10,10,10, 9, 9, 9, 9, 9,
		 9, 9, 9,10, 9, 9,10,10, 9,
};

static const static_codebook _44u1__p7_2 = {
		2, 169,
		(long *)_vq_lengthlist__44u1__p7_2,
		1, -531103744, 1611661312, 4, 0,
		(long *)_vq_quantlist__44u1__p7_2,
		0
};

static const long _huff_lengthlist__44u1__short[] = {
		12,13,14,13,17,12,15,17, 5, 5, 6,10,10,11,15,16,
		 4, 3, 3, 7, 5, 7,10,16, 7, 7, 7,10, 9,11,12,16,
		 6, 5, 5, 9, 5, 6,10,16, 8, 7, 7, 9, 6, 7, 9,16,
		11, 7, 3, 6, 4, 5, 8,16,12, 9, 4, 8, 5, 7, 9,16,
};

static const static_codebook _huff_book__44u1__short = {
		2, 64,
		(long *)_huff_lengthlist__44u1__short,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist__44u2__long[] = {
		 5, 9,14,12,15,13,10,13, 7, 4, 5, 6, 8, 7, 8,12,
		13, 4, 3, 5, 5, 6, 9,15,12, 6, 5, 6, 6, 6, 7,14,
		14, 7, 4, 6, 4, 6, 8,15,12, 6, 6, 5, 5, 5, 6,14,
		 9, 7, 8, 6, 7, 5, 4,10,10,13,14,14,15,10, 6, 8,
};

static const static_codebook _huff_book__44u2__long = {
		2, 64,
		(long *)_huff_lengthlist__44u2__long,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _vq_quantlist__44u2__p1_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__44u2__p1_0[] = {
		 1, 4, 4, 5, 8, 7, 5, 7, 8, 5, 8, 8, 8,11,11, 8,
		10,11, 5, 8, 8, 8,11,10, 8,11,11, 4, 8, 8, 8,11,
		11, 8,11,11, 8,11,11,11,13,14,11,13,13, 7,11,11,
		10,13,12,11,14,14, 4, 8, 8, 8,11,11, 8,11,11, 8,
		11,11,11,14,13,10,12,13, 8,11,11,11,13,13,11,13,
		13,
};

static const static_codebook _44u2__p1_0 = {
		4, 81,
		(long *)_vq_lengthlist__44u2__p1_0,
		1, -535822336, 1611661312, 2, 0,
		(long *)_vq_quantlist__44u2__p1_0,
		0
};

static const long _vq_quantlist__44u2__p2_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__44u2__p2_0[] = {
		 2, 5, 5, 5, 6, 6, 5, 6, 6, 5, 6, 6, 7, 8, 8, 6,
		 8, 8, 5, 6, 6, 6, 8, 7, 7, 8, 8, 5, 6, 6, 7, 8,
		 8, 6, 8, 8, 6, 8, 8, 8, 9,10, 8,10,10, 6, 8, 8,
		 7,10, 8, 8,10,10, 5, 6, 6, 6, 8, 8, 7, 8, 8, 6,
		 8, 8, 8,10,10, 8, 8,10, 6, 8, 8, 8,10,10, 8,10,
		 9,
};

static const static_codebook _44u2__p2_0 = {
		4, 81,
		(long *)_vq_lengthlist__44u2__p2_0,
		1, -535822336, 1611661312, 2, 0,
		(long *)_vq_quantlist__44u2__p2_0,
		0
};

static const long _vq_quantlist__44u2__p3_0[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__44u2__p3_0[] = {
		 2, 4, 4, 7, 8, 5, 7, 7, 9, 9, 5, 7, 7, 9, 9, 8,
		 9, 9,12,11, 8, 9, 9,11,12, 5, 7, 7,10,10, 7, 9,
		 9,11,11, 7, 9, 9,10,11,10,11,11,13,13, 9,10,11,
		12,13, 5, 7, 7,10,10, 7, 9, 9,11,10, 7, 9, 9,11,
		11, 9,11,10,13,13,10,11,11,13,13, 8,10,10,14,13,
		10,11,11,15,14, 9,11,11,15,14,13,14,13,16,14,12,
		13,13,15,16, 8,10,10,13,14, 9,11,11,14,15,10,11,
		11,14,15,12,13,13,15,15,12,13,14,15,16, 5, 7, 7,
		10,10, 7, 9, 9,11,11, 7, 9, 9,11,12,10,11,11,14,
		13,10,11,11,14,14, 7, 9, 9,12,12, 9,11,11,13,13,
		 9,11,11,13,13,12,13,12,14,14,11,12,13,15,15, 7,
		 9, 9,12,12, 8,11,10,13,12, 9,11,11,13,13,11,13,
		12,15,13,11,13,13,15,16, 9,12,11,15,15,11,12,12,
		16,15,11,12,13,16,16,13,14,15,16,15,13,15,15,17,
		17, 9,11,11,14,15,10,12,12,15,15,11,13,12,15,16,
		13,15,14,16,16,13,15,15,17,19, 5, 7, 7,10,10, 7,
		 9, 9,12,11, 7, 9, 9,11,11,10,11,11,14,14,10,11,
		11,13,14, 7, 9, 9,12,12, 9,11,11,13,13, 9,10,11,
		12,13,11,13,12,16,15,11,12,12,14,15, 7, 9, 9,12,
		12, 9,11,11,13,13, 9,11,11,13,12,11,13,12,15,16,
		12,13,13,15,14, 9,11,11,15,14,11,13,12,16,15,10,
		11,12,15,15,13,14,14,18,17,13,14,14,15,17,10,11,
		11,14,15,11,13,12,15,17,11,13,12,15,16,13,15,14,
		18,17,14,15,15,16,18, 7,10,10,14,14,10,12,12,15,
		15,10,12,12,15,15,14,15,15,18,17,13,15,15,16,16,
		 9,11,11,16,15,11,13,13,16,18,11,13,13,16,16,15,
		16,16, 0, 0,14,15,16,18,17, 9,11,11,15,15,10,13,
		12,17,16,11,12,13,16,17,14,15,16,19,19,14,15,15,
		 0,20,12,14,14, 0, 0,13,14,16,19,18,13,15,16,20,
		17,16,18, 0, 0, 0,15,16,17,18,19,11,14,14, 0,19,
		12,15,14,17,17,13,15,15, 0, 0,16,17,15,20,19,15,
		17,16,19, 0, 8,10,10,14,15,10,12,11,15,15,10,11,
		12,16,15,13,14,14,19,17,14,15,15, 0, 0, 9,11,11,
		16,15,11,13,13,17,16,10,12,13,16,17,14,15,15,18,
		18,14,15,16,20,19, 9,12,12, 0,15,11,13,13,16,17,
		11,13,13,19,17,14,16,16,18,17,15,16,16,17,19,11,
		14,14,18,18,13,14,15, 0, 0,12,14,15,19,18,15,16,
		19, 0,19,15,16,19,19,17,12,14,14,16,19,13,15,15,
		 0,17,13,15,14,18,18,15,16,15, 0,18,16,17,17, 0,
		 0,
};

static const static_codebook _44u2__p3_0 = {
		4, 625,
		(long *)_vq_lengthlist__44u2__p3_0,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__44u2__p3_0,
		0
};

static const long _vq_quantlist__44u2__p4_0[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__44u2__p4_0[] = {
		 4, 5, 5, 8, 8, 5, 7, 6, 9, 9, 5, 6, 7, 9, 9, 9,
		 9, 9,11,11, 9, 9, 9,11,11, 5, 7, 7, 9, 9, 7, 8,
		 8,10,10, 7, 7, 8,10,10,10,10,10,11,12, 9,10,10,
		11,12, 5, 7, 7, 9, 9, 6, 8, 7,10,10, 7, 8, 8,10,
		10, 9,10,10,12,11, 9,10,10,12,11, 9,10,10,12,12,
		10,10,10,13,12, 9,10,10,12,13,12,12,12,14,14,11,
		12,12,13,14, 9,10,10,12,12, 9,10,10,12,13,10,10,
		10,12,13,11,12,12,14,13,12,12,12,14,13, 5, 7, 7,
		10, 9, 7, 8, 8,10,10, 7, 8, 8,10,10,10,10,10,12,
		12,10,10,10,12,12, 7, 8, 8,11,10, 8, 8, 9,11,11,
		 8, 9, 9,11,11,10,11,11,12,13,10,11,11,13,13, 6,
		 8, 8,10,10, 7, 9, 8,11,10, 8, 9, 9,11,11,10,11,
		10,13,11,10,11,11,13,13, 9,10,10,13,13,10,11,11,
		13,13,10,11,11,14,13,12,11,13,12,15,12,13,13,15,
		15, 9,10,10,12,13,10,11,10,13,13,10,11,11,13,13,
		12,13,11,15,13,12,13,13,15,15, 5, 7, 7, 9,10, 7,
		 8, 8,10,10, 7, 8, 8,10,10,10,10,10,12,12,10,10,
		11,12,12, 6, 8, 8,10,10, 8, 9, 9,11,11, 7, 8, 9,
		10,11,10,11,11,13,13,10,10,11,11,13, 7, 8, 8,10,
		11, 8, 9, 9,11,11, 8, 9, 8,11,11,10,11,11,13,13,
		10,11,11,13,12, 9,10,10,13,12,10,11,11,14,13,10,
		10,11,13,13,12,13,13,15,15,12,11,13,12,14, 9,10,
		10,12,13,10,11,11,13,14,10,11,11,13,13,12,13,13,
		15,15,12,13,12,15,12, 8, 9, 9,12,12, 9,11,10,13,
		13, 9,10,10,13,13,12,13,13,15,15,12,12,12,14,14,
		 9,10,10,13,13,10,11,11,13,14,10,11,11,14,12,13,
		13,14,14,16,12,13,13,15,14, 9,10,10,13,13,10,11,
		10,14,13,10,11,11,13,14,12,14,13,16,14,13,13,13,
		14,15,11,13,12,15,14,11,12,13,14,15,12,13,13,16,
		15,14,12,15,12,16,14,15,15,17,16,11,12,12,14,15,
		11,13,11,15,14,12,13,13,15,16,13,15,12,17,13,14,
		15,15,16,16, 8, 9, 9,12,12, 9,10,10,13,13, 9,10,
		10,13,13,12,13,12,14,14,12,13,13,15,15, 9,10,10,
		13,13,10,11,11,14,13,10,10,11,13,14,12,13,13,15,
		14,12,12,14,14,16, 9,10,10,13,13,10,11,11,13,14,
		10,11,11,14,13,13,13,13,15,15,13,14,13,16,14,11,
		12,12,14,14,12,13,13,16,15,11,12,13,14,15,14,15,
		15,16,16,14,13,15,13,17,11,12,12,14,15,12,13,13,
		15,16,11,13,12,15,15,14,15,14,16,16,14,15,12,17,
		13,
};

static const static_codebook _44u2__p4_0 = {
		4, 625,
		(long *)_vq_lengthlist__44u2__p4_0,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__44u2__p4_0,
		0
};

static const long _vq_quantlist__44u2__p5_0[] = {
		4,
		3,
		5,
		2,
		6,
		1,
		7,
		0,
		8,
};

static const long _vq_lengthlist__44u2__p5_0[] = {
		 1, 4, 4, 7, 7, 8, 8, 9, 9, 4, 6, 5, 8, 8, 8, 8,
		10,10, 4, 5, 6, 8, 8, 8, 8,10,10, 7, 8, 8, 9, 9,
		 9, 9,11,11, 7, 8, 8, 9, 9, 9, 9,11,11, 8, 8, 8,
		 9, 9,10,11,12,12, 8, 8, 8, 9, 9,10,10,12,12,10,
		10,10,11,11,12,12,13,13,10,10,10,11,11,12,12,13,
		13,
};

static const static_codebook _44u2__p5_0 = {
		2, 81,
		(long *)_vq_lengthlist__44u2__p5_0,
		1, -531628032, 1611661312, 4, 0,
		(long *)_vq_quantlist__44u2__p5_0,
		0
};

static const long _vq_quantlist__44u2__p6_0[] = {
		6,
		5,
		7,
		4,
		8,
		3,
		9,
		2,
		10,
		1,
		11,
		0,
		12,
};

static const long _vq_lengthlist__44u2__p6_0[] = {
		 1, 4, 4, 6, 6, 8, 8,10,10,11,11,14,13, 4, 6, 5,
		 8, 8, 9, 9,11,10,12,11,15,14, 4, 5, 6, 8, 8, 9,
		 9,11,11,11,11,14,14, 6, 8, 8,10, 9,11,11,11,11,
		12,12,15,15, 6, 8, 8, 9, 9,11,11,11,12,12,12,15,
		15, 8,10,10,11,11,11,11,12,12,13,13,15,16, 8,10,
		10,11,11,11,11,12,12,13,13,16,16,10,11,11,12,12,
		12,12,13,13,13,13,17,16,10,11,11,12,12,12,12,13,
		13,13,14,16,17,11,12,12,13,13,13,13,14,14,15,14,
		18,17,11,12,12,13,13,13,13,14,14,14,15,19,18,14,
		15,15,15,15,16,16,18,19,18,18, 0, 0,14,15,15,16,
		15,17,17,16,18,17,18, 0, 0,
};

static const static_codebook _44u2__p6_0 = {
		2, 169,
		(long *)_vq_lengthlist__44u2__p6_0,
		1, -526516224, 1616117760, 4, 0,
		(long *)_vq_quantlist__44u2__p6_0,
		0
};

static const long _vq_quantlist__44u2__p6_1[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__44u2__p6_1[] = {
		 2, 4, 4, 5, 5, 4, 5, 5, 6, 5, 4, 5, 5, 5, 6, 5,
		 6, 5, 6, 6, 5, 5, 6, 6, 6,
};

static const static_codebook _44u2__p6_1 = {
		2, 25,
		(long *)_vq_lengthlist__44u2__p6_1,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__44u2__p6_1,
		0
};

static const long _vq_quantlist__44u2__p7_0[] = {
		4,
		3,
		5,
		2,
		6,
		1,
		7,
		0,
		8,
};

static const long _vq_lengthlist__44u2__p7_0[] = {
		 1, 3, 2,12,12,12,12,12,12, 4,12,12,12,12,12,12,
		12,12, 5,12,12,12,12,12,12,12,12,12,12,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,
};

static const static_codebook _44u2__p7_0 = {
		2, 81,
		(long *)_vq_lengthlist__44u2__p7_0,
		1, -516612096, 1626677248, 4, 0,
		(long *)_vq_quantlist__44u2__p7_0,
		0
};

static const long _vq_quantlist__44u2__p7_1[] = {
		6,
		5,
		7,
		4,
		8,
		3,
		9,
		2,
		10,
		1,
		11,
		0,
		12,
};

static const long _vq_lengthlist__44u2__p7_1[] = {
		 1, 4, 4, 7, 6, 7, 6, 8, 7, 9, 7, 9, 8, 4, 7, 6,
		 8, 8, 9, 8,10, 9,10,10,11,11, 4, 7, 7, 8, 8, 8,
		 8, 9,10,11,11,11,11, 6, 8, 8,10,10,10,10,11,11,
		12,12,12,12, 7, 8, 8,10,10,10,10,11,11,12,12,13,
		13, 7, 9, 9,11,10,12,12,13,13,14,13,14,14, 7, 9,
		 9,10,11,11,12,13,13,13,13,16,14, 9,10,10,12,12,
		13,13,14,14,15,16,15,16, 9,10,10,12,12,12,13,14,
		14,14,15,16,15,10,12,12,13,13,15,13,16,16,15,17,
		17,17,10,11,11,12,14,14,14,15,15,17,17,15,17,11,
		12,12,14,14,14,15,15,15,17,16,17,17,10,12,12,13,
		14,14,14,17,15,17,17,17,17,
};

static const static_codebook _44u2__p7_1 = {
		2, 169,
		(long *)_vq_lengthlist__44u2__p7_1,
		1, -523010048, 1618608128, 4, 0,
		(long *)_vq_quantlist__44u2__p7_1,
		0
};

static const long _vq_quantlist__44u2__p7_2[] = {
		6,
		5,
		7,
		4,
		8,
		3,
		9,
		2,
		10,
		1,
		11,
		0,
		12,
};

static const long _vq_lengthlist__44u2__p7_2[] = {
		 2, 5, 5, 6, 6, 7, 7, 8, 7, 8, 8, 8, 8, 5, 6, 6,
		 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 5, 6, 6, 7, 7, 8,
		 7, 8, 8, 8, 8, 8, 8, 6, 7, 7, 7, 8, 8, 8, 8, 8,
		 9, 9, 9, 9, 6, 7, 7, 8, 7, 8, 8, 9, 9, 9, 9, 9,
		 9, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 7, 8,
		 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 8, 8, 8, 8, 9,
		 9, 9, 9, 9, 9, 9, 9, 9, 8, 8, 8, 9, 9, 9, 9, 9,
		 9, 9, 9, 9, 9, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9,
		 9, 9, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 8,
		 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 8, 9, 9, 9,
		 9, 9, 9, 9, 9, 9, 9, 9, 9,
};

static const static_codebook _44u2__p7_2 = {
		2, 169,
		(long *)_vq_lengthlist__44u2__p7_2,
		1, -531103744, 1611661312, 4, 0,
		(long *)_vq_quantlist__44u2__p7_2,
		0
};

static const long _huff_lengthlist__44u2__short[] = {
		13,15,17,17,15,15,12,17,11, 9, 7,10,10, 9,12,17,
		10, 6, 3, 6, 5, 7,10,17,15,10, 6, 9, 8, 9,11,17,
		15, 8, 4, 7, 3, 5, 9,16,16,10, 5, 8, 4, 5, 8,16,
		13,11, 5, 8, 3, 3, 5,14,13,12, 7,10, 5, 5, 7,14,
};

static const static_codebook _huff_book__44u2__short = {
		2, 64,
		(long *)_huff_lengthlist__44u2__short,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist__44u3__long[] = {
		 6, 9,13,12,14,11,10,13, 8, 4, 5, 7, 8, 7, 8,12,
		11, 4, 3, 5, 5, 7, 9,14,11, 6, 5, 6, 6, 6, 7,13,
		13, 7, 5, 6, 4, 5, 7,14,11, 7, 6, 6, 5, 5, 6,13,
		 9, 7, 8, 6, 7, 5, 3, 9, 9,12,13,12,14,10, 6, 7,
};

static const static_codebook _huff_book__44u3__long = {
		2, 64,
		(long *)_huff_lengthlist__44u3__long,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _vq_quantlist__44u3__p1_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__44u3__p1_0[] = {
		 1, 4, 4, 5, 8, 7, 5, 7, 8, 5, 8, 8, 8,10,11, 8,
		10,11, 5, 8, 8, 8,11,10, 8,11,11, 4, 8, 8, 8,11,
		11, 8,11,11, 8,11,11,11,13,14,11,14,14, 8,11,11,
		10,14,12,11,14,14, 4, 8, 8, 8,11,11, 8,11,11, 7,
		11,11,11,14,14,10,12,14, 8,11,11,11,14,14,11,14,
		13,
};

static const static_codebook _44u3__p1_0 = {
		4, 81,
		(long *)_vq_lengthlist__44u3__p1_0,
		1, -535822336, 1611661312, 2, 0,
		(long *)_vq_quantlist__44u3__p1_0,
		0
};

static const long _vq_quantlist__44u3__p2_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__44u3__p2_0[] = {
		 2, 5, 4, 5, 6, 6, 5, 6, 6, 5, 6, 6, 7, 8, 8, 6,
		 8, 8, 5, 6, 6, 6, 8, 8, 7, 8, 8, 5, 7, 6, 7, 8,
		 8, 6, 8, 8, 7, 8, 8, 8, 9,10, 8,10,10, 6, 8, 8,
		 8,10, 8, 8,10,10, 5, 6, 6, 6, 8, 8, 7, 8, 8, 6,
		 8, 8, 8,10,10, 8, 8,10, 7, 8, 8, 8,10,10, 8,10,
		 9,
};

static const static_codebook _44u3__p2_0 = {
		4, 81,
		(long *)_vq_lengthlist__44u3__p2_0,
		1, -535822336, 1611661312, 2, 0,
		(long *)_vq_quantlist__44u3__p2_0,
		0
};

static const long _vq_quantlist__44u3__p3_0[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__44u3__p3_0[] = {
		 2, 4, 4, 7, 7, 5, 7, 7, 9, 9, 5, 7, 7, 9, 9, 8,
		 9, 9,12,12, 8, 9, 9,11,12, 5, 7, 7,10,10, 7, 9,
		 9,11,11, 7, 9, 9,10,11,10,11,11,13,13, 9,10,11,
		13,13, 5, 7, 7,10,10, 7, 9, 9,11,10, 7, 9, 9,11,
		11, 9,11,10,13,13,10,11,11,14,13, 8,10,10,14,13,
		10,11,11,15,14, 9,11,11,14,14,13,14,13,16,16,12,
		13,13,15,15, 8,10,10,13,14, 9,11,11,14,14,10,11,
		11,14,15,12,13,13,15,15,13,14,14,15,16, 5, 7, 7,
		10,10, 7, 9, 9,11,11, 7, 9, 9,11,12,10,11,11,14,
		14,10,11,11,14,14, 7, 9, 9,12,12, 9,11,11,13,13,
		 9,11,11,13,13,12,12,13,15,15,11,12,13,15,16, 7,
		 9, 9,11,11, 8,11,10,13,12, 9,11,11,13,13,11,13,
		12,15,13,11,13,13,15,16, 9,12,11,15,14,11,12,13,
		16,15,11,13,13,15,16,14,14,15,17,16,13,15,16, 0,
		17, 9,11,11,15,15,10,13,12,15,15,11,13,13,15,16,
		13,15,13,16,15,14,16,15, 0,19, 5, 7, 7,10,10, 7,
		 9, 9,11,11, 7, 9, 9,11,11,10,12,11,14,14,10,11,
		12,14,14, 7, 9, 9,12,12, 9,11,11,14,13, 9,10,11,
		12,13,11,13,13,16,16,11,12,13,13,16, 7, 9, 9,12,
		12, 9,11,11,13,13, 9,11,11,13,13,11,13,13,15,15,
		12,13,12,15,14, 9,11,11,15,14,11,13,12,16,16,10,
		12,12,15,15,13,15,15,17,19,13,14,15,16,17,10,12,
		12,15,15,11,13,13,16,16,11,13,13,15,16,13,15,15,
		 0, 0,14,15,15,16,16, 8,10,10,14,14,10,12,12,15,
		15,10,12,11,15,16,14,15,15,19,20,13,14,14,18,16,
		 9,11,11,15,15,11,13,13,17,16,11,13,13,16,16,15,
		17,17,20,20,14,15,16,17,20, 9,11,11,15,15,10,13,
		12,16,15,11,13,13,15,17,14,16,15,18, 0,14,16,15,
		18,20,12,14,14, 0, 0,14,14,16, 0, 0,13,16,15, 0,
		 0,17,17,18, 0, 0,16,17,19,19, 0,12,14,14,18, 0,
		12,16,14, 0,17,13,15,15,18, 0,16,18,17, 0,17,16,
		18,17, 0, 0, 7,10,10,14,14,10,12,11,15,15,10,12,
		12,16,15,13,15,15,18, 0,14,15,15,17, 0, 9,11,11,
		15,15,11,13,13,16,16,11,12,13,16,16,14,15,16,17,
		17,14,16,16,16,18, 9,11,12,16,16,11,13,13,17,17,
		11,14,13,20,17,15,16,16,19, 0,15,16,17, 0,19,11,
		13,14,17,16,14,15,15,20,18,13,14,15,17,19,16,18,
		18, 0,20,16,16,19,17, 0,12,15,14,17, 0,14,15,15,
		18,19,13,16,15,19,20,15,18,18, 0,20,17, 0,16, 0,
		 0,
};

static const static_codebook _44u3__p3_0 = {
		4, 625,
		(long *)_vq_lengthlist__44u3__p3_0,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__44u3__p3_0,
		0
};

static const long _vq_quantlist__44u3__p4_0[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__44u3__p4_0[] = {
		 4, 5, 5, 8, 8, 5, 7, 6, 9, 9, 5, 6, 7, 9, 9, 9,
		 9, 9,11,11, 9, 9, 9,11,11, 5, 7, 7, 9, 9, 7, 8,
		 8,10,10, 7, 7, 8,10,10, 9,10,10,11,12, 9,10,10,
		11,12, 5, 7, 7, 9, 9, 7, 8, 7,10,10, 7, 8, 8,10,
		10, 9,10, 9,12,11, 9,10,10,12,11, 9,10, 9,12,12,
		 9,10,10,13,12, 9,10,10,12,13,12,12,12,14,14,11,
		12,12,13,14, 9, 9,10,12,12, 9,10,10,12,12, 9,10,
		10,12,13,11,12,11,14,13,12,12,12,14,13, 5, 7, 7,
		 9, 9, 7, 8, 8,10,10, 7, 8, 8,10,10,10,10,10,12,
		12, 9,10,10,12,12, 7, 8, 8,11,10, 8, 8, 9,11,11,
		 8, 9, 9,11,11,11,11,11,12,13,10,11,11,13,13, 6,
		 8, 8,10,10, 7, 9, 8,11,10, 8, 9, 9,11,11,10,11,
		10,13,11,10,11,11,13,13, 9,11,10,13,12,10,11,11,
		13,13,10,11,11,13,13,12,12,13,12,15,12,13,13,15,
		15, 9,10,10,12,13,10,11,10,13,12,10,11,11,13,14,
		12,13,11,15,13,12,13,13,15,15, 5, 7, 7, 9, 9, 7,
		 8, 8,10,10, 7, 8, 8,10,10, 9,10,10,12,12,10,10,
		11,12,12, 6, 8, 8,10,10, 8, 9, 9,11,11, 7, 8, 9,
		10,11,10,11,11,13,13,10,10,11,11,13, 7, 8, 8,10,
		10, 8, 9, 9,11,11, 8, 9, 9,11,11,10,11,11,13,13,
		11,11,11,13,12, 9,10,10,13,12,10,11,11,14,13,10,
		10,11,12,13,12,13,13,15,15,12,11,13,13,14, 9,10,
		11,12,13,10,11,11,13,13,10,11,11,13,13,12,13,13,
		15,15,12,13,12,15,12, 8, 9, 9,12,12, 9,11,10,13,
		13, 9,10,10,13,13,12,13,13,15,14,12,12,12,14,13,
		 9,10,10,13,12,10,11,11,13,13,10,11,11,14,12,13,
		13,14,14,16,12,13,13,15,15, 9,10,10,13,13,10,11,
		10,14,13,10,11,11,13,14,12,14,13,15,14,13,13,13,
		15,15,11,13,12,15,14,11,12,13,14,15,12,13,13,16,
		14,14,12,15,12,16,14,15,15,17,15,11,12,12,14,14,
		11,13,11,15,14,12,13,13,15,15,13,15,12,17,13,14,
		15,15,16,16, 8, 9, 9,12,12, 9,10,10,12,13, 9,10,
		10,13,13,12,12,12,14,14,12,13,13,15,15, 9,10,10,
		13,12,10,11,11,14,13,10,10,11,13,14,12,13,13,15,
		15,12,12,13,14,16, 9,10,10,13,13,10,11,11,13,14,
		10,11,11,14,13,12,13,13,14,15,13,14,13,16,14,11,
		12,12,14,14,12,13,13,15,14,11,12,13,14,15,14,15,
		15,16,16,13,13,15,13,16,11,12,12,14,15,12,13,13,
		14,15,11,13,12,15,14,14,15,15,16,16,14,15,12,16,
		13,
};

static const static_codebook _44u3__p4_0 = {
		4, 625,
		(long *)_vq_lengthlist__44u3__p4_0,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__44u3__p4_0,
		0
};

static const long _vq_quantlist__44u3__p5_0[] = {
		4,
		3,
		5,
		2,
		6,
		1,
		7,
		0,
		8,
};

static const long _vq_lengthlist__44u3__p5_0[] = {
		 2, 3, 3, 6, 6, 7, 7, 9, 9, 4, 5, 5, 7, 7, 8, 8,
		10,10, 4, 5, 5, 7, 7, 8, 8,10,10, 6, 7, 7, 8, 8,
		 9, 9,11,10, 6, 7, 7, 8, 8, 9, 9,10,10, 7, 8, 8,
		 9, 9,10,10,11,11, 7, 8, 8, 9, 9,10,10,11,11, 9,
		10,10,11,10,11,11,12,12, 9,10,10,10,10,11,11,12,
		12,
};

static const static_codebook _44u3__p5_0 = {
		2, 81,
		(long *)_vq_lengthlist__44u3__p5_0,
		1, -531628032, 1611661312, 4, 0,
		(long *)_vq_quantlist__44u3__p5_0,
		0
};

static const long _vq_quantlist__44u3__p6_0[] = {
		6,
		5,
		7,
		4,
		8,
		3,
		9,
		2,
		10,
		1,
		11,
		0,
		12,
};

static const long _vq_lengthlist__44u3__p6_0[] = {
		 1, 4, 4, 6, 6, 8, 8, 9, 9,10,11,13,14, 4, 6, 5,
		 8, 8, 9, 9,10,10,11,11,14,14, 4, 6, 6, 8, 8, 9,
		 9,10,10,11,11,14,14, 6, 8, 8, 9, 9,10,10,11,11,
		12,12,15,15, 6, 8, 8, 9, 9,10,11,11,11,12,12,15,
		15, 8, 9, 9,11,10,11,11,12,12,13,13,15,16, 8, 9,
		 9,10,11,11,11,12,12,13,13,16,16,10,10,11,11,11,
		12,12,13,13,13,14,17,16, 9,10,11,12,11,12,12,13,
		13,13,13,16,18,11,12,11,12,12,13,13,13,14,15,14,
		17,17,11,11,12,12,12,13,13,13,14,14,15,18,17,14,
		15,15,15,15,16,16,17,17,19,18, 0,20,14,15,14,15,
		15,16,16,16,17,18,16,20,18,
};

static const static_codebook _44u3__p6_0 = {
		2, 169,
		(long *)_vq_lengthlist__44u3__p6_0,
		1, -526516224, 1616117760, 4, 0,
		(long *)_vq_quantlist__44u3__p6_0,
		0
};

static const long _vq_quantlist__44u3__p6_1[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__44u3__p6_1[] = {
		 2, 4, 4, 5, 5, 4, 5, 5, 6, 5, 4, 5, 5, 5, 6, 5,
		 6, 5, 6, 6, 5, 5, 6, 6, 6,
};

static const static_codebook _44u3__p6_1 = {
		2, 25,
		(long *)_vq_lengthlist__44u3__p6_1,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__44u3__p6_1,
		0
};

static const long _vq_quantlist__44u3__p7_0[] = {
		4,
		3,
		5,
		2,
		6,
		1,
		7,
		0,
		8,
};

static const long _vq_lengthlist__44u3__p7_0[] = {
		 1, 3, 3,10,10,10,10,10,10, 4,10,10,10,10,10,10,
		10,10, 4,10,10,10,10,10,10,10,10,10,10, 9, 9, 9,
		 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
		 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
		 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
		 9,
};

static const static_codebook _44u3__p7_0 = {
		2, 81,
		(long *)_vq_lengthlist__44u3__p7_0,
		1, -515907584, 1627381760, 4, 0,
		(long *)_vq_quantlist__44u3__p7_0,
		0
};

static const long _vq_quantlist__44u3__p7_1[] = {
		7,
		6,
		8,
		5,
		9,
		4,
		10,
		3,
		11,
		2,
		12,
		1,
		13,
		0,
		14,
};

static const long _vq_lengthlist__44u3__p7_1[] = {
		 1, 4, 4, 6, 6, 7, 6, 8, 7, 9, 8,10, 9,11,11, 4,
		 7, 7, 8, 7, 9, 9,10,10,11,11,11,11,12,12, 4, 7,
		 7, 7, 7, 9, 9,10,10,11,11,12,12,12,11, 6, 8, 8,
		 9, 9,10,10,11,11,12,12,13,12,13,13, 6, 8, 8, 9,
		 9,10,11,11,11,12,12,13,14,13,13, 8, 9, 9,11,11,
		12,12,12,13,14,13,14,14,14,15, 8, 9, 9,11,11,11,
		12,13,14,13,14,15,17,14,15, 9,10,10,12,12,13,13,
		13,14,15,15,15,16,16,16, 9,11,11,12,12,13,13,14,
		14,14,15,16,16,16,16,10,12,12,13,13,14,14,15,15,
		15,16,17,17,17,17,10,12,11,13,13,15,14,15,14,16,
		17,16,16,16,16,11,13,12,14,14,14,14,15,16,17,16,
		17,17,17,17,11,13,12,14,14,14,15,17,16,17,17,17,
		17,17,17,12,13,13,15,16,15,16,17,17,16,16,17,17,
		17,17,12,13,13,15,15,15,16,17,17,17,16,17,16,17,
		17,
};

static const static_codebook _44u3__p7_1 = {
		2, 225,
		(long *)_vq_lengthlist__44u3__p7_1,
		1, -522338304, 1620115456, 4, 0,
		(long *)_vq_quantlist__44u3__p7_1,
		0
};

static const long _vq_quantlist__44u3__p7_2[] = {
		8,
		7,
		9,
		6,
		10,
		5,
		11,
		4,
		12,
		3,
		13,
		2,
		14,
		1,
		15,
		0,
		16,
};

static const long _vq_lengthlist__44u3__p7_2[] = {
		 2, 5, 5, 7, 6, 7, 7, 8, 8, 8, 8, 9, 9, 9, 9, 9,
		 9, 5, 6, 6, 7, 7, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9,
		10,10, 5, 6, 6, 7, 7, 8, 8, 8, 8, 9, 8, 9, 9, 9,
		 9,10, 9, 7, 7, 7, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9,
		10,10,10,10, 7, 7, 7, 8, 8, 8, 8, 9, 9, 9, 9,10,
		 9,10,10,10,10, 7, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9,
		10,10,10,10,10,10, 7, 8, 8, 9, 8, 9, 9, 9, 9,10,
		 9,10,10,10,10,10,10, 8, 8, 8, 9, 9, 9, 9, 9, 9,
		 9,10,10,10,10,10,10,10, 8, 9, 8, 9, 9, 9, 9,10,
		 9,10,10,10,10,10,10,10,10, 9, 9, 9, 9, 9, 9,10,
		 9,10,10,10,10,10,10,10,10,10, 9, 9, 9, 9, 9,10,
		 9,10,10,10,10,10,10,10,10,10,10, 9, 9, 9,10, 9,
		10,10,10,10,10,10,10,10,10,10,10,10, 9, 9, 9,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10, 9, 9, 9,
		10,10,10,10,10,10,10,10,10,10,10,10,10,11, 9,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,11, 9,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		 9,10,10,10,10,10,10,10,10,10,10,10,11,11,11,10,
		11,
};

static const static_codebook _44u3__p7_2 = {
		2, 289,
		(long *)_vq_lengthlist__44u3__p7_2,
		1, -529530880, 1611661312, 5, 0,
		(long *)_vq_quantlist__44u3__p7_2,
		0
};

static const long _huff_lengthlist__44u3__short[] = {
		14,14,14,15,13,15,12,16,10, 8, 7, 9, 9, 8,12,16,
		10, 5, 4, 6, 5, 6, 9,16,14, 8, 6, 8, 7, 8,10,16,
		14, 7, 4, 6, 3, 5, 8,16,15, 9, 5, 7, 4, 4, 7,16,
		13,10, 6, 7, 4, 3, 4,13,13,12, 7, 9, 5, 5, 6,12,
};

static const static_codebook _huff_book__44u3__short = {
		2, 64,
		(long *)_huff_lengthlist__44u3__short,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist__44u4__long[] = {
		 3, 8,12,12,13,12,11,13, 5, 4, 6, 7, 8, 8, 9,13,
		 9, 5, 4, 5, 5, 7, 9,13, 9, 6, 5, 6, 6, 7, 8,12,
		12, 7, 5, 6, 4, 5, 8,13,11, 7, 6, 6, 5, 5, 6,12,
		10, 8, 8, 7, 7, 5, 3, 8,10,12,13,12,12, 9, 6, 7,
};

static const static_codebook _huff_book__44u4__long = {
		2, 64,
		(long *)_huff_lengthlist__44u4__long,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _vq_quantlist__44u4__p1_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__44u4__p1_0[] = {
		 1, 4, 4, 5, 8, 7, 5, 7, 8, 5, 8, 8, 8,10,11, 8,
		10,11, 5, 8, 8, 8,11,10, 8,11,11, 4, 8, 8, 8,11,
		11, 8,11,11, 8,11,11,11,13,14,11,15,14, 8,11,11,
		10,13,12,11,14,14, 4, 8, 8, 8,11,11, 8,11,11, 7,
		11,11,11,15,14,10,12,14, 8,11,11,11,14,14,11,14,
		13,
};

static const static_codebook _44u4__p1_0 = {
		4, 81,
		(long *)_vq_lengthlist__44u4__p1_0,
		1, -535822336, 1611661312, 2, 0,
		(long *)_vq_quantlist__44u4__p1_0,
		0
};

static const long _vq_quantlist__44u4__p2_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__44u4__p2_0[] = {
		 2, 5, 5, 5, 6, 6, 5, 6, 6, 5, 6, 6, 7, 8, 8, 6,
		 8, 8, 5, 6, 6, 6, 8, 8, 7, 8, 8, 5, 7, 6, 6, 8,
		 8, 6, 8, 8, 6, 8, 8, 8, 9,10, 8,10,10, 6, 8, 8,
		 8,10, 8, 8,10,10, 5, 6, 6, 6, 8, 8, 6, 8, 8, 6,
		 8, 8, 8,10,10, 8, 8,10, 6, 8, 8, 8,10,10, 8,10,
		 9,
};

static const static_codebook _44u4__p2_0 = {
		4, 81,
		(long *)_vq_lengthlist__44u4__p2_0,
		1, -535822336, 1611661312, 2, 0,
		(long *)_vq_quantlist__44u4__p2_0,
		0
};

static const long _vq_quantlist__44u4__p3_0[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__44u4__p3_0[] = {
		 2, 4, 4, 8, 8, 5, 7, 7, 9, 9, 5, 7, 7, 9, 9, 8,
		10, 9,12,12, 8, 9,10,12,12, 5, 7, 7,10,10, 7, 9,
		 9,11,11, 7, 9, 9,11,11,10,12,11,14,14, 9,10,11,
		13,14, 5, 7, 7,10,10, 7, 9, 9,11,11, 7, 9, 9,11,
		11, 9,11,10,14,13,10,11,11,14,14, 8,10,10,14,13,
		10,12,12,15,14, 9,11,11,15,14,13,14,14,17,17,12,
		14,14,16,16, 8,10,10,14,14, 9,11,11,14,15,10,12,
		12,14,15,12,14,13,16,16,13,14,15,15,18, 4, 7, 7,
		10,10, 7, 9, 9,12,11, 7, 9, 9,11,12,10,12,11,15,
		14,10,11,12,14,15, 7, 9, 9,12,12, 9,11,12,13,13,
		 9,11,12,13,13,12,13,13,15,16,11,13,13,15,16, 7,
		 9, 9,12,12, 9,11,10,13,12, 9,11,12,13,14,11,13,
		12,16,14,12,13,13,15,16,10,12,12,16,15,11,13,13,
		17,16,11,13,13,17,16,14,15,15,17,17,14,16,16,18,
		20, 9,11,11,15,16,11,13,12,16,16,11,13,13,16,17,
		14,15,14,18,16,14,16,16,17,20, 5, 7, 7,10,10, 7,
		 9, 9,12,11, 7, 9,10,11,12,10,12,11,15,15,10,12,
		12,14,14, 7, 9, 9,12,12, 9,12,11,14,13, 9,10,11,
		12,13,12,13,14,16,16,11,12,13,14,16, 7, 9, 9,12,
		12, 9,12,11,13,13, 9,12,11,13,13,11,13,13,16,16,
		12,13,13,16,15, 9,11,11,16,14,11,13,13,16,16,11,
		12,13,16,16,14,16,16,17,17,13,14,15,16,17,10,12,
		12,15,15,11,13,13,16,17,11,13,13,16,16,14,16,15,
		19,19,14,15,15,17,18, 8,10,10,14,14,10,12,12,15,
		15,10,12,12,16,16,14,16,15,20,19,13,15,15,17,16,
		 9,12,12,16,16,11,13,13,16,18,11,14,13,16,17,16,
		17,16,20, 0,15,16,18,18,20, 9,11,11,15,15,11,14,
		12,17,16,11,13,13,17,17,15,17,15,20,20,14,16,16,
		17, 0,13,15,14,18,16,14,15,16, 0,18,14,16,16, 0,
		 0,18,16, 0, 0,20,16,18,18, 0, 0,12,14,14,17,18,
		13,15,14,20,18,14,16,15,19,19,16,20,16, 0,18,16,
		19,17,19, 0, 8,10,10,14,14,10,12,12,16,15,10,12,
		12,16,16,13,15,15,18,17,14,16,16,19, 0, 9,11,11,
		16,15,11,14,13,18,17,11,12,13,17,18,14,17,16,18,
		18,15,16,17,18,18, 9,12,12,16,16,11,13,13,16,18,
		11,14,13,17,17,15,16,16,18,20,16,17,17,20,20,12,
		14,14,18,17,14,16,16, 0,19,13,14,15,18, 0,16, 0,
		 0, 0, 0,16,16, 0,19,20,13,15,14, 0, 0,14,16,16,
		18,19,14,16,15, 0,20,16,20,18, 0,20,17,20,17, 0,
		 0,
};

static const static_codebook _44u4__p3_0 = {
		4, 625,
		(long *)_vq_lengthlist__44u4__p3_0,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__44u4__p3_0,
		0
};

static const long _vq_quantlist__44u4__p4_0[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__44u4__p4_0[] = {
		 4, 5, 5, 8, 8, 5, 7, 6, 9, 9, 5, 6, 7, 9, 9, 9,
		 9, 9,11,11, 8, 9, 9,11,11, 5, 7, 7, 9, 9, 7, 8,
		 8,10,10, 7, 7, 8,10,10, 9,10,10,11,12, 9,10,10,
		11,12, 5, 7, 7, 9, 9, 7, 8, 7,10,10, 7, 8, 8,10,
		10, 9,10,10,12,11, 9,10,10,12,11, 9,10, 9,12,12,
		 9,10,10,13,12, 9,10,10,12,12,12,12,12,14,14,11,
		12,12,13,14, 9, 9,10,12,12, 9,10,10,13,13, 9,10,
		10,12,13,11,12,12,14,13,11,12,12,14,14, 5, 7, 7,
		 9, 9, 7, 8, 8,10,10, 7, 8, 8,10,10,10,10,10,12,
		12, 9,10,10,12,12, 7, 8, 8,11,10, 8, 8, 9,11,11,
		 8, 9, 9,11,11,11,11,11,12,13,10,11,11,13,13, 6,
		 8, 8,10,10, 7, 9, 8,11,10, 8, 9, 9,11,11,10,11,
		10,13,11,10,11,11,13,13, 9,11,10,13,12,10,11,11,
		13,14,10,11,11,14,13,12,12,13,12,15,12,13,13,15,
		15, 9,10,10,12,13,10,11,10,13,12,10,11,11,13,14,
		12,13,11,15,13,13,13,13,15,15, 5, 7, 7, 9, 9, 7,
		 8, 8,10,10, 7, 8, 8,10,10, 9,10,10,12,12,10,10,
		11,12,13, 6, 8, 8,10,10, 8, 9, 9,11,11, 7, 8, 9,
		10,11,10,11,11,13,13,10,10,11,11,13, 7, 8, 8,10,
		11, 8, 9, 9,11,11, 8, 9, 8,11,11,10,11,11,13,13,
		11,12,11,13,12, 9,10,10,13,12,10,11,11,14,13,10,
		10,11,12,13,12,13,13,15,15,12,11,13,13,14, 9,10,
		11,12,13,10,11,11,13,14,10,11,11,13,13,12,13,13,
		15,15,12,13,12,15,12, 8, 9, 9,12,12, 9,11,10,13,
		13, 9,10,10,13,13,12,13,13,15,15,12,12,12,14,14,
		 9,10,10,13,13,10,11,11,13,14,10,11,11,14,13,13,
		13,14,14,16,13,13,13,15,15, 9,10,10,13,13,10,11,
		10,14,13,10,11,11,13,14,12,14,13,16,14,12,13,13,
		14,15,11,12,12,15,14,11,12,13,14,15,12,13,13,16,
		15,14,12,15,12,16,14,15,15,16,16,11,12,12,14,14,
		11,13,12,15,14,12,13,13,15,16,13,15,13,17,13,14,
		15,15,16,17, 8, 9, 9,12,12, 9,10,10,12,13, 9,10,
		10,13,13,12,12,12,14,14,12,13,13,15,15, 9,10,10,
		13,12,10,11,11,14,13,10,10,11,13,14,13,13,13,15,
		15,12,13,14,14,16, 9,10,10,13,13,10,11,11,13,14,
		10,11,11,14,14,13,13,13,15,15,13,14,13,16,14,11,
		12,12,15,14,12,13,13,16,15,11,12,13,14,15,14,15,
		15,17,16,13,13,15,13,16,11,12,13,14,15,13,13,13,
		15,16,11,13,12,15,14,14,15,15,16,16,14,15,12,17,
		13,
};

static const static_codebook _44u4__p4_0 = {
		4, 625,
		(long *)_vq_lengthlist__44u4__p4_0,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__44u4__p4_0,
		0
};

static const long _vq_quantlist__44u4__p5_0[] = {
		4,
		3,
		5,
		2,
		6,
		1,
		7,
		0,
		8,
};

static const long _vq_lengthlist__44u4__p5_0[] = {
		 2, 3, 3, 6, 6, 7, 7, 9, 9, 4, 5, 5, 7, 7, 8, 8,
		10, 9, 4, 5, 5, 7, 7, 8, 8,10,10, 6, 7, 7, 8, 8,
		 9, 9,11,10, 6, 7, 7, 8, 8, 9, 9,10,11, 7, 8, 8,
		 9, 9,10,10,11,11, 7, 8, 8, 9, 9,10,10,11,11, 9,
		10,10,11,10,11,11,12,12, 9,10,10,10,11,11,11,12,
		12,
};

static const static_codebook _44u4__p5_0 = {
		2, 81,
		(long *)_vq_lengthlist__44u4__p5_0,
		1, -531628032, 1611661312, 4, 0,
		(long *)_vq_quantlist__44u4__p5_0,
		0
};

static const long _vq_quantlist__44u4__p6_0[] = {
		6,
		5,
		7,
		4,
		8,
		3,
		9,
		2,
		10,
		1,
		11,
		0,
		12,
};

static const long _vq_lengthlist__44u4__p6_0[] = {
		 1, 4, 4, 6, 6, 8, 8, 9, 9,11,10,13,13, 4, 6, 5,
		 8, 8, 9, 9,10,10,11,11,14,14, 4, 6, 6, 8, 8, 9,
		 9,10,10,11,11,14,14, 6, 8, 8, 9, 9,10,10,11,11,
		12,12,15,15, 6, 8, 8, 9, 9,10,11,11,11,12,12,15,
		15, 8, 9, 9,11,10,11,11,12,12,13,13,16,16, 8, 9,
		 9,10,10,11,11,12,12,13,13,16,16,10,10,10,12,11,
		12,12,13,13,14,14,16,16,10,10,10,11,12,12,12,13,
		13,13,14,16,17,11,12,11,12,12,13,13,14,14,15,14,
		18,17,11,11,12,12,12,13,13,14,14,14,15,19,18,14,
		15,14,15,15,17,16,17,17,17,17,21, 0,14,15,15,16,
		16,16,16,17,17,18,17,20,21,
};

static const static_codebook _44u4__p6_0 = {
		2, 169,
		(long *)_vq_lengthlist__44u4__p6_0,
		1, -526516224, 1616117760, 4, 0,
		(long *)_vq_quantlist__44u4__p6_0,
		0
};

static const long _vq_quantlist__44u4__p6_1[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__44u4__p6_1[] = {
		 2, 4, 4, 5, 5, 4, 5, 5, 6, 5, 4, 5, 5, 5, 6, 5,
		 6, 5, 6, 6, 5, 5, 6, 6, 6,
};

static const static_codebook _44u4__p6_1 = {
		2, 25,
		(long *)_vq_lengthlist__44u4__p6_1,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__44u4__p6_1,
		0
};

static const long _vq_quantlist__44u4__p7_0[] = {
		6,
		5,
		7,
		4,
		8,
		3,
		9,
		2,
		10,
		1,
		11,
		0,
		12,
};

static const long _vq_lengthlist__44u4__p7_0[] = {
		 1, 3, 3,12,12,12,12,12,12,12,12,12,12, 3,12,11,
		12,12,12,12,12,12,12,12,12,12, 4,11,10,12,12,12,
		12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
		12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
		12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
		12,12,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,
};

static const static_codebook _44u4__p7_0 = {
		2, 169,
		(long *)_vq_lengthlist__44u4__p7_0,
		1, -514332672, 1627381760, 4, 0,
		(long *)_vq_quantlist__44u4__p7_0,
		0
};

static const long _vq_quantlist__44u4__p7_1[] = {
		7,
		6,
		8,
		5,
		9,
		4,
		10,
		3,
		11,
		2,
		12,
		1,
		13,
		0,
		14,
};

static const long _vq_lengthlist__44u4__p7_1[] = {
		 1, 4, 4, 6, 6, 7, 7, 9, 8,10, 8,10, 9,11,11, 4,
		 7, 6, 8, 7, 9, 9,10,10,11,10,11,10,12,10, 4, 6,
		 7, 8, 8, 9, 9,10,10,11,11,11,11,12,12, 6, 8, 8,
		10, 9,11,10,12,11,12,12,12,12,13,13, 6, 8, 8,10,
		10,10,11,11,11,12,12,13,12,13,13, 8, 9, 9,11,11,
		12,11,12,12,13,13,13,13,13,13, 8, 9, 9,11,11,11,
		12,12,12,13,13,13,13,13,13, 9,10,10,12,11,13,13,
		13,13,14,13,13,14,14,14, 9,10,11,11,12,12,13,13,
		13,13,13,14,15,14,14,10,11,11,12,12,13,13,14,14,
		14,14,14,15,16,16,10,11,11,12,13,13,13,13,15,14,
		14,15,16,15,16,10,12,12,13,13,14,14,14,15,15,15,
		15,15,15,16,11,12,12,13,13,14,14,14,15,15,15,16,
		15,17,16,11,12,12,13,13,13,15,15,14,16,16,16,16,
		16,17,11,12,12,13,13,14,14,15,14,15,15,17,17,16,
		16,
};

static const static_codebook _44u4__p7_1 = {
		2, 225,
		(long *)_vq_lengthlist__44u4__p7_1,
		1, -522338304, 1620115456, 4, 0,
		(long *)_vq_quantlist__44u4__p7_1,
		0
};

static const long _vq_quantlist__44u4__p7_2[] = {
		8,
		7,
		9,
		6,
		10,
		5,
		11,
		4,
		12,
		3,
		13,
		2,
		14,
		1,
		15,
		0,
		16,
};

static const long _vq_lengthlist__44u4__p7_2[] = {
		 2, 5, 5, 7, 7, 7, 7, 8, 8, 8, 8, 9, 9, 9, 9, 9,
		 9, 5, 6, 6, 7, 7, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9,
		 9, 9, 5, 6, 6, 7, 7, 8, 8, 8, 8, 9, 9, 9, 9, 9,
		 9, 9, 9, 7, 7, 7, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9,
		10,10,10,10, 7, 7, 7, 8, 8, 8, 8, 9, 9, 9, 9,10,
		 9,10, 9,10,10, 7, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9,
		10,10,10,10,10,10, 7, 8, 8, 8, 8, 9, 9, 9, 9, 9,
		 9,10,10,10,10,10,10, 8, 9, 8, 9, 9, 9, 9, 9, 9,
		10,10,10,10,10,10,10,10, 8, 8, 8, 9, 9, 9, 9, 9,
		10,10,10,10,10,10,10,10,10, 9, 9, 9, 9, 9,10,10,
		10,10,10,10,10,10,10,10,10,10, 9, 9, 9, 9, 9,10,
		10,10,10,10,10,10,10,10,10,10,10, 9, 9, 9, 9,10,
		10,10,10,10,10,10,10,10,10,10,10,10, 9, 9, 9, 9,
		10,10,10,10,10,10,10,10,10,11,10,10,10, 9, 9, 9,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10, 9, 9,
		 9,10,10,10,10,10,10,10,10,10,10,10,10,10,10, 9,
		10, 9,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		 9,10, 9,10,10,10,10,10,10,10,10,10,10,11,10,10,
		10,
};

static const static_codebook _44u4__p7_2 = {
		2, 289,
		(long *)_vq_lengthlist__44u4__p7_2,
		1, -529530880, 1611661312, 5, 0,
		(long *)_vq_quantlist__44u4__p7_2,
		0
};

static const long _huff_lengthlist__44u4__short[] = {
		14,17,15,17,16,14,13,16,10, 7, 7,10,13,10,15,16,
		 9, 4, 4, 6, 5, 7, 9,16,12, 8, 7, 8, 8, 8,11,16,
		14, 7, 4, 6, 3, 5, 8,15,13, 8, 5, 7, 4, 5, 7,16,
		12, 9, 6, 8, 3, 3, 5,16,14,13, 7,10, 5, 5, 7,15,
};

static const static_codebook _huff_book__44u4__short = {
		2, 64,
		(long *)_huff_lengthlist__44u4__short,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist__44u5__long[] = {
		 3, 8,13,12,14,12,16,11,13,14, 5, 4, 5, 6, 7, 8,
		10, 9,12,15,10, 5, 5, 5, 6, 8, 9, 9,13,15,10, 5,
		 5, 6, 6, 7, 8, 8,11,13,12, 7, 5, 6, 4, 6, 7, 7,
		11,14,11, 7, 7, 6, 6, 6, 7, 6,10,14,14, 9, 8, 8,
		 6, 7, 7, 7,11,16,11, 8, 8, 7, 6, 6, 7, 4, 7,12,
		10,10,12,10,10, 9,10, 5, 6, 9,10,12,15,13,14,14,
		14, 8, 7, 8,
};

static const static_codebook _huff_book__44u5__long = {
		2, 100,
		(long *)_huff_lengthlist__44u5__long,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _vq_quantlist__44u5__p1_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__44u5__p1_0[] = {
		 1, 4, 4, 5, 8, 7, 5, 7, 7, 5, 8, 8, 8,10,10, 7,
		 9,10, 5, 8, 8, 7,10, 9, 8,10,10, 5, 8, 8, 8,10,
		10, 8,10,10, 8,10,10,10,12,13,10,13,13, 7,10,10,
		10,13,11,10,13,13, 4, 8, 8, 8,11,10, 8,10,10, 7,
		10,10,10,13,13,10,11,13, 8,10,11,10,13,13,10,13,
		12,
};

static const static_codebook _44u5__p1_0 = {
		4, 81,
		(long *)_vq_lengthlist__44u5__p1_0,
		1, -535822336, 1611661312, 2, 0,
		(long *)_vq_quantlist__44u5__p1_0,
		0
};

static const long _vq_quantlist__44u5__p2_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__44u5__p2_0[] = {
		 3, 4, 4, 5, 6, 6, 5, 6, 6, 5, 6, 6, 6, 8, 8, 6,
		 7, 8, 5, 6, 6, 6, 8, 7, 6, 8, 8, 5, 6, 6, 6, 8,
		 8, 6, 8, 8, 6, 8, 8, 8, 9, 9, 8, 9, 9, 6, 8, 7,
		 7, 9, 8, 8, 9, 9, 5, 6, 6, 6, 8, 7, 6, 8, 8, 6,
		 8, 7, 8, 9, 9, 7, 8, 9, 6, 8, 8, 8, 9, 9, 8, 9,
		 9,
};

static const static_codebook _44u5__p2_0 = {
		4, 81,
		(long *)_vq_lengthlist__44u5__p2_0,
		1, -535822336, 1611661312, 2, 0,
		(long *)_vq_quantlist__44u5__p2_0,
		0
};

static const long _vq_quantlist__44u5__p3_0[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__44u5__p3_0[] = {
		 2, 4, 5, 8, 8, 5, 7, 6, 9, 9, 5, 6, 7, 9, 9, 8,
		10, 9,13,12, 8, 9,10,12,12, 5, 7, 7,10,10, 7, 9,
		 9,11,11, 6, 8, 9,11,11,10,11,11,14,14, 9,10,11,
		13,14, 5, 7, 7, 9,10, 7, 9, 8,11,11, 7, 9, 9,11,
		11, 9,11,10,14,13,10,11,11,14,14, 8,10,10,13,13,
		10,11,11,15,14, 9,11,11,14,14,13,14,14,17,16,12,
		13,13,15,16, 8,10,10,13,13, 9,11,11,14,15,10,11,
		11,14,15,12,14,13,16,16,13,15,14,15,17, 5, 7, 7,
		10,10, 7, 9, 9,11,11, 7, 9, 9,11,11,10,11,11,14,
		14,10,11,12,14,14, 7, 9, 9,12,11, 9,11,11,13,13,
		 9,11,11,13,13,12,13,13,15,16,11,12,13,15,16, 6,
		 9, 9,11,11, 8,11,10,13,12, 9,11,11,13,14,11,13,
		12,16,14,11,13,13,16,17,10,12,11,15,15,11,13,13,
		16,16,11,13,13,17,16,14,15,15,17,17,14,16,16,17,
		18, 9,11,11,14,15,10,12,12,15,15,11,13,13,16,17,
		13,15,13,17,15,14,15,16,18, 0, 5, 7, 7,10,10, 7,
		 9, 9,11,11, 7, 9, 9,11,11,10,11,11,14,14,10,11,
		12,14,15, 6, 9, 9,12,11, 9,11,11,13,13, 8,10,11,
		12,13,11,13,13,16,15,11,12,13,14,15, 7, 9, 9,11,
		12, 9,11,11,13,13, 9,11,11,13,13,11,13,13,15,16,
		11,13,13,15,14, 9,11,11,15,14,11,13,13,17,15,10,
		12,12,15,15,14,16,16,17,17,13,13,15,15,17,10,11,
		12,15,15,11,13,13,16,16,11,13,13,15,15,14,15,15,
		18,18,14,15,15,17,17, 8,10,10,13,13,10,12,11,15,
		15,10,11,12,15,15,14,15,15,18,18,13,14,14,18,18,
		 9,11,11,15,16,11,13,13,17,17,11,13,13,16,16,15,
		15,16,17, 0,14,15,17, 0, 0, 9,11,11,15,15,10,13,
		12,18,16,11,13,13,15,16,14,16,15,20,20,14,15,16,
		17, 0,13,14,14,20,16,14,15,16,19,18,14,15,15,19,
		 0,18,16, 0,20,20,16,18,18, 0, 0,12,14,14,18,18,
		13,15,14,18,16,14,15,16,18,20,16,19,16, 0,17,17,
		18,18,19, 0, 8,10,10,14,14,10,11,11,14,15,10,11,
		12,15,15,13,15,14,19,17,13,15,15,17, 0, 9,11,11,
		16,15,11,13,13,16,16,10,12,13,15,17,14,16,16,18,
		18,14,15,15,18, 0, 9,11,11,15,15,11,13,13,16,17,
		11,13,13,18,17,14,18,16,18,18,15,17,17,18, 0,12,
		14,14,18,18,14,15,15,20, 0,13,14,15,17, 0,16,18,
		17, 0, 0,16,16, 0,17,20,12,14,14,18,18,14,16,15,
		 0,18,14,16,15,18, 0,16,19,17, 0, 0,17,18,16, 0,
		 0,
};

static const static_codebook _44u5__p3_0 = {
		4, 625,
		(long *)_vq_lengthlist__44u5__p3_0,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__44u5__p3_0,
		0
};

static const long _vq_quantlist__44u5__p4_0[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__44u5__p4_0[] = {
		 4, 5, 5, 8, 8, 6, 7, 6, 9, 9, 6, 6, 7, 9, 9, 8,
		 9, 9,11,11, 8, 9, 9,11,11, 6, 7, 7, 9, 9, 7, 8,
		 8,10,10, 6, 7, 8, 9,10, 9,10,10,11,12, 9, 9,10,
		11,12, 6, 7, 7, 9, 9, 6, 8, 7,10, 9, 7, 8, 8,10,
		10, 9,10, 9,12,11, 9,10,10,12,11, 8, 9, 9,12,11,
		 9,10,10,12,12, 9,10,10,12,12,11,12,12,13,14,11,
		11,12,13,14, 8, 9, 9,11,12, 9,10,10,12,12, 9,10,
		10,12,12,11,12,11,14,13,11,12,12,13,13, 5, 7, 7,
		 9, 9, 7, 8, 8,10,10, 7, 8, 8,10,10, 9,10,10,12,
		12, 9,10,10,12,12, 7, 8, 8,10,10, 8, 8, 9,10,11,
		 8, 9, 9,11,11,10,10,11,11,13,10,11,11,12,13, 6,
		 7, 8,10,10, 7, 9, 8,11,10, 8, 9, 9,11,11,10,11,
		10,13,11,10,11,11,12,12, 9,10,10,12,12,10,10,11,
		12,13,10,11,11,13,13,12,11,13,12,15,12,13,13,14,
		15, 9,10,10,12,12, 9,11,10,13,12,10,11,11,13,13,
		11,13,11,14,12,12,13,13,14,15, 5, 7, 7, 9, 9, 7,
		 8, 8,10,10, 7, 8, 8,10,10, 9,10,10,12,12, 9,10,
		10,12,12, 6, 8, 7,10,10, 8, 9, 9,11,11, 7, 8, 9,
		10,11,10,11,11,12,12,10,10,11,11,13, 7, 8, 8,10,
		10, 8, 9, 9,11,11, 8, 9, 8,11,10,10,11,11,13,12,
		10,11,10,13,11, 9,10,10,12,12,10,11,11,13,12, 9,
		10,10,12,13,12,13,13,14,15,11,11,13,12,14, 9,10,
		10,12,12,10,11,11,13,13,10,11,10,13,12,12,13,13,
		14,14,12,13,11,14,12, 8, 9, 9,12,12, 9,10,10,12,
		12, 9,10,10,12,12,12,12,12,14,14,11,12,12,14,13,
		 9,10,10,12,12,10,11,11,13,13,10,11,11,13,12,12,
		12,13,14,15,12,13,13,15,14, 9,10,10,12,12,10,11,
		10,13,12,10,11,11,12,13,12,13,12,15,13,12,13,13,
		14,15,11,12,12,14,13,11,12,12,14,15,12,13,13,15,
		14,13,12,14,12,16,13,14,14,15,15,11,11,12,14,14,
		11,12,11,14,13,12,13,13,14,15,13,14,12,16,12,14,
		14,15,16,16, 8, 9, 9,11,12, 9,10,10,12,12, 9,10,
		10,12,13,11,12,12,13,13,12,12,13,14,14, 9,10,10,
		12,12,10,11,10,13,12,10,10,11,12,13,12,13,13,15,
		14,12,12,13,13,15, 9,10,10,12,13,10,11,11,12,13,
		10,11,11,13,13,12,13,13,14,15,12,13,12,15,14,11,
		12,11,14,13,12,13,13,15,14,11,11,12,13,14,14,15,
		14,16,15,13,12,14,13,16,11,12,12,13,14,12,13,13,
		14,15,11,12,11,14,14,14,14,14,15,16,13,15,12,16,
		12,
};

static const static_codebook _44u5__p4_0 = {
		4, 625,
		(long *)_vq_lengthlist__44u5__p4_0,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__44u5__p4_0,
		0
};

static const long _vq_quantlist__44u5__p5_0[] = {
		4,
		3,
		5,
		2,
		6,
		1,
		7,
		0,
		8,
};

static const long _vq_lengthlist__44u5__p5_0[] = {
		 2, 3, 3, 6, 6, 8, 8,10,10, 4, 5, 5, 8, 7, 8, 8,
		11,10, 3, 5, 5, 7, 8, 8, 8,10,11, 6, 8, 7,10, 9,
		10,10,11,11, 6, 7, 8, 9, 9, 9,10,11,12, 8, 8, 8,
		10,10,11,11,13,12, 8, 8, 9, 9,10,11,11,12,13,10,
		11,10,12,11,13,12,14,14,10,10,11,11,12,12,13,14,
		14,
};

static const static_codebook _44u5__p5_0 = {
		2, 81,
		(long *)_vq_lengthlist__44u5__p5_0,
		1, -531628032, 1611661312, 4, 0,
		(long *)_vq_quantlist__44u5__p5_0,
		0
};

static const long _vq_quantlist__44u5__p6_0[] = {
		4,
		3,
		5,
		2,
		6,
		1,
		7,
		0,
		8,
};

static const long _vq_lengthlist__44u5__p6_0[] = {
		 3, 4, 4, 5, 5, 7, 7, 9, 9, 4, 5, 4, 6, 6, 7, 7,
		 9, 9, 4, 4, 5, 6, 6, 7, 7, 9, 9, 5, 6, 6, 7, 7,
		 8, 8,10,10, 6, 6, 6, 7, 7, 8, 8,10,10, 7, 7, 7,
		 8, 8, 9, 9,11,10, 7, 7, 7, 8, 8, 9, 9,10,11, 9,
		 9, 9,10,10,11,10,11,11, 9, 9, 9,10,10,11,10,11,
		11,
};

static const static_codebook _44u5__p6_0 = {
		2, 81,
		(long *)_vq_lengthlist__44u5__p6_0,
		1, -531628032, 1611661312, 4, 0,
		(long *)_vq_quantlist__44u5__p6_0,
		0
};

static const long _vq_quantlist__44u5__p7_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__44u5__p7_0[] = {
		 1, 4, 4, 5, 7, 7, 5, 7, 7, 5, 9, 9, 8,11,10, 7,
		11,10, 5, 9, 9, 7,10,10, 8,10,11, 4, 9, 9, 9,12,
		12, 9,12,12, 8,12,12,11,12,12,10,12,13, 7,12,12,
		11,12,12,10,12,13, 4, 9, 9, 9,12,12, 9,12,12, 7,
		12,11,10,13,13,11,12,12, 7,12,12,10,13,13,11,12,
		12,
};

static const static_codebook _44u5__p7_0 = {
		4, 81,
		(long *)_vq_lengthlist__44u5__p7_0,
		1, -529137664, 1618345984, 2, 0,
		(long *)_vq_quantlist__44u5__p7_0,
		0
};

static const long _vq_quantlist__44u5__p7_1[] = {
		5,
		4,
		6,
		3,
		7,
		2,
		8,
		1,
		9,
		0,
		10,
};

static const long _vq_lengthlist__44u5__p7_1[] = {
		 2, 4, 4, 6, 6, 7, 7, 8, 8, 8, 8, 4, 5, 5, 7, 7,
		 8, 8, 9, 8, 8, 9, 4, 5, 5, 7, 7, 8, 8, 9, 9, 8,
		 9, 6, 7, 7, 8, 8, 9, 8, 9, 9, 9, 9, 6, 7, 7, 8,
		 8, 9, 9, 9, 9, 9, 9, 7, 8, 8, 9, 9, 9, 9, 9, 9,
		 9, 9, 7, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 8, 9, 9,
		 9, 9, 9, 9,10,10,10,10, 8, 9, 9, 9, 9, 9, 9,10,
		10,10,10, 8, 9, 9, 9, 9, 9, 9,10,10,10,10, 8, 9,
		 9, 9, 9, 9, 9,10,10,10,10,
};

static const static_codebook _44u5__p7_1 = {
		2, 121,
		(long *)_vq_lengthlist__44u5__p7_1,
		1, -531365888, 1611661312, 4, 0,
		(long *)_vq_quantlist__44u5__p7_1,
		0
};

static const long _vq_quantlist__44u5__p8_0[] = {
		5,
		4,
		6,
		3,
		7,
		2,
		8,
		1,
		9,
		0,
		10,
};

static const long _vq_lengthlist__44u5__p8_0[] = {
		 1, 4, 4, 6, 6, 8, 8, 9, 9,10,10, 4, 6, 6, 7, 7,
		 9, 9,10,10,11,11, 4, 6, 6, 7, 7, 9, 9,10,10,11,
		11, 6, 8, 7, 9, 9,10,10,11,11,13,12, 6, 8, 8, 9,
		 9,10,10,11,11,12,13, 8, 9, 9,10,10,12,12,13,12,
		14,13, 8, 9, 9,10,10,12,12,13,13,14,14, 9,11,11,
		12,12,13,13,14,14,15,14, 9,11,11,12,12,13,13,14,
		14,15,14,11,12,12,13,13,14,14,15,14,15,14,11,11,
		12,13,13,14,14,14,14,15,15,
};

static const static_codebook _44u5__p8_0 = {
		2, 121,
		(long *)_vq_lengthlist__44u5__p8_0,
		1, -524582912, 1618345984, 4, 0,
		(long *)_vq_quantlist__44u5__p8_0,
		0
};

static const long _vq_quantlist__44u5__p8_1[] = {
		5,
		4,
		6,
		3,
		7,
		2,
		8,
		1,
		9,
		0,
		10,
};

static const long _vq_lengthlist__44u5__p8_1[] = {
		 3, 5, 5, 6, 6, 7, 7, 7, 7, 7, 7, 5, 6, 5, 7, 6,
		 7, 7, 8, 8, 8, 8, 5, 5, 5, 6, 6, 7, 7, 8, 8, 8,
		 8, 6, 7, 6, 7, 7, 8, 8, 8, 8, 8, 8, 6, 6, 7, 7,
		 7, 8, 8, 8, 8, 8, 8, 7, 7, 7, 8, 8, 8, 8, 8, 8,
		 8, 8, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 7, 8, 8,
		 8, 8, 8, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 8,
		 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
		 8, 8, 8, 8, 8, 8, 8, 8, 8,
};

static const static_codebook _44u5__p8_1 = {
		2, 121,
		(long *)_vq_lengthlist__44u5__p8_1,
		1, -531365888, 1611661312, 4, 0,
		(long *)_vq_quantlist__44u5__p8_1,
		0
};

static const long _vq_quantlist__44u5__p9_0[] = {
		6,
		5,
		7,
		4,
		8,
		3,
		9,
		2,
		10,
		1,
		11,
		0,
		12,
};

static const long _vq_lengthlist__44u5__p9_0[] = {
		 1, 3, 2,12,10,13,13,13,13,13,13,13,13, 4, 9, 9,
		13,13,13,13,13,13,13,13,13,13, 5,10, 9,13,13,13,
		13,13,13,13,13,13,13,12,13,13,13,13,13,13,13,13,
		13,13,13,13,11,13,13,13,13,13,13,13,13,13,13,13,
		13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
		13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
		13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
		13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
		13,13,13,13,13,13,13,13,13,13,13,13,13,12,12,12,
		12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
		12,12,12,12,12,12,12,12,12,
};

static const static_codebook _44u5__p9_0 = {
		2, 169,
		(long *)_vq_lengthlist__44u5__p9_0,
		1, -514332672, 1627381760, 4, 0,
		(long *)_vq_quantlist__44u5__p9_0,
		0
};

static const long _vq_quantlist__44u5__p9_1[] = {
		7,
		6,
		8,
		5,
		9,
		4,
		10,
		3,
		11,
		2,
		12,
		1,
		13,
		0,
		14,
};

static const long _vq_lengthlist__44u5__p9_1[] = {
		 1, 4, 4, 7, 7, 8, 8, 8, 7, 8, 7, 9, 8, 9, 9, 4,
		 7, 6, 9, 8,10,10, 9, 8, 9, 9, 9, 9, 9, 8, 5, 6,
		 6, 8, 9,10,10, 9, 9, 9,10,10,10,10,11, 7, 8, 8,
		10,10,11,11,10,10,11,11,11,12,11,11, 7, 8, 8,10,
		10,11,11,10,10,11,11,12,11,11,11, 8, 9, 9,11,11,
		12,12,11,11,12,11,12,12,12,12, 8, 9,10,11,11,12,
		12,11,11,12,12,12,12,12,12, 8, 9, 9,10,10,12,11,
		12,12,12,12,12,12,12,13, 8, 9, 9,11,11,11,11,12,
		12,12,12,13,12,13,13, 9,10,10,11,11,12,12,12,13,
		12,13,13,13,14,13, 9,10,10,11,11,12,12,12,13,13,
		12,13,13,14,13, 9,11,10,12,11,13,12,12,13,13,13,
		13,13,13,14, 9,10,10,12,12,12,12,12,13,13,13,13,
		13,14,14,10,11,11,12,12,12,13,13,13,14,14,13,14,
		14,14,10,11,11,12,12,12,12,13,12,13,14,13,14,14,
		14,
};

static const static_codebook _44u5__p9_1 = {
		2, 225,
		(long *)_vq_lengthlist__44u5__p9_1,
		1, -522338304, 1620115456, 4, 0,
		(long *)_vq_quantlist__44u5__p9_1,
		0
};

static const long _vq_quantlist__44u5__p9_2[] = {
		8,
		7,
		9,
		6,
		10,
		5,
		11,
		4,
		12,
		3,
		13,
		2,
		14,
		1,
		15,
		0,
		16,
};

static const long _vq_lengthlist__44u5__p9_2[] = {
		 2, 5, 5, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9,
		 9, 5, 6, 6, 7, 7, 8, 8, 9, 8, 9, 9, 9, 9, 9, 9,
		 9, 9, 5, 6, 6, 7, 7, 8, 8, 9, 8, 9, 9, 9, 9, 9,
		 9, 9, 9, 7, 7, 7, 8, 8, 9, 8, 9, 9, 9, 9, 9, 9,
		 9, 9, 9, 9, 7, 7, 7, 8, 8, 9, 8, 9, 9, 9, 9, 9,
		 9, 9, 9, 9, 9, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9,
		 9,10, 9,10,10,10, 8, 8, 8, 9, 8, 9, 9, 9, 9, 9,
		 9, 9,10, 9,10, 9,10, 8, 9, 9, 9, 9, 9, 9, 9, 9,
		 9,10, 9,10,10,10,10,10, 8, 9, 9, 9, 9, 9, 9,10,
		 9,10, 9,10,10,10,10,10,10, 9, 9, 9, 9, 9,10, 9,
		10,10,10,10,10,10,10,10,10,10, 9, 9, 9, 9, 9, 9,
		 9,10, 9,10, 9,10,10,10,10,10,10, 9, 9, 9, 9, 9,
		10,10,10,10,10,10,10,10,10,10,10,10, 9, 9, 9, 9,
		 9, 9,10,10,10,10,10,10,10,10,10,10,10, 9, 9, 9,
		 9,10,10, 9,10,10,10,10,10,10,10,10,10,10, 9, 9,
		 9, 9, 9,10,10,10,10,10,10,10,10,10,10,10,10, 9,
		 9, 9, 9, 9,10,10,10,10,10,10,10,10,10,10,10,10,
		 9, 9, 9,10, 9,10,10,10,10,10,10,10,10,10,10,10,
		10,
};

static const static_codebook _44u5__p9_2 = {
		2, 289,
		(long *)_vq_lengthlist__44u5__p9_2,
		1, -529530880, 1611661312, 5, 0,
		(long *)_vq_quantlist__44u5__p9_2,
		0
};

static const long _huff_lengthlist__44u5__short[] = {
		 4,10,17,13,17,13,17,17,17,17, 3, 6, 8, 9,11, 9,
		15,12,16,17, 6, 5, 5, 7, 7, 8,10,11,17,17, 7, 8,
		 7, 9, 9,10,13,13,17,17, 8, 6, 5, 7, 4, 7, 5, 8,
		14,17, 9, 9, 8, 9, 7, 9, 8,10,16,17,12,10, 7, 8,
		 4, 7, 4, 7,16,17,12,11, 9,10, 6, 9, 5, 7,14,17,
		14,13,10,15, 4, 8, 3, 5,14,17,17,14,11,15, 6,10,
		 6, 8,15,17,
};

static const static_codebook _huff_book__44u5__short = {
		2, 100,
		(long *)_huff_lengthlist__44u5__short,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist__44u6__long[] = {
		 3, 9,14,13,14,13,16,12,13,14, 5, 4, 6, 6, 8, 9,
		11,10,12,15,10, 5, 5, 6, 6, 8,10,10,13,16,10, 6,
		 6, 6, 6, 8, 9, 9,12,14,13, 7, 6, 6, 4, 6, 6, 7,
		11,14,10, 7, 7, 7, 6, 6, 6, 7,10,13,15,10, 9, 8,
		 5, 6, 5, 6,10,14,10, 9, 8, 8, 6, 6, 5, 4, 6,11,
		11,11,12,11,10, 9, 9, 5, 5, 9,10,12,15,13,13,13,
		13, 8, 7, 7,
};

static const static_codebook _huff_book__44u6__long = {
		2, 100,
		(long *)_huff_lengthlist__44u6__long,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _vq_quantlist__44u6__p1_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__44u6__p1_0[] = {
		 1, 4, 4, 4, 8, 7, 5, 7, 7, 5, 8, 8, 8,10,10, 7,
		 9,10, 5, 8, 8, 7,10, 9, 8,10,10, 5, 8, 8, 8,10,
		10, 8,10,10, 8,10,10,10,12,13,10,13,13, 7,10,10,
		10,13,11,10,13,13, 5, 8, 8, 8,11,10, 8,10,10, 7,
		10,10,10,13,13,10,11,13, 8,10,11,10,13,13,10,13,
		12,
};

static const static_codebook _44u6__p1_0 = {
		4, 81,
		(long *)_vq_lengthlist__44u6__p1_0,
		1, -535822336, 1611661312, 2, 0,
		(long *)_vq_quantlist__44u6__p1_0,
		0
};

static const long _vq_quantlist__44u6__p2_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__44u6__p2_0[] = {
		 3, 4, 4, 5, 6, 6, 5, 6, 6, 5, 6, 6, 6, 8, 8, 6,
		 7, 8, 5, 6, 6, 6, 8, 7, 6, 8, 8, 5, 6, 6, 6, 8,
		 8, 6, 8, 8, 6, 8, 8, 8, 9, 9, 8, 9, 9, 6, 7, 7,
		 7, 9, 8, 8, 9, 9, 5, 6, 6, 6, 8, 7, 6, 8, 8, 6,
		 8, 8, 8, 9, 9, 7, 8, 9, 6, 8, 8, 8, 9, 9, 8, 9,
		 9,
};

static const static_codebook _44u6__p2_0 = {
		4, 81,
		(long *)_vq_lengthlist__44u6__p2_0,
		1, -535822336, 1611661312, 2, 0,
		(long *)_vq_quantlist__44u6__p2_0,
		0
};

static const long _vq_quantlist__44u6__p3_0[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__44u6__p3_0[] = {
		 2, 5, 4, 8, 8, 5, 7, 6, 9, 9, 5, 6, 7, 9, 9, 8,
		 9, 9,13,12, 8, 9,10,12,13, 5, 7, 7,10, 9, 7, 9,
		 9,11,11, 7, 8, 9,11,11,10,11,11,14,14, 9,10,11,
		13,14, 5, 7, 7, 9,10, 6, 9, 8,11,11, 7, 9, 9,11,
		11, 9,11,10,14,13,10,11,11,14,13, 8,10,10,13,13,
		10,11,11,15,15, 9,11,11,14,14,13,14,14,17,16,12,
		13,14,16,16, 8,10,10,13,14, 9,11,11,14,15,10,11,
		12,14,15,12,14,13,16,15,13,14,14,15,17, 5, 7, 7,
		10,10, 7, 9, 9,11,11, 7, 9, 9,11,11,10,12,11,14,
		14,10,11,11,14,14, 7, 9, 9,12,11, 9,11,11,13,13,
		 9,11,11,13,13,11,13,13,14,15,11,12,13,15,16, 6,
		 9, 9,11,12, 8,11,10,13,12, 9,11,11,13,14,11,13,
		12,16,14,11,13,13,15,16,10,12,11,14,15,11,13,13,
		15,17,11,13,13,17,16,15,15,16,17,16,14,15,16,18,
		 0, 9,11,11,14,15,10,12,12,16,15,11,13,13,16,16,
		13,15,14,18,15,14,16,16, 0, 0, 5, 7, 7,10,10, 7,
		 9, 9,11,11, 7, 9, 9,11,11,10,11,11,14,14,10,11,
		12,14,14, 6, 9, 9,11,11, 9,11,11,13,13, 8,10,11,
		12,13,11,13,13,16,15,11,12,13,14,16, 7, 9, 9,11,
		12, 9,11,11,13,13, 9,11,11,13,13,11,13,13,16,15,
		11,13,12,15,15, 9,11,11,15,14,11,13,13,17,16,10,
		12,13,15,16,14,16,16, 0,18,14,14,15,15,17,10,11,
		12,15,15,11,13,13,16,16,11,13,13,16,16,14,16,16,
		19,17,14,15,15,17,17, 8,10,10,14,14,10,12,11,15,
		15,10,11,12,16,15,14,15,15,18,20,13,14,16,17,18,
		 9,11,11,15,16,11,13,13,17,17,11,13,13,17,16,15,
		16,16, 0, 0,15,16,16, 0, 0, 9,11,11,15,15,10,13,
		12,17,15,11,13,13,17,16,15,17,15,20,19,15,16,16,
		19, 0,13,15,14, 0,17,14,15,16, 0,20,15,16,16, 0,
		19,17,18, 0, 0, 0,16,17,18, 0, 0,12,14,14,19,18,
		13,15,14, 0,17,14,15,16,19,19,16,18,16, 0,19,19,
		20,17,20, 0, 8,10,10,13,14,10,11,11,15,15,10,12,
		12,15,16,14,15,14,19,16,14,15,15, 0,18, 9,11,11,
		16,15,11,13,13, 0,16,11,12,13,16,17,14,16,17, 0,
		19,15,16,16,18, 0, 9,11,11,15,16,11,13,13,16,16,
		11,14,13,18,17,15,16,16,18,20,15,17,19, 0, 0,12,
		14,14,17,17,14,16,15, 0, 0,13,14,15,19, 0,16,18,
		20, 0, 0,16,16,18,18, 0,12,14,14,17,20,14,16,16,
		19, 0,14,16,14, 0,20,16,20,17, 0, 0,17, 0,15, 0,
		19,
};

static const static_codebook _44u6__p3_0 = {
		4, 625,
		(long *)_vq_lengthlist__44u6__p3_0,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__44u6__p3_0,
		0
};

static const long _vq_quantlist__44u6__p4_0[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__44u6__p4_0[] = {
		 4, 5, 5, 8, 8, 6, 7, 6, 9, 9, 6, 6, 7, 9, 9, 8,
		 9, 9,11,11, 8, 9, 9,11,11, 6, 7, 7, 9, 9, 7, 8,
		 8,10,10, 7, 7, 8, 9,10, 9,10,10,11,11, 9, 9,10,
		11,12, 6, 7, 7, 9, 9, 7, 8, 7,10, 9, 7, 8, 8,10,
		10, 9,10, 9,12,11, 9,10,10,12,11, 8, 9, 9,11,11,
		 9,10,10,12,12, 9,10,10,12,12,11,12,12,14,13,11,
		11,12,13,13, 8, 9, 9,11,11, 9,10,10,12,12, 9,10,
		10,12,12,11,12,11,13,12,11,12,12,13,13, 5, 7, 7,
		 9, 9, 7, 8, 7,10,10, 7, 7, 8,10,10, 9,10,10,12,
		11, 9,10,10,11,12, 7, 8, 8,10,10, 8, 8, 9,11,11,
		 8, 9, 9,11,11,10,10,11,12,13,10,10,11,12,12, 6,
		 7, 7,10,10, 7, 9, 8,11,10, 8, 8, 9,10,11,10,11,
		10,13,11,10,11,11,12,12, 9,10,10,12,12,10,10,11,
		13,13,10,11,11,12,13,12,12,12,13,14,12,12,13,14,
		14, 9,10,10,12,12, 9,10,10,13,12,10,11,11,13,13,
		11,12,11,14,12,12,13,13,14,14, 6, 7, 7, 9, 9, 7,
		 8, 7,10,10, 7, 8, 8,10,10, 9,10,10,12,11, 9,10,
		10,11,12, 6, 7, 7,10,10, 8, 9, 8,11,10, 7, 8, 9,
		10,11,10,11,11,12,12,10,10,11,11,13, 7, 8, 8,10,
		10, 8, 9, 9,11,11, 8, 9, 8,11,11,10,11,10,13,12,
		10,11,11,13,12, 9,10,10,12,12,10,11,11,13,12, 9,
		10,10,12,13,12,13,12,14,14,11,11,12,12,14, 9,10,
		10,12,12,10,11,11,13,13,10,11,10,13,12,12,12,12,
		14,14,12,13,12,14,13, 8, 9, 9,11,11, 9,10,10,12,
		12, 9,10,10,12,12,11,12,12,14,13,11,12,12,13,14,
		 9,10,10,12,12,10,11,11,13,13,10,11,11,13,13,12,
		12,13,14,15,12,12,13,14,14, 9,10,10,12,12, 9,11,
		10,13,12,10,10,11,12,13,12,13,12,14,13,12,12,13,
		14,15,11,12,12,14,13,11,12,12,14,14,12,13,13,14,
		14,13,13,14,14,16,13,14,14,15,15,11,12,11,13,13,
		11,12,11,14,13,12,12,13,14,15,12,14,12,15,12,13,
		14,15,15,16, 8, 9, 9,11,11, 9,10,10,12,12, 9,10,
		10,12,12,11,12,12,14,13,11,12,12,13,13, 9,10,10,
		12,12,10,11,10,13,12, 9,10,11,12,13,12,13,12,14,
		14,12,12,13,13,14, 9,10,10,12,12,10,11,11,13,13,
		10,11,11,13,13,12,13,12,14,14,12,13,13,14,14,11,
		11,11,13,13,12,13,12,14,14,11,11,12,13,14,14,14,
		14,16,15,12,12,14,12,15,11,12,12,13,14,12,13,13,
		14,15,11,12,12,14,14,13,14,14,16,16,13,14,13,16,
		13,
};

static const static_codebook _44u6__p4_0 = {
		4, 625,
		(long *)_vq_lengthlist__44u6__p4_0,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__44u6__p4_0,
		0
};

static const long _vq_quantlist__44u6__p5_0[] = {
		4,
		3,
		5,
		2,
		6,
		1,
		7,
		0,
		8,
};

static const long _vq_lengthlist__44u6__p5_0[] = {
		 2, 3, 3, 6, 6, 8, 8,10,10, 4, 5, 5, 8, 7, 8, 8,
		11,11, 3, 5, 5, 7, 8, 8, 8,11,11, 6, 8, 7, 9, 9,
		10, 9,12,11, 6, 7, 8, 9, 9, 9,10,11,12, 8, 8, 8,
		10, 9,12,11,13,13, 8, 8, 9, 9,10,11,12,13,13,10,
		11,11,12,12,13,13,14,14,10,10,11,11,12,13,13,14,
		14,
};

static const static_codebook _44u6__p5_0 = {
		2, 81,
		(long *)_vq_lengthlist__44u6__p5_0,
		1, -531628032, 1611661312, 4, 0,
		(long *)_vq_quantlist__44u6__p5_0,
		0
};

static const long _vq_quantlist__44u6__p6_0[] = {
		4,
		3,
		5,
		2,
		6,
		1,
		7,
		0,
		8,
};

static const long _vq_lengthlist__44u6__p6_0[] = {
		 3, 4, 4, 5, 5, 7, 7, 9, 9, 4, 5, 4, 6, 6, 7, 7,
		 9, 9, 4, 4, 5, 6, 6, 7, 8, 9, 9, 5, 6, 6, 7, 7,
		 8, 8,10,10, 5, 6, 6, 7, 7, 8, 8,10,10, 7, 8, 7,
		 8, 8,10, 9,11,11, 7, 7, 8, 8, 8, 9,10,10,11, 9,
		 9, 9,10,10,11,11,12,11, 9, 9, 9,10,10,11,11,11,
		12,
};

static const static_codebook _44u6__p6_0 = {
		2, 81,
		(long *)_vq_lengthlist__44u6__p6_0,
		1, -531628032, 1611661312, 4, 0,
		(long *)_vq_quantlist__44u6__p6_0,
		0
};

static const long _vq_quantlist__44u6__p7_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__44u6__p7_0[] = {
		 1, 4, 4, 5, 7, 7, 5, 7, 7, 5, 9, 8, 7,10,10, 8,
		10,10, 5, 8, 9, 7,10,10, 7,10, 9, 4, 8, 8, 9,11,
		11, 8,11,11, 7,11,11,10,10,13,10,13,13, 7,11,11,
		10,13,12,10,13,13, 5, 9, 8, 8,11,11, 9,11,11, 7,
		11,11,10,13,13,10,12,13, 7,11,11,10,13,13, 9,13,
		10,
};

static const static_codebook _44u6__p7_0 = {
		4, 81,
		(long *)_vq_lengthlist__44u6__p7_0,
		1, -529137664, 1618345984, 2, 0,
		(long *)_vq_quantlist__44u6__p7_0,
		0
};

static const long _vq_quantlist__44u6__p7_1[] = {
		5,
		4,
		6,
		3,
		7,
		2,
		8,
		1,
		9,
		0,
		10,
};

static const long _vq_lengthlist__44u6__p7_1[] = {
		 3, 4, 4, 6, 6, 7, 7, 8, 8, 8, 8, 4, 5, 5, 7, 6,
		 8, 8, 8, 8, 8, 8, 4, 5, 5, 6, 7, 8, 8, 8, 8, 8,
		 8, 6, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 6, 7, 7, 7,
		 7, 8, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 9, 9,
		 9, 9, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 8, 8, 8,
		 8, 8, 9, 9, 9, 9, 9, 9, 8, 8, 8, 8, 8, 9, 9, 9,
		 9, 9, 9, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 8, 8,
		 8, 8, 8, 9, 9, 9, 9, 9, 9,
};

static const static_codebook _44u6__p7_1 = {
		2, 121,
		(long *)_vq_lengthlist__44u6__p7_1,
		1, -531365888, 1611661312, 4, 0,
		(long *)_vq_quantlist__44u6__p7_1,
		0
};

static const long _vq_quantlist__44u6__p8_0[] = {
		5,
		4,
		6,
		3,
		7,
		2,
		8,
		1,
		9,
		0,
		10,
};

static const long _vq_lengthlist__44u6__p8_0[] = {
		 1, 4, 4, 6, 6, 8, 8, 9, 9,10,10, 4, 6, 6, 7, 7,
		 9, 9,10,10,11,11, 4, 6, 6, 7, 7, 9, 9,10,10,11,
		11, 6, 8, 8, 9, 9,10,10,11,11,12,12, 6, 8, 8, 9,
		 9,10,10,11,11,12,12, 8, 9, 9,10,10,11,11,12,12,
		13,13, 8, 9, 9,10,10,11,11,12,12,13,13,10,10,10,
		11,11,13,13,13,13,15,14, 9,10,10,12,11,12,13,13,
		13,14,15,11,12,12,13,13,13,13,15,14,15,15,11,11,
		12,13,13,14,14,14,15,15,15,
};

static const static_codebook _44u6__p8_0 = {
		2, 121,
		(long *)_vq_lengthlist__44u6__p8_0,
		1, -524582912, 1618345984, 4, 0,
		(long *)_vq_quantlist__44u6__p8_0,
		0
};

static const long _vq_quantlist__44u6__p8_1[] = {
		5,
		4,
		6,
		3,
		7,
		2,
		8,
		1,
		9,
		0,
		10,
};

static const long _vq_lengthlist__44u6__p8_1[] = {
		 3, 5, 5, 6, 6, 7, 7, 7, 7, 7, 7, 5, 6, 5, 7, 7,
		 7, 7, 8, 7, 8, 8, 5, 5, 6, 6, 7, 7, 7, 7, 7, 8,
		 8, 6, 7, 7, 7, 7, 8, 7, 8, 8, 8, 8, 6, 6, 7, 7,
		 7, 7, 8, 8, 8, 8, 8, 7, 7, 7, 8, 8, 8, 8, 8, 8,
		 8, 8, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 7, 7, 7,
		 8, 8, 8, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 8,
		 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 8,
		 8, 8, 8, 8, 8, 8, 8, 8, 8,
};

static const static_codebook _44u6__p8_1 = {
		2, 121,
		(long *)_vq_lengthlist__44u6__p8_1,
		1, -531365888, 1611661312, 4, 0,
		(long *)_vq_quantlist__44u6__p8_1,
		0
};

static const long _vq_quantlist__44u6__p9_0[] = {
		7,
		6,
		8,
		5,
		9,
		4,
		10,
		3,
		11,
		2,
		12,
		1,
		13,
		0,
		14,
};

static const long _vq_lengthlist__44u6__p9_0[] = {
		 1, 3, 2, 9, 8,15,15,15,15,15,15,15,15,15,15, 4,
		 8, 9,13,14,14,14,14,14,14,14,14,14,14,14, 5, 8,
		 9,14,14,14,14,14,14,14,14,14,14,14,14,11,14,14,
		14,14,14,14,14,14,14,14,14,14,14,14,11,14,14,14,
		14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,
		14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,
		14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,
		14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,
		14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,
		14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,
		14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,
		14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,
		14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,
		14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,
		14,
};

static const static_codebook _44u6__p9_0 = {
		2, 225,
		(long *)_vq_lengthlist__44u6__p9_0,
		1, -514071552, 1627381760, 4, 0,
		(long *)_vq_quantlist__44u6__p9_0,
		0
};

static const long _vq_quantlist__44u6__p9_1[] = {
		7,
		6,
		8,
		5,
		9,
		4,
		10,
		3,
		11,
		2,
		12,
		1,
		13,
		0,
		14,
};

static const long _vq_lengthlist__44u6__p9_1[] = {
		 1, 4, 4, 7, 7, 8, 9, 8, 8, 9, 8, 9, 8, 9, 9, 4,
		 7, 6, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 4, 7,
		 6, 9, 9,10,10, 9, 9,10,10,10,10,11,11, 7, 9, 8,
		10,10,11,11,10,10,11,11,11,11,11,11, 7, 8, 9,10,
		10,11,11,10,10,11,11,11,11,11,12, 8,10,10,11,11,
		12,12,11,11,12,12,12,12,13,12, 8,10,10,11,11,12,
		11,11,11,11,12,12,12,12,13, 8, 9, 9,11,10,11,11,
		12,12,12,12,13,12,13,12, 8, 9, 9,11,11,11,11,12,
		12,12,12,12,13,13,13, 9,10,10,11,12,12,12,12,12,
		13,13,13,13,13,13, 9,10,10,11,11,12,12,12,12,13,
		13,13,13,14,13,10,10,10,12,11,12,12,13,13,13,13,
		13,13,13,13,10,10,11,11,11,12,12,13,13,13,13,13,
		13,13,13,10,11,11,12,12,13,12,12,13,13,13,13,13,
		13,14,10,11,11,12,12,13,12,13,13,13,14,13,13,14,
		13,
};

static const static_codebook _44u6__p9_1 = {
		2, 225,
		(long *)_vq_lengthlist__44u6__p9_1,
		1, -522338304, 1620115456, 4, 0,
		(long *)_vq_quantlist__44u6__p9_1,
		0
};

static const long _vq_quantlist__44u6__p9_2[] = {
		8,
		7,
		9,
		6,
		10,
		5,
		11,
		4,
		12,
		3,
		13,
		2,
		14,
		1,
		15,
		0,
		16,
};

static const long _vq_lengthlist__44u6__p9_2[] = {
		 3, 5, 5, 7, 7, 8, 8, 8, 8, 8, 8, 9, 8, 8, 9, 9,
		 9, 5, 6, 6, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9,
		 9, 9, 5, 6, 6, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9,
		 9, 9, 9, 7, 7, 7, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9,
		 9, 9, 9, 9, 7, 7, 7, 8, 8, 8, 8, 9, 9, 9, 9, 9,
		 9, 9, 9, 9, 9, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9,
		 9, 9, 9, 9, 9, 9, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9,
		 9, 9, 9, 9, 9, 9, 9, 8, 8, 8, 9, 9, 9, 9, 9, 9,
		 9, 9, 9, 9, 9, 9, 9, 9, 8, 8, 8, 9, 9, 9, 9, 9,
		 9, 9, 9, 9, 9, 9, 9, 9, 9, 8, 9, 9, 9, 9, 9, 9,
		 9, 9, 9, 9, 9, 9, 9, 9,10, 9, 8, 9, 9, 9, 9, 9,
		 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
		 9, 9, 9, 9, 9, 9, 9, 9, 9,10,10, 9, 9, 9, 9, 9,
		 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,10, 9, 9, 9,
		 9, 9, 9, 9, 9, 9, 9, 9,10, 9, 9, 9,10, 9, 9, 9,
		 9, 9, 9, 9, 9, 9, 9,10, 9, 9, 9,10, 9, 9,10, 9,
		 9, 9, 9, 9, 9, 9, 9, 9,10,10,10, 9,10, 9,10,10,
		 9, 9, 9, 9, 9, 9, 9, 9, 9,10,10, 9,10,10, 9, 9,
		10,
};

static const static_codebook _44u6__p9_2 = {
		2, 289,
		(long *)_vq_lengthlist__44u6__p9_2,
		1, -529530880, 1611661312, 5, 0,
		(long *)_vq_quantlist__44u6__p9_2,
		0
};

static const long _huff_lengthlist__44u6__short[] = {
		 4,11,16,13,17,13,17,16,17,17, 4, 7, 9, 9,13,10,
		16,12,16,17, 7, 6, 5, 7, 8, 9,12,12,16,17, 6, 9,
		 7, 9,10,10,15,15,17,17, 6, 7, 5, 7, 5, 7, 7,10,
		16,17, 7, 9, 8, 9, 8,10,11,11,15,17, 7, 7, 7, 8,
		 5, 8, 8, 9,15,17, 8, 7, 9, 9, 7, 8, 7, 2, 7,15,
		14,13,13,15, 5,10, 4, 3, 6,17,17,15,13,17, 7,11,
		 7, 6, 9,16,
};

static const static_codebook _huff_book__44u6__short = {
		2, 100,
		(long *)_huff_lengthlist__44u6__short,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist__44u7__long[] = {
		 3, 9,14,13,15,14,16,13,13,14, 5, 5, 7, 7, 8, 9,
		11,10,12,15,10, 6, 5, 6, 6, 9,10,10,13,16,10, 6,
		 6, 6, 6, 8, 9, 9,12,15,14, 7, 6, 6, 5, 6, 6, 8,
		12,15,10, 8, 7, 7, 6, 7, 7, 7,11,13,14,10, 9, 8,
		 5, 6, 4, 5, 9,12,10, 9, 9, 8, 6, 6, 5, 3, 6,11,
		12,11,12,12,10, 9, 8, 5, 5, 8,10,11,15,13,13,13,
		12, 8, 6, 7,
};

static const static_codebook _huff_book__44u7__long = {
		2, 100,
		(long *)_huff_lengthlist__44u7__long,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _vq_quantlist__44u7__p1_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__44u7__p1_0[] = {
		 1, 4, 4, 4, 7, 7, 5, 7, 7, 5, 8, 8, 8,10,10, 7,
		10,10, 5, 8, 8, 7,10,10, 8,10,10, 5, 8, 8, 8,11,
		10, 8,10,10, 8,10,10,10,12,13,10,13,13, 7,10,10,
		10,13,12,10,13,13, 5, 8, 8, 8,11,10, 8,10,11, 7,
		10,10,10,13,13,10,12,13, 8,11,11,10,13,13,10,13,
		12,
};

static const static_codebook _44u7__p1_0 = {
		4, 81,
		(long *)_vq_lengthlist__44u7__p1_0,
		1, -535822336, 1611661312, 2, 0,
		(long *)_vq_quantlist__44u7__p1_0,
		0
};

static const long _vq_quantlist__44u7__p2_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__44u7__p2_0[] = {
		 3, 4, 4, 5, 6, 6, 5, 6, 6, 5, 6, 6, 6, 8, 8, 6,
		 7, 8, 5, 6, 6, 6, 8, 7, 6, 8, 8, 5, 6, 6, 6, 8,
		 7, 6, 8, 8, 6, 8, 8, 8, 9, 9, 8, 9, 9, 6, 8, 7,
		 7, 9, 8, 8, 9, 9, 5, 6, 6, 6, 8, 7, 6, 8, 8, 6,
		 8, 8, 8, 9, 9, 7, 8, 9, 6, 8, 8, 8, 9, 9, 8, 9,
		 9,
};

static const static_codebook _44u7__p2_0 = {
		4, 81,
		(long *)_vq_lengthlist__44u7__p2_0,
		1, -535822336, 1611661312, 2, 0,
		(long *)_vq_quantlist__44u7__p2_0,
		0
};

static const long _vq_quantlist__44u7__p3_0[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__44u7__p3_0[] = {
		 2, 5, 4, 8, 8, 5, 7, 6, 9, 9, 5, 6, 7, 9, 9, 8,
		 9, 9,13,12, 8, 9,10,12,13, 5, 7, 7,10, 9, 7, 9,
		 9,11,11, 6, 8, 9,11,11,10,11,11,14,14, 9,10,11,
		13,14, 5, 7, 7, 9, 9, 7, 9, 8,11,11, 7, 9, 9,11,
		11, 9,11,10,14,13,10,11,11,14,14, 8,10,10,14,13,
		10,11,12,15,14, 9,11,11,15,14,13,14,14,16,16,12,
		13,14,17,16, 8,10,10,13,13, 9,11,11,14,15,10,11,
		12,14,15,12,14,13,16,16,13,14,15,15,17, 5, 7, 7,
		10,10, 7, 9, 9,11,11, 7, 9, 9,11,11,10,12,11,15,
		14,10,11,12,14,14, 7, 9, 9,12,12, 9,11,11,13,13,
		 9,11,11,13,13,11,13,13,14,17,11,13,13,15,16, 6,
		 9, 9,11,11, 8,11,10,13,12, 9,11,11,13,13,11,13,
		12,16,14,11,13,13,16,16,10,12,12,15,15,11,13,13,
		16,16,11,13,13,16,15,14,16,17,17,19,14,16,16,18,
		 0, 9,11,11,14,15,10,13,12,16,15,11,13,13,16,16,
		14,15,14, 0,16,14,16,16,18, 0, 5, 7, 7,10,10, 7,
		 9, 9,12,11, 7, 9, 9,11,12,10,11,11,15,14,10,11,
		12,14,14, 6, 9, 9,11,11, 9,11,11,13,13, 8,10,11,
		12,13,11,13,13,17,15,11,12,13,14,15, 7, 9, 9,11,
		12, 9,11,11,13,13, 9,11,11,13,13,11,13,12,16,16,
		11,13,13,15,14, 9,11,11,14,15,11,13,13,16,15,10,
		12,13,16,16,15,16,16, 0, 0,14,13,15,16,18,10,11,
		11,15,15,11,13,14,16,18,11,13,13,16,15,15,16,16,
		19, 0,14,15,15,16,16, 8,10,10,13,13,10,12,11,16,
		15,10,11,11,16,15,13,15,16,18, 0,13,14,15,17,17,
		 9,11,11,15,15,11,13,13,16,18,11,13,13,16,17,15,
		16,16, 0, 0,15,18,16, 0,17, 9,11,11,15,15,11,13,
		12,17,15,11,13,14,16,17,15,18,15, 0,17,15,16,16,
		18,19,13,15,14, 0,18,14,16,16,19,18,14,16,15,19,
		19,16,18,19, 0, 0,16,17, 0, 0, 0,12,14,14,17,17,
		13,16,14, 0,18,14,16,15,18, 0,16,18,16,19,17,18,
		19,17, 0, 0, 8,10,10,14,14, 9,12,11,15,15,10,11,
		12,15,17,13,15,15,18,16,14,16,15,18,17, 9,11,11,
		16,15,11,13,13, 0,16,11,12,13,16,15,15,16,16, 0,
		17,15,15,16,18,17, 9,12,11,15,17,11,13,13,16,16,
		11,14,13,16,16,15,15,16,18,19,16,18,16, 0, 0,12,
		14,14, 0,16,14,16,16, 0,18,13,14,15,16, 0,17,16,
		18, 0, 0,16,16,17,19, 0,13,14,14,17, 0,14,17,16,
		 0,19,14,15,15,18,19,17,16,18, 0, 0,15,19,16, 0,
		 0,
};

static const static_codebook _44u7__p3_0 = {
		4, 625,
		(long *)_vq_lengthlist__44u7__p3_0,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__44u7__p3_0,
		0
};

static const long _vq_quantlist__44u7__p4_0[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__44u7__p4_0[] = {
		 4, 5, 5, 8, 8, 6, 7, 6, 9, 9, 6, 6, 7, 9, 9, 8,
		 9, 9,11,11, 8, 9, 9,10,11, 6, 7, 7, 9, 9, 7, 8,
		 8,10,10, 6, 7, 8, 9,10, 9,10,10,12,12, 9, 9,10,
		11,12, 6, 7, 7, 9, 9, 6, 8, 7,10, 9, 7, 8, 8,10,
		10, 9,10, 9,12,11, 9,10,10,12,11, 8, 9, 9,11,11,
		 9,10,10,12,12, 9,10,10,12,12,11,12,12,13,14,11,
		11,12,13,13, 8, 9, 9,11,11, 9,10,10,12,11, 9,10,
		10,12,12,11,12,11,13,13,11,12,12,13,13, 6, 7, 7,
		 9, 9, 7, 8, 7,10,10, 7, 7, 8,10,10, 9,10,10,12,
		11, 9,10,10,12,12, 7, 8, 8,10,10, 8, 8, 9,11,11,
		 8, 9, 9,11,11,10,11,11,12,12,10,10,11,12,13, 6,
		 7, 7,10,10, 7, 9, 8,11,10, 8, 8, 9,10,11,10,11,
		10,13,11,10,11,11,12,12, 9,10,10,12,12,10,10,11,
		13,13,10,11,11,13,12,12,12,13,13,14,12,12,13,14,
		14, 9,10,10,12,12, 9,10,10,12,12,10,11,11,13,13,
		11,12,11,14,12,12,13,13,14,14, 6, 7, 7, 9, 9, 7,
		 8, 7,10,10, 7, 7, 8,10,10, 9,10,10,12,11, 9,10,
		10,11,12, 6, 7, 7,10,10, 8, 9, 8,11,10, 7, 8, 9,
		10,11,10,11,11,13,12,10,10,11,11,13, 7, 8, 8,10,
		10, 8, 9, 9,11,11, 8, 9, 9,11,11,10,11,10,13,12,
		10,11,11,12,12, 9,10,10,12,12,10,11,11,13,12, 9,
		10,10,12,13,12,13,12,14,14,11,11,12,12,14, 9,10,
		10,12,12,10,11,11,13,13,10,11,11,13,13,12,13,12,
		14,14,12,13,12,14,13, 8, 9, 9,11,11, 9,10,10,12,
		12, 9,10,10,12,12,11,12,12,14,13,11,12,12,13,13,
		 9,10,10,12,12,10,11,11,13,13,10,11,11,13,12,12,
		13,13,14,14,12,12,13,14,14, 9,10,10,12,12, 9,11,
		10,13,12,10,10,11,12,13,11,13,12,14,13,12,12,13,
		14,14,11,12,12,13,13,11,12,13,14,14,12,13,13,14,
		14,13,13,14,14,16,13,14,14,16,16,11,11,11,13,13,
		11,12,11,14,13,12,12,13,14,15,13,14,12,16,13,14,
		14,14,15,16, 8, 9, 9,11,11, 9,10,10,12,12, 9,10,
		10,12,12,11,12,12,14,13,11,12,12,13,14, 9,10,10,
		12,12,10,11,10,13,12, 9,10,11,12,13,12,13,12,14,
		14,12,12,13,13,14, 9,10,10,12,12,10,11,11,12,13,
		10,11,11,13,13,12,13,12,14,14,12,13,13,14,14,11,
		12,12,13,13,12,13,12,14,14,11,11,12,13,14,13,15,
		14,16,15,13,12,14,13,16,11,12,12,13,13,12,13,13,
		14,14,12,12,12,14,14,13,14,14,15,15,13,14,13,16,
		14,
};

static const static_codebook _44u7__p4_0 = {
		4, 625,
		(long *)_vq_lengthlist__44u7__p4_0,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__44u7__p4_0,
		0
};

static const long _vq_quantlist__44u7__p5_0[] = {
		4,
		3,
		5,
		2,
		6,
		1,
		7,
		0,
		8,
};

static const long _vq_lengthlist__44u7__p5_0[] = {
		 2, 3, 3, 6, 6, 7, 8,10,10, 4, 5, 5, 8, 7, 8, 8,
		11,11, 3, 5, 5, 7, 7, 8, 9,11,11, 6, 8, 7, 9, 9,
		10,10,12,12, 6, 7, 8, 9,10,10,10,12,12, 8, 8, 8,
		10,10,12,11,13,13, 8, 8, 9,10,10,11,11,13,13,10,
		11,11,12,12,13,13,14,14,10,11,11,12,12,13,13,14,
		14,
};

static const static_codebook _44u7__p5_0 = {
		2, 81,
		(long *)_vq_lengthlist__44u7__p5_0,
		1, -531628032, 1611661312, 4, 0,
		(long *)_vq_quantlist__44u7__p5_0,
		0
};

static const long _vq_quantlist__44u7__p6_0[] = {
		4,
		3,
		5,
		2,
		6,
		1,
		7,
		0,
		8,
};

static const long _vq_lengthlist__44u7__p6_0[] = {
		 3, 4, 4, 5, 5, 7, 7, 9, 9, 4, 5, 4, 6, 6, 8, 7,
		 9, 9, 4, 4, 5, 6, 6, 7, 7, 9, 9, 5, 6, 6, 7, 7,
		 8, 8,10,10, 5, 6, 6, 7, 7, 8, 8,10,10, 7, 8, 7,
		 8, 8,10, 9,11,11, 7, 7, 8, 8, 8, 9,10,11,11, 9,
		 9, 9,10,10,11,10,12,11, 9, 9, 9,10,10,11,11,11,
		12,
};

static const static_codebook _44u7__p6_0 = {
		2, 81,
		(long *)_vq_lengthlist__44u7__p6_0,
		1, -531628032, 1611661312, 4, 0,
		(long *)_vq_quantlist__44u7__p6_0,
		0
};

static const long _vq_quantlist__44u7__p7_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__44u7__p7_0[] = {
		 1, 4, 4, 5, 7, 7, 5, 7, 7, 5, 9, 8, 8, 9, 9, 7,
		10,10, 5, 8, 9, 7, 9,10, 8, 9, 9, 4, 9, 9, 9,11,
		10, 8,10,10, 7,11,10,10,10,12,10,12,12, 7,10,10,
		10,12,11,10,12,12, 5, 9, 9, 8,10,10, 9,11,11, 7,
		11,10,10,12,12,10,11,12, 7,10,11,10,12,12,10,12,
		10,
};

static const static_codebook _44u7__p7_0 = {
		4, 81,
		(long *)_vq_lengthlist__44u7__p7_0,
		1, -529137664, 1618345984, 2, 0,
		(long *)_vq_quantlist__44u7__p7_0,
		0
};

static const long _vq_quantlist__44u7__p7_1[] = {
		5,
		4,
		6,
		3,
		7,
		2,
		8,
		1,
		9,
		0,
		10,
};

static const long _vq_lengthlist__44u7__p7_1[] = {
		 3, 4, 4, 6, 6, 7, 7, 8, 8, 8, 8, 4, 5, 5, 6, 6,
		 8, 7, 8, 8, 8, 8, 4, 5, 5, 6, 6, 7, 8, 8, 8, 8,
		 8, 6, 7, 6, 7, 7, 8, 8, 9, 9, 9, 9, 6, 6, 7, 7,
		 7, 8, 8, 9, 9, 9, 9, 7, 8, 7, 8, 8, 9, 9, 9, 9,
		 9, 9, 7, 7, 8, 8, 8, 9, 9, 9, 9, 9, 9, 8, 8, 8,
		 9, 9, 9, 9,10, 9, 9, 9, 8, 8, 8, 9, 9, 9, 9, 9,
		 9, 9,10, 8, 8, 8, 9, 9, 9, 9,10, 9,10,10, 8, 8,
		 8, 9, 9, 9, 9, 9,10,10,10,
};

static const static_codebook _44u7__p7_1 = {
		2, 121,
		(long *)_vq_lengthlist__44u7__p7_1,
		1, -531365888, 1611661312, 4, 0,
		(long *)_vq_quantlist__44u7__p7_1,
		0
};

static const long _vq_quantlist__44u7__p8_0[] = {
		5,
		4,
		6,
		3,
		7,
		2,
		8,
		1,
		9,
		0,
		10,
};

static const long _vq_lengthlist__44u7__p8_0[] = {
		 1, 4, 4, 6, 6, 8, 8,10,10,11,11, 4, 6, 6, 7, 7,
		 9, 9,11,10,12,12, 5, 6, 5, 7, 7, 9, 9,10,11,12,
		12, 6, 7, 7, 8, 8,10,10,11,11,13,13, 6, 7, 7, 8,
		 8,10,10,11,12,13,13, 8, 9, 9,10,10,11,11,12,12,
		14,14, 8, 9, 9,10,10,11,11,12,12,14,14,10,10,10,
		11,11,13,12,14,14,15,15,10,10,10,12,12,13,13,14,
		14,15,15,11,12,12,13,13,14,14,15,14,16,15,11,12,
		12,13,13,14,14,15,15,15,16,
};

static const static_codebook _44u7__p8_0 = {
		2, 121,
		(long *)_vq_lengthlist__44u7__p8_0,
		1, -524582912, 1618345984, 4, 0,
		(long *)_vq_quantlist__44u7__p8_0,
		0
};

static const long _vq_quantlist__44u7__p8_1[] = {
		5,
		4,
		6,
		3,
		7,
		2,
		8,
		1,
		9,
		0,
		10,
};

static const long _vq_lengthlist__44u7__p8_1[] = {
		 4, 5, 5, 6, 6, 7, 7, 7, 7, 7, 7, 5, 6, 6, 7, 7,
		 7, 7, 7, 7, 7, 7, 5, 6, 6, 6, 7, 7, 7, 7, 7, 7,
		 7, 6, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 6, 7, 7, 7,
		 7, 7, 7, 7, 7, 8, 8, 7, 7, 7, 7, 7, 8, 7, 8, 8,
		 8, 8, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 7, 7, 7,
		 7, 7, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 8, 8, 8,
		 8, 8, 8, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 7, 7,
		 7, 8, 8, 8, 8, 8, 8, 8, 8,
};

static const static_codebook _44u7__p8_1 = {
		2, 121,
		(long *)_vq_lengthlist__44u7__p8_1,
		1, -531365888, 1611661312, 4, 0,
		(long *)_vq_quantlist__44u7__p8_1,
		0
};

static const long _vq_quantlist__44u7__p9_0[] = {
		5,
		4,
		6,
		3,
		7,
		2,
		8,
		1,
		9,
		0,
		10,
};

static const long _vq_lengthlist__44u7__p9_0[] = {
		 1, 3, 3,10,10,10,10,10,10,10,10, 4,10,10,10,10,
		10,10,10,10,10,10, 4,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10, 9, 9, 9,
		 9, 9, 9, 9, 9, 9, 9, 9, 9,
};

static const static_codebook _44u7__p9_0 = {
		2, 121,
		(long *)_vq_lengthlist__44u7__p9_0,
		1, -512171520, 1630791680, 4, 0,
		(long *)_vq_quantlist__44u7__p9_0,
		0
};

static const long _vq_quantlist__44u7__p9_1[] = {
		6,
		5,
		7,
		4,
		8,
		3,
		9,
		2,
		10,
		1,
		11,
		0,
		12,
};

static const long _vq_lengthlist__44u7__p9_1[] = {
		 1, 4, 4, 6, 5, 8, 6, 9, 8,10, 9,11,10, 4, 6, 6,
		 8, 8, 9, 9,11,10,11,11,11,11, 4, 6, 6, 8, 8,10,
		 9,11,11,11,11,11,12, 6, 8, 8,10,10,11,11,12,12,
		13,12,13,13, 6, 8, 8,10,10,11,11,12,12,12,13,14,
		13, 8,10,10,11,11,12,13,14,14,14,14,15,15, 8,10,
		10,11,12,12,13,13,14,14,14,14,15, 9,11,11,13,13,
		14,14,15,14,16,15,17,15, 9,11,11,12,13,14,14,15,
		14,15,15,15,16,10,12,12,13,14,15,15,15,15,16,17,
		16,17,10,13,12,13,14,14,16,16,16,16,15,16,17,11,
		13,13,14,15,14,17,15,16,17,17,17,17,11,13,13,14,
		15,15,15,15,17,17,16,17,16,
};

static const static_codebook _44u7__p9_1 = {
		2, 169,
		(long *)_vq_lengthlist__44u7__p9_1,
		1, -518889472, 1622704128, 4, 0,
		(long *)_vq_quantlist__44u7__p9_1,
		0
};

static const long _vq_quantlist__44u7__p9_2[] = {
		24,
		23,
		25,
		22,
		26,
		21,
		27,
		20,
		28,
		19,
		29,
		18,
		30,
		17,
		31,
		16,
		32,
		15,
		33,
		14,
		34,
		13,
		35,
		12,
		36,
		11,
		37,
		10,
		38,
		9,
		39,
		8,
		40,
		7,
		41,
		6,
		42,
		5,
		43,
		4,
		44,
		3,
		45,
		2,
		46,
		1,
		47,
		0,
		48,
};

static const long _vq_lengthlist__44u7__p9_2[] = {
		 2, 4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6,
		 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
		 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8,
		 8,
};

static const static_codebook _44u7__p9_2 = {
		1, 49,
		(long *)_vq_lengthlist__44u7__p9_2,
		1, -526909440, 1611661312, 6, 0,
		(long *)_vq_quantlist__44u7__p9_2,
		0
};

static const long _huff_lengthlist__44u7__short[] = {
		 5,12,17,16,16,17,17,17,17,17, 4, 7,11,11,12, 9,
		17,10,17,17, 7, 7, 8, 9, 7, 9,11,10,15,17, 7, 9,
		10,11,10,12,14,12,16,17, 7, 8, 5, 7, 4, 7, 7, 8,
		16,16, 6,10, 9,10, 7,10,11,11,16,17, 6, 8, 8, 9,
		 5, 7, 5, 8,16,17, 5, 5, 8, 7, 6, 7, 7, 6, 6,14,
		12,10,12,11, 7,11, 4, 4, 2, 7,17,15,15,15, 8,15,
		 6, 8, 5, 9,
};

static const static_codebook _huff_book__44u7__short = {
		2, 100,
		(long *)_huff_lengthlist__44u7__short,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist__44u8__long[] = {
		 3, 9,13,14,14,15,14,14,15,15, 5, 4, 6, 8,10,12,
		12,14,15,15, 9, 5, 4, 5, 8,10,11,13,16,16,10, 7,
		 4, 3, 5, 7, 9,11,13,13,10, 9, 7, 4, 4, 6, 8,10,
		12,14,13,11, 9, 6, 5, 5, 6, 8,12,14,13,11,10, 8,
		 7, 6, 6, 7,10,14,13,11,12,10, 8, 7, 6, 6, 9,13,
		12,11,14,12,11, 9, 8, 7, 9,11,11,12,14,13,14,11,
		10, 8, 8, 9,
};

static const static_codebook _huff_book__44u8__long = {
		2, 100,
		(long *)_huff_lengthlist__44u8__long,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist__44u8__short[] = {
		 6,14,18,18,17,17,17,17,17,17, 4, 7, 9, 9,10,13,
		15,17,17,17, 6, 7, 5, 6, 8,11,16,17,16,17, 5, 7,
		 5, 4, 6,10,14,17,17,17, 6, 6, 6, 5, 7,10,13,16,
		17,17, 7, 6, 7, 7, 7, 8, 7,10,15,16,12, 9, 9, 6,
		 6, 5, 3, 5,11,15,14,14,13, 5, 5, 7, 3, 4, 8,15,
		17,17,13, 7, 7,10, 6, 6,10,15,17,17,16,10,11,14,
		10,10,15,17,
};

static const static_codebook _huff_book__44u8__short = {
		2, 100,
		(long *)_huff_lengthlist__44u8__short,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _vq_quantlist__44u8_p1_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__44u8_p1_0[] = {
		 1, 5, 5, 5, 7, 7, 5, 7, 7, 5, 7, 7, 8, 9, 9, 7,
		 9, 9, 5, 7, 7, 7, 9, 9, 8, 9, 9, 5, 7, 7, 7, 9,
		 9, 7, 9, 9, 7, 9, 9, 9,10,11, 9,11,10, 7, 9, 9,
		 9,11,10, 9,10,11, 5, 7, 7, 7, 9, 9, 7, 9, 9, 7,
		 9, 9, 9,11,10, 9,10,10, 8, 9, 9, 9,11,11, 9,11,
		10,
};

static const static_codebook _44u8_p1_0 = {
		4, 81,
		(long *)_vq_lengthlist__44u8_p1_0,
		1, -535822336, 1611661312, 2, 0,
		(long *)_vq_quantlist__44u8_p1_0,
		0
};

static const long _vq_quantlist__44u8_p2_0[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__44u8_p2_0[] = {
		 4, 5, 5, 8, 8, 5, 7, 6, 9, 9, 5, 6, 7, 9, 9, 8,
		 9, 9,11,11, 8, 9, 9,11,11, 5, 7, 7, 9, 9, 7, 8,
		 8,10,10, 7, 8, 8,10,10, 9,10,10,12,12, 9,10,10,
		11,12, 5, 7, 7, 9, 9, 7, 8, 7,10,10, 7, 8, 8,10,
		10, 9,10, 9,12,11, 9,10,10,12,12, 8, 9, 9,12,11,
		 9,10,10,12,12, 9,10,10,12,12,11,12,12,14,14,11,
		11,12,13,14, 8, 9, 9,11,11, 9,10,10,12,12, 9,10,
		10,12,12,11,12,11,13,13,11,12,12,14,14, 5, 7, 7,
		 9, 9, 7, 8, 8,10,10, 7, 8, 8,10,10, 9,10,10,12,
		12, 9,10,10,11,12, 7, 8, 8,10,10, 8, 9, 9,11,11,
		 8, 9, 9,11,11,10,11,11,12,13,10,11,11,12,13, 6,
		 8, 8,10,10, 8, 9, 8,11,10, 8, 9, 9,11,11,10,11,
		10,13,12,10,11,11,13,13, 9,10,10,12,12,10,11,11,
		13,13,10,11,11,13,13,12,12,13,13,14,12,13,13,14,
		14, 9,10,10,12,12,10,11,10,13,12,10,11,11,13,13,
		11,13,12,14,13,12,13,13,14,14, 5, 7, 7, 9, 9, 7,
		 8, 8,10,10, 7, 8, 8,10,10, 9,10,10,12,12, 9,10,
		10,12,12, 7, 8, 8,10,10, 8, 9, 9,11,11, 8, 8, 9,
		10,11,10,11,11,13,13,10,10,11,12,13, 7, 8, 8,10,
		10, 8, 9, 9,11,11, 8, 9, 9,11,11,10,11,11,13,13,
		10,11,11,13,12, 9,10,10,12,12,10,11,11,13,13,10,
		10,11,12,13,12,13,13,14,14,12,12,13,13,14, 9,10,
		10,12,12,10,11,11,13,13,10,11,11,13,13,12,13,13,
		15,14,12,13,13,14,13, 8, 9, 9,11,11, 9,10,10,12,
		12, 9,10,10,12,12,12,12,12,14,13,11,12,12,14,14,
		 9,10,10,12,12,10,11,11,13,13,10,11,11,13,13,12,
		13,13,14,15,12,13,13,14,15, 9,10,10,12,12,10,11,
		10,13,12,10,11,11,13,13,12,13,12,15,14,12,13,13,
		14,15,11,12,12,14,14,12,13,13,14,14,12,13,13,15,
		14,14,14,14,14,16,14,14,15,16,16,11,12,12,14,14,
		11,12,12,14,14,12,13,13,14,15,13,14,13,16,14,14,
		14,14,16,16, 8, 9, 9,11,11, 9,10,10,12,12, 9,10,
		10,12,12,11,12,12,14,13,11,12,12,14,14, 9,10,10,
		12,12,10,11,11,13,13,10,10,11,12,13,12,13,13,15,
		14,12,12,13,13,14, 9,10,10,12,12,10,11,11,13,13,
		10,11,11,13,13,12,13,13,14,14,12,13,13,15,14,11,
		12,12,14,13,12,13,13,15,14,11,12,12,13,14,14,15,
		14,16,15,13,13,14,13,16,11,12,12,14,14,12,13,13,
		14,15,12,13,12,15,14,14,14,14,16,15,14,15,13,16,
		14,
};

static const static_codebook _44u8_p2_0 = {
		4, 625,
		(long *)_vq_lengthlist__44u8_p2_0,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__44u8_p2_0,
		0
};

static const long _vq_quantlist__44u8_p3_0[] = {
		4,
		3,
		5,
		2,
		6,
		1,
		7,
		0,
		8,
};

static const long _vq_lengthlist__44u8_p3_0[] = {
		 3, 4, 4, 5, 5, 7, 7, 9, 9, 4, 5, 4, 6, 6, 7, 7,
		 9, 9, 4, 4, 5, 6, 6, 7, 7, 9, 9, 5, 6, 6, 7, 7,
		 8, 8,10,10, 6, 6, 6, 7, 7, 8, 8,10,10, 7, 7, 7,
		 8, 8, 9, 9,11,10, 7, 7, 7, 8, 8, 9, 9,10,11, 9,
		 9, 9,10,10,11,10,12,11, 9, 9, 9, 9,10,11,11,11,
		12,
};

static const static_codebook _44u8_p3_0 = {
		2, 81,
		(long *)_vq_lengthlist__44u8_p3_0,
		1, -531628032, 1611661312, 4, 0,
		(long *)_vq_quantlist__44u8_p3_0,
		0
};

static const long _vq_quantlist__44u8_p4_0[] = {
		8,
		7,
		9,
		6,
		10,
		5,
		11,
		4,
		12,
		3,
		13,
		2,
		14,
		1,
		15,
		0,
		16,
};

static const long _vq_lengthlist__44u8_p4_0[] = {
		 4, 4, 4, 6, 6, 7, 7, 8, 8, 8, 8,10,10,11,11,11,
		11, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9,10,10,11,11,
		12,12, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9,10,10,11,
		11,12,12, 6, 6, 6, 7, 7, 8, 8, 9, 9, 9, 9,10,10,
		11,11,12,12, 6, 6, 6, 7, 7, 8, 8, 9, 9, 9, 9,10,
		10,11,11,12,12, 7, 7, 7, 8, 8, 9, 8,10, 9,10, 9,
		11,10,12,11,13,12, 7, 7, 7, 8, 8, 8, 9, 9,10, 9,
		10,10,11,11,12,12,13, 8, 8, 8, 9, 9, 9, 9,10,10,
		11,10,11,11,12,12,13,13, 8, 8, 8, 9, 9, 9,10,10,
		10,10,11,11,11,12,12,12,13, 8, 9, 9, 9, 9,10, 9,
		11,10,11,11,12,11,13,12,13,13, 8, 9, 9, 9, 9, 9,
		10,10,11,11,11,11,12,12,13,13,13,10,10,10,10,10,
		11,10,11,11,12,11,13,12,13,13,14,13,10,10,10,10,
		10,10,11,11,11,11,12,12,13,13,13,13,14,11,11,11,
		11,11,12,11,12,12,13,12,13,13,14,13,14,14,11,11,
		11,11,11,11,12,12,12,12,13,13,13,13,14,14,14,11,
		12,12,12,12,13,12,13,12,13,13,14,13,14,14,14,14,
		11,12,12,12,12,12,12,13,13,13,13,13,14,14,14,14,
		14,
};

static const static_codebook _44u8_p4_0 = {
		2, 289,
		(long *)_vq_lengthlist__44u8_p4_0,
		1, -529530880, 1611661312, 5, 0,
		(long *)_vq_quantlist__44u8_p4_0,
		0
};

static const long _vq_quantlist__44u8_p5_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__44u8_p5_0[] = {
		 1, 4, 4, 5, 7, 7, 5, 7, 7, 5, 8, 8, 8, 9, 9, 7,
		 9, 9, 5, 8, 8, 7, 9, 9, 8, 9, 9, 5, 8, 8, 8,10,
		10, 8,10,10, 7,10,10, 9,10,12, 9,12,11, 7,10,10,
		 9,11,10, 9,11,12, 5, 8, 8, 8,10,10, 8,10,10, 7,
		10,10, 9,11,11, 9,10,11, 7,10,10, 9,11,11,10,12,
		10,
};

static const static_codebook _44u8_p5_0 = {
		4, 81,
		(long *)_vq_lengthlist__44u8_p5_0,
		1, -529137664, 1618345984, 2, 0,
		(long *)_vq_quantlist__44u8_p5_0,
		0
};

static const long _vq_quantlist__44u8_p5_1[] = {
		5,
		4,
		6,
		3,
		7,
		2,
		8,
		1,
		9,
		0,
		10,
};

static const long _vq_lengthlist__44u8_p5_1[] = {
		 4, 5, 5, 6, 6, 7, 7, 7, 7, 8, 8, 5, 5, 5, 6, 6,
		 7, 7, 8, 8, 8, 8, 5, 5, 5, 6, 6, 7, 7, 7, 8, 8,
		 8, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 6, 6, 6, 7,
		 7, 7, 7, 8, 8, 8, 8, 7, 7, 7, 7, 7, 8, 8, 8, 8,
		 8, 8, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 7, 8, 7,
		 8, 8, 8, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 8,
		 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 8, 8,
		 8, 8, 8, 8, 8, 8, 8, 9, 9,
};

static const static_codebook _44u8_p5_1 = {
		2, 121,
		(long *)_vq_lengthlist__44u8_p5_1,
		1, -531365888, 1611661312, 4, 0,
		(long *)_vq_quantlist__44u8_p5_1,
		0
};

static const long _vq_quantlist__44u8_p6_0[] = {
		6,
		5,
		7,
		4,
		8,
		3,
		9,
		2,
		10,
		1,
		11,
		0,
		12,
};

static const long _vq_lengthlist__44u8_p6_0[] = {
		 2, 4, 4, 6, 6, 7, 7, 8, 8, 9, 9,10,10, 4, 6, 5,
		 7, 7, 8, 8, 8, 8, 9, 9,10,10, 4, 6, 6, 7, 7, 8,
		 8, 8, 8, 9, 9,10,10, 6, 7, 7, 7, 8, 8, 8, 8, 9,
		 9,10,10,10, 6, 7, 7, 8, 8, 8, 8, 9, 8,10, 9,11,
		10, 7, 8, 8, 8, 8, 8, 9, 9, 9,10,10,11,11, 7, 8,
		 8, 8, 8, 9, 8, 9, 9,10,10,11,11, 8, 8, 8, 9, 9,
		 9, 9, 9,10,10,10,11,11, 8, 8, 8, 9, 9, 9, 9,10,
		 9,10,10,11,11, 9, 9, 9, 9,10,10,10,10,10,10,11,
		11,12, 9, 9, 9,10, 9,10,10,10,10,11,10,12,11,10,
		10,10,10,10,11,11,11,11,11,12,12,12,10,10,10,10,
		11,11,11,11,11,12,11,12,12,
};

static const static_codebook _44u8_p6_0 = {
		2, 169,
		(long *)_vq_lengthlist__44u8_p6_0,
		1, -526516224, 1616117760, 4, 0,
		(long *)_vq_quantlist__44u8_p6_0,
		0
};

static const long _vq_quantlist__44u8_p6_1[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__44u8_p6_1[] = {
		 3, 4, 4, 5, 5, 4, 5, 5, 5, 5, 4, 5, 5, 5, 5, 5,
		 5, 5, 5, 5, 5, 5, 5, 5, 5,
};

static const static_codebook _44u8_p6_1 = {
		2, 25,
		(long *)_vq_lengthlist__44u8_p6_1,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__44u8_p6_1,
		0
};

static const long _vq_quantlist__44u8_p7_0[] = {
		6,
		5,
		7,
		4,
		8,
		3,
		9,
		2,
		10,
		1,
		11,
		0,
		12,
};

static const long _vq_lengthlist__44u8_p7_0[] = {
		 1, 4, 5, 6, 6, 7, 7, 8, 8,10,10,11,11, 5, 6, 6,
		 7, 7, 8, 8, 9, 9,11,10,12,11, 5, 6, 6, 7, 7, 8,
		 8, 9, 9,10,11,11,12, 6, 7, 7, 8, 8, 9, 9,10,10,
		11,11,12,12, 6, 7, 7, 8, 8, 9, 9,10,10,11,12,13,
		12, 7, 8, 8, 9, 9,10,10,11,11,12,12,13,13, 8, 8,
		 8, 9, 9,10,10,11,11,12,12,13,13, 9, 9, 9,10,10,
		11,11,12,12,13,13,14,14, 9, 9, 9,10,10,11,11,12,
		12,13,13,14,14,10,11,11,12,11,13,12,13,13,14,14,
		15,15,10,11,11,11,12,12,13,13,14,14,14,15,15,11,
		12,12,13,13,14,13,15,14,15,15,16,15,11,11,12,13,
		13,13,14,14,14,15,15,15,16,
};

static const static_codebook _44u8_p7_0 = {
		2, 169,
		(long *)_vq_lengthlist__44u8_p7_0,
		1, -523206656, 1618345984, 4, 0,
		(long *)_vq_quantlist__44u8_p7_0,
		0
};

static const long _vq_quantlist__44u8_p7_1[] = {
		5,
		4,
		6,
		3,
		7,
		2,
		8,
		1,
		9,
		0,
		10,
};

static const long _vq_lengthlist__44u8_p7_1[] = {
		 4, 5, 5, 6, 6, 7, 7, 7, 7, 7, 7, 5, 6, 6, 7, 7,
		 7, 7, 7, 7, 7, 7, 5, 6, 6, 7, 7, 7, 7, 7, 7, 7,
		 7, 6, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 6, 7, 7, 7,
		 7, 7, 7, 7, 7, 7, 8, 7, 7, 7, 7, 7, 7, 7, 8, 8,
		 8, 8, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 7, 7, 7,
		 8, 7, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 8, 8, 8,
		 8, 8, 8, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 7, 7,
		 7, 8, 8, 8, 8, 8, 8, 8, 8,
};

static const static_codebook _44u8_p7_1 = {
		2, 121,
		(long *)_vq_lengthlist__44u8_p7_1,
		1, -531365888, 1611661312, 4, 0,
		(long *)_vq_quantlist__44u8_p7_1,
		0
};

static const long _vq_quantlist__44u8_p8_0[] = {
		7,
		6,
		8,
		5,
		9,
		4,
		10,
		3,
		11,
		2,
		12,
		1,
		13,
		0,
		14,
};

static const long _vq_lengthlist__44u8_p8_0[] = {
		 1, 4, 4, 7, 7, 8, 8, 8, 7, 9, 8,10, 9,11,10, 4,
		 6, 6, 8, 8,10, 9, 9, 9,10,10,11,10,12,10, 4, 6,
		 6, 8, 8,10,10, 9, 9,10,10,11,11,11,12, 7, 8, 8,
		10,10,11,11,11,10,12,11,12,12,13,11, 7, 8, 8,10,
		10,11,11,10,10,11,11,12,12,13,13, 8,10,10,11,11,
		12,11,12,11,13,12,13,12,14,13, 8,10, 9,11,11,12,
		12,12,12,12,12,13,13,14,13, 8, 9, 9,11,10,12,11,
		13,12,13,13,14,13,14,13, 8, 9, 9,10,11,12,12,12,
		12,13,13,14,15,14,14, 9,10,10,12,11,13,12,13,13,
		14,13,14,14,14,14, 9,10,10,12,12,12,12,13,13,14,
		14,14,15,14,14,10,11,11,13,12,13,12,14,14,14,14,
		14,14,15,15,10,11,11,12,12,13,13,14,14,14,15,15,
		14,16,15,11,12,12,13,12,14,14,14,13,15,14,15,15,
		15,17,11,12,12,13,13,14,14,14,15,15,14,15,15,14,
		17,
};

static const static_codebook _44u8_p8_0 = {
		2, 225,
		(long *)_vq_lengthlist__44u8_p8_0,
		1, -520986624, 1620377600, 4, 0,
		(long *)_vq_quantlist__44u8_p8_0,
		0
};

static const long _vq_quantlist__44u8_p8_1[] = {
		10,
		9,
		11,
		8,
		12,
		7,
		13,
		6,
		14,
		5,
		15,
		4,
		16,
		3,
		17,
		2,
		18,
		1,
		19,
		0,
		20,
};

static const long _vq_lengthlist__44u8_p8_1[] = {
		 4, 6, 6, 7, 7, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9,
		 9, 9, 9, 9, 9, 6, 6, 6, 7, 7, 8, 8, 8, 8, 9, 9,
		 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 5, 6, 6, 7, 7, 8,
		 8, 9, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 7,
		 7, 7, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
		 9, 9, 9, 9, 7, 7, 7, 8, 8, 8, 8, 9, 9, 9, 9, 9,
		 9, 9, 9, 9, 9, 9, 9, 9, 9, 8, 8, 8, 8, 8, 9, 9,
		 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,10,10, 9,10, 8, 8,
		 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,10, 9,10,
		10, 9,10, 8, 9, 8, 9, 9, 9, 9, 9, 9, 9, 9,10, 9,
		10,10,10,10,10,10,10,10, 8, 9, 8, 9, 9, 9, 9, 9,
		 9, 9, 9, 9, 9, 9,10,10,10,10, 9,10,10, 9, 9, 9,
		 9, 9, 9, 9, 9, 9, 9, 9,10, 9,10,10,10,10,10,10,
		10,10, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,10, 9,10,
		10,10,10,10,10,10,10, 9, 9, 9, 9, 9, 9, 9,10, 9,
		10,10,10,10,10,10,10,10,10,10,10,10, 9, 9, 9, 9,
		 9, 9, 9, 9, 9, 9,10,10,10,10,10,10,10,10,10,10,
		10, 9, 9, 9, 9, 9, 9,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10, 9, 9, 9, 9, 9, 9, 9,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10, 9, 9, 9, 9, 9,
		 9, 9,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		 9, 9, 9, 9, 9,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10, 9, 9, 9,10, 9,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10, 9, 9, 9, 9, 9,10,
		 9,10,10,10,10,10,10,10,10,10,10,10,10,10,10, 9,
		 9, 9, 9, 9, 9,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10, 9, 9, 9,10, 9,10, 9,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,
};

static const static_codebook _44u8_p8_1 = {
		2, 441,
		(long *)_vq_lengthlist__44u8_p8_1,
		1, -529268736, 1611661312, 5, 0,
		(long *)_vq_quantlist__44u8_p8_1,
		0
};

static const long _vq_quantlist__44u8_p9_0[] = {
		4,
		3,
		5,
		2,
		6,
		1,
		7,
		0,
		8,
};

static const long _vq_lengthlist__44u8_p9_0[] = {
		 1, 3, 3, 9, 9, 9, 9, 9, 9, 4, 9, 9, 9, 9, 9, 9,
		 9, 9, 5, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
		 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
		 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
		 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 8, 8, 8,
		 8,
};

static const static_codebook _44u8_p9_0 = {
		2, 81,
		(long *)_vq_lengthlist__44u8_p9_0,
		1, -511895552, 1631393792, 4, 0,
		(long *)_vq_quantlist__44u8_p9_0,
		0
};

static const long _vq_quantlist__44u8_p9_1[] = {
		9,
		8,
		10,
		7,
		11,
		6,
		12,
		5,
		13,
		4,
		14,
		3,
		15,
		2,
		16,
		1,
		17,
		0,
		18,
};

static const long _vq_lengthlist__44u8_p9_1[] = {
		 1, 4, 4, 7, 7, 8, 7, 8, 6, 9, 7,10, 8,11,10,11,
		11,11,11, 4, 7, 6, 9, 9,10, 9, 9, 9,10,10,11,10,
		11,10,11,11,13,11, 4, 7, 7, 9, 9, 9, 9, 9, 9,10,
		10,11,10,11,11,11,12,11,12, 7, 9, 8,11,11,11,11,
		10,10,11,11,12,12,12,12,12,12,14,13, 7, 8, 9,10,
		11,11,11,10,10,11,11,11,11,12,12,14,12,13,14, 8,
		 9, 9,11,11,11,11,11,11,12,12,14,12,15,14,14,14,
		15,14, 8, 9, 9,11,11,11,11,12,11,12,12,13,13,13,
		13,13,13,14,14, 8, 9, 9,11,10,12,11,12,12,13,13,
		13,13,15,14,14,14,16,16, 8, 9, 9,10,11,11,12,12,
		12,13,13,13,14,14,14,15,16,15,15, 9,10,10,11,12,
		12,13,13,13,14,14,16,14,14,16,16,16,16,15, 9,10,
		10,11,11,12,13,13,14,15,14,16,14,15,16,16,16,16,
		15,10,11,11,12,13,13,14,15,15,15,15,15,16,15,16,
		15,16,15,15,10,11,11,13,13,14,13,13,15,14,15,15,
		16,15,15,15,16,15,16,10,12,12,14,14,14,14,14,16,
		16,15,15,15,16,16,16,16,16,16,11,12,12,14,14,14,
		14,15,15,16,15,16,15,16,15,16,16,16,16,12,12,13,
		14,14,15,16,16,16,16,16,16,15,16,16,16,16,16,16,
		12,13,13,14,14,14,14,15,16,15,16,16,16,16,16,16,
		16,16,16,12,13,14,14,14,16,15,16,15,16,16,16,16,
		16,16,16,16,16,16,12,14,13,14,15,15,15,16,15,16,
		16,15,16,16,16,16,16,16,16,
};

static const static_codebook _44u8_p9_1 = {
		2, 361,
		(long *)_vq_lengthlist__44u8_p9_1,
		1, -518287360, 1622704128, 5, 0,
		(long *)_vq_quantlist__44u8_p9_1,
		0
};

static const long _vq_quantlist__44u8_p9_2[] = {
		24,
		23,
		25,
		22,
		26,
		21,
		27,
		20,
		28,
		19,
		29,
		18,
		30,
		17,
		31,
		16,
		32,
		15,
		33,
		14,
		34,
		13,
		35,
		12,
		36,
		11,
		37,
		10,
		38,
		9,
		39,
		8,
		40,
		7,
		41,
		6,
		42,
		5,
		43,
		4,
		44,
		3,
		45,
		2,
		46,
		1,
		47,
		0,
		48,
};

static const long _vq_lengthlist__44u8_p9_2[] = {
		 2, 3, 4, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6,
		 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
		 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
		 7,
};

static const static_codebook _44u8_p9_2 = {
		1, 49,
		(long *)_vq_lengthlist__44u8_p9_2,
		1, -526909440, 1611661312, 6, 0,
		(long *)_vq_quantlist__44u8_p9_2,
		0
};

static const long _huff_lengthlist__44u9__long[] = {
		 3, 9,13,13,14,15,14,14,15,15, 5, 5, 9,10,12,12,
		13,14,16,15,10, 6, 6, 6, 8,11,12,13,16,15,11, 7,
		 5, 3, 5, 8,10,12,15,15,10,10, 7, 4, 3, 5, 8,10,
		12,12,12,12, 9, 7, 5, 4, 6, 8,10,13,13,12,11, 9,
		 7, 5, 5, 6, 9,12,14,12,12,10, 8, 6, 6, 6, 7,11,
		13,12,14,13,10, 8, 7, 7, 7,10,11,11,12,13,12,11,
		10, 8, 8, 9,
};

static const static_codebook _huff_book__44u9__long = {
		2, 100,
		(long *)_huff_lengthlist__44u9__long,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _huff_lengthlist__44u9__short[] = {
		 9,16,18,18,17,17,17,17,17,17, 5, 8,11,12,11,12,
		17,17,16,16, 6, 6, 8, 8, 9,10,14,15,16,16, 6, 7,
		 7, 4, 6, 9,13,16,16,16, 6, 6, 7, 4, 5, 8,11,15,
		17,16, 7, 6, 7, 6, 6, 8, 9,10,14,16,11, 8, 8, 7,
		 6, 6, 3, 4,10,15,14,12,12,10, 5, 6, 3, 3, 8,13,
		15,17,15,11, 6, 8, 6, 6, 9,14,17,15,15,12, 8,10,
		 9, 9,12,15,
};

static const static_codebook _huff_book__44u9__short = {
		2, 100,
		(long *)_huff_lengthlist__44u9__short,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _vq_quantlist__44u9_p1_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__44u9_p1_0[] = {
		 1, 5, 5, 5, 7, 7, 5, 7, 7, 5, 7, 7, 7, 9, 9, 7,
		 9, 9, 5, 7, 7, 7, 9, 9, 7, 9, 9, 5, 7, 7, 7, 9,
		 9, 7, 9, 9, 8, 9, 9, 9,10,11, 9,11,11, 7, 9, 9,
		 9,11,10, 9,11,11, 5, 7, 7, 7, 9, 9, 8, 9,10, 7,
		 9, 9, 9,11,11, 9,10,11, 7, 9,10, 9,11,11, 9,11,
		10,
};

static const static_codebook _44u9_p1_0 = {
		4, 81,
		(long *)_vq_lengthlist__44u9_p1_0,
		1, -535822336, 1611661312, 2, 0,
		(long *)_vq_quantlist__44u9_p1_0,
		0
};

static const long _vq_quantlist__44u9_p2_0[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__44u9_p2_0[] = {
		 3, 5, 5, 8, 8, 5, 7, 7, 9, 9, 6, 7, 7, 9, 9, 8,
		 9, 9,11,10, 8, 9, 9,11,11, 6, 7, 7, 9, 9, 7, 8,
		 8,10,10, 7, 8, 8, 9,10, 9,10,10,11,11, 9, 9,10,
		11,11, 6, 7, 7, 9, 9, 7, 8, 8,10, 9, 7, 8, 8,10,
		10, 9,10, 9,11,11, 9,10,10,11,11, 8, 9, 9,11,11,
		 9,10,10,12,11, 9,10,10,11,12,11,11,11,13,13,11,
		11,11,12,13, 8, 9, 9,11,11, 9,10,10,11,11, 9,10,
		10,12,11,11,12,11,13,12,11,11,12,13,13, 6, 7, 7,
		 9, 9, 7, 8, 8,10,10, 7, 8, 8,10,10, 9,10,10,12,
		11, 9,10,10,11,12, 7, 8, 8,10,10, 8, 9, 9,11,11,
		 8, 9, 9,10,10,10,11,11,12,12,10,10,11,12,12, 7,
		 8, 8,10,10, 8, 9, 8,10,10, 8, 9, 9,10,10,10,11,
		10,12,11,10,10,11,12,12, 9,10,10,11,12,10,11,11,
		12,12,10,11,10,12,12,12,12,12,13,13,11,12,12,13,
		13, 9,10,10,11,11, 9,10,10,12,12,10,11,11,12,13,
		11,12,11,13,12,12,12,12,13,14, 6, 7, 7, 9, 9, 7,
		 8, 8,10,10, 7, 8, 8,10,10, 9,10,10,11,11, 9,10,
		10,11,12, 7, 8, 8,10,10, 8, 9, 9,11,10, 8, 8, 9,
		10,10,10,11,10,12,12,10,10,11,11,12, 7, 8, 8,10,
		10, 8, 9, 9,10,10, 8, 9, 9,10,10,10,11,10,12,12,
		10,11,10,12,12, 9,10,10,12,11,10,11,11,12,12, 9,
		10,10,12,12,12,12,12,13,13,11,11,12,12,14, 9,10,
		10,11,12,10,11,11,12,12,10,11,11,12,12,11,12,12,
		14,14,12,12,12,13,13, 8, 9, 9,11,11, 9,10,10,12,
		11, 9,10,10,12,12,11,12,11,13,13,11,11,12,13,13,
		 9,10,10,12,12,10,11,11,12,12,10,11,11,12,12,12,
		12,12,14,14,12,12,12,13,13, 9,10,10,12,11,10,11,
		10,12,12,10,11,11,12,12,11,12,12,14,13,12,12,12,
		13,14,11,12,11,13,13,11,12,12,13,13,12,12,12,14,
		14,13,13,13,13,15,13,13,14,15,15,11,11,11,13,13,
		11,12,11,13,13,11,12,12,13,13,12,13,12,15,13,13,
		13,14,14,15, 8, 9, 9,11,11, 9,10,10,11,12, 9,10,
		10,11,12,11,12,11,13,13,11,12,12,13,13, 9,10,10,
		11,12,10,11,10,12,12,10,10,11,12,13,12,12,12,14,
		13,11,12,12,13,14, 9,10,10,12,12,10,11,11,12,12,
		10,11,11,12,12,12,12,12,14,13,12,12,12,14,13,11,
		11,11,13,13,11,12,12,14,13,11,11,12,13,13,13,13,
		13,15,14,12,12,13,13,15,11,12,12,13,13,12,12,12,
		13,14,11,12,12,13,13,13,13,14,14,15,13,13,13,14,
		14,
};

static const static_codebook _44u9_p2_0 = {
		4, 625,
		(long *)_vq_lengthlist__44u9_p2_0,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__44u9_p2_0,
		0
};

static const long _vq_quantlist__44u9_p3_0[] = {
		4,
		3,
		5,
		2,
		6,
		1,
		7,
		0,
		8,
};

static const long _vq_lengthlist__44u9_p3_0[] = {
		 3, 4, 4, 5, 5, 7, 7, 8, 8, 4, 5, 5, 6, 6, 7, 7,
		 9, 9, 4, 4, 5, 6, 6, 7, 7, 9, 9, 5, 6, 6, 7, 7,
		 8, 8, 9, 9, 5, 6, 6, 7, 7, 8, 8, 9, 9, 7, 7, 7,
		 8, 8, 9, 9,10,10, 7, 7, 7, 8, 8, 9, 9,10,10, 8,
		 9, 9,10, 9,10,10,11,11, 8, 9, 9, 9,10,10,10,11,
		11,
};

static const static_codebook _44u9_p3_0 = {
		2, 81,
		(long *)_vq_lengthlist__44u9_p3_0,
		1, -531628032, 1611661312, 4, 0,
		(long *)_vq_quantlist__44u9_p3_0,
		0
};

static const long _vq_quantlist__44u9_p4_0[] = {
		8,
		7,
		9,
		6,
		10,
		5,
		11,
		4,
		12,
		3,
		13,
		2,
		14,
		1,
		15,
		0,
		16,
};

static const long _vq_lengthlist__44u9_p4_0[] = {
		 4, 5, 5, 6, 6, 7, 7, 8, 8, 8, 8, 9, 9,10,10,11,
		11, 5, 5, 5, 6, 6, 7, 7, 8, 8, 8, 8, 9, 9,10,10,
		11,11, 5, 5, 5, 6, 6, 7, 7, 8, 8, 8, 8, 9, 9,10,
		10,11,11, 6, 6, 6, 7, 6, 7, 7, 8, 8, 9, 9,10,10,
		11,11,12,11, 6, 6, 6, 6, 7, 7, 7, 8, 8, 9, 9,10,
		10,11,11,11,12, 7, 7, 7, 7, 7, 8, 8, 9, 9, 9, 9,
		10,10,11,11,12,12, 7, 7, 7, 7, 7, 8, 8, 9, 9, 9,
		 9,10,10,11,11,12,12, 8, 8, 8, 8, 8, 9, 8,10, 9,
		10,10,11,10,12,11,13,12, 8, 8, 8, 8, 8, 9, 9, 9,
		10,10,10,10,11,11,12,12,12, 8, 8, 8, 9, 9, 9, 9,
		10,10,11,10,12,11,12,12,13,12, 8, 8, 8, 9, 9, 9,
		 9,10,10,10,11,11,11,12,12,12,13, 9, 9, 9,10,10,
		10,10,11,10,11,11,12,11,13,12,13,13, 9, 9,10,10,
		10,10,10,10,11,11,11,11,12,12,13,13,13,10,11,10,
		11,11,11,11,12,11,12,12,13,12,13,13,14,13,10,10,
		10,11,11,11,11,11,12,12,12,12,13,13,13,13,14,11,
		11,11,12,11,12,12,12,12,13,13,13,13,14,13,14,14,
		11,11,11,11,12,12,12,12,12,12,13,13,13,13,14,14,
		14,
};

static const static_codebook _44u9_p4_0 = {
		2, 289,
		(long *)_vq_lengthlist__44u9_p4_0,
		1, -529530880, 1611661312, 5, 0,
		(long *)_vq_quantlist__44u9_p4_0,
		0
};

static const long _vq_quantlist__44u9_p5_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__44u9_p5_0[] = {
		 1, 4, 4, 5, 7, 7, 5, 7, 7, 5, 8, 8, 8, 9, 9, 7,
		 9, 9, 5, 8, 8, 7, 9, 9, 8, 9, 9, 5, 8, 8, 8,10,
		10, 8,10,10, 7,10,10, 9,10,12, 9,11,11, 7,10,10,
		 9,11,10, 9,11,12, 5, 8, 8, 8,10,10, 8,10,10, 7,
		10,10, 9,12,11, 9,10,11, 7,10,10, 9,11,11,10,12,
		10,
};

static const static_codebook _44u9_p5_0 = {
		4, 81,
		(long *)_vq_lengthlist__44u9_p5_0,
		1, -529137664, 1618345984, 2, 0,
		(long *)_vq_quantlist__44u9_p5_0,
		0
};

static const long _vq_quantlist__44u9_p5_1[] = {
		5,
		4,
		6,
		3,
		7,
		2,
		8,
		1,
		9,
		0,
		10,
};

static const long _vq_lengthlist__44u9_p5_1[] = {
		 5, 5, 5, 6, 6, 7, 7, 7, 7, 7, 7, 5, 6, 6, 6, 6,
		 7, 7, 7, 7, 8, 7, 5, 6, 6, 6, 6, 7, 7, 7, 7, 7,
		 7, 6, 6, 6, 7, 7, 7, 7, 7, 7, 8, 8, 6, 6, 6, 7,
		 7, 7, 7, 7, 7, 8, 8, 7, 7, 7, 7, 7, 8, 7, 8, 8,
		 8, 8, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 7, 7, 7,
		 8, 7, 8, 8, 8, 8, 8, 8, 7, 7, 7, 7, 8, 8, 8, 8,
		 8, 8, 8, 7, 8, 7, 8, 8, 8, 8, 8, 8, 8, 8, 7, 8,
		 8, 8, 8, 8, 8, 8, 8, 8, 8,
};

static const static_codebook _44u9_p5_1 = {
		2, 121,
		(long *)_vq_lengthlist__44u9_p5_1,
		1, -531365888, 1611661312, 4, 0,
		(long *)_vq_quantlist__44u9_p5_1,
		0
};

static const long _vq_quantlist__44u9_p6_0[] = {
		6,
		5,
		7,
		4,
		8,
		3,
		9,
		2,
		10,
		1,
		11,
		0,
		12,
};

static const long _vq_lengthlist__44u9_p6_0[] = {
		 2, 4, 4, 6, 6, 7, 7, 8, 8, 9, 9,10,10, 4, 6, 5,
		 7, 7, 8, 8, 8, 8, 9, 9,10,10, 4, 5, 6, 7, 7, 8,
		 8, 8, 8, 9, 9,10,10, 6, 7, 7, 8, 8, 8, 8, 9, 9,
		10,10,10,10, 6, 7, 7, 8, 8, 8, 8, 9, 9,10,10,10,
		10, 7, 8, 8, 8, 8, 9, 9, 9, 9,10,10,11,11, 7, 8,
		 8, 8, 8, 9, 9, 9, 9,10,10,11,11, 8, 8, 8, 9, 9,
		 9, 9, 9,10,10,10,11,11, 8, 8, 8, 9, 9, 9, 9,10,
		 9,10,10,11,11, 9, 9, 9,10,10,10,10,10,11,11,11,
		11,12, 9, 9, 9,10,10,10,10,10,10,11,10,12,11,10,
		10,10,10,10,11,11,11,11,11,12,12,12,10,10,10,10,
		10,11,11,11,11,12,11,12,12,
};

static const static_codebook _44u9_p6_0 = {
		2, 169,
		(long *)_vq_lengthlist__44u9_p6_0,
		1, -526516224, 1616117760, 4, 0,
		(long *)_vq_quantlist__44u9_p6_0,
		0
};

static const long _vq_quantlist__44u9_p6_1[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__44u9_p6_1[] = {
		 4, 4, 4, 5, 5, 4, 5, 4, 5, 5, 4, 4, 5, 5, 5, 5,
		 5, 5, 5, 5, 5, 5, 5, 5, 5,
};

static const static_codebook _44u9_p6_1 = {
		2, 25,
		(long *)_vq_lengthlist__44u9_p6_1,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__44u9_p6_1,
		0
};

static const long _vq_quantlist__44u9_p7_0[] = {
		6,
		5,
		7,
		4,
		8,
		3,
		9,
		2,
		10,
		1,
		11,
		0,
		12,
};

static const long _vq_lengthlist__44u9_p7_0[] = {
		 1, 4, 5, 6, 6, 7, 7, 8, 9,10,10,11,11, 5, 6, 6,
		 7, 7, 8, 8, 9, 9,10,10,11,11, 5, 6, 6, 7, 7, 8,
		 8, 9, 9,10,10,11,11, 6, 7, 7, 8, 8, 9, 9,10,10,
		11,11,12,12, 6, 7, 7, 8, 8, 9, 9,10,10,11,11,12,
		12, 8, 8, 8, 9, 9,10,10,11,11,12,12,13,13, 8, 8,
		 8, 9, 9,10,10,11,11,12,12,13,13, 9, 9, 9,10,10,
		11,11,12,12,13,13,13,13, 9, 9, 9,10,10,11,11,12,
		12,13,13,14,14,10,10,10,11,11,12,12,13,13,14,13,
		15,14,10,10,10,11,11,12,12,13,13,14,14,14,14,11,
		11,12,12,12,13,13,14,14,14,14,15,15,11,11,12,12,
		12,13,13,14,14,14,15,15,15,
};

static const static_codebook _44u9_p7_0 = {
		2, 169,
		(long *)_vq_lengthlist__44u9_p7_0,
		1, -523206656, 1618345984, 4, 0,
		(long *)_vq_quantlist__44u9_p7_0,
		0
};

static const long _vq_quantlist__44u9_p7_1[] = {
		5,
		4,
		6,
		3,
		7,
		2,
		8,
		1,
		9,
		0,
		10,
};

static const long _vq_lengthlist__44u9_p7_1[] = {
		 5, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 7, 7,
		 7, 7, 7, 7, 7, 7, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7,
		 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 6, 7, 7, 7,
		 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
		 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
		 7, 7, 7, 7, 8, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
		 7, 8, 8, 7, 7, 7, 7, 7, 7, 7, 8, 7, 8, 8, 7, 7,
		 7, 7, 7, 7, 7, 8, 8, 8, 8,
};

static const static_codebook _44u9_p7_1 = {
		2, 121,
		(long *)_vq_lengthlist__44u9_p7_1,
		1, -531365888, 1611661312, 4, 0,
		(long *)_vq_quantlist__44u9_p7_1,
		0
};

static const long _vq_quantlist__44u9_p8_0[] = {
		7,
		6,
		8,
		5,
		9,
		4,
		10,
		3,
		11,
		2,
		12,
		1,
		13,
		0,
		14,
};

static const long _vq_lengthlist__44u9_p8_0[] = {
		 1, 4, 4, 7, 7, 8, 8, 8, 8, 9, 9,10, 9,11,10, 4,
		 6, 6, 8, 8, 9, 9, 9, 9,10,10,11,10,12,10, 4, 6,
		 6, 8, 8, 9,10, 9, 9,10,10,11,11,12,12, 7, 8, 8,
		10,10,11,11,10,10,11,11,12,12,13,12, 7, 8, 8,10,
		10,11,11,10,10,11,11,12,12,12,13, 8,10, 9,11,11,
		12,12,11,11,12,12,13,13,14,13, 8, 9, 9,11,11,12,
		12,11,12,12,12,13,13,14,13, 8, 9, 9,10,10,12,11,
		13,12,13,13,14,13,15,14, 8, 9, 9,10,10,11,12,12,
		12,13,13,13,14,14,14, 9,10,10,12,11,13,12,13,13,
		14,13,14,14,14,15, 9,10,10,11,12,12,12,13,13,14,
		14,14,15,15,15,10,11,11,12,12,13,13,14,14,14,14,
		15,14,16,15,10,11,11,12,12,13,13,13,14,14,14,14,
		14,15,16,11,12,12,13,13,14,13,14,14,15,14,15,16,
		16,16,11,12,12,13,13,14,13,14,14,15,15,15,16,15,
		15,
};

static const static_codebook _44u9_p8_0 = {
		2, 225,
		(long *)_vq_lengthlist__44u9_p8_0,
		1, -520986624, 1620377600, 4, 0,
		(long *)_vq_quantlist__44u9_p8_0,
		0
};

static const long _vq_quantlist__44u9_p8_1[] = {
		10,
		9,
		11,
		8,
		12,
		7,
		13,
		6,
		14,
		5,
		15,
		4,
		16,
		3,
		17,
		2,
		18,
		1,
		19,
		0,
		20,
};

static const long _vq_lengthlist__44u9_p8_1[] = {
		 4, 6, 6, 7, 7, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9,
		 9, 9, 9, 9, 9, 6, 6, 6, 7, 7, 8, 8, 8, 8, 9, 9,
		 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 6, 6, 6, 7, 7, 8,
		 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 7,
		 7, 7, 8, 8, 8, 8, 9, 8, 9, 9, 9, 9, 9, 9, 9, 9,
		 9, 9, 9, 9, 7, 7, 7, 8, 8, 8, 8, 9, 9, 9, 9, 9,
		 9, 9, 9, 9, 9, 9, 9, 9, 9, 8, 8, 8, 8, 8, 9, 9,
		 9, 9, 9, 9, 9, 9, 9, 9, 9,10, 9,10,10,10, 8, 8,
		 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
		 9,10,10, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
		10, 9,10, 9,10,10,10,10, 8, 8, 8, 9, 9, 9, 9, 9,
		 9, 9, 9, 9, 9,10,10, 9,10,10,10,10,10, 9, 9, 9,
		 9, 9, 9, 9, 9, 9, 9, 9,10, 9,10,10,10,10,10,10,
		10,10, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,10,10,10,
		10,10,10,10,10,10,10, 9, 9, 9, 9, 9, 9, 9, 9, 9,
		 9, 9,10,10,10,10,10,10,10,10,10,10, 9, 9, 9, 9,
		 9, 9, 9, 9, 9, 9, 9,10,10,10,10,10,10,10,10,10,
		10, 9, 9, 9, 9, 9, 9, 9,10, 9,10,10,10,10,10,10,
		10,10,10,10,10,10, 9, 9, 9, 9, 9, 9, 9, 9,10,10,
		10,10,10,10,10,10,10,10,10,10,10, 9, 9, 9, 9, 9,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		 9, 9, 9, 9,10, 9, 9,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10, 9, 9, 9,10, 9,10, 9,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10, 9, 9, 9,10, 9,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10, 9,
		 9, 9, 9, 9,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10, 9, 9, 9,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,
};

static const static_codebook _44u9_p8_1 = {
		2, 441,
		(long *)_vq_lengthlist__44u9_p8_1,
		1, -529268736, 1611661312, 5, 0,
		(long *)_vq_quantlist__44u9_p8_1,
		0
};

static const long _vq_quantlist__44u9_p9_0[] = {
		7,
		6,
		8,
		5,
		9,
		4,
		10,
		3,
		11,
		2,
		12,
		1,
		13,
		0,
		14,
};

static const long _vq_lengthlist__44u9_p9_0[] = {
		 1, 3, 3,11,11,11,11,11,11,11,11,11,11,11,11, 4,
		10,11,11,11,11,11,11,11,11,11,11,11,11,11, 4,10,
		10,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,
};

static const static_codebook _44u9_p9_0 = {
		2, 225,
		(long *)_vq_lengthlist__44u9_p9_0,
		1, -510036736, 1631393792, 4, 0,
		(long *)_vq_quantlist__44u9_p9_0,
		0
};

static const long _vq_quantlist__44u9_p9_1[] = {
		9,
		8,
		10,
		7,
		11,
		6,
		12,
		5,
		13,
		4,
		14,
		3,
		15,
		2,
		16,
		1,
		17,
		0,
		18,
};

static const long _vq_lengthlist__44u9_p9_1[] = {
		 1, 4, 4, 7, 7, 8, 7, 8, 7, 9, 8,10, 9,10,10,11,
		11,12,12, 4, 7, 6, 9, 9,10, 9, 9, 8,10,10,11,10,
		12,10,13,12,13,12, 4, 6, 6, 9, 9, 9, 9, 9, 9,10,
		10,11,11,11,12,12,12,12,12, 7, 9, 8,11,10,10,10,
		11,10,11,11,12,12,13,12,13,13,13,13, 7, 8, 9,10,
		10,11,11,10,10,11,11,11,12,13,13,13,13,14,14, 8,
		 9, 9,11,11,12,11,12,12,13,12,12,13,13,14,15,14,
		14,14, 8, 9, 9,10,11,11,11,12,12,13,12,13,13,14,
		14,14,15,14,16, 8, 9, 9,11,10,12,12,12,12,15,13,
		13,13,17,14,15,15,15,14, 8, 9, 9,10,11,11,12,13,
		12,13,13,13,14,15,14,14,14,16,15, 9,11,10,12,12,
		13,13,13,13,14,14,16,15,14,14,14,15,15,17, 9,10,
		10,11,11,13,13,13,14,14,13,15,14,15,14,15,16,15,
		16,10,11,11,12,12,13,14,15,14,15,14,14,15,17,16,
		15,15,17,17,10,12,11,13,12,14,14,13,14,15,15,15,
		15,16,17,17,15,17,16,11,12,12,14,13,15,14,15,16,
		17,15,17,15,17,15,15,16,17,15,11,11,12,14,14,14,
		14,14,15,15,16,15,17,17,17,16,17,16,15,12,12,13,
		14,14,14,15,14,15,15,16,16,17,16,17,15,17,17,16,
		12,14,12,14,14,15,15,15,14,14,16,16,16,15,16,16,
		15,17,15,12,13,13,14,15,14,15,17,15,17,16,17,17,
		17,16,17,16,17,17,12,13,13,14,16,15,15,15,16,15,
		17,17,15,17,15,17,16,16,17,
};

static const static_codebook _44u9_p9_1 = {
		2, 361,
		(long *)_vq_lengthlist__44u9_p9_1,
		1, -518287360, 1622704128, 5, 0,
		(long *)_vq_quantlist__44u9_p9_1,
		0
};

static const long _vq_quantlist__44u9_p9_2[] = {
		24,
		23,
		25,
		22,
		26,
		21,
		27,
		20,
		28,
		19,
		29,
		18,
		30,
		17,
		31,
		16,
		32,
		15,
		33,
		14,
		34,
		13,
		35,
		12,
		36,
		11,
		37,
		10,
		38,
		9,
		39,
		8,
		40,
		7,
		41,
		6,
		42,
		5,
		43,
		4,
		44,
		3,
		45,
		2,
		46,
		1,
		47,
		0,
		48,
};

static const long _vq_lengthlist__44u9_p9_2[] = {
		 2, 4, 4, 5, 4, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6,
		 6, 6, 6, 7, 6, 7, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7,
		 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
		 7,
};

static const static_codebook _44u9_p9_2 = {
		1, 49,
		(long *)_vq_lengthlist__44u9_p9_2,
		1, -526909440, 1611661312, 6, 0,
		(long *)_vq_quantlist__44u9_p9_2,
		0
};

static const long _huff_lengthlist__44un1__long[] = {
		 5, 6,12, 9,14, 9, 9,19, 6, 1, 5, 5, 8, 7, 9,19,
		12, 4, 4, 7, 7, 9,11,18, 9, 5, 6, 6, 8, 7, 8,17,
		14, 8, 7, 8, 8,10,12,18, 9, 6, 8, 6, 8, 6, 8,18,
		 9, 8,11, 8,11, 7, 5,15,16,18,18,18,17,15,11,18,
};

static const static_codebook _huff_book__44un1__long = {
		2, 64,
		(long *)_huff_lengthlist__44un1__long,
		0, 0, 0, 0, 0,
		NULL,
		0
};

static const long _vq_quantlist__44un1__p1_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__44un1__p1_0[] = {
		 1, 4, 4, 5, 8, 7, 5, 7, 8, 5, 8, 8, 8,10,11, 8,
		10,11, 5, 8, 8, 8,11,10, 8,11,10, 4, 9, 9, 8,11,
		11, 8,11,11, 8,12,11,10,12,14,11,13,13, 7,11,11,
		10,13,11,11,13,14, 4, 8, 9, 8,11,11, 8,11,12, 7,
		11,11,11,14,13,10,11,13, 8,11,12,11,13,13,10,14,
		12,
};

static const static_codebook _44un1__p1_0 = {
		4, 81,
		(long *)_vq_lengthlist__44un1__p1_0,
		1, -535822336, 1611661312, 2, 0,
		(long *)_vq_quantlist__44un1__p1_0,
		0
};

static const long _vq_quantlist__44un1__p2_0[] = {
		1,
		0,
		2,
};

static const long _vq_lengthlist__44un1__p2_0[] = {
		 2, 4, 4, 5, 6, 6, 5, 6, 6, 5, 7, 7, 7, 8, 8, 6,
		 7, 9, 5, 7, 7, 6, 8, 7, 7, 9, 8, 4, 7, 7, 7, 9,
		 8, 7, 8, 8, 7, 9, 8, 8, 8,10, 9,10,10, 6, 8, 8,
		 7,10, 8, 9,10,10, 5, 7, 7, 7, 8, 8, 7, 8, 9, 6,
		 8, 8, 9,10,10, 7, 8,10, 6, 8, 9, 9,10,10, 8,10,
		 8,
};

static const static_codebook _44un1__p2_0 = {
		4, 81,
		(long *)_vq_lengthlist__44un1__p2_0,
		1, -535822336, 1611661312, 2, 0,
		(long *)_vq_quantlist__44un1__p2_0,
		0
};

static const long _vq_quantlist__44un1__p3_0[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__44un1__p3_0[] = {
		 1, 5, 5, 8, 8, 5, 8, 7, 9, 9, 5, 7, 8, 9, 9, 9,
		10, 9,12,12, 9, 9,10,11,12, 6, 8, 8,10,10, 8,10,
		10,11,11, 8, 9,10,11,11,10,11,11,13,13,10,11,11,
		12,13, 6, 8, 8,10,10, 8,10, 9,11,11, 8,10,10,11,
		11,10,11,11,13,12,10,11,11,13,12, 9,11,11,15,13,
		10,12,11,15,13,10,11,11,15,14,12,14,13,16,15,12,
		13,13,17,16, 9,11,11,13,15,10,11,12,14,15,10,11,
		12,14,15,12,13,13,15,16,12,13,13,16,16, 5, 8, 8,
		11,11, 8,10,10,12,12, 8,10,10,12,12,11,12,12,14,
		14,11,12,12,14,14, 8,11,10,13,12,10,11,12,12,13,
		10,12,12,13,13,12,12,13,13,15,11,12,13,15,14, 7,
		10,10,12,12, 9,12,11,13,12,10,12,12,13,14,12,13,
		12,15,13,11,13,12,14,15,10,12,12,16,14,11,12,12,
		16,15,11,13,12,17,16,13,13,15,15,17,13,15,15,20,
		17,10,12,12,14,16,11,12,12,15,15,11,13,13,15,18,
		13,14,13,15,15,13,15,14,16,16, 5, 8, 8,11,11, 8,
		10,10,12,12, 8,10,10,12,12,11,12,12,14,14,11,12,
		12,14,15, 7,10,10,13,12,10,12,12,14,13, 9,10,12,
		12,13,11,13,13,15,15,11,12,13,13,15, 8,10,10,12,
		13,10,12,12,13,13,10,12,11,13,13,11,13,12,15,15,
		12,13,12,15,13,10,12,12,16,14,11,12,12,16,15,10,
		12,12,16,14,14,15,14,18,16,13,13,14,15,16,10,12,
		12,14,16,11,13,13,16,16,11,13,12,14,16,13,15,15,
		18,18,13,15,13,16,14, 8,11,11,16,16,10,13,13,17,
		16,10,12,12,16,15,14,16,15,20,17,13,14,14,17,17,
		 9,12,12,16,16,11,13,14,16,17,11,13,13,16,16,15,
		15,19,18, 0,14,15,15,18,18, 9,12,12,17,16,11,13,
		12,17,16,11,12,13,15,17,15,16,15, 0,19,14,15,14,
		19,18,12,14,14, 0,16,13,14,14,19,18,13,15,16,17,
		16,15,15,17,18, 0,14,16,16,19, 0,12,14,14,16,18,
		13,15,13,17,18,13,15,14,17,18,15,18,14,18,18,16,
		17,16, 0,17, 8,11,11,15,15,10,12,12,16,16,10,13,
		13,16,16,13,15,14,17,17,14,15,17,17,18, 9,12,12,
		16,15,11,13,13,16,16,11,12,13,17,17,14,14,15,17,
		17,14,15,16, 0,18, 9,12,12,16,17,11,13,13,16,17,
		11,14,13,18,17,14,16,14,17,17,15,17,17,18,18,12,
		14,14, 0,16,13,15,15,19, 0,12,13,15, 0, 0,14,17,
		16,19, 0,16,15,18,18, 0,12,14,14,17, 0,13,14,14,
		17, 0,13,15,14, 0,18,15,16,16, 0,18,15,18,15, 0,
		17,
};

static const static_codebook _44un1__p3_0 = {
		4, 625,
		(long *)_vq_lengthlist__44un1__p3_0,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__44un1__p3_0,
		0
};

static const long _vq_quantlist__44un1__p4_0[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__44un1__p4_0[] = {
		 3, 5, 5, 9, 9, 5, 6, 6,10, 9, 5, 6, 6, 9,10,10,
		10,10,12,11, 9,10,10,12,12, 5, 7, 7,10,10, 7, 7,
		 8,10,11, 7, 7, 8,10,11,10,10,11,11,13,10,10,11,
		11,13, 6, 7, 7,10,10, 7, 8, 7,11,10, 7, 8, 7,10,
		10,10,11, 9,13,11,10,11,10,13,11,10,10,10,14,13,
		10,11,11,14,13,10,10,11,13,14,12,12,13,15,15,12,
		12,13,13,14,10,10,10,12,13,10,11,10,13,13,10,11,
		11,13,13,12,13,12,14,13,12,13,13,14,13, 5, 7, 7,
		10,10, 7, 8, 8,11,10, 7, 8, 8,10,10,11,11,11,13,
		13,10,11,11,12,12, 7, 8, 8,11,11, 7, 8, 9,10,12,
		 8, 9, 9,11,11,11,10,12,11,14,11,11,12,13,13, 6,
		 8, 8,10,11, 7, 9, 7,12,10, 8, 9,10,11,12,10,12,
		10,14,11,11,12,11,13,13,10,11,11,14,14,10,10,11,
		13,14,11,12,12,15,13,12,11,14,12,16,12,13,14,15,
		16,10,10,11,13,14,10,11,10,14,12,11,12,12,13,14,
		12,13,11,15,12,14,14,14,15,15, 5, 7, 7,10,10, 7,
		 8, 8,10,10, 7, 8, 8,10,11,10,11,10,12,12,10,11,
		11,12,13, 6, 8, 8,11,11, 8, 9, 9,12,11, 7, 7, 9,
		10,12,11,11,11,12,13,11,10,12,11,15, 7, 8, 8,11,
		11, 8, 9, 9,11,11, 7, 9, 8,12,10,11,12,11,13,12,
		11,12,10,15,11,10,11,10,14,12,11,12,11,14,13,10,
		10,11,13,14,13,13,13,17,15,12,11,14,12,15,10,10,
		11,13,14,11,12,12,14,14,10,11,10,14,13,13,14,13,
		16,17,12,14,11,16,12, 9,10,10,14,13,10,11,10,14,
		14,10,11,11,13,13,13,14,14,16,15,12,13,13,14,14,
		 9,11,10,14,13,10,10,12,13,14,11,12,11,14,13,13,
		14,14,14,15,13,14,14,15,15, 9,10,11,13,14,10,11,
		10,15,13,11,11,12,12,15,13,14,12,15,14,13,13,14,
		14,15,12,13,12,16,14,11,11,12,15,14,13,15,13,16,
		14,13,12,15,12,17,15,16,15,16,16,12,12,13,13,15,
		11,13,11,15,14,13,13,14,15,17,13,14,12, 0,13,14,
		15,14,15, 0, 9,10,10,13,13,10,11,11,13,13,10,11,
		11,13,13,12,13,12,14,14,13,14,14,15,17, 9,10,10,
		13,13,11,12,11,15,12,10,10,11,13,16,13,14,13,15,
		14,13,13,14,15,16,10,10,11,13,14,11,11,12,13,14,
		10,12,11,14,14,13,13,13,14,15,13,15,13,16,15,12,
		13,12,15,13,12,15,13,15,15,11,11,13,14,15,15,15,
		15,15,17,13,12,14,13,17,12,12,14,14,15,13,13,14,
		14,16,11,13,11,16,15,14,16,16,17, 0,14,13,11,16,
		12,
};

static const static_codebook _44un1__p4_0 = {
		4, 625,
		(long *)_vq_lengthlist__44un1__p4_0,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__44un1__p4_0,
		0
};

static const long _vq_quantlist__44un1__p5_0[] = {
		4,
		3,
		5,
		2,
		6,
		1,
		7,
		0,
		8,
};

static const long _vq_lengthlist__44un1__p5_0[] = {
		 1, 4, 4, 7, 7, 8, 8, 9, 9, 4, 6, 5, 8, 7, 8, 8,
		10, 9, 4, 6, 6, 8, 8, 8, 8,10,10, 7, 8, 7, 9, 9,
		 9, 9,11,10, 7, 8, 8, 9, 9, 9, 9,10,11, 8, 8, 8,
		 9, 9,10,10,11,11, 8, 8, 8, 9, 9,10,10,11,11, 9,
		10,10,11,10,11,11,12,12, 9,10,10,10,11,11,11,12,
		12,
};

static const static_codebook _44un1__p5_0 = {
		2, 81,
		(long *)_vq_lengthlist__44un1__p5_0,
		1, -531628032, 1611661312, 4, 0,
		(long *)_vq_quantlist__44un1__p5_0,
		0
};

static const long _vq_quantlist__44un1__p6_0[] = {
		6,
		5,
		7,
		4,
		8,
		3,
		9,
		2,
		10,
		1,
		11,
		0,
		12,
};

static const long _vq_lengthlist__44un1__p6_0[] = {
		 1, 4, 4, 6, 6, 8, 8,10,10,11,11,15,15, 4, 5, 5,
		 8, 8, 9, 9,11,11,12,12,16,16, 4, 5, 6, 8, 8, 9,
		 9,11,11,12,12,14,14, 7, 8, 8, 9, 9,10,10,11,12,
		13,13,16,17, 7, 8, 8, 9, 9,10,10,12,12,12,13,15,
		15, 9,10,10,10,10,11,11,12,12,13,13,15,16, 9, 9,
		 9,10,10,11,11,13,12,13,13,17,17,10,11,11,11,12,
		12,12,13,13,14,15, 0,18,10,11,11,12,12,12,13,14,
		13,14,14,17,16,11,12,12,13,13,14,14,14,14,15,16,
		17,16,11,12,12,13,13,14,14,14,14,15,15,17,17,14,
		15,15,16,16,16,17,17,16, 0,17, 0,18,14,15,15,16,
		16, 0,15,18,18, 0,16, 0, 0,
};

static const static_codebook _44un1__p6_0 = {
		2, 169,
		(long *)_vq_lengthlist__44un1__p6_0,
		1, -526516224, 1616117760, 4, 0,
		(long *)_vq_quantlist__44un1__p6_0,
		0
};

static const long _vq_quantlist__44un1__p6_1[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__44un1__p6_1[] = {
		 2, 4, 4, 5, 5, 4, 5, 5, 5, 5, 4, 5, 5, 6, 5, 5,
		 6, 5, 6, 6, 5, 6, 6, 6, 6,
};

static const static_codebook _44un1__p6_1 = {
		2, 25,
		(long *)_vq_lengthlist__44un1__p6_1,
		1, -533725184, 1611661312, 3, 0,
		(long *)_vq_quantlist__44un1__p6_1,
		0
};

static const long _vq_quantlist__44un1__p7_0[] = {
		2,
		1,
		3,
		0,
		4,
};

static const long _vq_lengthlist__44un1__p7_0[] = {
		 1, 5, 3,11,11,11,11,11,11,11, 8,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,10,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,10,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11, 8,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,10,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11, 7,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,10,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
		10,
};

static const static_codebook _44un1__p7_0 = {
		4, 625,
		(long *)_vq_lengthlist__44un1__p7_0,
		1, -518709248, 1626677248, 3, 0,
		(long *)_vq_quantlist__44un1__p7_0,
		0
};

static const long _vq_quantlist__44un1__p7_1[] = {
		6,
		5,
		7,
		4,
		8,
		3,
		9,
		2,
		10,
		1,
		11,
		0,
		12,
};

static const long _vq_lengthlist__44un1__p7_1[] = {
		 1, 4, 4, 6, 6, 6, 6, 9, 8, 9, 8, 8, 8, 5, 7, 7,
		 7, 7, 8, 8, 8,10, 8,10, 8, 9, 5, 7, 7, 8, 7, 7,
		 8,10,10,11,10,12,11, 7, 8, 8, 9, 9, 9,10,11,11,
		11,11,11,11, 7, 8, 8, 8, 9, 9, 9,10,10,10,11,11,
		12, 7, 8, 8, 9, 9,10,11,11,12,11,12,11,11, 7, 8,
		 8, 9, 9,10,10,11,11,11,12,12,11, 8,10,10,10,10,
		11,11,14,11,12,12,12,13, 9,10,10,10,10,12,11,14,
		11,14,11,12,13,10,11,11,11,11,13,11,14,14,13,13,
		13,14,11,11,11,12,11,12,12,12,13,14,14,13,14,12,
		11,12,12,12,12,13,13,13,14,13,14,14,11,12,12,14,
		12,13,13,12,13,13,14,14,14,
};

static const static_codebook _44un1__p7_1 = {
		2, 169,
		(long *)_vq_lengthlist__44un1__p7_1,
		1, -523010048, 1618608128, 4, 0,
		(long *)_vq_quantlist__44un1__p7_1,
		0
};

static const long _vq_quantlist__44un1__p7_2[] = {
		6,
		5,
		7,
		4,
		8,
		3,
		9,
		2,
		10,
		1,
		11,
		0,
		12,
};

static const long _vq_lengthlist__44un1__p7_2[] = {
		 3, 4, 4, 6, 6, 7, 7, 8, 8, 9, 9, 9, 8, 4, 5, 5,
		 6, 6, 8, 8, 9, 8, 9, 9, 9, 9, 4, 5, 5, 7, 6, 8,
		 8, 8, 8, 9, 8, 9, 8, 6, 7, 7, 7, 8, 8, 8, 9, 9,
		 9, 9, 9, 9, 6, 7, 7, 7, 7, 8, 8, 9, 9, 9, 9, 9,
		 9, 7, 8, 8, 8, 8, 9, 8, 9, 9,10, 9, 9,10, 7, 8,
		 8, 8, 8, 9, 9, 9, 9, 9, 9,10,10, 8, 9, 9, 9, 9,
		 9, 9, 9, 9,10,10, 9,10, 8, 9, 9, 9, 9, 9, 9, 9,
		 9, 9, 9,10,10, 9, 9, 9,10, 9, 9,10, 9, 9,10,10,
		10,10, 9, 9, 9, 9, 9, 9, 9,10, 9,10,10,10,10, 9,
		 9, 9,10, 9, 9,10,10, 9,10,10,10,10, 9, 9, 9,10,
		 9, 9, 9,10,10,10,10,10,10,
};

static const static_codebook _44un1__p7_2 = {
		2, 169,
		(long *)_vq_lengthlist__44un1__p7_2,
		1, -531103744, 1611661312, 4, 0,
		(long *)_vq_quantlist__44un1__p7_2,
		0
};

static const long _huff_lengthlist__44un1__short[] = {
		12,12,14,12,14,14,14,14,12, 6, 6, 8, 9, 9,11,14,
		12, 4, 2, 6, 6, 7,11,14,13, 6, 5, 7, 8, 9,11,14,
		13, 8, 5, 8, 6, 8,12,14,12, 7, 7, 8, 8, 8,10,14,
		12, 6, 3, 4, 4, 4, 7,14,11, 7, 4, 6, 6, 6, 8,14,
};

static const static_codebook _huff_book__44un1__short = {
		2, 64,
		(long *)_huff_lengthlist__44un1__short,
		0, 0, 0, 0, 0,
		NULL,
		0
};

/*** End of inlined file: res_books_uncoupled.h ***/

/***** residue backends *********************************************/

static const vorbis_info_residue0 _residue_44_low_un={
  0,-1, -1, 8,-1,-1,
  {0},
  {-1},
  {  0,  1,  1,  2,  2,  4, 28},
  { -1, 25, -1, 45, -1, -1, -1}
};

static const vorbis_info_residue0 _residue_44_mid_un={
  0,-1, -1, 10,-1,-1,
  /* 0   1   2   3   4   5   6   7   8   9 */
  {0},
  {-1},
  {  0,  1,  1,  2,  2,  4,  4, 16, 60},
  { -1, 30, -1, 50, -1, 80, -1, -1, -1}
};

static const vorbis_info_residue0 _residue_44_hi_un={
  0,-1, -1, 10,-1,-1,
  /* 0   1   2   3   4   5   6   7   8   9 */
  {0},
  {-1},
  {  0,  1,  2,  4,  8, 16, 32, 71,157},
  { -1, -1, -1, -1, -1, -1, -1, -1, -1}
};

/* mapping conventions:
   only one submap (this would change for efficient 5.1 support for example)*/
/* Four psychoacoustic profiles are used, one for each blocktype */
static const vorbis_info_mapping0 _map_nominal_u[2]={
  {1, {0,0,0,0,0,0}, {0}, {0}, 0,{0},{0}},
  {1, {0,0,0,0,0,0}, {1}, {1}, 0,{0},{0}}
};

static const static_bookblock _resbook_44u_n1={
  {
	{0},
	{0,0,&_44un1__p1_0},
	{0,0,&_44un1__p2_0},
	{0,0,&_44un1__p3_0},
	{0,0,&_44un1__p4_0},
	{0,0,&_44un1__p5_0},
	{&_44un1__p6_0,&_44un1__p6_1},
	{&_44un1__p7_0,&_44un1__p7_1,&_44un1__p7_2}
   }
};
static const static_bookblock _resbook_44u_0={
  {
	{0},
	{0,0,&_44u0__p1_0},
	{0,0,&_44u0__p2_0},
	{0,0,&_44u0__p3_0},
	{0,0,&_44u0__p4_0},
	{0,0,&_44u0__p5_0},
	{&_44u0__p6_0,&_44u0__p6_1},
	{&_44u0__p7_0,&_44u0__p7_1,&_44u0__p7_2}
   }
};
static const static_bookblock _resbook_44u_1={
  {
	{0},
	{0,0,&_44u1__p1_0},
	{0,0,&_44u1__p2_0},
	{0,0,&_44u1__p3_0},
	{0,0,&_44u1__p4_0},
	{0,0,&_44u1__p5_0},
	{&_44u1__p6_0,&_44u1__p6_1},
	{&_44u1__p7_0,&_44u1__p7_1,&_44u1__p7_2}
   }
};
static const static_bookblock _resbook_44u_2={
  {
	{0},
	{0,0,&_44u2__p1_0},
	{0,0,&_44u2__p2_0},
	{0,0,&_44u2__p3_0},
	{0,0,&_44u2__p4_0},
	{0,0,&_44u2__p5_0},
	{&_44u2__p6_0,&_44u2__p6_1},
	{&_44u2__p7_0,&_44u2__p7_1,&_44u2__p7_2}
   }
};
static const static_bookblock _resbook_44u_3={
  {
	{0},
	{0,0,&_44u3__p1_0},
	{0,0,&_44u3__p2_0},
	{0,0,&_44u3__p3_0},
	{0,0,&_44u3__p4_0},
	{0,0,&_44u3__p5_0},
	{&_44u3__p6_0,&_44u3__p6_1},
	{&_44u3__p7_0,&_44u3__p7_1,&_44u3__p7_2}
   }
};
static const static_bookblock _resbook_44u_4={
  {
	{0},
	{0,0,&_44u4__p1_0},
	{0,0,&_44u4__p2_0},
	{0,0,&_44u4__p3_0},
	{0,0,&_44u4__p4_0},
	{0,0,&_44u4__p5_0},
	{&_44u4__p6_0,&_44u4__p6_1},
	{&_44u4__p7_0,&_44u4__p7_1,&_44u4__p7_2}
   }
};
static const static_bookblock _resbook_44u_5={
  {
	{0},
	{0,0,&_44u5__p1_0},
	{0,0,&_44u5__p2_0},
	{0,0,&_44u5__p3_0},
	{0,0,&_44u5__p4_0},
	{0,0,&_44u5__p5_0},
	{0,0,&_44u5__p6_0},
	{&_44u5__p7_0,&_44u5__p7_1},
	{&_44u5__p8_0,&_44u5__p8_1},
	{&_44u5__p9_0,&_44u5__p9_1,&_44u5__p9_2}
   }
};
static const static_bookblock _resbook_44u_6={
  {
	{0},
	{0,0,&_44u6__p1_0},
	{0,0,&_44u6__p2_0},
	{0,0,&_44u6__p3_0},
	{0,0,&_44u6__p4_0},
	{0,0,&_44u6__p5_0},
	{0,0,&_44u6__p6_0},
	{&_44u6__p7_0,&_44u6__p7_1},
	{&_44u6__p8_0,&_44u6__p8_1},
	{&_44u6__p9_0,&_44u6__p9_1,&_44u6__p9_2}
   }
};
static const static_bookblock _resbook_44u_7={
  {
	{0},
	{0,0,&_44u7__p1_0},
	{0,0,&_44u7__p2_0},
	{0,0,&_44u7__p3_0},
	{0,0,&_44u7__p4_0},
	{0,0,&_44u7__p5_0},
	{0,0,&_44u7__p6_0},
	{&_44u7__p7_0,&_44u7__p7_1},
	{&_44u7__p8_0,&_44u7__p8_1},
	{&_44u7__p9_0,&_44u7__p9_1,&_44u7__p9_2}
   }
};
static const static_bookblock _resbook_44u_8={
  {
	{0},
	{0,0,&_44u8_p1_0},
	{0,0,&_44u8_p2_0},
	{0,0,&_44u8_p3_0},
	{0,0,&_44u8_p4_0},
	{&_44u8_p5_0,&_44u8_p5_1},
	{&_44u8_p6_0,&_44u8_p6_1},
	{&_44u8_p7_0,&_44u8_p7_1},
	{&_44u8_p8_0,&_44u8_p8_1},
	{&_44u8_p9_0,&_44u8_p9_1,&_44u8_p9_2}
   }
};
static const static_bookblock _resbook_44u_9={
  {
	{0},
	{0,0,&_44u9_p1_0},
	{0,0,&_44u9_p2_0},
	{0,0,&_44u9_p3_0},
	{0,0,&_44u9_p4_0},
	{&_44u9_p5_0,&_44u9_p5_1},
	{&_44u9_p6_0,&_44u9_p6_1},
	{&_44u9_p7_0,&_44u9_p7_1},
	{&_44u9_p8_0,&_44u9_p8_1},
	{&_44u9_p9_0,&_44u9_p9_1,&_44u9_p9_2}
   }
};

static const vorbis_residue_template _res_44u_n1[]={
  {1,0,32,  &_residue_44_low_un,
   &_huff_book__44un1__short,&_huff_book__44un1__short,
   &_resbook_44u_n1,&_resbook_44u_n1},

  {1,0,32,  &_residue_44_low_un,
   &_huff_book__44un1__long,&_huff_book__44un1__long,
   &_resbook_44u_n1,&_resbook_44u_n1}
};
static const vorbis_residue_template _res_44u_0[]={
  {1,0,16,  &_residue_44_low_un,
   &_huff_book__44u0__short,&_huff_book__44u0__short,
   &_resbook_44u_0,&_resbook_44u_0},

  {1,0,32,  &_residue_44_low_un,
   &_huff_book__44u0__long,&_huff_book__44u0__long,
   &_resbook_44u_0,&_resbook_44u_0}
};
static const vorbis_residue_template _res_44u_1[]={
  {1,0,16,  &_residue_44_low_un,
   &_huff_book__44u1__short,&_huff_book__44u1__short,
   &_resbook_44u_1,&_resbook_44u_1},

  {1,0,32,  &_residue_44_low_un,
   &_huff_book__44u1__long,&_huff_book__44u1__long,
   &_resbook_44u_1,&_resbook_44u_1}
};
static const vorbis_residue_template _res_44u_2[]={
  {1,0,16,  &_residue_44_low_un,
   &_huff_book__44u2__short,&_huff_book__44u2__short,
   &_resbook_44u_2,&_resbook_44u_2},

  {1,0,32,  &_residue_44_low_un,
   &_huff_book__44u2__long,&_huff_book__44u2__long,
   &_resbook_44u_2,&_resbook_44u_2}
};
static const vorbis_residue_template _res_44u_3[]={
  {1,0,16,  &_residue_44_low_un,
   &_huff_book__44u3__short,&_huff_book__44u3__short,
   &_resbook_44u_3,&_resbook_44u_3},

  {1,0,32,  &_residue_44_low_un,
   &_huff_book__44u3__long,&_huff_book__44u3__long,
   &_resbook_44u_3,&_resbook_44u_3}
};
static const vorbis_residue_template _res_44u_4[]={
  {1,0,16,  &_residue_44_low_un,
   &_huff_book__44u4__short,&_huff_book__44u4__short,
   &_resbook_44u_4,&_resbook_44u_4},

  {1,0,32,  &_residue_44_low_un,
   &_huff_book__44u4__long,&_huff_book__44u4__long,
   &_resbook_44u_4,&_resbook_44u_4}
};

static const vorbis_residue_template _res_44u_5[]={
  {1,0,16,  &_residue_44_mid_un,
   &_huff_book__44u5__short,&_huff_book__44u5__short,
   &_resbook_44u_5,&_resbook_44u_5},

  {1,0,32,  &_residue_44_mid_un,
   &_huff_book__44u5__long,&_huff_book__44u5__long,
   &_resbook_44u_5,&_resbook_44u_5}
};

static const vorbis_residue_template _res_44u_6[]={
  {1,0,16,  &_residue_44_mid_un,
   &_huff_book__44u6__short,&_huff_book__44u6__short,
   &_resbook_44u_6,&_resbook_44u_6},

  {1,0,32,  &_residue_44_mid_un,
   &_huff_book__44u6__long,&_huff_book__44u6__long,
   &_resbook_44u_6,&_resbook_44u_6}
};

static const vorbis_residue_template _res_44u_7[]={
  {1,0,16,  &_residue_44_mid_un,
   &_huff_book__44u7__short,&_huff_book__44u7__short,
   &_resbook_44u_7,&_resbook_44u_7},

  {1,0,32,  &_residue_44_mid_un,
   &_huff_book__44u7__long,&_huff_book__44u7__long,
   &_resbook_44u_7,&_resbook_44u_7}
};

static const vorbis_residue_template _res_44u_8[]={
  {1,0,16,  &_residue_44_hi_un,
   &_huff_book__44u8__short,&_huff_book__44u8__short,
   &_resbook_44u_8,&_resbook_44u_8},

  {1,0,32,  &_residue_44_hi_un,
   &_huff_book__44u8__long,&_huff_book__44u8__long,
   &_resbook_44u_8,&_resbook_44u_8}
};
static const vorbis_residue_template _res_44u_9[]={
  {1,0,16,  &_residue_44_hi_un,
   &_huff_book__44u9__short,&_huff_book__44u9__short,
   &_resbook_44u_9,&_resbook_44u_9},

  {1,0,32,  &_residue_44_hi_un,
   &_huff_book__44u9__long,&_huff_book__44u9__long,
   &_resbook_44u_9,&_resbook_44u_9}
};

static const vorbis_mapping_template _mapres_template_44_uncoupled[]={
  { _map_nominal_u, _res_44u_n1 }, /* -1 */
  { _map_nominal_u, _res_44u_0 }, /* 0 */
  { _map_nominal_u, _res_44u_1 }, /* 1 */
  { _map_nominal_u, _res_44u_2 }, /* 2 */
  { _map_nominal_u, _res_44u_3 }, /* 3 */
  { _map_nominal_u, _res_44u_4 }, /* 4 */
  { _map_nominal_u, _res_44u_5 }, /* 5 */
  { _map_nominal_u, _res_44u_6 }, /* 6 */
  { _map_nominal_u, _res_44u_7 }, /* 7 */
  { _map_nominal_u, _res_44u_8 }, /* 8 */
  { _map_nominal_u, _res_44u_9 }, /* 9 */
};

/*** End of inlined file: residue_44u.h ***/

static const double rate_mapping_44_un[12]={
  32000.,48000.,60000.,70000.,80000.,86000.,
  96000.,110000.,120000.,140000.,160000.,240001.
};

static const ve_setup_data_template ve_setup_44_uncoupled={
  11,
  rate_mapping_44_un,
  quality_mapping_44,
  -1,
  40000,
  50000,

  blocksize_short_44,
  blocksize_long_44,

  _psy_tone_masteratt_44,
  _psy_tone_0dB,
  _psy_tone_suppress,

  _vp_tonemask_adj_otherblock,
  _vp_tonemask_adj_longblock,
  _vp_tonemask_adj_otherblock,

  _psy_noiseguards_44,
  _psy_noisebias_impulse,
  _psy_noisebias_padding,
  _psy_noisebias_trans,
  _psy_noisebias_long,
  _psy_noise_suppress,

  _psy_compand_44,
  _psy_compand_short_mapping,
  _psy_compand_long_mapping,

  {_noise_start_short_44,_noise_start_long_44},
  {_noise_part_short_44,_noise_part_long_44},
  _noise_thresh_44,

  _psy_ath_floater,
  _psy_ath_abs,

  _psy_lowpass_44,

  _psy_global_44,
  _global_mapping_44,
  _psy_stereo_modes_44,

  _floor_books,
  _floor,
  2,
  _floor_mapping_44,

  _mapres_template_44_uncoupled
};

/*** End of inlined file: setup_44u.h ***/


/*** Start of inlined file: setup_44p51.h ***/

/*** Start of inlined file: residue_44p51.h ***/

/*** Start of inlined file: res_books_51.h ***/
static const long _vq_quantlist__44p0_l0_0[] = {
	6,
	5,
	7,
	4,
	8,
	3,
	9,
	2,
	10,
	1,
	11,
	0,
	12,
};

static const long _vq_lengthlist__44p0_l0_0[] = {
	 1, 3, 4, 7, 7, 8, 8, 9, 9, 9,10,10,10, 5, 6, 5,
	 8, 7, 9, 8, 9, 9,10, 9,11,10, 5, 5, 7, 7, 8, 8,
	 9, 9, 9, 9,10,10,11, 8, 9, 8,10, 9,10, 9,10, 9,
	11,10,11,10, 8, 8, 9, 9,10, 9,10, 9,11,10,11,10,
	11,10,11,11,11,11,11,11,11,11,11,11,11,11,10,11,
	11,11,12,11,11,11,11,11,11,10,12,12,12,12,12,12,
	12,11,12,12,12,11,11,11,12,12,12,12,12,12,12,11,
	12,11,12,11,11,13,12,12,12,13,12,12,12,12,11,12,
	11,11,13,13,13,12,12,12,12,12,12,11,11,11,10,13,
	13,13,12,13,12,13,11,13,10,12,11,11,13,13,12,13,
	12,12,12,12,11,12,11,11,11,
};

static const static_codebook _44p0_l0_0 = {
	2, 169,
	(long *)_vq_lengthlist__44p0_l0_0,
	1, -526516224, 1616117760, 4, 0,
	(long *)_vq_quantlist__44p0_l0_0,
	0
};

static const long _vq_quantlist__44p0_l0_1[] = {
	2,
	1,
	3,
	0,
	4,
};

static const long _vq_lengthlist__44p0_l0_1[] = {
	 1, 4, 4, 6, 6, 5, 5, 5, 7, 5, 5, 5, 5, 6, 7, 7,
	 6, 7, 7, 7, 6, 7, 7, 7, 7,
};

static const static_codebook _44p0_l0_1 = {
	2, 25,
	(long *)_vq_lengthlist__44p0_l0_1,
	1, -533725184, 1611661312, 3, 0,
	(long *)_vq_quantlist__44p0_l0_1,
	0
};

static const long _vq_quantlist__44p0_l1_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p0_l1_0[] = {
	 1, 4, 4, 4, 4, 4, 4, 4, 4,
};

static const static_codebook _44p0_l1_0 = {
	2, 9,
	(long *)_vq_lengthlist__44p0_l1_0,
	1, -516716544, 1630767104, 2, 0,
	(long *)_vq_quantlist__44p0_l1_0,
	0
};

static const long _huff_lengthlist__44p0_lfe[] = {
	 1, 3, 2, 3,
};

static const static_codebook _huff_book__44p0_lfe = {
	2, 4,
	(long *)_huff_lengthlist__44p0_lfe,
	0, 0, 0, 0, 0,
	NULL,
	0
};

static const long _huff_lengthlist__44p0_long[] = {
	 2, 3, 6, 7,10,14,16, 3, 2, 5, 7,11,14,17, 6, 5,
	 5, 7,10,12,14, 7, 7, 6, 6, 7, 9,13,10,11, 9, 6,
	 6, 9,11,15,15,13,10, 9,10,12,18,18,16,14,12,13,
	16,
};

static const static_codebook _huff_book__44p0_long = {
	2, 49,
	(long *)_huff_lengthlist__44p0_long,
	0, 0, 0, 0, 0,
	NULL,
	0
};

static const long _vq_quantlist__44p0_p1_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p0_p1_0[] = {
	 1, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0,
};

static const static_codebook _44p0_p1_0 = {
	5, 243,
	(long *)_vq_lengthlist__44p0_p1_0,
	1, -535822336, 1611661312, 2, 0,
	(long *)_vq_quantlist__44p0_p1_0,
	0
};

static const long _vq_quantlist__44p0_p2_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p0_p2_0[] = {
	 1, 5, 5, 0, 7, 7, 0, 8, 8, 0, 9, 9, 0,12,12, 0,
	 8, 8, 0, 9, 9, 0,12,12, 0, 8, 8, 0, 6, 6, 0,11,
	11, 0,12,12, 0,12,12, 0,15,15, 0,11,11, 0,12,12,
	 0,15,15, 0,12,12, 0, 5, 5, 0, 5, 5, 0, 6, 6, 0,
	 7, 7, 0,11,11, 0, 6, 6, 0, 7, 7, 0,10,11, 0, 6,
	 6, 0, 7, 7, 0,11,11, 0,12,12, 0,11,11, 0,15,15,
	 0,10,10, 0,12,12, 0,15,15, 0,12,12, 0, 6, 6, 0,
	12,12, 0,12,12, 0,12,12, 0,15,15, 0,11,11, 0,12,
	12, 0,15,15, 0,12,12, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 8, 8, 0,12,12, 0,12,12, 0,12,12, 0,15,
	15, 0,12,12, 0,11,12, 0,15,16, 0,11,11, 0, 6, 6,
	 0,11,12, 0,12,12, 0,12,12, 0,16,15, 0,12,12, 0,
	13,12, 0,15,14, 0,12,12, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0,
};

static const static_codebook _44p0_p2_0 = {
	5, 243,
	(long *)_vq_lengthlist__44p0_p2_0,
	1, -533200896, 1614282752, 2, 0,
	(long *)_vq_quantlist__44p0_p2_0,
	0
};

static const long _vq_quantlist__44p0_p2_1[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p0_p2_1[] = {
	 1, 3, 3, 0, 9, 9, 0, 9, 9, 0,10,10, 0, 9, 9, 0,
	10,10, 0,10,10, 0, 9, 9, 0,10,10, 0, 7, 7, 0, 7,
	 7, 0, 6, 6, 0, 8, 8, 0, 7, 7, 0, 8, 8, 0, 8, 9,
	 0, 8, 8, 0, 8, 8, 0, 7, 7, 0, 9, 9, 0, 8, 8, 0,
	10,10, 0, 9, 9, 0,10,10, 0,10,10, 0, 9, 9, 0,10,
	10, 0, 9, 9, 0,11,11, 0,11,11, 0,12,12, 0,11,11,
	 0,12,12, 0,13,13, 0,12,12, 0,13,12, 0, 8, 8, 0,
	12,12, 0,12,12, 0,13,13, 0,12,12, 0,13,13, 0,13,
	13, 0,13,13, 0,13,13, 0, 7, 7, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 9, 9, 0,11,11, 0,12,12, 0,13,13, 0,12,
	12, 0,13,13, 0,13,13, 0,12,12, 0,12,12, 0, 8, 8,
	 0,12,12, 0,12,12, 0,13,13, 0,13,13, 0,13,14, 0,
	14,13, 0,13,13, 0,13,13, 0, 7, 7, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0,
};

static const static_codebook _44p0_p2_1 = {
	5, 243,
	(long *)_vq_lengthlist__44p0_p2_1,
	1, -535822336, 1611661312, 2, 0,
	(long *)_vq_quantlist__44p0_p2_1,
	0
};

static const long _vq_quantlist__44p0_p3_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p0_p3_0[] = {
	 1, 6, 6, 7, 8, 8, 7, 8, 8, 7, 9, 9,10,12,11, 9,
	 8, 8, 7, 9, 9,11,12,12, 9, 9, 9, 6, 7, 7,10,11,
	11,10,11,11,10,11,11,13,13,14,12,12,12,11,11,11,
	14,14,14,12,12,12, 6, 5, 5, 9, 6, 5, 9, 6, 6, 9,
	 7, 7,12,10,10,11, 6, 6,10, 7, 7,13,10,10,12, 7,
	 7, 7, 8, 8,12,10,10,12,10,10,11,10,10,15,13,13,
	13, 9, 9,12,11,11,16,13,13,15,11,11, 8, 7, 7,12,
	12,12,12,11,11,12,11,11,14,14,14,14,12,12,12,12,
	12,16,15,15,14,12,12, 0,10,10, 0,12,12, 0,12,12,
	 0,11,11, 0,14,14, 0,11,11, 0,12,12, 0,15,15, 0,
	11,11, 8, 8, 8,13,11,11,13,10,10,13,11,11,15,13,
	13,14,11,11,12,10,10,16,14,14,14,10,10, 9, 7, 7,
	13,11,11,13,11,11,12,11,11,16,14,14,14,12,12,13,
	12,12,15,14,14,15,13,12, 0,11,11, 0,12,12, 0,12,
	12, 0,12,12, 0,15,15, 0,12,12, 0,13,12, 0,14,15,
	 0,12,12,
};

static const static_codebook _44p0_p3_0 = {
	5, 243,
	(long *)_vq_lengthlist__44p0_p3_0,
	1, -531365888, 1616117760, 2, 0,
	(long *)_vq_quantlist__44p0_p3_0,
	0
};

static const long _vq_quantlist__44p0_p3_1[] = {
	2,
	1,
	3,
	0,
	4,
};

static const long _vq_lengthlist__44p0_p3_1[] = {
	 2, 4, 4, 8, 8,10,12,12,11,11, 9,11,11,12,13,11,
	12,12,11,11,11,12,12,12,12,10,13,12,13,13,11,12,
	12,13,13,11,12,12,13,13,11,12,13,13,13,11,13,13,
	13,13,10,13,13,12,13,11,12,12,14,14,11,13,12,12,
	12,11,12,12,13,13,11,13,13,12,12,11,13,13,13,13,
	11,12,12,13,13,11,13,13,12,12,11,12,12,13,13,11,
	13,13,12,12,11,13,13,13,13,11,12,12,14,14,11,13,
	13,12,12,11,12,12,13,13,11,13,13,12,12,11,10,10,
	10,10,12,10,10,11,11,11, 8, 8,11,11,13,10,10,10,
	10,12,10,10,10,10,13,11,11,11,11,13,10,10,11,11,
	13,11,11,12,12,13,11,11,11,11,13,11,11,12,12,13,
	11,11,12,12,13,10,10,11,11,13,11,11,11,11,13,11,
	10,11,11,13,11,11,11,11,13,11,11,11,11,13,10,10,
	11,11,13,11,11,11,11,12,10,11,11,11,13,11,11,11,
	11,13,11,11,11,11,13,10,10,11,11,13,11,11,11,11,
	13,11,11,11,11,13,11,11,11,11,11,10,10,10,10,12,
	10,10, 9, 9,12,12,12,11,11,13,12,12, 9, 9,13,12,
	12,10,10,12,12,12,12,12,13,13,13,14,14,13,12,12,
	11,11,13,13,13,12,12,13,12,12,11,11,13,12,13,11,
	11,13,13,13,14,14,13,12,12,10,10,13,13,13,11,11,
	13,12,12,10,10,13,13,13,11,11,13,13,13,14,14,13,
	12,12,10,10,13,13,13,11,11,13,12,13,10,10,13,13,
	13,11,11,13,13,13,14,14,13,12,12,10,10,13,13,13,
	11,11,13,13,12,10,10,14,12,12, 8, 8,14,12,12, 9,
	 9,14,11,11, 9, 9,14,12,12, 8, 8,14,11,11, 7, 7,
	14,13,13,10,10,15,12,12,10,10,15,13,13,10,10,15,
	12,12, 9, 9,15,13,13,10,10,15,13,13,10,10,15,12,
	12,10,10,15,13,13,10,10,14,12,12, 9, 9,14,13,13,
	 9, 9,14,13,13, 9, 9,15,12,12, 9, 9,15,13,13, 9,
	 9,14,12,12, 9, 9,14,13,13, 9, 9,14,13,13, 9, 9,
	15,12,12, 9, 9,14,13,13, 9, 9,14,12,12, 9, 9,14,
	13,13, 9, 9,13,12,12, 8, 8,13,13,13, 8, 8,14,13,
	13, 9, 9,13,13,13, 7, 7,14,13,13, 8, 8,14,14,14,
	10,10,14,14,14,11,11,14,14,14, 9, 9,14,14,14,10,
	10,14,14,14, 9, 9,14,14,14,10, 9,15,14,14,11,11,
	14,14,14, 9, 9,14,14,14,10,10,14,14,14, 9, 9,14,
	14,14, 9, 9,15,14,14,11,11,14,14,14, 8, 8,14,14,
	14, 9, 9,14,14,14, 8, 8,14,14,14, 9, 9,15,14,14,
	11,11,14,14,14, 8, 8,14,14,14, 9, 9,14,14,14, 8,
	 8,12,12,12,13,13,16,15,15,11,11,16,15,16,12,12,
	17,16,16,11,11,17,15,15,12,11,16,16,16,12,13,16,
	15,15,13,13,16,16,16,12,12,16,16,15,13,13,16,16,
	16,12,12,16,16,16,13,13,17,16,16,14,14,17,17,16,
	12,12,17,16,16,13,13,17,17,16,12,13,16,16,17,13,
	12,17,16,16,14,13,17,16,16,12,12,17,16,16,12,12,
	17,16,17,12,12,17,17,17,13,13,16,16,16,13,14,17,
	17,16,12,12,16,16,16,13,13,17,17,17,12,12,13,14,
	14,10,10,16,14,14,12,12,16,15,15,14,14,16,14,14,
	12,12,15,14,14,13,13,17,15,15,14,13,16,16,15,15,
	15,16,15,15,14,14,16,15,15,14,14,17,15,15,14,14,
	16,15,15,14,14,16,16,15,15,15,17,15,15,13,13,16,
	15,15,14,14,17,15,15,13,13,17,15,15,14,14,16,15,
	15,15,15,16,14,14,13,13,16,15,15,14,14,16,14,14,
	13,13,17,15,15,14,14,16,16,15,15,15,17,14,14,13,
	13,16,15,15,14,14,17,14,14,13,13,13,11,11,10,10,
	16,14,14,13,13,15,14,14,13,13,16,14,14,12,12,16,
	14,14,12,12,15,15,15,14,14,16,14,14,14,14,16,15,
	14,14,14,16,14,14,14,14,16,15,15,14,13,16,15,15,
	14,14,16,14,14,14,14,17,15,15,14,14,16,14,14,14,
	14,16,15,15,13,14,16,15,15,14,14,16,14,14,14,14,
	16,15,15,13,13,16,14,14,13,13,16,15,15,13,13,16,
	15,15,14,14,16,14,14,14,14,17,15,15,13,13,16,15,
	14,13,13,17,15,15,13,13,14,14,14, 9, 9,14,14,14,
	17,17,14,15,15,18,18,14,14,14,18,19,14,14,14,18,
	18,15,15,15,19,18,15,16,15,18,20,15,15,15,18,19,
	15,15,15,19,19,15,15,15,18,20,15,15,15,18,19,15,
	15,16,20,18,15,15,15,18,18,15,15,15,19,19,15,15,
	15,18,19,15,15,15,18,19,15,15,15,19,19,14,15,14,
	19,19,15,15,15,20,19,15,14,14,19,18,14,15,15,18,
	19,15,15,16,20,20,14,14,14,18,19,15,15,15,19,18,
	14,14,14,18,18,14,12,12, 9, 9,13,14,14,18,18,14,
	13,13,18,19,14,14,14,18,18,14,14,14,18,18,15,15,
	15,19,19,15,14,14,19,18,14,15,15,19,18,15,14,14,
	18,18,15,15,15,19,18,14,15,15,19,19,15,14,14,19,
	18,14,15,15,19,18,15,14,14,19,18,14,15,15,19,18,
	15,15,15,21,18,15,14,14,19,18,14,15,15,18,19,14,
	15,14,20,19,14,15,15,18,19,14,15,15,19,19,15,14,
	14,19,20,14,15,15,18,18,14,14,14,19,19,14,15,15,
	19,18,12,12,12,13,13,16,15,15,11,11,16,15,15,12,
	12,16,16,16,11,11,16,15,15,11,11,16,16,16,13,13,
	17,16,16,13,13,17,17,17,12,12,16,16,16,13,13,17,
	16,17,13,12,15,16,16,12,12,16,15,15,13,13,17,16,
	16,12,12,16,16,15,12,12,16,16,16,12,12,17,17,16,
	13,12,16,16,16,13,13,17,16,16,12,12,17,16,16,12,
	12,17,17,16,12,12,16,17,16,12,12,17,15,15,13,13,
	17,16,16,12,12,16,16,16,12,12,16,16,16,12,12,13,
	13,13, 9, 9,15,14,14,13,13,16,15,14,14,14,16,14,
	14,13,13,15,14,14,13,13,17,15,15,14,14,16,15,15,
	15,15,16,15,15,14,14,16,15,15,15,15,17,15,15,14,
	14,16,15,15,14,14,16,15,15,15,15,17,14,15,14,14,
	16,15,15,14,14,17,15,15,13,14,17,15,15,14,14,16,
	15,15,15,15,17,14,14,13,13,16,15,15,14,14,17,14,
	14,13,13,17,15,15,14,14,16,15,16,15,15,17,14,14,
	13,13,16,15,15,14,14,18,14,14,13,13,13,11,11,11,
	11,15,14,14,12,12,15,14,14,13,13,16,14,14,12,12,
	16,13,14,12,12,16,15,15,13,13,16,14,14,14,14,16,
	15,15,13,13,16,14,14,13,13,16,14,15,13,13,15,15,
	15,13,13,16,14,14,14,13,16,14,14,13,13,16,14,14,
	13,13,16,15,15,13,13,16,15,15,13,13,16,14,14,14,
	14,16,15,15,12,12,16,14,14,13,13,16,15,15,12,12,
	16,15,15,13,13,16,14,14,14,14,17,15,14,12,12,16,
	14,14,13,13,16,15,15,12,12,14,14,14, 8, 8,14,14,
	14,17,18,14,15,15,17,18,14,14,14,17,18,14,14,14,
	18,18,14,15,15,18,18,14,16,15,19,19,15,15,15,18,
	19,15,16,15,20,19,15,15,15,18,18,14,15,15,18,19,
	15,16,16,20,19,15,15,15,19,17,14,15,15,20,18,14,
	15,15,18,18,14,15,15,18,19,14,15,15,19,20,14,14,
	14,18,18,14,15,15,18,19,14,14,14,18,19,14,15,15,
	19,18,15,16,16,20,21,14,14,15,19,19,14,15,15,19,
	19,14,14,14,19,18,13,12,12, 9, 9,13,14,14,18,19,
	14,14,14,18,19,14,14,14,18,18,14,14,14,18,18,14,
	15,15,19,19,15,14,14,19,18,15,15,15,19,19,15,14,
	14,19,20,14,15,15,18,19,14,15,15,20,18,15,14,14,
	18,18,14,15,15,18,18,14,14,14,19,19,14,15,15,18,
	18,14,15,15,19,18,15,14,14,19,19,14,15,15,19,18,
	15,14,14,19,18,14,14,15,18,19,14,15,15,19,18,15,
	14,14,18,19,14,15,14,19,20,14,14,14,19,19,14,15,
	15,19,19,12,12,12,13,13,16,16,16,11,11,16,16,16,
	12,12,17,16,16,11,11,17,15,15,11,11,16,16,16,13,
	13,17,15,16,13,13,16,16,16,12,12,17,16,16,13,13,
	17,17,16,12,12,17,17,16,13,13,17,16,16,13,13,17,
	17,17,12,12,17,16,16,13,13,17,17,17,12,12,16,16,
	16,12,12,17,15,15,13,13,17,16,16,11,11,17,16,16,
	12,12,16,16,16,11,11,16,17,16,12,12,17,16,16,13,
	13,17,17,16,12,12,17,17,16,12,12,17,16,16,11,11,
	13,14,14, 9, 9,16,14,14,13,13,16,14,15,14,14,16,
	14,14,12,12,16,14,14,13,13,17,15,15,14,14,16,15,
	15,15,15,17,15,15,14,14,16,15,15,14,14,17,15,15,
	14,14,16,15,15,14,14,16,15,15,15,16,17,14,15,14,
	14,16,15,15,14,14,17,15,15,14,14,16,15,15,14,14,
	16,15,15,15,15,17,14,14,13,13,16,15,15,14,14,16,
	14,14,13,13,17,15,15,14,14,16,16,15,15,15,17,14,
	14,13,13,16,15,15,14,14,17,14,14,13,13,13,11,11,
	10,10,16,14,14,12,12,15,13,13,13,12,16,14,14,11,
	11,16,14,14,11,11,16,14,15,13,14,16,14,14,13,13,
	16,15,15,13,13,16,14,14,13,13,16,15,15,13,13,16,
	15,15,13,13,17,14,14,14,14,17,15,15,13,13,16,14,
	15,13,13,16,15,15,13,13,16,15,15,13,13,16,14,14,
	13,13,17,15,15,12,12,16,14,14,12,12,16,15,15,12,
	12,16,15,15,13,13,16,14,14,13,13,17,15,15,12,12,
	17,14,14,12,12,16,15,15,12,12,13,14,14, 8, 8,13,
	14,14,18,18,13,15,15,17,18,14,14,14,18,19,14,14,
	14,19,18,14,15,15,19,18,15,15,16,21,18,15,15,15,
	19,19,14,16,16,19,19,14,15,15,18,19,14,15,15,19,
	20,14,16,16,19,18,15,15,15,18,19,14,15,15,19,18,
	15,15,15,18,18,15,15,15,20,18,15,16,16,20,19,14,
	15,14,18,19,14,15,16,19,20,14,15,15,19,18,15,15,
	15,19,18,15,16,16,20,19,15,14,14,18,18,14,15,15,
	19,19,14,15,15,18,18,13,12,12, 8, 8,13,14,14,19,
	18,14,13,13,20,18,14,14,14,19,18,14,13,13,18,19,
	14,15,15,20,19,15,14,14,19,19,14,15,15,19,18,15,
	14,14,20,20,15,15,15,19,18,14,15,15,19,18,15,14,
	14,19,18,14,15,15,20,19,14,14,14,20,19,14,15,15,
	19,18,15,15,15,18,18,15,14,14,18,18,14,15,15,19,
	19,14,14,14,19,19,14,15,15,19,19,15,15,15,19,18,
	15,14,14,20,19,15,15,15,19,19,14,14,14,20,19,14,
	15,15,20,20,12,12,12,13,13,17,16,16,11,11,16,16,
	15,12,12,17,16,16,11,11,17,15,15,11,11,17,17,17,
	13,13,17,16,16,13,13,17,17,17,12,12,17,16,16,13,
	13,17,17,16,12,13,16,17,16,13,13,17,16,15,13,13,
	17,16,16,12,12,17,16,16,12,13,17,16,17,12,12,17,
	17,17,12,12,17,16,15,13,13,17,16,16,12,12,17,16,
	16,12,12,17,16,16,11,11,16,16,16,12,12,17,15,15,
	13,13,17,16,15,11,11,16,16,16,12,12,17,16,16,11,
	11,13,14,14, 9, 9,16,14,14,13,13,16,14,15,14,14,
	16,14,14,12,12,16,14,14,13,13,17,15,15,14,15,16,
	15,15,15,15,17,15,15,14,14,16,15,15,15,14,16,15,
	15,14,14,16,15,15,14,14,16,15,16,15,15,17,15,14,
	14,14,16,15,15,14,14,17,15,15,13,13,16,15,15,14,
	14,16,16,16,15,15,17,14,14,13,13,16,15,15,14,14,
	18,14,15,13,13,16,15,15,14,14,16,16,15,15,15,16,
	14,14,13,13,16,15,15,14,14,17,14,15,13,13,13,11,
	11,10,10,15,14,14,12,12,15,14,14,13,13,16,14,14,
	12,12,16,13,14,12,12,16,14,15,14,13,16,14,14,14,
	14,16,15,15,13,13,16,14,14,13,13,16,15,15,13,13,
	15,15,15,13,13,16,14,14,14,14,17,15,15,13,13,16,
	14,14,13,13,16,15,15,13,13,16,15,15,13,13,16,14,
	14,13,13,17,15,15,12,12,16,14,14,12,12,16,14,15,
	12,12,16,15,15,13,13,16,14,14,13,13,17,15,15,12,
	12,16,14,14,12,12,16,15,15,12,12,14,14,14, 8, 8,
	14,14,14,17,17,14,15,15,18,18,14,14,14,18,17,14,
	14,14,18,18,14,15,15,18,20,15,16,15,19,18,15,15,
	15,19,18,15,15,16,19,18,15,15,15,18,18,14,15,15,
	18,18,15,16,16,18,19,15,15,15,18,18,15,15,15,19,
	20,15,15,15,18,18,15,15,15,18,18,15,16,16,19,19,
	15,14,15,19,19,15,15,15,19,20,14,14,15,18,18,15,
	15,15,19,19,15,16,16,19,19,15,15,14,18,19,15,15,
	15,20,20,15,15,14,18,18,13,12,12, 8, 8,13,14,14,
	18,18,14,14,14,18,18,14,14,14,18,20,14,14,14,18,
	18,14,15,15,19,18,15,14,14,18,19,15,15,15,18,19,
	15,14,14,18,19,15,15,15,18,18,14,15,14,18,19,15,
	14,14,21,19,15,15,15,19,18,14,14,14,19,18,14,15,
	15,19,18,15,15,15,20,19,15,14,14,20,18,14,15,15,
	18,19,14,14,14,19,18,14,15,15,18,19,15,15,15,18,
	19,15,14,14,19,19,15,15,15,19,19,14,14,14,19,20,
	14,15,15,18,19,
};

static const static_codebook _44p0_p3_1 = {
	5, 3125,
	(long *)_vq_lengthlist__44p0_p3_1,
	1, -533725184, 1611661312, 3, 0,
	(long *)_vq_quantlist__44p0_p3_1,
	0
};

static const long _vq_quantlist__44p0_p4_0[] = {
	2,
	1,
	3,
	0,
	4,
};

static const long _vq_lengthlist__44p0_p4_0[] = {
	 2, 6, 6,14,14, 6, 8, 8,14,14, 7, 7, 7,14,14, 0,
	13,13,15,16, 0,13,13,15,15, 7, 8, 8,15,15, 9,10,
	10,16,16, 9, 8, 8,14,15, 0,13,13,17,17, 0,13,13,
	16,16, 8, 8, 8,15,15,12,11,11,16,16, 9, 8, 8,14,
	14, 0,13,13,17,17, 0,13,13,15,15, 0,14,14,16,16,
	 0, 0, 0,18,19, 0,12,12,16,15, 0,16,16, 0,20, 0,
	14,14,16,16, 0,14,14,17,17, 0, 0, 0,19,19, 0,12,
	12,15,15, 0,18,17,21,21, 0,14,14,16,16, 5, 7, 7,
	12,13, 9,10, 9,14,14,11,10,10,14,14, 0, 0, 0,18,
	17, 0,20,21,18,18, 9,10,10,14,14,12,12,12,17,16,
	12,10,10,14,14, 0,20,20,18,17, 0,21,21,17,17,11,
	10,10,14,14,15,13,13,18,18,13,11,11,14,14, 0,20,
	 0,18,18, 0,20,21,18,17, 0,21, 0,18,19, 0, 0, 0,
	 0,21, 0,21,20,16,17, 0, 0, 0,21,21, 0, 0, 0,20,
	18, 0,20, 0,17,18, 0, 0, 0, 0, 0, 0, 0,20,16,17,
	 0, 0, 0,20, 0, 0, 0, 0,18,18, 6, 6, 6,13,13, 8,
	 5, 5,11,11, 9, 6, 6,13,13, 0, 9, 9,12,12, 0,10,
	10,14,14, 9, 7, 7,13,13,12, 9, 9,13,13,10, 6, 6,
	13,13, 0,10,10,14,14, 0,10,10,13,13, 9, 7, 7,13,
	13,13,10,10,13,13,11, 6, 6,13,13, 0,10,10,15,15,
	 0,10,10,13,13, 0,12,11,15,15, 0,20,19,17,16, 0,
	 9, 9,13,13, 0,13,13,20,19, 0,11,11,13,13, 0,11,
	11,15,15, 0,20,19,17,17, 0,10,10,13,13, 0,14,15,
	 0,21, 0,12,12,13,13, 0,10,10,12,12, 0,11,11,15,
	15, 0,11,11,15,15, 0,15,15,20,20, 0,16,16, 0, 0,
	 0,11,11,15,15, 0,14,14,17,17, 0,11,11,15,15, 0,
	15,15,20,21, 0,16,16,21,21, 0,12,12,15,15, 0,15,
	15,18,20, 0,11,11,16,15, 0,15,15,21,21, 0,16,16,
	 0,21, 0,16,16, 0, 0, 0, 0, 0, 0, 0, 0,14,14,21,
	21, 0,17,18, 0, 0, 0,16,17,20, 0, 0,16,16, 0, 0,
	 0, 0, 0, 0, 0, 0,15,15,20,20, 0,19,18, 0,21, 0,
	18,17, 0, 0, 0,10,10,11,11, 0,10,10,10,10, 0,11,
	11,12,12, 0,11,11, 9, 9, 0,13,13,12,12, 0,11,11,
	12,12, 0,13,13,12,12, 0,10,10,12,12, 0,12,12,13,
	13, 0,12,12,12,12, 0,11,11,12,12, 0,13,13,12,12,
	 0,10,10,12,12, 0,13,13,13,13, 0,12,12,12,12, 0,
	14,13,13,13, 0,19,21,15,15, 0,12,11,12,12, 0,16,
	15,19,19, 0,13,13,11,11, 0,13,13,13,13, 0, 0,21,
	15,16, 0,12,12,12,12, 0,16,16,19,21, 0,13,13,12,
	12, 7, 7, 7,16,16,11, 9, 9,16,16,12, 9, 9,16,16,
	 0,13,13,16,16, 0,14,14,17,16,11, 9, 9,16,16,14,
	12,11,17,17,13, 8, 9,15,15, 0,13,13,19,19, 0,13,
	13,16,15,12,10,10,17,17,15,12,12,19,18,14, 9, 9,
	17,16, 0,14,14,18, 0, 0,14,13,16,16, 0,14,15,18,
	17, 0,21, 0,19,21, 0,12,12,16,16, 0,16,16, 0, 0,
	 0,14,14,16,16, 0,14,14,18,18, 0, 0,21,20, 0, 0,
	13,13,16,17, 0,18,18, 0, 0, 0,15,14,17,16, 8, 7,
	 7,14,14,11,10,10,15,15,13,10,10,15,15, 0,21,20,
	19,19, 0,21, 0,17,18,11,10,10,15,16,14,12,12,18,
	18,14,11,11,15,14, 0,21,20,18,19, 0, 0,21,18,18,
	12,11,11,16,16,16,14,14,18,20,14,11,11,16,15, 0,
	20,20,19,19, 0, 0,20,18,18, 0,21, 0,18,19, 0, 0,
	 0, 0, 0, 0,20,20,17,18, 0, 0, 0,20,20, 0, 0, 0,
	19,19, 0, 0, 0,20,18, 0, 0, 0, 0, 0, 0, 0,21,18,
	18, 0,21,21, 0,21, 0, 0, 0,19,20,11, 9, 9,14,14,
	13,10,10,14,14,13,11,11,15,15, 0,13,13,13,13, 0,
	14,14,16,16,13,11,11,15,15,16,12,12,15,15,14,10,
	10,14,14, 0,14,14,16,16, 0,14,14,15,15,13,10,10,
	15,15,17,13,14,15,16,15,10,10,15,15, 0,14,14,17,
	16, 0,14,14,15,15, 0,15,15,17,17, 0, 0,21,18,18,
	 0,13,13,15,15, 0,16,16,21,20, 0,14,14,15,14, 0,
	15,14,16,17, 0, 0,20,20,19, 0,13,13,15,15, 0,19,
	18, 0, 0, 0,15,15,15,15, 0,11,11,14,14, 0,12,12,
	16,16, 0,12,12,16,16, 0,15,16,21,21, 0,16,17,21,
	 0, 0,12,12,17,16, 0,14,14,18,19, 0,11,11,16,16,
	 0,15,15,20,21, 0,16,16,21, 0, 0,12,12,17,16, 0,
	15,15,19,19, 0,12,12,16,17, 0,16,15, 0, 0, 0,16,
	16, 0, 0, 0,17,17, 0,21, 0, 0, 0, 0, 0, 0,14,15,
	20, 0, 0,17,17, 0, 0, 0,17,17, 0, 0, 0,17,16, 0,
	 0, 0, 0, 0, 0, 0, 0,15,15, 0, 0, 0,18,18, 0, 0,
	 0,18,17, 0, 0, 0,11,11,14,14, 0,12,12,15,15, 0,
	12,12,15,15, 0,13,13,14,14, 0,14,14,17,17, 0,12,
	12,16,16, 0,14,14,16,16, 0,11,11,15,15, 0,13,13,
	16,17, 0,13,13,16,16, 0,12,12,15,15, 0,14,14,17,
	16, 0,11,11,15,15, 0,14,14,17,17, 0,13,13,16,16,
	 0,15,15,17,18, 0,21,20,20,21, 0,12,12,15,15, 0,
	16,16,20,21, 0,14,14,15,15, 0,14,14,17,17, 0, 0,
	 0,18,19, 0,12,13,15,15, 0,18,17,21, 0, 0,14,15,
	15,15, 8, 8, 8,16,16,12,10,10,16,16,13, 9, 9,16,
	16, 0,14,14,18,17, 0,14,14,16,17,12,10,10,18,17,
	14,12,11,18,18,14, 9, 9,16,16, 0,13,13,18,18, 0,
	13,13,17,16,12, 9, 9,16,17,17,13,13,17,17,14, 9,
	 9,15,15, 0,14,14,20,19, 0,13,13,16,16, 0,15,15,
	19,18, 0, 0, 0,20,19, 0,12,13,17,17, 0,16,16,20,
	 0, 0,14,14,16,17, 0,14,14,19,18, 0, 0, 0,20,20,
	 0,13,13,16,16, 0,18,17, 0, 0, 0,15,15,16,16, 9,
	 7, 7,14,14,12,10,10,15,15,13,10,10,15,15, 0,21,
	 0,18,19, 0,20,21,19,18,12,10,10,16,15,15,13,13,
	18,18,14,11,11,15,15, 0, 0, 0,19,18, 0, 0,21,18,
	18,13,11,11,15,15,16,14,14,17,19,15,11,11,15,15,
	 0,21,21,20,18, 0, 0,21,18,18, 0, 0,21,21,19, 0,
	 0, 0, 0, 0, 0,19,20,18,17, 0, 0, 0,21,21, 0,21,
	 0,20,18, 0, 0,21,19,19, 0, 0, 0, 0, 0, 0,20,21,
	17,17, 0, 0, 0, 0, 0, 0,21, 0,18,20, 0,10,10,14,
	14, 0,11,11,15,15, 0,11,11,15,15, 0,14,14,15,15,
	 0,15,15,16,16, 0,11,12,16,16, 0,13,13,16,16, 0,
	11,11,15,15, 0,14,14,17,17, 0,14,14,15,15, 0,11,
	11,16,15, 0,14,14,15,15, 0,11,11,15,15, 0,15,15,
	17,17, 0,14,14,15,15, 0,16,16,18,18, 0, 0, 0,20,
	19, 0,14,13,16,15, 0,17,17,21, 0, 0,15,15,15,15,
	 0,16,15,17,16, 0,20, 0,20,18, 0,13,14,15,15, 0,
	19,18, 0,21, 0,15,15,15,15, 0,11,11,14,14, 0,12,
	12,16,16, 0,12,12,16,16, 0,16,15,20,21, 0,17,16,
	 0, 0, 0,12,12,16,16, 0,14,14,18,18, 0,11,11,16,
	16, 0,15,15,21,20, 0,16,16, 0, 0, 0,12,12,16,17,
	 0,15,14,19,19, 0,11,12,16,16, 0,15,15,21, 0, 0,
	16,16, 0, 0, 0,16,17, 0, 0, 0, 0, 0, 0, 0, 0,15,
	15,21, 0, 0,17,17, 0, 0, 0,17,17, 0, 0, 0,17,16,
	 0, 0, 0, 0, 0, 0, 0, 0,15,15, 0,20, 0,19,20, 0,
	 0, 0,17,17, 0, 0, 0,12,12,15,15, 0,12,12,15,15,
	 0,12,12,16,16, 0,13,13,15,15, 0,15,15,17,17, 0,
	13,13,17,16, 0,14,14,17,17, 0,11,11,16,16, 0,14,
	14,17,17, 0,13,13,16,16, 0,12,12,16,16, 0,15,15,
	16,17, 0,11,11,15,16, 0,14,14,17,17, 0,13,14,16,
	16, 0,15,15,18,18, 0,21,20,20,19, 0,13,13,16,17,
	 0,16,16, 0, 0, 0,14,14,16,16, 0,15,15,18,18, 0,
	 0, 0,20,19, 0,13,13,16,16, 0,17,17, 0, 0, 0,14,
	14,16,16, 0,11,11,16,16, 0,13,13,18,17, 0,13,13,
	17,17, 0,16,16,17,17, 0,16,16,17,18, 0,12,12,17,
	17, 0,15,15,18,18, 0,12,12,16,16, 0,16,16,19,19,
	 0,15,15,16,17, 0,12,12,17,17, 0,17,17,18,18, 0,
	12,12,17,17, 0,16,16,19,19, 0,15,16,17,17, 0,16,
	16,18,17, 0, 0, 0,21,21, 0,13,13,16,16, 0,17,17,
	 0,20, 0,15,15,16,17, 0,16,16,19,18, 0, 0,21,20,
	21, 0,14,14,17,16, 0,20, 0, 0, 0, 0,15,16,16,17,
	 0, 9, 9,14,14, 0,13,13,16,16, 0,14,14,15,15, 0,
	 0,20,19,19, 0, 0, 0,19,19, 0,12,12,15,15, 0,15,
	16,19,18, 0,14,14,15,15, 0,21, 0,18,18, 0,20, 0,
	17,18, 0,13,13,16,16, 0,17,17,17,19, 0,14,14,16,
	15, 0,21,20,20,19, 0, 0, 0,19,19, 0, 0, 0,19,18,
	 0, 0, 0, 0, 0, 0,20,20,17,18, 0, 0, 0,21,21, 0,
	 0, 0,18,18, 0,21, 0,18,19, 0, 0, 0, 0, 0, 0,20,
	21,18,18, 0, 0, 0,20,21, 0, 0, 0,19,19, 0,18,18,
	15,15, 0,20,21,17,17, 0,19,21,17,17, 0, 0, 0,17,
	18, 0, 0, 0,20,19, 0,19,19,17,17, 0, 0, 0,18,18,
	 0,19,20,16,17, 0, 0,21,20,20, 0,19,20,19,18, 0,
	19,20,16,16, 0, 0, 0,18,19, 0,19,20,17,17, 0, 0,
	21, 0,20, 0,21,21,17,19, 0,20, 0,19,20, 0, 0, 0,
	20, 0, 0,19,18,17,16, 0, 0, 0, 0, 0, 0, 0,20,17,
	17, 0,20,21,18,20, 0, 0, 0, 0,21, 0,19,20,17,17,
	 0, 0, 0, 0, 0, 0,20,21,17,17, 0,11,11,14,14, 0,
	13,13,16,17, 0,13,13,16,16, 0,17,17, 0,21, 0,18,
	17,21, 0, 0,13,13,16,16, 0,15,15,18,18, 0,12,12,
	16,16, 0,17,16,21, 0, 0,17,17, 0, 0, 0,12,12,17,
	17, 0,17,17,19,21, 0,13,12,16,16, 0,17,17, 0, 0,
	 0,17,17, 0, 0, 0,18,17, 0,21, 0, 0, 0, 0, 0, 0,
	15,15,20, 0, 0,20,18, 0, 0, 0,17,18, 0, 0, 0,16,
	17, 0, 0, 0, 0, 0, 0, 0, 0,15,15, 0, 0, 0,19,19,
	 0, 0, 0,18,18, 0, 0, 0,14,14,18,18, 0,16,16, 0,
	21, 0,16,16,21,21, 0,17,17, 0,20, 0,17,17,20, 0,
	 0,16,15, 0, 0, 0,20,20, 0, 0, 0,15,15,20,20, 0,
	17,17,21, 0, 0,17,18,20,20, 0,15,15,20,20, 0,18,
	18, 0, 0, 0,15,15,19,20, 0,17,18, 0, 0, 0,17,17,
	20,20, 0,18,17,21, 0, 0, 0, 0, 0,21, 0,15,15,20,
	20, 0,19,19, 0, 0, 0,17,17,21, 0, 0,17,17, 0, 0,
	 0, 0, 0,21, 0, 0,15,15,19,19, 0,20,21, 0, 0, 0,
	18,17,21,21, 0,12,12,16,16, 0,14,14,17,17, 0,13,
	13,17,18, 0,16,16,18,17, 0,16,16,18,18, 0,13,13,
	18,18, 0,15,16,19,18, 0,13,13,16,16, 0,16,16,20,
	18, 0,16,16,17,17, 0,12,13,17,17, 0,17,16,18,18,
	 0,12,12,16,16, 0,17,16,20,19, 0,16,16,16,16, 0,
	16,17,18,20, 0, 0, 0,21,20, 0,14,14,17,16, 0,19,
	18, 0,20, 0,16,16,17,16, 0,16,16,17,18, 0, 0,21,
	21,21, 0,14,14,16,16, 0,20,20,21, 0, 0,16,16,16,
	16, 0,10,10,14,14, 0,14,14,15,16, 0,14,14,15,15,
	 0, 0,21,18,18, 0, 0,21,18,19, 0,13,13,16,16, 0,
	16,16,18,18, 0,14,14,15,15, 0,21, 0,18,18, 0,21,
	 0,18,18, 0,13,13,16,16, 0,17,17,19,20, 0,14,14,
	15,15, 0, 0, 0,18,20, 0, 0,21,18,18, 0, 0,21,19,
	18, 0, 0, 0, 0, 0, 0,20,21,18,17, 0, 0, 0,21,21,
	 0, 0, 0,19,19, 0,21, 0,18,19, 0, 0, 0, 0, 0, 0,
	21,20,17,17, 0, 0,21,20, 0, 0, 0, 0,19,19, 0,19,
	20,15,16, 0, 0,20,18,17, 0,20,21,17,18, 0,21, 0,
	18,18, 0, 0, 0,19,19, 0,20,20,17,18, 0, 0, 0,18,
	19, 0,20,20,18,17, 0, 0, 0, 0,20, 0, 0,21,17,18,
	 0,20,21,17,17, 0, 0, 0,18,18, 0,19,19,17,17, 0,
	 0, 0,21,21, 0,20,20,17,17, 0, 0, 0,21,19, 0, 0,
	 0,20,19, 0,21,20,17,18, 0, 0, 0, 0, 0, 0, 0,20,
	18,17, 0,21,20,18,18, 0, 0, 0,20,21, 0,20,20,17,
	17, 0, 0, 0, 0, 0, 0,20, 0,17,17, 0,11,11,13,14,
	 0,13,13,16,16, 0,13,13,16,16, 0,17,17, 0, 0, 0,
	17,18, 0, 0, 0,13,13,16,16, 0,15,16,18,18, 0,13,
	13,16,17, 0,16,17,20, 0, 0,17,18,20, 0, 0,13,13,
	17,17, 0,16,16,20,21, 0,13,13,16,16, 0,17,17,21,
	 0, 0,17,18, 0, 0, 0,17,18, 0,21, 0, 0, 0, 0, 0,
	 0,15,15,20, 0, 0,19,19, 0, 0, 0,17,17, 0, 0, 0,
	18,17,21,20, 0, 0, 0, 0, 0, 0,16,16,20,21, 0,21,
	20, 0,21, 0,19,21, 0, 0, 0,15,15, 0, 0, 0,16,17,
	 0,19, 0,16,16, 0, 0, 0,17,17, 0, 0, 0,19,18, 0,
	 0, 0,16,16,20,20, 0,20,18,21, 0, 0,15,15,21,21,
	 0,18,18, 0, 0, 0,18,19, 0, 0, 0,16,15, 0,21, 0,
	20,19, 0, 0, 0,16,16, 0, 0, 0,20,18, 0,21, 0,17,
	18,21, 0, 0,18,19, 0, 0, 0, 0, 0, 0, 0, 0,16,16,
	20,20, 0,19,20, 0, 0, 0,17,17, 0, 0, 0,18,17,20,
	21, 0, 0, 0, 0, 0, 0,16,16, 0,20, 0,20,22, 0, 0,
	 0,18,18, 0,22,
};

static const static_codebook _44p0_p4_0 = {
	5, 3125,
	(long *)_vq_lengthlist__44p0_p4_0,
	1, -528744448, 1616642048, 3, 0,
	(long *)_vq_quantlist__44p0_p4_0,
	0
};

static const long _vq_quantlist__44p0_p4_1[] = {
	3,
	2,
	4,
	1,
	5,
	0,
	6,
};

static const long _vq_lengthlist__44p0_p4_1[] = {
	 2, 3, 3, 3, 3, 3, 3,
};

static const static_codebook _44p0_p4_1 = {
	1, 7,
	(long *)_vq_lengthlist__44p0_p4_1,
	1, -533200896, 1611661312, 3, 0,
	(long *)_vq_quantlist__44p0_p4_1,
	0
};

static const long _vq_quantlist__44p0_p5_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p0_p5_0[] = {
	 1, 6, 6, 6, 8, 8, 7, 8, 8, 7, 9, 8,10,11,11, 9,
	 8, 8, 7, 8, 8,11,11,11, 9, 8, 8, 6, 7, 7,10,10,
	10,10,10,10,10,10,10,14,13,13,12,11,11,10,10,10,
	14,14,13,13,11,11, 6, 6, 6, 8, 5, 5, 8, 7, 7, 8,
	 7, 7,11, 9, 9, 9, 7, 7, 8, 7, 7,12,10,10,10, 7,
	 7, 7, 8, 8,12,11,11,12,10,10,11,10,10,14,13,13,
	13,10,10,11,10,11,16,14,14,13,10,10, 7, 8, 7,12,
	12,12,12,11,11,12,11,11,16,14,15,13,12,12,11,11,
	11,17,15,14,14,13,13,10, 9, 9,13,11,11,13,11,11,
	12,11,11,16,14,13,14,11,11,12,11,11,16,15,14,14,
	11,11, 7, 8, 8,12,11,11,12,10,10,12,10,10,16,14,
	13,13,11,11,12,10,10,16,14,14,13,10,10, 8, 8, 8,
	12,12,12,12,11,11,12,11,11,16,14,15,14,12,12,12,
	11,11,16,15,15,14,12,12,10,10,10,13,11,11,13,11,
	11,12,12,12,16,14,14,14,11,11,12,11,11,17,14,15,
	14,11,11,
};

static const static_codebook _44p0_p5_0 = {
	5, 243,
	(long *)_vq_lengthlist__44p0_p5_0,
	1, -527106048, 1620377600, 2, 0,
	(long *)_vq_quantlist__44p0_p5_0,
	0
};

static const long _vq_quantlist__44p0_p5_1[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p0_p5_1[] = {
	 2, 7, 7, 7, 8, 8, 7, 7, 7, 7, 8, 8, 8, 8, 9, 8,
	 7, 7, 8, 8, 8, 9, 9, 9, 9, 7, 7, 6, 6, 6, 9, 7,
	 7, 9, 7, 7, 9, 8, 8,10, 8, 8,10, 8, 8,10, 8, 8,
	10, 8, 8,10, 8, 8, 7, 6, 6, 9, 6, 6, 9, 6, 6, 9,
	 7, 7,10, 8, 8, 9, 6, 6, 9, 7, 7,10, 8, 8, 9, 7,
	 7, 7, 8, 8,11, 9, 9,11, 9, 9,11, 9, 9,12, 9, 9,
	12, 8, 8,12, 9, 9,12,10, 9,12, 8, 8, 8, 7, 7,10,
	 9, 9,11, 9, 9,11, 9, 9,11,11,10,11, 9, 9,11,10,
	 9,11,10,11,11, 9, 9,10, 8, 8,11, 9, 9,11, 9, 9,
	11, 9, 9,11,10,10,11, 9, 9,11, 9, 9,11,10,10,11,
	 9, 9, 9, 8, 8,12, 9, 9,12, 9, 9,11, 9, 9,12, 9,
	 9,12, 8, 8,12, 9, 9,12, 9, 9,12, 8, 8, 9, 7, 7,
	11, 9,10,11,10, 9,11, 9, 9,11,11,11,11, 9, 9,11,
	10,10,11,11,11,11, 9, 9,10, 9, 9,11, 9, 9,11,10,
	10,11,10, 9,11,10,10,11, 9, 9,11,10,10,11,10,11,
	11, 9, 9,
};

static const static_codebook _44p0_p5_1 = {
	5, 243,
	(long *)_vq_lengthlist__44p0_p5_1,
	1, -530841600, 1616642048, 2, 0,
	(long *)_vq_quantlist__44p0_p5_1,
	0
};

static const long _vq_quantlist__44p0_p6_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p0_p6_0[] = {
	 1, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 8, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 7, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9,
};

static const static_codebook _44p0_p6_0 = {
	5, 243,
	(long *)_vq_lengthlist__44p0_p6_0,
	1, -516716544, 1630767104, 2, 0,
	(long *)_vq_quantlist__44p0_p6_0,
	0
};

static const long _vq_quantlist__44p0_p6_1[] = {
	12,
	11,
	13,
	10,
	14,
	9,
	15,
	8,
	16,
	7,
	17,
	6,
	18,
	5,
	19,
	4,
	20,
	3,
	21,
	2,
	22,
	1,
	23,
	0,
	24,
};

static const long _vq_lengthlist__44p0_p6_1[] = {
	 1, 3, 2, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9,10,10,11,
	11,12,12,12,14,14,14,15,15,
};

static const static_codebook _44p0_p6_1 = {
	1, 25,
	(long *)_vq_lengthlist__44p0_p6_1,
	1, -518864896, 1620639744, 5, 0,
	(long *)_vq_quantlist__44p0_p6_1,
	0
};

static const long _vq_quantlist__44p0_p6_2[] = {
	12,
	11,
	13,
	10,
	14,
	9,
	15,
	8,
	16,
	7,
	17,
	6,
	18,
	5,
	19,
	4,
	20,
	3,
	21,
	2,
	22,
	1,
	23,
	0,
	24,
};

static const long _vq_lengthlist__44p0_p6_2[] = {
	 3, 4, 4, 5, 4, 5, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5,
	 5, 5, 5, 5, 5, 5, 5, 5, 5,
};

static const static_codebook _44p0_p6_2 = {
	1, 25,
	(long *)_vq_lengthlist__44p0_p6_2,
	1, -529006592, 1611661312, 5, 0,
	(long *)_vq_quantlist__44p0_p6_2,
	0
};

static const long _huff_lengthlist__44p0_short[] = {
	 3, 3, 7, 8,10,13,16, 3, 2, 5, 7, 9,13,16, 6, 4,
	 4, 6,10,14,15, 7, 5, 5, 7,10,13,14, 9, 8, 9, 9,
	 9,11,13,12,11,12, 9, 7, 8,11,14,12,10, 6, 5, 7,
	10,
};

static const static_codebook _huff_book__44p0_short = {
	2, 49,
	(long *)_huff_lengthlist__44p0_short,
	0, 0, 0, 0, 0,
	NULL,
	0
};

static const long _vq_quantlist__44p1_l0_0[] = {
	6,
	5,
	7,
	4,
	8,
	3,
	9,
	2,
	10,
	1,
	11,
	0,
	12,
};

static const long _vq_lengthlist__44p1_l0_0[] = {
	 1, 4, 4, 7, 7, 8, 8, 9, 9,10,10,11,11, 4, 6, 5,
	 8, 6, 9, 8,10, 9,10,10,11,10, 5, 5, 6, 6, 8, 8,
	 9, 9,10,10,10,10,11, 7, 8, 8, 9, 8,10, 9,10, 9,
	11,10,11,10, 7, 8, 8, 8,10, 9,10,10,10,10,11,10,
	11, 9,10,10,11,11,11,11,12,11,12,11,12,11, 9,10,
	10,11,11,11,11,11,11,11,12,11,12,11,11,11,12,12,
	12,12,12,12,12,12,12,11,11,12,11,12,12,12,12,12,
	12,12,12,11,12,12,12,12,12,13,12,13,12,12,12,12,
	12,12,12,12,12,13,13,13,13,12,13,12,12,12,12,12,
	13,13,12,13,12,13,12,13,12,12,12,12,13,13,13,13,
	13,13,12,12,12,12,12,11,12,
};

static const static_codebook _44p1_l0_0 = {
	2, 169,
	(long *)_vq_lengthlist__44p1_l0_0,
	1, -526516224, 1616117760, 4, 0,
	(long *)_vq_quantlist__44p1_l0_0,
	0
};

static const long _vq_quantlist__44p1_l0_1[] = {
	2,
	1,
	3,
	0,
	4,
};

static const long _vq_lengthlist__44p1_l0_1[] = {
	 1, 4, 4, 6, 6, 5, 5, 5, 6, 6, 5, 6, 5, 6, 6, 6,
	 6, 7, 7, 7, 6, 7, 6, 7, 7,
};

static const static_codebook _44p1_l0_1 = {
	2, 25,
	(long *)_vq_lengthlist__44p1_l0_1,
	1, -533725184, 1611661312, 3, 0,
	(long *)_vq_quantlist__44p1_l0_1,
	0
};

static const long _vq_quantlist__44p1_l1_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p1_l1_0[] = {
	 1, 4, 4, 4, 4, 4, 4, 4, 4,
};

static const static_codebook _44p1_l1_0 = {
	2, 9,
	(long *)_vq_lengthlist__44p1_l1_0,
	1, -516716544, 1630767104, 2, 0,
	(long *)_vq_quantlist__44p1_l1_0,
	0
};

static const long _huff_lengthlist__44p1_lfe[] = {
	 1, 3, 2, 3,
};

static const static_codebook _huff_book__44p1_lfe = {
	2, 4,
	(long *)_huff_lengthlist__44p1_lfe,
	0, 0, 0, 0, 0,
	NULL,
	0
};

static const long _huff_lengthlist__44p1_long[] = {
	 3, 3, 7, 7, 9,13,16, 3, 2, 4, 6,10,13,17, 7, 4,
	 4, 6, 9,12,14, 7, 6, 6, 5, 7, 9,12,10,10, 9, 6,
	 6, 9,12,14,14,13, 9, 8,10,11,18,18,15,13,11,10,
	11,
};

static const static_codebook _huff_book__44p1_long = {
	2, 49,
	(long *)_huff_lengthlist__44p1_long,
	0, 0, 0, 0, 0,
	NULL,
	0
};

static const long _vq_quantlist__44p1_p1_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p1_p1_0[] = {
	 1, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0,
};

static const static_codebook _44p1_p1_0 = {
	5, 243,
	(long *)_vq_lengthlist__44p1_p1_0,
	1, -535822336, 1611661312, 2, 0,
	(long *)_vq_quantlist__44p1_p1_0,
	0
};

static const long _vq_quantlist__44p1_p2_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p1_p2_0[] = {
	 1, 4, 4, 0, 7, 7, 0, 8, 8, 0, 9, 9, 0,12,12, 0,
	 8, 8, 0, 9, 9, 0,12,12, 0, 8, 8, 0, 6, 6, 0,11,
	11, 0,11,11, 0,12,12, 0,14,14, 0,11,11, 0,12,12,
	 0,14,14, 0,11,11, 0, 6, 6, 0, 6, 5, 0, 7, 6, 0,
	 7, 7, 0,10,10, 0, 6, 6, 0, 7, 7, 0,10,10, 0, 7,
	 7, 0, 7, 7, 0,10,10, 0,11,11, 0,11,11, 0,14,14,
	 0,10,10, 0,12,12, 0,14,14, 0,12,12, 0, 6, 6, 0,
	11,11, 0,11,11, 0,12,12, 0,14,14, 0,11,11, 0,12,
	12, 0,15,15, 0,11,11, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 8, 8, 0,11,11, 0,11,11, 0,12,12, 0,15,
	15, 0,12,12, 0,11,11, 0,15,15, 0,11,11, 0, 6, 6,
	 0,11,11, 0,12,12, 0,12,12, 0,15,15, 0,11,11, 0,
	12,12, 0,14,14, 0,12,12, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0,
};

static const static_codebook _44p1_p2_0 = {
	5, 243,
	(long *)_vq_lengthlist__44p1_p2_0,
	1, -533200896, 1614282752, 2, 0,
	(long *)_vq_quantlist__44p1_p2_0,
	0
};

static const long _vq_quantlist__44p1_p2_1[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p1_p2_1[] = {
	 1, 3, 3, 0, 8, 8, 0, 8, 8, 0,10,10, 0, 9, 9, 0,
	10,10, 0,10,10, 0, 9, 9, 0,10,10, 0, 7, 7, 0, 7,
	 7, 0, 7, 7, 0, 8, 8, 0, 8, 8, 0, 8, 8, 0, 9, 9,
	 0, 8, 8, 0, 8, 8, 0, 7, 7, 0, 8, 8, 0, 8, 8, 0,
	10,10, 0, 9, 9, 0, 9, 9, 0,10,10, 0, 9, 9, 0,10,
	10, 0, 8, 8, 0,11,11, 0,11,11, 0,12,12, 0,11,11,
	 0,12,12, 0,12,12, 0,12,12, 0,12,12, 0, 8, 8, 0,
	11,11, 0,11,11, 0,13,12, 0,12,12, 0,13,12, 0,13,
	13, 0,12,12, 0,13,13, 0, 7, 7, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 8, 8, 0,11,11, 0,11,11, 0,13,12, 0,12,
	12, 0,12,12, 0,12,12, 0,11,11, 0,12,12, 0, 8, 8,
	 0,12,12, 0,12,12, 0,13,13, 0,12,12, 0,13,13, 0,
	13,13, 0,12,13, 0,13,13, 0, 7, 7, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0,
};

static const static_codebook _44p1_p2_1 = {
	5, 243,
	(long *)_vq_lengthlist__44p1_p2_1,
	1, -535822336, 1611661312, 2, 0,
	(long *)_vq_quantlist__44p1_p2_1,
	0
};

static const long _vq_quantlist__44p1_p3_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p1_p3_0[] = {
	 1, 6, 6, 6, 7, 7, 7, 8, 8, 7, 8, 8,10,11,11, 9,
	 8, 8, 7, 9, 9,11,12,12, 9, 8, 8, 6, 7, 7, 9,11,
	11,10,11,11,10,11,11,13,13,13,11,12,12,10,11,11,
	13,14,14,12,12,12, 6, 6, 6, 8, 6, 6, 8, 6, 6, 9,
	 7, 7,12,10,10,10, 6, 6, 9, 7, 7,12,10,10,11, 7,
	 6, 7, 8, 8,12,10,10,12,10,10,11,10,10,15,13,13,
	13,10,10,12,11,11,15,13,13,14,11,11, 8, 7, 7,12,
	11,11,12,11,11,11,11,11,14,14,14,13,12,12,12,11,
	11,16,15,15,14,12,12, 0,10,10, 0,11,11, 0,12,12,
	 0,11,11, 0,14,14, 0,11,11, 0,11,11, 0,15,15, 0,
	11,11, 7, 8, 8,13,10,10,12,10,10,12,11,11,15,13,
	13,14,11,11,12,10,10,16,14,14,14,10,10, 8, 7, 7,
	12,11,11,13,11,11,12,11,11,15,14,14,14,12,12,13,
	12,12,15,14,14,15,12,12, 0,11,11, 0,12,12, 0,12,
	12, 0,12,12, 0,15,15, 0,12,12, 0,12,12, 0,15,14,
	 0,12,12,
};

static const static_codebook _44p1_p3_0 = {
	5, 243,
	(long *)_vq_lengthlist__44p1_p3_0,
	1, -531365888, 1616117760, 2, 0,
	(long *)_vq_quantlist__44p1_p3_0,
	0
};

static const long _vq_quantlist__44p1_p3_1[] = {
	2,
	1,
	3,
	0,
	4,
};

static const long _vq_lengthlist__44p1_p3_1[] = {
	 2, 3, 4, 7, 7,10,12,12,12,12,10,11,11,13,13,11,
	12,12,11,11,12,12,12,12,12,11,13,13,13,13,12,12,
	12,13,14,12,13,13,13,13,12,13,13,13,13,12,13,13,
	13,13,11,13,13,13,13,12,12,12,14,14,12,13,13,12,
	12,12,12,13,13,13,12,13,13,13,13,12,13,13,13,13,
	12,12,12,14,14,12,13,13,12,12,12,13,13,13,13,12,
	13,13,12,12,12,13,13,13,13,12,12,12,14,14,12,13,
	13,12,12,12,13,13,13,13,12,13,13,12,12,10,10,11,
	10,10,11,11,11,11,11,11, 9, 9,10,10,12,11,11,10,
	10,12,10,10,10,10,13,12,12,12,12,13,11,11,11,11,
	13,12,12,12,12,13,11,11,11,11,13,12,12,12,12,13,
	12,12,12,12,13,11,11,11,11,13,12,12,12,12,13,11,
	11,11,11,13,12,12,11,11,13,12,12,11,11,13,11,11,
	11,11,13,12,12,11,11,13,11,11,11,11,13,12,12,11,
	11,13,12,12,11,11,13,11,11,11,11,13,12,12,11,11,
	13,11,11,11,11,13,12,12,11,11,11,11,11,10,10,11,
	11,11, 9, 9,11,12,12,11,11,12,12,12, 9, 9,13,13,
	13,10,10,13,13,13,11,11,13,13,13,14,14,13,13,13,
	11,10,13,13,14,12,12,13,13,13,11,11,13,13,13,11,
	11,13,13,13,14,14,13,13,13,10,10,13,13,13,11,11,
	13,13,13,10,10,13,14,13,11,11,13,14,14,14,14,13,
	13,13,10,10,13,14,14,11,11,13,13,13,10,10,13,14,
	14,11,11,13,13,13,14,14,14,13,13,10,10,13,14,14,
	11,11,13,13,13,10,10,14,12,12, 9, 9,14,12,12, 9,
	 9,14,11,11, 9, 9,14,12,12, 8, 8,14,11,11, 7, 7,
	15,13,13,10,10,15,12,12,10,10,15,13,13,10,10,15,
	12,12,10,10,15,13,13,10,10,15,13,13,10,10,15,12,
	12,10,10,15,13,13,10,10,15,12,12,10,10,15,13,13,
	10,10,15,13,13,10,10,15,12,12,10,10,15,13,13, 9,
	 9,15,12,12, 9, 9,14,13,13, 9, 9,15,13,13,10,10,
	15,12,12,10,10,15,13,13, 9, 9,15,12,12, 9, 9,15,
	13,13, 9, 9,13,12,12, 9, 9,13,13,13, 8, 8,13,13,
	13, 9, 9,13,13,13, 7, 7,14,13,13, 8, 8,14,14,14,
	10,10,15,14,14,11,11,14,14,14, 9, 9,15,14,14,10,
	10,15,14,14, 9, 9,14,14,14,10,10,15,14,14,11,11,
	15,14,14, 9, 9,14,14,14,10,10,14,14,14, 9, 9,15,
	14,15,10,10,15,14,14,11,11,14,14,14, 9, 9,14,14,
	14, 9, 9,14,14,14, 8, 8,15,14,14,10,10,15,14,14,
	11,11,14,14,14, 9, 9,15,14,14, 9, 9,14,14,14, 8,
	 8,12,12,12,13,13,16,16,16,11,11,17,16,16,12,12,
	17,16,16,11,11,17,16,16,11,11,17,17,16,13,13,17,
	16,16,13,13,18,17,16,12,12,17,16,16,13,13,17,16,
	17,12,12,18,17,17,13,13,17,16,16,14,14,18,17,17,
	12,12,18,16,16,13,13,17,17,17,13,12,17,17,17,13,
	13,17,16,16,13,13,18,17,17,12,12,17,16,16,13,12,
	17,17,17,12,12,18,17,17,13,13,18,16,16,14,14,18,
	17,17,12,12,17,17,17,13,13,18,17,18,12,12,13,14,
	14,10,10,16,14,14,13,13,17,15,15,14,14,17,14,14,
	12,13,16,14,14,13,13,17,15,15,14,14,16,16,16,15,
	15,17,15,15,14,14,17,16,16,14,15,17,15,15,14,14,
	17,15,16,14,14,17,16,16,15,15,17,15,15,13,13,17,
	15,15,14,14,18,15,15,13,14,17,15,15,14,14,16,16,
	16,15,15,17,15,15,13,13,17,15,15,14,14,17,15,15,
	13,13,17,15,15,14,14,16,16,16,15,15,17,15,15,13,
	13,17,15,15,14,14,18,15,15,13,13,13,11,11,10,10,
	16,14,14,13,12,16,14,14,13,13,16,15,14,12,12,16,
	14,14,12,12,16,15,15,14,14,16,14,14,14,14,17,15,
	15,13,13,16,15,15,14,14,17,15,15,13,14,17,15,15,
	14,14,17,15,14,14,14,17,15,15,13,13,17,15,15,14,
	14,17,15,15,13,13,17,15,15,14,14,17,14,14,14,14,
	17,15,15,13,13,17,15,15,13,13,17,15,15,13,13,17,
	15,15,14,14,17,15,15,14,14,17,15,15,13,13,17,15,
	15,13,13,17,15,15,13,13,14,14,15, 8, 8,14,14,14,
	19,19,14,15,15,18,19,14,14,14,19,18,14,14,14,19,
	19,15,15,15,19,18,15,16,16,19,19,15,15,15,19,19,
	15,16,16,20,19,15,15,15,19,19,15,15,15,19,19,16,
	16,16,20,19,15,15,15,19,18,15,16,16,20,19,15,15,
	15,18,18,15,15,15,19,20,15,16,16,19,19,15,15,15,
	20,19,15,15,15,20,19,15,15,15,19,18,15,15,15,19,
	19,15,16,16,19,20,15,15,15,19,19,15,15,15,19,20,
	15,15,15,19,19,14,12,12, 9, 9,14,14,14,19,19,14,
	14,14,19,19,14,14,15,20,19,15,14,14,18,19,15,15,
	15,19,19,15,15,14,20,19,15,15,15,20,19,15,15,14,
	20,19,15,15,15,20,19,15,15,15,19,20,15,14,14,19,
	20,15,15,15,20,20,15,14,14,20,19,15,15,15,19,19,
	15,15,15,19,19,15,14,14,19,19,15,15,15,19,20,15,
	15,15,20,20,15,15,15,19,19,15,15,15,20,19,16,14,
	14,19,19,15,15,15,20,19,15,14,15,20,19,14,15,15,
	20,19,12,12,12,13,13,16,16,16,11,11,16,16,16,12,
	12,17,16,16,11,11,17,15,16,11,11,17,17,17,13,13,
	18,16,17,13,13,18,17,17,13,12,17,16,17,13,13,17,
	17,17,13,13,16,16,16,12,12,17,16,16,13,13,17,16,
	16,12,12,17,16,16,12,13,17,17,17,12,12,17,17,17,
	13,13,18,16,16,13,13,18,17,17,12,12,18,17,17,12,
	12,17,17,17,12,12,17,17,17,12,12,17,16,16,13,13,
	17,17,17,12,12,17,16,16,12,12,17,17,17,12,12,13,
	14,14, 9, 9,16,14,14,13,13,16,15,15,14,14,17,14,
	14,13,13,16,14,14,13,13,17,15,15,15,15,16,16,16,
	15,15,17,15,15,14,14,17,15,15,15,15,17,15,15,14,
	14,17,15,15,14,14,16,16,16,15,15,17,15,15,14,14,
	17,15,15,14,14,17,15,15,14,14,17,15,15,14,14,16,
	16,16,15,15,18,15,15,14,13,17,15,15,14,14,17,15,
	15,13,13,17,15,15,14,14,16,16,16,15,15,17,15,15,
	14,13,17,15,15,14,14,17,15,15,13,13,13,11,11,11,
	11,16,14,14,12,12,16,14,14,13,13,16,15,14,12,12,
	17,14,14,12,12,17,15,15,13,13,17,14,14,14,14,17,
	15,15,13,13,17,14,15,14,13,17,15,15,13,13,16,15,
	15,13,13,16,14,14,14,14,17,15,15,13,13,16,14,14,
	13,13,16,15,15,13,13,17,15,15,13,13,17,14,14,14,
	14,17,15,15,12,12,17,15,15,13,13,17,15,15,12,12,
	16,15,15,13,13,17,14,14,13,14,17,15,15,12,12,17,
	14,14,13,13,17,15,15,12,12,14,14,14, 8, 8,14,14,
	14,18,18,14,15,15,19,19,14,14,14,19,19,14,15,14,
	18,19,15,15,15,18,19,15,16,16,20,20,15,15,15,19,
	20,15,16,16,19,20,15,15,15,19,20,15,15,16,19,19,
	15,16,16,20,20,15,15,15,20,19,15,16,16,20,19,15,
	15,15,19,20,15,15,15,19,19,15,16,16,20,19,15,15,
	15,19,19,15,16,15,20,19,15,15,15,19,19,15,15,15,
	19,20,15,16,16,20,20,15,15,15,19,19,15,15,15,20,
	20,15,15,15,19,19,14,12,12, 9, 9,14,14,14,18,18,
	14,14,14,19,20,14,14,14,18,18,14,14,14,18,19,15,
	15,15,19,20,15,14,14,19,19,15,15,15,19,19,15,14,
	15,19,19,15,15,15,18,20,15,15,15,19,19,15,14,14,
	19,19,15,15,15,20,19,15,15,14,20,20,15,15,15,19,
	19,15,15,15,19,19,15,14,14,19,19,15,15,15,19,19,
	15,14,14,19,20,14,15,15,19,19,15,15,15,19,19,15,
	14,14,20,19,15,15,15,19,19,15,14,14,20,19,15,15,
	15,19,19,13,12,12,13,13,17,17,16,11,11,16,16,16,
	12,12,17,17,16,11,11,17,16,16,11,11,17,17,17,13,
	13,17,16,16,13,13,18,17,17,12,12,17,16,16,13,13,
	18,17,17,12,12,18,17,17,13,13,18,16,17,13,13,17,
	17,17,12,12,18,17,17,13,13,18,17,17,12,12,17,16,
	17,12,12,17,16,16,13,13,17,16,16,11,11,17,16,16,
	12,12,17,17,17,11,11,17,17,17,12,12,18,16,16,13,
	13,18,17,17,12,11,17,16,16,12,12,18,17,17,11,11,
	13,14,14, 9, 9,16,14,14,13,13,16,15,15,14,14,17,
	14,14,12,12,16,14,14,13,13,17,15,15,14,14,17,16,
	16,15,16,18,15,15,14,14,17,15,15,14,14,17,15,15,
	14,14,18,15,15,14,14,16,16,16,15,16,18,15,15,14,
	14,17,16,15,14,14,18,15,15,14,14,17,15,15,14,14,
	17,16,16,15,15,18,14,15,13,13,17,15,15,14,14,18,
	15,15,13,13,17,15,15,14,14,17,16,15,15,15,17,15,
	15,13,13,17,15,15,14,14,18,15,15,13,13,13,11,11,
	10,10,16,14,14,12,12,16,14,14,12,12,17,14,15,11,
	11,17,14,14,11,11,17,15,15,13,13,17,14,14,14,13,
	17,15,15,13,13,16,15,15,13,13,17,15,15,13,13,17,
	15,15,13,13,17,14,14,14,14,17,15,15,13,13,17,14,
	15,13,13,16,15,15,13,13,17,15,15,13,13,17,14,14,
	13,13,17,15,15,12,12,16,14,14,12,12,17,15,15,12,
	12,17,15,15,13,13,17,14,14,13,13,17,15,15,12,12,
	17,14,14,12,12,17,15,15,12,12,13,15,14, 8, 8,14,
	14,14,19,19,14,15,15,18,19,14,14,14,18,19,14,15,
	14,19,19,15,16,15,19,19,15,16,16,19,20,15,15,15,
	19,19,15,16,16,19,19,15,16,16,19,19,15,15,15,19,
	19,15,16,16,20,20,15,15,15,19,19,15,15,15,19,19,
	15,15,15,19,19,15,15,15,19,19,15,16,16,20,19,15,
	15,15,19,19,15,15,15,19,19,15,15,15,19,19,15,16,
	15,19,19,15,16,16,21,19,15,15,15,20,20,15,15,15,
	20,21,15,15,15,19,20,14,12,12, 8, 8,14,14,14,19,
	19,14,13,13,19,19,14,14,14,19,19,14,13,14,19,19,
	15,15,15,20,20,15,14,14,20,19,15,15,15,19,20,15,
	14,14,19,20,15,15,15,20,19,15,15,15,19,20,15,14,
	14,20,20,15,15,15,20,19,15,14,14,19,19,15,15,15,
	19,19,15,15,15,20,19,15,14,14,21,19,15,15,15,20,
	21,15,14,14,21,19,15,15,15,19,19,15,15,15,20,20,
	15,14,14,19,21,15,15,15,19,19,15,14,14,19,20,15,
	15,15,19,19,13,12,12,13,13,17,16,16,11,11,17,16,
	15,12,12,18,16,16,11,11,17,16,16,11,11,18,17,17,
	13,13,18,16,16,13,13,17,17,17,12,13,18,17,16,13,
	13,18,17,17,13,13,17,17,17,13,13,17,16,16,13,13,
	18,16,17,12,12,17,16,16,13,12,17,17,17,12,12,18,
	17,17,13,12,18,16,16,13,13,18,17,17,12,12,17,16,
	16,12,12,17,17,17,11,11,17,16,16,12,12,17,16,16,
	13,13,17,16,16,11,11,17,16,16,12,12,17,17,17,11,
	11,13,14,14, 9, 9,16,14,14,13,13,16,15,15,14,14,
	17,14,14,12,12,16,14,14,13,13,17,15,15,14,14,17,
	15,16,15,15,17,15,15,14,14,17,15,16,14,15,18,15,
	15,14,14,17,15,15,14,14,16,16,16,15,15,18,15,15,
	13,14,17,15,15,14,14,18,15,15,14,14,17,15,15,14,
	14,17,16,16,15,15,17,15,15,13,13,17,15,15,14,14,
	18,15,15,13,13,17,15,15,14,14,17,16,16,15,15,17,
	15,15,13,13,17,15,15,14,14,18,15,15,13,13,13,11,
	11,10,10,16,14,14,12,12,16,14,14,13,13,17,14,14,
	11,11,17,14,14,12,12,17,15,15,14,14,17,14,14,14,
	14,17,15,15,13,13,17,15,14,13,13,16,15,15,13,13,
	16,15,15,13,13,17,14,14,14,14,17,15,15,13,13,17,
	14,14,13,13,16,15,15,13,13,16,15,15,13,13,17,14,
	14,13,13,17,15,15,12,12,17,14,14,12,12,16,15,15,
	12,12,17,15,15,13,13,17,14,14,13,13,17,15,15,12,
	12,17,14,14,12,12,16,15,15,12,12,14,14,14, 8, 8,
	14,14,14,18,18,14,15,15,19,18,14,14,14,18,18,14,
	14,14,18,19,15,16,15,19,19,15,17,16,20,20,15,15,
	15,19,19,15,16,16,19,19,15,15,15,19,19,15,16,15,
	18,19,15,16,16,20,20,15,15,15,19,19,15,16,16,19,
	20,15,15,15,19,19,15,15,16,19,19,15,16,16,20,20,
	15,15,15,19,19,15,15,15,19,20,15,15,15,19,19,15,
	15,15,19,19,15,16,16,20,20,15,15,15,19,20,15,16,
	16,20,20,15,15,15,19,19,13,12,12, 8, 8,14,14,14,
	19,20,14,14,14,19,19,14,14,14,18,19,14,14,14,19,
	20,15,15,15,19,20,15,14,14,21,20,15,15,15,20,20,
	15,15,14,19,19,15,15,15,19,19,15,15,15,19,19,15,
	14,14,19,20,15,15,15,19,20,15,14,14,19,19,15,15,
	15,19,19,15,15,15,19,19,16,14,14,19,19,15,15,15,
	20,20,15,14,14,21,19,15,15,15,19,19,15,15,15,19,
	20,16,14,14,19,20,15,15,15,19,19,15,14,14,19,19,
	15,15,15,20,19,
};

static const static_codebook _44p1_p3_1 = {
	5, 3125,
	(long *)_vq_lengthlist__44p1_p3_1,
	1, -533725184, 1611661312, 3, 0,
	(long *)_vq_quantlist__44p1_p3_1,
	0
};

static const long _vq_quantlist__44p1_p4_0[] = {
	2,
	1,
	3,
	0,
	4,
};

static const long _vq_lengthlist__44p1_p4_0[] = {
	 2, 6, 6,14,14, 6, 7, 7,14,14, 7, 7, 7,14,14, 0,
	13,13,16,16, 0,13,13,15,14, 7, 8, 8,15,15, 9,10,
	10,16,16, 9, 8, 8,15,15, 0,13,13,17,16, 0,13,13,
	15,16, 8, 8, 8,15,15,12,11,11,16,16, 9, 8, 8,14,
	14, 0,13,13,17,18, 0,13,13,15,15, 0,14,14,16,16,
	 0, 0, 0,19,18, 0,12,12,16,15, 0,15,16, 0,20, 0,
	14,14,16,16, 0,14,14,17,17, 0, 0, 0,19,18, 0,12,
	12,15,15, 0,17,17, 0,20, 0,14,14,16,16, 5, 6, 7,
	12,12, 9, 9, 9,14,14,10,10,10,14,14, 0,21,21,18,
	17, 0,20,20,18,17, 9,10,10,14,14,12,12,12,16,16,
	12,10,10,14,14, 0,20,19,18,17, 0, 0,20,17,18,11,
	10,10,14,14,14,13,13,18,18,13,11,11,14,14, 0,20,
	20,17,18, 0,21,21,17,17, 0,21, 0,18,18, 0, 0, 0,
	 0, 0, 0,20,19,16,17, 0, 0, 0,19,19, 0, 0, 0,18,
	18, 0,21,21,18,18, 0, 0, 0, 0, 0, 0,20,20,16,17,
	 0, 0, 0,21,21, 0, 0, 0,18,19, 6, 6, 6,13,12, 8,
	 6, 6,11,11, 8, 6, 6,13,13, 0, 9, 9,11,11, 0,11,
	10,14,14, 9, 7, 7,13,13,11, 9, 9,13,13,10, 6, 6,
	13,13, 0,10,10,14,15, 0,10,10,13,13, 9, 7, 7,13,
	13,13,10, 9,13,13,10, 6, 6,13,13, 0,10,10,15,14,
	 0,10,10,13,13, 0,11,11,15,15, 0,19,20,17,17, 0,
	 9, 9,13,13, 0,13,13,20,20, 0,11,11,13,13, 0,11,
	11,15,15, 0,19,19,17,17, 0,10,10,13,13, 0,15,15,
	20,20, 0,12,12,13,13, 0,10,10,12,12, 0,11,11,15,
	15, 0,11,11,15,15, 0,15,15,20, 0, 0,16,16, 0,21,
	 0,11,11,15,15, 0,14,14,18,17, 0,11,11,15,15, 0,
	15,16,19,20, 0,16,16,21,21, 0,12,12,15,15, 0,15,
	14,18,18, 0,11,11,16,16, 0,15,15,21,21, 0,16,15,
	 0, 0, 0,16,16,21, 0, 0, 0, 0, 0, 0, 0,14,14,20,
	20, 0,18,18, 0, 0, 0,16,17,21, 0, 0,16,16,21,21,
	 0, 0, 0, 0, 0, 0,15,15,21,21, 0,20,19, 0,21, 0,
	17,17, 0, 0, 0,10,10,12,11, 0,10,10,10,11, 0,11,
	11,12,12, 0,11,11, 9, 9, 0,13,13,11,12, 0,11,11,
	12,12, 0,13,13,12,12, 0,10,10,12,12, 0,12,12,13,
	13, 0,12,12,12,12, 0,11,11,12,12, 0,13,13,12,12,
	 0,10,10,12,12, 0,13,13,14,14, 0,12,12,12,12, 0,
	14,14,14,13, 0,19,20,15,15, 0,12,11,12,12, 0,15,
	15,21,20, 0,13,13,11,11, 0,13,13,13,13, 0,19, 0,
	15,15, 0,12,12,12,12, 0,17,16,19, 0, 0,13,13,12,
	12, 7, 7, 7,16,16,11, 9, 9,15,15,12, 9, 9,16,16,
	 0,13,13,15,14, 0,14,14,17,16,10, 9, 9,16,16,14,
	11,11,17,16,12, 9, 8,15,15, 0,13,13,18,18, 0,13,
	13,15,15,12,10,10,18,17,15,12,12,17,17,14, 9, 9,
	16,16, 0,13,13,18,19, 0,14,13,17,16, 0,14,14,18,
	18, 0, 0, 0,20,21, 0,12,12,16,16, 0,16,16,20,21,
	 0,14,14,17,16, 0,14,14,18,19, 0, 0, 0,19,21, 0,
	13,13,17,17, 0,17,17, 0,21, 0,15,15,16,16, 8, 7,
	 7,14,14,11,10,10,15,15,12,10,10,15,15, 0,20,20,
	18,18, 0, 0, 0,17,17,11,10,10,16,16,14,12,12,18,
	17,14,11,11,15,15, 0,20,21,18,18, 0, 0,19,18,17,
	12,10,10,16,16,17,14,14,19,19,14,11,11,15,15, 0,
	21,21,19,19, 0,21,20,19,18, 0,21, 0,18,19, 0, 0,
	 0, 0, 0, 0,20,20,18,17, 0,21, 0, 0, 0, 0, 0, 0,
	19,18, 0, 0, 0,18,19, 0, 0, 0, 0, 0, 0, 0,21,17,
	18, 0, 0, 0, 0,21, 0, 0,21,18,19,11, 9, 9,14,14,
	13,10,10,13,13,13,11,11,15,15, 0,13,13,12,12, 0,
	15,15,16,16,13,10,10,15,15,16,12,12,15,15,15,10,
	10,15,15, 0,14,13,16,15, 0,14,13,15,15,13,10,10,
	15,15,18,14,14,15,15,15,10,10,14,15, 0,14,14,16,
	16, 0,14,14,16,15, 0,15,15,17,16, 0,21, 0,18,18,
	 0,12,13,15,15, 0,16,16, 0, 0, 0,14,14,15,15, 0,
	15,15,16,16, 0,21,20,18,18, 0,13,13,15,15, 0,19,
	18, 0, 0, 0,15,15,15,15, 0,11,11,13,13, 0,12,12,
	16,16, 0,12,12,16,16, 0,15,16,20, 0, 0,16,17, 0,
	 0, 0,12,12,16,16, 0,14,14,18,18, 0,11,11,16,17,
	 0,15,15,20, 0, 0,16,16, 0, 0, 0,12,12,16,16, 0,
	15,15,19,19, 0,11,11,17,17, 0,16,16,21, 0, 0,16,
	16, 0, 0, 0,17,17,20,20, 0, 0, 0, 0, 0, 0,15,15,
	20, 0, 0,17,18, 0, 0, 0,17,17, 0, 0, 0,16,16, 0,
	21, 0, 0, 0, 0, 0, 0,15,15,21, 0, 0,19,18, 0, 0,
	 0,18,17, 0, 0, 0,11,11,14,14, 0,11,11,15,15, 0,
	12,12,16,16, 0,13,13,14,14, 0,14,14,17,17, 0,12,
	12,16,16, 0,14,14,16,16, 0,11,11,16,15, 0,13,13,
	16,17, 0,13,13,16,16, 0,12,12,15,16, 0,15,14,16,
	16, 0,11,11,15,15, 0,14,14,17,17, 0,13,13,16,16,
	 0,15,14,18,18, 0,21, 0,19,19, 0,13,13,15,15, 0,
	16,16,20,20, 0,14,14,16,15, 0,14,14,17,17, 0,21,
	 0,20,18, 0,13,13,15,15, 0,17,17, 0, 0, 0,14,14,
	16,15, 8, 8, 8,16,16,12, 9, 9,16,16,13, 9, 9,16,
	16, 0,14,14,18,17, 0,14,14,16,17,12,10,10,18,17,
	14,11,11,18,18,14, 9, 9,16,16, 0,13,13,18,18, 0,
	13,13,17,16,12, 9, 9,16,17,17,13,13,16,16,14, 9,
	 9,15,15, 0,14,14,20,20, 0,13,13,15,15, 0,15,14,
	18,18, 0, 0, 0,20,21, 0,12,13,16,17, 0,16,16,20,
	21, 0,14,14,16,17, 0,14,14,18,17, 0, 0, 0,20,21,
	 0,13,13,16,16, 0,19,17, 0,21, 0,14,15,16,16, 8,
	 7, 7,14,13,12,10,10,15,15,13,10,10,15,15, 0,21,
	21,18,19, 0,20,21,18,18,12,10,10,16,15,15,12,12,
	17,17,14,11,11,15,15, 0,21,21,19,18, 0, 0,21,17,
	18,13,11,11,15,15,16,13,13,18,19,15,11,11,15,14,
	 0,21, 0,19,19, 0, 0,21,18,18, 0, 0,21,19,19, 0,
	 0, 0, 0, 0, 0,20,19,17,17, 0, 0, 0,21, 0, 0,21,
	 0,18,19, 0, 0,20,20,19, 0, 0, 0, 0, 0, 0,21,20,
	18,17, 0, 0, 0, 0,20, 0, 0, 0,18,19, 0,10,10,15,
	14, 0,11,11,14,14, 0,11,11,15,16, 0,14,14,15,15,
	 0,15,15,16,16, 0,11,11,16,16, 0,14,13,16,16, 0,
	11,11,15,15, 0,14,14,16,16, 0,14,14,15,15, 0,11,
	11,15,15, 0,13,13,15,15, 0,11,11,15,15, 0,15,15,
	18,17, 0,14,14,15,15, 0,15,16,18,18, 0, 0, 0,20,
	20, 0,14,13,16,15, 0,17,17,21, 0, 0,15,15,15,15,
	 0,16,15,17,17, 0, 0, 0,19,19, 0,13,13,15,15, 0,
	20,19, 0, 0, 0,15,15,15,15, 0,11,11,13,13, 0,12,
	12,16,16, 0,12,12,16,16, 0,15,15,21,21, 0,17,16,
	 0, 0, 0,12,12,16,16, 0,14,14,17,17, 0,11,11,16,
	16, 0,15,15, 0, 0, 0,16,16,21, 0, 0,12,12,17,16,
	 0,14,15,20,20, 0,11,11,16,16, 0,15,15, 0,20, 0,
	16,16, 0,21, 0,16,17,21, 0, 0, 0, 0, 0, 0, 0,15,
	15, 0,21, 0,18,18, 0, 0, 0,17,16, 0, 0, 0,17,17,
	21, 0, 0, 0, 0, 0, 0, 0,15,15, 0,20, 0,19,20,21,
	 0, 0,17,18, 0, 0, 0,12,12,15,15, 0,12,12,15,15,
	 0,12,12,16,16, 0,13,13,15,15, 0,15,15,17,17, 0,
	13,12,17,16, 0,14,14,17,16, 0,11,11,16,16, 0,14,
	14,17,17, 0,14,14,17,17, 0,12,12,16,16, 0,15,15,
	17,17, 0,11,11,16,16, 0,14,14,17,17, 0,14,14,16,
	16, 0,15,15,18,17, 0, 0, 0,19, 0, 0,13,13,16,16,
	 0,16,16, 0,21, 0,14,14,16,16, 0,15,15,18,17, 0,
	 0, 0,19,19, 0,13,13,16,16, 0,18,17, 0,21, 0,14,
	15,16,16, 0,11,11,16,16, 0,13,13,17,17, 0,13,13,
	17,17, 0,16,16,16,17, 0,16,16,18,18, 0,12,12,17,
	17, 0,16,15,18,17, 0,12,12,16,16, 0,16,15,19,19,
	 0,16,15,17,17, 0,12,12,17,18, 0,16,16,18,18, 0,
	12,12,16,16, 0,16,16,19,19, 0,15,16,17,17, 0,15,
	16,18,18, 0, 0, 0,20,20, 0,13,13,16,16, 0,18,18,
	21,20, 0,15,15,16,16, 0,16,16,19,18, 0, 0, 0,19,
	20, 0,14,14,17,17, 0,19,19, 0,21, 0,15,16,16,16,
	 0, 9, 9,14,14, 0,13,13,15,15, 0,14,14,15,15, 0,
	 0,21,19,19, 0, 0,21,18,18, 0,12,12,15,15, 0,15,
	15,18,18, 0,14,13,15,15, 0,21,21,18,19, 0,21,20,
	18,18, 0,13,13,16,16, 0,17,17,18,19, 0,14,14,15,
	15, 0, 0,21,19,19, 0,21,20,18,19, 0,20,20,19,19,
	 0, 0, 0, 0, 0, 0,19,20,17,17, 0, 0, 0,21,21, 0,
	21, 0,18,20, 0,21, 0,18,21, 0, 0, 0, 0, 0, 0,21,
	21,19,18, 0, 0, 0, 0, 0, 0, 0, 0,19,19, 0,18,18,
	15,15, 0,18,20,17,16, 0,20, 0,17,17, 0,21, 0,17,
	17, 0,21,20,19,20, 0,19,19,16,16, 0,21,21,17,18,
	 0,19,19,17,17, 0,20,21,21,21, 0,20,20,18,18, 0,
	19,19,16,16, 0, 0,21,18,19, 0,18,19,16,17, 0,21,
	21,19,20, 0,21,19,18,18, 0,21,20,19,21, 0, 0, 0,
	20,21, 0,19,19,17,16, 0, 0, 0, 0, 0, 0,21,20,17,
	17, 0,20,21,19,18, 0, 0, 0, 0,21, 0,19,18,16,17,
	 0, 0, 0, 0, 0, 0,20,20,17,17, 0,11,11,14,14, 0,
	13,13,16,16, 0,13,13,16,16, 0,17,17,21, 0, 0,17,
	18, 0, 0, 0,12,12,16,16, 0,15,15,17,18, 0,12,12,
	16,16, 0,16,16, 0,20, 0,17,17, 0,21, 0,12,12,17,
	17, 0,16,16,19,20, 0,12,12,17,17, 0,17,17, 0,20,
	 0,17,17, 0, 0, 0,17,17,21, 0, 0, 0, 0, 0, 0, 0,
	15,15, 0,20, 0,19,19, 0, 0, 0,18,18, 0, 0, 0,17,
	17, 0, 0, 0, 0, 0, 0, 0, 0,15,15, 0, 0, 0,20,19,
	 0, 0, 0,19,18, 0, 0, 0,14,14,21,19, 0,16,16,20,
	21, 0,16,16,20,20, 0,17,17,20, 0, 0,17,17,20,20,
	 0,15,15,20,20, 0,19,18,20, 0, 0,15,15,20,20, 0,
	17,18,21,20, 0,17,17,20,21, 0,15,15,19,19, 0,19,
	18,21,21, 0,15,15,19,20, 0,17,18, 0, 0, 0,17,17,
	20,20, 0,17,18,20,21, 0, 0, 0, 0, 0, 0,15,15,20,
	20, 0,19,19, 0, 0, 0,17,17,19,21, 0,17,17, 0,21,
	 0, 0, 0, 0,21, 0,15,15,20,19, 0, 0,20, 0, 0, 0,
	17,17,21,20, 0,12,12,16,16, 0,14,14,17,17, 0,13,
	13,17,17, 0,16,16,17,18, 0,17,16,18,18, 0,13,13,
	18,17, 0,15,16,19,18, 0,13,13,16,16, 0,16,16,19,
	19, 0,16,16,17,17, 0,13,12,17,17, 0,16,16,18,17,
	 0,12,12,16,16, 0,17,17,19,18, 0,16,15,16,16, 0,
	16,17,18,19, 0, 0, 0,20,20, 0,14,14,17,16, 0,18,
	18,21, 0, 0,16,16,16,16, 0,16,16,18,17, 0, 0,21,
	21,21, 0,14,14,16,16, 0,21,20,21, 0, 0,16,16,16,
	16, 0,10,10,14,14, 0,14,14,15,16, 0,14,14,15,15,
	 0, 0,21,18,18, 0, 0,21,18,19, 0,13,13,16,16, 0,
	16,16,18,17, 0,14,14,15,15, 0,20, 0,18,18, 0,21,
	 0,18,17, 0,13,13,16,15, 0,17,17,19,19, 0,14,14,
	15,15, 0,20,20,18,19, 0, 0, 0,18,17, 0, 0,21,18,
	18, 0, 0, 0, 0, 0, 0,20,21,18,17, 0, 0, 0, 0, 0,
	 0, 0, 0,19,19, 0, 0,21,18,18, 0, 0, 0, 0, 0, 0,
	21, 0,18,17, 0, 0, 0, 0,21, 0, 0, 0,19,20, 0,19,
	19,16,16, 0, 0,21,18,17, 0,21, 0,18,18, 0,20, 0,
	19,18, 0,21,20,19,19, 0,21,19,17,18, 0, 0,21,19,
	19, 0,21,19,18,18, 0,21, 0,20,18, 0, 0,21,18,18,
	 0,20,21,17,17, 0,21, 0,18,18, 0,21,19,17,17, 0,
	21, 0, 0,20, 0, 0,20,17,18, 0, 0, 0,19,20, 0, 0,
	 0,20,19, 0,19,21,17,18, 0,21, 0, 0, 0, 0,21,21,
	18,17, 0, 0,21,18,18, 0, 0, 0, 0,21, 0,20,19,16,
	17, 0, 0, 0, 0, 0, 0,21,20,17,17, 0,11,11,13,13,
	 0,13,13,16,16, 0,13,13,16,16, 0,17,17, 0,21, 0,
	18,19,21, 0, 0,12,12,16,16, 0,15,15,19,18, 0,13,
	13,16,16, 0,16,17,21,19, 0,17,17,21,21, 0,13,13,
	16,16, 0,16,16,20,18, 0,13,13,16,16, 0,17,17, 0,
	 0, 0,18,18, 0, 0, 0,18,17, 0,20, 0, 0, 0, 0, 0,
	 0,15,15,21,21, 0,19,18, 0, 0, 0,17,17,21,21, 0,
	17,17, 0, 0, 0, 0, 0, 0, 0, 0,15,15,20,21, 0,20,
	20, 0, 0, 0,19,19, 0, 0, 0,14,15,21,19, 0,16,16,
	 0,21, 0,17,16,21,21, 0,17,18,21,20, 0,18,18, 0,
	21, 0,16,16, 0,20, 0,19,19, 0, 0, 0,16,15, 0,20,
	 0,18,18, 0, 0, 0,17,17, 0,21, 0,16,16,20,20, 0,
	20,19, 0, 0, 0,15,16,21,22, 0,18,18, 0, 0, 0,18,
	17, 0, 0, 0,18,18, 0, 0, 0, 0, 0, 0, 0, 0,16,16,
	21,20, 0,19,20, 0, 0, 0,18,17,21, 0, 0,17,18, 0,
	 0, 0, 0, 0, 0, 0, 0,16,16, 0,20, 0, 0,20, 0, 0,
	 0,18,18,22, 0,
};

static const static_codebook _44p1_p4_0 = {
	5, 3125,
	(long *)_vq_lengthlist__44p1_p4_0,
	1, -528744448, 1616642048, 3, 0,
	(long *)_vq_quantlist__44p1_p4_0,
	0
};

static const long _vq_quantlist__44p1_p4_1[] = {
	3,
	2,
	4,
	1,
	5,
	0,
	6,
};

static const long _vq_lengthlist__44p1_p4_1[] = {
	 2, 3, 3, 3, 3, 3, 3,
};

static const static_codebook _44p1_p4_1 = {
	1, 7,
	(long *)_vq_lengthlist__44p1_p4_1,
	1, -533200896, 1611661312, 3, 0,
	(long *)_vq_quantlist__44p1_p4_1,
	0
};

static const long _vq_quantlist__44p1_p5_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p1_p5_0[] = {
	 1, 6, 6, 7, 8, 8, 7, 8, 8, 7, 9, 8,10,11,11, 9,
	 8, 8, 7, 8, 8,11,11,11, 9, 8, 8, 6, 7, 7,10,10,
	10,10,10,10,10,10,10,14,13,13,12,11,11,10,10,10,
	14,14,13,12,11,11, 6, 6, 6, 8, 5, 5, 8, 7, 7, 9,
	 7, 7,11,10,10, 9, 7, 7, 9, 7, 7,12,10,10,10, 7,
	 7, 7, 8, 8,12,11,10,12,10,10,11,10,10,15,13,13,
	13,10,10,11,10,10,17,14,13,13,10,10, 7, 7, 7,12,
	11,12,12,11,11,12,11,11,16,14,14,13,12,12,12,11,
	11,17,15,14,14,12,12,10, 9, 9,13,11,11,13,11,11,
	13,11,11,17,14,13,14,11,11,12,11,11,16,15,14,14,
	11,11, 7, 8, 8,12,11,11,12,10,10,12,10,10,15,13,
	13,14,11,10,12,10,10,16,14,14,14,10,10, 8, 7, 7,
	12,11,11,12,11,11,12,11,11,17,14,14,14,12,12,12,
	11,11,16,15,15,14,12,12,10,10,10,13,11,11,13,11,
	11,13,11,12,16,14,14,14,11,11,13,12,11,16,15,15,
	14,11,11,
};

static const static_codebook _44p1_p5_0 = {
	5, 243,
	(long *)_vq_lengthlist__44p1_p5_0,
	1, -527106048, 1620377600, 2, 0,
	(long *)_vq_quantlist__44p1_p5_0,
	0
};

static const long _vq_quantlist__44p1_p5_1[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p1_p5_1[] = {
	 2, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 9, 8, 8, 8,
	 7, 7, 8, 8, 8, 9, 8, 8, 9, 7, 7, 6, 6, 6, 9, 8,
	 7, 9, 7, 7, 9, 8, 8,10, 8, 8,10, 8, 8,10, 8, 8,
	10, 8, 8,10, 8, 8, 7, 6, 6, 9, 6, 6, 9, 7, 7, 9,
	 7, 7,10, 8, 8, 9, 6, 6, 9, 7, 7,10, 8, 8, 9, 7,
	 7, 7, 8, 8,11, 9, 9,11, 9, 9,11, 8, 9,12, 9, 9,
	12, 8, 8,11, 9, 9,12, 9, 9,12, 8, 8, 8, 7, 7,10,
	 9, 9,10,10, 9,10, 9, 9,11,10,10,11, 9, 9,11, 9,
	 9,11,10,11,11, 9, 9,10, 8, 8,11, 9, 9,10, 9, 9,
	11, 9, 9,11,10,10,11, 9, 9,11, 9, 9,11,10,10,11,
	 9, 9, 9, 8, 8,11, 9, 9,12, 9, 9,11, 9, 9,12, 9,
	 9,12, 8, 8,12, 9, 9,12, 9, 9,12, 8, 8, 9, 7, 7,
	11, 9, 9,11,10,10,11, 9, 9,11,11,11,11, 9, 9,11,
	10,10,11,11,11,11, 9, 9,10, 9, 9,11, 9, 9,11,10,
	10,11, 9, 9,11,10,10,11, 9, 9,11, 9,10,11,10,10,
	11, 9, 9,
};

static const static_codebook _44p1_p5_1 = {
	5, 243,
	(long *)_vq_lengthlist__44p1_p5_1,
	1, -530841600, 1616642048, 2, 0,
	(long *)_vq_quantlist__44p1_p5_1,
	0
};

static const long _vq_quantlist__44p1_p6_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p1_p6_0[] = {
	 1, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 8, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 7, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 7, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9,
};

static const static_codebook _44p1_p6_0 = {
	5, 243,
	(long *)_vq_lengthlist__44p1_p6_0,
	1, -516716544, 1630767104, 2, 0,
	(long *)_vq_quantlist__44p1_p6_0,
	0
};

static const long _vq_quantlist__44p1_p6_1[] = {
	12,
	11,
	13,
	10,
	14,
	9,
	15,
	8,
	16,
	7,
	17,
	6,
	18,
	5,
	19,
	4,
	20,
	3,
	21,
	2,
	22,
	1,
	23,
	0,
	24,
};

static const long _vq_lengthlist__44p1_p6_1[] = {
	 1, 3, 2, 5, 4, 7, 7, 8, 8, 9, 9,10,10,11,11,12,
	12,13,13,13,14,16,16,16,16,
};

static const static_codebook _44p1_p6_1 = {
	1, 25,
	(long *)_vq_lengthlist__44p1_p6_1,
	1, -518864896, 1620639744, 5, 0,
	(long *)_vq_quantlist__44p1_p6_1,
	0
};

static const long _vq_quantlist__44p1_p6_2[] = {
	12,
	11,
	13,
	10,
	14,
	9,
	15,
	8,
	16,
	7,
	17,
	6,
	18,
	5,
	19,
	4,
	20,
	3,
	21,
	2,
	22,
	1,
	23,
	0,
	24,
};

static const long _vq_lengthlist__44p1_p6_2[] = {
	 3, 4, 4, 5, 4, 5, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5,
	 5, 5, 5, 5, 5, 5, 5, 5, 5,
};

static const static_codebook _44p1_p6_2 = {
	1, 25,
	(long *)_vq_lengthlist__44p1_p6_2,
	1, -529006592, 1611661312, 5, 0,
	(long *)_vq_quantlist__44p1_p6_2,
	0
};

static const long _huff_lengthlist__44p1_short[] = {
	 4, 5, 7, 8,10,13,14, 4, 2, 4, 6, 8,11,12, 7, 4,
	 3, 5, 8,12,14, 8, 5, 4, 4, 8,12,12, 9, 7, 7, 7,
	 9,10,11,13,11,11, 9, 7, 8,10,13,11,10, 6, 5, 7,
	 9,
};

static const static_codebook _huff_book__44p1_short = {
	2, 49,
	(long *)_huff_lengthlist__44p1_short,
	0, 0, 0, 0, 0,
	NULL,
	0
};

static const long _vq_quantlist__44p2_l0_0[] = {
	6,
	5,
	7,
	4,
	8,
	3,
	9,
	2,
	10,
	1,
	11,
	0,
	12,
};

static const long _vq_lengthlist__44p2_l0_0[] = {
	 1, 4, 4, 7, 7, 8, 8, 9, 9,10,10,11,11, 4, 6, 5,
	 8, 7, 9, 8,10, 9,11,10,11,11, 4, 5, 6, 7, 8, 8,
	 9, 9,10,10,10,10,11, 8, 9, 8,10, 8,10, 9,11,10,
	11,11,11,11, 8, 8, 9, 8,10, 9,10,10,11,11,11,11,
	11, 9,10,10,11,11,11,11,11,11,12,11,12,11, 9,10,
	10,10,11,11,11,11,11,11,12,11,12,10,11,11,12,11,
	12,12,12,12,12,12,12,12,10,11,11,11,11,12,12,12,
	13,12,12,12,12,11,12,12,12,12,13,13,12,12,12,12,
	12,12,11,12,12,12,12,13,13,12,13,12,12,12,12,12,
	13,13,13,13,13,13,12,13,12,13,12,12,12,13,13,13,
	13,13,13,13,12,13,12,12,12,
};

static const static_codebook _44p2_l0_0 = {
	2, 169,
	(long *)_vq_lengthlist__44p2_l0_0,
	1, -526516224, 1616117760, 4, 0,
	(long *)_vq_quantlist__44p2_l0_0,
	0
};

static const long _vq_quantlist__44p2_l0_1[] = {
	2,
	1,
	3,
	0,
	4,
};

static const long _vq_lengthlist__44p2_l0_1[] = {
	 2, 4, 4, 5, 5, 4, 5, 5, 6, 5, 4, 5, 5, 5, 6, 5,
	 5, 6, 6, 6, 5, 6, 5, 6, 6,
};

static const static_codebook _44p2_l0_1 = {
	2, 25,
	(long *)_vq_lengthlist__44p2_l0_1,
	1, -533725184, 1611661312, 3, 0,
	(long *)_vq_quantlist__44p2_l0_1,
	0
};

static const long _vq_quantlist__44p2_l1_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p2_l1_0[] = {
	 1, 4, 4, 4, 4, 4, 4, 4, 4,
};

static const static_codebook _44p2_l1_0 = {
	2, 9,
	(long *)_vq_lengthlist__44p2_l1_0,
	1, -516716544, 1630767104, 2, 0,
	(long *)_vq_quantlist__44p2_l1_0,
	0
};

static const long _huff_lengthlist__44p2_lfe[] = {
	 1, 3, 2, 3,
};

static const static_codebook _huff_book__44p2_lfe = {
	2, 4,
	(long *)_huff_lengthlist__44p2_lfe,
	0, 0, 0, 0, 0,
	NULL,
	0
};

static const long _huff_lengthlist__44p2_long[] = {
	 3, 4, 9, 8, 8,10,13,16, 4, 2, 9, 5, 7,10,14,18,
	 9, 7, 6, 5, 7, 9,12,16, 7, 5, 5, 3, 5, 8,11,13,
	 8, 7, 7, 5, 5, 7, 9,11,10,10, 9, 8, 6, 6, 8,10,
	13,14,13,11, 9, 8, 9,10,17,18,16,14,11,10,10,10,
};

static const static_codebook _huff_book__44p2_long = {
	2, 64,
	(long *)_huff_lengthlist__44p2_long,
	0, 0, 0, 0, 0,
	NULL,
	0
};

static const long _vq_quantlist__44p2_p1_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p2_p1_0[] = {
	 1, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0,
};

static const static_codebook _44p2_p1_0 = {
	5, 243,
	(long *)_vq_lengthlist__44p2_p1_0,
	1, -535822336, 1611661312, 2, 0,
	(long *)_vq_quantlist__44p2_p1_0,
	0
};

static const long _vq_quantlist__44p2_p2_0[] = {
	2,
	1,
	3,
	0,
	4,
};

static const long _vq_lengthlist__44p2_p2_0[] = {
	 1, 4, 4, 0, 0, 0, 8, 8, 0, 0, 0, 9, 9, 0, 0, 0,
	10,10, 0, 0, 0, 0, 0, 0, 0, 0,10,10, 0, 0, 0, 0,
	 0, 0, 0, 0, 9, 9, 0, 0, 0,11,11, 0, 0, 0, 0, 0,
	 0, 0, 0,10,10, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0,
	 0, 0,11,11, 0, 0, 0, 0, 0, 0, 0, 0,11,11, 0, 0,
	 0, 0, 0, 0, 0, 0,10,10, 0, 0, 0,11,11, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 0, 0, 0,
	 6, 6, 0, 0, 0, 7, 7, 0, 0, 0, 8, 8, 0, 0, 0, 0,
	 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7,
	 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 0,
	 0, 0, 0, 0, 0, 0, 0, 7, 7, 0, 0, 0, 9, 9, 0, 0,
	 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0,
	 8, 8, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0,
	 0, 0,10,10, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0,
	 0,10,10, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0,
	11,11, 0, 0, 0, 0, 0, 0, 0, 0,10,10, 0, 0, 0, 0,
	 0, 0, 0, 0, 9, 9, 0, 0, 0,11,10, 0, 0, 0, 0, 0,
	 0, 0, 0,11,11, 0, 0, 0, 0, 0, 0, 0, 0,10,10, 0,
	 0, 0,11,11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 8, 8, 0, 0, 0,10,10, 0, 0, 0,11,11, 0, 0,
	 0,12,12, 0, 0, 0, 0, 0, 0, 0, 0,11,11, 0, 0, 0,
	 0, 0, 0, 0, 0,10,10, 0, 0, 0,13,13, 0, 0, 0, 0,
	 0, 0, 0, 0,13,13, 0, 0, 0, 0, 0, 0, 0, 0,12,12,
	 0, 0, 0,13,13, 0, 0, 0, 0, 0, 0, 0, 0,13,13, 0,
	 0, 0, 0, 0, 0, 0, 0,12,12, 0, 0, 0,13,13, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6,
	 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0,11,11,
	 0, 0, 0,12,12, 0, 0, 0,12,12, 0, 0, 0, 0, 0, 0,
	 0, 0,13,13, 0, 0, 0, 0, 0, 0, 0, 0,12,11, 0, 0,
	 0,12,12, 0, 0, 0, 0, 0, 0, 0, 0,13,13, 0, 0, 0,
	 0, 0, 0, 0, 0,12,12, 0, 0, 0,13,13, 0, 0, 0, 0,
	 0, 0, 0, 0,13,13, 0, 0, 0, 0, 0, 0, 0, 0,12,12,
	 0, 0, 0,13,13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 8, 8, 0, 0, 0,10,10, 0, 0, 0,11,11, 0,
	 0, 0,12,12, 0, 0, 0, 0, 0, 0, 0, 0,13,13, 0, 0,
	 0, 0, 0, 0, 0, 0,12,12, 0, 0, 0,13,13, 0, 0, 0,
	 0, 0, 0, 0, 0,11,11, 0, 0, 0, 0, 0, 0, 0, 0,10,
	10, 0, 0, 0,13,13, 0, 0, 0, 0, 0, 0, 0, 0,14,13,
	 0, 0, 0, 0, 0, 0, 0, 0,13,12, 0, 0, 0,13,13, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0,11,
	11, 0, 0, 0,12,12, 0, 0, 0,12,12, 0, 0, 0, 0, 0,
	 0, 0, 0,12,12, 0, 0, 0, 0, 0, 0, 0, 0,12,12, 0,
	 0, 0,13,13, 0, 0, 0, 0, 0, 0, 0, 0,13,13, 0, 0,
	 0, 0, 0, 0, 0, 0,12,12, 0, 0, 0,12,12, 0, 0, 0,
	 0, 0, 0, 0, 0,13,13, 0, 0, 0, 0, 0, 0, 0, 0,12,
	12, 0, 0, 0,13,13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 9, 9, 0, 0, 0,11,11, 0, 0, 0,12,12,
	 0, 0, 0,12,12, 0, 0, 0, 0, 0, 0, 0, 0,12,12, 0,
	 0, 0, 0, 0, 0, 0, 0,11,11, 0, 0, 0,14,14, 0, 0,
	 0, 0, 0, 0, 0, 0,13,13, 0, 0, 0, 0, 0, 0, 0, 0,
	12,12, 0, 0, 0,12,13, 0, 0, 0, 0, 0, 0, 0, 0,12,
	12, 0, 0, 0, 0, 0, 0, 0, 0,11,11, 0, 0, 0,14,13,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0,
	11,11, 0, 0, 0,12,12, 0, 0, 0,13,13, 0, 0, 0, 0,
	 0, 0, 0, 0,13,13, 0, 0, 0, 0, 0, 0, 0, 0,12,12,
	 0, 0, 0,13,13, 0, 0, 0, 0, 0, 0, 0, 0,12,12, 0,
	 0, 0, 0, 0, 0, 0, 0,12,12, 0, 0, 0,14,14, 0, 0,
	 0, 0, 0, 0, 0, 0,14,14, 0, 0, 0, 0, 0, 0, 0, 0,
	12,12, 0, 0, 0,13,13, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0,
};

static const static_codebook _44p2_p2_0 = {
	5, 3125,
	(long *)_vq_lengthlist__44p2_p2_0,
	1, -533725184, 1611661312, 3, 0,
	(long *)_vq_quantlist__44p2_p2_0,
	0
};

static const long _vq_quantlist__44p2_p3_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p2_p3_0[] = {
	 1, 5, 5, 6, 7, 7, 0, 8, 8, 6, 9, 9, 8,11,11, 0,
	 8, 8, 0, 9, 9, 0,12,12, 0, 8, 8, 5, 7, 7, 7,10,
	10, 0,12,12, 8,11,11, 9,12,12, 0,11,12, 0,12,12,
	 0,15,15, 0,12,12, 0, 6, 6, 0, 6, 6, 0, 7, 7, 0,
	 7, 7, 0,10,10, 0, 7, 7, 0, 8, 8, 0,11,11, 0, 7,
	 7, 6, 7, 7,10, 9, 9, 0,11,10,10, 9, 9,12,12,12,
	 0,10,10, 0,11,11, 0,13,13, 0,11,11, 7, 6, 6,10,
	10,10, 0,11,11,11,11,11,12,12,12, 0,11,11, 0,12,
	12, 0,15,15, 0,11,11, 0,11,11, 0,11,11, 0,12,12,
	 0,12,12, 0,14,14, 0,12,12, 0,12,12, 0,15,15, 0,
	11,11, 0, 8, 8, 0,10,10, 0,11,11, 0,11,11, 0,12,
	12, 0,12,12, 0,11,11, 0,15,15, 0,11,11, 0, 6, 6,
	 0,10,10, 0,12,12, 0,10,10, 0,13,13, 0,12,12, 0,
	13,13, 0,14,14, 0,12,12, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0,
};

static const static_codebook _44p2_p3_0 = {
	5, 243,
	(long *)_vq_lengthlist__44p2_p3_0,
	1, -533200896, 1614282752, 2, 0,
	(long *)_vq_quantlist__44p2_p3_0,
	0
};

static const long _vq_quantlist__44p2_p3_1[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p2_p3_1[] = {
	 2, 3, 3, 0, 8, 8, 0, 8, 8, 0, 9, 9, 0, 9, 9, 0,
	 9, 9, 0, 9, 9, 0, 9, 9, 0, 8, 8, 0, 6, 6, 0, 7,
	 7, 0, 7, 7, 0, 8, 8, 0, 8, 8, 0, 8, 8, 0, 8, 8,
	 0, 8, 8, 0, 8, 8, 0, 6, 6, 0, 6, 6, 0, 6, 6, 0,
	 8, 8, 0, 9, 9, 0, 7, 7, 0, 8, 8, 0, 9, 9, 0, 6,
	 6, 0, 8, 8, 0, 9, 9, 0, 9, 9, 0,10,10, 0,10,10,
	 0,10,10, 0,10,10, 0,11,11, 0, 9, 9, 0, 7, 7, 0,
	10,10, 0,10,10, 0,12,11, 0,12,12, 0,11,11, 0,11,
	11, 0,12,12, 0,10,10, 0, 7, 7, 0,10,10, 0,10,10,
	 0,12,12, 0,11,12, 0,11,11, 0,11,11, 0,11,11, 0,
	10,10, 0, 8, 8, 0, 9, 9, 0, 9, 9, 0,10,10, 0,10,
	10, 0,10, 9, 0,10,10, 0,10,10, 0, 9, 9, 0, 6, 6,
	 0,10,10, 0,10,10, 0,11,11, 0,12,12, 0,11,11, 0,
	11,11, 0,12,12, 0,11,11, 0, 7, 7, 0, 9, 9, 0, 9,
	 9, 0,11,11, 0,11,11, 0,10,10, 0,10,10, 0,11,11,
	 0, 9, 9,
};

static const static_codebook _44p2_p3_1 = {
	5, 243,
	(long *)_vq_lengthlist__44p2_p3_1,
	1, -535822336, 1611661312, 2, 0,
	(long *)_vq_quantlist__44p2_p3_1,
	0
};

static const long _vq_quantlist__44p2_p4_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p2_p4_0[] = {
	 1, 6, 6, 6, 7, 7, 7, 8, 8, 7, 8, 8,10,11,11, 9,
	 8, 8, 7, 8, 8,11,11,11, 9, 8, 8, 6, 7, 7, 9,11,
	11, 9,11,11,10,11,11,12,13,13,11,12,12,10,11,11,
	13,14,14,12,12,12, 6, 6, 6, 8, 6, 6, 8, 7, 7, 9,
	 7, 7,11,10,10,10, 6, 6, 9, 7, 7,12,10,10,11, 6,
	 7, 7, 7, 7,11,10,10,12,10,10,11,10,10,14,13,13,
	13,10,10,12,11,11,15,13,13,14,10,10, 8, 7, 7,12,
	11,11,12,11,11,11,11,11,14,14,14,13,12,12,12,11,
	11,15,15,15,13,12,12, 0,10,10, 0,11,11, 0,11,11,
	 0,11,11, 0,14,14, 0,11,11, 0,11,11, 0,15,15, 0,
	11,11, 7, 8, 8,12,10,10,12,10,10,12,11,11,15,13,
	13,14,11,11,12,10,10,16,14,14,14,10,10, 8, 7, 7,
	12,11,11,12,11,11,12,11,11,16,14,14,14,12,12,13,
	12,12,15,14,14,15,12,12, 0,11,11, 0,12,12, 0,12,
	12, 0,12,12, 0,15,15, 0,12,12, 0,12,12, 0,14,14,
	 0,12,12,
};

static const static_codebook _44p2_p4_0 = {
	5, 243,
	(long *)_vq_lengthlist__44p2_p4_0,
	1, -531365888, 1616117760, 2, 0,
	(long *)_vq_quantlist__44p2_p4_0,
	0
};

static const long _vq_quantlist__44p2_p4_1[] = {
	2,
	1,
	3,
	0,
	4,
};

static const long _vq_lengthlist__44p2_p4_1[] = {
	 3, 4, 4, 8, 8,11, 9, 9,12,12,11,10,10,12,12,12,
	10,10,11,11,12,12,12,12,12,12,11,11,13,13,12,12,
	12,13,13,12,10,10,12,12,12,11,11,13,13,12,13,13,
	13,13,12,11,11,13,13,12,12,12,13,13,12,10,10,12,
	12,12,11,11,13,13,12,13,13,12,12,12,11,11,13,13,
	12,13,13,13,13,12,11,11,12,12,12,11,11,12,12,12,
	13,13,12,12,12,13,13,13,13,12,13,13,13,13,13,13,
	13,12,12,12,13,13,13,13,12,13,13,12,12,11, 8, 8,
	10,10,12,11,11,11,11,12,10,10,10,10,13,11,11,10,
	10,13,11,11,10,10,13,12,12,12,12,13,11,11,11,11,
	13,12,12,11,11,13,12,12,11,11,13,12,12,12,11,13,
	12,12,12,12,13,11,11,11,11,13,12,12,11,11,13,11,
	12,11,11,13,12,12,11,11,14,12,12,11,11,13,11,11,
	11,11,14,12,12,11,11,13,11,12,10,10,14,12,12,11,
	11,14,12,12,11,11,14,11,11,11,11,14,12,12,11,11,
	13,12,12,11,11,14,12,12,11,11,11, 8, 8,10,10,12,
	 7, 7,10,10,12, 9, 9,11,11,13, 9, 9, 9, 9,13,13,
	13,10,10,13, 9, 9,12,12,13,13,13,12,12,13, 9, 8,
	11,11,13,10,10,12,12,14,13,13,11,11,13, 9, 9,11,
	11,13,13,13,12,12,13, 9, 9,10,10,13,10,10,11,11,
	13,13,13,10,10,14,10,10,11,11,14,14,14,12,12,13,
	 9, 9,10,10,13,10,10,11,11,14,13,14,10,10,14,14,
	14,11,12,14,14,14,14,14,14,13,13,10,10,13,14,14,
	11,11,14,14,14,10,10,14, 9, 9, 9, 9,14, 9, 9, 9,
	 9,14,10,10, 9, 9,14,10,10, 8, 8,14,11,11, 8, 8,
	15,11,11,10,10,15,12,12,10,10,15,10,10,10,10,15,
	11,11,10,10,15,13,13,10,10,15,11,11,10,10,15,12,
	12,10,10,15,10,10,10,10,15,11,11,10,10,15,13,13,
	10,10,15,11,11,10,10,15,12,12,10,10,15,11,11, 9,
	 9,15,11,11, 9, 9,15,13,13, 9, 9,15,13,13,10,10,
	15,12,12,10,10,15,13,13,10,10,15,13,12, 9, 9,15,
	13,13, 9, 9,14,12,12, 9, 9,14,13,13, 9, 9,14,13,
	13, 9, 9,14,13,13, 7, 7,14,13,13, 8, 8,15,14,14,
	10,10,15,14,14,10,10,15,14,14,10,10,15,14,14,10,
	10,15,14,14, 9, 9,15,14,14,10,10,15,14,14,10,10,
	14,14,14, 9, 9,15,14,14,10,10,14,14,14, 9, 9,15,
	14,14,10,10,15,14,14,10,10,14,14,14, 9, 9,14,14,
	14, 9, 9,14,14,14, 8, 8,15,14,14,10,10,15,14,14,
	11,11,15,14,14, 9, 9,15,14,14, 9, 9,14,14,14, 8,
	 8,13, 9, 9,12,12,17,11,11,12,12,17,12,12,12,12,
	17,12,12,11,11,18,15,15,12,12,17,12,12,12,12,17,
	14,15,13,13,17,12,12,12,12,17,13,13,12,13,17,15,
	15,12,12,18,13,13,13,13,18,15,15,13,13,18,12,12,
	12,12,18,13,13,13,13,18,15,15,12,12,18,13,13,12,
	12,18,15,15,13,13,18,13,13,12,12,17,13,13,12,12,
	17,15,15,12,12,18,15,15,13,13,18,15,15,13,14,18,
	15,16,12,12,18,15,15,12,12,18,16,16,12,12,13, 8,
	 8,10,10,14,15,14,11,11,14,15,15,12,12,15,14,14,
	12,11,15,15,15,12,12,15,15,15,12,12,15,15,15,13,
	13,15,15,15,12,12,15,15,15,13,13,15,15,15,13,13,
	15,15,15,13,13,15,15,16,13,13,15,15,15,12,12,15,
	15,15,13,13,15,15,15,13,13,15,15,15,13,13,15,15,
	15,13,13,15,15,14,12,12,15,15,15,12,12,16,15,14,
	12,12,16,15,15,13,13,16,16,16,13,13,16,15,15,12,
	12,15,15,15,13,13,15,15,15,12,12,13,12,12,10,10,
	14,14,14,11,11,15,14,14,12,12,15,14,14,11,11,15,
	14,14,11,11,15,15,15,13,13,15,14,14,13,13,15,15,
	15,12,12,15,14,15,13,13,16,15,15,12,12,15,15,15,
	13,13,16,14,14,13,13,15,15,15,12,12,15,15,15,13,
	13,16,15,15,12,12,16,15,15,12,12,16,14,14,13,13,
	15,15,15,11,11,15,15,15,12,12,16,15,15,11,11,16,
	15,15,13,13,16,14,15,14,14,16,15,15,12,12,16,15,
	14,12,12,16,15,15,12,12,14,10,10, 9, 9,14,11,11,
	12,12,14,12,12,13,13,14,12,12,12,12,15,14,14,13,
	13,15,13,13,14,14,15,14,14,15,15,15,12,12,13,13,
	15,13,13,14,14,15,14,14,13,13,15,13,13,13,14,15,
	14,14,15,15,15,12,12,13,13,15,13,13,14,14,15,14,
	14,13,13,15,13,13,14,14,15,14,14,15,15,15,13,13,
	12,12,15,13,13,13,13,15,14,14,13,12,15,15,15,14,
	15,15,15,14,20,20,15,14,14,13,13,15,14,14,13,13,
	15,14,14,13,13,14,12,12, 9, 9,14,14,14,12,12,14,
	13,13,12,13,14,14,14,12,12,15,14,14,12,12,15,14,
	14,14,13,15,14,14,14,14,15,14,14,13,13,15,14,14,
	13,13,15,15,15,14,14,15,14,14,13,13,15,14,14,14,
	14,15,14,14,13,13,15,14,14,13,13,15,15,15,15,14,
	15,15,15,13,13,15,14,14,14,14,15,14,14,13,13,15,
	14,14,13,13,14,15,15,14,14,15,15,15,14,14,15,14,
	14,14,14,15,15,15,14,14,15,14,14,13,14,15,15,15,
	14,14,13,10,10,12,12,17,11,11,12,12,17,12,12,12,
	12,17,12,12,11,11,17,15,15,12,11,18,13,13,13,13,
	18,15,15,13,13,17,12,12,12,12,18,13,13,13,13,17,
	15,15,12,12,17,12,12,12,12,17,15,15,13,13,17,12,
	12,12,12,17,13,13,12,12,17,15,15,12,12,18,14,13,
	12,12,18,15,15,13,13,18,13,13,12,12,18,13,13,12,
	12,18,16,16,12,12,18,16,16,12,12,18,15,15,13,13,
	18,16,16,12,12,17,15,15,12,12,17,16,16,12,12,13,
	 8, 8,10,10,14,14,15,12,12,14,15,15,12,12,15,14,
	14,12,12,15,15,14,12,12,15,15,15,13,13,15,15,15,
	13,13,15,15,15,12,12,16,15,15,13,13,16,15,15,13,
	13,15,15,15,12,12,15,15,15,14,14,15,15,15,12,12,
	15,15,15,13,13,16,15,15,13,13,15,15,15,13,13,16,
	15,15,13,13,15,15,14,12,12,15,15,15,12,12,16,14,
	15,13,13,16,15,15,13,13,15,16,15,13,13,16,15,14,
	13,13,16,15,15,13,13,16,15,15,13,13,13,12,12,11,
	11,14,14,14,11,11,14,14,14,12,12,15,14,14,11,11,
	16,14,14,11,11,15,15,15,12,13,16,14,14,13,13,15,
	15,15,12,12,15,14,14,13,13,16,15,15,12,12,15,15,
	15,12,12,15,14,14,13,13,15,15,15,12,12,15,14,14,
	12,12,16,15,15,12,12,16,15,15,12,12,16,14,14,13,
	13,15,15,15,11,11,15,15,14,12,12,16,15,15,11,11,
	16,15,15,12,12,16,14,14,13,13,16,15,15,11,11,16,
	14,14,12,12,16,15,15,11,11,14,10,10, 9, 9,14,11,
	11,12,12,14,12,12,13,14,14,12,12,12,12,14,14,14,
	13,13,15,13,13,14,14,15,14,14,15,15,15,12,12,13,
	13,15,13,13,14,14,15,15,15,14,14,15,13,13,14,14,
	15,15,15,15,15,15,12,12,13,13,15,13,13,14,14,15,
	14,14,13,13,15,13,13,14,14,15,14,14,15,15,15,12,
	12,13,13,15,13,13,13,13,14,14,14,13,13,15,15,15,
	14,15,15,15,15,21,19,15,14,14,13,13,15,14,14,14,
	14,14,14,14,13,13,14,12,12, 9, 9,14,14,14,12,12,
	14,14,13,13,13,14,14,14,12,12,14,14,14,12,12,15,
	14,14,13,13,15,14,14,14,14,15,14,14,13,13,15,14,
	14,13,13,15,15,15,15,15,15,14,14,13,13,15,14,14,
	14,14,15,14,14,13,13,15,14,14,13,13,14,15,15,15,
	15,15,14,15,13,13,15,14,14,14,14,15,14,14,13,13,
	15,14,14,13,13,14,15,15,14,14,15,15,15,14,14,15,
	14,14,14,14,15,15,15,15,15,15,14,14,14,13,14,15,
	15,14,14,13,10,10,12,12,18,12,12,12,12,17,12,12,
	12,12,18,13,13,11,11,18,15,14,11,11,17,13,13,13,
	13,18,15,15,12,12,18,12,12,12,12,17,13,13,12,12,
	18,15,15,12,12,18,13,13,13,12,18,15,15,13,13,18,
	13,13,12,12,18,13,13,12,12,18,15,15,12,12,17,13,
	13,12,12,17,15,15,12,12,17,12,12,11,11,17,13,13,
	11,11,17,15,15,11,11,18,16,16,12,12,18,15,15,13,
	13,18,15,15,11,11,17,15,15,12,12,18,15,15,11,11,
	13, 8, 8,10,10,14,14,14,11,11,15,15,15,12,12,15,
	14,14,11,11,16,14,14,12,12,15,15,15,12,12,15,15,
	15,13,13,15,15,15,12,12,15,15,15,12,12,16,15,15,
	13,13,15,15,15,12,12,15,15,15,13,13,16,15,15,12,
	12,15,15,15,12,12,16,15,15,13,13,16,15,15,12,12,
	15,15,15,13,13,15,14,14,12,12,15,15,15,12,12,16,
	15,14,12,12,16,15,15,13,13,16,16,16,13,13,16,14,
	15,13,13,15,15,15,13,13,16,15,15,12,12,13,12,12,
	10,10,14,14,14,11,11,15,14,14,12,12,15,14,14,11,
	11,16,14,14,11,11,15,14,15,12,12,15,14,14,13,13,
	15,15,15,12,12,15,14,14,12,12,15,14,15,12,12,15,
	15,15,12,12,16,14,14,13,13,15,15,15,11,12,16,14,
	14,12,12,16,15,15,12,12,15,15,15,12,12,16,14,14,
	12,12,15,15,15,11,11,15,14,14,11,12,15,15,14,11,
	11,16,15,15,12,12,16,14,14,13,13,16,15,15,11,11,
	16,14,14,12,12,16,15,15,11,11,13,10,10, 8, 8,14,
	12,12,12,12,14,12,12,13,13,14,12,12,12,12,14,14,
	14,13,13,15,13,13,14,14,15,15,14,15,15,15,13,13,
	13,13,15,13,13,14,14,15,14,15,14,14,15,13,13,13,
	13,15,15,15,15,15,15,12,12,13,12,15,13,13,14,14,
	15,14,14,13,13,15,13,13,14,13,15,15,15,16,16,15,
	13,13,12,12,15,13,13,13,13,14,14,14,12,12,15,15,
	15,14,14,15,15,15,20,20,15,14,14,13,13,15,15,14,
	14,14,15,14,14,13,13,13,12,12, 9, 9,14,13,13,12,
	12,14,13,13,12,12,14,14,14,12,12,14,14,14,13,13,
	15,14,14,13,13,15,14,14,14,14,15,15,14,12,12,15,
	14,14,13,13,15,14,15,14,15,15,14,14,13,13,15,14,
	14,14,14,15,14,14,12,12,15,14,14,13,13,14,15,14,
	15,14,15,14,14,13,13,15,14,14,14,14,15,14,14,12,
	12,15,14,14,13,13,15,15,15,14,14,15,15,15,14,14,
	16,14,14,14,14,15,15,15,14,14,15,14,14,14,14,14,
	15,15,14,14,13,13,13,12,13,17,15,15,12,12,17,15,
	15,12,12,18,15,15,11,11,17,16,16,11,11,18,16,16,
	13,13,18,17,16,13,13,18,16,16,12,12,18,16,16,12,
	12,18,17,17,12,12,17,16,16,12,13,17,16,16,12,13,
	17,16,16,12,12,17,16,16,12,12,18,17,16,12,12,18,
	16,16,12,12,17,16,17,12,12,18,15,15,11,11,18,15,
	15,12,12,17,17,17,11,11,17,17,17,12,12,17,16,16,
	13,13,18,16,16,11,11,18,16,16,12,12,18,17,16,11,
	11,14,14,14,10,10,16,15,14,11,11,16,15,15,12,12,
	16,14,14,12,12,17,14,14,13,13,17,15,15,13,13,17,
	15,15,14,14,16,15,15,12,12,16,15,15,13,13,18,15,
	15,14,14,16,15,15,12,12,16,15,15,14,14,16,15,15,
	12,12,16,15,15,13,13,17,15,15,13,13,17,15,15,13,
	13,17,15,15,14,14,16,14,14,12,12,17,15,15,12,12,
	18,15,15,13,13,17,15,15,14,14,17,16,16,15,15,17,
	15,14,13,13,17,15,15,14,14,17,15,15,13,13,14,12,
	12,11,11,15,14,14,12,12,16,14,14,12,12,16,14,14,
	11,11,17,14,14,12,12,16,15,14,13,13,16,14,14,13,
	13,16,15,15,12,12,16,14,14,13,13,17,15,15,13,13,
	16,15,15,13,13,17,14,14,13,13,16,15,15,12,12,16,
	14,14,12,12,16,15,15,12,12,17,15,15,12,12,17,14,
	14,13,13,16,15,15,12,12,16,14,14,12,12,16,15,15,
	12,12,17,15,15,13,13,17,14,14,13,13,17,15,15,12,
	12,17,14,14,12,12,17,15,15,12,12,14,14,14, 8, 8,
	14,14,14,13,13,14,15,15,14,14,14,14,14,14,14,15,
	15,15,19,19,15,15,15,14,14,15,15,16,20,19,15,15,
	15,14,14,15,16,16,15,15,15,15,15,19,19,15,15,15,
	14,14,15,16,16,19,20,15,15,15,14,14,15,15,15,15,
	15,15,15,15,19,19,15,15,15,15,15,15,15,16,19,20,
	15,14,15,14,14,15,15,15,15,15,15,15,15,20,19,15,
	15,15,21,19,15,16,16,20,20,15,15,14,19,19,15,15,
	16,20,21,15,15,15,20,19,13,12,12, 9, 9,14,14,14,
	12,12,14,13,13,13,13,14,14,14,13,13,15,14,14,20,
	19,15,14,14,14,13,15,14,14,19,19,15,15,14,13,13,
	15,14,14,14,14,15,15,15,19,20,15,14,14,13,13,15,
	14,14,20,19,14,15,14,13,13,15,14,14,14,13,15,15,
	15,19,20,15,15,14,14,14,15,14,14,21,19,15,15,15,
	13,13,15,14,14,14,14,14,15,15,20,20,15,15,15,21,
	20,15,14,14,19,20,15,15,15,20,20,15,14,14,19,20,
	15,15,15,21,19,
};

static const static_codebook _44p2_p4_1 = {
	5, 3125,
	(long *)_vq_lengthlist__44p2_p4_1,
	1, -533725184, 1611661312, 3, 0,
	(long *)_vq_quantlist__44p2_p4_1,
	0
};

static const long _vq_quantlist__44p2_p5_0[] = {
	2,
	1,
	3,
	0,
	4,
};

static const long _vq_lengthlist__44p2_p5_0[] = {
	 2, 6, 6,14,14, 6, 7, 7,14,14, 7, 7, 7,15,15, 0,
	13,13,16,16, 0,13,13,15,15, 7, 8, 8,15,15, 9,10,
	10,17,16, 9, 8, 8,15,15, 0,13,13,18,17, 0,13,13,
	16,16, 8, 8, 8,15,15,12,11,11,16,17, 9, 8, 8,14,
	14, 0,13,13,18,17, 0,13,13,16,15, 0,14,14,18,17,
	 0,20,22,18,20, 0,12,12,16,16, 0,16,16,22,20, 0,
	14,14,16,16, 0,14,14,17,17, 0,22,22,22,19, 0,12,
	13,16,16, 0,17,17, 0, 0, 0,15,15,16,16, 5, 7, 7,
	13,13, 9, 9, 9,15,14,10,10,10,14,14, 0,21,21,18,
	17, 0,21,22,18,17, 9,10,10,14,14,12,12,12,17,17,
	12,10,10,14,14, 0,19,21,18,17, 0,20,22,18,18,11,
	10,10,14,14,14,13,13,18,17,12,11,11,14,14, 0,22,
	19,17,18, 0,20, 0,18,17, 0,22,21,17,17, 0, 0, 0,
	 0, 0, 0,20,22,17,17, 0,22, 0,21,19, 0,22, 0,18,
	18, 0, 0,22,18,19, 0, 0, 0, 0, 0, 0,19,21,17,17,
	 0, 0, 0,20,20, 0, 0, 0,18,18, 6, 6, 6,13,12, 8,
	 6, 6,11,11, 8, 6, 6,13,13, 0, 9, 9,11,11, 0,11,
	11,14,14, 9, 7, 7,13,13,11, 9, 9,13,13,10, 6, 6,
	13,13, 0,10,10,14,14, 0,10,10,13,13, 9, 7, 7,13,
	14,13, 9, 9,13,13,10, 6, 6,13,12, 0,11,11,15,15,
	 0,10,10,13,13, 0,12,12,15,15, 0,19, 0,17,17, 0,
	 9, 9,13,13, 0,13,14,19,20, 0,11,11,13,13, 0,11,
	11,14,14, 0,19,20,17,18, 0,10,10,13,13, 0,15,15,
	21,19, 0,12,12,13,13, 0,10,10,12,13, 0,11,11,15,
	15, 0,11,11,15,15, 0,15,15,22, 0, 0,16,17,22, 0,
	 0,11,11,15,15, 0,14,14,18,17, 0,11,11,15,16, 0,
	15,15,22,21, 0,16,16, 0,20, 0,12,12,16,15, 0,15,
	14,19,19, 0,11,11,16,16, 0,15,15,21, 0, 0,16,15,
	 0, 0, 0,16,16,22,21, 0, 0, 0, 0, 0, 0,15,15,20,
	20, 0,18,18, 0, 0, 0,16,17, 0, 0, 0,17,17, 0,22,
	 0, 0, 0, 0, 0, 0,15,15,21,22, 0,20,18, 0, 0, 0,
	18,17,22, 0, 0,10,10,12,11, 0,10,10,10,10, 0,11,
	11,12,12, 0,11,11, 9, 9, 0,13,13,12,12, 0,11,11,
	12,12, 0,13,13,12,12, 0,10,10,12,12, 0,13,12,13,
	13, 0,12,12,12,12, 0,11,11,12,12, 0,13,13,12,12,
	 0,10,10,12,12, 0,13,13,13,14, 0,12,12,12,12, 0,
	13,14,14,14, 0,20,21,15,15, 0,12,11,12,12, 0,15,
	16,20,22, 0,13,12,11,11, 0,13,13,14,13, 0,20, 0,
	16,15, 0,12,12,12,12, 0,16,16,22,21, 0,13,13,12,
	12, 6, 7, 7,16,16,11, 9, 9,15,15,12, 9, 9,16,16,
	 0,13,13,14,14, 0,14,14,16,17,10, 9, 9,16,16,14,
	12,12,16,16,12, 9, 9,15,15, 0,13,13,18,18, 0,13,
	13,15,16,12,10,10,17,18,15,12,12,17,17,13, 9, 9,
	16,16, 0,13,13,17,18, 0,14,14,16,16, 0,15,15,18,
	18, 0,22, 0,20,20, 0,12,12,16,16, 0,16,16,20,22,
	 0,14,14,16,16, 0,15,14,18,18, 0, 0,22,19,21, 0,
	13,13,16,17, 0,17,17,22,22, 0,15,15,16,16, 7, 7,
	 7,14,14,11,10,10,15,15,12,10,10,15,14, 0,22, 0,
	18,18, 0, 0,21,17,18,11,10,10,15,15,14,12,12,17,
	17,14,11,11,15,15, 0,22,20,18,18, 0, 0,20,18,17,
	12,10,10,16,16,17,14,14,19,18,14,11,11,15,15, 0,
	21,22,19,19, 0,21,22,18,18, 0,22, 0,19,21, 0, 0,
	 0, 0, 0, 0,22,22,18,17, 0, 0, 0,21,20, 0,22,22,
	20,19, 0, 0,22,20,20, 0, 0, 0, 0, 0, 0,20,21,17,
	17, 0, 0,22,21,21, 0, 0, 0,18,18,10, 9, 9,14,14,
	13,10,10,13,13,13,10,11,14,14, 0,13,13,12,12, 0,
	15,15,16,16,13,10,10,15,15,15,12,12,14,14,15,10,
	10,14,15, 0,14,14,16,15, 0,14,14,15,15,13,10,10,
	15,15,18,13,13,15,15,15,10,10,14,15, 0,14,14,16,
	16, 0,14,14,15,15, 0,15,15,16,16, 0,22, 0,18,18,
	 0,12,13,14,14, 0,17,17,22, 0, 0,14,14,14,14, 0,
	15,15,16,16, 0,22, 0,18,17, 0,13,13,14,14, 0,19,
	18,21,22, 0,15,15,14,14, 0,11,11,13,13, 0,12,12,
	16,16, 0,12,12,16,16, 0,15,16,21, 0, 0,16,17, 0,
	22, 0,12,12,16,16, 0,14,14,17,18, 0,11,11,16,16,
	 0,15,15,21,22, 0,16,16, 0, 0, 0,12,12,16,16, 0,
	15,15, 0,19, 0,12,12,16,17, 0,16,16,22, 0, 0,16,
	16, 0,22, 0,17,17, 0,22, 0, 0, 0, 0, 0, 0,15,15,
	20,19, 0,18,18, 0, 0, 0,17,18, 0, 0, 0,17,17, 0,
	 0, 0, 0, 0, 0, 0, 0,15,15, 0,22, 0,20,18, 0, 0,
	 0,18,18,22,22, 0,11,11,14,14, 0,12,12,14,14, 0,
	12,12,15,15, 0,13,13,14,14, 0,14,14,17,16, 0,12,
	12,16,16, 0,14,14,16,16, 0,11,11,15,15, 0,13,13,
	16,16, 0,13,13,15,15, 0,12,12,15,15, 0,15,14,16,
	16, 0,11,11,15,15, 0,14,14,17,17, 0,13,13,15,15,
	 0,15,15,17,17, 0, 0, 0,19,18, 0,13,12,15,15, 0,
	16,16, 0, 0, 0,14,14,15,15, 0,14,14,16,17, 0,22,
	 0,18,18, 0,13,13,15,15, 0,17,17, 0, 0, 0,14,14,
	15,15, 8, 8, 8,16,16,12,10,10,16,16,13, 9, 9,16,
	16, 0,14,14,17,17, 0,14,14,17,16,12,10,10,18,17,
	14,11,11,18,18,14, 9,10,16,16, 0,13,13,18,19, 0,
	14,13,16,16,12, 9, 9,16,16,17,13,13,17,17,14, 9,
	 9,15,15, 0,14,14,19,20, 0,13,13,15,15, 0,15,15,
	18,19, 0, 0,22,22,22, 0,13,13,17,17, 0,16,16,19,
	21, 0,14,14,16,16, 0,14,14,18,18, 0, 0, 0, 0, 0,
	 0,13,13,16,16, 0,18,18, 0, 0, 0,15,15,16,16, 8,
	 7, 7,14,14,12,10,10,15,15,13,10,10,15,14, 0,22,
	 0,18,18, 0,22, 0,18,18,12,10,10,16,15,15,12,12,
	17,17,14,11,11,15,15, 0,20,21,19,18, 0, 0, 0,17,
	18,13,11,11,15,15,16,13,13,18,18,15,11,11,14,14,
	 0,22,21,19,19, 0,21,22,18,18, 0,22,22,20,18, 0,
	 0, 0, 0, 0, 0,22,19,17,17, 0, 0, 0,22,21, 0, 0,
	22,19,17, 0, 0,22,19,19, 0, 0, 0, 0, 0, 0,22,21,
	18,17, 0, 0, 0,22, 0, 0, 0, 0,19,19, 0,10,10,14,
	14, 0,11,11,15,14, 0,11,11,15,15, 0,14,14,15,14,
	 0,15,15,16,16, 0,11,11,16,16, 0,13,13,16,16, 0,
	11,11,15,15, 0,14,14,17,16, 0,14,14,15,15, 0,11,
	11,16,16, 0,14,13,15,15, 0,11,11,15,15, 0,15,15,
	17,17, 0,14,14,15,14, 0,16,16,17,17, 0, 0,22,18,
	18, 0,13,13,15,15, 0,17,17,22, 0, 0,15,15,15,14,
	 0,15,16,16,17, 0, 0,22,18,19, 0,13,13,15,15, 0,
	20,18,21, 0, 0,15,15,14,14, 0,11,11,13,13, 0,12,
	12,16,16, 0,12,12,16,15, 0,15,16,22,22, 0,17,17,
	 0, 0, 0,12,12,16,16, 0,14,14,18,18, 0,11,11,16,
	16, 0,15,16,22,20, 0,16,16, 0,22, 0,12,12,16,16,
	 0,15,15,18,20, 0,11,11,16,16, 0,15,15, 0, 0, 0,
	16,16, 0, 0, 0,17,17,22, 0, 0, 0, 0, 0, 0, 0,15,
	15, 0,21, 0,18,18, 0, 0, 0,17,16, 0, 0, 0,17,17,
	22,22, 0, 0, 0, 0, 0, 0,15,15,21, 0, 0,20,22, 0,
	 0, 0,18,18, 0, 0, 0,12,12,15,15, 0,12,12,15,15,
	 0,12,12,16,16, 0,13,13,15,15, 0,15,15,17,17, 0,
	13,12,16,16, 0,14,14,16,16, 0,12,11,16,16, 0,14,
	14,17,17, 0,14,14,16,16, 0,12,12,16,16, 0,15,15,
	17,16, 0,11,11,15,16, 0,14,14,17,17, 0,14,14,16,
	16, 0,15,15,18,18, 0, 0, 0,22,19, 0,13,13,15,16,
	 0,16,17, 0, 0, 0,14,14,16,16, 0,15,15,18,17, 0,
	 0, 0,20,20, 0,13,13,16,15, 0,17,17,22,22, 0,14,
	14,15,15, 0,11,11,16,16, 0,13,13,16,17, 0,13,13,
	17,18, 0,16,16,17,17, 0,17,17,18,18, 0,12,12,17,
	17, 0,16,15,18,18, 0,12,12,16,16, 0,16,16,18,18,
	 0,15,15,17,17, 0,12,12,17,17, 0,16,16,19,18, 0,
	12,12,16,17, 0,16,16,19,19, 0,15,16,16,17, 0,16,
	16,19,17, 0, 0, 0,20,22, 0,13,13,16,16, 0,19,18,
	21, 0, 0,15,15,16,16, 0,16,16,18,18, 0, 0, 0,22,
	21, 0,14,14,16,16, 0,21,19,21,22, 0,16,16,16,16,
	 0, 9, 9,14,14, 0,13,13,15,15, 0,14,14,15,15, 0,
	 0,20,18,19, 0, 0,22,18,18, 0,12,12,15,15, 0,15,
	15,17,18, 0,14,13,14,14, 0,20, 0,18,18, 0,21, 0,
	18,17, 0,13,13,15,16, 0,17,17,18,18, 0,14,14,15,
	15, 0,22,22,20,19, 0,20,21,18,18, 0,20,22,19,19,
	 0, 0, 0, 0, 0, 0,20,20,17,17, 0, 0,22,22,21, 0,
	22, 0,18,18, 0,20,22,19,19, 0, 0, 0, 0, 0, 0,21,
	21,17,18, 0, 0, 0,21,20, 0, 0,22,19,18, 0,18,18,
	15,15, 0,22,21,17,16, 0, 0,22,17,17, 0,20,22,18,
	18, 0, 0,22,20,20, 0,21,19,16,16, 0,21,21,18,18,
	 0,19,19,17,17, 0, 0,22,19,19, 0,22,20,17,17, 0,
	21,19,16,16, 0,22,22,19,18, 0,19,20,16,16, 0,22,
	21,19,21, 0,21,22,17,18, 0,21,20,18,18, 0, 0, 0,
	19,20, 0,20,19,16,16, 0,22,22, 0, 0, 0,21,21,17,
	16, 0,22,20,19,18, 0, 0, 0,20,20, 0,20,19,16,16,
	 0, 0, 0, 0, 0, 0,21,22,17,17, 0,11,11,13,13, 0,
	13,13,15,16, 0,13,13,16,16, 0,17,18,21, 0, 0,17,
	18, 0, 0, 0,12,12,15,16, 0,15,15,19,18, 0,12,12,
	16,16, 0,17,17,22, 0, 0,17,17, 0,22, 0,12,12,17,
	16, 0,16,16,19,20, 0,12,12,16,16, 0,17,17, 0, 0,
	 0,17,17, 0,21, 0,17,16,22, 0, 0, 0, 0, 0, 0, 0,
	15,15,20,22, 0,20,18, 0, 0, 0,18,18, 0, 0, 0,17,
	17,21, 0, 0, 0, 0, 0, 0, 0,15,15,21,22, 0,19,20,
	22, 0, 0,19,18, 0, 0, 0,14,14,18,18, 0,16,16,22,
	20, 0,16,16,22,19, 0,17,17,20,22, 0,19,19, 0, 0,
	 0,15,15,20, 0, 0,18,21, 0,20, 0,15,15,21,20, 0,
	18,17, 0, 0, 0,17,17, 0,22, 0,15,15,19,19, 0,19,
	18, 0, 0, 0,15,15,20, 0, 0,18,18,22,22, 0,17,17,
	 0,20, 0,18,18, 0, 0, 0, 0,22, 0, 0, 0,15,15,19,
	20, 0,20,19, 0, 0, 0,17,17,20,21, 0,17,18,20,22,
	 0, 0, 0, 0,22, 0,15,15,20,20, 0,22,20, 0, 0, 0,
	17,18,20, 0, 0,12,12,17,16, 0,14,14,17,17, 0,13,
	13,17,17, 0,16,16,18,18, 0,17,16,17,17, 0,13,13,
	17,17, 0,15,16,18,18, 0,13,13,16,16, 0,16,16,18,
	18, 0,16,16,17,16, 0,13,13,16,16, 0,17,17,18,17,
	 0,12,12,15,16, 0,17,17,19,19, 0,16,16,16,16, 0,
	16,17,19,18, 0, 0, 0,21,22, 0,14,14,16,16, 0,18,
	18, 0,22, 0,16,16,16,16, 0,16,16,18,17, 0, 0, 0,
	21,20, 0,14,14,16,16, 0,21,22,22, 0, 0,16,16,16,
	16, 0, 9, 9,14,13, 0,13,14,15,16, 0,14,13,15,14,
	 0,22, 0,18,18, 0,21, 0,17,18, 0,13,13,15,15, 0,
	15,16,18,17, 0,14,14,15,14, 0,20,22,18,18, 0,22,
	21,17,17, 0,13,13,15,15, 0,17,17,19,19, 0,14,14,
	14,14, 0, 0,22,18,18, 0, 0,22,17,17, 0, 0,22,19,
	20, 0, 0, 0, 0, 0, 0,21,20,17,16, 0, 0, 0,21,22,
	 0, 0, 0,18,19, 0, 0, 0,18,18, 0, 0, 0, 0, 0, 0,
	22, 0,17,17, 0, 0, 0,20,22, 0, 0, 0,18,19, 0,18,
	19,16,16, 0,22,20,17,17, 0,22,22,17,18, 0,22,22,
	18,17, 0, 0,22,18,19, 0,20,20,17,18, 0, 0,22,19,
	18, 0,22,22,17,17, 0,22, 0,19,19, 0, 0,22,18,18,
	 0,20,22,17,17, 0, 0,22,18,18, 0,19,20,17,17, 0,
	22, 0,20,19, 0,22,21,17,17, 0, 0, 0,18,18, 0, 0,
	 0,22,19, 0,20, 0,17,17, 0,22, 0, 0,22, 0, 0,20,
	17,18, 0,22, 0,19,19, 0, 0, 0, 0,19, 0,19,21,17,
	17, 0, 0, 0, 0, 0, 0,20,21,17,16, 0,11,11,13,13,
	 0,13,13,16,16, 0,13,13,15,16, 0,17,17,21,22, 0,
	17,18, 0, 0, 0,12,12,16,16, 0,15,15,18,18, 0,13,
	13,16,16, 0,17,16,21,21, 0,17,17, 0, 0, 0,13,13,
	16,16, 0,16,16,19,18, 0,13,13,16,16, 0,17,17, 0,
	22, 0,17,18,20,22, 0,17,18, 0, 0, 0, 0, 0, 0, 0,
	 0,15,15,20, 0, 0,18,19, 0, 0, 0,17,17, 0, 0, 0,
	18,17,22, 0, 0, 0, 0, 0, 0, 0,15,16,21,20, 0,20,
	20, 0, 0, 0,18,19, 0, 0, 0,15,15,22,22, 0,17,16,
	20,22, 0,17,17,20,22, 0,18,18, 0,21, 0,19,18, 0,
	 0, 0,16,16,20,20, 0,19,19,22, 0, 0,15,16,21,22,
	 0,18,19,22, 0, 0,17,18, 0, 0, 0,16,16,22, 0, 0,
	19,19, 0,21, 0,15,16,20, 0, 0,18,18, 0,22, 0,18,
	17, 0, 0, 0,18,18, 0, 0, 0, 0, 0, 0, 0, 0,16,16,
	22,21, 0,20,21, 0, 0, 0,17,18,22, 0, 0,18,18, 0,
	 0, 0, 0, 0, 0, 0, 0,16,16,20,19, 0,22,21, 0, 0,
	 0,18,18,22,22,
};

static const static_codebook _44p2_p5_0 = {
	5, 3125,
	(long *)_vq_lengthlist__44p2_p5_0,
	1, -528744448, 1616642048, 3, 0,
	(long *)_vq_quantlist__44p2_p5_0,
	0
};

static const long _vq_quantlist__44p2_p5_1[] = {
	3,
	2,
	4,
	1,
	5,
	0,
	6,
};

static const long _vq_lengthlist__44p2_p5_1[] = {
	 2, 3, 3, 3, 3, 3, 3,
};

static const static_codebook _44p2_p5_1 = {
	1, 7,
	(long *)_vq_lengthlist__44p2_p5_1,
	1, -533200896, 1611661312, 3, 0,
	(long *)_vq_quantlist__44p2_p5_1,
	0
};

static const long _vq_quantlist__44p2_p6_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p2_p6_0[] = {
	 1, 7, 7, 7, 8, 8, 7, 8, 8, 7, 9, 9,10,11,11, 9,
	 8, 8, 7, 8, 9,11,11,11, 9, 8, 8, 6, 7, 7,10,10,
	10,10,10,10,10,10,10,14,14,14,12,11,11,10,11,11,
	15,14,14,13,11,11, 6, 6, 6, 8, 5, 5, 8, 7, 7, 8,
	 7, 7,11,10,10, 9, 7, 7, 9, 7, 7,12,10,10,10, 7,
	 7, 6, 8, 7,12,10,10,12,10,10,11,10,10,15,14,13,
	13,10,10,11,10,10,16,14,14,14,10,10, 7, 7, 7,12,
	11,11,12,11,11,11,11,11,16,14,14,13,12,12,11,11,
	11,17,15,15,14,12,12,10, 9, 9,13,11,11,13,11,11,
	12,11,11,16,14,13,14,11,11,12,11,11,17,15,14,14,
	11,11, 7, 8, 8,12,11,11,12,10,10,12,10,10,16,13,
	14,13,10,10,11,10,10,17,14,14,14,10,10, 7, 7, 7,
	12,11,11,12,11,11,12,11,11,15,14,15,14,12,12,12,
	11,11,17,15,15,14,12,12,10,10, 9,13,11,11,13,11,
	11,13,11,11,16,14,14,14,11,11,13,11,11,16,15,15,
	15,11,11,
};

static const static_codebook _44p2_p6_0 = {
	5, 243,
	(long *)_vq_lengthlist__44p2_p6_0,
	1, -527106048, 1620377600, 2, 0,
	(long *)_vq_quantlist__44p2_p6_0,
	0
};

static const long _vq_quantlist__44p2_p6_1[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p2_p6_1[] = {
	 2, 6, 6, 7, 7, 7, 7, 7, 7, 7, 8, 8, 9, 9, 9, 8,
	 7, 7, 8, 8, 8, 9, 9, 9, 9, 8, 8, 6, 7, 7, 9, 8,
	 8, 9, 7, 7, 9, 8, 8,10, 8, 8,10, 8, 8,10, 8, 8,
	10, 8, 9,10, 8, 8, 7, 6, 6, 8, 6, 6, 9, 6, 6, 9,
	 7, 7,10, 8, 8, 9, 6, 6, 9, 7, 7,10, 9, 8, 9, 7,
	 7, 7, 7, 7,11, 8, 8,11, 9, 9,10, 9, 9,12, 9, 9,
	12, 8, 8,11, 9, 9,12, 9, 9,12, 8, 8, 8, 7, 7,10,
	 9, 9,10, 9, 9,10, 9, 9,11,10,11,11, 9, 9,11, 9,
	 9,11,11,11,11, 9, 9,10, 8, 8,11, 9, 9,10, 9, 9,
	11, 9, 9,11,10,10,11, 9, 9,11, 9, 9,12,10,10,11,
	 9, 9, 8, 8, 8,11, 9, 9,12, 9, 9,11, 9, 9,12, 9,
	 9,12, 8, 8,12, 9, 9,12, 9,10,12, 8, 8, 9, 7, 7,
	11, 9, 9,11,10,10,11, 9, 9,11,11,11,11, 9, 9,11,
	10,10,12,11,11,11, 9,10,10, 9, 9,11, 9, 9,11,10,
	10,11,10,10,11,11,11,11, 9, 9,11, 9,10,11,11,11,
	11, 9, 9,
};

static const static_codebook _44p2_p6_1 = {
	5, 243,
	(long *)_vq_lengthlist__44p2_p6_1,
	1, -530841600, 1616642048, 2, 0,
	(long *)_vq_quantlist__44p2_p6_1,
	0
};

static const long _vq_quantlist__44p2_p7_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p2_p7_0[] = {
	 1, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9,
};

static const static_codebook _44p2_p7_0 = {
	5, 243,
	(long *)_vq_lengthlist__44p2_p7_0,
	1, -513979392, 1633504256, 2, 0,
	(long *)_vq_quantlist__44p2_p7_0,
	0
};

static const long _vq_quantlist__44p2_p7_1[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p2_p7_1[] = {
	 1, 9, 9, 6, 9, 9, 5, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9,10,10,10,10,10,10,10,10,10,10,10,10,10,
	10,10,10,
};

static const static_codebook _44p2_p7_1 = {
	5, 243,
	(long *)_vq_lengthlist__44p2_p7_1,
	1, -516716544, 1630767104, 2, 0,
	(long *)_vq_quantlist__44p2_p7_1,
	0
};

static const long _vq_quantlist__44p2_p7_2[] = {
	12,
	11,
	13,
	10,
	14,
	9,
	15,
	8,
	16,
	7,
	17,
	6,
	18,
	5,
	19,
	4,
	20,
	3,
	21,
	2,
	22,
	1,
	23,
	0,
	24,
};

static const long _vq_lengthlist__44p2_p7_2[] = {
	 1, 3, 2, 5, 4, 7, 7, 8, 8, 9, 9,10,10,11,11,12,
	12,13,13,14,14,15,15,15,15,
};

static const static_codebook _44p2_p7_2 = {
	1, 25,
	(long *)_vq_lengthlist__44p2_p7_2,
	1, -518864896, 1620639744, 5, 0,
	(long *)_vq_quantlist__44p2_p7_2,
	0
};

static const long _vq_quantlist__44p2_p7_3[] = {
	12,
	11,
	13,
	10,
	14,
	9,
	15,
	8,
	16,
	7,
	17,
	6,
	18,
	5,
	19,
	4,
	20,
	3,
	21,
	2,
	22,
	1,
	23,
	0,
	24,
};

static const long _vq_lengthlist__44p2_p7_3[] = {
	 3, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
	 5, 5, 5, 5, 5, 5, 5, 5, 5,
};

static const static_codebook _44p2_p7_3 = {
	1, 25,
	(long *)_vq_lengthlist__44p2_p7_3,
	1, -529006592, 1611661312, 5, 0,
	(long *)_vq_quantlist__44p2_p7_3,
	0
};

static const long _huff_lengthlist__44p2_short[] = {
	 4, 4,12, 9, 8,12,15,17, 4, 2,11, 6, 5, 9,13,15,
	11, 7, 8, 7, 7,10,14,13, 8, 5, 7, 5, 5, 8,12,12,
	 8, 4, 7, 4, 3, 6,11,12,11, 8, 9, 7, 6, 8,11,12,
	15,13,14,12, 9, 7,10,13,16,12,17,12, 7, 5, 8,11,
};

static const static_codebook _huff_book__44p2_short = {
	2, 64,
	(long *)_huff_lengthlist__44p2_short,
	0, 0, 0, 0, 0,
	NULL,
	0
};

static const long _vq_quantlist__44p3_l0_0[] = {
	6,
	5,
	7,
	4,
	8,
	3,
	9,
	2,
	10,
	1,
	11,
	0,
	12,
};

static const long _vq_lengthlist__44p3_l0_0[] = {
	 1, 4, 4, 8, 8, 8, 8, 9, 9,10,10,10,10, 4, 6, 5,
	 8, 7, 9, 9, 9, 9,10, 9,11, 9, 4, 5, 6, 7, 8, 9,
	 9, 9, 9, 9,10, 9,10, 8, 9, 8, 9, 8,10, 9,11, 9,
	12,10,12,10, 8, 8, 9, 8, 9, 9,10, 9,11,10,12,10,
	12, 9,10,10,11,10,12,11,12,11,12,12,12,12, 9,10,
	10,11,11,11,11,11,12,12,12,12,12,10,11,11,12,12,
	12,12,12,12,12,12,12,12,10,11,11,12,12,12,12,12,
	12,12,12,12,12,11,12,12,12,12,12,13,12,13,12,13,
	12,12,11,12,12,12,12,12,12,13,12,12,12,12,12,12,
	12,12,13,13,12,13,12,13,12,13,12,12,12,13,12,13,
	12,13,12,13,12,13,12,12,12,
};

static const static_codebook _44p3_l0_0 = {
	2, 169,
	(long *)_vq_lengthlist__44p3_l0_0,
	1, -526516224, 1616117760, 4, 0,
	(long *)_vq_quantlist__44p3_l0_0,
	0
};

static const long _vq_quantlist__44p3_l0_1[] = {
	2,
	1,
	3,
	0,
	4,
};

static const long _vq_lengthlist__44p3_l0_1[] = {
	 3, 4, 4, 5, 5, 4, 4, 5, 5, 5, 4, 5, 4, 5, 5, 5,
	 5, 6, 5, 6, 5, 6, 5, 6, 5,
};

static const static_codebook _44p3_l0_1 = {
	2, 25,
	(long *)_vq_lengthlist__44p3_l0_1,
	1, -533725184, 1611661312, 3, 0,
	(long *)_vq_quantlist__44p3_l0_1,
	0
};

static const long _vq_quantlist__44p3_l1_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p3_l1_0[] = {
	 1, 4, 4, 4, 4, 4, 4, 4, 4,
};

static const static_codebook _44p3_l1_0 = {
	2, 9,
	(long *)_vq_lengthlist__44p3_l1_0,
	1, -516716544, 1630767104, 2, 0,
	(long *)_vq_quantlist__44p3_l1_0,
	0
};

static const long _huff_lengthlist__44p3_lfe[] = {
	 1, 3, 2, 3,
};

static const static_codebook _huff_book__44p3_lfe = {
	2, 4,
	(long *)_huff_lengthlist__44p3_lfe,
	0, 0, 0, 0, 0,
	NULL,
	0
};

static const long _huff_lengthlist__44p3_long[] = {
	 3, 4,13, 9, 9,12,15,17, 4, 2,18, 5, 7,10,14,18,
	11, 8, 6, 5, 6, 8,11,14, 8, 5, 5, 3, 5, 8,11,13,
	 9, 6, 7, 5, 5, 7, 9,10,11,10, 9, 8, 6, 6, 8,10,
	14,14,11,11, 9, 8, 9,10,17,17,14,13,10, 9,10,10,
};

static const static_codebook _huff_book__44p3_long = {
	2, 64,
	(long *)_huff_lengthlist__44p3_long,
	0, 0, 0, 0, 0,
	NULL,
	0
};

static const long _vq_quantlist__44p3_p1_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p3_p1_0[] = {
	 1, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0,
};

static const static_codebook _44p3_p1_0 = {
	5, 243,
	(long *)_vq_lengthlist__44p3_p1_0,
	1, -535822336, 1611661312, 2, 0,
	(long *)_vq_quantlist__44p3_p1_0,
	0
};

static const long _vq_quantlist__44p3_p2_0[] = {
	2,
	1,
	3,
	0,
	4,
};

static const long _vq_lengthlist__44p3_p2_0[] = {
	 3, 7, 7, 0, 0, 0, 8, 8, 0, 0, 0, 8, 8, 0, 0, 0,
	11,11, 0, 0, 0, 0, 0, 0, 0, 0,10, 9, 0, 0, 0, 0,
	 0, 0, 0, 0, 9, 9, 0, 0, 0,10,11, 0, 0, 0, 0, 0,
	 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0,
	 0, 0,10,10, 0, 0, 0, 0, 0, 0, 0, 0,12,12, 0, 0,
	 0, 0, 0, 0, 0, 0,11,11, 0, 0, 0,12,12, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 0, 0, 0,
	 5, 5, 0, 0, 0, 7, 7, 0, 0, 0, 9, 9, 0, 0, 0, 0,
	 0, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5,
	 0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 0,
	 0, 0, 0, 0, 0, 0, 0, 5, 6, 0, 0, 0, 7, 7, 0, 0,
	 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0,
	 8, 8, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0,11,11, 0, 0, 0, 9, 9, 0,
	 0, 0,10,10, 0, 0, 0,10,10, 0, 0, 0, 0, 0, 0, 0,
	 0,10,10, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0,
	10,10, 0, 0, 0, 0, 0, 0, 0, 0,10,10, 0, 0, 0, 0,
	 0, 0, 0, 0, 9, 9, 0, 0, 0,10,10, 0, 0, 0, 0, 0,
	 0, 0, 0,11,12, 0, 0, 0, 0, 0, 0, 0, 0,11,11, 0,
	 0, 0,12,12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 9, 9, 0, 0, 0, 7, 7, 0, 0, 0, 8, 8, 0, 0,
	 0,10,10, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0,
	 0, 0, 0, 0, 0, 7, 7, 0, 0, 0, 9, 9, 0, 0, 0, 0,
	 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8,
	 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0,10,10, 0,
	 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0,11,11, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5,
	 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 7, 7,
	 0, 0, 0, 9, 9, 0, 0, 0,10,10, 0, 0, 0, 0, 0, 0,
	 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 0, 0,
	 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0,
	 0, 0, 0, 0, 0, 7, 7, 0, 0, 0, 9, 9, 0, 0, 0, 0,
	 0, 0, 0, 0,11,11, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9,
	 0, 0, 0,10,10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 9, 9, 0, 0, 0, 7, 7, 0, 0, 0, 8, 8, 0,
	 0, 0,10,10, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0,
	 0, 0, 0, 0, 0, 0, 8, 7, 0, 0, 0, 9, 9, 0, 0, 0,
	 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 7,
	 7, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0,11,11,
	 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0,10,10, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 7,
	 7, 0, 0, 0, 9, 9, 0, 0, 0,10,10, 0, 0, 0, 0, 0,
	 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 0,
	 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0,
	 0, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 9, 9, 0, 0, 0,
	 0, 0, 0, 0, 0,10,10, 0, 0, 0, 0, 0, 0, 0, 0, 9,
	 9, 0, 0, 0,11,11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0,10,10, 0, 0, 0, 9, 9, 0, 0, 0,10,10,
	 0, 0, 0,11,12, 0, 0, 0, 0, 0, 0, 0, 0,10,10, 0,
	 0, 0, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0,11,11, 0, 0,
	 0, 0, 0, 0, 0, 0,10,10, 0, 0, 0, 0, 0, 0, 0, 0,
	 9, 9, 0, 0, 0,10,10, 0, 0, 0, 0, 0, 0, 0, 0,11,
	11, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0,12,12,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,10,10, 0, 0, 0,
	 9, 9, 0, 0, 0,10,10, 0, 0, 0,12,12, 0, 0, 0, 0,
	 0, 0, 0, 0,10,10, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9,
	 0, 0, 0,11,11, 0, 0, 0, 0, 0, 0, 0, 0,10,10, 0,
	 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0,11,11, 0, 0,
	 0, 0, 0, 0, 0, 0,12,12, 0, 0, 0, 0, 0, 0, 0, 0,
	10,10, 0, 0, 0,11,11, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0,
};

static const static_codebook _44p3_p2_0 = {
	5, 3125,
	(long *)_vq_lengthlist__44p3_p2_0,
	1, -533725184, 1611661312, 3, 0,
	(long *)_vq_quantlist__44p3_p2_0,
	0
};

static const long _vq_quantlist__44p3_p3_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p3_p3_0[] = {
	 1, 5, 5, 5, 8, 8, 0, 8, 8, 6, 9, 9, 8,10,10, 0,
	 8, 8, 0, 9, 9, 0,12,12, 0, 8, 8, 4, 7, 7, 6,10,
	10, 0,12,12, 7,11,11, 9,12,12, 0,12,12, 0,13,13,
	 0,15,15, 0,12,12, 0, 7, 7, 0, 7, 7, 0, 8, 8, 0,
	 8, 8, 0,10,10, 0, 7, 7, 0, 8, 8, 0,11,11, 0, 7,
	 7, 5, 7, 7, 9, 9, 9, 0,11,10, 9, 9, 9,11,12,12,
	 0,10,10, 0,11,11, 0,13,13, 0,11,11, 6, 7, 7, 9,
	10,10, 0,12,12,10,11,11,11,12,12, 0,12,12, 0,13,
	13, 0,15,15, 0,12,12, 0,10,10, 0,11,11, 0,11,11,
	 0,12,12, 0,13,13, 0,11,11, 0,12,12, 0,15,15, 0,
	11,11, 0, 8, 8, 0,10,10, 0,12,12, 0,11,11, 0,12,
	12, 0,12,12, 0,12,12, 0,15,15, 0,11,11, 0, 7, 7,
	 0,10,10, 0,12,12, 0,10,10, 0,12,13, 0,12,12, 0,
	13,13, 0,14,14, 0,12,12, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0,
};

static const static_codebook _44p3_p3_0 = {
	5, 243,
	(long *)_vq_lengthlist__44p3_p3_0,
	1, -533200896, 1614282752, 2, 0,
	(long *)_vq_quantlist__44p3_p3_0,
	0
};

static const long _vq_quantlist__44p3_p3_1[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p3_p3_1[] = {
	 3, 4, 4, 0, 8, 8, 0, 8, 8, 0, 9, 9, 0,10,10, 0,
	 8, 8, 0, 9, 9, 0,10,10, 0, 8, 8, 0, 7, 7, 0, 8,
	 8, 0, 8, 8, 0, 8, 8, 0, 8, 8, 0, 8, 8, 0, 8, 8,
	 0, 8, 8, 0, 8, 8, 0, 7, 7, 0, 6, 6, 0, 7, 7, 0,
	 7, 7, 0,10,10, 0, 6, 6, 0, 7, 7, 0,10,10, 0, 6,
	 5, 0, 8, 8, 0, 7, 7, 0, 8, 8, 0, 8, 8, 0, 9, 9,
	 0, 7, 7, 0, 8, 8, 0, 9, 9, 0, 7, 7, 0, 6, 6, 0,
	 9,10, 0,10,10, 0,10,10, 0,11,11, 0, 9, 9, 0,10,
	10, 0,11,11, 0, 9, 9, 0, 8, 8, 0, 8, 8, 0, 8, 8,
	 0, 9, 9, 0, 9, 9, 0, 8, 8, 0, 8, 8, 0, 9, 9, 0,
	 7, 7, 0, 8, 8, 0, 7, 7, 0, 7, 7, 0, 8, 8, 0, 9,
	 9, 0, 7, 7, 0, 7, 7, 0, 9, 9, 0, 6, 6, 0, 6, 6,
	 0,10,10, 0,10,10, 0,10,10, 0,12,12, 0, 9, 9, 0,
	10,10, 0,12,12, 0, 9, 9, 0, 8, 8, 0, 7, 7, 0, 8,
	 8, 0, 8, 8, 0, 9, 9, 0, 7, 7, 0, 8, 8, 0, 9, 9,
	 0, 7, 7,
};

static const static_codebook _44p3_p3_1 = {
	5, 243,
	(long *)_vq_lengthlist__44p3_p3_1,
	1, -535822336, 1611661312, 2, 0,
	(long *)_vq_quantlist__44p3_p3_1,
	0
};

static const long _vq_quantlist__44p3_p4_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p3_p4_0[] = {
	 1, 6, 6, 7, 7, 7, 7, 7, 7, 7, 8, 8,10,11,11, 9,
	 8, 8, 8, 8, 8,11,11,11,10, 8, 8, 5, 7, 7, 9,11,
	11,10,11,11,10,11,11,12,13,14,11,12,12,10,11,11,
	13,14,14,12,12,12, 5, 6, 6, 8, 6, 6, 8, 7, 7, 8,
	 7, 7,11,10,10,10, 7, 7, 9, 7, 7,12,11,11,11, 7,
	 7, 7, 7, 7,11,10,10,12,10,10,11,10,10,15,13,13,
	13,10,10,12,11,11,15,13,13,14,11,11, 7, 7, 7,11,
	11,11,12,11,11,12,11,11,14,14,14,14,12,12,12,12,
	12,16,15,15,14,12,12, 0,10,10, 0,11,11, 0,11,12,
	 0,11,11, 0,14,14, 0,11,11, 0,12,12, 0,15,15, 0,
	11,11, 8, 8, 8,12,10,10,12,10,10,13,11,11,15,13,
	13,14,11,11,12,10,10,16,14,14,14,10,10, 8, 7, 7,
	12,11,11,13,11,11,12,11,11,15,14,14,14,12,12,13,
	12,12,15,14,14,15,12,12, 0,11,11, 0,12,12, 0,12,
	12, 0,12,12, 0,15,15, 0,12,12, 0,13,13, 0,14,15,
	 0,12,12,
};

static const static_codebook _44p3_p4_0 = {
	5, 243,
	(long *)_vq_lengthlist__44p3_p4_0,
	1, -531365888, 1616117760, 2, 0,
	(long *)_vq_quantlist__44p3_p4_0,
	0
};

static const long _vq_quantlist__44p3_p4_1[] = {
	2,
	1,
	3,
	0,
	4,
};

static const long _vq_lengthlist__44p3_p4_1[] = {
	 3, 4, 5, 8, 8,12,10,10,12,12,12,10,10,12,12,13,
	11,11,12,12,13,12,12,12,12,13,10,10,13,13,13,13,
	13,13,13,13,10,10,13,13,13,11,11,13,13,14,13,13,
	12,12,13,10,10,13,13,13,13,13,13,13,13,10,10,12,
	12,13,11,11,13,13,13,13,13,12,12,13,12,12,13,13,
	13,13,13,13,13,14,11,11,12,12,14,12,12,13,12,14,
	14,14,12,12,13,14,14,13,13,14,13,13,13,13,14,14,
	14,12,12,14,13,13,13,13,14,14,14,12,12,12, 8, 8,
	11,11,12,12,12,11,11,12,11,11,10,10,13,12,12,10,
	10,13,12,12,10,10,13,12,12,12,12,14,12,12,12,12,
	13,13,13,11,11,14,12,12,11,11,14,12,12,12,12,14,
	12,12,12,12,13,12,12,12,12,13,13,13,11,11,14,12,
	12,11,11,14,12,12,12,12,14,13,13,12,12,14,12,12,
	12,11,14,13,13,11,11,14,13,12,11,11,14,13,13,11,
	11,14,13,13,12,12,14,12,12,12,12,15,13,13,12,12,
	14,12,12,11,11,14,13,13,11,11,12, 9, 9,10,10,12,
	 7, 7,11,11,12, 9, 9,12,12,13,10,10,10,10,14,14,
	14,11,11,13, 9, 9,12,12,14,14,14,12,12,13, 8, 8,
	11,11,14, 9, 9,12,12,14,14,14,11,11,13, 9, 9,12,
	12,14,14,14,12,12,14, 8, 8,11,11,14, 9, 9,12,12,
	14,14,14,11,11,14,10,10,12,12,14,14,14,13,13,14,
	 9, 9,11,11,14,10,10,12,12,14,14,14,11,11,14,14,
	15,12,12,15,14,14,14,14,15,14,14,11,11,14,14,14,
	12,12,14,14,14,11,11,14,11,11,10,10,14,10,10,10,
	10,14,10,10,10,10,15,11,11, 9, 9,14,12,12, 9, 9,
	15,11,11,11,11,15,13,13,11,11,15,10,10,10,10,15,
	11,11,10,10,15,13,13,11,11,15,11,11,11,11,15,13,
	13,11,11,15,10,10,10,10,15,11,11,10,10,15,13,13,
	11,11,15,12,12,11,11,15,13,13,11,11,15,11,11,10,
	10,15,12,12,10,10,15,13,13,10,10,15,14,14,11,11,
	15,13,13,11,11,15,14,14,10,11,15,13,13,10,10,15,
	13,14,10,10,14,13,13,10,10,14,13,13,10,10,14,13,
	13,10,10,14,13,13, 9, 9,14,14,14, 9, 9,15,14,14,
	11,11,15,14,14,10,10,15,14,14,10,10,15,14,14,11,
	11,15,14,14,10,10,15,14,14,11,11,15,14,14,10,10,
	14,14,14,10,10,15,14,14,10,10,14,14,14,10,10,15,
	14,14,11,11,15,14,14,11,11,14,14,14,10,10,15,14,
	14,10,10,14,14,14, 9, 9,15,15,15,11,11,15,14,14,
	12,12,15,15,14,10,10,15,14,14,10,10,14,15,15, 9,
	 9,14,10,10,12,12,17, 9, 9,12,12,17,10,10,13,13,
	17,11,11,12,12,18,14,14,12,12,17,10,10,13,13,17,
	14,14,12,12,17, 9, 9,12,12,17,11,11,12,12,17,14,
	14,12,12,18,10,10,13,13,18,14,14,13,13,18, 9, 9,
	12,12,18,10,10,13,13,18,14,14,12,12,18,11,11,13,
	13,18,14,14,13,13,18,10,10,12,12,17,11,11,12,12,
	17,14,14,12,12,18,15,15,13,13,18,14,14,14,14,18,
	15,15,12,12,18,14,14,12,12,18,15,15,12,12,13, 7,
	 7,11,11,14,15,15,11,11,14,15,15,12,12,14,15,15,
	11,11,15,15,15,11,11,14,15,15,12,12,14,15,15,12,
	12,14,15,15,11,11,14,15,15,11,11,15,15,15,12,12,
	14,15,15,12,12,14,15,15,12,12,14,15,15,11,11,14,
	15,15,11,11,15,15,15,12,12,15,15,15,12,12,14,15,
	15,12,12,14,15,14,12,12,14,15,15,11,11,15,14,14,
	12,12,15,15,15,12,12,15,16,16,12,12,15,15,15,12,
	12,15,15,15,12,12,15,15,15,12,12,13,13,13,11,10,
	14,14,15,11,11,14,14,14,12,12,15,14,14,10,10,15,
	15,15,11,11,14,15,15,12,12,14,14,14,11,11,14,15,
	15,11,11,14,15,15,12,12,15,15,15,11,11,14,15,15,
	12,12,14,14,14,12,12,14,15,15,11,11,14,15,15,12,
	12,15,15,15,11,11,15,15,15,12,12,15,14,14,12,12,
	14,15,15,11,11,14,15,15,11,11,15,15,15,10,10,15,
	15,16,12,12,15,15,15,14,14,15,15,15,11,11,15,15,
	15,12,12,15,15,15,11,11,14,11,11,10,10,15, 9, 9,
	12,12,15,10,10,12,12,15,11,11,11,11,15,14,14,12,
	12,15,10,10,13,13,15,14,14,12,12,15, 9, 9,12,12,
	15,10,10,13,13,15,13,13,12,11,15,10,10,12,12,15,
	14,14,12,12,15, 9, 9,11,11,15,11,11,12,12,15,13,
	13,11,11,15,11,11,13,13,15,13,14,13,14,15,11,11,
	11,11,15,11,11,12,12,15,14,14,11,11,15,14,14,13,
	13,15,14,14,20,20,15,14,14,12,12,15,14,14,12,12,
	15,14,14,11,11,14,13,13,10,10,14,13,13,12,12,14,
	14,13,12,12,15,14,14,12,12,15,14,14,11,11,15,14,
	14,12,12,15,14,14,13,13,15,14,14,12,11,15,14,14,
	11,11,15,14,14,13,13,15,14,14,12,12,15,14,14,13,
	13,15,14,14,12,11,15,14,14,12,12,15,14,14,13,13,
	15,14,14,13,13,15,14,14,12,12,15,14,14,12,12,15,
	14,14,12,12,15,15,15,13,13,15,15,15,13,13,15,14,
	14,13,13,15,15,15,13,13,15,14,15,12,12,15,15,15,
	13,13,14,10,10,12,13,17, 9, 9,12,12,17,10,10,13,
	13,17,11,11,12,12,18,14,14,12,12,18,10,10,13,13,
	18,14,14,12,12,17, 9, 9,12,12,18,10,11,13,13,18,
	14,14,12,12,17,10,10,12,12,17,14,14,12,12,17, 9,
	 9,12,12,17,11,11,12,12,17,14,14,12,12,18,11,11,
	12,12,18,14,14,13,13,18,11,11,12,12,18,11,11,12,
	12,18,14,14,12,12,18,15,15,12,12,18,14,14,13,13,
	18,15,15,12,12,17,14,14,12,12,17,15,15,12,12,13,
	 7, 7,11,11,14,15,15,11,11,14,15,15,11,11,14,15,
	14,12,12,15,15,15,12,11,14,15,15,12,12,14,15,15,
	12,12,14,15,15,11,11,14,15,15,11,11,15,15,15,13,
	13,14,15,15,11,11,14,15,15,13,12,14,15,15,11,11,
	14,15,15,11,11,15,15,15,13,13,14,15,15,12,12,15,
	15,15,12,12,15,15,15,11,11,15,15,15,11,11,15,15,
	15,12,12,15,15,15,13,13,15,16,16,12,12,15,15,15,
	12,13,15,15,15,12,12,15,15,15,12,12,13,13,13,11,
	11,14,14,14,11,11,14,14,14,12,12,14,14,14,10,10,
	15,14,14,11,11,14,15,15,12,12,14,14,14,12,12,14,
	15,15,11,11,14,15,14,12,12,15,14,14,11,11,14,15,
	15,12,12,14,14,14,11,11,14,15,15,11,11,14,14,14,
	12,12,15,15,14,11,11,15,15,15,12,12,15,14,14,12,
	12,14,15,15,11,11,14,15,14,11,11,15,15,15,10,10,
	15,15,15,12,12,15,14,14,14,13,15,15,15,11,11,15,
	15,15,11,11,15,15,15,10,10,14,11,11,10,10,15, 9,
	 9,12,12,15,10,10,12,12,15,11,11,11,11,15,14,14,
	12,12,15,10,10,13,13,15,13,13,12,12,15, 9, 9,12,
	12,15,11,11,13,13,15,14,14,12,12,15,10,10,13,13,
	15,13,14,12,12,15, 9, 9,12,12,15,10,10,13,13,15,
	13,13,11,11,15,11,11,13,13,15,14,14,13,13,15,10,
	10,11,11,15,11,11,12,12,15,14,14,11,11,15,14,14,
	13,13,15,14,14,21,20,15,14,14,11,11,15,14,14,12,
	12,15,14,14,11,11,14,13,13,10,10,14,13,13,11,11,
	15,14,14,12,12,15,14,14,12,12,14,14,14,12,12,15,
	14,14,12,12,15,14,14,13,13,14,14,14,11,11,15,14,
	14,11,11,15,14,14,13,13,15,14,14,12,12,15,14,14,
	13,13,14,14,14,11,11,15,14,14,11,11,14,14,14,13,
	13,15,14,14,12,12,15,14,14,12,12,15,14,14,12,12,
	15,14,14,12,12,14,14,14,13,13,15,15,15,13,13,16,
	14,14,12,13,15,15,15,13,13,15,14,14,12,12,15,15,
	15,13,13,15,11,11,13,12,18,10,10,12,12,17,11,11,
	12,12,18,12,12,11,11,18,14,14,12,12,18,11,11,13,
	13,17,14,14,12,12,18,10,10,12,12,18,12,12,12,12,
	18,14,15,12,12,18,11,11,13,13,18,14,14,12,12,17,
	10,10,12,12,18,11,11,12,12,18,15,14,12,12,17,12,
	12,12,12,17,14,14,12,12,17,11,11,11,11,17,12,12,
	12,11,17,15,15,11,11,18,15,15,12,12,18,14,15,13,
	13,18,15,15,11,11,17,15,15,12,12,18,15,15,11,11,
	14, 9, 9,11,11,14,15,15,11,11,15,15,15,11,11,15,
	15,15,12,11,15,15,15,12,12,15,15,15,11,11,15,15,
	15,13,13,14,15,15,11,11,15,15,15,11,11,15,15,15,
	13,13,15,15,15,11,11,15,15,15,13,13,15,15,15,11,
	11,15,15,15,11,11,15,15,15,13,13,15,15,15,12,12,
	15,15,15,13,13,15,15,14,11,11,15,15,15,12,12,15,
	15,15,12,12,16,15,15,13,13,15,16,16,13,13,16,15,
	15,12,12,15,15,15,13,12,15,15,15,12,12,13,12,12,
	11,11,14,14,14,11,11,14,14,14,12,12,15,14,14,11,
	11,15,14,14,12,12,15,14,14,12,12,15,14,14,12,12,
	14,15,15,11,11,15,14,14,12,12,15,14,14,11,11,15,
	14,14,12,12,15,14,14,12,12,14,15,15,11,11,15,14,
	14,12,12,15,14,14,11,11,15,15,15,12,12,15,14,14,
	12,12,15,15,15,11,11,15,14,14,11,11,15,14,15,11,
	11,15,15,15,12,12,15,14,14,13,13,16,15,15,11,11,
	15,14,14,12,12,15,15,15,11,11,14,11,11, 9, 9,15,
	10,10,12,12,14,11,11,12,12,15,12,12,12,12,15,14,
	14,13,13,15,11,11,13,13,15,14,14,13,13,15,10,10,
	12,12,15,12,12,13,13,15,14,14,13,13,15,11,11,12,
	12,15,14,14,13,13,14,10,10,12,12,15,12,12,13,13,
	15,14,14,12,12,15,12,12,13,13,15,14,14,15,15,15,
	11,11,12,12,15,12,12,12,13,15,14,14,12,12,15,15,
	15,14,14,15,14,14,20,20,15,14,14,12,12,15,14,14,
	13,13,15,14,14,12,12,14,13,13,10,10,14,13,13,11,
	11,14,13,13,12,12,14,14,14,12,12,15,14,14,13,13,
	15,14,14,12,12,14,14,14,14,14,14,14,14,11,11,15,
	14,14,12,12,15,14,14,14,14,15,14,14,12,12,14,14,
	14,14,14,14,14,14,11,11,15,14,14,12,12,14,14,14,
	14,14,15,14,14,12,12,15,14,14,13,13,15,14,14,12,
	12,15,14,14,12,12,14,14,14,14,13,15,15,15,14,14,
	15,14,14,13,13,15,15,15,14,14,15,14,14,13,13,15,
	15,15,13,13,14,13,13,13,13,18,15,15,12,12,18,15,
	15,13,12,18,15,16,11,11,18,16,17,12,12,18,15,15,
	13,13,18,17,17,12,12,18,15,15,12,12,17,15,15,12,
	12,18,17,17,12,12,18,15,15,13,13,18,16,17,12,12,
	17,15,15,12,12,18,15,15,12,12,18,16,17,11,12,18,
	16,16,12,12,17,16,17,12,12,18,15,15,11,11,18,15,
	15,12,12,18,17,17,11,11,17,17,17,12,12,18,16,16,
	13,13,18,17,17,11,11,18,16,16,12,12,18,17,17,11,
	11,15,14,14,11,11,16,15,15,11,11,16,15,15,12,12,
	16,15,15,12,12,17,15,15,14,13,16,15,15,12,12,17,
	15,15,14,14,16,15,15,11,11,16,15,15,12,12,18,15,
	15,13,13,16,15,15,11,11,17,15,15,14,14,16,15,15,
	11,11,16,15,15,12,12,17,15,15,13,13,16,15,15,12,
	12,17,16,15,14,14,16,14,15,12,12,16,15,15,12,12,
	18,15,15,13,13,17,15,15,14,14,17,16,16,15,15,17,
	15,15,13,13,17,15,15,14,14,18,15,15,13,13,15,12,
	13,11,11,15,14,14,12,12,16,14,14,12,12,16,14,14,
	12,12,16,14,14,12,12,16,14,14,13,12,17,14,14,13,
	13,16,15,15,12,12,16,14,14,12,12,17,14,14,12,12,
	16,14,14,12,12,17,14,14,13,13,15,15,15,12,12,16,
	14,14,12,12,17,14,14,12,12,17,15,15,12,12,17,14,
	14,13,13,16,15,15,12,12,16,14,14,12,12,17,15,15,
	12,12,18,15,15,13,13,17,14,14,13,13,17,15,15,12,
	12,17,14,14,12,12,17,15,15,12,12,14,15,15, 9, 9,
	15,15,15,12,12,15,15,15,13,13,15,15,15,14,14,15,
	15,15,19,19,15,15,16,13,13,15,15,16,19,20,15,15,
	15,13,12,15,16,16,14,14,15,15,15,19,19,15,15,15,
	13,13,15,16,15,20,19,14,15,15,13,13,15,15,15,14,
	14,15,15,15,19,19,15,15,15,14,14,15,16,16,19,20,
	15,15,15,14,14,15,15,15,14,14,15,15,15,19,19,15,
	15,15,20,19,15,16,16,20,19,15,15,15,19,19,15,16,
	16,20,20,15,15,15,19,20,14,13,13,10,10,14,14,14,
	11,11,14,14,14,12,12,15,14,14,13,13,15,14,14,19,
	20,15,14,14,12,12,14,14,14,20,19,14,14,14,11,11,
	15,14,14,12,12,15,14,14,20,20,15,14,14,12,12,14,
	14,14,20,19,14,14,14,11,11,15,14,14,12,12,15,14,
	14,19,20,15,14,14,13,13,15,14,14,22,19,15,15,14,
	12,12,15,14,14,13,13,14,15,15,22,20,15,15,15,20,
	20,15,14,14,21,20,15,15,15,20,21,15,14,14,20,20,
	14,15,15,20,20,
};

static const static_codebook _44p3_p4_1 = {
	5, 3125,
	(long *)_vq_lengthlist__44p3_p4_1,
	1, -533725184, 1611661312, 3, 0,
	(long *)_vq_quantlist__44p3_p4_1,
	0
};

static const long _vq_quantlist__44p3_p5_0[] = {
	2,
	1,
	3,
	0,
	4,
};

static const long _vq_lengthlist__44p3_p5_0[] = {
	 2, 6, 6,14,14, 6, 7, 7,14,14, 7, 7, 7,15,15, 0,
	12,12,15,15, 0,13,13,15,15, 7, 8, 8,15,15,10,10,
	10,16,16, 9, 8, 8,15,15, 0,13,13,18,17, 0,13,13,
	16,16, 8, 8, 8,15,15,12,11,11,16,16, 9, 8, 8,15,
	15, 0,13,13,18,18, 0,13,13,16,16, 0,14,14,17,17,
	 0,20, 0,19,20, 0,12,12,16,16, 0,16,16,20,22, 0,
	14,14,16,16, 0,14,14,17,17, 0,20,22,20,19, 0,13,
	13,15,16, 0,17,18, 0,21, 0,15,15,16,16, 5, 7, 7,
	13,13, 8, 9, 9,14,14,10,10,10,14,14, 0,20,22,18,
	18, 0,22,21,18,17, 9,10,10,14,14,12,12,12,17,17,
	12,10,10,14,14, 0, 0,20,17,17, 0,22,21,17,18,11,
	10,10,14,14,14,13,13,18,18,12,11,11,14,14, 0,22,
	21,18,19, 0,20, 0,17,17, 0,22, 0,18,18, 0, 0, 0,
	 0, 0, 0,20,20,17,17, 0,22, 0,22,21, 0,21, 0,19,
	18, 0,22,22,18,18, 0, 0, 0, 0, 0, 0,21, 0,17,17,
	 0,22, 0,20,20, 0, 0, 0,19,18, 6, 6, 6,12,12, 8,
	 6, 6,10,10, 8, 6, 6,13,12, 0,10,10,11,11, 0,11,
	11,13,13, 8, 7, 7,13,13,11, 9, 9,13,13,10, 6, 6,
	12,12, 0,10,10,14,14, 0,10,10,13,13, 9, 7, 7,13,
	13,12,10,10,13,13,10, 6, 6,12,12, 0,11,11,15,15,
	 0,10,10,13,13, 0,12,12,15,14, 0,19,20,16,17, 0,
	 9, 9,13,13, 0,14,14,20,21, 0,12,11,13,12, 0,12,
	12,15,14, 0,20,19,17,17, 0,10,10,12,13, 0,15,15,
	22,21, 0,12,12,12,13, 0,10,10,12,12, 0,11,11,15,
	15, 0,11,11,15,15, 0,15,15,22,22, 0,16,17, 0, 0,
	 0,11,11,15,15, 0,14,14,18,18, 0,11,11,16,16, 0,
	16,15, 0,21, 0,16,16, 0, 0, 0,12,12,15,15, 0,14,
	14,19,19, 0,11,11,15,15, 0,15,15,22, 0, 0,16,16,
	22, 0, 0,16,16, 0,21, 0, 0, 0, 0, 0, 0,15,15,19,
	20, 0,18,18, 0, 0, 0,17,17, 0, 0, 0,17,17, 0, 0,
	 0, 0, 0, 0, 0, 0,16,15,22,21, 0,20,20, 0, 0, 0,
	18,18, 0, 0, 0,10,10,12,12, 0,10,10,11,11, 0,11,
	11,12,12, 0,11,11, 9, 9, 0,13,12,12,12, 0,11,11,
	13,13, 0,13,13,12,12, 0,10,10,12,12, 0,13,12,13,
	13, 0,12,12,12,12, 0,11,11,13,13, 0,13,13,12,12,
	 0,10,10,12,12, 0,13,13,14,13, 0,12,12,12,12, 0,
	14,13,13,14, 0,20,21,15,15, 0,11,11,12,12, 0,15,
	16,20,20, 0,12,13,10,10, 0,13,13,14,13, 0,20,20,
	15,15, 0,11,11,12,12, 0,16,17,21,21, 0,13,13,11,
	11, 6, 7, 7,16,15,11, 9, 9,14,15,12, 9, 9,16,16,
	 0,13,13,15,15, 0,14,14,17,17,10, 9, 9,16,16,14,
	12,12,16,16,12, 9, 9,15,15, 0,13,13,17,18, 0,13,
	13,15,15,12,10,10,17,17,15,12,12,17,17,13, 9, 9,
	16,16, 0,13,13,18,19, 0,14,14,16,16, 0,15,15,18,
	18, 0, 0, 0,20,19, 0,12,12,17,16, 0,16,17, 0,21,
	 0,14,15,16,16, 0,15,15,18,18, 0, 0,22,19,21, 0,
	13,13,16,16, 0,18,17,22,22, 0,15,15,16,16, 7, 7,
	 7,13,13,11,10,10,15,15,12,10,10,14,14, 0,21, 0,
	18,17, 0,21,22,18,18,11,10,10,15,15,14,12,12,17,
	17,14,11,11,14,14, 0,21,20,18,18, 0,22,21,18,17,
	12,11,10,16,16,16,14,14,17,19,14,11,11,15,15, 0,
	 0,22,19,19, 0,21,22,18,18, 0,21, 0,18,19, 0, 0,
	 0,22, 0, 0,22,21,17,17, 0, 0, 0,20,22, 0, 0,21,
	18,18, 0, 0, 0,19,20, 0, 0, 0, 0, 0, 0, 0,21,17,
	17, 0, 0, 0,22,21, 0, 0, 0,19,19,10, 9, 9,14,13,
	13,10,10,12,12,13,10,10,14,14, 0,13,13,12,12, 0,
	15,14,16,15,13,10,10,14,14,15,12,12,14,14,15,10,
	10,14,14, 0,14,14,15,15, 0,14,13,14,14,13,10,10,
	15,15,17,13,13,15,15,14,10,10,14,14, 0,14,14,15,
	16, 0,14,14,15,15, 0,15,15,16,16, 0,21,22,17,18,
	 0,12,12,14,14, 0,17,17,20,21, 0,14,14,14,14, 0,
	15,15,16,16, 0,21,22,18,18, 0,13,13,14,14, 0,18,
	18,22, 0, 0,15,15,14,14, 0,11,11,13,13, 0,12,12,
	16,15, 0,12,12,16,16, 0,16,16, 0, 0, 0,16,17, 0,
	22, 0,12,12,16,16, 0,14,14,17,18, 0,11,11,16,16,
	 0,15,15, 0,21, 0,16,16,21,22, 0,12,12,16,16, 0,
	15,15,19,19, 0,12,12,17,16, 0,16,16,21,22, 0,16,
	16, 0, 0, 0,17,17, 0,22, 0, 0, 0, 0, 0, 0,15,15,
	19,20, 0,17,19, 0, 0, 0,17,17,22, 0, 0,17,17, 0,
	22, 0, 0, 0, 0, 0, 0,15,15,21, 0, 0,19,20, 0, 0,
	 0,19,18,22, 0, 0,11,12,14,14, 0,11,11,14,14, 0,
	12,12,15,15, 0,13,13,13,13, 0,14,14,16,16, 0,12,
	12,15,15, 0,14,14,16,15, 0,11,11,15,15, 0,13,13,
	16,16, 0,13,13,15,15, 0,12,12,15,15, 0,15,14,16,
	16, 0,11,11,15,15, 0,14,14,17,17, 0,13,13,15,15,
	 0,15,15,16,16, 0, 0, 0,18,18, 0,12,12,14,14, 0,
	16,16,22, 0, 0,14,14,15,15, 0,15,15,16,17, 0,21,
	22,18,18, 0,13,13,15,14, 0,18,17,22, 0, 0,14,14,
	15,15, 8, 8, 8,16,15,12,10,10,16,15,12,10,10,16,
	16, 0,14,14,16,17, 0,14,14,17,16,12,10,10,17,18,
	14,12,12,18,18,14,10,10,16,16, 0,14,14,18,18, 0,
	14,14,16,16,12, 9, 9,16,16,17,13,13,16,17,14, 9,
	 9,15,15, 0,14,14,18,19, 0,13,13,15,15, 0,15,15,
	18,19, 0, 0, 0,22,21, 0,13,13,16,16, 0,16,16,22,
	 0, 0,15,15,16,16, 0,14,14,18,17, 0, 0, 0,20, 0,
	 0,13,13,16,16, 0,18,18, 0, 0, 0,15,15,16,16, 8,
	 7, 7,13,13,12,10,10,15,15,12,10,10,14,14, 0,22,
	22,19,18, 0, 0, 0,18,18,12,10,10,15,15,14,13,13,
	17,17,14,11,11,15,15, 0,19,20,18,18, 0,22,21,17,
	18,13,11,11,15,15,16,13,13,18,18,14,11,11,14,15,
	 0,22,21,20,19, 0,22,21,17,17, 0, 0,22,19,18, 0,
	 0, 0, 0, 0, 0,22,20,17,17, 0, 0, 0,21,20, 0, 0,
	 0,19,17, 0, 0,22,19,19, 0, 0, 0, 0, 0, 0,22,20,
	18,17, 0, 0, 0, 0, 0, 0, 0, 0,18,18, 0,10,10,14,
	14, 0,11,11,14,14, 0,11,11,15,15, 0,14,14,14,14,
	 0,15,15,16,16, 0,11,11,16,16, 0,13,13,16,16, 0,
	11,11,15,15, 0,14,14,16,16, 0,14,14,15,15, 0,11,
	11,15,15, 0,13,13,15,15, 0,10,10,15,15, 0,15,15,
	17,17, 0,14,14,14,14, 0,16,16,16,16, 0, 0,22,19,
	19, 0,13,13,14,14, 0,17,17, 0, 0, 0,15,15,14,14,
	 0,16,16,17,17, 0, 0,22,18,18, 0,13,13,14,14, 0,
	21,18, 0, 0, 0,15,15,14,14, 0,11,11,13,13, 0,12,
	12,15,15, 0,12,12,16,15, 0,16,16, 0, 0, 0,17,17,
	22,22, 0,12,12,16,16, 0,14,14,18,18, 0,11,12,16,
	16, 0,15,16, 0,21, 0,16,16,22,21, 0,12,12,16,16,
	 0,15,15,19,20, 0,11,12,16,16, 0,15,15,20,22, 0,
	16,16, 0,22, 0,17,17,22, 0, 0, 0, 0, 0, 0, 0,15,
	15,21,22, 0,19,18, 0, 0, 0,17,17, 0, 0, 0,17,17,
	 0,22, 0, 0, 0, 0, 0, 0,16,15,22, 0, 0,19,19, 0,
	 0, 0,17,18, 0, 0, 0,12,12,15,15, 0,12,12,15,15,
	 0,12,12,15,15, 0,13,13,14,14, 0,15,15,16,17, 0,
	12,12,16,16, 0,14,14,16,16, 0,12,11,15,16, 0,14,
	14,16,17, 0,14,14,16,16, 0,13,12,16,16, 0,15,15,
	16,16, 0,11,11,15,15, 0,14,14,16,16, 0,14,14,15,
	15, 0,15,15,18,17, 0, 0,22, 0,20, 0,13,13,15,15,
	 0,16,17,22,22, 0,14,14,15,15, 0,15,15,17,18, 0,
	20, 0,19,19, 0,13,13,15,15, 0,18,18,22, 0, 0,14,
	14,15,15, 0,11,11,16,16, 0,14,14,17,16, 0,13,13,
	17,17, 0,16,16,17,17, 0,17,17,18,19, 0,12,12,16,
	17, 0,15,15,18,18, 0,12,12,16,16, 0,16,16,19,18,
	 0,16,16,17,16, 0,12,13,17,17, 0,17,16,18,17, 0,
	13,12,16,16, 0,16,16,18,19, 0,16,16,16,17, 0,16,
	16,18,18, 0,22, 0,22,22, 0,13,13,16,16, 0,19,18,
	22,20, 0,16,15,16,16, 0,16,17,18,18, 0, 0, 0,22,
	20, 0,14,14,16,16, 0,19,19, 0, 0, 0,16,16,16,16,
	 0, 9, 9,13,13, 0,13,13,15,15, 0,14,14,15,15, 0,
	 0,22,17,18, 0,22, 0,18,19, 0,12,12,15,15, 0,15,
	16,17,17, 0,14,14,14,14, 0,22, 0,18,18, 0,21,22,
	17,17, 0,13,13,15,15, 0,17,17,17,18, 0,14,14,15,
	15, 0,22,21,21,19, 0,20,21,17,17, 0,21,21,19,18,
	 0, 0, 0, 0, 0, 0,21,21,17,17, 0, 0, 0,22,22, 0,
	 0,22,19,18, 0, 0,21,19,18, 0, 0, 0, 0,22, 0,19,
	20,17,17, 0, 0, 0, 0,22, 0, 0, 0,19,18, 0,19,19,
	15,16, 0,21,19,16,17, 0, 0,21,17,17, 0, 0,22,17,
	17, 0,22,22,18,19, 0,20,20,16,16, 0, 0,22,18,18,
	 0,20,19,16,17, 0,22,21,20,19, 0, 0,21,17,17, 0,
	21,20,17,17, 0, 0, 0,18,18, 0,19,19,17,16, 0,22,
	 0,19,19, 0,21,22,17,18, 0, 0,22,19,18, 0, 0, 0,
	19,20, 0,19,19,16,16, 0,22,22,22, 0, 0,20,22,16,
	16, 0,22,20,18,19, 0, 0, 0,20,19, 0,20,20,16,16,
	 0, 0, 0, 0, 0, 0,22,20,17,16, 0,11,11,13,13, 0,
	14,13,15,15, 0,13,13,16,15, 0,18,17,21, 0, 0,18,
	18,21, 0, 0,12,12,15,15, 0,15,16,17,18, 0,12,12,
	15,15, 0,17,17,22,20, 0,17,18,22, 0, 0,12,12,17,
	16, 0,16,17,19,19, 0,13,13,16,16, 0,17,17, 0,22,
	 0,17,17, 0,21, 0,18,18,20,22, 0, 0, 0, 0, 0, 0,
	15,15,21,20, 0,20,19, 0, 0, 0,18,18,22, 0, 0,17,
	17,22, 0, 0, 0, 0, 0, 0, 0,15,16,20,22, 0,20,21,
	 0, 0, 0,19,18, 0, 0, 0,15,15,19,19, 0,17,16,20,
	20, 0,16,17,20,21, 0,18,17, 0, 0, 0,19,19, 0, 0,
	 0,15,15,21,19, 0,19,19, 0, 0, 0,15,15,22,22, 0,
	18,18, 0,22, 0,17,18,22,21, 0,15,15,20,19, 0,19,
	19, 0, 0, 0,15,15,20,22, 0,18,19,20, 0, 0,18,17,
	21,21, 0,18,18,19,22, 0, 0, 0, 0, 0, 0,15,15,20,
	19, 0,19,19, 0, 0, 0,18,18,21,22, 0,18,18,22, 0,
	 0, 0, 0, 0, 0, 0,15,15,19,20, 0,21,21, 0, 0, 0,
	17,17,20,20, 0,12,12,17,17, 0,14,14,16,17, 0,13,
	14,17,17, 0,16,16,17,17, 0,17,17,17,19, 0,13,13,
	17,17, 0,16,16,18,18, 0,13,13,16,16, 0,16,16,18,
	18, 0,16,16,17,17, 0,13,13,17,17, 0,17,17,18,17,
	 0,12,12,15,16, 0,17,18,19,20, 0,16,16,16,16, 0,
	17,16,18,19, 0, 0,22,21,22, 0,14,14,16,16, 0,19,
	19, 0, 0, 0,16,16,16,16, 0,16,16,18,17, 0, 0,22,
	21,21, 0,14,14,16,16, 0,22,20,22, 0, 0,16,16,15,
	15, 0, 9, 9,13,13, 0,14,14,15,15, 0,14,14,14,14,
	 0,22,22,18,18, 0, 0,22,18,18, 0,12,12,15,15, 0,
	16,16,18,17, 0,14,14,14,14, 0,20,21,18,18, 0,22,
	21,17,17, 0,13,13,15,15, 0,17,17,18,18, 0,14,14,
	14,14, 0, 0,21,18,19, 0, 0,22,17,17, 0,22,22,19,
	18, 0, 0, 0, 0, 0, 0,19,21,17,17, 0, 0, 0,22,20,
	 0, 0,21,18,19, 0, 0,22,18,18, 0, 0, 0, 0,22, 0,
	20,22,17,17, 0, 0, 0,20,22, 0, 0, 0,18,18, 0,19,
	21,16,16, 0,20,22,16,17, 0,20, 0,17,17, 0,22, 0,
	18,17, 0,21, 0,18,19, 0,20,20,17,17, 0,22, 0,18,
	18, 0,21,20,17,17, 0, 0,20,20,19, 0, 0,21,18,17,
	 0,21,21,17,17, 0,22, 0,18,17, 0,19,19,17,17, 0,
	 0,22,20,21, 0, 0,21,17,17, 0,22, 0,18,18, 0, 0,
	 0,20,22, 0,20,19,16,16, 0, 0, 0, 0, 0, 0,22,22,
	17,17, 0,22, 0,18,19, 0, 0, 0,21,20, 0,19,21,16,
	17, 0, 0, 0, 0, 0, 0,22,22,17,16, 0,11,11,13,13,
	 0,13,13,15,15, 0,13,13,15,15, 0,17,17,22,21, 0,
	18,18,22, 0, 0,12,13,16,15, 0,15,16,18,18, 0,13,
	13,16,16, 0,17,17, 0,22, 0,17,17,22,22, 0,13,13,
	16,16, 0,16,16,19,18, 0,13,13,16,16, 0,18,17, 0,
	20, 0,18,17,20, 0, 0,17,17,21, 0, 0, 0, 0, 0, 0,
	 0,15,15,21,22, 0,19,20, 0, 0, 0,18,18, 0, 0, 0,
	18,17, 0, 0, 0, 0, 0, 0, 0, 0,16,16,22,22, 0,20,
	20, 0, 0, 0,21,19, 0, 0, 0,15,15,20,19, 0,16,16,
	22,20, 0,17,17, 0,22, 0,18,18, 0,22, 0,19,17, 0,
	 0, 0,15,16,22,20, 0,18,19, 0, 0, 0,16,16,22,20,
	 0,18,18, 0,22, 0,18,18,22, 0, 0,16,16,21,20, 0,
	19,20, 0,22, 0,16,16, 0,22, 0,18,18, 0,22, 0,18,
	18, 0,21, 0,19,18, 0,22, 0, 0, 0, 0, 0, 0,16,16,
	21,20, 0,20, 0, 0, 0, 0,18,18,21, 0, 0,18,18, 0,
	 0, 0, 0, 0, 0, 0, 0,16,16,21,19, 0, 0, 0, 0, 0,
	 0,18,18, 0,21,
};

static const static_codebook _44p3_p5_0 = {
	5, 3125,
	(long *)_vq_lengthlist__44p3_p5_0,
	1, -528744448, 1616642048, 3, 0,
	(long *)_vq_quantlist__44p3_p5_0,
	0
};

static const long _vq_quantlist__44p3_p5_1[] = {
	3,
	2,
	4,
	1,
	5,
	0,
	6,
};

static const long _vq_lengthlist__44p3_p5_1[] = {
	 2, 3, 3, 3, 3, 3, 3,
};

static const static_codebook _44p3_p5_1 = {
	1, 7,
	(long *)_vq_lengthlist__44p3_p5_1,
	1, -533200896, 1611661312, 3, 0,
	(long *)_vq_quantlist__44p3_p5_1,
	0
};

static const long _vq_quantlist__44p3_p6_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p3_p6_0[] = {
	 1, 6, 6, 7, 7, 7, 7, 8, 8, 7, 9, 9,11,11,11, 9,
	 8, 8, 8, 9, 9,12,11,11, 9, 8, 8, 6, 7, 7,10,11,
	10,10,10,10,11,11,10,14,13,14,12,11,11,11,11,11,
	15,14,14,13,12,12, 5, 6, 6, 8, 5, 5, 8, 7, 7, 8,
	 8, 8,12,10,10, 9, 7, 7, 9, 7, 8,12,10,10,10, 7,
	 7, 7, 8, 8,12,10,10,12,10,10,11,10,10,15,13,13,
	13,10,10,11,10,10,16,13,14,14,10,10, 7, 7, 7,12,
	11,11,12,11,11,11,11,11,16,15,15,14,12,12,12,11,
	11,16,15,16,14,12,12,10, 9, 9,14,11,11,13,11,11,
	12,11,11,16,14,14,14,11,11,12,11,11,17,15,15,14,
	11,11, 7, 8, 8,12,11,11,12,10,10,12,10,10,16,14,
	13,14,10,10,12,10,10,17,14,14,14,10,10, 8, 7, 7,
	13,11,11,12,11,11,12,11,11,16,15,14,14,12,12,12,
	11,11,16,15,14,15,12,12,11,10,10,13,11,11,13,12,
	11,13,11,11,17,14,14,14,11,11,13,11,11,17,14,15,
	14,11,11,
};

static const static_codebook _44p3_p6_0 = {
	5, 243,
	(long *)_vq_lengthlist__44p3_p6_0,
	1, -527106048, 1620377600, 2, 0,
	(long *)_vq_quantlist__44p3_p6_0,
	0
};

static const long _vq_quantlist__44p3_p6_1[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p3_p6_1[] = {
	 2, 6, 6, 7, 7, 7, 7, 7, 7, 7, 8, 8, 9, 9, 9, 9,
	 7, 7, 8, 8, 8, 9, 9, 9, 9, 7, 8, 6, 7, 7, 8, 8,
	 8, 8, 8, 8, 9, 8, 8,10, 9, 9,10, 8, 8,10, 8, 8,
	10, 9, 9,10, 8, 8, 6, 6, 6, 8, 6, 6, 8, 7, 7, 8,
	 7, 7,10, 8, 8, 9, 7, 7, 9, 7, 7,10, 8, 9, 9, 7,
	 7, 7, 7, 7,10, 8, 8,11, 8, 8,10, 8, 8,12, 9, 9,
	12, 8, 8,11, 9, 9,12, 9, 9,11, 8, 8, 7, 7, 7,10,
	 9, 9,10, 9, 9,10, 9, 9,11,10,10,10, 9, 9,11, 9,
	 9,11,10,10,11, 9, 9, 9, 8, 8,10, 9, 9,10, 9, 9,
	11, 9, 9,11,10,10,11, 9, 9,11, 9, 9,11,10,10,11,
	 9, 9, 8, 8, 8,11, 9, 9,11, 9, 9,11, 9, 9,12, 9,
	 9,12, 8, 8,12, 9, 9,12, 9, 9,12, 8, 8, 8, 7, 7,
	10, 9, 9,10, 9, 9,11, 9, 9,11,11,11,11, 9, 9,11,
	10,10,11,11,11,11, 9, 9,10, 9, 9,11, 9, 9,11, 9,
	10,11,10, 9,11,10,10,11, 9, 9,11, 9,10,11,10,10,
	11, 9, 9,
};

static const static_codebook _44p3_p6_1 = {
	5, 243,
	(long *)_vq_lengthlist__44p3_p6_1,
	1, -530841600, 1616642048, 2, 0,
	(long *)_vq_quantlist__44p3_p6_1,
	0
};

static const long _vq_quantlist__44p3_p7_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p3_p7_0[] = {
	 1, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9,
};

static const static_codebook _44p3_p7_0 = {
	5, 243,
	(long *)_vq_lengthlist__44p3_p7_0,
	1, -513979392, 1633504256, 2, 0,
	(long *)_vq_quantlist__44p3_p7_0,
	0
};

static const long _vq_quantlist__44p3_p7_1[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p3_p7_1[] = {
	 1, 9, 9, 6, 9, 9, 5, 9, 9, 8, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 8, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 8, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 7, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 8, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9,10,10,10,10,10,10,10,10,10,10,10,
	10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
	10,10,10,
};

static const static_codebook _44p3_p7_1 = {
	5, 243,
	(long *)_vq_lengthlist__44p3_p7_1,
	1, -516716544, 1630767104, 2, 0,
	(long *)_vq_quantlist__44p3_p7_1,
	0
};

static const long _vq_quantlist__44p3_p7_2[] = {
	12,
	11,
	13,
	10,
	14,
	9,
	15,
	8,
	16,
	7,
	17,
	6,
	18,
	5,
	19,
	4,
	20,
	3,
	21,
	2,
	22,
	1,
	23,
	0,
	24,
};

static const long _vq_lengthlist__44p3_p7_2[] = {
	 1, 3, 2, 5, 4, 7, 7, 8, 8, 9, 9,10,10,11,11,12,
	12,13,13,14,14,15,15,15,15,
};

static const static_codebook _44p3_p7_2 = {
	1, 25,
	(long *)_vq_lengthlist__44p3_p7_2,
	1, -518864896, 1620639744, 5, 0,
	(long *)_vq_quantlist__44p3_p7_2,
	0
};

static const long _vq_quantlist__44p3_p7_3[] = {
	12,
	11,
	13,
	10,
	14,
	9,
	15,
	8,
	16,
	7,
	17,
	6,
	18,
	5,
	19,
	4,
	20,
	3,
	21,
	2,
	22,
	1,
	23,
	0,
	24,
};

static const long _vq_lengthlist__44p3_p7_3[] = {
	 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5,
	 5, 5, 5, 5, 5, 5, 5, 5, 5,
};

static const static_codebook _44p3_p7_3 = {
	1, 25,
	(long *)_vq_lengthlist__44p3_p7_3,
	1, -529006592, 1611661312, 5, 0,
	(long *)_vq_quantlist__44p3_p7_3,
	0
};

static const long _huff_lengthlist__44p3_short[] = {
	 4, 5,16, 9, 9,12,17,18, 4, 2,18, 6, 5, 9,13,15,
	10, 7, 7, 6, 7, 9,13,13, 8, 5, 6, 5, 5, 7,11,12,
	 8, 4, 7, 4, 3, 6,10,12,11, 8, 9, 7, 6, 8,11,12,
	15,13,13,11, 9, 7,10,12,16,12,16,12, 6, 5, 8,11,
};

static const static_codebook _huff_book__44p3_short = {
	2, 64,
	(long *)_huff_lengthlist__44p3_short,
	0, 0, 0, 0, 0,
	NULL,
	0
};

static const long _vq_quantlist__44p4_l0_0[] = {
	6,
	5,
	7,
	4,
	8,
	3,
	9,
	2,
	10,
	1,
	11,
	0,
	12,
};

static const long _vq_lengthlist__44p4_l0_0[] = {
	 1, 4, 4, 8, 8, 9, 8, 9, 9,10,10,10,10, 4, 6, 5,
	 8, 7, 9, 9, 9, 9,10, 9,10,10, 4, 5, 6, 7, 8, 9,
	 9, 9, 9, 9,10, 9,10, 8, 9, 8, 9, 8,10, 9,11, 9,
	12,10,11,10, 8, 8, 9, 8, 9, 9,10, 9,11,10,11,10,
	12, 9,10,10,11,10,11,11,12,11,12,12,12,12, 9,10,
	10,11,11,11,11,11,12,12,12,12,12,10,11,11,12,12,
	12,12,12,12,12,12,12,12,10,11,11,12,12,12,12,12,
	12,12,12,12,12,11,12,12,12,12,12,12,12,12,12,13,
	12,12,11,12,11,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,13,12,12,12,12,12,12,11,13,12,12,
	12,13,12,12,12,12,12,12,12,
};

static const static_codebook _44p4_l0_0 = {
	2, 169,
	(long *)_vq_lengthlist__44p4_l0_0,
	1, -526516224, 1616117760, 4, 0,
	(long *)_vq_quantlist__44p4_l0_0,
	0
};

static const long _vq_quantlist__44p4_l0_1[] = {
	2,
	1,
	3,
	0,
	4,
};

static const long _vq_lengthlist__44p4_l0_1[] = {
	 3, 4, 4, 5, 5, 4, 4, 5, 5, 5, 4, 5, 4, 5, 5, 5,
	 5, 6, 5, 6, 5, 6, 5, 6, 5,
};

static const static_codebook _44p4_l0_1 = {
	2, 25,
	(long *)_vq_lengthlist__44p4_l0_1,
	1, -533725184, 1611661312, 3, 0,
	(long *)_vq_quantlist__44p4_l0_1,
	0
};

static const long _vq_quantlist__44p4_l1_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p4_l1_0[] = {
	 1, 4, 4, 4, 4, 4, 4, 4, 4,
};

static const static_codebook _44p4_l1_0 = {
	2, 9,
	(long *)_vq_lengthlist__44p4_l1_0,
	1, -516716544, 1630767104, 2, 0,
	(long *)_vq_quantlist__44p4_l1_0,
	0
};

static const long _huff_lengthlist__44p4_lfe[] = {
	 1, 3, 2, 3,
};

static const static_codebook _huff_book__44p4_lfe = {
	2, 4,
	(long *)_huff_lengthlist__44p4_lfe,
	0, 0, 0, 0, 0,
	NULL,
	0
};

static const long _huff_lengthlist__44p4_long[] = {
	 3, 5,13, 9, 9,12,16,18, 4, 2,20, 6, 7,10,15,20,
	10, 7, 5, 5, 6, 8,10,13, 8, 5, 5, 3, 5, 7,10,11,
	 9, 7, 6, 5, 5, 7, 9, 9,11,10, 8, 7, 6, 6, 8, 8,
	15,15,10,10, 9, 7, 8, 9,17,19,13,12,10, 8, 9, 9,
};

static const static_codebook _huff_book__44p4_long = {
	2, 64,
	(long *)_huff_lengthlist__44p4_long,
	0, 0, 0, 0, 0,
	NULL,
	0
};

static const long _vq_quantlist__44p4_p1_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p4_p1_0[] = {
	 1, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0,
};

static const static_codebook _44p4_p1_0 = {
	5, 243,
	(long *)_vq_lengthlist__44p4_p1_0,
	1, -535822336, 1611661312, 2, 0,
	(long *)_vq_quantlist__44p4_p1_0,
	0
};

static const long _vq_quantlist__44p4_p2_0[] = {
	2,
	1,
	3,
	0,
	4,
};

static const long _vq_lengthlist__44p4_p2_0[] = {
	 3, 9, 9, 0, 0, 0, 8, 8, 0, 0, 0, 9, 9, 0, 0, 0,
	12,12, 0, 0, 0, 0, 0, 0, 0, 0,10,10, 0, 0, 0, 0,
	 0, 0, 0, 0, 9, 9, 0, 0, 0,11,11, 0, 0, 0, 0, 0,
	 0, 0, 0,10,10, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0,
	 0, 0,11,11, 0, 0, 0, 0, 0, 0, 0, 0,12,12, 0, 0,
	 0, 0, 0, 0, 0, 0,11,11, 0, 0, 0,12,12, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 0, 0, 0,
	 5, 5, 0, 0, 0, 7, 7, 0, 0, 0, 9, 9, 0, 0, 0, 0,
	 0, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5,
	 0, 0, 0, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 0,
	 0, 0, 0, 0, 0, 0, 0, 5, 5, 0, 0, 0, 7, 7, 0, 0,
	 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0,
	 7, 7, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0,11,11, 0, 0, 0, 9, 9, 0,
	 0, 0,10,10, 0, 0, 0,10,10, 0, 0, 0, 0, 0, 0, 0,
	 0,10,10, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0,
	10,10, 0, 0, 0, 0, 0, 0, 0, 0,10,10, 0, 0, 0, 0,
	 0, 0, 0, 0, 9, 9, 0, 0, 0,10,10, 0, 0, 0, 0, 0,
	 0, 0, 0,12,12, 0, 0, 0, 0, 0, 0, 0, 0,11,11, 0,
	 0, 0,12,12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 9, 9, 0, 0, 0, 7, 7, 0, 0, 0, 8, 8, 0, 0,
	 0,10,10, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0,
	 0, 0, 0, 0, 0, 7, 7, 0, 0, 0, 9, 9, 0, 0, 0, 0,
	 0, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8,
	 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0,10,10, 0,
	 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0,11,11, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5,
	 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0,10,10, 0, 0, 0, 7, 7,
	 0, 0, 0, 9, 9, 0, 0, 0,10,10, 0, 0, 0, 0, 0, 0,
	 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 0, 0,
	 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0,
	 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 9, 9, 0, 0, 0, 0,
	 0, 0, 0, 0,11,11, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9,
	 0, 0, 0,10,10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 9, 9, 0, 0, 0, 7, 7, 0, 0, 0, 8, 8, 0,
	 0, 0,10,11, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0,
	 0, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 9, 9, 0, 0, 0,
	 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 7,
	 7, 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0,11,11,
	 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0,10,10, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 5, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,10,10, 0, 0, 0, 7,
	 7, 0, 0, 0, 9, 9, 0, 0, 0,10,10, 0, 0, 0, 0, 0,
	 0, 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 7, 8, 0,
	 0, 0, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0,
	 0, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0, 9, 9, 0, 0, 0,
	 0, 0, 0, 0, 0,10,10, 0, 0, 0, 0, 0, 0, 0, 0, 9,
	 9, 0, 0, 0,11,11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0,10,10, 0, 0, 0, 9, 9, 0, 0, 0,10,10,
	 0, 0, 0,11,11, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0,
	 0, 0, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0,10,10, 0, 0,
	 0, 0, 0, 0, 0, 0,10,10, 0, 0, 0, 0, 0, 0, 0, 0,
	 9, 9, 0, 0, 0,10,10, 0, 0, 0, 0, 0, 0, 0, 0,11,
	11, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 0, 0, 0,12,12,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,10,10, 0, 0, 0,
	 9, 9, 0, 0, 0,10,10, 0, 0, 0,12,12, 0, 0, 0, 0,
	 0, 0, 0, 0,10,10, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9,
	 0, 0, 0,10,10, 0, 0, 0, 0, 0, 0, 0, 0,10,10, 0,
	 0, 0, 0, 0, 0, 0, 0, 8, 8, 0, 0, 0,10,10, 0, 0,
	 0, 0, 0, 0, 0, 0,11,11, 0, 0, 0, 0, 0, 0, 0, 0,
	10,10, 0, 0, 0,11,11, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0,
};

static const static_codebook _44p4_p2_0 = {
	5, 3125,
	(long *)_vq_lengthlist__44p4_p2_0,
	1, -533725184, 1611661312, 3, 0,
	(long *)_vq_quantlist__44p4_p2_0,
	0
};

static const long _vq_quantlist__44p4_p3_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p4_p3_0[] = {
	 1, 6, 6, 5, 7, 8, 0, 8, 8, 6, 9, 9, 7,10,10, 0,
	 8, 8, 0, 9, 9, 0,12,12, 0, 8, 8, 4, 7, 7, 6,10,
	10, 0,12,12, 7,11,11, 8,12,12, 0,12,12, 0,13,12,
	 0,15,15, 0,12,12, 0, 7, 7, 0, 7, 7, 0, 7, 7, 0,
	 8, 8, 0,10,10, 0, 7, 7, 0, 8, 8, 0,11,11, 0, 7,
	 7, 5, 7, 7, 8, 9, 9, 0,10,10, 8, 9, 9,11,11,11,
	 0,10, 9, 0,11,11, 0,13,13, 0,10,10, 6, 7, 7, 8,
	10,10, 0,12,12, 9,10,10,10,12,12, 0,12,12, 0,12,
	12, 0,15,15, 0,12,12, 0,10,10, 0,11,11, 0,11,11,
	 0,11,11, 0,13,13, 0,11,11, 0,11,11, 0,15,15, 0,
	10,10, 0, 8, 8, 0,10,10, 0,12,12, 0,11,11, 0,12,
	12, 0,12,12, 0,12,12, 0,15,15, 0,11,11, 0, 7, 7,
	 0,10,10, 0,12,12, 0,10,10, 0,12,12, 0,12,12, 0,
	13,13, 0,14,14, 0,12,12, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0,
};

static const static_codebook _44p4_p3_0 = {
	5, 243,
	(long *)_vq_lengthlist__44p4_p3_0,
	1, -533200896, 1614282752, 2, 0,
	(long *)_vq_quantlist__44p4_p3_0,
	0
};

static const long _vq_quantlist__44p4_p3_1[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p4_p3_1[] = {
	 3, 5, 5, 0, 8, 8, 0, 8, 8, 0, 9, 9, 0,10,10, 0,
	 8, 8, 0, 8, 8, 0,10,10, 0, 8, 8, 0, 7, 7, 0, 8,
	 8, 0, 7, 7, 0, 8, 8, 0, 8, 8, 0, 8, 8, 0, 8, 8,
	 0, 8, 8, 0, 8, 8, 0, 7, 7, 0, 6, 6, 0, 7, 7, 0,
	 7, 7, 0,10,10, 0, 6, 6, 0, 7, 7, 0,10,10, 0, 5,
	 5, 0, 8, 8, 0, 7, 7, 0, 8, 8, 0, 8, 8, 0, 9, 9,
	 0, 7, 7, 0, 8, 8, 0, 9, 9, 0, 7, 7, 0, 6, 6, 0,
	 9,10, 0,10,10, 0,10,10, 0,11,11, 0, 9, 9, 0,10,
	10, 0,11,11, 0, 9, 9, 0, 8, 8, 0, 8, 8, 0, 8, 8,
	 0, 9, 9, 0, 9, 9, 0, 7, 7, 0, 8, 8, 0, 9, 9, 0,
	 7, 7, 0, 8, 8, 0, 7, 7, 0, 7, 7, 0, 8, 8, 0, 9,
	 9, 0, 7, 7, 0, 7, 7, 0, 8, 8, 0, 6, 6, 0, 6, 6,
	 0,10,10, 0,10,10, 0,10,10, 0,12,12, 0, 9, 9, 0,
	10,10, 0,12,12, 0, 9, 9, 0, 8, 8, 0, 7, 7, 0, 7,
	 7, 0, 8, 8, 0, 9, 9, 0, 7, 7, 0, 8, 8, 0, 9, 9,
	 0, 6, 6,
};

static const static_codebook _44p4_p3_1 = {
	5, 243,
	(long *)_vq_lengthlist__44p4_p3_1,
	1, -535822336, 1611661312, 2, 0,
	(long *)_vq_quantlist__44p4_p3_1,
	0
};

static const long _vq_quantlist__44p4_p4_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p4_p4_0[] = {
	 1, 6, 6, 6, 7, 7, 7, 8, 8, 7, 8, 8,10,11,11, 9,
	 8, 8, 8, 8, 8,11,11,12, 9, 8, 8, 5, 7, 7, 9,11,
	11,10,11,11,10,11,11,12,14,14,11,12,12,10,12,12,
	13,14,14,12,12,12, 5, 6, 6, 7, 6, 6, 8, 7, 7, 8,
	 7, 7,11,10,10,10, 7, 7, 9, 8, 8,12,11,11,10, 7,
	 7, 7, 7, 7,11,10,10,12,10,10,11,10,10,15,13,13,
	13,10,10,12,11,11,15,13,13,14,11,11, 7, 7, 7,11,
	11,11,12,11,11,12,11,11,14,14,14,13,12,12,12,12,
	12,16,15,15,14,12,12, 0,10,10, 0,11,11, 0,12,12,
	 0,11,11, 0,14,14, 0,11,11, 0,12,12, 0,15,15, 0,
	11,11, 7, 8, 8,12,11,10,12,10,10,12,11,11,15,13,
	13,14,11,11,12,10,10,16,14,14,14,10,10, 8, 7, 7,
	12,11,11,12,11,11,12,11,11,15,14,14,14,12,12,13,
	12,12,15,14,14,15,13,13, 0,11,11, 0,12,12, 0,12,
	12, 0,12,12, 0,15,15, 0,12,12, 0,13,13, 0,15,14,
	 0,12,12,
};

static const static_codebook _44p4_p4_0 = {
	5, 243,
	(long *)_vq_lengthlist__44p4_p4_0,
	1, -531365888, 1616117760, 2, 0,
	(long *)_vq_quantlist__44p4_p4_0,
	0
};

static const long _vq_quantlist__44p4_p4_1[] = {
	2,
	1,
	3,
	0,
	4,
};

static const long _vq_lengthlist__44p4_p4_1[] = {
	 4, 5, 5, 9, 9,12, 9, 9,12,12,12,10,10,13,13,13,
	11,11,12,12,13,13,13,12,12,13,10,10,13,13,13,13,
	13,13,13,13,10,10,13,12,13,11,11,13,13,13,14,14,
	13,12,13,10,10,13,13,12,13,13,13,13,13,10,10,12,
	12,13,11,11,13,13,13,14,14,12,12,13,12,12,13,13,
	13,13,13,13,13,13,11,11,12,12,13,11,11,13,13,13,
	14,14,12,12,13,14,14,13,13,14,13,13,14,14,14,14,
	14,12,12,13,14,14,13,13,14,14,14,12,12,12, 8, 8,
	12,12,13,12,12,11,11,13,11,11,11,11,14,12,12,11,
	11,14,12,12,10,11,14,12,12,12,12,14,12,12,12,12,
	13,13,13,11,11,14,12,12,11,11,14,12,12,12,12,14,
	12,12,12,12,14,12,12,12,12,14,13,13,11,11,14,12,
	12,11,11,14,12,12,12,12,14,13,13,12,12,14,12,12,
	12,12,14,13,13,11,11,14,12,12,11,11,14,13,13,11,
	11,15,13,13,12,12,14,12,12,12,12,15,13,13,12,12,
	14,12,12,11,11,15,13,13,11,11,12, 9, 9,11,11,13,
	 7, 7,11,11,13, 8, 8,12,12,14,10,10,10,10,14,14,
	14,11,11,14, 8, 8,12,12,14,14,14,12,12,14, 7, 7,
	11,11,14, 9, 9,12,12,14,14,14,11,11,14, 8, 8,12,
	12,14,14,14,12,12,14, 7, 7,11,11,14, 9, 9,12,12,
	14,14,14,11,11,14,10,10,12,12,14,14,14,13,13,14,
	 9, 9,11,11,14,10,10,12,11,15,14,14,11,11,14,15,
	15,12,12,15,14,14,14,14,15,14,14,11,11,15,14,14,
	12,12,15,14,14,11,11,14,11,11,10,10,15,10,10,10,
	10,15,10,10,10,10,15,11,11, 9, 9,15,12,13, 9, 9,
	15,11,11,11,11,15,13,13,11,11,15,10,10,10,10,15,
	11,11,10,10,15,13,13,11,11,15,11,11,11,11,15,13,
	13,11,11,15,10,10,10,10,15,11,11,10,10,15,13,13,
	10,11,15,12,12,11,11,15,13,13,11,10,15,11,11,10,
	10,15,11,12,10, 9,15,13,13,10,10,15,14,14,11,11,
	15,13,13,11,11,15,14,14,10,10,15,13,13,10,10,15,
	14,14,10,10,14,13,13,10,10,15,13,13,10,10,15,13,
	13,10,10,14,14,14, 8, 9,15,14,14, 9, 9,15,14,14,
	11,11,15,14,14,10,10,15,14,14,10,10,15,14,14,11,
	11,15,14,14,10,10,15,14,14,11,11,15,14,14,10,10,
	15,14,14,10,10,15,14,14,10,10,15,14,14, 9, 9,15,
	14,14,11,11,15,14,14,11,11,15,14,14,10,10,15,14,
	14,10,10,14,14,14, 9, 9,15,15,15,11,11,15,14,14,
	12,12,15,15,15,10,10,15,14,15,10,10,15,15,15, 9,
	 9,15,10,10,13,13,17, 8, 8,12,12,17,10, 9,13,13,
	18,11,11,12,12,18,14,14,12,12,17, 9, 9,13,13,17,
	13,13,12,12,18, 8, 8,12,12,18,10,10,12,12,18,14,
	14,12,12,18,10,10,13,13,18,13,13,13,13,18, 9, 9,
	12,12,18,10,10,13,13,18,14,14,12,12,18,11,11,13,
	13,18,14,14,13,13,18,10,10,12,12,17,11,11,12,12,
	18,14,14,12,12,18,14,14,13,13,18,14,14,13,13,19,
	14,15,12,12,18,14,14,12,12,18,15,15,12,12,13, 7,
	 7,11,11,14,15,15,11,11,14,16,15,11,11,14,15,15,
	11,11,14,15,15,11,11,14,15,15,11,12,14,15,15,12,
	12,13,15,15,11,11,14,15,15,11,11,15,15,15,12,12,
	14,15,15,12,12,14,16,16,12,12,14,15,15,11,11,14,
	15,15,11,11,15,15,15,12,12,15,15,15,12,12,14,15,
	15,12,12,14,15,15,11,11,14,15,15,11,11,15,14,15,
	12,12,15,15,15,12,12,15,16,16,12,12,15,15,15,12,
	12,14,15,15,12,12,15,15,15,12,12,13,13,13,11,11,
	14,14,15,11,11,14,14,14,12,12,14,15,15,10,10,15,
	15,15,11,11,14,15,15,12,12,14,14,14,11,11,14,15,
	15,11,11,14,15,15,12,12,15,15,15,11,11,14,15,15,
	12,12,14,14,15,11,11,14,15,15,11,11,14,15,15,12,
	12,15,15,15,11,11,15,15,15,12,12,14,15,15,12,12,
	14,15,15,10,10,14,15,15,11,11,15,15,15,10,10,15,
	15,15,12,12,15,15,15,14,14,15,15,15,11,11,15,15,
	15,11,11,15,15,15,11,11,14,10,10,10,10,15, 9, 9,
	12,11,15,10,10,12,12,15,11,11,11,11,15,13,13,12,
	12,16,10,10,12,12,15,13,13,12,12,15, 9, 9,11,11,
	15,10,10,13,12,15,13,13,11,11,15,10,10,12,12,15,
	13,13,12,12,15, 9, 9,11,11,15,10,10,12,12,15,13,
	13,11,11,15,11,11,12,12,15,13,13,13,13,15,10,10,
	11,11,15,11,11,12,12,15,13,14,11,11,15,14,14,13,
	13,16,14,14,20,19,15,14,14,11,11,15,13,14,12,12,
	15,14,14,11,11,14,13,13,10,10,14,14,13,11,11,15,
	13,14,12,12,15,14,14,12,12,15,14,14,11,11,15,14,
	14,12,12,15,15,14,13,13,15,14,14,11,11,15,14,14,
	11,11,15,14,14,13,13,15,14,14,12,12,15,14,14,13,
	13,15,14,14,11,11,15,14,14,11,11,15,14,14,13,13,
	15,14,14,12,12,15,14,14,12,12,15,14,14,12,12,15,
	14,14,11,11,15,15,15,12,12,15,15,15,13,13,16,14,
	14,12,12,15,15,15,13,13,15,15,15,12,12,15,15,15,
	12,12,14,10,10,13,13,17, 9, 9,12,12,17, 9, 9,13,
	13,17,11,11,12,12,18,14,14,12,12,18,10,10,13,13,
	18,14,13,12,12,18, 9, 9,12,12,18,10,10,12,13,18,
	14,14,12,12,17, 9, 9,12,12,17,13,14,12,12,17, 9,
	 9,12,12,17,10,10,12,12,17,14,14,11,11,18,11,11,
	12,12,18,14,14,12,13,18,10,10,12,12,18,11,11,12,
	12,18,14,14,11,11,18,15,15,12,12,18,14,14,13,13,
	18,14,15,12,12,17,14,14,12,12,17,15,15,12,12,13,
	 7, 7,11,11,14,15,15,11,11,14,15,15,11,11,14,15,
	15,11,11,14,15,15,11,11,14,15,15,11,11,14,15,15,
	12,12,14,15,15,11,11,14,15,15,11,11,15,15,15,12,
	12,14,15,15,11,11,14,15,15,12,12,14,15,15,11,11,
	15,15,15,11,11,15,15,15,12,12,14,15,15,12,12,14,
	15,16,12,12,14,15,15,11,11,14,15,15,11,11,15,15,
	15,12,12,15,15,15,12,12,15,16,16,12,12,15,15,15,
	12,12,15,15,15,12,12,15,15,15,12,12,13,13,13,12,
	12,14,14,14,11,11,14,14,14,12,12,14,14,14,10,10,
	15,15,15,11,11,14,15,15,12,12,14,14,14,11,11,14,
	15,15,11,11,14,14,14,12,12,15,15,14,11,11,14,15,
	15,12,12,14,14,14,11,11,14,15,15,11,11,14,14,14,
	11,11,15,14,14,10,10,14,15,15,12,12,14,14,14,12,
	12,14,15,15,10,10,14,15,15,11,11,15,15,15,10,10,
	15,15,15,12,12,15,14,14,13,13,15,15,15,10,10,15,
	14,14,11,11,15,15,15,10,10,14,10,10,10,10,14, 9,
	 9,12,12,15,10,10,12,12,14,11,11,11,11,15,13,14,
	12,12,15,10,10,13,13,15,13,13,12,12,15, 9, 9,12,
	12,15,10,10,13,13,15,13,14,11,11,15,10,10,12,12,
	15,13,13,12,12,15, 9, 9,11,11,15,10,10,12,12,15,
	13,13,11,11,15,11,11,12,12,15,13,13,13,13,15,10,
	10,11,11,15,11,11,12,12,15,14,14,11,11,15,14,14,
	13,13,15,14,14,20,19,15,14,14,11,11,15,14,14,12,
	12,15,14,14,11,11,14,13,13,11,11,15,13,13,11,11,
	15,14,13,12,12,15,14,14,11,12,15,14,14,11,11,15,
	14,14,12,12,14,14,14,13,13,15,14,14,11,11,15,14,
	14,11,11,15,14,14,13,13,15,14,14,12,12,15,14,14,
	13,13,14,14,14,11,11,15,14,14,11,11,15,14,14,13,
	13,15,14,14,12,12,15,14,14,12,12,15,14,14,12,12,
	15,14,14,11,11,14,14,14,12,12,15,15,15,13,13,16,
	14,14,12,12,15,15,15,13,13,15,14,14,12,12,15,15,
	15,12,12,15,11,11,13,13,18,10,10,12,12,17,11,11,
	12,12,18,12,12,11,11,18,14,14,12,12,18,10,10,13,
	13,18,14,14,12,12,18,10,10,12,12,18,11,11,12,12,
	18,14,14,12,12,18,11,11,12,13,18,14,14,12,12,18,
	10,10,12,12,18,11,11,12,12,18,14,14,11,11,18,11,
	11,12,12,18,14,14,12,12,17,10,10,11,11,17,12,12,
	11,11,17,14,14,11,11,18,15,15,12,12,18,14,14,13,
	13,18,15,15,11,11,18,15,14,12,12,18,15,15,11,11,
	14, 8, 8,11,11,14,15,15,10,10,14,15,15,11,11,14,
	15,15,11,11,15,15,15,12,12,15,15,15,11,11,15,15,
	15,12,12,14,15,15,10,10,15,15,15,11,11,15,15,15,
	12,12,15,15,15,11,11,15,15,15,13,13,14,15,15,10,
	10,15,15,15,11,11,15,15,15,12,12,15,15,15,12,12,
	15,16,16,12,12,15,14,14,11,11,15,15,15,11,11,15,
	15,15,12,12,16,15,15,13,13,15,16,16,13,13,16,15,
	15,12,12,15,15,15,12,12,15,15,15,12,12,14,13,13,
	11,11,14,14,14,11,11,14,14,14,12,12,15,14,14,11,
	11,15,15,14,11,11,15,14,14,12,12,15,14,14,12,12,
	14,15,15,11,11,15,14,14,12,12,15,14,14,11,11,15,
	14,15,12,12,15,14,14,12,12,14,15,15,11,11,15,14,
	14,11,11,15,14,14,11,11,15,15,14,12,12,15,14,14,
	12,12,15,15,15,10,11,15,14,14,11,11,15,15,15,10,
	10,15,15,15,12,12,16,14,14,13,13,15,15,15,11,11,
	15,14,14,11,11,15,15,15,11,11,14,11,11, 9, 9,14,
	10,10,12,12,15,11,11,12,12,15,12,12,12,12,15,14,
	14,13,13,15,11,11,12,12,15,14,14,13,13,14,10,10,
	12,12,15,11,11,13,13,15,14,14,12,12,15,10,10,12,
	12,14,14,14,13,13,14,10,10,11,11,15,11,11,12,12,
	15,14,14,12,12,15,12,12,13,13,15,14,14,14,14,15,
	11,11,11,11,15,12,11,12,12,15,14,14,11,11,15,15,
	15,13,14,15,14,14,20,19,15,14,14,12,12,15,14,14,
	13,13,15,14,14,12,12,14,13,13,10,10,14,13,13,11,
	11,14,13,13,11,11,15,14,14,12,12,15,14,14,12,12,
	15,14,14,12,11,14,14,14,13,13,15,14,14,11,11,15,
	14,14,11,11,15,14,14,14,14,15,14,14,11,12,15,14,
	14,13,13,14,14,14,11,11,15,14,14,11,11,15,14,14,
	14,14,15,14,14,12,12,15,14,14,13,13,15,14,14,11,
	11,14,14,14,12,12,15,14,14,13,13,15,15,15,13,13,
	15,14,14,13,13,15,15,15,13,13,15,14,14,13,13,15,
	15,15,13,13,15,14,14,13,13,18,15,15,12,12,18,15,
	15,12,12,18,16,16,11,11,18,17,17,12,12,18,15,15,
	13,13,18,17,17,12,12,18,15,15,12,12,18,15,16,12,
	12,18,17,17,12,12,18,15,15,13,12,17,16,17,12,12,
	17,15,15,11,12,18,15,15,12,12,18,17,17,11,11,18,
	16,16,12,12,18,17,16,12,12,18,15,15,11,11,18,15,
	15,12,12,18,17,17,11,11,18,17,17,12,12,18,16,16,
	13,13,18,17,17,11,11,17,16,16,11,11,18,17,17,11,
	11,15,15,15,11,11,16,15,15,11,11,16,15,15,11,11,
	16,15,15,12,12,17,15,15,14,14,16,15,15,11,11,17,
	15,15,14,14,16,15,15,11,11,16,15,15,12,12,18,15,
	15,13,13,16,15,15,11,11,17,15,15,14,14,16,15,15,
	11,11,16,15,15,12,12,17,15,15,13,13,16,15,15,12,
	12,17,16,15,14,14,16,15,15,11,11,16,15,15,12,12,
	18,15,15,13,13,17,15,15,14,14,17,16,16,15,15,18,
	14,15,13,13,18,15,15,14,14,18,15,15,13,13,15,13,
	13,12,12,15,14,14,12,12,16,14,14,12,12,16,14,14,
	12,12,17,14,15,12,12,16,14,14,12,12,17,14,14,13,
	13,16,15,15,12,12,16,14,14,12,12,17,14,14,12,12,
	16,14,14,12,12,17,14,14,13,13,15,15,15,11,11,16,
	14,14,12,12,17,14,14,12,12,16,15,15,12,12,17,14,
	14,13,12,16,15,15,11,11,16,14,14,12,12,17,15,15,
	11,11,17,15,15,13,13,17,14,14,13,13,18,15,15,12,
	12,17,14,14,12,12,17,15,15,12,12,14,15,15, 9, 9,
	14,15,15,12,12,15,16,15,13,13,15,15,15,14,14,15,
	15,15,21,19,15,15,15,13,13,15,15,15,19,19,15,15,
	15,12,12,15,16,16,14,14,15,15,15,19,19,15,16,15,
	13,13,15,16,16,19,20,15,15,15,12,13,15,16,16,14,
	14,15,15,15,20,19,15,15,15,14,14,15,16,16,19,19,
	15,15,15,14,13,15,15,15,14,14,15,15,15,19,19,15,
	16,16,20,19,15,17,16,21,20,15,15,15,20,19,15,16,
	16,20,20,15,15,15,19,20,14,13,13,10,10,14,14,14,
	11,11,14,14,14,12,12,15,14,14,13,13,15,15,14,20,
	20,15,14,14,12,12,14,14,14,19,19,15,14,14,11,11,
	15,14,14,12,12,15,14,14,20,19,15,14,14,12,12,14,
	14,14,20,20,14,14,14,11,11,15,14,14,12,12,15,14,
	14,20,21,15,14,14,13,13,15,14,14,20,20,15,14,14,
	12,12,15,14,14,13,13,14,15,15,20,20,15,15,15,20,
	19,15,14,14,20,19,15,15,15,20,20,15,14,14,21,20,
	15,15,15,20,20,
};

static const static_codebook _44p4_p4_1 = {
	5, 3125,
	(long *)_vq_lengthlist__44p4_p4_1,
	1, -533725184, 1611661312, 3, 0,
	(long *)_vq_quantlist__44p4_p4_1,
	0
};

static const long _vq_quantlist__44p4_p5_0[] = {
	2,
	1,
	3,
	0,
	4,
};

static const long _vq_lengthlist__44p4_p5_0[] = {
	 1, 7, 6,15,15, 7, 8, 8,15,15, 8, 8, 8,15,15, 0,
	13,13,16,16, 0,14,14,16,16, 7, 9, 9,16,16,10,11,
	11,17,17,10, 8, 8,15,16, 0,14,14,18,18, 0,14,14,
	16,16, 9, 9, 9,16,16,12,11,11,17,17,10, 9, 9,15,
	15, 0,14,14,19,19, 0,14,14,16,16, 0,15,15,18,17,
	 0, 0, 0,20,20, 0,13,13,16,16, 0,17,17,22,20, 0,
	15,15,17,17, 0,15,15,18,18, 0,22,21,20,21, 0,13,
	13,16,16, 0,18,18, 0,22, 0,15,15,17,17, 6, 7, 7,
	13,13, 9,10,10,15,15,11,10,10,15,15, 0,21,22,18,
	18, 0, 0, 0,18,18,10,10,10,15,15,12,13,13,17,17,
	12,11,11,15,15, 0,22,22,18,18, 0, 0,21,18,18,12,
	11,11,15,15,15,14,14,18,18,13,11,11,15,15, 0, 0,
	21,18,19, 0,21,22,18,19, 0,22, 0,18,19, 0, 0, 0,
	 0, 0, 0,21,21,18,18, 0,22, 0, 0,21, 0, 0, 0,19,
	18, 0, 0, 0,18,19, 0, 0, 0, 0, 0, 0,20,20,18,17,
	 0, 0,22, 0,21, 0, 0, 0,19,19, 6, 6, 6,13,13, 8,
	 6, 6,11,11, 9, 7, 7,13,13, 0,10,10,11,11, 0,12,
	12,14,14, 9, 8, 8,14,14,12,10,10,13,13,10, 7, 7,
	13,13, 0,11,11,15,15, 0,11,11,13,13, 9, 8, 8,14,
	14,13,10,10,13,14,11, 7, 7,13,13, 0,11,11,15,15,
	 0,11,11,13,13, 0,12,12,15,15, 0,21,21,17,17, 0,
	10,10,13,13, 0,14,14,20,20, 0,12,12,13,13, 0,12,
	12,15,15, 0,21,22,17,18, 0,10,10,13,13, 0,16,16,
	20,21, 0,12,12,13,13, 0,11,11,13,13, 0,12,12,16,
	16, 0,12,12,16,16, 0,16,16, 0,21, 0,17,18, 0, 0,
	 0,12,12,15,15, 0,15,15,18,18, 0,12,12,16,16, 0,
	16,16,21,22, 0,17,17,22,21, 0,12,12,16,16, 0,15,
	15,19,19, 0,12,12,16,16, 0,16,16,22,22, 0,17,16,
	22, 0, 0,17,18, 0, 0, 0, 0, 0, 0, 0, 0,15,15,21,
	20, 0,19,20, 0,22, 0,18,18, 0, 0, 0,18,17, 0, 0,
	 0, 0, 0, 0, 0, 0,16,16,22,21, 0,20,20, 0,22, 0,
	20,19, 0, 0, 0,11,11,12,12, 0,10,10,11,11, 0,11,
	11,12,12, 0,12,12,10,10, 0,13,13,12,12, 0,11,11,
	13,13, 0,13,13,12,12, 0,10,10,12,12, 0,13,13,14,
	13, 0,12,12,12,12, 0,12,12,13,13, 0,14,14,13,13,
	 0,10,10,12,12, 0,13,13,14,14, 0,13,12,12,12, 0,
	14,14,14,14, 0,21,21,16,16, 0,12,12,12,12, 0,16,
	16,20,21, 0,13,13,11,11, 0,14,14,14,14, 0,20,20,
	16,15, 0,12,12,12,12, 0,17,17,20,20, 0,13,13,11,
	11, 7, 8, 8,16,16,11,10,10,15,15,12,10,10,17,17,
	 0,14,14,16,15, 0,15,15,17,17,11, 9, 9,16,16,14,
	12,12,17,17,13, 9, 9,16,15, 0,14,14,19,18, 0,14,
	14,16,16,12,10,10,17,18,16,13,13,17,18,14,10,10,
	16,16, 0,14,14,19,19, 0,14,15,17,17, 0,15,15,18,
	19, 0, 0, 0,20,20, 0,13,13,17,17, 0,17,18, 0,22,
	 0,15,15,16,17, 0,15,15,18,18, 0, 0, 0,20,21, 0,
	14,14,17,17, 0,19,18, 0, 0, 0,16,16,17,17, 8, 7,
	 7,14,14,12,11,11,15,15,13,11,11,15,15, 0, 0, 0,
	18,19, 0,21,20,18,18,12,10,11,15,16,14,13,13,18,
	18,14,11,11,15,15, 0,20,20,19,18, 0,20, 0,18,18,
	13,11,11,16,16,17,15,15,19,19,14,12,12,15,15, 0,
	21, 0,18,20, 0,22,22,18,19, 0,22,22,19,19, 0, 0,
	 0, 0, 0, 0,21,22,19,18, 0, 0, 0, 0,21, 0, 0, 0,
	19,19, 0, 0,22,20,20, 0, 0, 0, 0, 0, 0,22, 0,18,
	18, 0, 0, 0, 0,22, 0, 0, 0,19,20,11,10,10,14,14,
	14,11,11,13,13,14,11,11,15,15, 0,14,13,12,12, 0,
	15,15,16,16,13,11,11,15,15,16,13,13,15,15,15,10,
	10,14,15, 0,14,14,16,16, 0,14,14,15,15,13,11,11,
	15,15,18,14,14,15,15,15,10,10,15,14, 0,14,14,16,
	16, 0,14,14,15,15, 0,15,15,17,16, 0,21,22,18,18,
	 0,13,13,14,14, 0,18,17,20,21, 0,15,15,14,14, 0,
	15,16,16,17, 0, 0, 0,19,18, 0,13,13,15,14, 0,19,
	19, 0, 0, 0,15,15,14,14, 0,12,12,14,13, 0,13,13,
	16,16, 0,12,12,16,16, 0,16,16,22, 0, 0,17,18, 0,
	22, 0,13,13,16,16, 0,15,15,18,18, 0,12,12,16,16,
	 0,16,16,22,22, 0,17,17, 0, 0, 0,13,13,17,17, 0,
	16,16,19,20, 0,12,12,17,17, 0,17,17,22, 0, 0,17,
	17,22,21, 0,18,18, 0, 0, 0, 0, 0, 0, 0, 0,16,16,
	21,21, 0,19,19, 0, 0, 0,18,18, 0,22, 0,18,18, 0,
	22, 0, 0, 0, 0, 0, 0,16,16,22, 0, 0,20,20, 0, 0,
	 0,19,18, 0, 0, 0,12,12,15,15, 0,12,12,15,14, 0,
	13,13,15,15, 0,14,14,14,14, 0,15,15,16,16, 0,13,
	13,15,16, 0,15,15,16,16, 0,12,12,15,15, 0,14,14,
	16,16, 0,14,14,15,15, 0,13,13,15,16, 0,15,15,16,
	16, 0,12,12,15,15, 0,15,15,17,17, 0,14,14,15,15,
	 0,15,15,17,17, 0,21,21,19,19, 0,13,13,14,14, 0,
	17,17,22, 0, 0,14,14,15,15, 0,15,15,17,17, 0,22,
	 0,18,20, 0,13,13,15,15, 0,18,18, 0,22, 0,15,15,
	14,15, 8, 8, 8,17,16,12,10,10,16,16,13,10,10,17,
	16, 0,15,15,17,17, 0,15,15,17,17,12,11,11,18,18,
	15,12,12,18,18,15,10,10,16,17, 0,14,14,18,18, 0,
	14,14,17,17,13,10,10,16,16,17,14,14,17,17,15,10,
	10,16,15, 0,15,15,19,20, 0,14,14,15,16, 0,16,16,
	19,19, 0, 0, 0,21,22, 0,13,13,17,17, 0,18,17, 0,
	21, 0,15,15,17,17, 0,15,15,18,19, 0, 0,22, 0,21,
	 0,13,13,16,17, 0,19,19, 0,22, 0,16,15,16,16, 9,
	 8, 8,14,14,12,11,11,15,15,13,11,11,15,15, 0,21,
	20,19,18, 0, 0, 0,19,18,12,11,11,16,15,15,13,13,
	17,18,14,11,11,15,15, 0,22,22,19,18, 0,22,21,18,
	18,14,11,11,15,15,17,14,14,18,18,15,12,12,15,15,
	 0,22,22,20,19, 0, 0,21,18,18, 0, 0,22,20,20, 0,
	 0, 0, 0, 0, 0,20,21,18,18, 0, 0, 0,21,21, 0, 0,
	 0,20,19, 0,22,21,19,19, 0, 0, 0, 0, 0, 0, 0,22,
	17,18, 0, 0,22, 0,22, 0,22, 0,19,19, 0,11,11,15,
	15, 0,11,11,14,14, 0,12,12,15,15, 0,15,15,14,14,
	 0,16,16,16,16, 0,12,12,16,16, 0,14,14,16,16, 0,
	11,11,15,15, 0,15,15,17,17, 0,15,15,15,15, 0,12,
	12,16,16, 0,14,14,15,15, 0,11,11,15,15, 0,15,15,
	17,17, 0,15,15,14,15, 0,16,16,17,17, 0, 0, 0,19,
	19, 0,14,14,15,15, 0,18,18,21, 0, 0,15,15,14,15,
	 0,16,16,17,17, 0,21, 0,19,19, 0,14,14,15,15, 0,
	20,20,22, 0, 0,16,15,14,14, 0,12,12,13,13, 0,12,
	12,16,16, 0,12,12,16,16, 0,16,16,22,21, 0,18,17,
	21, 0, 0,13,13,16,16, 0,15,15,18,19, 0,12,12,16,
	16, 0,16,17,22, 0, 0,17,17, 0,22, 0,13,13,17,16,
	 0,15,15,19,19, 0,12,12,16,16, 0,16,16,21,20, 0,
	17,16,22, 0, 0,18,18,22,21, 0, 0, 0, 0, 0, 0,15,
	16,21,21, 0,19,19, 0, 0, 0,18,17, 0, 0, 0,18,18,
	21, 0, 0, 0, 0, 0, 0, 0,16,16,22,22, 0,20,21, 0,
	 0, 0,18,19, 0,22, 0,13,13,16,16, 0,12,12,15,15,
	 0,13,13,16,16, 0,14,14,15,15, 0,15,15,17,17, 0,
	13,13,17,16, 0,15,15,17,17, 0,12,12,16,16, 0,15,
	15,17,17, 0,14,14,16,16, 0,13,13,16,17, 0,15,15,
	17,17, 0,12,12,16,16, 0,14,14,17,17, 0,14,14,16,
	16, 0,16,16,17,17, 0,21, 0,21,19, 0,13,13,16,16,
	 0,17,17, 0, 0, 0,15,15,16,16, 0,16,15,18,18, 0,
	22, 0,20,20, 0,13,13,15,15, 0,18,18, 0, 0, 0,15,
	15,15,15, 0,12,12,17,17, 0,14,14,17,17, 0,14,14,
	17,17, 0,17,17,18,17, 0,17,17,19,18, 0,13,13,17,
	17, 0,16,16,18,18, 0,13,13,16,16, 0,17,17,19,19,
	 0,16,16,17,17, 0,13,13,18,18, 0,17,17,18,18, 0,
	13,13,17,17, 0,17,17,19,19, 0,16,17,17,17, 0,17,
	17,19,19, 0,21, 0,21,19, 0,14,14,16,16, 0,20,19,
	 0,21, 0,16,16,16,16, 0,17,18,19,19, 0, 0, 0, 0,
	21, 0,15,15,16,17, 0,21,20, 0, 0, 0,17,18,16,17,
	 0, 9, 9,14,14, 0,14,14,15,16, 0,14,14,15,15, 0,
	 0, 0,18,18, 0,21, 0,18,19, 0,12,12,15,15, 0,16,
	16,17,17, 0,14,14,14,14, 0,22, 0,19,18, 0,22, 0,
	17,18, 0,14,14,16,15, 0,18,18,19,18, 0,14,15,15,
	15, 0, 0,21,20,20, 0, 0, 0,18,18, 0,21,21,19,19,
	 0, 0, 0, 0, 0, 0,21,21,18,18, 0,22, 0,20,20, 0,
	22, 0,19,19, 0,22, 0,19,20, 0, 0, 0, 0, 0, 0, 0,
	21,17,18, 0, 0, 0,22,22, 0, 0, 0,19,18, 0,18,20,
	16,16, 0,21,20,17,17, 0, 0,21,18,18, 0,22,21,18,
	18, 0, 0,22,19,19, 0,20,20,17,17, 0, 0, 0,18,18,
	 0,19,20,17,17, 0,22, 0,19,21, 0,22,21,18,18, 0,
	20,19,17,18, 0, 0, 0,19,19, 0,20,20,17,17, 0,22,
	22,21,21, 0,20, 0,18,18, 0,22,22,18,18, 0, 0, 0,
	20,22, 0,20,20,16,16, 0, 0, 0,21, 0, 0,21,20,16,
	17, 0,22, 0,19,20, 0, 0, 0,21,20, 0,19,21,17,17,
	 0, 0, 0, 0, 0, 0,21,21,17,17, 0,12,12,13,13, 0,
	14,14,16,16, 0,14,14,16,16, 0,18,18, 0, 0, 0,19,
	18,22, 0, 0,13,13,16,16, 0,16,16,18,18, 0,13,13,
	16,16, 0,17,18,21, 0, 0,18,18,21, 0, 0,13,13,16,
	16, 0,17,17,19,20, 0,13,13,16,17, 0,18,18,21, 0,
	 0,18,18,21, 0, 0,18,19, 0,21, 0, 0, 0, 0, 0, 0,
	16,16,21,20, 0,20,20, 0, 0, 0,18,19, 0, 0, 0,18,
	18, 0, 0, 0, 0, 0, 0, 0, 0,16,16, 0,21, 0,22,22,
	 0, 0, 0,19,19, 0, 0, 0,16,16,19,20, 0,17,16,22,
	21, 0,17,17,21,20, 0,19,18, 0,22, 0,19,19,22,22,
	 0,16,15,22,22, 0,19,19, 0,21, 0,15,15,20,20, 0,
	18,19, 0,21, 0,18,18,22,22, 0,16,16,21,20, 0,20,
	19,21,22, 0,16,15,20,20, 0,19,19, 0,22, 0,18,18,
	21, 0, 0,19,18,21,22, 0, 0, 0, 0, 0, 0,16,16,19,
	21, 0,20,22, 0,22, 0,18,18,20,21, 0,19,18, 0,22,
	 0, 0, 0,22, 0, 0,16,16,20,20, 0,21,21, 0, 0, 0,
	18,18,21, 0, 0,12,12,17,17, 0,15,14,17,17, 0,14,
	14,18,18, 0,17,17,17,18, 0,18,18,18,18, 0,13,13,
	18,18, 0,16,17,19,18, 0,13,13,16,17, 0,17,17,18,
	19, 0,17,17,17,17, 0,13,13,17,17, 0,17,18,18,18,
	 0,13,13,16,16, 0,18,18,19,20, 0,16,17,17,16, 0,
	17,18,19,18, 0, 0, 0,22,21, 0,15,15,16,16, 0,20,
	20,21,22, 0,17,17,16,16, 0,16,17,18,18, 0, 0, 0,
	21,21, 0,15,15,16,16, 0,21,20, 0, 0, 0,17,17,16,
	16, 0,10,10,14,14, 0,14,14,15,15, 0,14,14,15,15,
	 0,22, 0,18,18, 0, 0, 0,19,19, 0,13,13,15,16, 0,
	17,16,18,18, 0,14,14,15,15, 0,21,21,19,18, 0,22,
	21,18,17, 0,14,14,15,15, 0,18,18,19,18, 0,15,15,
	14,14, 0,22,21,19,19, 0,22,21,17,18, 0, 0, 0,19,
	19, 0, 0, 0, 0, 0, 0,20,22,17,17, 0, 0,22,22,20,
	 0, 0, 0,19,18, 0,21,22,19,18, 0, 0, 0, 0, 0, 0,
	22,22,17,18, 0, 0, 0,21,22, 0, 0, 0,19,18, 0,20,
	20,17,17, 0,21,21,17,18, 0,21,22,18,18, 0,21, 0,
	18,18, 0,22, 0,19,19, 0,19,21,18,18, 0, 0,22,18,
	18, 0,22,21,17,17, 0,22, 0,20,20, 0, 0, 0,18,18,
	 0,22,21,18,18, 0,21, 0,19,19, 0,20,21,17,17, 0,
	 0,22,22,20, 0,21,22,17,17, 0, 0,21,19,18, 0, 0,
	 0,21,21, 0,21,20,16,17, 0, 0, 0, 0, 0, 0,21, 0,
	17,17, 0,21, 0,19,20, 0, 0, 0,20,22, 0,20,20,17,
	17, 0, 0, 0, 0, 0, 0,21,21,17,17, 0,12,12,13,13,
	 0,14,14,16,16, 0,14,14,16,16, 0,18,18,21, 0, 0,
	19,19,22, 0, 0,13,13,16,16, 0,16,16,18,18, 0,13,
	13,16,16, 0,18,18,21,22, 0,18,18, 0,22, 0,13,13,
	16,16, 0,17,17,20,18, 0,13,13,16,16, 0,19,18, 0,
	22, 0,18,18,22,21, 0,18,19, 0, 0, 0, 0, 0, 0, 0,
	 0,16,16,21,21, 0,21,21, 0, 0, 0,18,19, 0, 0, 0,
	19,19,21, 0, 0, 0, 0, 0, 0, 0,16,16, 0,21, 0,20,
	20, 0, 0, 0,20,20, 0, 0, 0,16,16,21,20, 0,18,17,
	21,22, 0,17,18, 0,21, 0,18,19,22,22, 0,19,19, 0,
	22, 0,16,17,21,22, 0,20,19, 0, 0, 0,16,16,20,21,
	 0,19,19, 0, 0, 0,19,19, 0,22, 0,17,17,21,21, 0,
	19,20, 0, 0, 0,16,16, 0,20, 0,19,20, 0,21, 0,18,
	18, 0,22, 0,19,20,22,22, 0, 0, 0, 0,22, 0,17,17,
	 0,21, 0,21,21, 0, 0, 0,18,19,23,21, 0,20,19, 0,
	 0, 0, 0, 0, 0, 0, 0,17,17, 0,20, 0, 0, 0, 0, 0,
	 0,19,19,23,22,
};

static const static_codebook _44p4_p5_0 = {
	5, 3125,
	(long *)_vq_lengthlist__44p4_p5_0,
	1, -528744448, 1616642048, 3, 0,
	(long *)_vq_quantlist__44p4_p5_0,
	0
};

static const long _vq_quantlist__44p4_p5_1[] = {
	3,
	2,
	4,
	1,
	5,
	0,
	6,
};

static const long _vq_lengthlist__44p4_p5_1[] = {
	 2, 3, 3, 3, 3, 3, 3,
};

static const static_codebook _44p4_p5_1 = {
	1, 7,
	(long *)_vq_lengthlist__44p4_p5_1,
	1, -533200896, 1611661312, 3, 0,
	(long *)_vq_quantlist__44p4_p5_1,
	0
};

static const long _vq_quantlist__44p4_p6_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p4_p6_0[] = {
	 1, 7, 7, 7, 8, 8, 7, 8, 8, 7, 9, 9,11,11,11, 9,
	 8, 8, 8, 9, 9,12,11,12, 9, 8, 8, 6, 7, 7,10,11,
	11,10,10,10,11,11,11,14,14,14,12,11,12,11,11,11,
	15,15,14,13,12,12, 5, 6, 6, 8, 5, 5, 8, 7, 7, 8,
	 7, 7,12,10,10,10, 7, 6, 9, 8, 8,12,10,10,10, 6,
	 6, 7, 8, 8,12,10,10,12,10,10,11,10,10,16,14,14,
	13,10,10,12,10,10,15,14,14,14,10,10, 7, 7, 7,13,
	11,11,13,11,11,12,11,11,16,14,14,14,12,12,12,11,
	11,18,15,15,14,12,12,10, 9,10,14,11,11,13,11,11,
	12,11,11,17,14,14,14,11,11,13,11,11,16,15,15,14,
	11,11, 7, 8, 8,13,11,11,12,10,10,12,10,10,16,14,
	13,13,10,10,12,10,10,17,14,14,14,10,10, 8, 7, 7,
	12,11,11,13,11,11,12,11,11,16,15,14,14,12,12,12,
	11,11,16,15,15,14,12,12,11,10,10,14,11,11,13,11,
	11,13,11,11,17,14,14,14,11,11,13,11,11,18,14,15,
	15,11,10,
};

static const static_codebook _44p4_p6_0 = {
	5, 243,
	(long *)_vq_lengthlist__44p4_p6_0,
	1, -527106048, 1620377600, 2, 0,
	(long *)_vq_quantlist__44p4_p6_0,
	0
};

static const long _vq_quantlist__44p4_p6_1[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p4_p6_1[] = {
	 2, 6, 6, 6, 7, 7, 7, 7, 7, 7, 8, 8, 9, 9, 9, 9,
	 7, 7, 8, 8, 8, 9, 9, 9, 9, 8, 8, 6, 7, 7, 8, 8,
	 8, 8, 8, 8, 9, 8, 8, 9, 8, 9, 9, 8, 8,10, 8, 8,
	10, 9, 9,10, 8, 8, 6, 6, 6, 8, 6, 6, 8, 7, 7, 8,
	 7, 7,10, 8, 8, 9, 7, 7, 9, 7, 7,10, 8, 8, 9, 7,
	 7, 7, 7, 7,10, 8, 8,11, 9, 9,10, 9, 9,11, 9, 9,
	11, 8, 8,11, 9, 9,12, 9, 9,12, 8, 8, 7, 7, 7,10,
	 9, 9,10, 9, 9,10, 9, 9,11,10,10,10, 9, 9,11, 9,
	10,11,10,11,10, 9, 9, 9, 8, 8,10, 9, 9,10, 9, 9,
	11, 9, 9,11,10,10,11, 9, 9,11, 9, 9,11,10,10,11,
	 9, 9, 8, 8, 8,11, 9, 9,11, 9, 9,11, 9, 9,12, 9,
	 9,12, 8, 8,11, 9, 9,12, 9, 9,12, 8, 8, 8, 7, 7,
	10, 9, 9,10, 9, 9,10, 9, 9,11,11,11,11, 9, 9,11,
	10,10,11,11,11,11, 9, 9,10, 9, 9,11, 9, 9,11, 9,
	10,11,10,10,11,10,10,11, 9, 9,11,10,10,11,10,10,
	11, 9, 9,
};

static const static_codebook _44p4_p6_1 = {
	5, 243,
	(long *)_vq_lengthlist__44p4_p6_1,
	1, -530841600, 1616642048, 2, 0,
	(long *)_vq_quantlist__44p4_p6_1,
	0
};

static const long _vq_quantlist__44p4_p7_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p4_p7_0[] = {
	 1, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9,
};

static const static_codebook _44p4_p7_0 = {
	5, 243,
	(long *)_vq_lengthlist__44p4_p7_0,
	1, -513979392, 1633504256, 2, 0,
	(long *)_vq_quantlist__44p4_p7_0,
	0
};

static const long _vq_quantlist__44p4_p7_1[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p4_p7_1[] = {
	 1, 9, 9, 7, 9, 9, 8, 8, 9, 9, 9, 9, 9, 9, 9, 8,
	 9, 9, 7, 9, 9, 9, 9, 9, 9, 9, 9, 7, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 6, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 5, 9, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 8, 9, 8, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 5,10, 9,10,10,10,10,10,10,10,10,10,10,10,
	10,10,10,10,10,10,10,10,10,10,10,10,10, 8,10,10,
	10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
	10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
	10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
	10,10,10,
};

static const static_codebook _44p4_p7_1 = {
	5, 243,
	(long *)_vq_lengthlist__44p4_p7_1,
	1, -516716544, 1630767104, 2, 0,
	(long *)_vq_quantlist__44p4_p7_1,
	0
};

static const long _vq_quantlist__44p4_p7_2[] = {
	12,
	11,
	13,
	10,
	14,
	9,
	15,
	8,
	16,
	7,
	17,
	6,
	18,
	5,
	19,
	4,
	20,
	3,
	21,
	2,
	22,
	1,
	23,
	0,
	24,
};

static const long _vq_lengthlist__44p4_p7_2[] = {
	 1, 3, 2, 5, 4, 7, 7, 8, 8, 9, 9,10,10,11,11,12,
	12,13,13,14,14,15,15,15,15,
};

static const static_codebook _44p4_p7_2 = {
	1, 25,
	(long *)_vq_lengthlist__44p4_p7_2,
	1, -518864896, 1620639744, 5, 0,
	(long *)_vq_quantlist__44p4_p7_2,
	0
};

static const long _vq_quantlist__44p4_p7_3[] = {
	12,
	11,
	13,
	10,
	14,
	9,
	15,
	8,
	16,
	7,
	17,
	6,
	18,
	5,
	19,
	4,
	20,
	3,
	21,
	2,
	22,
	1,
	23,
	0,
	24,
};

static const long _vq_lengthlist__44p4_p7_3[] = {
	 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5,
	 5, 5, 5, 5, 5, 5, 5, 5, 5,
};

static const static_codebook _44p4_p7_3 = {
	1, 25,
	(long *)_vq_lengthlist__44p4_p7_3,
	1, -529006592, 1611661312, 5, 0,
	(long *)_vq_quantlist__44p4_p7_3,
	0
};

static const long _huff_lengthlist__44p4_short[] = {
	 3, 5,16, 9, 9,13,18,21, 4, 2,21, 6, 6,10,15,21,
	16,19, 6, 5, 7,10,13,16, 8, 6, 5, 4, 4, 8,13,16,
	 8, 5, 6, 4, 4, 7,12,15,13,10, 9, 7, 7, 9,13,16,
	18,15,13,12, 9, 7,10,14,21,18,13,13, 7, 5, 8,12,
};

static const static_codebook _huff_book__44p4_short = {
	2, 64,
	(long *)_huff_lengthlist__44p4_short,
	0, 0, 0, 0, 0,
	NULL,
	0
};

static const long _vq_quantlist__44p5_l0_0[] = {
	6,
	5,
	7,
	4,
	8,
	3,
	9,
	2,
	10,
	1,
	11,
	0,
	12,
};

static const long _vq_lengthlist__44p5_l0_0[] = {
	 1, 4, 4, 8, 8,10,10,10,10, 9, 8,11,11, 4, 6, 5,
	 8, 6,10,10,10,10,10, 9,10, 9, 4, 5, 6, 6, 9,10,
	10,10,10, 9,10, 9,10, 8, 9, 8, 9, 8, 9, 9,10, 9,
	11,10,12,10, 8, 8, 9, 8, 9, 9, 9, 9,10,10,11,10,
	12, 9,10,10,11,10,11,10,12,11,12,11,13,11, 9,10,
	10,10,11,10,11,11,12,11,12,11,12,11,12,12,12,12,
	13,12,13,12,13,12,13,13,11,12,12,12,12,12,12,12,
	13,13,13,13,13,12,12,12,13,13,13,13,13,13,13,13,
	13,13,12,13,12,13,13,13,13,13,13,13,13,13,13,12,
	13,13,13,14,14,13,13,13,13,13,13,13,12,13,12,13,
	13,13,13,13,13,13,13,13,13,
};

static const static_codebook _44p5_l0_0 = {
	2, 169,
	(long *)_vq_lengthlist__44p5_l0_0,
	1, -526516224, 1616117760, 4, 0,
	(long *)_vq_quantlist__44p5_l0_0,
	0
};

static const long _vq_quantlist__44p5_l0_1[] = {
	2,
	1,
	3,
	0,
	4,
};

static const long _vq_lengthlist__44p5_l0_1[] = {
	 4, 4, 4, 5, 5, 4, 5, 5, 5, 5, 4, 5, 4, 4, 5, 5,
	 5, 5, 5, 5, 5, 5, 5, 5, 5,
};

static const static_codebook _44p5_l0_1 = {
	2, 25,
	(long *)_vq_lengthlist__44p5_l0_1,
	1, -533725184, 1611661312, 3, 0,
	(long *)_vq_quantlist__44p5_l0_1,
	0
};

static const long _vq_quantlist__44p5_l1_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p5_l1_0[] = {
	 1, 4, 4, 4, 4, 4, 4, 4, 4,
};

static const static_codebook _44p5_l1_0 = {
	2, 9,
	(long *)_vq_lengthlist__44p5_l1_0,
	1, -516716544, 1630767104, 2, 0,
	(long *)_vq_quantlist__44p5_l1_0,
	0
};

static const long _huff_lengthlist__44p5_lfe[] = {
	 1, 3, 2, 3,
};

static const static_codebook _huff_book__44p5_lfe = {
	2, 4,
	(long *)_huff_lengthlist__44p5_lfe,
	0, 0, 0, 0, 0,
	NULL,
	0
};

static const long _huff_lengthlist__44p5_long[] = {
	 3, 7,12,14,14,16,18,19, 6, 2, 4, 6, 8, 9,12,14,
	12, 3, 3, 5, 7, 8,11,13,13, 6, 4, 5, 7, 8,10,11,
	14, 8, 7, 7, 7, 7, 9,10,15, 9, 8, 7, 7, 6, 8, 9,
	17,11,11,10, 9, 8, 9, 9,19,14,13,11,10, 9, 9, 9,
};

static const static_codebook _huff_book__44p5_long = {
	2, 64,
	(long *)_huff_lengthlist__44p5_long,
	0, 0, 0, 0, 0,
	NULL,
	0
};

static const long _vq_quantlist__44p5_p1_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p5_p1_0[] = {
	 2, 5, 5, 5, 7, 7, 5, 7, 7, 5, 7, 7, 7, 8, 9, 7,
	 9, 9, 5, 7, 7, 7, 9, 9, 7, 9, 8, 5, 7, 8, 8, 9,
	10, 8, 9,10, 8, 9,10, 9,10,12,10,11,11, 8,10,10,
	10,11,11, 9,11,11, 5, 8, 7, 8, 9, 9, 8,10, 9, 8,
	10,10, 9,11,11,10,11,11, 8,10, 9,10,11,11, 9,12,
	10, 5, 8, 8, 7, 9,10, 8,10, 9, 7, 9, 9, 9,10,11,
	 9,11,11, 8,10, 9,10,11,11,10,11,11, 7, 9, 9, 9,
	10,11, 9,11,11, 9, 9,11,10,10,13,11,11,12, 9,11,
	11,11,12,13,11,13,12, 7, 9, 9, 9,11,11, 9,11,10,
	 9,11,10,10,11,12,11,13,12, 9,11,11,11,12,13,11,
	13,11, 5, 8, 8, 8, 9,10, 7,10, 9, 8, 9,10,10,11,
	11,10,11,11, 7, 9, 9, 9,11,11, 9,11,10, 7, 9, 9,
	 9,10,11, 9,11,11, 9,11,11,11,11,13,11,13,12, 9,
	10,11,11,12,13,10,12,11, 7, 9, 9, 9,11,11, 9,11,
	10, 9,11,11,11,12,13,11,13,12, 9,11, 9,11,12,11,
	10,13,10,
};

static const static_codebook _44p5_p1_0 = {
	5, 243,
	(long *)_vq_lengthlist__44p5_p1_0,
	1, -535822336, 1611661312, 2, 0,
	(long *)_vq_quantlist__44p5_p1_0,
	0
};

static const long _vq_quantlist__44p5_p2_0[] = {
	2,
	1,
	3,
	0,
	4,
};

static const long _vq_lengthlist__44p5_p2_0[] = {
	 4, 6, 6, 9, 9, 6, 7, 8,10,10, 6, 8, 7,10,10, 8,
	10,10,12,13, 8,10,10,13,12, 6, 7, 8,10,10, 7, 8,
	 9,10,11, 8, 9, 9,11,11,10,10,11,12,14,10,11,11,
	14,13, 6, 8, 7,10,10, 8, 9, 9,11,11, 7, 9, 8,11,
	10,10,11,11,13,14,10,11,10,14,12, 9,10,10,12,12,
	10,10,11,12,13,10,11,11,13,13,12,12,13,12,15,13,
	14,13,15,14, 9,10,10,12,12,10,11,11,13,13,10,11,
	10,13,12,13,13,14,14,15,12,13,12,15,12, 6, 7, 8,
	10,11, 8, 9,10,11,12, 8, 9, 9,11,12,10,11,12,13,
	14,10,11,11,14,13, 8, 9,10,11,12, 9,10,11,12,13,
	 9,10,11,12,13,11,12,13,13,15,12,12,13,15,14, 8,
	 9, 9,12,12, 9,10,11,12,13, 9,10,10,13,12,12,12,
	13,14,15,11,12,12,14,14,11,11,12,13,14,11,12,13,
	13,15,12,13,13,14,15,14,13,15,14,16,14,15,15,16,
	16,11,12,11,14,13,12,13,13,15,14,11,13,12,14,13,
	14,15,15,15,16,13,14,14,16,14, 6, 8, 7,11,10, 8,
	 9, 9,11,12, 8,10, 9,12,11,10,11,11,13,14,10,12,
	11,14,13, 8, 9, 9,12,12, 9,10,10,12,13, 9,11,10,
	13,12,11,12,12,13,14,12,13,12,15,14, 8,10, 9,12,
	11, 9,11,10,13,12, 9,11,10,13,12,12,13,12,14,15,
	11,13,12,15,13,11,11,12,13,14,11,12,13,13,15,12,
	13,13,14,15,13,14,14,14,16,14,15,15,16,16,11,12,
	11,14,13,12,13,13,15,14,11,13,12,15,13,14,15,15,
	16,16,13,15,13,16,14, 9,10,11,12,14,11,11,12,13,
	15,11,12,12,13,14,13,14,15,15,17,13,14,14,15,16,
	11,11,12,13,15,12,12,13,14,16,12,13,13,14,15,14,
	14,16,15,17,15,15,15,16,17,11,12,12,14,14,12,13,
	13,15,16,12,13,13,15,15,15,15,15,16,17,14,15,15,
	16,16,14,14,15,15,17,14,15,15,15,17,15,15,16,16,
	17,16,16,17,16,18,17,17,17,18,18,14,15,14,16,16,
	15,15,16,17,17,14,15,15,17,16,17,17,17,18,18,16,
	16,16,17,17, 9,11,10,14,12,11,12,12,14,13,11,12,
	11,15,13,13,14,14,16,15,13,15,14,17,15,11,12,12,
	15,14,12,13,13,15,15,12,13,13,15,15,14,15,15,16,
	16,15,15,15,17,16,11,12,11,15,13,12,13,13,15,14,
	12,13,12,16,14,15,15,15,17,16,14,15,14,17,15,14,
	14,15,16,16,14,15,15,16,16,15,16,15,17,17,16,16,
	16,17,17,17,17,17,18,17,14,15,14,16,15,15,15,15,
	17,16,15,15,15,17,15,17,17,17,18,18,16,17,16,18,
	16, 6, 8, 8,11,11, 8, 9, 9,11,12, 8, 9, 9,12,11,
	10,11,11,13,14,10,12,11,14,13, 7, 9, 9,11,12, 9,
	10,10,12,13, 9,10,10,13,13,11,11,12,13,15,11,12,
	12,15,14, 8, 9, 9,12,11, 9,11,10,13,13, 9,11,10,
	13,12,12,13,12,14,15,11,13,12,15,13,10,11,12,13,
	14,11,12,12,13,15,12,12,13,14,15,13,13,14,14,16,
	14,15,15,16,16,11,12,11,14,13,12,13,13,15,14,11,
	13,12,15,13,14,15,15,15,16,13,14,14,16,14, 7, 9,
	 9,11,12, 9,10,11,12,13, 9,10,10,13,12,11,12,12,
	14,15,11,12,12,15,14, 9, 9,11,11,13,10,10,12,12,
	14,10,11,12,13,14,12,12,13,14,16,12,13,13,15,15,
	 9,11,10,13,13,10,12,12,13,14,10,12,11,14,13,12,
	13,13,15,16,12,13,13,15,14,11,11,13,13,15,12,12,
	14,13,16,13,13,13,14,15,14,14,15,14,17,15,15,15,
	16,16,12,13,12,15,14,13,14,14,15,15,12,14,13,16,
	14,15,15,16,16,17,14,15,14,17,15, 7, 9, 9,12,11,
	 9,10,10,12,13, 9,11,10,13,12,11,12,12,14,14,11,
	13,12,15,14, 9,10,10,13,12,10,10,11,12,13,10,12,
	11,14,13,12,12,13,13,15,12,14,13,16,15, 9,10,10,
	13,12,11,11,12,13,13,10,12,10,14,12,13,13,13,15,
	15,12,13,12,15,13,11,12,12,14,14,12,12,13,14,15,
	13,14,13,15,15,14,13,15,13,16,15,16,15,17,16,12,
	13,12,14,14,13,14,14,15,15,12,13,12,15,14,15,15,
	16,16,17,14,15,13,16,13,10,11,12,13,14,11,12,13,
	14,15,12,13,13,15,15,14,14,15,15,17,14,15,15,16,
	16,12,12,13,12,15,12,12,14,13,16,13,13,14,14,16,
	14,14,16,15,17,15,15,16,16,17,12,13,13,15,15,13,
	14,14,16,16,13,14,13,16,15,15,16,16,17,17,14,15,
	15,17,16,14,14,15,14,17,15,15,16,15,17,15,15,16,
	15,17,16,16,17,16,18,17,17,17,17,18,14,15,15,17,
	16,15,16,16,17,17,15,16,15,17,16,17,17,17,18,18,
	16,17,16,18,17,10,12,11,14,14,12,13,13,15,15,12,
	13,12,15,14,14,15,15,16,16,14,15,15,17,16,11,13,
	12,15,14,12,13,13,15,15,13,14,13,16,14,15,15,15,
	16,16,15,16,15,17,16,12,13,13,15,15,13,14,14,16,
	16,12,14,13,16,15,15,16,16,17,17,15,16,15,17,16,
	14,15,15,16,16,14,15,15,16,16,15,16,16,17,16,16,
	16,16,16,17,17,18,17,18,17,14,15,15,17,16,15,16,
	16,17,17,15,16,15,17,16,17,17,18,18,18,16,17,16,
	18,16, 6, 8, 8,11,11, 8, 9, 9,11,12, 8, 9, 9,12,
	11,10,11,12,13,14,10,11,11,14,13, 8, 9, 9,11,12,
	 9,10,11,12,13, 9,10,11,13,13,11,12,13,13,15,12,
	12,12,15,14, 7, 9, 9,12,11, 9,10,10,13,13, 9,10,
	10,13,12,11,12,12,14,15,11,12,11,15,13,11,11,12,
	13,14,11,12,13,13,15,12,13,13,14,15,13,14,14,14,
	16,14,15,15,16,16,10,12,11,14,13,12,13,12,14,14,
	11,12,12,15,13,14,15,15,16,16,13,14,13,16,14, 7,
	 9, 9,11,12, 9,10,11,12,13, 9,10,10,13,12,11,12,
	13,14,15,11,12,12,14,14, 9,10,10,12,13,10,10,12,
	12,14,11,12,11,13,13,12,12,14,13,15,13,13,13,15,
	15, 9,10,10,12,13,10,11,12,13,14,10,11,10,13,12,
	13,13,14,15,16,12,13,12,15,13,12,13,13,14,14,12,
	12,13,14,15,13,14,14,15,15,14,13,15,13,16,15,16,
	15,17,16,11,12,12,14,14,13,13,14,15,15,12,13,12,
	15,14,15,15,16,16,17,14,14,13,16,13, 7, 9, 9,12,
	11, 9,10,10,12,13, 9,11,10,13,12,11,12,12,14,15,
	11,12,12,15,14, 9,10,11,13,13,10,11,12,13,14,10,
	12,12,14,13,12,13,13,14,16,12,13,13,16,15, 9,11,
	 9,13,11,10,12,11,13,13,10,12,10,14,12,12,13,13,
	15,15,12,13,12,16,14,12,12,13,14,15,12,13,14,14,
	15,13,14,14,15,15,14,14,15,15,17,15,16,15,17,16,
	11,13,11,15,13,13,14,13,15,14,12,14,12,16,13,15,
	15,15,16,16,14,15,14,17,14,10,11,12,14,14,12,12,
	13,14,15,12,13,13,15,15,14,15,15,16,17,14,15,15,
	16,16,12,12,13,15,15,13,13,14,15,16,13,14,14,16,
	16,15,15,16,16,17,15,16,16,17,17,11,12,13,14,15,
	13,13,14,15,16,12,13,13,15,15,15,15,16,16,17,15,
	15,15,16,16,14,15,15,16,17,15,15,16,16,17,15,16,
	16,17,17,16,16,17,16,18,17,17,17,18,18,14,15,15,
	16,16,15,16,16,16,17,15,15,15,16,16,17,17,17,18,
	18,16,16,16,17,16,10,12,11,14,13,12,13,13,15,15,
	11,13,12,15,14,14,15,15,16,16,14,15,14,17,15,12,
	13,13,15,15,13,13,14,16,16,13,14,14,16,16,15,15,
	15,16,17,15,16,16,17,17,12,13,12,15,12,13,14,13,
	16,14,12,14,12,16,13,15,16,15,17,16,14,16,14,17,
	15,14,15,15,16,17,15,15,16,17,17,15,16,16,17,17,
	16,16,17,17,18,17,18,17,18,18,14,15,14,17,14,15,
	16,15,17,15,15,16,15,17,15,17,17,17,18,17,16,17,
	16,18,16, 9,11,11,14,14,11,12,12,14,14,11,12,12,
	15,14,13,14,14,16,16,13,15,14,16,16,10,11,12,14,
	14,11,12,13,15,15,12,13,13,15,15,13,14,15,16,17,
	14,15,15,17,16,11,12,12,15,14,12,13,13,15,15,12,
	13,13,15,15,14,15,15,16,16,14,15,15,17,16,12,13,
	14,15,16,13,14,14,15,16,13,14,15,16,16,15,15,16,
	16,18,16,16,16,18,17,14,14,14,16,15,15,15,15,17,
	16,14,15,15,17,16,16,17,17,18,17,16,16,16,18,16,
	10,12,12,14,14,11,12,13,15,15,12,13,13,15,15,13,
	14,15,16,17,14,15,15,17,16,11,12,13,14,15,12,12,
	14,15,16,13,13,14,15,16,14,14,15,16,17,15,15,16,
	17,17,12,13,13,15,15,13,14,14,16,16,13,14,13,16,
	15,15,16,15,17,17,15,16,15,17,16,13,13,15,14,17,
	14,13,16,15,17,15,14,16,15,17,15,15,17,16,18,16,
	16,17,17,18,14,15,15,17,16,15,16,16,17,17,15,16,
	15,17,16,17,17,17,18,18,16,17,16,18,17,10,12,11,
	14,14,11,12,13,15,15,12,13,12,15,15,14,15,15,16,
	16,14,15,15,17,16,11,12,12,15,15,12,13,13,15,15,
	13,14,13,16,15,14,15,15,16,16,15,16,15,17,16,11,
	13,13,15,15,13,14,14,15,15,12,14,13,16,15,15,16,
	15,17,17,15,16,15,17,16,13,15,14,16,16,14,15,14,
	16,16,15,16,15,17,16,15,16,16,16,17,16,17,16,18,
	17,14,15,15,16,16,15,16,16,17,17,15,15,15,17,16,
	17,17,17,18,18,16,16,16,18,16,12,13,13,15,16,13,
	14,14,15,16,13,14,14,16,16,15,15,16,16,18,15,16,
	16,17,17,13,13,14,15,16,14,14,15,15,17,14,15,15,
	16,17,15,15,17,16,18,16,16,17,17,17,13,14,14,16,
	16,14,15,15,17,17,14,15,14,17,16,16,17,16,17,18,
	16,17,16,18,17,15,15,16,14,17,16,15,17,14,18,16,
	16,16,15,18,16,16,18,15,19,18,18,18,17,19,15,16,
	16,18,17,16,17,17,18,17,16,17,16,18,17,18,18,18,
	19,19,17,18,16,18,17,11,12,12,15,15,13,13,14,15,
	16,13,14,13,16,15,15,16,16,16,17,15,16,16,17,16,
	12,14,13,16,15,13,13,14,15,16,14,15,14,17,15,15,
	15,16,16,17,16,17,16,18,17,12,13,14,15,16,14,15,
	15,16,16,13,14,13,16,15,16,16,16,17,17,15,16,15,
	17,15,15,16,15,17,16,15,15,15,16,16,16,17,16,18,
	16,16,15,16,15,17,17,18,17,18,17,15,15,16,17,17,
	16,16,17,17,17,15,16,15,17,16,18,18,18,18,18,16,
	17,16,18,15, 9,11,11,14,14,11,12,12,14,15,10,12,
	12,15,14,13,14,15,16,16,13,14,14,16,16,11,12,12,
	14,15,12,12,13,15,15,12,13,13,15,15,14,15,15,16,
	17,14,15,15,16,16,10,12,12,14,14,12,13,13,15,15,
	11,13,12,15,15,14,15,15,16,17,13,15,14,16,16,14,
	14,14,15,16,14,15,15,16,17,14,15,15,16,17,16,16,
	17,16,18,16,17,17,17,17,12,14,13,16,15,13,15,14,
	16,16,13,14,14,16,15,16,16,16,17,17,15,16,15,17,
	16,10,11,11,14,14,12,12,13,14,15,11,13,12,15,14,
	14,15,15,16,17,14,15,15,16,16,12,13,13,15,15,12,
	13,14,15,16,13,14,14,15,15,15,15,16,16,17,15,15,
	16,17,17,11,12,12,15,15,13,13,14,15,16,12,13,13,
	15,15,15,15,16,16,17,14,15,15,16,16,14,15,15,16,
	16,15,15,15,16,17,15,16,16,17,17,16,16,17,16,18,
	17,17,17,17,18,13,14,15,16,16,15,15,16,16,17,14,
	14,14,16,16,16,16,17,17,18,16,16,16,17,16,10,12,
	12,14,14,12,13,13,15,15,11,13,12,15,15,14,15,15,
	16,17,13,15,14,17,16,12,13,13,15,15,13,13,14,15,
	16,13,14,14,16,16,15,15,16,16,17,15,15,16,17,17,
	11,13,12,15,14,13,14,13,16,15,12,14,12,16,15,15,
	16,15,17,17,14,15,14,17,16,14,15,15,16,17,15,15,
	16,16,17,15,16,16,17,17,16,16,17,17,18,17,17,17,
	18,18,13,15,13,17,14,14,16,14,17,16,14,15,13,17,
	15,16,17,16,18,17,15,17,15,18,16,11,12,12,15,15,
	13,13,14,15,16,13,14,13,16,15,15,16,16,16,17,15,
	16,16,17,16,12,14,13,16,15,13,13,14,15,16,14,15,
	15,16,16,16,15,16,16,17,16,16,16,17,17,12,13,14,
	15,16,14,14,15,15,17,13,14,13,16,15,16,16,17,17,
	18,15,16,15,17,15,15,16,15,17,17,15,15,16,16,17,
	16,17,16,17,17,16,15,17,15,18,17,18,17,18,18,15,
	15,16,16,17,16,16,17,16,18,15,15,15,16,16,17,17,
	18,17,18,16,16,15,17,15,12,13,13,15,15,13,14,14,
	16,16,13,14,14,16,16,15,16,16,17,18,15,16,15,18,
	16,13,14,14,16,16,14,14,15,16,17,14,15,15,17,17,
	16,16,17,17,18,16,16,17,18,17,13,14,13,16,14,14,
	15,15,17,16,14,15,14,17,15,16,17,17,18,17,15,17,
	15,18,16,15,16,16,17,17,16,16,17,17,18,16,17,17,
	18,18,17,16,18,17,19,18,18,18,18,18,15,16,15,17,
	14,16,16,16,18,15,16,17,15,18,14,18,18,18,18,17,
	17,18,16,19,15,
};

static const static_codebook _44p5_p2_0 = {
	5, 3125,
	(long *)_vq_lengthlist__44p5_p2_0,
	1, -533725184, 1611661312, 3, 0,
	(long *)_vq_quantlist__44p5_p2_0,
	0
};

static const long _vq_quantlist__44p5_p3_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p5_p3_0[] = {
	 1, 5, 6, 5, 7, 8, 5, 8, 7, 5, 7, 8, 7, 8,10, 8,
	10,10, 5, 8, 7, 8,10,10, 7,10, 8, 6, 8, 9, 8,10,
	11, 9,10,10, 9,10,11,10,11,12,11,12,12, 9,11,10,
	11,12,12,10,12,11, 6, 9, 8, 9,10,10, 8,11,10, 9,
	10,11,10,11,12,11,12,12, 9,11,10,11,12,12,10,12,
	11, 6, 9, 9, 8,10,11, 9,11,10, 8,10,10,10,10,12,
	11,12,12, 9,11,10,11,12,12,10,12,11, 8,10,10,10,
	11,12,10,12,11,10,10,12,11,11,13,12,13,13,10,12,
	11,12,13,13,11,13,11, 7,10,10,10,11,12,10,12,11,
	10,12,11,11,11,12,12,14,13,10,12,12,12,14,14,11,
	13,11, 6, 9, 9, 9,10,11, 8,11,10, 9,10,11,10,11,
	12,11,12,12, 8,11,10,11,12,12,10,12,10, 7,10,10,
	10,11,12,10,12,11,10,12,12,11,11,13,12,13,13,10,
	11,12,12,13,14,11,12,11, 8,10,10,10,11,12,10,12,
	11,10,11,12,11,11,13,12,13,13,10,12,10,12,13,13,
	11,13,11,
};

static const static_codebook _44p5_p3_0 = {
	5, 243,
	(long *)_vq_lengthlist__44p5_p3_0,
	1, -533200896, 1614282752, 2, 0,
	(long *)_vq_quantlist__44p5_p3_0,
	0
};

static const long _vq_quantlist__44p5_p3_1[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p5_p3_1[] = {
	 5, 6, 6, 6, 7, 7, 6, 7, 7, 6, 7, 7, 7, 7, 8, 7,
	 8, 8, 6, 7, 7, 7, 8, 8, 7, 8, 7, 7, 8, 8, 8, 8,
	 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 8, 9, 9, 8, 8, 8,
	 8, 9, 9, 8, 9, 9, 7, 8, 7, 8, 8, 8, 8, 8, 8, 8,
	 8, 8, 8, 9, 9, 8, 9, 9, 8, 8, 8, 8, 9, 9, 8, 9,
	 8, 6, 8, 8, 7, 8, 8, 7, 8, 8, 7, 8, 8, 8, 8, 9,
	 8, 9, 9, 8, 8, 8, 8, 9, 9, 8, 9, 8, 7, 8, 8, 8,
	 9, 9, 8, 9, 9, 8, 8, 9, 9, 9, 9, 9, 9, 9, 8, 9,
	 9, 9, 9, 9, 9, 9, 9, 7, 8, 8, 8, 8, 9, 8, 9, 8,
	 8, 8, 8, 8, 9, 9, 9, 9, 9, 8, 9, 8, 9, 9, 9, 8,
	 9, 9, 6, 8, 8, 7, 8, 8, 7, 8, 8, 8, 8, 8, 8, 8,
	 9, 8, 9, 9, 7, 8, 8, 8, 9, 9, 8, 9, 8, 7, 8, 8,
	 8, 8, 9, 8, 9, 8, 8, 8, 9, 8, 9, 9, 9, 9, 9, 8,
	 8, 8, 9, 9, 9, 8, 9, 9, 7, 8, 8, 8, 9, 9, 8, 9,
	 9, 8, 9, 9, 9, 9, 9, 9, 9, 9, 8, 9, 8, 9, 9, 9,
	 9, 9, 9,
};

static const static_codebook _44p5_p3_1 = {
	5, 243,
	(long *)_vq_lengthlist__44p5_p3_1,
	1, -535822336, 1611661312, 2, 0,
	(long *)_vq_quantlist__44p5_p3_1,
	0
};

static const long _vq_quantlist__44p5_p4_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p5_p4_0[] = {
	 1, 5, 5, 5, 7, 9, 5, 9, 7, 5, 7, 8, 7, 7,10, 9,
	10,10, 5, 8, 7, 9,10,10, 7,10, 7, 6, 8, 9, 9,10,
	12, 9,11,11, 9,10,11,11,11,13,12,13,13, 9,11,11,
	11,12,13,11,13,11, 6, 9, 8, 9,11,11, 9,12,10, 9,
	11,11,11,11,13,11,13,12, 9,11,10,12,13,13,11,13,
	11, 6, 9, 9, 8,10,11, 9,12,11, 9,10,11,10,10,12,
	11,13,13, 9,11,11,11,13,12,11,13,11, 8,10,10, 9,
	10,12,10,12,11,10,10,12,10,10,13,12,13,13,10,12,
	11,12,13,13,10,13,10, 7,10,10,11,11,13,11,14,11,
	10,12,11,11,11,13,13,14,13,10,12,12,14,14,14,11,
	14,11, 6, 9, 9, 9,11,12, 8,11,10, 9,11,11,11,11,
	13,11,12,13, 8,11,10,11,13,13,10,12,10, 7,10,10,
	11,11,14,11,13,11,10,12,12,11,11,14,14,14,14,10,
	11,12,13,13,14,11,13,11, 8,10,10,10,11,12, 9,12,
	10,10,11,12,11,10,13,12,13,13,10,12,10,12,13,13,
	11,13,10,
};

static const static_codebook _44p5_p4_0 = {
	5, 243,
	(long *)_vq_lengthlist__44p5_p4_0,
	1, -531365888, 1616117760, 2, 0,
	(long *)_vq_quantlist__44p5_p4_0,
	0
};

static const long _vq_quantlist__44p5_p4_1[] = {
	2,
	1,
	3,
	0,
	4,
};

static const long _vq_lengthlist__44p5_p4_1[] = {
	 5, 7, 7,10,10, 7, 8, 9,10,11, 7, 9, 8,11,10, 9,
	10,10,11,11, 9,10,10,11,11, 7, 9, 9,10,10, 8, 9,
	10,10,11, 9,10,10,11,11,10,10,11,11,11,10,11,11,
	12,12, 7, 9, 9,10,10, 9,10,10,11,11, 8,10, 9,11,
	10,10,11,11,11,11,10,11,10,11,11,10,10,10,11,11,
	10,10,11,11,11,11,11,11,11,11,11,11,12,11,12,11,
	12,11,12,12,10,10,10,11,11,10,11,11,11,11,10,11,
	10,11,11,11,12,11,12,12,11,12,11,12,11, 8, 9, 9,
	11,11, 9,10,10,11,12, 9,10,10,11,11,10,11,11,12,
	12,10,11,11,12,12, 9,10,10,11,11,10,10,11,11,12,
	10,11,11,12,12,11,11,12,12,12,11,12,12,12,12, 9,
	10,10,11,11,10,11,11,12,12,10,11,10,12,12,11,12,
	12,12,12,11,12,12,12,12,11,11,11,12,12,11,11,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,11,11,11,12,12,11,12,12,12,12,11,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12, 8, 9, 9,11,11, 9,
	10,10,11,11, 9,10,10,11,11,10,11,11,12,12,10,11,
	11,12,12, 9,10,10,11,11,10,10,11,12,12,10,11,11,
	12,12,11,12,12,12,12,11,12,12,12,12, 9,10,10,11,
	11,10,11,11,12,12,10,11,10,12,11,11,12,12,12,12,
	11,12,11,12,12,11,11,11,12,12,11,12,12,12,12,11,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,11,11,
	11,12,12,11,12,12,12,12,11,12,11,12,12,12,12,12,
	12,12,12,12,12,12,12,10,11,11,12,12,11,12,12,12,
	12,11,12,12,12,12,12,12,13,13,13,12,12,12,13,13,
	11,12,12,12,12,12,12,12,12,13,12,12,12,13,13,12,
	12,13,13,13,12,13,13,13,13,11,12,12,12,12,12,12,
	12,13,13,12,12,12,13,13,12,13,13,13,13,12,13,13,
	13,13,12,12,12,12,13,12,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,12,12,12,13,12,
	13,13,13,13,13,12,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,10,11,11,12,12,11,12,12,12,12,11,12,
	11,12,12,12,12,12,13,12,12,12,12,13,13,11,12,12,
	12,12,12,12,12,13,13,12,12,12,13,13,12,13,13,13,
	13,12,13,13,13,13,11,12,12,12,12,12,12,12,13,13,
	12,12,12,13,12,12,13,13,13,13,12,13,12,13,13,12,
	12,12,12,13,12,13,13,13,13,12,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,12,12,12,13,12,13,13,13,
	13,13,12,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13, 8, 9, 9,11,11, 9,10,10,11,11, 9,10,10,12,11,
	10,11,11,12,12,10,11,11,12,12, 9,10,10,11,11,10,
	10,11,11,12,10,11,11,12,12,11,11,12,12,12,11,12,
	12,12,12, 9,10,10,11,11,10,11,11,12,12,10,11,10,
	12,12,11,12,12,12,12,11,12,12,12,12,11,11,11,12,
	12,11,11,12,12,12,11,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,11,11,11,12,12,11,12,12,12,12,11,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12, 9,10,
	10,11,11,10,10,11,12,12,10,11,11,12,12,11,11,12,
	12,12,11,12,12,12,12,10,10,11,11,12,11,11,12,12,
	12,11,11,12,12,12,11,11,12,12,13,12,12,12,12,12,
	10,11,11,12,12,11,12,11,12,12,11,12,11,12,12,12,
	12,12,12,12,12,12,12,12,12,11,11,12,12,12,12,12,
	12,12,12,12,12,12,12,13,12,12,13,12,13,12,12,13,
	13,13,11,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,13,12,12,12,12,13,12, 8,10,10,11,11,
	10,11,11,12,12,10,11,10,12,12,11,12,12,12,12,11,
	12,12,12,12,10,11,10,12,12,10,10,11,12,12,11,12,
	12,12,12,12,12,12,12,13,12,12,12,13,13,10,11,11,
	12,12,11,12,12,12,12,10,12,11,12,12,12,12,12,13,
	13,12,13,12,13,12,11,12,12,12,12,11,12,12,12,13,
	12,12,12,13,13,12,12,13,12,13,12,13,13,13,13,11,
	12,12,12,12,12,12,12,13,13,12,12,12,13,12,12,13,
	13,13,13,12,13,12,13,12,11,11,11,12,12,11,12,12,
	12,13,11,12,12,12,12,12,12,12,13,13,12,12,13,13,
	13,11,12,12,12,12,12,12,12,12,13,12,12,13,13,13,
	12,12,13,13,13,13,13,13,13,13,11,12,12,12,12,12,
	13,12,13,13,12,12,12,13,13,12,13,13,13,13,12,13,
	13,13,13,12,12,12,12,13,12,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,12,12,12,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,10,11,11,12,12,11,12,12,12,13,11,
	12,12,13,12,12,13,13,13,13,12,13,13,13,13,11,12,
	12,12,12,12,12,12,13,13,12,13,12,13,13,13,13,13,
	13,13,13,13,13,13,13,11,12,12,13,12,12,13,12,13,
	13,12,13,12,13,13,13,13,13,13,13,13,13,13,13,13,
	12,13,13,13,13,12,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,12,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13, 8, 9, 9,11,11, 9,10,10,11,12, 9,10,10,11,
	11,10,11,11,12,12,10,11,11,12,12, 9,10,10,11,11,
	10,10,11,12,12,10,11,11,12,12,11,11,12,12,12,11,
	12,12,12,12, 9,10,10,11,11,10,11,11,12,12,10,11,
	10,12,12,11,12,12,12,12,11,12,11,12,12,11,11,11,
	12,12,11,11,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,11,11,11,12,12,11,12,12,12,12,
	11,12,11,12,12,12,12,12,12,12,12,12,12,12,12, 8,
	10,10,11,11,10,10,11,12,12,10,11,11,12,12,11,12,
	12,12,12,11,12,12,12,12,10,11,11,12,12,10,11,12,
	12,12,11,12,12,12,12,12,12,12,12,13,12,12,12,13,
	13,10,10,11,12,12,11,12,12,12,12,10,11,10,12,12,
	12,12,12,13,13,12,12,12,13,12,11,12,12,12,12,11,
	12,12,12,13,12,12,12,13,13,12,12,13,12,13,12,13,
	13,13,13,11,12,12,12,12,12,12,12,13,13,11,12,12,
	13,12,12,13,13,13,13,12,13,12,13,12, 9,10,10,11,
	11,10,11,11,12,12,10,11,11,12,12,11,12,12,12,12,
	11,12,11,12,12,10,11,11,12,12,11,11,12,12,12,11,
	11,12,12,12,12,12,12,12,13,12,12,12,13,12,10,11,
	10,12,11,11,12,11,12,12,11,12,11,12,12,12,12,12,
	12,12,12,12,11,12,12,11,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,13,12,13,12,13,13,13,13,
	11,12,11,12,12,12,12,12,13,12,12,12,12,12,12,12,
	13,12,13,13,12,12,12,13,12,10,11,11,12,12,11,12,
	12,12,13,11,12,12,13,12,12,12,13,13,13,12,13,13,
	13,13,11,12,12,12,13,12,12,13,13,13,12,12,13,13,
	13,13,13,13,13,13,13,13,13,13,13,11,12,12,12,12,
	12,12,13,13,13,12,13,12,13,13,13,13,13,13,13,13,
	13,13,13,13,12,13,13,13,13,12,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,12,12,13,
	13,13,13,13,13,13,13,12,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,11,11,11,12,12,11,12,12,12,12,
	11,12,12,12,12,12,12,13,13,13,12,13,12,13,13,11,
	12,12,12,12,12,12,13,13,13,12,12,13,13,13,12,13,
	13,13,13,12,13,13,13,13,11,12,12,12,12,12,13,12,
	13,13,12,12,12,13,12,13,13,13,13,13,12,13,12,13,
	13,12,12,12,13,13,12,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,12,12,12,13,12,13,
	13,13,13,13,12,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,10,11,11,12,12,11,12,12,12,12,11,12,12,
	12,12,12,12,12,13,13,12,12,12,13,13,11,12,12,12,
	12,11,12,12,13,13,12,12,12,13,13,12,12,13,13,13,
	12,13,13,13,13,11,12,12,12,12,12,12,12,13,13,12,
	12,12,13,12,12,13,13,13,13,12,13,12,13,13,12,12,
	12,12,12,12,12,13,13,13,12,13,13,13,13,12,13,13,
	13,13,13,13,13,13,13,12,12,12,13,12,12,13,13,13,
	13,12,13,12,13,13,13,13,13,13,13,13,13,13,13,13,
	10,11,11,12,12,11,12,12,12,13,11,12,12,13,12,12,
	12,12,13,13,12,12,12,13,13,11,12,12,12,12,12,12,
	13,13,13,12,12,12,13,13,12,12,13,13,13,12,13,13,
	13,13,11,12,12,12,12,12,12,12,13,13,12,12,12,13,
	13,12,13,13,13,13,12,13,13,13,13,12,12,12,12,13,
	12,12,13,13,13,12,13,13,13,13,12,13,13,13,13,13,
	13,13,13,13,12,12,12,13,13,13,13,13,13,13,12,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,10,11,11,
	12,12,11,12,12,12,13,11,12,12,13,12,12,13,13,13,
	13,12,13,12,13,13,11,12,12,13,13,12,12,12,13,13,
	12,12,13,13,13,12,13,13,13,13,13,13,13,13,13,11,
	12,12,13,12,12,13,12,13,13,12,13,12,13,13,13,13,
	13,13,13,12,13,13,13,13,12,12,12,13,13,12,13,13,
	13,13,12,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,12,12,12,13,13,12,13,13,13,13,12,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,11,11,11,12,12,11,
	12,12,12,12,11,12,12,12,12,12,12,12,13,13,12,12,
	12,13,13,11,12,12,12,12,12,12,12,12,13,12,12,12,
	13,13,12,12,13,13,13,12,13,13,13,13,11,12,12,12,
	12,12,12,12,13,13,12,12,12,13,12,12,13,13,13,13,
	12,13,12,13,13,12,12,12,12,12,12,12,13,12,13,12,
	13,13,13,13,12,13,13,12,13,13,13,13,13,13,12,12,
	12,12,12,12,13,13,13,13,12,13,12,13,13,13,13,13,
	13,13,12,13,13,13,12,10,11,11,12,12,11,12,12,12,
	12,11,12,12,12,12,12,12,12,13,13,12,13,12,13,13,
	11,12,12,12,12,12,12,12,13,13,12,12,12,13,13,12,
	12,13,13,13,13,13,13,13,13,11,12,12,12,12,12,13,
	12,13,13,12,13,12,13,13,12,13,13,13,13,12,13,12,
	13,13,12,12,12,12,12,12,13,13,13,13,12,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,12,12,12,13,12,
	12,13,13,13,13,12,13,12,13,13,13,13,13,13,13,13,
	13,13,13,13,10,11,11,12,12,11,12,12,12,12,11,12,
	12,12,12,12,12,12,13,13,12,12,12,13,13,11,12,12,
	12,12,12,12,12,13,13,12,12,12,13,13,12,12,13,13,
	13,12,12,13,13,13,11,12,11,12,12,12,12,12,13,13,
	11,12,12,13,13,12,13,13,13,13,12,13,12,13,13,12,
	12,12,12,12,12,13,13,13,13,12,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,12,12,12,13,12,12,13,13,
	13,13,12,13,12,13,13,13,13,13,13,13,12,13,13,13,
	13,10,11,11,12,12,11,12,12,12,13,11,12,12,13,12,
	12,12,13,13,13,12,13,13,13,13,11,12,12,13,13,12,
	12,13,13,13,12,12,13,13,13,12,13,13,13,13,13,13,
	13,13,13,11,12,12,13,12,12,13,12,13,13,12,12,12,
	13,13,12,13,13,13,13,13,13,13,13,13,12,12,13,13,
	13,12,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,12,12,12,13,13,13,13,13,13,13,12,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,10,12,
	11,12,12,11,12,12,12,13,11,12,12,12,12,12,12,12,
	13,13,12,12,12,13,13,11,12,12,12,13,12,12,12,13,
	13,12,12,12,13,13,12,13,13,13,13,12,13,13,13,13,
	11,12,12,13,12,12,12,12,13,13,12,12,12,13,13,12,
	13,13,13,13,12,13,12,13,13,12,13,12,13,13,12,13,
	13,13,13,12,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,12,12,12,13,12,13,13,13,13,13,12,13,12,13,
	13,13,13,13,13,13,12,13,13,13,13,10,11,11,12,12,
	11,12,12,12,13,11,12,12,12,12,12,12,12,13,13,12,
	12,12,13,13,11,12,12,12,12,12,12,13,13,13,12,13,
	13,13,13,12,12,13,13,13,13,13,13,13,13,11,12,12,
	12,12,12,13,12,13,13,12,12,12,13,13,12,13,13,13,
	13,12,13,12,13,13,12,12,12,12,13,12,13,13,13,13,
	12,13,13,13,13,12,13,13,13,13,13,13,13,13,13,12,
	12,12,12,12,12,13,13,13,13,12,13,13,13,13,13,13,
	13,13,13,12,13,13,13,13,11,12,11,12,12,11,12,12,
	12,12,11,12,12,12,12,12,12,12,12,13,12,12,12,13,
	12,11,12,12,12,12,12,12,12,12,13,12,12,12,13,13,
	12,12,13,13,13,12,13,13,13,13,11,12,12,12,12,12,
	12,12,13,13,12,12,12,13,12,12,13,13,13,13,12,13,
	12,13,13,12,12,12,12,12,12,12,13,13,13,12,13,13,
	13,13,13,13,13,12,13,13,13,13,13,13,12,12,12,12,
	12,12,13,13,13,13,12,13,12,13,12,13,13,13,13,13,
	13,13,13,13,12,
};

static const static_codebook _44p5_p4_1 = {
	5, 3125,
	(long *)_vq_lengthlist__44p5_p4_1,
	1, -533725184, 1611661312, 3, 0,
	(long *)_vq_quantlist__44p5_p4_1,
	0
};

static const long _vq_quantlist__44p5_p5_0[] = {
	2,
	1,
	3,
	0,
	4,
};

static const long _vq_lengthlist__44p5_p5_0[] = {
	 1, 6, 6,10,10, 6, 7, 9,11,13, 5, 9, 7,13,11, 8,
	11,12,13,15, 8,12,11,15,13, 6, 7, 8,11,11, 7, 8,
	10,11,13, 9,10,10,13,13,11,11,13,12,16,12,13,13,
	16,15, 6, 8, 7,11,11, 9,10,10,13,13, 7,10, 7,13,
	11,12,13,13,15,16,11,13,11,16,12,10,11,11,11,13,
	11,11,13,12,15,13,13,13,14,15,13,12,15,12,17,15,
	16,16,16,16,10,11,11,14,11,13,13,13,15,14,11,13,
	11,15,12,15,15,16,16,16,13,15,12,17,12, 6, 8, 9,
	12,12, 9,10,12,13,15, 9,11,11,15,14,12,13,15,16,
	18,13,14,14,17,16, 9,10,11,13,14,11,10,13,14,16,
	11,12,12,15,15,14,13,16,15,18,14,15,15,17,17, 9,
	11,11,14,14,11,12,13,15,16,11,13,11,15,14,15,15,
	15,17,18,14,15,14,17,15,13,14,14,15,16,14,14,15,
	15,17,15,16,15,17,17,16,16,17,15,19,17,18,18,19,
	18,13,14,14,16,15,15,15,16,17,17,14,15,14,18,15,
	17,17,17,19,19,16,17,15,19,16, 6, 9, 8,13,12, 9,
	11,11,14,15, 9,12,10,15,13,13,14,14,16,17,12,15,
	13,18,16, 9,11,11,14,14,11,11,13,14,15,11,13,12,
	16,15,14,14,15,15,18,14,15,15,18,17, 9,11,10,14,
	13,11,12,12,15,15,11,13,10,16,14,14,15,15,16,18,
	14,16,13,18,15,13,14,14,16,16,14,14,15,15,17,15,
	16,15,17,17,16,16,17,16,19,17,18,17,18,19,13,14,
	14,16,15,15,15,15,17,17,14,15,14,17,15,17,17,17,
	18,19,16,17,15,19,15,11,13,13,15,16,13,14,15,16,
	18,14,15,15,17,17,16,16,18,18,20,17,18,17,19,20,
	13,14,14,16,17,15,15,16,17,18,15,16,16,17,17,18,
	17,19,18,19,18,18,18,19,21,14,14,15,16,17,15,15,
	16,18,18,15,16,16,17,18,18,18,19,19,21,18,19,19,
	22,20,16,16,17,17,19,17,17,17,18,20,17,18,18,20,
	19,19,19,20,19, 0,19,19,20,20,21,17,17,17,19,18,
	18,18,20,19,19,18,18,18,20,20,19,19,20,20,20,20,
	21,20,21,19,11,13,13,16,15,14,15,15,17,17,14,15,
	14,18,16,16,18,18,20,19,16,19,17,21,18,13,14,15,
	16,17,15,15,16,18,18,15,16,15,19,18,18,18,18,19,
	19,18,18,18,22,20,13,14,14,16,16,15,16,16,18,17,
	15,16,15,18,17,18,18,18,19,19,17,18,17,21,18,16,
	17,17,18,18,17,18,19,19,19,18,20,18,19,19,19,20,
	21,19,21,20,20,20, 0,21,16,17,17,19,19,18,18,18,
	19,21,17,18,18,19,18,20,19,21,20,21,19,20,20,22,
	19, 7, 9, 9,13,13, 8,10,11,14,15, 9,12,11,15,14,
	11,13,14,16,17,13,15,14,17,16, 8,10,11,14,14,10,
	10,12,14,16,11,12,12,16,15,13,12,15,15,18,14,15,
	15,19,17, 9,11,11,14,14,11,12,12,15,15,11,13,11,
	16,14,14,15,14,17,17,14,16,14,18,15,12,13,14,15,
	16,13,13,15,14,17,15,15,15,17,17,15,14,17,14,19,
	17,18,18,19,18,13,14,14,16,16,15,15,15,17,17,14,
	15,14,18,15,17,18,17,18,17,16,18,16,19,15, 7,10,
	10,13,13, 9,10,12,14,15,10,12,11,15,14,12,13,14,
	16,17,13,15,14,18,16,10,10,12,13,14,10,10,13,13,
	16,12,12,13,15,15,13,12,15,15,18,15,15,16,18,17,
	10,11,11,14,14,12,13,13,15,16,10,13,10,16,14,14,
	15,15,17,17,14,15,13,17,15,13,13,14,15,16,14,13,
	15,14,18,15,15,16,16,17,16,15,18,15,18,17,18,18,
	18,18,13,15,14,17,16,15,16,16,17,17,14,15,13,17,
	15,17,17,18,18,18,16,17,14,20,14, 8,10,10,14,14,
	11,11,13,14,16,11,13,11,16,14,14,15,16,16,18,14,
	16,15,18,16,10,12,11,15,14,11,11,13,14,16,13,14,
	13,16,15,15,14,16,15,19,16,17,16,20,18,10,11,12,
	14,15,13,13,14,16,16,11,14,11,16,14,16,16,17,18,
	19,15,17,14,20,15,14,15,14,17,16,13,14,15,15,18,
	16,17,16,19,18,16,15,18,15,19,18,19,18,21,21,14,
	14,15,16,17,16,16,17,18,18,13,15,14,17,15,18,18,
	19,18,22,16,18,15,21,15,12,13,14,16,16,14,14,16,
	16,18,14,15,15,17,18,16,16,18,18,20,18,18,17,20,
	20,13,14,15,15,17,15,14,16,16,18,16,16,16,17,19,
	17,15,18,17,21,18,18,18,19,19,14,15,15,18,17,15,
	16,16,18,19,15,16,15,18,18,17,18,18,20,21,17,19,
	17,20,19,16,16,17,16,19,17,17,18,17,20,18,18,18,
	18,19,19,18,20,17,22,20,20,19,20,20,17,17,18,18,
	19,18,18,20,21,20,17,18,17,20,20,21,21,21,21,21,
	19,21,18,22,20,11,13,13,17,16,14,14,16,16,18,14,
	16,14,18,16,17,18,19,19,20,18,19,18,21,19,14,15,
	14,17,16,14,14,16,18,18,16,17,16,18,17,18,17,19,
	18,20,19,19,18,20,20,13,14,15,16,17,16,16,17,18,
	19,14,16,14,19,17,18,19,18,20,20,18,20,17,21,18,
	17,17,17,19,18,16,17,18,18,19,18,19,18,21,21,18,
	18,20,17,21,19,20,20,22,21,16,17,18,18,19,18,18,
	19,21,20,16,17,17,20,18,21,21,22,21,22,18,21,18,
	 0,18, 7, 9, 9,13,13, 9,11,12,14,15, 8,11,10,15,
	14,13,14,15,16,18,11,14,13,17,15, 9,11,11,14,14,
	11,11,13,14,16,11,12,12,15,15,14,14,16,15,18,14,
	14,15,17,17, 8,11,10,14,14,11,12,12,15,15,10,12,
	10,16,14,14,15,15,17,18,13,15,12,18,15,13,14,14,
	16,16,14,14,15,15,17,15,15,15,16,17,16,15,17,15,
	19,17,17,17,18,18,12,14,13,16,15,15,15,15,17,17,
	13,15,13,17,14,17,18,18,18,19,15,17,14,19,14, 8,
	10,10,14,14,11,11,13,14,16,11,13,11,16,14,14,15,
	16,17,19,14,16,15,18,17,10,12,11,15,14,11,11,14,
	14,17,13,14,13,17,15,15,14,17,15,19,16,17,16,19,
	17,10,11,12,14,15,13,13,14,15,17,11,13,11,17,14,
	16,16,17,18,19,15,16,14,18,15,14,15,14,16,16,13,
	14,15,15,18,16,16,16,18,18,16,15,18,15,20,18,19,
	18,21,18,14,14,15,16,17,16,16,17,17,18,13,15,14,
	17,16,19,19,19,19,19,15,18,15,20,15, 7,10,10,13,
	13,10,11,12,14,15, 9,12,10,15,14,13,14,15,16,17,
	12,15,13,17,16,10,11,11,14,14,10,10,13,14,16,12,
	13,13,16,15,14,13,16,15,18,15,15,16,17,17,10,12,
	10,14,13,12,13,12,15,15,10,13,10,16,13,15,16,15,
	17,18,13,16,12,18,15,13,14,14,16,17,14,13,15,15,
	18,15,16,15,17,17,16,14,17,15,19,17,18,18,19,19,
	13,15,13,17,14,15,15,15,18,17,14,15,13,17,14,18,
	17,18,18,19,15,17,15,19,15,11,13,13,16,17,14,14,
	16,16,18,14,16,15,18,17,17,18,19,18,21,18,18,17,
	20,18,13,15,14,17,16,14,14,16,17,18,16,17,16,19,
	17,18,17,19,18,22,18,19,19,21,21,13,14,15,16,18,
	16,16,17,17,20,14,16,14,18,17,18,18,19,19,21,17,
	18,17,21,18,17,18,17,19,18,16,17,17,18,19,18,18,
	18,22,22,18,17,19,17, 0,20,21,19,21,20,17,17,18,
	18,21,18,18,18,19,21,17,17,17,19,19,20,20,22,21,
	21,19,20,18,20,17,12,14,13,17,16,14,15,15,17,18,
	14,16,14,18,16,17,18,18,21,20,16,18,16,21,18,14,
	15,15,17,17,15,15,16,18,18,15,17,16,18,18,17,17,
	19,19,20,18,19,18,20,19,14,15,14,17,15,15,16,16,
	18,17,15,16,14,19,15,18,18,18,19,20,17,20,15,21,
	17,16,17,18,18,19,17,17,18,18,20,18,19,18,19,21,
	19,18,19,19,21,20, 0,19,21,20,16,17,16,19,16,18,
	18,18,19,19,17,18,17,20,17,19,20,20,22, 0,19,20,
	17,21,17,11,13,14,16,17,14,15,15,17,18,14,15,15,
	18,18,16,17,17,19,20,16,18,17,19,21,13,14,15,17,
	17,14,15,16,17,19,15,16,16,18,19,16,17,18,19,21,
	17,18,20,21,21,13,15,15,17,17,15,16,16,18,19,15,
	16,16,18,19,17,17,18,19,22,17,19,18,22,19,15,16,
	17,19,19,16,17,18,18,20,17,18,18,19,20,19,18,20,
	18,22,20,19,19,22,21,16,17,17,18,19,18,18,18,19,
	20,17,18,18,20,19,20,19,20,22,20,19,20,21,21,20,
	12,14,14,16,16,13,14,16,17,18,14,16,15,18,18,15,
	17,17,19,19,17,18,18,19,19,13,14,15,16,17,14,14,
	16,16,20,15,16,16,17,19,16,15,18,17,20,18,17,19,
	19,19,14,15,15,17,17,16,16,16,18,18,15,16,15,19,
	18,17,18,18,20,21,17,18,17,21,18,16,15,17,17,19,
	17,15,18,17,20,19,17,18,19,20,18,16,19,17,22,20,
	19,20,19,20,17,17,18,19,19,18,18,19,20,20,17,18,
	17,18,18,21,21,20,20,21,18,20,17,21,19,11,14,14,
	16,17,15,14,16,17,19,14,16,14,18,17,18,18,19,19,
	21,17,19,18,20,20,13,15,14,17,17,14,14,16,17,18,
	16,17,16,19,18,18,17,19,18,20,18,21,18,20,20,13,
	15,15,16,17,16,16,17,18,19,14,16,15,19,18,19,19,
	19,21,20,18,19,17,20,18,16,17,16,19,18,16,17,17,
	19,20,17,19,18,20,19,18,17,21,18, 0,21,20,20, 0,
	20,17,17,18,18,19,18,19,19,20,22,16,17,17,20,18,
	21,22,20,20,22,18,22,18,22,18,12,14,14,17,17,14,
	15,16,17,19,14,16,15,17,17,17,17,18,18,21,17,19,
	17,20,19,14,15,15,16,18,15,14,16,16,19,16,17,16,
	19,18,17,16,20,17,20,18,20,19,19,20,14,15,15,18,
	17,16,16,17,18,19,14,16,15,19,17,18,21,18,19,21,
	17,18,17,19,18,17,17,18,17,20,17,16,18,17,21,18,
	19,19,19,19,18,17,19,17,20,20,21,20,21,20,17,17,
	17,19,19,19,18,18,20,21,16,18,16,19,18,20,20,21,
	21,20,18,19,16, 0,17,12,14,14,17,17,15,15,18,17,
	19,15,18,15,20,16,20,19,21,18,22,20,20,20,22,19,
	14,16,14,20,17,14,15,17,17,20,18,18,17,20,18,18,
	17,19,17,21,20,21,20, 0,21,14,15,16,17,19,18,17,
	19,18,21,14,18,15,21,17,21,20,21,20, 0,18,21,17,
	21,17,18,19,17,20,18,16,17,17,19,19,19,21,20, 0,
	20,18,17,21,17, 0,22, 0,21, 0,22,17,17,19,18,20,
	20,20,21,19,22,16,17,18,20,18,22,22, 0,22, 0,17,
	21,17,22,17,11,14,13,16,16,14,15,15,17,18,14,15,
	14,18,17,17,18,18,19,20,16,17,17,21,19,13,14,15,
	17,17,15,16,16,18,18,15,16,16,19,18,18,18,18,19,
	20,17,18,18,20,19,13,15,14,17,17,15,16,16,17,18,
	14,16,15,19,17,17,18,19,21,21,17,18,17,20,18,16,
	17,17,19,19,17,18,19,19,20,18,19,18,21,21,21,20,
	19,21,22,20,20,19,21,20,15,17,16,19,19,17,18,18,
	20,21,16,18,17,20,18,19,19,21,21,21,19,19,19,20,
	18,11,14,13,17,16,14,14,16,16,19,14,16,15,19,16,
	18,18,18,19,22,17,18,17,20,19,13,15,14,17,17,15,
	15,16,17,19,16,17,16,20,18,18,17,19,18,21,19,19,
	18,22, 0,13,14,15,17,18,16,16,17,17,19,14,16,15,
	19,18,18,19,19,20,21,18,18,17,20,18,17,18,17,20,
	18,16,17,17,18,20,18,19,18,20,20,18,18,21,17,21,
	20,21,21, 0,19,16,16,18,18,19,19,18,20,19,20,16,
	17,17,20,18,21,20,21,22,22,18,20,17,21,17,12,14,
	14,17,16,14,15,16,18,18,13,15,14,18,17,17,18,18,
	19,19,15,17,16,19,19,14,15,15,17,17,15,15,16,18,
	19,15,16,16,19,18,17,17,18,18,20,18,18,18,21,20,
	13,15,14,17,16,15,16,15,18,18,14,16,14,18,17,18,
	18,18,19,21,16,18,16,20,17,17,18,17,18,19,17,17,
	18,18,19,18,19,19,21,19,19,18,20,18,21,21,20,20,
	21,20,16,17,15,20,17,17,19,17,19,19,17,18,15,20,
	17,19,20,19,21,22,17,20,16, 0,17,12,14,14,17,18,
	16,15,18,16,20,16,18,15,21,17,20,18,21,19,22,19,
	21,19, 0,19,14,16,15,19,17,14,15,17,16,21,18,19,
	18,21,17,19,17,21,17,22,20,21,21, 0,21,14,15,16,
	17,19,18,17,19,18,21,14,17,15,20,17,21,22,21,20,
	22,18,21,17,21,17,17,19,17,21,18,16,17,17,19,20,
	19,21,20,21,20,17,18,20,17,21, 0,22,20,21,22,17,
	17,20,18,21,21,20,22,20,21,16,17,17,21,19, 0,22,
	 0,21,21,18,22,17,21,17,12,14,14,17,16,14,15,16,
	17,18,14,16,15,18,17,17,17,20,19,20,16,18,17,21,
	18,14,15,15,17,17,14,15,16,17,19,16,17,16,18,18,
	17,16,19,18,19,18,19,18,21,20,14,15,15,18,17,16,
	16,16,19,18,15,16,14,20,16,18,18,19,19,20,16,19,
	16,21,17,17,17,18,19,19,16,16,18,18,19,19,19,18,
	20,20,18,16,19,18,20,22,21,20,19,20,16,18,17,20,
	16,18,19,18,19,18,16,18,16,20,17,21,20,21,20,20,
	18,19,17,21,16,
};

static const static_codebook _44p5_p5_0 = {
	5, 3125,
	(long *)_vq_lengthlist__44p5_p5_0,
	1, -528744448, 1616642048, 3, 0,
	(long *)_vq_quantlist__44p5_p5_0,
	0
};

static const long _vq_quantlist__44p5_p5_1[] = {
	3,
	2,
	4,
	1,
	5,
	0,
	6,
};

static const long _vq_lengthlist__44p5_p5_1[] = {
	 2, 3, 3, 3, 3, 3, 3,
};

static const static_codebook _44p5_p5_1 = {
	1, 7,
	(long *)_vq_lengthlist__44p5_p5_1,
	1, -533200896, 1611661312, 3, 0,
	(long *)_vq_quantlist__44p5_p5_1,
	0
};

static const long _vq_quantlist__44p5_p6_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p5_p6_0[] = {
	 1, 5, 5, 5, 7, 9, 5, 9, 7, 5, 7, 8, 7, 7,10, 9,
	 9,10, 5, 8, 7, 9,10, 9, 7,10, 7, 6, 9, 9, 9,10,
	12,10,12,11, 9,10,11,11,10,13,12,12,13,10,11,11,
	12,13,13,11,13,11, 6, 9, 9,10,11,12, 9,12,11,10,
	11,11,11,11,13,12,13,13, 9,11,10,12,13,13,11,13,
	10, 6, 9,10, 9,11,12,10,12,11, 9,10,11,10,10,13,
	11,13,13,10,11,11,12,13,12,11,13,11, 7, 9,10, 9,
	10,12,10,11,11,10,10,11,10,10,12,12,11,12,10,11,
	10,12,12,12,10,12,10, 7,10,10,11,11,13,11,13,11,
	10,12,11,11,10,13,13,14,13,10,11,12,13,13,14,11,
	13,10, 6,10, 9,10,11,12, 9,12,11, 9,11,11,11,11,
	13,12,12,13, 9,11,10,12,13,13,10,13,10, 7,10,10,
	11,11,14,11,13,11,10,12,11,11,10,14,13,14,13,10,
	11,12,13,13,14,11,13,10, 7,10, 9,10,10,12, 9,12,
	10,10,11,11,10,10,12,12,12,12, 9,11,10,11,12,12,
	10,12, 9,
};

static const static_codebook _44p5_p6_0 = {
	5, 243,
	(long *)_vq_lengthlist__44p5_p6_0,
	1, -527106048, 1620377600, 2, 0,
	(long *)_vq_quantlist__44p5_p6_0,
	0
};

static const long _vq_quantlist__44p5_p6_1[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p5_p6_1[] = {
	 2, 6, 6, 5, 7, 8, 5, 8, 7, 6, 7, 7, 7, 7, 8, 8,
	 8, 8, 6, 7, 7, 7, 8, 8, 7, 8, 7, 6, 8, 8, 8, 9,
	10, 8, 9, 9, 8, 9, 9, 9, 9,10,10,10,10, 8, 9, 9,
	10,10,10, 9,10,10, 6, 8, 8, 8, 9, 9, 8,10, 9, 9,
	 9, 9, 9, 9,10,10,10,10, 8, 9, 9,10,10,10, 9,10,
	 9, 6, 8, 9, 8, 9, 9, 8, 9, 9, 8, 9, 9, 9, 9,10,
	 9,10,10, 8, 9, 9, 9,10,10, 9,10, 9, 7, 8, 9, 8,
	 9, 9, 9, 9, 9, 8, 9, 9, 9, 9, 9, 9, 9, 9, 8, 9,
	 9, 9, 9, 9, 9, 9, 9, 7, 9, 9, 9,10,10, 9,10,10,
	 9,10, 9, 9, 9,10,10,10,10, 9,10, 9,10,10,10, 9,
	10, 9, 6, 8, 8, 8, 9, 9, 8, 9, 9, 8, 9, 9, 9, 9,
	10, 9,10,10, 8, 9, 9, 9,10,10, 9,10, 9, 7, 9, 9,
	 9,10,10, 9,10, 9, 9, 9,10,10, 9,10,10,10,10, 9,
	 9, 9,10,10,10, 9,10, 9, 7, 9, 8, 8, 9, 9, 8, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 8, 9, 8, 9, 9, 9,
	 9, 9, 9,
};

static const static_codebook _44p5_p6_1 = {
	5, 243,
	(long *)_vq_lengthlist__44p5_p6_1,
	1, -530841600, 1616642048, 2, 0,
	(long *)_vq_quantlist__44p5_p6_1,
	0
};

static const long _vq_quantlist__44p5_p7_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p5_p7_0[] = {
	 1, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9,
};

static const static_codebook _44p5_p7_0 = {
	5, 243,
	(long *)_vq_lengthlist__44p5_p7_0,
	1, -513979392, 1633504256, 2, 0,
	(long *)_vq_quantlist__44p5_p7_0,
	0
};

static const long _vq_quantlist__44p5_p7_1[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p5_p7_1[] = {
	 1, 7, 7, 6, 9, 9, 7, 9, 9, 6, 9, 9, 9, 9, 9, 9,
	 9, 9, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 7, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 7, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
	10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
	10,10,10,
};

static const static_codebook _44p5_p7_1 = {
	5, 243,
	(long *)_vq_lengthlist__44p5_p7_1,
	1, -516716544, 1630767104, 2, 0,
	(long *)_vq_quantlist__44p5_p7_1,
	0
};

static const long _vq_quantlist__44p5_p7_2[] = {
	12,
	11,
	13,
	10,
	14,
	9,
	15,
	8,
	16,
	7,
	17,
	6,
	18,
	5,
	19,
	4,
	20,
	3,
	21,
	2,
	22,
	1,
	23,
	0,
	24,
};

static const long _vq_lengthlist__44p5_p7_2[] = {
	 1, 2, 3, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9,10,10,11,
	11,12,12,13,13,14,14,14,14,
};

static const static_codebook _44p5_p7_2 = {
	1, 25,
	(long *)_vq_lengthlist__44p5_p7_2,
	1, -518864896, 1620639744, 5, 0,
	(long *)_vq_quantlist__44p5_p7_2,
	0
};

static const long _vq_quantlist__44p5_p7_3[] = {
	12,
	11,
	13,
	10,
	14,
	9,
	15,
	8,
	16,
	7,
	17,
	6,
	18,
	5,
	19,
	4,
	20,
	3,
	21,
	2,
	22,
	1,
	23,
	0,
	24,
};

static const long _vq_lengthlist__44p5_p7_3[] = {
	 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5,
	 5, 5, 5, 5, 5, 5, 5, 5, 5,
};

static const static_codebook _44p5_p7_3 = {
	1, 25,
	(long *)_vq_lengthlist__44p5_p7_3,
	1, -529006592, 1611661312, 5, 0,
	(long *)_vq_quantlist__44p5_p7_3,
	0
};

static const long _huff_lengthlist__44p5_short[] = {
	 4, 7,12,14,15,18,20,20, 5, 3, 4, 6, 9,11,15,19,
	 9, 4, 3, 4, 7, 9,13,18,11, 6, 3, 3, 5, 8,13,19,
	14, 9, 6, 5, 7,10,16,20,16,11, 9, 8,10,10,14,16,
	21,14,13,11, 8, 7,11,14,21,14,13, 9, 6, 5,10,12,
};

static const static_codebook _huff_book__44p5_short = {
	2, 64,
	(long *)_huff_lengthlist__44p5_short,
	0, 0, 0, 0, 0,
	NULL,
	0
};

static const long _vq_quantlist__44p6_l0_0[] = {
	6,
	5,
	7,
	4,
	8,
	3,
	9,
	2,
	10,
	1,
	11,
	0,
	12,
};

static const long _vq_lengthlist__44p6_l0_0[] = {
	 1, 4, 4, 7, 7,10,10,12,12,12,12,13,12, 5, 5, 5,
	 8, 6,11, 9,12,12,13,12,12,12, 4, 5, 5, 6, 8, 9,
	11,12,12,13,12,12,12, 7, 7, 8, 9, 9,11, 8,12, 9,
	12,12,12,12, 7, 8, 8, 9, 9, 8,11, 9,12,12,12,11,
	12,10,10,10,11,11,11,11,11,10,11,11,12,11,10,10,
	10,11,11,11,11,10,11,11,11,11,12,11,11,11,12,11,
	12,11,12,11,13,11,13,11,11,11,11,11,12,11,12,10,
	13,11,12,11,13,12,12,12,13,12,13,13,13,12,14,12,
	14,13,12,12,12,12,13,13,13,12,14,12,14,13,14,13,
	14,14,14,14,14,14,14,14,15,14,15,14,13,14,13,14,
	14,14,14,14,15,14,14,14,15,
};

static const static_codebook _44p6_l0_0 = {
	2, 169,
	(long *)_vq_lengthlist__44p6_l0_0,
	1, -526516224, 1616117760, 4, 0,
	(long *)_vq_quantlist__44p6_l0_0,
	0
};

static const long _vq_quantlist__44p6_l0_1[] = {
	2,
	1,
	3,
	0,
	4,
};

static const long _vq_lengthlist__44p6_l0_1[] = {
	 4, 4, 4, 5, 5, 4, 5, 5, 5, 5, 4, 5, 5, 5, 5, 5,
	 5, 5, 4, 5, 5, 5, 5, 5, 4,
};

static const static_codebook _44p6_l0_1 = {
	2, 25,
	(long *)_vq_lengthlist__44p6_l0_1,
	1, -533725184, 1611661312, 3, 0,
	(long *)_vq_quantlist__44p6_l0_1,
	0
};

static const long _vq_quantlist__44p6_l1_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p6_l1_0[] = {
	 1, 3, 2, 5, 5, 6, 6, 6, 6,
};

static const static_codebook _44p6_l1_0 = {
	2, 9,
	(long *)_vq_lengthlist__44p6_l1_0,
	1, -516716544, 1630767104, 2, 0,
	(long *)_vq_quantlist__44p6_l1_0,
	0
};

static const long _huff_lengthlist__44p6_lfe[] = {
	 2, 3, 1, 3,
};

static const static_codebook _huff_book__44p6_lfe = {
	2, 4,
	(long *)_huff_lengthlist__44p6_lfe,
	0, 0, 0, 0, 0,
	NULL,
	0
};

static const long _huff_lengthlist__44p6_long[] = {
	 2, 7,13,15,16,17,19,20, 6, 3, 4, 7, 9,10,12,15,
	13, 4, 3, 4, 7, 8,11,13,14, 7, 4, 4, 6, 7,10,11,
	16, 9, 7, 6, 7, 8, 9,10,16, 9, 8, 7, 7, 6, 8, 8,
	18,12,10,10, 9, 8, 8, 9,20,14,13,12,11, 8, 9, 9,
};

static const static_codebook _huff_book__44p6_long = {
	2, 64,
	(long *)_huff_lengthlist__44p6_long,
	0, 0, 0, 0, 0,
	NULL,
	0
};

static const long _vq_quantlist__44p6_p1_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p6_p1_0[] = {
	 2, 5, 5, 5, 7, 7, 5, 7, 7, 5, 7, 7, 7, 8, 9, 7,
	 9, 9, 5, 7, 7, 7, 9, 9, 7, 9, 8, 5, 7, 8, 8, 9,
	10, 8, 9, 9, 8, 9,10, 9,10,12,10,11,11, 8, 9,10,
	10,11,11, 9,11,11, 5, 8, 7, 8, 9, 9, 8,10, 9, 8,
	10, 9, 9,11,11,10,11,11, 8,10, 9,10,11,11, 9,12,
	10, 5, 8, 8, 7, 9,10, 8,10, 9, 7, 9, 9, 9,10,11,
	 9,11,11, 8,10,10,10,11,11,10,12,11, 7, 9, 9, 9,
	10,11, 9,11,11, 9, 9,11,10,10,13,11,11,12, 9,11,
	11,11,12,13,11,13,12, 7, 9, 9, 9,11,11, 9,12,10,
	 9,11,10,10,11,12,11,13,12, 9,11,11,11,13,13,11,
	13,11, 5, 8, 8, 8, 9,10, 7,10, 9, 8,10,10,10,11,
	11,10,11,11, 7, 9, 9, 9,11,11, 9,11,10, 7, 9, 9,
	 9,10,12, 9,11,11, 9,11,11,11,11,13,11,13,13, 9,
	10,11,11,12,13,10,12,11, 7, 9, 9, 9,11,11, 9,11,
	10, 9,11,11,11,12,13,11,13,12, 9,11, 9,11,12,11,
	10,13,10,
};

static const static_codebook _44p6_p1_0 = {
	5, 243,
	(long *)_vq_lengthlist__44p6_p1_0,
	1, -535822336, 1611661312, 2, 0,
	(long *)_vq_quantlist__44p6_p1_0,
	0
};

static const long _vq_quantlist__44p6_p2_0[] = {
	2,
	1,
	3,
	0,
	4,
};

static const long _vq_lengthlist__44p6_p2_0[] = {
	 4, 6, 6, 9, 9, 6, 7, 8,10,10, 6, 8, 7,10,10, 8,
	10,10,12,13, 8,10,10,13,12, 6, 8, 8,10,10, 7, 8,
	 9,10,11, 8, 9, 9,11,11,10,10,11,12,13,10,11,11,
	14,13, 6, 8, 8,10,10, 8, 9, 9,11,11, 7, 9, 8,11,
	10,10,11,11,13,14,10,11,10,13,12, 9,10,10,12,12,
	10,10,11,12,13,10,11,11,13,13,12,12,13,12,15,13,
	14,13,15,14, 9,10,10,13,12,10,11,11,13,13,10,11,
	10,13,12,13,13,14,14,15,12,13,12,15,12, 6, 8, 8,
	10,11, 8, 9,10,11,12, 8, 9, 9,11,11,10,11,12,13,
	14,10,11,11,14,13, 8, 9, 9,11,12, 9,10,11,12,13,
	 9,10,11,12,13,11,11,13,13,15,11,12,12,14,14, 8,
	 9, 9,12,12, 9,10,11,12,13, 9,10,10,13,12,11,12,
	13,14,15,11,12,12,14,14,11,11,12,13,14,11,12,13,
	13,15,12,13,13,14,15,13,13,14,14,16,14,15,15,16,
	16,11,12,11,14,13,12,13,13,14,14,11,13,12,14,13,
	14,15,15,16,16,13,14,14,16,14, 6, 8, 8,11,10, 8,
	 9, 9,12,11, 8,10, 9,12,11,10,11,11,13,13,10,12,
	11,14,13, 8, 9, 9,12,12, 9,10,10,12,13, 9,11,10,
	13,12,11,12,12,14,14,11,13,12,15,14, 8, 9, 9,12,
	11, 9,10,10,13,12, 9,11,10,13,12,12,12,12,14,14,
	11,13,12,15,13,11,11,12,13,14,11,12,13,13,14,12,
	13,13,14,15,13,13,14,14,16,14,15,15,16,16,11,12,
	11,14,13,12,13,13,15,14,11,13,12,15,13,14,15,15,
	16,16,13,15,13,16,14, 9,10,11,12,13,11,11,12,13,
	14,11,12,12,13,14,13,13,14,14,16,13,14,14,15,16,
	11,11,12,13,14,12,12,13,14,15,12,13,13,14,15,14,
	14,15,15,17,14,15,15,16,17,11,12,12,14,14,12,13,
	13,14,15,12,13,12,15,15,14,15,15,16,17,14,15,15,
	16,16,13,14,14,15,16,14,14,15,15,17,15,15,15,16,
	17,16,16,17,16,18,16,17,17,18,18,13,14,14,16,15,
	14,15,15,17,16,14,15,15,16,16,16,17,17,18,18,16,
	16,16,17,16, 9,11,10,13,12,11,12,12,14,13,11,12,
	11,15,13,13,14,14,16,15,13,14,13,17,14,11,12,12,
	14,14,12,12,13,15,15,12,13,13,15,14,14,14,15,16,
	16,14,15,15,17,16,11,12,11,14,13,12,13,13,15,14,
	12,13,12,15,13,14,15,15,16,16,14,15,14,17,15,13,
	14,14,15,16,14,15,15,16,17,14,15,15,16,17,16,16,
	16,17,17,16,17,17,18,18,13,15,14,16,15,15,15,15,
	17,16,14,15,14,17,15,16,17,17,18,18,16,17,16,18,
	16, 6, 8, 8,11,11, 8, 9, 9,11,12, 8, 9, 9,12,11,
	10,11,11,13,14,10,12,11,14,13, 7, 9, 9,11,12, 9,
	10,10,12,13, 9,10,10,13,12,11,11,12,13,15,11,12,
	12,15,14, 8, 9, 9,12,11, 9,10,10,13,13, 9,11,10,
	13,12,12,12,12,14,15,11,13,12,15,13,10,11,11,13,
	14,11,12,12,13,15,11,12,12,14,14,13,13,14,14,16,
	14,15,14,16,16,11,12,11,14,13,12,13,13,15,14,11,
	13,12,15,13,14,15,15,16,16,13,14,14,16,14, 8, 9,
	 9,11,12, 9,10,11,12,13, 9,10,10,13,12,11,12,13,
	14,15,11,12,12,15,14, 9, 9,11,11,13,10,10,12,12,
	14,10,10,11,13,14,12,12,13,14,16,12,13,13,15,15,
	 9,11,10,13,12,10,11,11,13,14,10,12,11,14,13,12,
	13,13,15,16,12,13,13,15,15,11,11,13,13,15,12,12,
	14,13,15,13,13,14,14,15,14,14,15,14,17,15,15,15,
	16,16,12,13,12,15,14,13,14,14,15,15,12,14,13,15,
	14,15,15,15,17,17,14,15,14,17,15, 7, 9, 9,12,11,
	 9,10,10,12,12, 9,11,10,13,12,11,12,12,14,14,11,
	13,12,15,14, 9,10,10,12,12,10,10,11,12,13,10,11,
	11,14,13,12,12,13,14,15,12,13,13,16,15, 9,10,10,
	13,12,10,11,11,13,13,10,11,10,14,12,13,13,13,15,
	15,12,13,12,15,14,11,12,12,14,14,12,12,13,14,15,
	13,14,13,15,15,14,13,15,14,16,15,16,15,17,16,12,
	12,12,14,14,13,13,14,15,15,12,13,12,15,14,15,15,
	16,16,17,14,15,14,17,14,10,11,12,13,14,11,12,13,
	14,15,11,12,13,14,15,13,14,15,15,17,14,15,15,16,
	16,11,12,13,12,15,12,12,14,13,16,13,13,14,13,16,
	14,14,16,14,18,15,15,16,16,17,12,13,12,15,15,13,
	14,14,15,16,13,14,13,16,15,15,15,16,17,18,15,15,
	15,17,16,14,14,15,14,17,15,14,16,14,17,15,15,16,
	15,18,16,16,17,16,19,17,17,17,17,18,14,15,15,17,
	16,15,16,16,17,17,15,16,15,18,16,17,17,18,18,18,
	16,17,16,18,17,10,11,11,14,13,11,12,12,15,14,11,
	13,12,15,14,14,15,15,16,16,14,15,15,17,16,11,12,
	12,15,14,12,13,13,15,14,13,14,13,16,14,14,15,15,
	16,16,15,16,15,18,16,11,13,12,15,15,13,14,14,15,
	15,12,14,13,16,15,15,16,16,17,17,15,16,15,17,16,
	14,15,14,16,16,14,15,15,16,16,15,16,15,17,16,16,
	16,17,16,17,17,18,17,19,18,14,15,15,17,16,15,16,
	16,17,17,15,15,15,18,16,17,18,18,18,18,16,17,16,
	19,16, 6, 8, 8,11,11, 8, 9, 9,11,12, 8, 9, 9,12,
	11,10,11,12,13,14,10,11,11,14,13, 8, 9, 9,11,12,
	 9,10,11,12,13, 9,10,10,13,13,11,12,13,13,15,11,
	12,12,15,14, 7, 9, 9,12,11, 9,10,10,12,13, 9,10,
	10,13,12,11,12,12,14,15,11,12,11,14,13,11,11,12,
	13,14,11,12,13,13,15,12,13,13,14,15,13,14,14,14,
	16,14,15,15,16,16,10,11,11,14,13,11,12,12,14,14,
	11,12,12,15,13,14,14,14,16,16,13,14,13,16,14, 7,
	 9, 9,11,12, 9,10,10,12,13, 9,10,10,12,12,11,12,
	13,14,15,11,12,12,14,14, 9,10,10,12,13,10,10,11,
	12,14,10,11,11,13,13,12,12,13,14,15,13,13,13,15,
	15, 9,10,10,12,12,10,11,11,13,14,10,11,10,13,12,
	12,13,13,15,16,12,13,12,15,14,11,12,13,14,14,12,
	12,13,14,15,13,14,13,15,15,14,14,15,14,17,15,16,
	15,17,16,11,12,12,14,14,13,13,13,15,15,12,13,12,
	15,14,15,15,15,16,17,14,15,14,16,14, 8, 9, 9,12,
	11, 9,10,10,12,13, 9,11,10,13,12,11,12,12,14,15,
	11,12,12,15,14, 9,10,11,13,13,10,11,12,13,14,10,
	11,11,14,13,12,13,13,15,15,12,13,13,16,15, 9,11,
	 9,13,11,10,11,10,14,13,10,12,10,14,12,12,13,13,
	15,15,12,13,12,16,14,12,12,13,14,15,12,13,14,14,
	16,13,14,14,15,15,14,14,15,15,17,15,16,15,17,16,
	11,13,11,15,13,13,14,13,15,14,12,14,12,16,13,15,
	15,15,16,16,14,15,14,17,14,10,11,11,13,14,11,12,
	13,14,15,11,12,12,14,15,14,14,15,16,17,14,15,15,
	16,16,11,12,13,14,15,12,13,14,15,16,13,14,14,15,
	16,15,15,16,16,18,15,16,16,17,17,11,12,12,14,15,
	13,13,14,14,16,12,13,13,15,15,15,15,16,16,18,14,
	15,15,16,16,14,15,15,16,17,15,15,16,16,17,15,16,
	16,17,17,16,16,17,16,19,17,18,17,18,18,14,14,15,
	16,16,15,15,16,16,17,14,15,15,16,16,17,17,18,18,
	19,16,17,16,17,16,10,12,11,14,13,11,13,12,15,14,
	11,13,12,15,14,14,15,15,16,16,13,15,14,17,15,12,
	13,13,15,15,13,13,14,15,16,13,14,14,16,16,14,15,
	15,17,17,15,16,16,17,17,11,13,12,15,12,13,14,13,
	16,13,12,14,12,16,13,15,16,15,17,16,14,16,14,18,
	14,14,15,15,16,17,15,15,16,16,17,15,16,16,17,17,
	16,16,17,17,18,17,18,17,18,18,14,15,14,17,14,15,
	16,15,18,15,15,16,15,18,14,17,17,17,18,17,16,17,
	16,19,16, 9,11,11,13,13,10,12,12,14,14,11,12,12,
	15,14,13,14,14,16,16,13,14,14,16,16,10,11,12,14,
	14,11,12,13,14,15,12,13,13,15,15,13,14,15,16,16,
	14,15,15,17,16,11,12,12,15,14,12,13,13,15,15,12,
	13,12,15,15,14,15,15,16,17,14,15,14,17,16,12,13,
	14,15,16,13,13,14,15,16,13,14,15,16,16,14,15,16,
	16,18,15,16,16,18,18,13,14,14,16,15,14,15,15,17,
	16,14,15,15,17,16,16,17,17,18,18,16,17,16,18,17,
	10,12,12,14,14,11,12,13,15,15,12,13,13,15,15,13,
	14,15,16,17,14,15,15,17,16,11,11,13,14,15,12,12,
	14,15,16,13,13,14,15,16,14,14,15,16,17,15,15,16,
	17,17,12,13,12,15,15,13,14,14,16,16,13,14,13,16,
	15,15,16,15,17,17,15,16,15,18,16,13,12,15,14,17,
	14,13,16,14,17,14,14,16,15,18,15,14,17,16,18,16,
	16,17,17,18,14,15,15,17,16,15,16,16,17,17,15,16,
	15,18,16,17,17,17,18,18,16,17,16,19,17,10,11,11,
	14,14,11,12,12,15,15,11,13,12,15,15,14,15,14,16,
	16,14,15,15,17,16,11,12,12,15,14,12,12,13,15,15,
	13,14,13,16,15,14,15,15,16,16,15,16,15,18,17,11,
	13,12,15,15,13,14,13,15,15,12,14,13,16,15,15,16,
	15,17,17,15,16,15,18,16,13,14,13,16,16,14,15,14,
	16,16,14,15,15,17,16,16,16,16,16,18,16,18,17,19,
	18,14,15,15,17,16,15,16,16,17,17,15,15,15,17,16,
	17,17,18,18,19,16,17,16,18,16,12,13,13,15,16,13,
	14,14,16,17,13,14,14,16,16,15,15,16,17,18,15,16,
	16,18,17,13,13,14,14,17,14,14,15,15,17,14,14,15,
	16,17,15,15,17,16,18,16,17,17,18,18,13,14,14,17,
	16,14,15,15,17,17,14,15,14,17,16,16,17,17,18,18,
	16,17,16,18,17,15,14,16,13,18,16,15,17,14,19,16,
	16,17,15,18,17,16,18,15,19,18,18,18,17,19,15,16,
	16,18,17,16,17,17,18,18,16,17,16,19,17,18,19,18,
	19,19,17,18,17,20,18,11,12,12,15,15,13,13,14,15,
	16,13,14,13,16,15,15,16,16,17,17,15,16,16,18,17,
	12,14,13,16,15,13,13,14,15,16,14,15,14,17,16,16,
	16,16,16,17,16,17,17,19,17,12,13,14,16,16,14,15,
	15,16,17,13,15,13,17,15,16,17,17,18,18,16,17,16,
	18,16,15,16,15,17,16,15,15,15,17,17,16,17,16,18,
	17,17,16,17,16,18,18,19,18,20,18,15,16,16,17,17,
	16,17,17,18,18,15,16,15,18,17,18,18,19,19,19,17,
	18,16,19,16, 9,11,11,13,13,11,12,12,14,15,10,12,
	12,14,14,13,14,14,16,16,13,14,14,16,16,11,12,12,
	14,14,12,12,13,15,15,12,13,13,15,15,14,15,15,16,
	17,14,15,15,16,16,10,12,11,14,14,12,13,13,15,15,
	11,13,12,15,14,14,15,15,16,17,13,15,14,17,16,13,
	14,14,15,16,14,15,15,16,17,14,15,15,16,17,16,16,
	17,17,18,16,17,17,18,18,12,14,13,16,15,13,15,14,
	17,16,13,14,13,17,15,15,16,16,18,18,15,16,15,18,
	16,10,11,11,14,14,11,12,13,14,15,11,12,12,15,15,
	14,15,15,16,17,14,15,15,16,16,11,12,13,15,15,12,
	13,14,15,16,13,14,14,15,16,15,15,16,16,18,15,15,
	16,17,17,11,12,12,14,15,13,13,14,15,16,12,13,13,
	15,15,15,15,16,17,18,14,15,15,17,16,14,15,15,16,
	17,15,15,16,16,17,15,16,16,17,17,16,16,17,16,19,
	17,17,18,19,18,13,13,14,16,16,14,15,16,17,17,14,
	14,15,16,16,16,16,17,18,18,16,16,16,18,16,10,12,
	12,14,14,12,13,13,15,15,11,13,12,15,15,14,15,15,
	16,17,13,15,14,17,16,12,13,13,15,15,13,13,14,15,
	16,13,14,14,16,16,15,15,16,17,18,15,15,16,17,17,
	11,13,12,15,14,13,14,13,16,15,12,14,12,16,14,15,
	16,15,17,17,14,16,14,17,16,14,15,15,16,17,15,15,
	16,16,18,15,16,16,17,17,16,17,17,17,19,17,17,17,
	18,18,13,15,12,17,14,14,16,14,17,15,14,15,13,17,
	14,16,17,16,18,17,15,17,14,19,15,11,12,12,15,15,
	13,13,14,15,16,13,14,13,16,15,15,16,16,17,18,15,
	16,16,17,17,12,14,13,16,16,13,13,15,15,17,14,15,
	15,17,16,16,16,17,16,19,16,17,17,18,18,12,13,14,
	15,16,14,14,15,16,17,13,14,13,16,15,16,17,17,18,
	19,15,16,16,17,16,15,16,16,18,17,15,15,16,17,18,
	16,17,17,18,18,16,16,18,16,19,18,19,19,20,19,15,
	15,16,16,17,16,16,17,17,18,15,15,15,17,16,18,18,
	19,18,20,17,17,16,18,16,12,13,13,16,15,13,14,14,
	16,16,13,14,14,16,16,15,16,16,17,18,15,16,15,18,
	17,13,14,14,16,16,14,15,15,16,17,14,15,15,17,17,
	16,17,17,18,18,16,17,17,18,18,13,14,13,17,14,14,
	15,14,17,16,14,15,14,17,15,16,17,17,18,18,15,17,
	15,19,15,16,16,16,17,18,16,16,17,17,19,16,17,17,
	18,19,17,17,18,18,20,18,18,18,19,19,15,16,14,18,
	13,16,17,16,19,15,16,17,15,19,14,18,18,18,19,17,
	17,18,16,20,15,
};

static const static_codebook _44p6_p2_0 = {
	5, 3125,
	(long *)_vq_lengthlist__44p6_p2_0,
	1, -533725184, 1611661312, 3, 0,
	(long *)_vq_quantlist__44p6_p2_0,
	0
};

static const long _vq_quantlist__44p6_p3_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p6_p3_0[] = {
	 1, 5, 5, 5, 7, 8, 5, 8, 7, 5, 7, 8, 8, 8,10, 8,
	10,10, 5, 8, 7, 8,10,10, 8,10, 8, 6, 8, 9, 8,10,
	12, 9,11,11, 9,10,11,11,11,13,12,13,13, 9,11,11,
	11,13,13,11,13,12, 6, 9, 8, 9,11,11, 8,12,10, 9,
	11,11,11,12,13,11,13,13, 9,11,10,11,13,13,11,13,
	11, 5, 9, 9, 8,11,11, 9,12,11, 8,10,11,10,11,13,
	11,13,13, 9,11,11,11,13,13,11,13,12, 8,10,11,10,
	12,13,10,13,12,10,10,13,11,11,14,12,13,14,11,13,
	12,13,14,14,12,14,12, 8,11,10,11,12,13,11,14,12,
	10,13,12,12,12,13,13,15,14,11,12,13,13,14,15,12,
	14,12, 5, 9, 9, 9,11,12, 8,11,11, 9,11,11,11,12,
	13,11,13,13, 8,11,10,11,13,13,10,13,11, 8,10,11,
	11,12,14,11,13,12,11,13,12,12,12,14,13,15,14,10,
	12,13,13,14,15,12,13,12, 8,11,10,10,12,13,10,13,
	12,11,12,13,12,12,14,13,14,14,10,13,10,12,14,13,
	11,14,11,
};

static const static_codebook _44p6_p3_0 = {
	5, 243,
	(long *)_vq_lengthlist__44p6_p3_0,
	1, -533200896, 1614282752, 2, 0,
	(long *)_vq_quantlist__44p6_p3_0,
	0
};

static const long _vq_quantlist__44p6_p3_1[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p6_p3_1[] = {
	 5, 7, 7, 6, 7, 7, 6, 7, 7, 6, 7, 7, 7, 8, 8, 7,
	 8, 8, 6, 7, 7, 7, 8, 8, 7, 8, 8, 7, 7, 8, 7, 8,
	 8, 7, 8, 8, 8, 8, 8, 8, 8, 9, 8, 9, 9, 8, 8, 8,
	 8, 9, 9, 8, 9, 8, 7, 8, 7, 7, 8, 8, 7, 8, 8, 8,
	 8, 8, 8, 8, 9, 8, 9, 9, 8, 8, 8, 8, 9, 9, 8, 9,
	 8, 6, 8, 8, 7, 8, 8, 7, 8, 8, 7, 8, 8, 8, 8, 9,
	 8, 9, 9, 8, 8, 8, 8, 9, 9, 8, 9, 8, 7, 8, 8, 8,
	 8, 9, 8, 9, 9, 8, 8, 9, 8, 9, 9, 9, 9, 9, 8, 9,
	 9, 9, 9, 9, 9, 9, 9, 7, 8, 8, 8, 9, 9, 8, 9, 8,
	 8, 8, 8, 8, 9, 9, 9, 9, 9, 8, 9, 8, 9, 9, 9, 9,
	 9, 9, 6, 8, 8, 7, 8, 8, 7, 8, 8, 8, 8, 8, 8, 8,
	 9, 8, 9, 9, 7, 8, 8, 8, 9, 9, 8, 9, 8, 7, 8, 8,
	 8, 8, 9, 8, 9, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 8,
	 8, 8, 9, 9, 9, 8, 9, 9, 7, 8, 8, 8, 9, 9, 8, 9,
	 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 8, 9, 8, 9, 9, 9,
	 9, 9, 9,
};

static const static_codebook _44p6_p3_1 = {
	5, 243,
	(long *)_vq_lengthlist__44p6_p3_1,
	1, -535822336, 1611661312, 2, 0,
	(long *)_vq_quantlist__44p6_p3_1,
	0
};

static const long _vq_quantlist__44p6_p4_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p6_p4_0[] = {
	 2, 5, 5, 5, 7, 8, 5, 8, 7, 5, 7, 7, 7, 7, 9, 7,
	 9, 9, 5, 7, 7, 8, 9, 9, 7, 9, 7, 6, 8, 8, 8, 9,
	10, 8, 9, 9, 8, 9,10, 9, 9,11,10,11,11, 8, 9, 9,
	10,11,11, 9,11,10, 6, 8, 8, 8, 9, 9, 8,10, 9, 8,
	 9, 9, 9,10,11,10,11,10, 8,10, 9,10,11,11, 9,11,
	 9, 6, 8, 8, 7, 9, 9, 8,10, 9, 7, 9, 9, 9, 9,10,
	 9,10,10, 8, 9, 9, 9,10,10, 9,11,10, 7, 9, 9, 8,
	10,10, 9,10,10, 9, 9,10,10,10,11,10,11,11, 9,10,
	10,10,11,11,10,11,10, 7, 9, 9, 9, 9,10, 9,10, 9,
	 8,10, 9, 9, 9,11,10,11,11, 9,10,10,10,11,11, 9,
	11, 9, 6, 8, 8, 8, 9,10, 7, 9, 9, 8, 9, 9, 9,10,
	10, 9,10,10, 7, 9, 9, 9,10,10, 9,10, 9, 7, 9, 9,
	 9, 9,10, 9,10, 9, 9,10,10, 9, 9,11,10,11,11, 8,
	 9,10,10,11,11, 9,11, 9, 7, 9, 9, 9,10,10, 8,10,
	10, 9,10,10,10,10,11,10,11,11, 9,10, 9,10,11,11,
	10,11,10,
};

static const static_codebook _44p6_p4_0 = {
	5, 243,
	(long *)_vq_lengthlist__44p6_p4_0,
	1, -531365888, 1616117760, 2, 0,
	(long *)_vq_quantlist__44p6_p4_0,
	0
};

static const long _vq_quantlist__44p6_p4_1[] = {
	2,
	1,
	3,
	0,
	4,
};

static const long _vq_lengthlist__44p6_p4_1[] = {
	 6, 8, 8,10,10, 8, 9, 9,10,11, 8,10, 9,11,10, 9,
	10,10,11,11, 9,10,10,11,11, 8, 9, 9,10,10, 9, 9,
	10,11,11,10,10,10,11,11,10,11,11,11,11,10,11,11,
	11,11, 8, 9, 9,11,10,10,10,10,11,11, 9,10, 9,11,
	11,10,11,11,11,11,10,11,10,11,11,10,10,11,11,11,
	10,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
	11,11,11,11,10,11,10,11,11,11,11,11,11,11,10,11,
	11,11,11,11,11,11,11,11,11,11,11,11,11, 8, 9,10,
	11,11,10,10,11,11,11,10,10,10,11,11,10,11,11,12,
	12,10,11,11,12,12,10,10,11,11,11,10,10,11,11,12,
	11,11,11,12,12,11,11,12,12,12,11,11,12,12,12,10,
	10,10,11,11,11,11,11,12,12,10,11,11,12,12,11,12,
	12,12,12,11,12,11,12,12,11,11,11,11,12,11,11,12,
	12,12,11,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,11,11,11,12,11,11,12,12,12,12,11,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12, 8,10, 9,11,11,10,
	10,10,11,11,10,11,10,11,11,10,11,11,12,12,10,11,
	11,12,12,10,10,10,11,11,10,11,11,12,12,11,11,11,
	12,12,11,11,12,12,12,11,12,12,12,12,10,11,10,11,
	11,11,11,11,12,12,10,11,10,12,11,11,12,11,12,12,
	11,12,11,12,12,11,11,11,12,12,11,11,12,12,12,11,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,11,11,
	11,12,11,11,12,12,12,12,11,12,11,12,12,12,12,12,
	12,12,12,12,12,12,12,10,11,11,11,12,11,11,12,12,
	12,11,11,11,12,12,11,12,12,12,12,11,12,12,12,12,
	11,11,12,12,12,11,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,13,11,12,11,12,12,12,12,
	12,12,12,11,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,13,12,13,12,12,12,12,13,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,13,13,13,13,12,
	12,12,13,12,10,11,11,12,11,11,11,12,12,12,11,12,
	11,12,12,11,12,12,12,12,11,12,12,12,12,11,11,12,
	12,12,11,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,11,12,11,12,12,12,12,12,12,12,
	11,12,12,12,12,12,12,12,12,12,12,12,12,13,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,13,12,12,12,12,13,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,13,13,12,13,12,13,
	12, 8,10,10,11,11,10,10,11,11,11,10,11,10,11,11,
	10,11,11,12,12,10,11,11,12,12, 9,10,11,11,11,10,
	10,11,12,12,10,11,11,12,12,11,11,12,12,12,11,12,
	12,12,12,10,11,10,11,11,11,11,11,12,12,10,11,11,
	12,12,11,12,12,12,12,11,12,11,12,12,11,11,11,12,
	12,11,11,12,12,12,11,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,11,11,11,12,12,11,12,12,12,12,11,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12, 9,10,
	10,11,11,10,11,11,12,12,10,11,11,12,12,11,11,12,
	12,12,11,12,12,12,12,10,11,11,12,12,11,11,12,12,
	12,11,11,12,12,12,11,11,12,12,12,12,12,12,12,12,
	10,11,11,12,12,11,12,12,12,12,11,12,11,12,12,12,
	12,12,12,12,12,12,12,12,12,11,11,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,11,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12, 9,10,10,11,11,
	10,11,11,12,12,10,11,11,12,11,11,12,12,12,12,11,
	12,12,12,12,10,11,11,12,12,11,11,11,12,12,11,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,10,11,11,
	12,12,11,12,12,12,12,11,12,11,12,12,12,12,12,12,
	12,12,12,12,12,12,11,12,12,12,12,11,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,11,
	12,12,12,12,12,12,12,12,12,11,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,11,11,11,12,12,11,12,12,
	12,12,11,12,12,12,12,12,12,12,12,12,12,12,12,12,
	13,11,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,13,12,13,12,12,13,13,13,11,12,12,12,12,12,
	12,12,13,13,12,12,12,13,12,12,12,12,13,13,12,13,
	12,13,13,12,12,12,12,12,12,12,12,12,13,12,13,13,
	13,13,12,13,13,13,13,13,13,13,13,13,12,12,12,12,
	12,12,12,13,13,13,12,13,12,13,13,12,13,13,13,13,
	12,13,13,13,13,11,11,11,12,12,11,12,12,12,12,11,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,11,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,13,
	12,13,12,12,12,13,13,11,12,12,12,12,12,12,12,12,
	13,12,12,12,13,12,12,13,12,13,13,12,13,12,13,13,
	12,12,12,12,12,12,12,13,13,13,12,12,13,13,13,12,
	13,13,12,13,13,13,13,13,13,12,12,12,12,12,12,13,
	12,13,13,12,13,12,13,12,12,13,13,13,13,12,13,13,
	13,13, 8,10,10,11,11,10,10,11,11,11, 9,11,10,11,
	11,10,11,11,12,12,10,11,11,12,12,10,10,11,11,11,
	10,11,11,12,12,11,11,11,12,12,11,11,12,12,12,11,
	12,12,12,12, 9,11,10,11,11,10,11,11,12,12,10,11,
	10,12,12,11,12,12,12,12,11,12,11,12,12,11,11,11,
	12,12,11,12,12,12,12,11,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,11,11,11,12,12,11,12,12,12,12,
	11,12,11,12,12,12,12,12,12,12,12,12,12,12,12, 9,
	10,10,11,11,10,11,11,12,12,10,11,11,12,12,11,12,
	12,12,12,11,12,12,12,12,10,11,11,12,12,11,11,12,
	12,12,11,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,10,11,11,12,12,11,11,12,12,12,11,11,11,12,12,
	12,12,12,12,12,11,12,12,12,12,11,12,12,12,12,11,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,11,12,12,12,12,12,12,12,12,12,11,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12, 9,10,10,11,
	11,10,11,11,12,12,10,11,11,12,12,11,12,12,12,12,
	11,12,11,12,12,10,11,11,12,12,11,11,12,12,12,11,
	11,12,12,12,12,12,12,12,12,12,12,12,12,12,10,11,
	11,12,12,11,12,11,12,12,11,12,11,12,12,12,12,12,
	12,12,11,12,11,12,12,11,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	11,12,11,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,11,11,11,12,12,11,12,
	12,12,12,11,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,11,12,12,12,12,12,12,12,12,12,12,12,12,13,
	13,12,12,12,13,13,12,12,13,13,13,11,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,13,12,13,13,12,
	12,12,13,12,12,12,12,12,12,12,12,13,13,13,12,12,
	13,13,13,12,13,13,12,13,12,13,13,13,13,12,12,12,
	12,12,12,12,13,13,13,12,12,12,13,12,12,13,13,13,
	13,12,13,13,13,13,11,11,11,12,12,11,12,12,12,12,
	11,12,12,12,12,12,12,12,12,12,12,12,12,12,12,11,
	12,12,12,12,12,12,12,12,12,12,12,12,13,12,12,12,
	13,13,13,12,12,12,13,13,11,12,12,12,12,12,12,12,
	13,12,12,12,12,13,12,12,13,12,13,13,12,13,12,13,
	12,12,12,12,12,12,12,12,13,13,13,12,13,13,13,13,
	12,13,13,13,13,13,13,13,13,13,12,12,12,12,12,12,
	13,12,13,12,12,13,12,13,12,13,13,13,13,13,12,13,
	13,13,13,10,11,11,12,12,11,12,12,12,12,11,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,11,11,12,12,
	12,11,12,12,12,12,12,12,12,12,12,12,12,12,13,13,
	12,12,12,13,13,11,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,13,13,12,12,12,13,12,12,12,
	12,12,12,12,12,12,12,13,12,12,12,12,13,12,12,13,
	12,13,12,13,13,13,13,12,12,12,12,12,12,12,12,13,
	12,12,12,12,13,12,12,13,13,13,13,12,13,12,13,13,
	11,11,11,12,12,11,12,12,12,12,11,12,12,12,12,12,
	12,12,12,13,12,12,12,13,12,11,12,12,12,12,12,12,
	12,12,13,12,12,12,12,13,12,12,13,13,13,12,12,13,
	13,13,11,12,12,12,12,12,12,12,12,13,12,12,12,13,
	12,12,13,12,13,13,12,13,12,13,13,12,12,12,12,12,
	12,12,13,12,13,12,12,13,13,13,12,12,13,13,13,13,
	13,13,13,13,12,12,12,12,12,12,13,13,13,13,12,13,
	12,13,12,12,13,13,13,13,12,13,13,13,13,11,11,11,
	12,12,11,12,12,12,12,11,12,12,12,12,12,12,12,12,
	12,12,12,12,12,13,11,12,12,12,12,12,12,12,12,13,
	12,12,12,13,13,12,12,13,13,13,12,12,13,13,13,11,
	12,12,12,12,12,12,12,13,13,12,12,12,13,12,12,13,
	12,13,13,12,13,12,13,13,12,12,12,12,12,12,12,12,
	12,13,12,13,12,13,13,12,13,13,13,13,12,13,13,13,
	13,12,12,12,12,12,12,13,12,13,13,12,12,12,13,13,
	12,13,13,13,13,12,13,12,13,13,11,12,12,12,12,11,
	12,12,12,12,11,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,11,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,13,12,13,12,12,12,13,13,11,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,13,13,
	12,13,12,13,13,12,12,12,12,12,12,12,13,12,13,12,
	12,13,12,13,12,12,13,12,13,12,13,13,13,13,12,12,
	12,12,12,12,12,12,12,12,12,12,12,13,12,12,13,13,
	13,13,12,13,12,13,12,11,11,11,12,12,11,12,12,12,
	12,11,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	11,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,13,13,11,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,13,13,12,12,12,
	13,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,13,12,12,12,13,12,12,12,12,12,12,12,12,
	12,12,12,13,12,12,12,12,13,12,12,13,12,13,12,12,
	13,12,13,12,10,11,11,12,12,11,12,12,12,12,11,12,
	11,12,12,11,12,12,12,12,11,12,12,12,12,11,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	13,12,12,12,13,13,11,12,11,12,12,12,12,12,12,12,
	11,12,12,12,12,12,12,12,13,13,12,12,12,13,12,12,
	12,12,12,12,12,12,12,12,13,12,12,12,12,13,12,13,
	13,12,13,12,13,13,13,13,12,12,12,12,12,12,12,12,
	13,13,12,12,12,13,12,12,13,13,13,13,12,13,12,13,
	12,11,11,11,12,12,11,12,12,12,12,11,12,12,12,12,
	12,12,12,13,13,12,12,12,13,12,11,12,12,12,12,12,
	12,12,12,13,12,12,12,13,13,12,12,13,13,13,12,12,
	13,13,13,11,12,12,12,12,12,12,12,13,13,12,12,12,
	13,12,12,13,12,13,13,12,12,12,13,13,12,12,12,12,
	12,12,12,13,13,13,12,12,13,13,13,12,12,13,13,13,
	12,13,13,13,13,12,12,12,12,12,12,12,13,13,13,12,
	12,12,13,12,12,13,13,13,13,12,13,13,13,13,11,11,
	11,12,12,11,12,12,12,12,11,12,12,12,12,12,12,12,
	12,13,12,12,12,13,13,11,12,12,12,12,12,12,12,12,
	13,12,12,12,13,13,12,12,13,13,13,12,12,13,13,13,
	11,12,12,12,12,12,12,12,13,12,12,12,12,13,12,12,
	13,12,13,13,12,13,12,13,13,12,12,12,12,12,12,12,
	12,13,13,12,13,12,13,13,12,13,13,13,13,13,13,13,
	13,13,12,12,12,12,12,12,13,12,13,13,12,13,12,13,
	12,12,13,13,13,13,12,13,12,13,13,11,11,11,12,12,
	11,12,12,12,12,11,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,11,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,13,12,12,12,13,13,11,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,13,
	13,12,12,12,12,12,12,12,12,12,12,12,12,12,12,13,
	12,12,12,12,13,12,12,12,12,13,12,12,13,12,13,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	13,12,12,12,13,12,12,12,11,12,11,12,12,11,12,12,
	12,12,11,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,11,12,12,12,12,12,12,12,12,13,12,12,12,12,12,
	12,12,12,13,13,12,12,12,13,13,11,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,13,12,13,13,12,12,
	12,13,12,12,12,12,12,12,12,12,12,12,13,12,12,12,
	13,13,12,12,13,12,13,12,13,13,13,13,12,12,12,12,
	12,12,12,12,13,12,12,12,12,13,12,12,13,12,13,13,
	12,13,12,13,12,
};

static const static_codebook _44p6_p4_1 = {
	5, 3125,
	(long *)_vq_lengthlist__44p6_p4_1,
	1, -533725184, 1611661312, 3, 0,
	(long *)_vq_quantlist__44p6_p4_1,
	0
};

static const long _vq_quantlist__44p6_p5_0[] = {
	2,
	1,
	3,
	0,
	4,
};

static const long _vq_lengthlist__44p6_p5_0[] = {
	 2, 6, 6,10,10, 5, 7, 8,11,12, 5, 8, 7,12,11, 9,
	11,11,13,15, 9,11,11,15,13, 6, 7, 8,11,11, 7, 7,
	 9,11,13, 8, 9, 9,13,12,11,11,12,12,15,11,12,12,
	15,14, 6, 8, 7,11,11, 8, 9, 9,12,13, 7, 9, 7,13,
	11,11,12,12,14,15,11,12,11,15,12,10,11,11,12,14,
	10,11,12,12,15,12,13,13,14,15,13,12,14,12,16,15,
	15,15,16,16,10,11,11,14,12,12,13,13,15,14,10,12,
	11,15,12,15,15,15,16,17,13,14,12,17,12, 6, 8, 8,
	12,12, 8, 9,10,13,13, 8, 9, 9,13,13,12,12,13,15,
	16,12,13,13,16,15, 8, 9,10,12,13, 9, 9,11,13,14,
	10,11,11,14,14,13,13,14,15,16,13,14,14,16,16, 8,
	10, 9,13,13,10,11,11,14,14, 9,10,10,14,13,13,14,
	14,16,17,13,13,13,16,15,12,13,13,14,16,13,13,14,
	14,16,14,14,14,16,16,15,15,16,15,18,16,17,17,18,
	18,12,13,13,15,15,14,14,14,16,16,13,14,13,16,15,
	16,16,17,18,18,15,16,15,18,15, 6, 8, 8,12,12, 8,
	 9, 9,13,13, 8,10, 9,13,13,12,13,13,15,16,12,13,
	12,16,15, 8, 9,10,13,13, 9,10,10,13,14,10,11,11,
	14,14,13,13,13,15,16,13,14,14,17,16, 8,10, 9,13,
	13,10,11,11,14,14, 9,11, 9,14,13,13,14,14,16,16,
	13,14,13,16,14,12,13,13,15,16,13,13,14,15,16,14,
	14,14,16,16,15,15,16,15,18,17,17,17,18,18,12,13,
	13,16,14,14,14,14,16,16,13,14,13,16,14,16,17,17,
	18,18,15,16,15,18,15,11,12,13,14,16,13,13,14,15,
	17,13,14,14,16,17,16,16,17,17,19,16,17,17,18,19,
	13,13,14,16,16,14,14,15,16,17,14,15,15,17,17,17,
	16,17,17,19,17,17,18,19,19,13,14,14,16,16,14,14,
	15,17,18,14,15,14,17,17,17,17,18,18,19,17,17,17,
	18,19,16,16,16,17,18,17,17,17,18,19,17,17,17,18,
	19,18,18,19,18,20,19,20,19,21,20,16,17,17,18,18,
	17,17,18,19,19,17,17,17,19,18,19,19,19,19,20,19,
	19,19,20,19,11,13,12,16,14,13,14,14,17,16,13,14,
	13,17,15,16,17,17,18,18,16,17,16,19,17,13,14,14,
	16,16,14,14,14,17,17,14,15,15,17,16,17,17,17,19,
	19,17,18,17,19,18,13,14,13,17,16,14,15,15,17,17,
	14,15,14,18,16,17,17,17,19,19,17,17,16,19,17,16,
	17,17,18,19,17,17,17,18,18,17,18,17,19,18,18,19,
	18,19,19,19,20,19,20,20,16,17,16,18,17,17,17,17,
	18,18,17,18,17,19,17,19,19,19,19,20,18,19,19,20,
	18, 6, 8, 8,12,12, 8, 9, 9,13,13, 8,10, 9,13,13,
	11,13,13,15,16,12,13,13,16,15, 8, 9, 9,13,13, 9,
	 9,10,13,14,10,11,11,14,14,12,12,13,14,16,13,14,
	14,17,16, 8,10, 9,13,13,10,11,11,14,14, 9,11,10,
	14,13,13,14,14,16,16,13,14,13,16,15,12,13,13,14,
	16,12,13,14,14,16,13,14,14,16,16,15,14,16,15,18,
	16,17,17,18,17,12,13,13,16,15,14,14,14,16,16,13,
	14,13,16,15,16,16,17,17,17,15,16,15,18,15, 7, 9,
	 9,13,13, 9, 9,11,13,14, 9,10,10,14,13,12,13,14,
	15,16,12,14,13,17,15, 9, 9,10,13,14,10, 9,11,13,
	15,11,11,11,14,14,13,12,14,14,17,14,14,14,17,16,
	 9,10,10,14,13,11,11,11,14,14,10,11,10,15,13,14,
	14,14,16,17,13,14,13,17,14,13,13,14,14,16,13,13,
	14,14,17,14,14,14,16,16,15,14,16,15,18,17,17,17,
	18,18,13,14,13,16,15,14,14,15,17,16,13,14,13,17,
	15,17,16,17,17,17,15,16,14,18,14, 7, 9, 9,13,13,
	 9,10,10,13,14, 9,11,10,14,13,13,14,14,16,16,13,
	14,14,17,15, 9,10,10,14,13, 9,10,11,13,14,11,12,
	11,15,14,13,13,14,14,16,14,15,15,17,17, 9,10,10,
	14,14,11,12,12,14,15,10,11,10,15,13,14,15,15,17,
	17,14,15,13,17,14,13,14,13,16,16,13,13,14,15,16,
	14,15,15,17,17,15,14,16,15,18,17,18,17,20,18,13,
	14,14,16,16,15,15,15,17,17,13,14,13,17,15,17,17,
	18,18,18,15,16,14,19,14,12,13,13,15,16,13,13,15,
	16,17,13,14,14,16,16,15,15,17,17,19,16,17,17,19,
	18,13,13,14,15,17,14,13,15,15,17,14,15,15,16,17,
	16,15,18,16,19,17,17,17,18,19,13,14,14,17,16,14,
	15,15,17,17,14,15,14,17,16,17,17,17,18,19,16,17,
	16,19,17,16,16,17,16,18,16,16,17,16,19,17,17,18,
	18,19,18,17,18,17,21,19,19,19,20,19,16,17,17,18,
	18,17,17,18,18,19,16,17,16,18,18,19,19,19,19,20,
	18,18,17,20,18,11,13,13,16,15,13,14,14,16,17,13,
	15,14,17,16,16,17,17,18,18,17,17,17,19,18,13,14,
	13,17,16,14,13,14,16,17,15,16,15,18,16,17,16,17,
	17,19,18,18,18,20,18,13,14,14,16,17,15,15,15,17,
	18,14,15,14,18,16,18,18,18,19,20,17,18,16,20,17,
	16,17,16,18,18,16,16,17,18,18,17,18,18,19,18,18,
	17,19,17,20,19,20,19,22,20,16,16,17,18,18,18,17,
	17,19,19,16,17,16,18,17,19,20,19,22,21,18,19,18,
	21,17, 6, 8, 8,12,12, 8, 9,10,13,13, 8, 9, 9,13,
	13,12,13,13,15,16,11,13,13,16,15, 8, 9,10,13,13,
	 9,10,11,13,14,10,11,11,14,14,13,13,14,15,16,13,
	14,14,16,16, 8, 9, 9,13,13,10,11,11,14,14, 9,10,
	 9,14,13,13,14,14,16,17,12,14,12,16,14,12,13,13,
	15,16,13,13,14,15,16,13,14,14,15,17,15,15,16,15,
	18,16,16,17,17,17,12,13,13,16,14,13,14,14,16,16,
	12,14,13,16,14,16,17,17,18,18,15,15,14,18,14, 7,
	 9, 9,13,13, 9,10,11,13,14, 9,10,10,14,13,13,14,
	14,15,17,13,14,14,16,15, 9,10,10,14,14,10,10,11,
	13,15,11,12,12,15,14,14,13,15,14,17,14,15,15,17,
	17, 9,10,10,13,14,11,11,12,14,15, 9,11,10,14,13,
	14,15,15,16,18,13,14,13,16,14,13,14,14,16,16,13,
	13,14,15,17,15,15,15,16,17,15,14,16,15,18,17,17,
	18,19,18,13,14,14,16,16,14,15,15,17,17,13,14,13,
	16,15,17,17,18,18,18,15,16,14,18,15, 7, 9, 9,13,
	13, 9,10,10,13,14, 9,11,10,14,13,12,13,14,15,16,
	12,14,13,16,15, 9,10,10,13,14,10,10,11,13,14,11,
	11,11,15,14,13,13,14,14,16,14,14,14,17,16, 9,10,
	 9,14,13,11,11,11,14,14,10,11, 9,15,13,14,14,14,
	16,16,13,14,12,17,14,13,13,14,15,16,13,13,14,15,
	16,14,15,14,16,17,15,14,16,14,18,16,17,17,18,18,
	13,14,13,16,14,14,14,14,16,16,13,14,13,17,14,17,
	17,17,18,18,15,16,14,18,15,11,13,13,16,16,13,14,
	15,16,17,13,14,14,17,16,16,17,17,18,19,17,17,17,
	19,18,13,14,14,17,17,13,13,15,16,18,15,15,15,17,
	17,17,16,18,17,20,18,17,18,19,19,13,14,14,16,17,
	15,15,16,16,18,14,15,14,16,16,17,17,18,18,20,17,
	18,16,18,17,16,17,16,19,18,16,16,17,18,19,18,18,
	18,19,19,18,17,18,17,21,20,19,19,21,21,16,16,17,
	18,18,17,17,18,19,19,16,17,16,19,18,20,20,20,19,
	21,18,18,17,20,18,12,13,13,16,15,13,14,14,16,16,
	13,14,13,17,16,16,17,17,18,18,15,17,15,19,17,13,
	14,14,16,17,14,14,15,16,17,14,15,15,17,17,16,16,
	17,17,18,17,17,17,19,19,13,14,13,17,15,14,15,15,
	17,16,14,15,13,17,15,17,18,17,19,18,16,17,15,20,
	16,16,17,17,18,18,16,16,17,18,18,17,18,17,19,18,
	17,17,18,18,20,19,20,19,20,19,16,16,16,19,16,17,
	17,17,19,18,16,17,16,19,16,19,19,19,19,19,18,19,
	17,19,17,11,13,13,16,16,13,14,14,17,17,13,14,14,
	17,17,15,17,17,19,19,16,18,17,20,19,12,14,14,17,
	17,13,14,15,17,18,14,15,15,17,18,16,16,17,18,20,
	17,18,18,20,18,13,14,14,17,17,14,15,15,17,18,14,
	15,15,17,17,17,18,17,19,19,17,18,17,19,19,15,16,
	16,18,18,15,16,17,18,19,16,17,17,19,19,17,17,18,
	18,21,18,19,19,21,19,16,17,17,18,18,17,17,18,19,
	19,17,18,17,19,19,19,19,19,20,20,18,19,18,21,19,
	12,13,13,16,16,13,14,14,16,17,13,15,14,17,16,15,
	16,17,17,19,16,17,17,19,18,13,13,14,16,17,14,13,
	15,16,17,14,15,15,17,17,15,15,17,17,20,17,17,18,
	19,18,13,14,14,17,16,15,15,15,17,18,14,15,14,17,
	16,17,17,17,18,18,16,17,16,19,17,16,15,17,17,19,
	16,15,17,16,19,17,16,17,18,19,17,16,19,16,20,19,
	18,19,19,19,16,17,17,18,18,17,17,17,18,19,16,17,
	16,19,18,20,19,19,20,19,18,18,17,20,17,11,13,13,
	16,16,13,14,15,16,17,14,15,14,18,16,17,17,17,18,
	21,17,18,17,20,19,13,14,14,17,16,13,14,15,16,18,
	15,16,15,18,17,17,16,17,17,19,17,18,18,20,19,13,
	14,14,16,17,15,15,16,17,18,14,15,14,18,17,17,18,
	18,19,20,17,18,16,19,17,16,17,15,19,18,16,16,16,
	18,18,17,18,17,20,19,18,17,18,17,20,20,20,19,22,
	20,16,17,17,18,19,18,18,18,19,20,16,17,16,19,18,
	20,19,19,20,20,18,19,17,20,17,13,14,14,16,17,14,
	14,16,16,18,14,16,15,17,16,16,16,17,17,18,17,17,
	16,19,18,14,14,15,16,17,14,14,16,16,18,16,16,16,
	17,17,16,15,17,16,19,18,18,18,19,19,14,15,15,17,
	17,15,16,16,17,18,14,16,14,18,16,17,17,18,18,19,
	16,17,16,19,17,16,16,17,16,18,16,16,17,16,19,18,
	18,18,17,18,17,16,18,16,20,19,19,19,19,19,16,17,
	17,18,18,17,17,18,19,19,16,17,16,19,17,18,19,19,
	19,20,17,18,16,20,16,11,14,13,17,17,14,14,16,16,
	18,14,16,14,19,16,18,18,19,18,19,18,19,18,21,18,
	13,15,14,18,16,14,14,16,16,18,16,17,16,19,17,18,
	16,19,17,20,19,19,19,21,19,13,14,15,17,18,17,16,
	17,17,19,14,16,14,18,16,20,19,19,20,21,18,19,16,
	21,17,17,18,16,19,17,16,16,17,18,18,19,19,18,21,
	18,17,17,18,17,20,20,20,20,22,20,17,17,18,18,20,
	19,19,19,18,20,16,17,17,19,19,21,21,21,20,21,17,
	19,17,23,17,11,13,13,16,16,13,14,14,17,17,13,14,
	14,17,17,16,17,17,19,20,15,16,16,19,19,13,14,14,
	16,17,14,15,15,17,18,14,15,15,17,17,17,17,18,19,
	19,17,17,18,19,19,13,14,14,17,16,14,15,15,17,17,
	13,15,14,18,17,17,18,18,19,20,16,17,16,19,18,16,
	16,17,18,18,17,17,17,18,19,17,18,17,19,19,19,19,
	19,19,20,19,20,19,20,20,15,16,16,18,17,16,17,17,
	20,18,15,16,16,19,17,19,19,19,20,20,17,18,17,21,
	17,11,13,13,16,16,13,14,15,16,17,13,15,14,17,16,
	17,17,18,18,20,17,17,17,19,19,13,14,14,17,17,14,
	14,15,17,18,15,15,15,18,17,17,17,18,17,20,18,18,
	17,20,18,13,14,14,16,17,15,15,16,17,18,14,15,13,
	17,17,17,18,18,19,20,17,17,16,19,17,16,17,17,18,
	18,16,16,17,18,18,18,18,18,19,19,18,17,19,18,21,
	19,20,20,20,20,16,15,17,18,18,17,17,18,18,20,16,
	16,16,18,17,20,19,20,21,22,17,18,17,20,17,12,13,
	13,16,16,13,14,15,16,17,13,14,14,17,16,16,17,18,
	18,19,15,16,16,19,18,13,14,14,16,17,14,14,15,16,
	17,14,15,15,17,17,16,16,17,17,19,17,17,17,19,18,
	13,14,13,17,16,14,15,15,17,17,13,15,13,17,16,17,
	17,17,19,19,15,17,15,19,17,16,17,17,18,18,16,16,
	17,17,19,17,18,17,19,19,18,17,19,17,19,19,19,19,
	20,19,15,17,15,19,16,17,17,16,19,18,16,17,15,18,
	16,19,19,19,20,19,17,19,16,19,16,11,14,14,17,17,
	15,14,16,16,18,15,16,14,18,16,18,18,19,18,21,18,
	19,18,20,18,13,15,14,18,17,14,14,16,16,18,16,17,
	16,19,17,17,17,19,17,22,19,19,19,21,19,13,14,15,
	17,18,17,16,17,17,19,14,16,14,18,16,19,19,19,20,
	21,18,18,16,20,17,17,18,16,19,18,15,17,17,19,19,
	19,19,18,21,19,18,17,20,17,21,22,21,20,21,21,17,
	16,19,18,20,19,18,19,18,20,16,17,16,19,18,21,20,
	21,19,23,18,19,16,20,17,13,14,14,17,16,14,14,15,
	16,18,14,16,14,17,16,16,16,17,17,19,16,17,16,19,
	17,14,15,15,17,17,14,14,16,16,17,15,16,16,18,17,
	16,16,17,17,19,17,18,17,19,18,14,15,14,17,16,16,
	16,16,17,17,14,16,14,17,16,18,18,18,18,19,16,17,
	15,19,16,17,17,17,18,18,16,15,17,17,18,18,18,18,
	19,19,17,16,18,16,19,19,19,19,19,19,16,17,16,19,
	16,18,18,17,19,18,16,17,16,19,16,19,19,20,19,19,
	17,18,16,20,16,
};

static const static_codebook _44p6_p5_0 = {
	5, 3125,
	(long *)_vq_lengthlist__44p6_p5_0,
	1, -528744448, 1616642048, 3, 0,
	(long *)_vq_quantlist__44p6_p5_0,
	0
};

static const long _vq_quantlist__44p6_p5_1[] = {
	3,
	2,
	4,
	1,
	5,
	0,
	6,
};

static const long _vq_lengthlist__44p6_p5_1[] = {
	 2, 3, 3, 3, 3, 3, 3,
};

static const static_codebook _44p6_p5_1 = {
	1, 7,
	(long *)_vq_lengthlist__44p6_p5_1,
	1, -533200896, 1611661312, 3, 0,
	(long *)_vq_quantlist__44p6_p5_1,
	0
};

static const long _vq_quantlist__44p6_p6_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p6_p6_0[] = {
	 1, 5, 5, 5, 7, 9, 5, 9, 7, 5, 7, 8, 7, 7,10, 9,
	10,10, 5, 8, 7, 9,10,10, 7,10, 7, 6, 9, 9, 9,10,
	12, 9,11,11, 9,10,11,11,11,13,12,13,13, 9,11,11,
	12,13,13,11,13,11, 6, 9, 9, 9,11,11, 9,12,10, 9,
	11,11,11,11,13,12,13,13, 9,11,10,12,13,13,11,13,
	11, 6, 9, 9, 9,11,12, 9,12,11, 9,10,11,10,10,13,
	12,13,13, 9,11,11,12,13,12,11,13,11, 7, 9,10, 9,
	10,12,10,12,11,10,10,12,10,10,12,12,12,13,10,11,
	11,12,12,13,10,12,10, 7,10,10,11,11,14,11,14,11,
	10,12,11,11,11,14,14,14,14,10,11,12,14,14,14,11,
	14,11, 6, 9, 9, 9,11,12, 9,12,11, 9,11,11,11,11,
	13,12,12,13, 9,11,10,12,13,13,10,13,10, 7,10,10,
	11,11,14,11,14,11,10,12,11,11,11,14,14,15,14,10,
	11,12,13,14,15,11,14,11, 7,10, 9,10,11,12, 9,12,
	10,10,11,11,10,10,12,12,13,12, 9,12,10,12,13,12,
	10,12,10,
};

static const static_codebook _44p6_p6_0 = {
	5, 243,
	(long *)_vq_lengthlist__44p6_p6_0,
	1, -527106048, 1620377600, 2, 0,
	(long *)_vq_quantlist__44p6_p6_0,
	0
};

static const long _vq_quantlist__44p6_p6_1[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p6_p6_1[] = {
	 2, 6, 6, 6, 7, 8, 6, 8, 7, 6, 7, 7, 7, 7, 8, 7,
	 8, 8, 6, 7, 7, 7, 8, 8, 7, 8, 7, 6, 8, 8, 8, 9,
	 9, 8, 9, 9, 8, 9, 9, 9, 9,10, 9,10,10, 8, 9, 9,
	 9,10,10, 9,10, 9, 6, 8, 8, 8, 9, 9, 8, 9, 9, 8,
	 9, 9, 9, 9,10, 9,10,10, 8, 9, 9, 9,10, 9, 9,10,
	 9, 6, 8, 8, 8, 9, 9, 8, 9, 9, 8, 9, 9, 9, 9,10,
	 9, 9,10, 8, 9, 9, 9,10, 9, 9,10, 9, 7, 8, 8, 8,
	 9, 9, 8, 9, 9, 8, 8, 9, 9, 9, 9, 9, 9, 9, 8, 9,
	 9, 9,10, 9, 9, 9, 9, 7, 9, 9, 9, 9,10, 9,10, 9,
	 9, 9, 9, 9, 9,10,10,10,10, 9, 9, 9,10,10,10, 9,
	10, 9, 6, 8, 8, 8, 9, 9, 8, 9, 9, 8, 9, 9, 9, 9,
	10, 9,10,10, 8, 9, 9, 9,10, 9, 9,10, 9, 7, 9, 9,
	 9, 9,10, 9,10, 9, 9, 9, 9, 9, 9,10,10,10,10, 9,
	 9, 9,10,10,10, 9,10, 9, 7, 8, 8, 8, 9, 9, 8, 9,
	 9, 8, 9, 9, 9, 9,10, 9, 9,10, 8, 9, 8, 9, 9, 9,
	 9,10, 9,
};

static const static_codebook _44p6_p6_1 = {
	5, 243,
	(long *)_vq_lengthlist__44p6_p6_1,
	1, -530841600, 1616642048, 2, 0,
	(long *)_vq_quantlist__44p6_p6_1,
	0
};

static const long _vq_quantlist__44p6_p7_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p6_p7_0[] = {
	 1, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9,
};

static const static_codebook _44p6_p7_0 = {
	5, 243,
	(long *)_vq_lengthlist__44p6_p7_0,
	1, -513979392, 1633504256, 2, 0,
	(long *)_vq_quantlist__44p6_p7_0,
	0
};

static const long _vq_quantlist__44p6_p7_1[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p6_p7_1[] = {
	 1, 4, 5, 5,10,10, 5,10,10, 5,10,10,10,10,10,10,
	10,10, 5,10,10,10,10,10,10,10,10, 7,10,10,10,10,
	10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
	10,10,10,10,10,10, 6,10,10,10,10,10,10,10,10,10,
	10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
	10, 6,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
	10,10,10,10,10,10,10,10,10,10,10,10, 9,10,10,10,
	10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
	10,10,10,10,10,10,10, 9,10,10,10,10,10,10,10,10,
	10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
	10,10, 6,10,10,10,10,10,10,10,10,10,10,10,10,10,
	10,10,10,10,10,10,10,10,10,10,10,10,10, 9,10,10,
	10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
	10,10,10,10,10,10,10,10, 9,10,10,10,10,10,10,10,
	10,10,10,10,10,10,10,10,10,10,10,11,11,11,11,11,
	11,11,11,
};

static const static_codebook _44p6_p7_1 = {
	5, 243,
	(long *)_vq_lengthlist__44p6_p7_1,
	1, -516716544, 1630767104, 2, 0,
	(long *)_vq_quantlist__44p6_p7_1,
	0
};

static const long _vq_quantlist__44p6_p7_2[] = {
	12,
	11,
	13,
	10,
	14,
	9,
	15,
	8,
	16,
	7,
	17,
	6,
	18,
	5,
	19,
	4,
	20,
	3,
	21,
	2,
	22,
	1,
	23,
	0,
	24,
};

static const long _vq_lengthlist__44p6_p7_2[] = {
	 1, 2, 3, 4, 5, 7, 7, 8, 8, 9, 9,10,10,11,11,12,
	12,13,13,14,14,15,15,15,15,
};

static const static_codebook _44p6_p7_2 = {
	1, 25,
	(long *)_vq_lengthlist__44p6_p7_2,
	1, -518864896, 1620639744, 5, 0,
	(long *)_vq_quantlist__44p6_p7_2,
	0
};

static const long _vq_quantlist__44p6_p7_3[] = {
	12,
	11,
	13,
	10,
	14,
	9,
	15,
	8,
	16,
	7,
	17,
	6,
	18,
	5,
	19,
	4,
	20,
	3,
	21,
	2,
	22,
	1,
	23,
	0,
	24,
};

static const long _vq_lengthlist__44p6_p7_3[] = {
	 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5,
	 5, 5, 5, 5, 5, 5, 5, 5, 5,
};

static const static_codebook _44p6_p7_3 = {
	1, 25,
	(long *)_vq_lengthlist__44p6_p7_3,
	1, -529006592, 1611661312, 5, 0,
	(long *)_vq_quantlist__44p6_p7_3,
	0
};

static const long _huff_lengthlist__44p6_short[] = {
	 2, 8,13,15,16,18,21,22, 5, 4, 6, 8,10,12,17,21,
	 9, 5, 5, 6, 8,11,15,19,11, 6, 5, 5, 6, 7,12,14,
	14, 8, 7, 5, 4, 4, 9,11,16,11, 9, 7, 4, 3, 7,10,
	22,15,14,12, 8, 7, 9,11,21,16,15,12, 9, 5, 6, 8,
};

static const static_codebook _huff_book__44p6_short = {
	2, 64,
	(long *)_huff_lengthlist__44p6_short,
	0, 0, 0, 0, 0,
	NULL,
	0
};

static const long _vq_quantlist__44p7_l0_0[] = {
	6,
	5,
	7,
	4,
	8,
	3,
	9,
	2,
	10,
	1,
	11,
	0,
	12,
};

static const long _vq_lengthlist__44p7_l0_0[] = {
	 2, 4, 4, 7, 7, 8, 8,10,10,11,11,12,12, 4, 5, 5,
	 7, 7, 9, 9,11, 9,12,11,12,12, 4, 5, 5, 7, 7, 9,
	 9, 9,10,10,11,12,12, 7, 7, 7, 7, 8, 9, 8,11, 5,
	12, 6,12,10, 7, 7, 7, 8, 7, 8, 9, 5,11, 6,12,10,
	12, 8, 9, 9, 9, 9,10,10,11, 7,11, 7,12, 9, 8, 9,
	 8, 9, 9,10,10, 7,11, 7,11, 9,11,10,10,10,10,10,
	10,10,11,10,11, 8,11, 9,10,10,10,10,10,10,10,10,
	11, 8,10, 9,11,10,11,11,11,11,11,10,11,10,12,10,
	12,11,10,11,11,11,11,10,11,10,11,10,12,11,12,11,
	12,12,12,12,12,12,12,12,12,12,13,12,11,12,11,12,
	12,12,12,12,11,12,11,12,13,
};

static const static_codebook _44p7_l0_0 = {
	2, 169,
	(long *)_vq_lengthlist__44p7_l0_0,
	1, -526516224, 1616117760, 4, 0,
	(long *)_vq_quantlist__44p7_l0_0,
	0
};

static const long _vq_quantlist__44p7_l0_1[] = {
	2,
	1,
	3,
	0,
	4,
};

static const long _vq_lengthlist__44p7_l0_1[] = {
	 4, 4, 4, 5, 5, 4, 4, 5, 5, 5, 4, 5, 4, 5, 5, 5,
	 5, 5, 5, 5, 5, 5, 5, 5, 5,
};

static const static_codebook _44p7_l0_1 = {
	2, 25,
	(long *)_vq_lengthlist__44p7_l0_1,
	1, -533725184, 1611661312, 3, 0,
	(long *)_vq_quantlist__44p7_l0_1,
	0
};

static const long _vq_quantlist__44p7_l1_0[] = {
	54,
	29,
	79,
	0,
	108,
};

static const long _vq_lengthlist__44p7_l1_0[] = {
	 1, 2, 3, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8,
	 8, 8, 8, 8, 8, 8, 8, 8, 8,
};

static const static_codebook _44p7_l1_0 = {
	2, 25,
	(long *)_vq_lengthlist__44p7_l1_0,
	1, -514516992, 1620639744, 7, 0,
	(long *)_vq_quantlist__44p7_l1_0,
	0
};

static const long _huff_lengthlist__44p7_lfe[] = {
	 2, 3, 1, 3,
};

static const static_codebook _huff_book__44p7_lfe = {
	2, 4,
	(long *)_huff_lengthlist__44p7_lfe,
	0, 0, 0, 0, 0,
	NULL,
	0
};

static const long _huff_lengthlist__44p7_long[] = {
	 2, 7,14,16,17,17,18,20, 6, 3, 5, 8,10,11,13,15,
	13, 5, 3, 5, 8, 9,11,12,15, 7, 4, 3, 5, 7, 9,11,
	16,10, 7, 5, 6, 7, 9,10,17,11, 8, 7, 7, 6, 8, 8,
	19,13,11, 9, 9, 8, 8, 9,20,14,13,11,10, 8, 9, 9,
};

static const static_codebook _huff_book__44p7_long = {
	2, 64,
	(long *)_huff_lengthlist__44p7_long,
	0, 0, 0, 0, 0,
	NULL,
	0
};

static const long _vq_quantlist__44p7_p1_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p7_p1_0[] = {
	 2, 5, 5, 4, 7, 7, 4, 7, 7, 5, 7, 7, 7, 8, 9, 7,
	 9, 9, 5, 7, 7, 7, 9, 9, 7, 9, 8, 6, 7, 8, 8, 9,
	10, 8, 9,10, 8, 9,10,10,10,12,10,11,11, 8,10,10,
	10,11,12,10,11,11, 6, 8, 7, 8,10, 9, 8,10, 9, 8,
	10,10,10,11,11,10,12,11, 8,10, 9,10,11,11,10,12,
	10, 5, 8, 8, 8,10,10, 8,10,10, 7, 9,10, 9,10,11,
	 9,11,11, 8,10,10,10,11,12,10,12,11, 7, 9, 9, 9,
	10,11, 9,11,11, 9, 9,11,10,11,12,11,11,12, 9,11,
	11,11,12,12,11,12,12, 7, 9, 9,10,11,11,10,12,11,
	 9,11,10,11,11,12,11,13,12,10,11,11,12,13,13,11,
	13,11, 5, 8, 8, 8,10,10, 8,10,10, 8,10,10,10,11,
	12,10,12,11, 7,10, 9, 9,11,11, 9,11,10, 7, 9, 9,
	10,11,12,10,11,11,10,11,11,11,11,13,12,13,13, 9,
	10,11,11,12,13,11,12,11, 7, 9, 9, 9,11,11, 9,11,
	10, 9,11,11,11,12,12,11,12,12, 9,11, 9,11,12,11,
	10,12,11,
};

static const static_codebook _44p7_p1_0 = {
	5, 243,
	(long *)_vq_lengthlist__44p7_p1_0,
	1, -535822336, 1611661312, 2, 0,
	(long *)_vq_quantlist__44p7_p1_0,
	0
};

static const long _vq_quantlist__44p7_p2_0[] = {
	2,
	1,
	3,
	0,
	4,
};

static const long _vq_lengthlist__44p7_p2_0[] = {
	 4, 6, 6, 9, 9, 6, 8, 8,10,10, 6, 8, 8,10,10, 8,
	10,10,12,13, 8,10,10,13,12, 6, 8, 8,10,10, 8, 8,
	 9,10,11, 8, 9, 9,11,11,10,10,11,12,13,10,11,11,
	13,13, 6, 8, 8,10,10, 8, 9, 9,11,11, 8, 9, 8,11,
	10,10,11,11,13,13,10,11,10,13,12, 9,10,10,12,12,
	10,10,11,12,13,10,11,11,13,13,12,12,13,12,15,13,
	13,13,15,14, 9,10,10,12,12,10,11,11,13,13,10,11,
	10,13,12,12,13,13,14,15,12,13,12,15,12, 6, 8, 8,
	10,11, 8, 9,10,11,12, 8, 9, 9,11,11,10,11,12,13,
	14,10,11,11,13,13, 8, 9, 9,11,12, 9,10,11,12,13,
	 9,10,10,12,13,11,12,13,13,15,11,12,12,14,14, 8,
	 9, 9,11,12, 9,10,11,12,13, 9,10,10,13,12,11,12,
	13,14,15,11,12,12,14,13,10,11,12,13,14,11,12,13,
	13,15,12,13,13,14,14,13,13,14,14,16,14,15,14,16,
	15,10,12,11,14,13,12,12,13,14,14,11,12,12,14,14,
	14,14,15,15,16,13,14,14,16,14, 6, 8, 8,11,10, 8,
	 9, 9,11,11, 8,10, 9,12,11,10,11,11,13,13,10,12,
	11,14,13, 8, 9, 9,12,11, 9,10,10,12,13, 9,11,10,
	13,12,11,12,12,14,14,11,13,12,15,14, 8, 9, 9,12,
	11, 9,10,10,13,12, 9,11,10,13,12,11,12,12,14,14,
	11,13,12,15,13,10,11,12,13,14,11,12,13,13,14,12,
	13,12,14,14,13,13,14,14,16,14,15,14,16,16,10,12,
	11,14,13,12,13,13,14,14,11,13,12,15,13,14,14,15,
	16,16,13,14,13,16,14, 9,10,11,12,13,11,11,12,13,
	14,11,11,12,13,14,13,13,14,14,16,13,14,14,15,15,
	11,11,12,13,14,12,12,13,13,15,12,13,13,14,15,14,
	14,15,15,17,14,14,15,16,16,11,12,12,13,14,12,12,
	13,14,15,12,13,12,14,15,14,14,15,15,17,14,15,14,
	16,16,13,14,14,15,16,14,14,15,15,17,14,15,15,16,
	16,15,16,17,16,18,16,17,16,17,17,13,14,14,16,15,
	14,15,15,16,16,14,15,14,16,15,16,16,17,17,18,16,
	16,16,17,16, 9,11,10,13,12,11,12,11,14,13,11,12,
	11,14,13,13,14,14,16,15,13,14,13,16,14,11,12,12,
	14,13,12,12,13,14,14,12,13,13,15,14,14,14,15,16,
	16,14,15,14,17,15,11,12,11,14,13,12,13,13,15,14,
	12,13,12,15,13,14,15,14,16,16,14,15,14,17,15,13,
	14,14,15,16,14,14,15,16,16,14,15,15,16,16,15,16,
	16,16,17,16,16,16,17,17,13,14,14,16,15,14,15,15,
	17,16,14,15,14,17,15,16,17,17,17,17,16,16,16,18,
	16, 6, 8, 8,11,11, 8, 9, 9,11,12, 8, 9, 9,12,11,
	10,11,11,13,14,10,11,11,14,13, 8, 9, 9,11,12, 9,
	10,10,12,13, 9,10,10,13,12,11,11,12,13,15,11,12,
	12,15,14, 8, 9, 9,12,11, 9,10,11,12,13, 9,11,10,
	13,12,11,12,12,14,15,11,13,12,15,14,10,11,11,13,
	14,11,12,12,13,14,11,12,12,14,14,13,13,14,14,16,
	13,14,14,16,15,11,12,11,14,13,12,13,13,14,14,11,
	13,12,14,13,14,14,15,16,16,13,14,14,16,14, 8, 9,
	 9,11,12, 9,10,10,12,13, 9,10,10,13,12,11,12,12,
	14,15,11,12,12,14,14, 9, 9,10,11,13,10,10,12,12,
	14,10,10,11,13,13,12,12,13,14,16,12,12,13,15,15,
	 9,10,10,13,12,10,11,11,13,14,10,12,11,14,13,12,
	13,13,15,15,12,13,13,15,15,11,11,12,13,15,12,12,
	13,13,15,12,13,13,14,15,14,14,15,15,17,14,15,15,
	16,16,11,13,12,15,14,13,13,13,15,15,12,14,13,15,
	14,15,15,15,16,16,14,15,15,17,15, 7, 9, 9,12,11,
	 9,10,10,12,12, 9,11,10,13,12,11,12,12,14,14,11,
	13,12,15,14, 9,10,10,12,12,10,10,11,12,13,10,11,
	11,14,13,12,12,13,14,15,12,13,13,15,14, 9,10,10,
	12,12,10,11,11,13,13,10,11,10,14,12,12,13,13,15,
	15,12,13,12,15,13,11,12,12,14,14,12,12,13,14,15,
	12,13,13,15,15,14,13,14,13,16,14,15,15,16,16,11,
	12,12,14,14,13,13,14,15,15,12,13,12,15,14,15,15,
	15,16,16,14,15,14,17,14,10,11,12,13,14,11,12,13,
	14,15,11,12,12,14,15,13,14,15,15,17,14,14,14,16,
	16,11,12,13,12,15,12,12,14,13,16,13,13,14,13,16,
	14,14,15,14,17,15,15,15,15,17,11,13,12,15,15,13,
	13,14,15,16,12,14,13,16,15,15,15,15,17,17,15,15,
	15,17,16,14,14,15,14,16,14,14,16,14,17,15,15,15,
	14,17,16,16,17,15,18,17,17,17,16,18,14,15,15,17,
	16,15,16,16,17,17,15,16,15,17,16,17,17,17,18,18,
	16,17,16,18,17,10,11,11,14,13,11,12,12,14,14,11,
	13,12,15,14,14,14,14,16,16,14,15,14,16,15,11,12,
	12,15,13,12,13,13,15,14,13,14,13,16,14,14,15,15,
	16,16,15,16,15,17,16,11,13,12,15,14,13,13,14,15,
	15,12,14,13,16,14,15,15,15,17,17,14,16,15,17,16,
	14,14,14,16,15,14,15,15,16,16,15,16,15,17,16,16,
	16,16,16,17,16,17,17,18,17,14,15,15,16,16,15,15,
	16,17,16,14,15,15,17,16,17,17,17,18,18,16,17,16,
	18,16, 6, 8, 8,11,11, 8, 9, 9,11,12, 8, 9, 9,12,
	11,10,11,12,13,14,10,11,11,14,13, 8, 9, 9,11,12,
	 9,10,11,12,13, 9,11,10,13,12,11,12,13,14,15,11,
	12,12,15,14, 8, 9, 9,12,11, 9,10,10,12,13, 9,10,
	10,13,12,11,12,12,14,15,11,12,12,14,13,11,11,12,
	13,14,11,12,13,13,15,12,13,13,14,14,13,14,14,14,
	16,14,15,14,16,16,10,11,11,14,13,11,12,12,14,14,
	11,12,12,14,13,13,14,14,15,16,13,14,13,16,14, 7,
	 9, 9,11,11, 9,10,11,12,13, 9,10,10,12,12,11,12,
	13,14,15,11,12,12,14,14, 9,10,10,12,12,10,10,11,
	12,13,10,11,11,13,13,12,12,13,13,15,12,13,13,15,
	15, 9,10,10,12,12,10,11,11,13,13,10,11,10,13,12,
	12,13,13,14,15,12,13,12,15,13,11,12,12,14,14,12,
	12,13,14,15,13,14,13,15,15,14,13,15,13,16,15,15,
	15,16,16,11,12,12,14,14,12,13,13,14,15,12,13,12,
	15,14,14,15,15,16,17,13,14,13,16,13, 8, 9, 9,12,
	11, 9,10,10,12,13, 9,10,10,13,12,11,12,12,14,15,
	11,12,12,15,14, 9,10,10,12,13,10,11,12,13,14,10,
	11,11,14,13,12,13,13,15,15,12,13,13,15,15, 9,10,
	 9,13,11,10,11,10,13,13,10,12,10,14,12,12,13,12,
	15,15,12,13,12,15,14,11,12,13,14,15,12,13,14,14,
	15,13,13,13,15,15,14,15,15,15,17,15,15,15,16,16,
	11,12,11,15,13,12,13,13,15,14,12,13,12,16,13,14,
	15,15,16,16,14,15,14,17,14,10,11,11,13,14,11,12,
	13,14,15,11,12,12,14,14,14,14,15,15,17,14,14,14,
	15,16,11,12,13,14,15,12,13,14,14,16,13,14,13,15,
	15,14,15,16,15,17,15,15,15,17,17,11,12,12,13,15,
	13,13,14,14,16,12,13,13,14,15,15,15,15,16,17,14,
	15,15,16,16,14,15,15,16,16,14,15,15,16,17,15,15,
	16,16,17,16,16,17,16,18,17,17,17,18,18,14,14,15,
	15,16,15,15,15,16,17,14,15,15,16,16,16,17,17,17,
	18,16,16,16,17,16,10,11,11,14,13,11,13,12,15,14,
	11,13,12,15,14,14,15,14,16,16,13,15,14,17,15,11,
	12,13,15,15,12,13,14,15,16,13,14,13,16,15,15,15,
	15,16,17,15,15,15,17,16,11,13,11,15,12,13,14,13,
	16,13,12,14,12,16,13,15,15,15,17,15,14,16,14,17,
	14,14,15,15,16,17,15,15,16,16,17,15,16,15,17,17,
	16,16,17,17,18,16,17,17,18,18,14,15,14,17,13,15,
	16,15,17,15,15,16,15,17,14,16,17,16,18,16,16,17,
	16,18,15, 9,11,11,13,13,10,12,12,14,14,11,12,12,
	14,14,13,14,14,15,16,13,14,14,16,16,10,11,12,14,
	14,11,12,13,14,15,11,13,13,15,15,13,14,14,15,16,
	14,15,15,16,16,11,12,12,14,14,12,13,13,15,15,12,
	13,12,15,14,14,15,15,16,16,14,15,14,17,16,12,13,
	13,15,16,13,13,14,15,16,13,14,14,16,16,14,15,16,
	16,17,15,16,16,17,17,13,14,14,16,15,14,15,15,17,
	16,14,15,14,17,15,16,16,17,17,17,16,16,16,18,16,
	10,11,12,14,14,11,12,13,14,15,11,13,12,15,15,13,
	14,15,16,16,14,15,15,17,16,11,11,13,14,15,12,12,
	14,14,16,12,13,14,15,15,14,14,15,16,17,15,15,15,
	17,17,12,13,12,15,15,13,14,14,16,15,13,14,13,16,
	15,15,16,15,17,17,15,16,15,17,16,13,12,15,14,16,
	14,13,15,14,17,14,13,15,15,17,15,14,17,15,18,16,
	15,17,17,18,14,15,15,17,16,15,16,16,17,17,15,16,
	15,17,16,16,17,17,18,18,16,17,16,18,17,10,11,11,
	14,14,11,12,12,14,15,11,13,12,15,14,13,14,14,16,
	16,14,15,14,16,16,11,12,12,14,14,12,12,13,15,15,
	12,13,13,15,15,14,14,15,16,16,14,15,15,17,16,11,
	12,12,15,15,13,13,13,15,15,12,13,13,15,15,15,15,
	15,17,17,14,15,15,17,16,13,14,13,16,15,14,14,14,
	16,16,14,15,14,17,16,15,15,16,16,17,16,17,16,18,
	17,14,15,15,16,16,15,15,15,17,17,14,15,15,17,16,
	16,17,17,18,18,16,17,16,18,16,12,13,13,15,15,13,
	14,14,16,16,13,14,14,16,16,14,15,16,16,18,15,16,
	16,17,17,13,13,14,14,16,14,14,15,15,17,14,14,15,
	15,17,15,15,17,15,18,16,16,17,17,18,13,14,14,16,
	16,14,15,15,16,17,14,15,15,17,16,16,17,16,17,18,
	16,17,16,18,17,15,14,16,13,18,16,15,17,14,18,16,
	15,17,14,18,17,16,18,15,19,17,17,18,16,19,15,16,
	16,17,17,16,17,17,18,18,16,17,16,18,17,18,18,18,
	19,18,17,18,17,19,17,11,12,12,15,15,13,13,14,15,
	16,13,14,13,16,15,15,15,15,16,17,15,16,15,17,16,
	12,13,13,15,15,13,13,14,15,16,14,15,14,16,15,15,
	15,16,16,17,16,16,16,18,17,12,13,13,15,15,14,14,
	15,16,16,13,14,13,16,15,16,16,16,17,17,15,16,15,
	18,16,15,15,15,17,15,14,15,15,16,16,16,17,16,17,
	16,16,16,17,16,17,17,18,17,19,18,15,15,16,17,17,
	16,16,16,17,17,15,16,15,17,16,17,18,18,18,18,16,
	17,16,18,16, 9,11,11,13,13,11,12,12,14,14,10,12,
	12,14,14,13,14,14,15,16,13,14,14,16,15,11,12,12,
	14,14,12,12,13,14,15,12,13,13,15,15,14,14,15,16,
	17,14,15,15,16,16,10,12,11,14,14,11,13,13,15,15,
	11,13,12,15,14,14,14,15,16,16,13,14,14,16,15,13,
	14,14,15,16,14,14,15,15,17,14,15,15,16,17,16,16,
	16,16,18,16,16,17,17,17,12,13,13,16,15,13,14,14,
	16,16,12,14,13,16,15,15,16,16,17,17,14,16,15,17,
	16,10,11,11,14,14,11,12,13,14,15,11,12,12,15,14,
	14,14,15,16,16,13,14,14,16,16,11,12,12,14,15,12,
	13,14,15,15,13,13,13,15,15,14,15,15,16,17,15,15,
	15,16,17,11,12,12,14,14,12,13,13,15,15,12,13,12,
	15,15,14,15,15,16,17,14,15,14,16,16,14,14,15,16,
	16,14,15,15,16,17,15,16,15,17,17,16,16,17,16,18,
	16,17,17,18,18,13,13,14,15,16,14,14,15,16,17,14,
	14,14,16,15,16,16,17,17,18,15,16,15,17,16,10,12,
	11,14,14,11,13,13,15,15,11,13,12,15,15,14,15,15,
	16,16,13,15,14,16,16,12,12,13,15,15,13,13,14,15,
	16,13,14,14,16,15,15,15,16,16,17,15,15,15,17,17,
	11,13,11,15,14,12,14,13,16,15,12,14,12,16,14,15,
	15,15,17,17,14,15,14,17,15,14,15,15,16,17,15,15,
	16,16,17,15,16,16,17,17,16,16,17,17,18,16,17,17,
	18,18,13,14,12,16,14,14,15,13,17,15,14,15,13,17,
	14,16,17,15,18,17,15,17,14,18,15,11,12,12,14,15,
	13,13,14,15,16,13,14,13,16,15,15,15,16,16,17,15,
	15,15,16,16,12,13,13,15,15,13,13,14,15,16,14,15,
	14,16,16,15,15,16,16,18,16,16,16,18,17,12,13,13,
	15,15,14,14,15,15,16,13,14,13,15,15,16,16,16,17,
	18,15,16,15,17,16,15,16,15,17,16,15,15,16,16,17,
	16,17,16,17,17,16,16,17,16,18,17,18,18,18,18,14,
	15,15,15,17,16,15,17,16,17,14,15,15,16,16,17,17,
	18,18,19,16,16,16,17,16,12,13,13,15,15,13,14,14,
	16,16,13,14,14,16,16,15,16,16,17,17,15,16,15,18,
	16,13,14,14,16,16,14,15,15,16,17,14,15,15,17,16,
	16,16,17,17,18,16,17,16,18,18,13,14,13,16,14,14,
	15,14,17,15,14,15,14,17,14,16,17,16,18,17,15,17,
	15,18,15,15,16,16,17,18,16,16,17,17,18,16,17,17,
	17,18,17,17,18,18,19,17,18,18,19,18,15,16,14,17,
	13,16,17,15,18,14,16,17,15,18,14,18,18,17,19,16,
	17,18,16,19,15,
};

static const static_codebook _44p7_p2_0 = {
	5, 3125,
	(long *)_vq_lengthlist__44p7_p2_0,
	1, -533725184, 1611661312, 3, 0,
	(long *)_vq_quantlist__44p7_p2_0,
	0
};

static const long _vq_quantlist__44p7_p3_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p7_p3_0[] = {
	 2, 5, 5, 4, 7, 7, 4, 7, 7, 5, 7, 8, 7, 8,10, 8,
	 9, 9, 5, 7, 7, 8, 9, 9, 7,10, 8, 5, 7, 8, 8, 9,
	10, 8,10,10, 8, 9,10,10,10,12,10,12,12, 8,10,10,
	10,12,12,10,12,11, 5, 8, 7, 8,10,10, 8,10, 9, 8,
	10,10,10,11,12,10,12,12, 8,10, 9,10,12,12,10,12,
	10, 5, 8, 8, 7,10,10, 8,10,10, 7, 9,10, 9,10,12,
	10,12,12, 8,10,10,10,12,12,10,12,11, 7, 9,10, 9,
	11,12,10,12,11, 9, 9,12,11,10,14,12,12,13,10,12,
	11,12,13,13,11,14,12, 7,10, 9,10,11,11,10,12,11,
	 9,11,11,11,11,13,12,14,13,10,12,12,12,14,14,11,
	14,12, 5, 8, 8, 8,10,10, 7,10,10, 8,10,10,10,11,
	12,10,12,12, 7,10, 9,10,12,12, 9,12,10, 7, 9,10,
	10,11,12,10,11,11,10,12,12,11,12,14,12,14,14, 9,
	11,11,12,13,14,11,13,11, 7,10, 9,10,11,12, 9,12,
	11,10,11,12,11,12,14,12,13,13, 9,12, 9,12,13,12,
	11,14,10,
};

static const static_codebook _44p7_p3_0 = {
	5, 243,
	(long *)_vq_lengthlist__44p7_p3_0,
	1, -533200896, 1614282752, 2, 0,
	(long *)_vq_quantlist__44p7_p3_0,
	0
};

static const long _vq_quantlist__44p7_p3_1[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p7_p3_1[] = {
	 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 8, 8, 7,
	 8, 8, 7, 8, 7, 7, 8, 8, 7, 8, 8, 7, 8, 8, 8, 8,
	 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 8, 8, 9, 8, 8, 8,
	 8, 8, 8, 8, 9, 8, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8,
	 8, 8, 8, 8, 9, 8, 8, 8, 8, 8, 8, 8, 9, 8, 8, 9,
	 8, 7, 8, 8, 7, 8, 8, 7, 8, 8, 7, 8, 8, 8, 8, 8,
	 8, 8, 8, 8, 8, 8, 8, 9, 8, 8, 9, 8, 7, 8, 8, 8,
	 8, 9, 8, 8, 8, 8, 8, 8, 8, 8, 9, 8, 9, 9, 8, 8,
	 8, 9, 9, 9, 8, 9, 9, 7, 8, 8, 8, 8, 8, 8, 8, 8,
	 8, 8, 8, 8, 8, 9, 8, 9, 9, 8, 8, 8, 8, 9, 9, 8,
	 9, 8, 7, 8, 8, 7, 8, 8, 7, 8, 8, 8, 8, 8, 8, 8,
	 9, 8, 8, 9, 7, 8, 8, 8, 8, 8, 8, 8, 8, 7, 8, 8,
	 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 8, 9, 9, 8,
	 8, 8, 8, 9, 9, 8, 9, 8, 7, 8, 8, 8, 8, 8, 8, 9,
	 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 8, 8, 8, 8, 9, 9,
	 8, 9, 8,
};

static const static_codebook _44p7_p3_1 = {
	5, 243,
	(long *)_vq_lengthlist__44p7_p3_1,
	1, -535822336, 1611661312, 2, 0,
	(long *)_vq_quantlist__44p7_p3_1,
	0
};

static const long _vq_quantlist__44p7_p4_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p7_p4_0[] = {
	 1, 5, 5, 5, 7, 8, 5, 8, 7, 5, 7, 8, 7, 8,10, 8,
	10,10, 5, 8, 7, 8,10,10, 7,10, 8, 6, 8, 9, 9,10,
	12, 9,11,11, 9,10,11,11,11,13,11,13,13, 9,11,11,
	11,12,13,11,13,11, 6, 9, 8, 9,11,11, 9,12,10, 9,
	11,11,11,11,13,11,13,13, 9,11,10,11,13,13,11,13,
	11, 6, 9, 9, 8,10,11, 9,12,11, 8,10,11,10,11,13,
	11,13,13, 9,11,11,11,13,12,11,13,11, 8,10,10, 9,
	11,12,10,12,12,10,10,12,11,11,14,12,13,14,10,12,
	12,12,13,13,11,14,11, 8,11,10,11,12,13,11,14,12,
	10,12,11,11,12,14,13,15,14,10,12,12,13,14,15,12,
	14,12, 5, 9, 9, 9,11,12, 8,11,10, 9,11,11,11,11,
	13,11,12,13, 8,11,10,11,13,13,10,13,11, 8,10,11,
	11,12,14,11,13,12,10,12,12,12,12,14,14,15,14,10,
	11,12,13,14,15,11,14,12, 8,10,10,10,12,12, 9,12,
	11,10,12,12,11,11,14,12,13,13,10,12,10,12,14,13,
	11,13,11,
};

static const static_codebook _44p7_p4_0 = {
	5, 243,
	(long *)_vq_lengthlist__44p7_p4_0,
	1, -531365888, 1616117760, 2, 0,
	(long *)_vq_quantlist__44p7_p4_0,
	0
};

static const long _vq_quantlist__44p7_p4_1[] = {
	2,
	1,
	3,
	0,
	4,
};

static const long _vq_lengthlist__44p7_p4_1[] = {
	 7, 8, 8,10,10, 8, 9, 9,10,11, 8, 9, 9,10,10, 9,
	10,10,11,11, 9,10,10,11,11, 8, 9, 9,10,10, 9, 9,
	10,11,11, 9,10,10,11,11,10,10,11,11,11,10,11,11,
	11,11, 8, 9, 9,10,10, 9,10,10,11,11, 9,10, 9,11,
	11,10,11,11,11,11,10,11,10,11,11,10,10,10,11,11,
	10,11,11,11,11,10,11,11,11,11,11,11,11,11,12,11,
	11,11,11,12,10,10,10,11,11,10,11,11,11,11,10,11,
	11,11,11,11,11,11,12,11,11,11,11,12,11, 8, 9,10,
	11,11, 9,10,11,11,11, 9,10,10,11,11,10,11,11,12,
	12,10,11,11,12,12,10,10,10,11,11,10,10,11,11,12,
	10,11,11,12,12,11,11,12,12,12,11,11,12,12,12,10,
	10,10,11,11,10,11,11,12,12,10,11,11,12,11,11,12,
	12,12,12,11,12,11,12,12,11,11,11,11,12,11,11,12,
	12,12,11,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,11,11,11,12,12,11,12,12,12,12,11,12,11,12,12,
	12,12,12,12,12,12,12,12,12,12, 8,10, 9,11,11, 9,
	10,10,11,11, 9,10,10,11,11,10,11,11,12,12,10,11,
	11,12,12,10,10,10,11,11,10,11,11,12,12,10,11,11,
	12,12,11,11,12,12,12,11,12,12,12,12,10,10,10,11,
	11,10,11,11,12,12,10,11,10,12,11,11,12,11,12,12,
	11,12,11,12,12,11,11,11,12,12,11,12,12,12,12,11,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,11,11,
	11,12,11,11,12,12,12,12,11,12,11,12,12,12,12,12,
	12,12,12,12,12,12,12,10,11,11,11,12,11,11,12,12,
	12,11,11,11,12,12,11,12,12,12,12,11,12,12,12,12,
	11,11,12,12,12,11,12,12,12,12,12,12,12,12,12,12,
	12,13,12,13,12,12,12,13,13,11,12,11,12,12,11,12,
	12,12,12,11,12,12,12,12,12,12,12,13,13,12,12,12,
	13,13,12,12,12,12,12,12,12,12,12,13,12,12,13,13,
	13,12,13,13,13,13,12,13,13,13,13,12,12,12,12,12,
	12,12,13,13,13,12,12,12,13,12,12,13,13,13,13,12,
	13,13,13,13,10,11,11,12,11,11,11,11,12,12,11,12,
	11,12,12,11,12,12,12,12,11,12,12,12,12,11,11,11,
	12,12,11,12,12,12,12,12,12,12,12,12,12,12,12,13,
	13,12,12,12,13,13,11,12,11,12,12,12,12,12,12,12,
	11,12,11,12,12,12,12,12,13,13,12,12,12,13,12,12,
	12,12,12,12,12,12,12,13,13,12,12,12,13,13,12,13,
	13,13,13,12,13,13,13,13,12,12,12,12,12,12,12,12,
	13,13,12,13,12,13,12,12,13,13,13,13,13,13,13,13,
	13, 8,10,10,11,11, 9,10,10,11,11, 9,10,10,11,11,
	10,11,11,12,12,10,11,11,12,12, 9,10,10,11,11,10,
	10,11,11,12,10,11,11,12,12,11,11,12,12,12,11,11,
	12,12,12,10,10,10,11,11,10,11,11,12,12,10,11,10,
	12,11,11,12,11,12,12,11,12,11,12,12,11,11,11,12,
	12,11,11,12,12,12,11,12,12,12,12,11,12,12,12,12,
	12,12,12,12,12,11,11,11,12,11,11,12,12,12,12,11,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12, 9,10,
	10,11,11,10,11,11,11,12,10,11,11,12,12,11,11,11,
	12,12,11,11,11,12,12,10,10,11,11,12,11,11,12,12,
	12,11,11,11,12,12,11,11,12,12,12,11,12,12,12,12,
	10,11,11,12,12,11,11,11,12,12,11,12,11,12,12,11,
	12,12,12,12,11,12,12,12,12,11,11,12,12,12,11,12,
	12,12,12,12,12,12,12,12,12,12,12,12,13,12,12,12,
	12,13,11,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,13,12, 9,10,10,11,11,
	10,11,11,12,12,10,11,11,12,11,11,12,11,12,12,11,
	12,11,12,12,10,11,11,12,12,11,11,11,12,12,11,12,
	11,12,12,11,12,12,12,12,12,12,12,12,12,10,11,11,
	12,12,11,12,11,12,12,11,12,11,12,12,12,12,12,13,
	12,12,12,12,12,12,11,12,11,12,12,11,12,12,12,12,
	12,12,12,12,12,12,12,12,12,13,12,12,12,12,13,11,
	12,12,12,12,12,12,12,13,12,11,12,12,12,12,12,12,
	12,13,12,12,12,12,13,12,10,11,11,12,12,11,12,12,
	12,12,11,12,12,12,12,12,12,12,12,13,12,12,12,13,
	13,11,11,12,12,12,12,12,12,12,13,12,12,12,12,12,
	12,12,13,12,13,12,12,13,13,13,11,12,12,12,12,12,
	12,12,13,13,12,12,12,13,12,12,13,12,13,13,12,13,
	12,13,13,12,12,12,12,12,12,12,13,12,13,12,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,12,12,12,13,
	13,12,13,13,13,13,12,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,10,11,11,12,12,11,12,12,12,12,11,
	12,12,12,12,12,12,12,13,13,12,12,12,13,13,11,12,
	12,12,12,12,12,12,12,13,12,12,12,13,12,12,12,13,
	13,13,12,13,13,13,13,11,12,12,12,12,12,12,12,13,
	13,12,12,12,13,12,12,13,13,13,13,12,13,12,13,13,
	12,12,12,12,12,12,13,13,13,13,12,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,12,12,12,13,12,12,13,
	13,13,13,12,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13, 8,10,10,11,11, 9,10,10,11,11, 9,10,10,11,
	11,10,11,11,12,12,10,11,11,12,12,10,10,10,11,11,
	10,11,11,11,12,10,11,11,12,12,11,11,12,12,12,11,
	11,12,12,12, 9,10,10,11,11,10,11,11,12,12,10,11,
	10,12,11,11,12,11,12,12,11,12,11,12,12,11,11,11,
	12,12,11,11,12,12,12,11,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,11,11,11,12,11,11,12,12,12,12,
	11,12,11,12,12,12,12,12,12,12,12,12,12,12,12, 9,
	10,10,11,11,10,11,11,12,12,10,11,11,12,12,11,11,
	12,12,12,11,12,12,12,12,10,11,11,12,12,11,11,12,
	12,12,11,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,10,11,11,12,12,11,11,12,12,12,11,11,11,12,12,
	12,12,12,12,12,11,12,12,12,12,11,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,13,12,13,12,12,
	12,13,12,11,12,12,12,12,12,12,12,12,12,11,12,12,
	12,12,12,12,12,13,12,12,12,12,13,12, 9,10,10,11,
	11,10,11,11,12,12,10,11,11,12,12,11,11,11,12,12,
	11,12,11,12,12,10,11,11,12,12,11,11,12,12,12,11,
	11,11,12,12,11,12,12,12,12,11,12,12,12,12,10,11,
	10,12,11,11,11,11,12,12,11,12,11,12,12,11,12,12,
	12,12,11,12,11,12,12,11,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,13,12,12,12,12,13,
	11,12,11,12,12,12,12,12,12,12,11,12,12,12,12,12,
	12,12,13,12,12,12,12,13,12,10,11,11,12,12,11,12,
	12,12,12,11,12,12,12,12,12,12,12,13,13,12,12,12,
	13,13,11,12,12,12,12,12,12,12,12,13,12,12,12,13,
	13,12,12,13,13,13,12,13,13,13,13,11,12,12,12,12,
	12,12,12,12,13,12,12,12,12,12,12,13,13,13,13,12,
	13,12,13,13,12,12,12,12,13,12,13,13,13,13,12,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,12,12,12,
	12,12,12,13,13,13,13,12,13,12,13,13,13,13,13,13,
	13,13,13,13,13,13,11,11,11,12,12,11,12,12,12,12,
	11,12,12,12,12,12,12,12,13,13,12,12,12,13,12,11,
	12,12,12,12,12,12,12,13,13,12,12,12,13,13,12,12,
	13,13,13,12,13,13,13,13,11,12,11,12,12,12,12,12,
	13,12,12,12,12,13,12,12,13,12,13,13,12,13,12,13,
	12,12,12,12,12,13,12,12,13,13,13,12,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,12,12,12,12,12,12,
	13,13,13,13,12,13,12,13,12,13,13,13,13,13,13,13,
	13,13,13,10,11,11,12,12,10,11,11,12,12,10,11,11,
	12,12,11,12,12,12,12,11,12,12,12,12,11,11,11,12,
	12,11,11,12,12,12,11,12,12,12,12,12,12,12,13,13,
	12,12,12,13,13,11,11,11,12,12,11,12,12,12,12,11,
	12,11,13,12,12,12,12,13,13,12,12,12,13,13,11,12,
	12,12,12,12,12,12,12,13,12,12,12,13,13,12,12,13,
	13,13,12,13,12,13,13,11,12,12,12,12,12,12,12,13,
	12,12,12,12,13,12,12,13,13,13,13,12,13,13,13,13,
	10,11,11,12,12,11,12,12,12,12,11,12,12,12,12,12,
	12,12,13,13,12,12,12,13,13,11,11,12,12,12,11,12,
	12,12,13,12,12,12,13,13,12,12,13,13,13,12,12,13,
	13,13,11,12,12,12,12,12,12,12,13,13,12,12,12,13,
	13,12,13,13,13,13,12,13,12,13,13,12,12,12,12,13,
	12,12,13,12,13,12,12,13,13,13,12,12,13,13,13,12,
	13,13,13,13,12,12,12,12,13,12,12,13,13,13,12,12,
	12,13,13,13,13,13,13,13,12,13,13,13,13,10,11,11,
	12,12,11,12,12,12,12,11,12,12,12,12,12,12,12,13,
	13,12,12,12,13,13,11,12,12,12,12,11,12,12,12,13,
	12,12,12,13,13,12,12,13,13,13,12,13,13,13,13,11,
	12,12,12,12,12,12,12,13,13,12,12,12,13,12,12,13,
	12,13,13,12,13,12,13,13,12,12,12,12,12,12,12,12,
	13,13,12,13,12,13,13,12,13,13,13,13,13,13,13,13,
	13,12,12,12,13,12,12,13,13,13,13,12,13,12,13,13,
	13,13,13,13,13,13,13,13,13,13,11,11,11,12,12,11,
	12,12,12,12,11,12,12,12,12,12,12,12,13,13,12,12,
	12,13,13,11,12,12,12,12,12,12,12,12,13,12,12,12,
	13,13,12,12,13,13,13,12,12,13,13,13,11,12,12,12,
	12,12,12,12,13,13,12,12,12,13,13,12,13,13,13,13,
	12,13,12,13,13,12,12,12,12,12,12,12,13,12,13,12,
	13,13,13,13,12,13,13,12,13,13,13,13,13,13,12,12,
	12,12,12,12,13,13,13,13,12,13,12,13,13,13,13,13,
	13,13,13,13,13,13,13,10,11,11,12,12,11,12,12,12,
	13,11,12,12,13,12,12,12,12,13,13,12,12,12,13,13,
	11,12,12,12,12,12,12,12,13,13,12,13,12,13,13,12,
	12,13,13,13,12,13,13,13,13,11,12,12,12,13,12,12,
	12,13,13,12,12,12,13,12,12,13,13,13,13,12,13,12,
	13,13,12,12,12,12,12,12,12,13,13,13,12,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,12,12,12,13,12,
	12,13,13,13,13,12,13,12,13,13,13,13,13,13,13,13,
	13,13,13,13,10,11,11,12,12,10,11,11,12,12,10,11,
	11,12,12,11,12,12,12,12,11,12,12,12,12,11,11,11,
	12,12,11,11,12,12,13,11,12,12,12,12,12,12,12,13,
	13,12,12,12,13,13,10,11,11,12,12,11,12,12,12,12,
	11,12,11,12,12,12,12,12,13,13,12,12,12,13,12,11,
	12,12,12,12,12,12,12,12,13,12,12,12,13,13,12,12,
	13,13,13,12,13,13,13,13,11,12,12,12,12,12,12,12,
	13,13,12,12,12,13,12,12,13,13,13,13,12,13,12,13,
	13,10,11,11,12,12,11,12,12,12,12,11,12,12,12,12,
	12,12,12,13,13,12,12,12,13,13,11,12,12,12,12,12,
	12,12,12,13,12,12,12,13,13,12,12,13,13,13,12,12,
	13,13,13,11,12,12,12,12,12,12,12,13,13,11,12,12,
	13,12,12,13,13,13,13,12,13,12,13,13,12,12,12,12,
	13,12,12,13,13,13,12,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,12,12,12,13,12,12,12,13,13,13,12,
	12,12,13,13,13,13,13,13,13,12,13,13,13,13,10,11,
	11,12,12,11,12,12,12,12,11,12,12,12,12,12,12,12,
	13,13,12,12,12,13,13,11,12,12,12,12,12,12,12,12,
	13,12,12,12,13,13,12,12,13,13,13,12,12,13,13,13,
	11,12,11,12,12,12,12,12,13,13,11,12,12,13,12,12,
	13,12,13,13,12,13,12,13,13,12,12,12,12,12,12,12,
	13,13,13,12,13,12,13,13,12,13,13,13,13,13,13,13,
	13,13,12,12,12,13,12,12,13,12,13,13,12,13,12,13,
	13,13,13,13,13,13,12,13,12,13,13,10,11,11,12,12,
	11,12,12,12,12,11,12,12,13,12,12,12,12,13,13,12,
	12,12,13,13,11,12,12,12,12,12,12,12,12,13,12,12,
	12,13,13,12,12,13,13,13,12,13,13,13,13,11,12,12,
	12,12,12,12,12,13,13,12,12,12,13,12,12,13,13,13,
	13,12,13,12,13,13,12,12,12,12,13,12,12,13,13,13,
	12,13,13,13,13,13,13,13,13,13,13,13,13,13,13,12,
	12,12,12,12,12,13,13,13,13,12,13,12,13,13,13,13,
	13,13,13,13,13,13,13,13,11,11,11,12,12,11,12,12,
	12,12,11,12,12,12,12,12,12,12,13,13,12,12,12,13,
	13,11,12,12,12,12,12,12,12,13,13,12,12,12,13,13,
	12,12,13,13,13,12,13,13,13,13,11,12,12,12,12,12,
	12,12,13,13,12,12,12,13,12,12,13,12,13,13,12,13,
	12,13,13,12,12,12,12,12,12,13,13,13,13,12,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,12,12,12,12,
	12,12,13,13,13,13,12,13,12,13,12,13,13,13,13,13,
	13,13,13,13,12,
};

static const static_codebook _44p7_p4_1 = {
	5, 3125,
	(long *)_vq_lengthlist__44p7_p4_1,
	1, -533725184, 1611661312, 3, 0,
	(long *)_vq_quantlist__44p7_p4_1,
	0
};

static const long _vq_quantlist__44p7_p5_0[] = {
	2,
	1,
	3,
	0,
	4,
};

static const long _vq_lengthlist__44p7_p5_0[] = {
	 2, 6, 6, 9, 9, 5, 7, 8,10,11, 5, 8, 7,11,10, 8,
	10,11,12,13, 8,11,10,13,12, 6, 7, 8,10,11, 7, 8,
	10,10,12, 8, 9, 9,12,11,10,10,12,11,14,10,11,12,
	14,13, 6, 8, 7,11,10, 8, 9, 9,11,12, 7,10, 8,12,
	10,10,12,12,13,14,10,12,10,14,11, 9,10,11,11,12,
	10,10,11,11,13,11,12,12,13,13,12,11,13,11,15,13,
	14,13,14,14, 9,11,10,12,11,11,12,12,13,13,10,11,
	10,13,11,13,13,14,14,14,12,13,11,14,11, 7, 8, 9,
	11,12, 9, 9,11,12,13, 9,10,10,13,12,11,12,13,13,
	15,11,12,12,14,14, 9,10,10,12,13,10,10,12,12,14,
	11,11,11,13,13,12,12,13,13,15,12,13,13,15,14, 9,
	10,10,12,13,10,11,11,13,14,10,12,11,14,13,12,13,
	13,14,15,12,13,13,15,14,12,12,13,13,14,12,13,13,
	13,15,13,14,14,14,15,14,14,15,14,16,14,15,15,16,
	16,12,13,13,14,14,13,13,14,15,14,12,13,13,15,14,
	14,15,15,15,16,14,15,14,16,14, 7, 9, 8,12,11, 9,
	10,10,12,13, 9,11, 9,13,12,11,12,12,14,14,11,13,
	12,15,13, 9,10,10,13,12,10,11,12,13,14,10,12,11,
	14,13,12,13,13,14,15,13,13,13,15,14, 9,10,10,13,
	12,11,11,11,13,13,10,12,10,14,12,13,13,13,14,15,
	12,13,12,15,13,12,13,13,14,14,12,13,13,14,15,13,
	14,13,15,15,14,14,15,14,16,14,15,15,16,15,12,13,
	12,14,13,13,13,13,15,14,12,13,13,15,13,14,15,15,
	16,15,14,15,14,16,14,11,12,12,13,14,12,13,14,14,
	15,12,13,13,14,15,14,14,15,15,16,14,15,15,16,16,
	12,13,13,14,15,13,13,14,14,16,13,14,14,15,15,15,
	15,16,15,17,15,15,15,16,16,12,13,13,14,15,13,14,
	14,15,16,13,14,14,15,15,15,15,16,16,17,15,15,15,
	17,16,14,15,15,16,16,15,15,16,15,16,15,16,16,16,
	17,16,16,17,16,18,16,16,17,18,17,14,15,15,16,16,
	15,16,16,16,17,15,16,15,17,16,16,17,17,17,18,16,
	16,16,17,16,11,12,12,14,13,12,13,13,15,14,12,14,
	13,15,14,14,15,15,16,16,14,15,14,16,15,12,13,13,
	15,14,13,14,14,15,15,13,14,14,16,15,15,15,15,16,
	16,15,16,15,17,16,12,13,13,15,14,13,14,14,15,15,
	13,14,13,16,14,15,15,15,16,16,15,15,15,17,15,14,
	15,15,16,16,15,15,15,16,16,15,16,16,17,17,16,16,
	17,17,17,16,17,17,18,17,14,15,15,16,15,15,15,16,
	16,16,15,15,15,17,15,17,17,17,18,17,16,17,16,18,
	16, 6, 9, 9,12,12, 8,10,10,12,13, 9,11,10,13,12,
	10,12,12,14,14,11,13,12,14,14, 8,10,10,12,12, 9,
	10,11,12,14,10,11,11,13,13,12,12,13,13,15,12,13,
	13,15,14, 9,10,10,13,13,10,11,11,13,13,10,12,10,
	14,13,12,13,13,14,15,12,13,13,15,14,11,12,12,13,
	14,12,12,13,13,15,12,13,13,14,14,13,13,14,13,16,
	14,15,15,16,15,11,12,12,14,14,13,13,13,15,14,12,
	13,13,15,14,14,15,15,16,15,14,14,14,16,14, 7, 9,
	10,12,12, 9,10,11,13,13, 9,11,10,13,13,11,12,13,
	14,15,12,13,13,15,14, 9,10,11,12,13,10,10,12,13,
	14,11,11,12,14,14,12,12,14,14,15,13,13,13,15,15,
	 9,11,11,13,13,11,12,12,14,14,10,12,10,14,13,13,
	14,13,15,15,12,14,13,15,14,12,12,13,13,15,12,12,
	14,13,15,13,14,14,15,15,14,14,15,14,17,14,15,15,
	16,16,12,13,13,15,14,13,14,14,15,15,12,14,13,15,
	14,14,15,15,16,16,14,15,14,16,14, 7,10,10,12,12,
	10,11,11,12,13,10,12,10,14,12,12,13,13,14,15,12,
	13,13,15,14, 9,11,10,13,12,10,10,12,12,14,11,13,
	12,14,13,13,13,14,13,15,13,14,14,15,14,10,11,11,
	13,13,12,12,12,13,14,10,12,10,14,12,13,14,14,15,
	15,13,14,13,15,13,12,13,13,14,14,12,12,13,14,15,
	13,14,14,15,15,13,13,14,13,15,14,15,15,16,16,12,
	13,13,14,14,13,14,14,15,15,12,13,13,15,13,15,15,
	15,16,16,13,14,13,16,13,11,12,13,14,14,12,13,14,
	14,15,12,13,13,15,15,14,14,15,15,17,14,15,15,16,
	16,12,13,14,14,15,13,13,14,14,16,13,14,14,15,16,
	14,14,16,15,17,15,15,16,16,16,12,13,13,15,15,13,
	14,14,15,16,13,14,14,15,16,15,15,16,17,17,15,16,
	15,17,16,14,15,15,15,16,15,15,16,15,17,15,15,16,
	16,17,16,16,16,16,18,16,16,17,17,17,14,15,15,16,
	16,15,16,16,16,17,15,16,15,17,16,16,17,17,17,17,
	16,17,16,18,17,11,12,12,14,14,13,13,14,14,15,13,
	14,13,15,14,14,15,15,15,16,14,15,15,17,15,12,13,
	13,15,14,13,13,14,15,15,14,15,14,16,15,15,15,15,
	15,16,15,16,15,17,16,12,13,13,15,15,14,14,14,15,
	16,13,14,13,16,15,15,15,16,16,17,15,16,15,17,15,
	14,15,15,16,16,14,15,15,16,16,15,16,16,17,16,15,
	15,16,15,17,16,17,17,18,17,14,15,15,16,16,15,16,
	16,16,17,14,15,15,17,16,17,17,17,17,18,15,16,16,
	18,15, 6, 9, 9,12,12, 9,10,11,12,13, 8,10,10,13,
	12,11,12,13,14,14,10,12,12,14,13, 9,10,10,12,13,
	10,10,12,13,14,10,11,11,13,13,12,13,13,14,15,12,
	13,13,15,14, 8,10,10,12,12,10,11,11,13,13, 9,11,
	10,13,13,12,13,13,14,15,12,13,12,15,13,11,12,12,
	14,14,12,13,13,13,15,13,13,13,14,15,14,14,15,14,
	16,14,15,15,15,15,11,12,12,14,13,12,13,13,15,14,
	12,13,12,15,13,14,14,15,16,16,13,14,13,16,13, 7,
	10,10,12,12,10,10,12,12,14,10,11,11,13,12,12,13,
	13,13,15,12,13,13,15,14,10,11,11,13,13,10,10,12,
	12,14,12,12,12,14,13,13,13,14,13,15,13,14,14,15,
	14, 9,10,11,13,13,11,12,12,13,14,10,12,10,14,12,
	13,13,14,14,15,13,13,12,15,13,12,13,13,14,14,12,
	13,13,14,15,13,14,14,15,15,13,13,15,13,16,15,15,
	15,16,16,12,13,13,14,14,13,14,14,15,15,12,13,12,
	15,14,15,15,15,16,16,13,14,13,15,13, 7,10, 9,12,
	12, 9,10,11,13,13, 9,11,10,13,13,11,13,13,14,15,
	11,13,12,15,14, 9,11,11,13,13,10,10,12,13,14,11,
	12,12,14,14,12,13,14,14,15,13,13,13,15,15, 9,11,
	10,13,12,11,12,11,14,14,10,12,10,14,13,13,14,13,
	15,15,12,14,12,15,14,12,13,13,14,15,13,13,14,14,
	15,13,14,14,15,15,14,14,15,14,17,14,15,15,16,16,
	12,13,12,15,13,13,14,14,15,15,12,14,13,15,13,14,
	15,15,16,16,14,15,14,16,14,11,12,12,14,14,13,13,
	14,14,15,13,14,13,15,15,14,15,15,16,17,14,15,15,
	16,15,12,13,13,15,15,13,13,14,15,16,14,14,14,16,
	15,15,15,16,15,17,15,16,15,17,16,12,13,13,14,15,
	14,14,15,15,16,13,14,13,15,15,15,15,16,16,17,15,
	15,15,16,15,14,15,15,16,16,14,15,15,16,17,15,16,
	16,17,17,16,15,16,15,17,16,17,17,17,17,14,15,15,
	15,16,15,15,16,16,17,14,15,15,16,16,16,16,17,17,
	18,15,16,15,17,15,11,13,12,14,14,12,13,13,15,15,
	12,14,13,15,14,14,15,15,16,16,14,15,14,16,15,12,
	13,13,15,15,13,14,14,15,16,13,14,14,16,16,15,15,
	16,16,17,15,16,15,17,16,12,13,13,15,14,13,14,14,
	16,15,13,14,13,16,14,15,16,15,17,16,15,15,14,18,
	15,14,15,15,16,16,15,15,16,16,17,15,16,15,17,16,
	16,16,17,17,18,16,17,17,18,17,14,15,15,16,15,15,
	16,15,17,16,15,15,15,17,15,16,17,17,18,17,16,17,
	16,18,15,10,12,12,14,14,12,13,13,14,14,12,13,13,
	14,14,13,14,14,15,15,13,14,14,16,15,11,12,13,14,
	14,12,13,13,15,15,12,13,13,15,15,13,14,15,15,16,
	14,15,15,16,16,12,13,13,14,14,13,13,14,15,15,13,
	14,13,15,15,14,15,15,16,16,14,15,14,16,15,13,14,
	14,15,15,13,14,14,15,16,14,14,15,16,16,14,15,15,
	15,17,15,16,16,17,17,13,14,14,15,15,14,15,15,16,
	16,14,15,15,16,16,15,16,16,16,17,15,16,15,17,16,
	11,12,12,14,14,12,13,13,14,15,12,13,13,15,14,13,
	14,14,15,16,13,14,14,16,15,12,13,13,14,15,13,13,
	14,15,15,13,14,14,15,15,14,14,15,15,17,14,15,15,
	16,16,12,13,13,15,15,13,14,14,15,15,13,14,13,15,
	15,14,15,15,16,17,14,15,15,16,16,13,13,14,15,16,
	14,14,15,15,16,14,15,15,16,16,15,15,16,15,18,15,
	16,16,17,17,14,15,15,16,16,15,15,15,16,16,14,15,
	15,17,16,16,16,16,17,17,15,16,16,17,16,10,12,12,
	14,14,12,13,13,14,15,12,13,13,15,14,14,14,15,15,
	16,14,15,14,16,15,12,13,13,15,14,13,13,14,15,15,
	13,14,14,15,15,14,14,15,15,16,14,15,15,16,16,12,
	13,13,15,15,13,14,14,15,16,13,14,13,15,14,15,15,
	15,16,16,14,15,15,16,15,13,14,14,16,15,14,14,14,
	15,16,14,15,15,16,16,15,15,16,15,17,16,17,16,17,
	17,14,14,15,15,16,15,15,16,16,16,14,15,14,16,15,
	16,16,16,17,17,15,16,15,17,15,11,13,13,14,15,13,
	13,14,15,15,13,14,13,15,15,14,15,15,15,16,14,15,
	15,17,15,13,13,14,15,15,13,14,15,15,16,14,14,14,
	16,16,15,14,16,15,17,15,16,16,17,16,13,14,14,15,
	15,14,14,14,16,16,13,15,14,16,15,15,15,16,17,17,
	15,16,15,17,16,14,15,15,15,16,15,15,16,15,17,15,
	16,16,16,17,16,16,17,15,18,16,17,17,17,17,14,15,
	15,16,16,15,16,16,17,17,15,16,15,17,16,16,17,17,
	18,18,16,17,15,18,16,10,12,12,14,14,13,13,14,14,
	15,13,14,13,15,14,14,15,15,15,16,15,15,15,16,15,
	12,13,13,15,14,12,12,14,14,15,14,15,14,16,15,15,
	14,15,14,17,15,16,16,17,16,12,13,13,14,15,14,14,
	15,15,16,13,14,12,16,14,15,16,16,16,17,15,16,14,
	17,15,14,15,14,16,15,14,14,15,15,15,15,16,15,17,
	16,15,14,16,14,16,16,17,17,18,17,14,14,15,15,16,
	15,16,16,16,17,14,15,14,16,15,16,16,17,17,17,15,
	16,14,17,14,10,12,12,14,13,12,13,13,14,14,11,13,
	12,14,14,13,14,14,15,16,13,14,14,16,15,12,13,13,
	14,14,13,13,14,15,15,13,14,13,15,15,14,14,15,15,
	16,14,15,15,16,16,11,13,12,14,14,12,13,13,15,15,
	12,13,13,15,15,14,15,15,16,16,13,14,14,16,15,13,
	14,14,15,15,14,15,15,15,16,14,15,15,16,16,15,16,
	16,16,17,16,16,16,17,17,13,14,14,15,15,14,15,15,
	16,16,13,14,14,16,15,15,16,16,17,17,15,15,15,17,
	15,11,12,12,14,14,12,13,13,14,15,12,13,13,15,14,
	14,14,15,15,16,14,14,14,16,15,12,13,13,15,14,13,
	13,14,15,15,13,14,14,16,15,14,15,15,15,16,15,15,
	15,16,16,12,13,13,14,15,13,13,14,15,15,13,14,13,
	15,15,15,15,15,16,16,14,15,14,16,15,14,14,15,16,
	16,14,15,15,15,16,15,16,15,16,16,15,15,16,15,17,
	16,16,16,17,17,13,14,14,15,16,14,15,15,16,16,14,
	14,14,16,16,16,16,16,17,17,15,15,15,17,15,11,12,
	12,14,14,12,13,13,14,15,12,13,13,15,14,14,14,14,
	15,16,13,14,14,16,15,12,13,13,15,15,13,13,14,15,
	16,13,14,14,15,15,14,15,15,16,17,14,15,15,17,16,
	12,13,13,15,14,13,14,14,15,15,13,14,13,15,15,14,
	15,15,16,16,14,15,14,17,15,14,15,15,16,16,14,15,
	15,16,17,15,15,15,17,17,15,16,16,16,17,16,17,16,
	17,17,13,15,14,16,15,14,15,15,16,16,14,15,14,16,
	15,16,16,16,17,17,15,16,15,17,15,10,12,12,14,14,
	13,13,14,14,15,13,14,13,15,14,14,15,15,15,17,14,
	15,15,16,15,12,13,13,15,14,12,12,14,14,15,14,15,
	14,16,15,15,14,16,15,17,15,16,16,17,16,12,13,13,
	14,15,14,14,15,15,16,12,14,12,15,14,15,16,16,16,
	17,15,16,14,17,14,14,15,14,16,16,14,14,15,15,16,
	15,16,16,17,16,15,14,16,14,17,16,17,17,18,17,14,
	14,15,15,16,15,15,16,16,17,14,15,14,16,15,16,17,
	17,17,18,15,16,14,17,14,11,13,13,15,14,13,13,14,
	15,15,12,14,13,15,15,14,15,15,15,17,14,15,14,16,
	15,13,14,14,15,15,13,14,15,15,16,14,15,14,16,16,
	15,15,16,16,17,15,16,16,17,17,13,14,13,15,15,14,
	14,14,16,16,13,15,14,16,15,15,16,16,17,17,15,16,
	14,17,15,15,15,15,16,17,15,15,16,16,17,15,16,16,
	17,17,16,15,17,16,17,17,17,17,18,18,14,15,15,17,
	15,15,16,16,17,16,15,16,15,17,15,16,17,17,17,17,
	16,17,15,18,15,
};

static const static_codebook _44p7_p5_0 = {
	5, 3125,
	(long *)_vq_lengthlist__44p7_p5_0,
	1, -528744448, 1616642048, 3, 0,
	(long *)_vq_quantlist__44p7_p5_0,
	0
};

static const long _vq_quantlist__44p7_p5_1[] = {
	3,
	2,
	4,
	1,
	5,
	0,
	6,
};

static const long _vq_lengthlist__44p7_p5_1[] = {
	 2, 3, 3, 3, 3, 3, 3,
};

static const static_codebook _44p7_p5_1 = {
	1, 7,
	(long *)_vq_lengthlist__44p7_p5_1,
	1, -533200896, 1611661312, 3, 0,
	(long *)_vq_quantlist__44p7_p5_1,
	0
};

static const long _vq_quantlist__44p7_p6_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p7_p6_0[] = {
	 2, 5, 6, 5, 7, 8, 5, 8, 7, 5, 7, 7, 7, 7, 9, 8,
	 9, 9, 5, 7, 7, 8, 9, 9, 7, 9, 7, 6, 8, 8, 8, 9,
	10, 8, 9, 9, 8, 9,10, 9, 9,11,10,10,11, 8,10, 9,
	10,10,11, 9,10,10, 6, 8, 8, 8, 9, 9, 8,10, 9, 8,
	 9,10, 9,10,10,10,11,10, 8,10, 9,10,11,10, 9,11,
	 9, 6, 8, 8, 7, 9, 9, 8, 9, 9, 7, 9, 9, 9, 9,10,
	 9,10,10, 8, 9, 9, 9,10,10, 9,10, 9, 7, 9, 9, 9,
	10,10, 9,10,10, 9, 9,10,10, 9,11,10,11,11, 9,10,
	10,10,11,11,10,11,10, 6, 9, 8, 9,10,10, 9,10, 9,
	 8,10,10, 9, 9,10,10,11,11, 9,10,10,10,11,11, 9,
	11, 9, 6, 8, 8, 8, 9, 9, 7, 9, 9, 8, 9, 9, 9, 9,
	10, 9,10,10, 7, 9, 9, 9,10,10, 9,10, 9, 6, 8, 9,
	 9, 9,10, 9,10,10, 9,10,10, 9, 9,11,10,11,11, 8,
	10,10,10,11,11, 9,10, 9, 7, 9, 9, 9,10,10, 9,10,
	10, 9,10,10,10,10,11,10,11,11, 9,10, 9,10,11,11,
	10,11, 9,
};

static const static_codebook _44p7_p6_0 = {
	5, 243,
	(long *)_vq_lengthlist__44p7_p6_0,
	1, -527106048, 1620377600, 2, 0,
	(long *)_vq_quantlist__44p7_p6_0,
	0
};

static const long _vq_quantlist__44p7_p6_1[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p7_p6_1[] = {
	 4, 7, 7, 6, 7, 8, 6, 8, 7, 7, 7, 8, 7, 7, 8, 8,
	 8, 8, 7, 7, 7, 8, 8, 8, 7, 8, 8, 7, 8, 8, 8, 8,
	 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 8, 9, 9, 8, 8, 8,
	 8, 9, 9, 8, 9, 8, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8,
	 8, 8, 8, 8, 9, 8, 9, 9, 8, 8, 8, 8, 9, 9, 8, 9,
	 8, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9,
	 8, 9, 9, 8, 8, 8, 8, 9, 9, 8, 9, 8, 7, 8, 8, 8,
	 8, 9, 8, 9, 8, 8, 8, 8, 8, 8, 9, 8, 9, 9, 8, 8,
	 8, 9, 9, 9, 8, 9, 9, 7, 8, 8, 8, 8, 8, 8, 8, 8,
	 8, 8, 8, 8, 8, 9, 8, 9, 9, 8, 8, 8, 8, 9, 9, 8,
	 9, 8, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
	 9, 8, 9, 9, 8, 8, 8, 8, 9, 9, 8, 9, 8, 7, 8, 8,
	 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 8, 9, 9, 8,
	 8, 8, 8, 9, 9, 8, 9, 8, 8, 8, 8, 8, 8, 8, 8, 8,
	 8, 8, 8, 8, 8, 9, 9, 8, 9, 9, 8, 8, 8, 9, 9, 9,
	 8, 9, 8,
};

static const static_codebook _44p7_p6_1 = {
	5, 243,
	(long *)_vq_lengthlist__44p7_p6_1,
	1, -530841600, 1616642048, 2, 0,
	(long *)_vq_quantlist__44p7_p6_1,
	0
};

static const long _vq_quantlist__44p7_p7_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p7_p7_0[] = {
	 1, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9,
};

static const static_codebook _44p7_p7_0 = {
	5, 243,
	(long *)_vq_lengthlist__44p7_p7_0,
	1, -513979392, 1633504256, 2, 0,
	(long *)_vq_quantlist__44p7_p7_0,
	0
};

static const long _vq_quantlist__44p7_p7_1[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p7_p7_1[] = {
	 1, 5, 5, 4,10,10, 5,10,10, 5,10,10,10,10,10,10,
	10,10, 5,10,10,10,10,10, 9,10,10, 6,10,10,10,10,
	10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
	10,10,10,10,10,10, 7,10,10,10,10,10,10,10,10,10,
	10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
	10, 6,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
	10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
	10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
	10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
	10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
	10,10, 6,10,10,10,10,10,10,10,10,10,10,10,10,10,
	10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
	10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
	10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
	10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,
	10,11,11,
};

static const static_codebook _44p7_p7_1 = {
	5, 243,
	(long *)_vq_lengthlist__44p7_p7_1,
	1, -516716544, 1630767104, 2, 0,
	(long *)_vq_quantlist__44p7_p7_1,
	0
};

static const long _vq_quantlist__44p7_p7_2[] = {
	12,
	11,
	13,
	10,
	14,
	9,
	15,
	8,
	16,
	7,
	17,
	6,
	18,
	5,
	19,
	4,
	20,
	3,
	21,
	2,
	22,
	1,
	23,
	0,
	24,
};

static const long _vq_lengthlist__44p7_p7_2[] = {
	 1, 3, 2, 4, 5, 7, 7, 8, 8, 9, 9,10,10,11,11,12,
	12,13,13,14,14,15,15,15,15,
};

static const static_codebook _44p7_p7_2 = {
	1, 25,
	(long *)_vq_lengthlist__44p7_p7_2,
	1, -518864896, 1620639744, 5, 0,
	(long *)_vq_quantlist__44p7_p7_2,
	0
};

static const long _vq_quantlist__44p7_p7_3[] = {
	12,
	11,
	13,
	10,
	14,
	9,
	15,
	8,
	16,
	7,
	17,
	6,
	18,
	5,
	19,
	4,
	20,
	3,
	21,
	2,
	22,
	1,
	23,
	0,
	24,
};

static const long _vq_lengthlist__44p7_p7_3[] = {
	 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5,
	 5, 5, 5, 5, 5, 5, 5, 5, 5,
};

static const static_codebook _44p7_p7_3 = {
	1, 25,
	(long *)_vq_lengthlist__44p7_p7_3,
	1, -529006592, 1611661312, 5, 0,
	(long *)_vq_quantlist__44p7_p7_3,
	0
};

static const long _huff_lengthlist__44p7_short[] = {
	 3, 9,14,16,17,19,22,22, 5, 4, 6, 9,11,13,17,20,
	 9, 5, 5, 6, 9,11,15,19,11, 7, 5, 5, 7, 9,13,17,
	14, 9, 7, 6, 6, 7,11,14,16,11, 9, 7, 6, 4, 4, 8,
	19,15,13,11, 9, 4, 3, 4,21,16,16,15,12, 6, 4, 4,
};

static const static_codebook _huff_book__44p7_short = {
	2, 64,
	(long *)_huff_lengthlist__44p7_short,
	0, 0, 0, 0, 0,
	NULL,
	0
};

static const long _vq_quantlist__44p8_l0_0[] = {
	6,
	5,
	7,
	4,
	8,
	3,
	9,
	2,
	10,
	1,
	11,
	0,
	12,
};

static const long _vq_lengthlist__44p8_l0_0[] = {
	 2, 4, 4, 7, 7, 8, 8,10,10,11,11,12,12, 4, 5, 5,
	 7, 7, 9, 9,10, 9,12,10,12,12, 4, 5, 5, 7, 7, 9,
	 9, 9,10,10,12,12,12, 7, 7, 7, 7, 8, 9, 8,11, 5,
	12, 6,12,10, 7, 7, 7, 8, 7, 8, 9, 5,11, 6,12,10,
	12, 8, 9, 9, 9, 9, 9, 9,11, 7,11, 7,11, 9, 8, 9,
	 9, 9, 9, 9, 9, 7,10, 7,11, 9,11,10,10,10,10,10,
	10,10,11,10,11, 8,12, 9,10,10,10,10,10,10,10,10,
	11, 8,11, 9,12,10,11,11,11,11,11,11,11,11,12,10,
	12,11,10,11,11,11,11,11,11,11,11,10,12,11,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,11,12,12,12,
	12,12,12,12,12,12,11,12,12,
};

static const static_codebook _44p8_l0_0 = {
	2, 169,
	(long *)_vq_lengthlist__44p8_l0_0,
	1, -526516224, 1616117760, 4, 0,
	(long *)_vq_quantlist__44p8_l0_0,
	0
};

static const long _vq_quantlist__44p8_l0_1[] = {
	2,
	1,
	3,
	0,
	4,
};

static const long _vq_lengthlist__44p8_l0_1[] = {
	 4, 4, 4, 5, 5, 4, 4, 5, 5, 5, 4, 5, 4, 5, 5, 5,
	 5, 5, 5, 5, 5, 5, 5, 5, 5,
};

static const static_codebook _44p8_l0_1 = {
	2, 25,
	(long *)_vq_lengthlist__44p8_l0_1,
	1, -533725184, 1611661312, 3, 0,
	(long *)_vq_quantlist__44p8_l0_1,
	0
};

static const long _vq_quantlist__44p8_l1_0[] = {
	54,
	29,
	79,
	0,
	108,
};

static const long _vq_lengthlist__44p8_l1_0[] = {
	 1, 2, 3, 6, 7, 7, 6, 7, 7, 8, 8, 8, 8, 8, 8, 8,
	 8, 8, 8, 8, 8, 8, 8, 8, 8,
};

static const static_codebook _44p8_l1_0 = {
	2, 25,
	(long *)_vq_lengthlist__44p8_l1_0,
	1, -514516992, 1620639744, 7, 0,
	(long *)_vq_quantlist__44p8_l1_0,
	0
};

static const long _huff_lengthlist__44p8_lfe[] = {
	 2, 3, 1, 3,
};

static const static_codebook _huff_book__44p8_lfe = {
	2, 4,
	(long *)_huff_lengthlist__44p8_lfe,
	0, 0, 0, 0, 0,
	NULL,
	0
};

static const long _huff_lengthlist__44p8_long[] = {
	 2, 7,14,16,17,18,20,21, 7, 4, 6, 8,11,12,14,16,
	13, 5, 4, 4, 8, 9,11,13,15, 8, 4, 3, 5, 7, 9,10,
	17,11, 8, 4, 4, 6, 9, 9,17,11, 9, 7, 6, 5, 7, 8,
	19,13,11, 9, 9, 7, 8, 8,21,15,13,11,10, 8, 8, 7,
};

static const static_codebook _huff_book__44p8_long = {
	2, 64,
	(long *)_huff_lengthlist__44p8_long,
	0, 0, 0, 0, 0,
	NULL,
	0
};

static const long _vq_quantlist__44p8_p1_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p8_p1_0[] = {
	 2, 5, 5, 4, 7, 7, 4, 7, 7, 5, 7, 7, 7, 8, 9, 7,
	 9, 9, 5, 7, 7, 7, 9, 9, 7, 9, 8, 6, 7, 8, 8, 9,
	10, 8, 9,10, 8, 9,10,10,10,12,10,11,12, 8,10,10,
	10,11,12,10,11,11, 6, 8, 7, 8,10, 9, 8,10, 9, 8,
	10,10,10,11,11,10,12,11, 8,10, 9,10,12,11,10,12,
	10, 5, 8, 8, 8,10,10, 8,10,10, 7, 9,10, 9,10,11,
	 9,11,11, 8,10,10,10,12,12,10,12,11, 7, 9, 9, 9,
	10,11, 9,11,11, 9, 9,11,10,11,12,10,11,12, 9,11,
	11,11,12,12,11,12,12, 7, 9, 9,10,11,11,10,12,11,
	 9,11,10,11,11,12,11,13,12,10,11,11,12,13,13,11,
	13,11, 5, 8, 8, 8,10,10, 8,10,10, 8,10,10,10,11,
	12,10,12,11, 7,10, 9, 9,11,11, 9,11,10, 7, 9, 9,
	10,11,12,10,11,11,10,11,11,11,11,13,12,13,13, 9,
	10,11,12,12,13,11,12,11, 7, 9, 9, 9,11,11, 9,11,
	10, 9,11,11,11,12,12,11,12,12, 9,11, 9,10,12,11,
	10,12,11,
};

static const static_codebook _44p8_p1_0 = {
	5, 243,
	(long *)_vq_lengthlist__44p8_p1_0,
	1, -535822336, 1611661312, 2, 0,
	(long *)_vq_quantlist__44p8_p1_0,
	0
};

static const long _vq_quantlist__44p8_p2_0[] = {
	2,
	1,
	3,
	0,
	4,
};

static const long _vq_lengthlist__44p8_p2_0[] = {
	 4, 6, 6, 9, 9, 6, 8, 8,10,10, 6, 8, 8,10,10, 8,
	 9,10,12,12, 8,10, 9,12,12, 6, 8, 8,10,10, 8, 8,
	 9,10,11, 8, 9, 9,11,11, 9,10,11,12,13,10,11,11,
	13,13, 6, 8, 8,10,10, 8, 9, 9,11,11, 8, 9, 8,11,
	10,10,11,11,13,13, 9,11,10,13,12, 9,10,10,12,12,
	10,10,11,12,13,10,11,11,13,13,12,12,13,12,15,12,
	13,13,15,14, 9,10,10,12,12,10,11,11,13,13,10,11,
	10,13,12,12,13,13,14,15,12,13,12,15,12, 7, 8, 8,
	10,11, 8, 9,10,11,12, 8, 9, 9,11,11,10,11,11,13,
	14,10,11,11,13,13, 8, 9, 9,11,12, 9,10,11,11,13,
	 9,10,10,12,12,11,11,12,13,15,11,12,12,14,14, 8,
	 9, 9,11,11, 9,10,11,12,13, 9,10,10,12,12,11,12,
	12,14,15,11,12,12,14,14,10,11,12,13,13,11,12,12,
	13,14,12,12,12,14,14,13,13,14,14,16,14,14,14,16,
	15,10,11,11,13,13,12,12,12,14,14,11,12,12,14,13,
	14,14,14,15,16,13,14,13,16,14, 7, 8, 8,11,10, 8,
	 9, 9,11,11, 8,10, 9,12,11,10,11,11,13,13,10,11,
	11,14,13, 8, 9, 9,12,11, 9,10,10,12,12, 9,11,10,
	13,12,11,12,12,13,14,11,12,12,15,14, 8, 9, 9,12,
	11, 9,10,10,12,12, 9,11,10,13,11,11,12,12,14,14,
	11,12,12,14,13,10,11,11,13,13,11,12,12,13,14,12,
	13,12,14,14,13,13,14,14,16,13,14,14,16,15,10,11,
	11,13,13,12,12,12,14,14,11,12,12,14,13,13,14,14,
	15,15,13,14,13,16,14, 9,10,11,12,13,11,11,12,12,
	14,11,11,12,13,14,13,13,14,14,16,13,13,14,15,15,
	11,11,12,12,14,12,12,13,13,15,12,12,13,13,15,14,
	14,15,15,16,14,14,14,15,16,11,12,12,13,14,12,12,
	13,14,15,12,13,12,14,14,14,14,15,15,16,14,14,14,
	16,16,13,13,14,15,16,14,14,15,15,16,14,15,15,16,
	16,15,15,16,16,18,16,16,16,17,17,13,14,14,15,15,
	14,14,15,16,16,14,15,14,16,16,16,16,16,17,18,15,
	16,16,17,16, 9,11,10,13,12,11,12,11,14,13,11,12,
	11,14,12,13,14,13,15,14,13,14,13,16,14,11,12,12,
	14,13,12,12,13,14,14,12,13,12,15,14,14,14,14,16,
	16,14,15,14,17,15,11,12,11,14,12,12,13,12,15,13,
	12,13,12,15,13,14,14,14,16,15,14,15,14,16,15,13,
	14,14,15,15,14,14,15,16,16,14,15,14,16,16,15,15,
	16,16,17,16,16,16,17,17,13,14,14,16,15,14,15,15,
	16,16,14,15,14,17,15,16,16,16,17,17,15,16,15,18,
	16, 7, 8, 8,10,11, 8, 9, 9,11,12, 8, 9, 9,12,11,
	10,11,11,13,14,10,11,11,14,13, 8, 9, 9,11,11, 9,
	10,10,12,12, 9,10,10,12,12,11,12,12,13,14,11,12,
	12,14,14, 8, 9, 9,12,11, 9,10,11,12,13, 9,11,10,
	13,12,11,12,12,14,14,11,12,12,14,13,10,11,11,13,
	13,11,12,12,13,14,11,12,12,14,14,13,13,14,14,16,
	13,14,14,16,15,10,12,11,13,13,12,12,12,14,14,11,
	12,12,14,13,14,14,14,15,16,13,14,14,16,14, 8, 9,
	 9,11,11, 9,10,10,12,12, 9,10,10,12,12,11,11,12,
	13,14,11,12,12,14,14, 9, 9,10,11,12,10,10,11,12,
	13,10,10,11,12,13,12,12,13,14,15,12,12,13,14,15,
	 9,10,10,12,12,10,11,11,13,13,10,11,11,13,13,12,
	13,13,15,15,12,13,13,15,14,11,11,12,13,14,12,12,
	13,13,15,12,12,13,14,15,14,14,15,14,16,14,14,15,
	15,16,11,12,12,14,14,12,13,13,15,15,12,13,13,15,
	14,14,15,15,16,16,14,15,14,17,15, 8, 9, 9,11,11,
	 9,10,10,12,12, 9,11,10,13,12,11,12,12,14,14,11,
	13,12,15,13, 9,10,10,12,12,10,10,11,12,13,10,12,
	11,13,13,12,12,13,13,15,12,13,13,15,14, 9,10,10,
	12,12,11,11,12,13,13,10,12,10,13,12,12,13,13,15,
	15,12,13,13,15,13,11,12,12,14,14,12,12,13,14,14,
	12,13,13,15,14,13,13,14,13,16,14,15,14,16,16,11,
	12,12,14,14,13,13,13,15,15,12,13,12,15,14,14,15,
	15,16,17,14,15,13,16,13,10,11,11,13,14,11,12,12,
	13,15,11,12,12,14,14,13,14,14,15,16,13,14,14,16,
	16,11,11,12,12,14,12,12,13,13,15,12,13,13,13,15,
	14,14,15,14,17,14,14,15,15,16,11,12,12,14,14,12,
	13,13,15,15,12,13,13,15,15,14,15,15,16,17,14,15,
	15,16,16,13,14,14,14,16,14,14,15,14,17,14,15,15,
	14,17,16,16,17,15,18,16,16,17,16,18,13,14,14,16,
	16,14,15,15,17,16,14,15,15,17,16,16,17,17,18,18,
	16,17,16,18,17,10,11,11,14,13,11,12,12,14,14,11,
	13,12,15,14,14,14,14,16,15,14,15,14,16,15,11,12,
	12,14,13,12,13,13,15,14,13,14,13,15,14,14,15,15,
	16,16,14,15,15,17,15,11,12,12,14,14,13,13,13,15,
	15,12,13,13,15,14,15,15,15,17,17,14,15,15,17,15,
	13,14,14,16,15,14,15,15,16,16,15,15,15,17,16,16,
	16,16,16,17,16,17,16,18,17,14,14,14,16,16,15,15,
	15,16,16,14,15,14,17,16,16,17,17,17,18,16,17,16,
	18,16, 7, 8, 8,11,11, 8, 9, 9,11,12, 8, 9, 9,12,
	11,10,11,11,13,14,10,11,11,14,13, 8, 9, 9,11,12,
	 9,10,11,12,13, 9,11,10,13,12,11,12,12,13,14,11,
	12,12,14,14, 8, 9, 9,11,11, 9,10,10,12,12, 9,10,
	10,13,12,11,12,12,14,14,11,12,11,14,13,10,11,12,
	13,13,11,12,12,13,14,12,13,12,14,14,13,13,14,14,
	16,13,14,14,16,15,10,11,11,13,13,11,12,12,14,14,
	11,12,12,14,13,13,14,14,15,16,13,14,13,16,14, 8,
	 9, 9,11,11, 9,10,11,12,13, 9,10,10,12,12,11,12,
	13,13,14,11,12,12,14,14, 9,10,10,12,12,10,10,11,
	12,13,11,12,11,13,13,12,12,13,13,15,12,13,13,15,
	15, 9,10,10,12,12,10,11,12,13,14,10,11,10,13,12,
	12,13,13,14,15,12,13,12,15,13,12,12,12,14,14,12,
	12,13,14,15,13,13,13,15,15,14,14,15,13,16,14,15,
	15,16,16,11,12,12,14,14,12,13,13,14,15,12,13,12,
	14,14,14,14,15,16,16,13,14,13,16,14, 8, 9, 9,11,
	11, 9,10,10,12,12, 9,10,10,12,12,11,12,12,14,14,
	11,12,11,14,14, 9,10,10,12,12,10,11,11,13,13,10,
	11,11,13,13,12,13,13,14,15,12,13,13,15,14, 9,10,
	 9,12,11,10,11,10,13,12,10,11,10,13,12,12,13,12,
	15,14,12,13,12,15,14,11,12,12,14,14,12,13,13,14,
	15,12,13,13,15,15,14,14,15,15,17,14,15,15,16,16,
	11,12,11,14,13,12,13,12,15,14,12,13,12,15,13,14,
	15,14,16,15,13,15,14,17,14,10,11,11,13,14,11,12,
	13,13,15,11,12,12,14,14,14,14,15,15,17,13,14,14,
	15,16,11,12,12,14,14,12,12,13,14,15,13,13,13,15,
	15,14,15,15,15,17,15,15,15,16,16,11,12,12,13,14,
	13,13,14,14,15,12,13,13,14,15,14,15,15,16,17,14,
	15,15,16,16,14,14,14,16,16,14,14,15,15,17,15,15,
	15,17,16,16,16,17,16,18,16,17,17,18,17,13,14,14,
	15,16,14,15,15,16,17,14,15,15,16,16,16,17,17,17,
	18,16,16,16,17,16,10,11,11,14,13,11,12,12,14,14,
	11,12,12,15,13,13,14,14,16,15,13,14,14,16,15,11,
	12,12,14,14,12,13,13,15,15,12,13,13,15,15,14,15,
	15,16,17,14,15,15,17,16,11,12,11,14,12,12,13,13,
	15,13,12,13,12,15,13,14,15,15,16,15,14,15,14,17,
	14,13,14,14,16,16,14,15,15,16,17,14,15,15,16,17,
	16,16,17,17,18,16,17,17,18,18,13,14,14,16,13,14,
	15,15,17,14,14,15,14,17,14,16,17,16,17,16,16,17,
	16,18,15, 8,11,11,13,13,10,12,12,14,14,11,12,12,
	14,14,13,13,14,15,16,13,14,14,16,15,10,11,11,14,
	14,11,12,12,14,15,11,12,12,15,14,13,14,14,15,16,
	13,14,14,16,16,11,12,12,14,14,12,13,13,15,15,12,
	13,12,15,14,14,14,15,16,16,14,15,14,16,16,12,13,
	13,15,15,12,13,14,15,16,13,14,14,16,16,14,15,15,
	16,17,15,15,16,17,17,13,14,14,16,15,14,15,15,16,
	16,14,15,14,16,16,16,16,16,17,17,15,16,16,18,16,
	10,11,11,13,14,11,12,12,14,15,11,12,12,15,14,13,
	14,14,16,16,13,14,14,16,16,11,11,12,14,14,12,12,
	13,14,15,12,13,13,15,15,14,14,15,15,17,14,14,15,
	16,16,11,12,12,15,14,12,13,13,15,15,12,13,13,15,
	15,14,15,15,17,17,14,15,15,17,16,13,12,14,14,16,
	13,13,15,14,17,14,13,15,15,17,15,14,16,15,18,16,
	15,16,16,18,13,14,14,16,16,14,15,15,17,17,14,15,
	15,17,16,16,17,17,18,18,16,17,16,18,17,10,11,11,
	14,13,11,12,12,14,14,11,13,12,15,14,13,14,14,15,
	16,13,14,14,16,16,11,12,12,14,14,12,13,13,14,15,
	12,13,13,15,15,14,14,15,15,16,14,15,15,17,16,11,
	12,12,14,14,13,13,13,15,15,12,13,13,15,14,14,15,
	15,16,17,14,15,14,17,15,13,14,13,16,15,14,14,14,
	15,16,14,15,14,16,16,15,15,16,16,17,16,16,16,18,
	17,14,14,14,16,16,15,15,15,17,16,14,15,14,17,16,
	16,16,17,17,18,16,17,16,18,16,11,13,13,15,15,12,
	13,14,15,16,12,14,14,15,15,14,15,15,16,17,14,15,
	15,17,17,12,13,14,14,16,13,14,14,14,16,14,14,14,
	15,16,15,15,16,15,18,15,16,16,17,17,13,14,14,16,
	16,14,14,15,16,16,14,15,14,16,16,15,16,16,17,18,
	15,16,16,18,17,14,14,16,13,17,15,15,16,14,18,15,
	15,16,14,18,16,16,18,15,19,17,17,18,16,18,15,16,
	15,17,17,15,16,17,18,18,16,16,16,18,17,17,18,18,
	19,19,17,18,17,19,18,11,12,12,15,14,13,13,14,15,
	16,13,14,13,16,14,15,15,15,16,17,15,16,15,17,16,
	12,13,13,15,14,13,13,14,15,15,14,15,14,16,15,15,
	15,16,16,17,16,16,16,18,17,12,13,13,15,15,14,14,
	15,16,16,13,14,13,16,15,16,16,16,17,18,15,16,15,
	17,16,14,15,14,17,15,14,15,15,16,16,15,16,15,17,
	16,16,15,16,15,17,17,18,17,18,17,15,15,15,16,17,
	16,16,16,17,17,15,16,15,17,16,17,18,18,18,18,16,
	17,16,18,15, 8,11,11,13,13,11,12,12,14,14,10,12,
	12,14,14,13,14,14,15,16,13,14,13,16,15,11,12,12,
	14,14,12,12,13,14,15,12,13,13,15,15,14,14,15,15,
	16,14,14,14,16,16,10,11,11,14,14,11,12,12,14,15,
	11,12,12,15,14,13,14,14,16,16,13,14,14,16,15,13,
	14,14,15,16,14,14,15,16,16,14,15,15,16,16,15,16,
	16,16,18,16,16,16,17,17,12,13,13,15,15,13,14,14,
	16,16,12,14,13,16,15,15,16,15,17,17,14,16,15,17,
	16,10,11,11,13,14,11,12,13,14,15,11,13,12,14,14,
	14,14,15,16,16,13,14,14,16,16,11,12,12,14,14,12,
	13,13,14,15,13,14,13,15,15,14,15,15,16,17,14,15,
	15,17,16,11,12,12,14,14,12,13,13,15,15,12,13,12,
	15,14,14,15,15,16,17,14,15,15,16,16,14,14,14,16,
	16,14,14,15,16,16,15,15,15,16,16,16,16,17,16,18,
	16,17,17,18,18,13,13,14,15,16,14,14,15,16,17,13,
	14,14,16,16,16,16,17,17,18,15,16,15,17,16,10,11,
	11,14,13,11,12,12,14,14,11,12,12,15,14,13,14,14,
	16,16,13,14,14,16,16,11,12,12,14,14,12,13,13,15,
	15,12,13,13,15,15,14,15,15,16,17,14,15,15,17,16,
	11,12,11,14,14,12,13,13,15,15,12,13,12,15,14,14,
	15,14,16,16,14,15,14,17,16,14,14,14,16,16,14,15,
	15,16,17,14,15,15,17,17,16,16,17,17,18,16,17,17,
	18,18,13,14,12,16,14,14,15,13,17,15,13,15,13,17,
	14,16,16,15,18,16,15,17,14,18,15,11,12,12,14,15,
	13,13,14,14,16,13,14,13,15,14,15,15,16,16,17,15,
	16,15,17,16,12,13,13,15,15,13,13,14,15,16,14,15,
	14,16,16,15,15,16,15,18,16,16,16,18,17,12,13,13,
	15,15,14,14,15,15,16,13,14,13,15,15,16,16,16,16,
	18,15,16,15,17,16,15,15,15,17,16,15,15,16,16,17,
	16,16,16,18,17,16,16,17,15,18,17,18,17,19,18,14,
	14,15,15,17,15,15,16,16,17,14,15,15,16,16,17,17,
	18,17,19,16,17,15,17,15,11,13,12,15,15,12,14,14,
	15,15,12,14,13,16,15,15,15,15,17,17,14,15,15,17,
	16,12,14,14,16,16,14,14,15,16,16,14,14,14,16,16,
	15,16,17,17,18,15,16,16,18,17,12,14,13,16,14,13,
	14,14,16,15,13,15,14,16,14,15,16,16,17,17,15,16,
	15,18,15,15,15,16,17,17,15,16,16,17,18,16,16,16,
	18,18,17,17,18,18,19,17,17,18,19,19,14,15,14,17,
	13,15,16,15,18,14,15,16,15,18,14,17,18,17,18,16,
	16,18,16,19,15,
};

static const static_codebook _44p8_p2_0 = {
	5, 3125,
	(long *)_vq_lengthlist__44p8_p2_0,
	1, -533725184, 1611661312, 3, 0,
	(long *)_vq_quantlist__44p8_p2_0,
	0
};

static const long _vq_quantlist__44p8_p3_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p8_p3_0[] = {
	 2, 5, 5, 5, 7, 7, 5, 7, 7, 5, 7, 7, 7, 8, 9, 7,
	 9, 9, 5, 7, 7, 7, 9, 9, 7, 9, 8, 5, 7, 8, 7, 9,
	10, 8, 9, 9, 8, 9,10, 9,10,12,10,11,11, 8,10, 9,
	10,11,12, 9,11,10, 5, 8, 7, 8,10, 9, 7,10, 9, 8,
	 9,10, 9,10,11,10,12,11, 8,10, 9,10,11,11, 9,12,
	10, 5, 8, 8, 7, 9,10, 8,10, 9, 7, 9,10, 9,10,11,
	 9,11,11, 8,10, 9,10,11,11,10,12,10, 7, 9,10, 9,
	10,12, 9,11,11, 9, 9,12,11,10,13,11,11,13,10,12,
	11,11,13,13,11,13,12, 7, 9, 9, 9,11,11, 9,12,11,
	 9,11,10,10,11,12,11,13,12, 9,11,11,12,13,13,11,
	13,11, 5, 8, 8, 8, 9,10, 7,10, 9, 8, 9,10,10,10,
	12,10,11,11, 7,10, 9, 9,11,11, 9,11,10, 7, 9, 9,
	 9,11,12, 9,11,11, 9,11,11,11,11,13,12,13,13, 9,
	10,11,11,12,13,10,12,11, 7,10, 9, 9,11,11, 9,12,
	10,10,11,12,11,12,13,12,13,13, 9,12, 9,11,13,11,
	10,13,10,
};

static const static_codebook _44p8_p3_0 = {
	5, 243,
	(long *)_vq_lengthlist__44p8_p3_0,
	1, -533200896, 1614282752, 2, 0,
	(long *)_vq_quantlist__44p8_p3_0,
	0
};

static const long _vq_quantlist__44p8_p3_1[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p8_p3_1[] = {
	 6, 7, 7, 7, 7, 8, 7, 8, 7, 7, 7, 8, 7, 8, 8, 8,
	 8, 8, 7, 8, 7, 7, 8, 8, 7, 8, 8, 7, 8, 8, 8, 8,
	 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
	 8, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8,
	 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
	 8, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
	 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 8, 8, 8,
	 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 8, 8, 9, 8, 8,
	 8, 8, 9, 9, 8, 9, 9, 7, 8, 8, 8, 8, 8, 8, 8, 8,
	 8, 8, 8, 8, 8, 8, 8, 9, 8, 8, 8, 8, 8, 9, 9, 8,
	 9, 8, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
	 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 8, 8,
	 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 8, 9, 9, 8,
	 8, 8, 8, 8, 9, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
	 8, 8, 8, 8, 8, 9, 9, 8, 9, 9, 8, 8, 8, 8, 9, 8,
	 8, 9, 8,
};

static const static_codebook _44p8_p3_1 = {
	5, 243,
	(long *)_vq_lengthlist__44p8_p3_1,
	1, -535822336, 1611661312, 2, 0,
	(long *)_vq_quantlist__44p8_p3_1,
	0
};

static const long _vq_quantlist__44p8_p4_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p8_p4_0[] = {
	 2, 5, 5, 4, 7, 8, 4, 8, 7, 5, 7, 8, 7, 7,10, 8,
	 9, 9, 5, 7, 7, 8, 9, 9, 7,10, 7, 5, 7, 8, 8, 9,
	11, 8,10,10, 8, 9,10,10,10,12,11,12,12, 8,10,10,
	10,12,12,10,12,11, 5, 8, 7, 8,10,10, 8,11, 9, 8,
	10,10,10,11,12,10,12,12, 8,10, 9,11,12,12,10,12,
	10, 5, 8, 8, 7,10,10, 8,11,10, 7, 9,10, 9,10,12,
	10,12,12, 8,10,10,10,12,12,10,12,11, 7, 9,10, 9,
	11,12,10,12,11, 9, 9,12,10,10,13,12,12,13,10,12,
	11,12,13,13,11,13,11, 7,10, 9,10,11,12,10,13,11,
	 9,11,11,11,11,13,12,14,13,10,11,11,12,14,14,11,
	14,11, 5, 8, 8, 8,10,11, 7,10,10, 8,10,10,10,11,
	12,10,12,12, 7,10, 9,10,12,12, 9,12,10, 7, 9,10,
	10,11,13,10,12,11,10,11,11,11,11,14,12,14,14, 9,
	11,11,12,13,14,11,13,11, 7,10, 9,10,11,12, 9,12,
	10,10,11,12,11,11,13,12,13,13, 9,12, 9,12,13,12,
	10,13,10,
};

static const static_codebook _44p8_p4_0 = {
	5, 243,
	(long *)_vq_lengthlist__44p8_p4_0,
	1, -531365888, 1616117760, 2, 0,
	(long *)_vq_quantlist__44p8_p4_0,
	0
};

static const long _vq_quantlist__44p8_p4_1[] = {
	2,
	1,
	3,
	0,
	4,
};

static const long _vq_lengthlist__44p8_p4_1[] = {
	 7, 9, 9,10,10, 9,10,10,10,11, 9,10,10,11,10, 9,
	10,10,11,11, 9,10,10,11,11, 9,10,10,11,11,10,10,
	10,11,11,10,10,10,11,11,10,11,11,11,11,10,11,11,
	11,11, 9,10,10,11,11,10,10,10,11,11, 9,10,10,11,
	11,10,11,11,11,11,10,11,11,11,11,10,11,11,11,11,
	10,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
	11,11,11,12,10,11,11,11,11,11,11,11,11,11,10,11,
	11,11,11,11,11,11,11,11,11,11,11,11,11, 9,10,10,
	11,11,10,10,11,11,11,10,10,11,11,11,10,11,11,11,
	12,10,11,11,12,12,10,10,11,11,11,10,11,11,11,12,
	11,11,11,12,12,11,11,12,12,12,11,11,12,12,12,10,
	11,11,11,11,11,11,11,12,12,10,11,11,12,12,11,12,
	11,12,12,11,12,11,12,12,11,11,11,11,12,11,11,12,
	12,12,11,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,11,11,11,12,12,11,12,12,12,12,11,12,11,12,12,
	12,12,12,12,12,12,12,12,12,12, 9,10,10,11,11,10,
	11,10,11,11,10,11,10,11,11,10,11,11,12,12,10,11,
	11,12,11,10,11,11,11,11,10,11,11,11,12,11,11,11,
	12,12,11,11,12,12,12,11,11,11,12,12,10,11,10,11,
	11,11,11,11,12,12,10,11,11,12,11,11,12,11,12,12,
	11,12,11,12,12,11,11,11,12,12,11,11,12,12,12,11,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,11,11,
	11,12,11,11,12,12,12,12,11,12,11,12,12,12,12,12,
	12,12,12,12,12,12,12,10,11,11,11,11,11,11,11,12,
	12,11,11,11,12,12,11,12,12,12,12,11,12,12,12,12,
	11,11,11,12,12,11,11,12,12,12,11,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,11,11,11,12,12,11,12,
	12,12,12,11,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,13,12,13,12,12,12,12,13,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,13,12,10,11,11,11,11,11,11,11,12,12,11,11,
	11,12,12,11,12,12,12,12,11,12,12,12,12,11,11,11,
	12,12,11,12,12,12,12,11,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,11,11,11,12,12,11,12,12,12,12,
	11,12,11,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,13,12,12,13,12,13,
	12, 9,10,10,11,11,10,10,11,11,11,10,11,10,11,11,
	10,11,11,12,12,10,11,11,12,12,10,10,11,11,11,10,
	11,11,11,12,10,11,11,12,12,11,11,12,12,12,11,11,
	11,12,12,10,11,10,11,11,11,11,11,12,12,10,11,11,
	12,11,11,12,11,12,12,11,12,11,12,12,11,11,11,11,
	12,11,11,12,12,12,11,12,12,12,12,11,12,12,12,12,
	11,12,12,12,12,11,11,11,12,11,11,12,12,12,12,11,
	12,11,12,12,12,12,12,12,12,12,12,12,12,12,10,10,
	11,11,11,10,11,11,12,12,10,11,11,12,12,11,11,11,
	12,12,11,11,12,12,12,10,11,11,11,12,11,11,12,12,
	12,11,11,12,12,12,11,11,12,12,12,11,12,12,12,12,
	11,11,11,12,12,11,12,12,12,12,11,12,11,12,12,11,
	12,12,12,12,11,12,12,12,12,11,11,12,12,12,11,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,11,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12, 9,10,10,11,11,
	10,11,11,11,12,10,11,11,12,11,11,12,11,12,12,11,
	12,11,12,12,10,11,11,12,11,11,11,11,12,12,11,12,
	11,12,12,11,12,12,12,12,11,12,12,12,12,10,11,11,
	12,12,11,12,11,12,12,11,12,11,12,12,12,12,12,12,
	12,11,12,12,12,12,11,12,11,12,12,11,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,11,
	12,12,12,12,12,12,12,12,12,11,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,11,11,11,12,12,11,12,12,
	12,12,11,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,11,11,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,13,12,12,12,12,12,11,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,13,13,12,12,
	12,13,13,12,12,12,12,12,12,12,12,12,13,12,12,12,
	12,13,12,12,13,12,13,12,13,13,13,13,12,12,12,12,
	12,12,12,12,13,12,12,12,12,13,12,12,13,13,13,13,
	12,13,13,13,13,10,11,11,12,12,11,12,12,12,12,11,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,11,11,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,11,12,12,12,12,12,12,12,12,
	12,12,12,12,13,12,12,12,12,13,13,12,12,12,13,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,13,13,12,
	13,13,12,13,12,13,13,13,13,12,12,12,12,12,12,12,
	12,13,12,12,12,12,13,12,12,13,13,13,13,12,13,13,
	13,13, 9,10,10,11,11,10,10,11,11,11,10,11,10,11,
	11,10,11,11,12,12,10,11,11,12,12,10,11,11,11,11,
	10,11,11,12,12,11,11,11,12,12,11,11,12,12,12,11,
	11,12,12,12,10,11,10,11,11,10,11,11,12,12,10,11,
	11,12,11,11,12,11,12,12,11,11,11,12,12,11,11,11,
	11,12,11,11,12,12,12,11,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,11,11,11,12,11,11,12,12,12,12,
	11,12,11,12,12,12,12,12,12,12,11,12,12,12,12, 9,
	10,10,11,11,10,11,11,11,12,10,11,11,12,11,11,11,
	12,12,12,11,11,12,12,12,10,11,11,12,12,11,11,12,
	12,12,11,11,12,12,12,12,12,12,12,12,12,12,12,12,
	12,10,11,11,12,12,11,11,11,12,12,11,11,11,12,12,
	11,12,12,12,12,11,12,12,12,12,11,12,12,12,12,11,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,11,11,12,12,12,12,12,12,12,12,11,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,10,11,10,11,
	11,10,11,11,12,12,10,11,11,12,12,11,11,11,12,12,
	11,12,11,12,12,11,11,11,12,12,11,11,12,12,12,11,
	11,12,12,12,11,12,12,12,12,11,12,12,12,12,10,11,
	11,12,11,11,12,11,12,12,11,12,11,12,12,11,12,12,
	12,12,11,12,11,12,12,11,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	11,12,11,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,11,11,11,12,12,11,11,
	12,12,12,11,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,11,12,12,12,12,12,12,12,12,13,12,12,12,12,
	12,12,12,12,13,13,12,12,12,13,13,11,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,13,12,
	12,12,12,12,12,12,12,12,12,12,12,13,12,13,12,12,
	12,13,13,12,13,13,12,13,12,13,13,13,13,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,13,13,13,
	13,12,13,12,13,12,11,11,11,12,12,11,12,12,12,12,
	11,12,12,12,12,12,12,12,12,12,12,12,12,12,12,11,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,13,13,12,12,12,13,13,11,12,11,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,13,12,12,12,12,13,
	12,12,12,12,12,12,12,12,12,13,13,12,12,12,12,13,
	12,13,13,13,13,12,13,13,13,13,12,12,12,12,12,12,
	12,12,13,12,12,12,12,13,12,12,13,13,13,13,12,13,
	13,13,12,10,11,11,12,12,11,11,11,12,12,11,11,11,
	12,12,11,12,12,12,12,11,12,12,12,12,11,11,11,12,
	12,11,11,12,12,12,11,12,12,12,12,11,12,12,12,12,
	12,12,12,12,12,11,11,11,12,12,11,12,12,12,12,11,
	12,11,12,12,12,12,12,12,12,12,12,12,12,12,11,12,
	12,12,12,11,12,12,12,12,12,12,12,12,12,12,12,12,
	12,13,12,12,12,12,12,11,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,13,12,12,12,12,12,12,
	11,11,11,12,12,11,12,12,12,12,11,12,12,12,12,12,
	12,12,12,12,11,12,12,12,12,11,11,12,12,12,11,12,
	12,12,12,12,12,12,12,12,12,12,12,12,13,12,12,12,
	13,13,11,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,13,13,12,12,12,13,13,12,12,12,12,12,
	12,12,12,12,13,12,12,12,12,13,12,12,13,12,13,12,
	12,13,13,13,12,12,12,12,12,12,12,12,12,13,12,12,
	12,13,12,12,13,13,13,13,12,13,13,13,13,10,11,11,
	12,12,11,12,12,12,12,11,12,12,12,12,11,12,12,12,
	12,12,12,12,12,12,11,11,12,12,12,11,12,12,12,12,
	12,12,12,12,12,12,12,12,12,13,12,12,12,13,13,11,
	12,11,12,12,12,12,12,12,12,11,12,12,12,12,12,12,
	12,13,13,12,12,12,13,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,13,12,12,12,12,12,13,12,13,12,13,
	13,12,12,12,12,12,12,12,12,13,12,12,12,12,13,12,
	12,13,12,13,13,12,13,12,13,12,11,11,11,12,12,11,
	12,12,12,12,11,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,11,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,13,12,13,12,12,13,13,13,11,12,12,12,
	12,12,12,12,12,12,12,12,12,13,12,12,12,12,13,13,
	12,12,12,13,12,12,12,12,12,12,12,12,13,12,13,12,
	12,12,12,13,12,12,13,12,13,12,13,13,12,13,12,12,
	12,12,12,12,13,13,13,12,12,12,12,13,12,12,13,13,
	13,13,12,13,13,13,12,11,11,11,12,12,11,12,12,12,
	12,11,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	11,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,13,12,12,13,13,13,11,12,12,12,12,12,12,
	12,12,13,12,12,12,13,12,12,13,12,13,13,12,13,12,
	13,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,13,12,13,12,13,13,13,12,12,12,12,12,12,
	12,13,12,13,12,12,12,12,13,12,12,13,13,13,12,12,
	13,12,13,12,10,11,11,12,12,11,11,11,12,12,11,11,
	11,12,12,11,12,12,12,12,11,12,12,12,12,11,11,11,
	12,12,11,11,12,12,12,11,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,11,11,11,12,12,11,12,12,12,12,
	11,12,11,12,12,12,12,12,12,12,11,12,12,12,12,11,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,13,12,12,12,12,12,11,12,12,12,12,12,12,12,
	12,12,11,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,10,11,11,12,12,11,11,12,12,12,11,12,12,12,12,
	11,12,12,12,12,12,12,12,12,12,11,11,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,13,12,12,
	12,13,13,11,11,11,12,12,12,12,12,12,12,11,12,12,
	12,12,12,12,12,13,13,12,12,12,13,13,12,12,12,12,
	12,12,12,12,12,13,12,12,12,12,13,12,12,13,12,13,
	12,12,13,13,13,12,12,12,12,12,12,12,12,12,13,12,
	12,12,12,12,12,12,13,13,13,12,12,12,13,12,11,11,
	11,12,12,11,12,12,12,12,11,12,12,12,12,12,12,12,
	12,12,11,12,12,12,12,11,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,13,13,12,12,12,13,13,
	11,12,11,12,12,12,12,12,12,12,11,12,12,12,12,12,
	12,12,13,13,12,12,12,13,12,12,12,12,12,12,12,12,
	12,12,13,12,12,12,13,13,12,13,13,13,13,12,13,13,
	13,13,12,12,12,12,12,12,12,12,13,12,12,12,12,13,
	12,12,13,12,13,13,12,13,12,13,12,11,11,11,12,12,
	11,12,12,12,12,11,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,11,12,12,12,12,12,12,12,12,13,12,12,
	12,13,13,12,12,13,12,13,12,12,13,13,13,11,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,13,
	13,12,12,12,13,12,12,12,12,12,12,12,12,12,12,13,
	12,12,12,13,13,12,12,13,12,13,12,13,13,13,13,12,
	12,12,12,12,12,12,13,12,13,12,12,12,12,12,12,13,
	13,12,12,12,13,12,12,12,11,11,11,12,12,11,12,12,
	12,12,11,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,11,12,12,12,12,12,12,12,12,13,12,12,12,12,13,
	12,12,13,13,13,12,12,12,13,13,11,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,13,12,13,13,12,13,
	12,13,12,12,12,12,12,12,12,12,12,12,13,12,13,12,
	13,13,12,13,13,12,13,12,13,13,13,13,12,12,12,12,
	12,12,12,12,13,12,12,13,12,13,12,12,13,12,13,12,
	12,13,12,13,12,
};

static const static_codebook _44p8_p4_1 = {
	5, 3125,
	(long *)_vq_lengthlist__44p8_p4_1,
	1, -533725184, 1611661312, 3, 0,
	(long *)_vq_quantlist__44p8_p4_1,
	0
};

static const long _vq_quantlist__44p8_p5_0[] = {
	2,
	1,
	3,
	0,
	4,
};

static const long _vq_lengthlist__44p8_p5_0[] = {
	 2, 6, 6, 9, 9, 5, 7, 8,10,11, 5, 8, 7,11,10, 8,
	10,11,12,13, 8,11,10,13,12, 6, 7, 8,10,11, 7, 8,
	10,10,12, 8, 9, 9,12,12,10,10,12,12,14,10,12,12,
	14,13, 6, 8, 7,11,10, 8, 9, 9,12,12, 7,10, 8,12,
	11,10,12,12,13,14,10,12,10,14,12, 9,10,11,11,13,
	10,10,11,11,13,11,12,12,13,14,12,12,13,11,15,13,
	14,14,15,14, 9,11,10,13,11,11,12,12,13,13,10,11,
	10,13,11,13,14,14,15,15,12,13,12,15,11, 6, 8, 9,
	11,12, 8, 9,11,12,13, 8,10,10,13,13,11,12,13,14,
	15,11,12,13,14,14, 9, 9,10,12,13,10,10,12,12,14,
	10,11,11,13,14,12,12,14,14,15,13,13,14,15,15, 9,
	10,10,13,13,10,11,11,13,14,10,11,10,14,13,13,13,
	14,15,15,12,14,13,15,14,12,12,13,13,14,12,13,14,
	13,15,13,14,14,15,15,14,14,15,14,16,15,15,15,16,
	16,12,13,13,14,14,13,14,14,15,15,12,14,13,15,14,
	14,15,15,16,16,14,15,14,16,14, 6, 9, 8,12,11, 8,
	10,10,13,13, 8,11, 9,13,12,11,12,12,14,14,11,13,
	12,15,14, 9,10,10,13,13,10,10,11,13,14,10,12,11,
	14,13,12,13,14,14,15,13,13,13,15,14, 9,10, 9,13,
	12,10,11,11,14,13,10,12,10,14,12,13,14,13,15,15,
	12,14,12,15,14,12,13,13,14,14,13,13,13,14,15,13,
	14,14,15,15,14,14,15,14,16,14,15,15,16,16,12,13,
	12,14,13,13,14,14,15,15,12,14,13,15,13,15,15,15,
	16,16,14,15,14,16,14,11,12,12,13,14,12,13,14,14,
	16,12,13,13,15,15,14,14,16,15,17,14,15,15,16,16,
	12,13,14,14,15,13,13,15,15,16,14,14,14,15,16,15,
	15,16,16,17,15,15,16,16,17,13,13,13,15,15,14,14,
	15,15,16,13,14,14,15,16,15,15,16,16,17,15,16,15,
	17,16,14,15,15,16,16,15,15,16,16,17,15,16,16,17,
	17,16,16,17,16,18,16,17,17,17,17,15,15,15,16,16,
	15,16,16,17,17,15,16,16,17,16,16,17,17,18,18,16,
	17,16,17,16,11,12,12,15,13,13,13,13,15,15,12,14,
	13,16,14,14,15,15,16,16,14,15,14,17,15,13,13,13,
	15,14,13,14,14,16,15,14,14,14,16,15,15,15,16,16,
	17,15,16,15,17,16,12,14,13,15,14,14,14,14,16,15,
	13,14,13,16,15,15,16,16,17,16,15,16,15,17,16,15,
	15,15,16,16,15,15,16,16,17,15,16,16,17,17,16,16,
	17,17,17,17,17,17,18,17,14,15,15,16,16,15,16,16,
	17,16,15,16,15,17,16,17,17,17,18,17,16,17,16,18,
	16, 6, 9, 9,12,12, 8,10,10,12,13, 8,10,10,13,12,
	10,12,12,14,15,11,13,12,15,14, 8, 9,10,12,13, 9,
	10,11,13,14,10,11,11,14,13,12,12,13,14,15,12,13,
	13,15,15, 8,10,10,13,13,10,11,11,13,14,10,12,10,
	14,13,12,13,13,15,15,12,14,13,15,14,11,12,12,13,
	14,12,12,13,13,15,12,13,13,15,15,14,13,15,14,16,
	14,15,15,16,16,12,13,13,14,14,13,13,14,15,14,12,
	14,13,15,14,14,15,15,16,15,14,15,14,16,14, 7, 9,
	10,12,12, 9,10,11,13,14, 9,11,10,13,13,11,12,13,
	14,15,12,13,13,15,14, 9,10,11,12,13,10,10,12,13,
	14,11,11,12,14,14,12,12,14,14,15,13,13,14,15,15,
	 9,11,11,13,13,11,12,12,14,14,10,12,10,14,13,13,
	14,14,15,15,13,14,13,16,14,12,12,13,14,15,13,13,
	14,14,16,13,14,14,15,15,14,14,15,14,17,14,15,15,
	16,16,12,13,13,15,14,13,14,14,15,15,13,14,13,16,
	14,15,15,15,16,16,14,15,14,16,14, 7,10, 9,13,12,
	10,11,12,12,14,10,12,11,14,12,12,13,13,14,15,12,
	14,13,15,14, 9,11,10,13,13,10,11,12,13,14,12,13,
	12,15,13,13,13,14,13,15,13,14,14,16,15,10,11,11,
	13,13,12,12,13,14,14,11,12,11,14,13,14,14,14,15,
	16,13,14,13,16,13,12,13,13,14,14,12,13,13,14,15,
	14,14,14,15,15,14,13,15,13,16,15,15,15,17,16,13,
	13,13,14,14,14,14,14,15,15,12,13,13,15,14,15,16,
	16,16,16,14,15,14,16,13,11,12,13,14,15,12,13,14,
	15,16,13,14,14,15,15,14,14,15,15,17,14,15,15,16,
	16,13,13,14,14,15,13,13,15,14,16,14,14,15,15,16,
	15,14,16,15,17,15,16,16,16,17,13,14,14,15,15,14,
	14,15,16,16,13,15,14,16,16,15,16,16,17,17,15,16,
	15,17,16,14,15,15,15,17,15,15,16,15,17,15,16,16,
	16,17,16,16,17,16,18,17,17,17,17,18,15,15,15,17,
	16,15,16,16,17,17,15,16,16,17,16,16,17,17,18,18,
	16,17,16,18,17,11,13,12,15,14,13,13,14,15,15,13,
	14,13,16,14,15,15,15,16,16,15,16,15,17,16,13,14,
	13,15,14,13,13,14,15,15,14,15,14,16,15,15,15,16,
	16,16,15,16,15,18,16,13,14,14,15,15,14,15,15,15,
	16,13,15,13,16,15,15,16,16,17,17,15,16,15,17,16,
	15,15,15,16,16,15,15,15,16,17,16,16,16,17,16,16,
	16,17,16,17,17,17,17,18,17,15,15,15,16,16,16,16,
	16,17,17,15,16,15,17,16,17,17,17,18,18,16,17,16,
	17,15, 6, 9, 9,12,12, 8,10,10,12,13, 8,10,10,13,
	12,11,12,13,14,15,10,12,12,14,14, 9,10,10,13,13,
	10,10,12,13,14,10,11,11,14,13,12,13,14,14,15,12,
	13,13,15,15, 8,10, 9,13,12,10,11,11,13,14, 9,11,
	10,14,13,12,13,13,15,15,12,13,12,15,14,12,13,13,
	14,14,12,13,13,14,15,13,14,14,14,15,14,14,15,14,
	16,14,15,15,16,16,11,12,12,14,13,13,13,13,15,15,
	12,13,12,15,13,14,15,15,16,16,14,15,14,16,14, 7,
	 9,10,12,13,10,10,12,12,14,10,12,11,14,13,12,13,
	14,14,15,12,13,13,15,14,10,11,11,13,13,11,11,12,
	13,14,12,13,12,14,14,13,13,14,13,16,14,14,14,15,
	15, 9,10,11,13,14,12,12,13,13,15,10,12,10,14,13,
	13,14,14,15,16,13,14,13,15,13,13,14,13,14,15,12,
	13,13,14,15,14,14,14,15,15,14,13,15,13,16,15,16,
	16,16,16,12,13,13,14,14,14,14,14,15,15,12,13,13,
	15,14,15,15,16,16,16,14,15,13,16,13, 7,10, 9,12,
	12, 9,10,11,13,13, 9,11,10,14,13,12,13,13,14,15,
	11,13,12,15,14, 9,11,11,13,13,10,10,12,13,14,11,
	12,12,14,14,13,13,14,14,16,13,14,14,16,15, 9,11,
	10,13,12,11,12,11,14,14,10,12,10,14,13,13,14,13,
	15,15,12,14,12,16,14,12,13,13,14,15,13,13,14,14,
	16,13,14,14,15,15,14,14,15,14,16,15,15,15,16,16,
	12,13,12,15,14,13,14,14,15,15,12,14,13,16,14,14,
	15,15,16,16,14,15,14,17,14,11,12,13,14,15,13,13,
	14,14,16,13,14,13,15,15,15,15,16,16,17,15,15,15,
	16,16,13,14,13,15,15,13,13,15,15,16,14,15,15,16,
	16,15,15,16,15,17,16,16,16,17,17,13,13,14,14,15,
	14,14,15,15,16,13,14,13,15,15,15,16,16,16,17,15,
	16,15,16,16,15,15,15,16,16,15,15,16,16,17,16,16,
	16,17,17,16,16,17,16,18,17,17,17,18,18,15,15,15,
	16,16,16,16,16,17,17,15,15,15,16,16,17,17,17,17,
	18,16,16,16,17,15,11,13,12,15,14,13,13,14,15,15,
	12,14,13,16,14,14,15,15,16,16,14,15,14,16,15,13,
	14,14,15,15,13,14,14,16,16,14,15,14,16,16,15,15,
	16,17,17,15,16,16,17,17,13,14,13,15,14,14,14,14,
	16,15,13,15,13,16,14,15,16,15,17,16,15,16,14,17,
	15,14,16,15,16,17,15,16,16,16,17,15,16,16,17,17,
	16,16,17,17,18,16,17,17,18,17,14,15,15,17,15,15,
	16,16,17,16,15,16,15,17,15,16,17,17,18,17,16,17,
	16,18,15,10,12,12,14,14,12,13,13,15,15,12,13,13,
	15,15,13,14,14,15,16,14,15,14,16,16,12,13,13,15,
	15,12,13,14,15,15,13,14,14,15,15,14,14,15,16,17,
	14,15,15,17,16,12,13,13,15,15,13,14,14,15,16,13,
	14,14,16,15,14,15,15,16,17,14,15,15,17,16,13,14,
	14,15,16,14,14,15,15,16,14,15,15,16,16,15,15,16,
	16,17,15,16,16,17,17,14,15,15,16,16,15,15,15,16,
	16,15,15,15,16,16,16,17,16,17,17,16,16,16,18,16,
	11,12,12,14,14,12,13,14,15,15,12,13,13,15,15,13,
	14,15,16,16,14,15,15,16,16,12,13,13,15,15,13,13,
	14,15,16,13,14,14,15,16,14,14,15,16,17,15,15,15,
	16,17,12,13,13,15,15,13,14,14,15,16,13,14,14,16,
	15,15,15,15,16,17,15,16,15,17,16,14,14,15,15,16,
	14,14,15,15,17,15,15,16,16,17,15,15,16,15,18,16,
	16,16,17,17,14,15,15,16,16,15,16,16,17,17,15,15,
	15,17,16,16,17,16,17,17,16,16,16,18,16,11,12,12,
	14,14,13,13,14,15,15,13,14,13,15,15,14,15,15,16,
	16,14,15,15,16,16,12,13,13,15,15,13,13,14,15,15,
	14,14,14,16,15,15,15,15,15,16,15,16,15,17,16,12,
	13,13,15,15,14,14,15,15,16,13,14,13,16,15,15,15,
	16,16,17,15,16,15,17,15,14,15,14,16,16,14,15,15,
	16,16,15,16,15,17,16,15,15,16,15,17,16,17,16,17,
	17,14,15,15,16,16,15,16,16,16,17,14,15,15,16,16,
	16,17,17,17,18,16,16,16,17,16,12,13,13,15,15,13,
	13,14,15,16,13,14,14,16,15,14,15,15,16,17,14,15,
	15,17,16,13,14,14,15,16,14,14,15,15,17,14,15,15,
	16,16,15,14,16,15,17,15,16,16,17,17,13,14,14,16,
	16,14,15,15,16,16,14,15,14,16,16,15,16,16,17,17,
	15,16,15,17,16,15,15,16,15,17,15,15,16,15,17,15,
	16,16,16,17,16,15,17,15,18,17,17,17,17,17,15,15,
	15,17,17,16,16,16,17,17,15,16,15,17,17,16,17,17,
	18,18,16,17,15,18,15,11,12,12,15,15,13,13,15,14,
	16,13,14,13,16,14,15,15,16,16,17,15,16,15,17,15,
	12,14,13,16,14,13,13,14,14,16,14,15,14,16,15,15,
	15,16,15,17,16,16,16,17,16,12,13,14,15,16,15,15,
	15,15,16,13,15,13,16,14,16,16,16,17,17,15,16,15,
	17,15,15,16,15,16,15,14,14,15,16,16,16,16,16,17,
	16,15,15,16,15,17,17,17,17,18,17,15,15,15,16,16,
	16,16,16,16,17,14,15,15,17,16,17,17,17,17,18,15,
	16,15,18,14,10,12,12,14,14,12,13,13,15,15,12,13,
	13,15,15,14,14,15,15,16,13,15,14,16,16,12,13,13,
	15,15,13,14,14,15,16,13,14,14,15,15,14,15,15,16,
	17,14,15,15,17,16,12,13,13,15,15,13,14,14,15,15,
	12,14,13,15,15,14,15,15,16,17,14,15,14,17,15,14,
	15,15,16,16,14,15,15,16,17,15,15,15,17,16,16,16,
	16,16,17,16,16,16,17,17,13,14,14,16,15,14,15,15,
	16,16,14,15,14,16,16,15,16,16,17,17,15,16,15,17,
	16,11,12,12,14,15,13,13,14,14,15,13,14,13,15,15,
	14,15,15,16,16,14,15,15,16,16,12,14,13,15,15,13,
	13,14,15,16,14,15,14,16,15,15,15,16,15,17,15,16,
	16,17,16,12,13,13,15,15,14,14,15,15,16,13,14,13,
	16,15,15,15,16,16,17,15,15,15,16,16,14,15,15,16,
	16,14,15,15,16,16,15,16,16,17,17,16,16,16,16,17,
	16,17,17,18,17,14,14,15,15,16,15,15,16,16,17,14,
	15,15,16,16,16,16,16,17,17,15,16,15,17,15,11,12,
	12,14,14,12,13,14,15,15,12,13,13,15,15,14,15,15,
	16,16,13,15,14,16,16,12,13,13,15,15,13,14,14,15,
	16,13,14,14,16,16,15,15,15,16,17,15,15,15,17,16,
	12,13,13,15,15,13,14,14,16,15,13,14,13,16,15,15,
	16,15,17,17,14,15,14,17,16,14,15,15,16,16,15,15,
	16,16,17,15,16,16,17,17,16,16,16,16,18,16,17,16,
	18,17,14,15,14,16,15,15,15,15,17,16,14,15,14,17,
	15,16,17,16,17,17,15,16,15,17,15,11,12,12,15,15,
	13,13,15,14,16,13,15,13,16,14,15,15,16,15,17,15,
	16,15,17,16,12,14,13,15,15,13,13,15,15,16,15,15,
	15,16,15,15,15,16,15,17,16,16,16,17,16,12,13,14,
	15,16,14,14,15,15,16,13,14,13,16,14,16,16,16,16,
	17,15,16,15,17,15,15,16,15,16,16,14,15,15,16,16,
	16,16,16,17,16,15,15,16,15,17,17,17,17,18,17,15,
	15,15,15,16,16,16,16,16,17,14,15,14,16,15,17,17,
	17,17,18,15,16,15,17,15,12,13,13,15,15,13,14,14,
	15,16,13,14,14,16,15,14,15,15,16,17,14,15,15,17,
	16,13,14,14,16,15,13,14,15,16,16,14,15,15,16,16,
	15,15,16,16,17,15,16,16,17,17,13,14,13,16,15,14,
	15,15,16,16,13,15,14,16,15,15,16,16,17,17,15,16,
	14,17,15,15,15,16,17,17,15,15,16,16,17,16,16,16,
	17,17,16,15,17,16,18,17,17,17,18,18,15,15,15,17,
	14,16,16,16,17,16,15,16,15,17,15,16,17,17,18,17,
	16,17,15,18,15,
};

static const static_codebook _44p8_p5_0 = {
	5, 3125,
	(long *)_vq_lengthlist__44p8_p5_0,
	1, -528744448, 1616642048, 3, 0,
	(long *)_vq_quantlist__44p8_p5_0,
	0
};

static const long _vq_quantlist__44p8_p5_1[] = {
	3,
	2,
	4,
	1,
	5,
	0,
	6,
};

static const long _vq_lengthlist__44p8_p5_1[] = {
	 2, 3, 3, 3, 3, 3, 3,
};

static const static_codebook _44p8_p5_1 = {
	1, 7,
	(long *)_vq_lengthlist__44p8_p5_1,
	1, -533200896, 1611661312, 3, 0,
	(long *)_vq_quantlist__44p8_p5_1,
	0
};

static const long _vq_quantlist__44p8_p6_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p8_p6_0[] = {
	 2, 6, 6, 5, 7, 7, 5, 7, 7, 5, 7, 7, 7, 7, 9, 7,
	 9, 9, 6, 7, 7, 8, 9, 9, 7, 9, 7, 6, 8, 8, 8, 9,
	10, 8, 9, 9, 8, 9,10, 9, 9,10,10,10,10, 8, 9, 9,
	10,10,11, 9,10,10, 6, 8, 8, 8, 9, 9, 8,10, 9, 8,
	 9, 9, 9,10,10,10,11,10, 8,10, 9,10,11,10, 9,11,
	 9, 6, 8, 8, 7, 9, 9, 7, 9, 9, 7, 9, 9, 8, 9,10,
	 9,10,10, 8, 9, 9, 9,10,10, 9,10, 9, 7, 9, 9, 9,
	 9,10, 9,10,10, 9, 9,10,10, 9,11,10,11,11, 9,10,
	10,10,11,11,10,11,10, 6, 9, 8, 9, 9,10, 9,10, 9,
	 8,10,10, 9, 9,10,10,11,11, 9,10,10,10,11,11, 9,
	11, 9, 6, 8, 8, 7, 9, 9, 7, 9, 9, 8, 9, 9, 9, 9,
	10, 9,10,10, 7, 9, 9, 9,10,10, 8,10, 9, 6, 8, 9,
	 9, 9,10, 9,10, 9, 9,10,10, 9, 9,11,10,11,11, 8,
	 9,10,10,11,11, 9,10, 9, 7, 9, 9, 9,10,10, 9,10,
	 9, 9,10,10,10,10,11,10,11,11, 9,10, 9,10,11,11,
	10,11, 9,
};

static const static_codebook _44p8_p6_0 = {
	5, 243,
	(long *)_vq_lengthlist__44p8_p6_0,
	1, -527106048, 1620377600, 2, 0,
	(long *)_vq_quantlist__44p8_p6_0,
	0
};

static const long _vq_quantlist__44p8_p6_1[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p8_p6_1[] = {
	 4, 7, 7, 7, 7, 8, 7, 8, 7, 7, 7, 8, 7, 8, 8, 8,
	 8, 8, 7, 8, 7, 8, 8, 8, 7, 8, 8, 7, 8, 8, 8, 8,
	 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 8, 8, 9, 8, 8, 8,
	 8, 9, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8,
	 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 8, 8, 9,
	 8, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9,
	 8, 8, 9, 8, 8, 8, 8, 9, 9, 8, 9, 8, 8, 8, 8, 8,
	 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 8, 9, 9, 8, 8,
	 8, 8, 9, 9, 8, 9, 9, 7, 8, 8, 8, 8, 8, 8, 8, 8,
	 8, 8, 8, 8, 8, 9, 8, 9, 8, 8, 8, 8, 8, 9, 9, 8,
	 9, 8, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
	 9, 8, 9, 9, 8, 8, 8, 8, 9, 8, 8, 9, 8, 7, 8, 8,
	 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 8, 9, 9, 8,
	 8, 8, 8, 9, 9, 8, 9, 8, 8, 8, 8, 8, 8, 8, 8, 8,
	 8, 8, 8, 8, 8, 9, 9, 8, 9, 9, 8, 8, 8, 8, 9, 9,
	 8, 9, 8,
};

static const static_codebook _44p8_p6_1 = {
	5, 243,
	(long *)_vq_lengthlist__44p8_p6_1,
	1, -530841600, 1616642048, 2, 0,
	(long *)_vq_quantlist__44p8_p6_1,
	0
};

static const long _vq_quantlist__44p8_p7_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p8_p7_0[] = {
	 1, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9,
};

static const static_codebook _44p8_p7_0 = {
	5, 243,
	(long *)_vq_lengthlist__44p8_p7_0,
	1, -512202240, 1635281408, 2, 0,
	(long *)_vq_quantlist__44p8_p7_0,
	0
};

static const long _vq_quantlist__44p8_p7_1[] = {
	2,
	1,
	3,
	0,
	4,
};

static const long _vq_lengthlist__44p8_p7_1[] = {
	 1, 7, 7,12,12, 5,11,12,12,12, 5,12,11,12,12,12,
	12,12,12,12,12,13,13,13,13, 7,11,11,13,13,13,12,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13, 7,13,10,13,13,13,13,13,13,13,12,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13, 7,13,12,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,12,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13, 8,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,12,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,12,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13, 8,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,12,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,10,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13, 8,13,12,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,11,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,11,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,
};

static const static_codebook _44p8_p7_1 = {
	5, 3125,
	(long *)_vq_lengthlist__44p8_p7_1,
	1, -514619392, 1630767104, 3, 0,
	(long *)_vq_quantlist__44p8_p7_1,
	0
};

static const long _vq_quantlist__44p8_p7_2[] = {
	12,
	11,
	13,
	10,
	14,
	9,
	15,
	8,
	16,
	7,
	17,
	6,
	18,
	5,
	19,
	4,
	20,
	3,
	21,
	2,
	22,
	1,
	23,
	0,
	24,
};

static const long _vq_lengthlist__44p8_p7_2[] = {
	 1, 3, 2, 4, 5, 7, 7, 8, 8, 9, 9,10,10,11,11,12,
	12,13,13,14,14,15,15,15,15,
};

static const static_codebook _44p8_p7_2 = {
	1, 25,
	(long *)_vq_lengthlist__44p8_p7_2,
	1, -518864896, 1620639744, 5, 0,
	(long *)_vq_quantlist__44p8_p7_2,
	0
};

static const long _vq_quantlist__44p8_p7_3[] = {
	12,
	11,
	13,
	10,
	14,
	9,
	15,
	8,
	16,
	7,
	17,
	6,
	18,
	5,
	19,
	4,
	20,
	3,
	21,
	2,
	22,
	1,
	23,
	0,
	24,
};

static const long _vq_lengthlist__44p8_p7_3[] = {
	 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5,
	 5, 5, 5, 5, 5, 5, 5, 5, 5,
};

static const static_codebook _44p8_p7_3 = {
	1, 25,
	(long *)_vq_lengthlist__44p8_p7_3,
	1, -529006592, 1611661312, 5, 0,
	(long *)_vq_quantlist__44p8_p7_3,
	0
};

static const long _huff_lengthlist__44p8_short[] = {
	 3, 9,15,17,20,21,22,23, 5, 5, 7, 9,11,13,17,20,
	 9, 5, 5, 6, 8,10,15,18,11, 7, 5, 4, 6, 9,13,17,
	14, 9, 7, 5, 6, 7,10,14,17,10, 8, 6, 6, 4, 5, 8,
	20,14,13,10, 8, 4, 3, 4,23,17,16,14,12, 6, 4, 4,
};

static const static_codebook _huff_book__44p8_short = {
	2, 64,
	(long *)_huff_lengthlist__44p8_short,
	0, 0, 0, 0, 0,
	NULL,
	0
};

static const long _vq_quantlist__44p9_l0_0[] = {
	6,
	5,
	7,
	4,
	8,
	3,
	9,
	2,
	10,
	1,
	11,
	0,
	12,
};

static const long _vq_lengthlist__44p9_l0_0[] = {
	 2, 5, 5, 7, 6, 8, 8, 9, 9,10,10,11,11, 4, 5, 5,
	 6, 7, 8, 8, 9, 9,10,10,11,10, 4, 5, 5, 7, 6, 8,
	 8, 9, 9,10,10,10,10, 6, 6, 7, 6, 7, 8, 8, 9, 9,
	10, 9,11, 9, 6, 6, 6, 7, 6, 8, 8, 9, 9, 9,10, 9,
	11, 7, 7, 8, 8, 8, 8, 9, 9, 9,10, 9,11, 9, 7, 8,
	 8, 8, 8, 9, 8, 9, 9, 9,10, 9,11, 8, 9, 9, 9, 9,
	 9, 9,10,10,11,10,12,10, 8, 9, 9, 9, 9, 9, 9,10,
	 9,10,11,11,12, 9,10,10,10,10,10,10,10,11,11,11,
	11,12, 9,10,10,10,10,11,10,11,10,11,11,12,11,11,
	11,11,11,11,11,11,11,12,11,12,11,12,11,11,11,11,
	11,11,11,12,11,12,11,12,11,
};

static const static_codebook _44p9_l0_0 = {
	2, 169,
	(long *)_vq_lengthlist__44p9_l0_0,
	1, -526516224, 1616117760, 4, 0,
	(long *)_vq_quantlist__44p9_l0_0,
	0
};

static const long _vq_quantlist__44p9_l0_1[] = {
	2,
	1,
	3,
	0,
	4,
};

static const long _vq_lengthlist__44p9_l0_1[] = {
	 4, 4, 4, 5, 5, 4, 4, 5, 5, 5, 4, 5, 4, 5, 5, 5,
	 5, 5, 5, 5, 5, 5, 5, 5, 5,
};

static const static_codebook _44p9_l0_1 = {
	2, 25,
	(long *)_vq_lengthlist__44p9_l0_1,
	1, -533725184, 1611661312, 3, 0,
	(long *)_vq_quantlist__44p9_l0_1,
	0
};

static const long _vq_quantlist__44p9_l1_0[] = {
	2,
	1,
	3,
	0,
	4,
};

static const long _vq_lengthlist__44p9_l1_0[] = {
	 1, 2, 3, 5, 9, 9, 4, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9,10,10,10,10,10,10,10,10,
};

static const static_codebook _44p9_l1_0 = {
	2, 25,
	(long *)_vq_lengthlist__44p9_l1_0,
	1, -514619392, 1630767104, 3, 0,
	(long *)_vq_quantlist__44p9_l1_0,
	0
};

static const long _huff_lengthlist__44p9_lfe[] = {
	 1, 1,
};

static const static_codebook _huff_book__44p9_lfe = {
	1, 2,
	(long *)_huff_lengthlist__44p9_lfe,
	0, 0, 0, 0, 0,
	NULL,
	0
};

static const long _huff_lengthlist__44p9_long[] = {
	 3, 3, 3, 3, 3, 3, 3, 3,
};

static const static_codebook _huff_book__44p9_long = {
	1, 8,
	(long *)_huff_lengthlist__44p9_long,
	0, 0, 0, 0, 0,
	NULL,
	0
};

static const long _vq_quantlist__44p9_p1_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p9_p1_0[] = {
	 1, 5, 5, 4, 8, 8, 4, 8, 8, 5, 7, 8, 8, 9,10, 8,
	10,10, 5, 8, 7, 8,10,10, 8,10, 9, 7, 9, 9, 9,11,
	11, 9,11,11, 9,11,11,11,12,13,11,13,13, 9,11,11,
	11,13,13,11,13,13, 7, 9, 9, 9,11,11, 9,11,11, 9,
	11,11,11,13,13,11,13,13, 9,11,11,11,13,13,11,13,
	12, 5, 9, 9, 9,11,11, 9,11,11, 9,11,11,11,12,13,
	11,13,13, 9,11,11,11,13,13,11,13,13, 9,11,12,11,
	13,13,12,13,13,11,12,13,13,14,15,13,14,14,12,13,
	13,13,15,15,13,15,14, 8,10,10,11,13,13,12,14,13,
	11,12,12,13,14,15,13,15,15,11,12,12,13,15,15,13,
	15,14, 5, 9, 9, 9,11,11, 9,11,11, 9,11,11,11,13,
	13,11,13,13, 9,11,10,11,13,13,11,13,12, 8,10,10,
	11,13,13,12,13,13,11,12,12,13,14,15,14,15,15,10,
	12,12,13,14,15,13,15,14, 9,12,11,12,13,13,11,13,
	13,12,13,13,13,15,15,13,14,15,11,13,12,13,15,14,
	13,15,14,
};

static const static_codebook _44p9_p1_0 = {
	5, 243,
	(long *)_vq_lengthlist__44p9_p1_0,
	1, -535822336, 1611661312, 2, 0,
	(long *)_vq_quantlist__44p9_p1_0,
	0
};

static const long _vq_quantlist__44p9_p2_0[] = {
	2,
	1,
	3,
	0,
	4,
};

static const long _vq_lengthlist__44p9_p2_0[] = {
	 4, 6, 6, 8, 8, 5, 7, 7, 9, 9, 5, 7, 7, 9, 9, 6,
	 8, 8,11,11, 6, 8, 8,11,11, 6, 7, 7, 9, 9, 7, 8,
	 9,10,11, 7, 9, 9,11,10, 8, 9,10,12,12, 8,10,10,
	12,12, 6, 7, 7, 9, 9, 7, 9, 9,10,10, 7, 9, 8,11,
	10, 8,10,10,12,12, 8,10, 9,12,12, 8, 9, 9,11,11,
	 9,10,10,12,12, 9,11,11,12,13,11,12,12,13,14,11,
	12,12,14,14, 8, 9, 9,11,11, 9,11,10,13,12, 9,10,
	10,13,12,11,12,12,14,14,11,12,12,14,13, 7, 8, 9,
	10,10, 8,10,10,11,11, 8,10,10,11,11,10,11,11,13,
	13,10,11,11,13,13, 8, 9,10,10,11,10,11,11,12,13,
	10,11,11,12,12,11,11,12,13,14,11,12,12,14,14, 8,
	10,10,11,11,10,11,11,12,13,10,11,11,12,12,11,12,
	12,14,14,11,12,12,14,14,10,11,11,12,13,11,12,12,
	13,14,12,13,13,14,14,13,13,14,14,16,13,14,14,15,
	16,10,11,11,13,13,12,12,12,14,14,11,12,12,14,14,
	13,14,14,15,16,13,14,14,16,15, 7, 8, 8,10,10, 8,
	10,10,11,11, 8,10,10,12,11,10,11,11,13,13,10,11,
	11,13,13, 8,10,10,11,11,10,11,11,12,12,10,11,11,
	12,12,11,12,12,14,14,11,12,12,14,14, 8,10, 9,11,
	10,10,11,11,13,12,10,11,10,13,12,11,12,12,14,14,
	11,12,11,14,13,10,11,11,13,13,11,12,12,14,14,12,
	12,12,14,14,13,14,14,15,16,13,14,14,15,15,10,11,
	11,13,12,12,12,12,14,14,11,12,12,14,13,13,14,14,
	16,15,13,14,13,16,14,10,11,11,13,13,12,12,13,14,
	15,12,13,13,14,15,13,14,15,15,16,13,14,14,16,16,
	11,12,13,14,14,13,13,14,15,16,13,14,14,15,16,14,
	15,15,16,17,14,15,16,17,17,11,12,12,14,14,13,14,
	14,15,16,13,14,14,15,15,14,15,15,16,18,14,15,15,
	17,16,13,14,15,15,16,15,15,16,16,18,15,15,15,17,
	17,16,16,17,17,18,16,16,16,18,18,14,14,14,16,16,
	15,15,15,16,17,15,15,15,16,17,16,17,17,18,18,16,
	16,17,18,17,10,11,11,14,13,12,13,13,15,14,11,13,
	13,15,14,13,15,15,16,16,13,14,14,16,16,11,12,12,
	14,14,13,13,13,15,15,13,14,13,15,15,15,15,15,17,
	16,14,15,15,17,16,11,13,12,14,14,13,14,13,15,15,
	13,14,13,15,15,14,15,15,17,17,14,15,15,17,16,14,
	14,14,16,16,14,15,15,17,17,15,15,16,17,16,17,16,
	17,18,18,16,17,17,18,18,13,14,14,16,15,15,15,15,
	17,17,14,16,15,16,16,17,17,17,18,18,16,17,16,20,
	19, 6, 8, 8,10,10, 8,10,10,11,11, 8,10,10,12,11,
	10,11,11,13,13,10,11,11,13,13, 8, 9,10,11,11,10,
	11,11,12,12,10,11,11,13,12,11,12,12,14,14,11,12,
	12,14,14, 9,10,10,11,11,10,11,11,12,12,10,11,11,
	13,12,11,12,12,14,14,11,12,12,14,14,10,10,11,12,
	13,11,12,12,14,14,11,12,12,14,14,13,14,14,15,16,
	13,14,14,15,16,10,11,11,13,13,12,12,12,14,14,12,
	13,12,14,14,13,14,14,16,16,13,14,14,15,15, 9,10,
	10,11,12,10,11,11,12,13,10,11,11,13,12,11,12,12,
	14,14,11,12,12,14,14,10,10,11,12,13,11,12,12,13,
	14,11,12,12,13,14,12,13,14,14,15,12,13,13,15,15,
	10,11,11,13,13,11,12,12,13,14,11,12,12,14,13,12,
	13,13,15,15,12,13,13,15,15,12,11,13,12,14,13,13,
	14,14,15,13,13,14,14,15,14,15,15,16,17,14,15,15,
	16,17,12,13,12,14,14,13,14,14,15,15,13,14,14,15,
	15,14,15,15,16,17,14,15,15,16,17, 8, 9, 9,11,11,
	10,11,11,12,13,10,11,11,13,12,12,13,13,14,15,11,
	13,12,15,14, 9,11,10,12,12,11,12,12,13,14,11,12,
	12,14,13,13,13,14,15,15,13,14,13,15,15, 9,11,11,
	12,12,11,12,12,14,14,11,12,12,14,13,13,14,14,15,
	16,13,14,13,15,14,11,12,12,14,13,12,13,13,14,15,
	13,14,14,16,15,15,15,15,15,16,15,16,15,17,17,11,
	12,12,14,14,13,14,14,15,15,12,13,13,15,14,15,15,
	15,17,17,14,15,15,17,15,11,12,12,14,14,12,13,13,
	15,15,12,13,13,15,15,14,15,15,17,17,14,15,15,16,
	16,12,13,13,14,15,13,14,14,16,16,14,14,14,15,16,
	15,16,16,17,17,15,16,16,17,17,12,13,13,15,15,14,
	14,14,16,16,14,14,15,16,16,15,16,16,17,17,15,16,
	16,17,17,14,15,15,15,16,15,15,16,16,18,15,16,16,
	17,17,17,17,17,18,18,16,17,17,19,18,14,15,15,16,
	17,15,16,16,17,17,15,16,16,18,17,16,17,17,19,18,
	17,17,17,19,18,10,12,12,14,14,13,13,14,15,15,12,
	14,13,16,15,15,15,15,17,17,14,15,15,17,16,12,13,
	13,15,14,13,14,14,16,16,14,14,15,17,16,15,16,16,
	17,17,15,16,16,18,17,12,13,13,15,14,14,15,15,16,
	16,13,15,14,16,15,16,17,16,19,17,15,16,16,17,17,
	14,15,15,17,15,15,16,15,17,17,16,17,16,18,17,17,
	17,18,18,18,17,17,18,19,18,14,15,15,16,16,15,16,
	16,17,18,15,16,16,18,16,17,18,18,19,19,17,18,17,
	18,19, 6, 8, 8,10,10, 8,10,10,11,11, 8,10,10,12,
	11,10,11,11,13,13, 9,11,11,13,13, 9,10,10,11,11,
	10,11,11,12,12,10,11,11,12,12,11,12,12,14,14,11,
	12,12,14,14, 8,10, 9,11,11,10,11,11,12,12,10,11,
	11,12,12,11,12,12,14,14,11,12,12,14,14,10,11,11,
	13,13,11,12,13,14,14,12,12,12,14,14,13,14,14,15,
	16,13,14,14,16,16,10,11,10,13,12,11,12,12,14,14,
	11,12,12,14,14,13,14,14,15,16,13,14,14,16,15, 8,
	 9, 9,11,11,10,11,11,12,13,10,11,11,13,12,12,13,
	13,14,15,12,13,13,15,14,10,11,11,12,12,11,11,12,
	13,14,11,12,12,14,14,13,13,14,15,16,13,14,14,15,
	15, 9,10,11,12,12,11,12,12,13,14,11,12,12,14,13,
	13,14,14,15,16,12,14,13,15,15,11,12,12,14,14,12,
	13,13,14,15,13,14,14,16,15,14,15,15,15,17,15,15,
	16,16,17,11,12,12,13,14,13,14,14,15,15,12,13,13,
	15,14,15,16,15,16,17,14,16,15,17,15, 9,10,10,12,
	11,10,11,11,13,13,10,11,11,13,12,11,12,12,14,14,
	11,12,12,14,14,10,11,11,12,13,11,12,12,13,14,11,
	12,12,14,14,12,13,13,15,15,12,13,13,15,15,10,11,
	10,13,12,11,12,12,13,13,11,12,12,14,13,12,13,13,
	15,15,12,13,13,15,14,12,13,12,14,14,13,14,14,15,
	15,13,14,14,15,15,14,15,15,16,16,14,15,15,16,16,
	11,13,11,14,12,13,13,13,15,14,12,14,13,15,14,15,
	15,15,17,16,14,15,14,17,15,10,12,12,14,14,13,13,
	14,15,16,12,14,13,15,15,14,15,16,17,17,14,15,16,
	17,17,12,13,13,14,15,13,14,14,16,16,14,14,15,16,
	16,16,16,16,17,17,16,16,16,18,18,12,13,13,14,15,
	14,14,15,16,16,13,14,14,16,15,16,16,16,17,18,15,
	16,16,17,17,14,15,15,16,16,15,15,16,17,17,15,16,
	16,17,18,17,18,18,18,19,17,18,18,19,19,14,15,15,
	16,16,15,16,16,17,17,15,16,16,17,17,17,17,18,20,
	18,17,18,17,18,18,11,12,12,14,14,12,13,14,15,15,
	12,13,13,15,15,14,15,15,16,17,14,15,15,16,17,12,
	13,13,15,15,14,14,14,16,16,14,14,14,16,16,15,16,
	16,17,17,15,16,16,17,17,12,13,13,15,14,13,14,14,
	16,15,14,15,14,16,15,15,16,16,17,17,15,16,16,17,
	16,14,15,15,16,16,15,16,16,17,17,16,16,16,17,17,
	17,17,17,19,18,17,17,17,18,19,14,15,14,17,15,15,
	16,16,17,17,15,16,15,17,17,16,17,17,18,18,16,17,
	17,18,17, 6,11,11,13,13,11,12,12,14,14,11,12,12,
	14,14,13,14,14,16,16,13,14,14,16,16,11,12,12,14,
	14,12,13,13,15,15,12,13,13,15,15,14,15,15,16,17,
	14,15,15,17,18,11,12,12,14,14,12,13,13,15,15,12,
	13,13,15,15,14,15,15,17,17,14,15,15,16,16,13,14,
	14,15,16,14,15,15,16,17,14,15,15,17,16,15,16,17,
	18,17,16,16,16,18,17,14,14,15,16,16,14,15,15,18,
	16,14,15,15,17,16,16,17,17,18,18,16,17,16,18,17,
	11,12,12,14,14,12,13,13,15,15,12,13,13,15,15,14,
	15,15,17,17,14,15,15,16,16,12,13,13,15,15,13,14,
	14,15,16,13,14,14,16,16,15,16,16,17,17,15,15,16,
	17,17,12,13,13,15,15,14,14,14,16,16,13,14,14,16,
	16,15,16,16,17,17,15,16,16,17,17,14,14,15,15,16,
	15,15,16,16,17,15,15,16,16,17,16,17,17,17,18,16,
	17,17,18,18,14,15,15,16,16,15,16,16,17,17,15,16,
	16,17,17,17,17,17,18,19,17,17,17,18,18,10,12,12,
	14,14,12,13,14,15,16,13,14,13,15,15,14,15,15,17,
	17,14,15,16,17,17,12,13,13,15,15,13,14,14,15,15,
	14,15,14,16,16,15,16,16,17,18,15,17,16,18,17,12,
	13,13,15,15,14,14,14,16,16,13,14,14,16,15,15,16,
	16,17,18,15,16,16,17,17,14,14,14,16,16,15,15,16,
	17,17,15,16,16,17,17,17,17,17,18,20,17,17,17,19,
	19,14,15,15,16,16,15,17,16,18,18,15,16,15,17,16,
	17,18,19,19,19,17,17,17,18,17,13,14,14,16,16,14,
	15,15,17,17,14,15,15,16,17,15,17,17,18,18,16,16,
	17,18,17,14,15,15,16,17,15,16,16,17,17,15,16,16,
	17,17,16,17,17,18,18,17,17,17,18,19,14,15,15,16,
	17,15,16,16,17,17,15,16,16,17,17,16,17,17,18,18,
	17,17,17,19,19,16,16,16,16,18,16,17,17,17,18,17,
	17,17,17,19,18,18,18,19,19,18,18,18,19,20,16,16,
	17,18,18,16,18,17,18,18,17,17,17,20,19,18,18,19,
	21,20,18,20,18,18,19,10,12,12,14,14,14,14,15,15,
	17,14,15,14,17,15,16,16,17,18,18,16,18,17,19,18,
	12,14,13,16,15,14,14,15,15,17,15,16,16,18,17,16,
	17,18,17,19,17,19,18,20,19,12,13,13,15,15,15,16,
	17,17,18,14,16,14,17,16,17,18,18,19,19,17,17,17,
	18,18,15,15,15,17,16,15,16,16,17,17,17,19,17,18,
	18,18,18,18,18,21,19,20,19,20,19,15,15,16,16,17,
	17,17,18,20,20,15,16,16,18,17,18,19,19,19,20,18,
	19,18,19,17, 6,11,11,13,13,11,12,12,14,14,11,12,
	12,14,14,13,14,14,16,16,13,14,14,16,16,11,12,12,
	14,14,12,13,13,15,15,12,13,13,15,15,14,15,15,17,
	17,14,15,15,17,16,11,12,12,14,14,12,13,13,15,15,
	12,13,13,15,15,14,15,15,16,16,14,15,15,16,16,13,
	14,14,16,16,15,15,15,16,16,14,15,15,17,16,16,17,
	17,19,18,16,17,17,18,18,13,14,14,15,15,14,15,15,
	17,16,14,15,15,17,16,16,17,16,17,18,15,16,16,18,
	18,10,12,12,14,14,12,13,14,15,15,12,13,13,15,15,
	14,15,15,17,17,14,15,15,17,16,12,13,13,15,15,14,
	14,14,15,16,14,15,15,16,16,15,16,16,17,18,16,16,
	16,18,18,12,13,13,14,14,14,14,15,16,16,13,14,14,
	16,16,15,16,16,18,18,15,16,16,19,17,14,15,15,16,
	17,15,15,16,17,17,16,17,16,17,18,17,17,18,17,19,
	17,17,18,18,19,14,14,14,16,16,15,16,16,17,17,15,
	16,15,17,17,17,17,17,19,20,16,17,17,18,18,11,12,
	12,14,14,12,13,13,15,15,12,13,13,15,15,14,15,15,
	16,16,14,15,14,16,16,12,13,13,15,15,14,14,14,16,
	16,13,14,14,16,16,15,16,16,18,17,15,16,16,17,17,
	12,13,13,15,15,13,14,14,16,16,13,14,14,16,16,15,
	16,15,18,18,15,16,15,17,16,14,15,15,16,16,15,16,
	16,17,17,15,16,16,18,17,16,17,17,18,18,16,17,17,
	18,18,14,15,14,16,15,15,16,15,17,17,15,16,15,17,
	16,16,17,17,18,18,17,17,16,19,17,10,12,12,14,15,
	14,14,15,15,17,14,15,14,17,15,16,17,17,17,18,16,
	17,17,18,18,12,14,13,16,15,14,14,16,15,17,15,17,
	16,18,17,17,17,18,17,19,18,18,18,19,18,12,13,14,
	15,15,15,16,16,16,17,14,15,14,18,16,18,17,18,19,
	19,17,18,17,20,18,15,15,15,17,17,15,16,16,17,18,
	18,18,18,19,18,18,18,19,18,20,18,19,19,21,21,15,
	15,16,16,17,17,18,18,18,18,15,16,16,17,17,17,19,
	20,19,20,17,18,18,19,17,13,14,14,16,16,14,15,15,
	16,17,14,15,15,17,17,16,16,17,17,18,15,17,16,17,
	17,14,15,15,16,16,15,16,16,17,17,16,16,16,17,17,
	17,17,18,17,18,17,17,17,18,20,14,15,15,17,16,15,
	16,16,17,17,15,16,16,17,17,17,17,17,18,18,16,17,
	17,19,18,16,16,17,17,17,17,18,17,19,18,17,17,17,
	18,19,17,20,18,19,21,17,19,18,19,20,15,17,15,17,
	16,16,17,17,18,18,17,17,17,18,17,18,19,18,19,21,
	18,18,17,19,19,
};

static const static_codebook _44p9_p2_0 = {
	5, 3125,
	(long *)_vq_lengthlist__44p9_p2_0,
	1, -533725184, 1611661312, 3, 0,
	(long *)_vq_quantlist__44p9_p2_0,
	0
};

static const long _vq_quantlist__44p9_p3_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p9_p3_0[] = {
	 2, 5, 4, 4, 7, 7, 4, 7, 6, 5, 6, 7, 7, 8, 9, 7,
	 9, 9, 5, 7, 6, 7, 9, 9, 7, 9, 8, 6, 8, 8, 8,10,
	10, 8,10,10, 8, 9,10,10,11,12,10,12,12, 8,10,10,
	10,12,12,10,12,11, 6, 8, 8, 8,10,10, 8,10,10, 8,
	10,10,10,11,12,10,12,12, 8,10, 9,10,12,11,10,12,
	11, 5, 8, 8, 8,10,10, 8,10,10, 8, 9,10,10,11,11,
	10,11,11, 8,10,10,10,11,12,10,12,11, 8,10,10,10,
	11,11,10,11,11,10,11,11,11,12,13,11,12,13,10,11,
	11,11,13,13,11,13,13, 7, 9, 9,10,11,12,10,12,11,
	 9,11,11,11,12,13,12,14,13, 9,11,11,12,13,14,11,
	13,12, 5, 8, 8, 8,10,10, 8,10,10, 8,10,10,10,11,
	12,10,12,12, 8,10, 9,10,12,11, 9,11,11, 7, 9, 9,
	10,11,12,10,12,11, 9,11,11,11,12,13,12,14,13, 9,
	11,11,12,13,14,11,13,12, 8,10,10,10,11,11,10,11,
	11,10,11,11,11,13,13,11,13,13,10,11,10,11,13,12,
	11,13,12,
};

static const static_codebook _44p9_p3_0 = {
	5, 243,
	(long *)_vq_lengthlist__44p9_p3_0,
	1, -533200896, 1614282752, 2, 0,
	(long *)_vq_quantlist__44p9_p3_0,
	0
};

static const long _vq_quantlist__44p9_p3_1[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p9_p3_1[] = {
	 4, 6, 6, 6, 7, 7, 6, 7, 7, 6, 7, 7, 7, 7, 8, 7,
	 7, 8, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8,
	 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 8, 9, 9, 8, 8, 8,
	 8, 9, 9, 8, 9, 9, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8,
	 8, 8, 8, 9, 9, 8, 9, 9, 8, 8, 8, 8, 9, 9, 8, 9,
	 9, 5, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9,
	 8, 9, 9, 8, 8, 8, 8, 9, 9, 8, 9, 9, 8, 8, 8, 8,
	 9, 9, 8, 9, 9, 8, 8, 9, 9, 9, 9, 9, 9, 9, 8, 9,
	 9, 9, 9, 9, 9, 9, 9, 7, 8, 8, 8, 9, 9, 8, 9, 9,
	 8, 9, 8, 9, 9, 9, 9, 9, 9, 8, 8, 8, 9, 9, 9, 9,
	 9, 9, 6, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9,
	 9, 8, 9, 9, 8, 8, 8, 8, 9, 9, 8, 9, 9, 7, 8, 8,
	 8, 9, 9, 8, 9, 9, 8, 8, 9, 9, 9, 9, 9, 9, 9, 8,
	 8, 8, 9, 9, 9, 9, 9, 9, 8, 8, 8, 8, 9, 9, 8, 9,
	 9, 8, 9, 9, 9, 9, 9, 9, 9, 9, 8, 9, 8, 9, 9, 9,
	 9, 9, 9,
};

static const static_codebook _44p9_p3_1 = {
	5, 243,
	(long *)_vq_lengthlist__44p9_p3_1,
	1, -535822336, 1611661312, 2, 0,
	(long *)_vq_quantlist__44p9_p3_1,
	0
};

static const long _vq_quantlist__44p9_p4_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p9_p4_0[] = {
	 2, 5, 5, 4, 7, 7, 4, 7, 6, 5, 7, 7, 7, 8, 9, 7,
	 9, 9, 5, 7, 7, 7, 9, 9, 7, 9, 8, 6, 7, 8, 8, 9,
	10, 8,10,10, 8, 9,10,10,11,12,10,11,12, 8,10,10,
	10,11,12,10,12,11, 6, 8, 7, 8,10,10, 8,10, 9, 8,
	10,10,10,11,12,10,12,12, 8,10, 9,10,12,11,10,12,
	11, 5, 8, 8, 8,10,10, 8,10,10, 7, 9,10, 9,10,11,
	10,11,11, 8,10,10,10,12,12,10,12,11, 7, 9, 9, 9,
	11,11, 9,11,11, 9,10,11,11,11,12,11,12,12, 9,11,
	11,11,12,12,11,12,12, 7, 9, 9,10,11,12,10,12,11,
	 9,11,10,11,11,12,12,13,13, 9,11,11,12,13,13,11,
	13,11, 5, 8, 8, 8,10,10, 8,10,10, 8,10,10,10,11,
	12,10,12,12, 7, 9, 9, 9,11,11, 9,11,10, 7, 9, 9,
	10,11,12,10,12,11, 9,11,11,11,11,13,12,13,13, 9,
	10,11,12,13,13,11,12,11, 7, 9, 9, 9,11,11, 9,11,
	11, 9,11,11,11,12,12,11,12,12, 9,11,10,11,12,12,
	10,12,11,
};

static const static_codebook _44p9_p4_0 = {
	5, 243,
	(long *)_vq_lengthlist__44p9_p4_0,
	1, -531365888, 1616117760, 2, 0,
	(long *)_vq_quantlist__44p9_p4_0,
	0
};

static const long _vq_quantlist__44p9_p4_1[] = {
	2,
	1,
	3,
	0,
	4,
};

static const long _vq_lengthlist__44p9_p4_1[] = {
	 6, 8, 8,10, 9, 8, 9, 9,10,10, 8, 9, 9,10,10, 8,
	10,10,10,10, 8,10,10,10,10, 9, 9, 9,10,10, 9,10,
	10,10,11, 9,10,10,11,11,10,10,10,11,11,10,10,10,
	11,11, 9, 9, 9,10,10, 9,10,10,11,11, 9,10,10,11,
	10,10,10,10,11,11,10,10,10,11,11,10,10,10,10,11,
	10,10,11,11,11,10,11,11,11,11,11,11,11,11,11,11,
	11,11,11,11,10,10,10,11,10,10,11,11,11,11,10,11,
	10,11,11,11,11,11,11,11,10,11,11,11,11, 9,10,10,
	10,11,10,10,11,11,11,10,11,11,11,11,10,11,11,11,
	11,10,11,11,11,11,10,10,11,11,11,11,11,11,11,11,
	11,11,11,11,12,11,11,12,12,12,11,11,11,12,12,10,
	11,11,11,11,11,11,11,12,12,11,11,11,11,11,11,11,
	11,12,12,11,11,11,12,12,11,11,11,11,11,11,12,12,
	12,12,11,12,12,12,12,11,12,12,12,12,12,12,12,12,
	12,11,11,11,11,11,11,12,12,12,12,11,12,11,12,12,
	11,12,12,12,12,12,12,12,12,12, 9,10,10,11,10,10,
	11,11,11,11,10,11,11,11,11,10,11,11,11,11,10,11,
	11,11,11,10,11,11,11,11,11,11,11,11,11,11,11,11,
	12,12,11,11,12,12,12,11,11,11,12,12,10,11,10,11,
	11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,12,
	11,11,11,12,12,11,11,11,11,11,11,12,12,12,12,11,
	12,12,12,12,11,12,12,12,12,12,12,12,12,12,11,11,
	11,11,11,11,12,12,12,12,11,12,11,12,12,12,12,12,
	12,12,11,12,12,12,12,11,11,11,11,11,11,12,12,12,
	12,11,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	11,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,13,13,12,12,12,13,13,11,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,13,13,12,12,12,
	13,13,12,12,12,12,12,12,12,12,12,13,12,12,12,13,
	13,12,13,13,13,13,12,13,13,13,13,12,12,12,12,12,
	12,12,12,13,13,12,12,12,13,13,12,13,13,13,13,12,
	13,13,13,13,11,11,11,11,11,11,12,12,12,12,11,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,11,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,13,
	13,12,12,12,13,13,11,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,13,13,12,12,12,13,13,12,
	12,12,12,12,12,12,12,13,13,12,12,12,13,13,12,13,
	13,13,13,12,13,13,13,13,12,12,12,12,12,12,12,12,
	13,13,12,12,12,13,12,12,13,13,13,13,12,13,13,13,
	13, 7,10,10,11,11,10,10,11,11,11,10,11,11,11,11,
	10,11,11,11,11,10,11,11,11,11,10,10,10,11,11,10,
	11,11,11,11,11,11,11,11,12,11,11,11,12,12,11,11,
	11,12,12,10,11,11,11,11,11,11,11,12,11,11,11,11,
	12,11,11,11,11,12,12,11,11,11,12,12,11,11,11,11,
	11,11,11,11,12,12,11,11,12,12,12,11,12,12,12,12,
	11,12,12,12,12,11,11,11,11,11,11,12,12,12,12,11,
	11,12,12,12,11,12,12,12,12,11,12,12,12,12,10,11,
	11,11,11,11,11,11,11,12,11,11,11,11,11,11,11,11,
	12,12,11,11,11,12,12,11,11,11,11,11,11,11,12,12,
	12,11,11,11,12,12,11,12,12,12,12,11,12,12,12,12,
	11,11,11,11,11,11,12,11,12,12,11,11,11,12,12,11,
	12,12,12,12,11,12,12,12,12,11,11,11,11,12,11,12,
	12,12,12,11,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,11,11,11,12,12,11,12,12,12,12,11,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,10,11,10,11,11,
	11,11,11,12,12,11,11,11,12,12,11,12,12,12,12,11,
	12,12,12,12,10,11,11,12,11,11,11,12,12,12,11,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,11,11,11,
	12,11,11,12,12,12,12,11,12,11,12,12,12,12,12,12,
	12,12,12,12,12,12,11,12,11,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,13,12,12,12,12,12,11,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,13,12,12,12,13,12,11,11,11,12,12,12,12,12,
	12,12,11,12,12,12,12,12,12,12,12,12,12,12,12,12,
	13,11,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,13,13,13,12,12,12,13,13,11,12,12,12,12,12,
	12,12,12,13,12,12,12,12,12,12,12,13,13,13,12,13,
	12,13,13,12,12,12,12,12,12,12,12,13,13,12,12,12,
	13,13,12,13,13,13,13,12,13,13,13,13,12,12,12,12,
	12,12,12,12,13,13,12,13,12,13,13,12,13,13,13,13,
	12,13,13,13,13,11,11,11,12,12,12,12,12,12,12,11,
	12,12,12,12,12,12,12,13,13,12,12,12,13,13,11,12,
	12,12,12,12,12,12,12,12,12,12,12,13,13,12,13,12,
	13,13,12,13,13,13,13,11,12,12,12,12,12,12,12,13,
	13,12,12,12,13,12,12,13,13,13,13,12,13,13,13,13,
	12,12,12,12,12,12,12,13,13,13,12,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,12,12,12,12,12,12,13,
	13,13,13,12,12,12,13,13,13,13,13,13,13,13,13,13,
	13,13, 7,10,10,11,11,10,11,11,11,11,10,11,11,11,
	11,10,11,11,11,11,10,11,11,11,11,10,11,11,11,11,
	11,11,11,11,11,11,11,11,12,11,11,11,12,12,12,11,
	11,11,12,12,10,10,10,11,11,11,11,11,12,11,10,11,
	11,11,11,11,11,11,12,12,11,11,11,12,12,11,11,11,
	11,11,11,11,12,12,12,11,12,11,12,12,11,12,12,12,
	12,11,12,12,12,12,11,11,11,11,11,11,11,11,12,12,
	11,12,11,12,12,11,12,12,12,12,11,12,12,12,12,10,
	10,10,11,11,11,11,11,12,12,11,11,11,12,12,11,12,
	12,12,12,11,12,12,12,12,11,11,11,11,11,11,11,12,
	12,12,11,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,11,11,11,11,11,11,12,12,12,12,11,12,11,12,12,
	12,12,12,12,12,12,12,12,12,12,11,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,13,12,12,
	12,13,12,11,11,11,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,10,11,11,11,
	11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,12,
	11,11,11,12,12,11,11,11,11,11,11,11,12,12,12,11,
	12,11,12,12,11,12,12,12,12,11,12,12,12,12,11,11,
	11,11,11,11,11,11,12,12,11,11,11,12,12,11,12,12,
	12,12,11,12,12,12,12,11,11,11,12,11,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	11,11,11,12,11,11,12,12,12,12,11,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,11,11,11,12,12,11,12,
	12,12,12,12,12,12,12,12,12,12,12,13,13,12,12,12,
	13,12,11,12,12,12,12,12,12,12,12,13,12,12,12,13,
	13,12,13,13,13,13,12,13,13,13,13,11,12,12,12,12,
	12,12,12,12,13,12,12,12,12,12,12,13,13,13,13,12,
	13,13,13,13,12,12,12,12,12,12,12,13,13,13,12,13,
	12,13,13,13,13,13,13,13,13,13,13,13,13,12,12,12,
	12,12,12,13,13,13,13,12,13,12,13,13,13,13,13,13,
	13,13,13,13,13,13,11,11,11,12,12,11,12,12,12,12,
	11,12,12,12,12,12,12,12,12,12,12,12,12,12,12,11,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,13,
	12,13,13,12,12,12,13,13,11,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,13,13,12,13,12,13,
	13,12,12,12,12,12,12,12,12,13,13,12,12,12,13,13,
	13,13,13,13,13,12,13,13,13,13,12,12,12,12,12,12,
	13,12,13,13,12,13,12,13,12,12,13,13,13,13,12,13,
	13,13,13, 8,11,11,12,12,11,12,12,12,12,11,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,11,11,11,12,
	12,11,12,12,12,12,12,12,12,12,12,12,12,12,13,13,
	12,12,12,13,13,11,11,11,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,13,13,12,12,12,13,13,11,12,
	12,12,12,12,12,12,12,13,12,12,12,12,12,12,12,13,
	13,13,12,12,13,13,13,11,12,12,12,12,12,12,12,13,
	12,12,12,12,13,13,12,13,13,13,13,12,13,13,13,13,
	11,11,11,12,12,11,12,12,12,12,11,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,11,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,13,13,12,12,12,
	13,13,11,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,13,12,13,13,12,13,12,13,13,12,12,12,12,12,
	12,12,12,12,13,12,12,12,13,13,12,13,13,13,13,12,
	13,13,13,13,12,12,12,12,12,12,12,12,13,13,12,12,
	12,13,13,12,13,13,13,13,12,13,13,13,13,11,11,11,
	12,12,11,12,12,12,12,11,12,12,12,12,12,12,12,13,
	12,12,12,12,12,13,11,12,12,12,12,12,12,12,12,13,
	12,12,12,12,13,12,13,13,13,13,12,13,13,13,13,11,
	12,12,12,12,12,12,12,12,13,12,12,12,13,12,12,13,
	13,13,13,12,13,13,13,13,12,12,12,12,12,12,12,12,
	13,13,12,12,13,13,13,12,13,13,13,13,12,13,13,13,
	13,12,12,12,12,12,12,13,13,13,13,12,13,12,13,13,
	12,13,13,13,13,13,13,13,13,13,11,11,11,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,11,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,13,13,13,12,13,13,13,13,11,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,13,13,13,13,
	12,13,12,13,13,12,12,12,12,12,12,12,12,13,13,12,
	12,12,13,13,12,13,13,13,13,12,13,13,13,13,12,12,
	12,12,12,12,13,12,13,13,12,12,12,13,13,13,13,13,
	13,13,12,13,13,13,13,11,11,11,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,13,12,12,12,13,12,
	11,12,12,12,12,12,12,12,12,12,12,12,12,13,13,12,
	12,13,13,13,12,13,13,13,13,11,12,12,12,12,12,12,
	12,12,13,12,12,12,13,12,12,13,13,13,13,12,13,13,
	13,13,12,12,12,12,12,12,12,12,13,13,12,12,12,13,
	13,13,13,13,13,13,13,13,13,13,13,12,12,12,12,12,
	12,13,13,13,13,12,13,12,13,13,13,13,13,13,13,13,
	13,13,13,13, 8,11,11,11,11,11,12,12,12,12,11,12,
	12,12,12,12,12,12,12,12,11,12,12,12,12,11,11,11,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	13,12,12,12,13,13,11,11,11,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,13,13,12,12,12,13,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,13,13,12,13,
	13,13,13,12,13,13,13,13,11,12,12,12,12,12,12,12,
	12,13,12,12,12,13,12,12,13,13,13,13,12,13,12,13,
	13,11,11,11,12,12,12,12,12,12,12,11,12,12,12,12,
	12,12,12,13,13,12,12,12,13,12,11,12,12,12,12,12,
	12,12,12,12,12,12,12,13,13,12,12,13,13,13,12,13,
	13,13,13,11,12,12,12,12,12,12,12,13,13,12,12,12,
	12,12,12,13,13,13,13,12,13,13,13,13,12,12,12,12,
	12,12,12,13,13,13,12,12,13,13,13,13,13,13,13,13,
	12,13,13,13,13,12,12,12,12,12,12,13,12,13,13,12,
	12,12,13,13,13,13,13,13,13,12,13,13,13,13,11,11,
	11,12,12,11,12,12,12,12,11,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,11,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,13,12,13,13,12,12,12,13,13,
	11,12,12,12,12,12,12,12,12,13,12,12,12,12,12,12,
	12,12,13,13,12,13,12,13,13,12,12,12,12,12,12,12,
	12,13,12,12,12,12,13,13,12,13,13,13,13,12,13,13,
	13,13,12,12,12,12,12,12,12,12,13,13,12,12,12,13,
	12,12,13,13,13,13,12,13,13,13,13,11,11,11,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,13,13,11,12,12,12,12,12,12,12,12,13,12,12,
	12,12,12,12,13,13,13,13,12,13,13,13,13,11,12,12,
	12,12,12,12,12,12,13,12,12,12,12,12,12,13,13,13,
	13,12,13,13,13,13,12,12,12,12,12,12,12,12,13,13,
	12,12,13,13,13,13,13,13,13,13,13,13,13,13,13,12,
	12,12,12,12,12,13,13,13,13,12,12,12,13,12,13,13,
	13,13,13,12,13,13,13,13,11,11,11,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	13,11,12,12,12,12,12,12,12,12,12,12,12,12,13,12,
	12,12,12,13,13,12,13,13,13,13,11,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,13,13,13,13,12,13,
	12,13,13,12,12,12,12,12,12,12,13,13,13,12,13,12,
	13,13,12,13,13,13,13,13,13,13,13,13,12,12,12,12,
	12,12,12,12,12,13,12,12,12,13,13,13,13,13,13,13,
	12,13,13,13,13,
};

static const static_codebook _44p9_p4_1 = {
	5, 3125,
	(long *)_vq_lengthlist__44p9_p4_1,
	1, -533725184, 1611661312, 3, 0,
	(long *)_vq_quantlist__44p9_p4_1,
	0
};

static const long _vq_quantlist__44p9_p5_0[] = {
	2,
	1,
	3,
	0,
	4,
};

static const long _vq_lengthlist__44p9_p5_0[] = {
	 4, 6, 6, 9, 9, 6, 7, 8,10,11, 6, 8, 7,10,10, 8,
	10,10,12,12, 8,10,10,12,12, 6, 7, 8,10,10, 7, 8,
	 9,10,11, 8, 9, 9,11,11,10,10,11,12,13,10,11,11,
	13,13, 6, 8, 7,10,10, 8, 9, 9,11,11, 7, 9, 8,11,
	10,10,11,11,13,13,10,11,10,13,12, 9,10,10,11,12,
	10,10,11,12,13,10,11,11,12,13,12,12,13,12,14,12,
	13,13,14,14, 9,10,10,12,11,10,11,11,13,12,10,11,
	10,13,12,12,13,13,14,14,12,13,12,14,12, 7, 8, 8,
	10,11, 8, 9,10,11,12, 8, 9, 9,11,12,10,11,12,13,
	14,10,11,11,13,13, 8, 9,10,11,12, 9,10,11,12,13,
	10,10,11,12,12,11,12,12,13,14,11,12,12,14,14, 8,
	 9, 9,11,12,10,10,11,12,13, 9,10,10,12,12,11,12,
	12,14,14,11,12,12,14,13,11,11,12,12,13,11,12,12,
	13,14,12,12,13,14,14,13,13,14,14,16,13,14,14,15,
	15,11,12,11,13,13,12,12,12,14,14,11,12,12,14,13,
	13,14,14,15,15,13,14,13,15,14, 7, 8, 8,11,10, 8,
	10, 9,12,11, 8,10, 9,12,11,10,11,11,13,13,10,12,
	11,14,13, 8, 9, 9,12,11, 9,10,10,12,12,10,11,10,
	13,12,11,12,12,13,14,11,12,12,14,14, 8,10, 9,12,
	11,10,11,10,12,12, 9,11,10,13,11,11,12,12,14,14,
	11,12,12,14,13,11,11,12,13,13,11,12,12,13,14,12,
	12,12,14,14,13,13,14,14,15,13,14,14,15,15,11,12,
	11,13,12,12,12,12,14,14,11,12,12,14,13,13,14,14,
	15,15,13,14,13,15,14,10,11,11,12,13,11,12,12,13,
	14,11,12,12,13,14,13,13,14,14,16,13,14,14,15,15,
	11,12,12,12,14,12,12,13,13,15,12,13,13,13,15,14,
	14,15,15,16,14,14,15,15,16,11,12,12,13,14,12,13,
	13,14,15,12,13,13,14,14,14,14,15,15,16,14,14,14,
	15,15,13,14,14,14,15,14,14,15,15,16,14,15,15,15,
	16,15,15,16,16,18,16,16,16,17,17,13,14,14,15,15,
	14,14,15,16,16,14,14,14,16,15,16,16,16,17,17,15,
	16,16,17,16,10,11,11,13,12,11,12,12,14,13,11,12,
	12,14,13,13,14,14,15,15,13,14,13,16,14,11,12,12,
	14,13,12,13,13,14,14,12,13,13,15,14,14,14,14,15,
	15,14,15,14,16,15,11,12,12,14,12,12,13,13,15,14,
	12,13,12,15,13,14,15,14,16,15,14,15,14,16,15,13,
	14,14,15,15,14,14,14,15,16,14,15,14,16,16,15,16,
	16,16,17,16,16,16,17,17,13,14,14,15,14,14,15,15,
	16,15,14,15,14,16,15,16,16,16,17,17,15,16,15,18,
	16, 6, 8, 8,11,11, 8, 9,10,11,12, 8,10, 9,12,12,
	10,11,11,13,13,10,12,11,14,13, 8, 9, 9,11,12, 9,
	10,10,12,12, 9,10,10,12,12,11,11,12,13,14,11,12,
	12,14,14, 8,10, 9,12,11,10,11,11,12,12, 9,11,10,
	13,12,11,12,12,14,14,11,12,12,14,13,10,11,11,13,
	13,11,12,12,13,14,11,12,12,14,14,13,13,14,13,15,
	13,14,14,15,15,11,12,11,13,13,12,12,12,14,14,11,
	12,12,14,13,13,14,14,15,15,13,14,13,15,14, 8, 9,
	 9,11,11, 9,10,10,12,12, 9,10,10,12,12,11,12,12,
	13,14,11,12,12,14,14, 9, 9,10,11,12,10,10,11,12,
	13,10,10,11,12,13,12,12,13,13,15,12,12,13,14,14,
	 9,10,10,12,12,10,11,11,13,13,10,11,11,13,13,12,
	13,13,14,15,12,13,12,14,14,11,11,12,12,14,12,12,
	13,13,14,12,12,13,13,14,13,13,14,14,16,14,14,14,
	15,15,11,12,12,14,13,12,13,13,14,14,12,13,13,15,
	14,14,14,14,16,16,13,14,14,16,14, 7, 9, 9,12,11,
	 9,10,10,12,12, 9,11,10,13,12,11,12,12,13,14,11,
	13,12,14,13, 9,10,10,12,12,10,10,11,12,13,10,12,
	11,13,13,12,12,13,13,14,12,13,13,15,14, 9,10,10,
	12,12,11,11,11,13,13,10,12,10,13,12,12,13,13,14,
	15,12,13,12,15,13,11,12,12,14,13,12,12,13,13,14,
	12,13,13,15,14,13,13,14,13,16,14,15,14,16,15,12,
	12,12,14,14,13,13,13,14,14,12,13,12,14,13,14,15,
	15,16,16,13,14,13,16,13,10,11,12,13,14,11,12,13,
	13,15,12,12,13,14,14,13,14,14,15,16,13,14,14,16,
	15,12,12,13,12,14,12,12,13,13,15,13,13,13,13,15,
	14,14,15,14,16,14,15,15,15,16,12,13,12,14,14,13,
	13,13,15,15,12,13,13,15,15,14,15,15,16,16,14,15,
	15,16,16,13,14,14,13,16,14,14,15,14,16,14,14,15,
	14,16,15,15,16,15,18,16,16,16,16,17,14,14,14,16,
	15,14,15,15,16,16,14,15,15,16,16,16,16,16,17,17,
	15,16,16,17,16,10,12,11,14,13,12,13,13,14,14,12,
	13,12,15,14,14,14,14,15,15,14,15,14,16,15,12,13,
	12,14,13,12,13,13,15,14,13,14,13,15,14,14,15,15,
	16,16,14,15,15,17,15,12,13,12,14,14,13,14,14,15,
	15,13,14,13,15,14,15,15,15,16,16,14,15,15,17,15,
	14,14,14,16,15,14,15,15,16,16,14,15,15,16,15,16,
	16,16,16,17,16,17,16,18,17,14,14,14,16,15,15,15,
	15,16,16,14,15,14,16,15,16,16,17,17,17,15,16,15,
	17,16, 6, 8, 8,11,11, 8, 9,10,12,12, 8,10, 9,12,
	11,10,11,12,13,13,10,11,11,13,13, 8, 9,10,11,12,
	 9,10,11,12,13,10,11,11,12,12,11,12,12,13,14,11,
	12,12,14,14, 8, 9, 9,12,11, 9,10,10,12,12, 9,10,
	10,12,12,11,12,12,14,14,11,12,11,14,13,11,11,12,
	13,13,11,12,12,13,14,12,12,12,14,14,13,13,14,14,
	15,13,14,14,15,15,10,11,11,13,13,11,12,12,14,14,
	11,12,12,14,13,13,14,14,15,15,13,14,13,15,13, 7,
	 9, 9,11,12, 9,10,11,12,13, 9,10,10,12,12,11,12,
	13,13,14,11,12,12,14,14, 9,10,10,12,12,10,10,11,
	12,13,11,12,11,13,13,12,12,13,13,15,12,13,13,15,
	14, 9,10,10,12,12,10,11,12,13,13,10,11,10,13,12,
	12,13,13,14,15,12,13,12,14,13,12,12,12,14,14,12,
	12,13,13,14,13,13,13,15,14,14,13,14,13,16,14,15,
	15,16,16,11,12,12,13,14,12,13,13,14,15,12,13,12,
	14,13,14,14,15,15,16,13,14,13,15,13, 8, 9, 9,11,
	11, 9,10,10,12,12, 9,10,10,12,12,11,12,12,14,14,
	11,12,11,14,13, 9,10,10,12,12,10,11,11,13,13,10,
	11,11,13,13,12,12,13,14,15,12,13,13,15,14, 9,10,
	 9,12,11,10,11,10,13,12,10,11,10,13,12,12,13,12,
	14,14,12,13,12,15,13,11,12,12,13,14,12,13,13,14,
	14,12,13,13,14,14,14,14,14,14,16,14,14,14,16,15,
	11,12,11,14,12,12,13,12,15,13,12,13,12,15,13,14,
	14,14,16,15,13,14,13,16,14,10,11,12,13,14,12,12,
	13,13,15,12,13,13,14,14,14,14,15,15,16,14,14,14,
	15,16,12,12,13,14,14,12,13,14,14,15,13,14,14,15,
	15,14,15,15,15,17,15,15,15,16,16,12,12,13,13,14,
	13,13,14,14,15,12,13,13,14,15,15,15,15,15,17,14,
	15,15,15,15,14,14,14,16,16,14,15,15,15,16,15,15,
	15,16,16,16,15,16,16,18,16,16,17,17,17,14,14,14,
	15,16,15,15,15,16,17,14,15,14,16,16,16,16,17,17,
	18,16,16,15,17,16,10,12,11,14,13,12,12,12,14,14,
	11,13,12,14,13,13,14,14,15,15,13,14,13,16,15,12,
	12,13,14,14,12,13,13,15,15,13,13,13,15,15,14,15,
	15,16,16,14,15,15,17,16,12,13,12,14,12,13,13,13,
	15,13,12,13,12,15,13,14,15,15,16,15,14,15,14,16,
	14,14,14,14,16,16,14,15,15,16,16,14,15,15,16,16,
	15,16,16,16,17,16,17,16,18,17,13,14,14,16,13,14,
	15,15,16,14,14,15,14,16,14,16,16,16,17,16,15,16,
	15,18,15, 9,11,11,13,13,11,12,12,14,14,11,12,12,
	14,14,13,14,14,15,15,13,14,14,15,15,11,12,12,14,
	14,11,12,13,14,15,12,13,13,15,14,13,14,14,15,16,
	13,14,14,16,16,11,12,12,14,14,12,13,13,15,15,12,
	13,13,15,14,14,14,14,16,16,14,15,14,16,15,12,13,
	13,14,15,12,13,14,15,16,13,14,14,16,16,14,14,15,
	16,17,15,15,15,17,17,13,14,14,15,15,14,15,14,16,
	16,14,15,14,16,15,15,16,16,17,17,15,16,15,17,16,
	10,12,12,13,14,11,12,13,14,14,12,13,12,14,14,13,
	14,14,15,16,13,14,14,16,15,11,12,12,14,14,12,12,
	13,14,15,12,13,13,15,15,13,13,15,15,17,14,14,15,
	16,16,12,13,12,14,14,12,13,13,15,15,12,13,13,15,
	14,14,15,15,16,16,14,15,14,16,16,13,12,14,13,16,
	13,13,15,14,16,14,13,15,15,16,14,14,16,15,17,15,
	15,16,16,17,13,14,14,16,15,14,15,15,16,16,14,15,
	14,16,15,16,16,16,17,17,15,16,16,18,16,10,12,12,
	14,14,12,12,13,14,14,12,13,12,15,14,13,14,14,15,
	16,14,15,14,16,15,11,12,12,14,14,12,13,13,14,15,
	13,14,13,15,15,14,14,15,15,16,14,15,15,17,16,12,
	13,13,14,14,13,13,14,15,15,12,14,13,15,15,14,15,
	15,16,16,14,15,15,17,15,13,14,13,15,15,13,14,14,
	15,16,14,15,14,17,16,15,15,15,15,17,16,16,16,18,
	17,14,14,14,16,16,15,15,15,16,16,14,15,14,16,16,
	16,16,17,17,17,16,16,16,17,16,11,12,13,14,14,12,
	13,13,15,15,12,13,13,15,15,14,15,15,16,16,14,15,
	15,17,16,12,13,13,14,15,13,13,14,14,16,13,14,14,
	15,16,15,14,16,15,17,15,15,16,16,17,12,13,13,15,
	15,13,14,14,16,16,13,14,14,16,15,15,15,16,17,17,
	15,16,15,17,16,14,14,15,13,16,15,14,16,14,17,15,
	15,16,14,17,16,15,17,15,18,16,16,17,16,18,14,15,
	15,17,16,15,16,16,17,17,15,16,15,17,16,16,17,17,
	18,18,16,17,15,18,16,11,12,12,14,14,13,13,14,14,
	15,13,14,13,16,14,15,15,15,16,16,15,16,15,17,16,
	12,13,13,15,14,13,13,14,15,15,14,15,14,16,15,15,
	15,16,15,16,16,16,16,18,16,12,13,13,15,15,14,14,
	15,15,16,13,14,13,16,15,16,16,16,17,17,15,16,15,
	17,15,14,15,14,16,15,14,15,15,16,16,15,16,15,17,
	16,16,15,16,15,17,17,18,17,18,17,15,15,15,16,16,
	16,16,16,17,17,14,15,15,17,16,17,17,18,18,18,16,
	17,15,18,15, 9,11,11,13,13,11,12,12,14,14,11,12,
	12,14,14,13,14,14,15,16,13,14,14,15,15,11,12,12,
	14,14,12,13,13,14,15,12,13,13,14,14,14,14,15,15,
	16,14,14,14,16,16,11,12,12,14,14,12,13,13,14,15,
	11,13,12,14,14,13,14,14,16,16,13,14,14,16,15,13,
	14,14,15,15,14,14,15,15,16,14,15,14,16,16,15,15,
	16,16,17,15,16,16,17,17,12,13,13,15,15,13,14,14,
	16,15,12,14,13,16,15,15,16,15,17,17,14,15,15,17,
	15,10,12,12,14,14,12,12,13,14,15,12,13,12,14,14,
	14,14,15,15,16,13,14,14,16,16,12,13,13,14,14,13,
	13,14,14,15,13,14,13,15,15,14,15,15,15,17,14,15,
	15,16,16,11,12,12,14,14,13,13,14,15,15,12,13,13,
	15,14,14,15,15,16,17,14,15,14,16,15,14,14,14,16,
	16,14,15,15,16,16,15,15,15,16,16,15,16,16,16,18,
	16,17,16,18,17,13,13,14,15,15,14,14,15,16,16,13,
	14,14,16,15,16,16,17,17,17,15,15,15,17,15,10,12,
	12,14,13,12,12,13,14,14,11,13,12,14,14,13,14,14,
	16,16,13,14,14,16,15,12,12,13,14,14,12,13,13,14,
	15,13,13,13,15,15,14,14,15,16,16,14,15,15,16,16,
	11,12,12,14,14,12,13,13,15,15,12,13,12,15,14,14,
	15,14,16,16,13,15,13,16,15,13,14,14,15,16,14,15,
	15,15,17,14,15,15,16,16,16,15,16,16,17,16,16,16,
	17,17,13,14,12,16,13,14,15,13,16,15,13,15,13,16,
	14,15,16,15,17,16,15,16,14,17,15,11,12,12,14,15,
	13,13,14,14,16,13,14,13,15,14,15,15,16,16,17,15,
	15,15,16,16,12,13,13,15,15,13,13,14,15,16,14,15,
	14,16,15,15,15,16,15,17,16,16,16,17,17,12,13,13,
	14,15,14,14,15,15,16,13,14,13,15,15,16,16,16,17,
	17,15,16,15,16,15,15,15,15,16,16,14,15,15,16,17,
	16,16,16,17,17,16,15,17,15,18,17,18,17,18,18,14,
	14,15,15,17,15,15,16,16,17,14,15,15,16,16,17,17,
	17,17,18,16,16,15,17,15,11,12,12,14,14,12,13,13,
	15,15,12,13,13,15,15,14,15,15,16,16,14,15,14,17,
	16,13,13,13,15,15,13,14,14,15,16,13,14,14,16,16,
	15,15,16,16,17,15,16,16,17,17,12,13,13,15,14,13,
	14,14,16,15,13,14,13,16,14,15,16,16,17,16,15,16,
	14,17,15,14,15,15,16,17,15,15,16,16,17,15,16,16,
	17,17,16,15,17,16,18,16,17,17,18,18,14,15,14,16,
	13,15,16,15,17,14,15,16,14,17,14,16,17,16,18,16,
	16,17,15,18,15,
};

static const static_codebook _44p9_p5_0 = {
	5, 3125,
	(long *)_vq_lengthlist__44p9_p5_0,
	1, -528744448, 1616642048, 3, 0,
	(long *)_vq_quantlist__44p9_p5_0,
	0
};

static const long _vq_quantlist__44p9_p5_1[] = {
	3,
	2,
	4,
	1,
	5,
	0,
	6,
};

static const long _vq_lengthlist__44p9_p5_1[] = {
	 2, 3, 3, 3, 3, 3, 3,
};

static const static_codebook _44p9_p5_1 = {
	1, 7,
	(long *)_vq_lengthlist__44p9_p5_1,
	1, -533200896, 1611661312, 3, 0,
	(long *)_vq_quantlist__44p9_p5_1,
	0
};

static const long _vq_quantlist__44p9_p6_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p9_p6_0[] = {
	 2, 5, 5, 5, 7, 7, 5, 7, 7, 5, 7, 7, 7, 8, 9, 7,
	 9, 9, 5, 7, 7, 7, 9, 9, 7, 9, 8, 5, 7, 8, 8, 9,
	10, 8, 9,10, 8, 9,10,10,10,12,10,11,11, 8,10,10,
	10,11,12,10,11,10, 5, 8, 7, 8,10,10, 8,10, 9, 8,
	10,10,10,10,11,10,12,11, 8,10, 9,10,11,11,10,12,
	10, 5, 8, 8, 7, 9,10, 8,10, 9, 7, 9,10, 9,10,11,
	 9,11,11, 8,10, 9,10,11,11, 9,11,10, 7, 9, 9, 9,
	10,11, 9,11,11, 9, 9,11,10,10,13,11,12,12, 9,11,
	11,11,12,13,11,13,11, 7, 9, 9, 9,10,11, 9,11,10,
	 9,11,10,10,10,12,11,13,12, 9,11,11,11,12,12,10,
	12,10, 5, 8, 8, 8, 9,10, 7,10, 9, 8, 9,10, 9,10,
	11,10,11,11, 7,10, 9, 9,11,11, 9,11,10, 7, 9, 9,
	 9,10,11, 9,11,10, 9,11,11,10,10,12,11,12,12, 9,
	10,11,11,12,13,10,12,10, 7, 9, 9, 9,11,11, 9,11,
	10, 9,11,11,11,11,13,11,13,12, 9,11, 9,11,12,12,
	10,13,10,
};

static const static_codebook _44p9_p6_0 = {
	5, 243,
	(long *)_vq_lengthlist__44p9_p6_0,
	1, -527106048, 1620377600, 2, 0,
	(long *)_vq_quantlist__44p9_p6_0,
	0
};

static const long _vq_quantlist__44p9_p6_1[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44p9_p6_1[] = {
	 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 8, 8, 7,
	 8, 8, 7, 8, 7, 7, 8, 8, 7, 8, 8, 7, 8, 8, 8, 8,
	 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 8, 8, 9, 8, 8, 8,
	 8, 8, 8, 8, 8, 8, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8,
	 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9,
	 8, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
	 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
	 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 8, 8, 9, 8, 8,
	 8, 8, 9, 9, 8, 9, 9, 7, 8, 8, 8, 8, 8, 8, 8, 8,
	 8, 8, 8, 8, 8, 8, 8, 9, 8, 8, 8, 8, 8, 9, 9, 8,
	 9, 8, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
	 9, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 7, 8, 8,
	 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 8, 9, 9, 8,
	 8, 8, 8, 8, 9, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
	 8, 8, 8, 8, 8, 9, 9, 8, 9, 9, 8, 8, 8, 8, 9, 8,
	 8, 9, 8,
};

static const static_codebook _44p9_p6_1 = {
	5, 243,
	(long *)_vq_lengthlist__44p9_p6_1,
	1, -530841600, 1616642048, 2, 0,
	(long *)_vq_quantlist__44p9_p6_1,
	0
};

static const long _vq_quantlist__44p9_p7_0[] = {
	2,
	1,
	3,
	0,
	4,
};

static const long _vq_lengthlist__44p9_p7_0[] = {
	 1,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,
};

static const static_codebook _44p9_p7_0 = {
	5, 3125,
	(long *)_vq_lengthlist__44p9_p7_0,
	1, -510105088, 1635281408, 3, 0,
	(long *)_vq_quantlist__44p9_p7_0,
	0
};

static const long _vq_quantlist__44p9_p7_1[] = {
	2,
	1,
	3,
	0,
	4,
};

static const long _vq_lengthlist__44p9_p7_1[] = {
	 1, 4, 4,16,16, 4, 9,11,15,16, 4,12, 8,16,16,12,
	16,16,16,16,13,16,16,16,16, 5, 8,10,16,16, 9, 9,
	14,15,16,12,14,14,16,16,16,16,16,16,16,16,16,16,
	16,16, 5,11, 8,16,15,12,14,16,16,16, 9,15, 9,16,
	16,16,16,16,16,16,16,16,16,16,16,15,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16, 6,11,11,
	16,16,12,13,16,16,16,12,16,14,16,16,16,16,16,16,
	16,16,16,16,16,16,11,15,15,16,16,14,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,12,
	15,16,16,16,16,16,16,16,16,14,16,15,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16, 5,11,11,16,16,12,
	15,16,16,16,12,16,14,16,16,16,16,16,16,16,16,16,
	16,16,16,12,15,15,16,16,14,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,11,15,15,16,
	16,16,16,16,16,16,15,16,14,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16, 6,11,12,16,16,11,15,16,16,16,13,16,14,16,16,
	16,16,16,16,16,16,16,16,16,16,11,16,14,16,16,14,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,12,14,14,16,16,16,16,16,16,16,15,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,15,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16, 8,13,
	15,16,16,15,15,16,16,16,14,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,14,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	15,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16, 7,12,12,16,16,
	13,12,16,16,16,14,16,14,16,16,16,16,16,16,16,16,
	16,16,16,16,13,16,16,16,16,14,14,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,12,14,16,
	16,16,16,16,16,16,16,14,16,14,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16, 6,11,11,16,16,13,15,16,16,16,11,15,14,16,
	16,16,16,16,16,16,14,16,16,16,16,11,16,16,16,16,
	16,16,16,16,16,15,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,11,16,14,16,16,14,16,16,16,16,13,15,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16, 7,
	11,11,16,16,13,13,16,16,16,13,16,13,16,16,16,16,
	16,16,16,16,16,16,16,16,12,16,15,16,16,14,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,12,14,16,16,16,16,16,16,16,16,14,16,13,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16, 8,13,14,16,
	16,15,16,16,16,16,14,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,15,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,15,16,
	15,16,16,16,16,16,16,16,16,16,15,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,15,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,15,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,
};

static const static_codebook _44p9_p7_1 = {
	5, 3125,
	(long *)_vq_lengthlist__44p9_p7_1,
	1, -514619392, 1630767104, 3, 0,
	(long *)_vq_quantlist__44p9_p7_1,
	0
};

static const long _vq_quantlist__44p9_p7_2[] = {
	12,
	11,
	13,
	10,
	14,
	9,
	15,
	8,
	16,
	7,
	17,
	6,
	18,
	5,
	19,
	4,
	20,
	3,
	21,
	2,
	22,
	1,
	23,
	0,
	24,
};

static const long _vq_lengthlist__44p9_p7_2[] = {
	 1, 3, 2, 5, 4, 7, 7, 8, 8, 9,10,10,10,11,11,11,
	12,12,12,13,13,13,13,13,13,
};

static const static_codebook _44p9_p7_2 = {
	1, 25,
	(long *)_vq_lengthlist__44p9_p7_2,
	1, -518864896, 1620639744, 5, 0,
	(long *)_vq_quantlist__44p9_p7_2,
	0
};

static const long _vq_quantlist__44p9_p7_3[] = {
	12,
	11,
	13,
	10,
	14,
	9,
	15,
	8,
	16,
	7,
	17,
	6,
	18,
	5,
	19,
	4,
	20,
	3,
	21,
	2,
	22,
	1,
	23,
	0,
	24,
};

static const long _vq_lengthlist__44p9_p7_3[] = {
	 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5,
	 5, 5, 5, 5, 5, 5, 5, 5, 5,
};

static const static_codebook _44p9_p7_3 = {
	1, 25,
	(long *)_vq_lengthlist__44p9_p7_3,
	1, -529006592, 1611661312, 5, 0,
	(long *)_vq_quantlist__44p9_p7_3,
	0
};

static const long _huff_lengthlist__44p9_short[] = {
	 3, 3, 3, 3, 3, 3, 3, 3,
};

static const static_codebook _huff_book__44p9_short = {
	1, 8,
	(long *)_huff_lengthlist__44p9_short,
	0, 0, 0, 0, 0,
	NULL,
	0
};

static const long _vq_quantlist__44pn1_l0_0[] = {
	6,
	5,
	7,
	4,
	8,
	3,
	9,
	2,
	10,
	1,
	11,
	0,
	12,
};

static const long _vq_lengthlist__44pn1_l0_0[] = {
	 1, 3, 3, 8, 8,10,10,10,10,10,10,10,10, 5, 7, 5,
	 9, 8,10,10,10,10,11,10,11,10, 5, 5, 7, 8, 9,10,
	10,11,10,10,11,10,11,10,10,10,11,11,11,11,11,11,
	11,10,11,11,10,10,10,10,11,11,11,11,11,10,11,11,
	11,11,11,11,11,11,12,11,10,11,11,11,11,11,11,11,
	11,11,11,11,11,10,10,11,11,12,11,11,11,11,11,11,
	12,11,11,11,10,11,11,11,11,11,11,11,11,10,11,11,
	10,11,10,11,11,11,11,11,11,11,11,11,11,12,11,11,
	12,12,11,11,11,11,11,11,11,11,11,11,11,11,12,11,
	10,11,11,11,11,11,11,11,12,11,13,11,11,11,11,11,
	11,11,11,11,11,11,12,11,13,
};

static const static_codebook _44pn1_l0_0 = {
	2, 169,
	(long *)_vq_lengthlist__44pn1_l0_0,
	1, -526516224, 1616117760, 4, 0,
	(long *)_vq_quantlist__44pn1_l0_0,
	0
};

static const long _vq_quantlist__44pn1_l0_1[] = {
	2,
	1,
	3,
	0,
	4,
};

static const long _vq_lengthlist__44pn1_l0_1[] = {
	 1, 4, 4, 7, 7, 4, 5, 6, 7, 7, 4, 6, 5, 7, 7, 7,
	 6, 7, 6, 7, 7, 7, 6, 7, 6,
};

static const static_codebook _44pn1_l0_1 = {
	2, 25,
	(long *)_vq_lengthlist__44pn1_l0_1,
	1, -533725184, 1611661312, 3, 0,
	(long *)_vq_quantlist__44pn1_l0_1,
	0
};

static const long _vq_quantlist__44pn1_l1_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44pn1_l1_0[] = {
	 1, 4, 4, 4, 4, 4, 4, 4, 4,
};

static const static_codebook _44pn1_l1_0 = {
	2, 9,
	(long *)_vq_lengthlist__44pn1_l1_0,
	1, -516716544, 1630767104, 2, 0,
	(long *)_vq_quantlist__44pn1_l1_0,
	0
};

static const long _huff_lengthlist__44pn1_lfe[] = {
	 1, 3, 2, 3,
};

static const static_codebook _huff_book__44pn1_lfe = {
	2, 4,
	(long *)_huff_lengthlist__44pn1_lfe,
	0, 0, 0, 0, 0,
	NULL,
	0
};

static const long _huff_lengthlist__44pn1_long[] = {
	 2, 3, 6, 7, 9,13,17, 3, 2, 5, 7, 9,13,17, 6, 5,
	 5, 6, 9,12,16, 7, 7, 6, 6, 7,10,13,10,10, 9, 7,
	 6,10,13,13,13,12,10,10,11,15,17,17,17,14,14,15,
	17,
};

static const static_codebook _huff_book__44pn1_long = {
	2, 49,
	(long *)_huff_lengthlist__44pn1_long,
	0, 0, 0, 0, 0,
	NULL,
	0
};

static const long _vq_quantlist__44pn1_p1_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44pn1_p1_0[] = {
	 1, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0,
};

static const static_codebook _44pn1_p1_0 = {
	5, 243,
	(long *)_vq_lengthlist__44pn1_p1_0,
	1, -535822336, 1611661312, 2, 0,
	(long *)_vq_quantlist__44pn1_p1_0,
	0
};

static const long _vq_quantlist__44pn1_p2_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44pn1_p2_0[] = {
	 1, 5, 5, 0, 7, 7, 0, 8, 8, 0, 9, 9, 0,12,12, 0,
	 8, 8, 0, 9, 9, 0,13,13, 0, 8, 8, 0, 6, 6, 0,11,
	11, 0,12,12, 0,12,12, 0,14,14, 0,11,12, 0,12,12,
	 0,15,15, 0,12,12, 0, 5, 5, 0, 5, 5, 0, 6, 6, 0,
	 7, 7, 0,10,10, 0, 6, 6, 0, 7, 7, 0,11,11, 0, 6,
	 6, 0, 7, 7, 0,11,11, 0,12,11, 0,11,11, 0,14,14,
	 0,10,10, 0,12,12, 0,15,15, 0,12,12, 0, 6, 6, 0,
	12,12, 0,12,12, 0,12,12, 0,14,14, 0,11,11, 0,12,
	12, 0,16,16, 0,12,12, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 8, 8, 0,12,12, 0,12,12, 0,12,12, 0,15,
	15, 0,12,12, 0,11,11, 0,16,16, 0,11,11, 0, 6, 6,
	 0,12,12, 0,12,12, 0,13,13, 0,15,15, 0,12,12, 0,
	13,13, 0,15,15, 0,12,12, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0,
};

static const static_codebook _44pn1_p2_0 = {
	5, 243,
	(long *)_vq_lengthlist__44pn1_p2_0,
	1, -533200896, 1614282752, 2, 0,
	(long *)_vq_quantlist__44pn1_p2_0,
	0
};

static const long _vq_quantlist__44pn1_p2_1[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44pn1_p2_1[] = {
	 1, 3, 3, 0, 9, 9, 0, 9, 9, 0,10,10, 0, 9, 9, 0,
	10,10, 0,10,10, 0,10,10, 0,10,10, 0, 7, 7, 0, 7,
	 7, 0, 6, 6, 0, 8, 8, 0, 7, 7, 0, 8, 8, 0, 8, 8,
	 0, 7, 7, 0, 8, 8, 0, 7, 7, 0, 9, 9, 0, 8, 9, 0,
	10,10, 0, 9, 9, 0,10,10, 0,10,11, 0, 9, 9, 0,10,
	10, 0, 9, 9, 0,11,11, 0,12,12, 0,12,12, 0,11,11,
	 0,12,12, 0,13,13, 0,12,12, 0,13,13, 0, 8, 8, 0,
	12,12, 0,12,12, 0,13,13, 0,13,13, 0,13,13, 0,13,
	13, 0,13,13, 0,13,13, 0, 7, 7, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0, 9, 9, 0,11,11, 0,12,12, 0,13,13, 0,12,
	12, 0,13,13, 0,13,13, 0,12,12, 0,12,12, 0, 9, 9,
	 0,12,12, 0,13,13, 0,14,14, 0,13,13, 0,14,14, 0,
	14,14, 0,13,13, 0,14,14, 0, 7, 7, 0, 0, 0, 0, 0,
	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	 0, 0, 0,
};

static const static_codebook _44pn1_p2_1 = {
	5, 243,
	(long *)_vq_lengthlist__44pn1_p2_1,
	1, -535822336, 1611661312, 2, 0,
	(long *)_vq_quantlist__44pn1_p2_1,
	0
};

static const long _vq_quantlist__44pn1_p3_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44pn1_p3_0[] = {
	 1, 6, 6, 6, 8, 8, 6, 8, 8, 7, 9, 9,10,11,11, 8,
	 8, 8, 7, 9, 9,11,12,12, 9, 9, 9, 6, 7, 7,10,11,
	11,10,11,11,10,11,11,13,13,13,12,12,12,10,12,11,
	14,14,14,12,12,12, 6, 5, 5, 9, 6, 6, 9, 6, 6, 9,
	 7, 7,12,10,10,11, 7, 6, 9, 7, 7,13,11,11,12, 7,
	 7, 7, 8, 8,12,10,10,12,10,10,11,10,10,15,13,13,
	13, 9, 9,12,11,11,15,14,14,15,11,11, 8, 7, 7,12,
	11,11,12,11,11,11,11,11,14,13,14,14,12,12,12,11,
	11,16,15,15,14,12,12, 0,10,10, 0,12,12, 0,12,12,
	 0,11,11, 0,14,14, 0,11,11, 0,11,11, 0,15,15, 0,
	11,11, 7, 8, 8,13,11,11,12,10,10,12,11,11,15,13,
	13,14,11,11,12,10,10,16,14,14,15,10,10, 9, 7, 7,
	13,11,12,13,12,11,12,11,11,15,14,14,14,12,12,13,
	12,12,16,15,15,15,12,12, 0,11,11, 0,12,12, 0,12,
	13, 0,12,12, 0,15,15, 0,12,12, 0,12,12, 0,16,15,
	 0,12,12,
};

static const static_codebook _44pn1_p3_0 = {
	5, 243,
	(long *)_vq_lengthlist__44pn1_p3_0,
	1, -531365888, 1616117760, 2, 0,
	(long *)_vq_quantlist__44pn1_p3_0,
	0
};

static const long _vq_quantlist__44pn1_p3_1[] = {
	2,
	1,
	3,
	0,
	4,
};

static const long _vq_lengthlist__44pn1_p3_1[] = {
	 2, 3, 4, 9, 9,10,12,12,12,11,10,12,12,13,12,11,
	13,12,11,11,11,12,12,12,11,11,13,13,13,13,11,12,
	12,14,14,12,13,13,13,13,11,13,13,13,13,11,13,13,
	13,13,11,13,13,13,13,11,12,12,14,14,12,13,13,12,
	12,11,13,13,13,13,11,13,13,12,12,11,13,13,13,13,
	12,12,13,14,14,12,13,13,12,12,11,13,13,13,13,11,
	13,13,12,12,11,13,13,13,13,12,13,13,14,14,12,13,
	13,12,12,11,13,13,13,13,11,13,13,12,12,11,10,10,
	10,10,12,10,10,11,11,12, 9, 9,11,11,13,11,11,10,
	10,13,10,10,10,10,13,11,11,12,12,13,10,10,12,12,
	14,12,11,12,12,13,11,11,11,12,13,12,12,12,12,13,
	11,11,12,12,13,10,10,12,12,14,11,11,12,12,13,11,
	11,12,12,13,11,11,12,12,14,12,12,12,12,14,10,10,
	11,11,14,12,11,11,11,13,11,11,11,11,13,12,12,11,
	11,14,12,12,12,11,14,10,10,11,11,14,12,11,11,11,
	13,11,11,11,11,13,12,12,11,11,11,11,11,10,10,12,
	10,11, 9, 9,12,12,12,11,11,13,12,12, 9, 9,13,13,
	13,10,10,13,13,13,12,12,13,13,13,14,14,13,12,12,
	11,11,14,13,13,12,12,14,13,13,11,11,13,13,13,12,
	11,13,13,13,14,14,13,12,12,10,10,14,13,13,11,11,
	13,13,13,10,10,13,13,13,11,11,14,13,13,14,14,14,
	12,12,10,10,13,13,13,11,11,13,13,13,10,10,13,13,
	13,11,11,14,13,13,14,14,14,13,13,10,10,13,13,13,
	11,11,13,13,13,10,10,14,12,12, 8, 8,14,12,12, 9,
	 9,14,11,11, 9, 9,14,12,12, 8, 8,14,12,12, 7, 7,
	15,13,13,10,10,15,12,12,10,10,15,13,13,10,10,15,
	12,13, 9, 9,15,13,13,10,10,15,13,13,10,10,15,12,
	12,10,10,15,13,13,10,10,15,13,13, 9, 9,15,13,13,
	10,10,15,13,13,10,10,15,12,12,10,10,15,13,13, 9,
	 9,14,13,12, 9, 9,14,13,13, 9, 9,15,13,13,10,10,
	15,12,12,10,10,15,13,13, 9, 9,15,13,13, 9, 9,14,
	13,13, 9, 9,14,12,12, 8, 8,13,13,13, 8, 8,14,14,
	13, 9, 9,14,14,13, 7, 7,14,14,14, 8, 8,14,14,14,
	10,10,15,14,14,12,12,14,14,14, 9, 9,15,14,14,10,
	10,14,14,14, 9, 9,14,14,14,10, 9,15,14,14,12,12,
	14,14,14, 9, 9,15,14,14,10,10,14,14,14, 9, 9,15,
	14,15, 9, 9,15,14,14,11,11,14,14,14, 8, 8,14,14,
	14, 9, 9,14,14,14, 8, 8,14,15,14,10,10,15,14,14,
	11,11,14,14,14, 8, 8,15,14,14, 9, 9,14,14,14, 8,
	 8,12,12,12,13,13,16,16,15,12,12,17,16,16,13,13,
	17,16,16,11,11,17,16,16,12,12,17,16,17,13,13,17,
	16,16,14,14,17,17,16,12,12,18,16,16,13,13,17,16,
	17,12,12,17,17,17,13,13,18,16,16,14,14,18,17,17,
	12,12,17,17,17,13,13,18,17,17,13,13,17,17,17,13,
	13,17,16,16,14,14,17,17,17,12,12,16,16,17,13,13,
	17,17,16,12,12,18,17,17,13,13,18,16,16,14,14,18,
	17,17,12,12,19,16,17,13,13,17,16,17,12,12,13,14,
	14,10,10,16,14,14,13,13,17,15,15,14,14,17,14,14,
	13,13,16,14,14,13,13,17,16,15,14,14,16,16,16,15,
	15,17,15,15,14,14,17,15,15,14,14,17,15,15,14,14,
	17,16,15,14,14,16,16,16,15,15,18,15,15,13,13,16,
	16,15,14,14,17,15,15,14,13,17,15,15,14,14,16,16,
	16,15,15,18,15,14,13,13,17,15,15,14,14,18,14,15,
	13,13,18,15,15,14,14,16,16,16,15,15,17,15,15,13,
	13,17,15,15,14,14,17,15,15,13,13,13,11,11,10,10,
	16,14,14,13,13,17,14,15,14,14,17,15,15,12,12,17,
	14,14,12,12,16,15,15,14,14,16,14,14,14,14,16,15,
	15,14,14,16,15,15,14,14,16,15,15,14,14,16,15,15,
	14,14,16,15,14,15,15,17,15,15,14,14,17,15,15,14,
	14,17,15,15,14,14,17,15,16,14,14,16,14,14,14,14,
	17,15,15,13,13,17,15,15,13,13,16,15,15,13,13,17,
	16,16,14,14,17,15,14,15,14,17,15,15,13,13,17,15,
	15,13,13,17,15,15,13,13,14,14,14, 9, 9,14,14,14,
	18,19,14,15,15,19,18,14,14,14,19,19,15,14,14,19,
	19,15,16,16,19,19,15,16,16,19,19,15,15,15,19,19,
	15,16,16,19,20,15,15,15,19,19,15,15,15,19,19,15,
	16,16,20,20,15,15,15,18,19,15,15,16,19,20,15,15,
	15,19,18,15,15,15,18,18,15,16,16,21,20,15,15,15,
	19,19,15,15,15,19,19,15,15,14,19,20,15,15,15,20,
	19,15,16,16,19,20,15,15,15,19,19,15,15,15,20,21,
	15,14,15,19,19,14,12,12, 9, 9,14,14,15,21,19,14,
	14,14,18,19,14,15,15,19,20,14,14,14,19,19,15,15,
	15,19,20,15,15,14,21,19,15,15,15,20,19,15,14,15,
	20,21,15,15,15,18,18,15,15,15,20,21,16,14,14,18,
	19,15,15,15,20,19,15,15,15,18,21,15,15,15,19,19,
	15,15,15,19,20,16,15,14,20,19,15,16,15,19,19,15,
	15,15,19, 0,14,15,15,19,19,15,15,15,19,19,15,15,
	14,20,19,15,15,15,20,19,15,15,15,19,19,15,15,15,
	20,19,12,12,12,13,13,16,15,16,11,11,16,16,16,12,
	12,17,16,16,11,11,17,16,16,12,11,17,17,17,13,13,
	18,16,16,14,14,18,18,17,13,13,17,16,16,13,13,17,
	17,17,13,13,17,16,17,12,12,17,15,16,13,13,17,16,
	17,12,12,17,16,16,13,12,17,16,16,12,12,18,17,17,
	13,13,18,16,16,13,14,18,17,17,12,12,17,16,16,12,
	12,17,17,17,12,12,18,17,17,13,13,17,16,16,14,14,
	17,17,17,12,12,17,16,16,12,12,18,17,17,12,12,13,
	14,14, 9, 9,16,14,14,13,13,16,15,15,14,14,16,14,
	14,13,13,16,14,14,13,13,17,16,15,15,15,16,15,16,
	16,15,17,15,15,14,14,17,15,15,15,15,17,15,15,14,
	14,17,15,15,14,14,16,15,16,16,16,17,15,15,14,14,
	16,15,15,14,15,16,15,15,14,14,17,15,15,15,15,16,
	16,16,15,16,18,15,14,13,14,17,15,15,14,14,17,14,
	14,13,13,17,15,15,14,14,16,15,15,15,15,17,15,14,
	14,14,17,15,15,14,14,17,14,14,13,13,13,11,11,11,
	11,16,14,14,12,12,16,14,14,13,13,16,14,14,12,12,
	16,14,14,12,12,16,15,15,13,13,17,14,14,14,14,17,
	15,15,13,13,16,15,15,14,13,16,15,15,13,13,16,15,
	15,13,13,16,14,14,14,14,16,15,15,13,13,16,14,15,
	13,13,17,15,15,13,13,17,15,15,13,13,16,14,14,14,
	14,17,15,15,12,12,17,14,15,13,13,17,15,15,12,12,
	16,15,15,13,13,17,14,14,14,14,17,15,15,12,12,17,
	15,15,13,13,16,15,15,12,12,14,15,15, 8, 8,14,14,
	14,19,18,14,15,15,19,20,14,14,14,19,19,14,14,15,
	19,20,15,16,15,19,21,15,16,16,21,19,15,15,15,20,
	19,15,16,16,19,20,15,15,15,19,18,15,16,15,20,19,
	15,16,16,19,20,15,15,15,19,19,15,16,15,20,20,14,
	15,15,19,19,15,15,15,21,19,15,17,16,19,20,15,14,
	15, 0,21,15,15,15,19,20,14,14,14,19,19,15,15,15,
	20,19,15,16,16,19,19,15,15,15,19,18,15,15,15,20,
	19,14,14,15,18,18,14,12,12, 9, 9,14,14,14,18,18,
	14,14,14,18,18,14,15,14,19,18,14,14,14,19,18,15,
	15,15,19,20,15,14,14,18,18,15,15,15,20,19,15,15,
	15,18,20,15,15,15,19,18,15,15,15,19,19,15,14,14,
	19,21,15,15,15,20,20,15,15,15,18,19,14,15,15,19,
	20,15,15,15,20,19,15,14,14,19,21,15,15,15,18,19,
	15,14,15,20,19,14,15,15,21,21,14,15,15,19,20,15,
	14,14,19,20,15,15,15,19,20,15,15,14,20,20,14,15,
	15,20,19,13,12,12,13,13,17,16,16,11,11,17,16,16,
	12,12,18,17,16,11,11,18,16,16,11,11,17,17,17,13,
	13,18,16,16,13,13,18,17,17,12,12,18,16,16,13,13,
	18,17,17,12,12,18,17,17,13,13,18,16,16,14,14,18,
	16,17,12,12,18,17,17,13,13,17,17,17,12,12,17,17,
	17,12,12,17,16,15,13,13,18,16,16,11,11,17,16,16,
	12,12,17,16,17,11,11,18,17,17,13,12,17,16,16,13,
	13,17,17,17,12,12,17,16,17,12,12,18,17,17,11,11,
	14,14,14, 9, 9,16,14,14,13,13,17,15,15,14,14,17,
	14,14,13,13,16,14,14,13,13,17,15,15,14,14,16,16,
	16,16,15,18,15,15,14,14,17,16,15,15,15,17,15,15,
	14,14,17,15,15,14,15,16,16,16,15,16,18,15,15,14,
	14,17,15,15,14,15,17,15,15,14,14,17,15,15,14,14,
	16,16,16,15,16,17,14,14,13,13,17,15,15,14,14,18,
	15,15,13,13,17,15,15,14,14,16,16,16,15,15,17,14,
	14,13,13,17,15,15,14,14,17,14,14,13,13,13,11,11,
	11,11,16,14,14,12,12,16,14,14,12,13,17,15,14,11,
	11,17,14,14,11,11,17,15,15,13,14,17,14,14,14,14,
	17,15,15,13,13,17,14,14,13,13,17,15,15,13,13,17,
	15,15,13,13,17,14,14,14,14,17,15,15,13,13,18,14,
	15,13,13,17,15,15,13,13,16,15,15,13,13,17,14,14,
	13,13,17,15,15,12,12,16,14,14,12,12,16,15,15,12,
	12,17,16,15,13,13,17,14,14,13,13,17,15,15,12,12,
	16,15,15,12,12,16,15,15,12,12,13,15,15, 8, 8,14,
	14,14,18,19,14,15,15,19,20,14,14,14,18,18,14,15,
	15,18,18,15,16,16,19,19,15,16,17,20,20,15,15,15,
	19,19,15,16,16,18,20,15,15,15,19,19,15,15,16,18,
	18,15,17,16,19,19,15,15,15,18,21,15,16,16,21,20,
	15,15,15,19,21,15,16,15,20,19,15,16,17,20,20,15,
	15,15,19,19,15,16,16,21,20,15,15,15,19,20,15,15,
	15,19,19,15,16,16,20,19,15,15,15,19,19,15,16,15,
	20,21,15,15,15,21,19,14,12,12, 8, 8,14,14,14,20,
	18,14,13,13,19,19,14,14,14,19,18,15,14,14,19,20,
	14,15,15,20,20,15,14,14,21,20,15,15,15,20,20,15,
	15,14,21,19,15,15,15,19,19,15,15,15,19,20,15,14,
	14,20,20,15,15,15,19,20,15,14,14,19,20,15,15,15,
	20,20,15,15,15,20,19,15,14,14,20,21,15,15,15,20,
	21,15,14,14,20, 0,15,16,15,20,21,15,15,15,19,20,
	15,14,14,19,19,15,15,15,19,20,15,15,15,19,19,15,
	15,15,18,20,13,12,12,13,13,18,16,17,12,12,17,16,
	16,12,12,17,17,16,11,11,18,16,16,11,11,17,17,18,
	13,13,18,16,16,14,14,18,17,17,13,13,18,16,16,13,
	13,18,17,17,12,12,17,17,16,13,13,17,16,16,13,14,
	18,17,17,12,12,18,16,16,12,13,17,16,17,12,12,17,
	18,17,13,13,18,16,16,13,13,18,17,17,12,12,17,16,
	16,12,12,17,17,17,11,11,17,16,17,12,12,17,16,16,
	13,13,17,16,16,11,11,17,16,16,12,12,18,16,17,11,
	11,14,14,14, 9, 9,16,14,15,13,13,17,15,15,14,14,
	17,14,14,12,12,16,14,14,13,13,18,15,15,15,15,17,
	15,16,15,16,18,15,15,14,14,17,15,16,15,15,17,15,
	15,14,14,18,15,15,14,14,16,16,16,16,15,17,15,15,
	14,14,16,15,15,14,14,17,15,15,14,14,17,15,15,14,
	14,17,16,16,15,15,17,15,14,13,13,17,15,15,14,14,
	17,15,15,13,13,17,15,15,14,14,16,16,16,15,15,18,
	15,14,14,14,17,15,15,14,14,18,15,15,13,13,13,12,
	12,11,11,16,14,14,12,12,16,14,14,13,13,17,15,15,
	12,12,17,14,14,12,12,17,15,15,14,14,17,14,14,14,
	14,17,15,15,13,13,17,15,14,13,13,17,15,15,13,13,
	17,15,15,13,13,16,14,14,14,14,17,15,15,13,13,16,
	14,14,13,13,16,15,15,13,13,17,15,16,13,13,17,14,
	14,14,13,17,15,15,12,12,16,15,14,12,12,17,15,15,
	12,12,16,15,16,13,13,16,14,14,14,13,17,15,15,12,
	12,16,14,14,12,12,17,15,15,12,12,14,15,15, 8, 8,
	14,14,14,18,18,14,15,15,19,18,14,14,14,18,18,14,
	15,15,19,20,15,16,15,21,18,15,16,16,18, 0,15,15,
	15,19,20,15,16,16,20, 0,15,16,15,19,18,15,15,15,
	19,19,15,16,16,21,19,15,15,15,19,19,15,16,16,20,
	20,15,15,15,19,19,15,15,15,19,18,15,16,16,20,20,
	15,14,15,20,19,15,15,15,19,20,15,15,15,19,19,15,
	16,15,19,20,15,16,16,19,20,15,15,15,19,19,15,16,
	15,20,20,15,15,15,20,18,13,12,12, 8, 8,14,14,14,
	19,20,14,14,14,19,19,14,15,15,20,20,14,14,14,18,
	19,15,15,15,20, 0,15,14,14,18,20,15,15,15,19,19,
	15,15,15,21,19,15,15,15,19,20,15,15,15,20,21,15,
	14,14,20,19,15,15,15,20,19,15,15,14,21,19,15,15,
	15,19,18,15,15,15,20,19,15,14,14,19,19,15,15,16,
	20,19,15,15,15,20, 0,15,15,15,19,21,15,15,15,22,
	20,15,14,14,22,19,15,15,15,19,20,15,14,14,20,19,
	14,15,15,19,21,
};

static const static_codebook _44pn1_p3_1 = {
	5, 3125,
	(long *)_vq_lengthlist__44pn1_p3_1,
	1, -533725184, 1611661312, 3, 0,
	(long *)_vq_quantlist__44pn1_p3_1,
	0
};

static const long _vq_quantlist__44pn1_p4_0[] = {
	2,
	1,
	3,
	0,
	4,
};

static const long _vq_lengthlist__44pn1_p4_0[] = {
	 1, 7, 7,14,14, 6, 8, 8,15,16, 7, 8, 8,16,15, 0,
	14,14,17,17, 0,14,14,16,16, 7, 9, 9,16,16,10,11,
	11,17,18, 9, 8, 8,16,16, 0,14,14,19,19, 0,14,14,
	17,16, 8, 9, 9,16,16,12,12,12,17,17,10, 9, 9,16,
	16, 0,15,14,18,20, 0,14,14,17,17, 0,15,15,18,17,
	 0,21, 0, 0,21, 0,13,13,17,17, 0,17,17, 0, 0, 0,
	15,15,17,17, 0,15,15,17,18, 0, 0, 0, 0,21, 0,13,
	13,17,17, 0,18,18, 0,21, 0,16,15,17,18, 6, 7, 7,
	14,14, 9,10,10,16,16,11,10,10,15,15, 0,21, 0,20,
	21, 0, 0, 0,18,20,10,10,10,15,16,12,13,13,18,18,
	12,11,11,15,15, 0, 0, 0,20,20, 0, 0,21,19,19,12,
	11,11,15,15,15,14,14,18,18,13,11,11,15,16, 0, 0,
	 0,20,19, 0, 0, 0,20,21, 0, 0,20,19,19, 0, 0, 0,
	 0, 0, 0,20, 0,17,18, 0, 0,21, 0, 0, 0, 0, 0,21,
	 0, 0,21, 0,20,19, 0, 0, 0, 0, 0, 0,21, 0,18,18,
	 0, 0, 0,21, 0, 0, 0, 0, 0,20, 7, 6, 6,13,13, 9,
	 6, 6,12,12, 9, 7, 7,14,14, 0,10,10,12,12, 0,11,
	11,15,15, 9, 7, 7,14,14,12, 9, 9,14,14,10, 7, 7,
	14,13, 0,11,11,16,15, 0,11,11,14,14, 9, 7, 7,14,
	14,13,10,10,14,14,11, 7, 7,14,13, 0,11,11,16,16,
	 0,11,11,14,14, 0,12,12,16,16, 0,19, 0,17,18, 0,
	10,10,14,14, 0,15,14, 0, 0, 0,12,12,14,14, 0,12,
	12,15,15, 0,20, 0,18,19, 0,10,10,14,14, 0,16,15,
	 0,20, 0,13,13,14,14, 0,11,11,13,13, 0,12,13,16,
	16, 0,12,12,16,16, 0,16,16, 0,21, 0,17,18, 0, 0,
	 0,12,12,16,16, 0,15,15,18, 0, 0,12,12,16,16, 0,
	17,16,21,21, 0,16,17, 0, 0, 0,13,13,17,16, 0,16,
	16,20,21, 0,12,12,17,16, 0,17,17, 0,21, 0,17,17,
	21,21, 0,17,18, 0, 0, 0, 0, 0, 0, 0, 0,15,15, 0,
	 0, 0,18,21, 0, 0, 0,18,19, 0, 0, 0,18,17,21,21,
	 0, 0, 0, 0, 0, 0,16,16, 0, 0, 0, 0, 0, 0, 0, 0,
	19,19, 0, 0, 0,11,11,12,12, 0,11,11,10,10, 0,12,
	12,13,13, 0,12,12, 9, 9, 0,14,14,13,13, 0,12,12,
	13,13, 0,14,14,12,13, 0,11,11,12,12, 0,13,13,13,
	13, 0,13,13,13,13, 0,12,12,13,13, 0,14,14,12,12,
	 0,11,11,12,12, 0,14,13,14,14, 0,13,13,13,13, 0,
	15,15,14,15, 0, 0, 0,16,16, 0,12,12,13,13, 0,16,
	17,20,21, 0,14,13,12,12, 0,14,14,14,14, 0,21, 0,
	16,16, 0,12,12,13,13, 0,18,17,21, 0, 0,14,14,13,
	13, 7, 8, 8,17,17,11,10,10,18,18,12,10,10,17,17,
	 0,15,15,20,18, 0,15,15,17,17,11, 9, 9,17,17,14,
	12,12,19,19,13, 9, 9,16,16, 0,15,14, 0,19, 0,14,
	14,16,16,12,10,10,20,18,16,13,13,21,20,14,10,10,
	17,17, 0,15,15,21,20, 0,15,14,17,17, 0,15,15,21,
	21, 0, 0,21, 0, 0, 0,13,13,18,18, 0,19,16, 0, 0,
	 0,15,15,17,16, 0,16,16, 0,21, 0, 0, 0, 0,21, 0,
	13,14,18,17, 0,20,19, 0, 0, 0,15,15,18,18, 8, 7,
	 7,15,15,12,11,11,17,16,13,11,11,16,16, 0, 0, 0,
	21,20, 0, 0, 0, 0,20,11,10,10,17,17,14,13,13,19,
	18,14,11,11,16,16, 0,20, 0,21,19, 0, 0,21, 0,20,
	12,11,11,17,17,16,15,15, 0,19,14,11,11,17,16, 0,
	21, 0, 0,19, 0, 0, 0,21,20, 0, 0,21,20, 0, 0, 0,
	 0, 0, 0, 0, 0, 0,19,21, 0, 0, 0, 0, 0, 0, 0, 0,
	19,20, 0, 0, 0,20,21, 0, 0, 0, 0, 0, 0,20, 0,19,
	21, 0, 0, 0, 0, 0, 0, 0, 0,21,20,11,10, 9,15,15,
	14,11,11,15,15,14,11,11,16,16, 0,14,14,14,14, 0,
	16,15,17,16,13,11,11,16,16,16,13,13,16,16,15,10,
	10,15,15, 0,14,15,17,17, 0,14,14,16,15,13,11,11,
	16,16,17,15,14,16,16,15,10,10,15,15, 0,15,15,17,
	18, 0,15,15,16,16, 0,16,16,17,17, 0,21, 0,21,20,
	 0,13,13,15,15, 0,18,18, 0,21, 0,15,15,15,15, 0,
	16,16,17,17, 0, 0, 0, 0,18, 0,13,13,15,15, 0,19,
	18, 0, 0, 0,15,15,16,16, 0,12,12,15,15, 0,13,13,
	17,17, 0,13,13,17,18, 0,16,17,21, 0, 0,20,18, 0,
	 0, 0,13,13,17,17, 0,15,15, 0,18, 0,12,12,17,18,
	 0,16,16, 0, 0, 0,17,17,21, 0, 0,13,13,18,18, 0,
	16,16,21,21, 0,12,12,17,18, 0,16,17,21, 0, 0,17,
	17, 0,21, 0,17,18, 0, 0, 0, 0, 0, 0, 0, 0,16,15,
	 0,21, 0,21,19, 0, 0, 0,18,18, 0, 0, 0,18,19, 0,
	 0, 0, 0, 0, 0, 0, 0,16,16,21,21, 0,20,19, 0, 0,
	 0,19,21, 0,21, 0,12,12,15,15, 0,12,12,15,16, 0,
	13,13,16,16, 0,14,14,15,15, 0,16,15,17,17, 0,13,
	13,17,17, 0,15,15,16,18, 0,12,12,16,16, 0,14,14,
	17,17, 0,15,14,16,16, 0,13,13,16,16, 0,16,15,17,
	17, 0,12,12,16,16, 0,15,15,18,18, 0,14,14,17,16,
	 0,16,16,17,18, 0, 0, 0,20,21, 0,13,13,16,17, 0,
	17,17, 0, 0, 0,15,15,16,16, 0,15,16,17,17, 0, 0,
	 0,19, 0, 0,13,13,15,16, 0,19,18, 0, 0, 0,16,15,
	16,17, 8, 8, 8,17,17,13,11,10,17,18,13,10,10,17,
	17, 0,15,15,20,19, 0,15,15,17,17,12,10,10,19,18,
	15,12,12,20,18,14,10,10,17,16, 0,15,15,20,20, 0,
	14,15,16,16,13,10,10,17,17,17,14,14, 0,18,15,10,
	10,17,17, 0,16,15,20,20, 0,14,14,17,17, 0,15,16,
	20,20, 0, 0,21, 0, 0, 0,13,13,17,17, 0,18,17, 0,
	 0, 0,15,16,17,18, 0,15,15,18,21, 0, 0, 0,21, 0,
	 0,13,13,18,18, 0,19,19, 0, 0, 0,16,16,18,17, 9,
	 8, 8,15,15,12,11,11,16,16,13,11,11,16,15, 0, 0,
	 0, 0,21, 0,21, 0,19,19,12,11,11,17,18,15,13,13,
	18,19,14,11,11,16,16, 0, 0,21,21,19, 0, 0, 0,21,
	20,13,11,11,18,17,17,14,15,20,21,15,11,12,16,16,
	 0, 0, 0,20, 0, 0, 0,21, 0,19, 0, 0, 0, 0,19, 0,
	 0, 0, 0, 0, 0,21,21,19,19, 0, 0, 0,21, 0, 0, 0,
	 0,19,21, 0, 0, 0,19,20, 0, 0, 0,21, 0, 0, 0,21,
	19,19, 0, 0, 0, 0, 0, 0, 0, 0,21,20, 0,11,11,15,
	15, 0,12,12,15,16, 0,12,12,16,16, 0,15,15,16,15,
	 0,16,16,17,17, 0,12,12,17,17, 0,14,14,17,17, 0,
	11,11,16,16, 0,15,15,19,18, 0,15,15,16,16, 0,12,
	12,17,16, 0,14,15,16,16, 0,11,11,15,15, 0,16,16,
	18,19, 0,15,15,15,16, 0,17,17,18,20, 0,21, 0,21,
	19, 0,14,14,16,16, 0,18,18, 0, 0, 0,16,16,15,15,
	 0,16,16,18,17, 0, 0, 0,19,20, 0,14,14,16,16, 0,
	19,19, 0, 0, 0,16,17,15,15, 0,12,12,14,15, 0,13,
	13,16,17, 0,12,12,17,17, 0,17,16, 0, 0, 0,18,17,
	21, 0, 0,13,13,19,17, 0,15,15,20,21, 0,12,12,17,
	17, 0,17,17, 0, 0, 0,17,17, 0, 0, 0,13,13,17,18,
	 0,16,16,21, 0, 0,12,12,17,17, 0,17,17, 0, 0, 0,
	17,17, 0, 0, 0,18,21, 0, 0, 0, 0, 0, 0, 0, 0,15,
	15,21, 0, 0,20,21, 0, 0, 0,18,19, 0, 0, 0,18,17,
	 0, 0, 0, 0, 0, 0, 0, 0,16,16,21, 0, 0,21,21, 0,
	 0, 0,18,19, 0, 0, 0,12,12,16,16, 0,13,13,16,17,
	 0,13,13,17,16, 0,14,14,16,16, 0,16,15,19,18, 0,
	13,13,17,17, 0,15,15,18,18, 0,12,12,16,16, 0,15,
	15,18,19, 0,15,15,17,16, 0,13,13,17,17, 0,16,16,
	18,17, 0,12,12,17,16, 0,15,15,18,18, 0,15,15,17,
	17, 0,16,16, 0,19, 0, 0, 0, 0, 0, 0,14,14,16,17,
	 0,18,18, 0, 0, 0,15,15,17,17, 0,16,16,21,19, 0,
	21, 0,21,21, 0,13,14,16,16, 0,19,19, 0, 0, 0,15,
	16,16,16, 0,11,11,17,16, 0,15,14,19,18, 0,14,14,
	19,19, 0,18,17,18,20, 0,17,17,18,19, 0,13,13,17,
	17, 0,16,17,21,18, 0,13,13,17,16, 0,18,17,19, 0,
	 0,16,17,18,18, 0,12,12,19,18, 0,18,18,20,20, 0,
	13,13,17,17, 0,17,17,21, 0, 0,16,17,17,18, 0,18,
	17,19,18, 0, 0, 0, 0, 0, 0,14,14,17,17, 0,19,19,
	21, 0, 0,16,16,16,17, 0,17,17,19,20, 0, 0, 0, 0,
	21, 0,15,15,17,18, 0,21,21, 0, 0, 0,17,17,17,18,
	 0,10,10,15,15, 0,15,14,17,18, 0,14,14,16,16, 0,
	 0, 0,18, 0, 0,21, 0,19, 0, 0,13,13,17,16, 0,17,
	17,18, 0, 0,14,14,16,15, 0, 0, 0,21, 0, 0,21, 0,
	19,18, 0,13,13,17,17, 0,18,18,20,20, 0,15,15,16,
	16, 0, 0, 0,21,21, 0, 0, 0,20,20, 0, 0, 0,19, 0,
	 0, 0, 0, 0, 0, 0,21,20,18,18, 0, 0, 0, 0, 0, 0,
	 0, 0, 0,20, 0, 0, 0, 0,20, 0, 0, 0, 0, 0, 0, 0,
	 0,19,18, 0, 0, 0, 0,21, 0, 0, 0,18,20, 0,18,19,
	16,17, 0,21,19,17,17, 0, 0,21,18,18, 0, 0,21,20,
	19, 0, 0, 0,20,20, 0, 0,21,17,17, 0, 0, 0,19,19,
	 0,20,20,17,17, 0, 0, 0, 0,20, 0, 0,20,18,18, 0,
	21,20,17,17, 0, 0, 0,20,21, 0,19, 0,17,17, 0, 0,
	21, 0, 0, 0,20, 0,18,19, 0, 0, 0,21,21, 0, 0, 0,
	 0,21, 0,20,20,17,17, 0, 0, 0, 0, 0, 0,21, 0,18,
	17, 0, 0, 0,20,19, 0, 0, 0, 0,21, 0,20,20,17,17,
	 0, 0, 0, 0, 0, 0,21,21,18,18, 0,12,12,15,14, 0,
	14,14,17,17, 0,14,14,17,16, 0,18,18,21, 0, 0,19,
	20, 0, 0, 0,13,13,18,17, 0,16,16,19,18, 0,13,13,
	17,17, 0,17,17, 0, 0, 0,17,17,21, 0, 0,13,13,17,
	17, 0,17,17,21,20, 0,13,13,18,17, 0,18,19,21,21,
	 0,19,18, 0, 0, 0,18,17, 0, 0, 0, 0, 0, 0, 0, 0,
	15,16, 0, 0, 0,21,21, 0, 0, 0,20,18,21, 0, 0,17,
	18, 0, 0, 0, 0, 0, 0, 0, 0,15,16, 0, 0, 0, 0,20,
	 0, 0, 0, 0,19, 0, 0, 0,15,15,18,19, 0,18,17,21,
	 0, 0,16,18, 0,20, 0,17,18,21, 0, 0,18,20, 0, 0,
	 0,16,16,21,21, 0,19,20,21, 0, 0,16,15, 0,21, 0,
	18,20, 0, 0, 0,18,19, 0, 0, 0,16,15,21,21, 0,21,
	 0, 0, 0, 0,16,15,21, 0, 0,20,19, 0, 0, 0,18,21,
	21, 0, 0,20,18, 0, 0, 0, 0, 0, 0, 0, 0,16,16, 0,
	20, 0,21, 0, 0, 0, 0,17,18,20,21, 0,18,18,21,21,
	 0, 0, 0, 0, 0, 0,16,16,20, 0, 0, 0,21, 0, 0, 0,
	21,18, 0, 0, 0,12,12,20,17, 0,15,15,19,18, 0,14,
	14,19,18, 0,18,17,21,19, 0,17,17,21,17, 0,13,13,
	21,19, 0,16,17,20,19, 0,13,13,16,16, 0,17,17,20,
	21, 0,16,16,19,17, 0,13,13,18,18, 0,17,19,19,19,
	 0,13,13,17,17, 0,18,18, 0,19, 0,16,17,18,18, 0,
	16,17,19,21, 0, 0, 0, 0, 0, 0,15,15,16,17, 0,20,
	19,21, 0, 0,17,17,17,17, 0,17,17,21,19, 0, 0, 0,
	 0, 0, 0,15,15,17,17, 0,21, 0, 0, 0, 0,18,18,17,
	17, 0,10,10,15,15, 0,15,15,17,17, 0,15,14,16,16,
	 0, 0, 0,21,19, 0,21,21,19,21, 0,13,13,17,16, 0,
	17,17,18,19, 0,14,15,16,15, 0, 0, 0,21,19, 0,21,
	21,18,19, 0,14,14,16,17, 0,18,18,18,19, 0,15,15,
	15,16, 0, 0,21, 0,21, 0, 0, 0,19,20, 0, 0, 0,21,
	19, 0, 0, 0, 0, 0, 0,21,21,19,17, 0, 0, 0, 0, 0,
	 0, 0, 0,21,21, 0,21, 0, 0,21, 0, 0, 0, 0, 0, 0,
	21,21,19,18, 0, 0, 0, 0, 0, 0, 0, 0, 0,19, 0,21,
	18,18,17, 0,21, 0,20,20, 0, 0, 0,18,20, 0, 0,21,
	18,21, 0, 0, 0,21,18, 0, 0, 0, 0,19, 0, 0, 0,21,
	21, 0,20,21,17,19, 0,21, 0,21, 0, 0,21, 0,18,18,
	 0,20,21,17,18, 0, 0, 0,21,19, 0,20,21,17,18, 0,
	 0, 0,21,21, 0, 0, 0,20,19, 0, 0, 0,21,21, 0, 0,
	 0, 0, 0, 0,21,21,19,18, 0, 0, 0, 0, 0, 0, 0,21,
	19,18, 0,21,21,19, 0, 0, 0, 0,21, 0, 0,21,21,18,
	17, 0, 0, 0, 0, 0, 0,21, 0,21,18, 0,12,12,14,14,
	 0,15,14,17,17, 0,14,14,17,16, 0,19,17, 0, 0, 0,
	19,19, 0, 0, 0,13,13,17,17, 0,17,17,20,20, 0,13,
	13,18,18, 0,18,17, 0, 0, 0,18,21, 0, 0, 0,13,13,
	17,17, 0,18,18,21,20, 0,14,14,18,19, 0,19,18,21,
	 0, 0,19,19, 0, 0, 0,20,18,20, 0, 0, 0, 0, 0, 0,
	 0,15,16, 0, 0, 0,21,21, 0, 0, 0,19,19, 0, 0, 0,
	18,18, 0, 0, 0, 0, 0, 0, 0, 0,16,16, 0,21, 0, 0,
	 0, 0, 0, 0,19,20, 0, 0, 0,15,15,20,21, 0,17,17,
	21,21, 0,17,17, 0, 0, 0,19,18, 0, 0, 0,18,19, 0,
	 0, 0,17,16, 0,21, 0, 0,20, 0, 0, 0,16,16, 0,20,
	 0,19,19, 0,21, 0,19,18, 0,21, 0,16,16, 0, 0, 0,
	21,21, 0, 0, 0,16,16, 0, 0, 0,21,21, 0, 0, 0,19,
	19, 0, 0, 0,20, 0, 0, 0, 0, 0, 0, 0, 0, 0,17,17,
	 0,21, 0, 0,20, 0, 0, 0,20,18,21,21, 0,19,18, 0,
	20, 0, 0, 0, 0, 0, 0,16,17,21, 0, 0, 0,21, 0, 0,
	 0,19,20,21,20,
};

static const static_codebook _44pn1_p4_0 = {
	5, 3125,
	(long *)_vq_lengthlist__44pn1_p4_0,
	1, -528744448, 1616642048, 3, 0,
	(long *)_vq_quantlist__44pn1_p4_0,
	0
};

static const long _vq_quantlist__44pn1_p4_1[] = {
	3,
	2,
	4,
	1,
	5,
	0,
	6,
};

static const long _vq_lengthlist__44pn1_p4_1[] = {
	 2, 3, 3, 3, 3, 3, 3,
};

static const static_codebook _44pn1_p4_1 = {
	1, 7,
	(long *)_vq_lengthlist__44pn1_p4_1,
	1, -533200896, 1611661312, 3, 0,
	(long *)_vq_quantlist__44pn1_p4_1,
	0
};

static const long _vq_quantlist__44pn1_p5_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44pn1_p5_0[] = {
	 1, 7, 7, 6, 8, 8, 7, 8, 8, 7, 9, 9,11,11,11, 9,
	 8, 8, 7, 9, 9,11,12,11, 9, 9, 9, 6, 7, 7,10,11,
	11,10,10,10,10,11,11,15,14,14,12,12,12,11,11,11,
	14,14,14,12,12,12, 5, 6, 6, 8, 5, 5, 8, 7, 7, 8,
	 8, 8,12,10,10,10, 7, 7, 8, 7, 7,12,10,10,10, 7,
	 7, 6, 7, 7,12,11,11,12,10,10,11,10,10,14,14,13,
	13,10,10,11,10,10,16,14,14,14,11,10, 7, 7, 7,13,
	12,12,12,12,11,11,11,11,15,14,17,13,12,12,12,11,
	11,15,15,15,14,13,13,10, 9, 9,14,12,11,13,11,11,
	12,11,11,16,15,14,14,11,11,12,11,11,17,14,14,15,
	11,11, 7, 8, 8,12,11,11,13,10,10,11,10,10,17,14,
	13,14,10,10,12,10,10,18,15,15,14,10,10, 8, 7, 7,
	13,12,12,13,11,11,12,11,11,16,14,15,14,12,12,12,
	11,11,18,16,16,14,12,12,11,10,10,13,12,11,13,11,
	11,13,12,12, 0,15,14,14,11,11,13,11,11,16,15,15,
	15,11,11,
};

static const static_codebook _44pn1_p5_0 = {
	5, 243,
	(long *)_vq_lengthlist__44pn1_p5_0,
	1, -527106048, 1620377600, 2, 0,
	(long *)_vq_quantlist__44pn1_p5_0,
	0
};

static const long _vq_quantlist__44pn1_p5_1[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44pn1_p5_1[] = {
	 2, 6, 7, 6, 8, 8, 7, 7, 8, 7, 8, 8, 9, 9, 9, 8,
	 7, 7, 8, 8, 8, 9, 9, 9, 9, 8, 8, 6, 6, 6, 9, 7,
	 7, 9, 7, 7, 9, 8, 8,10, 8, 8,10, 8, 8,10, 8, 8,
	10, 9, 8,10, 8, 8, 7, 6, 6, 9, 6, 6, 9, 6, 6, 9,
	 7, 7,10, 8, 8,10, 6, 6, 9, 7, 7,10, 8, 8,10, 6,
	 6, 7, 7, 7,11, 9, 9,11, 9, 9,10, 9, 9,12,10,10,
	12, 8, 8,11, 9, 9,13, 9,10,12, 8, 8, 8, 7, 7,11,
	 9,10,11,10,10,10, 9, 9,11,11,11,11, 9, 9,11,10,
	 9,12,11,11,11, 9,10,10, 8, 8,11, 9,10,11, 9, 9,
	11, 9, 9,12,10,10,11, 9, 9,11, 9, 9,12,10,11,11,
	 9, 9, 8, 8, 8,12, 9, 9,12, 9, 9,11, 9, 9,13, 9,
	 9,13, 8, 8,12, 9, 9,13,10,10,12, 8, 8, 9, 7, 7,
	11,10,10,11,10,10,11,10,10,12,11,11,11,10, 9,11,
	10,10,11,11,11,11, 9, 9,11, 9, 9,12,10,10,11,10,
	10,12,10,10,11,11,11,11, 9, 9,11,10,10,12,11,11,
	11, 9, 9,
};

static const static_codebook _44pn1_p5_1 = {
	5, 243,
	(long *)_vq_lengthlist__44pn1_p5_1,
	1, -530841600, 1616642048, 2, 0,
	(long *)_vq_quantlist__44pn1_p5_1,
	0
};

static const long _vq_quantlist__44pn1_p6_0[] = {
	1,
	0,
	2,
};

static const long _vq_lengthlist__44pn1_p6_0[] = {
	 1, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
	 9, 9, 9,
};

static const static_codebook _44pn1_p6_0 = {
	5, 243,
	(long *)_vq_lengthlist__44pn1_p6_0,
	1, -516716544, 1630767104, 2, 0,
	(long *)_vq_quantlist__44pn1_p6_0,
	0
};

static const long _vq_quantlist__44pn1_p6_1[] = {
	12,
	11,
	13,
	10,
	14,
	9,
	15,
	8,
	16,
	7,
	17,
	6,
	18,
	5,
	19,
	4,
	20,
	3,
	21,
	2,
	22,
	1,
	23,
	0,
	24,
};

static const long _vq_lengthlist__44pn1_p6_1[] = {
	 1, 3, 2, 5, 4, 7, 7, 8, 8, 9, 9,10,10,11,11,12,
	12,13,13,14,14,15,15,15,15,
};

static const static_codebook _44pn1_p6_1 = {
	1, 25,
	(long *)_vq_lengthlist__44pn1_p6_1,
	1, -518864896, 1620639744, 5, 0,
	(long *)_vq_quantlist__44pn1_p6_1,
	0
};

static const long _vq_quantlist__44pn1_p6_2[] = {
	12,
	11,
	13,
	10,
	14,
	9,
	15,
	8,
	16,
	7,
	17,
	6,
	18,
	5,
	19,
	4,
	20,
	3,
	21,
	2,
	22,
	1,
	23,
	0,
	24,
};

static const long _vq_lengthlist__44pn1_p6_2[] = {
	 3, 5, 4, 5, 4, 5, 4, 5, 5, 5, 4, 5, 5, 5, 5, 5,
	 5, 5, 5, 5, 5, 5, 5, 5, 5,
};

static const static_codebook _44pn1_p6_2 = {
	1, 25,
	(long *)_vq_lengthlist__44pn1_p6_2,
	1, -529006592, 1611661312, 5, 0,
	(long *)_vq_quantlist__44pn1_p6_2,
	0
};

static const long _huff_lengthlist__44pn1_short[] = {
	 4, 3, 7, 9,12,16,16, 3, 2, 5, 7,11,14,15, 7, 4,
	 5, 6, 9,12,15, 8, 5, 5, 5, 8,10,14, 9, 7, 6, 6,
	 8,10,12,12,10,10, 7, 6, 8,10,15,12,10, 6, 4, 7,
	 9,
};

static const static_codebook _huff_book__44pn1_short = {
	2, 49,
	(long *)_huff_lengthlist__44pn1_short,
	0, 0, 0, 0, 0,
	NULL,
	0
};

/*** End of inlined file: res_books_51.h ***/

/***** residue backends *********************************************/

static const vorbis_info_residue0 _residue_44p_lo={
  0,-1, -1, 7,-1,-1,
  /* 0   1   2   3   4   5   6   7   8  */
  {0},
  {-1},
  {  0,  1,  2,  7, 17, 31},
  {  0,  0, 99,  7, 17, 31},
};

static const vorbis_info_residue0 _residue_44p={
  0,-1, -1, 8,-1,-1,
  /* 0   1   2   3   4   5   6   7   8  */
  {0},
  {-1},
  {  0,  1,  1,   2,  7, 17, 31},
  {  0,  0, 99,  99,  7, 17, 31},
};

static const vorbis_info_residue0 _residue_44p_hi={
  0,-1, -1, 8,-1,-1,
  /* 0   1   2   3   4   5   6   7   8  */
  {0},
  {-1},
  {  0,  1,  2,  4,  7, 17, 31},
  {  0,  1,  2,  4,  7, 17, 31},
};

static const vorbis_info_residue0 _residue_44p_lfe={
  0,-1, -1, 2,-1,-1,
  /* 0   1   2   3   4   5   6   7   8  */
  {0},
  {-1},
  { 32},
  { -1}
};

static const static_bookblock _resbook_44p_n1={
  {
	{0},
	{0,&_44pn1_p1_0},

	{&_44pn1_p2_0,&_44pn1_p2_1,0},
	{&_44pn1_p3_0,&_44pn1_p3_1,0},
	{&_44pn1_p4_0,&_44pn1_p4_1,0},

	{&_44pn1_p5_0,&_44pn1_p5_1,&_44pn1_p4_1},
	{&_44pn1_p6_0,&_44pn1_p6_1,&_44pn1_p6_2},
   }
};

static const static_bookblock _resbook_44p_0={
  {
	{0},
	{0,&_44p0_p1_0},

	{&_44p0_p2_0,&_44p0_p2_1,0},
	{&_44p0_p3_0,&_44p0_p3_1,0},
	{&_44p0_p4_0,&_44p0_p4_1,0},

	{&_44p0_p5_0,&_44p0_p5_1,&_44p0_p4_1},
	{&_44p0_p6_0,&_44p0_p6_1,&_44p0_p6_2},
   }
};

static const static_bookblock _resbook_44p_1={
  {
	{0},
	{0,&_44p1_p1_0},

	{&_44p1_p2_0,&_44p1_p2_1,0},
	{&_44p1_p3_0,&_44p1_p3_1,0},
	{&_44p1_p4_0,&_44p1_p4_1,0},

	{&_44p1_p5_0,&_44p1_p5_1,&_44p1_p4_1},
	{&_44p1_p6_0,&_44p1_p6_1,&_44p1_p6_2},
   }
};

static const static_bookblock _resbook_44p_2={
  {
	{0},
	{0,0,&_44p2_p1_0},
	{0,&_44p2_p2_0,0},

	{&_44p2_p3_0,&_44p2_p3_1,0},
	{&_44p2_p4_0,&_44p2_p4_1,0},
	{&_44p2_p5_0,&_44p2_p5_1,0},

	{&_44p2_p6_0,&_44p2_p6_1,&_44p2_p5_1},
	{&_44p2_p7_0,&_44p2_p7_1,&_44p2_p7_2,&_44p2_p7_3}
   }
};
static const static_bookblock _resbook_44p_3={
  {
	{0},
	{0,0,&_44p3_p1_0},
	{0,&_44p3_p2_0,0},

	{&_44p3_p3_0,&_44p3_p3_1,0},
	{&_44p3_p4_0,&_44p3_p4_1,0},
	{&_44p3_p5_0,&_44p3_p5_1,0},

	{&_44p3_p6_0,&_44p3_p6_1,&_44p3_p5_1},
	{&_44p3_p7_0,&_44p3_p7_1,&_44p3_p7_2,&_44p3_p7_3}
   }
};
static const static_bookblock _resbook_44p_4={
  {
	{0},
	{0,0,&_44p4_p1_0},
	{0,&_44p4_p2_0,0},

	{&_44p4_p3_0,&_44p4_p3_1,0},
	{&_44p4_p4_0,&_44p4_p4_1,0},
	{&_44p4_p5_0,&_44p4_p5_1,0},

	{&_44p4_p6_0,&_44p4_p6_1,&_44p4_p5_1},
	{&_44p4_p7_0,&_44p4_p7_1,&_44p4_p7_2,&_44p4_p7_3}
   }
};
static const static_bookblock _resbook_44p_5={
  {
	{0},
	{0,0,&_44p5_p1_0},
	{0,&_44p5_p2_0,0},

	{&_44p5_p3_0,&_44p5_p3_1,0},
	{&_44p5_p4_0,&_44p5_p4_1,0},
	{&_44p5_p5_0,&_44p5_p5_1,0},

	{&_44p5_p6_0,&_44p5_p6_1,&_44p5_p5_1},
	{&_44p5_p7_0,&_44p5_p7_1,&_44p5_p7_2,&_44p5_p7_3}
   }
};
static const static_bookblock _resbook_44p_6={
  {
	{0},
	{0,0,&_44p6_p1_0},
	{0,&_44p6_p2_0,0},

	{&_44p6_p3_0,&_44p6_p3_1,0},
	{&_44p6_p4_0,&_44p6_p4_1,0},
	{&_44p6_p5_0,&_44p6_p5_1,0},

	{&_44p6_p6_0,&_44p6_p6_1,&_44p6_p5_1},
	{&_44p6_p7_0,&_44p6_p7_1,&_44p6_p7_2,&_44p6_p7_3}
   }
};
static const static_bookblock _resbook_44p_7={
  {
	{0},
	{0,0,&_44p7_p1_0},
	{0,&_44p7_p2_0,0},

	{&_44p7_p3_0,&_44p7_p3_1,0},
	{&_44p7_p4_0,&_44p7_p4_1,0},
	{&_44p7_p5_0,&_44p7_p5_1,0},

	{&_44p7_p6_0,&_44p7_p6_1,&_44p7_p5_1},
	{&_44p7_p7_0,&_44p7_p7_1,&_44p7_p7_2,&_44p7_p7_3}
   }
};
static const static_bookblock _resbook_44p_8={
  {
	{0},
	{0,0,&_44p8_p1_0},
	{0,&_44p8_p2_0,0},

	{&_44p8_p3_0,&_44p8_p3_1,0},
	{&_44p8_p4_0,&_44p8_p4_1,0},
	{&_44p8_p5_0,&_44p8_p5_1,0},

	{&_44p8_p6_0,&_44p8_p6_1,&_44p8_p5_1},
	{&_44p8_p7_0,&_44p8_p7_1,&_44p8_p7_2,&_44p8_p7_3}
   }
};
static const static_bookblock _resbook_44p_9={
  {
	{0},
	{0,0,&_44p9_p1_0},
	{0,&_44p9_p2_0,0},

	{&_44p9_p3_0,&_44p9_p3_1,0},
	{&_44p9_p4_0,&_44p9_p4_1,0},
	{&_44p9_p5_0,&_44p9_p5_1,0},

	{&_44p9_p6_0,&_44p9_p6_1,&_44p9_p5_1},
	{&_44p9_p7_0,&_44p9_p7_1,&_44p9_p7_2,&_44p9_p7_3}
   }
};

static const static_bookblock _resbook_44p_ln1={
  {
	{&_44pn1_l0_0,&_44pn1_l0_1,0},
	{&_44pn1_l1_0,&_44pn1_p6_1,&_44pn1_p6_2},
   }
};
static const static_bookblock _resbook_44p_l0={
  {
	{&_44p0_l0_0,&_44p0_l0_1,0},
	{&_44p0_l1_0,&_44p0_p6_1,&_44p0_p6_2},
   }
};
static const static_bookblock _resbook_44p_l1={
  {
	{&_44p1_l0_0,&_44p1_l0_1,0},
	{&_44p1_l1_0,&_44p1_p6_1,&_44p1_p6_2},
   }
};
static const static_bookblock _resbook_44p_l2={
  {
	{&_44p2_l0_0,&_44p2_l0_1,0},
	{&_44p2_l1_0,&_44p2_p7_2,&_44p2_p7_3},
   }
};
static const static_bookblock _resbook_44p_l3={
  {
	{&_44p3_l0_0,&_44p3_l0_1,0},
	{&_44p3_l1_0,&_44p3_p7_2,&_44p3_p7_3},
   }
};
static const static_bookblock _resbook_44p_l4={
  {
	{&_44p4_l0_0,&_44p4_l0_1,0},
	{&_44p4_l1_0,&_44p4_p7_2,&_44p4_p7_3},
   }
};
static const static_bookblock _resbook_44p_l5={
  {
	{&_44p5_l0_0,&_44p5_l0_1,0},
	{&_44p5_l1_0,&_44p5_p7_2,&_44p5_p7_3},
   }
};
static const static_bookblock _resbook_44p_l6={
  {
	{&_44p6_l0_0,&_44p6_l0_1,0},
	{&_44p6_l1_0,&_44p6_p7_2,&_44p6_p7_3},
   }
};
static const static_bookblock _resbook_44p_l7={
  {
	{&_44p7_l0_0,&_44p7_l0_1,0},
	{&_44p7_l1_0,&_44p7_p7_2,&_44p7_p7_3},
   }
};
static const static_bookblock _resbook_44p_l8={
  {
	{&_44p8_l0_0,&_44p8_l0_1,0},
	{&_44p8_l1_0,&_44p8_p7_2,&_44p8_p7_3},
   }
};
static const static_bookblock _resbook_44p_l9={
  {
	{&_44p9_l0_0,&_44p9_l0_1,0},
	{&_44p9_l1_0,&_44p9_p7_2,&_44p9_p7_3},
   }
};

static const vorbis_info_mapping0 _map_nominal_51[2]={
  {2, {0,0,0,0,0,1}, {0,2}, {0,2}, 4,{0,3,0,0},{2,4,1,3}},
  {2, {0,0,0,0,0,1}, {1,2}, {1,2}, 4,{0,3,0,0},{2,4,1,3}}
};
static const vorbis_info_mapping0 _map_nominal_51u[2]={
  {2, {0,0,0,0,0,1}, {0,2}, {0,2}, 0,{0},{0}},
  {2, {0,0,0,0,0,1}, {1,2}, {1,2}, 0,{0},{0}}
};

static const vorbis_residue_template _res_44p51_n1[]={
  {2,0,30,  &_residue_44p_lo,
   &_huff_book__44pn1_short,&_huff_book__44pn1_short,
   &_resbook_44p_n1,&_resbook_44p_n1},

  {2,0,30,  &_residue_44p_lo,
   &_huff_book__44pn1_long,&_huff_book__44pn1_long,
   &_resbook_44p_n1,&_resbook_44p_n1},

  {1,2,6,  &_residue_44p_lfe,
   &_huff_book__44pn1_lfe,&_huff_book__44pn1_lfe,
   &_resbook_44p_ln1,&_resbook_44p_ln1}
};
static const vorbis_residue_template _res_44p51_0[]={
  {2,0,15,  &_residue_44p_lo,
   &_huff_book__44p0_short,&_huff_book__44p0_short,
   &_resbook_44p_0,&_resbook_44p_0},

  {2,0,30,  &_residue_44p_lo,
   &_huff_book__44p0_long,&_huff_book__44p0_long,
   &_resbook_44p_0,&_resbook_44p_0},

  {1,2,6,  &_residue_44p_lfe,
   &_huff_book__44p0_lfe,&_huff_book__44p0_lfe,
   &_resbook_44p_l0,&_resbook_44p_l0}
};
static const vorbis_residue_template _res_44p51_1[]={
  {2,0,15,  &_residue_44p_lo,
   &_huff_book__44p1_short,&_huff_book__44p1_short,
   &_resbook_44p_1,&_resbook_44p_1},

  {2,0,30,  &_residue_44p_lo,
   &_huff_book__44p1_long,&_huff_book__44p1_long,
   &_resbook_44p_1,&_resbook_44p_1},

  {1,2,6,  &_residue_44p_lfe,
   &_huff_book__44p1_lfe,&_huff_book__44p1_lfe,
   &_resbook_44p_l1,&_resbook_44p_l1}
};
static const vorbis_residue_template _res_44p51_2[]={
  {2,0,15,  &_residue_44p,
   &_huff_book__44p2_short,&_huff_book__44p2_short,
   &_resbook_44p_2,&_resbook_44p_2},

  {2,0,30,  &_residue_44p,
   &_huff_book__44p2_long,&_huff_book__44p2_long,
   &_resbook_44p_2,&_resbook_44p_2},

  {1,2,6,  &_residue_44p_lfe,
   &_huff_book__44p2_lfe,&_huff_book__44p2_lfe,
   &_resbook_44p_l2,&_resbook_44p_l2}
};
static const vorbis_residue_template _res_44p51_3[]={
  {2,0,15,  &_residue_44p,
   &_huff_book__44p3_short,&_huff_book__44p3_short,
   &_resbook_44p_3,&_resbook_44p_3},

  {2,0,30,  &_residue_44p,
   &_huff_book__44p3_long,&_huff_book__44p3_long,
   &_resbook_44p_3,&_resbook_44p_3},

  {1,2,6,  &_residue_44p_lfe,
   &_huff_book__44p3_lfe,&_huff_book__44p3_lfe,
   &_resbook_44p_l3,&_resbook_44p_l3}
};
static const vorbis_residue_template _res_44p51_4[]={
  {2,0,15,  &_residue_44p,
   &_huff_book__44p4_short,&_huff_book__44p4_short,
   &_resbook_44p_4,&_resbook_44p_4},

  {2,0,30,  &_residue_44p,
   &_huff_book__44p4_long,&_huff_book__44p4_long,
   &_resbook_44p_4,&_resbook_44p_4},

  {1,2,6,  &_residue_44p_lfe,
   &_huff_book__44p4_lfe,&_huff_book__44p4_lfe,
   &_resbook_44p_l4,&_resbook_44p_l4}
};
static const vorbis_residue_template _res_44p51_5[]={
  {2,0,15,  &_residue_44p_hi,
   &_huff_book__44p5_short,&_huff_book__44p5_short,
   &_resbook_44p_5,&_resbook_44p_5},

  {2,0,30,  &_residue_44p_hi,
   &_huff_book__44p5_long,&_huff_book__44p5_long,
   &_resbook_44p_5,&_resbook_44p_5},

  {1,2,6,  &_residue_44p_lfe,
   &_huff_book__44p5_lfe,&_huff_book__44p5_lfe,
   &_resbook_44p_l5,&_resbook_44p_l5}
};
static const vorbis_residue_template _res_44p51_6[]={
  {2,0,15,  &_residue_44p_hi,
   &_huff_book__44p6_short,&_huff_book__44p6_short,
   &_resbook_44p_6,&_resbook_44p_6},

  {2,0,30,  &_residue_44p_hi,
   &_huff_book__44p6_long,&_huff_book__44p6_long,
   &_resbook_44p_6,&_resbook_44p_6},

  {1,2,6,  &_residue_44p_lfe,
   &_huff_book__44p6_lfe,&_huff_book__44p6_lfe,
   &_resbook_44p_l6,&_resbook_44p_l6}
};

static const vorbis_residue_template _res_44p51_7[]={
  {2,0,15,  &_residue_44p_hi,
   &_huff_book__44p7_short,&_huff_book__44p7_short,
   &_resbook_44p_7,&_resbook_44p_7},

  {2,0,30,  &_residue_44p_hi,
   &_huff_book__44p7_long,&_huff_book__44p7_long,
   &_resbook_44p_7,&_resbook_44p_7},

  {1,2,6,  &_residue_44p_lfe,
   &_huff_book__44p6_lfe,&_huff_book__44p6_lfe,
   &_resbook_44p_l6,&_resbook_44p_l6}
};
static const vorbis_residue_template _res_44p51_8[]={
  {2,0,15,  &_residue_44p_hi,
   &_huff_book__44p8_short,&_huff_book__44p8_short,
   &_resbook_44p_8,&_resbook_44p_8},

  {2,0,30,  &_residue_44p_hi,
   &_huff_book__44p8_long,&_huff_book__44p8_long,
   &_resbook_44p_8,&_resbook_44p_8},

  {1,2,6,  &_residue_44p_lfe,
   &_huff_book__44p6_lfe,&_huff_book__44p6_lfe,
   &_resbook_44p_l6,&_resbook_44p_l6}
};
static const vorbis_residue_template _res_44p51_9[]={
  {2,0,15,  &_residue_44p_hi,
   &_huff_book__44p9_short,&_huff_book__44p9_short,
   &_resbook_44p_9,&_resbook_44p_9},

  {2,0,30,  &_residue_44p_hi,
   &_huff_book__44p9_long,&_huff_book__44p9_long,
   &_resbook_44p_9,&_resbook_44p_9},

  {1,2,6,  &_residue_44p_lfe,
   &_huff_book__44p6_lfe,&_huff_book__44p6_lfe,
   &_resbook_44p_l6,&_resbook_44p_l6}
};

static const vorbis_mapping_template _mapres_template_44_51[]={
  { _map_nominal_51, _res_44p51_n1 }, /* -1 */
  { _map_nominal_51, _res_44p51_0 }, /* 0 */
  { _map_nominal_51, _res_44p51_1 }, /* 1 */
  { _map_nominal_51, _res_44p51_2 }, /* 2 */
  { _map_nominal_51, _res_44p51_3 }, /* 3 */
  { _map_nominal_51, _res_44p51_4 }, /* 4 */
  { _map_nominal_51u, _res_44p51_5 }, /* 5 */
  { _map_nominal_51u, _res_44p51_6 }, /* 6 */
  { _map_nominal_51u, _res_44p51_7 }, /* 7 */
  { _map_nominal_51u, _res_44p51_8 }, /* 8 */
  { _map_nominal_51u, _res_44p51_9 }, /* 9 */
};

/*** End of inlined file: residue_44p51.h ***/

static const double rate_mapping_44p51[12]={
  14000.,20000.,28000.,38000.,46000.,54000.,
  75000.,96000.,120000.,140000.,180000.,240001.
};

static const ve_setup_data_template ve_setup_44_51={
  11,
  rate_mapping_44p51,
  quality_mapping_44,
  6,
  40000,
  70000,

  blocksize_short_44,
  blocksize_long_44,

  _psy_tone_masteratt_44,
  _psy_tone_0dB,
  _psy_tone_suppress,

  _vp_tonemask_adj_otherblock,
  _vp_tonemask_adj_longblock,
  _vp_tonemask_adj_otherblock,

  _psy_noiseguards_44,
  _psy_noisebias_impulse,
  _psy_noisebias_padding,
  _psy_noisebias_trans,
  _psy_noisebias_long,
  _psy_noise_suppress,

  _psy_compand_44,
  _psy_compand_short_mapping,
  _psy_compand_long_mapping,

  {_noise_start_short_44,_noise_start_long_44},
  {_noise_part_short_44,_noise_part_long_44},
  _noise_thresh_44,

  _psy_ath_floater,
  _psy_ath_abs,

  _psy_lowpass_44,

  _psy_global_44,
  _global_mapping_44,
  _psy_stereo_modes_44,

  _floor_books,
  _floor,
  3,
  _floor_mapping_44,

  _mapres_template_44_51
};

/*** End of inlined file: setup_44p51.h ***/


/*** Start of inlined file: setup_32.h ***/
static const double rate_mapping_32[12]={
  18000.,28000.,35000.,45000.,56000.,60000.,
  75000.,90000.,100000.,115000.,150000.,190000.,
};

static const double rate_mapping_32_un[12]={
  30000.,42000.,52000.,64000.,72000.,78000.,
  86000.,92000.,110000.,120000.,140000.,190000.,
};

static const double _psy_lowpass_32[12]={
  12.3,13.,13.,14.,15.,99.,99.,99.,99.,99.,99.,99.
};

static const ve_setup_data_template ve_setup_32_stereo={
  11,
  rate_mapping_32,
  quality_mapping_44,
  2,
  26000,
  40000,

  blocksize_short_44,
  blocksize_long_44,

  _psy_tone_masteratt_44,
  _psy_tone_0dB,
  _psy_tone_suppress,

  _vp_tonemask_adj_otherblock,
  _vp_tonemask_adj_longblock,
  _vp_tonemask_adj_otherblock,

  _psy_noiseguards_44,
  _psy_noisebias_impulse,
  _psy_noisebias_padding,
  _psy_noisebias_trans,
  _psy_noisebias_long,
  _psy_noise_suppress,

  _psy_compand_44,
  _psy_compand_short_mapping,
  _psy_compand_long_mapping,

  {_noise_start_short_44,_noise_start_long_44},
  {_noise_part_short_44,_noise_part_long_44},
  _noise_thresh_44,

  _psy_ath_floater,
  _psy_ath_abs,

  _psy_lowpass_32,

  _psy_global_44,
  _global_mapping_44,
  _psy_stereo_modes_44,

  _floor_books,
  _floor,
  2,
  _floor_mapping_44,

  _mapres_template_44_stereo
};

static const ve_setup_data_template ve_setup_32_uncoupled={
  11,
  rate_mapping_32_un,
  quality_mapping_44,
  -1,
  26000,
  40000,

  blocksize_short_44,
  blocksize_long_44,

  _psy_tone_masteratt_44,
  _psy_tone_0dB,
  _psy_tone_suppress,

  _vp_tonemask_adj_otherblock,
  _vp_tonemask_adj_longblock,
  _vp_tonemask_adj_otherblock,

  _psy_noiseguards_44,
  _psy_noisebias_impulse,
  _psy_noisebias_padding,
  _psy_noisebias_trans,
  _psy_noisebias_long,
  _psy_noise_suppress,

  _psy_compand_44,
  _psy_compand_short_mapping,
  _psy_compand_long_mapping,

  {_noise_start_short_44,_noise_start_long_44},
  {_noise_part_short_44,_noise_part_long_44},
  _noise_thresh_44,

  _psy_ath_floater,
  _psy_ath_abs,

  _psy_lowpass_32,

  _psy_global_44,
  _global_mapping_44,
  NULL,

  _floor_books,
  _floor,
  2,
  _floor_mapping_44,

  _mapres_template_44_uncoupled
};

/*** End of inlined file: setup_32.h ***/


/*** Start of inlined file: setup_8.h ***/

/*** Start of inlined file: psych_8.h ***/
static const att3 _psy_tone_masteratt_8[3]={
  {{ 32,  25,  12},  0,   0},  /* 0 */
  {{ 30,  25,  12},  0,   0},  /* 0 */
  {{ 20,   0, -14},  0,   0}, /* 0 */
};

static const vp_adjblock _vp_tonemask_adj_8[3]={
  /* adjust for mode zero */
  /* 63     125     250     500     1     2     4     8    16 */
  {{-15,-15,-15,-15,-10,-10, -6, 0, 0, 0, 0,10, 0, 0,99,99,99}}, /* 1 */
  {{-15,-15,-15,-15,-10,-10, -6, 0, 0, 0, 0,10, 0, 0,99,99,99}}, /* 1 */
  {{-15,-15,-15,-15,-10,-10, -6, 0, 0, 0, 0, 0, 0, 0,99,99,99}}, /* 1 */
};

static const noise3 _psy_noisebias_8[3]={
  /*  63     125     250     500      1k       2k      4k      8k     16k*/
  {{{-10,-10,-10,-10, -5, -5, -5,  0,  4,  8,  8,  8, 10, 10, 99, 99, 99},
	{-10,-10,-10,-10, -5, -5, -5,  0,  0,  4,  4,  4,  4,  4, 99, 99, 99},
	{-30,-30,-30,-30,-30,-24,-20,-14,-10, -6, -8, -8, -6, -6, 99, 99, 99}}},

  {{{-10,-10,-10,-10, -5, -5, -5,  0,  4,  8,  8,  8, 10, 10, 99, 99, 99},
	{-10,-10,-10,-10,-10,-10, -5, -5, -5,  0,  0,  0,  0,  0, 99, 99, 99},
	{-30,-30,-30,-30,-30,-24,-20,-14,-10, -6, -8, -8, -6, -6, 99, 99, 99}}},

  {{{-15,-15,-15,-15,-15,-12,-10, -8,  0,  2,  4,  4,  5,  5, 99, 99, 99},
	{-30,-30,-30,-30,-26,-22,-20,-14,-12,-12,-10,-10,-10,-10, 99, 99, 99},
	{-30,-30,-30,-30,-26,-26,-26,-26,-26,-26,-26,-26,-26,-24, 99, 99, 99}}},
};

/* stereo mode by base quality level */
static const adj_stereo _psy_stereo_modes_8[3]={
  /*  0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  */
  {{  4,  4,  4,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3},
   {  6,  5,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4},
   {  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1},
   { 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99}},
  {{  4,  4,  4,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3},
   {  6,  5,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4},
   {  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1},
   { 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99}},
  {{  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3},
   {  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4},
   {  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1},
   { 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99}},
};

static const noiseguard _psy_noiseguards_8[2]={
  {10,10,-1},
  {10,10,-1},
};

static const compandblock _psy_compand_8[2]={
  {{
	 0, 1, 2, 3, 4, 5, 6,  7,     /* 7dB */
	 8, 8, 9, 9,10,10,11, 11,     /* 15dB */
	12,12,13,13,14,14,15, 15,     /* 23dB */
	16,16,17,17,17,18,18, 19,     /* 31dB */
	19,19,20,21,22,23,24, 25,     /* 39dB */
  }},
  {{
	 0, 1, 2, 3, 4, 5, 6,  6,     /* 7dB */
	 7, 7, 6, 6, 5, 5, 4,  4,     /* 15dB */
	 3, 3, 3, 4, 5, 6, 7,  8,     /* 23dB */
	 9,10,11,12,13,14,15, 16,     /* 31dB */
	17,18,19,20,21,22,23, 24,     /* 39dB */
  }},
};

static const double _psy_lowpass_8[3]={3.,4.,4.};
static const int _noise_start_8[2]={
  64,64,
};
static const int _noise_part_8[2]={
  8,8,
};

static const int _psy_ath_floater_8[3]={
  -100,-100,-105,
};

static const int _psy_ath_abs_8[3]={
  -130,-130,-140,
};

/*** End of inlined file: psych_8.h ***/


/*** Start of inlined file: residue_8.h ***/
/***** residue backends *********************************************/

static const static_bookblock _resbook_8s_0={
  {
	{0},
	{0,0,&_8c0_s_p1_0},
	{0},
	{0,0,&_8c0_s_p3_0},
	{0,0,&_8c0_s_p4_0},
	{0,0,&_8c0_s_p5_0},
	{0,0,&_8c0_s_p6_0},
	{&_8c0_s_p7_0,&_8c0_s_p7_1},
	{&_8c0_s_p8_0,&_8c0_s_p8_1},
	{&_8c0_s_p9_0,&_8c0_s_p9_1,&_8c0_s_p9_2}
   }
};
static const static_bookblock _resbook_8s_1={
  {
	{0},
	{0,0,&_8c1_s_p1_0},
	{0},
	{0,0,&_8c1_s_p3_0},
	{0,0,&_8c1_s_p4_0},
	{0,0,&_8c1_s_p5_0},
	{0,0,&_8c1_s_p6_0},
	{&_8c1_s_p7_0,&_8c1_s_p7_1},
	{&_8c1_s_p8_0,&_8c1_s_p8_1},
	{&_8c1_s_p9_0,&_8c1_s_p9_1,&_8c1_s_p9_2}
   }
};

static const vorbis_residue_template _res_8s_0[]={
  {2,0,32,  &_residue_44_mid,
   &_huff_book__8c0_s_single,&_huff_book__8c0_s_single,
   &_resbook_8s_0,&_resbook_8s_0},
};
static const vorbis_residue_template _res_8s_1[]={
  {2,0,32,  &_residue_44_mid,
   &_huff_book__8c1_s_single,&_huff_book__8c1_s_single,
   &_resbook_8s_1,&_resbook_8s_1},
};

static const vorbis_mapping_template _mapres_template_8_stereo[2]={
  { _map_nominal, _res_8s_0 }, /* 0 */
  { _map_nominal, _res_8s_1 }, /* 1 */
};

static const static_bookblock _resbook_8u_0={
  {
	{0},
	{0,0,&_8u0__p1_0},
	{0,0,&_8u0__p2_0},
	{0,0,&_8u0__p3_0},
	{0,0,&_8u0__p4_0},
	{0,0,&_8u0__p5_0},
	{&_8u0__p6_0,&_8u0__p6_1},
	{&_8u0__p7_0,&_8u0__p7_1,&_8u0__p7_2}
   }
};
static const static_bookblock _resbook_8u_1={
  {
	{0},
	{0,0,&_8u1__p1_0},
	{0,0,&_8u1__p2_0},
	{0,0,&_8u1__p3_0},
	{0,0,&_8u1__p4_0},
	{0,0,&_8u1__p5_0},
	{0,0,&_8u1__p6_0},
	{&_8u1__p7_0,&_8u1__p7_1},
	{&_8u1__p8_0,&_8u1__p8_1},
	{&_8u1__p9_0,&_8u1__p9_1,&_8u1__p9_2}
   }
};

static const vorbis_residue_template _res_8u_0[]={
  {1,0,32,  &_residue_44_low_un,
   &_huff_book__8u0__single,&_huff_book__8u0__single,
   &_resbook_8u_0,&_resbook_8u_0},
};
static const vorbis_residue_template _res_8u_1[]={
  {1,0,32,  &_residue_44_mid_un,
   &_huff_book__8u1__single,&_huff_book__8u1__single,
   &_resbook_8u_1,&_resbook_8u_1},
};

static const vorbis_mapping_template _mapres_template_8_uncoupled[2]={
  { _map_nominal_u, _res_8u_0 }, /* 0 */
  { _map_nominal_u, _res_8u_1 }, /* 1 */
};

/*** End of inlined file: residue_8.h ***/

static const int blocksize_8[2]={
  512,512
};

static const int _floor_mapping_8a[]={
  6,6
};

static const int *_floor_mapping_8[]={
  _floor_mapping_8a
};

static const double rate_mapping_8[3]={
  6000.,9000.,32000.,
};

static const double rate_mapping_8_uncoupled[3]={
  8000.,14000.,42000.,
};

static const double quality_mapping_8[3]={
  -.1,.0,1.
};

static const double _psy_compand_8_mapping[3]={ 0., 1., 1.};

static const double _global_mapping_8[3]={ 1., 2., 3. };

static const ve_setup_data_template ve_setup_8_stereo={
  2,
  rate_mapping_8,
  quality_mapping_8,
  2,
  8000,
  9000,

  blocksize_8,
  blocksize_8,

  _psy_tone_masteratt_8,
  _psy_tone_0dB,
  _psy_tone_suppress,

  _vp_tonemask_adj_8,
  NULL,
  _vp_tonemask_adj_8,

  _psy_noiseguards_8,
  _psy_noisebias_8,
  _psy_noisebias_8,
  NULL,
  NULL,
  _psy_noise_suppress,

  _psy_compand_8,
  _psy_compand_8_mapping,
  NULL,

  {_noise_start_8,_noise_start_8},
  {_noise_part_8,_noise_part_8},
  _noise_thresh_5only,

  _psy_ath_floater_8,
  _psy_ath_abs_8,

  _psy_lowpass_8,

  _psy_global_44,
  _global_mapping_8,
  _psy_stereo_modes_8,

  _floor_books,
  _floor,
  1,
  _floor_mapping_8,

  _mapres_template_8_stereo
};

static const ve_setup_data_template ve_setup_8_uncoupled={
  2,
  rate_mapping_8_uncoupled,
  quality_mapping_8,
  -1,
  8000,
  9000,

  blocksize_8,
  blocksize_8,

  _psy_tone_masteratt_8,
  _psy_tone_0dB,
  _psy_tone_suppress,

  _vp_tonemask_adj_8,
  NULL,
  _vp_tonemask_adj_8,

  _psy_noiseguards_8,
  _psy_noisebias_8,
  _psy_noisebias_8,
  NULL,
  NULL,
  _psy_noise_suppress,

  _psy_compand_8,
  _psy_compand_8_mapping,
  NULL,

  {_noise_start_8,_noise_start_8},
  {_noise_part_8,_noise_part_8},
  _noise_thresh_5only,

  _psy_ath_floater_8,
  _psy_ath_abs_8,

  _psy_lowpass_8,

  _psy_global_44,
  _global_mapping_8,
  _psy_stereo_modes_8,

  _floor_books,
  _floor,
  1,
  _floor_mapping_8,

  _mapres_template_8_uncoupled
};

/*** End of inlined file: setup_8.h ***/


/*** Start of inlined file: setup_11.h ***/

/*** Start of inlined file: psych_11.h ***/
static const double _psy_lowpass_11[3]={4.5,5.5,30.,};

static const att3 _psy_tone_masteratt_11[3]={
  {{ 30,  25,  12},  0,   0},  /* 0 */
  {{ 30,  25,  12},  0,   0},  /* 0 */
  {{ 20,   0, -14},  0,   0}, /* 0 */
};

static const vp_adjblock _vp_tonemask_adj_11[3]={
  /* adjust for mode zero */
  /* 63     125     250     500     1     2     4     8    16 */
  {{-20,-20,-20,-20,-20,-16,-10, 0, 0, 0, 0,10, 2, 0,99,99,99}}, /* 0 */
  {{-20,-20,-20,-20,-20,-16,-10, 0, 0, 0, 0, 5, 0, 0,99,99,99}}, /* 1 */
  {{-20,-20,-20,-20,-20,-16,-10, 0, 0, 0, 0, 0, 0, 0,99,99,99}}, /* 2 */
};

static const noise3 _psy_noisebias_11[3]={
  /*  63     125     250     500      1k       2k      4k      8k     16k*/
  {{{-10,-10,-10,-10, -5, -5, -5,  0,  4, 10, 10, 12, 12, 12, 99, 99, 99},
	{-15,-15,-15,-15,-10,-10, -5,  0,  0,  4,  4,  5,  5, 10, 99, 99, 99},
	{-30,-30,-30,-30,-30,-24,-20,-14,-10, -6, -8, -8, -6, -6, 99, 99, 99}}},

  {{{-10,-10,-10,-10, -5, -5, -5,  0,  4, 10, 10, 12, 12, 12, 99, 99, 99},
	{-15,-15,-15,-15,-10,-10, -5, -5, -5,  0,  0,  0,  0,  0, 99, 99, 99},
	{-30,-30,-30,-30,-30,-24,-20,-14,-10, -6, -8, -8, -6, -6, 99, 99, 99}}},

  {{{-15,-15,-15,-15,-15,-12,-10, -8,  0,  2,  4,  4,  5,  5, 99, 99, 99},
	{-30,-30,-30,-30,-26,-22,-20,-14,-12,-12,-10,-10,-10,-10, 99, 99, 99},
	{-30,-30,-30,-30,-26,-26,-26,-26,-26,-26,-26,-26,-26,-24, 99, 99, 99}}},
};

static const double _noise_thresh_11[3]={ .3,.5,.5 };

/*** End of inlined file: psych_11.h ***/

static const int blocksize_11[2]={
  512,512
};

static const int _floor_mapping_11a[]={
  6,6
};
static const int *_floor_mapping_11[]={
  _floor_mapping_11a
};

static const double rate_mapping_11[3]={
  8000.,13000.,44000.,
};

static const double rate_mapping_11_uncoupled[3]={
  12000.,20000.,50000.,
};

static const double quality_mapping_11[3]={
  -.1,.0,1.
};

static const ve_setup_data_template ve_setup_11_stereo={
  2,
  rate_mapping_11,
  quality_mapping_11,
  2,
  9000,
  15000,

  blocksize_11,
  blocksize_11,

  _psy_tone_masteratt_11,
  _psy_tone_0dB,
  _psy_tone_suppress,

  _vp_tonemask_adj_11,
  NULL,
  _vp_tonemask_adj_11,

  _psy_noiseguards_8,
  _psy_noisebias_11,
  _psy_noisebias_11,
  NULL,
  NULL,
  _psy_noise_suppress,

  _psy_compand_8,
  _psy_compand_8_mapping,
  NULL,

  {_noise_start_8,_noise_start_8},
  {_noise_part_8,_noise_part_8},
  _noise_thresh_11,

  _psy_ath_floater_8,
  _psy_ath_abs_8,

  _psy_lowpass_11,

  _psy_global_44,
  _global_mapping_8,
  _psy_stereo_modes_8,

  _floor_books,
  _floor,
  1,
  _floor_mapping_11,

  _mapres_template_8_stereo
};

static const ve_setup_data_template ve_setup_11_uncoupled={
  2,
  rate_mapping_11_uncoupled,
  quality_mapping_11,
  -1,
  9000,
  15000,

  blocksize_11,
  blocksize_11,

  _psy_tone_masteratt_11,
  _psy_tone_0dB,
  _psy_tone_suppress,

  _vp_tonemask_adj_11,
  NULL,
  _vp_tonemask_adj_11,

  _psy_noiseguards_8,
  _psy_noisebias_11,
  _psy_noisebias_11,
  NULL,
  NULL,
  _psy_noise_suppress,

  _psy_compand_8,
  _psy_compand_8_mapping,
  NULL,

  {_noise_start_8,_noise_start_8},
  {_noise_part_8,_noise_part_8},
  _noise_thresh_11,

  _psy_ath_floater_8,
  _psy_ath_abs_8,

  _psy_lowpass_11,

  _psy_global_44,
  _global_mapping_8,
  _psy_stereo_modes_8,

  _floor_books,
  _floor,
  1,
  _floor_mapping_11,

  _mapres_template_8_uncoupled
};

/*** End of inlined file: setup_11.h ***/


/*** Start of inlined file: setup_16.h ***/

/*** Start of inlined file: psych_16.h ***/
/* stereo mode by base quality level */
static const adj_stereo _psy_stereo_modes_16[4]={
  /*  0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  */
  {{  4,  4,  4,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3},
   {  6,  5,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4},
   {  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  2,  3,  3,  4,  4},
   { 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99}},
  {{  4,  4,  4,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3},
   {  6,  5,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4},
   {  2,  2,  2,  2,  2,  2,  2,  2,  2,  3,  4,  4,  4,  4,  4},
   { 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99}},
  {{  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3},
   {  5,  4,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  3},
   {  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4,  4},
   { 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99}},
  {{  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
   {  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0},
   {  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8},
   { 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99}},
};

static const double _psy_lowpass_16[4]={6.5,8,30.,99.};

static const att3 _psy_tone_masteratt_16[4]={
  {{ 30,  25,  12},  0,   0},  /* 0 */
  {{ 25,  22,  12},  0,   0},  /* 0 */
  {{ 20,  12,   0},  0,   0},  /* 0 */
  {{ 15,   0, -14},  0,   0}, /* 0 */
};

static const vp_adjblock _vp_tonemask_adj_16[4]={
  /* adjust for mode zero */
  /* 63     125     250     500       1     2     4     8    16 */
  {{-20,-20,-20,-20,-20,-16,-10,  0,  0, 0, 0,10, 0, 0, 0, 0, 0}}, /* 0 */
  {{-20,-20,-20,-20,-20,-16,-10,  0,  0, 0, 0,10, 0, 0, 0, 0, 0}}, /* 1 */
  {{-20,-20,-20,-20,-20,-16,-10,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0}}, /* 2 */
  {{-30,-30,-30,-30,-30,-26,-20,-10, -5, 0, 0, 0, 0, 0, 0, 0, 0}}, /* 2 */
};

static const noise3 _psy_noisebias_16_short[4]={
  /*  63     125     250     500      1k       2k      4k      8k     16k*/
  {{{-15,-15,-15,-15,-15,-10,-10,-5,   4, 10, 10, 10, 10, 12, 12, 14, 20},
	{-15,-15,-15,-15,-15,-10,-10, -5,  0,  0,  4,  5,  5,  6,  8,  8, 15},
	{-30,-30,-30,-30,-30,-24,-20,-14,-10, -6, -8, -8, -6, -6, -6, -6, -6}}},

  {{{-15,-15,-15,-15,-15,-10,-10,-5,   4,  6,  6,  6,  6,  8, 10, 12, 20},
	{-15,-15,-15,-15,-15,-15,-15,-10, -5, -5, -5,  4,  5,  6,  8,  8, 15},
	{-30,-30,-30,-30,-30,-24,-20,-14,-10,-10,-10,-10,-10,-10,-10,-10,-10}}},

  {{{-15,-15,-15,-15,-15,-12,-10, -8,  0,  2,  4,  4,  5,  5,  5,  8, 12},
	{-20,-20,-20,-20,-16,-12,-20,-14,-10,-10, -8,  0,  0,  0,  0,  2,  5},
	{-30,-30,-30,-30,-26,-26,-26,-26,-26,-26,-26,-26,-26,-24,-20,-20,-20}}},

  {{{-15,-15,-15,-15,-15,-12,-10, -8, -5, -5, -5, -5, -5,  0,  0,  0,  6},
	{-30,-30,-30,-30,-26,-22,-20,-14,-12,-12,-10,-10,-10,-10,-10,-10, -6},
	{-30,-30,-30,-30,-26,-26,-26,-26,-26,-26,-26,-26,-26,-24,-20,-20,-20}}},
};

static const noise3 _psy_noisebias_16_impulse[4]={
  /*  63     125     250     500      1k       2k      4k      8k     16k*/
  {{{-15,-15,-15,-15,-15,-10,-10,-5,   4, 10, 10, 10, 10, 12, 12, 14, 20},
	{-15,-15,-15,-15,-15,-10,-10, -5,  0,  0,  4,  5,  5,  6,  8,  8, 15},
	{-30,-30,-30,-30,-30,-24,-20,-14,-10, -6, -8, -8, -6, -6, -6, -6, -6}}},

  {{{-15,-15,-15,-15,-15,-10,-10,-5,   4,  4,  4,  4,  5,  5,  6,  8, 15},
	{-15,-15,-15,-15,-15,-15,-15,-10, -5, -5, -5,  0,  0,  0,  0,  4, 10},
	{-30,-30,-30,-30,-30,-24,-20,-14,-10,-10,-10,-10,-10,-10,-10,-10,-10}}},

  {{{-15,-15,-15,-15,-15,-12,-10, -8,  0,  0,  0,  0,  0,  0,  0,  4, 10},
	{-20,-20,-20,-20,-16,-12,-20,-14,-10,-10,-10,-10,-10,-10,-10, -7, -5},
	{-30,-30,-30,-30,-26,-26,-26,-26,-26,-26,-26,-26,-26,-24,-20,-20,-20}}},

  {{{-15,-15,-15,-15,-15,-12,-10, -8, -5, -5, -5, -5, -5,  0,  0,  0,  6},
	{-30,-30,-30,-30,-26,-22,-20,-18,-18,-18,-20,-20,-20,-20,-20,-20,-16},
	{-30,-30,-30,-30,-26,-26,-26,-26,-26,-26,-26,-26,-26,-24,-20,-20,-20}}},
};

static const noise3 _psy_noisebias_16[4]={
  /*  63     125     250     500      1k       2k      4k      8k     16k*/
  {{{-10,-10,-10,-10, -5, -5, -5,  0,  4,  6,  8,  8, 10, 10, 10, 14, 20},
	{-10,-10,-10,-10,-10, -5, -2, -2,  0,  0,  0,  4,  5,  6,  8,  8, 15},
	{-30,-30,-30,-30,-30,-24,-20,-14,-10, -6, -8, -8, -6, -6, -6, -6, -6}}},

  {{{-10,-10,-10,-10, -5, -5, -5,  0,  4,  6,  6,  6,  6,  8, 10, 12, 20},
	{-15,-15,-15,-15,-15,-10, -5, -5,  0,  0,  0,  4,  5,  6,  8,  8, 15},
	{-30,-30,-30,-30,-30,-24,-20,-14,-10, -6, -8, -8, -6, -6, -6, -6, -6}}},

  {{{-15,-15,-15,-15,-15,-12,-10, -8,  0,  2,  4,  4,  5,  5,  5,  8, 12},
	{-20,-20,-20,-20,-16,-12,-20,-10, -5, -5,  0,  0,  0,  0,  0,  2,  5},
	{-30,-30,-30,-30,-26,-26,-26,-26,-26,-26,-26,-26,-26,-24,-20,-20,-20}}},

  {{{-15,-15,-15,-15,-15,-12,-10, -8, -5, -5, -5, -5, -5,  0,  0,  0,  6},
	{-30,-30,-30,-30,-26,-22,-20,-14,-12,-12,-10,-10,-10,-10,-10,-10, -6},
	{-30,-30,-30,-30,-26,-26,-26,-26,-26,-26,-26,-26,-26,-24,-20,-20,-20}}},
};

static const noiseguard _psy_noiseguards_16[4]={
  {10,10,-1},
  {10,10,-1},
  {20,20,-1},
  {20,20,-1},
};

static const double _noise_thresh_16[4]={ .3,.5,.5,.5 };

static const int _noise_start_16[3]={ 256,256,9999 };
static const int _noise_part_16[4]={ 8,8,8,8 };

static const int _psy_ath_floater_16[4]={
  -100,-100,-100,-105,
};

static const int _psy_ath_abs_16[4]={
  -130,-130,-130,-140,
};

/*** End of inlined file: psych_16.h ***/


/*** Start of inlined file: residue_16.h ***/
/***** residue backends *********************************************/

static const static_bookblock _resbook_16s_0={
  {
	{0},
	{0,0,&_16c0_s_p1_0},
	{0},
	{0,0,&_16c0_s_p3_0},
	{0,0,&_16c0_s_p4_0},
	{0,0,&_16c0_s_p5_0},
	{0,0,&_16c0_s_p6_0},
	{&_16c0_s_p7_0,&_16c0_s_p7_1},
	{&_16c0_s_p8_0,&_16c0_s_p8_1},
	{&_16c0_s_p9_0,&_16c0_s_p9_1,&_16c0_s_p9_2}
   }
};
static const static_bookblock _resbook_16s_1={
  {
	{0},
	{0,0,&_16c1_s_p1_0},
	{0},
	{0,0,&_16c1_s_p3_0},
	{0,0,&_16c1_s_p4_0},
	{0,0,&_16c1_s_p5_0},
	{0,0,&_16c1_s_p6_0},
	{&_16c1_s_p7_0,&_16c1_s_p7_1},
	{&_16c1_s_p8_0,&_16c1_s_p8_1},
	{&_16c1_s_p9_0,&_16c1_s_p9_1,&_16c1_s_p9_2}
   }
};
static const static_bookblock _resbook_16s_2={
  {
	{0},
	{0,0,&_16c2_s_p1_0},
	{0,0,&_16c2_s_p2_0},
	{0,0,&_16c2_s_p3_0},
	{0,0,&_16c2_s_p4_0},
	{&_16c2_s_p5_0,&_16c2_s_p5_1},
	{&_16c2_s_p6_0,&_16c2_s_p6_1},
	{&_16c2_s_p7_0,&_16c2_s_p7_1},
	{&_16c2_s_p8_0,&_16c2_s_p8_1},
	{&_16c2_s_p9_0,&_16c2_s_p9_1,&_16c2_s_p9_2}
   }
};

static const vorbis_residue_template _res_16s_0[]={
  {2,0,32,  &_residue_44_mid,
   &_huff_book__16c0_s_single,&_huff_book__16c0_s_single,
   &_resbook_16s_0,&_resbook_16s_0},
};
static const vorbis_residue_template _res_16s_1[]={
  {2,0,32,  &_residue_44_mid,
   &_huff_book__16c1_s_short,&_huff_book__16c1_s_short,
   &_resbook_16s_1,&_resbook_16s_1},

  {2,0,32,  &_residue_44_mid,
   &_huff_book__16c1_s_long,&_huff_book__16c1_s_long,
   &_resbook_16s_1,&_resbook_16s_1}
};
static const vorbis_residue_template _res_16s_2[]={
  {2,0,32,  &_residue_44_high,
   &_huff_book__16c2_s_short,&_huff_book__16c2_s_short,
   &_resbook_16s_2,&_resbook_16s_2},

  {2,0,32,  &_residue_44_high,
   &_huff_book__16c2_s_long,&_huff_book__16c2_s_long,
   &_resbook_16s_2,&_resbook_16s_2}
};

static const vorbis_mapping_template _mapres_template_16_stereo[3]={
  { _map_nominal, _res_16s_0 }, /* 0 */
  { _map_nominal, _res_16s_1 }, /* 1 */
  { _map_nominal, _res_16s_2 }, /* 2 */
};

static const static_bookblock _resbook_16u_0={
  {
	{0},
	{0,0,&_16u0__p1_0},
	{0,0,&_16u0__p2_0},
	{0,0,&_16u0__p3_0},
	{0,0,&_16u0__p4_0},
	{0,0,&_16u0__p5_0},
	{&_16u0__p6_0,&_16u0__p6_1},
	{&_16u0__p7_0,&_16u0__p7_1,&_16u0__p7_2}
   }
};
static const static_bookblock _resbook_16u_1={
  {
	{0},
	{0,0,&_16u1__p1_0},
	{0,0,&_16u1__p2_0},
	{0,0,&_16u1__p3_0},
	{0,0,&_16u1__p4_0},
	{0,0,&_16u1__p5_0},
	{0,0,&_16u1__p6_0},
	{&_16u1__p7_0,&_16u1__p7_1},
	{&_16u1__p8_0,&_16u1__p8_1},
	{&_16u1__p9_0,&_16u1__p9_1,&_16u1__p9_2}
   }
};
static const static_bookblock _resbook_16u_2={
  {
	{0},
	{0,0,&_16u2_p1_0},
	{0,0,&_16u2_p2_0},
	{0,0,&_16u2_p3_0},
	{0,0,&_16u2_p4_0},
	{&_16u2_p5_0,&_16u2_p5_1},
	{&_16u2_p6_0,&_16u2_p6_1},
	{&_16u2_p7_0,&_16u2_p7_1},
	{&_16u2_p8_0,&_16u2_p8_1},
	{&_16u2_p9_0,&_16u2_p9_1,&_16u2_p9_2}
   }
};

static const vorbis_residue_template _res_16u_0[]={
  {1,0,32,  &_residue_44_low_un,
   &_huff_book__16u0__single,&_huff_book__16u0__single,
   &_resbook_16u_0,&_resbook_16u_0},
};
static const vorbis_residue_template _res_16u_1[]={
  {1,0,32,  &_residue_44_mid_un,
   &_huff_book__16u1__short,&_huff_book__16u1__short,
   &_resbook_16u_1,&_resbook_16u_1},

  {1,0,32,  &_residue_44_mid_un,
   &_huff_book__16u1__long,&_huff_book__16u1__long,
   &_resbook_16u_1,&_resbook_16u_1}
};
static const vorbis_residue_template _res_16u_2[]={
  {1,0,32,  &_residue_44_hi_un,
   &_huff_book__16u2__short,&_huff_book__16u2__short,
   &_resbook_16u_2,&_resbook_16u_2},

  {1,0,32,  &_residue_44_hi_un,
   &_huff_book__16u2__long,&_huff_book__16u2__long,
   &_resbook_16u_2,&_resbook_16u_2}
};

static const vorbis_mapping_template _mapres_template_16_uncoupled[3]={
  { _map_nominal_u, _res_16u_0 }, /* 0 */
  { _map_nominal_u, _res_16u_1 }, /* 1 */
  { _map_nominal_u, _res_16u_2 }, /* 2 */
};

/*** End of inlined file: residue_16.h ***/

static const int blocksize_16_short[3]={
  1024,512,512
};
static const int blocksize_16_long[3]={
  1024,1024,1024
};

static const int _floor_mapping_16a[]={
  9,3,3
};
static const int _floor_mapping_16b[]={
  9,9,9
};
static const int *_floor_mapping_16[]={
  _floor_mapping_16a,
  _floor_mapping_16b
};

static const double rate_mapping_16[4]={
  12000.,20000.,44000.,86000.
};

static const double rate_mapping_16_uncoupled[4]={
  16000.,28000.,64000.,100000.
};

static const double _global_mapping_16[4]={ 1., 2., 3., 4. };

static const double quality_mapping_16[4]={ -.1,.05,.5,1. };

static const double _psy_compand_16_mapping[4]={ 0., .8, 1., 1.};

static const ve_setup_data_template ve_setup_16_stereo={
  3,
  rate_mapping_16,
  quality_mapping_16,
  2,
  15000,
  19000,

  blocksize_16_short,
  blocksize_16_long,

  _psy_tone_masteratt_16,
  _psy_tone_0dB,
  _psy_tone_suppress,

  _vp_tonemask_adj_16,
  _vp_tonemask_adj_16,
  _vp_tonemask_adj_16,

  _psy_noiseguards_16,
  _psy_noisebias_16_impulse,
  _psy_noisebias_16_short,
  _psy_noisebias_16_short,
  _psy_noisebias_16,
  _psy_noise_suppress,

  _psy_compand_8,
  _psy_compand_16_mapping,
  _psy_compand_16_mapping,

  {_noise_start_16,_noise_start_16},
  { _noise_part_16, _noise_part_16},
  _noise_thresh_16,

  _psy_ath_floater_16,
  _psy_ath_abs_16,

  _psy_lowpass_16,

  _psy_global_44,
  _global_mapping_16,
  _psy_stereo_modes_16,

  _floor_books,
  _floor,
  2,
  _floor_mapping_16,

  _mapres_template_16_stereo
};

static const ve_setup_data_template ve_setup_16_uncoupled={
  3,
  rate_mapping_16_uncoupled,
  quality_mapping_16,
  -1,
  15000,
  19000,

  blocksize_16_short,
  blocksize_16_long,

  _psy_tone_masteratt_16,
  _psy_tone_0dB,
  _psy_tone_suppress,

  _vp_tonemask_adj_16,
  _vp_tonemask_adj_16,
  _vp_tonemask_adj_16,

  _psy_noiseguards_16,
  _psy_noisebias_16_impulse,
  _psy_noisebias_16_short,
  _psy_noisebias_16_short,
  _psy_noisebias_16,
  _psy_noise_suppress,

  _psy_compand_8,
  _psy_compand_16_mapping,
  _psy_compand_16_mapping,

  {_noise_start_16,_noise_start_16},
  { _noise_part_16, _noise_part_16},
  _noise_thresh_16,

  _psy_ath_floater_16,
  _psy_ath_abs_16,

  _psy_lowpass_16,

  _psy_global_44,
  _global_mapping_16,
  _psy_stereo_modes_16,

  _floor_books,
  _floor,
  2,
  _floor_mapping_16,

  _mapres_template_16_uncoupled
};

/*** End of inlined file: setup_16.h ***/


/*** Start of inlined file: setup_22.h ***/
static const double rate_mapping_22[4]={
  15000.,20000.,44000.,86000.
};

static const double rate_mapping_22_uncoupled[4]={
  16000.,28000.,50000.,90000.
};

static const double _psy_lowpass_22[4]={9.5,11.,30.,99.};

static const ve_setup_data_template ve_setup_22_stereo={
  3,
  rate_mapping_22,
  quality_mapping_16,
  2,
  19000,
  26000,

  blocksize_16_short,
  blocksize_16_long,

  _psy_tone_masteratt_16,
  _psy_tone_0dB,
  _psy_tone_suppress,

  _vp_tonemask_adj_16,
  _vp_tonemask_adj_16,
  _vp_tonemask_adj_16,

  _psy_noiseguards_16,
  _psy_noisebias_16_impulse,
  _psy_noisebias_16_short,
  _psy_noisebias_16_short,
  _psy_noisebias_16,
  _psy_noise_suppress,

  _psy_compand_8,
  _psy_compand_16_mapping,
  _psy_compand_16_mapping,

  {_noise_start_16,_noise_start_16},
  { _noise_part_16, _noise_part_16},
  _noise_thresh_16,

  _psy_ath_floater_16,
  _psy_ath_abs_16,

  _psy_lowpass_22,

  _psy_global_44,
  _global_mapping_16,
  _psy_stereo_modes_16,

  _floor_books,
  _floor,
  2,
  _floor_mapping_16,

  _mapres_template_16_stereo
};

static const ve_setup_data_template ve_setup_22_uncoupled={
  3,
  rate_mapping_22_uncoupled,
  quality_mapping_16,
  -1,
  19000,
  26000,

  blocksize_16_short,
  blocksize_16_long,

  _psy_tone_masteratt_16,
  _psy_tone_0dB,
  _psy_tone_suppress,

  _vp_tonemask_adj_16,
  _vp_tonemask_adj_16,
  _vp_tonemask_adj_16,

  _psy_noiseguards_16,
  _psy_noisebias_16_impulse,
  _psy_noisebias_16_short,
  _psy_noisebias_16_short,
  _psy_noisebias_16,
  _psy_noise_suppress,

  _psy_compand_8,
  _psy_compand_16_mapping,
  _psy_compand_16_mapping,

  {_noise_start_16,_noise_start_16},
  { _noise_part_16, _noise_part_16},
  _noise_thresh_16,

  _psy_ath_floater_16,
  _psy_ath_abs_16,

  _psy_lowpass_22,

  _psy_global_44,
  _global_mapping_16,
  _psy_stereo_modes_16,

  _floor_books,
  _floor,
  2,
  _floor_mapping_16,

  _mapres_template_16_uncoupled
};

/*** End of inlined file: setup_22.h ***/


/*** Start of inlined file: setup_X.h ***/
static const double rate_mapping_X[12]={
  -1.,-1.,-1.,-1.,-1.,-1.,
  -1.,-1.,-1.,-1.,-1.,-1.
};

static const ve_setup_data_template ve_setup_X_stereo={
  11,
  rate_mapping_X,
  quality_mapping_44,
  2,
  50000,
  200000,

  blocksize_short_44,
  blocksize_long_44,

  _psy_tone_masteratt_44,
  _psy_tone_0dB,
  _psy_tone_suppress,

  _vp_tonemask_adj_otherblock,
  _vp_tonemask_adj_longblock,
  _vp_tonemask_adj_otherblock,

  _psy_noiseguards_44,
  _psy_noisebias_impulse,
  _psy_noisebias_padding,
  _psy_noisebias_trans,
  _psy_noisebias_long,
  _psy_noise_suppress,

  _psy_compand_44,
  _psy_compand_short_mapping,
  _psy_compand_long_mapping,

  {_noise_start_short_44,_noise_start_long_44},
  {_noise_part_short_44,_noise_part_long_44},
  _noise_thresh_44,

  _psy_ath_floater,
  _psy_ath_abs,

  _psy_lowpass_44,

  _psy_global_44,
  _global_mapping_44,
  _psy_stereo_modes_44,

  _floor_books,
  _floor,
  2,
  _floor_mapping_44,

  _mapres_template_44_stereo
};

static const ve_setup_data_template ve_setup_X_uncoupled={
  11,
  rate_mapping_X,
  quality_mapping_44,
  -1,
  50000,
  200000,

  blocksize_short_44,
  blocksize_long_44,

  _psy_tone_masteratt_44,
  _psy_tone_0dB,
  _psy_tone_suppress,

  _vp_tonemask_adj_otherblock,
  _vp_tonemask_adj_longblock,
  _vp_tonemask_adj_otherblock,

  _psy_noiseguards_44,
  _psy_noisebias_impulse,
  _psy_noisebias_padding,
  _psy_noisebias_trans,
  _psy_noisebias_long,
  _psy_noise_suppress,

  _psy_compand_44,
  _psy_compand_short_mapping,
  _psy_compand_long_mapping,

  {_noise_start_short_44,_noise_start_long_44},
  {_noise_part_short_44,_noise_part_long_44},
  _noise_thresh_44,

  _psy_ath_floater,
  _psy_ath_abs,

  _psy_lowpass_44,

  _psy_global_44,
  _global_mapping_44,
  NULL,

  _floor_books,
  _floor,
  2,
  _floor_mapping_44,

  _mapres_template_44_uncoupled
};

static const ve_setup_data_template ve_setup_XX_stereo={
  2,
  rate_mapping_X,
  quality_mapping_8,
  2,
  0,
  8000,

  blocksize_8,
  blocksize_8,

  _psy_tone_masteratt_8,
  _psy_tone_0dB,
  _psy_tone_suppress,

  _vp_tonemask_adj_8,
  NULL,
  _vp_tonemask_adj_8,

  _psy_noiseguards_8,
  _psy_noisebias_8,
  _psy_noisebias_8,
  NULL,
  NULL,
  _psy_noise_suppress,

  _psy_compand_8,
  _psy_compand_8_mapping,
  NULL,

  {_noise_start_8,_noise_start_8},
  {_noise_part_8,_noise_part_8},
  _noise_thresh_5only,

  _psy_ath_floater_8,
  _psy_ath_abs_8,

  _psy_lowpass_8,

  _psy_global_44,
  _global_mapping_8,
  _psy_stereo_modes_8,

  _floor_books,
  _floor,
  1,
  _floor_mapping_8,

  _mapres_template_8_stereo
};

static const ve_setup_data_template ve_setup_XX_uncoupled={
  2,
  rate_mapping_X,
  quality_mapping_8,
  -1,
  0,
  8000,

  blocksize_8,
  blocksize_8,

  _psy_tone_masteratt_8,
  _psy_tone_0dB,
  _psy_tone_suppress,

  _vp_tonemask_adj_8,
  NULL,
  _vp_tonemask_adj_8,

  _psy_noiseguards_8,
  _psy_noisebias_8,
  _psy_noisebias_8,
  NULL,
  NULL,
  _psy_noise_suppress,

  _psy_compand_8,
  _psy_compand_8_mapping,
  NULL,

  {_noise_start_8,_noise_start_8},
  {_noise_part_8,_noise_part_8},
  _noise_thresh_5only,

  _psy_ath_floater_8,
  _psy_ath_abs_8,

  _psy_lowpass_8,

  _psy_global_44,
  _global_mapping_8,
  _psy_stereo_modes_8,

  _floor_books,
  _floor,
  1,
  _floor_mapping_8,

  _mapres_template_8_uncoupled
};

/*** End of inlined file: setup_X.h ***/

static const ve_setup_data_template *const setup_list[]={
  &ve_setup_44_stereo,
  &ve_setup_44_51,
  &ve_setup_44_uncoupled,

  &ve_setup_32_stereo,
  &ve_setup_32_uncoupled,

  &ve_setup_22_stereo,
  &ve_setup_22_uncoupled,
  &ve_setup_16_stereo,
  &ve_setup_16_uncoupled,

  &ve_setup_11_stereo,
  &ve_setup_11_uncoupled,
  &ve_setup_8_stereo,
  &ve_setup_8_uncoupled,

  &ve_setup_X_stereo,
  &ve_setup_X_uncoupled,
  &ve_setup_XX_stereo,
  &ve_setup_XX_uncoupled,
  0
};

static void vorbis_encode_floor_setup(vorbis_info *vi,int s,
									 const static_codebook *const *const *const books,
									 const vorbis_info_floor1 *in,
									 const int *x){
  int i,k,is=s;
  vorbis_info_floor1 *f=(vorbis_info_floor1*) _ogg_calloc(1,sizeof(*f));
  codec_setup_info *ci=(codec_setup_info*)vi->codec_setup;

  memcpy(f,in+x[is],sizeof(*f));

  /* books */
  {
	int partitions=f->partitions;
	int maxclass=-1;
	int maxbook=-1;
	for(i=0;i<partitions;i++)
	  if(f->partitionclass[i]>maxclass)maxclass=f->partitionclass[i];
	for(i=0;i<=maxclass;i++){
	  if(f->class_book[i]>maxbook)maxbook=f->class_book[i];
	  f->class_book[i]+=ci->books;
	  for(k=0;k<(1<<f->class_subs[i]);k++){
		if(f->class_subbook[i][k]>maxbook)maxbook=f->class_subbook[i][k];
		if(f->class_subbook[i][k]>=0)f->class_subbook[i][k]+=ci->books;
	  }
	}

	for(i=0;i<=maxbook;i++)
	  ci->book_param[ci->books++]=(static_codebook *)books[x[is]][i];
  }

  /* for now, we're only using floor 1 */
  ci->floor_type[ci->floors]=1;
  ci->floor_param[ci->floors]=f;
  ci->floors++;

  return;
}

static void vorbis_encode_global_psych_setup(vorbis_info *vi,double s,
											const vorbis_info_psy_global *in,
											const double *x){
  int i,is=s;
  double ds=s-is;
  codec_setup_info *ci=(codec_setup_info*)vi->codec_setup;
  vorbis_info_psy_global *g=&ci->psy_g_param;

  memcpy(g,in+(int)x[is],sizeof(*g));

  ds=x[is]*(1.-ds)+x[is+1]*ds;
  is=(int)ds;
  ds-=is;
  if(ds==0 && is>0){
	is--;
	ds=1.;
  }

  /* interpolate the trigger threshholds */
  for(i=0;i<4;i++){
	g->preecho_thresh[i]=in[is].preecho_thresh[i]*(1.-ds)+in[is+1].preecho_thresh[i]*ds;
	g->postecho_thresh[i]=in[is].postecho_thresh[i]*(1.-ds)+in[is+1].postecho_thresh[i]*ds;
  }
  g->ampmax_att_per_sec=ci->hi.amplitude_track_dBpersec;
  return;
}

static void vorbis_encode_global_stereo(vorbis_info *vi,
										const highlevel_encode_setup *const hi,
										const adj_stereo *p){
  float s=hi->stereo_point_setting;
  int i,is=s;
  double ds=s-is;
  codec_setup_info *ci=(codec_setup_info*)vi->codec_setup;
  vorbis_info_psy_global *g=&ci->psy_g_param;

  if(p){
	memcpy(g->coupling_prepointamp,p[is].pre,sizeof(*p[is].pre)*PACKETBLOBS);
	memcpy(g->coupling_postpointamp,p[is].post,sizeof(*p[is].post)*PACKETBLOBS);

	if(hi->managed){
	  /* interpolate the kHz threshholds */
	  for(i=0;i<PACKETBLOBS;i++){
		float kHz=p[is].kHz[i]*(1.-ds)+p[is+1].kHz[i]*ds;
		g->coupling_pointlimit[0][i]=kHz*1000./vi->rate*ci->blocksizes[0];
		g->coupling_pointlimit[1][i]=kHz*1000./vi->rate*ci->blocksizes[1];
		g->coupling_pkHz[i]=kHz;

		kHz=p[is].lowpasskHz[i]*(1.-ds)+p[is+1].lowpasskHz[i]*ds;
		g->sliding_lowpass[0][i]=kHz*1000./vi->rate*ci->blocksizes[0];
		g->sliding_lowpass[1][i]=kHz*1000./vi->rate*ci->blocksizes[1];

	  }
	}else{
	  float kHz=p[is].kHz[PACKETBLOBS/2]*(1.-ds)+p[is+1].kHz[PACKETBLOBS/2]*ds;
	  for(i=0;i<PACKETBLOBS;i++){
		g->coupling_pointlimit[0][i]=kHz*1000./vi->rate*ci->blocksizes[0];
		g->coupling_pointlimit[1][i]=kHz*1000./vi->rate*ci->blocksizes[1];
		g->coupling_pkHz[i]=kHz;
	  }

	  kHz=p[is].lowpasskHz[PACKETBLOBS/2]*(1.-ds)+p[is+1].lowpasskHz[PACKETBLOBS/2]*ds;
	  for(i=0;i<PACKETBLOBS;i++){
		g->sliding_lowpass[0][i]=kHz*1000./vi->rate*ci->blocksizes[0];
		g->sliding_lowpass[1][i]=kHz*1000./vi->rate*ci->blocksizes[1];
	  }
	}
  }else{
	for(i=0;i<PACKETBLOBS;i++){
	  g->sliding_lowpass[0][i]=ci->blocksizes[0];
	  g->sliding_lowpass[1][i]=ci->blocksizes[1];
	}
  }
  return;
}

static void vorbis_encode_psyset_setup(vorbis_info *vi,double s,
									   const int *nn_start,
									   const int *nn_partition,
									   const double *nn_thresh,
									   int block){
  codec_setup_info *ci=(codec_setup_info*)vi->codec_setup;
  vorbis_info_psy *p=ci->psy_param[block];
  highlevel_encode_setup *hi=&ci->hi;
  int is=s;

  if(block>=ci->psys)
	ci->psys=block+1;
  if(!p){
	p=(vorbis_info_psy*)_ogg_calloc(1,sizeof(*p));
	ci->psy_param[block]=p;
  }

  memcpy(p,&_psy_info_template,sizeof(*p));
  p->blockflag=block>>1;

  if(hi->noise_normalize_p){
	p->normal_p=1;
	p->normal_start=nn_start[is];
	p->normal_partition=nn_partition[is];
	p->normal_thresh=nn_thresh[is];
  }

  return;
}

static void vorbis_encode_tonemask_setup(vorbis_info *vi,double s,int block,
										 const att3 *att,
										 const int  *max,
										 const vp_adjblock *in){
  int i,is=s;
  double ds=s-is;
  codec_setup_info *ci=(codec_setup_info*)vi->codec_setup;
  vorbis_info_psy *p=ci->psy_param[block];

  /* 0 and 2 are only used by bitmanagement, but there's no harm to always
	 filling the values in here */
  p->tone_masteratt[0]=att[is].att[0]*(1.-ds)+att[is+1].att[0]*ds;
  p->tone_masteratt[1]=att[is].att[1]*(1.-ds)+att[is+1].att[1]*ds;
  p->tone_masteratt[2]=att[is].att[2]*(1.-ds)+att[is+1].att[2]*ds;
  p->tone_centerboost=att[is].boost*(1.-ds)+att[is+1].boost*ds;
  p->tone_decay=att[is].decay*(1.-ds)+att[is+1].decay*ds;

  p->max_curve_dB=max[is]*(1.-ds)+max[is+1]*ds;

  for(i=0;i<P_BANDS;i++)
	p->toneatt[i]=in[is].block[i]*(1.-ds)+in[is+1].block[i]*ds;
  return;
}

static void vorbis_encode_compand_setup(vorbis_info *vi,double s,int block,
										const compandblock *in,
										const double *x){
  int i,is=s;
  double ds=s-is;
  codec_setup_info *ci=(codec_setup_info*)vi->codec_setup;
  vorbis_info_psy *p=ci->psy_param[block];

  ds=x[is]*(1.-ds)+x[is+1]*ds;
  is=(int)ds;
  ds-=is;
  if(ds==0 && is>0){
	is--;
	ds=1.;
  }

  /* interpolate the compander settings */
  for(i=0;i<NOISE_COMPAND_LEVELS;i++)
	p->noisecompand[i]=in[is].data[i]*(1.-ds)+in[is+1].data[i]*ds;
  return;
}

static void vorbis_encode_peak_setup(vorbis_info *vi,double s,int block,
									const int *suppress){
  int is=s;
  double ds=s-is;
  codec_setup_info *ci=(codec_setup_info*)vi->codec_setup;
  vorbis_info_psy *p=ci->psy_param[block];

  p->tone_abs_limit=suppress[is]*(1.-ds)+suppress[is+1]*ds;

  return;
}

static void vorbis_encode_noisebias_setup(vorbis_info *vi,double s,int block,
										 const int *suppress,
										 const noise3 *in,
										 const noiseguard *guard,
										 double userbias){
  int i,is=s,j;
  double ds=s-is;
  codec_setup_info *ci=(codec_setup_info*)vi->codec_setup;
  vorbis_info_psy *p=ci->psy_param[block];

  p->noisemaxsupp=suppress[is]*(1.-ds)+suppress[is+1]*ds;
  p->noisewindowlomin=guard[block].lo;
  p->noisewindowhimin=guard[block].hi;
  p->noisewindowfixed=guard[block].fixed;

  for(j=0;j<P_NOISECURVES;j++)
	for(i=0;i<P_BANDS;i++)
	  p->noiseoff[j][i]=in[is].data[j][i]*(1.-ds)+in[is+1].data[j][i]*ds;

  /* impulse blocks may take a user specified bias to boost the
	 nominal/high noise encoding depth */
  for(j=0;j<P_NOISECURVES;j++){
	float min=p->noiseoff[j][0]+6; /* the lowest it can go */
	for(i=0;i<P_BANDS;i++){
	  p->noiseoff[j][i]+=userbias;
	  if(p->noiseoff[j][i]<min)p->noiseoff[j][i]=min;
	}
  }

  return;
}

static void vorbis_encode_ath_setup(vorbis_info *vi,int block){
  codec_setup_info *ci=(codec_setup_info*)vi->codec_setup;
  vorbis_info_psy *p=ci->psy_param[block];

  p->ath_adjatt=ci->hi.ath_floating_dB;
  p->ath_maxatt=ci->hi.ath_absolute_dB;
  return;
}

static int book_dup_or_new(codec_setup_info *ci,const static_codebook *book){
  int i;
  for(i=0;i<ci->books;i++)
	if(ci->book_param[i]==book)return(i);

  return(ci->books++);
}

static void vorbis_encode_blocksize_setup(vorbis_info *vi,double s,
										 const int *shortb,const int *longb){

  codec_setup_info *ci=(codec_setup_info*)vi->codec_setup;
  int is=s;

  int blockshort=shortb[is];
  int blocklong=longb[is];
  ci->blocksizes[0]=blockshort;
  ci->blocksizes[1]=blocklong;

}

static void vorbis_encode_residue_setup(vorbis_info *vi,
										int number, int block,
										const vorbis_residue_template *res){

  codec_setup_info *ci=(codec_setup_info*)vi->codec_setup;
  int i;

  vorbis_info_residue0 *r=(vorbis_info_residue0*)(ci->residue_param[number]=
	(vorbis_info_residue0*)_ogg_malloc(sizeof(*r)));

  memcpy(r,res->res,sizeof(*r));
  if(ci->residues<=number)ci->residues=number+1;

  r->grouping=res->grouping;
  ci->residue_type[number]=res->res_type;

  /* fill in all the books */
  {
	int booklist=0,k;

	if(ci->hi.managed){
	  for(i=0;i<r->partitions;i++)
		for(k=0;k<4;k++)
		  if(res->books_base_managed->books[i][k])
			r->secondstages[i]|=(1<<k);

	  r->groupbook=book_dup_or_new(ci,res->book_aux_managed);
	  ci->book_param[r->groupbook]=(static_codebook *)res->book_aux_managed;

	  for(i=0;i<r->partitions;i++){
		for(k=0;k<4;k++){
		  if(res->books_base_managed->books[i][k]){
			int bookid=book_dup_or_new(ci,res->books_base_managed->books[i][k]);
			r->booklist[booklist++]=bookid;
			ci->book_param[bookid]=(static_codebook *)res->books_base_managed->books[i][k];
		  }
		}
	  }

	}else{

	  for(i=0;i<r->partitions;i++)
		for(k=0;k<4;k++)
		  if(res->books_base->books[i][k])
			r->secondstages[i]|=(1<<k);

	  r->groupbook=book_dup_or_new(ci,res->book_aux);
	  ci->book_param[r->groupbook]=(static_codebook *)res->book_aux;

	  for(i=0;i<r->partitions;i++){
		for(k=0;k<4;k++){
		  if(res->books_base->books[i][k]){
			int bookid=book_dup_or_new(ci,res->books_base->books[i][k]);
			r->booklist[booklist++]=bookid;
			ci->book_param[bookid]=(static_codebook *)res->books_base->books[i][k];
		  }
		}
	  }
	}
  }

  /* lowpass setup/pointlimit */
  {
	double freq=ci->hi.lowpass_kHz*1000.;
	vorbis_info_floor1 *f=(vorbis_info_floor1*)ci->floor_param[block]; /* by convention */
	double nyq=vi->rate/2.;
	long blocksize=ci->blocksizes[block]>>1;

	/* lowpass needs to be set in the floor and the residue. */
	if(freq>nyq)freq=nyq;
	/* in the floor, the granularity can be very fine; it doesn't alter
	   the encoding structure, only the samples used to fit the floor
	   approximation */
	f->n=freq/nyq*blocksize;

	/* this res may by limited by the maximum pointlimit of the mode,
	   not the lowpass. the floor is always lowpass limited. */
	switch(res->limit_type){
	case 1: /* point stereo limited */
	  if(ci->hi.managed)
		freq=ci->psy_g_param.coupling_pkHz[PACKETBLOBS-1]*1000.;
	  else
		freq=ci->psy_g_param.coupling_pkHz[PACKETBLOBS/2]*1000.;
	  if(freq>nyq)freq=nyq;
	  break;
	case 2: /* LFE channel; lowpass at ~ 250Hz */
	  freq=250;
	  break;
	default:
	  /* already set */
	  break;
	}

	/* in the residue, we're constrained, physically, by partition
	   boundaries.  We still lowpass 'wherever', but we have to round up
	   here to next boundary, or the vorbis spec will round it *down* to
	   previous boundary in encode/decode */
	if(ci->residue_type[number]==2){
	  /* residue 2 bundles together multiple channels; used by stereo
		 and surround.  Count the channels in use */
	  /* Multiple maps/submaps can point to the same residue.  In the case
		 of residue 2, they all better have the same number of
		 channels/samples. */
	  int j,k,ch=0;
	  for(i=0;i<ci->maps&&ch==0;i++){
		vorbis_info_mapping0 *mi=(vorbis_info_mapping0 *)ci->map_param[i];
		for(j=0;j<mi->submaps && ch==0;j++)
		  if(mi->residuesubmap[j]==number) /* we found a submap referencing theis residue backend */
			for(k=0;k<vi->channels;k++)
			  if(mi->chmuxlist[k]==j) /* this channel belongs to the submap */
				ch++;
	  }

	  r->end=(int)((freq/nyq*blocksize*ch)/r->grouping+.9)* /* round up only if we're well past */
		r->grouping;
	  /* the blocksize and grouping may disagree at the end */
	  if(r->end>blocksize*ch)r->end=blocksize*ch/r->grouping*r->grouping;

	}else{

	  r->end=(int)((freq/nyq*blocksize)/r->grouping+.9)* /* round up only if we're well past */
		r->grouping;
	  /* the blocksize and grouping may disagree at the end */
	  if(r->end>blocksize)r->end=blocksize/r->grouping*r->grouping;

	}

	if(r->end==0)r->end=r->grouping; /* LFE channel */

  }
}

/* we assume two maps in this encoder */
static void vorbis_encode_map_n_res_setup(vorbis_info *vi,double s,
										  const vorbis_mapping_template *maps){

  codec_setup_info *ci=(codec_setup_info*)vi->codec_setup;
  int i,j,is=s,modes=2;
  const vorbis_info_mapping0 *map=maps[is].map;
  const vorbis_info_mode *mode=_mode_template;
  const vorbis_residue_template *res=maps[is].res;

  if(ci->blocksizes[0]==ci->blocksizes[1])modes=1;

  for(i=0;i<modes;i++){

	ci->map_param[i]=_ogg_calloc(1,sizeof(*map));
	ci->mode_param[i]=(vorbis_info_mode*)_ogg_calloc(1,sizeof(*mode));

	memcpy(ci->mode_param[i],mode+i,sizeof(*_mode_template));
	if(i>=ci->modes)ci->modes=i+1;

	ci->map_type[i]=0;
	memcpy(ci->map_param[i],map+i,sizeof(*map));
	if(i>=ci->maps)ci->maps=i+1;

	for(j=0;j<map[i].submaps;j++)
	  vorbis_encode_residue_setup(vi,map[i].residuesubmap[j],i
								  ,res+map[i].residuesubmap[j]);
  }
}

static double setting_to_approx_bitrate(vorbis_info *vi){
  codec_setup_info *ci=(codec_setup_info*)vi->codec_setup;
  highlevel_encode_setup *hi=&ci->hi;
  ve_setup_data_template *setup=(ve_setup_data_template *)hi->setup;
  int is=hi->base_setting;
  double ds=hi->base_setting-is;
  int ch=vi->channels;
  const double *r=setup->rate_mapping;

  if(r==NULL)
	return(-1);

  return((r[is]*(1.-ds)+r[is+1]*ds)*ch);
}

static const void *get_setup_template(long ch,long srate,
									  double req,int q_or_bitrate,
									  double *base_setting){
  int i=0,j;
  if(q_or_bitrate)req/=ch;

  while(setup_list[i]){
	if(setup_list[i]->coupling_restriction==-1 ||
	   setup_list[i]->coupling_restriction==ch){
	  if(srate>=setup_list[i]->samplerate_min_restriction &&
		 srate<=setup_list[i]->samplerate_max_restriction){
		int mappings=setup_list[i]->mappings;
		const double *map=(q_or_bitrate?
					 setup_list[i]->rate_mapping:
					 setup_list[i]->quality_mapping);

		/* the template matches.  Does the requested quality mode
		   fall within this template's modes? */
		if(req<map[0]){++i;continue;}
		if(req>map[setup_list[i]->mappings]){++i;continue;}
		for(j=0;j<mappings;j++)
		  if(req>=map[j] && req<map[j+1])break;
		/* an all-points match */
		if(j==mappings)
		  *base_setting=j-.001;
		else{
		  float low=map[j];
		  float high=map[j+1];
		  float del=(req-low)/(high-low);
		  *base_setting=j+del;
		}

		return(setup_list[i]);
	  }
	}
	i++;
  }

  return NULL;
}

/* encoders will need to use vorbis_info_init beforehand and call
   vorbis_info clear when all done */

/* two interfaces; this, more detailed one, and later a convenience
   layer on top */

/* the final setup call */
int vorbis_encode_setup_init(vorbis_info *vi){
  int i,i0=0,singleblock=0;
  codec_setup_info *ci=(codec_setup_info*)vi->codec_setup;
  ve_setup_data_template *setup=NULL;
  highlevel_encode_setup *hi=&ci->hi;

  if(ci==NULL)return(OV_EINVAL);
  if(!hi->impulse_block_p)i0=1;

  /* too low/high an ATH floater is nonsensical, but doesn't break anything */
  if(hi->ath_floating_dB>-80)hi->ath_floating_dB=-80;
  if(hi->ath_floating_dB<-200)hi->ath_floating_dB=-200;

  /* again, bound this to avoid the app shooting itself int he foot
	 too badly */
  if(hi->amplitude_track_dBpersec>0.)hi->amplitude_track_dBpersec=0.;
  if(hi->amplitude_track_dBpersec<-99999.)hi->amplitude_track_dBpersec=-99999.;

  /* get the appropriate setup template; matches the fetch in previous
	 stages */
  setup=(ve_setup_data_template *)hi->setup;
  if(setup==NULL)return(OV_EINVAL);

  hi->set_in_stone=1;
  /* choose block sizes from configured sizes as well as paying
	 attention to long_block_p and short_block_p.  If the configured
	 short and long blocks are the same length, we set long_block_p
	 and unset short_block_p */
  vorbis_encode_blocksize_setup(vi,hi->base_setting,
								setup->blocksize_short,
								setup->blocksize_long);
  if(ci->blocksizes[0]==ci->blocksizes[1])singleblock=1;

  /* floor setup; choose proper floor params.  Allocated on the floor
	 stack in order; if we alloc only a single long floor, it's 0 */
  for(i=0;i<setup->floor_mappings;i++)
	vorbis_encode_floor_setup(vi,hi->base_setting,
							  setup->floor_books,
							  setup->floor_params,
							  setup->floor_mapping_list[i]);

  /* setup of [mostly] short block detection and stereo*/
  vorbis_encode_global_psych_setup(vi,hi->trigger_setting,
								   setup->global_params,
								   setup->global_mapping);
  vorbis_encode_global_stereo(vi,hi,setup->stereo_modes);

  /* basic psych setup and noise normalization */
  vorbis_encode_psyset_setup(vi,hi->base_setting,
							 setup->psy_noise_normal_start[0],
							 setup->psy_noise_normal_partition[0],
							 setup->psy_noise_normal_thresh,
							 0);
  vorbis_encode_psyset_setup(vi,hi->base_setting,
							 setup->psy_noise_normal_start[0],
							 setup->psy_noise_normal_partition[0],
							 setup->psy_noise_normal_thresh,
							 1);
  if(!singleblock){
	vorbis_encode_psyset_setup(vi,hi->base_setting,
							   setup->psy_noise_normal_start[1],
							   setup->psy_noise_normal_partition[1],
									setup->psy_noise_normal_thresh,
							   2);
	vorbis_encode_psyset_setup(vi,hi->base_setting,
							   setup->psy_noise_normal_start[1],
							   setup->psy_noise_normal_partition[1],
							   setup->psy_noise_normal_thresh,
							   3);
  }

  /* tone masking setup */
  vorbis_encode_tonemask_setup(vi,hi->block[i0].tone_mask_setting,0,
							   setup->psy_tone_masteratt,
							   setup->psy_tone_0dB,
							   setup->psy_tone_adj_impulse);
  vorbis_encode_tonemask_setup(vi,hi->block[1].tone_mask_setting,1,
							   setup->psy_tone_masteratt,
							   setup->psy_tone_0dB,
							   setup->psy_tone_adj_other);
  if(!singleblock){
	vorbis_encode_tonemask_setup(vi,hi->block[2].tone_mask_setting,2,
								 setup->psy_tone_masteratt,
								 setup->psy_tone_0dB,
								 setup->psy_tone_adj_other);
	vorbis_encode_tonemask_setup(vi,hi->block[3].tone_mask_setting,3,
								 setup->psy_tone_masteratt,
								 setup->psy_tone_0dB,
								 setup->psy_tone_adj_long);
  }

  /* noise companding setup */
  vorbis_encode_compand_setup(vi,hi->block[i0].noise_compand_setting,0,
							  setup->psy_noise_compand,
							  setup->psy_noise_compand_short_mapping);
  vorbis_encode_compand_setup(vi,hi->block[1].noise_compand_setting,1,
							  setup->psy_noise_compand,
							  setup->psy_noise_compand_short_mapping);
  if(!singleblock){
	vorbis_encode_compand_setup(vi,hi->block[2].noise_compand_setting,2,
								setup->psy_noise_compand,
								setup->psy_noise_compand_long_mapping);
	vorbis_encode_compand_setup(vi,hi->block[3].noise_compand_setting,3,
								setup->psy_noise_compand,
								setup->psy_noise_compand_long_mapping);
  }

  /* peak guarding setup  */
  vorbis_encode_peak_setup(vi,hi->block[i0].tone_peaklimit_setting,0,
						   setup->psy_tone_dBsuppress);
  vorbis_encode_peak_setup(vi,hi->block[1].tone_peaklimit_setting,1,
						   setup->psy_tone_dBsuppress);
  if(!singleblock){
	vorbis_encode_peak_setup(vi,hi->block[2].tone_peaklimit_setting,2,
							 setup->psy_tone_dBsuppress);
	vorbis_encode_peak_setup(vi,hi->block[3].tone_peaklimit_setting,3,
							 setup->psy_tone_dBsuppress);
  }

  /* noise bias setup */
  vorbis_encode_noisebias_setup(vi,hi->block[i0].noise_bias_setting,0,
								setup->psy_noise_dBsuppress,
								setup->psy_noise_bias_impulse,
								setup->psy_noiseguards,
								(i0==0?hi->impulse_noisetune:0.));
  vorbis_encode_noisebias_setup(vi,hi->block[1].noise_bias_setting,1,
								setup->psy_noise_dBsuppress,
								setup->psy_noise_bias_padding,
								setup->psy_noiseguards,0.);
  if(!singleblock){
	vorbis_encode_noisebias_setup(vi,hi->block[2].noise_bias_setting,2,
								  setup->psy_noise_dBsuppress,
								  setup->psy_noise_bias_trans,
								  setup->psy_noiseguards,0.);
	vorbis_encode_noisebias_setup(vi,hi->block[3].noise_bias_setting,3,
								  setup->psy_noise_dBsuppress,
								  setup->psy_noise_bias_long,
								  setup->psy_noiseguards,0.);
  }

  vorbis_encode_ath_setup(vi,0);
  vorbis_encode_ath_setup(vi,1);
  if(!singleblock){
	vorbis_encode_ath_setup(vi,2);
	vorbis_encode_ath_setup(vi,3);
  }

  vorbis_encode_map_n_res_setup(vi,hi->base_setting,setup->maps);

  /* set bitrate readonlies and management */
  if(hi->bitrate_av>0)
	vi->bitrate_nominal=hi->bitrate_av;
  else{
	vi->bitrate_nominal=setting_to_approx_bitrate(vi);
  }

  vi->bitrate_lower=hi->bitrate_min;
  vi->bitrate_upper=hi->bitrate_max;
  if(hi->bitrate_av)
	vi->bitrate_window=(double)hi->bitrate_reservoir/hi->bitrate_av;
  else
	vi->bitrate_window=0.;

  if(hi->managed){
	ci->bi.avg_rate=hi->bitrate_av;
	ci->bi.min_rate=hi->bitrate_min;
	ci->bi.max_rate=hi->bitrate_max;

	ci->bi.reservoir_bits=hi->bitrate_reservoir;
	ci->bi.reservoir_bias=
	  hi->bitrate_reservoir_bias;

	ci->bi.slew_damp=hi->bitrate_av_damp;

  }

  return(0);

}

static void vorbis_encode_setup_setting(vorbis_info *vi,
									   long  channels,
									   long  rate){
  int i,is;
  codec_setup_info *ci=(codec_setup_info*)vi->codec_setup;
  highlevel_encode_setup *hi=&ci->hi;
  const ve_setup_data_template *setup=(ve_setup_data_template*)hi->setup;
  double ds;

  vi->version=0;
  vi->channels=channels;
  vi->rate=rate;

  hi->impulse_block_p=1;
  hi->noise_normalize_p=1;

  is=hi->base_setting;
  ds=hi->base_setting-is;

  hi->stereo_point_setting=hi->base_setting;

  if(!hi->lowpass_altered)
	hi->lowpass_kHz=
	  setup->psy_lowpass[is]*(1.-ds)+setup->psy_lowpass[is+1]*ds;

  hi->ath_floating_dB=setup->psy_ath_float[is]*(1.-ds)+
	setup->psy_ath_float[is+1]*ds;
  hi->ath_absolute_dB=setup->psy_ath_abs[is]*(1.-ds)+
	setup->psy_ath_abs[is+1]*ds;

  hi->amplitude_track_dBpersec=-6.;
  hi->trigger_setting=hi->base_setting;

  for(i=0;i<4;i++){
	hi->block[i].tone_mask_setting=hi->base_setting;
	hi->block[i].tone_peaklimit_setting=hi->base_setting;
	hi->block[i].noise_bias_setting=hi->base_setting;
	hi->block[i].noise_compand_setting=hi->base_setting;
  }
}

int vorbis_encode_setup_vbr(vorbis_info *vi,
							long  channels,
							long  rate,
							float quality){
  codec_setup_info *ci=(codec_setup_info*) vi->codec_setup;
  highlevel_encode_setup *hi=&ci->hi;

  quality+=.0000001;
  if(quality>=1.)quality=.9999;

  hi->req=quality;
  hi->setup=get_setup_template(channels,rate,quality,0,&hi->base_setting);
  if(!hi->setup)return OV_EIMPL;

  vorbis_encode_setup_setting(vi,channels,rate);
  hi->managed=0;
  hi->coupling_p=1;

  return 0;
}

int vorbis_encode_init_vbr(vorbis_info *vi,
						   long channels,
						   long rate,

						   float base_quality /* 0. to 1. */
						   ){
  int ret=0;

  ret=vorbis_encode_setup_vbr(vi,channels,rate,base_quality);

  if(ret){
	vorbis_info_clear(vi);
	return ret;
  }
  ret=vorbis_encode_setup_init(vi);
  if(ret)
	vorbis_info_clear(vi);
  return(ret);
}

int vorbis_encode_setup_managed(vorbis_info *vi,
								long channels,
								long rate,

								long max_bitrate,
								long nominal_bitrate,
								long min_bitrate){

  codec_setup_info *ci=(codec_setup_info*)vi->codec_setup;
  highlevel_encode_setup *hi=&ci->hi;
  double tnominal=nominal_bitrate;

  if(nominal_bitrate<=0.){
	if(max_bitrate>0.){
	  if(min_bitrate>0.)
		nominal_bitrate=(max_bitrate+min_bitrate)*.5;
	  else
		nominal_bitrate=max_bitrate*.875;
	}else{
	  if(min_bitrate>0.){
		nominal_bitrate=min_bitrate;
	  }else{
		return(OV_EINVAL);
	  }
	}
  }

  hi->req=nominal_bitrate;
  hi->setup=get_setup_template(channels,rate,nominal_bitrate,1,&hi->base_setting);
  if(!hi->setup)return OV_EIMPL;

  vorbis_encode_setup_setting(vi,channels,rate);

  /* initialize management with sane defaults */
  hi->coupling_p=1;
  hi->managed=1;
  hi->bitrate_min=min_bitrate;
  hi->bitrate_max=max_bitrate;
  hi->bitrate_av=tnominal;
  hi->bitrate_av_damp=1.5f; /* full range in no less than 1.5 second */
  hi->bitrate_reservoir=nominal_bitrate*2;
  hi->bitrate_reservoir_bias=.1; /* bias toward hoarding bits */

  return(0);

}

int vorbis_encode_init(vorbis_info *vi,
					   long channels,
					   long rate,

					   long max_bitrate,
					   long nominal_bitrate,
					   long min_bitrate){

  int ret=vorbis_encode_setup_managed(vi,channels,rate,
									  max_bitrate,
									  nominal_bitrate,
									  min_bitrate);
  if(ret){
	vorbis_info_clear(vi);
	return(ret);
  }

  ret=vorbis_encode_setup_init(vi);
  if(ret)
	vorbis_info_clear(vi);
  return(ret);
}

int vorbis_encode_ctl(vorbis_info *vi,int number,void *arg){
  if(vi){
	codec_setup_info *ci=(codec_setup_info*)vi->codec_setup;
	highlevel_encode_setup *hi=&ci->hi;
	int setp=(number&0xf); /* a read request has a low nibble of 0 */

	if(setp && hi->set_in_stone)return(OV_EINVAL);

	switch(number){

	/* now deprecated *****************/
	case OV_ECTL_RATEMANAGE_GET:
	  {

		struct ovectl_ratemanage_arg *ai=
		  (struct ovectl_ratemanage_arg *)arg;

		ai->management_active=hi->managed;
		ai->bitrate_hard_window=ai->bitrate_av_window=
		  (double)hi->bitrate_reservoir/vi->rate;
		ai->bitrate_av_window_center=1.;
		ai->bitrate_hard_min=hi->bitrate_min;
		ai->bitrate_hard_max=hi->bitrate_max;
		ai->bitrate_av_lo=hi->bitrate_av;
		ai->bitrate_av_hi=hi->bitrate_av;

	  }
	  return(0);

	/* now deprecated *****************/
	case OV_ECTL_RATEMANAGE_SET:
	  {
		struct ovectl_ratemanage_arg *ai=
		  (struct ovectl_ratemanage_arg *)arg;
		if(ai==NULL){
		  hi->managed=0;
		}else{
		  hi->managed=ai->management_active;
		  vorbis_encode_ctl(vi,OV_ECTL_RATEMANAGE_AVG,arg);
		  vorbis_encode_ctl(vi,OV_ECTL_RATEMANAGE_HARD,arg);
		}
	  }
	  return 0;

	/* now deprecated *****************/
	case OV_ECTL_RATEMANAGE_AVG:
	  {
		struct ovectl_ratemanage_arg *ai=
		  (struct ovectl_ratemanage_arg *)arg;
		if(ai==NULL){
		  hi->bitrate_av=0;
		}else{
		  hi->bitrate_av=(ai->bitrate_av_lo+ai->bitrate_av_hi)*.5;
		}
	  }
	  return(0);
	/* now deprecated *****************/
	case OV_ECTL_RATEMANAGE_HARD:
	  {
		struct ovectl_ratemanage_arg *ai=
		  (struct ovectl_ratemanage_arg *)arg;
		if(ai==NULL){
		  hi->bitrate_min=0;
		  hi->bitrate_max=0;
		}else{
		  hi->bitrate_min=ai->bitrate_hard_min;
		  hi->bitrate_max=ai->bitrate_hard_max;
		  hi->bitrate_reservoir=ai->bitrate_hard_window*
			(hi->bitrate_max+hi->bitrate_min)*.5;
		}
		if(hi->bitrate_reservoir<128.)
		  hi->bitrate_reservoir=128.;
	  }
	  return(0);

	  /* replacement ratemanage interface */
	case OV_ECTL_RATEMANAGE2_GET:
	  {
		struct ovectl_ratemanage2_arg *ai=
		  (struct ovectl_ratemanage2_arg *)arg;
		if(ai==NULL)return OV_EINVAL;

		ai->management_active=hi->managed;
		ai->bitrate_limit_min_kbps=hi->bitrate_min/1000;
		ai->bitrate_limit_max_kbps=hi->bitrate_max/1000;
		ai->bitrate_average_kbps=hi->bitrate_av/1000;
		ai->bitrate_average_damping=hi->bitrate_av_damp;
		ai->bitrate_limit_reservoir_bits=hi->bitrate_reservoir;
		ai->bitrate_limit_reservoir_bias=hi->bitrate_reservoir_bias;
	  }
	  return (0);
	case OV_ECTL_RATEMANAGE2_SET:
	  {
		struct ovectl_ratemanage2_arg *ai=
		  (struct ovectl_ratemanage2_arg *)arg;
		if(ai==NULL){
		  hi->managed=0;
		}else{
		  /* sanity check; only catch invariant violations */
		  if(ai->bitrate_limit_min_kbps>0 &&
			 ai->bitrate_average_kbps>0 &&
			 ai->bitrate_limit_min_kbps>ai->bitrate_average_kbps)
			return OV_EINVAL;

		  if(ai->bitrate_limit_max_kbps>0 &&
			 ai->bitrate_average_kbps>0 &&
			 ai->bitrate_limit_max_kbps<ai->bitrate_average_kbps)
			return OV_EINVAL;

		  if(ai->bitrate_limit_min_kbps>0 &&
			 ai->bitrate_limit_max_kbps>0 &&
			 ai->bitrate_limit_min_kbps>ai->bitrate_limit_max_kbps)
			return OV_EINVAL;

		  if(ai->bitrate_average_damping <= 0.)
			return OV_EINVAL;

		  if(ai->bitrate_limit_reservoir_bits < 0)
			return OV_EINVAL;

		  if(ai->bitrate_limit_reservoir_bias < 0.)
			return OV_EINVAL;

		  if(ai->bitrate_limit_reservoir_bias > 1.)
			return OV_EINVAL;

		  hi->managed=ai->management_active;
		  hi->bitrate_min=ai->bitrate_limit_min_kbps * 1000;
		  hi->bitrate_max=ai->bitrate_limit_max_kbps * 1000;
		  hi->bitrate_av=ai->bitrate_average_kbps * 1000;
		  hi->bitrate_av_damp=ai->bitrate_average_damping;
		  hi->bitrate_reservoir=ai->bitrate_limit_reservoir_bits;
		  hi->bitrate_reservoir_bias=ai->bitrate_limit_reservoir_bias;
		}
	  }
	  return 0;

	case OV_ECTL_LOWPASS_GET:
	  {
		double *farg=(double *)arg;
		*farg=hi->lowpass_kHz;
	  }
	  return(0);
	case OV_ECTL_LOWPASS_SET:
	  {
		double *farg=(double *)arg;
		hi->lowpass_kHz=*farg;

		if(hi->lowpass_kHz<2.)hi->lowpass_kHz=2.;
		if(hi->lowpass_kHz>99.)hi->lowpass_kHz=99.;
		hi->lowpass_altered=1;
	  }
	  return(0);
	case OV_ECTL_IBLOCK_GET:
	  {
		double *farg=(double *)arg;
		*farg=hi->impulse_noisetune;
	  }
	  return(0);
	case OV_ECTL_IBLOCK_SET:
	  {
		double *farg=(double *)arg;
		hi->impulse_noisetune=*farg;

		if(hi->impulse_noisetune>0.)hi->impulse_noisetune=0.;
		if(hi->impulse_noisetune<-15.)hi->impulse_noisetune=-15.;
	  }
	  return(0);
	case OV_ECTL_COUPLING_GET:
	  {
		int *iarg=(int *)arg;
		*iarg=hi->coupling_p;
	  }
	  return(0);
	case OV_ECTL_COUPLING_SET:
	  {
		const void *new_template;
		double new_base=0.;
		int *iarg=(int *)arg;
		hi->coupling_p=((*iarg)!=0);

		/* Fetching a new template can alter the base_setting, which
		   many other parameters are based on.  Right now, the only
		   parameter drawn from the base_setting that can be altered
		   by an encctl is the lowpass, so that is explictly flagged
		   to not be overwritten when we fetch a new template and
		   recompute the dependant settings */
		new_template = get_setup_template(hi->coupling_p?vi->channels:-1,
										  vi->rate,
										  hi->req,
										  hi->managed,
										  &new_base);
		if(!hi->setup)return OV_EIMPL;
		hi->setup=new_template;
		hi->base_setting=new_base;
		vorbis_encode_setup_setting(vi,vi->channels,vi->rate);
	  }
	  return(0);
	}
	return(OV_EIMPL);
  }
  return(OV_EINVAL);
}

/*** End of inlined file: vorbisenc.c ***/


/*** Start of inlined file: vorbisfile.c ***/
#include <stdlib.h>
#include <stdio.h>
#include <errno.h>
#include <string.h>
#include <math.h>

/* A 'chained bitstream' is a Vorbis bitstream that contains more than
   one logical bitstream arranged end to end (the only form of Ogg
   multiplexing allowed in a Vorbis bitstream; grouping [parallel
   multiplexing] is not allowed in Vorbis) */

/* A Vorbis file can be played beginning to end (streamed) without
   worrying ahead of time about chaining (see decoder_example.c).  If
   we have the whole file, however, and want random access
   (seeking/scrubbing) or desire to know the total length/time of a
   file, we need to account for the possibility of chaining. */

/* We can handle things a number of ways; we can determine the entire
   bitstream structure right off the bat, or find pieces on demand.
   This example determines and caches structure for the entire
   bitstream, but builds a virtual decoder on the fly when moving
   between links in the chain. */

/* There are also different ways to implement seeking.  Enough
   information exists in an Ogg bitstream to seek to
   sample-granularity positions in the output.  Or, one can seek by
   picking some portion of the stream roughly in the desired area if
   we only want coarse navigation through the stream. */

/*************************************************************************
 * Many, many internal helpers.  The intention is not to be confusing;
 * rampant duplication and monolithic function implementation would be
 * harder to understand anyway.  The high level functions are last.  Begin
 * grokking near the end of the file */

/* read a little more data from the file/pipe into the ogg_sync framer
*/
#define CHUNKSIZE 65536 /* greater-than-page-size granularity seeking */
#define READSIZE 2048 /* a smaller read size is needed for low-rate streaming. */

static long _get_data(OggVorbis_File *vf){
  errno=0;
  if(!(vf->callbacks.read_func))return(-1);
  if(vf->datasource){
	char *buffer=ogg_sync_buffer(&vf->oy,READSIZE);
	long bytes=(vf->callbacks.read_func)(buffer,1,READSIZE,vf->datasource);
	if(bytes>0)ogg_sync_wrote(&vf->oy,bytes);
	if(bytes==0 && errno)return(-1);
	return(bytes);
  }else
	return(0);
}

/* save a tiny smidge of verbosity to make the code more readable */
static int _seek_helper(OggVorbis_File *vf,ogg_int64_t offset){
  if(vf->datasource){
	if(!(vf->callbacks.seek_func)||
	   (vf->callbacks.seek_func)(vf->datasource, offset, SEEK_SET) == -1)
	  return OV_EREAD;
	vf->offset=offset;
	ogg_sync_reset(&vf->oy);
  }else{
	/* shouldn't happen unless someone writes a broken callback */
	return OV_EFAULT;
  }
  return 0;
}

/* The read/seek functions track absolute position within the stream */

/* from the head of the stream, get the next page.  boundary specifies
   if the function is allowed to fetch more data from the stream (and
   how much) or only use internally buffered data.

   boundary: -1) unbounded search
			  0) read no additional data; use cached only
			  n) search for a new page beginning for n bytes

   return:   <0) did not find a page (OV_FALSE, OV_EOF, OV_EREAD)
			  n) found a page at absolute offset n */

static ogg_int64_t _get_next_page(OggVorbis_File *vf,ogg_page *og,
								  ogg_int64_t boundary){
  if(boundary>0)boundary+=vf->offset;
  while(1){
	long more;

	if(boundary>0 && vf->offset>=boundary)return(OV_FALSE);
	more=ogg_sync_pageseek(&vf->oy,og);

	if(more<0){
	  /* skipped n bytes */
	  vf->offset-=more;
	}else{
	  if(more==0){
		/* send more paramedics */
		if(!boundary)return(OV_FALSE);
		{
		  long ret=_get_data(vf);
		  if(ret==0)return(OV_EOF);
		  if(ret<0)return(OV_EREAD);
		}
	  }else{
		/* got a page.  Return the offset at the page beginning,
		   advance the internal offset past the page end */
		ogg_int64_t ret=vf->offset;
		vf->offset+=more;
		return(ret);

	  }
	}
  }
}

/* find the latest page beginning before the current stream cursor
   position. Much dirtier than the above as Ogg doesn't have any
   backward search linkage.  no 'readp' as it will certainly have to
   read. */
/* returns offset or OV_EREAD, OV_FAULT */
static ogg_int64_t _get_prev_page(OggVorbis_File *vf,ogg_page *og){
  ogg_int64_t begin=vf->offset;
  ogg_int64_t end=begin;
  ogg_int64_t ret;
  ogg_int64_t offset=-1;

  while(offset==-1){
	begin-=CHUNKSIZE;
	if(begin<0)
	  begin=0;

	ret=_seek_helper(vf,begin);
	if(ret)return(ret);

	while(vf->offset<end){
	  memset(og,0,sizeof(*og));
	  ret=_get_next_page(vf,og,end-vf->offset);
	  if(ret==OV_EREAD)return(OV_EREAD);
	  if(ret<0){
		break;
	  }else{
		offset=ret;
	  }
	}
  }

  /* In a fully compliant, non-multiplexed stream, we'll still be
	 holding the last page.  In multiplexed (or noncompliant streams),
	 we will probably have to re-read the last page we saw */
  if(og->header_len==0){
	ret=_seek_helper(vf,offset);
	if(ret)return(ret);

	ret=_get_next_page(vf,og,CHUNKSIZE);
	if(ret<0)
	  /* this shouldn't be possible */
	  return(OV_EFAULT);
  }

  return(offset);
}

static void _add_serialno(ogg_page *og,long **serialno_list, int *n){
  long s = ogg_page_serialno(og);
  (*n)++;

  if(*serialno_list){
	*serialno_list = (long*)_ogg_realloc(*serialno_list, sizeof(**serialno_list)*(*n));
  }else{
	*serialno_list = (long*)_ogg_malloc(sizeof(**serialno_list));
  }

  (*serialno_list)[(*n)-1] = s;
}

/* returns nonzero if found */
static int _lookup_serialno(long s, long *serialno_list, int n){
  if(serialno_list){
	while(n--){
	  if(*serialno_list == s) return 1;
	  serialno_list++;
	}
  }
  return 0;
}

static int _lookup_page_serialno(ogg_page *og, long *serialno_list, int n){
  long s = ogg_page_serialno(og);
  return _lookup_serialno(s,serialno_list,n);
}

/* performs the same search as _get_prev_page, but prefers pages of
   the specified serial number. If a page of the specified serialno is
   spotted during the seek-back-and-read-forward, it will return the
   info of last page of the matching serial number instead of the very
   last page.  If no page of the specified serialno is seen, it will
   return the info of last page and alter *serialno.  */
static ogg_int64_t _get_prev_page_serial(OggVorbis_File *vf,
										 long *serial_list, int serial_n,
										 int *serialno, ogg_int64_t *granpos){
  ogg_page og;
  ogg_int64_t begin=vf->offset;
  ogg_int64_t end=begin;
  ogg_int64_t ret;

  ogg_int64_t prefoffset=-1;
  ogg_int64_t offset=-1;
  ogg_int64_t ret_serialno=-1;
  ogg_int64_t ret_gran=-1;

  while(offset==-1){
	begin-=CHUNKSIZE;
	if(begin<0)
	  begin=0;

	ret=_seek_helper(vf,begin);
	if(ret)return(ret);

	while(vf->offset<end){
	  ret=_get_next_page(vf,&og,end-vf->offset);
	  if(ret==OV_EREAD)return(OV_EREAD);
	  if(ret<0){
		break;
	  }else{
		ret_serialno=ogg_page_serialno(&og);
		ret_gran=ogg_page_granulepos(&og);
		offset=ret;

		if(ret_serialno == *serialno){
		  prefoffset=ret;
		  *granpos=ret_gran;
		}

		if(!_lookup_serialno(ret_serialno,serial_list,serial_n)){
		  /* we fell off the end of the link, which means we seeked
			 back too far and shouldn't have been looking in that link
			 to begin with.  If we found the preferred serial number,
			 forget that we saw it. */
		  prefoffset=-1;
		}
	  }
	}
  }

  /* we're not interested in the page... just the serialno and granpos. */
  if(prefoffset>=0)return(prefoffset);

  *serialno = ret_serialno;
  *granpos = ret_gran;
  return(offset);

}

/* uses the local ogg_stream storage in vf; this is important for
   non-streaming input sources */
static int _fetch_headers(OggVorbis_File *vf,vorbis_info *vi,vorbis_comment *vc,
						  long **serialno_list, int *serialno_n,
						  ogg_page *og_ptr){
  ogg_page og;
  ogg_packet op;
  int i,ret;
  int allbos=0;

  if(!og_ptr){
	ogg_int64_t llret=_get_next_page(vf,&og,CHUNKSIZE);
	if(llret==OV_EREAD)return(OV_EREAD);
	if(llret<0)return(OV_ENOTVORBIS);
	og_ptr=&og;
  }

  vorbis_info_init(vi);
  vorbis_comment_init(vc);
  vf->ready_state=OPENED;

  /* extract the serialnos of all BOS pages + the first set of vorbis
	 headers we see in the link */

  while(ogg_page_bos(og_ptr)){
	if(serialno_list){
	  if(_lookup_page_serialno(og_ptr,*serialno_list,*serialno_n)){
		/* a dupe serialnumber in an initial header packet set == invalid stream */
		if(*serialno_list)_ogg_free(*serialno_list);
		*serialno_list=0;
		*serialno_n=0;
		ret=OV_EBADHEADER;
		goto bail_header;
	  }

	  _add_serialno(og_ptr,serialno_list,serialno_n);
	}

	if(vf->ready_state<STREAMSET){
	  /* we don't have a vorbis stream in this link yet, so begin
		 prospective stream setup. We need a stream to get packets */
	  ogg_stream_reset_serialno(&vf->os,ogg_page_serialno(og_ptr));
	  ogg_stream_pagein(&vf->os,og_ptr);

	  if(ogg_stream_packetout(&vf->os,&op) > 0 &&
		 vorbis_synthesis_idheader(&op)){
		/* vorbis header; continue setup */
		vf->ready_state=STREAMSET;
		if((ret=vorbis_synthesis_headerin(vi,vc,&op))){
		  ret=OV_EBADHEADER;
		  goto bail_header;
		}
	  }
	}

	/* get next page */
	{
	  ogg_int64_t llret=_get_next_page(vf,og_ptr,CHUNKSIZE);
	  if(llret==OV_EREAD){
		ret=OV_EREAD;
		goto bail_header;
	  }
	  if(llret<0){
		ret=OV_ENOTVORBIS;
		goto bail_header;
	  }

	  /* if this page also belongs to our vorbis stream, submit it and break */
	  if(vf->ready_state==STREAMSET &&
		 vf->os.serialno == ogg_page_serialno(og_ptr)){
		ogg_stream_pagein(&vf->os,og_ptr);
		break;
	  }
	}
  }

  if(vf->ready_state!=STREAMSET){
	ret = OV_ENOTVORBIS;
	goto bail_header;
  }

  while(1){

	i=0;
	while(i<2){ /* get a page loop */

	  while(i<2){ /* get a packet loop */

		int result=ogg_stream_packetout(&vf->os,&op);
		if(result==0)break;
		if(result==-1){
		  ret=OV_EBADHEADER;
		  goto bail_header;
		}

		if((ret=vorbis_synthesis_headerin(vi,vc,&op)))
		  goto bail_header;

		i++;
	  }

	  while(i<2){
		if(_get_next_page(vf,og_ptr,CHUNKSIZE)<0){
		  ret=OV_EBADHEADER;
		  goto bail_header;
		}

		/* if this page belongs to the correct stream, go parse it */
		if(vf->os.serialno == ogg_page_serialno(og_ptr)){
		  ogg_stream_pagein(&vf->os,og_ptr);
		  break;
		}

		/* if we never see the final vorbis headers before the link
		   ends, abort */
		if(ogg_page_bos(og_ptr)){
		  if(allbos){
			ret = OV_EBADHEADER;
			goto bail_header;
		  }else
			allbos=1;
		}

		/* otherwise, keep looking */
	  }
	}

	return 0;
  }

 bail_header:
  vorbis_info_clear(vi);
  vorbis_comment_clear(vc);
  vf->ready_state=OPENED;

  return ret;
}

/* Starting from current cursor position, get initial PCM offset of
   next page.  Consumes the page in the process without decoding
   audio, however this is only called during stream parsing upon
   seekable open. */
static ogg_int64_t _initial_pcmoffset(OggVorbis_File *vf, vorbis_info *vi){
  ogg_page    og;
  ogg_int64_t accumulated=0;
  long        lastblock=-1;
  int         result;
  int         serialno = vf->os.serialno;

  while(1){
	ogg_packet op;
	if(_get_next_page(vf,&og,-1)<0)
	  break; /* should not be possible unless the file is truncated/mangled */

	if(ogg_page_bos(&og)) break;
	if(ogg_page_serialno(&og)!=serialno) continue;

	/* count blocksizes of all frames in the page */
	ogg_stream_pagein(&vf->os,&og);
	while((result=ogg_stream_packetout(&vf->os,&op))){
	  if(result>0){ /* ignore holes */
		long thisblock=vorbis_packet_blocksize(vi,&op);
		if(lastblock!=-1)
		  accumulated+=(lastblock+thisblock)>>2;
		lastblock=thisblock;
	  }
	}

	if(ogg_page_granulepos(&og)!=-1){
	  /* pcm offset of last packet on the first audio page */
	  accumulated= ogg_page_granulepos(&og)-accumulated;
	  break;
	}
  }

  /* less than zero?  Either a corrupt file or a stream with samples
	 trimmed off the beginning, a normal occurrence; in both cases set
	 the offset to zero */
  if(accumulated<0)accumulated=0;

  return accumulated;
}

/* finds each bitstream link one at a time using a bisection search
   (has to begin by knowing the offset of the lb's initial page).
   Recurses for each link so it can alloc the link storage after
   finding them all, then unroll and fill the cache at the same time */
static int _bisect_forward_serialno(OggVorbis_File *vf,
									ogg_int64_t begin,
									ogg_int64_t searched,
									ogg_int64_t end,
									ogg_int64_t endgran,
									int endserial,
									long *currentno_list,
									int  currentnos,
									long m){
  ogg_int64_t pcmoffset;
  ogg_int64_t dataoffset=searched;
  ogg_int64_t endsearched=end;
  ogg_int64_t next=end;
  ogg_int64_t searchgran=-1;
  ogg_page og;
  ogg_int64_t ret,last;
  int serialno = vf->os.serialno;

  /* invariants:
	 we have the headers and serialnos for the link beginning at 'begin'
	 we have the offset and granpos of the last page in the file (potentially
	   not a page we care about)
  */

  /* Is the last page in our list of current serialnumbers? */
  if(_lookup_serialno(endserial,currentno_list,currentnos)){

	/* last page is in the starting serialno list, so we've bisected
	   down to (or just started with) a single link.  Now we need to
	   find the last vorbis page belonging to the first vorbis stream
	   for this link. */

	while(endserial != serialno){
	  endserial = serialno;
	  vf->offset=_get_prev_page_serial(vf,currentno_list,currentnos,&endserial,&endgran);
	}

	vf->links=m+1;
	if(vf->offsets)_ogg_free(vf->offsets);
	if(vf->serialnos)_ogg_free(vf->serialnos);
	if(vf->dataoffsets)_ogg_free(vf->dataoffsets);

	vf->offsets=(ogg_int64_t*)_ogg_malloc((vf->links+1)*sizeof(*vf->offsets));
	vf->vi=(vorbis_info*)_ogg_realloc(vf->vi,vf->links*sizeof(*vf->vi));
	vf->vc=(vorbis_comment*)_ogg_realloc(vf->vc,vf->links*sizeof(*vf->vc));
	vf->serialnos=(long*)_ogg_malloc(vf->links*sizeof(*vf->serialnos));
	vf->dataoffsets=(ogg_int64_t*)_ogg_malloc(vf->links*sizeof(*vf->dataoffsets));
	vf->pcmlengths=(ogg_int64_t*)_ogg_malloc(vf->links*2*sizeof(*vf->pcmlengths));

	vf->offsets[m+1]=end;
	vf->offsets[m]=begin;
	vf->pcmlengths[m*2+1]=(endgran<0?0:endgran);

  }else{

	long *next_serialno_list=NULL;
	int next_serialnos=0;
	vorbis_info vi;
	vorbis_comment vc;

	/* the below guards against garbage seperating the last and
	   first pages of two links. */
	while(searched<endsearched){
	  ogg_int64_t bisect;

	  if(endsearched-searched<CHUNKSIZE){
		bisect=searched;
	  }else{
		bisect=(searched+endsearched)/2;
	  }

	  if(bisect != vf->offset){
		ret=_seek_helper(vf,bisect);
		if(ret)return(ret);
	  }

	  last=_get_next_page(vf,&og,-1);
	  if(last==OV_EREAD)return(OV_EREAD);
	  if(last<0 || !_lookup_page_serialno(&og,currentno_list,currentnos)){
		endsearched=bisect;
		if(last>=0)next=last;
	  }else{
		searched=vf->offset;
	  }
	}

	/* Bisection point found */

	/* for the time being, fetch end PCM offset the simple way */
	{
	  int testserial = serialno+1;
	  vf->offset = next;
	  while(testserial != serialno){
		testserial = serialno;
		vf->offset=_get_prev_page_serial(vf,currentno_list,currentnos,&testserial,&searchgran);
	  }
	}

	if(vf->offset!=next){
	  ret=_seek_helper(vf,next);
	  if(ret)return(ret);
	}

	ret=_fetch_headers(vf,&vi,&vc,&next_serialno_list,&next_serialnos,NULL);
	if(ret)return(ret);
	serialno = vf->os.serialno;
	dataoffset = vf->offset;

	/* this will consume a page, however the next bistection always
	   starts with a raw seek */
	pcmoffset = _initial_pcmoffset(vf,&vi);

	ret=_bisect_forward_serialno(vf,next,vf->offset,end,endgran,endserial,
								 next_serialno_list,next_serialnos,m+1);
	if(ret)return(ret);

	if(next_serialno_list)_ogg_free(next_serialno_list);

	vf->offsets[m+1]=next;
	vf->serialnos[m+1]=serialno;
	vf->dataoffsets[m+1]=dataoffset;

	vf->vi[m+1]=vi;
	vf->vc[m+1]=vc;

	vf->pcmlengths[m*2+1]=searchgran;
	vf->pcmlengths[m*2+2]=pcmoffset;
	vf->pcmlengths[m*2+3]-=pcmoffset;
	if(vf->pcmlengths[m*2+3]<0)vf->pcmlengths[m*2+3]=0;
  }
  return(0);
}

static int _make_decode_ready(OggVorbis_File *vf){
  if(vf->ready_state>STREAMSET)return 0;
  if(vf->ready_state<STREAMSET)return OV_EFAULT;
  if(vf->seekable){
	if(vorbis_synthesis_init(&vf->vd,vf->vi+vf->current_link))
	  return OV_EBADLINK;
  }else{
	if(vorbis_synthesis_init(&vf->vd,vf->vi))
	  return OV_EBADLINK;
  }
  vorbis_block_init(&vf->vd,&vf->vb);
  vf->ready_state=INITSET;
  vf->bittrack=0.f;
  vf->samptrack=0.f;
  return 0;
}

static int _open_seekable2(OggVorbis_File *vf){
  ogg_int64_t dataoffset=vf->dataoffsets[0],end,endgran=-1;
  int endserial=vf->os.serialno;
  int serialno=vf->os.serialno;

  /* we're partially open and have a first link header state in
	 storage in vf */

  /* fetch initial PCM offset */
  ogg_int64_t pcmoffset = _initial_pcmoffset(vf,vf->vi);

  /* we can seek, so set out learning all about this file */
  if(vf->callbacks.seek_func && vf->callbacks.tell_func){
	(vf->callbacks.seek_func)(vf->datasource,0,SEEK_END);
	vf->offset=vf->end=(vf->callbacks.tell_func)(vf->datasource);
  }else{
	vf->offset=vf->end=-1;
  }

  /* If seek_func is implemented, tell_func must also be implemented */
  if(vf->end==-1) return(OV_EINVAL);

  /* Get the offset of the last page of the physical bitstream, or, if
	 we're lucky the last vorbis page of this link as most OggVorbis
	 files will contain a single logical bitstream */
  end=_get_prev_page_serial(vf,vf->serialnos+2,vf->serialnos[1],&endserial,&endgran);
  if(end<0)return(end);

  /* now determine bitstream structure recursively */
  if(_bisect_forward_serialno(vf,0,dataoffset,vf->offset,endgran,endserial,
							  vf->serialnos+2,vf->serialnos[1],0)<0)return(OV_EREAD);

  vf->offsets[0]=0;
  vf->serialnos[0]=serialno;
  vf->dataoffsets[0]=dataoffset;
  vf->pcmlengths[0]=pcmoffset;
  vf->pcmlengths[1]-=pcmoffset;
  if(vf->pcmlengths[1]<0)vf->pcmlengths[1]=0;

  return(ov_raw_seek(vf,dataoffset));
}

/* clear out the current logical bitstream decoder */
static void _decode_clear(OggVorbis_File *vf){
  vorbis_dsp_clear(&vf->vd);
  vorbis_block_clear(&vf->vb);
  vf->ready_state=OPENED;
}

/* fetch and process a packet.  Handles the case where we're at a
   bitstream boundary and dumps the decoding machine.  If the decoding
   machine is unloaded, it loads it.  It also keeps pcm_offset up to
   date (seek and read both use this.  seek uses a special hack with
   readp).

   return: <0) error, OV_HOLE (lost packet) or OV_EOF
			0) need more data (only if readp==0)
			1) got a packet
*/

static int _fetch_and_process_packet(OggVorbis_File *vf,
									 ogg_packet *op_in,
									 int readp,
									 int spanp){
  ogg_page og;

  /* handle one packet.  Try to fetch it from current stream state */
  /* extract packets from page */
  while(1){

	if(vf->ready_state==STREAMSET){
	  int ret=_make_decode_ready(vf);
	  if(ret<0)return ret;
	}

	/* process a packet if we can. */

	if(vf->ready_state==INITSET){
	  int hs=vorbis_synthesis_halfrate_p(vf->vi);

	  while(1) {
			  ogg_packet op;
			  ogg_packet *op_ptr=(op_in?op_in:&op);
		int result=ogg_stream_packetout(&vf->os,op_ptr);
		ogg_int64_t granulepos;

		op_in=NULL;
		if(result==-1)return(OV_HOLE); /* hole in the data. */
		if(result>0){
		  /* got a packet.  process it */
		  granulepos=op_ptr->granulepos;
		  if(!vorbis_synthesis(&vf->vb,op_ptr)){ /* lazy check for lazy
													header handling.  The
													header packets aren't
													audio, so if/when we
													submit them,
													vorbis_synthesis will
													reject them */

			/* suck in the synthesis data and track bitrate */
			{
			  int oldsamples=vorbis_synthesis_pcmout(&vf->vd,NULL);
			  /* for proper use of libvorbis within libvorbisfile,
				 oldsamples will always be zero. */
			  if(oldsamples)return(OV_EFAULT);

			  vorbis_synthesis_blockin(&vf->vd,&vf->vb);
			  vf->samptrack+=(vorbis_synthesis_pcmout(&vf->vd,NULL)<<hs);
			  vf->bittrack+=op_ptr->bytes*8;
			}

			/* update the pcm offset. */
			if(granulepos!=-1 && !op_ptr->e_o_s){
			  int link=(vf->seekable?vf->current_link:0);
			  int i,samples;

			  /* this packet has a pcm_offset on it (the last packet
				 completed on a page carries the offset) After processing
				 (above), we know the pcm position of the *last* sample
				 ready to be returned. Find the offset of the *first*

				 As an aside, this trick is inaccurate if we begin
				 reading anew right at the last page; the end-of-stream
				 granulepos declares the last frame in the stream, and the
				 last packet of the last page may be a partial frame.
				 So, we need a previous granulepos from an in-sequence page
				 to have a reference point.  Thus the !op_ptr->e_o_s clause
				 above */

			  if(vf->seekable && link>0)
				granulepos-=vf->pcmlengths[link*2];
			  if(granulepos<0)granulepos=0; /* actually, this
											   shouldn't be possible
											   here unless the stream
											   is very broken */

			  samples=(vorbis_synthesis_pcmout(&vf->vd,NULL)<<hs);

			  granulepos-=samples;
			  for(i=0;i<link;i++)
				granulepos+=vf->pcmlengths[i*2+1];
			  vf->pcm_offset=granulepos;
			}
			return(1);
		  }
		}
		else
		  break;
	  }
	}

	if(vf->ready_state>=OPENED){
	  ogg_int64_t ret;

	  while(1){
		/* the loop is not strictly necessary, but there's no sense in
		   doing the extra checks of the larger loop for the common
		   case in a multiplexed bistream where the page is simply
		   part of a different logical bitstream; keep reading until
		   we get one with the correct serialno */

		if(!readp)return(0);
		if((ret=_get_next_page(vf,&og,-1))<0){
		  return(OV_EOF); /* eof. leave unitialized */
		}

		/* bitrate tracking; add the header's bytes here, the body bytes
		   are done by packet above */
		vf->bittrack+=og.header_len*8;

		if(vf->ready_state==INITSET){
		  if(vf->current_serialno!=ogg_page_serialno(&og)){

			/* two possibilities:
			   1) our decoding just traversed a bitstream boundary
			   2) another stream is multiplexed into this logical section */

			if(ogg_page_bos(&og)){
			  /* boundary case */
			  if(!spanp)
				return(OV_EOF);

			  _decode_clear(vf);

			  if(!vf->seekable){
				vorbis_info_clear(vf->vi);
				vorbis_comment_clear(vf->vc);
			  }
			  break;

			}else
			  continue; /* possibility #2 */
		  }
		}

		break;
	  }
	}

	/* Do we need to load a new machine before submitting the page? */
	/* This is different in the seekable and non-seekable cases.

	   In the seekable case, we already have all the header
	   information loaded and cached; we just initialize the machine
	   with it and continue on our merry way.

	   In the non-seekable (streaming) case, we'll only be at a
	   boundary if we just left the previous logical bitstream and
	   we're now nominally at the header of the next bitstream
	*/

	if(vf->ready_state!=INITSET){
	  int link;

	  if(vf->ready_state<STREAMSET){
		if(vf->seekable){
		  long serialno = ogg_page_serialno(&og);

		  /* match the serialno to bitstream section.  We use this rather than
			 offset positions to avoid problems near logical bitstream
			 boundaries */

		  for(link=0;link<vf->links;link++)
			if(vf->serialnos[link]==serialno)break;

		  if(link==vf->links) continue; /* not the desired Vorbis
										   bitstream section; keep
										   trying */

		  vf->current_serialno=serialno;
		  vf->current_link=link;

		  ogg_stream_reset_serialno(&vf->os,vf->current_serialno);
		  vf->ready_state=STREAMSET;

		}else{
		  /* we're streaming */
		  /* fetch the three header packets, build the info struct */

		  int ret=_fetch_headers(vf,vf->vi,vf->vc,NULL,NULL,&og);
		  if(ret)return(ret);
		  vf->current_serialno=vf->os.serialno;
		  vf->current_link++;
		  link=0;
		}
	  }
	}

	/* the buffered page is the data we want, and we're ready for it;
	   add it to the stream state */
	ogg_stream_pagein(&vf->os,&og);

  }
}

/* if, eg, 64 bit stdio is configured by default, this will build with
   fseek64 */
static int _fseek64_wrap(FILE *f,ogg_int64_t off,int whence){
  if(f==NULL)return(-1);
  return fseek(f,off,whence);
}

static int _ov_open1(void *f,OggVorbis_File *vf,const char *initial,
					 long ibytes, ov_callbacks callbacks){
  int offsettest=((f && callbacks.seek_func)?callbacks.seek_func(f,0,SEEK_CUR):-1);
  long *serialno_list=NULL;
  int serialno_list_size=0;
  int ret;

  memset(vf,0,sizeof(*vf));
  vf->datasource=f;
  vf->callbacks = callbacks;

  /* init the framing state */
  ogg_sync_init(&vf->oy);

  /* perhaps some data was previously read into a buffer for testing
	 against other stream types.  Allow initialization from this
	 previously read data (especially as we may be reading from a
	 non-seekable stream) */
  if(initial){
	char *buffer=ogg_sync_buffer(&vf->oy,ibytes);
	memcpy(buffer,initial,ibytes);
	ogg_sync_wrote(&vf->oy,ibytes);
  }

  /* can we seek? Stevens suggests the seek test was portable */
  if(offsettest!=-1)vf->seekable=1;

  /* No seeking yet; Set up a 'single' (current) logical bitstream
	 entry for partial open */
  vf->links=1;
  vf->vi=(vorbis_info*) _ogg_calloc(vf->links,sizeof(*vf->vi));
  vf->vc=(vorbis_comment*) _ogg_calloc(vf->links,sizeof(*vf->vc));
  ogg_stream_init(&vf->os,-1); /* fill in the serialno later */

  /* Fetch all BOS pages, store the vorbis header and all seen serial
	 numbers, load subsequent vorbis setup headers */
  if((ret=_fetch_headers(vf,vf->vi,vf->vc,&serialno_list,&serialno_list_size,NULL))<0){
	vf->datasource=NULL;
	ov_clear(vf);
  }else{
	/* serial number list for first link needs to be held somewhere
	   for second stage of seekable stream open; this saves having to
	   seek/reread first link's serialnumber data then. */
	vf->serialnos=(long*)_ogg_calloc(serialno_list_size+2,sizeof(*vf->serialnos));
	vf->serialnos[0]=vf->current_serialno=vf->os.serialno;
	vf->serialnos[1]=serialno_list_size;
	memcpy(vf->serialnos+2,serialno_list,serialno_list_size*sizeof(*vf->serialnos));

	vf->offsets=(ogg_int64_t*)_ogg_calloc(1,sizeof(*vf->offsets));
	vf->dataoffsets=(ogg_int64_t*)_ogg_calloc(1,sizeof(*vf->dataoffsets));
	vf->offsets[0]=0;
	vf->dataoffsets[0]=vf->offset;

	vf->ready_state=PARTOPEN;
  }
  if(serialno_list)_ogg_free(serialno_list);
  return(ret);
}

static int _ov_open2(OggVorbis_File *vf){
  if(vf->ready_state != PARTOPEN) return OV_EINVAL;
  vf->ready_state=OPENED;
  if(vf->seekable){
	int ret=_open_seekable2(vf);
	if(ret){
	  vf->datasource=NULL;
	  ov_clear(vf);
	}
	return(ret);
  }else
	vf->ready_state=STREAMSET;

  return 0;
}

/* clear out the OggVorbis_File struct */
int ov_clear(OggVorbis_File *vf){
  if(vf){
	vorbis_block_clear(&vf->vb);
	vorbis_dsp_clear(&vf->vd);
	ogg_stream_clear(&vf->os);

	if(vf->vi && vf->links){
	  int i;
	  for(i=0;i<vf->links;i++){
		vorbis_info_clear(vf->vi+i);
		vorbis_comment_clear(vf->vc+i);
	  }
	  _ogg_free(vf->vi);
	  _ogg_free(vf->vc);
	}
	if(vf->dataoffsets)_ogg_free(vf->dataoffsets);
	if(vf->pcmlengths)_ogg_free(vf->pcmlengths);
	if(vf->serialnos)_ogg_free(vf->serialnos);
	if(vf->offsets)_ogg_free(vf->offsets);
	ogg_sync_clear(&vf->oy);
	if(vf->datasource && vf->callbacks.close_func)
	  (vf->callbacks.close_func)(vf->datasource);
	memset(vf,0,sizeof(*vf));
  }
#ifdef DEBUG_LEAKS
  _VDBG_dump();
#endif
  return(0);
}

/* inspects the OggVorbis file and finds/documents all the logical
   bitstreams contained in it.  Tries to be tolerant of logical
   bitstream sections that are truncated/woogie.

   return: -1) error
			0) OK
*/

int ov_open_callbacks(void *f,OggVorbis_File *vf,
	const char *initial,long ibytes,ov_callbacks callbacks){
  int ret=_ov_open1(f,vf,initial,ibytes,callbacks);
  if(ret)return ret;
  return _ov_open2(vf);
}

int ov_open(FILE *f,OggVorbis_File *vf,const char *initial,long ibytes){
  ov_callbacks callbacks = {
	(size_t (*)(void *, size_t, size_t, void *))  fread,
	(int (*)(void *, ogg_int64_t, int))              _fseek64_wrap,
	(int (*)(void *))                             fclose,
	(long (*)(void *))                            ftell
  };

  return ov_open_callbacks((void *)f, vf, initial, ibytes, callbacks);
}

int ov_fopen(const char *path,OggVorbis_File *vf){
  int ret;
  FILE *f = fopen(path,"rb");
  if(!f) return -1;

  ret = ov_open(f,vf,NULL,0);
  if(ret) fclose(f);
  return ret;
}

/* cheap hack for game usage where downsampling is desirable; there's
   no need for SRC as we can just do it cheaply in libvorbis. */

int ov_halfrate(OggVorbis_File *vf,int flag){
  int i;
  if(vf->vi==NULL)return OV_EINVAL;
  if(vf->ready_state>STREAMSET){
	/* clear out stream state; dumping the decode machine is needed to
	   reinit the MDCT lookups. */
	vorbis_dsp_clear(&vf->vd);
	vorbis_block_clear(&vf->vb);
	vf->ready_state=STREAMSET;
	if(vf->pcm_offset>=0){
	  ogg_int64_t pos=vf->pcm_offset;
	  vf->pcm_offset=-1; /* make sure the pos is dumped if unseekable */
	  ov_pcm_seek(vf,pos);
	}
  }

  for(i=0;i<vf->links;i++){
	if(vorbis_synthesis_halfrate(vf->vi+i,flag)){
	  if(flag) ov_halfrate(vf,0);
	  return OV_EINVAL;
	}
  }
  return 0;
}

int ov_halfrate_p(OggVorbis_File *vf){
  if(vf->vi==NULL)return OV_EINVAL;
  return vorbis_synthesis_halfrate_p(vf->vi);
}

/* Only partially open the vorbis file; test for Vorbisness, and load
   the headers for the first chain.  Do not seek (although test for
   seekability).  Use ov_test_open to finish opening the file, else
   ov_clear to close/free it. Same return codes as open. */

int ov_test_callbacks(void *f,OggVorbis_File *vf,
	const char *initial,long ibytes,ov_callbacks callbacks)
{
  return _ov_open1(f,vf,initial,ibytes,callbacks);
}

int ov_test(FILE *f,OggVorbis_File *vf,const char *initial,long ibytes){
  ov_callbacks callbacks = {
	(size_t (*)(void *, size_t, size_t, void *))  fread,
	(int (*)(void *, ogg_int64_t, int))              _fseek64_wrap,
	(int (*)(void *))                             fclose,
	(long (*)(void *))                            ftell
  };

  return ov_test_callbacks((void *)f, vf, initial, ibytes, callbacks);
}

int ov_test_open(OggVorbis_File *vf){
  if(vf->ready_state!=PARTOPEN)return(OV_EINVAL);
  return _ov_open2(vf);
}

/* How many logical bitstreams in this physical bitstream? */
long ov_streams(OggVorbis_File *vf){
  return vf->links;
}

/* Is the FILE * associated with vf seekable? */
long ov_seekable(OggVorbis_File *vf){
  return vf->seekable;
}

/* returns the bitrate for a given logical bitstream or the entire
   physical bitstream.  If the file is open for random access, it will
   find the *actual* average bitrate.  If the file is streaming, it
   returns the nominal bitrate (if set) else the average of the
   upper/lower bounds (if set) else -1 (unset).

   If you want the actual bitrate field settings, get them from the
   vorbis_info structs */

long ov_bitrate(OggVorbis_File *vf,int i){
  if(vf->ready_state<OPENED)return(OV_EINVAL);
  if(i>=vf->links)return(OV_EINVAL);
  if(!vf->seekable && i!=0)return(ov_bitrate(vf,0));
  if(i<0){
	ogg_int64_t bits=0;
	int i;
	float br;
	for(i=0;i<vf->links;i++)
	  bits+=(vf->offsets[i+1]-vf->dataoffsets[i])*8;
	/* This once read: return(rint(bits/ov_time_total(vf,-1)));
	 * gcc 3.x on x86 miscompiled this at optimisation level 2 and above,
	 * so this is slightly transformed to make it work.
	 */
	br = bits/ov_time_total(vf,-1);
	return(rint(br));
  }else{
	if(vf->seekable){
	  /* return the actual bitrate */
	  return(rint((vf->offsets[i+1]-vf->dataoffsets[i])*8/ov_time_total(vf,i)));
	}else{
	  /* return nominal if set */
	  if(vf->vi[i].bitrate_nominal>0){
		return vf->vi[i].bitrate_nominal;
	  }else{
		if(vf->vi[i].bitrate_upper>0){
		  if(vf->vi[i].bitrate_lower>0){
			return (vf->vi[i].bitrate_upper+vf->vi[i].bitrate_lower)/2;
		  }else{
			return vf->vi[i].bitrate_upper;
		  }
		}
		return(OV_FALSE);
	  }
	}
  }
}

/* returns the actual bitrate since last call.  returns -1 if no
   additional data to offer since last call (or at beginning of stream),
   EINVAL if stream is only partially open
*/
long ov_bitrate_instant(OggVorbis_File *vf){
  int link=(vf->seekable?vf->current_link:0);
  long ret;
  if(vf->ready_state<OPENED)return(OV_EINVAL);
  if(vf->samptrack==0)return(OV_FALSE);
  ret=vf->bittrack/vf->samptrack*vf->vi[link].rate+.5;
  vf->bittrack=0.f;
  vf->samptrack=0.f;
  return(ret);
}

/* Guess */
long ov_serialnumber(OggVorbis_File *vf,int i){
  if(i>=vf->links)return(ov_serialnumber(vf,vf->links-1));
  if(!vf->seekable && i>=0)return(ov_serialnumber(vf,-1));
  if(i<0){
	return(vf->current_serialno);
  }else{
	return(vf->serialnos[i]);
  }
}

/* returns: total raw (compressed) length of content if i==-1
			raw (compressed) length of that logical bitstream for i==0 to n
			OV_EINVAL if the stream is not seekable (we can't know the length)
			or if stream is only partially open
*/
ogg_int64_t ov_raw_total(OggVorbis_File *vf,int i){
  if(vf->ready_state<OPENED)return(OV_EINVAL);
  if(!vf->seekable || i>=vf->links)return(OV_EINVAL);
  if(i<0){
	ogg_int64_t acc=0;
	int i;
	for(i=0;i<vf->links;i++)
	  acc+=ov_raw_total(vf,i);
	return(acc);
  }else{
	return(vf->offsets[i+1]-vf->offsets[i]);
  }
}

/* returns: total PCM length (samples) of content if i==-1 PCM length
			(samples) of that logical bitstream for i==0 to n
			OV_EINVAL if the stream is not seekable (we can't know the
			length) or only partially open
*/
ogg_int64_t ov_pcm_total(OggVorbis_File *vf,int i){
  if(vf->ready_state<OPENED)return(OV_EINVAL);
  if(!vf->seekable || i>=vf->links)return(OV_EINVAL);
  if(i<0){
	ogg_int64_t acc=0;
	int i;
	for(i=0;i<vf->links;i++)
	  acc+=ov_pcm_total(vf,i);
	return(acc);
  }else{
	return(vf->pcmlengths[i*2+1]);
  }
}

/* returns: total seconds of content if i==-1
			seconds in that logical bitstream for i==0 to n
			OV_EINVAL if the stream is not seekable (we can't know the
			length) or only partially open
*/
double ov_time_total(OggVorbis_File *vf,int i){
  if(vf->ready_state<OPENED)return(OV_EINVAL);
  if(!vf->seekable || i>=vf->links)return(OV_EINVAL);
  if(i<0){
	double acc=0;
	int i;
	for(i=0;i<vf->links;i++)
	  acc+=ov_time_total(vf,i);
	return(acc);
  }else{
	return((double)(vf->pcmlengths[i*2+1])/vf->vi[i].rate);
  }
}

/* seek to an offset relative to the *compressed* data. This also
   scans packets to update the PCM cursor. It will cross a logical
   bitstream boundary, but only if it can't get any packets out of the
   tail of the bitstream we seek to (so no surprises).

   returns zero on success, nonzero on failure */

int ov_raw_seek(OggVorbis_File *vf,ogg_int64_t pos){
  ogg_stream_state work_os;
  int ret;

  if(vf->ready_state<OPENED)return(OV_EINVAL);
  if(!vf->seekable)
	return(OV_ENOSEEK); /* don't dump machine if we can't seek */

  if(pos<0 || pos>vf->end)return(OV_EINVAL);

  /* is the seek position outside our current link [if any]? */
  if(vf->ready_state>=STREAMSET){
	if(pos<vf->offsets[vf->current_link] || pos>=vf->offsets[vf->current_link+1])
	  _decode_clear(vf); /* clear out stream state */
  }

  /* don't yet clear out decoding machine (if it's initialized), in
	 the case we're in the same link.  Restart the decode lapping, and
	 let _fetch_and_process_packet deal with a potential bitstream
	 boundary */
  vf->pcm_offset=-1;
  ogg_stream_reset_serialno(&vf->os,
							vf->current_serialno); /* must set serialno */
  vorbis_synthesis_restart(&vf->vd);

  ret=_seek_helper(vf,pos);
  if(ret)goto seek_error;

  /* we need to make sure the pcm_offset is set, but we don't want to
	 advance the raw cursor past good packets just to get to the first
	 with a granulepos.  That's not equivalent behavior to beginning
	 decoding as immediately after the seek position as possible.

	 So, a hack.  We use two stream states; a local scratch state and
	 the shared vf->os stream state.  We use the local state to
	 scan, and the shared state as a buffer for later decode.

	 Unfortuantely, on the last page we still advance to last packet
	 because the granulepos on the last page is not necessarily on a
	 packet boundary, and we need to make sure the granpos is
	 correct.
  */

  {
	ogg_page og;
	ogg_packet op;
	int lastblock=0;
	int accblock=0;
	int thisblock=0;
	int lastflag=0;
	int firstflag=0;
	ogg_int64_t pagepos=-1;

	ogg_stream_init(&work_os,vf->current_serialno); /* get the memory ready */
	ogg_stream_reset(&work_os); /* eliminate the spurious OV_HOLE
								   return from not necessarily
								   starting from the beginning */

	while(1){
	  if(vf->ready_state>=STREAMSET){
		/* snarf/scan a packet if we can */
		int result=ogg_stream_packetout(&work_os,&op);

		if(result>0){

		  if(vf->vi[vf->current_link].codec_setup){
			thisblock=vorbis_packet_blocksize(vf->vi+vf->current_link,&op);
			if(thisblock<0){
			  ogg_stream_packetout(&vf->os,NULL);
			  thisblock=0;
			}else{

			  /* We can't get a guaranteed correct pcm position out of the
				 last page in a stream because it might have a 'short'
				 granpos, which can only be detected in the presence of a
				 preceding page.  However, if the last page is also the first
				 page, the granpos rules of a first page take precedence.  Not
				 only that, but for first==last, the EOS page must be treated
				 as if its a normal first page for the stream to open/play. */
			  if(lastflag && !firstflag)
				ogg_stream_packetout(&vf->os,NULL);
			  else
				if(lastblock)accblock+=(lastblock+thisblock)>>2;
			}

			if(op.granulepos!=-1){
			  int i,link=vf->current_link;
			  ogg_int64_t granulepos=op.granulepos-vf->pcmlengths[link*2];
			  if(granulepos<0)granulepos=0;

			  for(i=0;i<link;i++)
				granulepos+=vf->pcmlengths[i*2+1];
			  vf->pcm_offset=granulepos-accblock;
			  if(vf->pcm_offset<0)vf->pcm_offset=0;
			  break;
			}
			lastblock=thisblock;
			continue;
		  }else
			ogg_stream_packetout(&vf->os,NULL);
		}
	  }

	  if(!lastblock){
		pagepos=_get_next_page(vf,&og,-1);
		if(pagepos<0){
		  vf->pcm_offset=ov_pcm_total(vf,-1);
		  break;
		}
	  }else{
		/* huh?  Bogus stream with packets but no granulepos */
		vf->pcm_offset=-1;
		break;
	  }

	  /* has our decoding just traversed a bitstream boundary? */
	  if(vf->ready_state>=STREAMSET){
		if(vf->current_serialno!=ogg_page_serialno(&og)){

		  /* two possibilities:
			 1) our decoding just traversed a bitstream boundary
			 2) another stream is multiplexed into this logical section? */

		  if(ogg_page_bos(&og)){
			/* we traversed */
			_decode_clear(vf); /* clear out stream state */
			ogg_stream_clear(&work_os);
		  } /* else, do nothing; next loop will scoop another page */
		}
	  }

	  if(vf->ready_state<STREAMSET){
		int link;
		long serialno = ogg_page_serialno(&og);

		for(link=0;link<vf->links;link++)
		  if(vf->serialnos[link]==serialno)break;

		if(link==vf->links) continue; /* not the desired Vorbis
										 bitstream section; keep
										 trying */
		vf->current_link=link;
		vf->current_serialno=serialno;
		ogg_stream_reset_serialno(&vf->os,serialno);
		ogg_stream_reset_serialno(&work_os,serialno);
		vf->ready_state=STREAMSET;
		firstflag=(pagepos<=vf->dataoffsets[link]);
	  }

	  ogg_stream_pagein(&vf->os,&og);
	  ogg_stream_pagein(&work_os,&og);
	  lastflag=ogg_page_eos(&og);

	}
  }

  ogg_stream_clear(&work_os);
  vf->bittrack=0.f;
  vf->samptrack=0.f;
  return(0);

 seek_error:
  /* dump the machine so we're in a known state */
  vf->pcm_offset=-1;
  ogg_stream_clear(&work_os);
  _decode_clear(vf);
  return OV_EBADLINK;
}

/* Page granularity seek (faster than sample granularity because we
   don't do the last bit of decode to find a specific sample).

   Seek to the last [granule marked] page preceding the specified pos
   location, such that decoding past the returned point will quickly
   arrive at the requested position. */
int ov_pcm_seek_page(OggVorbis_File *vf,ogg_int64_t pos){
  int link=-1;
  ogg_int64_t result=0;
  ogg_int64_t total=ov_pcm_total(vf,-1);

  if(vf->ready_state<OPENED)return(OV_EINVAL);
  if(!vf->seekable)return(OV_ENOSEEK);

  if(pos<0 || pos>total)return(OV_EINVAL);

  /* which bitstream section does this pcm offset occur in? */
  for(link=vf->links-1;link>=0;link--){
	total-=vf->pcmlengths[link*2+1];
	if(pos>=total)break;
  }

  /* search within the logical bitstream for the page with the highest
	 pcm_pos preceding (or equal to) pos.  There is a danger here;
	 missing pages or incorrect frame number information in the
	 bitstream could make our task impossible.  Account for that (it
	 would be an error condition) */

  /* new search algorithm by HB (Nicholas Vinen) */
  {
	ogg_int64_t end=vf->offsets[link+1];
	ogg_int64_t begin=vf->offsets[link];
	ogg_int64_t begintime = vf->pcmlengths[link*2];
	ogg_int64_t endtime = vf->pcmlengths[link*2+1]+begintime;
	ogg_int64_t target=pos-total+begintime;
	ogg_int64_t best=begin;

	ogg_page og;
	while(begin<end){
	  ogg_int64_t bisect;

	  if(end-begin<CHUNKSIZE){
		bisect=begin;
	  }else{
		/* take a (pretty decent) guess. */
		bisect=begin +
		  (ogg_int64_t)((double)(target-begintime)*(end-begin)/(endtime-begintime))
		  - CHUNKSIZE;
		if(bisect<begin+CHUNKSIZE)
		  bisect=begin;
	  }

	  if(bisect!=vf->offset){
		result=_seek_helper(vf,bisect);
		if(result) goto seek_error;
	  }

	  while(begin<end){
		result=_get_next_page(vf,&og,end-vf->offset);
		if(result==OV_EREAD) goto seek_error;
		if(result<0){
		  if(bisect<=begin+1)
			end=begin; /* found it */
		  else{
			if(bisect==0) goto seek_error;
			bisect-=CHUNKSIZE;
			if(bisect<=begin)bisect=begin+1;
			result=_seek_helper(vf,bisect);
			if(result) goto seek_error;
		  }
		}else{
		  ogg_int64_t granulepos;

		  if(ogg_page_serialno(&og)!=vf->serialnos[link])
			continue;

		  granulepos=ogg_page_granulepos(&og);
		  if(granulepos==-1)continue;

		  if(granulepos<target){
			best=result;  /* raw offset of packet with granulepos */
			begin=vf->offset; /* raw offset of next page */
			begintime=granulepos;

			if(target-begintime>44100)break;
			bisect=begin; /* *not* begin + 1 */
		  }else{
			if(bisect<=begin+1)
			  end=begin;  /* found it */
			else{
			  if(end==vf->offset){ /* we're pretty close - we'd be stuck in */
				end=result;
				bisect-=CHUNKSIZE; /* an endless loop otherwise. */
				if(bisect<=begin)bisect=begin+1;
				result=_seek_helper(vf,bisect);
				if(result) goto seek_error;
			  }else{
				end=bisect;
				endtime=granulepos;
				break;
			  }
			}
		  }
		}
	  }
	}

	/* found our page. seek to it, update pcm offset. Easier case than
	   raw_seek, don't keep packets preceding granulepos. */
	{
	  ogg_page og;
	  ogg_packet op;

	  /* seek */
	  result=_seek_helper(vf,best);
	  vf->pcm_offset=-1;
	  if(result) goto seek_error;
	  result=_get_next_page(vf,&og,-1);
	  if(result<0) goto seek_error;

	  if(link!=vf->current_link){
		/* Different link; dump entire decode machine */
		_decode_clear(vf);

		vf->current_link=link;
		vf->current_serialno=vf->serialnos[link];
		vf->ready_state=STREAMSET;

	  }else{
		vorbis_synthesis_restart(&vf->vd);
	  }

	  ogg_stream_reset_serialno(&vf->os,vf->current_serialno);
	  ogg_stream_pagein(&vf->os,&og);

	  /* pull out all but last packet; the one with granulepos */
	  while(1){
		result=ogg_stream_packetpeek(&vf->os,&op);
		if(result==0){
		  /* !!! the packet finishing this page originated on a
			 preceding page. Keep fetching previous pages until we
			 get one with a granulepos or without the 'continued' flag
			 set.  Then just use raw_seek for simplicity. */

		  result=_seek_helper(vf,best);
		  if(result<0) goto seek_error;

		  while(1){
			result=_get_prev_page(vf,&og);
			if(result<0) goto seek_error;
			if(ogg_page_serialno(&og)==vf->current_serialno &&
			   (ogg_page_granulepos(&og)>-1 ||
				!ogg_page_continued(&og))){
			  return ov_raw_seek(vf,result);
			}
			vf->offset=result;
		  }
		}
		if(result<0){
		  result = OV_EBADPACKET;
		  goto seek_error;
		}
		if(op.granulepos!=-1){
		  vf->pcm_offset=op.granulepos-vf->pcmlengths[vf->current_link*2];
		  if(vf->pcm_offset<0)vf->pcm_offset=0;
		  vf->pcm_offset+=total;
		  break;
		}else
		  result=ogg_stream_packetout(&vf->os,NULL);
	  }
	}
  }

  /* verify result */
  if(vf->pcm_offset>pos || pos>ov_pcm_total(vf,-1)){
	result=OV_EFAULT;
	goto seek_error;
  }
  vf->bittrack=0.f;
  vf->samptrack=0.f;
  return(0);

 seek_error:
  /* dump machine so we're in a known state */
  vf->pcm_offset=-1;
  _decode_clear(vf);
  return (int)result;
}

/* seek to a sample offset relative to the decompressed pcm stream
   returns zero on success, nonzero on failure */

int ov_pcm_seek(OggVorbis_File *vf,ogg_int64_t pos){
  int thisblock,lastblock=0;
  int ret=ov_pcm_seek_page(vf,pos);
  if(ret<0)return(ret);
  if((ret=_make_decode_ready(vf)))return ret;

  /* discard leading packets we don't need for the lapping of the
	 position we want; don't decode them */

  while(1){
	ogg_packet op;
	ogg_page og;

	int ret=ogg_stream_packetpeek(&vf->os,&op);
	if(ret>0){
	  thisblock=vorbis_packet_blocksize(vf->vi+vf->current_link,&op);
	  if(thisblock<0){
		ogg_stream_packetout(&vf->os,NULL);
		continue; /* non audio packet */
	  }
	  if(lastblock)vf->pcm_offset+=(lastblock+thisblock)>>2;

	  if(vf->pcm_offset+((thisblock+
						  vorbis_info_blocksize(vf->vi,1))>>2)>=pos)break;

	  /* remove the packet from packet queue and track its granulepos */
	  ogg_stream_packetout(&vf->os,NULL);
	  vorbis_synthesis_trackonly(&vf->vb,&op);  /* set up a vb with
												   only tracking, no
												   pcm_decode */
	  vorbis_synthesis_blockin(&vf->vd,&vf->vb);

	  /* end of logical stream case is hard, especially with exact
		 length positioning. */

	  if(op.granulepos>-1){
		int i;
		/* always believe the stream markers */
		vf->pcm_offset=op.granulepos-vf->pcmlengths[vf->current_link*2];
		if(vf->pcm_offset<0)vf->pcm_offset=0;
		for(i=0;i<vf->current_link;i++)
		  vf->pcm_offset+=vf->pcmlengths[i*2+1];
	  }

	  lastblock=thisblock;

	}else{
	  if(ret<0 && ret!=OV_HOLE)break;

	  /* suck in a new page */
	  if(_get_next_page(vf,&og,-1)<0)break;
	  if(ogg_page_bos(&og))_decode_clear(vf);

	  if(vf->ready_state<STREAMSET){
		long serialno=ogg_page_serialno(&og);
		int link;

		for(link=0;link<vf->links;link++)
		  if(vf->serialnos[link]==serialno)break;
		if(link==vf->links) continue;
		vf->current_link=link;

		vf->ready_state=STREAMSET;
		vf->current_serialno=ogg_page_serialno(&og);
		ogg_stream_reset_serialno(&vf->os,serialno);
		ret=_make_decode_ready(vf);
		if(ret)return ret;
		lastblock=0;
	  }

	  ogg_stream_pagein(&vf->os,&og);
	}
  }

  vf->bittrack=0.f;
  vf->samptrack=0.f;
  /* discard samples until we reach the desired position. Crossing a
	 logical bitstream boundary with abandon is OK. */
  {
	/* note that halfrate could be set differently in each link, but
	   vorbisfile encoforces all links are set or unset */
	int hs=vorbis_synthesis_halfrate_p(vf->vi);
	while(vf->pcm_offset<((pos>>hs)<<hs)){
	  ogg_int64_t target=(pos-vf->pcm_offset)>>hs;
	  long samples=vorbis_synthesis_pcmout(&vf->vd,NULL);

	  if(samples>target)samples=target;
	  vorbis_synthesis_read(&vf->vd,samples);
	  vf->pcm_offset+=samples<<hs;

	  if(samples<target)
		if(_fetch_and_process_packet(vf,NULL,1,1)<=0)
		  vf->pcm_offset=ov_pcm_total(vf,-1); /* eof */
	}
  }
  return 0;
}

/* seek to a playback time relative to the decompressed pcm stream
   returns zero on success, nonzero on failure */
int ov_time_seek(OggVorbis_File *vf,double seconds){
  /* translate time to PCM position and call ov_pcm_seek */

  int link=-1;
  ogg_int64_t pcm_total=0;
  double time_total=0.;

  if(vf->ready_state<OPENED)return(OV_EINVAL);
  if(!vf->seekable)return(OV_ENOSEEK);
  if(seconds<0)return(OV_EINVAL);

  /* which bitstream section does this time offset occur in? */
  for(link=0;link<vf->links;link++){
	double addsec = ov_time_total(vf,link);
	if(seconds<time_total+addsec)break;
	time_total+=addsec;
	pcm_total+=vf->pcmlengths[link*2+1];
  }

  if(link==vf->links)return(OV_EINVAL);

  /* enough information to convert time offset to pcm offset */
  {
	ogg_int64_t target=pcm_total+(seconds-time_total)*vf->vi[link].rate;
	return(ov_pcm_seek(vf,target));
  }
}

/* page-granularity version of ov_time_seek
   returns zero on success, nonzero on failure */
int ov_time_seek_page(OggVorbis_File *vf,double seconds){
  /* translate time to PCM position and call ov_pcm_seek */

  int link=-1;
  ogg_int64_t pcm_total=0;
  double time_total=0.;

  if(vf->ready_state<OPENED)return(OV_EINVAL);
  if(!vf->seekable)return(OV_ENOSEEK);
  if(seconds<0)return(OV_EINVAL);

  /* which bitstream section does this time offset occur in? */
  for(link=0;link<vf->links;link++){
	double addsec = ov_time_total(vf,link);
	if(seconds<time_total+addsec)break;
	time_total+=addsec;
	pcm_total+=vf->pcmlengths[link*2+1];
  }

  if(link==vf->links)return(OV_EINVAL);

  /* enough information to convert time offset to pcm offset */
  {
	ogg_int64_t target=pcm_total+(seconds-time_total)*vf->vi[link].rate;
	return(ov_pcm_seek_page(vf,target));
  }
}

/* tell the current stream offset cursor.  Note that seek followed by
   tell will likely not give the set offset due to caching */
ogg_int64_t ov_raw_tell(OggVorbis_File *vf){
  if(vf->ready_state<OPENED)return(OV_EINVAL);
  return(vf->offset);
}

/* return PCM offset (sample) of next PCM sample to be read */
ogg_int64_t ov_pcm_tell(OggVorbis_File *vf){
  if(vf->ready_state<OPENED)return(OV_EINVAL);
  return(vf->pcm_offset);
}

/* return time offset (seconds) of next PCM sample to be read */
double ov_time_tell(OggVorbis_File *vf){
  int link=0;
  ogg_int64_t pcm_total=0;
  double time_total=0.f;

  if(vf->ready_state<OPENED)return(OV_EINVAL);
  if(vf->seekable){
	pcm_total=ov_pcm_total(vf,-1);
	time_total=ov_time_total(vf,-1);

	/* which bitstream section does this time offset occur in? */
	for(link=vf->links-1;link>=0;link--){
	  pcm_total-=vf->pcmlengths[link*2+1];
	  time_total-=ov_time_total(vf,link);
	  if(vf->pcm_offset>=pcm_total)break;
	}
  }

  return((double)time_total+(double)(vf->pcm_offset-pcm_total)/vf->vi[link].rate);
}

/*  link:   -1) return the vorbis_info struct for the bitstream section
				currently being decoded
		   0-n) to request information for a specific bitstream section

	In the case of a non-seekable bitstream, any call returns the
	current bitstream.  NULL in the case that the machine is not
	initialized */

vorbis_info *ov_info(OggVorbis_File *vf,int link){
  if(vf->seekable){
	if(link<0)
	  if(vf->ready_state>=STREAMSET)
		return vf->vi+vf->current_link;
	  else
	  return vf->vi;
	else
	  if(link>=vf->links)
		return NULL;
	  else
		return vf->vi+link;
  }else{
	return vf->vi;
  }
}

/* grr, strong typing, grr, no templates/inheritence, grr */
vorbis_comment *ov_comment(OggVorbis_File *vf,int link){
  if(vf->seekable){
	if(link<0)
	  if(vf->ready_state>=STREAMSET)
		return vf->vc+vf->current_link;
	  else
		return vf->vc;
	else
	  if(link>=vf->links)
		return NULL;
	  else
		return vf->vc+link;
  }else{
	return vf->vc;
  }
}

static int host_is_big_endian() {
  ogg_int32_t pattern = 0xfeedface; /* deadbeef */
  unsigned char *bytewise = (unsigned char *)&pattern;
  if (bytewise[0] == 0xfe) return 1;
  return 0;
}

/* up to this point, everything could more or less hide the multiple
   logical bitstream nature of chaining from the toplevel application
   if the toplevel application didn't particularly care.  However, at
   the point that we actually read audio back, the multiple-section
   nature must surface: Multiple bitstream sections do not necessarily
   have to have the same number of channels or sampling rate.

   ov_read returns the sequential logical bitstream number currently
   being decoded along with the PCM data in order that the toplevel
   application can take action on channel/sample rate changes.  This
   number will be incremented even for streamed (non-seekable) streams
   (for seekable streams, it represents the actual logical bitstream
   index within the physical bitstream.  Note that the accessor
   functions above are aware of this dichotomy).

   ov_read_filter is exactly the same as ov_read except that it processes
   the decoded audio data through a filter before packing it into the
   requested format. This gives greater accuracy than applying a filter
   after the audio has been converted into integral PCM.

   input values: buffer) a buffer to hold packed PCM data for return
				 length) the byte length requested to be placed into buffer
				 bigendianp) should the data be packed LSB first (0) or
							 MSB first (1)
				 word) word size for output.  currently 1 (byte) or
					   2 (16 bit short)

   return values: <0) error/hole in data (OV_HOLE), partial open (OV_EINVAL)
				   0) EOF
				   n) number of bytes of PCM actually returned.  The
				   below works on a packet-by-packet basis, so the
				   return length is not related to the 'length' passed
				   in, just guaranteed to fit.

			*section) set to the logical bitstream number */

long ov_read_filter(OggVorbis_File *vf,char *buffer,int length,
					int bigendianp,int word,int sgned,int *bitstream,
					void (*filter)(float **pcm,long channels,long samples,void *filter_param),void *filter_param){
  int i,j;
  int host_endian = host_is_big_endian();
  int hs;

  float **pcm;
  long samples;

  if(vf->ready_state<OPENED)return(OV_EINVAL);

  while(1){
	if(vf->ready_state==INITSET){
	  samples=vorbis_synthesis_pcmout(&vf->vd,&pcm);
	  if(samples)break;
	}

	/* suck in another packet */
	{
	  int ret=_fetch_and_process_packet(vf,NULL,1,1);
	  if(ret==OV_EOF)
		return(0);
	  if(ret<=0)
		return(ret);
	}

  }

  if(samples>0){

	/* yay! proceed to pack data into the byte buffer */

	long channels=ov_info(vf,-1)->channels;
	long bytespersample=word * channels;
	vorbis_fpu_control fpu;
	(void) fpu;
	if(samples>length/bytespersample)samples=length/bytespersample;

	if(samples <= 0)
	  return OV_EINVAL;

	/* Here. */
	if(filter)
	  filter(pcm,channels,samples,filter_param);

	/* a tight loop to pack each size */
	{
	  int val;
	  if(word==1){
		int off=(sgned?0:128);
		vorbis_fpu_setround(&fpu);
		for(j=0;j<samples;j++)
		  for(i=0;i<channels;i++){
			val=vorbis_ftoi(pcm[i][j]*128.f);
			if(val>127)val=127;
			else if(val<-128)val=-128;
			*buffer++=val+off;
		  }
		vorbis_fpu_restore(fpu);
	  }else{
		int off=(sgned?0:32768);

		if(host_endian==bigendianp){
		  if(sgned){

			vorbis_fpu_setround(&fpu);
			for(i=0;i<channels;i++) { /* It's faster in this order */
			  float *src=pcm[i];
			  short *dest=((short *)buffer)+i;
			  for(j=0;j<samples;j++) {
				val=vorbis_ftoi(src[j]*32768.f);
				if(val>32767)val=32767;
				else if(val<-32768)val=-32768;
				*dest=val;
				dest+=channels;
			  }
			}
			vorbis_fpu_restore(fpu);

		  }else{

			vorbis_fpu_setround(&fpu);
			for(i=0;i<channels;i++) {
			  float *src=pcm[i];
			  short *dest=((short *)buffer)+i;
			  for(j=0;j<samples;j++) {
				val=vorbis_ftoi(src[j]*32768.f);
				if(val>32767)val=32767;
				else if(val<-32768)val=-32768;
				*dest=val+off;
				dest+=channels;
			  }
			}
			vorbis_fpu_restore(fpu);

		  }
		}else if(bigendianp){

		  vorbis_fpu_setround(&fpu);
		  for(j=0;j<samples;j++)
			for(i=0;i<channels;i++){
			  val=vorbis_ftoi(pcm[i][j]*32768.f);
			  if(val>32767)val=32767;
			  else if(val<-32768)val=-32768;
			  val+=off;
			  *buffer++=(val>>8);
			  *buffer++=(val&0xff);
			}
		  vorbis_fpu_restore(fpu);

		}else{
		  int val;
		  vorbis_fpu_setround(&fpu);
		  for(j=0;j<samples;j++)
			for(i=0;i<channels;i++){
			  val=vorbis_ftoi(pcm[i][j]*32768.f);
			  if(val>32767)val=32767;
			  else if(val<-32768)val=-32768;
			  val+=off;
			  *buffer++=(val&0xff);
			  *buffer++=(val>>8);
				  }
		  vorbis_fpu_restore(fpu);

		}
	  }
	}

	vorbis_synthesis_read(&vf->vd,samples);
	hs=vorbis_synthesis_halfrate_p(vf->vi);
	vf->pcm_offset+=(samples<<hs);
	if(bitstream)*bitstream=vf->current_link;
	return(samples*bytespersample);
  }else{
	return(samples);
  }
}

long ov_read(OggVorbis_File *vf,char *buffer,int length,
			 int bigendianp,int word,int sgned,int *bitstream){
  return ov_read_filter(vf, buffer, length, bigendianp, word, sgned, bitstream, NULL, NULL);
}

/* input values: pcm_channels) a float vector per channel of output
				 length) the sample length being read by the app

   return values: <0) error/hole in data (OV_HOLE), partial open (OV_EINVAL)
				   0) EOF
				   n) number of samples of PCM actually returned.  The
				   below works on a packet-by-packet basis, so the
				   return length is not related to the 'length' passed
				   in, just guaranteed to fit.

			*section) set to the logical bitstream number */

long ov_read_float(OggVorbis_File *vf,float ***pcm_channels,int length,
				   int *bitstream){

  if(vf->ready_state<OPENED)return(OV_EINVAL);

  while(1){
	if(vf->ready_state==INITSET){
	  float **pcm;
	  long samples=vorbis_synthesis_pcmout(&vf->vd,&pcm);
	  if(samples){
		int hs=vorbis_synthesis_halfrate_p(vf->vi);
		if(pcm_channels)*pcm_channels=pcm;
		if(samples>length)samples=length;
		vorbis_synthesis_read(&vf->vd,samples);
		vf->pcm_offset+=samples<<hs;
		if(bitstream)*bitstream=vf->current_link;
		return samples;

	  }
	}

	/* suck in another packet */
	{
	  int ret=_fetch_and_process_packet(vf,NULL,1,1);
	  if(ret==OV_EOF)return(0);
	  if(ret<=0)return(ret);
	}

  }
}

extern float *vorbis_window(vorbis_dsp_state *v,int W);

static void _ov_splice(float **pcm,float **lappcm,
					   int n1, int n2,
					   int ch1, int ch2,
					   float *w1, float *w2){
  int i,j;
  float *w=w1;
  int n=n1;

  if(n1>n2){
	n=n2;
	w=w2;
  }

  /* splice */
  for(j=0;j<ch1 && j<ch2;j++){
	float *s=lappcm[j];
	float *d=pcm[j];

	for(i=0;i<n;i++){
	  float wd=w[i]*w[i];
	  float ws=1.-wd;
	  d[i]=d[i]*wd + s[i]*ws;
	}
  }
  /* window from zero */
  for(;j<ch2;j++){
	float *d=pcm[j];
	for(i=0;i<n;i++){
	  float wd=w[i]*w[i];
	  d[i]=d[i]*wd;
	}
  }

}

/* make sure vf is INITSET */
static int _ov_initset(OggVorbis_File *vf){
  while(1){
	if(vf->ready_state==INITSET)break;
	/* suck in another packet */
	{
	  int ret=_fetch_and_process_packet(vf,NULL,1,0);
	  if(ret<0 && ret!=OV_HOLE)return(ret);
	}
  }
  return 0;
}

/* make sure vf is INITSET and that we have a primed buffer; if
   we're crosslapping at a stream section boundary, this also makes
   sure we're sanity checking against the right stream information */
static int _ov_initprime(OggVorbis_File *vf){
  vorbis_dsp_state *vd=&vf->vd;
  while(1){
	if(vf->ready_state==INITSET)
	  if(vorbis_synthesis_pcmout(vd,NULL))break;

	/* suck in another packet */
	{
	  int ret=_fetch_and_process_packet(vf,NULL,1,0);
	  if(ret<0 && ret!=OV_HOLE)return(ret);
	}
  }
  return 0;
}

/* grab enough data for lapping from vf; this may be in the form of
   unreturned, already-decoded pcm, remaining PCM we will need to
   decode, or synthetic postextrapolation from last packets. */
static void _ov_getlap(OggVorbis_File *vf,vorbis_info *vi,vorbis_dsp_state *vd,
					   float **lappcm,int lapsize){
  int lapcount=0,i;
  float **pcm;

  /* try first to decode the lapping data */
  while(lapcount<lapsize){
	int samples=vorbis_synthesis_pcmout(vd,&pcm);
	if(samples){
	  if(samples>lapsize-lapcount)samples=lapsize-lapcount;
	  for(i=0;i<vi->channels;i++)
		memcpy(lappcm[i]+lapcount,pcm[i],sizeof(**pcm)*samples);
	  lapcount+=samples;
	  vorbis_synthesis_read(vd,samples);
	}else{
	/* suck in another packet */
	  int ret=_fetch_and_process_packet(vf,NULL,1,0); /* do *not* span */
	  if(ret==OV_EOF)break;
	}
  }
  if(lapcount<lapsize){
	/* failed to get lapping data from normal decode; pry it from the
	   postextrapolation buffering, or the second half of the MDCT
	   from the last packet */
	int samples=vorbis_synthesis_lapout(&vf->vd,&pcm);
	if(samples==0){
	  for(i=0;i<vi->channels;i++)
		memset(lappcm[i]+lapcount,0,sizeof(**pcm)*lapsize-lapcount);
	  lapcount=lapsize;
	}else{
	  if(samples>lapsize-lapcount)samples=lapsize-lapcount;
	  for(i=0;i<vi->channels;i++)
		memcpy(lappcm[i]+lapcount,pcm[i],sizeof(**pcm)*samples);
	  lapcount+=samples;
	}
  }
}

/* this sets up crosslapping of a sample by using trailing data from
   sample 1 and lapping it into the windowing buffer of sample 2 */
int ov_crosslap(OggVorbis_File *vf1, OggVorbis_File *vf2){
  vorbis_info *vi1,*vi2;
  float **lappcm;
  float **pcm;
  float *w1,*w2;
  int n1,n2,i,ret,hs1,hs2;

  if(vf1==vf2)return(0); /* degenerate case */
  if(vf1->ready_state<OPENED)return(OV_EINVAL);
  if(vf2->ready_state<OPENED)return(OV_EINVAL);

  /* the relevant overlap buffers must be pre-checked and pre-primed
	 before looking at settings in the event that priming would cross
	 a bitstream boundary.  So, do it now */

  ret=_ov_initset(vf1);
  if(ret)return(ret);
  ret=_ov_initprime(vf2);
  if(ret)return(ret);

  vi1=ov_info(vf1,-1);
  vi2=ov_info(vf2,-1);
  hs1=ov_halfrate_p(vf1);
  hs2=ov_halfrate_p(vf2);

  lappcm=(float**) alloca(sizeof(*lappcm)*vi1->channels);
  n1=vorbis_info_blocksize(vi1,0)>>(1+hs1);
  n2=vorbis_info_blocksize(vi2,0)>>(1+hs2);
  w1=vorbis_window(&vf1->vd,0);
  w2=vorbis_window(&vf2->vd,0);

  for(i=0;i<vi1->channels;i++)
	lappcm[i]=(float*) alloca(sizeof(**lappcm)*n1);

  _ov_getlap(vf1,vi1,&vf1->vd,lappcm,n1);

  /* have a lapping buffer from vf1; now to splice it into the lapping
	 buffer of vf2 */
  /* consolidate and expose the buffer. */
  vorbis_synthesis_lapout(&vf2->vd,&pcm);

#if 0
  _analysis_output_always("pcmL",0,pcm[0],n1*2,0,0,0);
  _analysis_output_always("pcmR",0,pcm[1],n1*2,0,0,0);
#endif

  /* splice */
  _ov_splice(pcm,lappcm,n1,n2,vi1->channels,vi2->channels,w1,w2);

  /* done */
  return(0);
}

static int _ov_64_seek_lap(OggVorbis_File *vf,ogg_int64_t pos,
						   int (*localseek)(OggVorbis_File *,ogg_int64_t)){
  vorbis_info *vi;
  float **lappcm;
  float **pcm;
  float *w1,*w2;
  int n1,n2,ch1,ch2,hs;
  int i,ret;

  if(vf->ready_state<OPENED)return(OV_EINVAL);
  ret=_ov_initset(vf);
  if(ret)return(ret);
  vi=ov_info(vf,-1);
  hs=ov_halfrate_p(vf);

  ch1=vi->channels;
  n1=vorbis_info_blocksize(vi,0)>>(1+hs);
  w1=vorbis_window(&vf->vd,0);  /* window arrays from libvorbis are
								   persistent; even if the decode state
								   from this link gets dumped, this
								   window array continues to exist */

  lappcm=(float**) alloca(sizeof(*lappcm)*ch1);
  for(i=0;i<ch1;i++)
	lappcm[i]=(float*) alloca(sizeof(**lappcm)*n1);
  _ov_getlap(vf,vi,&vf->vd,lappcm,n1);

  /* have lapping data; seek and prime the buffer */
  ret=localseek(vf,pos);
  if(ret)return ret;
  ret=_ov_initprime(vf);
  if(ret)return(ret);

 /* Guard against cross-link changes; they're perfectly legal */
  vi=ov_info(vf,-1);
  ch2=vi->channels;
  n2=vorbis_info_blocksize(vi,0)>>(1+hs);
  w2=vorbis_window(&vf->vd,0);

  /* consolidate and expose the buffer. */
  vorbis_synthesis_lapout(&vf->vd,&pcm);

  /* splice */
  _ov_splice(pcm,lappcm,n1,n2,ch1,ch2,w1,w2);

  /* done */
  return(0);
}

int ov_raw_seek_lap(OggVorbis_File *vf,ogg_int64_t pos){
  return _ov_64_seek_lap(vf,pos,ov_raw_seek);
}

int ov_pcm_seek_lap(OggVorbis_File *vf,ogg_int64_t pos){
  return _ov_64_seek_lap(vf,pos,ov_pcm_seek);
}

int ov_pcm_seek_page_lap(OggVorbis_File *vf,ogg_int64_t pos){
  return _ov_64_seek_lap(vf,pos,ov_pcm_seek_page);
}

static int _ov_d_seek_lap(OggVorbis_File *vf,double pos,
						   int (*localseek)(OggVorbis_File *,double)){
  vorbis_info *vi;
  float **lappcm;
  float **pcm;
  float *w1,*w2;
  int n1,n2,ch1,ch2,hs;
  int i,ret;

  if(vf->ready_state<OPENED)return(OV_EINVAL);
  ret=_ov_initset(vf);
  if(ret)return(ret);
  vi=ov_info(vf,-1);
  hs=ov_halfrate_p(vf);

  ch1=vi->channels;
  n1=vorbis_info_blocksize(vi,0)>>(1+hs);
  w1=vorbis_window(&vf->vd,0);  /* window arrays from libvorbis are
								   persistent; even if the decode state
								   from this link gets dumped, this
								   window array continues to exist */

  lappcm=(float**) alloca(sizeof(*lappcm)*ch1);
  for(i=0;i<ch1;i++)
	lappcm[i]=(float*) alloca(sizeof(**lappcm)*n1);
  _ov_getlap(vf,vi,&vf->vd,lappcm,n1);

  /* have lapping data; seek and prime the buffer */
  ret=localseek(vf,pos);
  if(ret)return ret;
  ret=_ov_initprime(vf);
  if(ret)return(ret);

 /* Guard against cross-link changes; they're perfectly legal */
  vi=ov_info(vf,-1);
  ch2=vi->channels;
  n2=vorbis_info_blocksize(vi,0)>>(1+hs);
  w2=vorbis_window(&vf->vd,0);

  /* consolidate and expose the buffer. */
  vorbis_synthesis_lapout(&vf->vd,&pcm);

  /* splice */
  _ov_splice(pcm,lappcm,n1,n2,ch1,ch2,w1,w2);

  /* done */
  return(0);
}

int ov_time_seek_lap(OggVorbis_File *vf,double pos){
  return _ov_d_seek_lap(vf,pos,ov_time_seek);
}

int ov_time_seek_page_lap(OggVorbis_File *vf,double pos){
  return _ov_d_seek_lap(vf,pos,ov_time_seek_page);
}

/*** End of inlined file: vorbisfile.c ***/


/*** Start of inlined file: window.c ***/
#include <stdlib.h>
#include <math.h>

static float vwin64[32] = {
  0.0009460463F, 0.0085006468F, 0.0235352254F, 0.0458950567F,
  0.0753351908F, 0.1115073077F, 0.1539457973F, 0.2020557475F,
  0.2551056759F, 0.3122276645F, 0.3724270287F, 0.4346027792F,
  0.4975789974F, 0.5601459521F, 0.6211085051F, 0.6793382689F,
  0.7338252629F, 0.7837245849F, 0.8283939355F, 0.8674186656F,
  0.9006222429F, 0.9280614787F, 0.9500073081F, 0.9669131782F,
  0.9793740220F, 0.9880792941F, 0.9937636139F, 0.9971582668F,
  0.9989462667F, 0.9997230082F, 0.9999638688F, 0.9999995525F,
};

static float vwin128[64] = {
  0.0002365472F, 0.0021280687F, 0.0059065254F, 0.0115626550F,
  0.0190823442F, 0.0284463735F, 0.0396300935F, 0.0526030430F,
  0.0673285281F, 0.0837631763F, 0.1018564887F, 0.1215504095F,
  0.1427789367F, 0.1654677960F, 0.1895342001F, 0.2148867160F,
  0.2414252576F, 0.2690412240F, 0.2976177952F, 0.3270303960F,
  0.3571473350F, 0.3878306189F, 0.4189369387F, 0.4503188188F,
  0.4818259135F, 0.5133064334F, 0.5446086751F, 0.5755826278F,
  0.6060816248F, 0.6359640047F, 0.6650947483F, 0.6933470543F,
  0.7206038179F, 0.7467589810F, 0.7717187213F, 0.7954024542F,
  0.8177436264F, 0.8386902831F, 0.8582053981F, 0.8762669622F,
  0.8928678298F, 0.9080153310F, 0.9217306608F, 0.9340480615F,
  0.9450138200F, 0.9546851041F, 0.9631286621F, 0.9704194171F,
  0.9766389810F, 0.9818741197F, 0.9862151938F, 0.9897546035F,
  0.9925852598F, 0.9947991032F, 0.9964856900F, 0.9977308602F,
  0.9986155015F, 0.9992144193F, 0.9995953200F, 0.9998179155F,
  0.9999331503F, 0.9999825563F, 0.9999977357F, 0.9999999720F,
};

static float vwin256[128] = {
  0.0000591390F, 0.0005321979F, 0.0014780301F, 0.0028960636F,
  0.0047854363F, 0.0071449926F, 0.0099732775F, 0.0132685298F,
  0.0170286741F, 0.0212513119F, 0.0259337111F, 0.0310727950F,
  0.0366651302F, 0.0427069140F, 0.0491939614F, 0.0561216907F,
  0.0634851102F, 0.0712788035F, 0.0794969160F, 0.0881331402F,
  0.0971807028F, 0.1066323515F, 0.1164803426F, 0.1267164297F,
  0.1373318534F, 0.1483173323F, 0.1596630553F, 0.1713586755F,
  0.1833933062F, 0.1957555184F, 0.2084333404F, 0.2214142599F,
  0.2346852280F, 0.2482326664F, 0.2620424757F, 0.2761000481F,
  0.2903902813F, 0.3048975959F, 0.3196059553F, 0.3344988887F,
  0.3495595160F, 0.3647705766F, 0.3801144597F, 0.3955732382F,
  0.4111287047F, 0.4267624093F, 0.4424557009F, 0.4581897696F,
  0.4739456913F, 0.4897044744F, 0.5054471075F, 0.5211546088F,
  0.5368080763F, 0.5523887395F, 0.5678780103F, 0.5832575361F,
  0.5985092508F, 0.6136154277F, 0.6285587300F, 0.6433222619F,
  0.6578896175F, 0.6722449294F, 0.6863729144F, 0.7002589187F,
  0.7138889597F, 0.7272497662F, 0.7403288154F, 0.7531143679F,
  0.7655954985F, 0.7777621249F, 0.7896050322F, 0.8011158947F,
  0.8122872932F, 0.8231127294F, 0.8335866365F, 0.8437043850F,
  0.8534622861F, 0.8628575905F, 0.8718884835F, 0.8805540765F,
  0.8888543947F, 0.8967903616F, 0.9043637797F, 0.9115773078F,
  0.9184344360F, 0.9249394562F, 0.9310974312F, 0.9369141608F,
  0.9423961446F, 0.9475505439F, 0.9523851406F, 0.9569082947F,
  0.9611289005F, 0.9650563408F, 0.9687004405F, 0.9720714191F,
  0.9751798427F, 0.9780365753F, 0.9806527301F, 0.9830396204F,
  0.9852087111F, 0.9871715701F, 0.9889398207F, 0.9905250941F,
  0.9919389832F, 0.9931929973F, 0.9942985174F, 0.9952667537F,
  0.9961087037F, 0.9968351119F, 0.9974564312F, 0.9979827858F,
  0.9984239359F, 0.9987892441F, 0.9990876435F, 0.9993276081F,
  0.9995171241F, 0.9996636648F, 0.9997741654F, 0.9998550016F,
  0.9999119692F, 0.9999502656F, 0.9999744742F, 0.9999885497F,
  0.9999958064F, 0.9999989077F, 0.9999998584F, 0.9999999983F,
};

static float vwin512[256] = {
  0.0000147849F, 0.0001330607F, 0.0003695946F, 0.0007243509F,
  0.0011972759F, 0.0017882983F, 0.0024973285F, 0.0033242588F,
  0.0042689632F, 0.0053312973F, 0.0065110982F, 0.0078081841F,
  0.0092223540F, 0.0107533880F, 0.0124010466F, 0.0141650703F,
  0.0160451800F, 0.0180410758F, 0.0201524373F, 0.0223789233F,
  0.0247201710F, 0.0271757958F, 0.0297453914F, 0.0324285286F,
  0.0352247556F, 0.0381335972F, 0.0411545545F, 0.0442871045F,
  0.0475306997F, 0.0508847676F, 0.0543487103F, 0.0579219038F,
  0.0616036982F, 0.0653934164F, 0.0692903546F, 0.0732937809F,
  0.0774029356F, 0.0816170305F, 0.0859352485F, 0.0903567428F,
  0.0948806375F, 0.0995060259F, 0.1042319712F, 0.1090575056F,
  0.1139816300F, 0.1190033137F, 0.1241214941F, 0.1293350764F,
  0.1346429333F, 0.1400439046F, 0.1455367974F, 0.1511203852F,
  0.1567934083F, 0.1625545735F, 0.1684025537F, 0.1743359881F,
  0.1803534820F, 0.1864536069F, 0.1926349000F, 0.1988958650F,
  0.2052349715F, 0.2116506555F, 0.2181413191F, 0.2247053313F,
  0.2313410275F, 0.2380467105F, 0.2448206500F, 0.2516610835F,
  0.2585662164F, 0.2655342226F, 0.2725632448F, 0.2796513950F,
  0.2867967551F, 0.2939973773F, 0.3012512852F, 0.3085564739F,
  0.3159109111F, 0.3233125375F, 0.3307592680F, 0.3382489922F,
  0.3457795756F, 0.3533488602F, 0.3609546657F, 0.3685947904F,
  0.3762670121F, 0.3839690896F, 0.3916987634F, 0.3994537572F,
  0.4072317788F, 0.4150305215F, 0.4228476653F, 0.4306808783F,
  0.4385278181F, 0.4463861329F, 0.4542534630F, 0.4621274424F,
  0.4700057001F, 0.4778858615F, 0.4857655502F, 0.4936423891F,
  0.5015140023F, 0.5093780165F, 0.5172320626F, 0.5250737772F,
  0.5329008043F, 0.5407107971F, 0.5485014192F, 0.5562703465F,
  0.5640152688F, 0.5717338914F, 0.5794239366F, 0.5870831457F,
  0.5947092801F, 0.6023001235F, 0.6098534829F, 0.6173671907F,
  0.6248391059F, 0.6322671161F, 0.6396491384F, 0.6469831217F,
  0.6542670475F, 0.6614989319F, 0.6686768267F, 0.6757988210F,
  0.6828630426F, 0.6898676592F, 0.6968108799F, 0.7036909564F,
  0.7105061843F, 0.7172549043F, 0.7239355032F, 0.7305464154F,
  0.7370861235F, 0.7435531598F, 0.7499461068F, 0.7562635986F,
  0.7625043214F, 0.7686670148F, 0.7747504721F, 0.7807535410F,
  0.7866751247F, 0.7925141825F, 0.7982697296F, 0.8039408387F,
  0.8095266395F, 0.8150263196F, 0.8204391248F, 0.8257643590F,
  0.8310013848F, 0.8361496236F, 0.8412085555F, 0.8461777194F,
  0.8510567129F, 0.8558451924F, 0.8605428730F, 0.8651495278F,
  0.8696649882F, 0.8740891432F, 0.8784219392F, 0.8826633797F,
  0.8868135244F, 0.8908724888F, 0.8948404441F, 0.8987176157F,
  0.9025042831F, 0.9062007791F, 0.9098074886F, 0.9133248482F,
  0.9167533451F, 0.9200935163F, 0.9233459472F, 0.9265112712F,
  0.9295901680F, 0.9325833632F, 0.9354916263F, 0.9383157705F,
  0.9410566504F, 0.9437151618F, 0.9462922398F, 0.9487888576F,
  0.9512060252F, 0.9535447882F, 0.9558062262F, 0.9579914516F,
  0.9601016078F, 0.9621378683F, 0.9641014348F, 0.9659935361F,
  0.9678154261F, 0.9695683830F, 0.9712537071F, 0.9728727198F,
  0.9744267618F, 0.9759171916F, 0.9773453842F, 0.9787127293F,
  0.9800206298F, 0.9812705006F, 0.9824637665F, 0.9836018613F,
  0.9846862258F, 0.9857183066F, 0.9866995544F, 0.9876314227F,
  0.9885153662F, 0.9893528393F, 0.9901452948F, 0.9908941823F,
  0.9916009470F, 0.9922670279F, 0.9928938570F, 0.9934828574F,
  0.9940354423F, 0.9945530133F, 0.9950369595F, 0.9954886562F,
  0.9959094633F, 0.9963007242F, 0.9966637649F, 0.9969998925F,
  0.9973103939F, 0.9975965351F, 0.9978595598F, 0.9981006885F,
  0.9983211172F, 0.9985220166F, 0.9987045311F, 0.9988697776F,
  0.9990188449F, 0.9991527924F, 0.9992726499F, 0.9993794157F,
  0.9994740570F, 0.9995575079F, 0.9996306699F, 0.9996944099F,
  0.9997495605F, 0.9997969190F, 0.9998372465F, 0.9998712678F,
  0.9998996704F, 0.9999231041F, 0.9999421807F, 0.9999574732F,
  0.9999695157F, 0.9999788026F, 0.9999857885F, 0.9999908879F,
  0.9999944746F, 0.9999968817F, 0.9999984010F, 0.9999992833F,
  0.9999997377F, 0.9999999317F, 0.9999999911F, 0.9999999999F,
};

static float vwin1024[512] = {
  0.0000036962F, 0.0000332659F, 0.0000924041F, 0.0001811086F,
  0.0002993761F, 0.0004472021F, 0.0006245811F, 0.0008315063F,
  0.0010679699F, 0.0013339631F, 0.0016294757F, 0.0019544965F,
  0.0023090133F, 0.0026930125F, 0.0031064797F, 0.0035493989F,
  0.0040217533F, 0.0045235250F, 0.0050546946F, 0.0056152418F,
  0.0062051451F, 0.0068243817F, 0.0074729278F, 0.0081507582F,
  0.0088578466F, 0.0095941655F, 0.0103596863F, 0.0111543789F,
  0.0119782122F, 0.0128311538F, 0.0137131701F, 0.0146242260F,
  0.0155642855F, 0.0165333111F, 0.0175312640F, 0.0185581042F,
  0.0196137903F, 0.0206982797F, 0.0218115284F, 0.0229534910F,
  0.0241241208F, 0.0253233698F, 0.0265511886F, 0.0278075263F,
  0.0290923308F, 0.0304055484F, 0.0317471241F, 0.0331170013F,
  0.0345151222F, 0.0359414274F, 0.0373958560F, 0.0388783456F,
  0.0403888325F, 0.0419272511F, 0.0434935347F, 0.0450876148F,
  0.0467094213F, 0.0483588828F, 0.0500359261F, 0.0517404765F,
  0.0534724575F, 0.0552317913F, 0.0570183983F, 0.0588321971F,
  0.0606731048F, 0.0625410369F, 0.0644359070F, 0.0663576272F,
  0.0683061077F, 0.0702812571F, 0.0722829821F, 0.0743111878F,
  0.0763657775F, 0.0784466526F, 0.0805537129F, 0.0826868561F,
  0.0848459782F, 0.0870309736F, 0.0892417345F, 0.0914781514F,
  0.0937401128F, 0.0960275056F, 0.0983402145F, 0.1006781223F,
  0.1030411101F, 0.1054290568F, 0.1078418397F, 0.1102793336F,
  0.1127414119F, 0.1152279457F, 0.1177388042F, 0.1202738544F,
  0.1228329618F, 0.1254159892F, 0.1280227980F, 0.1306532471F,
  0.1333071937F, 0.1359844927F, 0.1386849970F, 0.1414085575F,
  0.1441550230F, 0.1469242403F, 0.1497160539F, 0.1525303063F,
  0.1553668381F, 0.1582254875F, 0.1611060909F, 0.1640084822F,
  0.1669324936F, 0.1698779549F, 0.1728446939F, 0.1758325362F,
  0.1788413055F, 0.1818708232F, 0.1849209084F, 0.1879913785F,
  0.1910820485F, 0.1941927312F, 0.1973232376F, 0.2004733764F,
  0.2036429541F, 0.2068317752F, 0.2100396421F, 0.2132663552F,
  0.2165117125F, 0.2197755102F, 0.2230575422F, 0.2263576007F,
  0.2296754753F, 0.2330109540F, 0.2363638225F, 0.2397338646F,
  0.2431208619F, 0.2465245941F, 0.2499448389F, 0.2533813719F,
  0.2568339669F, 0.2603023956F, 0.2637864277F, 0.2672858312F,
  0.2708003718F, 0.2743298135F, 0.2778739186F, 0.2814324472F,
  0.2850051576F, 0.2885918065F, 0.2921921485F, 0.2958059366F,
  0.2994329219F, 0.3030728538F, 0.3067254799F, 0.3103905462F,
  0.3140677969F, 0.3177569747F, 0.3214578205F, 0.3251700736F,
  0.3288934718F, 0.3326277513F, 0.3363726468F, 0.3401278914F,
  0.3438932168F, 0.3476683533F, 0.3514530297F, 0.3552469734F,
  0.3590499106F, 0.3628615659F, 0.3666816630F, 0.3705099239F,
  0.3743460698F, 0.3781898204F, 0.3820408945F, 0.3858990095F,
  0.3897638820F, 0.3936352274F, 0.3975127601F, 0.4013961936F,
  0.4052852405F, 0.4091796123F, 0.4130790198F, 0.4169831732F,
  0.4208917815F, 0.4248045534F, 0.4287211965F, 0.4326414181F,
  0.4365649248F, 0.4404914225F, 0.4444206167F, 0.4483522125F,
  0.4522859146F, 0.4562214270F, 0.4601584538F, 0.4640966984F,
  0.4680358644F, 0.4719756548F, 0.4759157726F, 0.4798559209F,
  0.4837958024F, 0.4877351199F, 0.4916735765F, 0.4956108751F,
  0.4995467188F, 0.5034808109F, 0.5074128550F, 0.5113425550F,
  0.5152696149F, 0.5191937395F, 0.5231146336F, 0.5270320028F,
  0.5309455530F, 0.5348549910F, 0.5387600239F, 0.5426603597F,
  0.5465557070F, 0.5504457754F, 0.5543302752F, 0.5582089175F,
  0.5620814145F, 0.5659474793F, 0.5698068262F, 0.5736591704F,
  0.5775042283F, 0.5813417176F, 0.5851713571F, 0.5889928670F,
  0.5928059689F, 0.5966103856F, 0.6004058415F, 0.6041920626F,
  0.6079687761F, 0.6117357113F, 0.6154925986F, 0.6192391705F,
  0.6229751612F, 0.6267003064F, 0.6304143441F, 0.6341170137F,
  0.6378080569F, 0.6414872173F, 0.6451542405F, 0.6488088741F,
  0.6524508681F, 0.6560799742F, 0.6596959469F, 0.6632985424F,
  0.6668875197F, 0.6704626398F, 0.6740236662F, 0.6775703649F,
  0.6811025043F, 0.6846198554F, 0.6881221916F, 0.6916092892F,
  0.6950809269F, 0.6985368861F, 0.7019769510F, 0.7054009085F,
  0.7088085484F, 0.7121996632F, 0.7155740484F, 0.7189315023F,
  0.7222718263F, 0.7255948245F, 0.7289003043F, 0.7321880760F,
  0.7354579530F, 0.7387097518F, 0.7419432921F, 0.7451583966F,
  0.7483548915F, 0.7515326059F, 0.7546913723F, 0.7578310265F,
  0.7609514077F, 0.7640523581F, 0.7671337237F, 0.7701953535F,
  0.7732371001F, 0.7762588195F, 0.7792603711F, 0.7822416178F,
  0.7852024259F, 0.7881426654F, 0.7910622097F, 0.7939609356F,
  0.7968387237F, 0.7996954579F, 0.8025310261F, 0.8053453193F,
  0.8081382324F, 0.8109096638F, 0.8136595156F, 0.8163876936F,
  0.8190941071F, 0.8217786690F, 0.8244412960F, 0.8270819086F,
  0.8297004305F, 0.8322967896F, 0.8348709171F, 0.8374227481F,
  0.8399522213F, 0.8424592789F, 0.8449438672F, 0.8474059356F,
  0.8498454378F, 0.8522623306F, 0.8546565748F, 0.8570281348F,
  0.8593769787F, 0.8617030779F, 0.8640064080F, 0.8662869477F,
  0.8685446796F, 0.8707795899F, 0.8729916682F, 0.8751809079F,
  0.8773473059F, 0.8794908626F, 0.8816115819F, 0.8837094713F,
  0.8857845418F, 0.8878368079F, 0.8898662874F, 0.8918730019F,
  0.8938569760F, 0.8958182380F, 0.8977568194F, 0.8996727552F,
  0.9015660837F, 0.9034368465F, 0.9052850885F, 0.9071108577F,
  0.9089142057F, 0.9106951869F, 0.9124538591F, 0.9141902832F,
  0.9159045233F, 0.9175966464F, 0.9192667228F, 0.9209148257F,
  0.9225410313F, 0.9241454187F, 0.9257280701F, 0.9272890704F,
  0.9288285075F, 0.9303464720F, 0.9318430576F, 0.9333183603F,
  0.9347724792F, 0.9362055158F, 0.9376175745F, 0.9390087622F,
  0.9403791881F, 0.9417289644F, 0.9430582055F, 0.9443670283F,
  0.9456555521F, 0.9469238986F, 0.9481721917F, 0.9494005577F,
  0.9506091252F, 0.9517980248F, 0.9529673894F, 0.9541173540F,
  0.9552480557F, 0.9563596334F, 0.9574522282F, 0.9585259830F,
  0.9595810428F, 0.9606175542F, 0.9616356656F, 0.9626355274F,
  0.9636172915F, 0.9645811114F, 0.9655271425F, 0.9664555414F,
  0.9673664664F, 0.9682600774F, 0.9691365355F, 0.9699960034F,
  0.9708386448F, 0.9716646250F, 0.9724741103F, 0.9732672685F,
  0.9740442683F, 0.9748052795F, 0.9755504729F, 0.9762800205F,
  0.9769940950F, 0.9776928703F, 0.9783765210F, 0.9790452223F,
  0.9796991504F, 0.9803384823F, 0.9809633954F, 0.9815740679F,
  0.9821706784F, 0.9827534063F, 0.9833224312F, 0.9838779332F,
  0.9844200928F, 0.9849490910F, 0.9854651087F, 0.9859683274F,
  0.9864589286F, 0.9869370940F, 0.9874030054F, 0.9878568447F,
  0.9882987937F, 0.9887290343F, 0.9891477481F, 0.9895551169F,
  0.9899513220F, 0.9903365446F, 0.9907109658F, 0.9910747662F,
  0.9914281260F, 0.9917712252F, 0.9921042433F, 0.9924273593F,
  0.9927407516F, 0.9930445982F, 0.9933390763F, 0.9936243626F,
  0.9939006331F, 0.9941680631F, 0.9944268269F, 0.9946770982F,
  0.9949190498F, 0.9951528537F, 0.9953786808F, 0.9955967011F,
  0.9958070836F, 0.9960099963F, 0.9962056061F, 0.9963940787F,
  0.9965755786F, 0.9967502693F, 0.9969183129F, 0.9970798704F,
  0.9972351013F, 0.9973841640F, 0.9975272151F, 0.9976644103F,
  0.9977959036F, 0.9979218476F, 0.9980423932F, 0.9981576901F,
  0.9982678862F, 0.9983731278F, 0.9984735596F, 0.9985693247F,
  0.9986605645F, 0.9987474186F, 0.9988300248F, 0.9989085193F,
  0.9989830364F, 0.9990537085F, 0.9991206662F, 0.9991840382F,
  0.9992439513F, 0.9993005303F, 0.9993538982F, 0.9994041757F,
  0.9994514817F, 0.9994959330F, 0.9995376444F, 0.9995767286F,
  0.9996132960F, 0.9996474550F, 0.9996793121F, 0.9997089710F,
  0.9997365339F, 0.9997621003F, 0.9997857677F, 0.9998076311F,
  0.9998277836F, 0.9998463156F, 0.9998633155F, 0.9998788692F,
  0.9998930603F, 0.9999059701F, 0.9999176774F, 0.9999282586F,
  0.9999377880F, 0.9999463370F, 0.9999539749F, 0.9999607685F,
  0.9999667820F, 0.9999720773F, 0.9999767136F, 0.9999807479F,
  0.9999842344F, 0.9999872249F, 0.9999897688F, 0.9999919127F,
  0.9999937009F, 0.9999951749F, 0.9999963738F, 0.9999973342F,
  0.9999980900F, 0.9999986724F, 0.9999991103F, 0.9999994297F,
  0.9999996543F, 0.9999998049F, 0.9999999000F, 0.9999999552F,
  0.9999999836F, 0.9999999957F, 0.9999999994F, 1.0000000000F,
};

static float vwin2048[1024] = {
  0.0000009241F, 0.0000083165F, 0.0000231014F, 0.0000452785F,
  0.0000748476F, 0.0001118085F, 0.0001561608F, 0.0002079041F,
  0.0002670379F, 0.0003335617F, 0.0004074748F, 0.0004887765F,
  0.0005774661F, 0.0006735427F, 0.0007770054F, 0.0008878533F,
  0.0010060853F, 0.0011317002F, 0.0012646969F, 0.0014050742F,
  0.0015528307F, 0.0017079650F, 0.0018704756F, 0.0020403610F,
  0.0022176196F, 0.0024022497F, 0.0025942495F, 0.0027936173F,
  0.0030003511F, 0.0032144490F, 0.0034359088F, 0.0036647286F,
  0.0039009061F, 0.0041444391F, 0.0043953253F, 0.0046535621F,
  0.0049191472F, 0.0051920781F, 0.0054723520F, 0.0057599664F,
  0.0060549184F, 0.0063572052F, 0.0066668239F, 0.0069837715F,
  0.0073080449F, 0.0076396410F, 0.0079785566F, 0.0083247884F,
  0.0086783330F, 0.0090391871F, 0.0094073470F, 0.0097828092F,
  0.0101655700F, 0.0105556258F, 0.0109529726F, 0.0113576065F,
  0.0117695237F, 0.0121887200F, 0.0126151913F, 0.0130489335F,
  0.0134899422F, 0.0139382130F, 0.0143937415F, 0.0148565233F,
  0.0153265536F, 0.0158038279F, 0.0162883413F, 0.0167800889F,
  0.0172790660F, 0.0177852675F, 0.0182986882F, 0.0188193231F,
  0.0193471668F, 0.0198822141F, 0.0204244594F, 0.0209738974F,
  0.0215305225F, 0.0220943289F, 0.0226653109F, 0.0232434627F,
  0.0238287784F, 0.0244212519F, 0.0250208772F, 0.0256276481F,
  0.0262415582F, 0.0268626014F, 0.0274907711F, 0.0281260608F,
  0.0287684638F, 0.0294179736F, 0.0300745833F, 0.0307382859F,
  0.0314090747F, 0.0320869424F, 0.0327718819F, 0.0334638860F,
  0.0341629474F, 0.0348690586F, 0.0355822122F, 0.0363024004F,
  0.0370296157F, 0.0377638502F, 0.0385050960F, 0.0392533451F,
  0.0400085896F, 0.0407708211F, 0.0415400315F, 0.0423162123F,
  0.0430993552F, 0.0438894515F, 0.0446864926F, 0.0454904698F,
  0.0463013742F, 0.0471191969F, 0.0479439288F, 0.0487755607F,
  0.0496140836F, 0.0504594879F, 0.0513117642F, 0.0521709031F,
  0.0530368949F, 0.0539097297F, 0.0547893979F, 0.0556758894F,
  0.0565691941F, 0.0574693019F, 0.0583762026F, 0.0592898858F,
  0.0602103410F, 0.0611375576F, 0.0620715250F, 0.0630122324F,
  0.0639596688F, 0.0649138234F, 0.0658746848F, 0.0668422421F,
  0.0678164838F, 0.0687973985F, 0.0697849746F, 0.0707792005F,
  0.0717800645F, 0.0727875547F, 0.0738016591F, 0.0748223656F,
  0.0758496620F, 0.0768835359F, 0.0779239751F, 0.0789709668F,
  0.0800244985F, 0.0810845574F, 0.0821511306F, 0.0832242052F,
  0.0843037679F, 0.0853898056F, 0.0864823050F, 0.0875812525F,
  0.0886866347F, 0.0897984378F, 0.0909166480F, 0.0920412513F,
  0.0931722338F, 0.0943095813F, 0.0954532795F, 0.0966033140F,
  0.0977596702F, 0.0989223336F, 0.1000912894F, 0.1012665227F,
  0.1024480185F, 0.1036357616F, 0.1048297369F, 0.1060299290F,
  0.1072363224F, 0.1084489014F, 0.1096676504F, 0.1108925534F,
  0.1121235946F, 0.1133607577F, 0.1146040267F, 0.1158533850F,
  0.1171088163F, 0.1183703040F, 0.1196378312F, 0.1209113812F,
  0.1221909370F, 0.1234764815F, 0.1247679974F, 0.1260654674F,
  0.1273688740F, 0.1286781995F, 0.1299934263F, 0.1313145365F,
  0.1326415121F, 0.1339743349F, 0.1353129866F, 0.1366574490F,
  0.1380077035F, 0.1393637315F, 0.1407255141F, 0.1420930325F,
  0.1434662677F, 0.1448452004F, 0.1462298115F, 0.1476200814F,
  0.1490159906F, 0.1504175195F, 0.1518246482F, 0.1532373569F,
  0.1546556253F, 0.1560794333F, 0.1575087606F, 0.1589435866F,
  0.1603838909F, 0.1618296526F, 0.1632808509F, 0.1647374648F,
  0.1661994731F, 0.1676668546F, 0.1691395880F, 0.1706176516F,
  0.1721010238F, 0.1735896829F, 0.1750836068F, 0.1765827736F,
  0.1780871610F, 0.1795967468F, 0.1811115084F, 0.1826314234F,
  0.1841564689F, 0.1856866221F, 0.1872218600F, 0.1887621595F,
  0.1903074974F, 0.1918578503F, 0.1934131947F, 0.1949735068F,
  0.1965387630F, 0.1981089393F, 0.1996840117F, 0.2012639560F,
  0.2028487479F, 0.2044383630F, 0.2060327766F, 0.2076319642F,
  0.2092359007F, 0.2108445614F, 0.2124579211F, 0.2140759545F,
  0.2156986364F, 0.2173259411F, 0.2189578432F, 0.2205943168F,
  0.2222353361F, 0.2238808751F, 0.2255309076F, 0.2271854073F,
  0.2288443480F, 0.2305077030F, 0.2321754457F, 0.2338475493F,
  0.2355239869F, 0.2372047315F, 0.2388897560F, 0.2405790329F,
  0.2422725350F, 0.2439702347F, 0.2456721043F, 0.2473781159F,
  0.2490882418F, 0.2508024539F, 0.2525207240F, 0.2542430237F,
  0.2559693248F, 0.2576995986F, 0.2594338166F, 0.2611719498F,
  0.2629139695F, 0.2646598466F, 0.2664095520F, 0.2681630564F,
  0.2699203304F, 0.2716813445F, 0.2734460691F, 0.2752144744F,
  0.2769865307F, 0.2787622079F, 0.2805414760F, 0.2823243047F,
  0.2841106637F, 0.2859005227F, 0.2876938509F, 0.2894906179F,
  0.2912907928F, 0.2930943447F, 0.2949012426F, 0.2967114554F,
  0.2985249520F, 0.3003417009F, 0.3021616708F, 0.3039848301F,
  0.3058111471F, 0.3076405901F, 0.3094731273F, 0.3113087266F,
  0.3131473560F, 0.3149889833F, 0.3168335762F, 0.3186811024F,
  0.3205315294F, 0.3223848245F, 0.3242409552F, 0.3260998886F,
  0.3279615918F, 0.3298260319F, 0.3316931758F, 0.3335629903F,
  0.3354354423F, 0.3373104982F, 0.3391881247F, 0.3410682882F,
  0.3429509551F, 0.3448360917F, 0.3467236642F, 0.3486136387F,
  0.3505059811F, 0.3524006575F, 0.3542976336F, 0.3561968753F,
  0.3580983482F, 0.3600020179F, 0.3619078499F, 0.3638158096F,
  0.3657258625F, 0.3676379737F, 0.3695521086F, 0.3714682321F,
  0.3733863094F, 0.3753063055F, 0.3772281852F, 0.3791519134F,
  0.3810774548F, 0.3830047742F, 0.3849338362F, 0.3868646053F,
  0.3887970459F, 0.3907311227F, 0.3926667998F, 0.3946040417F,
  0.3965428125F, 0.3984830765F, 0.4004247978F, 0.4023679403F,
  0.4043124683F, 0.4062583455F, 0.4082055359F, 0.4101540034F,
  0.4121037117F, 0.4140546246F, 0.4160067058F, 0.4179599190F,
  0.4199142277F, 0.4218695956F, 0.4238259861F, 0.4257833627F,
  0.4277416888F, 0.4297009279F, 0.4316610433F, 0.4336219983F,
  0.4355837562F, 0.4375462803F, 0.4395095337F, 0.4414734797F,
  0.4434380815F, 0.4454033021F, 0.4473691046F, 0.4493354521F,
  0.4513023078F, 0.4532696345F, 0.4552373954F, 0.4572055533F,
  0.4591740713F, 0.4611429123F, 0.4631120393F, 0.4650814151F,
  0.4670510028F, 0.4690207650F, 0.4709906649F, 0.4729606651F,
  0.4749307287F, 0.4769008185F, 0.4788708972F, 0.4808409279F,
  0.4828108732F, 0.4847806962F, 0.4867503597F, 0.4887198264F,
  0.4906890593F, 0.4926580213F, 0.4946266753F, 0.4965949840F,
  0.4985629105F, 0.5005304176F, 0.5024974683F, 0.5044640255F,
  0.5064300522F, 0.5083955114F, 0.5103603659F, 0.5123245790F,
  0.5142881136F, 0.5162509328F, 0.5182129997F, 0.5201742774F,
  0.5221347290F, 0.5240943178F, 0.5260530070F, 0.5280107598F,
  0.5299675395F, 0.5319233095F, 0.5338780330F, 0.5358316736F,
  0.5377841946F, 0.5397355596F, 0.5416857320F, 0.5436346755F,
  0.5455823538F, 0.5475287304F, 0.5494737691F, 0.5514174337F,
  0.5533596881F, 0.5553004962F, 0.5572398218F, 0.5591776291F,
  0.5611138821F, 0.5630485449F, 0.5649815818F, 0.5669129570F,
  0.5688426349F, 0.5707705799F, 0.5726967564F, 0.5746211290F,
  0.5765436624F, 0.5784643212F, 0.5803830702F, 0.5822998743F,
  0.5842146984F, 0.5861275076F, 0.5880382669F, 0.5899469416F,
  0.5918534968F, 0.5937578981F, 0.5956601107F, 0.5975601004F,
  0.5994578326F, 0.6013532732F, 0.6032463880F, 0.6051371429F,
  0.6070255039F, 0.6089114372F, 0.6107949090F, 0.6126758856F,
  0.6145543334F, 0.6164302191F, 0.6183035092F, 0.6201741706F,
  0.6220421700F, 0.6239074745F, 0.6257700513F, 0.6276298674F,
  0.6294868903F, 0.6313410873F, 0.6331924262F, 0.6350408745F,
  0.6368864001F, 0.6387289710F, 0.6405685552F, 0.6424051209F,
  0.6442386364F, 0.6460690702F, 0.6478963910F, 0.6497205673F,
  0.6515415682F, 0.6533593625F, 0.6551739194F, 0.6569852082F,
  0.6587931984F, 0.6605978593F, 0.6623991609F, 0.6641970728F,
  0.6659915652F, 0.6677826081F, 0.6695701718F, 0.6713542268F,
  0.6731347437F, 0.6749116932F, 0.6766850461F, 0.6784547736F,
  0.6802208469F, 0.6819832374F, 0.6837419164F, 0.6854968559F,
  0.6872480275F, 0.6889954034F, 0.6907389556F, 0.6924786566F,
  0.6942144788F, 0.6959463950F, 0.6976743780F, 0.6993984008F,
  0.7011184365F, 0.7028344587F, 0.7045464407F, 0.7062543564F,
  0.7079581796F, 0.7096578844F, 0.7113534450F, 0.7130448359F,
  0.7147320316F, 0.7164150070F, 0.7180937371F, 0.7197681970F,
  0.7214383620F, 0.7231042077F, 0.7247657098F, 0.7264228443F,
  0.7280755871F, 0.7297239147F, 0.7313678035F, 0.7330072301F,
  0.7346421715F, 0.7362726046F, 0.7378985069F, 0.7395198556F,
  0.7411366285F, 0.7427488034F, 0.7443563584F, 0.7459592717F,
  0.7475575218F, 0.7491510873F, 0.7507399471F, 0.7523240803F,
  0.7539034661F, 0.7554780839F, 0.7570479136F, 0.7586129349F,
  0.7601731279F, 0.7617284730F, 0.7632789506F, 0.7648245416F,
  0.7663652267F, 0.7679009872F, 0.7694318044F, 0.7709576599F,
  0.7724785354F, 0.7739944130F, 0.7755052749F, 0.7770111035F,
  0.7785118815F, 0.7800075916F, 0.7814982170F, 0.7829837410F,
  0.7844641472F, 0.7859394191F, 0.7874095408F, 0.7888744965F,
  0.7903342706F, 0.7917888476F, 0.7932382124F, 0.7946823501F,
  0.7961212460F, 0.7975548855F, 0.7989832544F, 0.8004063386F,
  0.8018241244F, 0.8032365981F, 0.8046437463F, 0.8060455560F,
  0.8074420141F, 0.8088331080F, 0.8102188253F, 0.8115991536F,
  0.8129740810F, 0.8143435957F, 0.8157076861F, 0.8170663409F,
  0.8184195489F, 0.8197672994F, 0.8211095817F, 0.8224463853F,
  0.8237777001F, 0.8251035161F, 0.8264238235F, 0.8277386129F,
  0.8290478750F, 0.8303516008F, 0.8316497814F, 0.8329424083F,
  0.8342294731F, 0.8355109677F, 0.8367868841F, 0.8380572148F,
  0.8393219523F, 0.8405810893F, 0.8418346190F, 0.8430825345F,
  0.8443248294F, 0.8455614974F, 0.8467925323F, 0.8480179285F,
  0.8492376802F, 0.8504517822F, 0.8516602292F, 0.8528630164F,
  0.8540601391F, 0.8552515928F, 0.8564373733F, 0.8576174766F,
  0.8587918990F, 0.8599606368F, 0.8611236868F, 0.8622810460F,
  0.8634327113F, 0.8645786802F, 0.8657189504F, 0.8668535195F,
  0.8679823857F, 0.8691055472F, 0.8702230025F, 0.8713347503F,
  0.8724407896F, 0.8735411194F, 0.8746357394F, 0.8757246489F,
  0.8768078479F, 0.8778853364F, 0.8789571146F, 0.8800231832F,
  0.8810835427F, 0.8821381942F, 0.8831871387F, 0.8842303777F,
  0.8852679127F, 0.8862997456F, 0.8873258784F, 0.8883463132F,
  0.8893610527F, 0.8903700994F, 0.8913734562F, 0.8923711263F,
  0.8933631129F, 0.8943494196F, 0.8953300500F, 0.8963050083F,
  0.8972742985F, 0.8982379249F, 0.8991958922F, 0.9001482052F,
  0.9010948688F, 0.9020358883F, 0.9029712690F, 0.9039010165F,
  0.9048251367F, 0.9057436357F, 0.9066565195F, 0.9075637946F,
  0.9084654678F, 0.9093615456F, 0.9102520353F, 0.9111369440F,
  0.9120162792F, 0.9128900484F, 0.9137582595F, 0.9146209204F,
  0.9154780394F, 0.9163296248F, 0.9171756853F, 0.9180162296F,
  0.9188512667F, 0.9196808057F, 0.9205048559F, 0.9213234270F,
  0.9221365285F, 0.9229441704F, 0.9237463629F, 0.9245431160F,
  0.9253344404F, 0.9261203465F, 0.9269008453F, 0.9276759477F,
  0.9284456648F, 0.9292100080F, 0.9299689889F, 0.9307226190F,
  0.9314709103F, 0.9322138747F, 0.9329515245F, 0.9336838721F,
  0.9344109300F, 0.9351327108F, 0.9358492275F, 0.9365604931F,
  0.9372665208F, 0.9379673239F, 0.9386629160F, 0.9393533107F,
  0.9400385220F, 0.9407185637F, 0.9413934501F, 0.9420631954F,
  0.9427278141F, 0.9433873208F, 0.9440417304F, 0.9446910576F,
  0.9453353176F, 0.9459745255F, 0.9466086968F, 0.9472378469F,
  0.9478619915F, 0.9484811463F, 0.9490953274F, 0.9497045506F,
  0.9503088323F, 0.9509081888F, 0.9515026365F, 0.9520921921F,
  0.9526768723F, 0.9532566940F, 0.9538316742F, 0.9544018300F,
  0.9549671786F, 0.9555277375F, 0.9560835241F, 0.9566345562F,
  0.9571808513F, 0.9577224275F, 0.9582593027F, 0.9587914949F,
  0.9593190225F, 0.9598419038F, 0.9603601571F, 0.9608738012F,
  0.9613828546F, 0.9618873361F, 0.9623872646F, 0.9628826591F,
  0.9633735388F, 0.9638599227F, 0.9643418303F, 0.9648192808F,
  0.9652922939F, 0.9657608890F, 0.9662250860F, 0.9666849046F,
  0.9671403646F, 0.9675914861F, 0.9680382891F, 0.9684807937F,
  0.9689190202F, 0.9693529890F, 0.9697827203F, 0.9702082347F,
  0.9706295529F, 0.9710466953F, 0.9714596828F, 0.9718685362F,
  0.9722732762F, 0.9726739240F, 0.9730705005F, 0.9734630267F,
  0.9738515239F, 0.9742360134F, 0.9746165163F, 0.9749930540F,
  0.9753656481F, 0.9757343198F, 0.9760990909F, 0.9764599829F,
  0.9768170175F, 0.9771702164F, 0.9775196013F, 0.9778651941F,
  0.9782070167F, 0.9785450909F, 0.9788794388F, 0.9792100824F,
  0.9795370437F, 0.9798603449F, 0.9801800080F, 0.9804960554F,
  0.9808085092F, 0.9811173916F, 0.9814227251F, 0.9817245318F,
  0.9820228343F, 0.9823176549F, 0.9826090160F, 0.9828969402F,
  0.9831814498F, 0.9834625674F, 0.9837403156F, 0.9840147169F,
  0.9842857939F, 0.9845535692F, 0.9848180654F, 0.9850793052F,
  0.9853373113F, 0.9855921062F, 0.9858437127F, 0.9860921535F,
  0.9863374512F, 0.9865796287F, 0.9868187085F, 0.9870547136F,
  0.9872876664F, 0.9875175899F, 0.9877445067F, 0.9879684396F,
  0.9881894112F, 0.9884074444F, 0.9886225619F, 0.9888347863F,
  0.9890441404F, 0.9892506468F, 0.9894543284F, 0.9896552077F,
  0.9898533074F, 0.9900486502F, 0.9902412587F, 0.9904311555F,
  0.9906183633F, 0.9908029045F, 0.9909848019F, 0.9911640779F,
  0.9913407550F, 0.9915148557F, 0.9916864025F, 0.9918554179F,
  0.9920219241F, 0.9921859437F, 0.9923474989F, 0.9925066120F,
  0.9926633054F, 0.9928176012F, 0.9929695218F, 0.9931190891F,
  0.9932663254F, 0.9934112527F, 0.9935538932F, 0.9936942686F,
  0.9938324012F, 0.9939683126F, 0.9941020248F, 0.9942335597F,
  0.9943629388F, 0.9944901841F, 0.9946153170F, 0.9947383593F,
  0.9948593325F, 0.9949782579F, 0.9950951572F, 0.9952100516F,
  0.9953229625F, 0.9954339111F, 0.9955429186F, 0.9956500062F,
  0.9957551948F, 0.9958585056F, 0.9959599593F, 0.9960595769F,
  0.9961573792F, 0.9962533869F, 0.9963476206F, 0.9964401009F,
  0.9965308483F, 0.9966198833F, 0.9967072261F, 0.9967928971F,
  0.9968769164F, 0.9969593041F, 0.9970400804F, 0.9971192651F,
  0.9971968781F, 0.9972729391F, 0.9973474680F, 0.9974204842F,
  0.9974920074F, 0.9975620569F, 0.9976306521F, 0.9976978122F,
  0.9977635565F, 0.9978279039F, 0.9978908736F, 0.9979524842F,
  0.9980127547F, 0.9980717037F, 0.9981293499F, 0.9981857116F,
  0.9982408073F, 0.9982946554F, 0.9983472739F, 0.9983986810F,
  0.9984488947F, 0.9984979328F, 0.9985458132F, 0.9985925534F,
  0.9986381711F, 0.9986826838F, 0.9987261086F, 0.9987684630F,
  0.9988097640F, 0.9988500286F, 0.9988892738F, 0.9989275163F,
  0.9989647727F, 0.9990010597F, 0.9990363938F, 0.9990707911F,
  0.9991042679F, 0.9991368404F, 0.9991685244F, 0.9991993358F,
  0.9992292905F, 0.9992584038F, 0.9992866914F, 0.9993141686F,
  0.9993408506F, 0.9993667526F, 0.9993918895F, 0.9994162761F,
  0.9994399273F, 0.9994628576F, 0.9994850815F, 0.9995066133F,
  0.9995274672F, 0.9995476574F, 0.9995671978F, 0.9995861021F,
  0.9996043841F, 0.9996220573F, 0.9996391352F, 0.9996556310F,
  0.9996715579F, 0.9996869288F, 0.9997017568F, 0.9997160543F,
  0.9997298342F, 0.9997431088F, 0.9997558905F, 0.9997681914F,
  0.9997800236F, 0.9997913990F, 0.9998023292F, 0.9998128261F,
  0.9998229009F, 0.9998325650F, 0.9998418296F, 0.9998507058F,
  0.9998592044F, 0.9998673362F, 0.9998751117F, 0.9998825415F,
  0.9998896358F, 0.9998964047F, 0.9999028584F, 0.9999090066F,
  0.9999148590F, 0.9999204253F, 0.9999257148F, 0.9999307368F,
  0.9999355003F, 0.9999400144F, 0.9999442878F, 0.9999483293F,
  0.9999521472F, 0.9999557499F, 0.9999591457F, 0.9999623426F,
  0.9999653483F, 0.9999681708F, 0.9999708175F, 0.9999732959F,
  0.9999756132F, 0.9999777765F, 0.9999797928F, 0.9999816688F,
  0.9999834113F, 0.9999850266F, 0.9999865211F, 0.9999879009F,
  0.9999891721F, 0.9999903405F, 0.9999914118F, 0.9999923914F,
  0.9999932849F, 0.9999940972F, 0.9999948336F, 0.9999954989F,
  0.9999960978F, 0.9999966349F, 0.9999971146F, 0.9999975411F,
  0.9999979185F, 0.9999982507F, 0.9999985414F, 0.9999987944F,
  0.9999990129F, 0.9999992003F, 0.9999993596F, 0.9999994939F,
  0.9999996059F, 0.9999996981F, 0.9999997732F, 0.9999998333F,
  0.9999998805F, 0.9999999170F, 0.9999999444F, 0.9999999643F,
  0.9999999784F, 0.9999999878F, 0.9999999937F, 0.9999999972F,
  0.9999999990F, 0.9999999997F, 1.0000000000F, 1.0000000000F,
};

static float vwin4096[2048] = {
  0.0000002310F, 0.0000020791F, 0.0000057754F, 0.0000113197F,
  0.0000187121F, 0.0000279526F, 0.0000390412F, 0.0000519777F,
  0.0000667623F, 0.0000833949F, 0.0001018753F, 0.0001222036F,
  0.0001443798F, 0.0001684037F, 0.0001942754F, 0.0002219947F,
  0.0002515616F, 0.0002829761F, 0.0003162380F, 0.0003513472F,
  0.0003883038F, 0.0004271076F, 0.0004677584F, 0.0005102563F,
  0.0005546011F, 0.0006007928F, 0.0006488311F, 0.0006987160F,
  0.0007504474F, 0.0008040251F, 0.0008594490F, 0.0009167191F,
  0.0009758351F, 0.0010367969F, 0.0010996044F, 0.0011642574F,
  0.0012307558F, 0.0012990994F, 0.0013692880F, 0.0014413216F,
  0.0015151998F, 0.0015909226F, 0.0016684898F, 0.0017479011F,
  0.0018291565F, 0.0019122556F, 0.0019971983F, 0.0020839845F,
  0.0021726138F, 0.0022630861F, 0.0023554012F, 0.0024495588F,
  0.0025455588F, 0.0026434008F, 0.0027430847F, 0.0028446103F,
  0.0029479772F, 0.0030531853F, 0.0031602342F, 0.0032691238F,
  0.0033798538F, 0.0034924239F, 0.0036068338F, 0.0037230833F,
  0.0038411721F, 0.0039610999F, 0.0040828664F, 0.0042064714F,
  0.0043319145F, 0.0044591954F, 0.0045883139F, 0.0047192696F,
  0.0048520622F, 0.0049866914F, 0.0051231569F, 0.0052614583F,
  0.0054015953F, 0.0055435676F, 0.0056873748F, 0.0058330166F,
  0.0059804926F, 0.0061298026F, 0.0062809460F, 0.0064339226F,
  0.0065887320F, 0.0067453738F, 0.0069038476F, 0.0070641531F,
  0.0072262899F, 0.0073902575F, 0.0075560556F, 0.0077236838F,
  0.0078931417F, 0.0080644288F, 0.0082375447F, 0.0084124891F,
  0.0085892615F, 0.0087678614F, 0.0089482885F, 0.0091305422F,
  0.0093146223F, 0.0095005281F, 0.0096882592F, 0.0098778153F,
  0.0100691958F, 0.0102624002F, 0.0104574281F, 0.0106542791F,
  0.0108529525F, 0.0110534480F, 0.0112557651F, 0.0114599032F,
  0.0116658618F, 0.0118736405F, 0.0120832387F, 0.0122946560F,
  0.0125078917F, 0.0127229454F, 0.0129398166F, 0.0131585046F,
  0.0133790090F, 0.0136013292F, 0.0138254647F, 0.0140514149F,
  0.0142791792F, 0.0145087572F, 0.0147401481F, 0.0149733515F,
  0.0152083667F, 0.0154451932F, 0.0156838304F, 0.0159242777F,
  0.0161665345F, 0.0164106001F, 0.0166564741F, 0.0169041557F,
  0.0171536443F, 0.0174049393F, 0.0176580401F, 0.0179129461F,
  0.0181696565F, 0.0184281708F, 0.0186884883F, 0.0189506084F,
  0.0192145303F, 0.0194802535F, 0.0197477772F, 0.0200171008F,
  0.0202882236F, 0.0205611449F, 0.0208358639F, 0.0211123801F,
  0.0213906927F, 0.0216708011F, 0.0219527043F, 0.0222364019F,
  0.0225218930F, 0.0228091769F, 0.0230982529F, 0.0233891203F,
  0.0236817782F, 0.0239762259F, 0.0242724628F, 0.0245704880F,
  0.0248703007F, 0.0251719002F, 0.0254752858F, 0.0257804565F,
  0.0260874117F, 0.0263961506F, 0.0267066722F, 0.0270189760F,
  0.0273330609F, 0.0276489263F, 0.0279665712F, 0.0282859949F,
  0.0286071966F, 0.0289301753F, 0.0292549303F, 0.0295814607F,
  0.0299097656F, 0.0302398442F, 0.0305716957F, 0.0309053191F,
  0.0312407135F, 0.0315778782F, 0.0319168122F, 0.0322575145F,
  0.0325999844F, 0.0329442209F, 0.0332902231F, 0.0336379900F,
  0.0339875208F, 0.0343388146F, 0.0346918703F, 0.0350466871F,
  0.0354032640F, 0.0357616000F, 0.0361216943F, 0.0364835458F,
  0.0368471535F, 0.0372125166F, 0.0375796339F, 0.0379485046F,
  0.0383191276F, 0.0386915020F, 0.0390656267F, 0.0394415008F,
  0.0398191231F, 0.0401984927F, 0.0405796086F, 0.0409624698F,
  0.0413470751F, 0.0417334235F, 0.0421215141F, 0.0425113457F,
  0.0429029172F, 0.0432962277F, 0.0436912760F, 0.0440880610F,
  0.0444865817F, 0.0448868370F, 0.0452888257F, 0.0456925468F,
  0.0460979992F, 0.0465051816F, 0.0469140931F, 0.0473247325F,
  0.0477370986F, 0.0481511902F, 0.0485670064F, 0.0489845458F,
  0.0494038074F, 0.0498247899F, 0.0502474922F, 0.0506719131F,
  0.0510980514F, 0.0515259060F, 0.0519554756F, 0.0523867590F,
  0.0528197550F, 0.0532544624F, 0.0536908800F, 0.0541290066F,
  0.0545688408F, 0.0550103815F, 0.0554536274F, 0.0558985772F,
  0.0563452297F, 0.0567935837F, 0.0572436377F, 0.0576953907F,
  0.0581488412F, 0.0586039880F, 0.0590608297F, 0.0595193651F,
  0.0599795929F, 0.0604415117F, 0.0609051202F, 0.0613704170F,
  0.0618374009F, 0.0623060704F, 0.0627764243F, 0.0632484611F,
  0.0637221795F, 0.0641975781F, 0.0646746555F, 0.0651534104F,
  0.0656338413F, 0.0661159469F, 0.0665997257F, 0.0670851763F,
  0.0675722973F, 0.0680610873F, 0.0685515448F, 0.0690436684F,
  0.0695374567F, 0.0700329081F, 0.0705300213F, 0.0710287947F,
  0.0715292269F, 0.0720313163F, 0.0725350616F, 0.0730404612F,
  0.0735475136F, 0.0740562172F, 0.0745665707F, 0.0750785723F,
  0.0755922207F, 0.0761075143F, 0.0766244515F, 0.0771430307F,
  0.0776632505F, 0.0781851092F, 0.0787086052F, 0.0792337371F,
  0.0797605032F, 0.0802889018F, 0.0808189315F, 0.0813505905F,
  0.0818838773F, 0.0824187903F, 0.0829553277F, 0.0834934881F,
  0.0840332697F, 0.0845746708F, 0.0851176899F, 0.0856623252F,
  0.0862085751F, 0.0867564379F, 0.0873059119F, 0.0878569954F,
  0.0884096867F, 0.0889639840F, 0.0895198858F, 0.0900773902F,
  0.0906364955F, 0.0911972000F, 0.0917595019F, 0.0923233995F,
  0.0928888909F, 0.0934559745F, 0.0940246485F, 0.0945949110F,
  0.0951667604F, 0.0957401946F, 0.0963152121F, 0.0968918109F,
  0.0974699893F, 0.0980497454F, 0.0986310773F, 0.0992139832F,
  0.0997984614F, 0.1003845098F, 0.1009721267F, 0.1015613101F,
  0.1021520582F, 0.1027443692F, 0.1033382410F, 0.1039336718F,
  0.1045306597F, 0.1051292027F, 0.1057292990F, 0.1063309466F,
  0.1069341435F, 0.1075388878F, 0.1081451776F, 0.1087530108F,
  0.1093623856F, 0.1099732998F, 0.1105857516F, 0.1111997389F,
  0.1118152597F, 0.1124323121F, 0.1130508939F, 0.1136710032F,
  0.1142926379F, 0.1149157960F, 0.1155404755F, 0.1161666742F,
  0.1167943901F, 0.1174236211F, 0.1180543652F, 0.1186866202F,
  0.1193203841F, 0.1199556548F, 0.1205924300F, 0.1212307078F,
  0.1218704860F, 0.1225117624F, 0.1231545349F, 0.1237988013F,
  0.1244445596F, 0.1250918074F, 0.1257405427F, 0.1263907632F,
  0.1270424667F, 0.1276956512F, 0.1283503142F, 0.1290064537F,
  0.1296640674F, 0.1303231530F, 0.1309837084F, 0.1316457312F,
  0.1323092193F, 0.1329741703F, 0.1336405820F, 0.1343084520F,
  0.1349777782F, 0.1356485582F, 0.1363207897F, 0.1369944704F,
  0.1376695979F, 0.1383461700F, 0.1390241842F, 0.1397036384F,
  0.1403845300F, 0.1410668567F, 0.1417506162F, 0.1424358061F,
  0.1431224240F, 0.1438104674F, 0.1444999341F, 0.1451908216F,
  0.1458831274F, 0.1465768492F, 0.1472719844F, 0.1479685308F,
  0.1486664857F, 0.1493658468F, 0.1500666115F, 0.1507687775F,
  0.1514723422F, 0.1521773031F, 0.1528836577F, 0.1535914035F,
  0.1543005380F, 0.1550110587F, 0.1557229631F, 0.1564362485F,
  0.1571509124F, 0.1578669524F, 0.1585843657F, 0.1593031499F,
  0.1600233024F, 0.1607448205F, 0.1614677017F, 0.1621919433F,
  0.1629175428F, 0.1636444975F, 0.1643728047F, 0.1651024619F,
  0.1658334665F, 0.1665658156F, 0.1672995067F, 0.1680345371F,
  0.1687709041F, 0.1695086050F, 0.1702476372F, 0.1709879978F,
  0.1717296843F, 0.1724726938F, 0.1732170237F, 0.1739626711F,
  0.1747096335F, 0.1754579079F, 0.1762074916F, 0.1769583819F,
  0.1777105760F, 0.1784640710F, 0.1792188642F, 0.1799749529F,
  0.1807323340F, 0.1814910049F, 0.1822509628F, 0.1830122046F,
  0.1837747277F, 0.1845385292F, 0.1853036062F, 0.1860699558F,
  0.1868375751F, 0.1876064613F, 0.1883766114F, 0.1891480226F,
  0.1899206919F, 0.1906946164F, 0.1914697932F, 0.1922462194F,
  0.1930238919F, 0.1938028079F, 0.1945829643F, 0.1953643583F,
  0.1961469868F, 0.1969308468F, 0.1977159353F, 0.1985022494F,
  0.1992897859F, 0.2000785420F, 0.2008685145F, 0.2016597005F,
  0.2024520968F, 0.2032457005F, 0.2040405084F, 0.2048365175F,
  0.2056337247F, 0.2064321269F, 0.2072317211F, 0.2080325041F,
  0.2088344727F, 0.2096376240F, 0.2104419547F, 0.2112474618F,
  0.2120541420F, 0.2128619923F, 0.2136710094F, 0.2144811902F,
  0.2152925315F, 0.2161050301F, 0.2169186829F, 0.2177334866F,
  0.2185494381F, 0.2193665340F, 0.2201847712F, 0.2210041465F,
  0.2218246565F, 0.2226462981F, 0.2234690680F, 0.2242929629F,
  0.2251179796F, 0.2259441147F, 0.2267713650F, 0.2275997272F,
  0.2284291979F, 0.2292597739F, 0.2300914518F, 0.2309242283F,
  0.2317581001F, 0.2325930638F, 0.2334291160F, 0.2342662534F,
  0.2351044727F, 0.2359437703F, 0.2367841431F, 0.2376255875F,
  0.2384681001F, 0.2393116776F, 0.2401563165F, 0.2410020134F,
  0.2418487649F, 0.2426965675F, 0.2435454178F, 0.2443953122F,
  0.2452462474F, 0.2460982199F, 0.2469512262F, 0.2478052628F,
  0.2486603262F, 0.2495164129F, 0.2503735194F, 0.2512316421F,
  0.2520907776F, 0.2529509222F, 0.2538120726F, 0.2546742250F,
  0.2555373760F, 0.2564015219F, 0.2572666593F, 0.2581327845F,
  0.2589998939F, 0.2598679840F, 0.2607370510F, 0.2616070916F,
  0.2624781019F, 0.2633500783F, 0.2642230173F, 0.2650969152F,
  0.2659717684F, 0.2668475731F, 0.2677243257F, 0.2686020226F,
  0.2694806601F, 0.2703602344F, 0.2712407419F, 0.2721221789F,
  0.2730045417F, 0.2738878265F, 0.2747720297F, 0.2756571474F,
  0.2765431760F, 0.2774301117F, 0.2783179508F, 0.2792066895F,
  0.2800963240F, 0.2809868505F, 0.2818782654F, 0.2827705647F,
  0.2836637447F, 0.2845578016F, 0.2854527315F, 0.2863485307F,
  0.2872451953F, 0.2881427215F, 0.2890411055F, 0.2899403433F,
  0.2908404312F, 0.2917413654F, 0.2926431418F, 0.2935457567F,
  0.2944492061F, 0.2953534863F, 0.2962585932F, 0.2971645230F,
  0.2980712717F, 0.2989788356F, 0.2998872105F, 0.3007963927F,
  0.3017063781F, 0.3026171629F, 0.3035287430F, 0.3044411145F,
  0.3053542736F, 0.3062682161F, 0.3071829381F, 0.3080984356F,
  0.3090147047F, 0.3099317413F, 0.3108495414F, 0.3117681011F,
  0.3126874163F, 0.3136074830F, 0.3145282972F, 0.3154498548F,
  0.3163721517F, 0.3172951841F, 0.3182189477F, 0.3191434385F,
  0.3200686525F, 0.3209945856F, 0.3219212336F, 0.3228485927F,
  0.3237766585F, 0.3247054271F, 0.3256348943F, 0.3265650560F,
  0.3274959081F, 0.3284274465F, 0.3293596671F, 0.3302925657F,
  0.3312261382F, 0.3321603804F, 0.3330952882F, 0.3340308574F,
  0.3349670838F, 0.3359039634F, 0.3368414919F, 0.3377796651F,
  0.3387184789F, 0.3396579290F, 0.3405980113F, 0.3415387216F,
  0.3424800556F, 0.3434220091F, 0.3443645779F, 0.3453077578F,
  0.3462515446F, 0.3471959340F, 0.3481409217F, 0.3490865036F,
  0.3500326754F, 0.3509794328F, 0.3519267715F, 0.3528746873F,
  0.3538231759F, 0.3547722330F, 0.3557218544F, 0.3566720357F,
  0.3576227727F, 0.3585740610F, 0.3595258964F, 0.3604782745F,
  0.3614311910F, 0.3623846417F, 0.3633386221F, 0.3642931280F,
  0.3652481549F, 0.3662036987F, 0.3671597548F, 0.3681163191F,
  0.3690733870F, 0.3700309544F, 0.3709890167F, 0.3719475696F,
  0.3729066089F, 0.3738661299F, 0.3748261285F, 0.3757866002F,
  0.3767475406F, 0.3777089453F, 0.3786708100F, 0.3796331302F,
  0.3805959014F, 0.3815591194F, 0.3825227796F, 0.3834868777F,
  0.3844514093F, 0.3854163698F, 0.3863817549F, 0.3873475601F,
  0.3883137810F, 0.3892804131F, 0.3902474521F, 0.3912148933F,
  0.3921827325F, 0.3931509650F, 0.3941195865F, 0.3950885925F,
  0.3960579785F, 0.3970277400F, 0.3979978725F, 0.3989683716F,
  0.3999392328F, 0.4009104516F, 0.4018820234F, 0.4028539438F,
  0.4038262084F, 0.4047988125F, 0.4057717516F, 0.4067450214F,
  0.4077186172F, 0.4086925345F, 0.4096667688F, 0.4106413155F,
  0.4116161703F, 0.4125913284F, 0.4135667854F, 0.4145425368F,
  0.4155185780F, 0.4164949044F, 0.4174715116F, 0.4184483949F,
  0.4194255498F, 0.4204029718F, 0.4213806563F, 0.4223585987F,
  0.4233367946F, 0.4243152392F, 0.4252939281F, 0.4262728566F,
  0.4272520202F, 0.4282314144F, 0.4292110345F, 0.4301908760F,
  0.4311709343F, 0.4321512047F, 0.4331316828F, 0.4341123639F,
  0.4350932435F, 0.4360743168F, 0.4370555794F, 0.4380370267F,
  0.4390186540F, 0.4400004567F, 0.4409824303F, 0.4419645701F,
  0.4429468716F, 0.4439293300F, 0.4449119409F, 0.4458946996F,
  0.4468776014F, 0.4478606418F, 0.4488438162F, 0.4498271199F,
  0.4508105483F, 0.4517940967F, 0.4527777607F, 0.4537615355F,
  0.4547454165F, 0.4557293991F, 0.4567134786F, 0.4576976505F,
  0.4586819101F, 0.4596662527F, 0.4606506738F, 0.4616351687F,
  0.4626197328F, 0.4636043614F, 0.4645890499F, 0.4655737936F,
  0.4665585880F, 0.4675434284F, 0.4685283101F, 0.4695132286F,
  0.4704981791F, 0.4714831570F, 0.4724681577F, 0.4734531766F,
  0.4744382089F, 0.4754232501F, 0.4764082956F, 0.4773933406F,
  0.4783783806F, 0.4793634108F, 0.4803484267F, 0.4813334237F,
  0.4823183969F, 0.4833033419F, 0.4842882540F, 0.4852731285F,
  0.4862579608F, 0.4872427462F, 0.4882274802F, 0.4892121580F,
  0.4901967751F, 0.4911813267F, 0.4921658083F, 0.4931502151F,
  0.4941345427F, 0.4951187863F, 0.4961029412F, 0.4970870029F,
  0.4980709667F, 0.4990548280F, 0.5000385822F, 0.5010222245F,
  0.5020057505F, 0.5029891553F, 0.5039724345F, 0.5049555834F,
  0.5059385973F, 0.5069214716F, 0.5079042018F, 0.5088867831F,
  0.5098692110F, 0.5108514808F, 0.5118335879F, 0.5128155277F,
  0.5137972956F, 0.5147788869F, 0.5157602971F, 0.5167415215F,
  0.5177225555F, 0.5187033945F, 0.5196840339F, 0.5206644692F,
  0.5216446956F, 0.5226247086F, 0.5236045035F, 0.5245840759F,
  0.5255634211F, 0.5265425344F, 0.5275214114F, 0.5285000474F,
  0.5294784378F, 0.5304565781F, 0.5314344637F, 0.5324120899F,
  0.5333894522F, 0.5343665461F, 0.5353433670F, 0.5363199102F,
  0.5372961713F, 0.5382721457F, 0.5392478287F, 0.5402232159F,
  0.5411983027F, 0.5421730845F, 0.5431475569F, 0.5441217151F,
  0.5450955548F, 0.5460690714F, 0.5470422602F, 0.5480151169F,
  0.5489876368F, 0.5499598155F, 0.5509316484F, 0.5519031310F,
  0.5528742587F, 0.5538450271F, 0.5548154317F, 0.5557854680F,
  0.5567551314F, 0.5577244174F, 0.5586933216F, 0.5596618395F,
  0.5606299665F, 0.5615976983F, 0.5625650302F, 0.5635319580F,
  0.5644984770F, 0.5654645828F, 0.5664302709F, 0.5673955370F,
  0.5683603765F, 0.5693247850F, 0.5702887580F, 0.5712522912F,
  0.5722153800F, 0.5731780200F, 0.5741402069F, 0.5751019362F,
  0.5760632034F, 0.5770240042F, 0.5779843341F, 0.5789441889F,
  0.5799035639F, 0.5808624549F, 0.5818208575F, 0.5827787673F,
  0.5837361800F, 0.5846930910F, 0.5856494961F, 0.5866053910F,
  0.5875607712F, 0.5885156324F, 0.5894699703F, 0.5904237804F,
  0.5913770586F, 0.5923298004F, 0.5932820016F, 0.5942336578F,
  0.5951847646F, 0.5961353179F, 0.5970853132F, 0.5980347464F,
  0.5989836131F, 0.5999319090F, 0.6008796298F, 0.6018267713F,
  0.6027733292F, 0.6037192993F, 0.6046646773F, 0.6056094589F,
  0.6065536400F, 0.6074972162F, 0.6084401833F, 0.6093825372F,
  0.6103242736F, 0.6112653884F, 0.6122058772F, 0.6131457359F,
  0.6140849604F, 0.6150235464F, 0.6159614897F, 0.6168987862F,
  0.6178354318F, 0.6187714223F, 0.6197067535F, 0.6206414213F,
  0.6215754215F, 0.6225087501F, 0.6234414028F, 0.6243733757F,
  0.6253046646F, 0.6262352654F, 0.6271651739F, 0.6280943862F,
  0.6290228982F, 0.6299507057F, 0.6308778048F, 0.6318041913F,
  0.6327298612F, 0.6336548105F, 0.6345790352F, 0.6355025312F,
  0.6364252945F, 0.6373473211F, 0.6382686070F, 0.6391891483F,
  0.6401089409F, 0.6410279808F, 0.6419462642F, 0.6428637869F,
  0.6437805452F, 0.6446965350F, 0.6456117524F, 0.6465261935F,
  0.6474398544F, 0.6483527311F, 0.6492648197F, 0.6501761165F,
  0.6510866174F, 0.6519963186F, 0.6529052162F, 0.6538133064F,
  0.6547205854F, 0.6556270492F, 0.6565326941F, 0.6574375162F,
  0.6583415117F, 0.6592446769F, 0.6601470079F, 0.6610485009F,
  0.6619491521F, 0.6628489578F, 0.6637479143F, 0.6646460177F,
  0.6655432643F, 0.6664396505F, 0.6673351724F, 0.6682298264F,
  0.6691236087F, 0.6700165157F, 0.6709085436F, 0.6717996889F,
  0.6726899478F, 0.6735793167F, 0.6744677918F, 0.6753553697F,
  0.6762420466F, 0.6771278190F, 0.6780126832F, 0.6788966357F,
  0.6797796728F, 0.6806617909F, 0.6815429866F, 0.6824232562F,
  0.6833025961F, 0.6841810030F, 0.6850584731F, 0.6859350031F,
  0.6868105894F, 0.6876852284F, 0.6885589168F, 0.6894316510F,
  0.6903034275F, 0.6911742430F, 0.6920440939F, 0.6929129769F,
  0.6937808884F, 0.6946478251F, 0.6955137837F, 0.6963787606F,
  0.6972427525F, 0.6981057560F, 0.6989677678F, 0.6998287845F,
  0.7006888028F, 0.7015478194F, 0.7024058309F, 0.7032628340F,
  0.7041188254F, 0.7049738019F, 0.7058277601F, 0.7066806969F,
  0.7075326089F, 0.7083834929F, 0.7092333457F, 0.7100821640F,
  0.7109299447F, 0.7117766846F, 0.7126223804F, 0.7134670291F,
  0.7143106273F, 0.7151531721F, 0.7159946602F, 0.7168350885F,
  0.7176744539F, 0.7185127534F, 0.7193499837F, 0.7201861418F,
  0.7210212247F, 0.7218552293F, 0.7226881526F, 0.7235199914F,
  0.7243507428F, 0.7251804039F, 0.7260089715F, 0.7268364426F,
  0.7276628144F, 0.7284880839F, 0.7293122481F, 0.7301353040F,
  0.7309572487F, 0.7317780794F, 0.7325977930F, 0.7334163868F,
  0.7342338579F, 0.7350502033F, 0.7358654202F, 0.7366795059F,
  0.7374924573F, 0.7383042718F, 0.7391149465F, 0.7399244787F,
  0.7407328655F, 0.7415401041F, 0.7423461920F, 0.7431511261F,
  0.7439549040F, 0.7447575227F, 0.7455589797F, 0.7463592723F,
  0.7471583976F, 0.7479563532F, 0.7487531363F, 0.7495487443F,
  0.7503431745F, 0.7511364244F, 0.7519284913F, 0.7527193726F,
  0.7535090658F, 0.7542975683F, 0.7550848776F, 0.7558709910F,
  0.7566559062F, 0.7574396205F, 0.7582221314F, 0.7590034366F,
  0.7597835334F, 0.7605624194F, 0.7613400923F, 0.7621165495F,
  0.7628917886F, 0.7636658072F, 0.7644386030F, 0.7652101735F,
  0.7659805164F, 0.7667496292F, 0.7675175098F, 0.7682841556F,
  0.7690495645F, 0.7698137341F, 0.7705766622F, 0.7713383463F,
  0.7720987844F, 0.7728579741F, 0.7736159132F, 0.7743725994F,
  0.7751280306F, 0.7758822046F, 0.7766351192F, 0.7773867722F,
  0.7781371614F, 0.7788862848F, 0.7796341401F, 0.7803807253F,
  0.7811260383F, 0.7818700769F, 0.7826128392F, 0.7833543230F,
  0.7840945263F, 0.7848334471F, 0.7855710833F, 0.7863074330F,
  0.7870424941F, 0.7877762647F, 0.7885087428F, 0.7892399264F,
  0.7899698137F, 0.7906984026F, 0.7914256914F, 0.7921516780F,
  0.7928763607F, 0.7935997375F, 0.7943218065F, 0.7950425661F,
  0.7957620142F, 0.7964801492F, 0.7971969692F, 0.7979124724F,
  0.7986266570F, 0.7993395214F, 0.8000510638F, 0.8007612823F,
  0.8014701754F, 0.8021777413F, 0.8028839784F, 0.8035888849F,
  0.8042924592F, 0.8049946997F, 0.8056956048F, 0.8063951727F,
  0.8070934020F, 0.8077902910F, 0.8084858381F, 0.8091800419F,
  0.8098729007F, 0.8105644130F, 0.8112545774F, 0.8119433922F,
  0.8126308561F, 0.8133169676F, 0.8140017251F, 0.8146851272F,
  0.8153671726F, 0.8160478598F, 0.8167271874F, 0.8174051539F,
  0.8180817582F, 0.8187569986F, 0.8194308741F, 0.8201033831F,
  0.8207745244F, 0.8214442966F, 0.8221126986F, 0.8227797290F,
  0.8234453865F, 0.8241096700F, 0.8247725781F, 0.8254341097F,
  0.8260942636F, 0.8267530385F, 0.8274104334F, 0.8280664470F,
  0.8287210782F, 0.8293743259F, 0.8300261889F, 0.8306766662F,
  0.8313257566F, 0.8319734591F, 0.8326197727F, 0.8332646963F,
  0.8339082288F, 0.8345503692F, 0.8351911167F, 0.8358304700F,
  0.8364684284F, 0.8371049907F, 0.8377401562F, 0.8383739238F,
  0.8390062927F, 0.8396372618F, 0.8402668305F, 0.8408949977F,
  0.8415217626F, 0.8421471245F, 0.8427710823F, 0.8433936354F,
  0.8440147830F, 0.8446345242F, 0.8452528582F, 0.8458697844F,
  0.8464853020F, 0.8470994102F, 0.8477121084F, 0.8483233958F,
  0.8489332718F, 0.8495417356F, 0.8501487866F, 0.8507544243F,
  0.8513586479F, 0.8519614568F, 0.8525628505F, 0.8531628283F,
  0.8537613897F, 0.8543585341F, 0.8549542611F, 0.8555485699F,
  0.8561414603F, 0.8567329315F, 0.8573229832F, 0.8579116149F,
  0.8584988262F, 0.8590846165F, 0.8596689855F, 0.8602519327F,
  0.8608334577F, 0.8614135603F, 0.8619922399F, 0.8625694962F,
  0.8631453289F, 0.8637197377F, 0.8642927222F, 0.8648642821F,
  0.8654344172F, 0.8660031272F, 0.8665704118F, 0.8671362708F,
  0.8677007039F, 0.8682637109F, 0.8688252917F, 0.8693854460F,
  0.8699441737F, 0.8705014745F, 0.8710573485F, 0.8716117953F,
  0.8721648150F, 0.8727164073F, 0.8732665723F, 0.8738153098F,
  0.8743626197F, 0.8749085021F, 0.8754529569F, 0.8759959840F,
  0.8765375835F, 0.8770777553F, 0.8776164996F, 0.8781538162F,
  0.8786897054F, 0.8792241670F, 0.8797572013F, 0.8802888082F,
  0.8808189880F, 0.8813477407F, 0.8818750664F, 0.8824009653F,
  0.8829254375F, 0.8834484833F, 0.8839701028F, 0.8844902961F,
  0.8850090636F, 0.8855264054F, 0.8860423218F, 0.8865568131F,
  0.8870698794F, 0.8875815212F, 0.8880917386F, 0.8886005319F,
  0.8891079016F, 0.8896138479F, 0.8901183712F, 0.8906214719F,
  0.8911231503F, 0.8916234067F, 0.8921222417F, 0.8926196556F,
  0.8931156489F, 0.8936102219F, 0.8941033752F, 0.8945951092F,
  0.8950854244F, 0.8955743212F, 0.8960618003F, 0.8965478621F,
  0.8970325071F, 0.8975157359F, 0.8979975490F, 0.8984779471F,
  0.8989569307F, 0.8994345004F, 0.8999106568F, 0.9003854005F,
  0.9008587323F, 0.9013306526F, 0.9018011623F, 0.9022702619F,
  0.9027379521F, 0.9032042337F, 0.9036691074F, 0.9041325739F,
  0.9045946339F, 0.9050552882F, 0.9055145376F, 0.9059723828F,
  0.9064288246F, 0.9068838638F, 0.9073375013F, 0.9077897379F,
  0.9082405743F, 0.9086900115F, 0.9091380503F, 0.9095846917F,
  0.9100299364F, 0.9104737854F, 0.9109162397F, 0.9113573001F,
  0.9117969675F, 0.9122352430F, 0.9126721275F, 0.9131076219F,
  0.9135417273F, 0.9139744447F, 0.9144057750F, 0.9148357194F,
  0.9152642787F, 0.9156914542F, 0.9161172468F, 0.9165416576F,
  0.9169646877F, 0.9173863382F, 0.9178066102F, 0.9182255048F,
  0.9186430232F, 0.9190591665F, 0.9194739359F, 0.9198873324F,
  0.9202993574F, 0.9207100120F, 0.9211192973F, 0.9215272147F,
  0.9219337653F, 0.9223389504F, 0.9227427713F, 0.9231452290F,
  0.9235463251F, 0.9239460607F, 0.9243444371F, 0.9247414557F,
  0.9251371177F, 0.9255314245F, 0.9259243774F, 0.9263159778F,
  0.9267062270F, 0.9270951264F, 0.9274826774F, 0.9278688814F,
  0.9282537398F, 0.9286372540F, 0.9290194254F, 0.9294002555F,
  0.9297797458F, 0.9301578976F, 0.9305347125F, 0.9309101919F,
  0.9312843373F, 0.9316571503F, 0.9320286323F, 0.9323987849F,
  0.9327676097F, 0.9331351080F, 0.9335012816F, 0.9338661320F,
  0.9342296607F, 0.9345918694F, 0.9349527596F, 0.9353123330F,
  0.9356705911F, 0.9360275357F, 0.9363831683F, 0.9367374905F,
  0.9370905042F, 0.9374422108F, 0.9377926122F, 0.9381417099F,
  0.9384895057F, 0.9388360014F, 0.9391811985F, 0.9395250989F,
  0.9398677043F, 0.9402090165F, 0.9405490371F, 0.9408877680F,
  0.9412252110F, 0.9415613678F, 0.9418962402F, 0.9422298301F,
  0.9425621392F, 0.9428931695F, 0.9432229226F, 0.9435514005F,
  0.9438786050F, 0.9442045381F, 0.9445292014F, 0.9448525971F,
  0.9451747268F, 0.9454955926F, 0.9458151963F, 0.9461335399F,
  0.9464506253F, 0.9467664545F, 0.9470810293F, 0.9473943517F,
  0.9477064238F, 0.9480172474F, 0.9483268246F, 0.9486351573F,
  0.9489422475F, 0.9492480973F, 0.9495527087F, 0.9498560837F,
  0.9501582243F, 0.9504591325F, 0.9507588105F, 0.9510572603F,
  0.9513544839F, 0.9516504834F, 0.9519452609F, 0.9522388186F,
  0.9525311584F, 0.9528222826F, 0.9531121932F, 0.9534008923F,
  0.9536883821F, 0.9539746647F, 0.9542597424F, 0.9545436171F,
  0.9548262912F, 0.9551077667F, 0.9553880459F, 0.9556671309F,
  0.9559450239F, 0.9562217272F, 0.9564972429F, 0.9567715733F,
  0.9570447206F, 0.9573166871F, 0.9575874749F, 0.9578570863F,
  0.9581255236F, 0.9583927890F, 0.9586588849F, 0.9589238134F,
  0.9591875769F, 0.9594501777F, 0.9597116180F, 0.9599719003F,
  0.9602310267F, 0.9604889995F, 0.9607458213F, 0.9610014942F,
  0.9612560206F, 0.9615094028F, 0.9617616433F, 0.9620127443F,
  0.9622627083F, 0.9625115376F, 0.9627592345F, 0.9630058016F,
  0.9632512411F, 0.9634955555F, 0.9637387471F, 0.9639808185F,
  0.9642217720F, 0.9644616100F, 0.9647003349F, 0.9649379493F,
  0.9651744556F, 0.9654098561F, 0.9656441534F, 0.9658773499F,
  0.9661094480F, 0.9663404504F, 0.9665703593F, 0.9667991774F,
  0.9670269071F, 0.9672535509F, 0.9674791114F, 0.9677035909F,
  0.9679269921F, 0.9681493174F, 0.9683705694F, 0.9685907506F,
  0.9688098636F, 0.9690279108F, 0.9692448948F, 0.9694608182F,
  0.9696756836F, 0.9698894934F, 0.9701022503F, 0.9703139569F,
  0.9705246156F, 0.9707342291F, 0.9709428000F, 0.9711503309F,
  0.9713568243F, 0.9715622829F, 0.9717667093F, 0.9719701060F,
  0.9721724757F, 0.9723738210F, 0.9725741446F, 0.9727734490F,
  0.9729717369F, 0.9731690109F, 0.9733652737F, 0.9735605279F,
  0.9737547762F, 0.9739480212F, 0.9741402656F, 0.9743315120F,
  0.9745217631F, 0.9747110216F, 0.9748992901F, 0.9750865714F,
  0.9752728681F, 0.9754581829F, 0.9756425184F, 0.9758258775F,
  0.9760082627F, 0.9761896768F, 0.9763701224F, 0.9765496024F,
  0.9767281193F, 0.9769056760F, 0.9770822751F, 0.9772579193F,
  0.9774326114F, 0.9776063542F, 0.9777791502F, 0.9779510023F,
  0.9781219133F, 0.9782918858F, 0.9784609226F, 0.9786290264F,
  0.9787962000F, 0.9789624461F, 0.9791277676F, 0.9792921671F,
  0.9794556474F, 0.9796182113F, 0.9797798615F, 0.9799406009F,
  0.9801004321F, 0.9802593580F, 0.9804173813F, 0.9805745049F,
  0.9807307314F, 0.9808860637F, 0.9810405046F, 0.9811940568F,
  0.9813467232F, 0.9814985065F, 0.9816494095F, 0.9817994351F,
  0.9819485860F, 0.9820968650F, 0.9822442750F, 0.9823908186F,
  0.9825364988F, 0.9826813184F, 0.9828252801F, 0.9829683868F,
  0.9831106413F, 0.9832520463F, 0.9833926048F, 0.9835323195F,
  0.9836711932F, 0.9838092288F, 0.9839464291F, 0.9840827969F,
  0.9842183351F, 0.9843530464F, 0.9844869337F, 0.9846199998F,
  0.9847522475F, 0.9848836798F, 0.9850142993F, 0.9851441090F,
  0.9852731117F, 0.9854013101F, 0.9855287073F, 0.9856553058F,
  0.9857811087F, 0.9859061188F, 0.9860303388F, 0.9861537717F,
  0.9862764202F, 0.9863982872F, 0.9865193756F, 0.9866396882F,
  0.9867592277F, 0.9868779972F, 0.9869959993F, 0.9871132370F,
  0.9872297131F, 0.9873454304F, 0.9874603918F, 0.9875746001F,
  0.9876880581F, 0.9878007688F, 0.9879127348F, 0.9880239592F,
  0.9881344447F, 0.9882441941F, 0.9883532104F, 0.9884614962F,
  0.9885690546F, 0.9886758883F, 0.9887820001F, 0.9888873930F,
  0.9889920697F, 0.9890960331F, 0.9891992859F, 0.9893018312F,
  0.9894036716F, 0.9895048100F, 0.9896052493F, 0.9897049923F,
  0.9898040418F, 0.9899024006F, 0.9900000717F, 0.9900970577F,
  0.9901933616F, 0.9902889862F, 0.9903839343F, 0.9904782087F,
  0.9905718122F, 0.9906647477F, 0.9907570180F, 0.9908486259F,
  0.9909395742F, 0.9910298658F, 0.9911195034F, 0.9912084899F,
  0.9912968281F, 0.9913845208F, 0.9914715708F, 0.9915579810F,
  0.9916437540F, 0.9917288928F, 0.9918134001F, 0.9918972788F,
  0.9919805316F, 0.9920631613F, 0.9921451707F, 0.9922265626F,
  0.9923073399F, 0.9923875052F, 0.9924670615F, 0.9925460114F,
  0.9926243577F, 0.9927021033F, 0.9927792508F, 0.9928558032F,
  0.9929317631F, 0.9930071333F, 0.9930819167F, 0.9931561158F,
  0.9932297337F, 0.9933027728F, 0.9933752362F, 0.9934471264F,
  0.9935184462F, 0.9935891985F, 0.9936593859F, 0.9937290112F,
  0.9937980771F, 0.9938665864F, 0.9939345418F, 0.9940019460F,
  0.9940688018F, 0.9941351118F, 0.9942008789F, 0.9942661057F,
  0.9943307950F, 0.9943949494F, 0.9944585717F, 0.9945216645F,
  0.9945842307F, 0.9946462728F, 0.9947077936F, 0.9947687957F,
  0.9948292820F, 0.9948892550F, 0.9949487174F, 0.9950076719F,
  0.9950661212F, 0.9951240679F, 0.9951815148F, 0.9952384645F,
  0.9952949196F, 0.9953508828F, 0.9954063568F, 0.9954613442F,
  0.9955158476F, 0.9955698697F, 0.9956234132F, 0.9956764806F,
  0.9957290746F, 0.9957811978F, 0.9958328528F, 0.9958840423F,
  0.9959347688F, 0.9959850351F, 0.9960348435F, 0.9960841969F,
  0.9961330977F, 0.9961815486F, 0.9962295521F, 0.9962771108F,
  0.9963242274F, 0.9963709043F, 0.9964171441F, 0.9964629494F,
  0.9965083228F, 0.9965532668F, 0.9965977840F, 0.9966418768F,
  0.9966855479F, 0.9967287998F, 0.9967716350F, 0.9968140559F,
  0.9968560653F, 0.9968976655F, 0.9969388591F, 0.9969796485F,
  0.9970200363F, 0.9970600250F, 0.9970996170F, 0.9971388149F,
  0.9971776211F, 0.9972160380F, 0.9972540683F, 0.9972917142F,
  0.9973289783F, 0.9973658631F, 0.9974023709F, 0.9974385042F,
  0.9974742655F, 0.9975096571F, 0.9975446816F, 0.9975793413F,
  0.9976136386F, 0.9976475759F, 0.9976811557F, 0.9977143803F,
  0.9977472521F, 0.9977797736F, 0.9978119470F, 0.9978437748F,
  0.9978752593F, 0.9979064029F, 0.9979372079F, 0.9979676768F,
  0.9979978117F, 0.9980276151F, 0.9980570893F, 0.9980862367F,
  0.9981150595F, 0.9981435600F, 0.9981717406F, 0.9981996035F,
  0.9982271511F, 0.9982543856F, 0.9982813093F, 0.9983079246F,
  0.9983342336F, 0.9983602386F, 0.9983859418F, 0.9984113456F,
  0.9984364522F, 0.9984612638F, 0.9984857825F, 0.9985100108F,
  0.9985339507F, 0.9985576044F, 0.9985809743F, 0.9986040624F,
  0.9986268710F, 0.9986494022F, 0.9986716583F, 0.9986936413F,
  0.9987153535F, 0.9987367969F, 0.9987579738F, 0.9987788864F,
  0.9987995366F, 0.9988199267F, 0.9988400587F, 0.9988599348F,
  0.9988795572F, 0.9988989278F, 0.9989180487F, 0.9989369222F,
  0.9989555501F, 0.9989739347F, 0.9989920780F, 0.9990099820F,
  0.9990276487F, 0.9990450803F, 0.9990622787F, 0.9990792460F,
  0.9990959841F, 0.9991124952F, 0.9991287812F, 0.9991448440F,
  0.9991606858F, 0.9991763084F, 0.9991917139F, 0.9992069042F,
  0.9992218813F, 0.9992366471F, 0.9992512035F, 0.9992655525F,
  0.9992796961F, 0.9992936361F, 0.9993073744F, 0.9993209131F,
  0.9993342538F, 0.9993473987F, 0.9993603494F, 0.9993731080F,
  0.9993856762F, 0.9993980559F, 0.9994102490F, 0.9994222573F,
  0.9994340827F, 0.9994457269F, 0.9994571918F, 0.9994684793F,
  0.9994795910F, 0.9994905288F, 0.9995012945F, 0.9995118898F,
  0.9995223165F, 0.9995325765F, 0.9995426713F, 0.9995526029F,
  0.9995623728F, 0.9995719829F, 0.9995814349F, 0.9995907304F,
  0.9995998712F, 0.9996088590F, 0.9996176954F, 0.9996263821F,
  0.9996349208F, 0.9996433132F, 0.9996515609F, 0.9996596656F,
  0.9996676288F, 0.9996754522F, 0.9996831375F, 0.9996906862F,
  0.9996981000F, 0.9997053804F, 0.9997125290F, 0.9997195474F,
  0.9997264371F, 0.9997331998F, 0.9997398369F, 0.9997463500F,
  0.9997527406F, 0.9997590103F, 0.9997651606F, 0.9997711930F,
  0.9997771089F, 0.9997829098F, 0.9997885973F, 0.9997941728F,
  0.9997996378F, 0.9998049936F, 0.9998102419F, 0.9998153839F,
  0.9998204211F, 0.9998253550F, 0.9998301868F, 0.9998349182F,
  0.9998395503F, 0.9998440847F, 0.9998485226F, 0.9998528654F,
  0.9998571146F, 0.9998612713F, 0.9998653370F, 0.9998693130F,
  0.9998732007F, 0.9998770012F, 0.9998807159F, 0.9998843461F,
  0.9998878931F, 0.9998913581F, 0.9998947424F, 0.9998980473F,
  0.9999012740F, 0.9999044237F, 0.9999074976F, 0.9999104971F,
  0.9999134231F, 0.9999162771F, 0.9999190601F, 0.9999217733F,
  0.9999244179F, 0.9999269950F, 0.9999295058F, 0.9999319515F,
  0.9999343332F, 0.9999366519F, 0.9999389088F, 0.9999411050F,
  0.9999432416F, 0.9999453196F, 0.9999473402F, 0.9999493044F,
  0.9999512132F, 0.9999530677F, 0.9999548690F, 0.9999566180F,
  0.9999583157F, 0.9999599633F, 0.9999615616F, 0.9999631116F,
  0.9999646144F, 0.9999660709F, 0.9999674820F, 0.9999688487F,
  0.9999701719F, 0.9999714526F, 0.9999726917F, 0.9999738900F,
  0.9999750486F, 0.9999761682F, 0.9999772497F, 0.9999782941F,
  0.9999793021F, 0.9999802747F, 0.9999812126F, 0.9999821167F,
  0.9999829878F, 0.9999838268F, 0.9999846343F, 0.9999854113F,
  0.9999861584F, 0.9999868765F, 0.9999875664F, 0.9999882287F,
  0.9999888642F, 0.9999894736F, 0.9999900577F, 0.9999906172F,
  0.9999911528F, 0.9999916651F, 0.9999921548F, 0.9999926227F,
  0.9999930693F, 0.9999934954F, 0.9999939015F, 0.9999942883F,
  0.9999946564F, 0.9999950064F, 0.9999953390F, 0.9999956547F,
  0.9999959541F, 0.9999962377F, 0.9999965062F, 0.9999967601F,
  0.9999969998F, 0.9999972260F, 0.9999974392F, 0.9999976399F,
  0.9999978285F, 0.9999980056F, 0.9999981716F, 0.9999983271F,
  0.9999984724F, 0.9999986081F, 0.9999987345F, 0.9999988521F,
  0.9999989613F, 0.9999990625F, 0.9999991562F, 0.9999992426F,
  0.9999993223F, 0.9999993954F, 0.9999994625F, 0.9999995239F,
  0.9999995798F, 0.9999996307F, 0.9999996768F, 0.9999997184F,
  0.9999997559F, 0.9999997895F, 0.9999998195F, 0.9999998462F,
  0.9999998698F, 0.9999998906F, 0.9999999088F, 0.9999999246F,
  0.9999999383F, 0.9999999500F, 0.9999999600F, 0.9999999684F,
  0.9999999754F, 0.9999999811F, 0.9999999858F, 0.9999999896F,
  0.9999999925F, 0.9999999948F, 0.9999999965F, 0.9999999978F,
  0.9999999986F, 0.9999999992F, 0.9999999996F, 0.9999999998F,
  0.9999999999F, 1.0000000000F, 1.0000000000F, 1.0000000000F,
};

static float vwin8192[4096] = {
  0.0000000578F, 0.0000005198F, 0.0000014438F, 0.0000028299F,
  0.0000046780F, 0.0000069882F, 0.0000097604F, 0.0000129945F,
  0.0000166908F, 0.0000208490F, 0.0000254692F, 0.0000305515F,
  0.0000360958F, 0.0000421021F, 0.0000485704F, 0.0000555006F,
  0.0000628929F, 0.0000707472F, 0.0000790635F, 0.0000878417F,
  0.0000970820F, 0.0001067842F, 0.0001169483F, 0.0001275744F,
  0.0001386625F, 0.0001502126F, 0.0001622245F, 0.0001746984F,
  0.0001876343F, 0.0002010320F, 0.0002148917F, 0.0002292132F,
  0.0002439967F, 0.0002592421F, 0.0002749493F, 0.0002911184F,
  0.0003077493F, 0.0003248421F, 0.0003423967F, 0.0003604132F,
  0.0003788915F, 0.0003978316F, 0.0004172335F, 0.0004370971F,
  0.0004574226F, 0.0004782098F, 0.0004994587F, 0.0005211694F,
  0.0005433418F, 0.0005659759F, 0.0005890717F, 0.0006126292F,
  0.0006366484F, 0.0006611292F, 0.0006860716F, 0.0007114757F,
  0.0007373414F, 0.0007636687F, 0.0007904576F, 0.0008177080F,
  0.0008454200F, 0.0008735935F, 0.0009022285F, 0.0009313250F,
  0.0009608830F, 0.0009909025F, 0.0010213834F, 0.0010523257F,
  0.0010837295F, 0.0011155946F, 0.0011479211F, 0.0011807090F,
  0.0012139582F, 0.0012476687F, 0.0012818405F, 0.0013164736F,
  0.0013515679F, 0.0013871235F, 0.0014231402F, 0.0014596182F,
  0.0014965573F, 0.0015339576F, 0.0015718190F, 0.0016101415F,
  0.0016489251F, 0.0016881698F, 0.0017278754F, 0.0017680421F,
  0.0018086698F, 0.0018497584F, 0.0018913080F, 0.0019333185F,
  0.0019757898F, 0.0020187221F, 0.0020621151F, 0.0021059690F,
  0.0021502837F, 0.0021950591F, 0.0022402953F, 0.0022859921F,
  0.0023321497F, 0.0023787679F, 0.0024258467F, 0.0024733861F,
  0.0025213861F, 0.0025698466F, 0.0026187676F, 0.0026681491F,
  0.0027179911F, 0.0027682935F, 0.0028190562F, 0.0028702794F,
  0.0029219628F, 0.0029741066F, 0.0030267107F, 0.0030797749F,
  0.0031332994F, 0.0031872841F, 0.0032417289F, 0.0032966338F,
  0.0033519988F, 0.0034078238F, 0.0034641089F, 0.0035208539F,
  0.0035780589F, 0.0036357237F, 0.0036938485F, 0.0037524331F,
  0.0038114775F, 0.0038709817F, 0.0039309456F, 0.0039913692F,
  0.0040522524F, 0.0041135953F, 0.0041753978F, 0.0042376599F,
  0.0043003814F, 0.0043635624F, 0.0044272029F, 0.0044913028F,
  0.0045558620F, 0.0046208806F, 0.0046863585F, 0.0047522955F,
  0.0048186919F, 0.0048855473F, 0.0049528619F, 0.0050206356F,
  0.0050888684F, 0.0051575601F, 0.0052267108F, 0.0052963204F,
  0.0053663890F, 0.0054369163F, 0.0055079025F, 0.0055793474F,
  0.0056512510F, 0.0057236133F, 0.0057964342F, 0.0058697137F,
  0.0059434517F, 0.0060176482F, 0.0060923032F, 0.0061674166F,
  0.0062429883F, 0.0063190183F, 0.0063955066F, 0.0064724532F,
  0.0065498579F, 0.0066277207F, 0.0067060416F, 0.0067848205F,
  0.0068640575F, 0.0069437523F, 0.0070239051F, 0.0071045157F,
  0.0071855840F, 0.0072671102F, 0.0073490940F, 0.0074315355F,
  0.0075144345F, 0.0075977911F, 0.0076816052F, 0.0077658768F,
  0.0078506057F, 0.0079357920F, 0.0080214355F, 0.0081075363F,
  0.0081940943F, 0.0082811094F, 0.0083685816F, 0.0084565108F,
  0.0085448970F, 0.0086337401F, 0.0087230401F, 0.0088127969F,
  0.0089030104F, 0.0089936807F, 0.0090848076F, 0.0091763911F,
  0.0092684311F, 0.0093609276F, 0.0094538805F, 0.0095472898F,
  0.0096411554F, 0.0097354772F, 0.0098302552F, 0.0099254894F,
  0.0100211796F, 0.0101173259F, 0.0102139281F, 0.0103109863F,
  0.0104085002F, 0.0105064700F, 0.0106048955F, 0.0107037766F,
  0.0108031133F, 0.0109029056F, 0.0110031534F, 0.0111038565F,
  0.0112050151F, 0.0113066289F, 0.0114086980F, 0.0115112222F,
  0.0116142015F, 0.0117176359F, 0.0118215252F, 0.0119258695F,
  0.0120306686F, 0.0121359225F, 0.0122416312F, 0.0123477944F,
  0.0124544123F, 0.0125614847F, 0.0126690116F, 0.0127769928F,
  0.0128854284F, 0.0129943182F, 0.0131036623F, 0.0132134604F,
  0.0133237126F, 0.0134344188F, 0.0135455790F, 0.0136571929F,
  0.0137692607F, 0.0138817821F, 0.0139947572F, 0.0141081859F,
  0.0142220681F, 0.0143364037F, 0.0144511927F, 0.0145664350F,
  0.0146821304F, 0.0147982791F, 0.0149148808F, 0.0150319355F,
  0.0151494431F, 0.0152674036F, 0.0153858168F, 0.0155046828F,
  0.0156240014F, 0.0157437726F, 0.0158639962F, 0.0159846723F,
  0.0161058007F, 0.0162273814F, 0.0163494142F, 0.0164718991F,
  0.0165948361F, 0.0167182250F, 0.0168420658F, 0.0169663584F,
  0.0170911027F, 0.0172162987F, 0.0173419462F, 0.0174680452F,
  0.0175945956F, 0.0177215974F, 0.0178490504F, 0.0179769545F,
  0.0181053098F, 0.0182341160F, 0.0183633732F, 0.0184930812F,
  0.0186232399F, 0.0187538494F, 0.0188849094F, 0.0190164200F,
  0.0191483809F, 0.0192807923F, 0.0194136539F, 0.0195469656F,
  0.0196807275F, 0.0198149394F, 0.0199496012F, 0.0200847128F,
  0.0202202742F, 0.0203562853F, 0.0204927460F, 0.0206296561F,
  0.0207670157F, 0.0209048245F, 0.0210430826F, 0.0211817899F,
  0.0213209462F, 0.0214605515F, 0.0216006057F, 0.0217411086F,
  0.0218820603F, 0.0220234605F, 0.0221653093F, 0.0223076066F,
  0.0224503521F, 0.0225935459F, 0.0227371879F, 0.0228812779F,
  0.0230258160F, 0.0231708018F, 0.0233162355F, 0.0234621169F,
  0.0236084459F, 0.0237552224F, 0.0239024462F, 0.0240501175F,
  0.0241982359F, 0.0243468015F, 0.0244958141F, 0.0246452736F,
  0.0247951800F, 0.0249455331F, 0.0250963329F, 0.0252475792F,
  0.0253992720F, 0.0255514111F, 0.0257039965F, 0.0258570281F,
  0.0260105057F, 0.0261644293F, 0.0263187987F, 0.0264736139F,
  0.0266288747F, 0.0267845811F, 0.0269407330F, 0.0270973302F,
  0.0272543727F, 0.0274118604F, 0.0275697930F, 0.0277281707F,
  0.0278869932F, 0.0280462604F, 0.0282059723F, 0.0283661287F,
  0.0285267295F, 0.0286877747F, 0.0288492641F, 0.0290111976F,
  0.0291735751F, 0.0293363965F, 0.0294996617F, 0.0296633706F,
  0.0298275231F, 0.0299921190F, 0.0301571583F, 0.0303226409F,
  0.0304885667F, 0.0306549354F, 0.0308217472F, 0.0309890017F,
  0.0311566989F, 0.0313248388F, 0.0314934211F, 0.0316624459F,
  0.0318319128F, 0.0320018220F, 0.0321721732F, 0.0323429663F,
  0.0325142013F, 0.0326858779F, 0.0328579962F, 0.0330305559F,
  0.0332035570F, 0.0333769994F, 0.0335508829F, 0.0337252074F,
  0.0338999728F, 0.0340751790F, 0.0342508259F, 0.0344269134F,
  0.0346034412F, 0.0347804094F, 0.0349578178F, 0.0351356663F,
  0.0353139548F, 0.0354926831F, 0.0356718511F, 0.0358514588F,
  0.0360315059F, 0.0362119924F, 0.0363929182F, 0.0365742831F,
  0.0367560870F, 0.0369383297F, 0.0371210113F, 0.0373041315F,
  0.0374876902F, 0.0376716873F, 0.0378561226F, 0.0380409961F,
  0.0382263077F, 0.0384120571F, 0.0385982443F, 0.0387848691F,
  0.0389719315F, 0.0391594313F, 0.0393473683F, 0.0395357425F,
  0.0397245537F, 0.0399138017F, 0.0401034866F, 0.0402936080F,
  0.0404841660F, 0.0406751603F, 0.0408665909F, 0.0410584576F,
  0.0412507603F, 0.0414434988F, 0.0416366731F, 0.0418302829F,
  0.0420243282F, 0.0422188088F, 0.0424137246F, 0.0426090755F,
  0.0428048613F, 0.0430010819F, 0.0431977371F, 0.0433948269F,
  0.0435923511F, 0.0437903095F, 0.0439887020F, 0.0441875285F,
  0.0443867889F, 0.0445864830F, 0.0447866106F, 0.0449871717F,
  0.0451881661F, 0.0453895936F, 0.0455914542F, 0.0457937477F,
  0.0459964738F, 0.0461996326F, 0.0464032239F, 0.0466072475F,
  0.0468117032F, 0.0470165910F, 0.0472219107F, 0.0474276622F,
  0.0476338452F, 0.0478404597F, 0.0480475056F, 0.0482549827F,
  0.0484628907F, 0.0486712297F, 0.0488799994F, 0.0490891998F,
  0.0492988306F, 0.0495088917F, 0.0497193830F, 0.0499303043F,
  0.0501416554F, 0.0503534363F, 0.0505656468F, 0.0507782867F,
  0.0509913559F, 0.0512048542F, 0.0514187815F, 0.0516331376F,
  0.0518479225F, 0.0520631358F, 0.0522787775F, 0.0524948475F,
  0.0527113455F, 0.0529282715F, 0.0531456252F, 0.0533634066F,
  0.0535816154F, 0.0538002515F, 0.0540193148F, 0.0542388051F,
  0.0544587222F, 0.0546790660F, 0.0548998364F, 0.0551210331F,
  0.0553426561F, 0.0555647051F, 0.0557871801F, 0.0560100807F,
  0.0562334070F, 0.0564571587F, 0.0566813357F, 0.0569059378F,
  0.0571309649F, 0.0573564168F, 0.0575822933F, 0.0578085942F,
  0.0580353195F, 0.0582624689F, 0.0584900423F, 0.0587180396F,
  0.0589464605F, 0.0591753049F, 0.0594045726F, 0.0596342635F,
  0.0598643774F, 0.0600949141F, 0.0603258735F, 0.0605572555F,
  0.0607890597F, 0.0610212862F, 0.0612539346F, 0.0614870049F,
  0.0617204968F, 0.0619544103F, 0.0621887451F, 0.0624235010F,
  0.0626586780F, 0.0628942758F, 0.0631302942F, 0.0633667331F,
  0.0636035923F, 0.0638408717F, 0.0640785710F, 0.0643166901F,
  0.0645552288F, 0.0647941870F, 0.0650335645F, 0.0652733610F,
  0.0655135765F, 0.0657542108F, 0.0659952636F, 0.0662367348F,
  0.0664786242F, 0.0667209316F, 0.0669636570F, 0.0672068000F,
  0.0674503605F, 0.0676943384F, 0.0679387334F, 0.0681835454F,
  0.0684287742F, 0.0686744196F, 0.0689204814F, 0.0691669595F,
  0.0694138536F, 0.0696611637F, 0.0699088894F, 0.0701570307F,
  0.0704055873F, 0.0706545590F, 0.0709039458F, 0.0711537473F,
  0.0714039634F, 0.0716545939F, 0.0719056387F, 0.0721570975F,
  0.0724089702F, 0.0726612565F, 0.0729139563F, 0.0731670694F,
  0.0734205956F, 0.0736745347F, 0.0739288866F, 0.0741836510F,
  0.0744388277F, 0.0746944166F, 0.0749504175F, 0.0752068301F,
  0.0754636543F, 0.0757208899F, 0.0759785367F, 0.0762365946F,
  0.0764950632F, 0.0767539424F, 0.0770132320F, 0.0772729319F,
  0.0775330418F, 0.0777935616F, 0.0780544909F, 0.0783158298F,
  0.0785775778F, 0.0788397349F, 0.0791023009F, 0.0793652755F,
  0.0796286585F, 0.0798924498F, 0.0801566492F, 0.0804212564F,
  0.0806862712F, 0.0809516935F, 0.0812175231F, 0.0814837597F,
  0.0817504031F, 0.0820174532F, 0.0822849097F, 0.0825527724F,
  0.0828210412F, 0.0830897158F, 0.0833587960F, 0.0836282816F,
  0.0838981724F, 0.0841684682F, 0.0844391688F, 0.0847102740F,
  0.0849817835F, 0.0852536973F, 0.0855260150F, 0.0857987364F,
  0.0860718614F, 0.0863453897F, 0.0866193211F, 0.0868936554F,
  0.0871683924F, 0.0874435319F, 0.0877190737F, 0.0879950175F,
  0.0882713632F, 0.0885481105F, 0.0888252592F, 0.0891028091F,
  0.0893807600F, 0.0896591117F, 0.0899378639F, 0.0902170165F,
  0.0904965692F, 0.0907765218F, 0.0910568740F, 0.0913376258F,
  0.0916187767F, 0.0919003268F, 0.0921822756F, 0.0924646230F,
  0.0927473687F, 0.0930305126F, 0.0933140545F, 0.0935979940F,
  0.0938823310F, 0.0941670653F, 0.0944521966F, 0.0947377247F,
  0.0950236494F, 0.0953099704F, 0.0955966876F, 0.0958838007F,
  0.0961713094F, 0.0964592136F, 0.0967475131F, 0.0970362075F,
  0.0973252967F, 0.0976147805F, 0.0979046585F, 0.0981949307F,
  0.0984855967F, 0.0987766563F, 0.0990681093F, 0.0993599555F,
  0.0996521945F, 0.0999448263F, 0.1002378506F, 0.1005312671F,
  0.1008250755F, 0.1011192757F, 0.1014138675F, 0.1017088505F,
  0.1020042246F, 0.1022999895F, 0.1025961450F, 0.1028926909F,
  0.1031896268F, 0.1034869526F, 0.1037846680F, 0.1040827729F,
  0.1043812668F, 0.1046801497F, 0.1049794213F, 0.1052790813F,
  0.1055791294F, 0.1058795656F, 0.1061803894F, 0.1064816006F,
  0.1067831991F, 0.1070851846F, 0.1073875568F, 0.1076903155F,
  0.1079934604F, 0.1082969913F, 0.1086009079F, 0.1089052101F,
  0.1092098975F, 0.1095149699F, 0.1098204270F, 0.1101262687F,
  0.1104324946F, 0.1107391045F, 0.1110460982F, 0.1113534754F,
  0.1116612359F, 0.1119693793F, 0.1122779055F, 0.1125868142F,
  0.1128961052F, 0.1132057781F, 0.1135158328F, 0.1138262690F,
  0.1141370863F, 0.1144482847F, 0.1147598638F, 0.1150718233F,
  0.1153841631F, 0.1156968828F, 0.1160099822F, 0.1163234610F,
  0.1166373190F, 0.1169515559F, 0.1172661714F, 0.1175811654F,
  0.1178965374F, 0.1182122874F, 0.1185284149F, 0.1188449198F,
  0.1191618018F, 0.1194790606F, 0.1197966960F, 0.1201147076F,
  0.1204330953F, 0.1207518587F, 0.1210709976F, 0.1213905118F,
  0.1217104009F, 0.1220306647F, 0.1223513029F, 0.1226723153F,
  0.1229937016F, 0.1233154615F, 0.1236375948F, 0.1239601011F,
  0.1242829803F, 0.1246062319F, 0.1249298559F, 0.1252538518F,
  0.1255782195F, 0.1259029586F, 0.1262280689F, 0.1265535501F,
  0.1268794019F, 0.1272056241F, 0.1275322163F, 0.1278591784F,
  0.1281865099F, 0.1285142108F, 0.1288422805F, 0.1291707190F,
  0.1294995259F, 0.1298287009F, 0.1301582437F, 0.1304881542F,
  0.1308184319F, 0.1311490766F, 0.1314800881F, 0.1318114660F,
  0.1321432100F, 0.1324753200F, 0.1328077955F, 0.1331406364F,
  0.1334738422F, 0.1338074129F, 0.1341413479F, 0.1344756472F,
  0.1348103103F, 0.1351453370F, 0.1354807270F, 0.1358164801F,
  0.1361525959F, 0.1364890741F, 0.1368259145F, 0.1371631167F,
  0.1375006805F, 0.1378386056F, 0.1381768917F, 0.1385155384F,
  0.1388545456F, 0.1391939129F, 0.1395336400F, 0.1398737266F,
  0.1402141724F, 0.1405549772F, 0.1408961406F, 0.1412376623F,
  0.1415795421F, 0.1419217797F, 0.1422643746F, 0.1426073268F,
  0.1429506358F, 0.1432943013F, 0.1436383231F, 0.1439827008F,
  0.1443274342F, 0.1446725229F, 0.1450179667F, 0.1453637652F,
  0.1457099181F, 0.1460564252F, 0.1464032861F, 0.1467505006F,
  0.1470980682F, 0.1474459888F, 0.1477942620F, 0.1481428875F,
  0.1484918651F, 0.1488411942F, 0.1491908748F, 0.1495409065F,
  0.1498912889F, 0.1502420218F, 0.1505931048F, 0.1509445376F,
  0.1512963200F, 0.1516484516F, 0.1520009321F, 0.1523537612F,
  0.1527069385F, 0.1530604638F, 0.1534143368F, 0.1537685571F,
  0.1541231244F, 0.1544780384F, 0.1548332987F, 0.1551889052F,
  0.1555448574F, 0.1559011550F, 0.1562577978F, 0.1566147853F,
  0.1569721173F, 0.1573297935F, 0.1576878135F, 0.1580461771F,
  0.1584048838F, 0.1587639334F, 0.1591233255F, 0.1594830599F,
  0.1598431361F, 0.1602035540F, 0.1605643131F, 0.1609254131F,
  0.1612868537F, 0.1616486346F, 0.1620107555F, 0.1623732160F,
  0.1627360158F, 0.1630991545F, 0.1634626319F, 0.1638264476F,
  0.1641906013F, 0.1645550926F, 0.1649199212F, 0.1652850869F,
  0.1656505892F, 0.1660164278F, 0.1663826024F, 0.1667491127F,
  0.1671159583F, 0.1674831388F, 0.1678506541F, 0.1682185036F,
  0.1685866872F, 0.1689552044F, 0.1693240549F, 0.1696932384F,
  0.1700627545F, 0.1704326029F, 0.1708027833F, 0.1711732952F,
  0.1715441385F, 0.1719153127F, 0.1722868175F, 0.1726586526F,
  0.1730308176F, 0.1734033121F, 0.1737761359F, 0.1741492886F,
  0.1745227698F, 0.1748965792F, 0.1752707164F, 0.1756451812F,
  0.1760199731F, 0.1763950918F, 0.1767705370F, 0.1771463083F,
  0.1775224054F, 0.1778988279F, 0.1782755754F, 0.1786526477F,
  0.1790300444F, 0.1794077651F, 0.1797858094F, 0.1801641771F,
  0.1805428677F, 0.1809218810F, 0.1813012165F, 0.1816808739F,
  0.1820608528F, 0.1824411530F, 0.1828217739F, 0.1832027154F,
  0.1835839770F, 0.1839655584F, 0.1843474592F, 0.1847296790F,
  0.1851122175F, 0.1854950744F, 0.1858782492F, 0.1862617417F,
  0.1866455514F, 0.1870296780F, 0.1874141211F, 0.1877988804F,
  0.1881839555F, 0.1885693461F, 0.1889550517F, 0.1893410721F,
  0.1897274068F, 0.1901140555F, 0.1905010178F, 0.1908882933F,
  0.1912758818F, 0.1916637828F, 0.1920519959F, 0.1924405208F,
  0.1928293571F, 0.1932185044F, 0.1936079625F, 0.1939977308F,
  0.1943878091F, 0.1947781969F, 0.1951688939F, 0.1955598998F,
  0.1959512141F, 0.1963428364F, 0.1967347665F, 0.1971270038F,
  0.1975195482F, 0.1979123990F, 0.1983055561F, 0.1986990190F,
  0.1990927873F, 0.1994868607F, 0.1998812388F, 0.2002759212F,
  0.2006709075F, 0.2010661974F, 0.2014617904F, 0.2018576862F,
  0.2022538844F, 0.2026503847F, 0.2030471865F, 0.2034442897F,
  0.2038416937F, 0.2042393982F, 0.2046374028F, 0.2050357071F,
  0.2054343107F, 0.2058332133F, 0.2062324145F, 0.2066319138F,
  0.2070317110F, 0.2074318055F, 0.2078321970F, 0.2082328852F,
  0.2086338696F, 0.2090351498F, 0.2094367255F, 0.2098385962F,
  0.2102407617F, 0.2106432213F, 0.2110459749F, 0.2114490220F,
  0.2118523621F, 0.2122559950F, 0.2126599202F, 0.2130641373F,
  0.2134686459F, 0.2138734456F, 0.2142785361F, 0.2146839168F,
  0.2150895875F, 0.2154955478F, 0.2159017972F, 0.2163083353F,
  0.2167151617F, 0.2171222761F, 0.2175296780F, 0.2179373670F,
  0.2183453428F, 0.2187536049F, 0.2191621529F, 0.2195709864F,
  0.2199801051F, 0.2203895085F, 0.2207991961F, 0.2212091677F,
  0.2216194228F, 0.2220299610F, 0.2224407818F, 0.2228518850F,
  0.2232632699F, 0.2236749364F, 0.2240868839F, 0.2244991121F,
  0.2249116204F, 0.2253244086F, 0.2257374763F, 0.2261508229F,
  0.2265644481F, 0.2269783514F, 0.2273925326F, 0.2278069911F,
  0.2282217265F, 0.2286367384F, 0.2290520265F, 0.2294675902F,
  0.2298834292F, 0.2302995431F, 0.2307159314F, 0.2311325937F,
  0.2315495297F, 0.2319667388F, 0.2323842207F, 0.2328019749F,
  0.2332200011F, 0.2336382988F, 0.2340568675F, 0.2344757070F,
  0.2348948166F, 0.2353141961F, 0.2357338450F, 0.2361537629F,
  0.2365739493F, 0.2369944038F, 0.2374151261F, 0.2378361156F,
  0.2382573720F, 0.2386788948F, 0.2391006836F, 0.2395227380F,
  0.2399450575F, 0.2403676417F, 0.2407904902F, 0.2412136026F,
  0.2416369783F, 0.2420606171F, 0.2424845185F, 0.2429086820F,
  0.2433331072F, 0.2437577936F, 0.2441827409F, 0.2446079486F,
  0.2450334163F, 0.2454591435F, 0.2458851298F, 0.2463113747F,
  0.2467378779F, 0.2471646389F, 0.2475916573F, 0.2480189325F,
  0.2484464643F, 0.2488742521F, 0.2493022955F, 0.2497305940F,
  0.2501591473F, 0.2505879549F, 0.2510170163F, 0.2514463311F,
  0.2518758989F, 0.2523057193F, 0.2527357916F, 0.2531661157F,
  0.2535966909F, 0.2540275169F, 0.2544585931F, 0.2548899193F,
  0.2553214948F, 0.2557533193F, 0.2561853924F, 0.2566177135F,
  0.2570502822F, 0.2574830981F, 0.2579161608F, 0.2583494697F,
  0.2587830245F, 0.2592168246F, 0.2596508697F, 0.2600851593F,
  0.2605196929F, 0.2609544701F, 0.2613894904F, 0.2618247534F,
  0.2622602586F, 0.2626960055F, 0.2631319938F, 0.2635682230F,
  0.2640046925F, 0.2644414021F, 0.2648783511F, 0.2653155391F,
  0.2657529657F, 0.2661906305F, 0.2666285329F, 0.2670666725F,
  0.2675050489F, 0.2679436616F, 0.2683825101F, 0.2688215940F,
  0.2692609127F, 0.2697004660F, 0.2701402532F, 0.2705802739F,
  0.2710205278F, 0.2714610142F, 0.2719017327F, 0.2723426830F,
  0.2727838644F, 0.2732252766F, 0.2736669191F, 0.2741087914F,
  0.2745508930F, 0.2749932235F, 0.2754357824F, 0.2758785693F,
  0.2763215837F, 0.2767648251F, 0.2772082930F, 0.2776519870F,
  0.2780959066F, 0.2785400513F, 0.2789844207F, 0.2794290143F,
  0.2798738316F, 0.2803188722F, 0.2807641355F, 0.2812096211F,
  0.2816553286F, 0.2821012574F, 0.2825474071F, 0.2829937773F,
  0.2834403673F, 0.2838871768F, 0.2843342053F, 0.2847814523F,
  0.2852289174F, 0.2856765999F, 0.2861244996F, 0.2865726159F,
  0.2870209482F, 0.2874694962F, 0.2879182594F, 0.2883672372F,
  0.2888164293F, 0.2892658350F, 0.2897154540F, 0.2901652858F,
  0.2906153298F, 0.2910655856F, 0.2915160527F, 0.2919667306F,
  0.2924176189F, 0.2928687171F, 0.2933200246F, 0.2937715409F,
  0.2942232657F, 0.2946751984F, 0.2951273386F, 0.2955796856F,
  0.2960322391F, 0.2964849986F, 0.2969379636F, 0.2973911335F,
  0.2978445080F, 0.2982980864F, 0.2987518684F, 0.2992058534F,
  0.2996600409F, 0.3001144305F, 0.3005690217F, 0.3010238139F,
  0.3014788067F, 0.3019339995F, 0.3023893920F, 0.3028449835F,
  0.3033007736F, 0.3037567618F, 0.3042129477F, 0.3046693306F,
  0.3051259102F, 0.3055826859F, 0.3060396572F, 0.3064968236F,
  0.3069541847F, 0.3074117399F, 0.3078694887F, 0.3083274307F,
  0.3087855653F, 0.3092438920F, 0.3097024104F, 0.3101611199F,
  0.3106200200F, 0.3110791103F, 0.3115383902F, 0.3119978592F,
  0.3124575169F, 0.3129173627F, 0.3133773961F, 0.3138376166F,
  0.3142980238F, 0.3147586170F, 0.3152193959F, 0.3156803598F,
  0.3161415084F, 0.3166028410F, 0.3170643573F, 0.3175260566F,
  0.3179879384F, 0.3184500023F, 0.3189122478F, 0.3193746743F,
  0.3198372814F, 0.3203000685F, 0.3207630351F, 0.3212261807F,
  0.3216895048F, 0.3221530069F, 0.3226166865F, 0.3230805430F,
  0.3235445760F, 0.3240087849F, 0.3244731693F, 0.3249377285F,
  0.3254024622F, 0.3258673698F, 0.3263324507F, 0.3267977045F,
  0.3272631306F, 0.3277287286F, 0.3281944978F, 0.3286604379F,
  0.3291265482F, 0.3295928284F, 0.3300592777F, 0.3305258958F,
  0.3309926821F, 0.3314596361F, 0.3319267573F, 0.3323940451F,
  0.3328614990F, 0.3333291186F, 0.3337969033F, 0.3342648525F,
  0.3347329658F, 0.3352012427F, 0.3356696825F, 0.3361382849F,
  0.3366070492F, 0.3370759749F, 0.3375450616F, 0.3380143087F,
  0.3384837156F, 0.3389532819F, 0.3394230071F, 0.3398928905F,
  0.3403629317F, 0.3408331302F, 0.3413034854F, 0.3417739967F,
  0.3422446638F, 0.3427154860F, 0.3431864628F, 0.3436575938F,
  0.3441288782F, 0.3446003158F, 0.3450719058F, 0.3455436478F,
  0.3460155412F, 0.3464875856F, 0.3469597804F, 0.3474321250F,
  0.3479046189F, 0.3483772617F, 0.3488500527F, 0.3493229914F,
  0.3497960774F, 0.3502693100F, 0.3507426887F, 0.3512162131F,
  0.3516898825F, 0.3521636965F, 0.3526376545F, 0.3531117559F,
  0.3535860003F, 0.3540603870F, 0.3545349157F, 0.3550095856F,
  0.3554843964F, 0.3559593474F, 0.3564344381F, 0.3569096680F,
  0.3573850366F, 0.3578605432F, 0.3583361875F, 0.3588119687F,
  0.3592878865F, 0.3597639402F, 0.3602401293F, 0.3607164533F,
  0.3611929117F, 0.3616695038F, 0.3621462292F, 0.3626230873F,
  0.3631000776F, 0.3635771995F, 0.3640544525F, 0.3645318360F,
  0.3650093496F, 0.3654869926F, 0.3659647645F, 0.3664426648F,
  0.3669206930F, 0.3673988484F, 0.3678771306F, 0.3683555390F,
  0.3688340731F, 0.3693127322F, 0.3697915160F, 0.3702704237F,
  0.3707494549F, 0.3712286091F, 0.3717078857F, 0.3721872840F,
  0.3726668037F, 0.3731464441F, 0.3736262047F, 0.3741060850F,
  0.3745860843F, 0.3750662023F, 0.3755464382F, 0.3760267915F,
  0.3765072618F, 0.3769878484F, 0.3774685509F, 0.3779493686F,
  0.3784303010F, 0.3789113475F, 0.3793925076F, 0.3798737809F,
  0.3803551666F, 0.3808366642F, 0.3813182733F, 0.3817999932F,
  0.3822818234F, 0.3827637633F, 0.3832458124F, 0.3837279702F,
  0.3842102360F, 0.3846926093F, 0.3851750897F, 0.3856576764F,
  0.3861403690F, 0.3866231670F, 0.3871060696F, 0.3875890765F,
  0.3880721870F, 0.3885554007F, 0.3890387168F, 0.3895221349F,
  0.3900056544F, 0.3904892748F, 0.3909729955F, 0.3914568160F,
  0.3919407356F, 0.3924247539F, 0.3929088702F, 0.3933930841F,
  0.3938773949F, 0.3943618021F, 0.3948463052F, 0.3953309035F,
  0.3958155966F, 0.3963003838F, 0.3967852646F, 0.3972702385F,
  0.3977553048F, 0.3982404631F, 0.3987257127F, 0.3992110531F,
  0.3996964838F, 0.4001820041F, 0.4006676136F, 0.4011533116F,
  0.4016390976F, 0.4021249710F, 0.4026109313F, 0.4030969779F,
  0.4035831102F, 0.4040693277F, 0.4045556299F, 0.4050420160F,
  0.4055284857F, 0.4060150383F, 0.4065016732F, 0.4069883899F,
  0.4074751879F, 0.4079620665F, 0.4084490252F, 0.4089360635F,
  0.4094231807F, 0.4099103763F, 0.4103976498F, 0.4108850005F,
  0.4113724280F, 0.4118599315F, 0.4123475107F, 0.4128351648F,
  0.4133228934F, 0.4138106959F, 0.4142985716F, 0.4147865201F,
  0.4152745408F, 0.4157626330F, 0.4162507963F, 0.4167390301F,
  0.4172273337F, 0.4177157067F, 0.4182041484F, 0.4186926583F,
  0.4191812359F, 0.4196698805F, 0.4201585915F, 0.4206473685F,
  0.4211362108F, 0.4216251179F, 0.4221140892F, 0.4226031241F,
  0.4230922221F, 0.4235813826F, 0.4240706050F, 0.4245598887F,
  0.4250492332F, 0.4255386379F, 0.4260281022F, 0.4265176256F,
  0.4270072075F, 0.4274968473F, 0.4279865445F, 0.4284762984F,
  0.4289661086F, 0.4294559743F, 0.4299458951F, 0.4304358704F,
  0.4309258996F, 0.4314159822F, 0.4319061175F, 0.4323963050F,
  0.4328865441F, 0.4333768342F, 0.4338671749F, 0.4343575654F,
  0.4348480052F, 0.4353384938F, 0.4358290306F, 0.4363196149F,
  0.4368102463F, 0.4373009241F, 0.4377916478F, 0.4382824168F,
  0.4387732305F, 0.4392640884F, 0.4397549899F, 0.4402459343F,
  0.4407369212F, 0.4412279499F, 0.4417190198F, 0.4422101305F,
  0.4427012813F, 0.4431924717F, 0.4436837010F, 0.4441749686F,
  0.4446662742F, 0.4451576169F, 0.4456489963F, 0.4461404118F,
  0.4466318628F, 0.4471233487F, 0.4476148690F, 0.4481064230F,
  0.4485980103F, 0.4490896302F, 0.4495812821F, 0.4500729654F,
  0.4505646797F, 0.4510564243F, 0.4515481986F, 0.4520400021F,
  0.4525318341F, 0.4530236942F, 0.4535155816F, 0.4540074959F,
  0.4544994365F, 0.4549914028F, 0.4554833941F, 0.4559754100F,
  0.4564674499F, 0.4569595131F, 0.4574515991F, 0.4579437074F,
  0.4584358372F, 0.4589279881F, 0.4594201595F, 0.4599123508F,
  0.4604045615F, 0.4608967908F, 0.4613890383F, 0.4618813034F,
  0.4623735855F, 0.4628658841F, 0.4633581984F, 0.4638505281F,
  0.4643428724F, 0.4648352308F, 0.4653276028F, 0.4658199877F,
  0.4663123849F, 0.4668047940F, 0.4672972143F, 0.4677896451F,
  0.4682820861F, 0.4687745365F, 0.4692669958F, 0.4697594634F,
  0.4702519387F, 0.4707444211F, 0.4712369102F, 0.4717294052F,
  0.4722219056F, 0.4727144109F, 0.4732069204F, 0.4736994336F,
  0.4741919498F, 0.4746844686F, 0.4751769893F, 0.4756695113F,
  0.4761620341F, 0.4766545571F, 0.4771470797F, 0.4776396013F,
  0.4781321213F, 0.4786246392F, 0.4791171544F, 0.4796096663F,
  0.4801021744F, 0.4805946779F, 0.4810871765F, 0.4815796694F,
  0.4820721561F, 0.4825646360F, 0.4830571086F, 0.4835495732F,
  0.4840420293F, 0.4845344763F, 0.4850269136F, 0.4855193407F,
  0.4860117569F, 0.4865041617F, 0.4869965545F, 0.4874889347F,
  0.4879813018F, 0.4884736551F, 0.4889659941F, 0.4894583182F,
  0.4899506268F, 0.4904429193F, 0.4909351952F, 0.4914274538F,
  0.4919196947F, 0.4924119172F, 0.4929041207F, 0.4933963046F,
  0.4938884685F, 0.4943806116F, 0.4948727335F, 0.4953648335F,
  0.4958569110F, 0.4963489656F, 0.4968409965F, 0.4973330032F,
  0.4978249852F, 0.4983169419F, 0.4988088726F, 0.4993007768F,
  0.4997926539F, 0.5002845034F, 0.5007763247F, 0.5012681171F,
  0.5017598801F, 0.5022516132F, 0.5027433157F, 0.5032349871F,
  0.5037266268F, 0.5042182341F, 0.5047098086F, 0.5052013497F,
  0.5056928567F, 0.5061843292F, 0.5066757664F, 0.5071671679F,
  0.5076585330F, 0.5081498613F, 0.5086411520F, 0.5091324047F,
  0.5096236187F, 0.5101147934F, 0.5106059284F, 0.5110970230F,
  0.5115880766F, 0.5120790887F, 0.5125700587F, 0.5130609860F,
  0.5135518700F, 0.5140427102F, 0.5145335059F, 0.5150242566F,
  0.5155149618F, 0.5160056208F, 0.5164962331F, 0.5169867980F,
  0.5174773151F, 0.5179677837F, 0.5184582033F, 0.5189485733F,
  0.5194388931F, 0.5199291621F, 0.5204193798F, 0.5209095455F,
  0.5213996588F, 0.5218897190F, 0.5223797256F, 0.5228696779F,
  0.5233595755F, 0.5238494177F, 0.5243392039F, 0.5248289337F,
  0.5253186063F, 0.5258082213F, 0.5262977781F, 0.5267872760F,
  0.5272767146F, 0.5277660932F, 0.5282554112F, 0.5287446682F,
  0.5292338635F, 0.5297229965F, 0.5302120667F, 0.5307010736F,
  0.5311900164F, 0.5316788947F, 0.5321677079F, 0.5326564554F,
  0.5331451366F, 0.5336337511F, 0.5341222981F, 0.5346107771F,
  0.5350991876F, 0.5355875290F, 0.5360758007F, 0.5365640021F,
  0.5370521327F, 0.5375401920F, 0.5380281792F, 0.5385160939F,
  0.5390039355F, 0.5394917034F, 0.5399793971F, 0.5404670159F,
  0.5409545594F, 0.5414420269F, 0.5419294179F, 0.5424167318F,
  0.5429039680F, 0.5433911261F, 0.5438782053F, 0.5443652051F,
  0.5448521250F, 0.5453389644F, 0.5458257228F, 0.5463123995F,
  0.5467989940F, 0.5472855057F, 0.5477719341F, 0.5482582786F,
  0.5487445387F, 0.5492307137F, 0.5497168031F, 0.5502028063F,
  0.5506887228F, 0.5511745520F, 0.5516602934F, 0.5521459463F,
  0.5526315103F, 0.5531169847F, 0.5536023690F, 0.5540876626F,
  0.5545728649F, 0.5550579755F, 0.5555429937F, 0.5560279189F,
  0.5565127507F, 0.5569974884F, 0.5574821315F, 0.5579666794F,
  0.5584511316F, 0.5589354875F, 0.5594197465F, 0.5599039080F,
  0.5603879716F, 0.5608719367F, 0.5613558026F, 0.5618395689F,
  0.5623232350F, 0.5628068002F, 0.5632902642F, 0.5637736262F,
  0.5642568858F, 0.5647400423F, 0.5652230953F, 0.5657060442F,
  0.5661888883F, 0.5666716272F, 0.5671542603F, 0.5676367870F,
  0.5681192069F, 0.5686015192F, 0.5690837235F, 0.5695658192F,
  0.5700478058F, 0.5705296827F, 0.5710114494F, 0.5714931052F,
  0.5719746497F, 0.5724560822F, 0.5729374023F, 0.5734186094F,
  0.5738997029F, 0.5743806823F, 0.5748615470F, 0.5753422965F,
  0.5758229301F, 0.5763034475F, 0.5767838480F, 0.5772641310F,
  0.5777442960F, 0.5782243426F, 0.5787042700F, 0.5791840778F,
  0.5796637654F, 0.5801433322F, 0.5806227778F, 0.5811021016F,
  0.5815813029F, 0.5820603814F, 0.5825393363F, 0.5830181673F,
  0.5834968737F, 0.5839754549F, 0.5844539105F, 0.5849322399F,
  0.5854104425F, 0.5858885179F, 0.5863664653F, 0.5868442844F,
  0.5873219746F, 0.5877995353F, 0.5882769660F, 0.5887542661F,
  0.5892314351F, 0.5897084724F, 0.5901853776F, 0.5906621500F,
  0.5911387892F, 0.5916152945F, 0.5920916655F, 0.5925679016F,
  0.5930440022F, 0.5935199669F, 0.5939957950F, 0.5944714861F,
  0.5949470396F, 0.5954224550F, 0.5958977317F, 0.5963728692F,
  0.5968478669F, 0.5973227244F, 0.5977974411F, 0.5982720163F,
  0.5987464497F, 0.5992207407F, 0.5996948887F, 0.6001688932F,
  0.6006427537F, 0.6011164696F, 0.6015900405F, 0.6020634657F,
  0.6025367447F, 0.6030098770F, 0.6034828621F, 0.6039556995F,
  0.6044283885F, 0.6049009288F, 0.6053733196F, 0.6058455606F,
  0.6063176512F, 0.6067895909F, 0.6072613790F, 0.6077330152F,
  0.6082044989F, 0.6086758295F, 0.6091470065F, 0.6096180294F,
  0.6100888977F, 0.6105596108F, 0.6110301682F, 0.6115005694F,
  0.6119708139F, 0.6124409011F, 0.6129108305F, 0.6133806017F,
  0.6138502139F, 0.6143196669F, 0.6147889599F, 0.6152580926F,
  0.6157270643F, 0.6161958746F, 0.6166645230F, 0.6171330088F,
  0.6176013317F, 0.6180694910F, 0.6185374863F, 0.6190053171F,
  0.6194729827F, 0.6199404828F, 0.6204078167F, 0.6208749841F,
  0.6213419842F, 0.6218088168F, 0.6222754811F, 0.6227419768F,
  0.6232083032F, 0.6236744600F, 0.6241404465F, 0.6246062622F,
  0.6250719067F, 0.6255373795F, 0.6260026799F, 0.6264678076F,
  0.6269327619F, 0.6273975425F, 0.6278621487F, 0.6283265800F,
  0.6287908361F, 0.6292549163F, 0.6297188201F, 0.6301825471F,
  0.6306460966F, 0.6311094683F, 0.6315726617F, 0.6320356761F,
  0.6324985111F, 0.6329611662F, 0.6334236410F, 0.6338859348F,
  0.6343480472F, 0.6348099777F, 0.6352717257F, 0.6357332909F,
  0.6361946726F, 0.6366558704F, 0.6371168837F, 0.6375777122F,
  0.6380383552F, 0.6384988123F, 0.6389590830F, 0.6394191668F,
  0.6398790631F, 0.6403387716F, 0.6407982916F, 0.6412576228F,
  0.6417167645F, 0.6421757163F, 0.6426344778F, 0.6430930483F,
  0.6435514275F, 0.6440096149F, 0.6444676098F, 0.6449254119F,
  0.6453830207F, 0.6458404356F, 0.6462976562F, 0.6467546820F,
  0.6472115125F, 0.6476681472F, 0.6481245856F, 0.6485808273F,
  0.6490368717F, 0.6494927183F, 0.6499483667F, 0.6504038164F,
  0.6508590670F, 0.6513141178F, 0.6517689684F, 0.6522236185F,
  0.6526780673F, 0.6531323146F, 0.6535863598F, 0.6540402024F,
  0.6544938419F, 0.6549472779F, 0.6554005099F, 0.6558535373F,
  0.6563063598F, 0.6567589769F, 0.6572113880F, 0.6576635927F,
  0.6581155906F, 0.6585673810F, 0.6590189637F, 0.6594703380F,
  0.6599215035F, 0.6603724598F, 0.6608232064F, 0.6612737427F,
  0.6617240684F, 0.6621741829F, 0.6626240859F, 0.6630737767F,
  0.6635232550F, 0.6639725202F, 0.6644215720F, 0.6648704098F,
  0.6653190332F, 0.6657674417F, 0.6662156348F, 0.6666636121F,
  0.6671113731F, 0.6675589174F, 0.6680062445F, 0.6684533538F,
  0.6689002450F, 0.6693469177F, 0.6697933712F, 0.6702396052F,
  0.6706856193F, 0.6711314129F, 0.6715769855F, 0.6720223369F,
  0.6724674664F, 0.6729123736F, 0.6733570581F, 0.6738015194F,
  0.6742457570F, 0.6746897706F, 0.6751335596F, 0.6755771236F,
  0.6760204621F, 0.6764635747F, 0.6769064609F, 0.6773491204F,
  0.6777915525F, 0.6782337570F, 0.6786757332F, 0.6791174809F,
  0.6795589995F, 0.6800002886F, 0.6804413477F, 0.6808821765F,
  0.6813227743F, 0.6817631409F, 0.6822032758F, 0.6826431785F,
  0.6830828485F, 0.6835222855F, 0.6839614890F, 0.6844004585F,
  0.6848391936F, 0.6852776939F, 0.6857159589F, 0.6861539883F,
  0.6865917815F, 0.6870293381F, 0.6874666576F, 0.6879037398F,
  0.6883405840F, 0.6887771899F, 0.6892135571F, 0.6896496850F,
  0.6900855733F, 0.6905212216F, 0.6909566294F, 0.6913917963F,
  0.6918267218F, 0.6922614055F, 0.6926958471F, 0.6931300459F,
  0.6935640018F, 0.6939977141F, 0.6944311825F, 0.6948644066F,
  0.6952973859F, 0.6957301200F, 0.6961626085F, 0.6965948510F,
  0.6970268470F, 0.6974585961F, 0.6978900980F, 0.6983213521F,
  0.6987523580F, 0.6991831154F, 0.6996136238F, 0.7000438828F,
  0.7004738921F, 0.7009036510F, 0.7013331594F, 0.7017624166F,
  0.7021914224F, 0.7026201763F, 0.7030486779F, 0.7034769268F,
  0.7039049226F, 0.7043326648F, 0.7047601531F, 0.7051873870F,
  0.7056143662F, 0.7060410902F, 0.7064675586F, 0.7068937711F,
  0.7073197271F, 0.7077454264F, 0.7081708684F, 0.7085960529F,
  0.7090209793F, 0.7094456474F, 0.7098700566F, 0.7102942066F,
  0.7107180970F, 0.7111417274F, 0.7115650974F, 0.7119882066F,
  0.7124110545F, 0.7128336409F, 0.7132559653F, 0.7136780272F,
  0.7140998264F, 0.7145213624F, 0.7149426348F, 0.7153636433F,
  0.7157843874F, 0.7162048668F, 0.7166250810F, 0.7170450296F,
  0.7174647124F, 0.7178841289F, 0.7183032786F, 0.7187221613F,
  0.7191407765F, 0.7195591239F, 0.7199772030F, 0.7203950135F,
  0.7208125550F, 0.7212298271F, 0.7216468294F, 0.7220635616F,
  0.7224800233F, 0.7228962140F, 0.7233121335F, 0.7237277813F,
  0.7241431571F, 0.7245582604F, 0.7249730910F, 0.7253876484F,
  0.7258019322F, 0.7262159422F, 0.7266296778F, 0.7270431388F,
  0.7274563247F, 0.7278692353F, 0.7282818700F, 0.7286942287F,
  0.7291063108F, 0.7295181160F, 0.7299296440F, 0.7303408944F,
  0.7307518669F, 0.7311625609F, 0.7315729763F, 0.7319831126F,
  0.7323929695F, 0.7328025466F, 0.7332118435F, 0.7336208600F,
  0.7340295955F, 0.7344380499F, 0.7348462226F, 0.7352541134F,
  0.7356617220F, 0.7360690478F, 0.7364760907F, 0.7368828502F,
  0.7372893259F, 0.7376955176F, 0.7381014249F, 0.7385070475F,
  0.7389123849F, 0.7393174368F, 0.7397222029F, 0.7401266829F,
  0.7405308763F, 0.7409347829F, 0.7413384023F, 0.7417417341F,
  0.7421447780F, 0.7425475338F, 0.7429500009F, 0.7433521791F,
  0.7437540681F, 0.7441556674F, 0.7445569769F, 0.7449579960F,
  0.7453587245F, 0.7457591621F, 0.7461593084F, 0.7465591631F,
  0.7469587259F, 0.7473579963F, 0.7477569741F, 0.7481556590F,
  0.7485540506F, 0.7489521486F, 0.7493499526F, 0.7497474623F,
  0.7501446775F, 0.7505415977F, 0.7509382227F, 0.7513345521F,
  0.7517305856F, 0.7521263229F, 0.7525217636F, 0.7529169074F,
  0.7533117541F, 0.7537063032F, 0.7541005545F, 0.7544945076F,
  0.7548881623F, 0.7552815182F, 0.7556745749F, 0.7560673323F,
  0.7564597899F, 0.7568519474F, 0.7572438046F, 0.7576353611F,
  0.7580266166F, 0.7584175708F, 0.7588082235F, 0.7591985741F,
  0.7595886226F, 0.7599783685F, 0.7603678116F, 0.7607569515F,
  0.7611457879F, 0.7615343206F, 0.7619225493F, 0.7623104735F,
  0.7626980931F, 0.7630854078F, 0.7634724171F, 0.7638591209F,
  0.7642455188F, 0.7646316106F, 0.7650173959F, 0.7654028744F,
  0.7657880459F, 0.7661729100F, 0.7665574664F, 0.7669417150F,
  0.7673256553F, 0.7677092871F, 0.7680926100F, 0.7684756239F,
  0.7688583284F, 0.7692407232F, 0.7696228080F, 0.7700045826F,
  0.7703860467F, 0.7707671999F, 0.7711480420F, 0.7715285728F,
  0.7719087918F, 0.7722886989F, 0.7726682938F, 0.7730475762F,
  0.7734265458F, 0.7738052023F, 0.7741835454F, 0.7745615750F,
  0.7749392906F, 0.7753166921F, 0.7756937791F, 0.7760705514F,
  0.7764470087F, 0.7768231508F, 0.7771989773F, 0.7775744880F,
  0.7779496827F, 0.7783245610F, 0.7786991227F, 0.7790733676F,
  0.7794472953F, 0.7798209056F, 0.7801941982F, 0.7805671729F,
  0.7809398294F, 0.7813121675F, 0.7816841869F, 0.7820558873F,
  0.7824272684F, 0.7827983301F, 0.7831690720F, 0.7835394940F,
  0.7839095957F, 0.7842793768F, 0.7846488373F, 0.7850179767F,
  0.7853867948F, 0.7857552914F, 0.7861234663F, 0.7864913191F,
  0.7868588497F, 0.7872260578F, 0.7875929431F, 0.7879595055F,
  0.7883257445F, 0.7886916601F, 0.7890572520F, 0.7894225198F,
  0.7897874635F, 0.7901520827F, 0.7905163772F, 0.7908803468F,
  0.7912439912F, 0.7916073102F, 0.7919703035F, 0.7923329710F,
  0.7926953124F, 0.7930573274F, 0.7934190158F, 0.7937803774F,
  0.7941414120F, 0.7945021193F, 0.7948624991F, 0.7952225511F,
  0.7955822752F, 0.7959416711F, 0.7963007387F, 0.7966594775F,
  0.7970178875F, 0.7973759685F, 0.7977337201F, 0.7980911422F,
  0.7984482346F, 0.7988049970F, 0.7991614292F, 0.7995175310F,
  0.7998733022F, 0.8002287426F, 0.8005838519F, 0.8009386299F,
  0.8012930765F, 0.8016471914F, 0.8020009744F, 0.8023544253F,
  0.8027075438F, 0.8030603298F, 0.8034127831F, 0.8037649035F,
  0.8041166906F, 0.8044681445F, 0.8048192647F, 0.8051700512F,
  0.8055205038F, 0.8058706222F, 0.8062204062F, 0.8065698556F,
  0.8069189702F, 0.8072677499F, 0.8076161944F, 0.8079643036F,
  0.8083120772F, 0.8086595151F, 0.8090066170F, 0.8093533827F,
  0.8096998122F, 0.8100459051F, 0.8103916613F, 0.8107370806F,
  0.8110821628F, 0.8114269077F, 0.8117713151F, 0.8121153849F,
  0.8124591169F, 0.8128025108F, 0.8131455666F, 0.8134882839F,
  0.8138306627F, 0.8141727027F, 0.8145144038F, 0.8148557658F,
  0.8151967886F, 0.8155374718F, 0.8158778154F, 0.8162178192F,
  0.8165574830F, 0.8168968067F, 0.8172357900F, 0.8175744328F,
  0.8179127349F, 0.8182506962F, 0.8185883164F, 0.8189255955F,
  0.8192625332F, 0.8195991295F, 0.8199353840F, 0.8202712967F,
  0.8206068673F, 0.8209420958F, 0.8212769820F, 0.8216115256F,
  0.8219457266F, 0.8222795848F, 0.8226131000F, 0.8229462721F,
  0.8232791009F, 0.8236115863F, 0.8239437280F, 0.8242755260F,
  0.8246069801F, 0.8249380901F, 0.8252688559F, 0.8255992774F,
  0.8259293544F, 0.8262590867F, 0.8265884741F, 0.8269175167F,
  0.8272462141F, 0.8275745663F, 0.8279025732F, 0.8282302344F,
  0.8285575501F, 0.8288845199F, 0.8292111437F, 0.8295374215F,
  0.8298633530F, 0.8301889382F, 0.8305141768F, 0.8308390688F,
  0.8311636141F, 0.8314878124F, 0.8318116637F, 0.8321351678F,
  0.8324583246F, 0.8327811340F, 0.8331035957F, 0.8334257098F,
  0.8337474761F, 0.8340688944F, 0.8343899647F, 0.8347106867F,
  0.8350310605F, 0.8353510857F, 0.8356707624F, 0.8359900904F,
  0.8363090696F, 0.8366276999F, 0.8369459811F, 0.8372639131F,
  0.8375814958F, 0.8378987292F, 0.8382156130F, 0.8385321472F,
  0.8388483316F, 0.8391641662F, 0.8394796508F, 0.8397947853F,
  0.8401095697F, 0.8404240037F, 0.8407380873F, 0.8410518204F,
  0.8413652029F, 0.8416782347F, 0.8419909156F, 0.8423032456F,
  0.8426152245F, 0.8429268523F, 0.8432381289F, 0.8435490541F,
  0.8438596279F, 0.8441698502F, 0.8444797208F, 0.8447892396F,
  0.8450984067F, 0.8454072218F, 0.8457156849F, 0.8460237959F,
  0.8463315547F, 0.8466389612F, 0.8469460154F, 0.8472527170F,
  0.8475590661F, 0.8478650625F, 0.8481707063F, 0.8484759971F,
  0.8487809351F, 0.8490855201F, 0.8493897521F, 0.8496936308F,
  0.8499971564F, 0.8503003286F, 0.8506031474F, 0.8509056128F,
  0.8512077246F, 0.8515094828F, 0.8518108872F, 0.8521119379F,
  0.8524126348F, 0.8527129777F, 0.8530129666F, 0.8533126015F,
  0.8536118822F, 0.8539108087F, 0.8542093809F, 0.8545075988F,
  0.8548054623F, 0.8551029712F, 0.8554001257F, 0.8556969255F,
  0.8559933707F, 0.8562894611F, 0.8565851968F, 0.8568805775F,
  0.8571756034F, 0.8574702743F, 0.8577645902F, 0.8580585509F,
  0.8583521566F, 0.8586454070F, 0.8589383021F, 0.8592308420F,
  0.8595230265F, 0.8598148556F, 0.8601063292F, 0.8603974473F,
  0.8606882098F, 0.8609786167F, 0.8612686680F, 0.8615583636F,
  0.8618477034F, 0.8621366874F, 0.8624253156F, 0.8627135878F,
  0.8630015042F, 0.8632890646F, 0.8635762690F, 0.8638631173F,
  0.8641496096F, 0.8644357457F, 0.8647215257F, 0.8650069495F,
  0.8652920171F, 0.8655767283F, 0.8658610833F, 0.8661450820F,
  0.8664287243F, 0.8667120102F, 0.8669949397F, 0.8672775127F,
  0.8675597293F, 0.8678415894F, 0.8681230929F, 0.8684042398F,
  0.8686850302F, 0.8689654640F, 0.8692455412F, 0.8695252617F,
  0.8698046255F, 0.8700836327F, 0.8703622831F, 0.8706405768F,
  0.8709185138F, 0.8711960940F, 0.8714733174F, 0.8717501840F,
  0.8720266939F, 0.8723028469F, 0.8725786430F, 0.8728540824F,
  0.8731291648F, 0.8734038905F, 0.8736782592F, 0.8739522711F,
  0.8742259261F, 0.8744992242F, 0.8747721653F, 0.8750447496F,
  0.8753169770F, 0.8755888475F, 0.8758603611F, 0.8761315177F,
  0.8764023175F, 0.8766727603F, 0.8769428462F, 0.8772125752F,
  0.8774819474F, 0.8777509626F, 0.8780196209F, 0.8782879224F,
  0.8785558669F, 0.8788234546F, 0.8790906854F, 0.8793575594F,
  0.8796240765F, 0.8798902368F, 0.8801560403F, 0.8804214870F,
  0.8806865768F, 0.8809513099F, 0.8812156863F, 0.8814797059F,
  0.8817433687F, 0.8820066749F, 0.8822696243F, 0.8825322171F,
  0.8827944532F, 0.8830563327F, 0.8833178556F, 0.8835790219F,
  0.8838398316F, 0.8841002848F, 0.8843603815F, 0.8846201217F,
  0.8848795054F, 0.8851385327F, 0.8853972036F, 0.8856555182F,
  0.8859134764F, 0.8861710783F, 0.8864283239F, 0.8866852133F,
  0.8869417464F, 0.8871979234F, 0.8874537443F, 0.8877092090F,
  0.8879643177F, 0.8882190704F, 0.8884734671F, 0.8887275078F,
  0.8889811927F, 0.8892345216F, 0.8894874948F, 0.8897401122F,
  0.8899923738F, 0.8902442798F, 0.8904958301F, 0.8907470248F,
  0.8909978640F, 0.8912483477F, 0.8914984759F, 0.8917482487F,
  0.8919976662F, 0.8922467284F, 0.8924954353F, 0.8927437871F,
  0.8929917837F, 0.8932394252F, 0.8934867118F, 0.8937336433F,
  0.8939802199F, 0.8942264417F, 0.8944723087F, 0.8947178210F,
  0.8949629785F, 0.8952077815F, 0.8954522299F, 0.8956963239F,
  0.8959400634F, 0.8961834486F, 0.8964264795F, 0.8966691561F,
  0.8969114786F, 0.8971534470F, 0.8973950614F, 0.8976363219F,
  0.8978772284F, 0.8981177812F, 0.8983579802F, 0.8985978256F,
  0.8988373174F, 0.8990764556F, 0.8993152405F, 0.8995536720F,
  0.8997917502F, 0.9000294751F, 0.9002668470F, 0.9005038658F,
  0.9007405317F, 0.9009768446F, 0.9012128048F, 0.9014484123F,
  0.9016836671F, 0.9019185693F, 0.9021531191F, 0.9023873165F,
  0.9026211616F, 0.9028546546F, 0.9030877954F, 0.9033205841F,
  0.9035530210F, 0.9037851059F, 0.9040168392F, 0.9042482207F,
  0.9044792507F, 0.9047099293F, 0.9049402564F, 0.9051702323F,
  0.9053998569F, 0.9056291305F, 0.9058580531F, 0.9060866248F,
  0.9063148457F, 0.9065427159F, 0.9067702355F, 0.9069974046F,
  0.9072242233F, 0.9074506917F, 0.9076768100F, 0.9079025782F,
  0.9081279964F, 0.9083530647F, 0.9085777833F, 0.9088021523F,
  0.9090261717F, 0.9092498417F, 0.9094731623F, 0.9096961338F,
  0.9099187561F, 0.9101410295F, 0.9103629540F, 0.9105845297F,
  0.9108057568F, 0.9110266354F, 0.9112471656F, 0.9114673475F,
  0.9116871812F, 0.9119066668F, 0.9121258046F, 0.9123445945F,
  0.9125630367F, 0.9127811314F, 0.9129988786F, 0.9132162785F,
  0.9134333312F, 0.9136500368F, 0.9138663954F, 0.9140824073F,
  0.9142980724F, 0.9145133910F, 0.9147283632F, 0.9149429890F,
  0.9151572687F, 0.9153712023F, 0.9155847900F, 0.9157980319F,
  0.9160109282F, 0.9162234790F, 0.9164356844F, 0.9166475445F,
  0.9168590595F, 0.9170702296F, 0.9172810548F, 0.9174915354F,
  0.9177016714F, 0.9179114629F, 0.9181209102F, 0.9183300134F,
  0.9185387726F, 0.9187471879F, 0.9189552595F, 0.9191629876F,
  0.9193703723F, 0.9195774136F, 0.9197841119F, 0.9199904672F,
  0.9201964797F, 0.9204021495F, 0.9206074767F, 0.9208124616F,
  0.9210171043F, 0.9212214049F, 0.9214253636F, 0.9216289805F,
  0.9218322558F, 0.9220351896F, 0.9222377821F, 0.9224400335F,
  0.9226419439F, 0.9228435134F, 0.9230447423F, 0.9232456307F,
  0.9234461787F, 0.9236463865F, 0.9238462543F, 0.9240457822F,
  0.9242449704F, 0.9244438190F, 0.9246423282F, 0.9248404983F,
  0.9250383293F, 0.9252358214F, 0.9254329747F, 0.9256297896F,
  0.9258262660F, 0.9260224042F, 0.9262182044F, 0.9264136667F,
  0.9266087913F, 0.9268035783F, 0.9269980280F, 0.9271921405F,
  0.9273859160F, 0.9275793546F, 0.9277724566F, 0.9279652221F,
  0.9281576513F, 0.9283497443F, 0.9285415014F, 0.9287329227F,
  0.9289240084F, 0.9291147586F, 0.9293051737F, 0.9294952536F,
  0.9296849987F, 0.9298744091F, 0.9300634850F, 0.9302522266F,
  0.9304406340F, 0.9306287074F, 0.9308164471F, 0.9310038532F,
  0.9311909259F, 0.9313776654F, 0.9315640719F, 0.9317501455F,
  0.9319358865F, 0.9321212951F, 0.9323063713F, 0.9324911155F,
  0.9326755279F, 0.9328596085F, 0.9330433577F, 0.9332267756F,
  0.9334098623F, 0.9335926182F, 0.9337750434F, 0.9339571380F,
  0.9341389023F, 0.9343203366F, 0.9345014409F, 0.9346822155F,
  0.9348626606F, 0.9350427763F, 0.9352225630F, 0.9354020207F,
  0.9355811498F, 0.9357599503F, 0.9359384226F, 0.9361165667F,
  0.9362943830F, 0.9364718716F, 0.9366490327F, 0.9368258666F,
  0.9370023733F, 0.9371785533F, 0.9373544066F, 0.9375299335F,
  0.9377051341F, 0.9378800087F, 0.9380545576F, 0.9382287809F,
  0.9384026787F, 0.9385762515F, 0.9387494993F, 0.9389224223F,
  0.9390950209F, 0.9392672951F, 0.9394392453F, 0.9396108716F,
  0.9397821743F, 0.9399531536F, 0.9401238096F, 0.9402941427F,
  0.9404641530F, 0.9406338407F, 0.9408032061F, 0.9409722495F,
  0.9411409709F, 0.9413093707F, 0.9414774491F, 0.9416452062F,
  0.9418126424F, 0.9419797579F, 0.9421465528F, 0.9423130274F,
  0.9424791819F, 0.9426450166F, 0.9428105317F, 0.9429757274F,
  0.9431406039F, 0.9433051616F, 0.9434694005F, 0.9436333209F,
  0.9437969232F, 0.9439602074F, 0.9441231739F, 0.9442858229F,
  0.9444481545F, 0.9446101691F, 0.9447718669F, 0.9449332481F,
  0.9450943129F, 0.9452550617F, 0.9454154945F, 0.9455756118F,
  0.9457354136F, 0.9458949003F, 0.9460540721F, 0.9462129292F,
  0.9463714719F, 0.9465297003F, 0.9466876149F, 0.9468452157F,
  0.9470025031F, 0.9471594772F, 0.9473161384F, 0.9474724869F,
  0.9476285229F, 0.9477842466F, 0.9479396584F, 0.9480947585F,
  0.9482495470F, 0.9484040243F, 0.9485581906F, 0.9487120462F,
  0.9488655913F, 0.9490188262F, 0.9491717511F, 0.9493243662F,
  0.9494766718F, 0.9496286683F, 0.9497803557F, 0.9499317345F,
  0.9500828047F, 0.9502335668F, 0.9503840209F, 0.9505341673F,
  0.9506840062F, 0.9508335380F, 0.9509827629F, 0.9511316810F,
  0.9512802928F, 0.9514285984F, 0.9515765982F, 0.9517242923F,
  0.9518716810F, 0.9520187646F, 0.9521655434F, 0.9523120176F,
  0.9524581875F, 0.9526040534F, 0.9527496154F, 0.9528948739F,
  0.9530398292F, 0.9531844814F, 0.9533288310F, 0.9534728780F,
  0.9536166229F, 0.9537600659F, 0.9539032071F, 0.9540460470F,
  0.9541885858F, 0.9543308237F, 0.9544727611F, 0.9546143981F,
  0.9547557351F, 0.9548967723F, 0.9550375100F, 0.9551779485F,
  0.9553180881F, 0.9554579290F, 0.9555974714F, 0.9557367158F,
  0.9558756623F, 0.9560143112F, 0.9561526628F, 0.9562907174F,
  0.9564284752F, 0.9565659366F, 0.9567031017F, 0.9568399710F,
  0.9569765446F, 0.9571128229F, 0.9572488061F, 0.9573844944F,
  0.9575198883F, 0.9576549879F, 0.9577897936F, 0.9579243056F,
  0.9580585242F, 0.9581924497F, 0.9583260824F, 0.9584594226F,
  0.9585924705F, 0.9587252264F, 0.9588576906F, 0.9589898634F,
  0.9591217452F, 0.9592533360F, 0.9593846364F, 0.9595156465F,
  0.9596463666F, 0.9597767971F, 0.9599069382F, 0.9600367901F,
  0.9601663533F, 0.9602956279F, 0.9604246143F, 0.9605533128F,
  0.9606817236F, 0.9608098471F, 0.9609376835F, 0.9610652332F,
  0.9611924963F, 0.9613194733F, 0.9614461644F, 0.9615725699F,
  0.9616986901F, 0.9618245253F, 0.9619500757F, 0.9620753418F,
  0.9622003238F, 0.9623250219F, 0.9624494365F, 0.9625735679F,
  0.9626974163F, 0.9628209821F, 0.9629442656F, 0.9630672671F,
  0.9631899868F, 0.9633124251F, 0.9634345822F, 0.9635564585F,
  0.9636780543F, 0.9637993699F, 0.9639204056F, 0.9640411616F,
  0.9641616383F, 0.9642818359F, 0.9644017549F, 0.9645213955F,
  0.9646407579F, 0.9647598426F, 0.9648786497F, 0.9649971797F,
  0.9651154328F, 0.9652334092F, 0.9653511095F, 0.9654685337F,
  0.9655856823F, 0.9657025556F, 0.9658191538F, 0.9659354773F,
  0.9660515263F, 0.9661673013F, 0.9662828024F, 0.9663980300F,
  0.9665129845F, 0.9666276660F, 0.9667420750F, 0.9668562118F,
  0.9669700766F, 0.9670836698F, 0.9671969917F, 0.9673100425F,
  0.9674228227F, 0.9675353325F, 0.9676475722F, 0.9677595422F,
  0.9678712428F, 0.9679826742F, 0.9680938368F, 0.9682047309F,
  0.9683153569F, 0.9684257150F, 0.9685358056F, 0.9686456289F,
  0.9687551853F, 0.9688644752F, 0.9689734987F, 0.9690822564F,
  0.9691907483F, 0.9692989750F, 0.9694069367F, 0.9695146337F,
  0.9696220663F, 0.9697292349F, 0.9698361398F, 0.9699427813F,
  0.9700491597F, 0.9701552754F, 0.9702611286F, 0.9703667197F,
  0.9704720490F, 0.9705771169F, 0.9706819236F, 0.9707864695F,
  0.9708907549F, 0.9709947802F, 0.9710985456F, 0.9712020514F,
  0.9713052981F, 0.9714082859F, 0.9715110151F, 0.9716134862F,
  0.9717156993F, 0.9718176549F, 0.9719193532F, 0.9720207946F,
  0.9721219794F, 0.9722229080F, 0.9723235806F, 0.9724239976F,
  0.9725241593F, 0.9726240661F, 0.9727237183F, 0.9728231161F,
  0.9729222601F, 0.9730211503F, 0.9731197873F, 0.9732181713F,
  0.9733163027F, 0.9734141817F, 0.9735118088F, 0.9736091842F,
  0.9737063083F, 0.9738031814F, 0.9738998039F, 0.9739961760F,
  0.9740922981F, 0.9741881706F, 0.9742837938F, 0.9743791680F,
  0.9744742935F, 0.9745691707F, 0.9746637999F, 0.9747581814F,
  0.9748523157F, 0.9749462029F, 0.9750398435F, 0.9751332378F,
  0.9752263861F, 0.9753192887F, 0.9754119461F, 0.9755043585F,
  0.9755965262F, 0.9756884496F, 0.9757801291F, 0.9758715650F,
  0.9759627575F, 0.9760537071F, 0.9761444141F, 0.9762348789F,
  0.9763251016F, 0.9764150828F, 0.9765048228F, 0.9765943218F,
  0.9766835802F, 0.9767725984F, 0.9768613767F, 0.9769499154F,
  0.9770382149F, 0.9771262755F, 0.9772140976F, 0.9773016815F,
  0.9773890275F, 0.9774761360F, 0.9775630073F, 0.9776496418F,
  0.9777360398F, 0.9778222016F, 0.9779081277F, 0.9779938182F,
  0.9780792736F, 0.9781644943F, 0.9782494805F, 0.9783342326F,
  0.9784187509F, 0.9785030359F, 0.9785870877F, 0.9786709069F,
  0.9787544936F, 0.9788378484F, 0.9789209714F, 0.9790038631F,
  0.9790865238F, 0.9791689538F, 0.9792511535F, 0.9793331232F,
  0.9794148633F, 0.9794963742F, 0.9795776561F, 0.9796587094F,
  0.9797395345F, 0.9798201316F, 0.9799005013F, 0.9799806437F,
  0.9800605593F, 0.9801402483F, 0.9802197112F, 0.9802989483F,
  0.9803779600F, 0.9804567465F, 0.9805353082F, 0.9806136455F,
  0.9806917587F, 0.9807696482F, 0.9808473143F, 0.9809247574F,
  0.9810019778F, 0.9810789759F, 0.9811557519F, 0.9812323064F,
  0.9813086395F, 0.9813847517F, 0.9814606433F, 0.9815363147F,
  0.9816117662F, 0.9816869981F, 0.9817620108F, 0.9818368047F,
  0.9819113801F, 0.9819857374F, 0.9820598769F, 0.9821337989F,
  0.9822075038F, 0.9822809920F, 0.9823542638F, 0.9824273195F,
  0.9825001596F, 0.9825727843F, 0.9826451940F, 0.9827173891F,
  0.9827893700F, 0.9828611368F, 0.9829326901F, 0.9830040302F,
  0.9830751574F, 0.9831460720F, 0.9832167745F, 0.9832872652F,
  0.9833575444F, 0.9834276124F, 0.9834974697F, 0.9835671166F,
  0.9836365535F, 0.9837057806F, 0.9837747983F, 0.9838436071F,
  0.9839122072F, 0.9839805990F, 0.9840487829F, 0.9841167591F,
  0.9841845282F, 0.9842520903F, 0.9843194459F, 0.9843865953F,
  0.9844535389F, 0.9845202771F, 0.9845868101F, 0.9846531383F,
  0.9847192622F, 0.9847851820F, 0.9848508980F, 0.9849164108F,
  0.9849817205F, 0.9850468276F, 0.9851117324F, 0.9851764352F,
  0.9852409365F, 0.9853052366F, 0.9853693358F, 0.9854332344F,
  0.9854969330F, 0.9855604317F, 0.9856237309F, 0.9856868310F,
  0.9857497325F, 0.9858124355F, 0.9858749404F, 0.9859372477F,
  0.9859993577F, 0.9860612707F, 0.9861229871F, 0.9861845072F,
  0.9862458315F, 0.9863069601F, 0.9863678936F, 0.9864286322F,
  0.9864891764F, 0.9865495264F, 0.9866096826F, 0.9866696454F,
  0.9867294152F, 0.9867889922F, 0.9868483769F, 0.9869075695F,
  0.9869665706F, 0.9870253803F, 0.9870839991F, 0.9871424273F,
  0.9872006653F, 0.9872587135F, 0.9873165721F, 0.9873742415F,
  0.9874317222F, 0.9874890144F, 0.9875461185F, 0.9876030348F,
  0.9876597638F, 0.9877163057F, 0.9877726610F, 0.9878288300F,
  0.9878848130F, 0.9879406104F, 0.9879962225F, 0.9880516497F,
  0.9881068924F, 0.9881619509F, 0.9882168256F, 0.9882715168F,
  0.9883260249F, 0.9883803502F, 0.9884344931F, 0.9884884539F,
  0.9885422331F, 0.9885958309F, 0.9886492477F, 0.9887024838F,
  0.9887555397F, 0.9888084157F, 0.9888611120F, 0.9889136292F,
  0.9889659675F, 0.9890181273F, 0.9890701089F, 0.9891219128F,
  0.9891735392F, 0.9892249885F, 0.9892762610F, 0.9893273572F,
  0.9893782774F, 0.9894290219F, 0.9894795911F, 0.9895299853F,
  0.9895802049F, 0.9896302502F, 0.9896801217F, 0.9897298196F,
  0.9897793443F, 0.9898286961F, 0.9898778755F, 0.9899268828F,
  0.9899757183F, 0.9900243823F, 0.9900728753F, 0.9901211976F,
  0.9901693495F, 0.9902173314F, 0.9902651436F, 0.9903127865F,
  0.9903602605F, 0.9904075659F, 0.9904547031F, 0.9905016723F,
  0.9905484740F, 0.9905951086F, 0.9906415763F, 0.9906878775F,
  0.9907340126F, 0.9907799819F, 0.9908257858F, 0.9908714247F,
  0.9909168988F, 0.9909622086F, 0.9910073543F, 0.9910523364F,
  0.9910971552F, 0.9911418110F, 0.9911863042F, 0.9912306351F,
  0.9912748042F, 0.9913188117F, 0.9913626580F, 0.9914063435F,
  0.9914498684F, 0.9914932333F, 0.9915364383F, 0.9915794839F,
  0.9916223703F, 0.9916650981F, 0.9917076674F, 0.9917500787F,
  0.9917923323F, 0.9918344286F, 0.9918763679F, 0.9919181505F,
  0.9919597769F, 0.9920012473F, 0.9920425621F, 0.9920837217F,
  0.9921247263F, 0.9921655765F, 0.9922062724F, 0.9922468145F,
  0.9922872030F, 0.9923274385F, 0.9923675211F, 0.9924074513F,
  0.9924472294F, 0.9924868557F, 0.9925263306F, 0.9925656544F,
  0.9926048275F, 0.9926438503F, 0.9926827230F, 0.9927214461F,
  0.9927600199F, 0.9927984446F, 0.9928367208F, 0.9928748486F,
  0.9929128285F, 0.9929506608F, 0.9929883459F, 0.9930258841F,
  0.9930632757F, 0.9931005211F, 0.9931376207F, 0.9931745747F,
  0.9932113836F, 0.9932480476F, 0.9932845671F, 0.9933209425F,
  0.9933571742F, 0.9933932623F, 0.9934292074F, 0.9934650097F,
  0.9935006696F, 0.9935361874F, 0.9935715635F, 0.9936067982F,
  0.9936418919F, 0.9936768448F, 0.9937116574F, 0.9937463300F,
  0.9937808629F, 0.9938152565F, 0.9938495111F, 0.9938836271F,
  0.9939176047F, 0.9939514444F, 0.9939851465F, 0.9940187112F,
  0.9940521391F, 0.9940854303F, 0.9941185853F, 0.9941516044F,
  0.9941844879F, 0.9942172361F, 0.9942498495F, 0.9942823283F,
  0.9943146729F, 0.9943468836F, 0.9943789608F, 0.9944109047F,
  0.9944427158F, 0.9944743944F, 0.9945059408F, 0.9945373553F,
  0.9945686384F, 0.9945997902F, 0.9946308112F, 0.9946617017F,
  0.9946924621F, 0.9947230926F, 0.9947535937F, 0.9947839656F,
  0.9948142086F, 0.9948443232F, 0.9948743097F, 0.9949041683F,
  0.9949338995F, 0.9949635035F, 0.9949929807F, 0.9950223315F,
  0.9950515561F, 0.9950806549F, 0.9951096282F, 0.9951384764F,
  0.9951671998F, 0.9951957987F, 0.9952242735F, 0.9952526245F,
  0.9952808520F, 0.9953089564F, 0.9953369380F, 0.9953647971F,
  0.9953925340F, 0.9954201491F, 0.9954476428F, 0.9954750153F,
  0.9955022670F, 0.9955293981F, 0.9955564092F, 0.9955833003F,
  0.9956100720F, 0.9956367245F, 0.9956632582F, 0.9956896733F,
  0.9957159703F, 0.9957421494F, 0.9957682110F, 0.9957941553F,
  0.9958199828F, 0.9958456937F, 0.9958712884F, 0.9958967672F,
  0.9959221305F, 0.9959473784F, 0.9959725115F, 0.9959975300F,
  0.9960224342F, 0.9960472244F, 0.9960719011F, 0.9960964644F,
  0.9961209148F, 0.9961452525F, 0.9961694779F, 0.9961935913F,
  0.9962175930F, 0.9962414834F, 0.9962652627F, 0.9962889313F,
  0.9963124895F, 0.9963359377F, 0.9963592761F, 0.9963825051F,
  0.9964056250F, 0.9964286361F, 0.9964515387F, 0.9964743332F,
  0.9964970198F, 0.9965195990F, 0.9965420709F, 0.9965644360F,
  0.9965866946F, 0.9966088469F, 0.9966308932F, 0.9966528340F,
  0.9966746695F, 0.9966964001F, 0.9967180260F, 0.9967395475F,
  0.9967609651F, 0.9967822789F, 0.9968034894F, 0.9968245968F,
  0.9968456014F, 0.9968665036F, 0.9968873037F, 0.9969080019F,
  0.9969285987F, 0.9969490942F, 0.9969694889F, 0.9969897830F,
  0.9970099769F, 0.9970300708F, 0.9970500651F, 0.9970699601F,
  0.9970897561F, 0.9971094533F, 0.9971290522F, 0.9971485531F,
  0.9971679561F, 0.9971872617F, 0.9972064702F, 0.9972255818F,
  0.9972445968F, 0.9972635157F, 0.9972823386F, 0.9973010659F,
  0.9973196980F, 0.9973382350F, 0.9973566773F, 0.9973750253F,
  0.9973932791F, 0.9974114392F, 0.9974295059F, 0.9974474793F,
  0.9974653599F, 0.9974831480F, 0.9975008438F, 0.9975184476F,
  0.9975359598F, 0.9975533806F, 0.9975707104F, 0.9975879495F,
  0.9976050981F, 0.9976221566F, 0.9976391252F, 0.9976560043F,
  0.9976727941F, 0.9976894950F, 0.9977061073F, 0.9977226312F,
  0.9977390671F, 0.9977554152F, 0.9977716759F, 0.9977878495F,
  0.9978039361F, 0.9978199363F, 0.9978358501F, 0.9978516780F,
  0.9978674202F, 0.9978830771F, 0.9978986488F, 0.9979141358F,
  0.9979295383F, 0.9979448566F, 0.9979600909F, 0.9979752417F,
  0.9979903091F, 0.9980052936F, 0.9980201952F, 0.9980350145F,
  0.9980497515F, 0.9980644067F, 0.9980789804F, 0.9980934727F,
  0.9981078841F, 0.9981222147F, 0.9981364649F, 0.9981506350F,
  0.9981647253F, 0.9981787360F, 0.9981926674F, 0.9982065199F,
  0.9982202936F, 0.9982339890F, 0.9982476062F, 0.9982611456F,
  0.9982746074F, 0.9982879920F, 0.9983012996F, 0.9983145304F,
  0.9983276849F, 0.9983407632F, 0.9983537657F, 0.9983666926F,
  0.9983795442F, 0.9983923208F, 0.9984050226F, 0.9984176501F,
  0.9984302033F, 0.9984426827F, 0.9984550884F, 0.9984674208F,
  0.9984796802F, 0.9984918667F, 0.9985039808F, 0.9985160227F,
  0.9985279926F, 0.9985398909F, 0.9985517177F, 0.9985634734F,
  0.9985751583F, 0.9985867727F, 0.9985983167F, 0.9986097907F,
  0.9986211949F, 0.9986325297F, 0.9986437953F, 0.9986549919F,
  0.9986661199F, 0.9986771795F, 0.9986881710F, 0.9986990946F,
  0.9987099507F, 0.9987207394F, 0.9987314611F, 0.9987421161F,
  0.9987527045F, 0.9987632267F, 0.9987736829F, 0.9987840734F,
  0.9987943985F, 0.9988046584F, 0.9988148534F, 0.9988249838F,
  0.9988350498F, 0.9988450516F, 0.9988549897F, 0.9988648641F,
  0.9988746753F, 0.9988844233F, 0.9988941086F, 0.9989037313F,
  0.9989132918F, 0.9989227902F, 0.9989322269F, 0.9989416021F,
  0.9989509160F, 0.9989601690F, 0.9989693613F, 0.9989784931F,
  0.9989875647F, 0.9989965763F, 0.9990055283F, 0.9990144208F,
  0.9990232541F, 0.9990320286F, 0.9990407443F, 0.9990494016F,
  0.9990580008F, 0.9990665421F, 0.9990750257F, 0.9990834519F,
  0.9990918209F, 0.9991001331F, 0.9991083886F, 0.9991165877F,
  0.9991247307F, 0.9991328177F, 0.9991408491F, 0.9991488251F,
  0.9991567460F, 0.9991646119F, 0.9991724232F, 0.9991801801F,
  0.9991878828F, 0.9991955316F, 0.9992031267F, 0.9992106684F,
  0.9992181569F, 0.9992255925F, 0.9992329753F, 0.9992403057F,
  0.9992475839F, 0.9992548101F, 0.9992619846F, 0.9992691076F,
  0.9992761793F, 0.9992832001F, 0.9992901701F, 0.9992970895F,
  0.9993039587F, 0.9993107777F, 0.9993175470F, 0.9993242667F,
  0.9993309371F, 0.9993375583F, 0.9993441307F, 0.9993506545F,
  0.9993571298F, 0.9993635570F, 0.9993699362F, 0.9993762678F,
  0.9993825519F, 0.9993887887F, 0.9993949785F, 0.9994011216F,
  0.9994072181F, 0.9994132683F, 0.9994192725F, 0.9994252307F,
  0.9994311434F, 0.9994370107F, 0.9994428327F, 0.9994486099F,
  0.9994543423F, 0.9994600303F, 0.9994656739F, 0.9994712736F,
  0.9994768294F, 0.9994823417F, 0.9994878105F, 0.9994932363F,
  0.9994986191F, 0.9995039592F, 0.9995092568F, 0.9995145122F,
  0.9995197256F, 0.9995248971F, 0.9995300270F, 0.9995351156F,
  0.9995401630F, 0.9995451695F, 0.9995501352F, 0.9995550604F,
  0.9995599454F, 0.9995647903F, 0.9995695953F, 0.9995743607F,
  0.9995790866F, 0.9995837734F, 0.9995884211F, 0.9995930300F,
  0.9995976004F, 0.9996021324F, 0.9996066263F, 0.9996110822F,
  0.9996155004F, 0.9996198810F, 0.9996242244F, 0.9996285306F,
  0.9996327999F, 0.9996370326F, 0.9996412287F, 0.9996453886F,
  0.9996495125F, 0.9996536004F, 0.9996576527F, 0.9996616696F,
  0.9996656512F, 0.9996695977F, 0.9996735094F, 0.9996773865F,
  0.9996812291F, 0.9996850374F, 0.9996888118F, 0.9996925523F,
  0.9996962591F, 0.9996999325F, 0.9997035727F, 0.9997071798F,
  0.9997107541F, 0.9997142957F, 0.9997178049F, 0.9997212818F,
  0.9997247266F, 0.9997281396F, 0.9997315209F, 0.9997348708F,
  0.9997381893F, 0.9997414767F, 0.9997447333F, 0.9997479591F,
  0.9997511544F, 0.9997543194F, 0.9997574542F, 0.9997605591F,
  0.9997636342F, 0.9997666797F, 0.9997696958F, 0.9997726828F,
  0.9997756407F, 0.9997785698F, 0.9997814703F, 0.9997843423F,
  0.9997871860F, 0.9997900016F, 0.9997927894F, 0.9997955494F,
  0.9997982818F, 0.9998009869F, 0.9998036648F, 0.9998063157F,
  0.9998089398F, 0.9998115373F, 0.9998141082F, 0.9998166529F,
  0.9998191715F, 0.9998216642F, 0.9998241311F, 0.9998265724F,
  0.9998289884F, 0.9998313790F, 0.9998337447F, 0.9998360854F,
  0.9998384015F, 0.9998406930F, 0.9998429602F, 0.9998452031F,
  0.9998474221F, 0.9998496171F, 0.9998517885F, 0.9998539364F,
  0.9998560610F, 0.9998581624F, 0.9998602407F, 0.9998622962F,
  0.9998643291F, 0.9998663394F, 0.9998683274F, 0.9998702932F,
  0.9998722370F, 0.9998741589F, 0.9998760591F, 0.9998779378F,
  0.9998797952F, 0.9998816313F, 0.9998834464F, 0.9998852406F,
  0.9998870141F, 0.9998887670F, 0.9998904995F, 0.9998922117F,
  0.9998939039F, 0.9998955761F, 0.9998972285F, 0.9998988613F,
  0.9999004746F, 0.9999020686F, 0.9999036434F, 0.9999051992F,
  0.9999067362F, 0.9999082544F, 0.9999097541F, 0.9999112354F,
  0.9999126984F, 0.9999141433F, 0.9999155703F, 0.9999169794F,
  0.9999183709F, 0.9999197449F, 0.9999211014F, 0.9999224408F,
  0.9999237631F, 0.9999250684F, 0.9999263570F, 0.9999276289F,
  0.9999288843F, 0.9999301233F, 0.9999313461F, 0.9999325529F,
  0.9999337437F, 0.9999349187F, 0.9999360780F, 0.9999372218F,
  0.9999383503F, 0.9999394635F, 0.9999405616F, 0.9999416447F,
  0.9999427129F, 0.9999437665F, 0.9999448055F, 0.9999458301F,
  0.9999468404F, 0.9999478365F, 0.9999488185F, 0.9999497867F,
  0.9999507411F, 0.9999516819F, 0.9999526091F, 0.9999535230F,
  0.9999544236F, 0.9999553111F, 0.9999561856F, 0.9999570472F,
  0.9999578960F, 0.9999587323F, 0.9999595560F, 0.9999603674F,
  0.9999611666F, 0.9999619536F, 0.9999627286F, 0.9999634917F,
  0.9999642431F, 0.9999649828F, 0.9999657110F, 0.9999664278F,
  0.9999671334F, 0.9999678278F, 0.9999685111F, 0.9999691835F,
  0.9999698451F, 0.9999704960F, 0.9999711364F, 0.9999717662F,
  0.9999723858F, 0.9999729950F, 0.9999735942F, 0.9999741834F,
  0.9999747626F, 0.9999753321F, 0.9999758919F, 0.9999764421F,
  0.9999769828F, 0.9999775143F, 0.9999780364F, 0.9999785495F,
  0.9999790535F, 0.9999795485F, 0.9999800348F, 0.9999805124F,
  0.9999809813F, 0.9999814417F, 0.9999818938F, 0.9999823375F,
  0.9999827731F, 0.9999832005F, 0.9999836200F, 0.9999840316F,
  0.9999844353F, 0.9999848314F, 0.9999852199F, 0.9999856008F,
  0.9999859744F, 0.9999863407F, 0.9999866997F, 0.9999870516F,
  0.9999873965F, 0.9999877345F, 0.9999880656F, 0.9999883900F,
  0.9999887078F, 0.9999890190F, 0.9999893237F, 0.9999896220F,
  0.9999899140F, 0.9999901999F, 0.9999904796F, 0.9999907533F,
  0.9999910211F, 0.9999912830F, 0.9999915391F, 0.9999917896F,
  0.9999920345F, 0.9999922738F, 0.9999925077F, 0.9999927363F,
  0.9999929596F, 0.9999931777F, 0.9999933907F, 0.9999935987F,
  0.9999938018F, 0.9999940000F, 0.9999941934F, 0.9999943820F,
  0.9999945661F, 0.9999947456F, 0.9999949206F, 0.9999950912F,
  0.9999952575F, 0.9999954195F, 0.9999955773F, 0.9999957311F,
  0.9999958807F, 0.9999960265F, 0.9999961683F, 0.9999963063F,
  0.9999964405F, 0.9999965710F, 0.9999966979F, 0.9999968213F,
  0.9999969412F, 0.9999970576F, 0.9999971707F, 0.9999972805F,
  0.9999973871F, 0.9999974905F, 0.9999975909F, 0.9999976881F,
  0.9999977824F, 0.9999978738F, 0.9999979624F, 0.9999980481F,
  0.9999981311F, 0.9999982115F, 0.9999982892F, 0.9999983644F,
  0.9999984370F, 0.9999985072F, 0.9999985750F, 0.9999986405F,
  0.9999987037F, 0.9999987647F, 0.9999988235F, 0.9999988802F,
  0.9999989348F, 0.9999989873F, 0.9999990379F, 0.9999990866F,
  0.9999991334F, 0.9999991784F, 0.9999992217F, 0.9999992632F,
  0.9999993030F, 0.9999993411F, 0.9999993777F, 0.9999994128F,
  0.9999994463F, 0.9999994784F, 0.9999995091F, 0.9999995384F,
  0.9999995663F, 0.9999995930F, 0.9999996184F, 0.9999996426F,
  0.9999996657F, 0.9999996876F, 0.9999997084F, 0.9999997282F,
  0.9999997469F, 0.9999997647F, 0.9999997815F, 0.9999997973F,
  0.9999998123F, 0.9999998265F, 0.9999998398F, 0.9999998524F,
  0.9999998642F, 0.9999998753F, 0.9999998857F, 0.9999998954F,
  0.9999999045F, 0.9999999130F, 0.9999999209F, 0.9999999282F,
  0.9999999351F, 0.9999999414F, 0.9999999472F, 0.9999999526F,
  0.9999999576F, 0.9999999622F, 0.9999999664F, 0.9999999702F,
  0.9999999737F, 0.9999999769F, 0.9999999798F, 0.9999999824F,
  0.9999999847F, 0.9999999868F, 0.9999999887F, 0.9999999904F,
  0.9999999919F, 0.9999999932F, 0.9999999943F, 0.9999999953F,
  0.9999999961F, 0.9999999969F, 0.9999999975F, 0.9999999980F,
  0.9999999985F, 0.9999999988F, 0.9999999991F, 0.9999999993F,
  0.9999999995F, 0.9999999997F, 0.9999999998F, 0.9999999999F,
  0.9999999999F, 1.0000000000F, 1.0000000000F, 1.0000000000F,
  1.0000000000F, 1.0000000000F, 1.0000000000F, 1.0000000000F,
};

static float *vwin[8] = {
  vwin64,
  vwin128,
  vwin256,
  vwin512,
  vwin1024,
  vwin2048,
  vwin4096,
  vwin8192,
};

float *_vorbis_window_get(int n){
  return vwin[n];
}

void _vorbis_apply_window(float *d,int *winno,long *blocksizes,
						  int lW,int W,int nW){
  lW=(W?lW:0);
  nW=(W?nW:0);

  {
	float *windowLW=vwin[winno[lW]];
	float *windowNW=vwin[winno[nW]];

	long n=blocksizes[W];
	long ln=blocksizes[lW];
	long rn=blocksizes[nW];

	long leftbegin=n/4-ln/4;
	long leftend=leftbegin+ln/2;

	long rightbegin=n/2+n/4-rn/4;
	long rightend=rightbegin+rn/2;

	int i,p;

	for(i=0;i<leftbegin;i++)
	  d[i]=0.f;

	for(p=0;i<leftend;i++,p++)
	  d[i]*=windowLW[p];

	for(i=rightbegin,p=rn/2-1;i<rightend;i++,p--)
	  d[i]*=windowNW[p];

	for(;i<n;i++)
	  d[i]=0.f;
  }
}

/*** End of inlined file: window.c ***/

 #if JUCE_MSVC
  #pragma warning (pop)
 #endif
#else
 #include <vorbis/vorbisenc.h>
 #include <vorbis/codec.h>
 #include <vorbis/vorbisfile.h>
#endif
}

#undef max
#undef min

static const char* const oggFormatName = "Ogg-Vorbis file";
static const char* const oggExtensions[] = { ".ogg", 0 };

class OggReader : public AudioFormatReader
{
public:
	OggReader (InputStream* const inp)
		: AudioFormatReader (inp, TRANS (oggFormatName)),
		  reservoir (2, 4096),
		  reservoirStart (0),
		  samplesInReservoir (0)
	{
		using namespace OggVorbisNamespace;
		sampleRate = 0;
		usesFloatingPointData = true;

		callbacks.read_func = &oggReadCallback;
		callbacks.seek_func = &oggSeekCallback;
		callbacks.close_func = &oggCloseCallback;
		callbacks.tell_func = &oggTellCallback;

		const int err = ov_open_callbacks (input, &ovFile, 0, 0, callbacks);

		if (err == 0)
		{
			vorbis_info* info = ov_info (&ovFile, -1);
			lengthInSamples = (uint32) ov_pcm_total (&ovFile, -1);
			numChannels = (unsigned int) info->channels;
			bitsPerSample = 16;
			sampleRate = info->rate;

			reservoir.setSize ((int) numChannels,
							   (int) jmin (lengthInSamples, (int64) reservoir.getNumSamples()));
		}
	}

	~OggReader()
	{
		OggVorbisNamespace::ov_clear (&ovFile);
	}

	bool readSamples (int** destSamples, int numDestChannels, int startOffsetInDestBuffer,
					  int64 startSampleInFile, int numSamples)
	{
		while (numSamples > 0)
		{
			const int numAvailable = reservoirStart + samplesInReservoir - startSampleInFile;

			if (startSampleInFile >= reservoirStart && numAvailable > 0)
			{
				// got a few samples overlapping, so use them before seeking..

				const int numToUse = jmin (numSamples, numAvailable);

				for (int i = jmin (numDestChannels, reservoir.getNumChannels()); --i >= 0;)
					if (destSamples[i] != nullptr)
						memcpy (destSamples[i] + startOffsetInDestBuffer,
								reservoir.getSampleData (i, (int) (startSampleInFile - reservoirStart)),
								sizeof (float) * numToUse);

				startSampleInFile += numToUse;
				numSamples -= numToUse;
				startOffsetInDestBuffer += numToUse;

				if (numSamples == 0)
					break;
			}

			if (startSampleInFile < reservoirStart
				|| startSampleInFile + numSamples > reservoirStart + samplesInReservoir)
			{
				// buffer miss, so refill the reservoir
				int bitStream = 0;

				reservoirStart = jmax (0, (int) startSampleInFile);
				samplesInReservoir = reservoir.getNumSamples();

				if (reservoirStart != (int) OggVorbisNamespace::ov_pcm_tell (&ovFile))
					OggVorbisNamespace::ov_pcm_seek (&ovFile, reservoirStart);

				int offset = 0;
				int numToRead = samplesInReservoir;

				while (numToRead > 0)
				{
					float** dataIn = nullptr;

					const int samps = OggVorbisNamespace::ov_read_float (&ovFile, &dataIn, numToRead, &bitStream);
					if (samps <= 0)
						break;

					jassert (samps <= numToRead);

					for (int i = jmin ((int) numChannels, reservoir.getNumChannels()); --i >= 0;)
					{
						memcpy (reservoir.getSampleData (i, offset),
								dataIn[i],
								sizeof (float) * samps);
					}

					numToRead -= samps;
					offset += samps;
				}

				if (numToRead > 0)
					reservoir.clear (offset, numToRead);
			}
		}

		if (numSamples > 0)
		{
			for (int i = numDestChannels; --i >= 0;)
				if (destSamples[i] != nullptr)
					zeromem (destSamples[i] + startOffsetInDestBuffer, sizeof (int) * numSamples);
		}

		return true;
	}

	static size_t oggReadCallback (void* ptr, size_t size, size_t nmemb, void* datasource)
	{
		return (size_t) (static_cast <InputStream*> (datasource)->read (ptr, (int) (size * nmemb)) / size);
	}

	static int oggSeekCallback (void* datasource, OggVorbisNamespace::ogg_int64_t offset, int whence)
	{
		InputStream* const in = static_cast <InputStream*> (datasource);

		if (whence == SEEK_CUR)
			offset += in->getPosition();
		else if (whence == SEEK_END)
			offset += in->getTotalLength();

		in->setPosition (offset);
		return 0;
	}

	static int oggCloseCallback (void*)
	{
		return 0;
	}

	static long oggTellCallback (void* datasource)
	{
		return (long) static_cast <InputStream*> (datasource)->getPosition();
	}

private:
	OggVorbisNamespace::OggVorbis_File ovFile;
	OggVorbisNamespace::ov_callbacks callbacks;
	AudioSampleBuffer reservoir;
	int reservoirStart, samplesInReservoir;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (OggReader);
};

class OggWriter  : public AudioFormatWriter
{
public:
	OggWriter (OutputStream* const out,
			   const double sampleRate_,
			   const unsigned int numChannels_,
			   const unsigned int bitsPerSample_,
			   const int qualityIndex,
			   const StringPairArray& metadataValues)
		: AudioFormatWriter (out, TRANS (oggFormatName), sampleRate_, numChannels_, bitsPerSample_),
		  ok (false)
	{
		using namespace OggVorbisNamespace;

		vorbis_info_init (&vi);

		if (vorbis_encode_init_vbr (&vi, (int) numChannels_, (int) sampleRate_,
									jlimit (0.0f, 1.0f, qualityIndex * 0.1f)) == 0)
		{
			vorbis_comment_init (&vc);

			const String encoder (metadataValues [OggVorbisAudioFormat::encoderName]);
			if (encoder.isNotEmpty())
				vorbis_comment_add_tag (&vc, "ENCODER", const_cast <char*> (encoder.toUTF8().getAddress()));

			vorbis_analysis_init (&vd, &vi);
			vorbis_block_init (&vd, &vb);

			ogg_stream_init (&os, Random::getSystemRandom().nextInt());

			ogg_packet header;
			ogg_packet header_comm;
			ogg_packet header_code;

			vorbis_analysis_headerout (&vd, &vc, &header, &header_comm, &header_code);

			ogg_stream_packetin (&os, &header);
			ogg_stream_packetin (&os, &header_comm);
			ogg_stream_packetin (&os, &header_code);

			for (;;)
			{
				if (ogg_stream_flush (&os, &og) == 0)
					break;

				output->write (og.header, og.header_len);
				output->write (og.body, og.body_len);
			}

			ok = true;
		}
	}

	~OggWriter()
	{
		using namespace OggVorbisNamespace;
		if (ok)
		{
			// write a zero-length packet to show ogg that we're finished..
			writeSamples (0);

			ogg_stream_clear (&os);
			vorbis_block_clear (&vb);
			vorbis_dsp_clear (&vd);
			vorbis_comment_clear (&vc);

			vorbis_info_clear (&vi);
			output->flush();
		}
		else
		{
			vorbis_info_clear (&vi);
			output = nullptr; // to stop the base class deleting this, as it needs to be returned
							  // to the caller of createWriter()
		}
	}

	bool write (const int** samplesToWrite, int numSamples)
	{
		if (ok)
		{
			using namespace OggVorbisNamespace;

			if (numSamples > 0)
			{
				const double gain = 1.0 / 0x80000000u;
				float** const vorbisBuffer = vorbis_analysis_buffer (&vd, numSamples);

				for (int i = (int) numChannels; --i >= 0;)
				{
					float* const dst = vorbisBuffer[i];
					const int* const src = samplesToWrite [i];

					if (src != nullptr && dst != nullptr)
					{
						for (int j = 0; j < numSamples; ++j)
							dst[j] = (float) (src[j] * gain);
					}
				}
			}

			writeSamples (numSamples);
		}

		return ok;
	}

	void writeSamples (int numSamples)
	{
		using namespace OggVorbisNamespace;

		vorbis_analysis_wrote (&vd, numSamples);

		while (vorbis_analysis_blockout (&vd, &vb) == 1)
		{
			vorbis_analysis (&vb, 0);
			vorbis_bitrate_addblock (&vb);

			while (vorbis_bitrate_flushpacket (&vd, &op))
			{
				ogg_stream_packetin (&os, &op);

				for (;;)
				{
					if (ogg_stream_pageout (&os, &og) == 0)
						break;

					output->write (og.header, og.header_len);
					output->write (og.body, og.body_len);

					if (ogg_page_eos (&og))
						break;
				}
			}
		}
	}

	bool ok;

private:
	OggVorbisNamespace::ogg_stream_state os;
	OggVorbisNamespace::ogg_page og;
	OggVorbisNamespace::ogg_packet op;
	OggVorbisNamespace::vorbis_info vi;
	OggVorbisNamespace::vorbis_comment vc;
	OggVorbisNamespace::vorbis_dsp_state vd;
	OggVorbisNamespace::vorbis_block vb;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (OggWriter);
};

OggVorbisAudioFormat::OggVorbisAudioFormat()
	: AudioFormat (TRANS (oggFormatName), StringArray (oggExtensions))
{
}

OggVorbisAudioFormat::~OggVorbisAudioFormat()
{
}

Array<int> OggVorbisAudioFormat::getPossibleSampleRates()
{
	const int rates[] = { 22050, 32000, 44100, 48000, 88200, 96000, 176400, 192000, 0 };
	return Array <int> (rates);
}

Array<int> OggVorbisAudioFormat::getPossibleBitDepths()
{
	const int depths[] = { 32, 0 };
	return Array <int> (depths);
}

bool OggVorbisAudioFormat::canDoStereo()    { return true; }
bool OggVorbisAudioFormat::canDoMono()      { return true; }
bool OggVorbisAudioFormat::isCompressed()   { return true; }

const char* const OggVorbisAudioFormat::encoderName = "encoder";

AudioFormatReader* OggVorbisAudioFormat::createReaderFor (InputStream* in, const bool deleteStreamIfOpeningFails)
{
	ScopedPointer<OggReader> r (new OggReader (in));

	if (r->sampleRate > 0)
		return r.release();

	if (! deleteStreamIfOpeningFails)
		r->input = nullptr;

	return nullptr;
}

AudioFormatWriter* OggVorbisAudioFormat::createWriterFor (OutputStream* out,
														  double sampleRate,
														  unsigned int numChannels,
														  int bitsPerSample,
														  const StringPairArray& metadataValues,
														  int qualityOptionIndex)
{
	ScopedPointer <OggWriter> w (new OggWriter (out, sampleRate, numChannels,
												(unsigned int) bitsPerSample, qualityOptionIndex, metadataValues));

	return w->ok ? w.release() : nullptr;
}

StringArray OggVorbisAudioFormat::getQualityOptions()
{
	const char* options[] = { "64 kbps", "80 kbps", "96 kbps", "112 kbps", "128 kbps", "160 kbps",
							  "192 kbps", "224 kbps", "256 kbps", "320 kbps", "500 kbps", 0 };
	return StringArray (options);
}

int OggVorbisAudioFormat::estimateOggFileQuality (const File& source)
{
	FileInputStream* const in = source.createInputStream();

	if (in != nullptr)
	{
		ScopedPointer <AudioFormatReader> r (createReaderFor (in, true));

		if (r != nullptr)
		{
			const int64 numSamps = r->lengthInSamples;
			r = nullptr;

			const int64 fileNumSamps = source.getSize() / 4;
			const double ratio = numSamps / (double) fileNumSamps;

			if (ratio > 12.0)
				return 0;
			else if (ratio > 6.0)
				return 1;
			else
				return 2;
		}
	}

	return 1;
}

#endif

/*** End of inlined file: juce_OggVorbisAudioFormat.cpp ***/


/*** Start of inlined file: juce_QuickTimeAudioFormat.cpp ***/
#if JUCE_QUICKTIME && ! (JUCE_64BIT || JUCE_IOS)

} // (juce namespace)

#if ! JUCE_WINDOWS
 #define Point CarbonDummyPointName // (workaround to avoid definition of "Point" by old Carbon headers)
 #define Component CarbonDummyCompName
 #include <QuickTime/Movies.h>
 #include <QuickTime/QTML.h>
 #include <QuickTime/QuickTimeComponents.h>
 #include <QuickTime/MediaHandlers.h>
 #include <QuickTime/ImageCodec.h>
 #undef Point
 #undef Component
#else
 #if JUCE_MSVC
  #pragma warning (push)
  #pragma warning (disable : 4100)
 #endif

 /* If you've got an include error here, you probably need to install the QuickTime SDK and
	add its header directory to your include path.

	Alternatively, if you don't need any QuickTime services, just set the JUCE_QUICKTIME flag to 0.
 */
 #undef SIZE_MAX
 #include <Movies.h>
 #include <QTML.h>
 #include <QuickTimeComponents.h>
 #include <MediaHandlers.h>
 #include <ImageCodec.h>
 #undef SIZE_MAX

 #if JUCE_MSVC
  #pragma warning (pop)
 #endif
#endif

namespace juce
{

bool juce_OpenQuickTimeMovieFromStream (InputStream* input, Movie& movie, Handle& dataHandle);

static const char* const quickTimeFormatName = "QuickTime file";
static const char* const quickTimeExtensions[] = { ".mov", ".mp3", ".mp4", ".m4a", 0 };

class QTAudioReader     : public AudioFormatReader
{
public:
	QTAudioReader (InputStream* const input_, const int trackNum_)
		: AudioFormatReader (input_, TRANS (quickTimeFormatName)),
		  ok (false),
		  movie (0),
		  trackNum (trackNum_),
		  lastSampleRead (0),
		  lastThreadId (0),
		  extractor (0),
		  dataHandle (0)
	{
		JUCE_AUTORELEASEPOOL
		bufferList.calloc (256, 1);

	   #if JUCE_WINDOWS
		if (InitializeQTML (0) != noErr)
			return;
	   #endif

		if (EnterMovies() != noErr)
			return;

		bool opened = juce_OpenQuickTimeMovieFromStream (input_, movie, dataHandle);

		if (! opened)
			return;

		{
			const int numTracks = GetMovieTrackCount (movie);
			int trackCount = 0;

			for (int i = 1; i <= numTracks; ++i)
			{
				track = GetMovieIndTrack (movie, i);
				media = GetTrackMedia (track);

				OSType mediaType;
				GetMediaHandlerDescription (media, &mediaType, 0, 0);

				if (mediaType == SoundMediaType
					 && trackCount++ == trackNum_)
				{
					ok = true;
					break;
				}
			}
		}

		if (! ok)
			return;

		ok = false;

		lengthInSamples = GetMediaDecodeDuration (media);
		usesFloatingPointData = false;

		samplesPerFrame = (int) (GetMediaDecodeDuration (media) / GetMediaSampleCount (media));

		trackUnitsPerFrame = GetMovieTimeScale (movie) * samplesPerFrame
								/ GetMediaTimeScale (media);

		OSStatus err = MovieAudioExtractionBegin (movie, 0, &extractor);

		unsigned long output_layout_size;
		err = MovieAudioExtractionGetPropertyInfo (extractor,
												   kQTPropertyClass_MovieAudioExtraction_Audio,
												   kQTMovieAudioExtractionAudioPropertyID_AudioChannelLayout,
												   0, &output_layout_size, 0);
		if (err != noErr)
			return;

		HeapBlock <AudioChannelLayout> qt_audio_channel_layout;
		qt_audio_channel_layout.calloc (output_layout_size, 1);

		err = MovieAudioExtractionGetProperty (extractor,
											   kQTPropertyClass_MovieAudioExtraction_Audio,
											   kQTMovieAudioExtractionAudioPropertyID_AudioChannelLayout,
											   output_layout_size, qt_audio_channel_layout, 0);

		qt_audio_channel_layout[0].mChannelLayoutTag = kAudioChannelLayoutTag_Stereo;

		err = MovieAudioExtractionSetProperty (extractor,
											   kQTPropertyClass_MovieAudioExtraction_Audio,
											   kQTMovieAudioExtractionAudioPropertyID_AudioChannelLayout,
											   output_layout_size,
											   qt_audio_channel_layout);

		err = MovieAudioExtractionGetProperty (extractor,
											   kQTPropertyClass_MovieAudioExtraction_Audio,
											   kQTMovieAudioExtractionAudioPropertyID_AudioStreamBasicDescription,
											   sizeof (inputStreamDesc),
											   &inputStreamDesc, 0);
		if (err != noErr)
			return;

		inputStreamDesc.mFormatFlags = kAudioFormatFlagIsSignedInteger
										| kAudioFormatFlagIsPacked
										| kAudioFormatFlagsNativeEndian;
		inputStreamDesc.mBitsPerChannel = sizeof (SInt16) * 8;
		inputStreamDesc.mChannelsPerFrame = jmin ((UInt32) 2, inputStreamDesc.mChannelsPerFrame);
		inputStreamDesc.mBytesPerFrame = sizeof (SInt16) * inputStreamDesc.mChannelsPerFrame;
		inputStreamDesc.mBytesPerPacket = inputStreamDesc.mBytesPerFrame;

		err = MovieAudioExtractionSetProperty (extractor,
											   kQTPropertyClass_MovieAudioExtraction_Audio,
											   kQTMovieAudioExtractionAudioPropertyID_AudioStreamBasicDescription,
											   sizeof (inputStreamDesc),
											   &inputStreamDesc);
		if (err != noErr)
			return;

		Boolean allChannelsDiscrete = false;
		err = MovieAudioExtractionSetProperty (extractor,
											   kQTPropertyClass_MovieAudioExtraction_Movie,
											   kQTMovieAudioExtractionMoviePropertyID_AllChannelsDiscrete,
											   sizeof (allChannelsDiscrete),
											   &allChannelsDiscrete);

		if (err != noErr)
			return;

		bufferList->mNumberBuffers = 1;
		bufferList->mBuffers[0].mNumberChannels = inputStreamDesc.mChannelsPerFrame;
		bufferList->mBuffers[0].mDataByteSize =  jmax ((UInt32) 4096, (UInt32) (samplesPerFrame * inputStreamDesc.mBytesPerFrame) + 16);

		dataBuffer.malloc (bufferList->mBuffers[0].mDataByteSize);
		bufferList->mBuffers[0].mData = dataBuffer;

		sampleRate = inputStreamDesc.mSampleRate;
		bitsPerSample = 16;
		numChannels = inputStreamDesc.mChannelsPerFrame;

		detachThread();
		ok = true;
	}

	~QTAudioReader()
	{
		JUCE_AUTORELEASEPOOL
		checkThreadIsAttached();

		if (dataHandle != nullptr)
			DisposeHandle (dataHandle);

		if (extractor != nullptr)
		{
			MovieAudioExtractionEnd (extractor);
			extractor = nullptr;
		}

		DisposeMovie (movie);

	   #if JUCE_MAC
		ExitMoviesOnThread ();
	   #endif
	}

	bool readSamples (int** destSamples, int numDestChannels, int startOffsetInDestBuffer,
					  int64 startSampleInFile, int numSamples)
	{
		JUCE_AUTORELEASEPOOL
		checkThreadIsAttached();
		bool ok = true;

		while (numSamples > 0)
		{
			if (lastSampleRead != startSampleInFile)
			{
				TimeRecord time;
				time.scale = (TimeScale) inputStreamDesc.mSampleRate;
				time.base = 0;
				time.value.hi = 0;
				time.value.lo = (UInt32) startSampleInFile;

				OSStatus err = MovieAudioExtractionSetProperty (extractor,
																kQTPropertyClass_MovieAudioExtraction_Movie,
																kQTMovieAudioExtractionMoviePropertyID_CurrentTime,
																sizeof (time), &time);

				if (err != noErr)
				{
					ok = false;
					break;
				}
			}

			int framesToDo = jmin (numSamples, (int) (bufferList->mBuffers[0].mDataByteSize / inputStreamDesc.mBytesPerFrame));
			bufferList->mBuffers[0].mDataByteSize = inputStreamDesc.mBytesPerFrame * framesToDo;

			UInt32 outFlags = 0;
			UInt32 actualNumFrames = framesToDo;
			OSStatus err = MovieAudioExtractionFillBuffer (extractor, &actualNumFrames, bufferList, &outFlags);
			if (err != noErr)
			{
				ok = false;
				break;
			}

			lastSampleRead = startSampleInFile + actualNumFrames;
			const int samplesReceived = actualNumFrames;

			for (int j = numDestChannels; --j >= 0;)
			{
				if (destSamples[j] != nullptr)
				{
					const short* src = ((const short*) bufferList->mBuffers[0].mData) + j;

					for (int i = 0; i < samplesReceived; ++i)
					{
						destSamples[j][startOffsetInDestBuffer + i] = (*src << 16);
						src += numChannels;
					}
				}
			}

			startOffsetInDestBuffer += samplesReceived;
			startSampleInFile += samplesReceived;
			numSamples -= samplesReceived;

			if (((outFlags & kQTMovieAudioExtractionComplete) != 0 || samplesReceived == 0) && numSamples > 0)
			{
				for (int j = numDestChannels; --j >= 0;)
					if (destSamples[j] != nullptr)
						zeromem (destSamples[j] + startOffsetInDestBuffer, sizeof (int) * numSamples);

				break;
			}
		}

		detachThread();
		return ok;
	}

	bool ok;

private:
	Movie movie;
	Media media;
	Track track;
	const int trackNum;
	double trackUnitsPerFrame;
	int samplesPerFrame;
	int64 lastSampleRead;
	Thread::ThreadID lastThreadId;
	MovieAudioExtractionRef extractor;
	AudioStreamBasicDescription inputStreamDesc;
	HeapBlock <AudioBufferList> bufferList;
	HeapBlock <char> dataBuffer;
	Handle dataHandle;

	void checkThreadIsAttached()
	{
	   #if JUCE_MAC
		if (Thread::getCurrentThreadId() != lastThreadId)
			EnterMoviesOnThread (0);
		AttachMovieToCurrentThread (movie);
	   #endif
	}

	void detachThread()
	{
	   #if JUCE_MAC
		DetachMovieFromCurrentThread (movie);
	   #endif
	}

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (QTAudioReader);
};

QuickTimeAudioFormat::QuickTimeAudioFormat()
	: AudioFormat (TRANS (quickTimeFormatName), StringArray (quickTimeExtensions))
{
}

QuickTimeAudioFormat::~QuickTimeAudioFormat()
{
}

Array<int> QuickTimeAudioFormat::getPossibleSampleRates()    { return Array<int>(); }
Array<int> QuickTimeAudioFormat::getPossibleBitDepths()      { return Array<int>(); }

bool QuickTimeAudioFormat::canDoStereo()    { return true; }
bool QuickTimeAudioFormat::canDoMono()      { return true; }

AudioFormatReader* QuickTimeAudioFormat::createReaderFor (InputStream* sourceStream,
														  const bool deleteStreamIfOpeningFails)
{
	ScopedPointer <QTAudioReader> r (new QTAudioReader (sourceStream, 0));

	if (r->ok)
		return r.release();

	if (! deleteStreamIfOpeningFails)
		r->input = 0;

	return nullptr;
}

AudioFormatWriter* QuickTimeAudioFormat::createWriterFor (OutputStream* /*streamToWriteTo*/,
														  double /*sampleRateToUse*/,
														  unsigned int /*numberOfChannels*/,
														  int /*bitsPerSample*/,
														  const StringPairArray& /*metadataValues*/,
														  int /*qualityOptionIndex*/)
{
	jassertfalse; // not yet implemented!
	return nullptr;
}

#endif

/*** End of inlined file: juce_QuickTimeAudioFormat.cpp ***/


/*** Start of inlined file: juce_WavAudioFormat.cpp ***/
static const char* const wavFormatName = "WAV file";
static const char* const wavExtensions[] = { ".wav", ".bwf", 0 };

const char* const WavAudioFormat::bwavDescription      = "bwav description";
const char* const WavAudioFormat::bwavOriginator       = "bwav originator";
const char* const WavAudioFormat::bwavOriginatorRef    = "bwav originator ref";
const char* const WavAudioFormat::bwavOriginationDate  = "bwav origination date";
const char* const WavAudioFormat::bwavOriginationTime  = "bwav origination time";
const char* const WavAudioFormat::bwavTimeReference    = "bwav time reference";
const char* const WavAudioFormat::bwavCodingHistory    = "bwav coding history";

StringPairArray WavAudioFormat::createBWAVMetadata (const String& description,
													const String& originator,
													const String& originatorRef,
													const Time& date,
													const int64 timeReferenceSamples,
													const String& codingHistory)
{
	StringPairArray m;

	m.set (bwavDescription, description);
	m.set (bwavOriginator, originator);
	m.set (bwavOriginatorRef, originatorRef);
	m.set (bwavOriginationDate, date.formatted ("%Y-%m-%d"));
	m.set (bwavOriginationTime, date.formatted ("%H:%M:%S"));
	m.set (bwavTimeReference, String (timeReferenceSamples));
	m.set (bwavCodingHistory, codingHistory);

	return m;
}

namespace WavFileHelpers
{
	inline int chunkName (const char* const name) noexcept   { return (int) ByteOrder::littleEndianInt (name); }

	#if JUCE_MSVC
	 #pragma pack (push, 1)
	 #define PACKED
	#elif JUCE_GCC
	 #define PACKED __attribute__((packed))
	#else
	 #define PACKED
	#endif

	struct BWAVChunk
	{
		char description [256];
		char originator [32];
		char originatorRef [32];
		char originationDate [10];
		char originationTime [8];
		uint32 timeRefLow;
		uint32 timeRefHigh;
		uint16 version;
		uint8 umid[64];
		uint8 reserved[190];
		char codingHistory[1];

		void copyTo (StringPairArray& values) const
		{
			values.set (WavAudioFormat::bwavDescription, String::fromUTF8 (description, 256));
			values.set (WavAudioFormat::bwavOriginator, String::fromUTF8 (originator, 32));
			values.set (WavAudioFormat::bwavOriginatorRef, String::fromUTF8 (originatorRef, 32));
			values.set (WavAudioFormat::bwavOriginationDate, String::fromUTF8 (originationDate, 10));
			values.set (WavAudioFormat::bwavOriginationTime, String::fromUTF8 (originationTime, 8));

			const uint32 timeLow = ByteOrder::swapIfBigEndian (timeRefLow);
			const uint32 timeHigh = ByteOrder::swapIfBigEndian (timeRefHigh);
			const int64 time = (((int64)timeHigh) << 32) + timeLow;

			values.set (WavAudioFormat::bwavTimeReference, String (time));
			values.set (WavAudioFormat::bwavCodingHistory, String::fromUTF8 (codingHistory));
		}

		static MemoryBlock createFrom (const StringPairArray& values)
		{
			const size_t sizeNeeded = sizeof (BWAVChunk) + values [WavAudioFormat::bwavCodingHistory].getNumBytesAsUTF8();
			MemoryBlock data ((sizeNeeded + 3) & ~3);
			data.fillWith (0);

			BWAVChunk* b = (BWAVChunk*) data.getData();

			// Allow these calls to overwrite an extra byte at the end, which is fine as long
			// as they get called in the right order..
			values [WavAudioFormat::bwavDescription].copyToUTF8 (b->description, 257);
			values [WavAudioFormat::bwavOriginator].copyToUTF8 (b->originator, 33);
			values [WavAudioFormat::bwavOriginatorRef].copyToUTF8 (b->originatorRef, 33);
			values [WavAudioFormat::bwavOriginationDate].copyToUTF8 (b->originationDate, 11);
			values [WavAudioFormat::bwavOriginationTime].copyToUTF8 (b->originationTime, 9);

			const int64 time = values [WavAudioFormat::bwavTimeReference].getLargeIntValue();
			b->timeRefLow = ByteOrder::swapIfBigEndian ((uint32) (time & 0xffffffff));
			b->timeRefHigh = ByteOrder::swapIfBigEndian ((uint32) (time >> 32));

			values [WavAudioFormat::bwavCodingHistory].copyToUTF8 (b->codingHistory, 0x7fffffff);

			if (b->description[0] != 0
				|| b->originator[0] != 0
				|| b->originationDate[0] != 0
				|| b->originationTime[0] != 0
				|| b->codingHistory[0] != 0
				|| time != 0)
			{
				return data;
			}

			return MemoryBlock();
		}

	} PACKED;

	struct SMPLChunk
	{
		struct SampleLoop
		{
			uint32 identifier;
			uint32 type; // these are different in AIFF and WAV
			uint32 start;
			uint32 end;
			uint32 fraction;
			uint32 playCount;
		} PACKED;

		uint32 manufacturer;
		uint32 product;
		uint32 samplePeriod;
		uint32 midiUnityNote;
		uint32 midiPitchFraction;
		uint32 smpteFormat;
		uint32 smpteOffset;
		uint32 numSampleLoops;
		uint32 samplerData;
		SampleLoop loops[1];

		void copyTo (StringPairArray& values, const int totalSize) const
		{
			values.set ("Manufacturer",      String (ByteOrder::swapIfBigEndian (manufacturer)));
			values.set ("Product",           String (ByteOrder::swapIfBigEndian (product)));
			values.set ("SamplePeriod",      String (ByteOrder::swapIfBigEndian (samplePeriod)));
			values.set ("MidiUnityNote",     String (ByteOrder::swapIfBigEndian (midiUnityNote)));
			values.set ("MidiPitchFraction", String (ByteOrder::swapIfBigEndian (midiPitchFraction)));
			values.set ("SmpteFormat",       String (ByteOrder::swapIfBigEndian (smpteFormat)));
			values.set ("SmpteOffset",       String (ByteOrder::swapIfBigEndian (smpteOffset)));
			values.set ("NumSampleLoops",    String (ByteOrder::swapIfBigEndian (numSampleLoops)));
			values.set ("SamplerData",       String (ByteOrder::swapIfBigEndian (samplerData)));

			for (uint32 i = 0; i < numSampleLoops; ++i)
			{
				if ((uint8*) (loops + (i + 1)) > ((uint8*) this) + totalSize)
					break;

				const String prefix ("Loop" + String(i));
				values.set (prefix + "Identifier", String (ByteOrder::swapIfBigEndian (loops[i].identifier)));
				values.set (prefix + "Type",       String (ByteOrder::swapIfBigEndian (loops[i].type)));
				values.set (prefix + "Start",      String (ByteOrder::swapIfBigEndian (loops[i].start)));
				values.set (prefix + "End",        String (ByteOrder::swapIfBigEndian (loops[i].end)));
				values.set (prefix + "Fraction",   String (ByteOrder::swapIfBigEndian (loops[i].fraction)));
				values.set (prefix + "PlayCount",  String (ByteOrder::swapIfBigEndian (loops[i].playCount)));
			}
		}

		static MemoryBlock createFrom (const StringPairArray& values)
		{
			MemoryBlock data;
			const int numLoops = jmin (64, values.getValue ("NumSampleLoops", "0").getIntValue());

			if (numLoops > 0)
			{
				const size_t sizeNeeded = sizeof (SMPLChunk) + (numLoops - 1) * sizeof (SampleLoop);
				data.setSize ((sizeNeeded + 3) & ~3, true);

				SMPLChunk* const s = static_cast <SMPLChunk*> (data.getData());

				s->manufacturer      = ByteOrder::swapIfBigEndian ((uint32) values.getValue ("Manufacturer", "0").getIntValue());
				s->product           = ByteOrder::swapIfBigEndian ((uint32) values.getValue ("Product", "0").getIntValue());
				s->samplePeriod      = ByteOrder::swapIfBigEndian ((uint32) values.getValue ("SamplePeriod", "0").getIntValue());
				s->midiUnityNote     = ByteOrder::swapIfBigEndian ((uint32) values.getValue ("MidiUnityNote", "60").getIntValue());
				s->midiPitchFraction = ByteOrder::swapIfBigEndian ((uint32) values.getValue ("MidiPitchFraction", "0").getIntValue());
				s->smpteFormat       = ByteOrder::swapIfBigEndian ((uint32) values.getValue ("SmpteFormat", "0").getIntValue());
				s->smpteOffset       = ByteOrder::swapIfBigEndian ((uint32) values.getValue ("SmpteOffset", "0").getIntValue());
				s->numSampleLoops    = ByteOrder::swapIfBigEndian ((uint32) numLoops);
				s->samplerData       = ByteOrder::swapIfBigEndian ((uint32) values.getValue ("SamplerData", "0").getIntValue());

				for (int i = 0; i < numLoops; ++i)
				{
					const String prefix ("Loop" + String(i));
					s->loops[i].identifier = ByteOrder::swapIfBigEndian ((uint32) values.getValue (prefix + "Identifier", "0").getIntValue());
					s->loops[i].type       = ByteOrder::swapIfBigEndian ((uint32) values.getValue (prefix + "Type", "0").getIntValue());
					s->loops[i].start      = ByteOrder::swapIfBigEndian ((uint32) values.getValue (prefix + "Start", "0").getIntValue());
					s->loops[i].end        = ByteOrder::swapIfBigEndian ((uint32) values.getValue (prefix + "End", "0").getIntValue());
					s->loops[i].fraction   = ByteOrder::swapIfBigEndian ((uint32) values.getValue (prefix + "Fraction", "0").getIntValue());
					s->loops[i].playCount  = ByteOrder::swapIfBigEndian ((uint32) values.getValue (prefix + "PlayCount", "0").getIntValue());
				}
			}

			return data;
		}
	} PACKED;

	struct InstChunk
	{
		int8 baseNote;
		int8 detune;
		int8 gain;
		int8 lowNote;
		int8 highNote;
		int8 lowVelocity;
		int8 highVelocity;

		void copyTo (StringPairArray& values) const
		{
			values.set ("MidiUnityNote",    String (baseNote));
			values.set ("Detune",           String (detune));
			values.set ("Gain",             String (gain));
			values.set ("LowNote",          String (lowNote));
			values.set ("HighNote",         String (highNote));
			values.set ("LowVelocity",      String (lowVelocity));
			values.set ("HighVelocity",     String (highVelocity));
		}

		static MemoryBlock createFrom (const StringPairArray& values)
		{
			MemoryBlock data;
			const StringArray& keys = values.getAllKeys();

			if (keys.contains ("LowNote", true) && keys.contains ("HighNote", true))
			{
				data.setSize (8, true);
				InstChunk* const inst = static_cast <InstChunk*> (data.getData());

				inst->baseNote      = (int8) values.getValue ("MidiUnityNote", "60").getIntValue();
				inst->detune        = (int8) values.getValue ("Detune", "0").getIntValue();
				inst->gain          = (int8) values.getValue ("Gain", "0").getIntValue();
				inst->lowNote       = (int8) values.getValue ("LowNote", "0").getIntValue();
				inst->highNote      = (int8) values.getValue ("HighNote", "127").getIntValue();
				inst->lowVelocity   = (int8) values.getValue ("LowVelocity", "1").getIntValue();
				inst->highVelocity  = (int8) values.getValue ("HighVelocity", "127").getIntValue();
			}

			return data;
		}
	} PACKED;

	struct CueChunk
	{
		struct Cue
		{
			uint32 identifier;
			uint32 order;
			uint32 chunkID;
			uint32 chunkStart;
			uint32 blockStart;
			uint32 offset;
		} PACKED;

		uint32 numCues;
		Cue cues[1];

		void copyTo (StringPairArray& values, const int totalSize) const
		{
			values.set ("NumCuePoints", String (ByteOrder::swapIfBigEndian (numCues)));

			for (uint32 i = 0; i < numCues; ++i)
			{
				if ((uint8*) (cues + (i + 1)) > ((uint8*) this) + totalSize)
					break;

				const String prefix ("Cue" + String(i));
				values.set (prefix + "Identifier",  String (ByteOrder::swapIfBigEndian (cues[i].identifier)));
				values.set (prefix + "Order",       String (ByteOrder::swapIfBigEndian (cues[i].order)));
				values.set (prefix + "ChunkID",     String (ByteOrder::swapIfBigEndian (cues[i].chunkID)));
				values.set (prefix + "ChunkStart",  String (ByteOrder::swapIfBigEndian (cues[i].chunkStart)));
				values.set (prefix + "BlockStart",  String (ByteOrder::swapIfBigEndian (cues[i].blockStart)));
				values.set (prefix + "Offset",      String (ByteOrder::swapIfBigEndian (cues[i].offset)));
			}
		}

		static void create (MemoryBlock& data, const StringPairArray& values)
		{
			const int numCues = values.getValue ("NumCuePoints", "0").getIntValue();

			if (numCues > 0)
			{
				const size_t sizeNeeded = sizeof (CueChunk) + (numCues - 1) * sizeof (Cue);
				data.setSize ((sizeNeeded + 3) & ~3, true);

				CueChunk* const c = static_cast <CueChunk*> (data.getData());

				c->numCues = ByteOrder::swapIfBigEndian ((uint32) numCues);

				const String dataChunkID (chunkName ("data"));
				int nextOrder = 0;

			   #if JUCE_DEBUG
				Array<uint32> identifiers;
			   #endif

				for (int i = 0; i < numCues; ++i)
				{
					const String prefix ("Cue" + String (i));

					uint32 identifier = (uint32) values.getValue (prefix + "Identifier", "0").getIntValue();

				   #if JUCE_DEBUG
					jassert (! identifiers.contains (identifier));
					identifiers.add (identifier);
				   #endif

					c->cues[i].identifier   = ByteOrder::swapIfBigEndian ((uint32) identifier);

					const int order = values.getValue (prefix + "Order", String (nextOrder)).getIntValue();
					nextOrder = jmax (nextOrder, order) + 1;

					c->cues[i].order        = ByteOrder::swapIfBigEndian ((uint32) order);
					c->cues[i].chunkID      = ByteOrder::swapIfBigEndian ((uint32) values.getValue (prefix + "ChunkID", dataChunkID).getIntValue());
					c->cues[i].chunkStart   = ByteOrder::swapIfBigEndian ((uint32) values.getValue (prefix + "ChunkStart", "0").getIntValue());
					c->cues[i].blockStart   = ByteOrder::swapIfBigEndian ((uint32) values.getValue (prefix + "BlockStart", "0").getIntValue());
					c->cues[i].offset       = ByteOrder::swapIfBigEndian ((uint32) values.getValue (prefix + "Offset", "0").getIntValue());
				}
			}
		}

	} PACKED;

	namespace ListChunk
	{
		void appendLabelOrNoteChunk (const StringPairArray& values, const String& prefix,
									 const int chunkType, MemoryOutputStream& out)
		{
			const String label (values.getValue (prefix + "Text", prefix));
			const int labelLength = label.getNumBytesAsUTF8() + 1;
			const int chunkLength = 4 + labelLength + (labelLength & 1);

			out.writeInt (chunkType);
			out.writeInt (chunkLength);
			out.writeInt (values.getValue (prefix + "Identifier", "0").getIntValue());
			out.write (label.toUTF8(), labelLength);

			if ((out.getDataSize() & 1) != 0)
				out.writeByte (0);
		}

		void appendExtraChunk (const StringPairArray& values, const String& prefix, MemoryOutputStream& out)
		{
			const String text (values.getValue (prefix + "Text", prefix));

			const int textLength = text.getNumBytesAsUTF8() + 1; // include null terminator
			int chunkLength = textLength + 20 + (textLength & 1);

			out.writeInt (chunkName ("ltxt"));
			out.writeInt (chunkLength);
			out.writeInt (values.getValue (prefix + "Identifier", "0").getIntValue());
			out.writeInt (values.getValue (prefix + "SampleLength", "0").getIntValue());
			out.writeInt (values.getValue (prefix + "Purpose", "0").getIntValue());
			out.writeShort ((short) values.getValue (prefix + "Country", "0").getIntValue());
			out.writeShort ((short) values.getValue (prefix + "Language", "0").getIntValue());
			out.writeShort ((short) values.getValue (prefix + "Dialect", "0").getIntValue());
			out.writeShort ((short) values.getValue (prefix + "CodePage", "0").getIntValue());
			out.write (text.toUTF8(), textLength);

			if ((out.getDataSize() & 1) != 0)
				out.writeByte (0);
		}

		void create (MemoryBlock& block, const StringPairArray& values)
		{
			const int numCueLabels  = values.getValue ("NumCueLabels", "0").getIntValue();
			const int numCueNotes   = values.getValue ("NumCueNotes", "0").getIntValue();
			const int numCueRegions = values.getValue ("NumCueRegions", "0").getIntValue();

			if (numCueLabels > 0 || numCueNotes > 0 || numCueRegions > 0)
			{
				MemoryOutputStream out (block, false);

				int i;
				for (i = 0; i < numCueLabels; ++i)
					appendLabelOrNoteChunk (values, "CueLabel" + String (i), chunkName ("labl"), out);

				for (i = 0; i < numCueNotes; ++i)
					appendLabelOrNoteChunk (values, "CueNote" + String (i), chunkName ("note"), out);

				for (i = 0; i < numCueRegions; ++i)
					appendExtraChunk (values, "CueRegion" + String (i), out);
			}
		}
	}

	struct ExtensibleWavSubFormat
	{
		uint32 data1;
		uint16 data2;
		uint16 data3;
		uint8  data4[8];
	} PACKED;

	struct DataSize64Chunk   // chunk ID = 'ds64' if data size > 0xffffffff, 'JUNK' otherwise
	{
		uint32 riffSizeLow;     // low 4 byte size of RF64 block
		uint32 riffSizeHigh;    // high 4 byte size of RF64 block
		uint32 dataSizeLow;     // low 4 byte size of data chunk
		uint32 dataSizeHigh;    // high 4 byte size of data chunk
		uint32 sampleCountLow;  // low 4 byte sample count of fact chunk
		uint32 sampleCountHigh; // high 4 byte sample count of fact chunk
		uint32 tableLength;     // number of valid entries in array 'table'
	} PACKED;

	#if JUCE_MSVC
	 #pragma pack (pop)
	#endif

	#undef PACKED
}

class WavAudioFormatReader  : public AudioFormatReader
{
public:
	WavAudioFormatReader (InputStream* const in)
		: AudioFormatReader (in, TRANS (wavFormatName)),
		  bwavChunkStart (0),
		  bwavSize (0),
		  dataLength (0),
		  isRF64 (false)
	{
		using namespace WavFileHelpers;
		uint64 len = 0;
		uint64 end = 0;
		bool hasGotType = false;
		bool hasGotData = false;
		int cueNoteIndex = 0;
		int cueLabelIndex = 0;
		int cueRegionIndex = 0;

		const int firstChunkType = input->readInt();

		if (firstChunkType == chunkName ("RF64"))
		{
			input->skipNextBytes (4); // size is -1 for RF64
			isRF64 = true;
		}
		else if (firstChunkType == chunkName ("RIFF"))
		{
			len = (uint64) (uint32) input->readInt();
			end = input->getPosition() + len;
		}
		else
		{
			return;
		}

		const int64 startOfRIFFChunk = input->getPosition();

		if (input->readInt() == chunkName ("WAVE"))
		{
			if (isRF64 && input->readInt() == chunkName ("ds64"))
			{
				uint32 length = (uint32) input->readInt();

				if (length < 28)
				{
					return;
				}
				else
				{
					const int64 chunkEnd = input->getPosition() + length + (length & 1);
					len = (uint64) input->readInt64();
					end = startOfRIFFChunk + len;
					dataLength = input->readInt64();
					input->setPosition (chunkEnd);
				}
			}

			while ((uint64) input->getPosition() < end && ! input->isExhausted())
			{
				const int chunkType = input->readInt();
				uint32 length = (uint32) input->readInt();
				const int64 chunkEnd = input->getPosition() + length + (length & 1);

				if (chunkType == chunkName ("fmt "))
				{
					// read the format chunk
					const unsigned short format = (unsigned short) input->readShort();
					numChannels = (unsigned int) input->readShort();
					sampleRate = input->readInt();
					const int bytesPerSec = input->readInt();
					input->skipNextBytes (2);
					bitsPerSample = (unsigned int) (int) input->readShort();

					if (bitsPerSample > 64)
					{
						bytesPerFrame = bytesPerSec / (int) sampleRate;
						bitsPerSample = 8 * bytesPerFrame / numChannels;
					}
					else
					{
						bytesPerFrame = numChannels * bitsPerSample / 8;
					}

					if (format == 3)
					{
						usesFloatingPointData = true;
					}
					else if (format == 0xfffe /*WAVE_FORMAT_EXTENSIBLE*/)
					{
						if (length < 40) // too short
						{
							bytesPerFrame = 0;
						}
						else
						{
							input->skipNextBytes (10); // skip over bitsPerSample and speakerPosition mask
							ExtensibleWavSubFormat subFormat;
							subFormat.data1 = (uint32) input->readInt();
							subFormat.data2 = (uint16) input->readShort();
							subFormat.data3 = (uint16) input->readShort();
							input->read (subFormat.data4, sizeof (subFormat.data4));

							const ExtensibleWavSubFormat pcmFormat
								= { 0x00000001, 0x0000, 0x0010, { 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71 } };

							if (memcmp (&subFormat, &pcmFormat, sizeof (subFormat)) != 0)
							{
								const ExtensibleWavSubFormat ambisonicFormat
									= { 0x00000001, 0x0721, 0x11d3, { 0x86, 0x44, 0xC8, 0xC1, 0xCA, 0x00, 0x00, 0x00 } };

								if (memcmp (&subFormat, &ambisonicFormat, sizeof (subFormat)) != 0)
									bytesPerFrame = 0;
							}
						}
					}
					else if (format != 1)
					{
						bytesPerFrame = 0;
					}

					hasGotType = true;
				}
				else if (chunkType == chunkName ("data"))
				{
					if (! isRF64) // data size is expected to be -1, actual data size is in ds64 chunk
						dataLength = length;

					dataChunkStart = input->getPosition();
					lengthInSamples = (bytesPerFrame > 0) ? (dataLength / bytesPerFrame) : 0;

					hasGotData = true;
				}
				else if (chunkType == chunkName ("bext"))
				{
					bwavChunkStart = input->getPosition();
					bwavSize = length;

					HeapBlock <BWAVChunk> bwav;
					bwav.calloc (jmax ((size_t) length + 1, sizeof (BWAVChunk)), 1);
					input->read (bwav, (int) length);
					bwav->copyTo (metadataValues);
				}
				else if (chunkType == chunkName ("smpl"))
				{
					HeapBlock <SMPLChunk> smpl;
					smpl.calloc (jmax ((size_t) length + 1, sizeof (SMPLChunk)), 1);
					input->read (smpl, (int) length);
					smpl->copyTo (metadataValues, (int) length);
				}
				else if (chunkType == chunkName ("inst") || chunkType == chunkName ("INST")) // need to check which...
				{
					HeapBlock <InstChunk> inst;
					inst.calloc (jmax ((size_t) length + 1, sizeof (InstChunk)), 1);
					input->read (inst, (int) length);
					inst->copyTo (metadataValues);
				}
				else if (chunkType == chunkName ("cue "))
				{
					HeapBlock <CueChunk> cue;
					cue.calloc (jmax ((size_t) length + 1, sizeof (CueChunk)), 1);
					input->read (cue, (int) length);
					cue->copyTo (metadataValues, (int) length);
				}
				else if (chunkType == chunkName ("LIST"))
				{
					if (input->readInt() == chunkName ("adtl"))
					{
						while (input->getPosition() < chunkEnd)
						{
							const int adtlChunkType = input->readInt();
							const uint32 adtlLength = (uint32) input->readInt();
							const int64 adtlChunkEnd = input->getPosition() + (adtlLength + (adtlLength & 1));

							if (adtlChunkType == chunkName ("labl") || adtlChunkType == chunkName ("note"))
							{
								String prefix;

								if (adtlChunkType == chunkName ("labl"))
									prefix << "CueLabel" << cueLabelIndex++;
								else if (adtlChunkType == chunkName ("note"))
									prefix << "CueNote" << cueNoteIndex++;

								const uint32 identifier = (uint32) input->readInt();
								const int stringLength = (int) adtlLength - 4;

								MemoryBlock textBlock;
								input->readIntoMemoryBlock (textBlock, stringLength);

								metadataValues.set (prefix + "Identifier", String (identifier));
								metadataValues.set (prefix + "Text", textBlock.toString());
							}
							else if (adtlChunkType == chunkName ("ltxt"))
							{
								const String prefix ("CueRegion" + String (cueRegionIndex++));
								const uint32 identifier     = (uint32) input->readInt();
								const uint32 sampleLength   = (uint32) input->readInt();
								const uint32 purpose        = (uint32) input->readInt();
								const uint16 country        = (uint16) input->readInt();
								const uint16 language       = (uint16) input->readInt();
								const uint16 dialect        = (uint16) input->readInt();
								const uint16 codePage       = (uint16) input->readInt();
								const uint32 stringLength   = adtlLength - 20;

								MemoryBlock textBlock;
								input->readIntoMemoryBlock (textBlock, (int) stringLength);

								metadataValues.set (prefix + "Identifier",   String (identifier));
								metadataValues.set (prefix + "SampleLength", String (sampleLength));
								metadataValues.set (prefix + "Purpose",      String (purpose));
								metadataValues.set (prefix + "Country",      String (country));
								metadataValues.set (prefix + "Language",     String (language));
								metadataValues.set (prefix + "Dialect",      String (dialect));
								metadataValues.set (prefix + "CodePage",     String (codePage));
								metadataValues.set (prefix + "Text",         textBlock.toString());
							}

							input->setPosition (adtlChunkEnd);
						}
					}
				}
				else if (chunkEnd <= input->getPosition())
				{
					break;
				}

				input->setPosition (chunkEnd);
			}
		}

		if (cueLabelIndex > 0)          metadataValues.set ("NumCueLabels",     String (cueLabelIndex));
		if (cueNoteIndex > 0)           metadataValues.set ("NumCueNotes",      String (cueNoteIndex));
		if (cueRegionIndex > 0)         metadataValues.set ("NumCueRegions",    String (cueRegionIndex));
		if (metadataValues.size() > 0)  metadataValues.set ("MetaDataSource",   "WAV");
	}

	bool readSamples (int** destSamples, int numDestChannels, int startOffsetInDestBuffer,
					  int64 startSampleInFile, int numSamples)
	{
		jassert (destSamples != nullptr);
		const int64 samplesAvailable = lengthInSamples - startSampleInFile;

		if (samplesAvailable < numSamples)
		{
			for (int i = numDestChannels; --i >= 0;)
				if (destSamples[i] != nullptr)
					zeromem (destSamples[i] + startOffsetInDestBuffer, sizeof (int) * numSamples);

			numSamples = (int) samplesAvailable;
		}

		if (numSamples <= 0)
			return true;

		input->setPosition (dataChunkStart + startSampleInFile * bytesPerFrame);

		while (numSamples > 0)
		{
			const int tempBufSize = 480 * 3 * 4; // (keep this a multiple of 3)
			char tempBuffer [tempBufSize];

			const int numThisTime = jmin (tempBufSize / bytesPerFrame, numSamples);
			const int bytesRead = input->read (tempBuffer, numThisTime * bytesPerFrame);

			if (bytesRead < numThisTime * bytesPerFrame)
			{
				jassert (bytesRead >= 0);
				zeromem (tempBuffer + bytesRead, (size_t) (numThisTime * bytesPerFrame - bytesRead));
			}

			switch (bitsPerSample)
			{
				case 8:     ReadHelper<AudioData::Int32, AudioData::UInt8, AudioData::LittleEndian>::read (destSamples, startOffsetInDestBuffer, numDestChannels, tempBuffer, (int) numChannels, numThisTime); break;
				case 16:    ReadHelper<AudioData::Int32, AudioData::Int16, AudioData::LittleEndian>::read (destSamples, startOffsetInDestBuffer, numDestChannels, tempBuffer, (int) numChannels, numThisTime); break;
				case 24:    ReadHelper<AudioData::Int32, AudioData::Int24, AudioData::LittleEndian>::read (destSamples, startOffsetInDestBuffer, numDestChannels, tempBuffer, (int) numChannels, numThisTime); break;
				case 32:    if (usesFloatingPointData) ReadHelper<AudioData::Float32, AudioData::Float32, AudioData::LittleEndian>::read (destSamples, startOffsetInDestBuffer, numDestChannels, tempBuffer, (int) numChannels, numThisTime);
							else                       ReadHelper<AudioData::Int32, AudioData::Int32, AudioData::LittleEndian>::read (destSamples, startOffsetInDestBuffer, numDestChannels, tempBuffer, (int) numChannels, numThisTime); break;
				default:    jassertfalse; break;
			}

			startOffsetInDestBuffer += numThisTime;
			numSamples -= numThisTime;
		}

		return true;
	}

	int64 bwavChunkStart, bwavSize;

private:
	ScopedPointer<AudioData::Converter> converter;
	int bytesPerFrame;
	int64 dataChunkStart, dataLength;
	bool isRF64;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (WavAudioFormatReader);
};

class WavAudioFormatWriter  : public AudioFormatWriter
{
public:
	WavAudioFormatWriter (OutputStream* const out, const double sampleRate_,
						  const unsigned int numChannels_, const unsigned int bits,
						  const StringPairArray& metadataValues)
		: AudioFormatWriter (out, TRANS (wavFormatName), sampleRate_, numChannels_, bits),
		  lengthInSamples (0),
		  bytesWritten (0),
		  writeFailed (false)
	{
		using namespace WavFileHelpers;

		if (metadataValues.size() > 0)
		{
			// The meta data should have been santised for the WAV format.
			// If it was originally sourced from an AIFF file the MetaDataSource
			// key should be removed (or set to "WAV") once this has been done
			jassert (metadataValues.getValue ("MetaDataSource", "None") != "AIFF");

			bwavChunk = BWAVChunk::createFrom (metadataValues);
			smplChunk = SMPLChunk::createFrom (metadataValues);
			instChunk = InstChunk::createFrom (metadataValues);
			CueChunk ::create (cueChunk, metadataValues);
			ListChunk::create (listChunk, metadataValues);
		}

		headerPosition = out->getPosition();
		writeHeader();
	}

	~WavAudioFormatWriter()
	{
		if ((bytesWritten & 1) != 0) // pad to an even length
		{
			++bytesWritten;
			output->writeByte (0);
		}

		writeHeader();
	}

	bool write (const int** data, int numSamples)
	{
		jassert (data != nullptr && *data != nullptr); // the input must contain at least one channel!

		if (writeFailed)
			return false;

		const size_t bytes = numChannels * numSamples * bitsPerSample / 8;
		tempBlock.ensureSize (bytes, false);

		switch (bitsPerSample)
		{
			case 8:     WriteHelper<AudioData::UInt8, AudioData::Int32, AudioData::LittleEndian>::write (tempBlock.getData(), (int) numChannels, data, numSamples); break;
			case 16:    WriteHelper<AudioData::Int16, AudioData::Int32, AudioData::LittleEndian>::write (tempBlock.getData(), (int) numChannels, data, numSamples); break;
			case 24:    WriteHelper<AudioData::Int24, AudioData::Int32, AudioData::LittleEndian>::write (tempBlock.getData(), (int) numChannels, data, numSamples); break;
			case 32:    WriteHelper<AudioData::Int32, AudioData::Int32, AudioData::LittleEndian>::write (tempBlock.getData(), (int) numChannels, data, numSamples); break;
			default:    jassertfalse; break;
		}

		if (! output->write (tempBlock.getData(), (int) bytes))
		{
			// failed to write to disk, so let's try writing the header.
			// If it's just run out of disk space, then if it does manage
			// to write the header, we'll still have a useable file..
			writeHeader();
			writeFailed = true;
			return false;
		}
		else
		{
			bytesWritten += bytes;
			lengthInSamples += numSamples;

			return true;
		}
	}

private:
	ScopedPointer<AudioData::Converter> converter;
	MemoryBlock tempBlock, bwavChunk, smplChunk, instChunk, cueChunk, listChunk;
	uint64 lengthInSamples, bytesWritten;
	int64 headerPosition;
	bool writeFailed;

	static int getChannelMask (const int numChannels) noexcept
	{
		switch (numChannels)
		{
			case 1:   return 0;
			case 2:   return 1 + 2; // SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT
			case 5:   return 1 + 2 + 4 + 16 + 32; // SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | SPEAKER_FRONT_CENTER | SPEAKER_BACK_LEFT | SPEAKER_BACK_RIGHT
			case 6:   return 1 + 2 + 4 + 8 + 16 + 32; // SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | SPEAKER_FRONT_CENTER | SPEAKER_LOW_FREQUENCY | SPEAKER_BACK_LEFT | SPEAKER_BACK_RIGHT
			default:  break;
		}

		return 0;
	}

	void writeHeader()
	{
		using namespace WavFileHelpers;
		const bool seekedOk = output->setPosition (headerPosition);
		(void) seekedOk;

		// if this fails, you've given it an output stream that can't seek! It needs
		// to be able to seek back to write the header
		jassert (seekedOk);

		const size_t bytesPerFrame = numChannels * bitsPerSample / 8;
		uint64 audioDataSize = bytesPerFrame * lengthInSamples;

		const bool isRF64 = (bytesWritten >= literal64bit (0x100000000));
		const bool isWaveFmtEx = isRF64 || (numChannels > 2);

		int64 riffChunkSize = 4 /* 'RIFF' */ + 8 + 40 /* WAVEFORMATEX */
							   + 8 + audioDataSize + (audioDataSize & 1)
							   + (bwavChunk.getSize() > 0 ? (8  + bwavChunk.getSize()) : 0)
							   + (smplChunk.getSize() > 0 ? (8  + smplChunk.getSize()) : 0)
							   + (instChunk.getSize() > 0 ? (8  + instChunk.getSize()) : 0)
							   + (cueChunk .getSize() > 0 ? (8  + cueChunk .getSize()) : 0)
							   + (listChunk.getSize() > 0 ? (12 + listChunk.getSize()) : 0)
							   + (8 + 28); // (ds64 chunk)

		riffChunkSize += (riffChunkSize & 0x1);

		output->writeInt (chunkName (isRF64 ? "RF64" : "RIFF"));
		output->writeInt (isRF64 ? -1 : (int) riffChunkSize);
		output->writeInt (chunkName ("WAVE"));

		if (! isRF64)
		{
			output->writeInt (chunkName ("JUNK"));
			output->writeInt (28 + (isWaveFmtEx? 0 : 24));
			output->writeRepeatedByte (0, 28 /* ds64 */ + (isWaveFmtEx? 0 : 24));
		}
		else
		{
			// write ds64 chunk
			output->writeInt (chunkName ("ds64"));
			output->writeInt (28);  // chunk size for uncompressed data (no table)
			output->writeInt64 (riffChunkSize);
			output->writeInt64 (audioDataSize);
			output->writeRepeatedByte (0, 12);
		}

		output->writeInt (chunkName ("fmt "));

		if (isWaveFmtEx)
		{
			output->writeInt (40); // chunk size
			output->writeShort ((short) (uint16) 0xfffe); // WAVE_FORMAT_EXTENSIBLE
		}
		else
		{
			output->writeInt (16); // chunk size
			output->writeShort (bitsPerSample < 32 ? (short) 1 /*WAVE_FORMAT_PCM*/
												   : (short) 3 /*WAVE_FORMAT_IEEE_FLOAT*/);
		}

		output->writeShort ((short) numChannels);
		output->writeInt ((int) sampleRate);
		output->writeInt ((int) (bytesPerFrame * sampleRate)); // nAvgBytesPerSec
		output->writeShort ((short) bytesPerFrame); // nBlockAlign
		output->writeShort ((short) bitsPerSample); // wBitsPerSample

		if (isWaveFmtEx)
		{
			output->writeShort (22); // cbSize (size of  the extension)
			output->writeShort ((short) bitsPerSample); // wValidBitsPerSample
			output->writeInt (getChannelMask ((int) numChannels));

			const ExtensibleWavSubFormat pcmFormat
				= { 0x00000001, 0x0000, 0x0010, { 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71 } };

			const ExtensibleWavSubFormat IEEEFloatFormat
				= { 0x00000003, 0x0000, 0x0010, { 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71 } };

			const ExtensibleWavSubFormat& subFormat = bitsPerSample < 32 ? pcmFormat : IEEEFloatFormat;

			output->writeInt ((int) subFormat.data1);
			output->writeShort ((short) subFormat.data2);
			output->writeShort ((short) subFormat.data3);
			output->write (subFormat.data4, sizeof (subFormat.data4));
		}

		if (bwavChunk.getSize() > 0)
		{
			output->writeInt (chunkName ("bext"));
			output->writeInt ((int) bwavChunk.getSize());
			*output << bwavChunk;
		}

		if (smplChunk.getSize() > 0)
		{
			output->writeInt (chunkName ("smpl"));
			output->writeInt ((int) smplChunk.getSize());
			*output << smplChunk;
		}

		if (instChunk.getSize() > 0)
		{
			output->writeInt (chunkName ("inst"));
			output->writeInt (7);
			*output << instChunk;
		}

		if (cueChunk.getSize() > 0)
		{
			output->writeInt (chunkName ("cue "));
			output->writeInt ((int) cueChunk.getSize());
			*output << cueChunk;
		}

		if (listChunk.getSize() > 0)
		{
			output->writeInt (chunkName ("LIST"));
			output->writeInt ((int) listChunk.getSize() + 4);
			output->writeInt (chunkName ("adtl"));
			*output << listChunk;
		}

		output->writeInt (chunkName ("data"));
		output->writeInt (isRF64 ? -1 : (int) (lengthInSamples * bytesPerFrame));

		usesFloatingPointData = (bitsPerSample == 32);
	}

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (WavAudioFormatWriter);
};

WavAudioFormat::WavAudioFormat()
	: AudioFormat (TRANS (wavFormatName), StringArray (wavExtensions))
{
}

WavAudioFormat::~WavAudioFormat()
{
}

Array<int> WavAudioFormat::getPossibleSampleRates()
{
	const int rates[] = { 22050, 32000, 44100, 48000, 88200, 96000, 176400, 192000, 0 };
	return Array <int> (rates);
}

Array<int> WavAudioFormat::getPossibleBitDepths()
{
	const int depths[] = { 8, 16, 24, 32, 0 };
	return Array <int> (depths);
}

bool WavAudioFormat::canDoStereo()  { return true; }
bool WavAudioFormat::canDoMono()    { return true; }

AudioFormatReader* WavAudioFormat::createReaderFor (InputStream* sourceStream,
													const bool deleteStreamIfOpeningFails)
{
	ScopedPointer <WavAudioFormatReader> r (new WavAudioFormatReader (sourceStream));

	if (r->sampleRate > 0)
		return r.release();

	if (! deleteStreamIfOpeningFails)
		r->input = nullptr;

	return nullptr;
}

AudioFormatWriter* WavAudioFormat::createWriterFor (OutputStream* out, double sampleRate,
													unsigned int numChannels, int bitsPerSample,
													const StringPairArray& metadataValues, int /*qualityOptionIndex*/)
{
	if (getPossibleBitDepths().contains (bitsPerSample))
		return new WavAudioFormatWriter (out, sampleRate, (int) numChannels, bitsPerSample, metadataValues);

	return nullptr;
}

namespace WavFileHelpers
{
	bool slowCopyWavFileWithNewMetadata (const File& file, const StringPairArray& metadata)
	{
		TemporaryFile tempFile (file);

		WavAudioFormat wav;
		ScopedPointer <AudioFormatReader> reader (wav.createReaderFor (file.createInputStream(), true));

		if (reader != nullptr)
		{
			ScopedPointer <OutputStream> outStream (tempFile.getFile().createOutputStream());

			if (outStream != nullptr)
			{
				ScopedPointer <AudioFormatWriter> writer (wav.createWriterFor (outStream, reader->sampleRate,
																			   reader->numChannels, (int) reader->bitsPerSample,
																			   metadata, 0));

				if (writer != nullptr)
				{
					outStream.release();

					bool ok = writer->writeFromAudioReader (*reader, 0, -1);
					writer = nullptr;
					reader = nullptr;

					return ok && tempFile.overwriteTargetFileWithTemporary();
				}
			}
		}

		return false;
	}
}

bool WavAudioFormat::replaceMetadataInFile (const File& wavFile, const StringPairArray& newMetadata)
{
	using namespace WavFileHelpers;
	ScopedPointer <WavAudioFormatReader> reader (static_cast <WavAudioFormatReader*> (createReaderFor (wavFile.createInputStream(), true)));

	if (reader != nullptr)
	{
		const int64 bwavPos  = reader->bwavChunkStart;
		const int64 bwavSize = reader->bwavSize;
		reader = nullptr;

		if (bwavSize > 0)
		{
			MemoryBlock chunk (BWAVChunk::createFrom (newMetadata));

			if (chunk.getSize() <= (size_t) bwavSize)
			{
				// the new one will fit in the space available, so write it directly..
				const int64 oldSize = wavFile.getSize();

				{
					FileOutputStream out (wavFile);

					if (! out.failedToOpen())
					{
						out.setPosition (bwavPos);
						out << chunk;
						out.setPosition (oldSize);
					}
				}

				jassert (wavFile.getSize() == oldSize);

				return true;
			}
		}
	}

	return slowCopyWavFileWithNewMetadata (wavFile, newMetadata);
}

/*** End of inlined file: juce_WavAudioFormat.cpp ***/


/*** Start of inlined file: juce_WindowsMediaAudioFormat.cpp ***/
#if JUCE_WINDOWS

namespace WindowsMediaCodec
{

class JuceIStream   : public ComBaseClassHelper <IStream>
{
public:
	JuceIStream (InputStream& source_) noexcept
		: source (source_)
	{
		resetReferenceCount();
	}

	JUCE_COMRESULT Commit (DWORD)                        { return S_OK; }
	JUCE_COMRESULT Write (const void*, ULONG, ULONG*)    { return E_NOTIMPL; }
	JUCE_COMRESULT Clone (IStream**)                     { return E_NOTIMPL; }
	JUCE_COMRESULT SetSize (ULARGE_INTEGER)              { return E_NOTIMPL; }
	JUCE_COMRESULT Revert()                              { return E_NOTIMPL; }
	JUCE_COMRESULT LockRegion (ULARGE_INTEGER, ULARGE_INTEGER, DWORD)    { return E_NOTIMPL; }
	JUCE_COMRESULT UnlockRegion (ULARGE_INTEGER, ULARGE_INTEGER, DWORD)  { return E_NOTIMPL; }

	JUCE_COMRESULT Read (void* dest, ULONG numBytes, ULONG* bytesRead)
	{
		const int numRead = source.read (dest, numBytes);

		if (bytesRead != nullptr)
			*bytesRead = numRead;

		return numRead == (int) numBytes ? S_OK : S_FALSE;
	}

	JUCE_COMRESULT Seek (LARGE_INTEGER position, DWORD origin, ULARGE_INTEGER* resultPosition)
	{
		int64 newPos = (int64) position.QuadPart;

		if (origin == STREAM_SEEK_CUR)
		{
			newPos += source.getPosition();
		}
		else if (origin == STREAM_SEEK_END)
		{
			const int64 len = source.getTotalLength();
			if (len < 0)
				return E_NOTIMPL;

			newPos += len;
		}

		if (resultPosition != nullptr)
			resultPosition->QuadPart = newPos;

		return source.setPosition (newPos) ? S_OK : E_NOTIMPL;
	}

	JUCE_COMRESULT CopyTo (IStream* destStream, ULARGE_INTEGER numBytesToDo,
						   ULARGE_INTEGER* bytesRead, ULARGE_INTEGER* bytesWritten)
	{
		uint64 totalCopied = 0;
		int64 numBytes = numBytesToDo.QuadPart;

		while (numBytes > 0 && ! source.isExhausted())
		{
			char buffer [1024];

			const int numToCopy = (int) jmin ((int64) sizeof (buffer), (int64) numBytes);
			const int numRead = source.read (buffer, numToCopy);

			if (numRead <= 0)
				break;

			destStream->Write (buffer, numRead, nullptr);
			totalCopied += numRead;
		}

		if (bytesRead != nullptr)      bytesRead->QuadPart = totalCopied;
		if (bytesWritten != nullptr)   bytesWritten->QuadPart = totalCopied;

		return S_OK;
	}

	JUCE_COMRESULT Stat (STATSTG* stat, DWORD)
	{
		if (stat == nullptr)
			return STG_E_INVALIDPOINTER;

		zerostruct (*stat);
		stat->type = STGTY_STREAM;
		stat->cbSize.QuadPart = jmax ((int64) 0, source.getTotalLength());
		return S_OK;
	}

private:
	InputStream& source;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (JuceIStream);
};

static const char* wmFormatName = "Windows Media";
static const char* const extensions[] = { ".mp3", ".wmv", ".asf", ".wm", ".wma", 0 };

class WMAudioReader   : public AudioFormatReader
{
public:
	WMAudioReader (InputStream* const input_)
		: AudioFormatReader (input_, TRANS (wmFormatName)),
		  wmvCoreLib ("Wmvcore.dll"),
		  currentPosition (0),
		  bufferStart (0), bufferEnd (0)
	{
		typedef HRESULT (*WMCreateSyncReaderType) (IUnknown*, DWORD, IWMSyncReader**);
		WMCreateSyncReaderType wmCreateSyncReader = nullptr;
		wmCreateSyncReader = (WMCreateSyncReaderType) wmvCoreLib.getFunction ("WMCreateSyncReader");

		if (wmCreateSyncReader != nullptr)
		{
			CoInitialize (0);

			HRESULT hr = wmCreateSyncReader (nullptr, WMT_RIGHT_PLAYBACK, wmSyncReader.resetAndGetPointerAddress());

			if (SUCCEEDED (hr))
				hr = wmSyncReader->OpenStream (new JuceIStream (*input));

			if (SUCCEEDED (hr))
			{
				WORD streamNum = 1;
				hr = wmSyncReader->GetStreamNumberForOutput (0, &streamNum);
				hr = wmSyncReader->SetReadStreamSamples (streamNum, false);

				scanFileForDetails();
			}
		}
	}

	~WMAudioReader()
	{
		if (wmSyncReader != nullptr)
		{
			wmSyncReader->Close();
			wmSyncReader = nullptr;
		}
	}

	bool readSamples (int** destSamples, int numDestChannels, int startOffsetInDestBuffer,
					  int64 startSampleInFile, int numSamples)
	{
		if (sampleRate <= 0)
			return false;

		if (startSampleInFile != currentPosition)
		{
			currentPosition = startSampleInFile;
			wmSyncReader->SetRange (((QWORD) startSampleInFile * 10000000) / (int) sampleRate, 0);
			bufferStart = bufferEnd = 0;
		}

		while (numSamples > 0)
		{
			if (bufferEnd <= bufferStart)
			{
				INSSBuffer* sampleBuffer = nullptr;
				QWORD sampleTime, duration;
				DWORD flags, outputNum;
				WORD streamNum;

				HRESULT hr = wmSyncReader->GetNextSample (0, &sampleBuffer, &sampleTime,
														  &duration, &flags, &outputNum, &streamNum);

				if (SUCCEEDED (hr))
				{
					BYTE* rawData = nullptr;
					DWORD dataLength = 0;
					hr = sampleBuffer->GetBufferAndLength (&rawData, &dataLength);
					jassert (SUCCEEDED (hr));

					bufferStart = 0;
					bufferEnd = (int) dataLength;

					if (bufferEnd <= 0)
						return false;

					buffer.ensureSize (bufferEnd);
					memcpy (buffer.getData(), rawData, bufferEnd);
				}
				else
				{
					bufferStart = 0;
					bufferEnd = 512;
					buffer.ensureSize (bufferEnd);
					buffer.fillWith (0);
				}
			}

			const int stride = numChannels * sizeof (int16);
			const int16* const rawData = static_cast <const int16*> (addBytesToPointer (buffer.getData(), bufferStart));
			const int numToDo = jmin (numSamples, (bufferEnd - bufferStart) / stride);

			for (int i = 0; i < numDestChannels; ++i)
			{
				jassert (destSamples[i] != nullptr);

				const int srcChan = jmin (i, (int) numChannels - 1);
				const int16* src = rawData + srcChan;
				int* const dst = destSamples[i] + startOffsetInDestBuffer;

				for (int j = 0; j < numToDo; ++j)
				{
					dst[j] = ((uint32) *src) << 16;
					src += numChannels;
				}
			}

			bufferStart += numToDo * stride;
			startOffsetInDestBuffer += numToDo;
			numSamples -= numToDo;
			currentPosition += numToDo;
		}

		return true;
	}

private:
	DynamicLibrary wmvCoreLib;
	ComSmartPtr<IWMSyncReader> wmSyncReader;
	int64 currentPosition;
	MemoryBlock buffer;
	int bufferStart, bufferEnd;

	void scanFileForDetails()
	{
		ComSmartPtr<IWMHeaderInfo> wmHeaderInfo;
		HRESULT hr = wmSyncReader.QueryInterface (wmHeaderInfo);

		if (SUCCEEDED (hr))
		{
			QWORD lengthInNanoseconds = 0;
			WORD lengthOfLength = sizeof (lengthInNanoseconds);
			WORD streamNum = 0;
			WMT_ATTR_DATATYPE wmAttrDataType;
			hr = wmHeaderInfo->GetAttributeByName (&streamNum, L"Duration", &wmAttrDataType,
												   (BYTE*) &lengthInNanoseconds, &lengthOfLength);

			ComSmartPtr<IWMProfile> wmProfile;
			hr = wmSyncReader.QueryInterface (wmProfile);

			if (SUCCEEDED (hr))
			{
				ComSmartPtr<IWMStreamConfig> wmStreamConfig;
				hr = wmProfile->GetStream (0, wmStreamConfig.resetAndGetPointerAddress());

				if (SUCCEEDED (hr))
				{
					ComSmartPtr<IWMMediaProps> wmMediaProperties;
					hr = wmStreamConfig.QueryInterface (wmMediaProperties);

					if (SUCCEEDED (hr))
					{
						DWORD sizeMediaType;
						hr = wmMediaProperties->GetMediaType (0, &sizeMediaType);

						HeapBlock<WM_MEDIA_TYPE> mediaType;
						mediaType.malloc (sizeMediaType, 1);
						hr = wmMediaProperties->GetMediaType (mediaType, &sizeMediaType);

						if (mediaType->majortype == WMMEDIATYPE_Audio)
						{
							const WAVEFORMATEX* const inputFormat = reinterpret_cast<WAVEFORMATEX*> (mediaType->pbFormat);

							sampleRate = inputFormat->nSamplesPerSec;
							numChannels = inputFormat->nChannels;
							bitsPerSample = inputFormat->wBitsPerSample;
							lengthInSamples = (lengthInNanoseconds * (int) sampleRate) / 10000000;
						}
					}
				}
			}
		}
	}

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (WMAudioReader);
};

}

WindowsMediaAudioFormat::WindowsMediaAudioFormat()
	: AudioFormat (TRANS (WindowsMediaCodec::wmFormatName), StringArray (WindowsMediaCodec::extensions))
{
}

WindowsMediaAudioFormat::~WindowsMediaAudioFormat() {}

Array<int> WindowsMediaAudioFormat::getPossibleSampleRates()    { return Array<int>(); }
Array<int> WindowsMediaAudioFormat::getPossibleBitDepths()      { return Array<int>(); }

bool WindowsMediaAudioFormat::canDoStereo()     { return true; }
bool WindowsMediaAudioFormat::canDoMono()       { return true; }

AudioFormatReader* WindowsMediaAudioFormat::createReaderFor (InputStream* sourceStream, bool deleteStreamIfOpeningFails)
{
	ScopedPointer<WindowsMediaCodec::WMAudioReader> r (new WindowsMediaCodec::WMAudioReader (sourceStream));

	if (r->sampleRate > 0)
		return r.release();

	if (! deleteStreamIfOpeningFails)
		r->input = nullptr;

	return nullptr;
}

AudioFormatWriter* WindowsMediaAudioFormat::createWriterFor (OutputStream* /*streamToWriteTo*/, double /*sampleRateToUse*/,
															 unsigned int /*numberOfChannels*/, int /*bitsPerSample*/,
															 const StringPairArray& /*metadataValues*/, int /*qualityOptionIndex*/)
{
	jassertfalse; // not yet implemented!
	return nullptr;
}

#endif

/*** End of inlined file: juce_WindowsMediaAudioFormat.cpp ***/

// END_AUTOINCLUDE

}

/*** End of inlined file: juce_audio_formats.cpp ***/

