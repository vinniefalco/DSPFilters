/* bypass certain compile time usage checks */
#define JUCE_AMALGAMATED_INCLUDE 1

#include "AppConfig.h"


/*** Start of inlined file: juce_gui_basics.cpp ***/
#if defined (__JUCE_GUI_BASICS_JUCEHEADER__) && ! JUCE_AMALGAMATED_INCLUDE
 /* When you add this cpp file to your project, you mustn't include it in a file where you've
	already included any other headers - just put it inside a file on its own, possibly with your config
	flags preceding it, but don't include anything else. That also includes avoiding any automatic prefix
	header files that the compiler may be using.
 */
 #error "Incorrect use of JUCE cpp file"
#endif

// Your project must contain an AppConfig.h file with your project-specific settings in it,
// and your header search path must make it accessible to the module's files.
#include "AppConfig.h"


/*** Start of inlined file: juce_BasicNativeHeaders.h ***/
#ifndef __JUCE_BASICNATIVEHEADERS_JUCEHEADER__
#define __JUCE_BASICNATIVEHEADERS_JUCEHEADER__


/*** Start of inlined file: juce_TargetPlatform.h ***/
#ifndef __JUCE_TARGETPLATFORM_JUCEHEADER__
#define __JUCE_TARGETPLATFORM_JUCEHEADER__

/*  This file figures out which platform is being built, and defines some macros
	that the rest of the code can use for OS-specific compilation.

	Macros that will be set here are:

	- One of JUCE_WINDOWS, JUCE_MAC JUCE_LINUX, JUCE_IOS, JUCE_ANDROID, etc.
	- Either JUCE_32BIT or JUCE_64BIT, depending on the architecture.
	- Either JUCE_LITTLE_ENDIAN or JUCE_BIG_ENDIAN.
	- Either JUCE_INTEL or JUCE_PPC
	- Either JUCE_GCC or JUCE_MSVC
*/

/* This line is here as a sanity-check to catch syntax errors caused by mistakes in 3rd-party
   header files that have been included before this one. If you hit an error at this line, there
   must be some kind of syntax problem in whatever code immediately precedes this header.

   It also causes an error if you attempt to build using a C or obj-C compiler rather than a C++ one.
*/
namespace JuceDummyNamespace {}

#if (defined (_WIN32) || defined (_WIN64))
  #define       JUCE_WIN32 1
  #define       JUCE_WINDOWS 1
#elif defined (JUCE_ANDROID)
  #undef        JUCE_ANDROID
  #define       JUCE_ANDROID 1
#elif defined (LINUX) || defined (__linux__)
  #define     JUCE_LINUX 1
#elif defined (__APPLE_CPP__) || defined(__APPLE_CC__)
  #define Point CarbonDummyPointName // (workaround to avoid definition of "Point" by old Carbon headers)
  #define Component CarbonDummyCompName
  #include <CoreFoundation/CoreFoundation.h> // (needed to find out what platform we're using)
  #undef Point
  #undef Component

  #if TARGET_OS_IPHONE || TARGET_IPHONE_SIMULATOR
	#define     JUCE_IPHONE 1
	#define     JUCE_IOS 1
  #else
	#define     JUCE_MAC 1
  #endif
#else
  #error "Unknown platform!"
#endif

#if JUCE_WINDOWS
  #ifdef _MSC_VER
	#ifdef _WIN64
	  #define JUCE_64BIT 1
	#else
	  #define JUCE_32BIT 1
	#endif
  #endif

  #ifdef _DEBUG
	#define JUCE_DEBUG 1
  #endif

  #ifdef __MINGW32__
	#define JUCE_MINGW 1
  #endif

  /** If defined, this indicates that the processor is little-endian. */
  #define JUCE_LITTLE_ENDIAN 1

  #define JUCE_INTEL 1
#endif

#if JUCE_MAC || JUCE_IOS

  #if defined (DEBUG) || defined (_DEBUG) || ! (defined (NDEBUG) || defined (_NDEBUG))
	#define JUCE_DEBUG 1
  #endif

  #if ! (defined (DEBUG) || defined (_DEBUG) || defined (NDEBUG) || defined (_NDEBUG))
	#warning "Neither NDEBUG or DEBUG has been defined - you should set one of these to make it clear whether this is a release build,"
  #endif

  #ifdef __LITTLE_ENDIAN__
	#define JUCE_LITTLE_ENDIAN 1
  #else
	#define JUCE_BIG_ENDIAN 1
  #endif
#endif

#if JUCE_MAC

  #if defined (__ppc__) || defined (__ppc64__)
	#define JUCE_PPC 1
  #else
	#define JUCE_INTEL 1
  #endif

  #ifdef __LP64__
	#define JUCE_64BIT 1
  #else
	#define JUCE_32BIT 1
  #endif

  #if MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_4
	#error "Building for OSX 10.3 is no longer supported!"
  #endif

  #ifndef MAC_OS_X_VERSION_10_5
	#error "To build with 10.4 compatibility, use a 10.5 or 10.6 SDK and set the deployment target to 10.4"
  #endif

#endif

#if JUCE_LINUX || JUCE_ANDROID

  #ifdef _DEBUG
	#define JUCE_DEBUG 1
  #endif

  // Allow override for big-endian Linux platforms
  #if defined (__LITTLE_ENDIAN__) || ! defined (JUCE_BIG_ENDIAN)
	#define JUCE_LITTLE_ENDIAN 1
	#undef JUCE_BIG_ENDIAN
  #else
	#undef JUCE_LITTLE_ENDIAN
	#define JUCE_BIG_ENDIAN 1
  #endif

  #if defined (__LP64__) || defined (_LP64)
	#define JUCE_64BIT 1
  #else
	#define JUCE_32BIT 1
  #endif

  #if __MMX__ || __SSE__ || __amd64__
	#define JUCE_INTEL 1
  #endif
#endif

// Compiler type macros.

#ifdef __GNUC__
  #define JUCE_GCC 1
#elif defined (_MSC_VER)
  #define JUCE_MSVC 1

  #if _MSC_VER < 1500
	#define JUCE_VC8_OR_EARLIER 1

	#if _MSC_VER < 1400
	  #define JUCE_VC7_OR_EARLIER 1

	  #if _MSC_VER < 1300
		#warning "MSVC 6.0 is no longer supported!"
	  #endif
	#endif
  #endif

  #if JUCE_64BIT || ! JUCE_VC7_OR_EARLIER
	#define JUCE_USE_INTRINSICS 1
  #endif
#else
  #error unknown compiler
#endif

#endif   // __JUCE_TARGETPLATFORM_JUCEHEADER__

/*** End of inlined file: juce_TargetPlatform.h ***/

#undef T

#if JUCE_MAC || JUCE_IOS

 #if JUCE_IOS
  #import <Foundation/Foundation.h>
  #import <UIKit/UIKit.h>
  #import <CoreData/CoreData.h>
  #import <MobileCoreServices/MobileCoreServices.h>
  #include <sys/fcntl.h>
 #else
  #define Point CarbonDummyPointName
  #define Component CarbonDummyCompName
  #import <Cocoa/Cocoa.h>
  #import <CoreAudio/HostTime.h>
  #undef Point
  #undef Component
  #include <sys/dir.h>
 #endif

 #include <sys/socket.h>
 #include <sys/sysctl.h>
 #include <sys/stat.h>
 #include <sys/param.h>
 #include <sys/mount.h>
 #include <sys/utsname.h>
 #include <sys/mman.h>
 #include <fnmatch.h>
 #include <utime.h>
 #include <dlfcn.h>
 #include <ifaddrs.h>
 #include <net/if_dl.h>
 #include <mach/mach_time.h>
 #include <mach-o/dyld.h>

#elif JUCE_WINDOWS
 #if JUCE_MSVC
  #ifndef _CPPRTTI
   #error "You're compiling without RTTI enabled! This is needed for a lot of JUCE classes, please update your compiler settings!"
  #endif

  #ifndef _CPPUNWIND
   #error "You're compiling without exceptions enabled! This is needed for a lot of JUCE classes, please update your compiler settings!"
  #endif

  #pragma warning (push)
  #pragma warning (disable : 4100 4201 4514 4312 4995)
 #endif

 #define STRICT 1
 #define WIN32_LEAN_AND_MEAN 1
 #define _WIN32_WINNT 0x0600
 #define _UNICODE 1
 #define UNICODE 1
 #ifndef _WIN32_IE
  #define _WIN32_IE 0x0400
 #endif

 #include <windows.h>
 #include <shellapi.h>
 #include <tchar.h>
 #include <stddef.h>
 #include <ctime>
 #include <wininet.h>
 #include <nb30.h>
 #include <iphlpapi.h>
 #include <mapi.h>
 #include <float.h>
 #include <process.h>
 #include <shlobj.h>
 #include <shlwapi.h>
 #include <mmsystem.h>

 #if ! JUCE_MINGW
  #include <crtdbg.h>
  #include <comutil.h>
 #endif

 #undef PACKED

 #if JUCE_MSVC
  #pragma warning (pop)
  #pragma warning (4: 4511 4512 4100 /*4365*/)  // (enable some warnings that are turned off in VC8)
 #endif

 #if JUCE_MSVC && ! JUCE_DONT_AUTOLINK_TO_WIN32_LIBRARIES
  #pragma comment (lib, "kernel32.lib")
  #pragma comment (lib, "user32.lib")
  #pragma comment (lib, "shell32.lib")
  #pragma comment (lib, "wininet.lib")
  #pragma comment (lib, "advapi32.lib")
  #pragma comment (lib, "ws2_32.lib")
  #pragma comment (lib, "version.lib")
  #pragma comment (lib, "shlwapi.lib")
  #pragma comment (lib, "winmm.lib")

  #ifdef _NATIVE_WCHAR_T_DEFINED
   #ifdef _DEBUG
	#pragma comment (lib, "comsuppwd.lib")
   #else
	#pragma comment (lib, "comsuppw.lib")
   #endif
  #else
   #ifdef _DEBUG
	#pragma comment (lib, "comsuppd.lib")
   #else
	#pragma comment (lib, "comsupp.lib")
   #endif
  #endif
 #endif

 /* Used with DynamicLibrary to simplify importing functions

	functionName: function to import
	localFunctionName: name you want to use to actually call it (must be different)
	returnType: the return type
	object: the DynamicLibrary to use
	params: list of params (bracketed)
 */
 #define JUCE_DLL_FUNCTION(functionName, localFunctionName, returnType, object, params) \
	typedef returnType (WINAPI *type##localFunctionName) params; \
	type##localFunctionName localFunctionName = (type##localFunctionName)object.getFunction (#functionName);

#elif JUCE_LINUX
 #include <sched.h>
 #include <pthread.h>
 #include <sys/time.h>
 #include <errno.h>
 #include <sys/stat.h>
 #include <sys/dir.h>
 #include <sys/ptrace.h>
 #include <sys/vfs.h>
 #include <sys/wait.h>
 #include <sys/mman.h>
 #include <fnmatch.h>
 #include <utime.h>
 #include <pwd.h>
 #include <fcntl.h>
 #include <dlfcn.h>
 #include <netdb.h>
 #include <arpa/inet.h>
 #include <netinet/in.h>
 #include <sys/types.h>
 #include <sys/ioctl.h>
 #include <sys/socket.h>
 #include <net/if.h>
 #include <sys/sysinfo.h>
 #include <sys/file.h>
 #include <sys/prctl.h>
 #include <signal.h>

#elif JUCE_ANDROID
 #include <jni.h>
 #include <pthread.h>
 #include <sched.h>
 #include <sys/time.h>
 #include <utime.h>
 #include <errno.h>
 #include <fcntl.h>
 #include <dlfcn.h>
 #include <sys/stat.h>
 #include <sys/statfs.h>
 #include <sys/ptrace.h>
 #include <sys/sysinfo.h>
 #include <sys/mman.h>
 #include <pwd.h>
 #include <dirent.h>
 #include <fnmatch.h>
 #include <sys/wait.h>
#endif

// Need to clear various moronic redefinitions made by system headers..
#undef max
#undef min
#undef direct
#undef check

#endif   // __JUCE_BASICNATIVEHEADERS_JUCEHEADER__

/*** End of inlined file: juce_BasicNativeHeaders.h ***/


/*** Start of inlined file: juce_gui_basics.h ***/
#ifndef __JUCE_GUI_BASICS_JUCEHEADER__
#define __JUCE_GUI_BASICS_JUCEHEADER__


/*** Start of inlined file: juce_graphics.h ***/
#ifndef __JUCE_GRAPHICS_MODULE_JUCEHEADER__ // %%
#define __JUCE_GRAPHICS_MODULE_JUCEHEADER__


/*** Start of inlined file: juce_core.h ***/
#ifndef __JUCE_CORE_JUCEHEADER__
#define __JUCE_CORE_JUCEHEADER__

/** Config: JUCE_FORCE_DEBUG

	Normally, JUCE_DEBUG is set to 1 or 0 based on compiler and project settings,
	but if you define this value, you can override this to force it to be true or false.
*/
#ifndef JUCE_FORCE_DEBUG
 //#define JUCE_FORCE_DEBUG 0
#endif

/** Config: JUCE_LOG_ASSERTIONS

	If this flag is enabled, the the jassert and jassertfalse macros will always use Logger::writeToLog()
	to write a message when an assertion happens.

	Enabling it will also leave this turned on in release builds. When it's disabled,
	however, the jassert and jassertfalse macros will not be compiled in a
	release build.

	@see jassert, jassertfalse, Logger
*/
#ifndef JUCE_LOG_ASSERTIONS
 #define JUCE_LOG_ASSERTIONS 0
#endif

/** Config: JUCE_CHECK_MEMORY_LEAKS

	Enables a memory-leak check for certain objects when the app terminates. See the LeakedObjectDetector
	class and the JUCE_LEAK_DETECTOR macro for more details about enabling leak checking for specific classes.
*/
#if JUCE_DEBUG && ! defined (JUCE_CHECK_MEMORY_LEAKS)
 #define JUCE_CHECK_MEMORY_LEAKS 1
#endif

/** Config: JUCE_DONT_AUTOLINK_TO_WIN32_LIBRARIES

	In a Visual C++  build, this can be used to stop the required system libs being
	automatically added to the link stage.
*/
#ifndef JUCE_DONT_AUTOLINK_TO_WIN32_LIBRARIES
 #define JUCE_DONT_AUTOLINK_TO_WIN32_LIBRARIES 0
#endif

/*  Config: JUCE_INCLUDE_ZLIB_CODE
	This can be used to disable Juce's embedded 3rd-party zlib code.
	You might need to tweak this if you're linking to an external zlib library in your app,
	but for normal apps, this option should be left alone.

	If you disable this, you might also want to set a value for JUCE_ZLIB_INCLUDE_PATH, to
	specify the path where your zlib headers live.
*/
#ifndef JUCE_INCLUDE_ZLIB_CODE
 #define JUCE_INCLUDE_ZLIB_CODE 1
#endif

#ifndef JUCE_ZLIB_INCLUDE_PATH
 #define JUCE_ZLIB_INCLUDE_PATH <zlib.h>
#endif

/*  Config: JUCE_CATCH_UNHANDLED_EXCEPTIONS
	If enabled, this will add some exception-catching code to forward unhandled exceptions
	to your JUCEApplication::unhandledException() callback.
*/
#ifndef JUCE_CATCH_UNHANDLED_EXCEPTIONS
 //#define JUCE_CATCH_UNHANDLED_EXCEPTIONS 1
#endif

#if JUCE_MSVC
 #pragma warning (disable: 4251) // (DLL build warning, must be disabled before pushing the warning state)

 #pragma pack (push, 8) // this is set explicitly in case the app is using a different packing size.
 #pragma warning (push)
 #pragma warning (disable: 4786) // (long class name warning)
 #ifdef __INTEL_COMPILER
  #pragma warning (disable: 1125)
 #endif
#endif


/*** Start of inlined file: juce_StandardHeader.h ***/
#ifndef __JUCE_STANDARDHEADER_JUCEHEADER__
#define __JUCE_STANDARDHEADER_JUCEHEADER__

/** Current JUCE version number.

	See also SystemStats::getJUCEVersion() for a string version.
*/
#define JUCE_MAJOR_VERSION      2
#define JUCE_MINOR_VERSION      0
#define JUCE_BUILDNUMBER        18

/** Current Juce version number.

	Bits 16 to 32 = major version.
	Bits 8 to 16 = minor version.
	Bits 0 to 8 = point release.

	See also SystemStats::getJUCEVersion() for a string version.
*/
#define JUCE_VERSION            ((JUCE_MAJOR_VERSION << 16) + (JUCE_MINOR_VERSION << 8) + JUCE_BUILDNUMBER)

#ifndef DOXYGEN
 // These are old macros that are now deprecated: you should just use the juce namespace directly.
 #define JUCE_NAMESPACE juce
 #define BEGIN_JUCE_NAMESPACE    namespace juce {
 #define END_JUCE_NAMESPACE      }
#endif


/*** Start of inlined file: juce_PlatformDefs.h ***/
#ifndef __JUCE_PLATFORMDEFS_JUCEHEADER__
#define __JUCE_PLATFORMDEFS_JUCEHEADER__

/*  This file defines miscellaneous macros for debugging, assertions, etc.
*/

#ifdef JUCE_FORCE_DEBUG
 #undef JUCE_DEBUG

 #if JUCE_FORCE_DEBUG
  #define JUCE_DEBUG 1
 #endif
#endif

/** This macro defines the C calling convention used as the standard for Juce calls. */
#if JUCE_MSVC
 #define JUCE_CALLTYPE   __stdcall
 #define JUCE_CDECL      __cdecl
#else
 #define JUCE_CALLTYPE
 #define JUCE_CDECL
#endif

// Debugging and assertion macros

#if JUCE_LOG_ASSERTIONS
 #define juce_LogCurrentAssertion    juce_LogAssertion (__FILE__, __LINE__);
#elif JUCE_DEBUG
 #define juce_LogCurrentAssertion    std::cerr << "JUCE Assertion failure in " << __FILE__ << ", line " << __LINE__ << std::endl;
#else
 #define juce_LogCurrentAssertion
#endif

#if JUCE_MAC || JUCE_IOS || JUCE_LINUX || JUCE_ANDROID
  /** This will try to break into the debugger if the app is currently being debugged.
	  If called by an app that's not being debugged, the behaiour isn't defined - it may crash or not, depending
	  on the platform.
	  @see jassert()
  */
  #define juce_breakDebugger        { ::kill (0, SIGTRAP); }
#elif JUCE_USE_INTRINSICS
  #ifndef __INTEL_COMPILER
	#pragma intrinsic (__debugbreak)
  #endif
  #define juce_breakDebugger        { __debugbreak(); }
#elif JUCE_GCC
  #define juce_breakDebugger        { asm("int $3"); }
#else
  #define juce_breakDebugger        { __asm int 3 }
#endif

#if JUCE_DEBUG || DOXYGEN
  /** Writes a string to the standard error stream.
	  This is only compiled in a debug build.
	  @see Logger::outputDebugString
  */
  #define DBG(dbgtext)              { juce::String tempDbgBuf; tempDbgBuf << dbgtext; juce::Logger::outputDebugString (tempDbgBuf); }

  /** This will always cause an assertion failure.
	  It is only compiled in a debug build, (unless JUCE_LOG_ASSERTIONS is enabled for your build).
	  @see jassert
  */
  #define jassertfalse              { juce_LogCurrentAssertion; if (juce::juce_isRunningUnderDebugger()) juce_breakDebugger; }

  /** Platform-independent assertion macro.

	  This macro gets turned into a no-op when you're building with debugging turned off, so be
	  careful that the expression you pass to it doesn't perform any actions that are vital for the
	  correct behaviour of your program!
	  @see jassertfalse
  */
  #define jassert(expression)       { if (! (expression)) jassertfalse; }

#else

  // If debugging is disabled, these dummy debug and assertion macros are used..

  #define DBG(dbgtext)
  #define jassertfalse              { juce_LogCurrentAssertion }

  #if JUCE_LOG_ASSERTIONS
   #define jassert(expression)      { if (! (expression)) jassertfalse; }
  #else
   #define jassert(a)               {}
  #endif

#endif

#ifndef DOXYGEN
namespace juce
{
	template <bool b> struct JuceStaticAssert;
	template <> struct JuceStaticAssert <true> { static void dummy() {} };
}
#endif

/** A compile-time assertion macro.
	If the expression parameter is false, the macro will cause a compile error. (The actual error
	message that the compiler generates may be completely bizarre and seem to have no relation to
	the place where you put the static_assert though!)
*/
#define static_jassert(expression)      juce::JuceStaticAssert<expression>::dummy();

/** This is a shorthand macro for declaring stubs for a class's copy constructor and operator=.

	For example, instead of
	@code
	class MyClass
	{
		etc..

	private:
		MyClass (const MyClass&);
		MyClass& operator= (const MyClass&);
	};@endcode

	..you can just write:

	@code
	class MyClass
	{
		etc..

	private:
		JUCE_DECLARE_NON_COPYABLE (MyClass);
	};@endcode
*/
#define JUCE_DECLARE_NON_COPYABLE(className) \
	className (const className&);\
	className& operator= (const className&)

/** This is a shorthand way of writing both a JUCE_DECLARE_NON_COPYABLE and
	JUCE_LEAK_DETECTOR macro for a class.
*/
#define JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(className) \
	JUCE_DECLARE_NON_COPYABLE(className);\
	JUCE_LEAK_DETECTOR(className)

/** This macro can be added to class definitions to disable the use of new/delete to
	allocate the object on the heap, forcing it to only be used as a stack or member variable.
*/
#define JUCE_PREVENT_HEAP_ALLOCATION \
   private: \
	static void* operator new (size_t); \
	static void operator delete (void*);

#if ! DOXYGEN
 #define JUCE_JOIN_MACRO_HELPER(a, b) a ## b
 #define JUCE_STRINGIFY_MACRO_HELPER(a) #a
#endif

/** A good old-fashioned C macro concatenation helper.
	This combines two items (which may themselves be macros) into a single string,
	avoiding the pitfalls of the ## macro operator.
*/
#define JUCE_JOIN_MACRO(item1, item2)  JUCE_JOIN_MACRO_HELPER (item1, item2)

/** A handy C macro for stringifying any symbol, rather than just a macro parameter.
*/
#define JUCE_STRINGIFY(item)  JUCE_STRINGIFY_MACRO_HELPER (item)

#if JUCE_CATCH_UNHANDLED_EXCEPTIONS

  #define JUCE_TRY try

  #define JUCE_CATCH_ALL            catch (...) {}
  #define JUCE_CATCH_ALL_ASSERT     catch (...) { jassertfalse; }

  #if ! JUCE_MODULE_AVAILABLE_juce_gui_basics
	#define JUCE_CATCH_EXCEPTION    JUCE_CATCH_ALL
  #else
	/** Used in try-catch blocks, this macro will send exceptions to the JUCEApplication
		object so they can be logged by the application if it wants to.
	*/
	#define JUCE_CATCH_EXCEPTION \
	  catch (const std::exception& e)  \
	  { \
		  JUCEApplication::sendUnhandledException (&e, __FILE__, __LINE__); \
	  } \
	  catch (...) \
	  { \
		  JUCEApplication::sendUnhandledException (nullptr, __FILE__, __LINE__); \
	  }
  #endif

#else

  #define JUCE_TRY
  #define JUCE_CATCH_EXCEPTION
  #define JUCE_CATCH_ALL
  #define JUCE_CATCH_ALL_ASSERT

#endif

#if JUCE_DEBUG || DOXYGEN
  /** A platform-independent way of forcing an inline function.
	  Use the syntax: @code
	  forcedinline void myfunction (int x)
	  @endcode
  */
  #define forcedinline  inline
#else
  #if JUCE_MSVC
   #define forcedinline       __forceinline
  #else
   #define forcedinline       inline __attribute__((always_inline))
  #endif
#endif

#if JUCE_MSVC || DOXYGEN
  /** This can be placed before a stack or member variable declaration to tell the compiler
	  to align it to the specified number of bytes. */
  #define JUCE_ALIGN(bytes)   __declspec (align (bytes))
#else
  #define JUCE_ALIGN(bytes)   __attribute__ ((aligned (bytes)))
#endif

// Cross-compiler deprecation macros..
#if DOXYGEN || (JUCE_MSVC && ! JUCE_NO_DEPRECATION_WARNINGS)
 /** This can be used to wrap a function which has been deprecated. */
 #define JUCE_DEPRECATED(functionDef)     __declspec(deprecated) functionDef
#elif JUCE_GCC  && ! JUCE_NO_DEPRECATION_WARNINGS
 #define JUCE_DEPRECATED(functionDef)     functionDef __attribute__ ((deprecated))
#else
 #define JUCE_DEPRECATED(functionDef)     functionDef
#endif

#if JUCE_ANDROID && ! DOXYGEN
 #define JUCE_MODAL_LOOPS_PERMITTED 0
#else
 /** Some operating environments don't provide a modal loop mechanism, so this flag can be
	 used to disable any functions that try to run a modal loop. */
 #define JUCE_MODAL_LOOPS_PERMITTED 1
#endif

// Here, we'll check for C++11 compiler support, and if it's not available, define
// a few workarounds, so that we can still use some of the newer language features.
#if defined (__GXX_EXPERIMENTAL_CXX0X__) && defined (__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5))
 #define JUCE_COMPILER_SUPPORTS_NOEXCEPT 1
 #define JUCE_COMPILER_SUPPORTS_NULLPTR 1
 #define JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS 1
#endif

#if defined (__clang__) && defined (__has_feature)
 #if __has_feature (cxx_nullptr)
  #define JUCE_COMPILER_SUPPORTS_NULLPTR 1
 #endif

 #if __has_feature (cxx_noexcept)
  #define JUCE_COMPILER_SUPPORTS_NOEXCEPT 1
 #endif

 #if __has_feature (cxx_rvalue_references)
  #define JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS 1
 #endif
#endif

#if defined (_MSC_VER) && _MSC_VER >= 1600
 #define JUCE_COMPILER_SUPPORTS_NOEXCEPT 0
 #define JUCE_COMPILER_SUPPORTS_NULLPTR 1
 #define JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS 1
#endif

// Declare some fake versions of nullptr and noexcept, for older compilers:
#if ! (DOXYGEN || JUCE_COMPILER_SUPPORTS_NOEXCEPT)
 #define noexcept  throw()
#endif

#if ! (DOXYGEN || JUCE_COMPILER_SUPPORTS_NULLPTR)
 #define nullptr (0)
#endif

#endif   // __JUCE_PLATFORMDEFS_JUCEHEADER__

/*** End of inlined file: juce_PlatformDefs.h ***/

// Now we'll include any OS headers we need.. (at this point we are outside the Juce namespace).
#if JUCE_MSVC
 #pragma warning (push)
 #pragma warning (disable: 4514 4245 4100)
#endif

#include <cstdlib>
#include <cstdarg>
#include <climits>
#include <limits>
#include <cmath>
#include <cwchar>
#include <stdexcept>
#include <typeinfo>
#include <cstring>
#include <cstdio>
#include <iostream>
#include <vector>

#if JUCE_USE_INTRINSICS
 #include <intrin.h>
#endif

#if JUCE_MAC || JUCE_IOS
 #include <libkern/OSAtomic.h>
#endif

#if JUCE_LINUX
 #include <signal.h>

 #if __INTEL_COMPILER
  #if __ia64__
   #include <ia64intrin.h>
  #else
   #include <ia32intrin.h>
  #endif
 #endif
#endif

#if JUCE_MSVC && JUCE_DEBUG
 #include <crtdbg.h>
#endif

#if JUCE_MSVC
 #include <malloc.h>
 #pragma warning (pop)
#endif

#if JUCE_ANDROID
 #include <sys/atomics.h>
 #include <byteswap.h>
#endif

// DLL building settings on Windows
#if JUCE_MSVC
 #ifdef JUCE_DLL_BUILD
  #define JUCE_API __declspec (dllexport)
  #pragma warning (disable: 4251)
 #elif defined (JUCE_DLL)
  #define JUCE_API __declspec (dllimport)
  #pragma warning (disable: 4251)
 #endif
 #ifdef __INTEL_COMPILER
  #pragma warning (disable: 1125) // (virtual override warning)
 #endif
#elif defined (__GNUC__) && ((__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
 #ifdef JUCE_DLL_BUILD
  #define JUCE_API __attribute__ ((visibility("default")))
 #endif
#endif

#ifndef JUCE_API
 /** This macro is added to all juce public class declarations. */
 #define JUCE_API
#endif

/** This macro is added to all juce public function declarations. */
#define JUCE_PUBLIC_FUNCTION        JUCE_API JUCE_CALLTYPE

/** This turns on some non-essential bits of code that should prevent old code from compiling
	in cases where method signatures have changed, etc.
*/
#if (! defined (JUCE_CATCH_DEPRECATED_CODE_MISUSE)) && JUCE_DEBUG && ! DOXYGEN
 #define JUCE_CATCH_DEPRECATED_CODE_MISUSE 1
#endif

// Now include some basics that are needed by most of the Juce classes...
BEGIN_JUCE_NAMESPACE

extern JUCE_API bool JUCE_CALLTYPE juce_isRunningUnderDebugger();

#if JUCE_LOG_ASSERTIONS
 extern JUCE_API void juce_LogAssertion (const char* filename, int lineNum) noexcept;
#endif


/*** Start of inlined file: juce_Memory.h ***/
#ifndef __JUCE_MEMORY_JUCEHEADER__
#define __JUCE_MEMORY_JUCEHEADER__

#if JUCE_MSVC || DOXYGEN
 /** This is a compiler-independent way of declaring a variable as being thread-local.

	 E.g.
	 @code
	 juce_ThreadLocal int myVariable;
	 @endcode
 */
 #define juce_ThreadLocal    __declspec(thread)
#else
 #define juce_ThreadLocal    __thread
#endif

#if JUCE_MINGW
 /** This allocator is not defined in mingw gcc. */
 #define alloca              __builtin_alloca
#endif

/** Fills a block of memory with zeros. */
inline void zeromem (void* memory, size_t numBytes) noexcept        { memset (memory, 0, numBytes); }

/** Overwrites a structure or object with zeros. */
template <typename Type>
inline void zerostruct (Type& structure) noexcept                   { memset (&structure, 0, sizeof (structure)); }

/** Delete an object pointer, and sets the pointer to null.

	Remember that it's not good c++ practice to use delete directly - always try to use a ScopedPointer
	or other automatic lieftime-management system rather than resorting to deleting raw pointers!
*/
template <typename Type>
inline void deleteAndZero (Type& pointer)                           { delete pointer; pointer = nullptr; }

/** A handy function which adds a number of bytes to any type of pointer and returns the result.
	This can be useful to avoid casting pointers to a char* and back when you want to move them by
	a specific number of bytes,
*/
template <typename Type>
inline Type* addBytesToPointer (Type* pointer, int bytes) noexcept  { return (Type*) (((char*) pointer) + bytes); }

/** A handy function which returns the difference between any two pointers, in bytes.
	The address of the second pointer is subtracted from the first, and the difference in bytes is returned.
*/
template <typename Type1, typename Type2>
inline int getAddressDifference (Type1* pointer1, Type2* pointer2) noexcept  { return (int) (((const char*) pointer1) - (const char*) pointer2); }

/** If a pointer is non-null, this returns a new copy of the object that it points to, or safely returns
	nullptr if the pointer is null.
*/
template <class Type>
inline Type* createCopyIfNotNull (Type* pointer)     { return pointer != nullptr ? new Type (*pointer) : nullptr; }

/* In a Windows DLL build, we'll expose some malloc/free functions that live inside the DLL, and use these for
   allocating all the objects - that way all juce objects in the DLL and in the host will live in the same heap,
   avoiding problems when an object is created in one module and passed across to another where it is deleted.
   By piggy-backing on the JUCE_LEAK_DETECTOR macro, these allocators can be injected into most juce classes.
*/
#if JUCE_MSVC && defined (JUCE_DLL) && ! DOXYGEN
 extern JUCE_API void* juceDLL_malloc (size_t);
 extern JUCE_API void  juceDLL_free (void*);

 #define JUCE_LEAK_DETECTOR(OwnerClass)  public:\
			  static void* operator new (size_t sz)           { return juce::juceDLL_malloc ((int) sz); } \
			  static void* operator new (size_t, void* p)     { return p; } \
			  static void operator delete (void* p)           { juce::juceDLL_free (p); } \
			  static void operator delete (void*, void*)      {}
#endif

/** (Deprecated) This was a Windows-specific way of checking for object leaks - now please
	use the JUCE_LEAK_DETECTOR instead.
*/
#ifndef juce_UseDebuggingNewOperator
 #define juce_UseDebuggingNewOperator
#endif

#endif   // __JUCE_MEMORY_JUCEHEADER__

/*** End of inlined file: juce_Memory.h ***/


/*** Start of inlined file: juce_MathsFunctions.h ***/
#ifndef __JUCE_MATHSFUNCTIONS_JUCEHEADER__
#define __JUCE_MATHSFUNCTIONS_JUCEHEADER__

/*
	This file sets up some handy mathematical typdefs and functions.
*/

// Definitions for the int8, int16, int32, int64 and pointer_sized_int types.

/** A platform-independent 8-bit signed integer type. */
typedef signed char                 int8;
/** A platform-independent 8-bit unsigned integer type. */
typedef unsigned char               uint8;
/** A platform-independent 16-bit signed integer type. */
typedef signed short                int16;
/** A platform-independent 16-bit unsigned integer type. */
typedef unsigned short              uint16;
/** A platform-independent 32-bit signed integer type. */
typedef signed int                  int32;
/** A platform-independent 32-bit unsigned integer type. */
typedef unsigned int                uint32;

#if JUCE_MSVC
  /** A platform-independent 64-bit integer type. */
  typedef __int64                   int64;
  /** A platform-independent 64-bit unsigned integer type. */
  typedef unsigned __int64          uint64;
  /** A platform-independent macro for writing 64-bit literals, needed because
	  different compilers have different syntaxes for this.

	  E.g. writing literal64bit (0x1000000000) will translate to 0x1000000000LL for
	  GCC, or 0x1000000000 for MSVC.
  */
  #define literal64bit(longLiteral)     ((__int64) longLiteral)
#else
  /** A platform-independent 64-bit integer type. */
  typedef long long                 int64;
  /** A platform-independent 64-bit unsigned integer type. */
  typedef unsigned long long        uint64;
  /** A platform-independent macro for writing 64-bit literals, needed because
	  different compilers have different syntaxes for this.

	  E.g. writing literal64bit (0x1000000000) will translate to 0x1000000000LL for
	  GCC, or 0x1000000000 for MSVC.
  */
  #define literal64bit(longLiteral)     (longLiteral##LL)
#endif

#if JUCE_64BIT
  /** A signed integer type that's guaranteed to be large enough to hold a pointer without truncating it. */
  typedef int64                     pointer_sized_int;
  /** An unsigned integer type that's guaranteed to be large enough to hold a pointer without truncating it. */
  typedef uint64                    pointer_sized_uint;
#elif JUCE_MSVC
  /** A signed integer type that's guaranteed to be large enough to hold a pointer without truncating it. */
  typedef _W64 int                  pointer_sized_int;
  /** An unsigned integer type that's guaranteed to be large enough to hold a pointer without truncating it. */
  typedef _W64 unsigned int         pointer_sized_uint;
#else
  /** A signed integer type that's guaranteed to be large enough to hold a pointer without truncating it. */
  typedef int                       pointer_sized_int;
  /** An unsigned integer type that's guaranteed to be large enough to hold a pointer without truncating it. */
  typedef unsigned int              pointer_sized_uint;
#endif

#if JUCE_MSVC
  typedef pointer_sized_int ssize_t;
#endif

// Some indispensible min/max functions

/** Returns the larger of two values. */
template <typename Type>
inline Type jmax (const Type a, const Type b)                                               { return (a < b) ? b : a; }

/** Returns the larger of three values. */
template <typename Type>
inline Type jmax (const Type a, const Type b, const Type c)                                 { return (a < b) ? ((b < c) ? c : b) : ((a < c) ? c : a); }

/** Returns the larger of four values. */
template <typename Type>
inline Type jmax (const Type a, const Type b, const Type c, const Type d)                   { return jmax (a, jmax (b, c, d)); }

/** Returns the smaller of two values. */
template <typename Type>
inline Type jmin (const Type a, const Type b)                                               { return (b < a) ? b : a; }

/** Returns the smaller of three values. */
template <typename Type>
inline Type jmin (const Type a, const Type b, const Type c)                                 { return (b < a) ? ((c < b) ? c : b) : ((c < a) ? c : a); }

/** Returns the smaller of four values. */
template <typename Type>
inline Type jmin (const Type a, const Type b, const Type c, const Type d)                   { return jmin (a, jmin (b, c, d)); }

/** Scans an array of values, returning the minimum value that it contains. */
template <typename Type>
const Type findMinimum (const Type* data, int numValues)
{
	if (numValues <= 0)
		return Type();

	Type result (*data++);

	while (--numValues > 0) // (> 0 rather than >= 0 because we've already taken the first sample)
	{
		const Type& v = *data++;
		if (v < result)  result = v;
	}

	return result;
}

/** Scans an array of values, returning the maximum value that it contains. */
template <typename Type>
const Type findMaximum (const Type* values, int numValues)
{
	if (numValues <= 0)
		return Type();

	Type result (*values++);

	while (--numValues > 0) // (> 0 rather than >= 0 because we've already taken the first sample)
	{
		const Type& v = *values++;
		if (result < v)  result = v;
	}

	return result;
}

/** Scans an array of values, returning the minimum and maximum values that it contains. */
template <typename Type>
void findMinAndMax (const Type* values, int numValues, Type& lowest, Type& highest)
{
	if (numValues <= 0)
	{
		lowest = Type();
		highest = Type();
	}
	else
	{
		Type mn (*values++);
		Type mx (mn);

		while (--numValues > 0) // (> 0 rather than >= 0 because we've already taken the first sample)
		{
			const Type& v = *values++;

			if (mx < v)  mx = v;
			if (v < mn)  mn = v;
		}

		lowest = mn;
		highest = mx;
	}
}

/** Constrains a value to keep it within a given range.

	This will check that the specified value lies between the lower and upper bounds
	specified, and if not, will return the nearest value that would be in-range. Effectively,
	it's like calling jmax (lowerLimit, jmin (upperLimit, value)).

	Note that it expects that lowerLimit <= upperLimit. If this isn't true,
	the results will be unpredictable.

	@param lowerLimit           the minimum value to return
	@param upperLimit           the maximum value to return
	@param valueToConstrain     the value to try to return
	@returns    the closest value to valueToConstrain which lies between lowerLimit
				and upperLimit (inclusive)
	@see jlimit0To, jmin, jmax
*/
template <typename Type>
inline Type jlimit (const Type lowerLimit,
					const Type upperLimit,
					const Type valueToConstrain) noexcept
{
	jassert (lowerLimit <= upperLimit); // if these are in the wrong order, results are unpredictable..

	return (valueToConstrain < lowerLimit) ? lowerLimit
										   : ((upperLimit < valueToConstrain) ? upperLimit
																			  : valueToConstrain);
}

/** Returns true if a value is at least zero, and also below a specified upper limit.
	This is basically a quicker way to write:
	@code valueToTest >= 0 && valueToTest < upperLimit
	@endcode
*/
template <typename Type>
inline bool isPositiveAndBelow (Type valueToTest, Type upperLimit) noexcept
{
	jassert (Type() <= upperLimit); // makes no sense to call this if the upper limit is itself below zero..
	return Type() <= valueToTest && valueToTest < upperLimit;
}

template <>
inline bool isPositiveAndBelow (const int valueToTest, const int upperLimit) noexcept
{
	jassert (upperLimit >= 0); // makes no sense to call this if the upper limit is itself below zero..
	return static_cast <unsigned int> (valueToTest) < static_cast <unsigned int> (upperLimit);
}

/** Returns true if a value is at least zero, and also less than or equal to a specified upper limit.
	This is basically a quicker way to write:
	@code valueToTest >= 0 && valueToTest <= upperLimit
	@endcode
*/
template <typename Type>
inline bool isPositiveAndNotGreaterThan (Type valueToTest, Type upperLimit) noexcept
{
	jassert (Type() <= upperLimit); // makes no sense to call this if the upper limit is itself below zero..
	return Type() <= valueToTest && valueToTest <= upperLimit;
}

template <>
inline bool isPositiveAndNotGreaterThan (const int valueToTest, const int upperLimit) noexcept
{
	jassert (upperLimit >= 0); // makes no sense to call this if the upper limit is itself below zero..
	return static_cast <unsigned int> (valueToTest) <= static_cast <unsigned int> (upperLimit);
}

/** Handy function to swap two values. */
template <typename Type>
inline void swapVariables (Type& variable1, Type& variable2)
{
	std::swap (variable1, variable2);
}

/** Handy function for getting the number of elements in a simple const C array.
	E.g.
	@code
	static int myArray[] = { 1, 2, 3 };

	int numElements = numElementsInArray (myArray) // returns 3
	@endcode
*/
template <typename Type, int N>
inline int numElementsInArray (Type (&array)[N])
{
	(void) array; // (required to avoid a spurious warning in MS compilers)
	(void) sizeof (0[array]); // This line should cause an error if you pass an object with a user-defined subscript operator
	return N;
}

// Some useful maths functions that aren't always present with all compilers and build settings.

/** Using juce_hypot is easier than dealing with the different types of hypot function
	that are provided by the various platforms and compilers. */
template <typename Type>
inline Type juce_hypot (Type a, Type b) noexcept
{
   #if JUCE_WINDOWS
	return static_cast <Type> (_hypot (a, b));
   #else
	return static_cast <Type> (hypot (a, b));
   #endif
}

/** 64-bit abs function. */
inline int64 abs64 (const int64 n) noexcept
{
	return (n >= 0) ? n : -n;
}

/** This templated negate function will negate pointers as well as integers */
template <typename Type>
inline Type juce_negate (Type n) noexcept
{
	return sizeof (Type) == 1 ? (Type) -(signed char) n
		: (sizeof (Type) == 2 ? (Type) -(short) n
		: (sizeof (Type) == 4 ? (Type) -(int) n
		: ((Type) -(int64) n)));
}

/** This templated negate function will negate pointers as well as integers */
template <typename Type>
inline Type* juce_negate (Type* n) noexcept
{
	return (Type*) -(pointer_sized_int) n;
}

/** A predefined value for Pi, at double-precision.

	@see float_Pi
*/
const double  double_Pi  = 3.1415926535897932384626433832795;

/** A predefined value for Pi, at sngle-precision.

	@see double_Pi
*/
const float   float_Pi   = 3.14159265358979323846f;

/** The isfinite() method seems to vary between platforms, so this is a
	platform-independent function for it.
*/
template <typename FloatingPointType>
inline bool juce_isfinite (FloatingPointType value)
{
   #if JUCE_WINDOWS
	return _finite (value);
   #elif JUCE_ANDROID
	return isfinite (value);
   #else
	return std::isfinite (value);
   #endif
}

#if JUCE_MSVC
 #pragma optimize ("t", off)
 #pragma float_control (precise, on, push)
#endif

/** Fast floating-point-to-integer conversion.

	This is faster than using the normal c++ cast to convert a float to an int, and
	it will round the value to the nearest integer, rather than rounding it down
	like the normal cast does.

	Note that this routine gets its speed at the expense of some accuracy, and when
	rounding values whose floating point component is exactly 0.5, odd numbers and
	even numbers will be rounded up or down differently.
*/
template <typename FloatType>
inline int roundToInt (const FloatType value) noexcept
{
	union { int asInt[2]; double asDouble; } n;
	n.asDouble = ((double) value) + 6755399441055744.0;

   #if JUCE_BIG_ENDIAN
	return n.asInt [1];
   #else
	return n.asInt [0];
   #endif
}

#if JUCE_MSVC
 #pragma float_control (pop)
 #pragma optimize ("", on)  // resets optimisations to the project defaults
#endif

/** Fast floating-point-to-integer conversion.

	This is a slightly slower and slightly more accurate version of roundDoubleToInt(). It works
	fine for values above zero, but negative numbers are rounded the wrong way.
*/
inline int roundToIntAccurate (const double value) noexcept
{
	return roundToInt (value + 1.5e-8);
}

/** Fast floating-point-to-integer conversion.

	This is faster than using the normal c++ cast to convert a double to an int, and
	it will round the value to the nearest integer, rather than rounding it down
	like the normal cast does.

	Note that this routine gets its speed at the expense of some accuracy, and when
	rounding values whose floating point component is exactly 0.5, odd numbers and
	even numbers will be rounded up or down differently. For a more accurate conversion,
	see roundDoubleToIntAccurate().
*/
inline int roundDoubleToInt (const double value) noexcept
{
	return roundToInt (value);
}

/** Fast floating-point-to-integer conversion.

	This is faster than using the normal c++ cast to convert a float to an int, and
	it will round the value to the nearest integer, rather than rounding it down
	like the normal cast does.

	Note that this routine gets its speed at the expense of some accuracy, and when
	rounding values whose floating point component is exactly 0.5, odd numbers and
	even numbers will be rounded up or down differently.
*/
inline int roundFloatToInt (const float value) noexcept
{
	return roundToInt (value);
}

/** Returns true if the specified integer is a power-of-two.
*/
template <typename IntegerType>
bool isPowerOfTwo (IntegerType value)
{
   return (value & (value - 1)) == 0;
}

/** Returns the next power-of-two which is equal to or greater than the given integer.
*/
inline int nextPowerOfTwo (int n)
{
	--n;
	n |= (n >> 1);
	n |= (n >> 2);
	n |= (n >> 4);
	n |= (n >> 8);
	n |= (n >> 16);
	return n + 1;
}

/** Performs a modulo operation, but can cope with the dividend being negative.
	The divisor must be greater than zero.
*/
template <typename IntegerType>
int negativeAwareModulo (IntegerType dividend, const IntegerType divisor) noexcept
{
	jassert (divisor > 0);
	dividend %= divisor;
	return (dividend < 0) ? (dividend + divisor) : dividend;
}

#if (JUCE_INTEL && JUCE_32BIT) || defined (DOXYGEN)
 /** This macro can be applied to a float variable to check whether it contains a denormalised
	 value, and to normalise it if necessary.
	 On CPUs that aren't vulnerable to denormalisation problems, this will have no effect.
 */
 #define JUCE_UNDENORMALISE(x)   x += 1.0f; x -= 1.0f;
#else
 #define JUCE_UNDENORMALISE(x)
#endif

/** This namespace contains a few template classes for helping work out class type variations.
*/
namespace TypeHelpers
{
   #if JUCE_VC8_OR_EARLIER
	#define PARAMETER_TYPE(type) const type&
   #else
	/** The ParameterType struct is used to find the best type to use when passing some kind
		of object as a parameter.

		Of course, this is only likely to be useful in certain esoteric template situations.

		Because "typename TypeHelpers::ParameterType<SomeClass>::type" is a bit of a mouthful, there's
		a PARAMETER_TYPE(SomeClass) macro that you can use to get the same effect.

		E.g. "myFunction (PARAMETER_TYPE (int), PARAMETER_TYPE (MyObject))"
		would evaluate to "myfunction (int, const MyObject&)", keeping any primitive types as
		pass-by-value, but passing objects as a const reference, to avoid copying.
	*/
	template <typename Type> struct ParameterType                   { typedef const Type& type; };

   #if ! DOXYGEN
	template <typename Type> struct ParameterType <Type&>           { typedef Type& type; };
	template <typename Type> struct ParameterType <Type*>           { typedef Type* type; };
	template <>              struct ParameterType <char>            { typedef char type; };
	template <>              struct ParameterType <unsigned char>   { typedef unsigned char type; };
	template <>              struct ParameterType <short>           { typedef short type; };
	template <>              struct ParameterType <unsigned short>  { typedef unsigned short type; };
	template <>              struct ParameterType <int>             { typedef int type; };
	template <>              struct ParameterType <unsigned int>    { typedef unsigned int type; };
	template <>              struct ParameterType <long>            { typedef long type; };
	template <>              struct ParameterType <unsigned long>   { typedef unsigned long type; };
	template <>              struct ParameterType <int64>           { typedef int64 type; };
	template <>              struct ParameterType <uint64>          { typedef uint64 type; };
	template <>              struct ParameterType <bool>            { typedef bool type; };
	template <>              struct ParameterType <float>           { typedef float type; };
	template <>              struct ParameterType <double>          { typedef double type; };
   #endif

	/** A helpful macro to simplify the use of the ParameterType template.
		@see ParameterType
	*/
	#define PARAMETER_TYPE(a)    typename TypeHelpers::ParameterType<a>::type
   #endif

	/** These templates are designed to take a type, and if it's a double, they return a double
		type; for anything else, they return a float type.
	*/
	template <typename Type> struct SmallestFloatType             { typedef float  type; };
	template <>              struct SmallestFloatType <double>    { typedef double type; };
}

#endif   // __JUCE_MATHSFUNCTIONS_JUCEHEADER__

/*** End of inlined file: juce_MathsFunctions.h ***/


/*** Start of inlined file: juce_ByteOrder.h ***/
#ifndef __JUCE_BYTEORDER_JUCEHEADER__
#define __JUCE_BYTEORDER_JUCEHEADER__

/** Contains static methods for converting the byte order between different
	endiannesses.
*/
class JUCE_API  ByteOrder
{
public:

	/** Swaps the upper and lower bytes of a 16-bit integer. */
	static uint16 swap (uint16 value);

	/** Reverses the order of the 4 bytes in a 32-bit integer. */
	static uint32 swap (uint32 value);

	/** Reverses the order of the 8 bytes in a 64-bit integer. */
	static uint64 swap (uint64 value);

	/** Swaps the byte order of a 16-bit int if the CPU is big-endian */
	static uint16 swapIfBigEndian (uint16 value);

	/** Swaps the byte order of a 32-bit int if the CPU is big-endian */
	static uint32 swapIfBigEndian (uint32 value);

	/** Swaps the byte order of a 64-bit int if the CPU is big-endian */
	static uint64 swapIfBigEndian (uint64 value);

	/** Swaps the byte order of a 16-bit int if the CPU is little-endian */
	static uint16 swapIfLittleEndian (uint16 value);

	/** Swaps the byte order of a 32-bit int if the CPU is little-endian */
	static uint32 swapIfLittleEndian (uint32 value);

	/** Swaps the byte order of a 64-bit int if the CPU is little-endian */
	static uint64 swapIfLittleEndian (uint64 value);

	/** Turns 4 bytes into a little-endian integer. */
	static uint32 littleEndianInt (const void* bytes);

	/** Turns 2 bytes into a little-endian integer. */
	static uint16 littleEndianShort (const void* bytes);

	/** Turns 4 bytes into a big-endian integer. */
	static uint32 bigEndianInt (const void* bytes);

	/** Turns 2 bytes into a big-endian integer. */
	static uint16 bigEndianShort (const void* bytes);

	/** Converts 3 little-endian bytes into a signed 24-bit value (which is sign-extended to 32 bits). */
	static int littleEndian24Bit (const char* bytes);

	/** Converts 3 big-endian bytes into a signed 24-bit value (which is sign-extended to 32 bits). */
	static int bigEndian24Bit (const char* bytes);

	/** Copies a 24-bit number to 3 little-endian bytes. */
	static void littleEndian24BitToChars (int value, char* destBytes);

	/** Copies a 24-bit number to 3 big-endian bytes. */
	static void bigEndian24BitToChars (int value, char* destBytes);

	/** Returns true if the current CPU is big-endian. */
	static bool isBigEndian();

private:
	ByteOrder();

	JUCE_DECLARE_NON_COPYABLE (ByteOrder);
};

#if JUCE_USE_INTRINSICS && ! defined (__INTEL_COMPILER)
 #pragma intrinsic (_byteswap_ulong)
#endif

inline uint16 ByteOrder::swap (uint16 n)
{
   #if JUCE_USE_INTRINSICSxxx // agh - the MS compiler has an internal error when you try to use this intrinsic!
	return static_cast <uint16> (_byteswap_ushort (n));
   #else
	return static_cast <uint16> ((n << 8) | (n >> 8));
   #endif
}

inline uint32 ByteOrder::swap (uint32 n)
{
   #if JUCE_MAC || JUCE_IOS
	return OSSwapInt32 (n);
   #elif JUCE_GCC && JUCE_INTEL
	asm("bswap %%eax" : "=a"(n) : "a"(n));
	return n;
   #elif JUCE_USE_INTRINSICS
	return _byteswap_ulong (n);
   #elif JUCE_MSVC
	__asm {
		mov eax, n
		bswap eax
		mov n, eax
	}
	return n;
   #elif JUCE_ANDROID
	return bswap_32 (n);
   #else
	return (n << 24) | (n >> 24) | ((n & 0xff00) << 8) | ((n & 0xff0000) >> 8);
   #endif
}

inline uint64 ByteOrder::swap (uint64 value)
{
   #if JUCE_MAC || JUCE_IOS
	return OSSwapInt64 (value);
   #elif JUCE_USE_INTRINSICS
	return _byteswap_uint64 (value);
   #else
	return (((int64) swap ((uint32) value)) << 32) | swap ((uint32) (value >> 32));
   #endif
}

#if JUCE_LITTLE_ENDIAN
 inline uint16 ByteOrder::swapIfBigEndian (const uint16 v)                                  { return v; }
 inline uint32 ByteOrder::swapIfBigEndian (const uint32 v)                                  { return v; }
 inline uint64 ByteOrder::swapIfBigEndian (const uint64 v)                                  { return v; }
 inline uint16 ByteOrder::swapIfLittleEndian (const uint16 v)                               { return swap (v); }
 inline uint32 ByteOrder::swapIfLittleEndian (const uint32 v)                               { return swap (v); }
 inline uint64 ByteOrder::swapIfLittleEndian (const uint64 v)                               { return swap (v); }
 inline uint32 ByteOrder::littleEndianInt (const void* const bytes)                         { return *static_cast <const uint32*> (bytes); }
 inline uint16 ByteOrder::littleEndianShort (const void* const bytes)                       { return *static_cast <const uint16*> (bytes); }
 inline uint32 ByteOrder::bigEndianInt (const void* const bytes)                            { return swap (*static_cast <const uint32*> (bytes)); }
 inline uint16 ByteOrder::bigEndianShort (const void* const bytes)                          { return swap (*static_cast <const uint16*> (bytes)); }
 inline bool ByteOrder::isBigEndian()                                                       { return false; }
#else
 inline uint16 ByteOrder::swapIfBigEndian (const uint16 v)                                  { return swap (v); }
 inline uint32 ByteOrder::swapIfBigEndian (const uint32 v)                                  { return swap (v); }
 inline uint64 ByteOrder::swapIfBigEndian (const uint64 v)                                  { return swap (v); }
 inline uint16 ByteOrder::swapIfLittleEndian (const uint16 v)                               { return v; }
 inline uint32 ByteOrder::swapIfLittleEndian (const uint32 v)                               { return v; }
 inline uint64 ByteOrder::swapIfLittleEndian (const uint64 v)                               { return v; }
 inline uint32 ByteOrder::littleEndianInt (const void* const bytes)                         { return swap (*static_cast <const uint32*> (bytes)); }
 inline uint16 ByteOrder::littleEndianShort (const void* const bytes)                       { return swap (*static_cast <const uint16*> (bytes)); }
 inline uint32 ByteOrder::bigEndianInt (const void* const bytes)                            { return *static_cast <const uint32*> (bytes); }
 inline uint16 ByteOrder::bigEndianShort (const void* const bytes)                          { return *static_cast <const uint16*> (bytes); }
 inline bool ByteOrder::isBigEndian()                                                       { return true; }
#endif

inline int  ByteOrder::littleEndian24Bit (const char* const bytes)                          { return (((int) bytes[2]) << 16) | (((int) (uint8) bytes[1]) << 8) | ((int) (uint8) bytes[0]); }
inline int  ByteOrder::bigEndian24Bit (const char* const bytes)                             { return (((int) bytes[0]) << 16) | (((int) (uint8) bytes[1]) << 8) | ((int) (uint8) bytes[2]); }
inline void ByteOrder::littleEndian24BitToChars (const int value, char* const destBytes)    { destBytes[0] = (char)(value & 0xff); destBytes[1] = (char)((value >> 8) & 0xff); destBytes[2] = (char)((value >> 16) & 0xff); }
inline void ByteOrder::bigEndian24BitToChars (const int value, char* const destBytes)       { destBytes[0] = (char)((value >> 16) & 0xff); destBytes[1] = (char)((value >> 8) & 0xff); destBytes[2] = (char)(value & 0xff); }

#endif   // __JUCE_BYTEORDER_JUCEHEADER__

/*** End of inlined file: juce_ByteOrder.h ***/


/*** Start of inlined file: juce_Logger.h ***/
#ifndef __JUCE_LOGGER_JUCEHEADER__
#define __JUCE_LOGGER_JUCEHEADER__


/*** Start of inlined file: juce_String.h ***/
#ifndef __JUCE_STRING_JUCEHEADER__
#define __JUCE_STRING_JUCEHEADER__


/*** Start of inlined file: juce_CharacterFunctions.h ***/
#ifndef __JUCE_CHARACTERFUNCTIONS_JUCEHEADER__
#define __JUCE_CHARACTERFUNCTIONS_JUCEHEADER__

#if JUCE_WINDOWS && ! DOXYGEN
 #define JUCE_NATIVE_WCHAR_IS_UTF8      0
 #define JUCE_NATIVE_WCHAR_IS_UTF16     1
 #define JUCE_NATIVE_WCHAR_IS_UTF32     0
#else
 /** This macro will be set to 1 if the compiler's native wchar_t is an 8-bit type. */
 #define JUCE_NATIVE_WCHAR_IS_UTF8      0
 /** This macro will be set to 1 if the compiler's native wchar_t is a 16-bit type. */
 #define JUCE_NATIVE_WCHAR_IS_UTF16     0
 /** This macro will be set to 1 if the compiler's native wchar_t is a 32-bit type. */
 #define JUCE_NATIVE_WCHAR_IS_UTF32     1
#endif

#if JUCE_NATIVE_WCHAR_IS_UTF32 || DOXYGEN
 /** A platform-independent 32-bit unicode character type. */
 typedef wchar_t        juce_wchar;
#else
 typedef uint32         juce_wchar;
#endif

/** This macro is deprecated, but preserved for compatibility with old code. */
#define JUCE_T(stringLiteral)   (L##stringLiteral)

#if JUCE_DEFINE_T_MACRO
 /** The 'T' macro is an alternative for using the "L" prefix in front of a string literal.

	 This macro is deprecated, but available for compatibility with old code if you set
	 JUCE_DEFINE_T_MACRO = 1. The fastest, most portable and best way to write your string
	 literals is as standard char strings, using escaped utf-8 character sequences for extended
	 characters, rather than trying to store them as wide-char strings.
 */
 #define T(stringLiteral)   JUCE_T(stringLiteral)
#endif

#undef max
#undef min

/**
	A set of methods for manipulating characters and character strings.

	These are defined as wrappers around the basic C string handlers, to provide
	a clean, cross-platform layer, (because various platforms differ in the
	range of C library calls that they provide).

	@see String
*/
class JUCE_API  CharacterFunctions
{
public:

	static juce_wchar toUpperCase (juce_wchar character) noexcept;
	static juce_wchar toLowerCase (juce_wchar character) noexcept;

	static bool isUpperCase (juce_wchar character) noexcept;
	static bool isLowerCase (juce_wchar character) noexcept;

	static bool isWhitespace (char character) noexcept;
	static bool isWhitespace (juce_wchar character) noexcept;

	static bool isDigit (char character) noexcept;
	static bool isDigit (juce_wchar character) noexcept;

	static bool isLetter (char character) noexcept;
	static bool isLetter (juce_wchar character) noexcept;

	static bool isLetterOrDigit (char character) noexcept;
	static bool isLetterOrDigit (juce_wchar character) noexcept;

	/** Returns 0 to 16 for '0' to 'F", or -1 for characters that aren't a legal hex digit. */
	static int getHexDigitValue (juce_wchar digit) noexcept;

	template <typename CharPointerType>
	static double readDoubleValue (CharPointerType& text) noexcept
	{
		double result[3] = { 0 }, accumulator[2] = { 0 };
		int exponentAdjustment[2] = { 0 }, exponentAccumulator[2] = { -1, -1 };
		int exponent = 0, decPointIndex = 0, digit = 0;
		int lastDigit = 0, numSignificantDigits = 0;
		bool isNegative = false, digitsFound = false;
		const int maxSignificantDigits = 15 + 2;

		text = text.findEndOfWhitespace();
		juce_wchar c = *text;

		switch (c)
		{
			case '-':   isNegative = true; // fall-through..
			case '+':   c = *++text;
		}

		switch (c)
		{
			case 'n':
			case 'N':
				if ((text[1] == 'a' || text[1] == 'A') && (text[2] == 'n' || text[2] == 'N'))
					return std::numeric_limits<double>::quiet_NaN();
				break;

			case 'i':
			case 'I':
				if ((text[1] == 'n' || text[1] == 'N') && (text[2] == 'f' || text[2] == 'F'))
					return std::numeric_limits<double>::infinity();
				break;
		}

		for (;;)
		{
			if (text.isDigit())
			{
				lastDigit = digit;
				digit = (int) text.getAndAdvance() - '0';
				digitsFound = true;

				if (decPointIndex != 0)
					exponentAdjustment[1]++;

				if (numSignificantDigits == 0 && digit == 0)
					continue;

				if (++numSignificantDigits > maxSignificantDigits)
				{
					if (digit > 5)
						++accumulator [decPointIndex];
					else if (digit == 5 && (lastDigit & 1) != 0)
						++accumulator [decPointIndex];

					if (decPointIndex > 0)
						exponentAdjustment[1]--;
					else
						exponentAdjustment[0]++;

					while (text.isDigit())
					{
						++text;
						if (decPointIndex == 0)
							exponentAdjustment[0]++;
					}
				}
				else
				{
					const double maxAccumulatorValue = (double) ((std::numeric_limits<unsigned int>::max() - 9) / 10);
					if (accumulator [decPointIndex] > maxAccumulatorValue)
					{
						result [decPointIndex] = mulexp10 (result [decPointIndex], exponentAccumulator [decPointIndex])
													+ accumulator [decPointIndex];
						accumulator [decPointIndex] = 0;
						exponentAccumulator [decPointIndex] = 0;
					}

					accumulator [decPointIndex] = accumulator[decPointIndex] * 10 + digit;
					exponentAccumulator [decPointIndex]++;
				}
			}
			else if (decPointIndex == 0 && *text == '.')
			{
				++text;
				decPointIndex = 1;

				if (numSignificantDigits > maxSignificantDigits)
				{
					while (text.isDigit())
						++text;
					break;
				}
			}
			else
			{
				break;
			}
		}

		result[0] = mulexp10 (result[0], exponentAccumulator[0]) + accumulator[0];

		if (decPointIndex != 0)
			result[1] = mulexp10 (result[1], exponentAccumulator[1]) + accumulator[1];

		c = *text;
		if ((c == 'e' || c == 'E') && digitsFound)
		{
			bool negativeExponent = false;

			switch (*++text)
			{
				case '-':   negativeExponent = true; // fall-through..
				case '+':   ++text;
			}

			while (text.isDigit())
				exponent = (exponent * 10) + ((int) text.getAndAdvance() - '0');

			if (negativeExponent)
				exponent = -exponent;
		}

		double r = mulexp10 (result[0], exponent + exponentAdjustment[0]);
		if (decPointIndex != 0)
			r += mulexp10 (result[1], exponent - exponentAdjustment[1]);

		return isNegative ? -r : r;
	}

	template <typename CharPointerType>
	static double getDoubleValue (const CharPointerType& text) noexcept
	{
		CharPointerType t (text);
		return readDoubleValue (t);
	}

	template <typename IntType, typename CharPointerType>
	static IntType getIntValue (const CharPointerType& text) noexcept
	{
		IntType v = 0;
		CharPointerType s (text.findEndOfWhitespace());

		const bool isNeg = *s == '-';
		if (isNeg)
			++s;

		for (;;)
		{
			const juce_wchar c = s.getAndAdvance();

			if (c >= '0' && c <= '9')
				v = v * 10 + (IntType) (c - '0');
			else
				break;
		}

		return isNeg ? -v : v;
	}

	template <typename CharPointerType>
	static size_t lengthUpTo (CharPointerType text, const size_t maxCharsToCount) noexcept
	{
		size_t len = 0;

		while (len < maxCharsToCount && text.getAndAdvance() != 0)
			++len;

		return len;
	}

	template <typename CharPointerType>
	static size_t lengthUpTo (CharPointerType start, const CharPointerType& end) noexcept
	{
		size_t len = 0;

		while (start < end && start.getAndAdvance() != 0)
			++len;

		return len;
	}

	template <typename DestCharPointerType, typename SrcCharPointerType>
	static void copyAll (DestCharPointerType& dest, SrcCharPointerType src) noexcept
	{
		for (;;)
		{
			const juce_wchar c = src.getAndAdvance();

			if (c == 0)
				break;

			dest.write (c);
		}

		dest.writeNull();
	}

	template <typename DestCharPointerType, typename SrcCharPointerType>
	static int copyWithDestByteLimit (DestCharPointerType& dest, SrcCharPointerType src, int maxBytes) noexcept
	{
		typename DestCharPointerType::CharType const* const startAddress = dest.getAddress();
		maxBytes -= sizeof (typename DestCharPointerType::CharType); // (allow for a terminating null)

		for (;;)
		{
			const juce_wchar c = src.getAndAdvance();
			const int bytesNeeded = (int) DestCharPointerType::getBytesRequiredFor (c);

			maxBytes -= bytesNeeded;
			if (c == 0 || maxBytes < 0)
				break;

			dest.write (c);
		}

		dest.writeNull();

		return (int) (getAddressDifference (dest.getAddress(), startAddress) + sizeof (typename DestCharPointerType::CharType));
	}

	template <typename DestCharPointerType, typename SrcCharPointerType>
	static void copyWithCharLimit (DestCharPointerType& dest, SrcCharPointerType src, int maxChars) noexcept
	{
		while (--maxChars > 0)
		{
			const juce_wchar c = src.getAndAdvance();
			if (c == 0)
				break;

			dest.write (c);
		}

		dest.writeNull();
	}

	template <typename CharPointerType1, typename CharPointerType2>
	static int compare (CharPointerType1 s1, CharPointerType2 s2) noexcept
	{
		for (;;)
		{
			const int c1 = (int) s1.getAndAdvance();
			const int c2 = (int) s2.getAndAdvance();

			const int diff = c1 - c2;
			if (diff != 0)
				return diff < 0 ? -1 : 1;
			else if (c1 == 0)
				break;
		}

		return 0;
	}

	template <typename CharPointerType1, typename CharPointerType2>
	static int compareUpTo (CharPointerType1 s1, CharPointerType2 s2, int maxChars) noexcept
	{
		while (--maxChars >= 0)
		{
			const int c1 = (int) s1.getAndAdvance();
			const int c2 = (int) s2.getAndAdvance();

			const int diff = c1 - c2;
			if (diff != 0)
				return diff < 0 ? -1 : 1;
			else if (c1 == 0)
				break;
		}

		return 0;
	}

	template <typename CharPointerType1, typename CharPointerType2>
	static int compareIgnoreCase (CharPointerType1 s1, CharPointerType2 s2) noexcept
	{
		for (;;)
		{
			int c1 = (int) s1.toUpperCase();
			int c2 = (int) s2.toUpperCase();
			++s1;
			++s2;

			const int diff = c1 - c2;
			if (diff != 0)
				return diff < 0 ? -1 : 1;
			else if (c1 == 0)
				break;
		}

		return 0;
	}

	template <typename CharPointerType1, typename CharPointerType2>
	static int compareIgnoreCaseUpTo (CharPointerType1 s1, CharPointerType2 s2, int maxChars) noexcept
	{
		while (--maxChars >= 0)
		{
			int c1 = s1.toUpperCase();
			int c2 = s2.toUpperCase();
			++s1;
			++s2;

			const int diff = c1 - c2;
			if (diff != 0)
				return diff < 0 ? -1 : 1;
			else if (c1 == 0)
				break;
		}

		return 0;
	}

	template <typename CharPointerType1, typename CharPointerType2>
	static int indexOf (CharPointerType1 haystack, const CharPointerType2& needle) noexcept
	{
		int index = 0;
		const int needleLength = (int) needle.length();

		for (;;)
		{
			if (haystack.compareUpTo (needle, needleLength) == 0)
				return index;

			if (haystack.getAndAdvance() == 0)
				return -1;

			++index;
		}
	}

	template <typename CharPointerType1, typename CharPointerType2>
	static int indexOfIgnoreCase (CharPointerType1 haystack, const CharPointerType2& needle) noexcept
	{
		int index = 0;
		const int needleLength = (int) needle.length();

		for (;;)
		{
			if (haystack.compareIgnoreCaseUpTo (needle, needleLength) == 0)
				return index;

			if (haystack.getAndAdvance() == 0)
				return -1;

			++index;
		}
	}

	template <typename Type>
	static int indexOfChar (Type text, const juce_wchar charToFind) noexcept
	{
		int i = 0;

		while (! text.isEmpty())
		{
			if (text.getAndAdvance() == charToFind)
				return i;

			++i;
		}

		return -1;
	}

	template <typename Type>
	static int indexOfCharIgnoreCase (Type text, juce_wchar charToFind) noexcept
	{
		charToFind = CharacterFunctions::toLowerCase (charToFind);
		int i = 0;

		while (! text.isEmpty())
		{
			if (text.toLowerCase() == charToFind)
				return i;

			++text;
			++i;
		}

		return -1;
	}

	template <typename Type>
	static Type findEndOfWhitespace (const Type& text) noexcept
	{
		Type p (text);

		while (p.isWhitespace())
			++p;

		return p;
	}

	template <typename Type>
	static Type findEndOfToken (const Type& text, const Type& breakCharacters, const Type& quoteCharacters)
	{
		Type t (text);
		juce_wchar currentQuoteChar = 0;

		while (! t.isEmpty())
		{
			const juce_wchar c = t.getAndAdvance();

			if (currentQuoteChar == 0 && breakCharacters.indexOf (c) >= 0)
			{
				--t;
				break;
			}

			if (quoteCharacters.indexOf (c) >= 0)
			{
				if (currentQuoteChar == 0)
					currentQuoteChar = c;
				else if (currentQuoteChar == c)
					currentQuoteChar = 0;
			}
		}

		return t;
	}

private:
	static double mulexp10 (const double value, int exponent) noexcept;
};

#endif   // __JUCE_CHARACTERFUNCTIONS_JUCEHEADER__

/*** End of inlined file: juce_CharacterFunctions.h ***/

#ifndef JUCE_STRING_UTF_TYPE
 #define JUCE_STRING_UTF_TYPE 8
#endif

#if JUCE_MSVC
 #pragma warning (push)
 #pragma warning (disable: 4514 4996)
#endif


/*** Start of inlined file: juce_Atomic.h ***/
#ifndef __JUCE_ATOMIC_JUCEHEADER__
#define __JUCE_ATOMIC_JUCEHEADER__

/**
	Simple class to hold a primitive value and perform atomic operations on it.

	The type used must be a 32 or 64 bit primitive, like an int, pointer, etc.
	There are methods to perform most of the basic atomic operations.
*/
template <typename Type>
class Atomic
{
public:
	/** Creates a new value, initialised to zero. */
	inline Atomic() noexcept
		: value (0)
	{
	}

	/** Creates a new value, with a given initial value. */
	inline Atomic (const Type initialValue) noexcept
		: value (initialValue)
	{
	}

	/** Copies another value (atomically). */
	inline Atomic (const Atomic& other) noexcept
		: value (other.get())
	{
	}

	/** Destructor. */
	inline ~Atomic() noexcept
	{
		// This class can only be used for types which are 32 or 64 bits in size.
		static_jassert (sizeof (Type) == 4 || sizeof (Type) == 8);
	}

	/** Atomically reads and returns the current value. */
	Type get() const noexcept;

	/** Copies another value onto this one (atomically). */
	inline Atomic& operator= (const Atomic& other) noexcept         { exchange (other.get()); return *this; }

	/** Copies another value onto this one (atomically). */
	inline Atomic& operator= (const Type newValue) noexcept         { exchange (newValue); return *this; }

	/** Atomically sets the current value. */
	void set (Type newValue) noexcept                               { exchange (newValue); }

	/** Atomically sets the current value, returning the value that was replaced. */
	Type exchange (Type value) noexcept;

	/** Atomically adds a number to this value, returning the new value. */
	Type operator+= (Type amountToAdd) noexcept;

	/** Atomically subtracts a number from this value, returning the new value. */
	Type operator-= (Type amountToSubtract) noexcept;

	/** Atomically increments this value, returning the new value. */
	Type operator++() noexcept;

	/** Atomically decrements this value, returning the new value. */
	Type operator--() noexcept;

	/** Atomically compares this value with a target value, and if it is equal, sets
		this to be equal to a new value.

		This operation is the atomic equivalent of doing this:
		@code
		bool compareAndSetBool (Type newValue, Type valueToCompare)
		{
			if (get() == valueToCompare)
			{
				set (newValue);
				return true;
			}

			return false;
		}
		@endcode

		@returns true if the comparison was true and the value was replaced; false if
				 the comparison failed and the value was left unchanged.
		@see compareAndSetValue
	*/
	bool compareAndSetBool (Type newValue, Type valueToCompare) noexcept;

	/** Atomically compares this value with a target value, and if it is equal, sets
		this to be equal to a new value.

		This operation is the atomic equivalent of doing this:
		@code
		Type compareAndSetValue (Type newValue, Type valueToCompare)
		{
			Type oldValue = get();
			if (oldValue == valueToCompare)
				set (newValue);

			return oldValue;
		}
		@endcode

		@returns the old value before it was changed.
		@see compareAndSetBool
	*/
	Type compareAndSetValue (Type newValue, Type valueToCompare) noexcept;

	/** Implements a memory read/write barrier. */
	static void memoryBarrier() noexcept;

   #if JUCE_64BIT
	JUCE_ALIGN (8)
   #else
	JUCE_ALIGN (4)
   #endif

	/** The raw value that this class operates on.
		This is exposed publically in case you need to manipulate it directly
		for performance reasons.
	*/
	volatile Type value;

private:
	static inline Type castFrom32Bit (int32 value) noexcept   { return *(Type*) &value; }
	static inline Type castFrom64Bit (int64 value) noexcept   { return *(Type*) &value; }
	static inline int32 castTo32Bit (Type value) noexcept     { return *(int32*) &value; }
	static inline int64 castTo64Bit (Type value) noexcept     { return *(int64*) &value; }

	Type operator++ (int); // better to just use pre-increment with atomics..
	Type operator-- (int);
};

/*
	The following code is in the header so that the atomics can be inlined where possible...
*/
#if JUCE_IOS || (JUCE_MAC && (JUCE_PPC || defined (__clang__) || __GNUC__ < 4 || (__GNUC__ == 4 && __GNUC_MINOR__ < 2)))
  #define JUCE_ATOMICS_MAC 1        // Older OSX builds using gcc4.1 or earlier

  #if MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_5
	#define JUCE_MAC_ATOMICS_VOLATILE
  #else
	#define JUCE_MAC_ATOMICS_VOLATILE volatile
  #endif

  #if JUCE_PPC || JUCE_IOS
	// None of these atomics are available for PPC or for iPhoneOS 3.1 or earlier!!
	template <typename Type> static Type OSAtomicAdd64Barrier (Type b, JUCE_MAC_ATOMICS_VOLATILE Type* a) noexcept  { jassertfalse; return *a += b; }
	template <typename Type> static Type OSAtomicIncrement64Barrier (JUCE_MAC_ATOMICS_VOLATILE Type* a) noexcept    { jassertfalse; return ++*a; }
	template <typename Type> static Type OSAtomicDecrement64Barrier (JUCE_MAC_ATOMICS_VOLATILE Type* a) noexcept    { jassertfalse; return --*a; }
	template <typename Type> static bool OSAtomicCompareAndSwap64Barrier (Type old, Type newValue, JUCE_MAC_ATOMICS_VOLATILE Type* value) noexcept
		{ jassertfalse; if (old == *value) { *value = newValue; return true; } return false; }
	#define JUCE_64BIT_ATOMICS_UNAVAILABLE 1
  #endif

#elif JUCE_GCC
  #define JUCE_ATOMICS_GCC 1        // GCC with intrinsics

  #if JUCE_IOS || JUCE_ANDROID // (64-bit ops will compile but not link on these mobile OSes)
	#define JUCE_64BIT_ATOMICS_UNAVAILABLE 1
  #endif

#else
  #define JUCE_ATOMICS_WINDOWS 1    // Windows with intrinsics

  #if JUCE_USE_INTRINSICS
	#ifndef __INTEL_COMPILER
	 #pragma intrinsic (_InterlockedExchange, _InterlockedIncrement, _InterlockedDecrement, _InterlockedCompareExchange, \
						_InterlockedCompareExchange64, _InterlockedExchangeAdd, _ReadWriteBarrier)
	#endif
	#define juce_InterlockedExchange(a, b)              _InterlockedExchange(a, b)
	#define juce_InterlockedIncrement(a)                _InterlockedIncrement(a)
	#define juce_InterlockedDecrement(a)                _InterlockedDecrement(a)
	#define juce_InterlockedExchangeAdd(a, b)           _InterlockedExchangeAdd(a, b)
	#define juce_InterlockedCompareExchange(a, b, c)    _InterlockedCompareExchange(a, b, c)
	#define juce_InterlockedCompareExchange64(a, b, c)  _InterlockedCompareExchange64(a, b, c)
	#define juce_MemoryBarrier _ReadWriteBarrier
  #else
	long juce_InterlockedExchange (volatile long* a, long b) noexcept;
	long juce_InterlockedIncrement (volatile long* a) noexcept;
	long juce_InterlockedDecrement (volatile long* a) noexcept;
	long juce_InterlockedExchangeAdd (volatile long* a, long b) noexcept;
	long juce_InterlockedCompareExchange (volatile long* a, long b, long c) noexcept;
	__int64 juce_InterlockedCompareExchange64 (volatile __int64* a, __int64 b, __int64 c) noexcept;
	inline void juce_MemoryBarrier() noexcept  { long x = 0; juce_InterlockedIncrement (&x); }
  #endif

  #if JUCE_64BIT
	#ifndef __INTEL_COMPILER
	 #pragma intrinsic (_InterlockedExchangeAdd64, _InterlockedExchange64, _InterlockedIncrement64, _InterlockedDecrement64)
	#endif
	#define juce_InterlockedExchangeAdd64(a, b)     _InterlockedExchangeAdd64(a, b)
	#define juce_InterlockedExchange64(a, b)        _InterlockedExchange64(a, b)
	#define juce_InterlockedIncrement64(a)          _InterlockedIncrement64(a)
	#define juce_InterlockedDecrement64(a)          _InterlockedDecrement64(a)
  #else
	// None of these atomics are available in a 32-bit Windows build!!
	template <typename Type> static Type juce_InterlockedExchangeAdd64 (volatile Type* a, Type b) noexcept  { jassertfalse; Type old = *a; *a += b; return old; }
	template <typename Type> static Type juce_InterlockedExchange64 (volatile Type* a, Type b) noexcept     { jassertfalse; Type old = *a; *a = b; return old; }
	template <typename Type> static Type juce_InterlockedIncrement64 (volatile Type* a) noexcept            { jassertfalse; return ++*a; }
	template <typename Type> static Type juce_InterlockedDecrement64 (volatile Type* a) noexcept            { jassertfalse; return --*a; }
	#define JUCE_64BIT_ATOMICS_UNAVAILABLE 1
  #endif
#endif

#if JUCE_MSVC
  #pragma warning (push)
  #pragma warning (disable: 4311)  // (truncation warning)
#endif

template <typename Type>
inline Type Atomic<Type>::get() const noexcept
{
  #if JUCE_ATOMICS_MAC
	return sizeof (Type) == 4 ? castFrom32Bit ((int32) OSAtomicAdd32Barrier ((int32_t) 0, (JUCE_MAC_ATOMICS_VOLATILE int32_t*) &value))
							  : castFrom64Bit ((int64) OSAtomicAdd64Barrier ((int64_t) 0, (JUCE_MAC_ATOMICS_VOLATILE int64_t*) &value));
  #elif JUCE_ATOMICS_WINDOWS
	return sizeof (Type) == 4 ? castFrom32Bit ((int32) juce_InterlockedExchangeAdd ((volatile long*) &value, (long) 0))
							  : castFrom64Bit ((int64) juce_InterlockedExchangeAdd64 ((volatile __int64*) &value, (__int64) 0));
  #elif JUCE_ATOMICS_GCC
	return sizeof (Type) == 4 ? castFrom32Bit ((int32) __sync_add_and_fetch ((volatile int32*) &value, 0))
							  : castFrom64Bit ((int64) __sync_add_and_fetch ((volatile int64*) &value, 0));
  #endif
}

template <typename Type>
inline Type Atomic<Type>::exchange (const Type newValue) noexcept
{
  #if JUCE_ATOMICS_MAC || JUCE_ATOMICS_GCC
	Type currentVal = value;
	while (! compareAndSetBool (newValue, currentVal)) { currentVal = value; }
	return currentVal;
  #elif JUCE_ATOMICS_WINDOWS
	return sizeof (Type) == 4 ? castFrom32Bit ((int32) juce_InterlockedExchange ((volatile long*) &value, (long) castTo32Bit (newValue)))
							  : castFrom64Bit ((int64) juce_InterlockedExchange64 ((volatile __int64*) &value, (__int64) castTo64Bit (newValue)));
  #endif
}

template <typename Type>
inline Type Atomic<Type>::operator+= (const Type amountToAdd) noexcept
{
  #if JUCE_ATOMICS_MAC
	return sizeof (Type) == 4 ? (Type) OSAtomicAdd32Barrier ((int32_t) castTo32Bit (amountToAdd), (JUCE_MAC_ATOMICS_VOLATILE int32_t*) &value)
							  : (Type) OSAtomicAdd64Barrier ((int64_t) amountToAdd, (JUCE_MAC_ATOMICS_VOLATILE int64_t*) &value);
  #elif JUCE_ATOMICS_WINDOWS
	return sizeof (Type) == 4 ? (Type) (juce_InterlockedExchangeAdd ((volatile long*) &value, (long) amountToAdd) + (long) amountToAdd)
							  : (Type) (juce_InterlockedExchangeAdd64 ((volatile __int64*) &value, (__int64) amountToAdd) + (__int64) amountToAdd);
  #elif JUCE_ATOMICS_GCC
	return (Type) __sync_add_and_fetch (&value, amountToAdd);
  #endif
}

template <typename Type>
inline Type Atomic<Type>::operator-= (const Type amountToSubtract) noexcept
{
	return operator+= (juce_negate (amountToSubtract));
}

template <typename Type>
inline Type Atomic<Type>::operator++() noexcept
{
  #if JUCE_ATOMICS_MAC
	return sizeof (Type) == 4 ? (Type) OSAtomicIncrement32Barrier ((JUCE_MAC_ATOMICS_VOLATILE int32_t*) &value)
							  : (Type) OSAtomicIncrement64Barrier ((JUCE_MAC_ATOMICS_VOLATILE int64_t*) &value);
  #elif JUCE_ATOMICS_WINDOWS
	return sizeof (Type) == 4 ? (Type) juce_InterlockedIncrement ((volatile long*) &value)
							  : (Type) juce_InterlockedIncrement64 ((volatile __int64*) &value);
  #elif JUCE_ATOMICS_GCC
	return (Type) __sync_add_and_fetch (&value, 1);
  #endif
}

template <typename Type>
inline Type Atomic<Type>::operator--() noexcept
{
  #if JUCE_ATOMICS_MAC
	return sizeof (Type) == 4 ? (Type) OSAtomicDecrement32Barrier ((JUCE_MAC_ATOMICS_VOLATILE int32_t*) &value)
							  : (Type) OSAtomicDecrement64Barrier ((JUCE_MAC_ATOMICS_VOLATILE int64_t*) &value);
  #elif JUCE_ATOMICS_WINDOWS
	return sizeof (Type) == 4 ? (Type) juce_InterlockedDecrement ((volatile long*) &value)
							  : (Type) juce_InterlockedDecrement64 ((volatile __int64*) &value);
  #elif JUCE_ATOMICS_GCC
	return (Type) __sync_add_and_fetch (&value, -1);
  #endif
}

template <typename Type>
inline bool Atomic<Type>::compareAndSetBool (const Type newValue, const Type valueToCompare) noexcept
{
  #if JUCE_ATOMICS_MAC
	return sizeof (Type) == 4 ? OSAtomicCompareAndSwap32Barrier ((int32_t) castTo32Bit (valueToCompare), (int32_t) castTo32Bit (newValue), (JUCE_MAC_ATOMICS_VOLATILE int32_t*) &value)
							  : OSAtomicCompareAndSwap64Barrier ((int64_t) castTo64Bit (valueToCompare), (int64_t) castTo64Bit (newValue), (JUCE_MAC_ATOMICS_VOLATILE int64_t*) &value);
  #elif JUCE_ATOMICS_WINDOWS
	return compareAndSetValue (newValue, valueToCompare) == valueToCompare;
  #elif JUCE_ATOMICS_GCC
	return sizeof (Type) == 4 ? __sync_bool_compare_and_swap ((volatile int32*) &value, castTo32Bit (valueToCompare), castTo32Bit (newValue))
							  : __sync_bool_compare_and_swap ((volatile int64*) &value, castTo64Bit (valueToCompare), castTo64Bit (newValue));
  #endif
}

template <typename Type>
inline Type Atomic<Type>::compareAndSetValue (const Type newValue, const Type valueToCompare) noexcept
{
  #if JUCE_ATOMICS_MAC
	for (;;) // Annoying workaround for only having a bool CAS operation..
	{
		if (compareAndSetBool (newValue, valueToCompare))
			return valueToCompare;

		const Type result = value;
		if (result != valueToCompare)
			return result;
	}

  #elif JUCE_ATOMICS_WINDOWS
	return sizeof (Type) == 4 ? castFrom32Bit ((int32) juce_InterlockedCompareExchange ((volatile long*) &value, (long) castTo32Bit (newValue), (long) castTo32Bit (valueToCompare)))
							  : castFrom64Bit ((int64) juce_InterlockedCompareExchange64 ((volatile __int64*) &value, (__int64) castTo64Bit (newValue), (__int64) castTo64Bit (valueToCompare)));
  #elif JUCE_ATOMICS_GCC
	return sizeof (Type) == 4 ? castFrom32Bit ((int32) __sync_val_compare_and_swap ((volatile int32*) &value, castTo32Bit (valueToCompare), castTo32Bit (newValue)))
							  : castFrom64Bit ((int64) __sync_val_compare_and_swap ((volatile int64*) &value, castTo64Bit (valueToCompare), castTo64Bit (newValue)));
  #endif
}

template <typename Type>
inline void Atomic<Type>::memoryBarrier() noexcept
{
  #if JUCE_ATOMICS_MAC
	OSMemoryBarrier();
  #elif JUCE_ATOMICS_GCC
	__sync_synchronize();
  #elif JUCE_ATOMICS_WINDOWS
	juce_MemoryBarrier();
  #endif
}

#if JUCE_MSVC
  #pragma warning (pop)
#endif

#endif   // __JUCE_ATOMIC_JUCEHEADER__

/*** End of inlined file: juce_Atomic.h ***/


/*** Start of inlined file: juce_CharPointer_UTF8.h ***/
#ifndef __JUCE_CHARPOINTER_UTF8_JUCEHEADER__
#define __JUCE_CHARPOINTER_UTF8_JUCEHEADER__

/**
	Wraps a pointer to a null-terminated UTF-8 character string, and provides
	various methods to operate on the data.
	@see CharPointer_UTF16, CharPointer_UTF32
*/
class CharPointer_UTF8
{
public:
	typedef char CharType;

	inline explicit CharPointer_UTF8 (const CharType* const rawPointer) noexcept
		: data (const_cast <CharType*> (rawPointer))
	{
	}

	inline CharPointer_UTF8 (const CharPointer_UTF8& other) noexcept
		: data (other.data)
	{
	}

	inline CharPointer_UTF8& operator= (const CharPointer_UTF8& other) noexcept
	{
		data = other.data;
		return *this;
	}

	inline CharPointer_UTF8& operator= (const CharType* text) noexcept
	{
		data = const_cast <CharType*> (text);
		return *this;
	}

	/** This is a pointer comparison, it doesn't compare the actual text. */
	inline bool operator== (const CharPointer_UTF8& other) const noexcept { return data == other.data; }
	inline bool operator!= (const CharPointer_UTF8& other) const noexcept { return data != other.data; }
	inline bool operator<= (const CharPointer_UTF8& other) const noexcept { return data <= other.data; }
	inline bool operator<  (const CharPointer_UTF8& other) const noexcept { return data <  other.data; }
	inline bool operator>= (const CharPointer_UTF8& other) const noexcept { return data >= other.data; }
	inline bool operator>  (const CharPointer_UTF8& other) const noexcept { return data >  other.data; }

	/** Returns the address that this pointer is pointing to. */
	inline CharType* getAddress() const noexcept        { return data; }

	/** Returns the address that this pointer is pointing to. */
	inline operator const CharType*() const noexcept    { return data; }

	/** Returns true if this pointer is pointing to a null character. */
	inline bool isEmpty() const noexcept                { return *data == 0; }

	/** Returns the unicode character that this pointer is pointing to. */
	juce_wchar operator*() const noexcept
	{
		const signed char byte = (signed char) *data;

		if (byte >= 0)
			return (juce_wchar) (uint8) byte;

		uint32 n = (uint32) (uint8) byte;
		uint32 mask = 0x7f;
		uint32 bit = 0x40;
		size_t numExtraValues = 0;

		while ((n & bit) != 0 && bit > 0x10)
		{
			mask >>= 1;
			++numExtraValues;
			bit >>= 1;
		}

		n &= mask;

		for (size_t i = 1; i <= numExtraValues; ++i)
		{
			const uint8 nextByte = (uint8) data [i];

			if ((nextByte & 0xc0) != 0x80)
				break;

			n <<= 6;
			n |= (nextByte & 0x3f);
		}

		return (juce_wchar) n;
	}

	/** Moves this pointer along to the next character in the string. */
	CharPointer_UTF8& operator++() noexcept
	{
		const signed char n = (signed char) *data++;

		if (n < 0)
		{
			juce_wchar bit = 0x40;

			while ((n & bit) != 0 && bit > 0x8)
			{
				++data;
				bit >>= 1;
			}
		}

		return *this;
	}

	/** Moves this pointer back to the previous character in the string. */
	CharPointer_UTF8& operator--() noexcept
	{
		const char n = *--data;

		if ((n & 0xc0) == 0xc0)
		{
			int count = 3;

			do
			{
				--data;
			}
			while ((*data & 0xc0) == 0xc0 && --count >= 0);
		}

		return *this;
	}

	/** Returns the character that this pointer is currently pointing to, and then
		advances the pointer to point to the next character. */
	juce_wchar getAndAdvance() noexcept
	{
		const signed char byte = (signed char) *data++;

		if (byte >= 0)
			return (juce_wchar) (uint8) byte;

		uint32 n = (uint32) (uint8) byte;
		uint32 mask = 0x7f;
		uint32 bit = 0x40;
		int numExtraValues = 0;

		while ((n & bit) != 0 && bit > 0x8)
		{
			mask >>= 1;
			++numExtraValues;
			bit >>= 1;
		}

		n &= mask;

		while (--numExtraValues >= 0)
		{
			const uint32 nextByte = (uint32) (uint8) *data++;

			if ((nextByte & 0xc0) != 0x80)
				break;

			n <<= 6;
			n |= (nextByte & 0x3f);
		}

		return (juce_wchar) n;
	}

	/** Moves this pointer along to the next character in the string. */
	CharPointer_UTF8 operator++ (int) noexcept
	{
		CharPointer_UTF8 temp (*this);
		++*this;
		return temp;
	}

	/** Moves this pointer forwards by the specified number of characters. */
	void operator+= (int numToSkip) noexcept
	{
		if (numToSkip < 0)
		{
			while (++numToSkip <= 0)
				--*this;
		}
		else
		{
			while (--numToSkip >= 0)
				++*this;
		}
	}

	/** Moves this pointer backwards by the specified number of characters. */
	void operator-= (int numToSkip) noexcept
	{
		operator+= (-numToSkip);
	}

	/** Returns the character at a given character index from the start of the string. */
	juce_wchar operator[] (int characterIndex) const noexcept
	{
		CharPointer_UTF8 p (*this);
		p += characterIndex;
		return *p;
	}

	/** Returns a pointer which is moved forwards from this one by the specified number of characters. */
	CharPointer_UTF8 operator+ (int numToSkip) const noexcept
	{
		CharPointer_UTF8 p (*this);
		p += numToSkip;
		return p;
	}

	/** Returns a pointer which is moved backwards from this one by the specified number of characters. */
	CharPointer_UTF8 operator- (int numToSkip) const noexcept
	{
		CharPointer_UTF8 p (*this);
		p += -numToSkip;
		return p;
	}

	/** Returns the number of characters in this string. */
	size_t length() const noexcept
	{
		const CharType* d = data;
		size_t count = 0;

		for (;;)
		{
			const uint32 n = (uint32) (uint8) *d++;

			if ((n & 0x80) != 0)
			{
				uint32 bit = 0x40;

				while ((n & bit) != 0)
				{
					++d;
					bit >>= 1;

					if (bit == 0)
						break; // illegal utf-8 sequence
				}
			}
			else if (n == 0)
				break;

			++count;
		}

		return count;
	}

	/** Returns the number of characters in this string, or the given value, whichever is lower. */
	size_t lengthUpTo (const size_t maxCharsToCount) const noexcept
	{
		return CharacterFunctions::lengthUpTo (*this, maxCharsToCount);
	}

	/** Returns the number of characters in this string, or up to the given end pointer, whichever is lower. */
	size_t lengthUpTo (const CharPointer_UTF8& end) const noexcept
	{
		return CharacterFunctions::lengthUpTo (*this, end);
	}

	/** Returns the number of bytes that are used to represent this string.
		This includes the terminating null character.
	*/
	size_t sizeInBytes() const noexcept
	{
		jassert (data != nullptr);
		return strlen (data) + 1;
	}

	/** Returns the number of bytes that would be needed to represent the given
		unicode character in this encoding format.
	*/
	static size_t getBytesRequiredFor (const juce_wchar charToWrite) noexcept
	{
		size_t num = 1;
		const uint32 c = (uint32) charToWrite;

		if (c >= 0x80)
		{
			++num;
			if (c >= 0x800)
			{
				++num;
				if (c >= 0x10000)
					++num;
			}
		}

		return num;
	}

	/** Returns the number of bytes that would be needed to represent the given
		string in this encoding format.
		The value returned does NOT include the terminating null character.
	*/
	template <class CharPointer>
	static size_t getBytesRequiredFor (CharPointer text) noexcept
	{
		size_t count = 0;
		juce_wchar n;

		while ((n = text.getAndAdvance()) != 0)
			count += getBytesRequiredFor (n);

		return count;
	}

	/** Returns a pointer to the null character that terminates this string. */
	CharPointer_UTF8 findTerminatingNull() const noexcept
	{
		return CharPointer_UTF8 (data + strlen (data));
	}

	/** Writes a unicode character to this string, and advances this pointer to point to the next position. */
	void write (const juce_wchar charToWrite) noexcept
	{
		const uint32 c = (uint32) charToWrite;

		if (c >= 0x80)
		{
			int numExtraBytes = 1;
			if (c >= 0x800)
			{
				++numExtraBytes;
				if (c >= 0x10000)
					++numExtraBytes;
			}

			*data++ = (CharType) ((0xff << (7 - numExtraBytes)) | (c >> (numExtraBytes * 6)));

			while (--numExtraBytes >= 0)
				*data++ = (CharType) (0x80 | (0x3f & (c >> (numExtraBytes * 6))));
		}
		else
		{
			*data++ = (CharType) c;
		}
	}

	/** Writes a null character to this string (leaving the pointer's position unchanged). */
	inline void writeNull() const noexcept
	{
		*data = 0;
	}

	/** Copies a source string to this pointer, advancing this pointer as it goes. */
	template <typename CharPointer>
	void writeAll (const CharPointer& src) noexcept
	{
		CharacterFunctions::copyAll (*this, src);
	}

	/** Copies a source string to this pointer, advancing this pointer as it goes. */
	void writeAll (const CharPointer_UTF8& src) noexcept
	{
		const CharType* s = src.data;

		while ((*data = *s) != 0)
		{
			++data;
			++s;
		}
	}

	/** Copies a source string to this pointer, advancing this pointer as it goes.
		The maxDestBytes parameter specifies the maximum number of bytes that can be written
		to the destination buffer before stopping.
	*/
	template <typename CharPointer>
	int writeWithDestByteLimit (const CharPointer& src, const int maxDestBytes) noexcept
	{
		return CharacterFunctions::copyWithDestByteLimit (*this, src, maxDestBytes);
	}

	/** Copies a source string to this pointer, advancing this pointer as it goes.
		The maxChars parameter specifies the maximum number of characters that can be
		written to the destination buffer before stopping (including the terminating null).
	*/
	template <typename CharPointer>
	void writeWithCharLimit (const CharPointer& src, const int maxChars) noexcept
	{
		CharacterFunctions::copyWithCharLimit (*this, src, maxChars);
	}

	/** Compares this string with another one. */
	template <typename CharPointer>
	int compare (const CharPointer& other) const noexcept
	{
		return CharacterFunctions::compare (*this, other);
	}

	/** Compares this string with another one, up to a specified number of characters. */
	template <typename CharPointer>
	int compareUpTo (const CharPointer& other, const int maxChars) const noexcept
	{
		return CharacterFunctions::compareUpTo (*this, other, maxChars);
	}

	/** Compares this string with another one. */
	template <typename CharPointer>
	int compareIgnoreCase (const CharPointer& other) const noexcept
	{
		return CharacterFunctions::compareIgnoreCase (*this, other);
	}

	/** Compares this string with another one. */
	int compareIgnoreCase (const CharPointer_UTF8& other) const noexcept
	{
	   #if JUCE_WINDOWS
		return stricmp (data, other.data);
	   #else
		return strcasecmp (data, other.data);
	   #endif
	}

	/** Compares this string with another one, up to a specified number of characters. */
	template <typename CharPointer>
	int compareIgnoreCaseUpTo (const CharPointer& other, const int maxChars) const noexcept
	{
		return CharacterFunctions::compareIgnoreCaseUpTo (*this, other, maxChars);
	}

	/** Returns the character index of a substring, or -1 if it isn't found. */
	template <typename CharPointer>
	int indexOf (const CharPointer& stringToFind) const noexcept
	{
		return CharacterFunctions::indexOf (*this, stringToFind);
	}

	/** Returns the character index of a unicode character, or -1 if it isn't found. */
	int indexOf (const juce_wchar charToFind) const noexcept
	{
		return CharacterFunctions::indexOfChar (*this, charToFind);
	}

	/** Returns the character index of a unicode character, or -1 if it isn't found. */
	int indexOf (const juce_wchar charToFind, const bool ignoreCase) const noexcept
	{
		return ignoreCase ? CharacterFunctions::indexOfCharIgnoreCase (*this, charToFind)
						  : CharacterFunctions::indexOfChar (*this, charToFind);
	}

	/** Returns true if the first character of this string is whitespace. */
	bool isWhitespace() const noexcept      { return *data == ' ' || (*data <= 13 && *data >= 9); }
	/** Returns true if the first character of this string is a digit. */
	bool isDigit() const noexcept           { return *data >= '0' && *data <= '9'; }
	/** Returns true if the first character of this string is a letter. */
	bool isLetter() const noexcept          { return CharacterFunctions::isLetter (operator*()) != 0; }
	/** Returns true if the first character of this string is a letter or digit. */
	bool isLetterOrDigit() const noexcept   { return CharacterFunctions::isLetterOrDigit (operator*()) != 0; }
	/** Returns true if the first character of this string is upper-case. */
	bool isUpperCase() const noexcept       { return CharacterFunctions::isUpperCase (operator*()) != 0; }
	/** Returns true if the first character of this string is lower-case. */
	bool isLowerCase() const noexcept       { return CharacterFunctions::isLowerCase (operator*()) != 0; }

	/** Returns an upper-case version of the first character of this string. */
	juce_wchar toUpperCase() const noexcept { return CharacterFunctions::toUpperCase (operator*()); }
	/** Returns a lower-case version of the first character of this string. */
	juce_wchar toLowerCase() const noexcept { return CharacterFunctions::toLowerCase (operator*()); }

	/** Parses this string as a 32-bit integer. */
	int getIntValue32() const noexcept      { return atoi (data); }

	/** Parses this string as a 64-bit integer. */
	int64 getIntValue64() const noexcept
	{
	   #if JUCE_LINUX || JUCE_ANDROID
		return atoll (data);
	   #elif JUCE_WINDOWS
		return _atoi64 (data);
	   #else
		return CharacterFunctions::getIntValue <int64, CharPointer_UTF8> (*this);
	   #endif
	}

	/** Parses this string as a floating point double. */
	double getDoubleValue() const noexcept  { return CharacterFunctions::getDoubleValue (*this); }

	/** Returns the first non-whitespace character in the string. */
	CharPointer_UTF8 findEndOfWhitespace() const noexcept   { return CharacterFunctions::findEndOfWhitespace (*this); }

	/** Returns true if the given unicode character can be represented in this encoding. */
	static bool canRepresent (juce_wchar character) noexcept
	{
		return ((unsigned int) character) < (unsigned int) 0x10ffff;
	}

	/** Returns true if this data contains a valid string in this encoding. */
	static bool isValidString (const CharType* dataToTest, int maxBytesToRead)
	{
		while (--maxBytesToRead >= 0 && *dataToTest != 0)
		{
			const signed char byte = (signed char) *dataToTest;

			if (byte < 0)
			{
				uint32 n = (uint32) (uint8) byte;
				uint32 mask = 0x7f;
				uint32 bit = 0x40;
				int numExtraValues = 0;

				while ((n & bit) != 0)
				{
					if (bit <= 0x10)
						return false;

					mask >>= 1;
					++numExtraValues;
					bit >>= 1;
				}

				n &= mask;

				while (--numExtraValues >= 0)
				{
					const uint32 nextByte = (uint32) (uint8) *dataToTest++;

					if ((nextByte & 0xc0) != 0x80)
						return false;
				}
			}
		}

		return true;
	}

	/** Atomically swaps this pointer for a new value, returning the previous value. */
	CharPointer_UTF8 atomicSwap (const CharPointer_UTF8& newValue)
	{
		return CharPointer_UTF8 (reinterpret_cast <Atomic<CharType*>&> (data).exchange (newValue.data));
	}

	/** These values are the byte-order-mark (BOM) values for a UTF-8 stream. */
	enum
	{
		byteOrderMark1 = 0xef,
		byteOrderMark2 = 0xbb,
		byteOrderMark3 = 0xbf
	};

private:
	CharType* data;
};

#endif   // __JUCE_CHARPOINTER_UTF8_JUCEHEADER__

/*** End of inlined file: juce_CharPointer_UTF8.h ***/


/*** Start of inlined file: juce_CharPointer_UTF16.h ***/
#ifndef __JUCE_CHARPOINTER_UTF16_JUCEHEADER__
#define __JUCE_CHARPOINTER_UTF16_JUCEHEADER__

/**
	Wraps a pointer to a null-terminated UTF-16 character string, and provides
	various methods to operate on the data.
	@see CharPointer_UTF8, CharPointer_UTF32
*/
class CharPointer_UTF16
{
public:
   #if JUCE_NATIVE_WCHAR_IS_UTF16
	typedef wchar_t CharType;
   #else
	typedef int16 CharType;
   #endif

	inline explicit CharPointer_UTF16 (const CharType* const rawPointer) noexcept
		: data (const_cast <CharType*> (rawPointer))
	{
	}

	inline CharPointer_UTF16 (const CharPointer_UTF16& other) noexcept
		: data (other.data)
	{
	}

	inline CharPointer_UTF16& operator= (const CharPointer_UTF16& other) noexcept
	{
		data = other.data;
		return *this;
	}

	inline CharPointer_UTF16& operator= (const CharType* text) noexcept
	{
		data = const_cast <CharType*> (text);
		return *this;
	}

	/** This is a pointer comparison, it doesn't compare the actual text. */
	inline bool operator== (const CharPointer_UTF16& other) const noexcept { return data == other.data; }
	inline bool operator!= (const CharPointer_UTF16& other) const noexcept { return data != other.data; }
	inline bool operator<= (const CharPointer_UTF16& other) const noexcept { return data <= other.data; }
	inline bool operator<  (const CharPointer_UTF16& other) const noexcept { return data <  other.data; }
	inline bool operator>= (const CharPointer_UTF16& other) const noexcept { return data >= other.data; }
	inline bool operator>  (const CharPointer_UTF16& other) const noexcept { return data >  other.data; }

	/** Returns the address that this pointer is pointing to. */
	inline CharType* getAddress() const noexcept        { return data; }

	/** Returns the address that this pointer is pointing to. */
	inline operator const CharType*() const noexcept    { return data; }

	/** Returns true if this pointer is pointing to a null character. */
	inline bool isEmpty() const noexcept                { return *data == 0; }

	/** Returns the unicode character that this pointer is pointing to. */
	juce_wchar operator*() const noexcept
	{
		uint32 n = (uint32) (uint16) *data;

		if (n >= 0xd800 && n <= 0xdfff && ((uint32) (uint16) data[1]) >= 0xdc00)
			n = 0x10000 + (((n - 0xd800) << 10) | (((uint32) (uint16) data[1]) - 0xdc00));

		return (juce_wchar) n;
	}

	/** Moves this pointer along to the next character in the string. */
	CharPointer_UTF16& operator++() noexcept
	{
		const juce_wchar n = *data++;

		if (n >= 0xd800 && n <= 0xdfff && ((uint32) (uint16) *data) >= 0xdc00)
			++data;

		return *this;
	}

	/** Moves this pointer back to the previous character in the string. */
	CharPointer_UTF16& operator--() noexcept
	{
		const juce_wchar n = *--data;

		if (n >= 0xdc00 && n <= 0xdfff)
			--data;

		return *this;
	}

	/** Returns the character that this pointer is currently pointing to, and then
		advances the pointer to point to the next character. */
	juce_wchar getAndAdvance() noexcept
	{
		uint32 n = (uint32) (uint16) *data++;

		if (n >= 0xd800 && n <= 0xdfff && ((uint32) (uint16) *data) >= 0xdc00)
			n = 0x10000 + ((((n - 0xd800) << 10) | (((uint32) (uint16) *data++) - 0xdc00)));

		return (juce_wchar) n;
	}

	/** Moves this pointer along to the next character in the string. */
	CharPointer_UTF16 operator++ (int) noexcept
	{
		CharPointer_UTF16 temp (*this);
		++*this;
		return temp;
	}

	/** Moves this pointer forwards by the specified number of characters. */
	void operator+= (int numToSkip) noexcept
	{
		if (numToSkip < 0)
		{
			while (++numToSkip <= 0)
				--*this;
		}
		else
		{
			while (--numToSkip >= 0)
				++*this;
		}
	}

	/** Moves this pointer backwards by the specified number of characters. */
	void operator-= (int numToSkip) noexcept
	{
		operator+= (-numToSkip);
	}

	/** Returns the character at a given character index from the start of the string. */
	juce_wchar operator[] (const int characterIndex) const noexcept
	{
		CharPointer_UTF16 p (*this);
		p += characterIndex;
		return *p;
	}

	/** Returns a pointer which is moved forwards from this one by the specified number of characters. */
	CharPointer_UTF16 operator+ (const int numToSkip) const noexcept
	{
		CharPointer_UTF16 p (*this);
		p += numToSkip;
		return p;
	}

	/** Returns a pointer which is moved backwards from this one by the specified number of characters. */
	CharPointer_UTF16 operator- (const int numToSkip) const noexcept
	{
		CharPointer_UTF16 p (*this);
		p += -numToSkip;
		return p;
	}

	/** Writes a unicode character to this string, and advances this pointer to point to the next position. */
	void write (juce_wchar charToWrite) noexcept
	{
		if (charToWrite >= 0x10000)
		{
			charToWrite -= 0x10000;
			*data++ = (CharType) (0xd800 + (charToWrite >> 10));
			*data++ = (CharType) (0xdc00 + (charToWrite & 0x3ff));
		}
		else
		{
			*data++ = (CharType) charToWrite;
		}
	}

	/** Writes a null character to this string (leaving the pointer's position unchanged). */
	inline void writeNull() const noexcept
	{
		*data = 0;
	}

	/** Returns the number of characters in this string. */
	size_t length() const noexcept
	{
		const CharType* d = data;
		size_t count = 0;

		for (;;)
		{
			const int n = *d++;

			if (n >= 0xd800 && n <= 0xdfff)
			{
				if (*d++ == 0)
					break;
			}
			else if (n == 0)
				break;

			++count;
		}

		return count;
	}

	/** Returns the number of characters in this string, or the given value, whichever is lower. */
	size_t lengthUpTo (const size_t maxCharsToCount) const noexcept
	{
		return CharacterFunctions::lengthUpTo (*this, maxCharsToCount);
	}

	/** Returns the number of characters in this string, or up to the given end pointer, whichever is lower. */
	size_t lengthUpTo (const CharPointer_UTF16& end) const noexcept
	{
		return CharacterFunctions::lengthUpTo (*this, end);
	}

	/** Returns the number of bytes that are used to represent this string.
		This includes the terminating null character.
	*/
	size_t sizeInBytes() const noexcept
	{
		return sizeof (CharType) * (findNullIndex (data) + 1);
	}

	/** Returns the number of bytes that would be needed to represent the given
		unicode character in this encoding format.
	*/
	static size_t getBytesRequiredFor (const juce_wchar charToWrite) noexcept
	{
		return (charToWrite >= 0x10000) ? (sizeof (CharType) * 2) : sizeof (CharType);
	}

	/** Returns the number of bytes that would be needed to represent the given
		string in this encoding format.
		The value returned does NOT include the terminating null character.
	*/
	template <class CharPointer>
	static size_t getBytesRequiredFor (CharPointer text) noexcept
	{
		size_t count = 0;
		juce_wchar n;

		while ((n = text.getAndAdvance()) != 0)
			count += getBytesRequiredFor (n);

		return count;
	}

	/** Returns a pointer to the null character that terminates this string. */
	CharPointer_UTF16 findTerminatingNull() const noexcept
	{
		const CharType* t = data;

		while (*t != 0)
			++t;

		return CharPointer_UTF16 (t);
	}

	/** Copies a source string to this pointer, advancing this pointer as it goes. */
	template <typename CharPointer>
	void writeAll (const CharPointer& src) noexcept
	{
		CharacterFunctions::copyAll (*this, src);
	}

	/** Copies a source string to this pointer, advancing this pointer as it goes. */
	void writeAll (const CharPointer_UTF16& src) noexcept
	{
		const CharType* s = src.data;

		while ((*data = *s) != 0)
		{
			++data;
			++s;
		}
	}

	/** Copies a source string to this pointer, advancing this pointer as it goes.
		The maxDestBytes parameter specifies the maximum number of bytes that can be written
		to the destination buffer before stopping.
	*/
	template <typename CharPointer>
	int writeWithDestByteLimit (const CharPointer& src, const int maxDestBytes) noexcept
	{
		return CharacterFunctions::copyWithDestByteLimit (*this, src, maxDestBytes);
	}

	/** Copies a source string to this pointer, advancing this pointer as it goes.
		The maxChars parameter specifies the maximum number of characters that can be
		written to the destination buffer before stopping (including the terminating null).
	*/
	template <typename CharPointer>
	void writeWithCharLimit (const CharPointer& src, const int maxChars) noexcept
	{
		CharacterFunctions::copyWithCharLimit (*this, src, maxChars);
	}

	/** Compares this string with another one. */
	template <typename CharPointer>
	int compare (const CharPointer& other) const noexcept
	{
		return CharacterFunctions::compare (*this, other);
	}

	/** Compares this string with another one, up to a specified number of characters. */
	template <typename CharPointer>
	int compareUpTo (const CharPointer& other, const int maxChars) const noexcept
	{
		return CharacterFunctions::compareUpTo (*this, other, maxChars);
	}

	/** Compares this string with another one. */
	template <typename CharPointer>
	int compareIgnoreCase (const CharPointer& other) const noexcept
	{
		return CharacterFunctions::compareIgnoreCase (*this, other);
	}

	/** Compares this string with another one, up to a specified number of characters. */
	template <typename CharPointer>
	int compareIgnoreCaseUpTo (const CharPointer& other, const int maxChars) const noexcept
	{
		return CharacterFunctions::compareIgnoreCaseUpTo (*this, other, maxChars);
	}

   #if JUCE_WINDOWS && ! DOXYGEN
	int compareIgnoreCase (const CharPointer_UTF16& other) const noexcept
	{
		return _wcsicmp (data, other.data);
	}

	int compareIgnoreCaseUpTo (const CharPointer_UTF16& other, int maxChars) const noexcept
	{
		return _wcsnicmp (data, other.data, (size_t) maxChars);
	}

	int indexOf (const CharPointer_UTF16& stringToFind) const noexcept
	{
		const CharType* const t = wcsstr (data, stringToFind.getAddress());
		return t == nullptr ? -1 : (int) (t - data);
	}
   #endif

	/** Returns the character index of a substring, or -1 if it isn't found. */
	template <typename CharPointer>
	int indexOf (const CharPointer& stringToFind) const noexcept
	{
		return CharacterFunctions::indexOf (*this, stringToFind);
	}

	/** Returns the character index of a unicode character, or -1 if it isn't found. */
	int indexOf (const juce_wchar charToFind) const noexcept
	{
		return CharacterFunctions::indexOfChar (*this, charToFind);
	}

	/** Returns the character index of a unicode character, or -1 if it isn't found. */
	int indexOf (const juce_wchar charToFind, const bool ignoreCase) const noexcept
	{
		return ignoreCase ? CharacterFunctions::indexOfCharIgnoreCase (*this, charToFind)
						  : CharacterFunctions::indexOfChar (*this, charToFind);
	}

	/** Returns true if the first character of this string is whitespace. */
	bool isWhitespace() const noexcept      { return CharacterFunctions::isWhitespace (operator*()) != 0; }
	/** Returns true if the first character of this string is a digit. */
	bool isDigit() const noexcept           { return CharacterFunctions::isDigit (operator*()) != 0; }
	/** Returns true if the first character of this string is a letter. */
	bool isLetter() const noexcept          { return CharacterFunctions::isLetter (operator*()) != 0; }
	/** Returns true if the first character of this string is a letter or digit. */
	bool isLetterOrDigit() const noexcept   { return CharacterFunctions::isLetterOrDigit (operator*()) != 0; }
	/** Returns true if the first character of this string is upper-case. */
	bool isUpperCase() const noexcept       { return CharacterFunctions::isUpperCase (operator*()) != 0; }
	/** Returns true if the first character of this string is lower-case. */
	bool isLowerCase() const noexcept       { return CharacterFunctions::isLowerCase (operator*()) != 0; }

	/** Returns an upper-case version of the first character of this string. */
	juce_wchar toUpperCase() const noexcept { return CharacterFunctions::toUpperCase (operator*()); }
	/** Returns a lower-case version of the first character of this string. */
	juce_wchar toLowerCase() const noexcept { return CharacterFunctions::toLowerCase (operator*()); }

	/** Parses this string as a 32-bit integer. */
	int getIntValue32() const noexcept
	{
	   #if JUCE_WINDOWS
		return _wtoi (data);
	   #else
		return CharacterFunctions::getIntValue <int, CharPointer_UTF16> (*this);
	   #endif
	}

	/** Parses this string as a 64-bit integer. */
	int64 getIntValue64() const noexcept
	{
	   #if JUCE_WINDOWS
		return _wtoi64 (data);
	   #else
		return CharacterFunctions::getIntValue <int64, CharPointer_UTF16> (*this);
	   #endif
	}

	/** Parses this string as a floating point double. */
	double getDoubleValue() const noexcept  { return CharacterFunctions::getDoubleValue (*this); }

	/** Returns the first non-whitespace character in the string. */
	CharPointer_UTF16 findEndOfWhitespace() const noexcept   { return CharacterFunctions::findEndOfWhitespace (*this); }

	/** Returns true if the given unicode character can be represented in this encoding. */
	static bool canRepresent (juce_wchar character) noexcept
	{
		return ((unsigned int) character) < (unsigned int) 0x10ffff
				 && (((unsigned int) character) < 0xd800 || ((unsigned int) character) > 0xdfff);
	}

	/** Returns true if this data contains a valid string in this encoding. */
	static bool isValidString (const CharType* dataToTest, int maxBytesToRead)
	{
		maxBytesToRead /= sizeof (CharType);

		while (--maxBytesToRead >= 0 && *dataToTest != 0)
		{
			const uint32 n = (uint32) (uint16) *dataToTest++;

			if (n >= 0xd800)
			{
				if (n > 0x10ffff)
					return false;

				if (n <= 0xdfff)
				{
					if (n > 0xdc00)
						return false;

					const uint32 nextChar = (uint32) (uint16) *dataToTest++;

					if (nextChar < 0xdc00 || nextChar > 0xdfff)
						return false;
				}
			}
		}

		return true;
	}

	/** Atomically swaps this pointer for a new value, returning the previous value. */
	CharPointer_UTF16 atomicSwap (const CharPointer_UTF16& newValue)
	{
		return CharPointer_UTF16 (reinterpret_cast <Atomic<CharType*>&> (data).exchange (newValue.data));
	}

	/** These values are the byte-order-mark (BOM) values for a UTF-16 stream. */
	enum
	{
		byteOrderMarkBE1 = 0xfe,
		byteOrderMarkBE2 = 0xff,
		byteOrderMarkLE1 = 0xff,
		byteOrderMarkLE2 = 0xfe
	};

private:
	CharType* data;

	static int findNullIndex (const CharType* const t) noexcept
	{
		int n = 0;

		while (t[n] != 0)
			++n;

		return n;
	}
};

#endif   // __JUCE_CHARPOINTER_UTF16_JUCEHEADER__

/*** End of inlined file: juce_CharPointer_UTF16.h ***/


/*** Start of inlined file: juce_CharPointer_UTF32.h ***/
#ifndef __JUCE_CHARPOINTER_UTF32_JUCEHEADER__
#define __JUCE_CHARPOINTER_UTF32_JUCEHEADER__

/**
	Wraps a pointer to a null-terminated UTF-32 character string, and provides
	various methods to operate on the data.
	@see CharPointer_UTF8, CharPointer_UTF16
*/
class CharPointer_UTF32
{
public:
	typedef juce_wchar CharType;

	inline explicit CharPointer_UTF32 (const CharType* const rawPointer) noexcept
		: data (const_cast <CharType*> (rawPointer))
	{
	}

	inline CharPointer_UTF32 (const CharPointer_UTF32& other) noexcept
		: data (other.data)
	{
	}

	inline CharPointer_UTF32& operator= (const CharPointer_UTF32& other) noexcept
	{
		data = other.data;
		return *this;
	}

	inline CharPointer_UTF32& operator= (const CharType* text) noexcept
	{
		data = const_cast <CharType*> (text);
		return *this;
	}

	/** This is a pointer comparison, it doesn't compare the actual text. */
	inline bool operator== (const CharPointer_UTF32& other) const noexcept { return data == other.data; }
	inline bool operator!= (const CharPointer_UTF32& other) const noexcept { return data != other.data; }
	inline bool operator<= (const CharPointer_UTF32& other) const noexcept { return data <= other.data; }
	inline bool operator<  (const CharPointer_UTF32& other) const noexcept { return data <  other.data; }
	inline bool operator>= (const CharPointer_UTF32& other) const noexcept { return data >= other.data; }
	inline bool operator>  (const CharPointer_UTF32& other) const noexcept { return data >  other.data; }

	/** Returns the address that this pointer is pointing to. */
	inline CharType* getAddress() const noexcept        { return data; }

	/** Returns the address that this pointer is pointing to. */
	inline operator const CharType*() const noexcept    { return data; }

	/** Returns true if this pointer is pointing to a null character. */
	inline bool isEmpty() const noexcept                { return *data == 0; }

	/** Returns the unicode character that this pointer is pointing to. */
	inline juce_wchar operator*() const noexcept        { return *data; }

	/** Moves this pointer along to the next character in the string. */
	inline CharPointer_UTF32& operator++() noexcept
	{
		++data;
		return *this;
	}

	/** Moves this pointer to the previous character in the string. */
	inline CharPointer_UTF32& operator--() noexcept
	{
		--data;
		return *this;
	}

	/** Returns the character that this pointer is currently pointing to, and then
		advances the pointer to point to the next character. */
	inline juce_wchar getAndAdvance() noexcept  { return *data++; }

	/** Moves this pointer along to the next character in the string. */
	CharPointer_UTF32 operator++ (int) noexcept
	{
		CharPointer_UTF32 temp (*this);
		++data;
		return temp;
	}

	/** Moves this pointer forwards by the specified number of characters. */
	inline void operator+= (const int numToSkip) noexcept
	{
		data += numToSkip;
	}

	inline void operator-= (const int numToSkip) noexcept
	{
		data -= numToSkip;
	}

	/** Returns the character at a given character index from the start of the string. */
	inline juce_wchar& operator[] (const int characterIndex) const noexcept
	{
		return data [characterIndex];
	}

	/** Returns a pointer which is moved forwards from this one by the specified number of characters. */
	CharPointer_UTF32 operator+ (const int numToSkip) const noexcept
	{
		return CharPointer_UTF32 (data + numToSkip);
	}

	/** Returns a pointer which is moved backwards from this one by the specified number of characters. */
	CharPointer_UTF32 operator- (const int numToSkip) const noexcept
	{
		return CharPointer_UTF32 (data - numToSkip);
	}

	/** Writes a unicode character to this string, and advances this pointer to point to the next position. */
	inline void write (const juce_wchar charToWrite) noexcept
	{
		*data++ = charToWrite;
	}

	inline void replaceChar (const juce_wchar newChar) noexcept
	{
		*data = newChar;
	}

	/** Writes a null character to this string (leaving the pointer's position unchanged). */
	inline void writeNull() const noexcept
	{
		*data = 0;
	}

	/** Returns the number of characters in this string. */
	size_t length() const noexcept
	{
	   #if JUCE_NATIVE_WCHAR_IS_UTF32 && ! JUCE_ANDROID
		return wcslen (data);
	   #else
		size_t n = 0;
		while (data[n] != 0)
			++n;
		return n;
	   #endif
	}

	/** Returns the number of characters in this string, or the given value, whichever is lower. */
	size_t lengthUpTo (const size_t maxCharsToCount) const noexcept
	{
		return CharacterFunctions::lengthUpTo (*this, maxCharsToCount);
	}

	/** Returns the number of characters in this string, or up to the given end pointer, whichever is lower. */
	size_t lengthUpTo (const CharPointer_UTF32& end) const noexcept
	{
		return CharacterFunctions::lengthUpTo (*this, end);
	}

	/** Returns the number of bytes that are used to represent this string.
		This includes the terminating null character.
	*/
	size_t sizeInBytes() const noexcept
	{
		return sizeof (CharType) * (length() + 1);
	}

	/** Returns the number of bytes that would be needed to represent the given
		unicode character in this encoding format.
	*/
	static inline size_t getBytesRequiredFor (const juce_wchar) noexcept
	{
		return sizeof (CharType);
	}

	/** Returns the number of bytes that would be needed to represent the given
		string in this encoding format.
		The value returned does NOT include the terminating null character.
	*/
	template <class CharPointer>
	static size_t getBytesRequiredFor (const CharPointer& text) noexcept
	{
		return sizeof (CharType) * text.length();
	}

	/** Returns a pointer to the null character that terminates this string. */
	CharPointer_UTF32 findTerminatingNull() const noexcept
	{
		return CharPointer_UTF32 (data + length());
	}

	/** Copies a source string to this pointer, advancing this pointer as it goes. */
	template <typename CharPointer>
	void writeAll (const CharPointer& src) noexcept
	{
		CharacterFunctions::copyAll (*this, src);
	}

	/** Copies a source string to this pointer, advancing this pointer as it goes. */
	void writeAll (const CharPointer_UTF32& src) noexcept
	{
		const CharType* s = src.data;

		while ((*data = *s) != 0)
		{
			++data;
			++s;
		}
	}

	/** Copies a source string to this pointer, advancing this pointer as it goes.
		The maxDestBytes parameter specifies the maximum number of bytes that can be written
		to the destination buffer before stopping.
	*/
	template <typename CharPointer>
	int writeWithDestByteLimit (const CharPointer& src, const int maxDestBytes) noexcept
	{
		return CharacterFunctions::copyWithDestByteLimit (*this, src, maxDestBytes);
	}

	/** Copies a source string to this pointer, advancing this pointer as it goes.
		The maxChars parameter specifies the maximum number of characters that can be
		written to the destination buffer before stopping (including the terminating null).
	*/
	template <typename CharPointer>
	void writeWithCharLimit (const CharPointer& src, const int maxChars) noexcept
	{
		CharacterFunctions::copyWithCharLimit (*this, src, maxChars);
	}

	/** Compares this string with another one. */
	template <typename CharPointer>
	int compare (const CharPointer& other) const noexcept
	{
		return CharacterFunctions::compare (*this, other);
	}

   #if JUCE_NATIVE_WCHAR_IS_UTF32 && ! JUCE_ANDROID
	/** Compares this string with another one. */
	int compare (const CharPointer_UTF32& other) const noexcept
	{
		return wcscmp (data, other.data);
	}
   #endif

	/** Compares this string with another one, up to a specified number of characters. */
	template <typename CharPointer>
	int compareUpTo (const CharPointer& other, const int maxChars) const noexcept
	{
		return CharacterFunctions::compareUpTo (*this, other, maxChars);
	}

	/** Compares this string with another one. */
	template <typename CharPointer>
	int compareIgnoreCase (const CharPointer& other) const
	{
		return CharacterFunctions::compareIgnoreCase (*this, other);
	}

	/** Compares this string with another one, up to a specified number of characters. */
	template <typename CharPointer>
	int compareIgnoreCaseUpTo (const CharPointer& other, const int maxChars) const noexcept
	{
		return CharacterFunctions::compareIgnoreCaseUpTo (*this, other, maxChars);
	}

	/** Returns the character index of a substring, or -1 if it isn't found. */
	template <typename CharPointer>
	int indexOf (const CharPointer& stringToFind) const noexcept
	{
		return CharacterFunctions::indexOf (*this, stringToFind);
	}

	/** Returns the character index of a unicode character, or -1 if it isn't found. */
	int indexOf (const juce_wchar charToFind) const noexcept
	{
		int i = 0;

		while (data[i] != 0)
		{
			if (data[i] == charToFind)
				return i;

			++i;
		}

		return -1;
	}

	/** Returns the character index of a unicode character, or -1 if it isn't found. */
	int indexOf (const juce_wchar charToFind, const bool ignoreCase) const noexcept
	{
		return ignoreCase ? CharacterFunctions::indexOfCharIgnoreCase (*this, charToFind)
						  : CharacterFunctions::indexOfChar (*this, charToFind);
	}

	/** Returns true if the first character of this string is whitespace. */
	bool isWhitespace() const               { return CharacterFunctions::isWhitespace (*data) != 0; }
	/** Returns true if the first character of this string is a digit. */
	bool isDigit() const                    { return CharacterFunctions::isDigit (*data) != 0; }
	/** Returns true if the first character of this string is a letter. */
	bool isLetter() const                   { return CharacterFunctions::isLetter (*data) != 0; }
	/** Returns true if the first character of this string is a letter or digit. */
	bool isLetterOrDigit() const            { return CharacterFunctions::isLetterOrDigit (*data) != 0; }
	/** Returns true if the first character of this string is upper-case. */
	bool isUpperCase() const                { return CharacterFunctions::isUpperCase (*data) != 0; }
	/** Returns true if the first character of this string is lower-case. */
	bool isLowerCase() const                { return CharacterFunctions::isLowerCase (*data) != 0; }

	/** Returns an upper-case version of the first character of this string. */
	juce_wchar toUpperCase() const noexcept { return CharacterFunctions::toUpperCase (*data); }
	/** Returns a lower-case version of the first character of this string. */
	juce_wchar toLowerCase() const noexcept { return CharacterFunctions::toLowerCase (*data); }

	/** Parses this string as a 32-bit integer. */
	int getIntValue32() const noexcept      { return CharacterFunctions::getIntValue <int, CharPointer_UTF32> (*this); }
	/** Parses this string as a 64-bit integer. */
	int64 getIntValue64() const noexcept    { return CharacterFunctions::getIntValue <int64, CharPointer_UTF32> (*this); }

	/** Parses this string as a floating point double. */
	double getDoubleValue() const noexcept  { return CharacterFunctions::getDoubleValue (*this); }

	/** Returns the first non-whitespace character in the string. */
	CharPointer_UTF32 findEndOfWhitespace() const noexcept   { return CharacterFunctions::findEndOfWhitespace (*this); }

	/** Returns true if the given unicode character can be represented in this encoding. */
	static bool canRepresent (juce_wchar character) noexcept
	{
		return ((unsigned int) character) < (unsigned int) 0x10ffff;
	}

	/** Returns true if this data contains a valid string in this encoding. */
	static bool isValidString (const CharType* dataToTest, int maxBytesToRead)
	{
		maxBytesToRead /= sizeof (CharType);

		while (--maxBytesToRead >= 0 && *dataToTest != 0)
			if (! canRepresent (*dataToTest++))
				return false;

		return true;
	}

	/** Atomically swaps this pointer for a new value, returning the previous value. */
	CharPointer_UTF32 atomicSwap (const CharPointer_UTF32& newValue)
	{
		return CharPointer_UTF32 (reinterpret_cast <Atomic<CharType*>&> (data).exchange (newValue.data));
	}

private:
	CharType* data;
};

#endif   // __JUCE_CHARPOINTER_UTF32_JUCEHEADER__

/*** End of inlined file: juce_CharPointer_UTF32.h ***/


/*** Start of inlined file: juce_CharPointer_ASCII.h ***/
#ifndef __JUCE_CHARPOINTER_ASCII_JUCEHEADER__
#define __JUCE_CHARPOINTER_ASCII_JUCEHEADER__

/**
	Wraps a pointer to a null-terminated ASCII character string, and provides
	various methods to operate on the data.

	A valid ASCII string is assumed to not contain any characters above 127.

	@see CharPointer_UTF8, CharPointer_UTF16, CharPointer_UTF32
*/
class CharPointer_ASCII
{
public:
	typedef char CharType;

	inline explicit CharPointer_ASCII (const CharType* const rawPointer) noexcept
		: data (const_cast <CharType*> (rawPointer))
	{
	}

	inline CharPointer_ASCII (const CharPointer_ASCII& other) noexcept
		: data (other.data)
	{
	}

	inline CharPointer_ASCII& operator= (const CharPointer_ASCII& other) noexcept
	{
		data = other.data;
		return *this;
	}

	inline CharPointer_ASCII& operator= (const CharType* text) noexcept
	{
		data = const_cast <CharType*> (text);
		return *this;
	}

	/** This is a pointer comparison, it doesn't compare the actual text. */
	inline bool operator== (const CharPointer_ASCII& other) const noexcept { return data == other.data; }
	inline bool operator!= (const CharPointer_ASCII& other) const noexcept { return data != other.data; }
	inline bool operator<= (const CharPointer_ASCII& other) const noexcept { return data <= other.data; }
	inline bool operator<  (const CharPointer_ASCII& other) const noexcept { return data <  other.data; }
	inline bool operator>= (const CharPointer_ASCII& other) const noexcept { return data >= other.data; }
	inline bool operator>  (const CharPointer_ASCII& other) const noexcept { return data >  other.data; }

	/** Returns the address that this pointer is pointing to. */
	inline CharType* getAddress() const noexcept        { return data; }

	/** Returns the address that this pointer is pointing to. */
	inline operator const CharType*() const noexcept    { return data; }

	/** Returns true if this pointer is pointing to a null character. */
	inline bool isEmpty() const noexcept                { return *data == 0; }

	/** Returns the unicode character that this pointer is pointing to. */
	inline juce_wchar operator*() const noexcept        { return (juce_wchar) (uint8) *data; }

	/** Moves this pointer along to the next character in the string. */
	inline CharPointer_ASCII& operator++() noexcept
	{
		++data;
		return *this;
	}

	/** Moves this pointer to the previous character in the string. */
	inline CharPointer_ASCII& operator--() noexcept
	{
		--data;
		return *this;
	}

	/** Returns the character that this pointer is currently pointing to, and then
		advances the pointer to point to the next character. */
	inline juce_wchar getAndAdvance() noexcept  { return (juce_wchar) (uint8) *data++; }

	/** Moves this pointer along to the next character in the string. */
	CharPointer_ASCII operator++ (int) noexcept
	{
		CharPointer_ASCII temp (*this);
		++data;
		return temp;
	}

	/** Moves this pointer forwards by the specified number of characters. */
	inline void operator+= (const int numToSkip) noexcept
	{
		data += numToSkip;
	}

	inline void operator-= (const int numToSkip) noexcept
	{
		data -= numToSkip;
	}

	/** Returns the character at a given character index from the start of the string. */
	inline juce_wchar operator[] (const int characterIndex) const noexcept
	{
		return (juce_wchar) (unsigned char) data [characterIndex];
	}

	/** Returns a pointer which is moved forwards from this one by the specified number of characters. */
	CharPointer_ASCII operator+ (const int numToSkip) const noexcept
	{
		return CharPointer_ASCII (data + numToSkip);
	}

	/** Returns a pointer which is moved backwards from this one by the specified number of characters. */
	CharPointer_ASCII operator- (const int numToSkip) const noexcept
	{
		return CharPointer_ASCII (data - numToSkip);
	}

	/** Writes a unicode character to this string, and advances this pointer to point to the next position. */
	inline void write (const juce_wchar charToWrite) noexcept
	{
		*data++ = (char) charToWrite;
	}

	inline void replaceChar (const juce_wchar newChar) noexcept
	{
		*data = (char) newChar;
	}

	/** Writes a null character to this string (leaving the pointer's position unchanged). */
	inline void writeNull() const noexcept
	{
		*data = 0;
	}

	/** Returns the number of characters in this string. */
	size_t length() const noexcept
	{
		return (size_t) strlen (data);
	}

	/** Returns the number of characters in this string, or the given value, whichever is lower. */
	size_t lengthUpTo (const size_t maxCharsToCount) const noexcept
	{
		return CharacterFunctions::lengthUpTo (*this, maxCharsToCount);
	}

	/** Returns the number of characters in this string, or up to the given end pointer, whichever is lower. */
	size_t lengthUpTo (const CharPointer_ASCII& end) const noexcept
	{
		return CharacterFunctions::lengthUpTo (*this, end);
	}

	/** Returns the number of bytes that are used to represent this string.
		This includes the terminating null character.
	*/
	size_t sizeInBytes() const noexcept
	{
		return length() + 1;
	}

	/** Returns the number of bytes that would be needed to represent the given
		unicode character in this encoding format.
	*/
	static inline size_t getBytesRequiredFor (const juce_wchar) noexcept
	{
		return 1;
	}

	/** Returns the number of bytes that would be needed to represent the given
		string in this encoding format.
		The value returned does NOT include the terminating null character.
	*/
	template <class CharPointer>
	static size_t getBytesRequiredFor (const CharPointer& text) noexcept
	{
		return text.length();
	}

	/** Returns a pointer to the null character that terminates this string. */
	CharPointer_ASCII findTerminatingNull() const noexcept
	{
		return CharPointer_ASCII (data + length());
	}

	/** Copies a source string to this pointer, advancing this pointer as it goes. */
	template <typename CharPointer>
	void writeAll (const CharPointer& src) noexcept
	{
		CharacterFunctions::copyAll (*this, src);
	}

	/** Copies a source string to this pointer, advancing this pointer as it goes. */
	void writeAll (const CharPointer_ASCII& src) noexcept
	{
		strcpy (data, src.data);
	}

	/** Copies a source string to this pointer, advancing this pointer as it goes.
		The maxDestBytes parameter specifies the maximum number of bytes that can be written
		to the destination buffer before stopping.
	*/
	template <typename CharPointer>
	int writeWithDestByteLimit (const CharPointer& src, const int maxDestBytes) noexcept
	{
		return CharacterFunctions::copyWithDestByteLimit (*this, src, maxDestBytes);
	}

	/** Copies a source string to this pointer, advancing this pointer as it goes.
		The maxChars parameter specifies the maximum number of characters that can be
		written to the destination buffer before stopping (including the terminating null).
	*/
	template <typename CharPointer>
	void writeWithCharLimit (const CharPointer& src, const int maxChars) noexcept
	{
		CharacterFunctions::copyWithCharLimit (*this, src, maxChars);
	}

	/** Compares this string with another one. */
	template <typename CharPointer>
	int compare (const CharPointer& other) const noexcept
	{
		return CharacterFunctions::compare (*this, other);
	}

	/** Compares this string with another one. */
	int compare (const CharPointer_ASCII& other) const noexcept
	{
		return strcmp (data, other.data);
	}

	/** Compares this string with another one, up to a specified number of characters. */
	template <typename CharPointer>
	int compareUpTo (const CharPointer& other, const int maxChars) const noexcept
	{
		return CharacterFunctions::compareUpTo (*this, other, maxChars);
	}

	/** Compares this string with another one, up to a specified number of characters. */
	int compareUpTo (const CharPointer_ASCII& other, const int maxChars) const noexcept
	{
		return strncmp (data, other.data, (size_t) maxChars);
	}

	/** Compares this string with another one. */
	template <typename CharPointer>
	int compareIgnoreCase (const CharPointer& other) const
	{
		return CharacterFunctions::compareIgnoreCase (*this, other);
	}

	int compareIgnoreCase (const CharPointer_ASCII& other) const
	{
	   #if JUCE_WINDOWS
		return stricmp (data, other.data);
	   #else
		return strcasecmp (data, other.data);
	   #endif
	}

	/** Compares this string with another one, up to a specified number of characters. */
	template <typename CharPointer>
	int compareIgnoreCaseUpTo (const CharPointer& other, const int maxChars) const noexcept
	{
		return CharacterFunctions::compareIgnoreCaseUpTo (*this, other, maxChars);
	}

	/** Returns the character index of a substring, or -1 if it isn't found. */
	template <typename CharPointer>
	int indexOf (const CharPointer& stringToFind) const noexcept
	{
		return CharacterFunctions::indexOf (*this, stringToFind);
	}

	/** Returns the character index of a unicode character, or -1 if it isn't found. */
	int indexOf (const juce_wchar charToFind) const noexcept
	{
		int i = 0;

		while (data[i] != 0)
		{
			if (data[i] == (char) charToFind)
				return i;

			++i;
		}

		return -1;
	}

	/** Returns the character index of a unicode character, or -1 if it isn't found. */
	int indexOf (const juce_wchar charToFind, const bool ignoreCase) const noexcept
	{
		return ignoreCase ? CharacterFunctions::indexOfCharIgnoreCase (*this, charToFind)
						  : CharacterFunctions::indexOfChar (*this, charToFind);
	}

	/** Returns true if the first character of this string is whitespace. */
	bool isWhitespace() const               { return CharacterFunctions::isWhitespace (*data) != 0; }
	/** Returns true if the first character of this string is a digit. */
	bool isDigit() const                    { return CharacterFunctions::isDigit (*data) != 0; }
	/** Returns true if the first character of this string is a letter. */
	bool isLetter() const                   { return CharacterFunctions::isLetter (*data) != 0; }
	/** Returns true if the first character of this string is a letter or digit. */
	bool isLetterOrDigit() const            { return CharacterFunctions::isLetterOrDigit (*data) != 0; }
	/** Returns true if the first character of this string is upper-case. */
	bool isUpperCase() const                { return CharacterFunctions::isUpperCase ((juce_wchar) (uint8) *data) != 0; }
	/** Returns true if the first character of this string is lower-case. */
	bool isLowerCase() const                { return CharacterFunctions::isLowerCase ((juce_wchar) (uint8) *data) != 0; }

	/** Returns an upper-case version of the first character of this string. */
	juce_wchar toUpperCase() const noexcept { return CharacterFunctions::toUpperCase ((juce_wchar) (uint8) *data); }
	/** Returns a lower-case version of the first character of this string. */
	juce_wchar toLowerCase() const noexcept { return CharacterFunctions::toLowerCase ((juce_wchar) (uint8) *data); }

	/** Parses this string as a 32-bit integer. */
	int getIntValue32() const noexcept      { return atoi (data); }

	/** Parses this string as a 64-bit integer. */
	int64 getIntValue64() const noexcept
	{
	   #if JUCE_LINUX || JUCE_ANDROID
		return atoll (data);
	   #elif JUCE_WINDOWS
		return _atoi64 (data);
	   #else
		return CharacterFunctions::getIntValue <int64, CharPointer_ASCII> (*this);
	   #endif
	}

	/** Parses this string as a floating point double. */
	double getDoubleValue() const noexcept  { return CharacterFunctions::getDoubleValue (*this); }

	/** Returns the first non-whitespace character in the string. */
	CharPointer_ASCII findEndOfWhitespace() const noexcept   { return CharacterFunctions::findEndOfWhitespace (*this); }

	/** Returns true if the given unicode character can be represented in this encoding. */
	static bool canRepresent (juce_wchar character) noexcept
	{
		return ((unsigned int) character) < (unsigned int) 128;
	}

	/** Returns true if this data contains a valid string in this encoding. */
	static bool isValidString (const CharType* dataToTest, int maxBytesToRead)
	{
		while (--maxBytesToRead >= 0)
		{
			if (((signed char) *dataToTest) <= 0)
				return *dataToTest == 0;

			++dataToTest;
		}

		return true;
	}

private:
	CharType* data;
};

#endif   // __JUCE_CHARPOINTER_ASCII_JUCEHEADER__

/*** End of inlined file: juce_CharPointer_ASCII.h ***/

#if JUCE_MSVC
 #pragma warning (pop)
#endif

class OutputStream;

/**
	The JUCE String class!

	Using a reference-counted internal representation, these strings are fast
	and efficient, and there are methods to do just about any operation you'll ever
	dream of.

	@see StringArray, StringPairArray
*/
class JUCE_API  String
{
public:

	/** Creates an empty string.
		@see empty
	*/
	String() noexcept;

	/** Creates a copy of another string. */
	String (const String& other) noexcept;

   #if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
	String (String&& other) noexcept;
   #endif

	/** Creates a string from a zero-terminated ascii text string.

		The string passed-in must not contain any characters with a value above 127, because
		these can't be converted to unicode without knowing the original encoding that was
		used to create the string. If you attempt to pass-in values above 127, you'll get an
		assertion.

		To create strings with extended characters from UTF-8, you should explicitly call
		String (CharPointer_UTF8 ("my utf8 string..")). It's *highly* recommended that you
		use UTF-8 with escape characters in your source code to represent extended characters,
		because there's no other way to represent unicode strings in a way that isn't dependent
		on the compiler, source code editor and platform.
	*/
	String (const char* text);

	/** Creates a string from a string of 8-bit ascii characters.

		The string passed-in must not contain any characters with a value above 127, because
		these can't be converted to unicode without knowing the original encoding that was
		used to create the string. If you attempt to pass-in values above 127, you'll get an
		assertion.

		To create strings with extended characters from UTF-8, you should explicitly call
		String (CharPointer_UTF8 ("my utf8 string..")). It's *highly* recommended that you
		use UTF-8 with escape characters in your source code to represent extended characters,
		because there's no other way to represent unicode strings in a way that isn't dependent
		on the compiler, source code editor and platform.

		This will use up the the first maxChars characters of the string (or less if the string
		is actually shorter).
	*/
	String (const char* text, size_t maxChars);

	/** Creates a string from a whcar_t character string.
		Depending on the platform, this may be treated as either UTF-32 or UTF-16.
	*/
	String (const wchar_t* text);

	/** Creates a string from a whcar_t character string.
		Depending on the platform, this may be treated as either UTF-32 or UTF-16.
	*/
	String (const wchar_t* text, size_t maxChars);

	/** Creates a string from a UTF-8 character string */
	String (const CharPointer_UTF8& text);

	/** Creates a string from a UTF-8 character string */
	String (const CharPointer_UTF8& text, size_t maxChars);

	/** Creates a string from a UTF-8 character string */
	String (const CharPointer_UTF8& start, const CharPointer_UTF8& end);

	/** Creates a string from a UTF-16 character string */
	String (const CharPointer_UTF16& text);

	/** Creates a string from a UTF-16 character string */
	String (const CharPointer_UTF16& text, size_t maxChars);

	/** Creates a string from a UTF-16 character string */
	String (const CharPointer_UTF16& start, const CharPointer_UTF16& end);

	/** Creates a string from a UTF-32 character string */
	String (const CharPointer_UTF32& text);

	/** Creates a string from a UTF-32 character string */
	String (const CharPointer_UTF32& text, size_t maxChars);

	/** Creates a string from a UTF-32 character string */
	String (const CharPointer_UTF32& start, const CharPointer_UTF32& end);

	/** Creates a string from an ASCII character string */
	String (const CharPointer_ASCII& text);

	/** Creates a string from a single character. */
	static String charToString (juce_wchar character);

	/** Destructor. */
	~String() noexcept;

	/** This is an empty string that can be used whenever one is needed.

		It's better to use this than String() because it explains what's going on
		and is more efficient.
	*/
	static const String empty;

	/** This is the character encoding type used internally to store the string.

		By setting the value of JUCE_STRING_UTF_TYPE to 8, 16, or 32, you can change the
		internal storage format of the String class. UTF-8 uses the least space (if your strings
		contain few extended characters), but call operator[] involves iterating the string to find
		the required index. UTF-32 provides instant random access to its characters, but uses 4 bytes
		per character to store them. UTF-16 uses more space than UTF-8 and is also slow to index,
		but is the native wchar_t format used in Windows.

		It doesn't matter too much which format you pick, because the toUTF8(), toUTF16() and
		toUTF32() methods let you access the string's content in any of the other formats.
	*/
   #if (JUCE_STRING_UTF_TYPE == 32)
	typedef CharPointer_UTF32 CharPointerType;
   #elif (JUCE_STRING_UTF_TYPE == 16)
	typedef CharPointer_UTF16 CharPointerType;
   #elif (JUCE_STRING_UTF_TYPE == 8)
	typedef CharPointer_UTF8  CharPointerType;
   #else
	#error "You must set the value of JUCE_STRING_UTF_TYPE to be either 8, 16, or 32!"
   #endif

	/** Generates a probably-unique 32-bit hashcode from this string. */
	int hashCode() const noexcept;

	/** Generates a probably-unique 64-bit hashcode from this string. */
	int64 hashCode64() const noexcept;

	/** Returns the number of characters in the string. */
	int length() const noexcept;

	// Assignment and concatenation operators..

	/** Replaces this string's contents with another string. */
	String& operator= (const String& other) noexcept;

   #if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
	String& operator= (String&& other) noexcept;
   #endif

	/** Appends another string at the end of this one. */
	String& operator+= (const String& stringToAppend);
	/** Appends another string at the end of this one. */
	String& operator+= (const char* textToAppend);
	/** Appends another string at the end of this one. */
	String& operator+= (const wchar_t* textToAppend);
	/** Appends a decimal number at the end of this string. */
	String& operator+= (int numberToAppend);
	/** Appends a character at the end of this string. */
	String& operator+= (char characterToAppend);
	/** Appends a character at the end of this string. */
	String& operator+= (wchar_t characterToAppend);
   #if ! JUCE_NATIVE_WCHAR_IS_UTF32
	/** Appends a character at the end of this string. */
	String& operator+= (juce_wchar characterToAppend);
   #endif

	/** Appends a string to the end of this one.

		@param textToAppend     the string to add
		@param maxCharsToTake   the maximum number of characters to take from the string passed in
	*/
	void append (const String& textToAppend, size_t maxCharsToTake);

	/** Appends a string to the end of this one.

		@param textToAppend     the string to add
		@param maxCharsToTake   the maximum number of characters to take from the string passed in
	*/
	template <class CharPointer>
	void appendCharPointer (const CharPointer& textToAppend, size_t maxCharsToTake)
	{
		if (textToAppend.getAddress() != nullptr)
		{
			size_t extraBytesNeeded = 0;
			size_t numChars = 0;

			for (CharPointer t (textToAppend); numChars < maxCharsToTake && ! t.isEmpty();)
			{
				extraBytesNeeded += CharPointerType::getBytesRequiredFor (t.getAndAdvance());
				++numChars;
			}

			if (numChars > 0)
			{
				const size_t byteOffsetOfNull = getByteOffsetOfEnd();

				preallocateBytes (byteOffsetOfNull + extraBytesNeeded);
				CharPointerType (addBytesToPointer (text.getAddress(), (int) byteOffsetOfNull)).writeWithCharLimit (textToAppend, (int) (numChars + 1));
			}
		}
	}

	/** Appends a string to the end of this one. */
	template <class CharPointer>
	void appendCharPointer (const CharPointer& textToAppend)
	{
		if (textToAppend.getAddress() != nullptr)
		{
			size_t extraBytesNeeded = 0;

			for (CharPointer t (textToAppend); ! t.isEmpty();)
				extraBytesNeeded += CharPointerType::getBytesRequiredFor (t.getAndAdvance());

			if (extraBytesNeeded > 0)
			{
				const size_t byteOffsetOfNull = getByteOffsetOfEnd();

				preallocateBytes (byteOffsetOfNull + extraBytesNeeded);
				CharPointerType (addBytesToPointer (text.getAddress(), (int) byteOffsetOfNull)).writeAll (textToAppend);
			}
		}
	}

	// Comparison methods..

	/** Returns true if the string contains no characters.
		Note that there's also an isNotEmpty() method to help write readable code.
		@see containsNonWhitespaceChars()
	*/
	inline bool isEmpty() const noexcept                    { return text[0] == 0; }

	/** Returns true if the string contains at least one character.
		Note that there's also an isEmpty() method to help write readable code.
		@see containsNonWhitespaceChars()
	*/
	inline bool isNotEmpty() const noexcept                 { return text[0] != 0; }

	/** Case-insensitive comparison with another string. */
	bool equalsIgnoreCase (const String& other) const noexcept;

	/** Case-insensitive comparison with another string. */
	bool equalsIgnoreCase (const wchar_t* other) const noexcept;

	/** Case-insensitive comparison with another string. */
	bool equalsIgnoreCase (const char* other) const noexcept;

	/** Case-sensitive comparison with another string.
		@returns     0 if the two strings are identical; negative if this string comes before
					 the other one alphabetically, or positive if it comes after it.
	*/
	int compare (const String& other) const noexcept;

	/** Case-sensitive comparison with another string.
		@returns     0 if the two strings are identical; negative if this string comes before
					 the other one alphabetically, or positive if it comes after it.
	*/
	int compare (const char* other) const noexcept;

	/** Case-sensitive comparison with another string.
		@returns     0 if the two strings are identical; negative if this string comes before
					 the other one alphabetically, or positive if it comes after it.
	*/
	int compare (const wchar_t* other) const noexcept;

	/** Case-insensitive comparison with another string.
		@returns     0 if the two strings are identical; negative if this string comes before
					 the other one alphabetically, or positive if it comes after it.
	*/
	int compareIgnoreCase (const String& other) const noexcept;

	/** Lexicographic comparison with another string.

		The comparison used here is case-insensitive and ignores leading non-alphanumeric
		characters, making it good for sorting human-readable strings.

		@returns     0 if the two strings are identical; negative if this string comes before
					 the other one alphabetically, or positive if it comes after it.
	*/
	int compareLexicographically (const String& other) const noexcept;

	/** Tests whether the string begins with another string.
		If the parameter is an empty string, this will always return true.
		Uses a case-sensitive comparison.
	*/
	bool startsWith (const String& text) const noexcept;

	/** Tests whether the string begins with a particular character.
		If the character is 0, this will always return false.
		Uses a case-sensitive comparison.
	*/
	bool startsWithChar (juce_wchar character) const noexcept;

	/** Tests whether the string begins with another string.
		If the parameter is an empty string, this will always return true.
		Uses a case-insensitive comparison.
	*/
	bool startsWithIgnoreCase (const String& text) const noexcept;

	/** Tests whether the string ends with another string.
		If the parameter is an empty string, this will always return true.
		Uses a case-sensitive comparison.
	*/
	bool endsWith (const String& text) const noexcept;

	/** Tests whether the string ends with a particular character.
		If the character is 0, this will always return false.
		Uses a case-sensitive comparison.
	*/
	bool endsWithChar (juce_wchar character) const noexcept;

	/** Tests whether the string ends with another string.
		If the parameter is an empty string, this will always return true.
		Uses a case-insensitive comparison.
	*/
	bool endsWithIgnoreCase (const String& text) const noexcept;

	/** Tests whether the string contains another substring.
		If the parameter is an empty string, this will always return true.
		Uses a case-sensitive comparison.
	*/
	bool contains (const String& text) const noexcept;

	/** Tests whether the string contains a particular character.
		Uses a case-sensitive comparison.
	*/
	bool containsChar (juce_wchar character) const noexcept;

	/** Tests whether the string contains another substring.
		Uses a case-insensitive comparison.
	*/
	bool containsIgnoreCase (const String& text) const noexcept;

	/** Tests whether the string contains another substring as a distict word.

		@returns    true if the string contains this word, surrounded by
					non-alphanumeric characters
		@see indexOfWholeWord, containsWholeWordIgnoreCase
	*/
	bool containsWholeWord (const String& wordToLookFor) const noexcept;

	/** Tests whether the string contains another substring as a distict word.

		@returns    true if the string contains this word, surrounded by
					non-alphanumeric characters
		@see indexOfWholeWordIgnoreCase, containsWholeWord
	*/
	bool containsWholeWordIgnoreCase (const String& wordToLookFor) const noexcept;

	/** Finds an instance of another substring if it exists as a distict word.

		@returns    if the string contains this word, surrounded by non-alphanumeric characters,
					then this will return the index of the start of the substring. If it isn't
					found, then it will return -1
		@see indexOfWholeWordIgnoreCase, containsWholeWord
	*/
	int indexOfWholeWord (const String& wordToLookFor) const noexcept;

	/** Finds an instance of another substring if it exists as a distict word.

		@returns    if the string contains this word, surrounded by non-alphanumeric characters,
					then this will return the index of the start of the substring. If it isn't
					found, then it will return -1
		@see indexOfWholeWord, containsWholeWordIgnoreCase
	*/
	int indexOfWholeWordIgnoreCase (const String& wordToLookFor) const noexcept;

	/** Looks for any of a set of characters in the string.
		Uses a case-sensitive comparison.

		@returns    true if the string contains any of the characters from
					the string that is passed in.
	*/
	bool containsAnyOf (const String& charactersItMightContain) const noexcept;

	/** Looks for a set of characters in the string.
		Uses a case-sensitive comparison.

		@returns    Returns false if any of the characters in this string do not occur in
					the parameter string. If this string is empty, the return value will
					always be true.
	*/
	bool containsOnly (const String& charactersItMightContain) const noexcept;

	/** Returns true if this string contains any non-whitespace characters.

		This will return false if the string contains only whitespace characters, or
		if it's empty.

		It is equivalent to calling "myString.trim().isNotEmpty()".
	*/
	bool containsNonWhitespaceChars() const noexcept;

	/** Returns true if the string matches this simple wildcard expression.

		So for example String ("abcdef").matchesWildcard ("*DEF", true) would return true.

		This isn't a full-blown regex though! The only wildcard characters supported
		are "*" and "?". It's mainly intended for filename pattern matching.
	*/
	bool matchesWildcard (const String& wildcard, bool ignoreCase) const noexcept;

	// Substring location methods..

	/** Searches for a character inside this string.
		Uses a case-sensitive comparison.
		@returns    the index of the first occurrence of the character in this
					string, or -1 if it's not found.
	*/
	int indexOfChar (juce_wchar characterToLookFor) const noexcept;

	/** Searches for a character inside this string.
		Uses a case-sensitive comparison.
		@param startIndex           the index from which the search should proceed
		@param characterToLookFor   the character to look for
		@returns            the index of the first occurrence of the character in this
							string, or -1 if it's not found.
	*/
	int indexOfChar (int startIndex, juce_wchar characterToLookFor) const noexcept;

	/** Returns the index of the first character that matches one of the characters
		passed-in to this method.

		This scans the string, beginning from the startIndex supplied, and if it finds
		a character that appears in the string charactersToLookFor, it returns its index.

		If none of these characters are found, it returns -1.

		If ignoreCase is true, the comparison will be case-insensitive.

		@see indexOfChar, lastIndexOfAnyOf
	*/
	int indexOfAnyOf (const String& charactersToLookFor,
					  int startIndex = 0,
					  bool ignoreCase = false) const noexcept;

	/** Searches for a substring within this string.
		Uses a case-sensitive comparison.
		@returns    the index of the first occurrence of this substring, or -1 if it's not found.
					If textToLookFor is an empty string, this will always return 0.
	*/
	int indexOf (const String& textToLookFor) const noexcept;

	/** Searches for a substring within this string.
		Uses a case-sensitive comparison.
		@param startIndex       the index from which the search should proceed
		@param textToLookFor    the string to search for
		@returns                the index of the first occurrence of this substring, or -1 if it's not found.
								If textToLookFor is an empty string, this will always return -1.
	*/
	int indexOf (int startIndex, const String& textToLookFor) const noexcept;

	/** Searches for a substring within this string.
		Uses a case-insensitive comparison.
		@returns    the index of the first occurrence of this substring, or -1 if it's not found.
					If textToLookFor is an empty string, this will always return 0.
	*/
	int indexOfIgnoreCase (const String& textToLookFor) const noexcept;

	/** Searches for a substring within this string.
		Uses a case-insensitive comparison.
		@param startIndex       the index from which the search should proceed
		@param textToLookFor    the string to search for
		@returns                the index of the first occurrence of this substring, or -1 if it's not found.
								If textToLookFor is an empty string, this will always return -1.
	*/
	int indexOfIgnoreCase (int startIndex, const String& textToLookFor) const noexcept;

	/** Searches for a character inside this string (working backwards from the end of the string).
		Uses a case-sensitive comparison.
		@returns    the index of the last occurrence of the character in this string, or -1 if it's not found.
	*/
	int lastIndexOfChar (juce_wchar character) const noexcept;

	/** Searches for a substring inside this string (working backwards from the end of the string).
		Uses a case-sensitive comparison.
		@returns    the index of the start of the last occurrence of the substring within this string,
					or -1 if it's not found. If textToLookFor is an empty string, this will always return -1.
	*/
	int lastIndexOf (const String& textToLookFor) const noexcept;

	/** Searches for a substring inside this string (working backwards from the end of the string).
		Uses a case-insensitive comparison.
		@returns    the index of the start of the last occurrence of the substring within this string, or -1
					if it's not found. If textToLookFor is an empty string, this will always return -1.
	*/
	int lastIndexOfIgnoreCase (const String& textToLookFor) const noexcept;

	/** Returns the index of the last character in this string that matches one of the
		characters passed-in to this method.

		This scans the string backwards, starting from its end, and if it finds
		a character that appears in the string charactersToLookFor, it returns its index.

		If none of these characters are found, it returns -1.

		If ignoreCase is true, the comparison will be case-insensitive.

		@see lastIndexOf, indexOfAnyOf
	*/
	int lastIndexOfAnyOf (const String& charactersToLookFor,
						  bool ignoreCase = false) const noexcept;

	// Substring extraction and manipulation methods..

	/** Returns the character at this index in the string.
		In a release build, no checks are made to see if the index is within a valid range, so be
		careful! In a debug build, the index is checked and an assertion fires if it's out-of-range.

		Also beware that depending on the encoding format that the string is using internally, this
		method may execute in either O(1) or O(n) time, so be careful when using it in your algorithms.
		If you're scanning through a string to inspect its characters, you should never use this operator
		for random access, it's far more efficient to call getCharPointer() to return a pointer, and
		then to use that to iterate the string.
		@see getCharPointer
	*/
	const juce_wchar operator[] (int index) const noexcept;

	/** Returns the final character of the string.
		If the string is empty this will return 0.
	*/
	juce_wchar getLastCharacter() const noexcept;

	/** Returns a subsection of the string.

		If the range specified is beyond the limits of the string, as much as
		possible is returned.

		@param startIndex   the index of the start of the substring needed
		@param endIndex     all characters from startIndex up to (but not including)
							this index are returned
		@see fromFirstOccurrenceOf, dropLastCharacters, getLastCharacters, upToFirstOccurrenceOf
	*/
	String substring (int startIndex, int endIndex) const;

	/** Returns a section of the string, starting from a given position.

		@param startIndex   the first character to include. If this is beyond the end
							of the string, an empty string is returned. If it is zero or
							less, the whole string is returned.
		@returns            the substring from startIndex up to the end of the string
		@see dropLastCharacters, getLastCharacters, fromFirstOccurrenceOf, upToFirstOccurrenceOf, fromLastOccurrenceOf
	*/
	String substring (int startIndex) const;

	/** Returns a version of this string with a number of characters removed
		from the end.

		@param numberToDrop     the number of characters to drop from the end of the
								string. If this is greater than the length of the string,
								an empty string will be returned. If zero or less, the
								original string will be returned.
		@see substring, fromFirstOccurrenceOf, upToFirstOccurrenceOf, fromLastOccurrenceOf, getLastCharacter
	*/
	String dropLastCharacters (int numberToDrop) const;

	/** Returns a number of characters from the end of the string.

		This returns the last numCharacters characters from the end of the string. If the
		string is shorter than numCharacters, the whole string is returned.

		@see substring, dropLastCharacters, getLastCharacter
	*/
	String getLastCharacters (int numCharacters) const;

	/** Returns a section of the string starting from a given substring.

		This will search for the first occurrence of the given substring, and
		return the section of the string starting from the point where this is
		found (optionally not including the substring itself).

		e.g. for the string "123456", fromFirstOccurrenceOf ("34", true) would return "3456", and
									  fromFirstOccurrenceOf ("34", false) would return "56".

		If the substring isn't found, the method will return an empty string.

		If ignoreCase is true, the comparison will be case-insensitive.

		@see upToFirstOccurrenceOf, fromLastOccurrenceOf
	*/
	String fromFirstOccurrenceOf (const String& substringToStartFrom,
								  bool includeSubStringInResult,
										bool ignoreCase) const;

	/** Returns a section of the string starting from the last occurrence of a given substring.

		Similar to fromFirstOccurrenceOf(), but using the last occurrence of the substring, and
		unlike fromFirstOccurrenceOf(), if the substring isn't found, this method will
		return the whole of the original string.

		@see fromFirstOccurrenceOf, upToLastOccurrenceOf
	*/
	String fromLastOccurrenceOf (const String& substringToFind,
								 bool includeSubStringInResult,
								 bool ignoreCase) const;

	/** Returns the start of this string, up to the first occurrence of a substring.

		This will search for the first occurrence of a given substring, and then
		return a copy of the string, up to the position of this substring,
		optionally including or excluding the substring itself in the result.

		e.g. for the string "123456", upTo ("34", false) would return "12", and
									  upTo ("34", true) would return "1234".

		If the substring isn't found, this will return the whole of the original string.

		@see upToLastOccurrenceOf, fromFirstOccurrenceOf
	*/
	String upToFirstOccurrenceOf (const String& substringToEndWith,
								  bool includeSubStringInResult,
								  bool ignoreCase) const;

	/** Returns the start of this string, up to the last occurrence of a substring.

		Similar to upToFirstOccurrenceOf(), but this finds the last occurrence rather than the first.
		If the substring isn't found, this will return the whole of the original string.

		@see upToFirstOccurrenceOf, fromFirstOccurrenceOf
	*/
	String upToLastOccurrenceOf (const String& substringToFind,
								 bool includeSubStringInResult,
								 bool ignoreCase) const;

	/** Returns a copy of this string with any whitespace characters removed from the start and end. */
	String trim() const;

	/** Returns a copy of this string with any whitespace characters removed from the start. */
	String trimStart() const;

	/** Returns a copy of this string with any whitespace characters removed from the end. */
	String trimEnd() const;

	/** Returns a copy of this string, having removed a specified set of characters from its start.
		Characters are removed from the start of the string until it finds one that is not in the
		specified set, and then it stops.
		@param charactersToTrim     the set of characters to remove.
		@see trim, trimStart, trimCharactersAtEnd
	*/
	String trimCharactersAtStart (const String& charactersToTrim) const;

	/** Returns a copy of this string, having removed a specified set of characters from its end.
		Characters are removed from the end of the string until it finds one that is not in the
		specified set, and then it stops.
		@param charactersToTrim     the set of characters to remove.
		@see trim, trimEnd, trimCharactersAtStart
	*/
	String trimCharactersAtEnd (const String& charactersToTrim) const;

	/** Returns an upper-case version of this string. */
	String toUpperCase() const;

	/** Returns an lower-case version of this string. */
	String toLowerCase() const;

	/** Replaces a sub-section of the string with another string.

		This will return a copy of this string, with a set of characters
		from startIndex to startIndex + numCharsToReplace removed, and with
		a new string inserted in their place.

		Note that this is a const method, and won't alter the string itself.

		@param startIndex               the first character to remove. If this is beyond the bounds of the string,
										it will be constrained to a valid range.
		@param numCharactersToReplace   the number of characters to remove. If zero or less, no
										characters will be taken out.
		@param stringToInsert           the new string to insert at startIndex after the characters have been
										removed.
	*/
	String replaceSection (int startIndex,
						   int numCharactersToReplace,
						   const String& stringToInsert) const;

	/** Replaces all occurrences of a substring with another string.

		Returns a copy of this string, with any occurrences of stringToReplace
		swapped for stringToInsertInstead.

		Note that this is a const method, and won't alter the string itself.
	*/
	String replace (const String& stringToReplace,
					const String& stringToInsertInstead,
					bool ignoreCase = false) const;

	/** Returns a string with all occurrences of a character replaced with a different one. */
	String replaceCharacter (juce_wchar characterToReplace,
							 juce_wchar characterToInsertInstead) const;

	/** Replaces a set of characters with another set.

		Returns a string in which each character from charactersToReplace has been replaced
		by the character at the equivalent position in newCharacters (so the two strings
		passed in must be the same length).

		e.g. replaceCharacters ("abc", "def") replaces 'a' with 'd', 'b' with 'e', etc.

		Note that this is a const method, and won't affect the string itself.
	*/
	String replaceCharacters (const String& charactersToReplace,
							  const String& charactersToInsertInstead) const;

	/** Returns a version of this string that only retains a fixed set of characters.

		This will return a copy of this string, omitting any characters which are not
		found in the string passed-in.

		e.g. for "1122334455", retainCharacters ("432") would return "223344"

		Note that this is a const method, and won't alter the string itself.
	*/
	String retainCharacters (const String& charactersToRetain) const;

	/** Returns a version of this string with a set of characters removed.

		This will return a copy of this string, omitting any characters which are
		found in the string passed-in.

		e.g. for "1122334455", removeCharacters ("432") would return "1155"

		Note that this is a const method, and won't alter the string itself.
	*/
	String removeCharacters (const String& charactersToRemove) const;

	/** Returns a section from the start of the string that only contains a certain set of characters.

		This returns the leftmost section of the string, up to (and not including) the
		first character that doesn't appear in the string passed in.
	*/
	String initialSectionContainingOnly (const String& permittedCharacters) const;

	/** Returns a section from the start of the string that only contains a certain set of characters.

		This returns the leftmost section of the string, up to (and not including) the
		first character that occurs in the string passed in. (If none of the specified
		characters are found in the string, the return value will just be the original string).
	*/
	String initialSectionNotContaining (const String& charactersToStopAt) const;

	/** Checks whether the string might be in quotation marks.

		@returns    true if the string begins with a quote character (either a double or single quote).
					It is also true if there is whitespace before the quote, but it doesn't check the end of the string.
		@see unquoted, quoted
	*/
	bool isQuotedString() const;

	/** Removes quotation marks from around the string, (if there are any).

		Returns a copy of this string with any quotes removed from its ends. Quotes that aren't
		at the ends of the string are not affected. If there aren't any quotes, the original string
		is returned.

		Note that this is a const method, and won't alter the string itself.

		@see isQuotedString, quoted
	*/
	String unquoted() const;

	/** Adds quotation marks around a string.

		This will return a copy of the string with a quote at the start and end, (but won't
		add the quote if there's already one there, so it's safe to call this on strings that
		may already have quotes around them).

		Note that this is a const method, and won't alter the string itself.

		@param quoteCharacter   the character to add at the start and end
		@see isQuotedString, unquoted
	*/
	String quoted (juce_wchar quoteCharacter = '"') const;

	/** Creates a string which is a version of a string repeated and joined together.

		@param stringToRepeat         the string to repeat
		@param numberOfTimesToRepeat  how many times to repeat it
	*/
	static String repeatedString (const String& stringToRepeat,
								  int numberOfTimesToRepeat);

	/** Returns a copy of this string with the specified character repeatedly added to its
		beginning until the total length is at least the minimum length specified.
	*/
	String paddedLeft (juce_wchar padCharacter, int minimumLength) const;

	/** Returns a copy of this string with the specified character repeatedly added to its
		end until the total length is at least the minimum length specified.
	*/
	String paddedRight (juce_wchar padCharacter, int minimumLength) const;

	/** Creates a string from data in an unknown format.

		This looks at some binary data and tries to guess whether it's Unicode
		or 8-bit characters, then returns a string that represents it correctly.

		Should be able to handle Unicode endianness correctly, by looking at
		the first two bytes.
	*/
	static String createStringFromData (const void* data, int size);

	/** Creates a String from a printf-style parameter list.

		I don't like this method. I don't use it myself, and I recommend avoiding it and
		using the operator<< methods or pretty much anything else instead. It's only provided
		here because of the popular unrest that was stirred-up when I tried to remove it...

		If you're really determined to use it, at least make sure that you never, ever,
		pass any String objects to it as parameters. And bear in mind that internally, depending
		on the platform, it may be using wchar_t or char character types, so that even string
		literals can't be safely used as parameters if you're writing portable code.
	*/
	static String formatted (const String formatString, ... );

	// Numeric conversions..

	/** Creates a string containing this signed 32-bit integer as a decimal number.
		@see getIntValue, getFloatValue, getDoubleValue, toHexString
	*/
	explicit String (int decimalInteger);

	/** Creates a string containing this unsigned 32-bit integer as a decimal number.
		@see getIntValue, getFloatValue, getDoubleValue, toHexString
	*/
	explicit String (unsigned int decimalInteger);

	/** Creates a string containing this signed 16-bit integer as a decimal number.
		@see getIntValue, getFloatValue, getDoubleValue, toHexString
	*/
	explicit String (short decimalInteger);

	/** Creates a string containing this unsigned 16-bit integer as a decimal number.
		@see getIntValue, getFloatValue, getDoubleValue, toHexString
	*/
	explicit String (unsigned short decimalInteger);

	/** Creates a string containing this signed 64-bit integer as a decimal number.
		@see getLargeIntValue, getFloatValue, getDoubleValue, toHexString
	*/
	explicit String (int64 largeIntegerValue);

	/** Creates a string containing this unsigned 64-bit integer as a decimal number.
		@see getLargeIntValue, getFloatValue, getDoubleValue, toHexString
	*/
	explicit String (uint64 largeIntegerValue);

	/** Creates a string representing this floating-point number.
		@param floatValue               the value to convert to a string
		@see getDoubleValue, getIntValue
	*/
	explicit String (float floatValue);

	/** Creates a string representing this floating-point number.
		@param doubleValue              the value to convert to a string
		@see getFloatValue, getIntValue
	*/
	explicit String (double doubleValue);

	/** Creates a string representing this floating-point number.
		@param floatValue               the value to convert to a string
		@param numberOfDecimalPlaces    if this is > 0, it will format the number using that many
										decimal places, and will not use exponent notation. If 0 or
										less, it will use exponent notation if necessary.
		@see getDoubleValue, getIntValue
	*/
	String (float floatValue, int numberOfDecimalPlaces);

	/** Creates a string representing this floating-point number.
		@param doubleValue              the value to convert to a string
		@param numberOfDecimalPlaces    if this is > 0, it will format the number using that many
										decimal places, and will not use exponent notation. If 0 or
										less, it will use exponent notation if necessary.
		@see getFloatValue, getIntValue
	*/
	String (double doubleValue, int numberOfDecimalPlaces);

	/** Reads the value of the string as a decimal number (up to 32 bits in size).

		@returns the value of the string as a 32 bit signed base-10 integer.
		@see getTrailingIntValue, getHexValue32, getHexValue64
	*/
	int getIntValue() const noexcept;

	/** Reads the value of the string as a decimal number (up to 64 bits in size).

		@returns the value of the string as a 64 bit signed base-10 integer.
	*/
	int64 getLargeIntValue() const noexcept;

	/** Parses a decimal number from the end of the string.

		This will look for a value at the end of the string.
		e.g. for "321 xyz654" it will return 654; for "2 3 4" it'll return 4.

		Negative numbers are not handled, so "xyz-5" returns 5.

		@see getIntValue
	*/
	int getTrailingIntValue() const noexcept;

	/** Parses this string as a floating point number.

		@returns    the value of the string as a 32-bit floating point value.
		@see getDoubleValue
	*/
	float getFloatValue() const noexcept;

	/** Parses this string as a floating point number.

		@returns    the value of the string as a 64-bit floating point value.
		@see getFloatValue
	*/
	double getDoubleValue() const noexcept;

	/** Parses the string as a hexadecimal number.

		Non-hexadecimal characters in the string are ignored.

		If the string contains too many characters, then the lowest significant
		digits are returned, e.g. "ffff12345678" would produce 0x12345678.

		@returns    a 32-bit number which is the value of the string in hex.
	*/
	int getHexValue32() const noexcept;

	/** Parses the string as a hexadecimal number.

		Non-hexadecimal characters in the string are ignored.

		If the string contains too many characters, then the lowest significant
		digits are returned, e.g. "ffff1234567812345678" would produce 0x1234567812345678.

		@returns    a 64-bit number which is the value of the string in hex.
	*/
	int64 getHexValue64() const noexcept;

	/** Creates a string representing this 32-bit value in hexadecimal. */
	static String toHexString (int number);

	/** Creates a string representing this 64-bit value in hexadecimal. */
	static String toHexString (int64 number);

	/** Creates a string representing this 16-bit value in hexadecimal. */
	static String toHexString (short number);

	/** Creates a string containing a hex dump of a block of binary data.

		@param data         the binary data to use as input
		@param size         how many bytes of data to use
		@param groupSize    how many bytes are grouped together before inserting a
							space into the output. e.g. group size 0 has no spaces,
							group size 1 looks like: "be a1 c2 ff", group size 2 looks
							like "bea1 c2ff".
	*/
	static String toHexString (const void* data, int size, int groupSize = 1);

	/** Returns the character pointer currently being used to store this string.

		Because it returns a reference to the string's internal data, the pointer
		that is returned must not be stored anywhere, as it can be deleted whenever the
		string changes.
	*/
	inline const CharPointerType& getCharPointer() const noexcept    { return text; }

	/** Returns a pointer to a UTF-8 version of this string.

		Because it returns a reference to the string's internal data, the pointer
		that is returned must not be stored anywhere, as it can be deleted whenever the
		string changes.

		To find out how many bytes you need to store this string as UTF-8, you can call
		CharPointer_UTF8::getBytesRequiredFor (myString.getCharPointer())

		@see getCharPointer, toUTF16, toUTF32
	*/
	CharPointer_UTF8 toUTF8() const;

	/** Returns a pointer to a UTF-32 version of this string.

		Because it returns a reference to the string's internal data, the pointer
		that is returned must not be stored anywhere, as it can be deleted whenever the
		string changes.

		To find out how many bytes you need to store this string as UTF-16, you can call
		CharPointer_UTF16::getBytesRequiredFor (myString.getCharPointer())

		@see getCharPointer, toUTF8, toUTF32
	*/
	CharPointer_UTF16 toUTF16() const;

	/** Returns a pointer to a UTF-32 version of this string.

		Because it returns a reference to the string's internal data, the pointer
		that is returned must not be stored anywhere, as it can be deleted whenever the
		string changes.

		@see getCharPointer, toUTF8, toUTF16
	*/
	CharPointer_UTF32 toUTF32() const;

	/** Returns a pointer to a wchar_t version of this string.

		Because it returns a reference to the string's internal data, the pointer
		that is returned must not be stored anywhere, as it can be deleted whenever the
		string changes.

		Bear in mind that the wchar_t type is different on different platforms, so on
		Windows, this will be equivalent to calling toUTF16(), on unix it'll be the same
		as calling toUTF32(), etc.

		@see getCharPointer, toUTF8, toUTF16, toUTF32
	*/
	const wchar_t* toWideCharPointer() const;

	/** Creates a String from a UTF-8 encoded buffer.
		If the size is < 0, it'll keep reading until it hits a zero.
	*/
	static String fromUTF8 (const char* utf8buffer, int bufferSizeBytes = -1);

	/** Returns the number of bytes required to represent this string as UTF8.
		The number returned does NOT include the trailing zero.
		@see toUTF8, copyToUTF8
	*/
	int getNumBytesAsUTF8() const noexcept;

	/** Copies the string to a buffer as UTF-8 characters.

		Returns the number of bytes copied to the buffer, including the terminating null
		character.

		To find out how many bytes you need to store this string as UTF-8, you can call
		CharPointer_UTF8::getBytesRequiredFor (myString.getCharPointer())

		@param destBuffer       the place to copy it to; if this is a null pointer, the method just
								returns the number of bytes required (including the terminating null character).
		@param maxBufferSizeBytes  the size of the destination buffer, in bytes. If the string won't fit, it'll
								put in as many as it can while still allowing for a terminating null char at the
								end, and will return the number of bytes that were actually used.
		@see CharPointer_UTF8::writeWithDestByteLimit
	*/
	int copyToUTF8 (CharPointer_UTF8::CharType* destBuffer, int maxBufferSizeBytes) const noexcept;

	/** Copies the string to a buffer as UTF-16 characters.

		Returns the number of bytes copied to the buffer, including the terminating null
		character.

		To find out how many bytes you need to store this string as UTF-16, you can call
		CharPointer_UTF16::getBytesRequiredFor (myString.getCharPointer())

		@param destBuffer       the place to copy it to; if this is a null pointer, the method just
								returns the number of bytes required (including the terminating null character).
		@param maxBufferSizeBytes  the size of the destination buffer, in bytes. If the string won't fit, it'll
								put in as many as it can while still allowing for a terminating null char at the
								end, and will return the number of bytes that were actually used.
		@see CharPointer_UTF16::writeWithDestByteLimit
	*/
	int copyToUTF16 (CharPointer_UTF16::CharType* destBuffer, int maxBufferSizeBytes) const noexcept;

	/** Copies the string to a buffer as UTF-16 characters.

		Returns the number of bytes copied to the buffer, including the terminating null
		character.

		To find out how many bytes you need to store this string as UTF-32, you can call
		CharPointer_UTF32::getBytesRequiredFor (myString.getCharPointer())

		@param destBuffer       the place to copy it to; if this is a null pointer, the method just
								returns the number of bytes required (including the terminating null character).
		@param maxBufferSizeBytes  the size of the destination buffer, in bytes. If the string won't fit, it'll
								put in as many as it can while still allowing for a terminating null char at the
								end, and will return the number of bytes that were actually used.
		@see CharPointer_UTF32::writeWithDestByteLimit
	*/
	int copyToUTF32 (CharPointer_UTF32::CharType* destBuffer, int maxBufferSizeBytes) const noexcept;

	/** Increases the string's internally allocated storage.

		Although the string's contents won't be affected by this call, it will
		increase the amount of memory allocated internally for the string to grow into.

		If you're about to make a large number of calls to methods such
		as += or <<, it's more efficient to preallocate enough extra space
		beforehand, so that these methods won't have to keep resizing the string
		to append the extra characters.

		@param numBytesNeeded   the number of bytes to allocate storage for. If this
								value is less than the currently allocated size, it will
								have no effect.
	*/
	void preallocateBytes (size_t numBytesNeeded);

	/** Swaps the contents of this string with another one.
		This is a very fast operation, as no allocation or copying needs to be done.
	*/
	void swapWith (String& other) noexcept;

   #if JUCE_MAC || JUCE_IOS || DOXYGEN
	/** MAC ONLY - Creates a String from an OSX CFString. */
	static String fromCFString (CFStringRef cfString);

	/** MAC ONLY - Converts this string to a CFString.
		Remember that you must use CFRelease() to free the returned string when you're
		finished with it.
	*/
	CFStringRef toCFString() const;

	/** MAC ONLY - Returns a copy of this string in which any decomposed unicode characters have
		been converted to their precomposed equivalents. */
	String convertToPrecomposedUnicode() const;
   #endif

private:

	CharPointerType text;

	struct PreallocationBytes
	{
		explicit PreallocationBytes (size_t);
		size_t numBytes;
	};

	explicit String (const PreallocationBytes&); // This constructor preallocates a certain amount of memory
	void appendFixedLength (const char* text, int numExtraChars);
	size_t getByteOffsetOfEnd() const noexcept;
	JUCE_DEPRECATED (String (const String& stringToCopy, size_t charsToAllocate));

	// This private cast operator should prevent strings being accidentally cast
	// to bools (this is possible because the compiler can add an implicit cast
	// via a const char*)
	operator bool() const noexcept  { return false; }
};

/** Concatenates two strings. */
JUCE_API String JUCE_CALLTYPE operator+ (const char* string1,     const String& string2);
/** Concatenates two strings. */
JUCE_API String JUCE_CALLTYPE operator+ (const wchar_t* string1,  const String& string2);
/** Concatenates two strings. */
JUCE_API String JUCE_CALLTYPE operator+ (char string1,            const String& string2);
/** Concatenates two strings. */
JUCE_API String JUCE_CALLTYPE operator+ (wchar_t string1,         const String& string2);
#if ! JUCE_NATIVE_WCHAR_IS_UTF32
/** Concatenates two strings. */
JUCE_API String JUCE_CALLTYPE operator+ (juce_wchar string1,      const String& string2);
#endif

/** Concatenates two strings. */
JUCE_API String JUCE_CALLTYPE operator+ (String string1, const String& string2);
/** Concatenates two strings. */
JUCE_API String JUCE_CALLTYPE operator+ (String string1, const char* string2);
/** Concatenates two strings. */
JUCE_API String JUCE_CALLTYPE operator+ (String string1, const wchar_t* string2);
/** Concatenates two strings. */
JUCE_API String JUCE_CALLTYPE operator+ (String string1, char characterToAppend);
/** Concatenates two strings. */
JUCE_API String JUCE_CALLTYPE operator+ (String string1, wchar_t characterToAppend);
#if ! JUCE_NATIVE_WCHAR_IS_UTF32
/** Concatenates two strings. */
JUCE_API String JUCE_CALLTYPE operator+ (String string1, juce_wchar characterToAppend);
#endif

/** Appends a character at the end of a string. */
JUCE_API String& JUCE_CALLTYPE operator<< (String& string1, char characterToAppend);
/** Appends a character at the end of a string. */
JUCE_API String& JUCE_CALLTYPE operator<< (String& string1, wchar_t characterToAppend);
#if ! JUCE_NATIVE_WCHAR_IS_UTF32
/** Appends a character at the end of a string. */
JUCE_API String& JUCE_CALLTYPE operator<< (String& string1, juce_wchar characterToAppend);
#endif

/** Appends a string to the end of the first one. */
JUCE_API String& JUCE_CALLTYPE operator<< (String& string1, const char* string2);
/** Appends a string to the end of the first one. */
JUCE_API String& JUCE_CALLTYPE operator<< (String& string1, const wchar_t* string2);
/** Appends a string to the end of the first one. */
JUCE_API String& JUCE_CALLTYPE operator<< (String& string1, const String& string2);

/** Appends a decimal number at the end of a string. */
JUCE_API String& JUCE_CALLTYPE operator<< (String& string1, short number);
/** Appends a decimal number at the end of a string. */
JUCE_API String& JUCE_CALLTYPE operator<< (String& string1, int number);
/** Appends a decimal number at the end of a string. */
JUCE_API String& JUCE_CALLTYPE operator<< (String& string1, long number);
/** Appends a decimal number at the end of a string. */
JUCE_API String& JUCE_CALLTYPE operator<< (String& string1, float number);
/** Appends a decimal number at the end of a string. */
JUCE_API String& JUCE_CALLTYPE operator<< (String& string1, double number);

/** Case-sensitive comparison of two strings. */
JUCE_API bool JUCE_CALLTYPE operator== (const String& string1, const String& string2) noexcept;
/** Case-sensitive comparison of two strings. */
JUCE_API bool JUCE_CALLTYPE operator== (const String& string1, const char* string2) noexcept;
/** Case-sensitive comparison of two strings. */
JUCE_API bool JUCE_CALLTYPE operator== (const String& string1, const wchar_t* string2) noexcept;
/** Case-sensitive comparison of two strings. */
JUCE_API bool JUCE_CALLTYPE operator== (const String& string1, const CharPointer_UTF8& string2) noexcept;
/** Case-sensitive comparison of two strings. */
JUCE_API bool JUCE_CALLTYPE operator== (const String& string1, const CharPointer_UTF16& string2) noexcept;
/** Case-sensitive comparison of two strings. */
JUCE_API bool JUCE_CALLTYPE operator== (const String& string1, const CharPointer_UTF32& string2) noexcept;
/** Case-sensitive comparison of two strings. */
JUCE_API bool JUCE_CALLTYPE operator!= (const String& string1, const String& string2) noexcept;
/** Case-sensitive comparison of two strings. */
JUCE_API bool JUCE_CALLTYPE operator!= (const String& string1, const char* string2) noexcept;
/** Case-sensitive comparison of two strings. */
JUCE_API bool JUCE_CALLTYPE operator!= (const String& string1, const wchar_t* string2) noexcept;
/** Case-sensitive comparison of two strings. */
JUCE_API bool JUCE_CALLTYPE operator!= (const String& string1, const CharPointer_UTF8& string2) noexcept;
/** Case-sensitive comparison of two strings. */
JUCE_API bool JUCE_CALLTYPE operator!= (const String& string1, const CharPointer_UTF16& string2) noexcept;
/** Case-sensitive comparison of two strings. */
JUCE_API bool JUCE_CALLTYPE operator!= (const String& string1, const CharPointer_UTF32& string2) noexcept;
/** Case-sensitive comparison of two strings. */
JUCE_API bool JUCE_CALLTYPE operator>  (const String& string1, const String& string2) noexcept;
/** Case-sensitive comparison of two strings. */
JUCE_API bool JUCE_CALLTYPE operator<  (const String& string1, const String& string2) noexcept;
/** Case-sensitive comparison of two strings. */
JUCE_API bool JUCE_CALLTYPE operator>= (const String& string1, const String& string2) noexcept;
/** Case-sensitive comparison of two strings. */
JUCE_API bool JUCE_CALLTYPE operator<= (const String& string1, const String& string2) noexcept;

/** This operator allows you to write a juce String directly to std output streams.
	This is handy for writing strings to std::cout, std::cerr, etc.
*/
template <class traits>
std::basic_ostream <char, traits>& JUCE_CALLTYPE operator<< (std::basic_ostream <char, traits>& stream, const String& stringToWrite)
{
	return stream << stringToWrite.toUTF8().getAddress();
}

/** This operator allows you to write a juce String directly to std output streams.
	This is handy for writing strings to std::wcout, std::wcerr, etc.
*/
template <class traits>
std::basic_ostream <wchar_t, traits>& JUCE_CALLTYPE operator<< (std::basic_ostream <wchar_t, traits>& stream, const String& stringToWrite)
{
	return stream << stringToWrite.toWideCharPointer();
}

/** Writes a string to an OutputStream as UTF8. */
JUCE_API OutputStream& JUCE_CALLTYPE operator<< (OutputStream& stream, const String& stringToWrite);

#endif   // __JUCE_STRING_JUCEHEADER__

/*** End of inlined file: juce_String.h ***/

/**
	Acts as an application-wide logging class.

	A subclass of Logger can be created and passed into the Logger::setCurrentLogger
	method and this will then be used by all calls to writeToLog.

	The logger class also contains methods for writing messages to the debugger's
	output stream.

	@see FileLogger
*/
class JUCE_API  Logger
{
public:

	/** Destructor. */
	virtual ~Logger();

	/** Sets the current logging class to use.

		Note that the object passed in won't be deleted when no longer needed.
		A null pointer can be passed-in to disable any logging.

		If deleteOldLogger is set to true, the existing logger will be
		deleted (if there is one).
	*/
	static void JUCE_CALLTYPE setCurrentLogger (Logger* newLogger,
												bool deleteOldLogger = false);

	/** Writes a string to the current logger.

		This will pass the string to the logger's logMessage() method if a logger
		has been set.

		@see logMessage
	*/
	static void JUCE_CALLTYPE writeToLog (const String& message);

	/** Writes a message to the standard error stream.

		This can be called directly, or by using the DBG() macro in
		juce_PlatformDefs.h (which will avoid calling the method in non-debug builds).
	*/
	static void JUCE_CALLTYPE outputDebugString (const String& text);

protected:

	Logger();

	/** This is overloaded by subclasses to implement custom logging behaviour.

		@see setCurrentLogger
	*/
	virtual void logMessage (const String& message) = 0;

private:
	static Logger* currentLogger;
};

#endif   // __JUCE_LOGGER_JUCEHEADER__

/*** End of inlined file: juce_Logger.h ***/


/*** Start of inlined file: juce_LeakedObjectDetector.h ***/
#ifndef __JUCE_LEAKEDOBJECTDETECTOR_JUCEHEADER__
#define __JUCE_LEAKEDOBJECTDETECTOR_JUCEHEADER__

/**
	Embedding an instance of this class inside another class can be used as a low-overhead
	way of detecting leaked instances.

	This class keeps an internal static count of the number of instances that are
	active, so that when the app is shutdown and the static destructors are called,
	it can check whether there are any left-over instances that may have been leaked.

	To use it, use the JUCE_LEAK_DETECTOR macro as a simple way to put one in your
	class declaration. Have a look through the juce codebase for examples, it's used
	in most of the classes.
*/
template <class OwnerClass>
class LeakedObjectDetector
{
public:

	LeakedObjectDetector() noexcept                                 { ++(getCounter().numObjects); }
	LeakedObjectDetector (const LeakedObjectDetector&) noexcept     { ++(getCounter().numObjects); }

	~LeakedObjectDetector()
	{
		if (--(getCounter().numObjects) < 0)
		{
			DBG ("*** Dangling pointer deletion! Class: " << getLeakedObjectClassName());

			/** If you hit this, then you've managed to delete more instances of this class than you've
				created.. That indicates that you're deleting some dangling pointers.

				Note that although this assertion will have been triggered during a destructor, it might
				not be this particular deletion that's at fault - the incorrect one may have happened
				at an earlier point in the program, and simply not been detected until now.

				Most errors like this are caused by using old-fashioned, non-RAII techniques for
				your object management. Tut, tut. Always, always use ScopedPointers, OwnedArrays,
				ReferenceCountedObjects, etc, and avoid the 'delete' operator at all costs!
			*/
			jassertfalse;
		}
	}

private:

	class LeakCounter
	{
	public:
		LeakCounter() noexcept {}

		~LeakCounter()
		{
			if (numObjects.value > 0)
			{
				DBG ("*** Leaked objects detected: " << numObjects.value << " instance(s) of class " << getLeakedObjectClassName());

				/** If you hit this, then you've leaked one or more objects of the type specified by
					the 'OwnerClass' template parameter - the name should have been printed by the line above.

					If you're leaking, it's probably because you're using old-fashioned, non-RAII techniques for
					your object management. Tut, tut. Always, always use ScopedPointers, OwnedArrays,
					ReferenceCountedObjects, etc, and avoid the 'delete' operator at all costs!
				*/
				jassertfalse;
			}
		}

		Atomic<int> numObjects;
	};

	static const char* getLeakedObjectClassName()
	{
		return OwnerClass::getLeakedObjectClassName();
	}

	static LeakCounter& getCounter() noexcept
	{
		static LeakCounter counter;
		return counter;
	}
};

#if DOXYGEN || ! defined (JUCE_LEAK_DETECTOR)
 #if (DOXYGEN || JUCE_CHECK_MEMORY_LEAKS)
  /** This macro lets you embed a leak-detecting object inside a class.

	  To use it, simply declare a JUCE_LEAK_DETECTOR(YourClassName) inside a private section
	  of the class declaration. E.g.

	  @code
	  class MyClass
	  {
	  public:
		  MyClass();
		  void blahBlah();

	  private:
		  JUCE_LEAK_DETECTOR (MyClass);
	  };@endcode

	  @see JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR, LeakedObjectDetector
  */
  #define JUCE_LEAK_DETECTOR(OwnerClass) \
		friend class juce::LeakedObjectDetector<OwnerClass>; \
		static const char* getLeakedObjectClassName() noexcept { return #OwnerClass; } \
		juce::LeakedObjectDetector<OwnerClass> JUCE_JOIN_MACRO (leakDetector, __LINE__);
 #else
  #define JUCE_LEAK_DETECTOR(OwnerClass)
 #endif
#endif

#endif   // __JUCE_LEAKEDOBJECTDETECTOR_JUCEHEADER__

/*** End of inlined file: juce_LeakedObjectDetector.h ***/

// unbelievably, some system headers actually use macros to define these symbols:
#undef check
#undef TYPE_BOOL

#if JUCE_MAC || JUCE_IOS || DOXYGEN

 /** A handy C++ wrapper that creates and deletes an NSAutoreleasePool object using RAII.
	 You should use the JUCE_AUTORELEASEPOOL macro to create a local auto-release pool on the stack.
 */
 class JUCE_API  ScopedAutoReleasePool
 {
 public:
	 ScopedAutoReleasePool();
	 ~ScopedAutoReleasePool();

 private:
	 void* pool;

	 JUCE_DECLARE_NON_COPYABLE (ScopedAutoReleasePool);
 };

 /** A macro that can be used to easily declare a local ScopedAutoReleasePool object for RAII-based obj-C autoreleasing. */
 #define JUCE_AUTORELEASEPOOL  const juce::ScopedAutoReleasePool JUCE_JOIN_MACRO (autoReleasePool_, __LINE__);

#else
 #define JUCE_AUTORELEASEPOOL
#endif

END_JUCE_NAMESPACE

#endif   // __JUCE_STANDARDHEADER_JUCEHEADER__

/*** End of inlined file: juce_StandardHeader.h ***/

namespace juce
{

// START_AUTOINCLUDE containers, files, json, logging, maths, memory, misc, network,
// streams, system, text, threads, time, unit_tests, xml, zip
#ifndef __JUCE_ABSTRACTFIFO_JUCEHEADER__

/*** Start of inlined file: juce_AbstractFifo.h ***/
#ifndef __JUCE_ABSTRACTFIFO_JUCEHEADER__
#define __JUCE_ABSTRACTFIFO_JUCEHEADER__

/**
	Encapsulates the logic required to implement a lock-free FIFO.

	This class handles the logic needed when building a single-reader, single-writer FIFO.

	It doesn't actually hold any data itself, but your FIFO class can use one of these to manage
	its position and status when reading or writing to it.

	To use it, you can call prepareToWrite() to determine the position within your own buffer that
	an incoming block of data should be stored, and prepareToRead() to find out when the next
	outgoing block should be read from.

	e.g.
	@code
	class MyFifo
	{
	public:
		MyFifo()  : abstractFifo (1024)
		{
		}

		void addToFifo (const int* someData, int numItems)
		{
			int start1, size1, start2, size2;
			abstractFifo.prepareToWrite (numItems, start1, size1, start2, size2);

			if (size1 > 0)
				copySomeData (myBuffer + start1, someData, size1);

			if (size2 > 0)
				copySomeData (myBuffer + start2, someData + size1, size2);

			abstractFifo.finishedWrite (size1 + size2);
		}

		void readFromFifo (int* someData, int numItems)
		{
			int start1, size1, start2, size2;
			abstractFifo.prepareToRead (numSamples, start1, size1, start2, size2);

			if (size1 > 0)
				copySomeData (someData, myBuffer + start1, size1);

			if (size2 > 0)
				copySomeData (someData + size1, myBuffer + start2, size2);

			abstractFifo.finishedRead (size1 + size2);
		}

	private:
		AbstractFifo abstractFifo;
		int myBuffer [1024];
	};
	@endcode
*/
class JUCE_API  AbstractFifo
{
public:

	/** Creates a FIFO to manage a buffer with the specified capacity. */
	AbstractFifo (int capacity) noexcept;

	/** Destructor */
	~AbstractFifo();

	/** Returns the total size of the buffer being managed. */
	int getTotalSize() const noexcept;

	/** Returns the number of items that can currently be added to the buffer without it overflowing. */
	int getFreeSpace() const noexcept;

	/** Returns the number of items that can currently be read from the buffer. */
	int getNumReady() const noexcept;

	/** Clears the buffer positions, so that it appears empty. */
	void reset() noexcept;

	/** Changes the buffer's total size.
		Note that this isn't thread-safe, so don't call it if there's any danger that it
		might overlap with a call to any other method in this class!
	*/
	void setTotalSize (int newSize) noexcept;

	/** Returns the location within the buffer at which an incoming block of data should be written.

		Because the section of data that you want to add to the buffer may overlap the end
		and wrap around to the start, two blocks within your buffer are returned, and you
		should copy your data into the first one, with any remaining data spilling over into
		the second.

		If the number of items you ask for is too large to fit within the buffer's free space, then
		blockSize1 + blockSize2 may add up to a lower value than numToWrite. If this happens, you
		may decide to keep waiting and re-trying the method until there's enough space available.

		After calling this method, if you choose to write your data into the blocks returned, you
		must call finishedWrite() to tell the FIFO how much data you actually added.

		e.g.
		@code
		void addToFifo (const int* someData, int numItems)
		{
			int start1, size1, start2, size2;
			prepareToWrite (numItems, start1, size1, start2, size2);

			if (size1 > 0)
				copySomeData (myBuffer + start1, someData, size1);

			if (size2 > 0)
				copySomeData (myBuffer + start2, someData + size1, size2);

			finishedWrite (size1 + size2);
		}
		@endcode

		@param numToWrite       indicates how many items you'd like to add to the buffer
		@param startIndex1      on exit, this will contain the start index in your buffer at which your data should be written
		@param blockSize1       on exit, this indicates how many items can be written to the block starting at startIndex1
		@param startIndex2      on exit, this will contain the start index in your buffer at which any data that didn't fit into
								the first block should be written
		@param blockSize2       on exit, this indicates how many items can be written to the block starting at startIndex2
		@see finishedWrite
	*/
	void prepareToWrite (int numToWrite, int& startIndex1, int& blockSize1, int& startIndex2, int& blockSize2) const noexcept;

	/** Called after reading from the FIFO, to indicate that this many items have been added.
		@see prepareToWrite
	*/
	void finishedWrite (int numWritten) noexcept;

	/** Returns the location within the buffer from which the next block of data should be read.

		Because the section of data that you want to read from the buffer may overlap the end
		and wrap around to the start, two blocks within your buffer are returned, and you
		should read from both of them.

		If the number of items you ask for is greater than the amount of data available, then
		blockSize1 + blockSize2 may add up to a lower value than numWanted. If this happens, you
		may decide to keep waiting and re-trying the method until there's enough data available.

		After calling this method, if you choose to read the data, you must call finishedRead() to
		tell the FIFO how much data you have consumed.

		e.g.
		@code
		void readFromFifo (int* someData, int numItems)
		{
			int start1, size1, start2, size2;
			prepareToRead (numSamples, start1, size1, start2, size2);

			if (size1 > 0)
				copySomeData (someData, myBuffer + start1, size1);

			if (size2 > 0)
				copySomeData (someData + size1, myBuffer + start2, size2);

			finishedRead (size1 + size2);
		}
		@endcode

		@param numWanted        indicates how many items you'd like to add to the buffer
		@param startIndex1      on exit, this will contain the start index in your buffer at which your data should be written
		@param blockSize1       on exit, this indicates how many items can be written to the block starting at startIndex1
		@param startIndex2      on exit, this will contain the start index in your buffer at which any data that didn't fit into
								the first block should be written
		@param blockSize2       on exit, this indicates how many items can be written to the block starting at startIndex2
		@see finishedRead
	*/
	void prepareToRead (int numWanted, int& startIndex1, int& blockSize1, int& startIndex2, int& blockSize2) const noexcept;

	/** Called after reading from the FIFO, to indicate that this many items have now been consumed.
		@see prepareToRead
	*/
	void finishedRead (int numRead) noexcept;

private:

	int bufferSize;
	Atomic <int> validStart, validEnd;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (AbstractFifo);
};

#endif   // __JUCE_ABSTRACTFIFO_JUCEHEADER__

/*** End of inlined file: juce_AbstractFifo.h ***/


#endif
#ifndef __JUCE_ARRAY_JUCEHEADER__

/*** Start of inlined file: juce_Array.h ***/
#ifndef __JUCE_ARRAY_JUCEHEADER__
#define __JUCE_ARRAY_JUCEHEADER__


/*** Start of inlined file: juce_ArrayAllocationBase.h ***/
#ifndef __JUCE_ARRAYALLOCATIONBASE_JUCEHEADER__
#define __JUCE_ARRAYALLOCATIONBASE_JUCEHEADER__


/*** Start of inlined file: juce_HeapBlock.h ***/
#ifndef __JUCE_HEAPBLOCK_JUCEHEADER__
#define __JUCE_HEAPBLOCK_JUCEHEADER__

#ifndef DOXYGEN
namespace HeapBlockHelper
{
	template <bool shouldThrow>
	struct ThrowOnFail          { static void check (void*) {} };

	template<>
	struct ThrowOnFail <true>   { static void check (void* data) { if (data == nullptr) throw std::bad_alloc(); } };
}
#endif

/**
	Very simple container class to hold a pointer to some data on the heap.

	When you need to allocate some heap storage for something, always try to use
	this class instead of allocating the memory directly using malloc/free.

	A HeapBlock<char> object can be treated in pretty much exactly the same way
	as an char*, but as long as you allocate it on the stack or as a class member,
	it's almost impossible for it to leak memory.

	It also makes your code much more concise and readable than doing the same thing
	using direct allocations,

	E.g. instead of this:
	@code
		int* temp = (int*) malloc (1024 * sizeof (int));
		memcpy (temp, xyz, 1024 * sizeof (int));
		free (temp);
		temp = (int*) calloc (2048 * sizeof (int));
		temp[0] = 1234;
		memcpy (foobar, temp, 2048 * sizeof (int));
		free (temp);
	@endcode

	..you could just write this:
	@code
		HeapBlock <int> temp (1024);
		memcpy (temp, xyz, 1024 * sizeof (int));
		temp.calloc (2048);
		temp[0] = 1234;
		memcpy (foobar, temp, 2048 * sizeof (int));
	@endcode

	The class is extremely lightweight, containing only a pointer to the
	data, and exposes malloc/realloc/calloc/free methods that do the same jobs
	as their less object-oriented counterparts. Despite adding safety, you probably
	won't sacrifice any performance by using this in place of normal pointers.

	The throwOnFailure template parameter can be set to true if you'd like the class
	to throw a std::bad_alloc exception when an allocation fails. If this is false,
	then a failed allocation will just leave the heapblock with a null pointer (assuming
	that the system's malloc() function doesn't throw).

	@see Array, OwnedArray, MemoryBlock
*/
template <class ElementType, bool throwOnFailure = false>
class HeapBlock
{
public:

	/** Creates a HeapBlock which is initially just a null pointer.

		After creation, you can resize the array using the malloc(), calloc(),
		or realloc() methods.
	*/
	HeapBlock() noexcept  : data (nullptr)
	{
	}

	/** Creates a HeapBlock containing a number of elements.

		The contents of the block are undefined, as it will have been created by a
		malloc call.

		If you want an array of zero values, you can use the calloc() method instead.
	*/
	explicit HeapBlock (const size_t numElements)
		: data (static_cast <ElementType*> (::malloc (numElements * sizeof (ElementType))))
	{
		throwOnAllocationFailure();
	}

	/** Destructor.

		This will free the data, if any has been allocated.
	*/
	~HeapBlock()
	{
		::free (data);
	}

   #if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
	HeapBlock (HeapBlock&& other) noexcept
		: data (other.data)
	{
		other.data = nullptr;
	}

	HeapBlock& operator= (HeapBlock&& other) noexcept
	{
		std::swap (data, other.data);
		return *this;
	}
   #endif

	/** Returns a raw pointer to the allocated data.
		This may be a null pointer if the data hasn't yet been allocated, or if it has been
		freed by calling the free() method.
	*/
	inline operator ElementType*() const noexcept                           { return data; }

	/** Returns a raw pointer to the allocated data.
		This may be a null pointer if the data hasn't yet been allocated, or if it has been
		freed by calling the free() method.
	*/
	inline ElementType* getData() const noexcept                            { return data; }

	/** Returns a void pointer to the allocated data.
		This may be a null pointer if the data hasn't yet been allocated, or if it has been
		freed by calling the free() method.
	*/
	inline operator void*() const noexcept                                  { return static_cast <void*> (data); }

	/** Returns a void pointer to the allocated data.
		This may be a null pointer if the data hasn't yet been allocated, or if it has been
		freed by calling the free() method.
	*/
	inline operator const void*() const noexcept                            { return static_cast <const void*> (data); }

	/** Lets you use indirect calls to the first element in the array.
		Obviously this will cause problems if the array hasn't been initialised, because it'll
		be referencing a null pointer.
	*/
	inline ElementType* operator->() const  noexcept                        { return data; }

	/** Returns a reference to one of the data elements.
		Obviously there's no bounds-checking here, as this object is just a dumb pointer and
		has no idea of the size it currently has allocated.
	*/
	template <typename IndexType>
	inline ElementType& operator[] (IndexType index) const noexcept         { return data [index]; }

	/** Returns a pointer to a data element at an offset from the start of the array.
		This is the same as doing pointer arithmetic on the raw pointer itself.
	*/
	template <typename IndexType>
	inline ElementType* operator+ (IndexType index) const noexcept          { return data + index; }

	/** Compares the pointer with another pointer.
		This can be handy for checking whether this is a null pointer.
	*/
	inline bool operator== (const ElementType* const otherPointer) const noexcept   { return otherPointer == data; }

	/** Compares the pointer with another pointer.
		This can be handy for checking whether this is a null pointer.
	*/
	inline bool operator!= (const ElementType* const otherPointer) const noexcept   { return otherPointer != data; }

	/** Allocates a specified amount of memory.

		This uses the normal malloc to allocate an amount of memory for this object.
		Any previously allocated memory will be freed by this method.

		The number of bytes allocated will be (newNumElements * elementSize). Normally
		you wouldn't need to specify the second parameter, but it can be handy if you need
		to allocate a size in bytes rather than in terms of the number of elements.

		The data that is allocated will be freed when this object is deleted, or when you
		call free() or any of the allocation methods.
	*/
	void malloc (const size_t newNumElements, const size_t elementSize = sizeof (ElementType))
	{
		::free (data);
		data = static_cast <ElementType*> (::malloc (newNumElements * elementSize));
		throwOnAllocationFailure();
	}

	/** Allocates a specified amount of memory and clears it.
		This does the same job as the malloc() method, but clears the memory that it allocates.
	*/
	void calloc (const size_t newNumElements, const size_t elementSize = sizeof (ElementType))
	{
		::free (data);
		data = static_cast <ElementType*> (::calloc (newNumElements, elementSize));
		throwOnAllocationFailure();
	}

	/** Allocates a specified amount of memory and optionally clears it.
		This does the same job as either malloc() or calloc(), depending on the
		initialiseToZero parameter.
	*/
	void allocate (const size_t newNumElements, const bool initialiseToZero)
	{
		::free (data);

		if (initialiseToZero)
			data = static_cast <ElementType*> (::calloc (newNumElements, sizeof (ElementType)));
		else
			data = static_cast <ElementType*> (::malloc (newNumElements * sizeof (ElementType)));

		throwOnAllocationFailure();
	}

	/** Re-allocates a specified amount of memory.

		The semantics of this method are the same as malloc() and calloc(), but it
		uses realloc() to keep as much of the existing data as possible.
	*/
	void realloc (const size_t newNumElements, const size_t elementSize = sizeof (ElementType))
	{
		if (data == nullptr)
			data = static_cast <ElementType*> (::malloc (newNumElements * elementSize));
		else
			data = static_cast <ElementType*> (::realloc (data, newNumElements * elementSize));

		throwOnAllocationFailure();
	}

	/** Frees any currently-allocated data.
		This will free the data and reset this object to be a null pointer.
	*/
	void free()
	{
		::free (data);
		data = nullptr;
	}

	/** Swaps this object's data with the data of another HeapBlock.
		The two objects simply exchange their data pointers.
	*/
	template <bool otherBlockThrows>
	void swapWith (HeapBlock <ElementType, otherBlockThrows>& other) noexcept
	{
		std::swap (data, other.data);
	}

	/** This fills the block with zeros, up to the number of elements specified.
		Since the block has no way of knowing its own size, you must make sure that the number of
		elements you specify doesn't exceed the allocated size.
	*/
	void clear (size_t numElements) noexcept
	{
		zeromem (data, sizeof (ElementType) * numElements);
	}

private:

	ElementType* data;

	void throwOnAllocationFailure() const
	{
		HeapBlockHelper::ThrowOnFail<throwOnFailure>::check (data);
	}

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (HeapBlock);

	JUCE_PREVENT_HEAP_ALLOCATION; // Creating a 'new HeapBlock' would be missing the point!
};

#endif   // __JUCE_HEAPBLOCK_JUCEHEADER__

/*** End of inlined file: juce_HeapBlock.h ***/

/**
	Implements some basic array storage allocation functions.

	This class isn't really for public use - it's used by the other
	array classes, but might come in handy for some purposes.

	It inherits from a critical section class to allow the arrays to use
	the "empty base class optimisation" pattern to reduce their footprint.

	@see Array, OwnedArray, ReferenceCountedArray
*/
template <class ElementType, class TypeOfCriticalSectionToUse>
class ArrayAllocationBase  : public TypeOfCriticalSectionToUse
{
public:

	/** Creates an empty array. */
	ArrayAllocationBase() noexcept
		: numAllocated (0)
	{
	}

	/** Destructor. */
	~ArrayAllocationBase() noexcept
	{
	}

   #if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
	ArrayAllocationBase (ArrayAllocationBase<ElementType, TypeOfCriticalSectionToUse>&& other) noexcept
		: elements (static_cast <HeapBlock <ElementType>&&> (other.elements)),
		  numAllocated (other.numAllocated)
	{
	}

	ArrayAllocationBase& operator= (ArrayAllocationBase<ElementType, TypeOfCriticalSectionToUse>&& other) noexcept
	{
		elements = static_cast <HeapBlock <ElementType>&&> (other.elements);
		numAllocated = other.numAllocated;
		return *this;
	}
   #endif

	/** Changes the amount of storage allocated.

		This will retain any data currently held in the array, and either add or
		remove extra space at the end.

		@param numElements  the number of elements that are needed
	*/
	void setAllocatedSize (const int numElements)
	{
		if (numAllocated != numElements)
		{
			if (numElements > 0)
				elements.realloc ((size_t) numElements);
			else
				elements.free();

			numAllocated = numElements;
		}
	}

	/** Increases the amount of storage allocated if it is less than a given amount.

		This will retain any data currently held in the array, but will add
		extra space at the end to make sure there it's at least as big as the size
		passed in. If it's already bigger, no action is taken.

		@param minNumElements  the minimum number of elements that are needed
	*/
	void ensureAllocatedSize (const int minNumElements)
	{
		if (minNumElements > numAllocated)
			setAllocatedSize ((minNumElements + minNumElements / 2 + 8) & ~7);
	}

	/** Minimises the amount of storage allocated so that it's no more than
		the given number of elements.
	*/
	void shrinkToNoMoreThan (const int maxNumElements)
	{
		if (maxNumElements < numAllocated)
			setAllocatedSize (maxNumElements);
	}

	/** Swap the contents of two objects. */
	void swapWith (ArrayAllocationBase <ElementType, TypeOfCriticalSectionToUse>& other) noexcept
	{
		elements.swapWith (other.elements);
		std::swap (numAllocated, other.numAllocated);
	}

	HeapBlock <ElementType> elements;
	int numAllocated;

private:
	JUCE_DECLARE_NON_COPYABLE (ArrayAllocationBase);
};

#endif   // __JUCE_ARRAYALLOCATIONBASE_JUCEHEADER__

/*** End of inlined file: juce_ArrayAllocationBase.h ***/


/*** Start of inlined file: juce_ElementComparator.h ***/
#ifndef __JUCE_ELEMENTCOMPARATOR_JUCEHEADER__
#define __JUCE_ELEMENTCOMPARATOR_JUCEHEADER__

/**
	Sorts a range of elements in an array.

	The comparator object that is passed-in must define a public method with the following
	signature:
	@code
	int compareElements (ElementType first, ElementType second);
	@endcode

	..and this method must return:
	  - a value of < 0 if the first comes before the second
	  - a value of 0 if the two objects are equivalent
	  - a value of > 0 if the second comes before the first

	To improve performance, the compareElements() method can be declared as static or const.

	@param comparator       an object which defines a compareElements() method
	@param array            the array to sort
	@param firstElement     the index of the first element of the range to be sorted
	@param lastElement      the index of the last element in the range that needs
							sorting (this is inclusive)
	@param retainOrderOfEquivalentItems     if true, the order of items that the
							comparator deems the same will be maintained - this will be
							a slower algorithm than if they are allowed to be moved around.

	@see sortArrayRetainingOrder
*/
template <class ElementType, class ElementComparator>
static void sortArray (ElementComparator& comparator,
					   ElementType* const array,
					   int firstElement,
					   int lastElement,
					   const bool retainOrderOfEquivalentItems)
{
	(void) comparator;  // if you pass in an object with a static compareElements() method, this
						// avoids getting warning messages about the parameter being unused

	if (lastElement > firstElement)
	{
		if (retainOrderOfEquivalentItems)
		{
			for (int i = firstElement; i < lastElement; ++i)
			{
				if (comparator.compareElements (array[i], array [i + 1]) > 0)
				{
					std::swap (array[i], array[i + 1]);

					if (i > firstElement)
						i -= 2;
				}
			}
		}
		else
		{
			int fromStack[30], toStack[30];
			int stackIndex = 0;

			for (;;)
			{
				const int size = (lastElement - firstElement) + 1;

				if (size <= 8)
				{
					int j = lastElement;
					int maxIndex;

					while (j > firstElement)
					{
						maxIndex = firstElement;
						for (int k = firstElement + 1; k <= j; ++k)
							if (comparator.compareElements (array[k], array [maxIndex]) > 0)
								maxIndex = k;

						std::swap (array[j], array[maxIndex]);
						--j;
					}
				}
				else
				{
					const int mid = firstElement + (size >> 1);
					std::swap (array[mid], array[firstElement]);

					int i = firstElement;
					int j = lastElement + 1;

					for (;;)
					{
						while (++i <= lastElement
								&& comparator.compareElements (array[i], array [firstElement]) <= 0)
						{}

						while (--j > firstElement
								&& comparator.compareElements (array[j], array [firstElement]) >= 0)
						{}

						if (j < i)
							break;

						std::swap (array[i], array[j]);
					}

					std::swap (array[j], array[firstElement]);

					if (j - 1 - firstElement >= lastElement - i)
					{
						if (firstElement + 1 < j)
						{
							fromStack [stackIndex] = firstElement;
							toStack [stackIndex] = j - 1;
							++stackIndex;
						}

						if (i < lastElement)
						{
							firstElement = i;
							continue;
						}
					}
					else
					{
						if (i < lastElement)
						{
							fromStack [stackIndex] = i;
							toStack [stackIndex] = lastElement;
							++stackIndex;
						}

						if (firstElement + 1 < j)
						{
							lastElement = j - 1;
							continue;
						}
					}
				}

				if (--stackIndex < 0)
					break;

				jassert (stackIndex < numElementsInArray (fromStack));

				firstElement = fromStack [stackIndex];
				lastElement = toStack [stackIndex];
			}
		}
	}
}

/**
	Searches a sorted array of elements, looking for the index at which a specified value
	should be inserted for it to be in the correct order.

	The comparator object that is passed-in must define a public method with the following
	signature:
	@code
	int compareElements (ElementType first, ElementType second);
	@endcode

	..and this method must return:
	  - a value of < 0 if the first comes before the second
	  - a value of 0 if the two objects are equivalent
	  - a value of > 0 if the second comes before the first

	To improve performance, the compareElements() method can be declared as static or const.

	@param comparator       an object which defines a compareElements() method
	@param array            the array to search
	@param newElement       the value that is going to be inserted
	@param firstElement     the index of the first element to search
	@param lastElement      the index of the last element in the range (this is non-inclusive)
*/
template <class ElementType, class ElementComparator>
static int findInsertIndexInSortedArray (ElementComparator& comparator,
										 ElementType* const array,
										 const ElementType newElement,
										 int firstElement,
										 int lastElement)
{
	jassert (firstElement <= lastElement);

	(void) comparator;  // if you pass in an object with a static compareElements() method, this
						// avoids getting warning messages about the parameter being unused

	while (firstElement < lastElement)
	{
		if (comparator.compareElements (newElement, array [firstElement]) == 0)
		{
			++firstElement;
			break;
		}
		else
		{
			const int halfway = (firstElement + lastElement) >> 1;

			if (halfway == firstElement)
			{
				if (comparator.compareElements (newElement, array [halfway]) >= 0)
					++firstElement;

				break;
			}
			else if (comparator.compareElements (newElement, array [halfway]) >= 0)
			{
				firstElement = halfway;
			}
			else
			{
				lastElement = halfway;
			}
		}
	}

	return firstElement;
}

/**
	A simple ElementComparator class that can be used to sort an array of
	objects that support the '<' operator.

	This will work for primitive types and objects that implement operator<().

	Example: @code
	Array <int> myArray;
	DefaultElementComparator<int> sorter;
	myArray.sort (sorter);
	@endcode

	@see ElementComparator
*/
template <class ElementType>
class DefaultElementComparator
{
private:
	typedef PARAMETER_TYPE (ElementType) ParameterType;

public:
	static int compareElements (ParameterType first, ParameterType second)
	{
		return (first < second) ? -1 : ((second < first) ? 1 : 0);
	}
};

#endif   // __JUCE_ELEMENTCOMPARATOR_JUCEHEADER__

/*** End of inlined file: juce_ElementComparator.h ***/


/*** Start of inlined file: juce_CriticalSection.h ***/
#ifndef __JUCE_CRITICALSECTION_JUCEHEADER__
#define __JUCE_CRITICALSECTION_JUCEHEADER__


/*** Start of inlined file: juce_ScopedLock.h ***/
#ifndef __JUCE_SCOPEDLOCK_JUCEHEADER__
#define __JUCE_SCOPEDLOCK_JUCEHEADER__

/**
	Automatically locks and unlocks a mutex object.

	Use one of these as a local variable to provide RAII-based locking of a mutex.

	The templated class could be a CriticalSection, SpinLock, or anything else that
	provides enter() and exit() methods.

	e.g. @code
	CriticalSection myCriticalSection;

	for (;;)
	{
		const GenericScopedLock<CriticalSection> myScopedLock (myCriticalSection);
		// myCriticalSection is now locked

		...do some stuff...

		// myCriticalSection gets unlocked here.
	}
	@endcode

	@see GenericScopedUnlock, CriticalSection, SpinLock, ScopedLock, ScopedUnlock
*/
template <class LockType>
class GenericScopedLock
{
public:

	/** Creates a GenericScopedLock.

		As soon as it is created, this will acquire the lock, and when the GenericScopedLock
		object is deleted, the lock will be released.

		Make sure this object is created and deleted by the same thread,
		otherwise there are no guarantees what will happen! Best just to use it
		as a local stack object, rather than creating one with the new() operator.
	*/
	inline explicit GenericScopedLock (const LockType& lock) noexcept : lock_ (lock)     { lock.enter(); }

	/** Destructor.
		The lock will be released when the destructor is called.
		Make sure this object is created and deleted by the same thread, otherwise there are
		no guarantees what will happen!
	*/
	inline ~GenericScopedLock() noexcept                                                 { lock_.exit(); }

private:

	const LockType& lock_;

	JUCE_DECLARE_NON_COPYABLE (GenericScopedLock);
};

/**
	Automatically unlocks and re-locks a mutex object.

	This is the reverse of a GenericScopedLock object - instead of locking the mutex
	for the lifetime of this object, it unlocks it.

	Make sure you don't try to unlock mutexes that aren't actually locked!

	e.g. @code

	CriticalSection myCriticalSection;

	for (;;)
	{
		const GenericScopedLock<CriticalSection> myScopedLock (myCriticalSection);
		// myCriticalSection is now locked

		... do some stuff with it locked ..

		while (xyz)
		{
			... do some stuff with it locked ..

			const GenericScopedUnlock<CriticalSection> unlocker (myCriticalSection);

			// myCriticalSection is now unlocked for the remainder of this block,
			// and re-locked at the end.

			...do some stuff with it unlocked ...
		}

		// myCriticalSection gets unlocked here.
	}
	@endcode

	@see GenericScopedLock, CriticalSection, ScopedLock, ScopedUnlock
*/
template <class LockType>
class GenericScopedUnlock
{
public:

	/** Creates a GenericScopedUnlock.

		As soon as it is created, this will unlock the CriticalSection, and
		when the ScopedLock object is deleted, the CriticalSection will
		be re-locked.

		Make sure this object is created and deleted by the same thread,
		otherwise there are no guarantees what will happen! Best just to use it
		as a local stack object, rather than creating one with the new() operator.
	*/
	inline explicit GenericScopedUnlock (const LockType& lock) noexcept : lock_ (lock)   { lock.exit(); }

	/** Destructor.

		The CriticalSection will be unlocked when the destructor is called.

		Make sure this object is created and deleted by the same thread,
		otherwise there are no guarantees what will happen!
	*/
	inline ~GenericScopedUnlock() noexcept                                               { lock_.enter(); }

private:

	const LockType& lock_;

	JUCE_DECLARE_NON_COPYABLE (GenericScopedUnlock);
};

/**
	Automatically locks and unlocks a mutex object.

	Use one of these as a local variable to provide RAII-based locking of a mutex.

	The templated class could be a CriticalSection, SpinLock, or anything else that
	provides enter() and exit() methods.

	e.g. @code

	CriticalSection myCriticalSection;

	for (;;)
	{
		const GenericScopedTryLock<CriticalSection> myScopedTryLock (myCriticalSection);

		// Unlike using a ScopedLock, this may fail to actually get the lock, so you
		// should test this with the isLocked() method before doing your thread-unsafe
		// action..
		if (myScopedTryLock.isLocked())
		{
		   ...do some stuff...
		}
		else
		{
			..our attempt at locking failed because another thread had already locked it..
		}

		// myCriticalSection gets unlocked here (if it was locked)
	}
	@endcode

	@see CriticalSection::tryEnter, GenericScopedLock, GenericScopedUnlock
*/
template <class LockType>
class GenericScopedTryLock
{
public:

	/** Creates a GenericScopedTryLock.

		As soon as it is created, this will attempt to acquire the lock, and when the
		GenericScopedTryLock is deleted, the lock will be released (if the lock was
		successfully acquired).

		Make sure this object is created and deleted by the same thread,
		otherwise there are no guarantees what will happen! Best just to use it
		as a local stack object, rather than creating one with the new() operator.
	*/
	inline explicit GenericScopedTryLock (const LockType& lock) noexcept
		: lock_ (lock), lockWasSuccessful (lock.tryEnter()) {}

	/** Destructor.

		The mutex will be unlocked (if it had been successfully locked) when the
		destructor is called.

		Make sure this object is created and deleted by the same thread,
		otherwise there are no guarantees what will happen!
	*/
	inline ~GenericScopedTryLock() noexcept         { if (lockWasSuccessful) lock_.exit(); }

	/** Returns true if the mutex was successfully locked. */
	bool isLocked() const noexcept                  { return lockWasSuccessful; }

private:

	const LockType& lock_;
	const bool lockWasSuccessful;

	JUCE_DECLARE_NON_COPYABLE (GenericScopedTryLock);
};

#endif   // __JUCE_SCOPEDLOCK_JUCEHEADER__

/*** End of inlined file: juce_ScopedLock.h ***/

/**
	A mutex class.

	A CriticalSection acts as a re-entrant mutex lock. The best way to lock and unlock
	one of these is by using RAII in the form of a local ScopedLock object - have a look
	through the codebase for many examples of how to do this.

	@see ScopedLock, ScopedTryLock, ScopedUnlock, SpinLock, ReadWriteLock, Thread, InterProcessLock
*/
class JUCE_API  CriticalSection
{
public:

	/** Creates a CriticalSection object. */
	CriticalSection() noexcept;

	/** Destructor.
		If the critical section is deleted whilst locked, any subsequent behaviour
		is unpredictable.
	*/
	~CriticalSection() noexcept;

	/** Acquires the lock.

		If the lock is already held by the caller thread, the method returns immediately.
		If the lock is currently held by another thread, this will wait until it becomes free.

		It's strongly recommended that you never call this method directly - instead use the
		ScopedLock class to manage the locking using an RAII pattern instead.

		@see exit, tryEnter, ScopedLock
	*/
	void enter() const noexcept;

	/** Attempts to lock this critical section without blocking.

		This method behaves identically to CriticalSection::enter, except that the caller thread
		does not wait if the lock is currently held by another thread but returns false immediately.

		@returns false if the lock is currently held by another thread, true otherwise.
		@see enter
	*/
	bool tryEnter() const noexcept;

	/** Releases the lock.

		If the caller thread hasn't got the lock, this can have unpredictable results.

		If the enter() method has been called multiple times by the thread, each
		call must be matched by a call to exit() before other threads will be allowed
		to take over the lock.

		@see enter, ScopedLock
	*/
	void exit() const noexcept;

	/** Provides the type of scoped lock to use with a CriticalSection. */
	typedef GenericScopedLock <CriticalSection>       ScopedLockType;

	/** Provides the type of scoped unlocker to use with a CriticalSection. */
	typedef GenericScopedUnlock <CriticalSection>     ScopedUnlockType;

	/** Provides the type of scoped try-locker to use with a CriticalSection. */
	typedef GenericScopedTryLock <CriticalSection>    ScopedTryLockType;

private:

   #if JUCE_WINDOWS
	// To avoid including windows.h in the public JUCE headers, we'll just allocate a
	// block of memory here that's big enough to be used internally as a windows critical
	// section structure.
	#if JUCE_64BIT
	 uint8 internal [44];
	#else
	 uint8 internal [24];
	#endif
   #else
	mutable pthread_mutex_t internal;
   #endif

	JUCE_DECLARE_NON_COPYABLE (CriticalSection);
};

/**
	A class that can be used in place of a real CriticalSection object, but which
	doesn't perform any locking.

	This is currently used by some templated classes, and most compilers should
	manage to optimise it out of existence.

	@see CriticalSection, Array, OwnedArray, ReferenceCountedArray
*/
class JUCE_API  DummyCriticalSection
{
public:
	inline DummyCriticalSection() noexcept      {}
	inline ~DummyCriticalSection() noexcept     {}

	inline void enter() const noexcept          {}
	inline bool tryEnter() const noexcept       { return true; }
	inline void exit() const noexcept           {}

	/** A dummy scoped-lock type to use with a dummy critical section. */
	struct ScopedLockType
	{
		ScopedLockType (const DummyCriticalSection&) noexcept {}
	};

	/** A dummy scoped-unlocker type to use with a dummy critical section. */
	typedef ScopedLockType ScopedUnlockType;

private:
	JUCE_DECLARE_NON_COPYABLE (DummyCriticalSection);
};

/**
	Automatically locks and unlocks a CriticalSection object.

	Use one of these as a local variable to provide RAII-based locking of a CriticalSection.

	e.g. @code

	CriticalSection myCriticalSection;

	for (;;)
	{
		const ScopedLock myScopedLock (myCriticalSection);
		// myCriticalSection is now locked

		...do some stuff...

		// myCriticalSection gets unlocked here.
	}
	@endcode

	@see CriticalSection, ScopedUnlock
*/
typedef CriticalSection::ScopedLockType  ScopedLock;

/**
	Automatically unlocks and re-locks a CriticalSection object.

	This is the reverse of a ScopedLock object - instead of locking the critical
	section for the lifetime of this object, it unlocks it.

	Make sure you don't try to unlock critical sections that aren't actually locked!

	e.g. @code

	CriticalSection myCriticalSection;

	for (;;)
	{
		const ScopedLock myScopedLock (myCriticalSection);
		// myCriticalSection is now locked

		... do some stuff with it locked ..

		while (xyz)
		{
			... do some stuff with it locked ..

			const ScopedUnlock unlocker (myCriticalSection);

			// myCriticalSection is now unlocked for the remainder of this block,
			// and re-locked at the end.

			...do some stuff with it unlocked ...
		}

		// myCriticalSection gets unlocked here.
	}
	@endcode

	@see CriticalSection, ScopedLock
*/
typedef CriticalSection::ScopedUnlockType  ScopedUnlock;

/**
	Automatically tries to lock and unlock a CriticalSection object.

	Use one of these as a local variable to control access to a CriticalSection.

	e.g. @code
	CriticalSection myCriticalSection;

	for (;;)
	{
		const ScopedTryLock myScopedTryLock (myCriticalSection);

		// Unlike using a ScopedLock, this may fail to actually get the lock, so you
		// should test this with the isLocked() method before doing your thread-unsafe
		// action..
		if (myScopedTryLock.isLocked())
		{
		   ...do some stuff...
		}
		else
		{
			..our attempt at locking failed because another thread had already locked it..
		}

		// myCriticalSection gets unlocked here (if it was locked)
	}
	@endcode

	@see CriticalSection::tryEnter, ScopedLock, ScopedUnlock, ScopedReadLock
*/
typedef CriticalSection::ScopedTryLockType  ScopedTryLock;

#endif   // __JUCE_CRITICALSECTION_JUCEHEADER__

/*** End of inlined file: juce_CriticalSection.h ***/

/**
	Holds a resizable array of primitive or copy-by-value objects.

	Examples of arrays are: Array<int>, Array<Rectangle> or Array<MyClass*>

	The Array class can be used to hold simple, non-polymorphic objects as well as primitive types - to
	do so, the class must fulfil these requirements:
	- it must have a copy constructor and assignment operator
	- it must be able to be relocated in memory by a memcpy without this causing any problems - so
	  objects whose functionality relies on external pointers or references to themselves can be used.

	You can of course have an array of pointers to any kind of object, e.g. Array <MyClass*>, but if
	you do this, the array doesn't take any ownership of the objects - see the OwnedArray class or the
	ReferenceCountedArray class for more powerful ways of holding lists of objects.

	For holding lists of strings, you can use Array\<String\>, but it's usually better to use the
	specialised class StringArray, which provides more useful functions.

	To make all the array's methods thread-safe, pass in "CriticalSection" as the templated
	TypeOfCriticalSectionToUse parameter, instead of the default DummyCriticalSection.

	@see OwnedArray, ReferenceCountedArray, StringArray, CriticalSection
*/
template <typename ElementType,
		  typename TypeOfCriticalSectionToUse = DummyCriticalSection>
class Array
{
private:
	typedef PARAMETER_TYPE (ElementType) ParameterType;

public:

	/** Creates an empty array. */
	Array() noexcept
	   : numUsed (0)
	{
	}

	/** Creates a copy of another array.
		@param other    the array to copy
	*/
	Array (const Array<ElementType, TypeOfCriticalSectionToUse>& other)
	{
		const ScopedLockType lock (other.getLock());
		numUsed = other.numUsed;
		data.setAllocatedSize (other.numUsed);

		for (int i = 0; i < numUsed; ++i)
			new (data.elements + i) ElementType (other.data.elements[i]);
	}

   #if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
	Array (Array<ElementType, TypeOfCriticalSectionToUse>&& other) noexcept
		: data (static_cast <ArrayAllocationBase<ElementType, TypeOfCriticalSectionToUse>&&> (other.data)),
		  numUsed (other.numUsed)
	{
		other.numUsed = 0;
	}
   #endif

	/** Initalises from a null-terminated C array of values.

		@param values   the array to copy from
	*/
	template <typename TypeToCreateFrom>
	explicit Array (const TypeToCreateFrom* values)
	   : numUsed (0)
	{
		while (*values != TypeToCreateFrom())
			add (*values++);
	}

	/** Initalises from a C array of values.

		@param values       the array to copy from
		@param numValues    the number of values in the array
	*/
	template <typename TypeToCreateFrom>
	Array (const TypeToCreateFrom* values, int numValues)
	   : numUsed (numValues)
	{
		data.setAllocatedSize (numValues);

		for (int i = 0; i < numValues; ++i)
			new (data.elements + i) ElementType (values[i]);
	}

	/** Destructor. */
	~Array()
	{
		deleteAllElements();
	}

	/** Copies another array.
		@param other    the array to copy
	*/
	Array& operator= (const Array& other)
	{
		if (this != &other)
		{
			Array<ElementType, TypeOfCriticalSectionToUse> otherCopy (other);
			swapWithArray (otherCopy);
		}

		return *this;
	}

   #if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
	Array& operator= (Array&& other) noexcept
	{
		data = static_cast <ArrayAllocationBase<ElementType, TypeOfCriticalSectionToUse>&&> (other.data);
		numUsed = other.numUsed;
		other.numUsed = 0;
		return *this;
	}
   #endif

	/** Compares this array to another one.
		Two arrays are considered equal if they both contain the same set of
		elements, in the same order.
		@param other    the other array to compare with
	*/
	template <class OtherArrayType>
	bool operator== (const OtherArrayType& other) const
	{
		const ScopedLockType lock (getLock());
		const typename OtherArrayType::ScopedLockType lock2 (other.getLock());

		if (numUsed != other.numUsed)
			return false;

		for (int i = numUsed; --i >= 0;)
			if (! (data.elements [i] == other.data.elements [i]))
				return false;

		return true;
	}

	/** Compares this array to another one.
		Two arrays are considered equal if they both contain the same set of
		elements, in the same order.
		@param other    the other array to compare with
	*/
	template <class OtherArrayType>
	bool operator!= (const OtherArrayType& other) const
	{
		return ! operator== (other);
	}

	/** Removes all elements from the array.
		This will remove all the elements, and free any storage that the array is
		using. To clear the array without freeing the storage, use the clearQuick()
		method instead.

		@see clearQuick
	*/
	void clear()
	{
		const ScopedLockType lock (getLock());
		deleteAllElements();
		data.setAllocatedSize (0);
		numUsed = 0;
	}

	/** Removes all elements from the array without freeing the array's allocated storage.

		@see clear
	*/
	void clearQuick()
	{
		const ScopedLockType lock (getLock());
		deleteAllElements();
		numUsed = 0;
	}

	/** Returns the current number of elements in the array.
	*/
	inline int size() const noexcept
	{
		return numUsed;
	}

	/** Returns one of the elements in the array.
		If the index passed in is beyond the range of valid elements, this
		will return zero.

		If you're certain that the index will always be a valid element, you
		can call getUnchecked() instead, which is faster.

		@param index    the index of the element being requested (0 is the first element in the array)
		@see getUnchecked, getFirst, getLast
	*/
	ElementType operator[] (const int index) const
	{
		const ScopedLockType lock (getLock());
		return isPositiveAndBelow (index, numUsed) ? data.elements [index]
												   : ElementType();
	}

	/** Returns one of the elements in the array, without checking the index passed in.

		Unlike the operator[] method, this will try to return an element without
		checking that the index is within the bounds of the array, so should only
		be used when you're confident that it will always be a valid index.

		@param index    the index of the element being requested (0 is the first element in the array)
		@see operator[], getFirst, getLast
	*/
	inline ElementType getUnchecked (const int index) const
	{
		const ScopedLockType lock (getLock());
		jassert (isPositiveAndBelow (index, numUsed));
		return data.elements [index];
	}

	/** Returns a direct reference to one of the elements in the array, without checking the index passed in.

		This is like getUnchecked, but returns a direct reference to the element, so that
		you can alter it directly. Obviously this can be dangerous, so only use it when
		absolutely necessary.

		@param index    the index of the element being requested (0 is the first element in the array)
		@see operator[], getFirst, getLast
	*/
	inline ElementType& getReference (const int index) const noexcept
	{
		const ScopedLockType lock (getLock());
		jassert (isPositiveAndBelow (index, numUsed));
		return data.elements [index];
	}

	/** Returns the first element in the array, or 0 if the array is empty.

		@see operator[], getUnchecked, getLast
	*/
	inline ElementType getFirst() const
	{
		const ScopedLockType lock (getLock());
		return (numUsed > 0) ? data.elements [0]
							 : ElementType();
	}

	/** Returns the last element in the array, or 0 if the array is empty.

		@see operator[], getUnchecked, getFirst
	*/
	inline ElementType getLast() const
	{
		const ScopedLockType lock (getLock());
		return (numUsed > 0) ? data.elements [numUsed - 1]
							 : ElementType();
	}

	/** Returns a pointer to the actual array data.
		This pointer will only be valid until the next time a non-const method
		is called on the array.
	*/
	inline ElementType* getRawDataPointer() noexcept
	{
		return data.elements;
	}

	/** Returns a pointer to the first element in the array.
		This method is provided for compatibility with standard C++ iteration mechanisms.
	*/
	inline ElementType* begin() const noexcept
	{
		return data.elements;
	}

	/** Returns a pointer to the element which follows the last element in the array.
		This method is provided for compatibility with standard C++ iteration mechanisms.
	*/
	inline ElementType* end() const noexcept
	{
		return data.elements + numUsed;
	}

	/** Finds the index of the first element which matches the value passed in.

		This will search the array for the given object, and return the index
		of its first occurrence. If the object isn't found, the method will return -1.

		@param elementToLookFor   the value or object to look for
		@returns                  the index of the object, or -1 if it's not found
	*/
	int indexOf (ParameterType elementToLookFor) const
	{
		const ScopedLockType lock (getLock());
		const ElementType* e = data.elements.getData();
		const ElementType* const end_ = e + numUsed;

		for (; e != end_; ++e)
			if (elementToLookFor == *e)
				return static_cast <int> (e - data.elements.getData());

		return -1;
	}

	/** Returns true if the array contains at least one occurrence of an object.

		@param elementToLookFor     the value or object to look for
		@returns                    true if the item is found
	*/
	bool contains (ParameterType elementToLookFor) const
	{
		const ScopedLockType lock (getLock());
		const ElementType* e = data.elements.getData();
		const ElementType* const end_ = e + numUsed;

		for (; e != end_; ++e)
			if (elementToLookFor == *e)
				return true;

		return false;
	}

	/** Appends a new element at the end of the array.

		@param newElement       the new object to add to the array
		@see set, insert, addIfNotAlreadyThere, addSorted, addUsingDefaultSort, addArray
	*/
	void add (ParameterType newElement)
	{
		const ScopedLockType lock (getLock());
		data.ensureAllocatedSize (numUsed + 1);
		new (data.elements + numUsed++) ElementType (newElement);
	}

	/** Inserts a new element into the array at a given position.

		If the index is less than 0 or greater than the size of the array, the
		element will be added to the end of the array.
		Otherwise, it will be inserted into the array, moving all the later elements
		along to make room.

		@param indexToInsertAt    the index at which the new element should be
								  inserted (pass in -1 to add it to the end)
		@param newElement         the new object to add to the array
		@see add, addSorted, addUsingDefaultSort, set
	*/
	void insert (int indexToInsertAt, ParameterType newElement)
	{
		const ScopedLockType lock (getLock());
		data.ensureAllocatedSize (numUsed + 1);

		if (isPositiveAndBelow (indexToInsertAt, numUsed))
		{
			ElementType* const insertPos = data.elements + indexToInsertAt;
			const int numberToMove = numUsed - indexToInsertAt;

			if (numberToMove > 0)
				memmove (insertPos + 1, insertPos, numberToMove * sizeof (ElementType));

			new (insertPos) ElementType (newElement);
			++numUsed;
		}
		else
		{
			new (data.elements + numUsed++) ElementType (newElement);
		}
	}

	/** Inserts multiple copies of an element into the array at a given position.

		If the index is less than 0 or greater than the size of the array, the
		element will be added to the end of the array.
		Otherwise, it will be inserted into the array, moving all the later elements
		along to make room.

		@param indexToInsertAt    the index at which the new element should be inserted
		@param newElement         the new object to add to the array
		@param numberOfTimesToInsertIt  how many copies of the value to insert
		@see insert, add, addSorted, set
	*/
	void insertMultiple (int indexToInsertAt, ParameterType newElement,
						 int numberOfTimesToInsertIt)
	{
		if (numberOfTimesToInsertIt > 0)
		{
			const ScopedLockType lock (getLock());
			data.ensureAllocatedSize (numUsed + numberOfTimesToInsertIt);
			ElementType* insertPos;

			if (isPositiveAndBelow (indexToInsertAt, numUsed))
			{
				insertPos = data.elements + indexToInsertAt;
				const int numberToMove = numUsed - indexToInsertAt;
				memmove (insertPos + numberOfTimesToInsertIt, insertPos, numberToMove * sizeof (ElementType));
			}
			else
			{
				insertPos = data.elements + numUsed;
			}

			numUsed += numberOfTimesToInsertIt;

			while (--numberOfTimesToInsertIt >= 0)
				new (insertPos++) ElementType (newElement);
		}
	}

	/** Inserts an array of values into this array at a given position.

		If the index is less than 0 or greater than the size of the array, the
		new elements will be added to the end of the array.
		Otherwise, they will be inserted into the array, moving all the later elements
		along to make room.

		@param indexToInsertAt      the index at which the first new element should be inserted
		@param newElements          the new values to add to the array
		@param numberOfElements     how many items are in the array
		@see insert, add, addSorted, set
	*/
	void insertArray (int indexToInsertAt,
					  const ElementType* newElements,
					  int numberOfElements)
	{
		if (numberOfElements > 0)
		{
			const ScopedLockType lock (getLock());
			data.ensureAllocatedSize (numUsed + numberOfElements);
			ElementType* insertPos;

			if (isPositiveAndBelow (indexToInsertAt, numUsed))
			{
				insertPos = data.elements + indexToInsertAt;
				const int numberToMove = numUsed - indexToInsertAt;
				memmove (insertPos + numberOfElements, insertPos, numberToMove * sizeof (ElementType));
			}
			else
			{
				insertPos = data.elements + numUsed;
			}

			numUsed += numberOfElements;

			while (--numberOfElements >= 0)
				new (insertPos++) ElementType (*newElements++);
		}
	}

	/** Appends a new element at the end of the array as long as the array doesn't
		already contain it.

		If the array already contains an element that matches the one passed in, nothing
		will be done.

		@param newElement   the new object to add to the array
	*/
	void addIfNotAlreadyThere (ParameterType newElement)
	{
		const ScopedLockType lock (getLock());

		if (! contains (newElement))
			add (newElement);
	}

	/** Replaces an element with a new value.

		If the index is less than zero, this method does nothing.
		If the index is beyond the end of the array, the item is added to the end of the array.

		@param indexToChange    the index whose value you want to change
		@param newValue         the new value to set for this index.
		@see add, insert
	*/
	void set (const int indexToChange, ParameterType newValue)
	{
		jassert (indexToChange >= 0);
		const ScopedLockType lock (getLock());

		if (isPositiveAndBelow (indexToChange, numUsed))
		{
			data.elements [indexToChange] = newValue;
		}
		else if (indexToChange >= 0)
		{
			data.ensureAllocatedSize (numUsed + 1);
			new (data.elements + numUsed++) ElementType (newValue);
		}
	}

	/** Replaces an element with a new value without doing any bounds-checking.

		This just sets a value directly in the array's internal storage, so you'd
		better make sure it's in range!

		@param indexToChange    the index whose value you want to change
		@param newValue         the new value to set for this index.
		@see set, getUnchecked
	*/
	void setUnchecked (const int indexToChange, ParameterType newValue)
	{
		const ScopedLockType lock (getLock());
		jassert (isPositiveAndBelow (indexToChange, numUsed));
		data.elements [indexToChange] = newValue;
	}

	/** Adds elements from an array to the end of this array.

		@param elementsToAdd        the array of elements to add
		@param numElementsToAdd     how many elements are in this other array
		@see add
	*/
	void addArray (const ElementType* elementsToAdd, int numElementsToAdd)
	{
		const ScopedLockType lock (getLock());

		if (numElementsToAdd > 0)
		{
			data.ensureAllocatedSize (numUsed + numElementsToAdd);

			while (--numElementsToAdd >= 0)
			{
				new (data.elements + numUsed) ElementType (*elementsToAdd++);
				++numUsed;
			}
		}
	}

	/** This swaps the contents of this array with those of another array.

		If you need to exchange two arrays, this is vastly quicker than using copy-by-value
		because it just swaps their internal pointers.
	*/
	void swapWithArray (Array& otherArray) noexcept
	{
		const ScopedLockType lock1 (getLock());
		const ScopedLockType lock2 (otherArray.getLock());

		data.swapWith (otherArray.data);
		swapVariables (numUsed, otherArray.numUsed);
	}

	/** Adds elements from another array to the end of this array.

		@param arrayToAddFrom       the array from which to copy the elements
		@param startIndex           the first element of the other array to start copying from
		@param numElementsToAdd     how many elements to add from the other array. If this
									value is negative or greater than the number of available elements,
									all available elements will be copied.
		@see add
	*/
	template <class OtherArrayType>
	void addArray (const OtherArrayType& arrayToAddFrom,
				   int startIndex = 0,
				   int numElementsToAdd = -1)
	{
		const typename OtherArrayType::ScopedLockType lock1 (arrayToAddFrom.getLock());

		{
			const ScopedLockType lock2 (getLock());

			if (startIndex < 0)
			{
				jassertfalse;
				startIndex = 0;
			}

			if (numElementsToAdd < 0 || startIndex + numElementsToAdd > arrayToAddFrom.size())
				numElementsToAdd = arrayToAddFrom.size() - startIndex;

			while (--numElementsToAdd >= 0)
				add (arrayToAddFrom.getUnchecked (startIndex++));
		}
	}

	/** This will enlarge or shrink the array to the given number of elements, by adding
		or removing items from its end.

		If the array is smaller than the given target size, empty elements will be appended
		until its size is as specified. If its size is larger than the target, items will be
		removed from its end to shorten it.
	*/
	void resize (const int targetNumItems)
	{
		jassert (targetNumItems >= 0);

		const int numToAdd = targetNumItems - numUsed;
		if (numToAdd > 0)
			insertMultiple (numUsed, ElementType(), numToAdd);
		else if (numToAdd < 0)
			removeRange (targetNumItems, -numToAdd);
	}

	/** Inserts a new element into the array, assuming that the array is sorted.

		This will use a comparator to find the position at which the new element
		should go. If the array isn't sorted, the behaviour of this
		method will be unpredictable.

		@param comparator   the comparator to use to compare the elements - see the sort()
							method for details about the form this object should take
		@param newElement   the new element to insert to the array
		@returns the index at which the new item was added
		@see addUsingDefaultSort, add, sort
	*/
	template <class ElementComparator>
	int addSorted (ElementComparator& comparator, ParameterType newElement)
	{
		const ScopedLockType lock (getLock());
		const int index = findInsertIndexInSortedArray (comparator, data.elements.getData(), newElement, 0, numUsed);
		insert (index, newElement);
		return index;
	}

	/** Inserts a new element into the array, assuming that the array is sorted.

		This will use the DefaultElementComparator class for sorting, so your ElementType
		must be suitable for use with that class. If the array isn't sorted, the behaviour of this
		method will be unpredictable.

		@param newElement   the new element to insert to the array
		@see addSorted, sort
	*/
	void addUsingDefaultSort (ParameterType newElement)
	{
		DefaultElementComparator <ElementType> comparator;
		addSorted (comparator, newElement);
	}

	/** Finds the index of an element in the array, assuming that the array is sorted.

		This will use a comparator to do a binary-chop to find the index of the given
		element, if it exists. If the array isn't sorted, the behaviour of this
		method will be unpredictable.

		@param comparator           the comparator to use to compare the elements - see the sort()
									method for details about the form this object should take
		@param elementToLookFor     the element to search for
		@returns                    the index of the element, or -1 if it's not found
		@see addSorted, sort
	*/
	template <class ElementComparator>
	int indexOfSorted (ElementComparator& comparator, ParameterType elementToLookFor) const
	{
		(void) comparator;  // if you pass in an object with a static compareElements() method, this
							// avoids getting warning messages about the parameter being unused

		const ScopedLockType lock (getLock());
		int start = 0;
		int end_ = numUsed;

		for (;;)
		{
			if (start >= end_)
			{
				return -1;
			}
			else if (comparator.compareElements (elementToLookFor, data.elements [start]) == 0)
			{
				return start;
			}
			else
			{
				const int halfway = (start + end_) >> 1;

				if (halfway == start)
					return -1;
				else if (comparator.compareElements (elementToLookFor, data.elements [halfway]) >= 0)
					start = halfway;
				else
					end_ = halfway;
			}
		}
	}

	/** Removes an element from the array.

		This will remove the element at a given index, and move back
		all the subsequent elements to close the gap.
		If the index passed in is out-of-range, nothing will happen.

		@param indexToRemove    the index of the element to remove
		@returns                the element that has been removed
		@see removeValue, removeRange
	*/
	ElementType remove (const int indexToRemove)
	{
		const ScopedLockType lock (getLock());

		if (isPositiveAndBelow (indexToRemove, numUsed))
		{
			--numUsed;

			ElementType* const e = data.elements + indexToRemove;
			ElementType removed (*e);
			e->~ElementType();
			const int numberToShift = numUsed - indexToRemove;

			if (numberToShift > 0)
				memmove (e, e + 1, numberToShift * sizeof (ElementType));

			if ((numUsed << 1) < data.numAllocated)
				minimiseStorageOverheads();

			return removed;
		}
		else
		{
			return ElementType();
		}
	}

	/** Removes an item from the array.

		This will remove the first occurrence of the given element from the array.
		If the item isn't found, no action is taken.

		@param valueToRemove   the object to try to remove
		@see remove, removeRange
	*/
	void removeValue (ParameterType valueToRemove)
	{
		const ScopedLockType lock (getLock());
		ElementType* const e = data.elements;

		for (int i = 0; i < numUsed; ++i)
		{
			if (valueToRemove == e[i])
			{
				remove (i);
				break;
			}
		}
	}

	/** Removes a range of elements from the array.

		This will remove a set of elements, starting from the given index,
		and move subsequent elements down to close the gap.

		If the range extends beyond the bounds of the array, it will
		be safely clipped to the size of the array.

		@param startIndex       the index of the first element to remove
		@param numberToRemove   how many elements should be removed
		@see remove, removeValue
	*/
	void removeRange (int startIndex, int numberToRemove)
	{
		const ScopedLockType lock (getLock());
		const int endIndex = jlimit (0, numUsed, startIndex + numberToRemove);
		startIndex = jlimit (0, numUsed, startIndex);

		if (endIndex > startIndex)
		{
			ElementType* const e = data.elements + startIndex;

			numberToRemove = endIndex - startIndex;
			for (int i = 0; i < numberToRemove; ++i)
				e[i].~ElementType();

			const int numToShift = numUsed - endIndex;
			if (numToShift > 0)
				memmove (e, e + numberToRemove, numToShift * sizeof (ElementType));

			numUsed -= numberToRemove;

			if ((numUsed << 1) < data.numAllocated)
				minimiseStorageOverheads();
		}
	}

	/** Removes the last n elements from the array.

		@param howManyToRemove   how many elements to remove from the end of the array
		@see remove, removeValue, removeRange
	*/
	void removeLast (int howManyToRemove = 1)
	{
		const ScopedLockType lock (getLock());

		if (howManyToRemove > numUsed)
			howManyToRemove = numUsed;

		for (int i = 1; i <= howManyToRemove; ++i)
			data.elements [numUsed - i].~ElementType();

		numUsed -= howManyToRemove;

		if ((numUsed << 1) < data.numAllocated)
			minimiseStorageOverheads();
	}

	/** Removes any elements which are also in another array.

		@param otherArray   the other array in which to look for elements to remove
		@see removeValuesNotIn, remove, removeValue, removeRange
	*/
	template <class OtherArrayType>
	void removeValuesIn (const OtherArrayType& otherArray)
	{
		const typename OtherArrayType::ScopedLockType lock1 (otherArray.getLock());
		const ScopedLockType lock2 (getLock());

		if (this == &otherArray)
		{
			clear();
		}
		else
		{
			if (otherArray.size() > 0)
			{
				for (int i = numUsed; --i >= 0;)
					if (otherArray.contains (data.elements [i]))
						remove (i);
			}
		}
	}

	/** Removes any elements which are not found in another array.

		Only elements which occur in this other array will be retained.

		@param otherArray    the array in which to look for elements NOT to remove
		@see removeValuesIn, remove, removeValue, removeRange
	*/
	template <class OtherArrayType>
	void removeValuesNotIn (const OtherArrayType& otherArray)
	{
		const typename OtherArrayType::ScopedLockType lock1 (otherArray.getLock());
		const ScopedLockType lock2 (getLock());

		if (this != &otherArray)
		{
			if (otherArray.size() <= 0)
			{
				clear();
			}
			else
			{
				for (int i = numUsed; --i >= 0;)
					if (! otherArray.contains (data.elements [i]))
						remove (i);
			}
		}
	}

	/** Swaps over two elements in the array.

		This swaps over the elements found at the two indexes passed in.
		If either index is out-of-range, this method will do nothing.

		@param index1   index of one of the elements to swap
		@param index2   index of the other element to swap
	*/
	void swap (const int index1,
			   const int index2)
	{
		const ScopedLockType lock (getLock());

		if (isPositiveAndBelow (index1, numUsed)
			 && isPositiveAndBelow (index2, numUsed))
		{
			swapVariables (data.elements [index1],
						   data.elements [index2]);
		}
	}

	/** Moves one of the values to a different position.

		This will move the value to a specified index, shuffling along
		any intervening elements as required.

		So for example, if you have the array { 0, 1, 2, 3, 4, 5 } then calling
		move (2, 4) would result in { 0, 1, 3, 4, 2, 5 }.

		@param currentIndex     the index of the value to be moved. If this isn't a
								valid index, then nothing will be done
		@param newIndex         the index at which you'd like this value to end up. If this
								is less than zero, the value will be moved to the end
								of the array
	*/
	void move (const int currentIndex, int newIndex) noexcept
	{
		if (currentIndex != newIndex)
		{
			const ScopedLockType lock (getLock());

			if (isPositiveAndBelow (currentIndex, numUsed))
			{
				if (! isPositiveAndBelow (newIndex, numUsed))
					newIndex = numUsed - 1;

				char tempCopy [sizeof (ElementType)];
				memcpy (tempCopy, data.elements + currentIndex, sizeof (ElementType));

				if (newIndex > currentIndex)
				{
					memmove (data.elements + currentIndex,
							 data.elements + currentIndex + 1,
							 (newIndex - currentIndex) * sizeof (ElementType));
				}
				else
				{
					memmove (data.elements + newIndex + 1,
							 data.elements + newIndex,
							 (currentIndex - newIndex) * sizeof (ElementType));
				}

				memcpy (data.elements + newIndex, tempCopy, sizeof (ElementType));
			}
		}
	}

	/** Reduces the amount of storage being used by the array.

		Arrays typically allocate slightly more storage than they need, and after
		removing elements, they may have quite a lot of unused space allocated.
		This method will reduce the amount of allocated storage to a minimum.
	*/
	void minimiseStorageOverheads()
	{
		const ScopedLockType lock (getLock());
		data.shrinkToNoMoreThan (numUsed);
	}

	/** Increases the array's internal storage to hold a minimum number of elements.

		Calling this before adding a large known number of elements means that
		the array won't have to keep dynamically resizing itself as the elements
		are added, and it'll therefore be more efficient.
	*/
	void ensureStorageAllocated (const int minNumElements)
	{
		const ScopedLockType lock (getLock());
		data.ensureAllocatedSize (minNumElements);
	}

	/** Sorts the elements in the array.

		This will use a comparator object to sort the elements into order. The object
		passed must have a method of the form:
		@code
		int compareElements (ElementType first, ElementType second);
		@endcode

		..and this method must return:
		  - a value of < 0 if the first comes before the second
		  - a value of 0 if the two objects are equivalent
		  - a value of > 0 if the second comes before the first

		To improve performance, the compareElements() method can be declared as static or const.

		@param comparator   the comparator to use for comparing elements.
		@param retainOrderOfEquivalentItems     if this is true, then items
							which the comparator says are equivalent will be
							kept in the order in which they currently appear
							in the array. This is slower to perform, but may
							be important in some cases. If it's false, a faster
							algorithm is used, but equivalent elements may be
							rearranged.

		@see addSorted, indexOfSorted, sortArray
	*/
	template <class ElementComparator>
	void sort (ElementComparator& comparator,
			   const bool retainOrderOfEquivalentItems = false) const
	{
		const ScopedLockType lock (getLock());
		(void) comparator;  // if you pass in an object with a static compareElements() method, this
							// avoids getting warning messages about the parameter being unused
		sortArray (comparator, data.elements.getData(), 0, size() - 1, retainOrderOfEquivalentItems);
	}

	/** Returns the CriticalSection that locks this array.
		To lock, you can call getLock().enter() and getLock().exit(), or preferably use
		an object of ScopedLockType as an RAII lock for it.
	*/
	inline const TypeOfCriticalSectionToUse& getLock() const noexcept      { return data; }

	/** Returns the type of scoped lock to use for locking this array */
	typedef typename TypeOfCriticalSectionToUse::ScopedLockType ScopedLockType;

private:

	ArrayAllocationBase <ElementType, TypeOfCriticalSectionToUse> data;
	int numUsed;

	inline void deleteAllElements() noexcept
	{
		for (int i = 0; i < numUsed; ++i)
			data.elements[i].~ElementType();
	}
};

#endif   // __JUCE_ARRAY_JUCEHEADER__

/*** End of inlined file: juce_Array.h ***/


#endif
#ifndef __JUCE_ARRAYALLOCATIONBASE_JUCEHEADER__

#endif
#ifndef __JUCE_DYNAMICOBJECT_JUCEHEADER__

/*** Start of inlined file: juce_DynamicObject.h ***/
#ifndef __JUCE_DYNAMICOBJECT_JUCEHEADER__
#define __JUCE_DYNAMICOBJECT_JUCEHEADER__


/*** Start of inlined file: juce_NamedValueSet.h ***/
#ifndef __JUCE_NAMEDVALUESET_JUCEHEADER__
#define __JUCE_NAMEDVALUESET_JUCEHEADER__


/*** Start of inlined file: juce_Variant.h ***/
#ifndef __JUCE_VARIANT_JUCEHEADER__
#define __JUCE_VARIANT_JUCEHEADER__


/*** Start of inlined file: juce_Identifier.h ***/
#ifndef __JUCE_IDENTIFIER_JUCEHEADER__
#define __JUCE_IDENTIFIER_JUCEHEADER__

class StringPool;

/**
	Represents a string identifier, designed for accessing properties by name.

	Identifier objects are very light and fast to copy, but slower to initialise
	from a string, so it's much faster to keep a static identifier object to refer
	to frequently-used names, rather than constructing them each time you need it.

	@see NamedPropertySet, ValueTree
*/
class JUCE_API  Identifier
{
public:
	/** Creates a null identifier. */
	Identifier() noexcept;

	/** Creates an identifier with a specified name.
		Because this name may need to be used in contexts such as script variables or XML
		tags, it must only contain ascii letters and digits, or the underscore character.
	*/
	Identifier (const char* name);

	/** Creates an identifier with a specified name.
		Because this name may need to be used in contexts such as script variables or XML
		tags, it must only contain ascii letters and digits, or the underscore character.
	*/
	Identifier (const String& name);

	/** Creates a copy of another identifier. */
	Identifier (const Identifier& other) noexcept;

	/** Creates a copy of another identifier. */
	Identifier& operator= (const Identifier& other) noexcept;

	/** Destructor */
	~Identifier();

	/** Compares two identifiers. This is a very fast operation. */
	inline bool operator== (const Identifier& other) const noexcept     { return name == other.name; }

	/** Compares two identifiers. This is a very fast operation. */
	inline bool operator!= (const Identifier& other) const noexcept     { return name != other.name; }

	/** Returns this identifier as a string. */
	String toString() const                                             { return name; }

	/** Returns this identifier's raw string pointer. */
	operator const String::CharPointerType() const noexcept             { return name; }

	/** Returns this identifier's raw string pointer. */
	const String::CharPointerType getCharPointer() const noexcept       { return name; }

	/** Checks a given string for characters that might not be valid in an Identifier.
		Since Identifiers are used as a script variables and XML attributes, they should only contain
		alphanumeric characters, underscores, or the '-' and ':' characters.
	*/
	static bool isValidIdentifier (const String& possibleIdentifier) noexcept;

private:

	String::CharPointerType name;

	static StringPool& getPool();
};

#endif   // __JUCE_IDENTIFIER_JUCEHEADER__

/*** End of inlined file: juce_Identifier.h ***/


/*** Start of inlined file: juce_OutputStream.h ***/
#ifndef __JUCE_OUTPUTSTREAM_JUCEHEADER__
#define __JUCE_OUTPUTSTREAM_JUCEHEADER__


/*** Start of inlined file: juce_NewLine.h ***/
#ifndef __JUCE_NEWLINE_JUCEHEADER__
#define __JUCE_NEWLINE_JUCEHEADER__

/** This class is used for represent a new-line character sequence.

	To write a new-line to a stream, you can use the predefined 'newLine' variable, e.g.
	@code
	myOutputStream << "Hello World" << newLine << newLine;
	@endcode

	The exact character sequence that will be used for the new-line can be set and
	retrieved with OutputStream::setNewLineString() and OutputStream::getNewLineString().
*/
class JUCE_API  NewLine
{
public:
	/** Returns the default new-line sequence that the library uses.
		@see OutputStream::setNewLineString()
	*/
	static const char* getDefault() noexcept        { return "\r\n"; }

	/** Returns the default new-line sequence that the library uses.
		@see getDefault()
	*/
	operator String() const                         { return getDefault(); }
};

/** A predefined object representing a new-line, which can be written to a string or stream.

	To write a new-line to a stream, you can use the predefined 'newLine' variable like this:
	@code
	myOutputStream << "Hello World" << newLine << newLine;
	@endcode
*/
extern NewLine newLine;

/** Writes a new-line sequence to a string.
	You can use the predefined object 'newLine' to invoke this, e.g.
	@code
	myString << "Hello World" << newLine << newLine;
	@endcode
*/
JUCE_API String& JUCE_CALLTYPE operator<< (String& string1, const NewLine&);

#endif   // __JUCE_NEWLINE_JUCEHEADER__

/*** End of inlined file: juce_NewLine.h ***/

class InputStream;
class MemoryBlock;
class File;

/**
	The base class for streams that write data to some kind of destination.

	Input and output streams are used throughout the library - subclasses can override
	some or all of the virtual functions to implement their behaviour.

	@see InputStream, MemoryOutputStream, FileOutputStream
*/
class JUCE_API  OutputStream
{
protected:

	OutputStream();

public:
	/** Destructor.

		Some subclasses might want to do things like call flush() during their
		destructors.
	*/
	virtual ~OutputStream();

	/** If the stream is using a buffer, this will ensure it gets written
		out to the destination. */
	virtual void flush() = 0;

	/** Tries to move the stream's output position.

		Not all streams will be able to seek to a new position - this will return
		false if it fails to work.

		@see getPosition
	*/
	virtual bool setPosition (int64 newPosition) = 0;

	/** Returns the stream's current position.

		@see setPosition
	*/
	virtual int64 getPosition() = 0;

	/** Writes a block of data to the stream.

		When creating a subclass of OutputStream, this is the only write method
		that needs to be overloaded - the base class has methods for writing other
		types of data which use this to do the work.

		@param dataToWrite      the target buffer to receive the data. This must not be null.
		@param numberOfBytes    the number of bytes to write. This must not be negative.
		@returns false if the write operation fails for some reason
	*/
	virtual bool write (const void* dataToWrite,
						int numberOfBytes) = 0;

	/** Writes a single byte to the stream.

		@see InputStream::readByte
	*/
	virtual void writeByte (char byte);

	/** Writes a boolean to the stream as a single byte.
		This is encoded as a binary byte (not as text) with a value of 1 or 0.
		@see InputStream::readBool
	*/
	virtual void writeBool (bool boolValue);

	/** Writes a 16-bit integer to the stream in a little-endian byte order.
		This will write two bytes to the stream: (value & 0xff), then (value >> 8).
		@see InputStream::readShort
	*/
	virtual void writeShort (short value);

	/** Writes a 16-bit integer to the stream in a big-endian byte order.
		This will write two bytes to the stream: (value >> 8), then (value & 0xff).
		@see InputStream::readShortBigEndian
	*/
	virtual void writeShortBigEndian (short value);

	/** Writes a 32-bit integer to the stream in a little-endian byte order.
		@see InputStream::readInt
	*/
	virtual void writeInt (int value);

	/** Writes a 32-bit integer to the stream in a big-endian byte order.
		@see InputStream::readIntBigEndian
	*/
	virtual void writeIntBigEndian (int value);

	/** Writes a 64-bit integer to the stream in a little-endian byte order.
		@see InputStream::readInt64
	*/
	virtual void writeInt64 (int64 value);

	/** Writes a 64-bit integer to the stream in a big-endian byte order.
		@see InputStream::readInt64BigEndian
	*/
	virtual void writeInt64BigEndian (int64 value);

	/** Writes a 32-bit floating point value to the stream in a binary format.
		The binary 32-bit encoding of the float is written as a little-endian int.
		@see InputStream::readFloat
	*/
	virtual void writeFloat (float value);

	/** Writes a 32-bit floating point value to the stream in a binary format.
		The binary 32-bit encoding of the float is written as a big-endian int.
		@see InputStream::readFloatBigEndian
	*/
	virtual void writeFloatBigEndian (float value);

	/** Writes a 64-bit floating point value to the stream in a binary format.
		The eight raw bytes of the double value are written out as a little-endian 64-bit int.
		@see InputStream::readDouble
	*/
	virtual void writeDouble (double value);

	/** Writes a 64-bit floating point value to the stream in a binary format.
		The eight raw bytes of the double value are written out as a big-endian 64-bit int.
		@see InputStream::readDoubleBigEndian
	*/
	virtual void writeDoubleBigEndian (double value);

	/** Writes a byte to the output stream a given number of times. */
	virtual void writeRepeatedByte (uint8 byte, int numTimesToRepeat);

	/** Writes a condensed binary encoding of a 32-bit integer.

		If you're storing a lot of integers which are unlikely to have very large values,
		this can save a lot of space, because values under 0xff will only take up 2 bytes,
		under 0xffff only 3 bytes, etc.

		The format used is: number of significant bytes + up to 4 bytes in little-endian order.

		@see InputStream::readCompressedInt
	*/
	virtual void writeCompressedInt (int value);

	/** Stores a string in the stream in a binary format.

		This isn't the method to use if you're trying to append text to the end of a
		text-file! It's intended for storing a string so that it can be retrieved later
		by InputStream::readString().

		It writes the string to the stream as UTF8, including the null termination character.

		For appending text to a file, instead use writeText, or operator<<

		@see InputStream::readString, writeText, operator<<
	*/
	virtual void writeString (const String& text);

	/** Writes a string of text to the stream.

		It can either write the text as UTF-8 or UTF-16, and can also add the UTF-16 byte-order-mark
		bytes (0xff, 0xfe) to indicate the endianness (these should only be used at the start
		of a file).

		The method also replaces '\\n' characters in the text with '\\r\\n'.
	*/
	virtual void writeText (const String& text,
							bool asUTF16,
							bool writeUTF16ByteOrderMark);

	/** Reads data from an input stream and writes it to this stream.

		@param source               the stream to read from
		@param maxNumBytesToWrite   the number of bytes to read from the stream (if this is
									less than zero, it will keep reading until the input
									is exhausted)
	*/
	virtual int writeFromInputStream (InputStream& source, int64 maxNumBytesToWrite);

	/** Sets the string that will be written to the stream when the writeNewLine()
		method is called.
		By default this will be set the the value of NewLine::getDefault().
	*/
	void setNewLineString (const String& newLineString);

	/** Returns the current new-line string that was set by setNewLineString(). */
	const String& getNewLineString() const noexcept         { return newLineString; }

private:

	String newLineString;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (OutputStream);
};

/** Writes a number to a stream as 8-bit characters in the default system encoding. */
OutputStream& JUCE_CALLTYPE operator<< (OutputStream& stream, int number);

/** Writes a number to a stream as 8-bit characters in the default system encoding. */
OutputStream& JUCE_CALLTYPE operator<< (OutputStream& stream, double number);

/** Writes a character to a stream. */
OutputStream& JUCE_CALLTYPE operator<< (OutputStream& stream, char character);

/** Writes a null-terminated text string to a stream. */
OutputStream& JUCE_CALLTYPE operator<< (OutputStream& stream, const char* text);

/** Writes a block of data from a MemoryBlock to a stream. */
OutputStream& JUCE_CALLTYPE operator<< (OutputStream& stream, const MemoryBlock& data);

/** Writes the contents of a file to a stream. */
OutputStream& JUCE_CALLTYPE operator<< (OutputStream& stream, const File& fileToRead);

/** Writes the complete contents of an input stream to an output stream. */
OutputStream& JUCE_CALLTYPE operator<< (OutputStream& stream, InputStream& streamToRead);

/** Writes a new-line to a stream.
	You can use the predefined symbol 'newLine' to invoke this, e.g.
	@code
	myOutputStream << "Hello World" << newLine << newLine;
	@endcode
	@see OutputStream::setNewLineString
*/
OutputStream& JUCE_CALLTYPE operator<< (OutputStream& stream, const NewLine&);

#endif   // __JUCE_OUTPUTSTREAM_JUCEHEADER__

/*** End of inlined file: juce_OutputStream.h ***/


/*** Start of inlined file: juce_InputStream.h ***/
#ifndef __JUCE_INPUTSTREAM_JUCEHEADER__
#define __JUCE_INPUTSTREAM_JUCEHEADER__

class MemoryBlock;

/** The base class for streams that read data.

	Input and output streams are used throughout the library - subclasses can override
	some or all of the virtual functions to implement their behaviour.

	@see OutputStream, MemoryInputStream, BufferedInputStream, FileInputStream
*/
class JUCE_API  InputStream
{
public:
	/** Destructor. */
	virtual ~InputStream()  {}

	/** Returns the total number of bytes available for reading in this stream.

		Note that this is the number of bytes available from the start of the
		stream, not from the current position.

		If the size of the stream isn't actually known, this may return -1.
	*/
	virtual int64 getTotalLength() = 0;

	/** Returns true if the stream has no more data to read. */
	virtual bool isExhausted() = 0;

	/** Reads some data from the stream into a memory buffer.

		This is the only read method that subclasses actually need to implement, as the
		InputStream base class implements the other read methods in terms of this one (although
		it's often more efficient for subclasses to implement them directly).

		@param destBuffer       the destination buffer for the data. This must not be null.
		@param maxBytesToRead   the maximum number of bytes to read - make sure the
								memory block passed in is big enough to contain this
								many bytes. This value must not be negative.

		@returns    the actual number of bytes that were read, which may be less than
					maxBytesToRead if the stream is exhausted before it gets that far
	*/
	virtual int read (void* destBuffer, int maxBytesToRead) = 0;

	/** Reads a byte from the stream.

		If the stream is exhausted, this will return zero.

		@see OutputStream::writeByte
	*/
	virtual char readByte();

	/** Reads a boolean from the stream.

		The bool is encoded as a single byte - 1 for true, 0 for false.

		If the stream is exhausted, this will return false.

		@see OutputStream::writeBool
	*/
	virtual bool readBool();

	/** Reads two bytes from the stream as a little-endian 16-bit value.

		If the next two bytes read are byte1 and byte2, this returns
		(byte1 | (byte2 << 8)).

		If the stream is exhausted partway through reading the bytes, this will return zero.

		@see OutputStream::writeShort, readShortBigEndian
	*/
	virtual short readShort();

	/** Reads two bytes from the stream as a little-endian 16-bit value.

		If the next two bytes read are byte1 and byte2, this returns
		(byte2 | (byte1 << 8)).

		If the stream is exhausted partway through reading the bytes, this will return zero.

		@see OutputStream::writeShortBigEndian, readShort
	*/
	virtual short readShortBigEndian();

	/** Reads four bytes from the stream as a little-endian 32-bit value.

		If the next four bytes are byte1 to byte4, this returns
		(byte1 | (byte2 << 8) | (byte3 << 16) | (byte4 << 24)).

		If the stream is exhausted partway through reading the bytes, this will return zero.

		@see OutputStream::writeInt, readIntBigEndian
	*/
	virtual int readInt();

	/** Reads four bytes from the stream as a big-endian 32-bit value.

		If the next four bytes are byte1 to byte4, this returns
		(byte4 | (byte3 << 8) | (byte2 << 16) | (byte1 << 24)).

		If the stream is exhausted partway through reading the bytes, this will return zero.

		@see OutputStream::writeIntBigEndian, readInt
	*/
	virtual int readIntBigEndian();

	/** Reads eight bytes from the stream as a little-endian 64-bit value.

		If the next eight bytes are byte1 to byte8, this returns
		(byte1 | (byte2 << 8) | (byte3 << 16) | (byte4 << 24) | (byte5 << 32) | (byte6 << 40) | (byte7 << 48) | (byte8 << 56)).

		If the stream is exhausted partway through reading the bytes, this will return zero.

		@see OutputStream::writeInt64, readInt64BigEndian
	*/
	virtual int64 readInt64();

	/** Reads eight bytes from the stream as a big-endian 64-bit value.

		If the next eight bytes are byte1 to byte8, this returns
		(byte8 | (byte7 << 8) | (byte6 << 16) | (byte5 << 24) | (byte4 << 32) | (byte3 << 40) | (byte2 << 48) | (byte1 << 56)).

		If the stream is exhausted partway through reading the bytes, this will return zero.

		@see OutputStream::writeInt64BigEndian, readInt64
	*/
	virtual int64 readInt64BigEndian();

	/** Reads four bytes as a 32-bit floating point value.

		The raw 32-bit encoding of the float is read from the stream as a little-endian int.

		If the stream is exhausted partway through reading the bytes, this will return zero.

		@see OutputStream::writeFloat, readDouble
	*/
	virtual float readFloat();

	/** Reads four bytes as a 32-bit floating point value.

		The raw 32-bit encoding of the float is read from the stream as a big-endian int.

		If the stream is exhausted partway through reading the bytes, this will return zero.

		@see OutputStream::writeFloatBigEndian, readDoubleBigEndian
	*/
	virtual float readFloatBigEndian();

	/** Reads eight bytes as a 64-bit floating point value.

		The raw 64-bit encoding of the double is read from the stream as a little-endian int64.

		If the stream is exhausted partway through reading the bytes, this will return zero.

		@see OutputStream::writeDouble, readFloat
	*/
	virtual double readDouble();

	/** Reads eight bytes as a 64-bit floating point value.

		The raw 64-bit encoding of the double is read from the stream as a big-endian int64.

		If the stream is exhausted partway through reading the bytes, this will return zero.

		@see OutputStream::writeDoubleBigEndian, readFloatBigEndian
	*/
	virtual double readDoubleBigEndian();

	/** Reads an encoded 32-bit number from the stream using a space-saving compressed format.

		For small values, this is more space-efficient than using readInt() and OutputStream::writeInt()

		The format used is: number of significant bytes + up to 4 bytes in little-endian order.

		@see OutputStream::writeCompressedInt()
	*/
	virtual int readCompressedInt();

	/** Reads a UTF8 string from the stream, up to the next linefeed or carriage return.

		This will read up to the next "\n" or "\r\n" or end-of-stream.

		After this call, the stream's position will be left pointing to the next character
		following the line-feed, but the linefeeds aren't included in the string that
		is returned.
	*/
	virtual String readNextLine();

	/** Reads a zero-terminated UTF8 string from the stream.

		This will read characters from the stream until it hits a zero character or
		end-of-stream.

		@see OutputStream::writeString, readEntireStreamAsString
	*/
	virtual String readString();

	/** Tries to read the whole stream and turn it into a string.

		This will read from the stream's current position until the end-of-stream, and
		will try to make an educated guess about whether it's unicode or an 8-bit encoding.
	*/
	virtual String readEntireStreamAsString();

	/** Reads from the stream and appends the data to a MemoryBlock.

		@param destBlock            the block to append the data onto
		@param maxNumBytesToRead    if this is a positive value, it sets a limit to the number
									of bytes that will be read - if it's negative, data
									will be read until the stream is exhausted.
		@returns the number of bytes that were added to the memory block
	*/
	virtual int readIntoMemoryBlock (MemoryBlock& destBlock,
									 ssize_t maxNumBytesToRead = -1);

	/** Returns the offset of the next byte that will be read from the stream.

		@see setPosition
	*/
	virtual int64 getPosition() = 0;

	/** Tries to move the current read position of the stream.

		The position is an absolute number of bytes from the stream's start.

		Some streams might not be able to do this, in which case they should do
		nothing and return false. Others might be able to manage it by resetting
		themselves and skipping to the correct position, although this is
		obviously a bit slow.

		@returns  true if the stream manages to reposition itself correctly
		@see getPosition
	*/
	virtual bool setPosition (int64 newPosition) = 0;

	/** Reads and discards a number of bytes from the stream.

		Some input streams might implement this efficiently, but the base
		class will just keep reading data until the requisite number of bytes
		have been done.
	*/
	virtual void skipNextBytes (int64 numBytesToSkip);

protected:

	InputStream() noexcept {}

private:
	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (InputStream);
};

#endif   // __JUCE_INPUTSTREAM_JUCEHEADER__

/*** End of inlined file: juce_InputStream.h ***/

#ifndef DOXYGEN
 class ReferenceCountedObject;
 class DynamicObject;
#endif

/**
	A variant class, that can be used to hold a range of primitive values.

	A var object can hold a range of simple primitive values, strings, or
	any kind of ReferenceCountedObject. The var class is intended to act like
	the kind of values used in dynamic scripting languages.

	You can save/load var objects either in a small, proprietary binary format
	using writeToStream()/readFromStream(), or as JSON by using the JSON class.

	@see JSON, DynamicObject
*/
class JUCE_API  var
{
public:

	typedef const var (DynamicObject::*MethodFunction) (const var* arguments, int numArguments);
	typedef Identifier identifier;

	/** Creates a void variant. */
	var() noexcept;

	/** Destructor. */
	~var() noexcept;

	/** A static var object that can be used where you need an empty variant object. */
	static const var null;

	var (const var& valueToCopy);
	var (int value) noexcept;
	var (int64 value) noexcept;
	var (bool value) noexcept;
	var (double value) noexcept;
	var (const char* value);
	var (const wchar_t* value);
	var (const String& value);
	var (const Array<var>& value);
	var (ReferenceCountedObject* object);
	var (MethodFunction method) noexcept;

	var& operator= (const var& valueToCopy);
	var& operator= (int value);
	var& operator= (int64 value);
	var& operator= (bool value);
	var& operator= (double value);
	var& operator= (const char* value);
	var& operator= (const wchar_t* value);
	var& operator= (const String& value);
	var& operator= (const Array<var>& value);
	var& operator= (ReferenceCountedObject* object);
	var& operator= (MethodFunction method);

   #if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
	var (var&& other) noexcept;
	var (String&& value);
	var& operator= (var&& other) noexcept;
	var& operator= (String&& value);
   #endif

	void swapWith (var& other) noexcept;

	operator int() const noexcept;
	operator int64() const noexcept;
	operator bool() const noexcept;
	operator float() const noexcept;
	operator double() const noexcept;
	operator String() const;
	String toString() const;
	Array<var>* getArray() const noexcept;
	ReferenceCountedObject* getObject() const noexcept;
	DynamicObject* getDynamicObject() const noexcept;

	bool isVoid() const noexcept;
	bool isInt() const noexcept;
	bool isInt64() const noexcept;
	bool isBool() const noexcept;
	bool isDouble() const noexcept;
	bool isString() const noexcept;
	bool isObject() const noexcept;
	bool isArray() const noexcept;
	bool isMethod() const noexcept;

	/** Returns true if this var has the same value as the one supplied.
		Note that this ignores the type, so a string var "123" and an integer var with the
		value 123 are considered to be equal.
		@see equalsWithSameType
	*/
	bool equals (const var& other) const noexcept;

	/** Returns true if this var has the same value and type as the one supplied.
		This differs from equals() because e.g. "123" and 123 will be considered different.
		@see equals
	*/
	bool equalsWithSameType (const var& other) const noexcept;

	/** If the var is an array, this returns the number of elements.
		If the var isn't actually an array, this will return 0.
	*/
	int size() const;

	/** If the var is an array, this can be used to return one of its elements.
		To call this method, you must make sure that the var is actually an array, and
		that the index is a valid number. If these conditions aren't met, behaviour is
		undefined.
		For more control over the array's contents, you can call getArray() and manipulate
		it directly as an Array\<var\>.
	*/
	const var& operator[] (int arrayIndex) const;

	/** If the var is an array, this can be used to return one of its elements.
		To call this method, you must make sure that the var is actually an array, and
		that the index is a valid number. If these conditions aren't met, behaviour is
		undefined.
		For more control over the array's contents, you can call getArray() and manipulate
		it directly as an Array\<var\>.
	*/
	var& operator[] (int arrayIndex);

	/** Appends an element to the var, converting it to an array if it isn't already one.
		If the var isn't an array, it will be converted to one, and if its value was non-void,
		this value will be kept as the first element of the new array. The parameter value
		will then be appended to it.
		For more control over the array's contents, you can call getArray() and manipulate
		it directly as an Array\<var\>.
	*/
	void append (const var& valueToAppend);

	/** Inserts an element to the var, converting it to an array if it isn't already one.
		If the var isn't an array, it will be converted to one, and if its value was non-void,
		this value will be kept as the first element of the new array. The parameter value
		will then be inserted into it.
		For more control over the array's contents, you can call getArray() and manipulate
		it directly as an Array\<var\>.
	*/
	void insert (int index, const var& value);

	/** If the var is an array, this removes one of its elements.
		If the index is out-of-range or the var isn't an array, nothing will be done.
		For more control over the array's contents, you can call getArray() and manipulate
		it directly as an Array\<var\>.
	*/
	void remove (int index);

	/** Treating the var as an array, this resizes it to contain the specified number of elements.
		If the var isn't an array, it will be converted to one, and if its value was non-void,
		this value will be kept as the first element of the new array before resizing.
		For more control over the array's contents, you can call getArray() and manipulate
		it directly as an Array\<var\>.
	*/
	void resize (int numArrayElementsWanted);

	/** If the var is an array, this searches it for the first occurrence of the specified value,
		and returns its index.
		If the var isn't an array, or if the value isn't found, this returns -1.
	*/
	int indexOf (const var& value) const;

	/** If this variant is an object, this returns one of its properties. */
	var operator[] (const Identifier& propertyName) const;
	/** If this variant is an object, this returns one of its properties. */
	var operator[] (const char* propertyName) const;
	/** If this variant is an object, this returns one of its properties, or a default
		fallback value if the property is not set. */
	var getProperty (const Identifier& propertyName, const var& defaultReturnValue) const;

	/** If this variant is an object, this invokes one of its methods with no arguments. */
	var call (const Identifier& method) const;
	/** If this variant is an object, this invokes one of its methods with one argument. */
	var call (const Identifier& method, const var& arg1) const;
	/** If this variant is an object, this invokes one of its methods with 2 arguments. */
	var call (const Identifier& method, const var& arg1, const var& arg2) const;
	/** If this variant is an object, this invokes one of its methods with 3 arguments. */
	var call (const Identifier& method, const var& arg1, const var& arg2, const var& arg3);
	/** If this variant is an object, this invokes one of its methods with 4 arguments. */
	var call (const Identifier& method, const var& arg1, const var& arg2, const var& arg3, const var& arg4) const;
	/** If this variant is an object, this invokes one of its methods with 5 arguments. */
	var call (const Identifier& method, const var& arg1, const var& arg2, const var& arg3, const var& arg4, const var& arg5) const;
	/** If this variant is an object, this invokes one of its methods with a list of arguments. */
	var invoke (const Identifier& method, const var* arguments, int numArguments) const;

	/** Writes a binary representation of this value to a stream.
		The data can be read back later using readFromStream().
		@see JSON
	*/
	void writeToStream (OutputStream& output) const;

	/** Reads back a stored binary representation of a value.
		The data in the stream must have been written using writeToStream(), or this
		will have unpredictable results.
		@see JSON
	*/
	static var readFromStream (InputStream& input);

private:

	class VariantType;         friend class VariantType;
	class VariantType_Void;    friend class VariantType_Void;
	class VariantType_Int;     friend class VariantType_Int;
	class VariantType_Int64;   friend class VariantType_Int64;
	class VariantType_Double;  friend class VariantType_Double;
	class VariantType_Bool;    friend class VariantType_Bool;
	class VariantType_String;  friend class VariantType_String;
	class VariantType_Object;  friend class VariantType_Object;
	class VariantType_Array;   friend class VariantType_Array;
	class VariantType_Method;  friend class VariantType_Method;

	union ValueUnion
	{
		int intValue;
		int64 int64Value;
		bool boolValue;
		double doubleValue;
		char stringValue [sizeof (String)];
		ReferenceCountedObject* objectValue;
		Array<var>* arrayValue;
		MethodFunction methodValue;
	};

	const VariantType* type;
	ValueUnion value;

	Array<var>* convertToArray();
	friend class DynamicObject;
	var invokeMethod (DynamicObject*, const var*, int) const;
};

/** Compares the values of two var objects, using the var::equals() comparison. */
bool operator== (const var& v1, const var& v2) noexcept;
/** Compares the values of two var objects, using the var::equals() comparison. */
bool operator!= (const var& v1, const var& v2) noexcept;
bool operator== (const var& v1, const String& v2);
bool operator!= (const var& v1, const String& v2);
bool operator== (const var& v1, const char* v2);
bool operator!= (const var& v1, const char* v2);

#endif   // __JUCE_VARIANT_JUCEHEADER__

/*** End of inlined file: juce_Variant.h ***/


/*** Start of inlined file: juce_LinkedListPointer.h ***/
#ifndef __JUCE_LINKEDLISTPOINTER_JUCEHEADER__
#define __JUCE_LINKEDLISTPOINTER_JUCEHEADER__

/**
	Helps to manipulate singly-linked lists of objects.

	For objects that are designed to contain a pointer to the subsequent item in the
	list, this class contains methods to deal with the list. To use it, the ObjectType
	class that it points to must contain a LinkedListPointer called nextListItem, e.g.

	@code
	struct MyObject
	{
		int x, y, z;

		// A linkable object must contain a member with this name and type, which must be
		// accessible by the LinkedListPointer class. (This doesn't mean it has to be public -
		// you could make your class a friend of a LinkedListPointer<MyObject> instead).
		LinkedListPointer<MyObject> nextListItem;
	};

	LinkedListPointer<MyObject> myList;
	myList.append (new MyObject());
	myList.append (new MyObject());

	int numItems = myList.size(); // returns 2
	MyObject* lastInList = myList.getLast();
	@endcode
*/
template <class ObjectType>
class LinkedListPointer
{
public:

	/** Creates a null pointer to an empty list. */
	LinkedListPointer() noexcept
		: item (nullptr)
	{
	}

	/** Creates a pointer to a list whose head is the item provided. */
	explicit LinkedListPointer (ObjectType* const headItem) noexcept
		: item (headItem)
	{
	}

	/** Sets this pointer to point to a new list. */
	LinkedListPointer& operator= (ObjectType* const newItem) noexcept
	{
		item = newItem;
		return *this;
	}

   #if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
	LinkedListPointer (LinkedListPointer&& other) noexcept
		: item (other.item)
	{
		other.item = nullptr;
	}

	LinkedListPointer& operator= (LinkedListPointer&& other) noexcept
	{
		jassert (this != &other); // hopefully the compiler should make this situation impossible!

		item = other.item;
		other.item = nullptr;
		return *this;
	}
   #endif

	/** Returns the item which this pointer points to. */
	inline operator ObjectType*() const noexcept
	{
		return item;
	}

	/** Returns the item which this pointer points to. */
	inline ObjectType* get() const noexcept
	{
		return item;
	}

	/** Returns the last item in the list which this pointer points to.
		This will iterate the list and return the last item found. Obviously the speed
		of this operation will be proportional to the size of the list. If the list is
		empty the return value will be this object.
		If you're planning on appending a number of items to your list, it's much more
		efficient to use the Appender class than to repeatedly call getLast() to find the end.
	*/
	LinkedListPointer& getLast() noexcept
	{
		LinkedListPointer* l = this;

		while (l->item != nullptr)
			l = &(l->item->nextListItem);

		return *l;
	}

	/** Returns the number of items in the list.
		Obviously with a simple linked list, getting the size involves iterating the list, so
		this can be a lengthy operation - be careful when using this method in your code.
	*/
	int size() const noexcept
	{
		int total = 0;

		for (ObjectType* i = item; i != nullptr; i = i->nextListItem)
			++total;

		return total;
	}

	/** Returns the item at a given index in the list.
		Since the only way to find an item is to iterate the list, this operation can obviously
		be slow, depending on its size, so you should be careful when using this in algorithms.
	*/
	LinkedListPointer& operator[] (int index) noexcept
	{
		LinkedListPointer* l = this;

		while (--index >= 0 && l->item != nullptr)
			l = &(l->item->nextListItem);

		return *l;
	}

	/** Returns the item at a given index in the list.
		Since the only way to find an item is to iterate the list, this operation can obviously
		be slow, depending on its size, so you should be careful when using this in algorithms.
	*/
	const LinkedListPointer& operator[] (int index) const noexcept
	{
		const LinkedListPointer* l = this;

		while (--index >= 0 && l->item != nullptr)
			l = &(l->item->nextListItem);

		return *l;
	}

	/** Returns true if the list contains the given item. */
	bool contains (const ObjectType* const itemToLookFor) const noexcept
	{
		for (ObjectType* i = item; i != nullptr; i = i->nextListItem)
			if (itemToLookFor == i)
				return true;

		return false;
	}

	/** Inserts an item into the list, placing it before the item that this pointer
		currently points to.
	*/
	void insertNext (ObjectType* const newItem)
	{
		jassert (newItem != nullptr);
		jassert (newItem->nextListItem == nullptr);
		newItem->nextListItem = item;
		item = newItem;
	}

	/** Inserts an item at a numeric index in the list.
		Obviously this will involve iterating the list to find the item at the given index,
		so be careful about the impact this may have on execution time.
	*/
	void insertAtIndex (int index, ObjectType* newItem)
	{
		jassert (newItem != nullptr);
		LinkedListPointer* l = this;

		while (index != 0 && l->item != nullptr)
		{
			l = &(l->item->nextListItem);
			--index;
		}

		l->insertNext (newItem);
	}

	/** Replaces the object that this pointer points to, appending the rest of the list to
		the new object, and returning the old one.
	*/
	ObjectType* replaceNext (ObjectType* const newItem) noexcept
	{
		jassert (newItem != nullptr);
		jassert (newItem->nextListItem == nullptr);

		ObjectType* const oldItem = item;
		item = newItem;
		item->nextListItem = oldItem->nextListItem.item;
		oldItem->nextListItem = (ObjectType*) 0;
		return oldItem;
	}

	/** Adds an item to the end of the list.

		This operation involves iterating the whole list, so can be slow - if you need to
		append a number of items to your list, it's much more efficient to use the Appender
		class than to repeatedly call append().
	*/
	void append (ObjectType* const newItem)
	{
		getLast().item = newItem;
	}

	/** Creates copies of all the items in another list and adds them to this one.
		This will use the ObjectType's copy constructor to try to create copies of each
		item in the other list, and appends them to this list.
	*/
	void addCopyOfList (const LinkedListPointer& other)
	{
		LinkedListPointer* insertPoint = this;

		for (ObjectType* i = other.item; i != nullptr; i = i->nextListItem)
		{
			insertPoint->insertNext (new ObjectType (*i));
			insertPoint = &(insertPoint->item->nextListItem);
		}
	}

	/** Removes the head item from the list.
		This won't delete the object that is removed, but returns it, so the caller can
		delete it if necessary.
	*/
	ObjectType* removeNext() noexcept
	{
		ObjectType* const oldItem = item;

		if (oldItem != nullptr)
		{
			item = oldItem->nextListItem;
			oldItem->nextListItem = (ObjectType*) 0;
		}

		return oldItem;
	}

	/** Removes a specific item from the list.
		Note that this will not delete the item, it simply unlinks it from the list.
	*/
	void remove (ObjectType* const itemToRemove)
	{
		LinkedListPointer* const l = findPointerTo (itemToRemove);

		if (l != nullptr)
			l->removeNext();
	}

	/** Iterates the list, calling the delete operator on all of its elements and
		leaving this pointer empty.
	*/
	void deleteAll()
	{
		while (item != nullptr)
		{
			ObjectType* const oldItem = item;
			item = oldItem->nextListItem;
			delete oldItem;
		}
	}

	/** Finds a pointer to a given item.
		If the item is found in the list, this returns the pointer that points to it. If
		the item isn't found, this returns null.
	*/
	LinkedListPointer* findPointerTo (ObjectType* const itemToLookFor) noexcept
	{
		LinkedListPointer* l = this;

		while (l->item != nullptr)
		{
			if (l->item == itemToLookFor)
				return l;

			l = &(l->item->nextListItem);
		}

		return nullptr;
	}

	/** Copies the items in the list to an array.
		The destArray must contain enough elements to hold the entire list - no checks are
		made for this!
	*/
	void copyToArray (ObjectType** destArray) const noexcept
	{
		jassert (destArray != nullptr);

		for (ObjectType* i = item; i != nullptr; i = i->nextListItem)
			*destArray++ = i;
	}

	/** Swaps this pointer with another one */
	void swapWith (LinkedListPointer& other) noexcept
	{
		std::swap (item, other.item);
	}

	/**
		Allows efficient repeated insertions into a list.

		You can create an Appender object which points to the last element in your
		list, and then repeatedly call Appender::append() to add items to the end
		of the list in O(1) time.
	*/
	class Appender
	{
	public:
		/** Creates an appender which will add items to the given list.
		*/
		Appender (LinkedListPointer& endOfListPointer) noexcept
			: endOfList (&endOfListPointer)
		{
			// This can only be used to add to the end of a list.
			jassert (endOfListPointer.item == nullptr);
		}

		/** Appends an item to the list. */
		void append (ObjectType* const newItem) noexcept
		{
			*endOfList = newItem;
			endOfList = &(newItem->nextListItem);
		}

	private:
		LinkedListPointer* endOfList;

		JUCE_DECLARE_NON_COPYABLE (Appender);
	};

private:

	ObjectType* item;

	JUCE_DECLARE_NON_COPYABLE (LinkedListPointer);
};

#endif   // __JUCE_LINKEDLISTPOINTER_JUCEHEADER__

/*** End of inlined file: juce_LinkedListPointer.h ***/

class XmlElement;
#ifndef DOXYGEN
 class JSONFormatter;
#endif

/** Holds a set of named var objects.

	This can be used as a basic structure to hold a set of var object, which can
	be retrieved by using their identifier.
*/
class JUCE_API  NamedValueSet
{
public:
	/** Creates an empty set. */
	NamedValueSet() noexcept;

	/** Creates a copy of another set. */
	NamedValueSet (const NamedValueSet& other);

	/** Replaces this set with a copy of another set. */
	NamedValueSet& operator= (const NamedValueSet& other);

   #if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
	NamedValueSet (NamedValueSet&& other) noexcept;
	NamedValueSet& operator= (NamedValueSet&& other) noexcept;
   #endif

	/** Destructor. */
	~NamedValueSet();

	bool operator== (const NamedValueSet& other) const;
	bool operator!= (const NamedValueSet& other) const;

	/** Returns the total number of values that the set contains. */
	int size() const noexcept;

	/** Returns the value of a named item.
		If the name isn't found, this will return a void variant.
		@see getProperty
	*/
	const var& operator[] (const Identifier& name) const;

	/** Tries to return the named value, but if no such value is found, this will
		instead return the supplied default value.
	*/
	var getWithDefault (const Identifier& name, const var& defaultReturnValue) const;

	/** Changes or adds a named value.
		@returns    true if a value was changed or added; false if the
					value was already set the the value passed-in.
	*/
	bool set (const Identifier& name, const var& newValue);

   #if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
	/** Changes or adds a named value.
		@returns    true if a value was changed or added; false if the
					value was already set the the value passed-in.
	*/
	bool set (const Identifier& name, var&& newValue);
   #endif

	/** Returns true if the set contains an item with the specified name. */
	bool contains (const Identifier& name) const;

	/** Removes a value from the set.
		@returns    true if a value was removed; false if there was no value
					with the name that was given.
	*/
	bool remove (const Identifier& name);

	/** Returns the name of the value at a given index.
		The index must be between 0 and size() - 1.
	*/
	const Identifier getName (int index) const;

	/** Returns the value of the item at a given index.
		The index must be between 0 and size() - 1.
	*/
	const var& getValueAt (int index) const;

	/** Removes all values. */
	void clear();

	/** Returns a pointer to the var that holds a named value, or null if there is
		no value with this name.

		Do not use this method unless you really need access to the internal var object
		for some reason - for normal reading and writing always prefer operator[]() and set().
	*/
	var* getVarPointer (const Identifier& name) const noexcept;

	/** Sets properties to the values of all of an XML element's attributes. */
	void setFromXmlAttributes (const XmlElement& xml);

	/** Sets attributes in an XML element corresponding to each of this object's
		properties.
	*/
	void copyToXmlAttributes (XmlElement& xml) const;

private:

	class NamedValue
	{
	public:
		NamedValue() noexcept;
		NamedValue (const NamedValue&);
		NamedValue (const Identifier& name, const var& value);
		NamedValue& operator= (const NamedValue&);
	   #if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
		NamedValue (NamedValue&&) noexcept;
		NamedValue (const Identifier& name, var&& value);
		NamedValue& operator= (NamedValue&&) noexcept;
	   #endif
		bool operator== (const NamedValue& other) const noexcept;

		LinkedListPointer<NamedValue> nextListItem;
		Identifier name;
		var value;

	private:
		JUCE_LEAK_DETECTOR (NamedValue);
	};

	friend class LinkedListPointer<NamedValue>;
	LinkedListPointer<NamedValue> values;

	friend class JSONFormatter;
};

#endif   // __JUCE_NAMEDVALUESET_JUCEHEADER__

/*** End of inlined file: juce_NamedValueSet.h ***/


/*** Start of inlined file: juce_ReferenceCountedObject.h ***/
#ifndef __JUCE_REFERENCECOUNTEDOBJECT_JUCEHEADER__
#define __JUCE_REFERENCECOUNTEDOBJECT_JUCEHEADER__

/**
	Adds reference-counting to an object.

	To add reference-counting to a class, derive it from this class, and
	use the ReferenceCountedObjectPtr class to point to it.

	e.g. @code
	class MyClass : public ReferenceCountedObject
	{
		void foo();

		// This is a neat way of declaring a typedef for a pointer class,
		// rather than typing out the full templated name each time..
		typedef ReferenceCountedObjectPtr<MyClass> Ptr;
	};

	MyClass::Ptr p = new MyClass();
	MyClass::Ptr p2 = p;
	p = nullptr;
	p2->foo();
	@endcode

	Once a new ReferenceCountedObject has been assigned to a pointer, be
	careful not to delete the object manually.

	This class uses an Atomic<int> value to hold the reference count, so that it
	the pointers can be passed between threads safely. For a faster but non-thread-safe
	version, use SingleThreadedReferenceCountedObject instead.

	@see ReferenceCountedObjectPtr, ReferenceCountedArray, SingleThreadedReferenceCountedObject
*/
class JUCE_API  ReferenceCountedObject
{
public:

	/** Increments the object's reference count.

		This is done automatically by the smart pointer, but is public just
		in case it's needed for nefarious purposes.
	*/
	inline void incReferenceCount() noexcept
	{
		++refCount;
	}

	/** Decreases the object's reference count.

		If the count gets to zero, the object will be deleted.
	*/
	inline void decReferenceCount() noexcept
	{
		jassert (getReferenceCount() > 0);

		if (--refCount == 0)
			delete this;
	}

	/** Returns the object's current reference count. */
	inline int getReferenceCount() const noexcept       { return refCount.get(); }

protected:

	/** Creates the reference-counted object (with an initial ref count of zero). */
	ReferenceCountedObject()
	{
	}

	/** Destructor. */
	virtual ~ReferenceCountedObject()
	{
		// it's dangerous to delete an object that's still referenced by something else!
		jassert (getReferenceCount() == 0);
	}

	/** Resets the reference count to zero without deleting the object.
		You should probably never need to use this!
	*/
	void resetReferenceCount() noexcept
	{
		refCount = 0;
	}

private:

	Atomic <int> refCount;
};

/**
	Adds reference-counting to an object.

	This is efectively a version of the ReferenceCountedObject class, but which
	uses a non-atomic counter, and so is not thread-safe (but which will be more
	efficient).
	For more details on how to use it, see the ReferenceCountedObject class notes.

	@see ReferenceCountedObject, ReferenceCountedObjectPtr, ReferenceCountedArray
*/
class JUCE_API  SingleThreadedReferenceCountedObject
{
public:

	/** Increments the object's reference count.

		This is done automatically by the smart pointer, but is public just
		in case it's needed for nefarious purposes.
	*/
	inline void incReferenceCount() noexcept
	{
		++refCount;
	}

	/** Decreases the object's reference count.

		If the count gets to zero, the object will be deleted.
	*/
	inline void decReferenceCount() noexcept
	{
		jassert (getReferenceCount() > 0);

		if (--refCount == 0)
			delete this;
	}

	/** Returns the object's current reference count. */
	inline int getReferenceCount() const noexcept       { return refCount; }

protected:

	/** Creates the reference-counted object (with an initial ref count of zero). */
	SingleThreadedReferenceCountedObject() : refCount (0)  {}

	/** Destructor. */
	virtual ~SingleThreadedReferenceCountedObject()
	{
		// it's dangerous to delete an object that's still referenced by something else!
		jassert (getReferenceCount() == 0);
	}

private:

	int refCount;
};

/**
	A smart-pointer class which points to a reference-counted object.

	The template parameter specifies the class of the object you want to point to - the easiest
	way to make a class reference-countable is to simply make it inherit from ReferenceCountedObject,
	but if you need to, you could roll your own reference-countable class by implementing a pair of
	mathods called incReferenceCount() and decReferenceCount().

	When using this class, you'll probably want to create a typedef to abbreviate the full
	templated name - e.g.
	@code typedef ReferenceCountedObjectPtr<MyClass> MyClassPtr;@endcode

	@see ReferenceCountedObject, ReferenceCountedObjectArray
*/
template <class ReferenceCountedObjectClass>
class ReferenceCountedObjectPtr
{
public:
	/** The class being referenced by this pointer. */
	typedef ReferenceCountedObjectClass ReferencedType;

	/** Creates a pointer to a null object. */
	inline ReferenceCountedObjectPtr() noexcept
		: referencedObject (nullptr)
	{
	}

	/** Creates a pointer to an object.

		This will increment the object's reference-count if it is non-null.
	*/
	inline ReferenceCountedObjectPtr (ReferenceCountedObjectClass* const refCountedObject) noexcept
		: referencedObject (refCountedObject)
	{
		if (refCountedObject != nullptr)
			refCountedObject->incReferenceCount();
	}

	/** Copies another pointer.
		This will increment the object's reference-count (if it is non-null).
	*/
	inline ReferenceCountedObjectPtr (const ReferenceCountedObjectPtr& other) noexcept
		: referencedObject (other.referencedObject)
	{
		if (referencedObject != nullptr)
			referencedObject->incReferenceCount();
	}

   #if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
	/** Takes-over the object from another pointer. */
	inline ReferenceCountedObjectPtr (ReferenceCountedObjectPtr&& other) noexcept
		: referencedObject (other.referencedObject)
	{
		other.referencedObject = nullptr;
	}
   #endif

	/** Copies another pointer.
		This will increment the object's reference-count (if it is non-null).
	*/
	template <class DerivedClass>
	inline ReferenceCountedObjectPtr (const ReferenceCountedObjectPtr<DerivedClass>& other) noexcept
		: referencedObject (static_cast <ReferenceCountedObjectClass*> (other.getObject()))
	{
		if (referencedObject != nullptr)
			referencedObject->incReferenceCount();
	}

	/** Changes this pointer to point at a different object.

		The reference count of the old object is decremented, and it might be
		deleted if it hits zero. The new object's count is incremented.
	*/
	ReferenceCountedObjectPtr& operator= (const ReferenceCountedObjectPtr& other)
	{
		return operator= (other.referencedObject);
	}

	/** Changes this pointer to point at a different object.

		The reference count of the old object is decremented, and it might be
		deleted if it hits zero. The new object's count is incremented.
	*/
	template <class DerivedClass>
	ReferenceCountedObjectPtr& operator= (const ReferenceCountedObjectPtr<DerivedClass>& other)
	{
		return operator= (static_cast <ReferenceCountedObjectClass*> (other.getObject()));
	}

   #if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
	/** Takes-over the object from another pointer. */
	ReferenceCountedObjectPtr& operator= (ReferenceCountedObjectPtr&& other)
	{
		std::swap (referencedObject, other.referencedObject);
		return *this;
	}
   #endif

	/** Changes this pointer to point at a different object.

		The reference count of the old object is decremented, and it might be
		deleted if it hits zero. The new object's count is incremented.
	*/
	ReferenceCountedObjectPtr& operator= (ReferenceCountedObjectClass* const newObject)
	{
		if (referencedObject != newObject)
		{
			if (newObject != nullptr)
				newObject->incReferenceCount();

			ReferenceCountedObjectClass* const oldObject = referencedObject;
			referencedObject = newObject;

			if (oldObject != nullptr)
				oldObject->decReferenceCount();
		}

		return *this;
	}

	/** Destructor.

		This will decrement the object's reference-count, and may delete it if it
		gets to zero.
	*/
	inline ~ReferenceCountedObjectPtr()
	{
		if (referencedObject != nullptr)
			referencedObject->decReferenceCount();
	}

	/** Returns the object that this pointer references.
		The pointer returned may be zero, of course.
	*/
	inline operator ReferenceCountedObjectClass*() const noexcept
	{
		return referencedObject;
	}

	// the -> operator is called on the referenced object
	inline ReferenceCountedObjectClass* operator->() const noexcept
	{
		return referencedObject;
	}

	/** Returns the object that this pointer references.
		The pointer returned may be zero, of course.
	*/
	inline ReferenceCountedObjectClass* getObject() const noexcept
	{
		return referencedObject;
	}

private:

	ReferenceCountedObjectClass* referencedObject;
};

/** Compares two ReferenceCountedObjectPointers. */
template <class ReferenceCountedObjectClass>
bool operator== (const ReferenceCountedObjectPtr<ReferenceCountedObjectClass>& object1, ReferenceCountedObjectClass* const object2) noexcept
{
	return object1.getObject() == object2;
}

/** Compares two ReferenceCountedObjectPointers. */
template <class ReferenceCountedObjectClass>
bool operator== (const ReferenceCountedObjectPtr<ReferenceCountedObjectClass>& object1, const ReferenceCountedObjectPtr<ReferenceCountedObjectClass>& object2) noexcept
{
	return object1.getObject() == object2.getObject();
}

/** Compares two ReferenceCountedObjectPointers. */
template <class ReferenceCountedObjectClass>
bool operator== (ReferenceCountedObjectClass* object1, ReferenceCountedObjectPtr<ReferenceCountedObjectClass>& object2) noexcept
{
	return object1 == object2.getObject();
}

/** Compares two ReferenceCountedObjectPointers. */
template <class ReferenceCountedObjectClass>
bool operator!= (const ReferenceCountedObjectPtr<ReferenceCountedObjectClass>& object1, const ReferenceCountedObjectClass* object2) noexcept
{
	return object1.getObject() != object2;
}

/** Compares two ReferenceCountedObjectPointers. */
template <class ReferenceCountedObjectClass>
bool operator!= (const ReferenceCountedObjectPtr<ReferenceCountedObjectClass>& object1, ReferenceCountedObjectPtr<ReferenceCountedObjectClass>& object2) noexcept
{
	return object1.getObject() != object2.getObject();
}

/** Compares two ReferenceCountedObjectPointers. */
template <class ReferenceCountedObjectClass>
bool operator!= (ReferenceCountedObjectClass* object1, ReferenceCountedObjectPtr<ReferenceCountedObjectClass>& object2) noexcept
{
	return object1 != object2.getObject();
}

#endif   // __JUCE_REFERENCECOUNTEDOBJECT_JUCEHEADER__

/*** End of inlined file: juce_ReferenceCountedObject.h ***/

/**
	Represents a dynamically implemented object.

	This class is primarily intended for wrapping scripting language objects,
	but could be used for other purposes.

	An instance of a DynamicObject can be used to store named properties, and
	by subclassing hasMethod() and invokeMethod(), you can give your object
	methods.
*/
class JUCE_API  DynamicObject  : public ReferenceCountedObject
{
public:

	DynamicObject();

	/** Destructor. */
	virtual ~DynamicObject();

	/** Returns true if the object has a property with this name.
		Note that if the property is actually a method, this will return false.
	*/
	virtual bool hasProperty (const Identifier& propertyName) const;

	/** Returns a named property.

		This returns a void if no such property exists.
	*/
	virtual var getProperty (const Identifier& propertyName) const;

	/** Sets a named property. */
	virtual void setProperty (const Identifier& propertyName, const var& newValue);

	/** Removes a named property. */
	virtual void removeProperty (const Identifier& propertyName);

	/** Checks whether this object has the specified method.

		The default implementation of this just checks whether there's a property
		with this name that's actually a method, but this can be overridden for
		building objects with dynamic invocation.
	*/
	virtual bool hasMethod (const Identifier& methodName) const;

	/** Invokes a named method on this object.

		The default implementation looks up the named property, and if it's a method
		call, then it invokes it.

		This method is virtual to allow more dynamic invocation to used for objects
		where the methods may not already be set as properies.
	*/
	virtual var invokeMethod (const Identifier& methodName,
							  const var* parameters,
							  int numParameters);

	/** Sets up a method.

		This is basically the same as calling setProperty (methodName, (var::MethodFunction) myFunction), but
		helps to avoid accidentally invoking the wrong type of var constructor. It also makes
		the code easier to read,

		The compiler will probably force you to use an explicit cast your method to a (var::MethodFunction), e.g.
		@code
		setMethod ("doSomething", (var::MethodFunction) &MyClass::doSomething);
		@endcode
	*/
	void setMethod (const Identifier& methodName,
					var::MethodFunction methodFunction);

	/** Removes all properties and methods from the object. */
	void clear();

	/** Returns the NamedValueSet that holds the object's properties. */
	NamedValueSet& getProperties() noexcept     { return properties; }

private:

	NamedValueSet properties;

	JUCE_LEAK_DETECTOR (DynamicObject);
};

#endif   // __JUCE_DYNAMICOBJECT_JUCEHEADER__

/*** End of inlined file: juce_DynamicObject.h ***/


#endif
#ifndef __JUCE_ELEMENTCOMPARATOR_JUCEHEADER__

#endif
#ifndef __JUCE_HASHMAP_JUCEHEADER__

/*** Start of inlined file: juce_HashMap.h ***/
#ifndef __JUCE_HASHMAP_JUCEHEADER__
#define __JUCE_HASHMAP_JUCEHEADER__


/*** Start of inlined file: juce_OwnedArray.h ***/
#ifndef __JUCE_OWNEDARRAY_JUCEHEADER__
#define __JUCE_OWNEDARRAY_JUCEHEADER__

/** An array designed for holding objects.

	This holds a list of pointers to objects, and will automatically
	delete the objects when they are removed from the array, or when the
	array is itself deleted.

	Declare it in the form:  OwnedArray<MyObjectClass>

	..and then add new objects, e.g.   myOwnedArray.add (new MyObjectClass());

	After adding objects, they are 'owned' by the array and will be deleted when
	removed or replaced.

	To make all the array's methods thread-safe, pass in "CriticalSection" as the templated
	TypeOfCriticalSectionToUse parameter, instead of the default DummyCriticalSection.

	@see Array, ReferenceCountedArray, StringArray, CriticalSection
*/
template <class ObjectClass,
		  class TypeOfCriticalSectionToUse = DummyCriticalSection>

class OwnedArray
{
public:

	/** Creates an empty array. */
	OwnedArray() noexcept
		: numUsed (0)
	{
	}

	/** Deletes the array and also deletes any objects inside it.

		To get rid of the array without deleting its objects, use its
		clear (false) method before deleting it.
	*/
	~OwnedArray()
	{
		clear (true);
	}

   #if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
	OwnedArray (OwnedArray&& other) noexcept
		: data (static_cast <ArrayAllocationBase <ObjectClass*, TypeOfCriticalSectionToUse>&&> (other.data)),
		  numUsed (other.numUsed)
	{
		other.numUsed = 0;
	}

	OwnedArray& operator= (OwnedArray&& other) noexcept
	{
		data = static_cast <ArrayAllocationBase <ObjectClass*, TypeOfCriticalSectionToUse>&&> (other.data);
		numUsed = other.numUsed;
		other.numUsed = 0;
		return *this;
	}
   #endif

	/** Clears the array, optionally deleting the objects inside it first. */
	void clear (const bool deleteObjects = true)
	{
		const ScopedLockType lock (getLock());

		if (deleteObjects)
		{
			while (numUsed > 0)
				delete data.elements [--numUsed];
		}

		data.setAllocatedSize (0);
		numUsed = 0;
	}

	/** Returns the number of items currently in the array.
		@see operator[]
	*/
	inline int size() const noexcept
	{
		return numUsed;
	}

	/** Returns a pointer to the object at this index in the array.

		If the index is out-of-range, this will return a null pointer, (and
		it could be null anyway, because it's ok for the array to hold null
		pointers as well as objects).

		@see getUnchecked
	*/
	inline ObjectClass* operator[] (const int index) const noexcept
	{
		const ScopedLockType lock (getLock());
		return isPositiveAndBelow (index, numUsed) ? data.elements [index]
												   : static_cast <ObjectClass*> (nullptr);
	}

	/** Returns a pointer to the object at this index in the array, without checking whether the index is in-range.

		This is a faster and less safe version of operator[] which doesn't check the index passed in, so
		it can be used when you're sure the index if always going to be legal.
	*/
	inline ObjectClass* getUnchecked (const int index) const noexcept
	{
		const ScopedLockType lock (getLock());
		jassert (isPositiveAndBelow (index, numUsed));
		return data.elements [index];
	}

	/** Returns a pointer to the first object in the array.

		This will return a null pointer if the array's empty.
		@see getLast
	*/
	inline ObjectClass* getFirst() const noexcept
	{
		const ScopedLockType lock (getLock());
		return numUsed > 0 ? data.elements [0]
						   : static_cast <ObjectClass*> (nullptr);
	}

	/** Returns a pointer to the last object in the array.

		This will return a null pointer if the array's empty.
		@see getFirst
	*/
	inline ObjectClass* getLast() const noexcept
	{
		const ScopedLockType lock (getLock());
		return numUsed > 0 ? data.elements [numUsed - 1]
						   : static_cast <ObjectClass*> (nullptr);
	}

	/** Returns a pointer to the actual array data.
		This pointer will only be valid until the next time a non-const method
		is called on the array.
	*/
	inline ObjectClass** getRawDataPointer() noexcept
	{
		return data.elements;
	}

	/** Returns a pointer to the first element in the array.
		This method is provided for compatibility with standard C++ iteration mechanisms.
	*/
	inline ObjectClass** begin() const noexcept
	{
		return data.elements;
	}

	/** Returns a pointer to the element which follows the last element in the array.
		This method is provided for compatibility with standard C++ iteration mechanisms.
	*/
	inline ObjectClass** end() const noexcept
	{
		return data.elements + numUsed;
	}

	/** Finds the index of an object which might be in the array.

		@param objectToLookFor    the object to look for
		@returns                  the index at which the object was found, or -1 if it's not found
	*/
	int indexOf (const ObjectClass* const objectToLookFor) const noexcept
	{
		const ScopedLockType lock (getLock());
		ObjectClass* const* e = data.elements.getData();
		ObjectClass* const* const end_ = e + numUsed;

		for (; e != end_; ++e)
			if (objectToLookFor == *e)
				return static_cast <int> (e - data.elements.getData());

		return -1;
	}

	/** Returns true if the array contains a specified object.

		@param objectToLookFor      the object to look for
		@returns                    true if the object is in the array
	*/
	bool contains (const ObjectClass* const objectToLookFor) const noexcept
	{
		const ScopedLockType lock (getLock());
		ObjectClass* const* e = data.elements.getData();
		ObjectClass* const* const end_ = e + numUsed;

		for (; e != end_; ++e)
			if (objectToLookFor == *e)
				return true;

		return false;
	}

	/** Appends a new object to the end of the array.

		Note that the this object will be deleted by the OwnedArray when it
		is removed, so be careful not to delete it somewhere else.

		Also be careful not to add the same object to the array more than once,
		as this will obviously cause deletion of dangling pointers.

		@param newObject       the new object to add to the array
		@see set, insert, addIfNotAlreadyThere, addSorted
	*/
	void add (const ObjectClass* const newObject) noexcept
	{
		const ScopedLockType lock (getLock());
		data.ensureAllocatedSize (numUsed + 1);
		data.elements [numUsed++] = const_cast <ObjectClass*> (newObject);
	}

	/** Inserts a new object into the array at the given index.

		Note that the this object will be deleted by the OwnedArray when it
		is removed, so be careful not to delete it somewhere else.

		If the index is less than 0 or greater than the size of the array, the
		element will be added to the end of the array.
		Otherwise, it will be inserted into the array, moving all the later elements
		along to make room.

		Be careful not to add the same object to the array more than once,
		as this will obviously cause deletion of dangling pointers.

		@param indexToInsertAt      the index at which the new element should be inserted
		@param newObject            the new object to add to the array
		@see add, addSorted, addIfNotAlreadyThere, set
	*/
	void insert (int indexToInsertAt,
				 const ObjectClass* const newObject) noexcept
	{
		if (indexToInsertAt >= 0)
		{
			const ScopedLockType lock (getLock());

			if (indexToInsertAt > numUsed)
				indexToInsertAt = numUsed;

			data.ensureAllocatedSize (numUsed + 1);

			ObjectClass** const e = data.elements + indexToInsertAt;
			const int numToMove = numUsed - indexToInsertAt;

			if (numToMove > 0)
				memmove (e + 1, e, numToMove * sizeof (ObjectClass*));

			*e = const_cast <ObjectClass*> (newObject);
			++numUsed;
		}
		else
		{
			add (newObject);
		}
	}

	/** Appends a new object at the end of the array as long as the array doesn't
		already contain it.

		If the array already contains a matching object, nothing will be done.

		@param newObject   the new object to add to the array
	*/
	void addIfNotAlreadyThere (const ObjectClass* const newObject) noexcept
	{
		const ScopedLockType lock (getLock());

		if (! contains (newObject))
			add (newObject);
	}

	/** Replaces an object in the array with a different one.

		If the index is less than zero, this method does nothing.
		If the index is beyond the end of the array, the new object is added to the end of the array.

		Be careful not to add the same object to the array more than once,
		as this will obviously cause deletion of dangling pointers.

		@param indexToChange        the index whose value you want to change
		@param newObject            the new value to set for this index.
		@param deleteOldElement     whether to delete the object that's being replaced with the new one
		@see add, insert, remove
	*/
	void set (const int indexToChange,
			  const ObjectClass* const newObject,
			  const bool deleteOldElement = true)
	{
		if (indexToChange >= 0)
		{
			ObjectClass* toDelete = nullptr;

			{
				const ScopedLockType lock (getLock());

				if (indexToChange < numUsed)
				{
					if (deleteOldElement)
					{
						toDelete = data.elements [indexToChange];

						if (toDelete == newObject)
							toDelete = nullptr;
					}

					data.elements [indexToChange] = const_cast <ObjectClass*> (newObject);
				}
				else
				{
					data.ensureAllocatedSize (numUsed + 1);
					data.elements [numUsed++] = const_cast <ObjectClass*> (newObject);
				}
			}

			delete toDelete; // don't want to use a ScopedPointer here because if the
							 // object has a private destructor, both OwnedArray and
							 // ScopedPointer would need to be friend classes..
		}
		else
		{
			jassertfalse; // you're trying to set an object at a negative index, which doesn't have
						  // any effect - but since the object is not being added, it may be leaking..
		}
	}

	/** Adds elements from another array to the end of this array.

		@param arrayToAddFrom       the array from which to copy the elements
		@param startIndex           the first element of the other array to start copying from
		@param numElementsToAdd     how many elements to add from the other array. If this
									value is negative or greater than the number of available elements,
									all available elements will be copied.
		@see add
	*/
	template <class OtherArrayType>
	void addArray (const OtherArrayType& arrayToAddFrom,
				   int startIndex = 0,
				   int numElementsToAdd = -1)
	{
		const typename OtherArrayType::ScopedLockType lock1 (arrayToAddFrom.getLock());
		const ScopedLockType lock2 (getLock());

		if (startIndex < 0)
		{
			jassertfalse;
			startIndex = 0;
		}

		if (numElementsToAdd < 0 || startIndex + numElementsToAdd > arrayToAddFrom.size())
			numElementsToAdd = arrayToAddFrom.size() - startIndex;

		data.ensureAllocatedSize (numUsed + numElementsToAdd);

		while (--numElementsToAdd >= 0)
		{
			data.elements [numUsed] = arrayToAddFrom.getUnchecked (startIndex++);
			++numUsed;
		}
	}

	/** Adds copies of the elements in another array to the end of this array.

		The other array must be either an OwnedArray of a compatible type of object, or an Array
		containing pointers to the same kind of object. The objects involved must provide
		a copy constructor, and this will be used to create new copies of each element, and
		add them to this array.

		@param arrayToAddFrom       the array from which to copy the elements
		@param startIndex           the first element of the other array to start copying from
		@param numElementsToAdd     how many elements to add from the other array. If this
									value is negative or greater than the number of available elements,
									all available elements will be copied.
		@see add
	*/
	template <class OtherArrayType>
	void addCopiesOf (const OtherArrayType& arrayToAddFrom,
					  int startIndex = 0,
					  int numElementsToAdd = -1)
	{
		const typename OtherArrayType::ScopedLockType lock1 (arrayToAddFrom.getLock());
		const ScopedLockType lock2 (getLock());

		if (startIndex < 0)
		{
			jassertfalse;
			startIndex = 0;
		}

		if (numElementsToAdd < 0 || startIndex + numElementsToAdd > arrayToAddFrom.size())
			numElementsToAdd = arrayToAddFrom.size() - startIndex;

		data.ensureAllocatedSize (numUsed + numElementsToAdd);

		while (--numElementsToAdd >= 0)
		{
			data.elements [numUsed] = new ObjectClass (*arrayToAddFrom.getUnchecked (startIndex++));
			++numUsed;
		}
	}

	/** Inserts a new object into the array assuming that the array is sorted.

		This will use a comparator to find the position at which the new object
		should go. If the array isn't sorted, the behaviour of this
		method will be unpredictable.

		@param comparator   the comparator to use to compare the elements - see the sort method
							for details about this object's structure
		@param newObject    the new object to insert to the array
		@returns the index at which the new object was added
		@see add, sort, indexOfSorted
	*/
	template <class ElementComparator>
	int addSorted (ElementComparator& comparator, ObjectClass* const newObject) noexcept
	{
		(void) comparator;  // if you pass in an object with a static compareElements() method, this
							// avoids getting warning messages about the parameter being unused
		const ScopedLockType lock (getLock());
		const int index = findInsertIndexInSortedArray (comparator, data.elements.getData(), newObject, 0, numUsed);
		insert (index, newObject);
		return index;
	}

	/** Finds the index of an object in the array, assuming that the array is sorted.

		This will use a comparator to do a binary-chop to find the index of the given
		element, if it exists. If the array isn't sorted, the behaviour of this
		method will be unpredictable.

		@param comparator           the comparator to use to compare the elements - see the sort()
									method for details about the form this object should take
		@param objectToLookFor      the object to search for
		@returns                    the index of the element, or -1 if it's not found
		@see addSorted, sort
	*/
	template <class ElementComparator>
	int indexOfSorted (ElementComparator& comparator,
					   const ObjectClass* const objectToLookFor) const noexcept
	{
		(void) comparator;  // if you pass in an object with a static compareElements() method, this
							// avoids getting warning messages about the parameter being unused
		const ScopedLockType lock (getLock());

		int start = 0;
		int end_ = numUsed;

		for (;;)
		{
			if (start >= end_)
			{
				return -1;
			}
			else if (comparator.compareElements (objectToLookFor, data.elements [start]) == 0)
			{
				return start;
			}
			else
			{
				const int halfway = (start + end_) >> 1;

				if (halfway == start)
					return -1;
				else if (comparator.compareElements (objectToLookFor, data.elements [halfway]) >= 0)
					start = halfway;
				else
					end_ = halfway;
			}
		}
	}

	/** Removes an object from the array.

		This will remove the object at a given index (optionally also
		deleting it) and move back all the subsequent objects to close the gap.
		If the index passed in is out-of-range, nothing will happen.

		@param indexToRemove    the index of the element to remove
		@param deleteObject     whether to delete the object that is removed
		@see removeObject, removeRange
	*/
	void remove (const int indexToRemove,
				 const bool deleteObject = true)
	{
		ObjectClass* toDelete = nullptr;

		{
			const ScopedLockType lock (getLock());

			if (isPositiveAndBelow (indexToRemove, numUsed))
			{
				ObjectClass** const e = data.elements + indexToRemove;

				if (deleteObject)
					toDelete = *e;

				--numUsed;
				const int numToShift = numUsed - indexToRemove;

				if (numToShift > 0)
					memmove (e, e + 1, numToShift * sizeof (ObjectClass*));
			}
		}

		delete toDelete; // don't want to use a ScopedPointer here because if the
						 // object has a private destructor, both OwnedArray and
						 // ScopedPointer would need to be friend classes..

		if ((numUsed << 1) < data.numAllocated)
			minimiseStorageOverheads();
	}

	/** Removes and returns an object from the array without deleting it.

		This will remove the object at a given index and return it, moving back all
		the subsequent objects to close the gap. If the index passed in is out-of-range,
		nothing will happen.

		@param indexToRemove    the index of the element to remove
		@see remove, removeObject, removeRange
	*/
	ObjectClass* removeAndReturn (const int indexToRemove)
	{
		ObjectClass* removedItem = nullptr;
		const ScopedLockType lock (getLock());

		if (isPositiveAndBelow (indexToRemove, numUsed))
		{
			ObjectClass** const e = data.elements + indexToRemove;
			removedItem = *e;

			--numUsed;
			const int numToShift = numUsed - indexToRemove;

			if (numToShift > 0)
				memmove (e, e + 1, numToShift * sizeof (ObjectClass*));

			if ((numUsed << 1) < data.numAllocated)
				minimiseStorageOverheads();
		}

		return removedItem;
	}

	/** Removes a specified object from the array.

		If the item isn't found, no action is taken.

		@param objectToRemove   the object to try to remove
		@param deleteObject     whether to delete the object (if it's found)
		@see remove, removeRange
	*/
	void removeObject (const ObjectClass* const objectToRemove,
					   const bool deleteObject = true)
	{
		const ScopedLockType lock (getLock());
		ObjectClass** const e = data.elements.getData();

		for (int i = 0; i < numUsed; ++i)
		{
			if (objectToRemove == e[i])
			{
				remove (i, deleteObject);
				break;
			}
		}
	}

	/** Removes a range of objects from the array.

		This will remove a set of objects, starting from the given index,
		and move any subsequent elements down to close the gap.

		If the range extends beyond the bounds of the array, it will
		be safely clipped to the size of the array.

		@param startIndex       the index of the first object to remove
		@param numberToRemove   how many objects should be removed
		@param deleteObjects    whether to delete the objects that get removed
		@see remove, removeObject
	*/
	void removeRange (int startIndex,
					  const int numberToRemove,
					  const bool deleteObjects = true)
	{
		const ScopedLockType lock (getLock());
		const int endIndex = jlimit (0, numUsed, startIndex + numberToRemove);
		startIndex = jlimit (0, numUsed, startIndex);

		if (endIndex > startIndex)
		{
			if (deleteObjects)
			{
				for (int i = startIndex; i < endIndex; ++i)
				{
					delete data.elements [i];
					data.elements [i] = nullptr; // (in case one of the destructors accesses this array and hits a dangling pointer)
				}
			}

			const int rangeSize = endIndex - startIndex;
			ObjectClass** e = data.elements + startIndex;
			int numToShift = numUsed - endIndex;
			numUsed -= rangeSize;

			while (--numToShift >= 0)
			{
				*e = e [rangeSize];
				++e;
			}

			if ((numUsed << 1) < data.numAllocated)
				minimiseStorageOverheads();
		}
	}

	/** Removes the last n objects from the array.

		@param howManyToRemove   how many objects to remove from the end of the array
		@param deleteObjects     whether to also delete the objects that are removed
		@see remove, removeObject, removeRange
	*/
	void removeLast (int howManyToRemove = 1,
					 const bool deleteObjects = true)
	{
		const ScopedLockType lock (getLock());

		if (howManyToRemove >= numUsed)
			clear (deleteObjects);
		else
			removeRange (numUsed - howManyToRemove, howManyToRemove, deleteObjects);
	}

	/** Swaps a pair of objects in the array.

		If either of the indexes passed in is out-of-range, nothing will happen,
		otherwise the two objects at these positions will be exchanged.
	*/
	void swap (const int index1,
			   const int index2) noexcept
	{
		const ScopedLockType lock (getLock());

		if (isPositiveAndBelow (index1, numUsed)
			 && isPositiveAndBelow (index2, numUsed))
		{
			swapVariables (data.elements [index1],
						   data.elements [index2]);
		}
	}

	/** Moves one of the objects to a different position.

		This will move the object to a specified index, shuffling along
		any intervening elements as required.

		So for example, if you have the array { 0, 1, 2, 3, 4, 5 } then calling
		move (2, 4) would result in { 0, 1, 3, 4, 2, 5 }.

		@param currentIndex     the index of the object to be moved. If this isn't a
								valid index, then nothing will be done
		@param newIndex         the index at which you'd like this object to end up. If this
								is less than zero, it will be moved to the end of the array
	*/
	void move (const int currentIndex,
			   int newIndex) noexcept
	{
		if (currentIndex != newIndex)
		{
			const ScopedLockType lock (getLock());

			if (isPositiveAndBelow (currentIndex, numUsed))
			{
				if (! isPositiveAndBelow (newIndex, numUsed))
					newIndex = numUsed - 1;

				ObjectClass* const value = data.elements [currentIndex];

				if (newIndex > currentIndex)
				{
					memmove (data.elements + currentIndex,
							 data.elements + currentIndex + 1,
							 (newIndex - currentIndex) * sizeof (ObjectClass*));
				}
				else
				{
					memmove (data.elements + newIndex + 1,
							 data.elements + newIndex,
							 (currentIndex - newIndex) * sizeof (ObjectClass*));
				}

				data.elements [newIndex] = value;
			}
		}
	}

	/** This swaps the contents of this array with those of another array.

		If you need to exchange two arrays, this is vastly quicker than using copy-by-value
		because it just swaps their internal pointers.
	*/
	void swapWithArray (OwnedArray& otherArray) noexcept
	{
		const ScopedLockType lock1 (getLock());
		const ScopedLockType lock2 (otherArray.getLock());

		data.swapWith (otherArray.data);
		swapVariables (numUsed, otherArray.numUsed);
	}

	/** Reduces the amount of storage being used by the array.

		Arrays typically allocate slightly more storage than they need, and after
		removing elements, they may have quite a lot of unused space allocated.
		This method will reduce the amount of allocated storage to a minimum.
	*/
	void minimiseStorageOverheads() noexcept
	{
		const ScopedLockType lock (getLock());
		data.shrinkToNoMoreThan (numUsed);
	}

	/** Increases the array's internal storage to hold a minimum number of elements.

		Calling this before adding a large known number of elements means that
		the array won't have to keep dynamically resizing itself as the elements
		are added, and it'll therefore be more efficient.
	*/
	void ensureStorageAllocated (const int minNumElements) noexcept
	{
		const ScopedLockType lock (getLock());
		data.ensureAllocatedSize (minNumElements);
	}

	/** Sorts the elements in the array.

		This will use a comparator object to sort the elements into order. The object
		passed must have a method of the form:
		@code
		int compareElements (ElementType first, ElementType second);
		@endcode

		..and this method must return:
		  - a value of < 0 if the first comes before the second
		  - a value of 0 if the two objects are equivalent
		  - a value of > 0 if the second comes before the first

		To improve performance, the compareElements() method can be declared as static or const.

		@param comparator   the comparator to use for comparing elements.
		@param retainOrderOfEquivalentItems     if this is true, then items
							which the comparator says are equivalent will be
							kept in the order in which they currently appear
							in the array. This is slower to perform, but may
							be important in some cases. If it's false, a faster
							algorithm is used, but equivalent elements may be
							rearranged.
		@see sortArray, indexOfSorted
	*/
	template <class ElementComparator>
	void sort (ElementComparator& comparator,
			   const bool retainOrderOfEquivalentItems = false) const noexcept
	{
		(void) comparator;  // if you pass in an object with a static compareElements() method, this
							// avoids getting warning messages about the parameter being unused

		const ScopedLockType lock (getLock());
		sortArray (comparator, data.elements.getData(), 0, size() - 1, retainOrderOfEquivalentItems);
	}

	/** Returns the CriticalSection that locks this array.
		To lock, you can call getLock().enter() and getLock().exit(), or preferably use
		an object of ScopedLockType as an RAII lock for it.
	*/
	inline const TypeOfCriticalSectionToUse& getLock() const noexcept      { return data; }

	/** Returns the type of scoped lock to use for locking this array */
	typedef typename TypeOfCriticalSectionToUse::ScopedLockType ScopedLockType;

private:

	ArrayAllocationBase <ObjectClass*, TypeOfCriticalSectionToUse> data;
	int numUsed;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (OwnedArray);
};

#endif   // __JUCE_OWNEDARRAY_JUCEHEADER__

/*** End of inlined file: juce_OwnedArray.h ***/


/*** Start of inlined file: juce_ScopedPointer.h ***/
#ifndef __JUCE_SCOPEDPOINTER_JUCEHEADER__
#define __JUCE_SCOPEDPOINTER_JUCEHEADER__

/**
	This class holds a pointer which is automatically deleted when this object goes
	out of scope.

	Once a pointer has been passed to a ScopedPointer, it will make sure that the pointer
	gets deleted when the ScopedPointer is deleted. Using the ScopedPointer on the stack or
	as member variables is a good way to use RAII to avoid accidentally leaking dynamically
	created objects.

	A ScopedPointer can be used in pretty much the same way that you'd use a normal pointer
	to an object. If you use the assignment operator to assign a different object to a
	ScopedPointer, the old one will be automatically deleted.

	A const ScopedPointer is guaranteed not to lose ownership of its object or change the
	object to which it points during its lifetime. This means that making a copy of a const
	ScopedPointer is impossible, as that would involve the new copy taking ownership from the
	old one.

	If you need to get a pointer out of a ScopedPointer without it being deleted, you
	can use the release() method.

	Something to note is the main difference between this class and the std::auto_ptr class,
	which is that ScopedPointer provides a cast-to-object operator, wheras std::auto_ptr
	requires that you always call get() to retrieve the pointer. The advantages of providing
	the cast is that you don't need to call get(), so can use the ScopedPointer in pretty much
	exactly the same way as a raw pointer. The disadvantage is that the compiler is free to
	use the cast in unexpected and sometimes dangerous ways - in particular, it becomes difficult
	to return a ScopedPointer as the result of a function. To avoid this causing errors,
	ScopedPointer contains an overloaded constructor that should cause a syntax error in these
	circumstances, but it does mean that instead of returning a ScopedPointer from a function,
	you'd need to return a raw pointer (or use a std::auto_ptr instead).
*/
template <class ObjectType>
class ScopedPointer
{
public:

	/** Creates a ScopedPointer containing a null pointer. */
	inline ScopedPointer() noexcept   : object (nullptr)
	{
	}

	/** Creates a ScopedPointer that owns the specified object. */
	inline ScopedPointer (ObjectType* const objectToTakePossessionOf) noexcept
		: object (objectToTakePossessionOf)
	{
	}

	/** Creates a ScopedPointer that takes its pointer from another ScopedPointer.

		Because a pointer can only belong to one ScopedPointer, this transfers
		the pointer from the other object to this one, and the other object is reset to
		be a null pointer.
	*/
	ScopedPointer (ScopedPointer& objectToTransferFrom) noexcept
		: object (objectToTransferFrom.object)
	{
		objectToTransferFrom.object = nullptr;
	}

	/** Destructor.
		This will delete the object that this ScopedPointer currently refers to.
	*/
	inline ~ScopedPointer()                                                         { delete object; }

	/** Changes this ScopedPointer to point to a new object.

		Because a pointer can only belong to one ScopedPointer, this transfers
		the pointer from the other object to this one, and the other object is reset to
		be a null pointer.

		If this ScopedPointer already points to an object, that object
		will first be deleted.
	*/
	ScopedPointer& operator= (ScopedPointer& objectToTransferFrom)
	{
		if (this != objectToTransferFrom.getAddress())
		{
			// Two ScopedPointers should never be able to refer to the same object - if
			// this happens, you must have done something dodgy!
			jassert (object == nullptr || object != objectToTransferFrom.object);

			ObjectType* const oldObject = object;
			object = objectToTransferFrom.object;
			objectToTransferFrom.object = nullptr;
			delete oldObject;
		}

		return *this;
	}

	/** Changes this ScopedPointer to point to a new object.

		If this ScopedPointer already points to an object, that object
		will first be deleted.

		The pointer that you pass is may be null.
	*/
	ScopedPointer& operator= (ObjectType* const newObjectToTakePossessionOf)
	{
		if (object != newObjectToTakePossessionOf)
		{
			ObjectType* const oldObject = object;
			object = newObjectToTakePossessionOf;
			delete oldObject;
		}

		return *this;
	}

	/** Returns the object that this ScopedPointer refers to. */
	inline operator ObjectType*() const noexcept                                    { return object; }

	/** Returns the object that this ScopedPointer refers to. */
	inline ObjectType* get() const noexcept                                         { return object; }

	/** Returns the object that this ScopedPointer refers to. */
	inline ObjectType& operator*() const noexcept                                   { return *object; }

	/** Lets you access methods and properties of the object that this ScopedPointer refers to. */
	inline ObjectType* operator->() const noexcept                                  { return object; }

	/** Removes the current object from this ScopedPointer without deleting it.
		This will return the current object, and set the ScopedPointer to a null pointer.
	*/
	ObjectType* release() noexcept                                                  { ObjectType* const o = object; object = nullptr; return o; }

	/** Swaps this object with that of another ScopedPointer.
		The two objects simply exchange their pointers.
	*/
	void swapWith (ScopedPointer <ObjectType>& other) noexcept
	{
		// Two ScopedPointers should never be able to refer to the same object - if
		// this happens, you must have done something dodgy!
		jassert (object != other.object);

		std::swap (object, other.object);
	}

	/** If the pointer is non-null, this will attempt to return a new copy of the object that is pointed to.
		If the pointer is null, this will safely return a nullptr.
	*/
	inline ObjectType* createCopy() const                                           { return createCopyIfNotNull (object); }

private:

	ObjectType* object;

	// (Required as an alternative to the overloaded & operator).
	const ScopedPointer* getAddress() const noexcept                                { return this; }

  #if ! JUCE_MSVC  // (MSVC can't deal with multiple copy constructors)
	/* These are private to stop people accidentally copying a const ScopedPointer (the compiler
	   would let you do so by implicitly casting the source to its raw object pointer).

	   A side effect of this is that you may hit a puzzling compiler error when you write something
	   like this:

		  ScopedPointer<MyClass> m = new MyClass();  // Compile error: copy constructor is private.

	   Even though the compiler would normally ignore the assignment here, it can't do so when the
	   copy constructor is private. It's very easy to fis though - just write it like this:

		  ScopedPointer<MyClass> m (new MyClass());  // Compiles OK

	   It's good practice to always use the latter form when writing your object declarations anyway,
	   rather than writing them as assignments and assuming (or hoping) that the compiler will be
	   smart enough to replace your construction + assignment with a single constructor.
	*/
	ScopedPointer (const ScopedPointer&);
	ScopedPointer& operator= (const ScopedPointer&);
  #endif
};

/** Compares a ScopedPointer with another pointer.
	This can be handy for checking whether this is a null pointer.
*/
template <class ObjectType>
bool operator== (const ScopedPointer<ObjectType>& pointer1, ObjectType* const pointer2) noexcept
{
	return static_cast <ObjectType*> (pointer1) == pointer2;
}

/** Compares a ScopedPointer with another pointer.
	This can be handy for checking whether this is a null pointer.
*/
template <class ObjectType>
bool operator!= (const ScopedPointer<ObjectType>& pointer1, ObjectType* const pointer2) noexcept
{
	return static_cast <ObjectType*> (pointer1) != pointer2;
}

#endif   // __JUCE_SCOPEDPOINTER_JUCEHEADER__

/*** End of inlined file: juce_ScopedPointer.h ***/

/**
	A simple class to generate hash functions for some primitive types, intended for
	use with the HashMap class.
	@see HashMap
*/
class DefaultHashFunctions
{
public:
	/** Generates a simple hash from an integer. */
	static int generateHash (const int key, const int upperLimit) noexcept        { return std::abs (key) % upperLimit; }
	/** Generates a simple hash from a string. */
	static int generateHash (const String& key, const int upperLimit) noexcept    { return (int) (((uint32) key.hashCode()) % upperLimit); }
	/** Generates a simple hash from a variant. */
	static int generateHash (const var& key, const int upperLimit) noexcept       { return generateHash (key.toString(), upperLimit); }
};

/**
	Holds a set of mappings between some key/value pairs.

	The types of the key and value objects are set as template parameters.
	You can also specify a class to supply a hash function that converts a key value
	into an hashed integer. This class must have the form:

	@code
	struct MyHashGenerator
	{
		static int generateHash (MyKeyType key, int upperLimit)
		{
			// The function must return a value 0 <= x < upperLimit
			return someFunctionOfMyKeyType (key) % upperLimit;
		}
	};
	@endcode

	Like the Array class, the key and value types are expected to be copy-by-value types, so
	if you define them to be pointer types, this class won't delete the objects that they
	point to.

	If you don't supply a class for the HashFunctionToUse template parameter, the
	default one provides some simple mappings for strings and ints.

	@code
	HashMap<int, String> hash;
	hash.set (1, "item1");
	hash.set (2, "item2");

	DBG (hash [1]); // prints "item1"
	DBG (hash [2]); // prints "item2"

	// This iterates the map, printing all of its key -> value pairs..
	for (HashMap<int, String>::Iterator i (hash); i.next();)
		DBG (i.getKey() << " -> " << i.getValue());
	@endcode

	@see CriticalSection, DefaultHashFunctions, NamedValueSet, SortedSet
*/
template <typename KeyType,
		  typename ValueType,
		  class HashFunctionToUse = DefaultHashFunctions,
		  class TypeOfCriticalSectionToUse = DummyCriticalSection>
class HashMap
{
private:
	typedef PARAMETER_TYPE (KeyType)   KeyTypeParameter;
	typedef PARAMETER_TYPE (ValueType) ValueTypeParameter;

public:

	/** Creates an empty hash-map.

		The numberOfSlots parameter specifies the number of hash entries the map will use. This
		will be the "upperLimit" parameter that is passed to your generateHash() function. The number
		of hash slots will grow automatically if necessary, or it can be remapped manually using remapTable().
	*/
	explicit HashMap (const int numberOfSlots = defaultHashTableSize)
	   : totalNumItems (0)
	{
		slots.insertMultiple (0, nullptr, numberOfSlots);
	}

	/** Destructor. */
	~HashMap()
	{
		clear();
	}

	/** Removes all values from the map.
		Note that this will clear the content, but won't affect the number of slots (see
		remapTable and getNumSlots).
	*/
	void clear()
	{
		const ScopedLockType sl (getLock());

		for (int i = slots.size(); --i >= 0;)
		{
			HashEntry* h = slots.getUnchecked(i);

			while (h != nullptr)
			{
				const ScopedPointer<HashEntry> deleter (h);
				h = h->nextEntry;
			}

			slots.set (i, nullptr);
		}

		totalNumItems = 0;
	}

	/** Returns the current number of items in the map. */
	inline int size() const noexcept
	{
		return totalNumItems;
	}

	/** Returns the value corresponding to a given key.
		If the map doesn't contain the key, a default instance of the value type is returned.
		@param keyToLookFor    the key of the item being requested
	*/
	inline const ValueType operator[] (KeyTypeParameter keyToLookFor) const
	{
		const ScopedLockType sl (getLock());

		for (const HashEntry* entry = slots.getUnchecked (generateHashFor (keyToLookFor)); entry != nullptr; entry = entry->nextEntry)
			if (entry->key == keyToLookFor)
				return entry->value;

		return ValueType();
	}

	/** Returns true if the map contains an item with the specied key. */
	bool contains (KeyTypeParameter keyToLookFor) const
	{
		const ScopedLockType sl (getLock());

		for (const HashEntry* entry = slots.getUnchecked (generateHashFor (keyToLookFor)); entry != nullptr; entry = entry->nextEntry)
			if (entry->key == keyToLookFor)
				return true;

		return false;
	}

	/** Returns true if the hash contains at least one occurrence of a given value. */
	bool containsValue (ValueTypeParameter valueToLookFor) const
	{
		const ScopedLockType sl (getLock());

		for (int i = getNumSlots(); --i >= 0;)
			for (const HashEntry* entry = slots.getUnchecked(i); entry != nullptr; entry = entry->nextEntry)
				if (entry->value == valueToLookFor)
					return true;

		return false;
	}

	/** Adds or replaces an element in the hash-map.
		If there's already an item with the given key, this will replace its value. Otherwise, a new item
		will be added to the map.
	*/
	void set (KeyTypeParameter newKey, ValueTypeParameter newValue)
	{
		const ScopedLockType sl (getLock());
		const int hashIndex = generateHashFor (newKey);

		HashEntry* const firstEntry = slots.getUnchecked (hashIndex);

		for (HashEntry* entry = firstEntry; entry != nullptr; entry = entry->nextEntry)
		{
			if (entry->key == newKey)
			{
				entry->value = newValue;
				return;
			}
		}

		slots.set (hashIndex, new HashEntry (newKey, newValue, firstEntry));
		++totalNumItems;

		if (totalNumItems > (getNumSlots() * 3) / 2)
			remapTable (getNumSlots() * 2);
	}

	/** Removes an item with the given key. */
	void remove (KeyTypeParameter keyToRemove)
	{
		const ScopedLockType sl (getLock());
		const int hashIndex = generateHashFor (keyToRemove);
		HashEntry* entry = slots.getUnchecked (hashIndex);
		HashEntry* previous = nullptr;

		while (entry != nullptr)
		{
			if (entry->key == keyToRemove)
			{
				const ScopedPointer<HashEntry> deleter (entry);

				entry = entry->nextEntry;

				if (previous != nullptr)
					previous->nextEntry = entry;
				else
					slots.set (hashIndex, entry);

				--totalNumItems;
			}
			else
			{
				previous = entry;
				entry = entry->nextEntry;
			}
		}
	}

	/** Removes all items with the given value. */
	void removeValue (ValueTypeParameter valueToRemove)
	{
		const ScopedLockType sl (getLock());

		for (int i = getNumSlots(); --i >= 0;)
		{
			HashEntry* entry = slots.getUnchecked(i);
			HashEntry* previous = nullptr;

			while (entry != nullptr)
			{
				if (entry->value == valueToRemove)
				{
					const ScopedPointer<HashEntry> deleter (entry);

					entry = entry->nextEntry;

					if (previous != nullptr)
						previous->nextEntry = entry;
					else
						slots.set (i, entry);

					--totalNumItems;
				}
				else
				{
					previous = entry;
					entry = entry->nextEntry;
				}
			}
		}
	}

	/** Remaps the hash-map to use a different number of slots for its hash function.
		Each slot corresponds to a single hash-code, and each one can contain multiple items.
		@see getNumSlots()
	*/
	void remapTable (int newNumberOfSlots)
	{
		HashMap newTable (newNumberOfSlots);

		for (int i = getNumSlots(); --i >= 0;)
			for (const HashEntry* entry = slots.getUnchecked(i); entry != nullptr; entry = entry->nextEntry)
				newTable.set (entry->key, entry->value);

		swapWith (newTable);
	}

	/** Returns the number of slots which are available for hashing.
		Each slot corresponds to a single hash-code, and each one can contain multiple items.
		@see getNumSlots()
	*/
	inline int getNumSlots() const noexcept
	{
		return slots.size();
	}

	/** Efficiently swaps the contents of two hash-maps. */
	void swapWith (HashMap& otherHashMap) noexcept
	{
		const ScopedLockType lock1 (getLock());
		const ScopedLockType lock2 (otherHashMap.getLock());

		slots.swapWithArray (otherHashMap.slots);
		std::swap (totalNumItems, otherHashMap.totalNumItems);
	}

	/** Returns the CriticalSection that locks this structure.
		To lock, you can call getLock().enter() and getLock().exit(), or preferably use
		an object of ScopedLockType as an RAII lock for it.
	*/
	inline const TypeOfCriticalSectionToUse& getLock() const noexcept      { return lock; }

	/** Returns the type of scoped lock to use for locking this array */
	typedef typename TypeOfCriticalSectionToUse::ScopedLockType ScopedLockType;

private:

	class HashEntry
	{
	public:
		HashEntry (KeyTypeParameter key_, ValueTypeParameter value_, HashEntry* const nextEntry_)
			: key (key_), value (value_), nextEntry (nextEntry_)
		{}

		const KeyType key;
		ValueType value;
		HashEntry* nextEntry;

		JUCE_DECLARE_NON_COPYABLE (HashEntry);
	};

public:

	/** Iterates over the items in a HashMap.

		To use it, repeatedly call next() until it returns false, e.g.
		@code
		HashMap <String, String> myMap;

		HashMap<String, String>::Iterator i (myMap);

		while (i.next())
		{
			DBG (i.getKey() << " -> " << i.getValue());
		}
		@endcode

		The order in which items are iterated bears no resemblence to the order in which
		they were originally added!

		Obviously as soon as you call any non-const methods on the original hash-map, any
		iterators that were created beforehand will cease to be valid, and should not be used.

		@see HashMap
	*/
	class Iterator
	{
	public:

		Iterator (const HashMap& hashMapToIterate)
			: hashMap (hashMapToIterate), entry (nullptr), index (0)
		{}

		/** Moves to the next item, if one is available.
			When this returns true, you can get the item's key and value using getKey() and
			getValue(). If it returns false, the iteration has finished and you should stop.
		*/
		bool next()
		{
			if (entry != nullptr)
				entry = entry->nextEntry;

			while (entry == nullptr)
			{
				if (index >= hashMap.getNumSlots())
					return false;

				entry = hashMap.slots.getUnchecked (index++);
			}

			return true;
		}

		/** Returns the current item's key.
			This should only be called when a call to next() has just returned true.
		*/
		KeyType getKey() const
		{
			return entry != nullptr ? entry->key : KeyType();
		}

		/** Returns the current item's value.
			This should only be called when a call to next() has just returned true.
		*/
		ValueType getValue() const
		{
			return entry != nullptr ? entry->value : ValueType();
		}

	private:

		const HashMap& hashMap;
		HashEntry* entry;
		int index;

		JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (Iterator);
	};

private:

	enum { defaultHashTableSize = 101 };
	friend class Iterator;

	Array <HashEntry*> slots;
	int totalNumItems;
	TypeOfCriticalSectionToUse lock;

	int generateHashFor (KeyTypeParameter key) const
	{
		const int hash = HashFunctionToUse::generateHash (key, getNumSlots());
		jassert (isPositiveAndBelow (hash, getNumSlots())); // your hash function is generating out-of-range numbers!
		return hash;
	}

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (HashMap);
};

#endif   // __JUCE_HASHMAP_JUCEHEADER__

/*** End of inlined file: juce_HashMap.h ***/


#endif
#ifndef __JUCE_LINKEDLISTPOINTER_JUCEHEADER__

#endif
#ifndef __JUCE_NAMEDVALUESET_JUCEHEADER__

#endif
#ifndef __JUCE_OWNEDARRAY_JUCEHEADER__

#endif
#ifndef __JUCE_PROPERTYSET_JUCEHEADER__

/*** Start of inlined file: juce_PropertySet.h ***/
#ifndef __JUCE_PROPERTYSET_JUCEHEADER__
#define __JUCE_PROPERTYSET_JUCEHEADER__


/*** Start of inlined file: juce_StringPairArray.h ***/
#ifndef __JUCE_STRINGPAIRARRAY_JUCEHEADER__
#define __JUCE_STRINGPAIRARRAY_JUCEHEADER__


/*** Start of inlined file: juce_StringArray.h ***/
#ifndef __JUCE_STRINGARRAY_JUCEHEADER__
#define __JUCE_STRINGARRAY_JUCEHEADER__

/**
	A special array for holding a list of strings.

	@see String, StringPairArray
*/
class JUCE_API  StringArray
{
public:

	/** Creates an empty string array */
	StringArray() noexcept;

	/** Creates a copy of another string array */
	StringArray (const StringArray& other);

   #if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
	StringArray (StringArray&& other) noexcept;
   #endif

	/** Creates an array containing a single string. */
	explicit StringArray (const String& firstValue);

	/** Creates a copy of an array of string literals.
		@param strings          an array of strings to add. Null pointers in the array will be
								treated as empty strings
		@param numberOfStrings  how many items there are in the array
	*/
	StringArray (const char* const* strings, int numberOfStrings);

	/** Creates a copy of a null-terminated array of string literals.

		Each item from the array passed-in is added, until it encounters a null pointer,
		at which point it stops.
	*/
	explicit StringArray (const char* const* strings);

	/** Creates a copy of a null-terminated array of string literals.
		Each item from the array passed-in is added, until it encounters a null pointer,
		at which point it stops.
	*/
	explicit StringArray (const wchar_t* const* strings);

	/** Creates a copy of an array of string literals.
		@param strings          an array of strings to add. Null pointers in the array will be
								treated as empty strings
		@param numberOfStrings  how many items there are in the array
	*/
	StringArray (const wchar_t* const* strings, int numberOfStrings);

	/** Destructor. */
	~StringArray();

	/** Copies the contents of another string array into this one */
	StringArray& operator= (const StringArray& other);

   #if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
	StringArray& operator= (StringArray&& other) noexcept;
   #endif

	/** Compares two arrays.
		Comparisons are case-sensitive.
		@returns    true only if the other array contains exactly the same strings in the same order
	*/
	bool operator== (const StringArray& other) const noexcept;

	/** Compares two arrays.
		Comparisons are case-sensitive.
		@returns    false if the other array contains exactly the same strings in the same order
	*/
	bool operator!= (const StringArray& other) const noexcept;

	/** Returns the number of strings in the array */
	inline int size() const noexcept                                    { return strings.size(); };

	/** Returns one of the strings from the array.

		If the index is out-of-range, an empty string is returned.

		Obviously the reference returned shouldn't be stored for later use, as the
		string it refers to may disappear when the array changes.
	*/
	const String& operator[] (int index) const noexcept;

	/** Returns a reference to one of the strings in the array.
		This lets you modify a string in-place in the array, but you must be sure that
		the index is in-range.
	*/
	String& getReference (int index) noexcept;

	/** Searches for a string in the array.

		The comparison will be case-insensitive if the ignoreCase parameter is true.

		@returns    true if the string is found inside the array
	*/
	bool contains (const String& stringToLookFor,
				   bool ignoreCase = false) const;

	/** Searches for a string in the array.

		The comparison will be case-insensitive if the ignoreCase parameter is true.

		@param stringToLookFor  the string to try to find
		@param ignoreCase       whether the comparison should be case-insensitive
		@param startIndex       the first index to start searching from
		@returns                the index of the first occurrence of the string in this array,
								or -1 if it isn't found.
	*/
	int indexOf (const String& stringToLookFor,
				 bool ignoreCase = false,
				 int startIndex = 0) const;

	/** Appends a string at the end of the array. */
	void add (const String& stringToAdd);

	/** Inserts a string into the array.

		This will insert a string into the array at the given index, moving
		up the other elements to make room for it.
		If the index is less than zero or greater than the size of the array,
		the new string will be added to the end of the array.
	*/
	void insert (int index, const String& stringToAdd);

	/** Adds a string to the array as long as it's not already in there.

		The search can optionally be case-insensitive.
	*/
	void addIfNotAlreadyThere (const String& stringToAdd, bool ignoreCase = false);

	/** Replaces one of the strings in the array with another one.

		If the index is higher than the array's size, the new string will be
		added to the end of the array; if it's less than zero nothing happens.
	*/
	void set (int index, const String& newString);

	/** Appends some strings from another array to the end of this one.

		@param other                the array to add
		@param startIndex           the first element of the other array to add
		@param numElementsToAdd     the maximum number of elements to add (if this is
									less than zero, they are all added)
	*/
	void addArray (const StringArray& other,
				   int startIndex = 0,
				   int numElementsToAdd = -1);

	/** Breaks up a string into tokens and adds them to this array.

		This will tokenise the given string using whitespace characters as the
		token delimiters, and will add these tokens to the end of the array.

		@returns    the number of tokens added
	*/
	int addTokens (const String& stringToTokenise,
				   bool preserveQuotedStrings);

	/** Breaks up a string into tokens and adds them to this array.

		This will tokenise the given string (using the string passed in to define the
		token delimiters), and will add these tokens to the end of the array.

		@param stringToTokenise     the string to tokenise
		@param breakCharacters      a string of characters, any of which will be considered
									to be a token delimiter.
		@param quoteCharacters      if this string isn't empty, it defines a set of characters
									which are treated as quotes. Any text occurring
									between quotes is not broken up into tokens.
		@returns    the number of tokens added
	*/
	int addTokens (const String& stringToTokenise,
				   const String& breakCharacters,
				   const String& quoteCharacters);

	/** Breaks up a string into lines and adds them to this array.

		This breaks a string down into lines separated by \\n or \\r\\n, and adds each line
		to the array. Line-break characters are omitted from the strings that are added to
		the array.
	*/
	int addLines (const String& stringToBreakUp);

	/** Removes all elements from the array. */
	void clear();

	/** Removes a string from the array.

		If the index is out-of-range, no action will be taken.
	*/
	void remove (int index);

	/** Finds a string in the array and removes it.

		This will remove the first occurrence of the given string from the array. The
		comparison may be case-insensitive depending on the ignoreCase parameter.
	*/
	void removeString (const String& stringToRemove,
					   bool ignoreCase = false);

	/** Removes a range of elements from the array.

		This will remove a set of elements, starting from the given index,
		and move subsequent elements down to close the gap.

		If the range extends beyond the bounds of the array, it will
		be safely clipped to the size of the array.

		@param startIndex       the index of the first element to remove
		@param numberToRemove   how many elements should be removed
	*/
	void removeRange (int startIndex, int numberToRemove);

	/** Removes any duplicated elements from the array.

		If any string appears in the array more than once, only the first occurrence of
		it will be retained.

		@param ignoreCase   whether to use a case-insensitive comparison
	*/
	void removeDuplicates (bool ignoreCase);

	/** Removes empty strings from the array.

		@param removeWhitespaceStrings  if true, strings that only contain whitespace
										characters will also be removed
	*/
	void removeEmptyStrings (bool removeWhitespaceStrings = true);

	/** Moves one of the strings to a different position.

		This will move the string to a specified index, shuffling along
		any intervening elements as required.

		So for example, if you have the array { 0, 1, 2, 3, 4, 5 } then calling
		move (2, 4) would result in { 0, 1, 3, 4, 2, 5 }.

		@param currentIndex     the index of the value to be moved. If this isn't a
								valid index, then nothing will be done
		@param newIndex         the index at which you'd like this value to end up. If this
								is less than zero, the value will be moved to the end
								of the array
	*/
	void move (int currentIndex, int newIndex) noexcept;

	/** Deletes any whitespace characters from the starts and ends of all the strings. */
	void trim();

	/** Adds numbers to the strings in the array, to make each string unique.

		This will add numbers to the ends of groups of similar strings.
		e.g. if there are two "moose" strings, they will become "moose (1)" and "moose (2)"

		@param ignoreCaseWhenComparing      whether the comparison used is case-insensitive
		@param appendNumberToFirstInstance  whether the first of a group of similar strings
											also has a number appended to it.
		@param preNumberString              when adding a number, this string is added before the number.
											If you pass 0, a default string will be used, which adds
											brackets around the number.
		@param postNumberString             this string is appended after any numbers that are added.
											If you pass 0, a default string will be used, which adds
											brackets around the number.
	*/
	void appendNumbersToDuplicates (bool ignoreCaseWhenComparing,
									bool appendNumberToFirstInstance,
									CharPointer_UTF8 preNumberString = CharPointer_UTF8 (nullptr),
									CharPointer_UTF8 postNumberString = CharPointer_UTF8 (nullptr));

	/** Joins the strings in the array together into one string.

		This will join a range of elements from the array into a string, separating
		them with a given string.

		e.g. joinIntoString (",") will turn an array of "a" "b" and "c" into "a,b,c".

		@param separatorString      the string to insert between all the strings
		@param startIndex           the first element to join
		@param numberOfElements     how many elements to join together. If this is less
									than zero, all available elements will be used.
	*/
	String joinIntoString (const String& separatorString,
						   int startIndex = 0,
						   int numberOfElements = -1) const;

	/** Sorts the array into alphabetical order.

		@param ignoreCase       if true, the comparisons used will be case-sensitive.
	*/
	void sort (bool ignoreCase);

	/** Reduces the amount of storage being used by the array.

		Arrays typically allocate slightly more storage than they need, and after
		removing elements, they may have quite a lot of unused space allocated.
		This method will reduce the amount of allocated storage to a minimum.
	*/
	void minimiseStorageOverheads();

private:

	Array <String> strings;

	JUCE_LEAK_DETECTOR (StringArray);
};

#endif   // __JUCE_STRINGARRAY_JUCEHEADER__

/*** End of inlined file: juce_StringArray.h ***/

/**
	A container for holding a set of strings which are keyed by another string.

	@see StringArray
*/
class JUCE_API  StringPairArray
{
public:

	/** Creates an empty array */
	StringPairArray (bool ignoreCaseWhenComparingKeys = true);

	/** Creates a copy of another array */
	StringPairArray (const StringPairArray& other);

	/** Destructor. */
	~StringPairArray();

	/** Copies the contents of another string array into this one */
	StringPairArray& operator= (const StringPairArray& other);

	/** Compares two arrays.
		Comparisons are case-sensitive.
		@returns    true only if the other array contains exactly the same strings with the same keys
	*/
	bool operator== (const StringPairArray& other) const;

	/** Compares two arrays.
		Comparisons are case-sensitive.
		@returns    false if the other array contains exactly the same strings with the same keys
	*/
	bool operator!= (const StringPairArray& other) const;

	/** Finds the value corresponding to a key string.

		If no such key is found, this will just return an empty string. To check whether
		a given key actually exists (because it might actually be paired with an empty string), use
		the getAllKeys() method to obtain a list.

		Obviously the reference returned shouldn't be stored for later use, as the
		string it refers to may disappear when the array changes.

		@see getValue
	*/
	const String& operator[] (const String& key) const;

	/** Finds the value corresponding to a key string.

		If no such key is found, this will just return the value provided as a default.

		@see operator[]
	*/
	String getValue (const String& key, const String& defaultReturnValue) const;

	/** Returns a list of all keys in the array. */
	const StringArray& getAllKeys() const noexcept          { return keys; }

	/** Returns a list of all values in the array. */
	const StringArray& getAllValues() const noexcept        { return values; }

	/** Returns the number of strings in the array */
	inline int size() const noexcept                        { return keys.size(); };

	/** Adds or amends a key/value pair.

		If a value already exists with this key, its value will be overwritten,
		otherwise the key/value pair will be added to the array.
	*/
	void set (const String& key, const String& value);

	/** Adds the items from another array to this one.

		This is equivalent to using set() to add each of the pairs from the other array.
	*/
	void addArray (const StringPairArray& other);

	/** Removes all elements from the array. */
	void clear();

	/** Removes a string from the array based on its key.

		If the key isn't found, nothing will happen.
	*/
	void remove (const String& key);

	/** Removes a string from the array based on its index.

		If the index is out-of-range, no action will be taken.
	*/
	void remove (int index);

	/** Indicates whether to use a case-insensitive search when looking up a key string.
	*/
	void setIgnoresCase (bool shouldIgnoreCase);

	/** Returns a descriptive string containing the items.
		This is handy for dumping the contents of an array.
	*/
	String getDescription() const;

	/** Reduces the amount of storage being used by the array.

		Arrays typically allocate slightly more storage than they need, and after
		removing elements, they may have quite a lot of unused space allocated.
		This method will reduce the amount of allocated storage to a minimum.
	*/
	void minimiseStorageOverheads();

private:

	StringArray keys, values;
	bool ignoreCase;

	JUCE_LEAK_DETECTOR (StringPairArray);
};

#endif   // __JUCE_STRINGPAIRARRAY_JUCEHEADER__

/*** End of inlined file: juce_StringPairArray.h ***/


/*** Start of inlined file: juce_XmlElement.h ***/
#ifndef __JUCE_XMLELEMENT_JUCEHEADER__
#define __JUCE_XMLELEMENT_JUCEHEADER__


/*** Start of inlined file: juce_File.h ***/
#ifndef __JUCE_FILE_JUCEHEADER__
#define __JUCE_FILE_JUCEHEADER__


/*** Start of inlined file: juce_Time.h ***/
#ifndef __JUCE_TIME_JUCEHEADER__
#define __JUCE_TIME_JUCEHEADER__


/*** Start of inlined file: juce_RelativeTime.h ***/
#ifndef __JUCE_RELATIVETIME_JUCEHEADER__
#define __JUCE_RELATIVETIME_JUCEHEADER__

/** A relative measure of time.

	The time is stored as a number of seconds, at double-precision floating
	point accuracy, and may be positive or negative.

	If you need an absolute time, (i.e. a date + time), see the Time class.
*/
class JUCE_API  RelativeTime
{
public:

	/** Creates a RelativeTime.

		@param seconds  the number of seconds, which may be +ve or -ve.
		@see milliseconds, minutes, hours, days, weeks
	*/
	explicit RelativeTime (double seconds = 0.0) noexcept;

	/** Copies another relative time. */
	RelativeTime (const RelativeTime& other) noexcept;

	/** Copies another relative time. */
	RelativeTime& operator= (const RelativeTime& other) noexcept;

	/** Destructor. */
	~RelativeTime() noexcept;

	/** Creates a new RelativeTime object representing a number of milliseconds.
		@see minutes, hours, days, weeks
	*/
	static const RelativeTime milliseconds (int milliseconds) noexcept;

	/** Creates a new RelativeTime object representing a number of milliseconds.
		@see minutes, hours, days, weeks
	*/
	static const RelativeTime milliseconds (int64 milliseconds) noexcept;

	/** Creates a new RelativeTime object representing a number of minutes.
		@see milliseconds, hours, days, weeks
	*/
	static const RelativeTime minutes (double numberOfMinutes) noexcept;

	/** Creates a new RelativeTime object representing a number of hours.
		@see milliseconds, minutes, days, weeks
	*/
	static const RelativeTime hours (double numberOfHours) noexcept;

	/** Creates a new RelativeTime object representing a number of days.
		@see milliseconds, minutes, hours, weeks
	*/
	static const RelativeTime days (double numberOfDays) noexcept;

	/** Creates a new RelativeTime object representing a number of weeks.
		@see milliseconds, minutes, hours, days
	*/
	static const RelativeTime weeks (double numberOfWeeks) noexcept;

	/** Returns the number of milliseconds this time represents.
		@see milliseconds, inSeconds, inMinutes, inHours, inDays, inWeeks
	*/
	int64 inMilliseconds() const noexcept;

	/** Returns the number of seconds this time represents.
		@see inMilliseconds, inMinutes, inHours, inDays, inWeeks
	*/
	double inSeconds() const noexcept       { return seconds; }

	/** Returns the number of minutes this time represents.
		@see inMilliseconds, inSeconds, inHours, inDays, inWeeks
	*/
	double inMinutes() const noexcept;

	/** Returns the number of hours this time represents.
		@see inMilliseconds, inSeconds, inMinutes, inDays, inWeeks
	*/
	double inHours() const noexcept;

	/** Returns the number of days this time represents.
		@see inMilliseconds, inSeconds, inMinutes, inHours, inWeeks
	*/
	double inDays() const noexcept;

	/** Returns the number of weeks this time represents.
		@see inMilliseconds, inSeconds, inMinutes, inHours, inDays
	*/
	double inWeeks() const noexcept;

	/** Returns a readable textual description of the time.

		The exact format of the string returned will depend on
		the magnitude of the time - e.g.

		"1 min 4 secs", "1 hr 45 mins", "2 weeks 5 days", "140 ms"

		so that only the two most significant units are printed.

		The returnValueForZeroTime value is the result that is returned if the
		length is zero. Depending on your application you might want to use this
		to return something more relevant like "empty" or "0 secs", etc.

		@see inMilliseconds, inSeconds, inMinutes, inHours, inDays, inWeeks
	*/
	String getDescription (const String& returnValueForZeroTime = "0") const;

	/** Adds another RelativeTime to this one. */
	const RelativeTime& operator+= (const RelativeTime& timeToAdd) noexcept;
	/** Subtracts another RelativeTime from this one. */
	const RelativeTime& operator-= (const RelativeTime& timeToSubtract) noexcept;

	/** Adds a number of seconds to this time. */
	const RelativeTime& operator+= (double secondsToAdd) noexcept;
	/** Subtracts a number of seconds from this time. */
	const RelativeTime& operator-= (double secondsToSubtract) noexcept;

private:

	double seconds;
};

/** Compares two RelativeTimes. */
bool operator== (const RelativeTime& t1, const RelativeTime& t2) noexcept;
/** Compares two RelativeTimes. */
bool operator!= (const RelativeTime& t1, const RelativeTime& t2) noexcept;
/** Compares two RelativeTimes. */
bool operator>  (const RelativeTime& t1, const RelativeTime& t2) noexcept;
/** Compares two RelativeTimes. */
bool operator<  (const RelativeTime& t1, const RelativeTime& t2) noexcept;
/** Compares two RelativeTimes. */
bool operator>= (const RelativeTime& t1, const RelativeTime& t2) noexcept;
/** Compares two RelativeTimes. */
bool operator<= (const RelativeTime& t1, const RelativeTime& t2) noexcept;

/** Adds two RelativeTimes together. */
RelativeTime  operator+  (const RelativeTime&  t1, const RelativeTime& t2) noexcept;
/** Subtracts two RelativeTimes. */
RelativeTime  operator-  (const RelativeTime&  t1, const RelativeTime& t2) noexcept;

#endif   // __JUCE_RELATIVETIME_JUCEHEADER__

/*** End of inlined file: juce_RelativeTime.h ***/

/**
	Holds an absolute date and time.

	Internally, the time is stored at millisecond precision.

	@see RelativeTime
*/
class JUCE_API  Time
{
public:

	/** Creates a Time object.

		This default constructor creates a time of 1st January 1970, (which is
		represented internally as 0ms).

		To create a time object representing the current time, use getCurrentTime().

		@see getCurrentTime
	*/
	Time() noexcept;

	/** Creates a time based on a number of milliseconds.

		The internal millisecond count is set to 0 (1st January 1970). To create a
		time object set to the current time, use getCurrentTime().

		@param millisecondsSinceEpoch   the number of milliseconds since the unix
										'epoch' (midnight Jan 1st 1970).
		@see getCurrentTime, currentTimeMillis
	*/
	explicit Time (int64 millisecondsSinceEpoch) noexcept;

	/** Creates a time from a set of date components.

		The timezone is assumed to be whatever the system is using as its locale.

		@param year             the year, in 4-digit format, e.g. 2004
		@param month            the month, in the range 0 to 11
		@param day              the day of the month, in the range 1 to 31
		@param hours            hours in 24-hour clock format, 0 to 23
		@param minutes          minutes 0 to 59
		@param seconds          seconds 0 to 59
		@param milliseconds     milliseconds 0 to 999
		@param useLocalTime     if true, encode using the current machine's local time; if
								false, it will always work in GMT.
	*/
	Time (int year,
		  int month,
		  int day,
		  int hours,
		  int minutes,
		  int seconds = 0,
		  int milliseconds = 0,
		  bool useLocalTime = true) noexcept;

	/** Creates a copy of another Time object. */
	Time (const Time& other) noexcept;

	/** Destructor. */
	~Time() noexcept;

	/** Copies this time from another one. */
	Time& operator= (const Time& other) noexcept;

	/** Returns a Time object that is set to the current system time.

		@see currentTimeMillis
	*/
	static Time JUCE_CALLTYPE getCurrentTime() noexcept;

	/** Returns the time as a number of milliseconds.

		@returns    the number of milliseconds this Time object represents, since
					midnight jan 1st 1970.
		@see getMilliseconds
	*/
	int64 toMilliseconds() const noexcept                           { return millisSinceEpoch; }

	/** Returns the year.

		A 4-digit format is used, e.g. 2004.
	*/
	int getYear() const noexcept;

	/** Returns the number of the month.

		The value returned is in the range 0 to 11.
		@see getMonthName
	*/
	int getMonth() const noexcept;

	/** Returns the name of the month.

		@param threeLetterVersion   if true, it'll be a 3-letter abbreviation, e.g. "Jan"; if false
									it'll return the long form, e.g. "January"
		@see getMonth
	*/
	String getMonthName (bool threeLetterVersion) const;

	/** Returns the day of the month.
		The value returned is in the range 1 to 31.
	*/
	int getDayOfMonth() const noexcept;

	/** Returns the number of the day of the week.
		The value returned is in the range 0 to 6 (0 = sunday, 1 = monday, etc).
	*/
	int getDayOfWeek() const noexcept;

	/** Returns the number of the day of the year.
		The value returned is in the range 0 to 365.
	*/
	int getDayOfYear() const noexcept;

	/** Returns the name of the weekday.

		@param threeLetterVersion   if true, it'll return a 3-letter abbreviation, e.g. "Tue"; if
									false, it'll return the full version, e.g. "Tuesday".
	*/
	String getWeekdayName (bool threeLetterVersion) const;

	/** Returns the number of hours since midnight.

		This is in 24-hour clock format, in the range 0 to 23.

		@see getHoursInAmPmFormat, isAfternoon
	*/
	int getHours() const noexcept;

	/** Returns true if the time is in the afternoon.

		So it returns true for "PM", false for "AM".

		@see getHoursInAmPmFormat, getHours
	*/
	bool isAfternoon() const noexcept;

	/** Returns the hours in 12-hour clock format.

		This will return a value 1 to 12 - use isAfternoon() to find out
		whether this is in the afternoon or morning.

		@see getHours, isAfternoon
	*/
	int getHoursInAmPmFormat() const noexcept;

	/** Returns the number of minutes, 0 to 59. */
	int getMinutes() const noexcept;

	/** Returns the number of seconds, 0 to 59. */
	int getSeconds() const noexcept;

	/** Returns the number of milliseconds, 0 to 999.

		Unlike toMilliseconds(), this just returns the position within the
		current second rather than the total number since the epoch.

		@see toMilliseconds
	*/
	int getMilliseconds() const noexcept;

	/** Returns true if the local timezone uses a daylight saving correction. */
	bool isDaylightSavingTime() const noexcept;

	/** Returns a 3-character string to indicate the local timezone. */
	String getTimeZone() const noexcept;

	/** Quick way of getting a string version of a date and time.

		For a more powerful way of formatting the date and time, see the formatted() method.

		@param includeDate      whether to include the date in the string
		@param includeTime      whether to include the time in the string
		@param includeSeconds   if the time is being included, this provides an option not to include
								the seconds in it
		@param use24HourClock   if the time is being included, sets whether to use am/pm or 24
								hour notation.
		@see formatted
	*/
	String toString (bool includeDate,
					 bool includeTime,
					 bool includeSeconds = true,
					 bool use24HourClock = false) const noexcept;

	/** Converts this date/time to a string with a user-defined format.

		This uses the C strftime() function to format this time as a string. To save you
		looking it up, these are the escape codes that strftime uses (other codes might
		work on some platforms and not others, but these are the common ones):

		%a  is replaced by the locale's abbreviated weekday name.
		%A  is replaced by the locale's full weekday name.
		%b  is replaced by the locale's abbreviated month name.
		%B  is replaced by the locale's full month name.
		%c  is replaced by the locale's appropriate date and time representation.
		%d  is replaced by the day of the month as a decimal number [01,31].
		%H  is replaced by the hour (24-hour clock) as a decimal number [00,23].
		%I  is replaced by the hour (12-hour clock) as a decimal number [01,12].
		%j  is replaced by the day of the year as a decimal number [001,366].
		%m  is replaced by the month as a decimal number [01,12].
		%M  is replaced by the minute as a decimal number [00,59].
		%p  is replaced by the locale's equivalent of either a.m. or p.m.
		%S  is replaced by the second as a decimal number [00,61].
		%U  is replaced by the week number of the year (Sunday as the first day of the week) as a decimal number [00,53].
		%w  is replaced by the weekday as a decimal number [0,6], with 0 representing Sunday.
		%W  is replaced by the week number of the year (Monday as the first day of the week) as a decimal number [00,53]. All days in a new year preceding the first Monday are considered to be in week 0.
		%x  is replaced by the locale's appropriate date representation.
		%X  is replaced by the locale's appropriate time representation.
		%y  is replaced by the year without century as a decimal number [00,99].
		%Y  is replaced by the year with century as a decimal number.
		%Z  is replaced by the timezone name or abbreviation, or by no bytes if no timezone information exists.
		%%  is replaced by %.

		@see toString
	*/
	String formatted (const String& format) const;

	/** Adds a RelativeTime to this time. */
	Time& operator+= (const RelativeTime& delta);
	/** Subtracts a RelativeTime from this time. */
	Time& operator-= (const RelativeTime& delta);

	/** Tries to set the computer's clock.

		@returns    true if this succeeds, although depending on the system, the
					application might not have sufficient privileges to do this.
	*/
	bool setSystemTimeToThisTime() const;

	/** Returns the name of a day of the week.

		@param dayNumber            the day, 0 to 6 (0 = sunday, 1 = monday, etc)
		@param threeLetterVersion   if true, it'll return a 3-letter abbreviation, e.g. "Tue"; if
									false, it'll return the full version, e.g. "Tuesday".
	*/
	static String getWeekdayName (int dayNumber,
								  bool threeLetterVersion);

	/** Returns the name of one of the months.

		@param monthNumber  the month, 0 to 11
		@param threeLetterVersion   if true, it'll be a 3-letter abbreviation, e.g. "Jan"; if false
									it'll return the long form, e.g. "January"
	*/
	static String getMonthName (int monthNumber,
								bool threeLetterVersion);

	// Static methods for getting system timers directly..

	/** Returns the current system time.

		Returns the number of milliseconds since midnight jan 1st 1970.

		Should be accurate to within a few millisecs, depending on platform,
		hardware, etc.
	*/
	static int64 currentTimeMillis() noexcept;

	/** Returns the number of millisecs since a fixed event (usually system startup).

		This returns a monotonically increasing value which it unaffected by changes to the
		system clock. It should be accurate to within a few millisecs, depending on platform,
		hardware, etc.

		Being a 32-bit return value, it will of course wrap back to 0 after 2^32 seconds of
		uptime, so be careful to take that into account. If you need a 64-bit time, you can
		use currentTimeMillis() instead.

		@see getApproximateMillisecondCounter
	*/
	static uint32 getMillisecondCounter() noexcept;

	/** Returns the number of millisecs since a fixed event (usually system startup).

		This has the same function as getMillisecondCounter(), but returns a more accurate
		value, using a higher-resolution timer if one is available.

		@see getMillisecondCounter
	*/
	static double getMillisecondCounterHiRes() noexcept;

	/** Waits until the getMillisecondCounter() reaches a given value.

		This will make the thread sleep as efficiently as it can while it's waiting.
	*/
	static void waitForMillisecondCounter (uint32 targetTime) noexcept;

	/** Less-accurate but faster version of getMillisecondCounter().

		This will return the last value that getMillisecondCounter() returned, so doesn't
		need to make a system call, but is less accurate - it shouldn't be more than
		100ms away from the correct time, though, so is still accurate enough for a
		lot of purposes.

		@see getMillisecondCounter
	*/
	static uint32 getApproximateMillisecondCounter() noexcept;

	// High-resolution timers..

	/** Returns the current high-resolution counter's tick-count.

		This is a similar idea to getMillisecondCounter(), but with a higher
		resolution.

		@see getHighResolutionTicksPerSecond, highResolutionTicksToSeconds,
			 secondsToHighResolutionTicks
	*/
	static int64 getHighResolutionTicks() noexcept;

	/** Returns the resolution of the high-resolution counter in ticks per second.

		@see getHighResolutionTicks, highResolutionTicksToSeconds,
			 secondsToHighResolutionTicks
	*/
	static int64 getHighResolutionTicksPerSecond() noexcept;

	/** Converts a number of high-resolution ticks into seconds.

		@see getHighResolutionTicks, getHighResolutionTicksPerSecond,
			 secondsToHighResolutionTicks
	*/
	static double highResolutionTicksToSeconds (int64 ticks) noexcept;

	/** Converts a number seconds into high-resolution ticks.

		@see getHighResolutionTicks, getHighResolutionTicksPerSecond,
			 highResolutionTicksToSeconds
	*/
	static int64 secondsToHighResolutionTicks (double seconds) noexcept;

private:

	int64 millisSinceEpoch;
};

/** Adds a RelativeTime to a Time. */
JUCE_API Time operator+ (const Time& time, const RelativeTime& delta);
/** Adds a RelativeTime to a Time. */
JUCE_API Time operator+ (const RelativeTime& delta, const Time& time);

/** Subtracts a RelativeTime from a Time. */
JUCE_API Time operator- (const Time& time, const RelativeTime& delta);
/** Returns the relative time difference between two times. */
JUCE_API const RelativeTime operator- (const Time& time1, const Time& time2);

/** Compares two Time objects. */
JUCE_API bool operator== (const Time& time1, const Time& time2);
/** Compares two Time objects. */
JUCE_API bool operator!= (const Time& time1, const Time& time2);
/** Compares two Time objects. */
JUCE_API bool operator<  (const Time& time1, const Time& time2);
/** Compares two Time objects. */
JUCE_API bool operator<= (const Time& time1, const Time& time2);
/** Compares two Time objects. */
JUCE_API bool operator>  (const Time& time1, const Time& time2);
/** Compares two Time objects. */
JUCE_API bool operator>= (const Time& time1, const Time& time2);

#endif   // __JUCE_TIME_JUCEHEADER__

/*** End of inlined file: juce_Time.h ***/


/*** Start of inlined file: juce_MemoryBlock.h ***/
#ifndef __JUCE_MEMORYBLOCK_JUCEHEADER__
#define __JUCE_MEMORYBLOCK_JUCEHEADER__

/**
	A class to hold a resizable block of raw data.

*/
class JUCE_API  MemoryBlock
{
public:

	/** Create an uninitialised block with 0 size. */
	MemoryBlock() noexcept;

	/** Creates a memory block with a given initial size.

		@param initialSize          the size of block to create
		@param initialiseToZero     whether to clear the memory or just leave it uninitialised
	*/
	MemoryBlock (const size_t initialSize,
				 bool initialiseToZero = false);

	/** Creates a copy of another memory block. */
	MemoryBlock (const MemoryBlock& other);

	/** Creates a memory block using a copy of a block of data.

		@param dataToInitialiseFrom     some data to copy into this block
		@param sizeInBytes              how much space to use
	*/
	MemoryBlock (const void* dataToInitialiseFrom, size_t sizeInBytes);

	/** Destructor. */
	~MemoryBlock() noexcept;

	/** Copies another memory block onto this one.

		This block will be resized and copied to exactly match the other one.
	*/
	MemoryBlock& operator= (const MemoryBlock& other);

   #if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
	MemoryBlock (MemoryBlock&& other) noexcept;
	MemoryBlock& operator= (MemoryBlock&& other) noexcept;
   #endif

	/** Compares two memory blocks.

		@returns true only if the two blocks are the same size and have identical contents.
	*/
	bool operator== (const MemoryBlock& other) const noexcept;

	/** Compares two memory blocks.

		@returns true if the two blocks are different sizes or have different contents.
	*/
	bool operator!= (const MemoryBlock& other) const noexcept;

	/** Returns true if the data in this MemoryBlock matches the raw bytes passed-in.
	*/
	bool matches (const void* data, size_t dataSize) const noexcept;

	/** Returns a void pointer to the data.

		Note that the pointer returned will probably become invalid when the
		block is resized.
	*/
	void* getData() const noexcept                                  { return data; }

	/** Returns a byte from the memory block.

		This returns a reference, so you can also use it to set a byte.
	*/
	template <typename Type>
	char& operator[] (const Type offset) const noexcept             { return data [offset]; }

	/** Returns the block's current allocated size, in bytes. */
	size_t getSize() const noexcept                                 { return size; }

	/** Resizes the memory block.

		This will try to keep as much of the block's current content as it can,
		and can optionally be made to clear any new space that gets allocated at
		the end of the block.

		@param newSize                      the new desired size for the block
		@param initialiseNewSpaceToZero     if the block gets enlarged, this determines
											whether to clear the new section or just leave it
											uninitialised
		@see ensureSize
	*/
	void setSize (const size_t newSize,
				  bool initialiseNewSpaceToZero = false);

	/** Increases the block's size only if it's smaller than a given size.

		@param minimumSize                  if the block is already bigger than this size, no action
											will be taken; otherwise it will be increased to this size
		@param initialiseNewSpaceToZero     if the block gets enlarged, this determines
											whether to clear the new section or just leave it
											uninitialised
		@see setSize
	*/
	void ensureSize (const size_t minimumSize,
					 bool initialiseNewSpaceToZero = false);

	/** Fills the entire memory block with a repeated byte value.

		This is handy for clearing a block of memory to zero.
	*/
	void fillWith (uint8 valueToUse) noexcept;

	/** Adds another block of data to the end of this one.
		The data pointer must not be null. This block's size will be increased accordingly.
	*/
	void append (const void* data, size_t numBytes);

	/** Inserts some data into the block.
		The dataToInsert pointer must not be null. This block's size will be increased accordingly.
		If the insert position lies outside the valid range of the block, it will be clipped to
		within the range before being used.
	*/
	void insert (const void* dataToInsert, size_t numBytesToInsert, size_t insertPosition);

	/** Chops out a section  of the block.

		This will remove a section of the memory block and close the gap around it,
		shifting any subsequent data downwards and reducing the size of the block.

		If the range specified goes beyond the size of the block, it will be clipped.
	*/
	void removeSection (size_t startByte, size_t numBytesToRemove);

	/** Copies data into this MemoryBlock from a memory address.

		@param srcData              the memory location of the data to copy into this block
		@param destinationOffset    the offset in this block at which the data being copied should begin
		@param numBytes             how much to copy in (if this goes beyond the size of the memory block,
									it will be clipped so not to do anything nasty)
	*/
	void copyFrom (const void* srcData,
				   int destinationOffset,
				   size_t numBytes) noexcept;

	/** Copies data from this MemoryBlock to a memory address.

		@param destData         the memory location to write to
		@param sourceOffset     the offset within this block from which the copied data will be read
		@param numBytes         how much to copy (if this extends beyond the limits of the memory block,
								zeros will be used for that portion of the data)
	*/
	void copyTo (void* destData,
				 int sourceOffset,
				 size_t numBytes) const noexcept;

	/** Exchanges the contents of this and another memory block.
		No actual copying is required for this, so it's very fast.
	*/
	void swapWith (MemoryBlock& other) noexcept;

	/** Attempts to parse the contents of the block as a zero-terminated UTF8 string. */
	String toString() const;

	/** Parses a string of hexadecimal numbers and writes this data into the memory block.

		The block will be resized to the number of valid bytes read from the string.
		Non-hex characters in the string will be ignored.

		@see String::toHexString()
	*/
	void loadFromHexString (const String& sourceHexString);

	/** Sets a number of bits in the memory block, treating it as a long binary sequence. */
	void setBitRange (size_t bitRangeStart,
					  size_t numBits,
					  int binaryNumberToApply) noexcept;

	/** Reads a number of bits from the memory block, treating it as one long binary sequence */
	int getBitRange (size_t bitRangeStart,
					 size_t numBitsToRead) const noexcept;

	/** Returns a string of characters that represent the binary contents of this block.

		Uses a 64-bit encoding system to allow binary data to be turned into a string
		of simple non-extended characters, e.g. for storage in XML.

		@see fromBase64Encoding
	*/
	String toBase64Encoding() const;

	/** Takes a string of encoded characters and turns it into binary data.

		The string passed in must have been created by to64BitEncoding(), and this
		block will be resized to recreate the original data block.

		@see toBase64Encoding
	*/
	bool fromBase64Encoding  (const String& encodedString);

private:

	HeapBlock <char> data;
	size_t size;
	static const char* const encodingTable;

	JUCE_LEAK_DETECTOR (MemoryBlock);
};

#endif   // __JUCE_MEMORYBLOCK_JUCEHEADER__

/*** End of inlined file: juce_MemoryBlock.h ***/


/*** Start of inlined file: juce_Result.h ***/
#ifndef __JUCE_RESULT_JUCEHEADER__
#define __JUCE_RESULT_JUCEHEADER__

/**
	Represents the 'success' or 'failure' of an operation, and holds an associated
	error message to describe the error when there's a failure.

	E.g.
	@code
	Result myOperation()
	{
		if (doSomeKindOfFoobar())
			return Result::ok();
		else
			return Result::fail ("foobar didn't work!");
	}

	const Result result (myOperation());

	if (result.wasOk())
	{
		...it's all good...
	}
	else
	{
		warnUserAboutFailure ("The foobar operation failed! Error message was: "
								+ result.getErrorMessage());
	}
	@endcode
*/
class JUCE_API  Result
{
public:

	/** Creates and returns a 'successful' result. */
	static Result ok() noexcept;

	/** Creates a 'failure' result.
		If you pass a blank error message in here, a default "Unknown Error" message
		will be used instead.
	*/
	static Result fail (const String& errorMessage) noexcept;

	/** Returns true if this result indicates a success. */
	bool wasOk() const noexcept;

	/** Returns true if this result indicates a failure.
		You can use getErrorMessage() to retrieve the error message associated
		with the failure.
	*/
	bool failed() const noexcept;

	/** Returns true if this result indicates a success.
		This is equivalent to calling wasOk().
	*/
	operator bool() const noexcept;

	/** Returns true if this result indicates a failure.
		This is equivalent to calling failed().
	*/
	bool operator!() const noexcept;

	/** Returns the error message that was set when this result was created.
		For a successful result, this will be an empty string;
	*/
	const String& getErrorMessage() const noexcept;

	Result (const Result& other);
	Result& operator= (const Result& other);

   #if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
	Result (Result&& other) noexcept;
	Result& operator= (Result&& other) noexcept;
   #endif

	bool operator== (const Result& other) const noexcept;
	bool operator!= (const Result& other) const noexcept;

private:
	String errorMessage;

	explicit Result (const String& errorMessage) noexcept;

	// These casts are private to prevent people trying to use the Result object in numeric contexts
	operator int() const;
	operator void*() const;
};

#endif   // __JUCE_RESULT_JUCEHEADER__

/*** End of inlined file: juce_Result.h ***/

class FileInputStream;
class FileOutputStream;

/**
	Represents a local file or directory.

	This class encapsulates the absolute pathname of a file or directory, and
	has methods for finding out about the file and changing its properties.

	To read or write to the file, there are methods for returning an input or
	output stream.

	@see FileInputStream, FileOutputStream
*/
class JUCE_API  File
{
public:

	/** Creates an (invalid) file object.

		The file is initially set to an empty path, so getFullPath() will return
		an empty string, and comparing the file to File::nonexistent will return
		true.

		You can use its operator= method to point it at a proper file.
	*/
	File()   {}

	/** Creates a file from an absolute path.

		If the path supplied is a relative path, it is taken to be relative
		to the current working directory (see File::getCurrentWorkingDirectory()),
		but this isn't a recommended way of creating a file, because you
		never know what the CWD is going to be.

		On the Mac/Linux, the path can include "~" notation for referring to
		user home directories.
	*/
	File (const String& path);

	/** Creates a copy of another file object. */
	File (const File& other);

	/** Destructor. */
	~File()  {}

	/** Sets the file based on an absolute pathname.

		If the path supplied is a relative path, it is taken to be relative
		to the current working directory (see File::getCurrentWorkingDirectory()),
		but this isn't a recommended way of creating a file, because you
		never know what the CWD is going to be.

		On the Mac/Linux, the path can include "~" notation for referring to
		user home directories.
	*/
	File& operator= (const String& newFilePath);

	/** Copies from another file object. */
	File& operator= (const File& otherFile);

   #if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
	File (File&& otherFile) noexcept;
	File& operator= (File&& otherFile) noexcept;
   #endif

	/** This static constant is used for referring to an 'invalid' file. */
	static const File nonexistent;

	/** Checks whether the file actually exists.

		@returns    true if the file exists, either as a file or a directory.
		@see existsAsFile, isDirectory
	*/
	bool exists() const;

	/** Checks whether the file exists and is a file rather than a directory.

		@returns    true only if this is a real file, false if it's a directory
					or doesn't exist
		@see exists, isDirectory
	*/
	bool existsAsFile() const;

	/** Checks whether the file is a directory that exists.

		@returns    true only if the file is a directory which actually exists, so
					false if it's a file or doesn't exist at all
		@see exists, existsAsFile
	*/
	bool isDirectory() const;

	/** Returns the size of the file in bytes.

		@returns    the number of bytes in the file, or 0 if it doesn't exist.
	*/
	int64 getSize() const;

	/** Utility function to convert a file size in bytes to a neat string description.

		So for example 100 would return "100 bytes", 2000 would return "2 KB",
		2000000 would produce "2 MB", etc.
	*/
	static String descriptionOfSizeInBytes (int64 bytes);

	/** Returns the complete, absolute path of this file.

		This includes the filename and all its parent folders. On Windows it'll
		also include the drive letter prefix; on Mac or Linux it'll be a complete
		path starting from the root folder.

		If you just want the file's name, you should use getFileName() or
		getFileNameWithoutExtension().

		@see getFileName, getRelativePathFrom
	*/
	const String& getFullPathName() const noexcept          { return fullPath; }

	/** Returns the last section of the pathname.

		Returns just the final part of the path - e.g. if the whole path
		is "/moose/fish/foo.txt" this will return "foo.txt".

		For a directory, it returns the final part of the path - e.g. for the
		directory "/moose/fish" it'll return "fish".

		If the filename begins with a dot, it'll return the whole filename, e.g. for
		"/moose/.fish", it'll return ".fish"

		@see getFullPathName, getFileNameWithoutExtension
	*/
	String getFileName() const;

	/** Creates a relative path that refers to a file relatively to a given directory.

		e.g. File ("/moose/foo.txt").getRelativePathFrom (File ("/moose/fish/haddock"))
			 would return "../../foo.txt".

		If it's not possible to navigate from one file to the other, an absolute
		path is returned. If the paths are invalid, an empty string may also be
		returned.

		@param directoryToBeRelativeTo  the directory which the resultant string will
										be relative to. If this is actually a file rather than
										a directory, its parent directory will be used instead.
										If it doesn't exist, it's assumed to be a directory.
		@see getChildFile, isAbsolutePath
	*/
	String getRelativePathFrom (const File& directoryToBeRelativeTo) const;

	/** Returns the file's extension.

		Returns the file extension of this file, also including the dot.

		e.g. "/moose/fish/foo.txt" would return ".txt"

		@see hasFileExtension, withFileExtension, getFileNameWithoutExtension
	*/
	String getFileExtension() const;

	/** Checks whether the file has a given extension.

		@param extensionToTest  the extension to look for - it doesn't matter whether or
								not this string has a dot at the start, so ".wav" and "wav"
								will have the same effect. The comparison used is
								case-insensitve. To compare with multiple extensions, this
								parameter can contain multiple strings, separated by semi-colons -
								so, for example: hasFileExtension (".jpeg;png;gif") would return
								true if the file has any of those three extensions.

		@see getFileExtension, withFileExtension, getFileNameWithoutExtension
	*/
	bool hasFileExtension (const String& extensionToTest) const;

	/** Returns a version of this file with a different file extension.

		e.g. File ("/moose/fish/foo.txt").withFileExtension ("html") returns "/moose/fish/foo.html"

		@param newExtension     the new extension, either with or without a dot at the start (this
								doesn't make any difference). To get remove a file's extension altogether,
								pass an empty string into this function.

		@see getFileName, getFileExtension, hasFileExtension, getFileNameWithoutExtension
	*/
	File withFileExtension (const String& newExtension) const;

	/** Returns the last part of the filename, without its file extension.

		e.g. for "/moose/fish/foo.txt" this will return "foo".

		@see getFileName, getFileExtension, hasFileExtension, withFileExtension
	*/
	String getFileNameWithoutExtension() const;

	/** Returns a 32-bit hash-code that identifies this file.

		This is based on the filename. Obviously it's possible, although unlikely, that
		two files will have the same hash-code.
	*/
	int hashCode() const;

	/** Returns a 64-bit hash-code that identifies this file.

		This is based on the filename. Obviously it's possible, although unlikely, that
		two files will have the same hash-code.
	*/
	int64 hashCode64() const;

	/** Returns a file based on a relative path.

		This will find a child file or directory of the current object.

		e.g.
			File ("/moose/fish").getChildFile ("foo.txt") will produce "/moose/fish/foo.txt".
			File ("/moose/fish").getChildFile ("../foo.txt") will produce "/moose/foo.txt".

		If the string is actually an absolute path, it will be treated as such, e.g.
			File ("/moose/fish").getChildFile ("/foo.txt") will produce "/foo.txt"

		@see getSiblingFile, getParentDirectory, getRelativePathFrom, isAChildOf
	*/
	File getChildFile (String relativePath) const;

	/** Returns a file which is in the same directory as this one.

		This is equivalent to getParentDirectory().getChildFile (name).

		@see getChildFile, getParentDirectory
	*/
	File getSiblingFile (const String& siblingFileName) const;

	/** Returns the directory that contains this file or directory.

		e.g. for "/moose/fish/foo.txt" this will return "/moose/fish".
	*/
	File getParentDirectory() const;

	/** Checks whether a file is somewhere inside a directory.

		Returns true if this file is somewhere inside a subdirectory of the directory
		that is passed in. Neither file actually has to exist, because the function
		just checks the paths for similarities.

		e.g. File ("/moose/fish/foo.txt").isAChildOf ("/moose") is true.
			 File ("/moose/fish/foo.txt").isAChildOf ("/moose/fish") is also true.
	*/
	bool isAChildOf (const File& potentialParentDirectory) const;

	/** Chooses a filename relative to this one that doesn't already exist.

		If this file is a directory, this will return a child file of this
		directory that doesn't exist, by adding numbers to a prefix and suffix until
		it finds one that isn't already there.

		If the prefix + the suffix doesn't exist, it won't bother adding a number.

		e.g. File ("/moose/fish").getNonexistentChildFile ("foo", ".txt", true) might
			 return "/moose/fish/foo(2).txt" if there's already a file called "foo.txt".

		@param prefix                   the string to use for the filename before the number
		@param suffix                   the string to add to the filename after the number
		@param putNumbersInBrackets     if true, this will create filenames in the
										format "prefix(number)suffix", if false, it will leave the
										brackets out.
	*/
	File getNonexistentChildFile (const String& prefix,
								  const String& suffix,
								  bool putNumbersInBrackets = true) const;

	/** Chooses a filename for a sibling file to this one that doesn't already exist.

		If this file doesn't exist, this will just return itself, otherwise it
		will return an appropriate sibling that doesn't exist, e.g. if a file
		"/moose/fish/foo.txt" exists, this might return "/moose/fish/foo(2).txt".

		@param putNumbersInBrackets     whether to add brackets around the numbers that
										get appended to the new filename.
	*/
	File getNonexistentSibling (bool putNumbersInBrackets = true) const;

	/** Compares the pathnames for two files. */
	bool operator== (const File& otherFile) const;
	/** Compares the pathnames for two files. */
	bool operator!= (const File& otherFile) const;
	/** Compares the pathnames for two files. */
	bool operator< (const File& otherFile) const;
	/** Compares the pathnames for two files. */
	bool operator> (const File& otherFile) const;

	/** Checks whether a file can be created or written to.

		@returns    true if it's possible to create and write to this file. If the file
					doesn't already exist, this will check its parent directory to
					see if writing is allowed.
		@see setReadOnly
	*/
	bool hasWriteAccess() const;

	/** Changes the write-permission of a file or directory.

		@param shouldBeReadOnly     whether to add or remove write-permission
		@param applyRecursively     if the file is a directory and this is true, it will
									recurse through all the subfolders changing the permissions
									of all files
		@returns    true if it manages to change the file's permissions.
		@see hasWriteAccess
	*/
	bool setReadOnly (bool shouldBeReadOnly,
					  bool applyRecursively = false) const;

	/** Returns true if this file is a hidden or system file.

		The criteria for deciding whether a file is hidden are platform-dependent.
	*/
	bool isHidden() const;

	/** If this file is a link, this returns the file that it points to.

		If this file isn't actually link, it'll just return itself.
	*/
	File getLinkedTarget() const;

	/** Returns the last modification time of this file.

		@returns    the time, or an invalid time if the file doesn't exist.
		@see setLastModificationTime, getLastAccessTime, getCreationTime
	*/
	Time getLastModificationTime() const;

	/** Returns the last time this file was accessed.

		@returns    the time, or an invalid time if the file doesn't exist.
		@see setLastAccessTime, getLastModificationTime, getCreationTime
	*/
	Time getLastAccessTime() const;

	/** Returns the time that this file was created.

		@returns    the time, or an invalid time if the file doesn't exist.
		@see getLastModificationTime, getLastAccessTime
	*/
	Time getCreationTime() const;

	/** Changes the modification time for this file.

		@param newTime  the time to apply to the file
		@returns true if it manages to change the file's time.
		@see getLastModificationTime, setLastAccessTime, setCreationTime
	*/
	bool setLastModificationTime (const Time& newTime) const;

	/** Changes the last-access time for this file.

		@param newTime  the time to apply to the file
		@returns true if it manages to change the file's time.
		@see getLastAccessTime, setLastModificationTime, setCreationTime
	*/
	bool setLastAccessTime (const Time& newTime) const;

	/** Changes the creation date for this file.

		@param newTime  the time to apply to the file
		@returns true if it manages to change the file's time.
		@see getCreationTime, setLastModificationTime, setLastAccessTime
	*/
	bool setCreationTime (const Time& newTime) const;

	/** If possible, this will try to create a version string for the given file.

		The OS may be able to look at the file and give a version for it - e.g. with
		executables, bundles, dlls, etc. If no version is available, this will
		return an empty string.
	*/
	String getVersion() const;

	/** Creates an empty file if it doesn't already exist.

		If the file that this object refers to doesn't exist, this will create a file
		of zero size.

		If it already exists or is a directory, this method will do nothing.

		@returns    true if the file has been created (or if it already existed).
		@see createDirectory
	*/
	Result create() const;

	/** Creates a new directory for this filename.

		This will try to create the file as a directory, and fill also create
		any parent directories it needs in order to complete the operation.

		@returns    a result to indicate whether the directory was created successfully, or
					an error message if it failed.
		@see create
	*/
	Result createDirectory() const;

	/** Deletes a file.

		If this file is actually a directory, it may not be deleted correctly if it
		contains files. See deleteRecursively() as a better way of deleting directories.

		@returns    true if the file has been successfully deleted (or if it didn't exist to
					begin with).
		@see deleteRecursively
	*/
	bool deleteFile() const;

	/** Deletes a file or directory and all its subdirectories.

		If this file is a directory, this will try to delete it and all its subfolders. If
		it's just a file, it will just try to delete the file.

		@returns    true if the file and all its subfolders have been successfully deleted
					(or if it didn't exist to begin with).
		@see deleteFile
	*/
	bool deleteRecursively() const;

	/** Moves this file or folder to the trash.

		@returns true if the operation succeeded. It could fail if the trash is full, or
				 if the file is write-protected, so you should check the return value
				 and act appropriately.
	*/
	bool moveToTrash() const;

	/** Moves or renames a file.

		Tries to move a file to a different location.
		If the target file already exists, this will attempt to delete it first, and
		will fail if this can't be done.

		Note that the destination file isn't the directory to put it in, it's the actual
		filename that you want the new file to have.

		@returns    true if the operation succeeds
	*/
	bool moveFileTo (const File& targetLocation) const;

	/** Copies a file.

		Tries to copy a file to a different location.
		If the target file already exists, this will attempt to delete it first, and
		will fail if this can't be done.

		@returns    true if the operation succeeds
	*/
	bool copyFileTo (const File& targetLocation) const;

	/** Copies a directory.

		Tries to copy an entire directory, recursively.

		If this file isn't a directory or if any target files can't be created, this
		will return false.

		@param newDirectory    the directory that this one should be copied to. Note that this
							   is the name of the actual directory to create, not the directory
							   into which the new one should be placed, so there must be enough
							   write privileges to create it if it doesn't exist. Any files inside
							   it will be overwritten by similarly named ones that are copied.
	*/
	bool copyDirectoryTo (const File& newDirectory) const;

	/** Used in file searching, to specify whether to return files, directories, or both.
	*/
	enum TypesOfFileToFind
	{
		findDirectories             = 1,    /**< Use this flag to indicate that you want to find directories. */
		findFiles                   = 2,    /**< Use this flag to indicate that you want to find files. */
		findFilesAndDirectories     = 3,    /**< Use this flag to indicate that you want to find both files and directories. */
		ignoreHiddenFiles           = 4     /**< Add this flag to avoid returning any hidden files in the results. */
	};

	/** Searches inside a directory for files matching a wildcard pattern.

		Assuming that this file is a directory, this method will search it
		for either files or subdirectories whose names match a filename pattern.

		@param results                  an array to which File objects will be added for the
										files that the search comes up with
		@param whatToLookFor            a value from the TypesOfFileToFind enum, specifying whether to
										return files, directories, or both. If the ignoreHiddenFiles flag
										is also added to this value, hidden files won't be returned
		@param searchRecursively        if true, all subdirectories will be recursed into to do
										an exhaustive search
		@param wildCardPattern          the filename pattern to search for, e.g. "*.txt"
		@returns                        the number of results that have been found

		@see getNumberOfChildFiles, DirectoryIterator
	*/
	int findChildFiles (Array<File>& results,
						int whatToLookFor,
						bool searchRecursively,
						const String& wildCardPattern = "*") const;

	/** Searches inside a directory and counts how many files match a wildcard pattern.

		Assuming that this file is a directory, this method will search it
		for either files or subdirectories whose names match a filename pattern,
		and will return the number of matches found.

		This isn't a recursive call, and will only search this directory, not
		its children.

		@param whatToLookFor    a value from the TypesOfFileToFind enum, specifying whether to
								count files, directories, or both. If the ignoreHiddenFiles flag
								is also added to this value, hidden files won't be counted
		@param wildCardPattern  the filename pattern to search for, e.g. "*.txt"
		@returns                the number of matches found
		@see findChildFiles, DirectoryIterator
	*/
	int getNumberOfChildFiles (int whatToLookFor,
							   const String& wildCardPattern = "*") const;

	/** Returns true if this file is a directory that contains one or more subdirectories.
		@see isDirectory, findChildFiles
	*/
	bool containsSubDirectories() const;

	/** Creates a stream to read from this file.

		@returns    a stream that will read from this file (initially positioned at the
					start of the file), or 0 if the file can't be opened for some reason
		@see createOutputStream, loadFileAsData
	*/
	FileInputStream* createInputStream() const;

	/** Creates a stream to write to this file.

		If the file exists, the stream that is returned will be positioned ready for
		writing at the end of the file, so you might want to use deleteFile() first
		to write to an empty file.

		@returns    a stream that will write to this file (initially positioned at the
					end of the file), or 0 if the file can't be opened for some reason
		@see createInputStream, appendData, appendText
	*/
	FileOutputStream* createOutputStream (int bufferSize = 0x8000) const;

	/** Loads a file's contents into memory as a block of binary data.

		Of course, trying to load a very large file into memory will blow up, so
		it's better to check first.

		@param result   the data block to which the file's contents should be appended - note
						that if the memory block might already contain some data, you
						might want to clear it first
		@returns        true if the file could all be read into memory
	*/
	bool loadFileAsData (MemoryBlock& result) const;

	/** Reads a file into memory as a string.

		Attempts to load the entire file as a zero-terminated string.

		This makes use of InputStream::readEntireStreamAsString, which should
		automatically cope with unicode/acsii file formats.
	*/
	String loadFileAsString() const;

	/** Reads the contents of this file as text and splits it into lines, which are
		appended to the given StringArray.
	*/
	void readLines (StringArray& destLines) const;

	/** Appends a block of binary data to the end of the file.

		This will try to write the given buffer to the end of the file.

		@returns false if it can't write to the file for some reason
	*/
	bool appendData (const void* dataToAppend,
					 int numberOfBytes) const;

	/** Replaces this file's contents with a given block of data.

		This will delete the file and replace it with the given data.

		A nice feature of this method is that it's safe - instead of deleting
		the file first and then re-writing it, it creates a new temporary file,
		writes the data to that, and then moves the new file to replace the existing
		file. This means that if the power gets pulled out or something crashes,
		you're a lot less likely to end up with a corrupted or unfinished file..

		Returns true if the operation succeeds, or false if it fails.

		@see appendText
	*/
	bool replaceWithData (const void* dataToWrite,
						  int numberOfBytes) const;

	/** Appends a string to the end of the file.

		This will try to append a text string to the file, as either 16-bit unicode
		or 8-bit characters in the default system encoding.

		It can also write the 'ff fe' unicode header bytes before the text to indicate
		the endianness of the file.

		Any single \\n characters in the string are replaced with \\r\\n before it is written.

		@see replaceWithText
	*/
	bool appendText (const String& textToAppend,
					 bool asUnicode = false,
					 bool writeUnicodeHeaderBytes = false) const;

	/** Replaces this file's contents with a given text string.

		This will delete the file and replace it with the given text.

		A nice feature of this method is that it's safe - instead of deleting
		the file first and then re-writing it, it creates a new temporary file,
		writes the text to that, and then moves the new file to replace the existing
		file. This means that if the power gets pulled out or something crashes,
		you're a lot less likely to end up with an empty file..

		For an explanation of the parameters here, see the appendText() method.

		Returns true if the operation succeeds, or false if it fails.

		@see appendText
	*/
	bool replaceWithText (const String& textToWrite,
						  bool asUnicode = false,
						  bool writeUnicodeHeaderBytes = false) const;

	/** Attempts to scan the contents of this file and compare it to another file, returning
		true if this is possible and they match byte-for-byte.
	*/
	bool hasIdenticalContentTo (const File& other) const;

	/** Creates a set of files to represent each file root.

		e.g. on Windows this will create files for "c:\", "d:\" etc according
		to which ones are available. On the Mac/Linux, this will probably
		just add a single entry for "/".
	*/
	static void findFileSystemRoots (Array<File>& results);

	/** Finds the name of the drive on which this file lives.

		@returns the volume label of the drive, or an empty string if this isn't possible
	*/
	String getVolumeLabel() const;

	/** Returns the serial number of the volume on which this file lives.

		@returns the serial number, or zero if there's a problem doing this
	*/
	int getVolumeSerialNumber() const;

	/** Returns the number of bytes free on the drive that this file lives on.

		@returns the number of bytes free, or 0 if there's a problem finding this out
		@see getVolumeTotalSize
	*/
	int64 getBytesFreeOnVolume() const;

	/** Returns the total size of the drive that contains this file.

		@returns the total number of bytes that the volume can hold
		@see getBytesFreeOnVolume
	*/
	int64 getVolumeTotalSize() const;

	/** Returns true if this file is on a CD or DVD drive. */
	bool isOnCDRomDrive() const;

	/** Returns true if this file is on a hard disk.

		This will fail if it's a network drive, but will still be true for
		removable hard-disks.
	*/
	bool isOnHardDisk() const;

	/** Returns true if this file is on a removable disk drive.

		This might be a usb-drive, a CD-rom, or maybe a network drive.
	*/
	bool isOnRemovableDrive() const;

	/** Launches the file as a process.

		- if the file is executable, this will run it.

		- if it's a document of some kind, it will launch the document with its
		default viewer application.

		- if it's a folder, it will be opened in Explorer, Finder, or equivalent.

		@see revealToUser
	*/
	bool startAsProcess (const String& parameters = String::empty) const;

	/** Opens Finder, Explorer, or whatever the OS uses, to show the user this file's location.
		@see startAsProcess
	*/
	void revealToUser() const;

	/** A set of types of location that can be passed to the getSpecialLocation() method.
	*/
	enum SpecialLocationType
	{
		/** The user's home folder. This is the same as using File ("~"). */
		userHomeDirectory,

		/** The user's default documents folder. On Windows, this might be the user's
			"My Documents" folder. On the Mac it'll be their "Documents" folder. Linux
			doesn't tend to have one of these, so it might just return their home folder.
		*/
		userDocumentsDirectory,

		/** The folder that contains the user's desktop objects. */
		userDesktopDirectory,

		/** The folder in which applications store their persistent user-specific settings.
			On Windows, this might be "\Documents and Settings\username\Application Data".
			On the Mac, it might be "~/Library". If you're going to store your settings in here,
			always create your own sub-folder to put them in, to avoid making a mess.
		*/
		userApplicationDataDirectory,

		/** An equivalent of the userApplicationDataDirectory folder that is shared by all users
			of the computer, rather than just the current user.

			On the Mac it'll be "/Library", on Windows, it could be something like
			"\Documents and Settings\All Users\Application Data".

			Depending on the setup, this folder may be read-only.
		*/
		commonApplicationDataDirectory,

		/** The folder that should be used for temporary files.

			Always delete them when you're finished, to keep the user's computer tidy!
		*/
		tempDirectory,

		/** Returns this application's executable file.

			If running as a plug-in or DLL, this will (where possible) be the DLL rather than the
			host app.

			On the mac this will return the unix binary, not the package folder - see
			currentApplicationFile for that.

			See also invokedExecutableFile, which is similar, but if the exe was launched from a
			file link, invokedExecutableFile will return the name of the link.
		*/
		currentExecutableFile,

		/** Returns this application's location.

			If running as a plug-in or DLL, this will (where possible) be the DLL rather than the
			host app.

			On the mac this will return the package folder (if it's in one), not the unix binary
			that's inside it - compare with currentExecutableFile.
		*/
		currentApplicationFile,

		/** Returns the file that was invoked to launch this executable.
			This may differ from currentExecutableFile if the app was started from e.g. a link - this
			will return the name of the link that was used, whereas currentExecutableFile will return
			the actual location of the target executable.
		*/
		invokedExecutableFile,

		/** In a plugin, this will return the path of the host executable. */
		hostApplicationPath,

		/** The directory in which applications normally get installed.

			So on windows, this would be something like "c:\program files", on the
			Mac "/Applications", or "/usr" on linux.
		*/
		globalApplicationsDirectory,

		/** The most likely place where a user might store their music files.
		*/
		userMusicDirectory,

		/** The most likely place where a user might store their movie files.
		*/
		userMoviesDirectory,
	};

	/** Finds the location of a special type of file or directory, such as a home folder or
		documents folder.

		@see SpecialLocationType
	*/
	static File JUCE_CALLTYPE getSpecialLocation (const SpecialLocationType type);

	/** Returns a temporary file in the system's temp directory.

		This will try to return the name of a non-existent temp file.

		To get the temp folder, you can use getSpecialLocation (File::tempDirectory).
	*/
	static File createTempFile (const String& fileNameEnding);

	/** Returns the current working directory.

		@see setAsCurrentWorkingDirectory
	*/
	static File getCurrentWorkingDirectory();

	/** Sets the current working directory to be this file.

		For this to work the file must point to a valid directory.

		@returns true if the current directory has been changed.
		@see getCurrentWorkingDirectory
	*/
	bool setAsCurrentWorkingDirectory() const;

	/** The system-specific file separator character.

		On Windows, this will be '\', on Mac/Linux, it'll be '/'
	*/
	static const juce_wchar separator;

	/** The system-specific file separator character, as a string.

		On Windows, this will be '\', on Mac/Linux, it'll be '/'
	*/
	static const String separatorString;

	/** Removes illegal characters from a filename.

		This will return a copy of the given string after removing characters
		that are not allowed in a legal filename, and possibly shortening the
		string if it's too long.

		Because this will remove slashes, don't use it on an absolute pathname.

		@see createLegalPathName
	*/
	static String createLegalFileName (const String& fileNameToFix);

	/** Removes illegal characters from a pathname.

		Similar to createLegalFileName(), but this won't remove slashes, so can
		be used on a complete pathname.

		@see createLegalFileName
	*/
	static String createLegalPathName (const String& pathNameToFix);

	/** Indicates whether filenames are case-sensitive on the current operating system.
	*/
	static bool areFileNamesCaseSensitive();

	/** Returns true if the string seems to be a fully-specified absolute path.
	*/
	static bool isAbsolutePath (const String& path);

	/** Creates a file that simply contains this string, without doing the sanity-checking
		that the normal constructors do.

		Best to avoid this unless you really know what you're doing.
	*/
	static File createFileWithoutCheckingPath (const String& path);

	/** Adds a separator character to the end of a path if it doesn't already have one. */
	static String addTrailingSeparator (const String& path);

   #if JUCE_MAC || JUCE_IOS || DOXYGEN

	/** OSX ONLY - Finds the OSType of a file from the its resources. */
	OSType getMacOSType() const;

	/** OSX ONLY - Returns true if this file is actually a bundle. */
	bool isBundle() const;
   #endif

   #if JUCE_MAC || DOXYGEN
	/** OSX ONLY - Adds this file to the OSX dock */
	void addToDock() const;
   #endif

private:

	String fullPath;

	static String parseAbsolutePath (const String&);
	String getPathUpToLastSlash() const;

	Result createDirectoryInternal (const String&) const;
	bool copyInternal (const File&) const;
	bool moveInternal (const File&) const;
	bool setFileTimesInternal (int64 modificationTime, int64 accessTime, int64 creationTime) const;
	void getFileTimesInternal (int64& modificationTime, int64& accessTime, int64& creationTime) const;
	bool setFileReadOnlyInternal (bool shouldBeReadOnly) const;

	JUCE_LEAK_DETECTOR (File);
};

#endif   // __JUCE_FILE_JUCEHEADER__

/*** End of inlined file: juce_File.h ***/

/** A handy macro to make it easy to iterate all the child elements in an XmlElement.

	The parentXmlElement should be a reference to the parent XML, and the childElementVariableName
	will be the name of a pointer to each child element.

	E.g. @code
	XmlElement* myParentXml = createSomeKindOfXmlDocument();

	forEachXmlChildElement (*myParentXml, child)
	{
		if (child->hasTagName ("FOO"))
			doSomethingWithXmlElement (child);
	}

	@endcode

	@see forEachXmlChildElementWithTagName
*/
#define forEachXmlChildElement(parentXmlElement, childElementVariableName) \
\
	for (juce::XmlElement* childElementVariableName = (parentXmlElement).getFirstChildElement(); \
		 childElementVariableName != nullptr; \
		 childElementVariableName = childElementVariableName->getNextElement())

/** A macro that makes it easy to iterate all the child elements of an XmlElement
	which have a specified tag.

	This does the same job as the forEachXmlChildElement macro, but only for those
	elements that have a particular tag name.

	The parentXmlElement should be a reference to the parent XML, and the childElementVariableName
	will be the name of a pointer to each child element. The requiredTagName is the
	tag name to match.

	E.g. @code
	XmlElement* myParentXml = createSomeKindOfXmlDocument();

	forEachXmlChildElementWithTagName (*myParentXml, child, "MYTAG")
	{
		// the child object is now guaranteed to be a <MYTAG> element..
		doSomethingWithMYTAGElement (child);
	}

	@endcode

	@see forEachXmlChildElement
*/
#define forEachXmlChildElementWithTagName(parentXmlElement, childElementVariableName, requiredTagName) \
\
	for (juce::XmlElement* childElementVariableName = (parentXmlElement).getChildByName (requiredTagName); \
		 childElementVariableName != nullptr; \
		 childElementVariableName = childElementVariableName->getNextElementWithTagName (requiredTagName))

/** Used to build a tree of elements representing an XML document.

	An XML document can be parsed into a tree of XmlElements, each of which
	represents an XML tag structure, and which may itself contain other
	nested elements.

	An XmlElement can also be converted back into a text document, and has
	lots of useful methods for manipulating its attributes and sub-elements,
	so XmlElements can actually be used as a handy general-purpose data
	structure.

	Here's an example of parsing some elements: @code
	// check we're looking at the right kind of document..
	if (myElement->hasTagName ("ANIMALS"))
	{
		// now we'll iterate its sub-elements looking for 'giraffe' elements..
		forEachXmlChildElement (*myElement, e)
		{
			if (e->hasTagName ("GIRAFFE"))
			{
				// found a giraffe, so use some of its attributes..

				String giraffeName  = e->getStringAttribute ("name");
				int giraffeAge      = e->getIntAttribute ("age");
				bool isFriendly     = e->getBoolAttribute ("friendly");
			}
		}
	}
	@endcode

	And here's an example of how to create an XML document from scratch: @code
	// create an outer node called "ANIMALS"
	XmlElement animalsList ("ANIMALS");

	for (int i = 0; i < numAnimals; ++i)
	{
		// create an inner element..
		XmlElement* giraffe = new XmlElement ("GIRAFFE");

		giraffe->setAttribute ("name", "nigel");
		giraffe->setAttribute ("age", 10);
		giraffe->setAttribute ("friendly", true);

		// ..and add our new element to the parent node
		animalsList.addChildElement (giraffe);
	}

	// now we can turn the whole thing into a text document..
	String myXmlDoc = animalsList.createDocument (String::empty);
	@endcode

	@see XmlDocument
*/
class JUCE_API  XmlElement
{
public:

	/** Creates an XmlElement with this tag name. */
	explicit XmlElement (const String& tagName) noexcept;

	/** Creates a (deep) copy of another element. */
	XmlElement (const XmlElement& other);

	/** Creates a (deep) copy of another element. */
	XmlElement& operator= (const XmlElement& other);

   #if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
	XmlElement (XmlElement&& other) noexcept;
	XmlElement& operator= (XmlElement&& other) noexcept;
   #endif

	/** Deleting an XmlElement will also delete all its child elements. */
	~XmlElement() noexcept;

	/** Compares two XmlElements to see if they contain the same text and attiributes.

		The elements are only considered equivalent if they contain the same attiributes
		with the same values, and have the same sub-nodes.

		@param other                    the other element to compare to
		@param ignoreOrderOfAttributes  if true, this means that two elements with the
										same attributes in a different order will be
										considered the same; if false, the attributes must
										be in the same order as well
	*/
	bool isEquivalentTo (const XmlElement* other,
						 bool ignoreOrderOfAttributes) const noexcept;

	/** Returns an XML text document that represents this element.

		The string returned can be parsed to recreate the same XmlElement that
		was used to create it.

		@param dtdToUse         the DTD to add to the document
		@param allOnOneLine     if true, this means that the document will not contain any
								linefeeds, so it'll be smaller but not very easy to read.
		@param includeXmlHeader whether to add the "<?xml version..etc" line at the start of the
								document
		@param encodingType     the character encoding format string to put into the xml
								header
		@param lineWrapLength   the line length that will be used before items get placed on
								a new line. This isn't an absolute maximum length, it just
								determines how lists of attributes get broken up
		@see writeToStream, writeToFile
	*/
	String createDocument (const String& dtdToUse,
						   bool allOnOneLine = false,
						   bool includeXmlHeader = true,
						   const String& encodingType = "UTF-8",
						   int lineWrapLength = 60) const;

	/** Writes the document to a stream as UTF-8.

		@param output           the stream to write to
		@param dtdToUse         the DTD to add to the document
		@param allOnOneLine     if true, this means that the document will not contain any
								linefeeds, so it'll be smaller but not very easy to read.
		@param includeXmlHeader whether to add the "<?xml version..etc" line at the start of the
								document
		@param encodingType     the character encoding format string to put into the xml
								header
		@param lineWrapLength   the line length that will be used before items get placed on
								a new line. This isn't an absolute maximum length, it just
								determines how lists of attributes get broken up
		@see writeToFile, createDocument
	*/
	void writeToStream (OutputStream& output,
						const String& dtdToUse,
						bool allOnOneLine = false,
						bool includeXmlHeader = true,
						const String& encodingType = "UTF-8",
						int lineWrapLength = 60) const;

	/** Writes the element to a file as an XML document.

		To improve safety in case something goes wrong while writing the file, this
		will actually write the document to a new temporary file in the same
		directory as the destination file, and if this succeeds, it will rename this
		new file as the destination file (overwriting any existing file that was there).

		@param destinationFile  the file to write to. If this already exists, it will be
								overwritten.
		@param dtdToUse         the DTD to add to the document
		@param encodingType     the character encoding format string to put into the xml
								header
		@param lineWrapLength   the line length that will be used before items get placed on
								a new line. This isn't an absolute maximum length, it just
								determines how lists of attributes get broken up
		@returns    true if the file is written successfully; false if something goes wrong
					in the process
		@see createDocument
	*/
	bool writeToFile (const File& destinationFile,
					  const String& dtdToUse,
					  const String& encodingType = "UTF-8",
					  int lineWrapLength = 60) const;

	/** Returns this element's tag type name.

		E.g. for an element such as \<MOOSE legs="4" antlers="2">, this would return
		"MOOSE".

		@see hasTagName
	*/
	inline const String& getTagName() const noexcept            { return tagName; }

	/** Tests whether this element has a particular tag name.

		@param possibleTagName  the tag name you're comparing it with

		@see getTagName
	*/
	bool hasTagName (const String& possibleTagName) const noexcept;

	/** Returns the number of XML attributes this element contains.

		E.g. for an element such as \<MOOSE legs="4" antlers="2">, this would
		return 2.
	*/
	int getNumAttributes() const noexcept;

	/** Returns the name of one of the elements attributes.

		E.g. for an element such as \<MOOSE legs="4" antlers="2">, then
		getAttributeName(1) would return "antlers".

		@see getAttributeValue, getStringAttribute
	*/
	const String& getAttributeName (int attributeIndex) const noexcept;

	/** Returns the value of one of the elements attributes.

		E.g. for an element such as \<MOOSE legs="4" antlers="2">, then
		getAttributeName(1) would return "2".

		@see getAttributeName, getStringAttribute
	*/
	const String& getAttributeValue (int attributeIndex) const noexcept;

	// Attribute-handling methods..

	/** Checks whether the element contains an attribute with a certain name. */
	bool hasAttribute (const String& attributeName) const noexcept;

	/** Returns the value of a named attribute.

		@param attributeName        the name of the attribute to look up
	*/
	const String& getStringAttribute (const String& attributeName) const noexcept;

	/** Returns the value of a named attribute.

		@param attributeName        the name of the attribute to look up
		@param defaultReturnValue   a value to return if the element doesn't have an attribute
									with this name
	*/
	String getStringAttribute (const String& attributeName,
							   const String& defaultReturnValue) const;

	/** Compares the value of a named attribute with a value passed-in.

		@param attributeName            the name of the attribute to look up
		@param stringToCompareAgainst   the value to compare it with
		@param ignoreCase               whether the comparison should be case-insensitive
		@returns    true if the value of the attribute is the same as the string passed-in;
					false if it's different (or if no such attribute exists)
	*/
	bool compareAttribute (const String& attributeName,
						   const String& stringToCompareAgainst,
						   bool ignoreCase = false) const noexcept;

	/** Returns the value of a named attribute as an integer.

		This will try to find the attribute and convert it to an integer (using
		the String::getIntValue() method).

		@param attributeName        the name of the attribute to look up
		@param defaultReturnValue   a value to return if the element doesn't have an attribute
									with this name
		@see setAttribute
	*/
	int getIntAttribute (const String& attributeName,
						 int defaultReturnValue = 0) const;

	/** Returns the value of a named attribute as floating-point.

		This will try to find the attribute and convert it to an integer (using
		the String::getDoubleValue() method).

		@param attributeName        the name of the attribute to look up
		@param defaultReturnValue   a value to return if the element doesn't have an attribute
									with this name
		@see setAttribute
	*/
	double getDoubleAttribute (const String& attributeName,
							   double defaultReturnValue = 0.0) const;

	/** Returns the value of a named attribute as a boolean.

		This will try to find the attribute and interpret it as a boolean. To do this,
		it'll return true if the value is "1", "true", "y", etc, or false for other
		values.

		@param attributeName        the name of the attribute to look up
		@param defaultReturnValue   a value to return if the element doesn't have an attribute
									with this name
	*/
	bool getBoolAttribute (const String& attributeName,
						   bool defaultReturnValue = false) const;

	/** Adds a named attribute to the element.

		If the element already contains an attribute with this name, it's value will
		be updated to the new value. If there's no such attribute yet, a new one will
		be added.

		Note that there are other setAttribute() methods that take integers,
		doubles, etc. to make it easy to store numbers.

		@param attributeName        the name of the attribute to set
		@param newValue             the value to set it to
		@see removeAttribute
	*/
	void setAttribute (const String& attributeName,
					   const String& newValue);

	/** Adds a named attribute to the element, setting it to an integer value.

		If the element already contains an attribute with this name, it's value will
		be updated to the new value. If there's no such attribute yet, a new one will
		be added.

		Note that there are other setAttribute() methods that take integers,
		doubles, etc. to make it easy to store numbers.

		@param attributeName        the name of the attribute to set
		@param newValue             the value to set it to
	*/
	void setAttribute (const String& attributeName,
					   int newValue);

	/** Adds a named attribute to the element, setting it to a floating-point value.

		If the element already contains an attribute with this name, it's value will
		be updated to the new value. If there's no such attribute yet, a new one will
		be added.

		Note that there are other setAttribute() methods that take integers,
		doubles, etc. to make it easy to store numbers.

		@param attributeName        the name of the attribute to set
		@param newValue             the value to set it to
	*/
	void setAttribute (const String& attributeName,
					   double newValue);

	/** Removes a named attribute from the element.

		@param attributeName    the name of the attribute to remove
		@see removeAllAttributes
	*/
	void removeAttribute (const String& attributeName) noexcept;

	/** Removes all attributes from this element.
	*/
	void removeAllAttributes() noexcept;

	// Child element methods..

	/** Returns the first of this element's sub-elements.

		see getNextElement() for an example of how to iterate the sub-elements.

		@see forEachXmlChildElement
	*/
	XmlElement* getFirstChildElement() const noexcept       { return firstChildElement; }

	/** Returns the next of this element's siblings.

		This can be used for iterating an element's sub-elements, e.g.
		@code
		XmlElement* child = myXmlDocument->getFirstChildElement();

		while (child != nullptr)
		{
			...do stuff with this child..

			child = child->getNextElement();
		}
		@endcode

		Note that when iterating the child elements, some of them might be
		text elements as well as XML tags - use isTextElement() to work this
		out.

		Also, it's much easier and neater to use this method indirectly via the
		forEachXmlChildElement macro.

		@returns    the sibling element that follows this one, or zero if this is the last
					element in its parent

		@see getNextElement, isTextElement, forEachXmlChildElement
	*/
	inline XmlElement* getNextElement() const noexcept          { return nextListItem; }

	/** Returns the next of this element's siblings which has the specified tag
		name.

		This is like getNextElement(), but will scan through the list until it
		finds an element with the given tag name.

		@see getNextElement, forEachXmlChildElementWithTagName
	*/
	XmlElement* getNextElementWithTagName (const String& requiredTagName) const;

	/** Returns the number of sub-elements in this element.

		@see getChildElement
	*/
	int getNumChildElements() const noexcept;

	/** Returns the sub-element at a certain index.

		It's not very efficient to iterate the sub-elements by index - see
		getNextElement() for an example of how best to iterate.

		@returns the n'th child of this element, or 0 if the index is out-of-range
		@see getNextElement, isTextElement, getChildByName
	*/
	XmlElement* getChildElement (int index) const noexcept;

	/** Returns the first sub-element with a given tag-name.

		@param tagNameToLookFor     the tag name of the element you want to find
		@returns the first element with this tag name, or 0 if none is found
		@see getNextElement, isTextElement, getChildElement
	*/
	XmlElement* getChildByName (const String& tagNameToLookFor) const noexcept;

	/** Appends an element to this element's list of children.

		Child elements are deleted automatically when their parent is deleted, so
		make sure the object that you pass in will not be deleted by anything else,
		and make sure it's not already the child of another element.

		@see getFirstChildElement, getNextElement, getNumChildElements,
			 getChildElement, removeChildElement
	*/
	void addChildElement (XmlElement* newChildElement) noexcept;

	/** Inserts an element into this element's list of children.

		Child elements are deleted automatically when their parent is deleted, so
		make sure the object that you pass in will not be deleted by anything else,
		and make sure it's not already the child of another element.

		@param newChildNode     the element to add
		@param indexToInsertAt  the index at which to insert the new element - if this is
								below zero, it will be added to the end of the list
		@see addChildElement, insertChildElement
	*/
	void insertChildElement (XmlElement* newChildNode,
							 int indexToInsertAt) noexcept;

	/** Creates a new element with the given name and returns it, after adding it
		as a child element.

		This is a handy method that means that instead of writing this:
		@code
		XmlElement* newElement = new XmlElement ("foobar");
		myParentElement->addChildElement (newElement);
		@endcode

		..you could just write this:
		@code
		XmlElement* newElement = myParentElement->createNewChildElement ("foobar");
		@endcode
	*/
	XmlElement* createNewChildElement (const String& tagName);

	/** Replaces one of this element's children with another node.

		If the current element passed-in isn't actually a child of this element,
		this will return false and the new one won't be added. Otherwise, the
		existing element will be deleted, replaced with the new one, and it
		will return true.
	*/
	bool replaceChildElement (XmlElement* currentChildElement,
							  XmlElement* newChildNode) noexcept;

	/** Removes a child element.

		@param childToRemove            the child to look for and remove
		@param shouldDeleteTheChild     if true, the child will be deleted, if false it'll
										just remove it
	*/
	void removeChildElement (XmlElement* childToRemove,
							 bool shouldDeleteTheChild) noexcept;

	/** Deletes all the child elements in the element.

		@see removeChildElement, deleteAllChildElementsWithTagName
	*/
	void deleteAllChildElements() noexcept;

	/** Deletes all the child elements with a given tag name.

		@see removeChildElement
	*/
	void deleteAllChildElementsWithTagName (const String& tagName) noexcept;

	/** Returns true if the given element is a child of this one. */
	bool containsChildElement (const XmlElement* possibleChild) const noexcept;

	/** Recursively searches all sub-elements to find one that contains the specified
		child element.
	*/
	XmlElement* findParentElementOf (const XmlElement* elementToLookFor) noexcept;

	/** Sorts the child elements using a comparator.

		This will use a comparator object to sort the elements into order. The object
		passed must have a method of the form:
		@code
		int compareElements (const XmlElement* first, const XmlElement* second);
		@endcode

		..and this method must return:
		  - a value of < 0 if the first comes before the second
		  - a value of 0 if the two objects are equivalent
		  - a value of > 0 if the second comes before the first

		To improve performance, the compareElements() method can be declared as static or const.

		@param comparator   the comparator to use for comparing elements.
		@param retainOrderOfEquivalentItems     if this is true, then items which the comparator
							says are equivalent will be kept in the order in which they
							currently appear in the array. This is slower to perform, but
							may be important in some cases. If it's false, a faster algorithm
							is used, but equivalent elements may be rearranged.
	*/
	template <class ElementComparator>
	void sortChildElements (ElementComparator& comparator,
							bool retainOrderOfEquivalentItems = false)
	{
		const int num = getNumChildElements();

		if (num > 1)
		{
			HeapBlock <XmlElement*> elems (num);
			getChildElementsAsArray (elems);
			sortArray (comparator, (XmlElement**) elems, 0, num - 1, retainOrderOfEquivalentItems);
			reorderChildElements (elems, num);
		}
	}

	/** Returns true if this element is a section of text.

		Elements can either be an XML tag element or a secton of text, so this
		is used to find out what kind of element this one is.

		@see getAllText, addTextElement, deleteAllTextElements
	*/
	bool isTextElement() const noexcept;

	/** Returns the text for a text element.

		Note that if you have an element like this:

		@code<xyz>hello</xyz>@endcode

		then calling getText on the "xyz" element won't return "hello", because that is
		actually stored in a special text sub-element inside the xyz element. To get the
		"hello" string, you could either call getText on the (unnamed) sub-element, or
		use getAllSubText() to do this automatically.

		Note that leading and trailing whitespace will be included in the string - to remove
		if, just call String::trim() on the result.

		@see isTextElement, getAllSubText, getChildElementAllSubText
	*/
	const String& getText() const noexcept;

	/** Sets the text in a text element.

		Note that this is only a valid call if this element is a text element. If it's
		not, then no action will be performed. If you're trying to add text inside a normal
		element, you probably want to use addTextElement() instead.
	*/
	void setText (const String& newText);

	/** Returns all the text from this element's child nodes.

		This iterates all the child elements and when it finds text elements,
		it concatenates their text into a big string which it returns.

		E.g. @code<xyz>hello <x>there</x> world</xyz>@endcode
		if you called getAllSubText on the "xyz" element, it'd return "hello there world".

		Note that leading and trailing whitespace will be included in the string - to remove
		if, just call String::trim() on the result.

		@see isTextElement, getChildElementAllSubText, getText, addTextElement
	*/
	String getAllSubText() const;

	/** Returns all the sub-text of a named child element.

		If there is a child element with the given tag name, this will return
		all of its sub-text (by calling getAllSubText() on it). If there is
		no such child element, this will return the default string passed-in.

		@see getAllSubText
	*/
	String getChildElementAllSubText (const String& childTagName,
									  const String& defaultReturnValue) const;

	/** Appends a section of text to this element.

		@see isTextElement, getText, getAllSubText
	*/
	void addTextElement (const String& text);

	/** Removes all the text elements from this element.

		@see isTextElement, getText, getAllSubText, addTextElement
	*/
	void deleteAllTextElements() noexcept;

	/** Creates a text element that can be added to a parent element.
	*/
	static XmlElement* createTextElement (const String& text);

private:
	struct XmlAttributeNode
	{
		XmlAttributeNode (const XmlAttributeNode&) noexcept;
		XmlAttributeNode (const String& name, const String& value) noexcept;

		LinkedListPointer<XmlAttributeNode> nextListItem;
		String name, value;

		bool hasName (const String&) const noexcept;

	private:
		XmlAttributeNode& operator= (const XmlAttributeNode&);
	};

	friend class XmlDocument;
	friend class LinkedListPointer <XmlAttributeNode>;
	friend class LinkedListPointer <XmlElement>;
	friend class LinkedListPointer <XmlElement>::Appender;

	LinkedListPointer <XmlElement> nextListItem;
	LinkedListPointer <XmlElement> firstChildElement;
	LinkedListPointer <XmlAttributeNode> attributes;
	String tagName;

	XmlElement (int) noexcept;
	void copyChildrenAndAttributesFrom (const XmlElement&);
	void writeElementAsText (OutputStream&, int indentationLevel, int lineWrapLength) const;
	void getChildElementsAsArray (XmlElement**) const noexcept;
	void reorderChildElements (XmlElement**, int) noexcept;

	JUCE_LEAK_DETECTOR (XmlElement);
};

#endif   // __JUCE_XMLELEMENT_JUCEHEADER__

/*** End of inlined file: juce_XmlElement.h ***/

/**
	A set of named property values, which can be strings, integers, floating point, etc.

	Effectively, this just wraps a StringPairArray in an interface that makes it easier
	to load and save types other than strings.

	See the PropertiesFile class for a subclass of this, which automatically broadcasts change
	messages and saves/loads the list from a file.
*/
class JUCE_API  PropertySet
{
public:

	/** Creates an empty PropertySet.

		@param ignoreCaseOfKeyNames         if true, the names of properties are compared in a
											case-insensitive way
	*/
	PropertySet (bool ignoreCaseOfKeyNames = false);

	/** Creates a copy of another PropertySet.
	*/
	PropertySet (const PropertySet& other);

	/** Copies another PropertySet over this one.
	*/
	PropertySet& operator= (const PropertySet& other);

	/** Destructor. */
	virtual ~PropertySet();

	/** Returns one of the properties as a string.

		If the value isn't found in this set, then this will look for it in a fallback
		property set (if you've specified one with the setFallbackPropertySet() method),
		and if it can't find one there, it'll return the default value passed-in.

		@param keyName              the name of the property to retrieve
		@param defaultReturnValue   a value to return if the named property doesn't actually exist
	*/
	String getValue (const String& keyName,
					 const String& defaultReturnValue = String::empty) const noexcept;

	/** Returns one of the properties as an integer.

		If the value isn't found in this set, then this will look for it in a fallback
		property set (if you've specified one with the setFallbackPropertySet() method),
		and if it can't find one there, it'll return the default value passed-in.

		@param keyName              the name of the property to retrieve
		@param defaultReturnValue   a value to return if the named property doesn't actually exist
	*/
	int getIntValue (const String& keyName,
					 const int defaultReturnValue = 0) const noexcept;

	/** Returns one of the properties as an double.

		If the value isn't found in this set, then this will look for it in a fallback
		property set (if you've specified one with the setFallbackPropertySet() method),
		and if it can't find one there, it'll return the default value passed-in.

		@param keyName              the name of the property to retrieve
		@param defaultReturnValue   a value to return if the named property doesn't actually exist
	*/
	double getDoubleValue (const String& keyName,
						   const double defaultReturnValue = 0.0) const noexcept;

	/** Returns one of the properties as an boolean.

		The result will be true if the string found for this key name can be parsed as a non-zero
		integer.

		If the value isn't found in this set, then this will look for it in a fallback
		property set (if you've specified one with the setFallbackPropertySet() method),
		and if it can't find one there, it'll return the default value passed-in.

		@param keyName              the name of the property to retrieve
		@param defaultReturnValue   a value to return if the named property doesn't actually exist
	*/
	bool getBoolValue (const String& keyName,
					   const bool defaultReturnValue = false) const noexcept;

	/** Returns one of the properties as an XML element.

		The result will a new XMLElement object that the caller must delete. If may return 0 if the
		key isn't found, or if the entry contains an string that isn't valid XML.

		If the value isn't found in this set, then this will look for it in a fallback
		property set (if you've specified one with the setFallbackPropertySet() method),
		and if it can't find one there, it'll return the default value passed-in.

		@param keyName              the name of the property to retrieve
	*/
	XmlElement* getXmlValue (const String& keyName) const;

	/** Sets a named property.

		@param keyName      the name of the property to set. (This mustn't be an empty string)
		@param value        the new value to set it to
	*/
	void setValue (const String& keyName, const var& value);

	/** Sets a named property to an XML element.

		@param keyName      the name of the property to set. (This mustn't be an empty string)
		@param xml          the new element to set it to. If this is zero, the value will be set to
							an empty string
		@see getXmlValue
	*/
	void setValue (const String& keyName, const XmlElement* xml);

	/** This copies all the values from a source PropertySet to this one.
		This won't remove any existing settings, it just adds any that it finds in the source set.
	*/
	void addAllPropertiesFrom (const PropertySet& source);

	/** Deletes a property.

		@param keyName      the name of the property to delete. (This mustn't be an empty string)
	*/
	void removeValue (const String& keyName);

	/** Returns true if the properies include the given key. */
	bool containsKey (const String& keyName) const noexcept;

	/** Removes all values. */
	void clear();

	/** Returns the keys/value pair array containing all the properties. */
	StringPairArray& getAllProperties() noexcept                        { return properties; }

	/** Returns the lock used when reading or writing to this set */
	const CriticalSection& getLock() const noexcept                     { return lock; }

	/** Returns an XML element which encapsulates all the items in this property set.

		The string parameter is the tag name that should be used for the node.

		@see restoreFromXml
	*/
	XmlElement* createXml (const String& nodeName) const;

	/** Reloads a set of properties that were previously stored as XML.

		The node passed in must have been created by the createXml() method.

		@see createXml
	*/
	void restoreFromXml (const XmlElement& xml);

	/** Sets up a second PopertySet that will be used to look up any values that aren't
		set in this one.

		If you set this up to be a pointer to a second property set, then whenever one
		of the getValue() methods fails to find an entry in this set, it will look up that
		value in the fallback set, and if it finds it, it will return that.

		Make sure that you don't delete the fallback set while it's still being used by
		another set! To remove the fallback set, just call this method with a null pointer.

		@see getFallbackPropertySet
	*/
	void setFallbackPropertySet (PropertySet* fallbackProperties) noexcept;

	/** Returns the fallback property set.
		@see setFallbackPropertySet
	*/
	PropertySet* getFallbackPropertySet() const noexcept                { return fallbackProperties; }

protected:

	/** Subclasses can override this to be told when one of the properies has been changed. */
	virtual void propertyChanged();

private:

	StringPairArray properties;
	PropertySet* fallbackProperties;
	CriticalSection lock;
	bool ignoreCaseOfKeys;

	JUCE_LEAK_DETECTOR (PropertySet);
};

#endif   // __JUCE_PROPERTYSET_JUCEHEADER__

/*** End of inlined file: juce_PropertySet.h ***/


#endif
#ifndef __JUCE_REFERENCECOUNTEDARRAY_JUCEHEADER__

/*** Start of inlined file: juce_ReferenceCountedArray.h ***/
#ifndef __JUCE_REFERENCECOUNTEDARRAY_JUCEHEADER__
#define __JUCE_REFERENCECOUNTEDARRAY_JUCEHEADER__

/**
	Holds a list of objects derived from ReferenceCountedObject.

	A ReferenceCountedArray holds objects derived from ReferenceCountedObject,
	and takes care of incrementing and decrementing their ref counts when they
	are added and removed from the array.

	To make all the array's methods thread-safe, pass in "CriticalSection" as the templated
	TypeOfCriticalSectionToUse parameter, instead of the default DummyCriticalSection.

	@see Array, OwnedArray, StringArray
*/
template <class ObjectClass, class TypeOfCriticalSectionToUse = DummyCriticalSection>
class ReferenceCountedArray
{
public:
	typedef ReferenceCountedObjectPtr<ObjectClass> ObjectClassPtr;

	/** Creates an empty array.
		@see ReferenceCountedObject, Array, OwnedArray
	*/
	ReferenceCountedArray() noexcept
		: numUsed (0)
	{
	}

	/** Creates a copy of another array */
	template <class OtherObjectClass>
	ReferenceCountedArray (const ReferenceCountedArray<OtherObjectClass, TypeOfCriticalSectionToUse>& other) noexcept
	{
		const ScopedLockType lock (other.getLock());
		numUsed = other.size();
		data.setAllocatedSize (numUsed);
		memcpy (data.elements, other.getRawDataPointer(), numUsed * sizeof (ObjectClass*));

		for (int i = numUsed; --i >= 0;)
			if (data.elements[i] != nullptr)
				data.elements[i]->incReferenceCount();
	}

	/** Copies another array into this one.

		Any existing objects in this array will first be released.
	*/
	template <class OtherObjectClass>
	ReferenceCountedArray<ObjectClass, TypeOfCriticalSectionToUse>& operator= (const ReferenceCountedArray<OtherObjectClass, TypeOfCriticalSectionToUse>& other) noexcept
	{
		ReferenceCountedArray<ObjectClass, TypeOfCriticalSectionToUse> otherCopy (other);
		swapWithArray (otherCopy);
		return *this;
	}

	/** Destructor.
		Any objects in the array will be released, and may be deleted if not referenced from elsewhere.
	*/
	~ReferenceCountedArray()
	{
		clear();
	}

	/** Removes all objects from the array.

		Any objects in the array that are not referenced from elsewhere will be deleted.
	*/
	void clear()
	{
		const ScopedLockType lock (getLock());

		while (numUsed > 0)
			if (data.elements [--numUsed] != nullptr)
				data.elements [numUsed]->decReferenceCount();

		jassert (numUsed == 0);
		data.setAllocatedSize (0);
	}

	/** Returns the current number of objects in the array. */
	inline int size() const noexcept
	{
		return numUsed;
	}

	/** Returns a pointer to the object at this index in the array.

		If the index is out-of-range, this will return a null pointer, (and
		it could be null anyway, because it's ok for the array to hold null
		pointers as well as objects).

		@see getUnchecked
	*/
	inline ObjectClassPtr operator[] (const int index) const noexcept
	{
		return getObjectPointer (index);
	}

	/** Returns a pointer to the object at this index in the array, without checking
		whether the index is in-range.

		This is a faster and less safe version of operator[] which doesn't check the index passed in, so
		it can be used when you're sure the index if always going to be legal.
	*/
	inline ObjectClassPtr getUnchecked (const int index) const noexcept
	{
		return getObjectPointerUnchecked (index);
	}

	/** Returns a raw pointer to the object at this index in the array.

		If the index is out-of-range, this will return a null pointer, (and
		it could be null anyway, because it's ok for the array to hold null
		pointers as well as objects).

		@see getUnchecked
	*/
	inline ObjectClass* getObjectPointer (const int index) const noexcept
	{
		const ScopedLockType lock (getLock());
		return isPositiveAndBelow (index, numUsed) ? data.elements [index]
												   : nullptr;
	}

	/** Returns a raw pointer to the object at this index in the array, without checking
		whether the index is in-range.
	*/
	inline ObjectClass* getObjectPointerUnchecked (const int index) const noexcept
	{
		const ScopedLockType lock (getLock());
		jassert (isPositiveAndBelow (index, numUsed));
		return data.elements [index];
	}

	/** Returns a pointer to the first object in the array.

		This will return a null pointer if the array's empty.
		@see getLast
	*/
	inline ObjectClassPtr getFirst() const noexcept
	{
		const ScopedLockType lock (getLock());
		return numUsed > 0 ? data.elements [0]
						   : static_cast <ObjectClass*> (nullptr);
	}

	/** Returns a pointer to the last object in the array.

		This will return a null pointer if the array's empty.
		@see getFirst
	*/
	inline ObjectClassPtr getLast() const noexcept
	{
		const ScopedLockType lock (getLock());
		return numUsed > 0 ? data.elements [numUsed - 1]
						   : static_cast <ObjectClass*> (nullptr);
	}

	/** Returns a pointer to the actual array data.
		This pointer will only be valid until the next time a non-const method
		is called on the array.
	*/
	inline ObjectClass** getRawDataPointer() const noexcept
	{
		return data.elements;
	}

	/** Returns a pointer to the first element in the array.
		This method is provided for compatibility with standard C++ iteration mechanisms.
	*/
	inline ObjectClass** begin() const noexcept
	{
		return data.elements;
	}

	/** Returns a pointer to the element which follows the last element in the array.
		This method is provided for compatibility with standard C++ iteration mechanisms.
	*/
	inline ObjectClass** end() const noexcept
	{
		return data.elements + numUsed;
	}

	/** Finds the index of the first occurrence of an object in the array.

		@param objectToLookFor    the object to look for
		@returns                  the index at which the object was found, or -1 if it's not found
	*/
	int indexOf (const ObjectClass* const objectToLookFor) const noexcept
	{
		const ScopedLockType lock (getLock());
		ObjectClass** e = data.elements.getData();
		ObjectClass** const end_ = e + numUsed;

		while (e != end_)
		{
			if (objectToLookFor == *e)
				return static_cast <int> (e - data.elements.getData());

			++e;
		}

		return -1;
	}

	/** Returns true if the array contains a specified object.

		@param objectToLookFor      the object to look for
		@returns                    true if the object is in the array
	*/
	bool contains (const ObjectClass* const objectToLookFor) const noexcept
	{
		const ScopedLockType lock (getLock());
		ObjectClass** e = data.elements.getData();
		ObjectClass** const end_ = e + numUsed;

		while (e != end_)
		{
			if (objectToLookFor == *e)
				return true;

			++e;
		}

		return false;
	}

	/** Appends a new object to the end of the array.

		This will increase the new object's reference count.

		@param newObject       the new object to add to the array
		@see set, insert, addIfNotAlreadyThere, addSorted, addArray
	*/
	void add (ObjectClass* const newObject) noexcept
	{
		const ScopedLockType lock (getLock());
		data.ensureAllocatedSize (numUsed + 1);
		data.elements [numUsed++] = newObject;

		if (newObject != nullptr)
			newObject->incReferenceCount();
	}

	/** Inserts a new object into the array at the given index.

		If the index is less than 0 or greater than the size of the array, the
		element will be added to the end of the array.
		Otherwise, it will be inserted into the array, moving all the later elements
		along to make room.

		This will increase the new object's reference count.

		@param indexToInsertAt      the index at which the new element should be inserted
		@param newObject            the new object to add to the array
		@see add, addSorted, addIfNotAlreadyThere, set
	*/
	void insert (int indexToInsertAt,
				 ObjectClass* const newObject) noexcept
	{
		if (indexToInsertAt >= 0)
		{
			const ScopedLockType lock (getLock());

			if (indexToInsertAt > numUsed)
				indexToInsertAt = numUsed;

			data.ensureAllocatedSize (numUsed + 1);

			ObjectClass** const e = data.elements + indexToInsertAt;
			const int numToMove = numUsed - indexToInsertAt;

			if (numToMove > 0)
				memmove (e + 1, e, numToMove * sizeof (ObjectClass*));

			*e = newObject;

			if (newObject != nullptr)
				newObject->incReferenceCount();

			++numUsed;
		}
		else
		{
			add (newObject);
		}
	}

	/** Appends a new object at the end of the array as long as the array doesn't
		already contain it.

		If the array already contains a matching object, nothing will be done.

		@param newObject   the new object to add to the array
	*/
	void addIfNotAlreadyThere (ObjectClass* const newObject) noexcept
	{
		const ScopedLockType lock (getLock());
		if (! contains (newObject))
			add (newObject);
	}

	/** Replaces an object in the array with a different one.

		If the index is less than zero, this method does nothing.
		If the index is beyond the end of the array, the new object is added to the end of the array.

		The object being added has its reference count increased, and if it's replacing
		another object, then that one has its reference count decreased, and may be deleted.

		@param indexToChange        the index whose value you want to change
		@param newObject            the new value to set for this index.
		@see add, insert, remove
	*/
	void set (const int indexToChange,
			  ObjectClass* const newObject)
	{
		if (indexToChange >= 0)
		{
			const ScopedLockType lock (getLock());

			if (newObject != nullptr)
				newObject->incReferenceCount();

			if (indexToChange < numUsed)
			{
				if (data.elements [indexToChange] != nullptr)
					data.elements [indexToChange]->decReferenceCount();

				data.elements [indexToChange] = newObject;
			}
			else
			{
				data.ensureAllocatedSize (numUsed + 1);
				data.elements [numUsed++] = newObject;
			}
		}
	}

	/** Adds elements from another array to the end of this array.

		@param arrayToAddFrom       the array from which to copy the elements
		@param startIndex           the first element of the other array to start copying from
		@param numElementsToAdd     how many elements to add from the other array. If this
									value is negative or greater than the number of available elements,
									all available elements will be copied.
		@see add
	*/
	void addArray (const ReferenceCountedArray<ObjectClass, TypeOfCriticalSectionToUse>& arrayToAddFrom,
				   int startIndex = 0,
				   int numElementsToAdd = -1) noexcept
	{
		const ScopedLockType lock1 (arrayToAddFrom.getLock());

		{
			const ScopedLockType lock2 (getLock());

			if (startIndex < 0)
			{
				jassertfalse;
				startIndex = 0;
			}

			if (numElementsToAdd < 0 || startIndex + numElementsToAdd > arrayToAddFrom.size())
				numElementsToAdd = arrayToAddFrom.size() - startIndex;

			if (numElementsToAdd > 0)
			{
				data.ensureAllocatedSize (numUsed + numElementsToAdd);

				while (--numElementsToAdd >= 0)
					add (arrayToAddFrom.getUnchecked (startIndex++));
			}
		}
	}

	/** Inserts a new object into the array assuming that the array is sorted.

		This will use a comparator to find the position at which the new object
		should go. If the array isn't sorted, the behaviour of this
		method will be unpredictable.

		@param comparator   the comparator object to use to compare the elements - see the
							sort() method for details about this object's form
		@param newObject    the new object to insert to the array
		@returns the index at which the new object was added
		@see add, sort
	*/
	template <class ElementComparator>
	int addSorted (ElementComparator& comparator, ObjectClass* newObject) noexcept
	{
		const ScopedLockType lock (getLock());
		const int index = findInsertIndexInSortedArray (comparator, data.elements.getData(), newObject, 0, numUsed);
		insert (index, newObject);
		return index;
	}

	/** Inserts or replaces an object in the array, assuming it is sorted.

		This is similar to addSorted, but if a matching element already exists, then it will be
		replaced by the new one, rather than the new one being added as well.
	*/
	template <class ElementComparator>
	void addOrReplaceSorted (ElementComparator& comparator,
							 ObjectClass* newObject) noexcept
	{
		const ScopedLockType lock (getLock());
		const int index = findInsertIndexInSortedArray (comparator, data.elements.getData(), newObject, 0, numUsed);

		if (index > 0 && comparator.compareElements (newObject, data.elements [index - 1]) == 0)
			set (index - 1, newObject); // replace an existing object that matches
		else
			insert (index, newObject);  // no match, so insert the new one
	}

	/** Removes an object from the array.

		This will remove the object at a given index and move back all the
		subsequent objects to close the gap.

		If the index passed in is out-of-range, nothing will happen.

		The object that is removed will have its reference count decreased,
		and may be deleted if not referenced from elsewhere.

		@param indexToRemove    the index of the element to remove
		@see removeObject, removeRange
	*/
	void remove (const int indexToRemove)
	{
		const ScopedLockType lock (getLock());

		if (isPositiveAndBelow (indexToRemove, numUsed))
		{
			ObjectClass** const e = data.elements + indexToRemove;

			if (*e != nullptr)
				(*e)->decReferenceCount();

			--numUsed;
			const int numberToShift = numUsed - indexToRemove;

			if (numberToShift > 0)
				memmove (e, e + 1, numberToShift * sizeof (ObjectClass*));

			if ((numUsed << 1) < data.numAllocated)
				minimiseStorageOverheads();
		}
	}

	/** Removes and returns an object from the array.

		This will remove the object at a given index and return it, moving back all
		the subsequent objects to close the gap. If the index passed in is out-of-range,
		nothing will happen and a null pointer will be returned.

		@param indexToRemove    the index of the element to remove
		@see remove, removeObject, removeRange
	*/
	ObjectClassPtr removeAndReturn (const int indexToRemove)
	{
		ObjectClassPtr removedItem;
		const ScopedLockType lock (getLock());

		if (isPositiveAndBelow (indexToRemove, numUsed))
		{
			ObjectClass** const e = data.elements + indexToRemove;

			if (*e != nullptr)
			{
				removedItem = *e;
				(*e)->decReferenceCount();
			}

			--numUsed;
			const int numberToShift = numUsed - indexToRemove;

			if (numberToShift > 0)
				memmove (e, e + 1, numberToShift * sizeof (ObjectClass*));

			if ((numUsed << 1) < data.numAllocated)
				minimiseStorageOverheads();
		}

		return removedItem;
	}

	/** Removes the first occurrence of a specified object from the array.

		If the item isn't found, no action is taken. If it is found, it is
		removed and has its reference count decreased.

		@param objectToRemove   the object to try to remove
		@see remove, removeRange
	*/
	void removeObject (ObjectClass* const objectToRemove)
	{
		const ScopedLockType lock (getLock());
		remove (indexOf (objectToRemove));
	}

	/** Removes a range of objects from the array.

		This will remove a set of objects, starting from the given index,
		and move any subsequent elements down to close the gap.

		If the range extends beyond the bounds of the array, it will
		be safely clipped to the size of the array.

		The objects that are removed will have their reference counts decreased,
		and may be deleted if not referenced from elsewhere.

		@param startIndex       the index of the first object to remove
		@param numberToRemove   how many objects should be removed
		@see remove, removeObject
	*/
	void removeRange (const int startIndex,
					  const int numberToRemove)
	{
		const ScopedLockType lock (getLock());

		const int start = jlimit (0, numUsed, startIndex);
		const int end_   = jlimit (0, numUsed, startIndex + numberToRemove);

		if (end_ > start)
		{
			int i;
			for (i = start; i < end_; ++i)
			{
				if (data.elements[i] != nullptr)
				{
					data.elements[i]->decReferenceCount();
					data.elements[i] = nullptr; // (in case one of the destructors accesses this array and hits a dangling pointer)
				}
			}

			const int rangeSize = end_ - start;
			ObjectClass** e = data.elements + start;
			i = numUsed - end_;
			numUsed -= rangeSize;

			while (--i >= 0)
			{
				*e = e [rangeSize];
				++e;
			}

			if ((numUsed << 1) < data.numAllocated)
				minimiseStorageOverheads();
		}
	}

	/** Removes the last n objects from the array.

		The objects that are removed will have their reference counts decreased,
		and may be deleted if not referenced from elsewhere.

		@param howManyToRemove   how many objects to remove from the end of the array
		@see remove, removeObject, removeRange
	*/
	void removeLast (int howManyToRemove = 1)
	{
		const ScopedLockType lock (getLock());

		if (howManyToRemove > numUsed)
			howManyToRemove = numUsed;

		while (--howManyToRemove >= 0)
			remove (numUsed - 1);
	}

	/** Swaps a pair of objects in the array.

		If either of the indexes passed in is out-of-range, nothing will happen,
		otherwise the two objects at these positions will be exchanged.
	*/
	void swap (const int index1,
			   const int index2) noexcept
	{
		const ScopedLockType lock (getLock());

		if (isPositiveAndBelow (index1, numUsed)
			 && isPositiveAndBelow (index2, numUsed))
		{
			std::swap (data.elements [index1],
					   data.elements [index2]);
		}
	}

	/** Moves one of the objects to a different position.

		This will move the object to a specified index, shuffling along
		any intervening elements as required.

		So for example, if you have the array { 0, 1, 2, 3, 4, 5 } then calling
		move (2, 4) would result in { 0, 1, 3, 4, 2, 5 }.

		@param currentIndex     the index of the object to be moved. If this isn't a
								valid index, then nothing will be done
		@param newIndex         the index at which you'd like this object to end up. If this
								is less than zero, it will be moved to the end of the array
	*/
	void move (const int currentIndex,
			   int newIndex) noexcept
	{
		if (currentIndex != newIndex)
		{
			const ScopedLockType lock (getLock());

			if (isPositiveAndBelow (currentIndex, numUsed))
			{
				if (! isPositiveAndBelow (newIndex, numUsed))
					newIndex = numUsed - 1;

				ObjectClass* const value = data.elements [currentIndex];

				if (newIndex > currentIndex)
				{
					memmove (data.elements + currentIndex,
							 data.elements + currentIndex + 1,
							 (newIndex - currentIndex) * sizeof (ObjectClass*));
				}
				else
				{
					memmove (data.elements + newIndex + 1,
							 data.elements + newIndex,
							 (currentIndex - newIndex) * sizeof (ObjectClass*));
				}

				data.elements [newIndex] = value;
			}
		}
	}

	/** This swaps the contents of this array with those of another array.

		If you need to exchange two arrays, this is vastly quicker than using copy-by-value
		because it just swaps their internal pointers.
	*/
	void swapWithArray (ReferenceCountedArray& otherArray) noexcept
	{
		const ScopedLockType lock1 (getLock());
		const ScopedLockType lock2 (otherArray.getLock());

		data.swapWith (otherArray.data);
		std::swap (numUsed, otherArray.numUsed);
	}

	/** Compares this array to another one.

		@returns true only if the other array contains the same objects in the same order
	*/
	bool operator== (const ReferenceCountedArray& other) const noexcept
	{
		const ScopedLockType lock2 (other.getLock());
		const ScopedLockType lock1 (getLock());

		if (numUsed != other.numUsed)
			return false;

		for (int i = numUsed; --i >= 0;)
			if (data.elements [i] != other.data.elements [i])
				return false;

		return true;
	}

	/** Compares this array to another one.

		@see operator==
	*/
	bool operator!= (const ReferenceCountedArray<ObjectClass, TypeOfCriticalSectionToUse>& other) const noexcept
	{
		return ! operator== (other);
	}

	/** Sorts the elements in the array.

		This will use a comparator object to sort the elements into order. The object
		passed must have a method of the form:
		@code
		int compareElements (ElementType first, ElementType second);
		@endcode

		..and this method must return:
		  - a value of < 0 if the first comes before the second
		  - a value of 0 if the two objects are equivalent
		  - a value of > 0 if the second comes before the first

		To improve performance, the compareElements() method can be declared as static or const.

		@param comparator   the comparator to use for comparing elements.
		@param retainOrderOfEquivalentItems     if this is true, then items
							which the comparator says are equivalent will be
							kept in the order in which they currently appear
							in the array. This is slower to perform, but may
							be important in some cases. If it's false, a faster
							algorithm is used, but equivalent elements may be
							rearranged.

		@see sortArray
	*/
	template <class ElementComparator>
	void sort (ElementComparator& comparator,
			   const bool retainOrderOfEquivalentItems = false) const noexcept
	{
		(void) comparator;  // if you pass in an object with a static compareElements() method, this
							// avoids getting warning messages about the parameter being unused

		const ScopedLockType lock (getLock());
		sortArray (comparator, data.elements.getData(), 0, size() - 1, retainOrderOfEquivalentItems);
	}

	/** Reduces the amount of storage being used by the array.

		Arrays typically allocate slightly more storage than they need, and after
		removing elements, they may have quite a lot of unused space allocated.
		This method will reduce the amount of allocated storage to a minimum.
	*/
	void minimiseStorageOverheads() noexcept
	{
		const ScopedLockType lock (getLock());
		data.shrinkToNoMoreThan (numUsed);
	}

	/** Increases the array's internal storage to hold a minimum number of elements.

		Calling this before adding a large known number of elements means that
		the array won't have to keep dynamically resizing itself as the elements
		are added, and it'll therefore be more efficient.
	*/
	void ensureStorageAllocated (const int minNumElements)
	{
		const ScopedLockType lock (getLock());
		data.ensureAllocatedSize (minNumElements);
	}

	/** Returns the CriticalSection that locks this array.
		To lock, you can call getLock().enter() and getLock().exit(), or preferably use
		an object of ScopedLockType as an RAII lock for it.
	*/
	inline const TypeOfCriticalSectionToUse& getLock() const noexcept      { return data; }

	/** Returns the type of scoped lock to use for locking this array */
	typedef typename TypeOfCriticalSectionToUse::ScopedLockType ScopedLockType;

private:

	ArrayAllocationBase <ObjectClass*, TypeOfCriticalSectionToUse> data;
	int numUsed;
};

#endif   // __JUCE_REFERENCECOUNTEDARRAY_JUCEHEADER__

/*** End of inlined file: juce_ReferenceCountedArray.h ***/


#endif
#ifndef __JUCE_SCOPEDVALUESETTER_JUCEHEADER__

/*** Start of inlined file: juce_ScopedValueSetter.h ***/
#ifndef __JUCE_SCOPEDVALUESETTER_JUCEHEADER__
#define __JUCE_SCOPEDVALUESETTER_JUCEHEADER__

/**
	Helper class providing an RAII-based mechanism for temporarily setting and
	then re-setting a value.

	E.g. @code
	int x = 1;

	{
		ScopedValueSetter setter (x, 2);

		// x is now 2
	}

	// x is now 1 again

	{
		ScopedValueSetter setter (x, 3, 4);

		// x is now 3
	}

	// x is now 4
	@endcode

*/
template <typename ValueType>
class ScopedValueSetter
{
public:
	/** Creates a ScopedValueSetter that will immediately change the specified value to the
		given new value, and will then reset it to its original value when this object is deleted.
	*/
	ScopedValueSetter (ValueType& valueToSet,
					   const ValueType& newValue)
		: value (valueToSet),
		  originalValue (valueToSet)
	{
		valueToSet = newValue;
	}

	/** Creates a ScopedValueSetter that will immediately change the specified value to the
		given new value, and will then reset it to be valueWhenDeleted when this object is deleted.
	*/
	ScopedValueSetter (ValueType& valueToSet,
					   const ValueType& newValue,
					   const ValueType& valueWhenDeleted)
		: value (valueToSet),
		  originalValue (valueWhenDeleted)
	{
		valueToSet = newValue;
	}

	~ScopedValueSetter()
	{
		value = originalValue;
	}

private:

	ValueType& value;
	const ValueType originalValue;

	JUCE_DECLARE_NON_COPYABLE (ScopedValueSetter);
};

#endif   // __JUCE_SCOPEDVALUESETTER_JUCEHEADER__

/*** End of inlined file: juce_ScopedValueSetter.h ***/


#endif
#ifndef __JUCE_SORTEDSET_JUCEHEADER__

/*** Start of inlined file: juce_SortedSet.h ***/
#ifndef __JUCE_SORTEDSET_JUCEHEADER__
#define __JUCE_SORTEDSET_JUCEHEADER__

#if JUCE_MSVC
  #pragma warning (push)
  #pragma warning (disable: 4512)
#endif

/**
	Holds a set of unique primitive objects, such as ints or doubles.

	A set can only hold one item with a given value, so if for example it's a
	set of integers, attempting to add the same integer twice will do nothing
	the second time.

	Internally, the list of items is kept sorted (which means that whatever
	kind of primitive type is used must support the ==, <, >, <= and >= operators
	to determine the order), and searching the set for known values is very fast
	because it uses a binary-chop method.

	Note that if you're using a class or struct as the element type, it must be
	capable of being copied or moved with a straightforward memcpy, rather than
	needing construction and destruction code.

	To make all the set's methods thread-safe, pass in "CriticalSection" as the templated
	TypeOfCriticalSectionToUse parameter, instead of the default DummyCriticalSection.

	@see Array, OwnedArray, ReferenceCountedArray, StringArray, CriticalSection
*/
template <class ElementType, class TypeOfCriticalSectionToUse = DummyCriticalSection>
class SortedSet
{
public:

	/** Creates an empty set. */
	SortedSet() noexcept
	   : numUsed (0)
	{
	}

	/** Creates a copy of another set.
		@param other    the set to copy
	*/
	SortedSet (const SortedSet& other) noexcept
	{
		const ScopedLockType lock (other.getLock());
		numUsed = other.numUsed;
		data.setAllocatedSize (other.numUsed);
		memcpy (data.elements, other.data.elements, numUsed * sizeof (ElementType));
	}

	/** Destructor. */
	~SortedSet() noexcept
	{
	}

	/** Copies another set over this one.
		@param other    the set to copy
	*/
	SortedSet& operator= (const SortedSet& other) noexcept
	{
		if (this != &other)
		{
			const ScopedLockType lock1 (other.getLock());
			const ScopedLockType lock2 (getLock());

			data.ensureAllocatedSize (other.size());
			numUsed = other.numUsed;
			memcpy (data.elements, other.data.elements, numUsed * sizeof (ElementType));
			minimiseStorageOverheads();
		}

		return *this;
	}

	/** Compares this set to another one.

		Two sets are considered equal if they both contain the same set of
		elements.

		@param other    the other set to compare with
	*/
	bool operator== (const SortedSet<ElementType>& other) const noexcept
	{
		const ScopedLockType lock (getLock());

		if (numUsed != other.numUsed)
			return false;

		for (int i = numUsed; --i >= 0;)
			if (! (data.elements[i] == other.data.elements[i]))
				return false;

		return true;
	}

	/** Compares this set to another one.

		Two sets are considered equal if they both contain the same set of
		elements.

		@param other    the other set to compare with
	*/
	bool operator!= (const SortedSet<ElementType>& other) const noexcept
	{
		return ! operator== (other);
	}

	/** Removes all elements from the set.

		This will remove all the elements, and free any storage that the set is
		using. To clear it without freeing the storage, use the clearQuick()
		method instead.

		@see clearQuick
	*/
	void clear() noexcept
	{
		const ScopedLockType lock (getLock());
		data.setAllocatedSize (0);
		numUsed = 0;
	}

	/** Removes all elements from the set without freeing the array's allocated storage.

		@see clear
	*/
	void clearQuick() noexcept
	{
		const ScopedLockType lock (getLock());
		numUsed = 0;
	}

	/** Returns the current number of elements in the set.
	*/
	inline int size() const noexcept
	{
		return numUsed;
	}

	/** Returns one of the elements in the set.

		If the index passed in is beyond the range of valid elements, this
		will return zero.

		If you're certain that the index will always be a valid element, you
		can call getUnchecked() instead, which is faster.

		@param index    the index of the element being requested (0 is the first element in the set)
		@see getUnchecked, getFirst, getLast
	*/
	inline ElementType operator[] (const int index) const noexcept
	{
		const ScopedLockType lock (getLock());
		return isPositiveAndBelow (index, numUsed) ? data.elements [index]
												   : ElementType();
	}

	/** Returns one of the elements in the set, without checking the index passed in.
		Unlike the operator[] method, this will try to return an element without
		checking that the index is within the bounds of the set, so should only
		be used when you're confident that it will always be a valid index.

		@param index    the index of the element being requested (0 is the first element in the set)
		@see operator[], getFirst, getLast
	*/
	inline ElementType getUnchecked (const int index) const noexcept
	{
		const ScopedLockType lock (getLock());
		jassert (isPositiveAndBelow (index, numUsed));
		return data.elements [index];
	}

	/** Returns a direct reference to one of the elements in the set, without checking the index passed in.

		This is like getUnchecked, but returns a direct reference to the element, so that
		you can alter it directly. Obviously this can be dangerous, so only use it when
		absolutely necessary.

		@param index    the index of the element being requested (0 is the first element in the array)
	*/
	inline ElementType& getReference (const int index) const noexcept
	{
		const ScopedLockType lock (getLock());
		jassert (isPositiveAndBelow (index, numUsed));
		return data.elements [index];
	}

	/** Returns the first element in the set, or 0 if the set is empty.

		@see operator[], getUnchecked, getLast
	*/
	inline ElementType getFirst() const noexcept
	{
		const ScopedLockType lock (getLock());
		return numUsed > 0 ? data.elements [0] : ElementType();
	}

	/** Returns the last element in the set, or 0 if the set is empty.

		@see operator[], getUnchecked, getFirst
	*/
	inline ElementType getLast() const noexcept
	{
		const ScopedLockType lock (getLock());
		return numUsed > 0 ? data.elements [numUsed - 1] : ElementType();
	}

	/** Returns a pointer to the first element in the set.
		This method is provided for compatibility with standard C++ iteration mechanisms.
	*/
	inline ElementType* begin() const noexcept
	{
		return data.elements;
	}

	/** Returns a pointer to the element which follows the last element in the set.
		This method is provided for compatibility with standard C++ iteration mechanisms.
	*/
	inline ElementType* end() const noexcept
	{
		return data.elements + numUsed;
	}

	/** Finds the index of the first element which matches the value passed in.

		This will search the set for the given object, and return the index
		of its first occurrence. If the object isn't found, the method will return -1.

		@param elementToLookFor   the value or object to look for
		@returns                  the index of the object, or -1 if it's not found
	*/
	int indexOf (const ElementType elementToLookFor) const noexcept
	{
		const ScopedLockType lock (getLock());

		int start = 0;
		int end_ = numUsed;

		for (;;)
		{
			if (start >= end_)
			{
				return -1;
			}
			else if (elementToLookFor == data.elements [start])
			{
				return start;
			}
			else
			{
				const int halfway = (start + end_) >> 1;

				if (halfway == start)
					return -1;
				else if (elementToLookFor < data.elements [halfway])
					end_ = halfway;
				else
					start = halfway;
			}
		}
	}

	/** Returns true if the set contains at least one occurrence of an object.

		@param elementToLookFor     the value or object to look for
		@returns                    true if the item is found
	*/
	bool contains (const ElementType elementToLookFor) const noexcept
	{
		const ScopedLockType lock (getLock());

		int start = 0;
		int end_ = numUsed;

		for (;;)
		{
			if (start >= end_)
			{
				return false;
			}
			else if (elementToLookFor == data.elements [start])
			{
				return true;
			}
			else
			{
				const int halfway = (start + end_) >> 1;

				if (halfway == start)
					return false;
				else if (elementToLookFor < data.elements [halfway])
					end_ = halfway;
				else
					start = halfway;
			}
		}
	}

	/** Adds a new element to the set, (as long as it's not already in there).

		@param newElement       the new object to add to the set
		@see set, insert, addIfNotAlreadyThere, addSorted, addSet, addArray
	*/
	void add (const ElementType newElement) noexcept
	{
		const ScopedLockType lock (getLock());

		int start = 0;
		int end_ = numUsed;

		for (;;)
		{
			if (start >= end_)
			{
				jassert (start <= end_);
				insertInternal (start, newElement);
				break;
			}
			else if (newElement == data.elements [start])
			{
				break;
			}
			else
			{
				const int halfway = (start + end_) >> 1;

				if (halfway == start)
				{
					if (newElement < data.elements [halfway])
						insertInternal (start, newElement);
					else
						insertInternal (start + 1, newElement);

					break;
				}
				else if (newElement < data.elements [halfway])
					end_ = halfway;
				else
					start = halfway;
			}
		}
	}

	/** Adds elements from an array to this set.

		@param elementsToAdd        the array of elements to add
		@param numElementsToAdd     how many elements are in this other array
		@see add
	*/
	void addArray (const ElementType* elementsToAdd,
				   int numElementsToAdd) noexcept
	{
		const ScopedLockType lock (getLock());

		while (--numElementsToAdd >= 0)
			add (*elementsToAdd++);
	}

	/** Adds elements from another set to this one.

		@param setToAddFrom         the set from which to copy the elements
		@param startIndex           the first element of the other set to start copying from
		@param numElementsToAdd     how many elements to add from the other set. If this
									value is negative or greater than the number of available elements,
									all available elements will be copied.
		@see add
	*/
	template <class OtherSetType>
	void addSet (const OtherSetType& setToAddFrom,
				 int startIndex = 0,
				 int numElementsToAdd = -1) noexcept
	{
		const typename OtherSetType::ScopedLockType lock1 (setToAddFrom.getLock());

		{
			const ScopedLockType lock2 (getLock());
			jassert (this != &setToAddFrom);

			if (this != &setToAddFrom)
			{
				if (startIndex < 0)
				{
					jassertfalse;
					startIndex = 0;
				}

				if (numElementsToAdd < 0 || startIndex + numElementsToAdd > setToAddFrom.size())
					numElementsToAdd = setToAddFrom.size() - startIndex;

				addArray (setToAddFrom.elements + startIndex, numElementsToAdd);
			}
		}
	}

	/** Removes an element from the set.

		This will remove the element at a given index.
		If the index passed in is out-of-range, nothing will happen.

		@param indexToRemove    the index of the element to remove
		@returns                the element that has been removed
		@see removeValue, removeRange
	*/
	ElementType remove (const int indexToRemove) noexcept
	{
		const ScopedLockType lock (getLock());

		if (isPositiveAndBelow (indexToRemove, numUsed))
		{
			--numUsed;

			ElementType* const e = data.elements + indexToRemove;
			ElementType const removed = *e;
			const int numberToShift = numUsed - indexToRemove;

			if (numberToShift > 0)
				memmove (e, e + 1, numberToShift * sizeof (ElementType));

			if ((numUsed << 1) < data.numAllocated)
				minimiseStorageOverheads();

			return removed;
		}

		return ElementType();
	}

	/** Removes an item from the set.

		This will remove the given element from the set, if it's there.

		@param valueToRemove   the object to try to remove
		@see remove, removeRange
	*/
	void removeValue (const ElementType valueToRemove) noexcept
	{
		const ScopedLockType lock (getLock());
		remove (indexOf (valueToRemove));
	}

	/** Removes any elements which are also in another set.

		@param otherSet   the other set in which to look for elements to remove
		@see removeValuesNotIn, remove, removeValue, removeRange
	*/
	template <class OtherSetType>
	void removeValuesIn (const OtherSetType& otherSet) noexcept
	{
		const typename OtherSetType::ScopedLockType lock1 (otherSet.getLock());
		const ScopedLockType lock2 (getLock());

		if (this == &otherSet)
		{
			clear();
		}
		else
		{
			if (otherSet.size() > 0)
			{
				for (int i = numUsed; --i >= 0;)
					if (otherSet.contains (data.elements [i]))
						remove (i);
			}
		}
	}

	/** Removes any elements which are not found in another set.

		Only elements which occur in this other set will be retained.

		@param otherSet    the set in which to look for elements NOT to remove
		@see removeValuesIn, remove, removeValue, removeRange
	*/
	template <class OtherSetType>
	void removeValuesNotIn (const OtherSetType& otherSet) noexcept
	{
		const typename OtherSetType::ScopedLockType lock1 (otherSet.getLock());
		const ScopedLockType lock2 (getLock());

		if (this != &otherSet)
		{
			if (otherSet.size() <= 0)
			{
				clear();
			}
			else
			{
				for (int i = numUsed; --i >= 0;)
					if (! otherSet.contains (data.elements [i]))
						remove (i);
			}
		}
	}

	/** Reduces the amount of storage being used by the set.

		Sets typically allocate slightly more storage than they need, and after
		removing elements, they may have quite a lot of unused space allocated.
		This method will reduce the amount of allocated storage to a minimum.
	*/
	void minimiseStorageOverheads() noexcept
	{
		const ScopedLockType lock (getLock());
		data.shrinkToNoMoreThan (numUsed);
	}

	/** Increases the set's internal storage to hold a minimum number of elements.

		Calling this before adding a large known number of elements means that
		the set won't have to keep dynamically resizing itself as the elements
		are added, and it'll therefore be more efficient.
	*/
	void ensureStorageAllocated (const int minNumElements)
	{
		const ScopedLockType lock (getLock());
		data.ensureAllocatedSize (minNumElements);
	}

	/** Returns the CriticalSection that locks this array.
		To lock, you can call getLock().enter() and getLock().exit(), or preferably use
		an object of ScopedLockType as an RAII lock for it.
	*/
	inline const TypeOfCriticalSectionToUse& getLock() const noexcept      { return data; }

	/** Returns the type of scoped lock to use for locking this array */
	typedef typename TypeOfCriticalSectionToUse::ScopedLockType ScopedLockType;

private:

	ArrayAllocationBase <ElementType, TypeOfCriticalSectionToUse> data;
	int numUsed;

	void insertInternal (const int indexToInsertAt, const ElementType newElement) noexcept
	{
		data.ensureAllocatedSize (numUsed + 1);

		ElementType* const insertPos = data.elements + indexToInsertAt;
		const int numberToMove = numUsed - indexToInsertAt;

		if (numberToMove > 0)
			memmove (insertPos + 1, insertPos, numberToMove * sizeof (ElementType));

		*insertPos = newElement;
		++numUsed;
	}
};

#if JUCE_MSVC
  #pragma warning (pop)
#endif

#endif   // __JUCE_SORTEDSET_JUCEHEADER__

/*** End of inlined file: juce_SortedSet.h ***/


#endif
#ifndef __JUCE_SPARSESET_JUCEHEADER__

/*** Start of inlined file: juce_SparseSet.h ***/
#ifndef __JUCE_SPARSESET_JUCEHEADER__
#define __JUCE_SPARSESET_JUCEHEADER__


/*** Start of inlined file: juce_Range.h ***/
#ifndef __JUCE_RANGE_JUCEHEADER__
#define __JUCE_RANGE_JUCEHEADER__

/** A general-purpose range object, that simply represents any linear range with
	a start and end point.

	The templated parameter is expected to be a primitive integer or floating point
	type, though class types could also be used if they behave in a number-like way.
*/
template <typename ValueType>
class Range
{
public:

	/** Constructs an empty range. */
	Range() noexcept
		: start (ValueType()), end (ValueType())
	{
	}

	/** Constructs a range with given start and end values. */
	Range (const ValueType start_, const ValueType end_) noexcept
		: start (start_), end (jmax (start_, end_))
	{
	}

	/** Constructs a copy of another range. */
	Range (const Range& other) noexcept
		: start (other.start), end (other.end)
	{
	}

	/** Copies another range object. */
	Range& operator= (const Range& other) noexcept
	{
		start = other.start;
		end = other.end;
		return *this;
	}

	/** Destructor. */
	~Range() noexcept
	{
	}

	/** Returns the range that lies between two positions (in either order). */
	static Range between (const ValueType position1, const ValueType position2) noexcept
	{
		return (position1 < position2) ? Range (position1, position2)
									   : Range (position2, position1);
	}

	/** Returns a range with the specified start position and a length of zero. */
	static Range emptyRange (const ValueType start) noexcept
	{
		return Range (start, start);
	}

	/** Returns the start of the range. */
	inline ValueType getStart() const noexcept          { return start; }

	/** Returns the length of the range. */
	inline ValueType getLength() const noexcept         { return end - start; }

	/** Returns the end of the range. */
	inline ValueType getEnd() const noexcept            { return end; }

	/** Returns true if the range has a length of zero. */
	inline bool isEmpty() const noexcept                { return start == end; }

	/** Changes the start position of the range, leaving the end position unchanged.
		If the new start position is higher than the current end of the range, the end point
		will be pushed along to equal it, leaving an empty range at the new position.
	*/
	void setStart (const ValueType newStart) noexcept
	{
		start = newStart;
		if (end < newStart)
			end = newStart;
	}

	/** Returns a range with the same end as this one, but a different start.
		If the new start position is higher than the current end of the range, the end point
		will be pushed along to equal it, returning an empty range at the new position.
	*/
	Range withStart (const ValueType newStart) const noexcept
	{
		return Range (newStart, jmax (newStart, end));
	}

	/** Returns a range with the same length as this one, but moved to have the given start position. */
	Range movedToStartAt (const ValueType newStart) const noexcept
	{
		return Range (newStart, end + (newStart - start));
	}

	/** Changes the end position of the range, leaving the start unchanged.
		If the new end position is below the current start of the range, the start point
		will be pushed back to equal the new end point.
	*/
	void setEnd (const ValueType newEnd) noexcept
	{
		end = newEnd;
		if (newEnd < start)
			start = newEnd;
	}

	/** Returns a range with the same start position as this one, but a different end.
		If the new end position is below the current start of the range, the start point
		will be pushed back to equal the new end point.
	*/
	Range withEnd (const ValueType newEnd) const noexcept
	{
		return Range (jmin (start, newEnd), newEnd);
	}

	/** Returns a range with the same length as this one, but moved to have the given start position. */
	Range movedToEndAt (const ValueType newEnd) const noexcept
	{
		return Range (start + (newEnd - end), newEnd);
	}

	/** Changes the length of the range.
		Lengths less than zero are treated as zero.
	*/
	void setLength (const ValueType newLength) noexcept
	{
		end = start + jmax (ValueType(), newLength);
	}

	/** Returns a range with the same start as this one, but a different length.
		Lengths less than zero are treated as zero.
	*/
	Range withLength (const ValueType newLength) const noexcept
	{
		return Range (start, start + newLength);
	}

	/** Adds an amount to the start and end of the range. */
	inline const Range& operator+= (const ValueType amountToAdd) noexcept
	{
		start += amountToAdd;
		end += amountToAdd;
		return *this;
	}

	/** Subtracts an amount from the start and end of the range. */
	inline const Range& operator-= (const ValueType amountToSubtract) noexcept
	{
		start -= amountToSubtract;
		end -= amountToSubtract;
		return *this;
	}

	/** Returns a range that is equal to this one with an amount added to its
		start and end.
	*/
	Range operator+ (const ValueType amountToAdd) const noexcept
	{
		return Range (start + amountToAdd, end + amountToAdd);
	}

	/** Returns a range that is equal to this one with the specified amount
		subtracted from its start and end. */
	Range operator- (const ValueType amountToSubtract) const noexcept
	{
		return Range (start - amountToSubtract, end - amountToSubtract);
	}

	bool operator== (const Range& other) const noexcept     { return start == other.start && end == other.end; }
	bool operator!= (const Range& other) const noexcept     { return start != other.start || end != other.end; }

	/** Returns true if the given position lies inside this range. */
	bool contains (const ValueType position) const noexcept
	{
		return start <= position && position < end;
	}

	/** Returns the nearest value to the one supplied, which lies within the range. */
	ValueType clipValue (const ValueType value) const noexcept
	{
		return jlimit (start, end, value);
	}

	/** Returns true if the given range lies entirely inside this range. */
	bool contains (const Range& other) const noexcept
	{
		return start <= other.start && end >= other.end;
	}

	/** Returns true if the given range intersects this one. */
	bool intersects (const Range& other) const noexcept
	{
		return other.start < end && start < other.end;
	}

	/** Returns the range that is the intersection of the two ranges, or an empty range
		with an undefined start position if they don't overlap. */
	Range getIntersectionWith (const Range& other) const noexcept
	{
		return Range (jmax (start, other.start),
					  jmin (end, other.end));
	}

	/** Returns the smallest range that contains both this one and the other one. */
	Range getUnionWith (const Range& other) const noexcept
	{
		return Range (jmin (start, other.start),
					  jmax (end, other.end));
	}

	/** Returns a given range, after moving it forwards or backwards to fit it
		within this range.

		If the supplied range has a greater length than this one, the return value
		will be this range.

		Otherwise, if the supplied range is smaller than this one, the return value
		will be the new range, shifted forwards or backwards so that it doesn't extend
		beyond this one, but keeping its original length.
	*/
	Range constrainRange (const Range& rangeToConstrain) const noexcept
	{
		const ValueType otherLen = rangeToConstrain.getLength();
		return getLength() <= otherLen
				? *this
				: rangeToConstrain.movedToStartAt (jlimit (start, end - otherLen, rangeToConstrain.getStart()));
	}

private:

	ValueType start, end;
};

#endif   // __JUCE_RANGE_JUCEHEADER__

/*** End of inlined file: juce_Range.h ***/

/**
	Holds a set of primitive values, storing them as a set of ranges.

	This container acts like an array, but can efficiently hold large continguous
	ranges of values. It's quite a specialised class, mostly useful for things
	like keeping the set of selected rows in a listbox.

	The type used as a template paramter must be an integer type, such as int, short,
	int64, etc.
*/
template <class Type>
class SparseSet
{
public:

	/** Creates a new empty set. */
	SparseSet()
	{
	}

	/** Creates a copy of another SparseSet. */
	SparseSet (const SparseSet<Type>& other)
		: values (other.values)
	{
	}

	/** Clears the set. */
	void clear()
	{
		values.clear();
	}

	/** Checks whether the set is empty.

		This is much quicker than using (size() == 0).
	*/
	bool isEmpty() const noexcept
	{
		return values.size() == 0;
	}

	/** Returns the number of values in the set.

		Because of the way the data is stored, this method can take longer if there
		are a lot of items in the set. Use isEmpty() for a quick test of whether there
		are any items.
	*/
	Type size() const
	{
		Type total (0);

		for (int i = 0; i < values.size(); i += 2)
			total += values.getUnchecked (i + 1) - values.getUnchecked (i);

		return total;
	}

	/** Returns one of the values in the set.

		@param index    the index of the value to retrieve, in the range 0 to (size() - 1).
		@returns        the value at this index, or 0 if it's out-of-range
	*/
	Type operator[] (Type index) const
	{
		for (int i = 0; i < values.size(); i += 2)
		{
			const Type start (values.getUnchecked (i));
			const Type len (values.getUnchecked (i + 1) - start);

			if (index < len)
				return start + index;

			index -= len;
		}

		return Type();
	}

	/** Checks whether a particular value is in the set. */
	bool contains (const Type valueToLookFor) const
	{
		for (int i = 0; i < values.size(); ++i)
			if (valueToLookFor < values.getUnchecked(i))
				return (i & 1) != 0;

		return false;
	}

	/** Returns the number of contiguous blocks of values.
		@see getRange
	*/
	int getNumRanges() const noexcept
	{
		return values.size() >> 1;
	}

	/** Returns one of the contiguous ranges of values stored.
		@param rangeIndex   the index of the range to look up, between 0
							and (getNumRanges() - 1)
		@see getTotalRange
	*/
	const Range<Type> getRange (const int rangeIndex) const
	{
		if (isPositiveAndBelow (rangeIndex, getNumRanges()))
			return Range<Type> (values.getUnchecked (rangeIndex << 1),
								values.getUnchecked ((rangeIndex << 1) + 1));
		else
			return Range<Type>();
	}

	/** Returns the range between the lowest and highest values in the set.
		@see getRange
	*/
	Range<Type> getTotalRange() const
	{
		if (values.size() > 0)
		{
			jassert ((values.size() & 1) == 0);
			return Range<Type> (values.getUnchecked (0),
								values.getUnchecked (values.size() - 1));
		}

		return Range<Type>();
	}

	/** Adds a range of contiguous values to the set.
		e.g. addRange (Range \<int\> (10, 14)) will add (10, 11, 12, 13) to the set.
	*/
	void addRange (const Range<Type>& range)
	{
		jassert (range.getLength() >= 0);
		if (range.getLength() > 0)
		{
			removeRange (range);

			values.addUsingDefaultSort (range.getStart());
			values.addUsingDefaultSort (range.getEnd());

			simplify();
		}
	}

	/** Removes a range of values from the set.
		e.g. removeRange (Range\<int\> (10, 14)) will remove (10, 11, 12, 13) from the set.
	*/
	void removeRange (const Range<Type>& rangeToRemove)
	{
		jassert (rangeToRemove.getLength() >= 0);

		if (rangeToRemove.getLength() > 0
			 && values.size() > 0
			 && rangeToRemove.getStart() < values.getUnchecked (values.size() - 1)
			 && values.getUnchecked(0) < rangeToRemove.getEnd())
		{
			const bool onAtStart = contains (rangeToRemove.getStart() - 1);
			const Type lastValue (jmin (rangeToRemove.getEnd(), values.getLast()));
			const bool onAtEnd = contains (lastValue);

			for (int i = values.size(); --i >= 0;)
			{
				if (values.getUnchecked(i) <= lastValue)
				{
					while (values.getUnchecked(i) >= rangeToRemove.getStart())
					{
						values.remove (i);

						if (--i < 0)
							break;
					}

					break;
				}
			}

			if (onAtStart)   values.addUsingDefaultSort (rangeToRemove.getStart());
			if (onAtEnd)     values.addUsingDefaultSort (lastValue);

			simplify();
		}
	}

	/** Does an XOR of the values in a given range. */
	void invertRange (const Range<Type>& range)
	{
		SparseSet newItems;
		newItems.addRange (range);

		int i;
		for (i = getNumRanges(); --i >= 0;)
			newItems.removeRange (getRange (i));

		removeRange (range);

		for (i = newItems.getNumRanges(); --i >= 0;)
			addRange (newItems.getRange(i));
	}

	/** Checks whether any part of a given range overlaps any part of this set. */
	bool overlapsRange (const Range<Type>& range)
	{
		if (range.getLength() > 0)
		{
			for (int i = getNumRanges(); --i >= 0;)
			{
				if (values.getUnchecked ((i << 1) + 1) <= range.getStart())
					return false;

				if (values.getUnchecked (i << 1) < range.getEnd())
					return true;
			}
		}

		return false;
	}

	/** Checks whether the whole of a given range is contained within this one. */
	bool containsRange (const Range<Type>& range)
	{
		if (range.getLength() > 0)
		{
			for (int i = getNumRanges(); --i >= 0;)
			{
				if (values.getUnchecked ((i << 1) + 1) <= range.getStart())
					return false;

				if (values.getUnchecked (i << 1) <= range.getStart()
					 && range.getEnd() <= values.getUnchecked ((i << 1) + 1))
					return true;
			}
		}

		return false;
	}

	bool operator== (const SparseSet<Type>& other) noexcept
	{
		return values == other.values;
	}

	bool operator!= (const SparseSet<Type>& other) noexcept
	{
		return values != other.values;
	}

private:

	// alternating start/end values of ranges of values that are present.
	Array<Type, DummyCriticalSection> values;

	void simplify()
	{
		jassert ((values.size() & 1) == 0);

		for (int i = values.size(); --i > 0;)
			if (values.getUnchecked(i) == values.getUnchecked (i - 1))
				values.removeRange (--i, 2);
	}
};

#endif   // __JUCE_SPARSESET_JUCEHEADER__

/*** End of inlined file: juce_SparseSet.h ***/


#endif
#ifndef __JUCE_VARIANT_JUCEHEADER__

#endif
#ifndef __JUCE_DIRECTORYITERATOR_JUCEHEADER__

/*** Start of inlined file: juce_DirectoryIterator.h ***/
#ifndef __JUCE_DIRECTORYITERATOR_JUCEHEADER__
#define __JUCE_DIRECTORYITERATOR_JUCEHEADER__

/**
	Searches through a the files in a directory, returning each file that is found.

	A DirectoryIterator will search through a directory and its subdirectories using
	a wildcard filepattern match.

	If you may be finding a large number of files, this is better than
	using File::findChildFiles() because it doesn't block while it finds them
	all, and this is more memory-efficient.

	It can also guess how far it's got using a wildly inaccurate algorithm.
*/
class JUCE_API  DirectoryIterator
{
public:

	/** Creates a DirectoryIterator for a given directory.

		After creating one of these, call its next() method to get the
		first file - e.g. @code

		DirectoryIterator iter (File ("/animals/mooses"), true, "*.moose");

		while (iter.next())
		{
			File theFileItFound (iter.getFile());

			... etc
		}
		@endcode

		@param directory    the directory to search in
		@param isRecursive  whether all the subdirectories should also be searched
		@param wildCard     the file pattern to match
		@param whatToLookFor    a value from the File::TypesOfFileToFind enum, specifying
								whether to look for files, directories, or both.
	*/
	DirectoryIterator (const File& directory,
					   bool isRecursive,
					   const String& wildCard = "*",
					   int whatToLookFor = File::findFiles);

	/** Destructor. */
	~DirectoryIterator();

	/** Moves the iterator along to the next file.

		@returns    true if a file was found (you can then use getFile() to see what it was) - or
					false if there are no more matching files.
	*/
	bool next();

	/** Moves the iterator along to the next file, and returns various properties of that file.

		If you need to find out details about the file, it's more efficient to call this method than
		to call the normal next() method and then find out the details afterwards.

		All the parameters are optional, so pass null pointers for any items that you're not
		interested in.

		@returns    true if a file was found (you can then use getFile() to see what it was) - or
					false if there are no more matching files. If it returns false, then none of the
					parameters will be filled-in.
	*/
	bool next (bool* isDirectory,
			   bool* isHidden,
			   int64* fileSize,
			   Time* modTime,
			   Time* creationTime,
			   bool* isReadOnly);

	/** Returns the file that the iterator is currently pointing at.

		The result of this call is only valid after a call to next() has returned true.
	*/
	const File& getFile() const;

	/** Returns a guess of how far through the search the iterator has got.

		@returns    a value 0.0 to 1.0 to show the progress, although this won't be
					very accurate.
	*/
	float getEstimatedProgress() const;

private:

	class NativeIterator
	{
	public:
		NativeIterator (const File& directory, const String& wildCard);
		~NativeIterator();

		bool next (String& filenameFound,
				   bool* isDirectory, bool* isHidden, int64* fileSize,
				   Time* modTime, Time* creationTime, bool* isReadOnly);

		class Pimpl;

	private:
		friend class DirectoryIterator;
		friend class ScopedPointer<Pimpl>;
		ScopedPointer<Pimpl> pimpl;

		JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (NativeIterator);
	};

	friend class ScopedPointer<NativeIterator::Pimpl>;
	NativeIterator fileFinder;
	String wildCard, path;
	int index;
	mutable int totalNumFiles;
	const int whatToLookFor;
	const bool isRecursive;
	bool hasBeenAdvanced;
	ScopedPointer <DirectoryIterator> subIterator;
	File currentFile;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (DirectoryIterator);
};

#endif   // __JUCE_DIRECTORYITERATOR_JUCEHEADER__

/*** End of inlined file: juce_DirectoryIterator.h ***/


#endif
#ifndef __JUCE_FILE_JUCEHEADER__

#endif
#ifndef __JUCE_FILEINPUTSTREAM_JUCEHEADER__

/*** Start of inlined file: juce_FileInputStream.h ***/
#ifndef __JUCE_FILEINPUTSTREAM_JUCEHEADER__
#define __JUCE_FILEINPUTSTREAM_JUCEHEADER__

/**
	An input stream that reads from a local file.

	@see InputStream, FileOutputStream, File::createInputStream
*/
class JUCE_API  FileInputStream  : public InputStream
{
public:

	/** Creates a FileInputStream.

		@param fileToRead   the file to read from - if the file can't be accessed for some
							reason, then the stream will just contain no data
	*/
	explicit FileInputStream (const File& fileToRead);

	/** Destructor. */
	~FileInputStream();

	/** Returns the file that this stream is reading from. */
	const File& getFile() const noexcept                { return file; }

	/** Returns the status of the file stream.
		The result will be ok if the file opened successfully. If an error occurs while
		opening or reading from the file, this will contain an error message.
	*/
	const Result& getStatus() const noexcept            { return status; }

	/** Returns true if the stream couldn't be opened for some reason.
		@see getResult()
	*/
	bool failedToOpen() const noexcept                  { return status.failed(); }

	/** Returns true if the stream opened without problems.
		@see getResult()
	*/
	bool openedOk() const noexcept                      { return status.wasOk(); }

	int64 getTotalLength();
	int read (void* destBuffer, int maxBytesToRead);
	bool isExhausted();
	int64 getPosition();
	bool setPosition (int64 pos);

private:

	File file;
	void* fileHandle;
	int64 currentPosition, totalSize;
	Result status;
	bool needToSeek;

	void openHandle();
	void closeHandle();
	size_t readInternal (void* buffer, size_t numBytes);

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (FileInputStream);
};

#endif   // __JUCE_FILEINPUTSTREAM_JUCEHEADER__

/*** End of inlined file: juce_FileInputStream.h ***/


#endif
#ifndef __JUCE_FILEOUTPUTSTREAM_JUCEHEADER__

/*** Start of inlined file: juce_FileOutputStream.h ***/
#ifndef __JUCE_FILEOUTPUTSTREAM_JUCEHEADER__
#define __JUCE_FILEOUTPUTSTREAM_JUCEHEADER__

/**
	An output stream that writes into a local file.

	@see OutputStream, FileInputStream, File::createOutputStream
*/
class JUCE_API  FileOutputStream  : public OutputStream
{
public:

	/** Creates a FileOutputStream.

		If the file doesn't exist, it will first be created. If the file can't be
		created or opened, the failedToOpen() method will return
		true.

		If the file already exists when opened, the stream's write-postion will
		be set to the end of the file. To overwrite an existing file,
		use File::deleteFile() before opening the stream, or use setPosition(0)
		after it's opened (although this won't truncate the file).

		@see TemporaryFile
	*/
	FileOutputStream (const File& fileToWriteTo,
					  int bufferSizeToUse = 16384);

	/** Destructor. */
	~FileOutputStream();

	/** Returns the file that this stream is writing to.
	*/
	const File& getFile() const                         { return file; }

	/** Returns the status of the file stream.
		The result will be ok if the file opened successfully. If an error occurs while
		opening or writing to the file, this will contain an error message.
	*/
	const Result& getStatus() const noexcept            { return status; }

	/** Returns true if the stream couldn't be opened for some reason.
		@see getResult()
	*/
	bool failedToOpen() const noexcept                  { return status.failed(); }

	/** Returns true if the stream opened without problems.
		@see getResult()
	*/
	bool openedOk() const noexcept                      { return status.wasOk(); }

	/** Attempts to truncate the file to the current write position.
		To truncate a file to a specific size, first use setPosition() to seek to the
		appropriate location, and then call this method.
	*/
	Result truncate();

	void flush();
	int64 getPosition();
	bool setPosition (int64 pos);
	bool write (const void* data, int numBytes);
	void writeRepeatedByte (uint8 byte, int numTimesToRepeat);

private:

	File file;
	void* fileHandle;
	Result status;
	int64 currentPosition;
	int bufferSize, bytesInBuffer;
	HeapBlock <char> buffer;

	void openHandle();
	void closeHandle();
	void flushInternal();
	bool flushBuffer();
	int64 setPositionInternal (int64 newPosition);
	int writeInternal (const void* data, int numBytes);

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (FileOutputStream);
};

#endif   // __JUCE_FILEOUTPUTSTREAM_JUCEHEADER__

/*** End of inlined file: juce_FileOutputStream.h ***/


#endif
#ifndef __JUCE_FILESEARCHPATH_JUCEHEADER__

/*** Start of inlined file: juce_FileSearchPath.h ***/
#ifndef __JUCE_FILESEARCHPATH_JUCEHEADER__
#define __JUCE_FILESEARCHPATH_JUCEHEADER__

/**
	Encapsulates a set of folders that make up a search path.

	@see File
*/
class JUCE_API  FileSearchPath
{
public:

	/** Creates an empty search path. */
	FileSearchPath();

	/** Creates a search path from a string of pathnames.

		The path can be semicolon- or comma-separated, e.g.
		"/foo/bar;/foo/moose;/fish/moose"

		The separate folders are tokenised and added to the search path.
	*/
	FileSearchPath (const String& path);

	/** Creates a copy of another search path. */
	FileSearchPath (const FileSearchPath& other);

	/** Destructor. */
	~FileSearchPath();

	/** Uses a string containing a list of pathnames to re-initialise this list.

		This search path is cleared and the semicolon- or comma-separated folders
		in this string are added instead. e.g. "/foo/bar;/foo/moose;/fish/moose"
	*/
	FileSearchPath& operator= (const String& path);

	/** Returns the number of folders in this search path.

		@see operator[]
	*/
	int getNumPaths() const;

	/** Returns one of the folders in this search path.

		The file returned isn't guaranteed to actually be a valid directory.

		@see getNumPaths
	*/
	File operator[] (int index) const;

	/** Returns the search path as a semicolon-separated list of directories. */
	String toString() const;

	/** Adds a new directory to the search path.

		The new directory is added to the end of the list if the insertIndex parameter is
		less than zero, otherwise it is inserted at the given index.
	*/
	void add (const File& directoryToAdd,
			  int insertIndex = -1);

	/** Adds a new directory to the search path if it's not already in there. */
	void addIfNotAlreadyThere (const File& directoryToAdd);

	/** Removes a directory from the search path. */
	void remove (int indexToRemove);

	/** Merges another search path into this one.

		This will remove any duplicate directories.
	*/
	void addPath (const FileSearchPath& other);

	/** Removes any directories that are actually subdirectories of one of the other directories in the search path.

		If the search is intended to be recursive, there's no point having nested folders in the search
		path, because they'll just get searched twice and you'll get duplicate results.

		e.g. if the path is "c:\abc\de;c:\abc", this method will simplify it to "c:\abc"
	*/
	void removeRedundantPaths();

	/** Removes any directories that don't actually exist. */
	void removeNonExistentPaths();

	/** Searches the path for a wildcard.

		This will search all the directories in the search path in order, adding any
		matching files to the results array.

		@param results                  an array to append the results to
		@param whatToLookFor            a value from the File::TypesOfFileToFind enum, specifying whether to
										return files, directories, or both.
		@param searchRecursively        whether to recursively search the subdirectories too
		@param wildCardPattern          a pattern to match against the filenames
		@returns the number of files added to the array
		@see File::findChildFiles
	*/
	int findChildFiles (Array<File>& results,
						int whatToLookFor,
						bool searchRecursively,
						const String& wildCardPattern = "*") const;

	/** Finds out whether a file is inside one of the path's directories.

		This will return true if the specified file is a child of one of the
		directories specified by this path. Note that this doesn't actually do any
		searching or check that the files exist - it just looks at the pathnames
		to work out whether the file would be inside a directory.

		@param fileToCheck      the file to look for
		@param checkRecursively if true, then this will return true if the file is inside a
								subfolder of one of the path's directories (at any depth). If false
								it will only return true if the file is actually a direct child
								of one of the directories.
		@see File::isAChildOf

	*/
	bool isFileInPath (const File& fileToCheck,
					   bool checkRecursively) const;

private:

	StringArray directories;

	void init (const String& path);

	JUCE_LEAK_DETECTOR (FileSearchPath);
};

#endif   // __JUCE_FILESEARCHPATH_JUCEHEADER__

/*** End of inlined file: juce_FileSearchPath.h ***/


#endif
#ifndef __JUCE_MEMORYMAPPEDFILE_JUCEHEADER__

/*** Start of inlined file: juce_MemoryMappedFile.h ***/
#ifndef __JUCE_MEMORYMAPPEDFILE_JUCEHEADER__
#define __JUCE_MEMORYMAPPEDFILE_JUCEHEADER__

/**
	Maps a file into virtual memory for easy reading and/or writing.
*/
class JUCE_API  MemoryMappedFile
{
public:
	/** The read/write flags used when opening a memory mapped file. */
	enum AccessMode
	{
		readOnly,   /**< Indicates that the memory can only be read. */
		readWrite   /**< Indicates that the memory can be read and written to - changes that are
						 made will be flushed back to disk at the whim of the OS. */
	};

	/** Opens a file and maps it to an area of virtual memory.

		The file should already exist, and should already be the size that you want to work with
		when you call this. If the file is resized after being opened, the behaviour is undefined.

		If the file exists and the operation succeeds, the getData() and getSize() methods will
		return the location and size of the data that can be read or written. Note that the entire
		file is not read into memory immediately - the OS simply creates a virtual mapping, which
		will lazily pull the data into memory when blocks are accessed.

		If the file can't be opened for some reason, the getData() method will return a null pointer.
	*/
	MemoryMappedFile (const File& file, AccessMode mode);

	/** Destructor. */
	~MemoryMappedFile();

	/** Returns the address at which this file has been mapped, or a null pointer if
		the file couldn't be successfully mapped.
	*/
	void* getData() const noexcept              { return address; }

	/** Returns the number of bytes of data that are available for reading or writing.
		This will normally be the size of the file.
	*/
	size_t getSize() const noexcept             { return length; }

private:

	void* address;
	size_t length;

   #if JUCE_WINDOWS
	void* fileHandle;
   #else
	int fileHandle;
   #endif

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (MemoryMappedFile);
};

#endif   // __JUCE_MEMORYMAPPEDFILE_JUCEHEADER__

/*** End of inlined file: juce_MemoryMappedFile.h ***/


#endif
#ifndef __JUCE_TEMPORARYFILE_JUCEHEADER__

/*** Start of inlined file: juce_TemporaryFile.h ***/
#ifndef __JUCE_TEMPORARYFILE_JUCEHEADER__
#define __JUCE_TEMPORARYFILE_JUCEHEADER__

/**
	Manages a temporary file, which will be deleted when this object is deleted.

	This object is intended to be used as a stack based object, using its scope
	to make sure the temporary file isn't left lying around.

	For example:

	@code
	{
		File myTargetFile ("~/myfile.txt");

		// this will choose a file called something like "~/myfile_temp239348.txt"
		// which definitely doesn't exist at the time the constructor is called.
		TemporaryFile temp (myTargetFile);

		// create a stream to the temporary file, and write some data to it...
		ScopedPointer <FileOutputStream> out (temp.getFile().createOutputStream());

		if (out != nullptr)
		{
			out->write ( ...etc )
			out = nullptr; // (deletes the stream)

			// ..now we've finished writing, this will rename the temp file to
			// make it replace the target file we specified above.
			bool succeeded = temp.overwriteTargetFileWithTemporary();
		}

		// ..and even if something went wrong and our overwrite failed,
		// as the TemporaryFile object goes out of scope here, it'll make sure
		// that the temp file gets deleted.
	}
	@endcode

	@see File, FileOutputStream
*/
class JUCE_API  TemporaryFile
{
public:

	enum OptionFlags
	{
		useHiddenFile = 1,          /**< Indicates that the temporary file should be hidden -
										 i.e. its name should start with a dot. */
		putNumbersInBrackets = 2    /**< Indicates that when numbers are appended to make sure
										 the file is unique, they should go in brackets rather
										 than just being appended (see File::getNonexistentSibling() )*/
	};

	/** Creates a randomly-named temporary file in the default temp directory.

		@param suffix       a file suffix to use for the file
		@param optionFlags  a combination of the values listed in the OptionFlags enum
		The file will not be created until you write to it. And remember that when
		this object is deleted, the file will also be deleted!
	*/
	TemporaryFile (const String& suffix = String::empty,
				   int optionFlags = 0);

	/** Creates a temporary file in the same directory as a specified file.

		This is useful if you have a file that you want to overwrite, but don't
		want to harm the original file if the write operation fails. You can
		use this to create a temporary file next to the target file, then
		write to the temporary file, and finally use overwriteTargetFileWithTemporary()
		to replace the target file with the one you've just written.

		This class won't create any files until you actually write to them. And remember
		that when this object is deleted, the temporary file will also be deleted!

		@param targetFile   the file that you intend to overwrite - the temporary
							file will be created in the same directory as this
		@param optionFlags  a combination of the values listed in the OptionFlags enum
	*/
	TemporaryFile (const File& targetFile,
				   int optionFlags = 0);

	/** Destructor.

		When this object is deleted it will make sure that its temporary file is
		also deleted! If the operation fails, it'll throw an assertion in debug
		mode.
	*/
	~TemporaryFile();

	/** Returns the temporary file. */
	const File& getFile() const                 { return temporaryFile; }

	/** Returns the target file that was specified in the constructor. */
	const File& getTargetFile() const           { return targetFile; }

	/** Tries to move the temporary file to overwrite the target file that was
		specified in the constructor.

		If you used the constructor that specified a target file, this will attempt
		to replace that file with the temporary one.

		Before calling this, make sure:
		- that you've actually written to the temporary file
		- that you've closed any open streams that you were using to write to it
		- and that you don't have any streams open to the target file, which would
		  prevent it being overwritten

		If the file move succeeds, this returns false, and the temporary file will
		have disappeared. If it fails, the temporary file will probably still exist,
		but will be deleted when this object is destroyed.
	*/
	bool overwriteTargetFileWithTemporary() const;

	/** Attempts to delete the temporary file, if it exists.
		@returns true if the file is successfully deleted (or if it didn't exist).
	*/
	bool deleteTemporaryFile() const;

private:

	File temporaryFile, targetFile;

	void createTempFile (const File& parentDirectory, String name, const String& suffix, int optionFlags);

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (TemporaryFile);
};

#endif   // __JUCE_TEMPORARYFILE_JUCEHEADER__

/*** End of inlined file: juce_TemporaryFile.h ***/


#endif
#ifndef __JUCE_JSON_JUCEHEADER__

/*** Start of inlined file: juce_JSON.h ***/
#ifndef __JUCE_JSON_JUCEHEADER__
#define __JUCE_JSON_JUCEHEADER__

class InputStream;
class OutputStream;
class File;

/**
	Contains static methods for converting JSON-formatted text to and from var objects.

	The var class is structurally compatible with JSON-formatted data, so these
	functions allow you to parse JSON into a var object, and to convert a var
	object to JSON-formatted text.

	@see var
*/
class JSON
{
public:

	/** Parses a string of JSON-formatted text, and returns a result code containing
		any parse errors.

		This will return the parsed structure in the parsedResult parameter, and will
		return a Result object to indicate whether parsing was successful, and if not,
		it will contain an error message.

		If you're not interested in the error message, you can use one of the other
		shortcut parse methods, which simply return a var::null if the parsing fails.
	*/
	static Result parse (const String& text, var& parsedResult);

	/** Attempts to parse some JSON-formatted text, and returns the result as a var object.

		If the parsing fails, this simply returns var::null - if you need to find out more
		detail about the parse error, use the alternative parse() method which returns a Result.
	*/
	static var parse (const String& text);

	/** Attempts to parse some JSON-formatted text from a file, and returns the result
		as a var object.

		Note that this is just a short-cut for reading the entire file into a string and
		parsing the result.

		If the parsing fails, this simply returns var::null - if you need to find out more
		detail about the parse error, use the alternative parse() method which returns a Result.
	*/
	static var parse (const File& file);

	/** Attempts to parse some JSON-formatted text from a stream, and returns the result
		as a var object.

		Note that this is just a short-cut for reading the entire stream into a string and
		parsing the result.

		If the parsing fails, this simply returns var::null - if you need to find out more
		detail about the parse error, use the alternative parse() method which returns a Result.
	*/
	static var parse (InputStream& input);

	/** Returns a string which contains a JSON-formatted representation of the var object.
		If allOnOneLine is true, the result will be compacted into a single line of text
		with no carriage-returns. If false, it will be laid-out in a more human-readable format.
		@see writeToStream
	*/
	static String toString (const var& objectToFormat,
							bool allOnOneLine = false);

	/** Writes a JSON-formatted representation of the var object to the given stream.
		If allOnOneLine is true, the result will be compacted into a single line of text
		with no carriage-returns. If false, it will be laid-out in a more human-readable format.
		@see toString
	*/
	static void writeToStream (OutputStream& output,
							   const var& objectToFormat,
							   bool allOnOneLine = false);

private:

	JSON(); // This class can't be instantiated - just use its static methods.
};

#endif   // __JUCE_JSON_JUCEHEADER__

/*** End of inlined file: juce_JSON.h ***/


#endif
#ifndef __JUCE_FILELOGGER_JUCEHEADER__

/*** Start of inlined file: juce_FileLogger.h ***/
#ifndef __JUCE_FILELOGGER_JUCEHEADER__
#define __JUCE_FILELOGGER_JUCEHEADER__

/**
	A simple implemenation of a Logger that writes to a file.

	@see Logger
*/
class JUCE_API  FileLogger  : public Logger
{
public:

	/** Creates a FileLogger for a given file.

		@param fileToWriteTo    the file that to use - new messages will be appended
								to the file. If the file doesn't exist, it will be created,
								along with any parent directories that are needed.
		@param welcomeMessage   when opened, the logger will write a header to the log, along
								with the current date and time, and this welcome message
		@param maxInitialFileSizeBytes  if this is zero or greater, then if the file already exists
								but is larger than this number of bytes, then the start of the
								file will be truncated to keep the size down. This prevents a log
								file getting ridiculously large over time. The file will be truncated
								at a new-line boundary. If this value is less than zero, no size limit
								will be imposed; if it's zero, the file will always be deleted. Note that
								the size is only checked once when this object is created - any logging
								that is done later will be appended without any checking
	*/
	FileLogger (const File& fileToWriteTo,
				const String& welcomeMessage,
				const int maxInitialFileSizeBytes = 128 * 1024);

	/** Destructor. */
	~FileLogger();

	void logMessage (const String& message);

	File getLogFile() const               { return logFile; }

	/** Helper function to create a log file in the correct place for this platform.

		On Windows this will return a logger with a path such as:
		c:\\Documents and Settings\\username\\Application Data\\[logFileSubDirectoryName]\\[logFileName]

		On the Mac it'll create something like:
		~/Library/Logs/[logFileName]

		The method might return 0 if the file can't be created for some reason.

		@param logFileSubDirectoryName      if a subdirectory is needed, this is what it will be called -
											it's best to use the something like the name of your application here.
		@param logFileName                  the name of the file to create, e.g. "MyAppLog.txt". Don't just
											call it "log.txt" because if it goes in a directory with logs
											from other applications (as it will do on the Mac) then no-one
											will know which one is yours!
		@param welcomeMessage               a message that will be written to the log when it's opened.
		@param maxInitialFileSizeBytes      (see the FileLogger constructor for more info on this)
	*/
	static FileLogger* createDefaultAppLogger (const String& logFileSubDirectoryName,
											   const String& logFileName,
											   const String& welcomeMessage,
											   const int maxInitialFileSizeBytes = 128 * 1024);

private:

	File logFile;
	CriticalSection logLock;

	void trimFileSize (int maxFileSizeBytes) const;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (FileLogger);
};

#endif   // __JUCE_FILELOGGER_JUCEHEADER__

/*** End of inlined file: juce_FileLogger.h ***/


#endif
#ifndef __JUCE_LOGGER_JUCEHEADER__

#endif
#ifndef __JUCE_BIGINTEGER_JUCEHEADER__

/*** Start of inlined file: juce_BigInteger.h ***/
#ifndef __JUCE_BIGINTEGER_JUCEHEADER__
#define __JUCE_BIGINTEGER_JUCEHEADER__

class MemoryBlock;

/**
	An arbitrarily large integer class.

	A BigInteger can be used in a similar way to a normal integer, but has no size
	limit (except for memory and performance constraints).

	Negative values are possible, but the value isn't stored as 2s-complement, so
	be careful if you use negative values and look at the values of individual bits.
*/
class JUCE_API  BigInteger
{
public:

	/** Creates an empty BigInteger */
	BigInteger();

	/** Creates a BigInteger containing an integer value in its low bits.

		The low 32 bits of the number are initialised with this value.
	*/
	BigInteger (uint32 value);

	/** Creates a BigInteger containing an integer value in its low bits.

		The low 32 bits of the number are initialised with the absolute value
		passed in, and its sign is set to reflect the sign of the number.
	*/
	BigInteger (int32 value);

	/** Creates a BigInteger containing an integer value in its low bits.

		The low 64 bits of the number are initialised with the absolute value
		passed in, and its sign is set to reflect the sign of the number.
	*/
	BigInteger (int64 value);

	/** Creates a copy of another BigInteger. */
	BigInteger (const BigInteger& other);

   #if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
	BigInteger (BigInteger&& other) noexcept;
	BigInteger& operator= (BigInteger&& other) noexcept;
   #endif

	/** Destructor. */
	~BigInteger();

	/** Copies another BigInteger onto this one. */
	BigInteger& operator= (const BigInteger& other);

	/** Swaps the internal contents of this with another object. */
	void swapWith (BigInteger& other) noexcept;

	/** Returns the value of a specified bit in the number.
		If the index is out-of-range, the result will be false.
	*/
	bool operator[] (int bit) const noexcept;

	/** Returns true if no bits are set. */
	bool isZero() const noexcept;

	/** Returns true if the value is 1. */
	bool isOne() const noexcept;

	/** Attempts to get the lowest bits of the value as an integer.
		If the value is bigger than the integer limits, this will return only the lower bits.
	*/
	int toInteger() const noexcept;

	/** Resets the value to 0. */
	void clear();

	/** Clears a particular bit in the number. */
	void clearBit (int bitNumber) noexcept;

	/** Sets a specified bit to 1. */
	void setBit (int bitNumber);

	/** Sets or clears a specified bit. */
	void setBit (int bitNumber, bool shouldBeSet);

	/** Sets a range of bits to be either on or off.

		@param startBit     the first bit to change
		@param numBits      the number of bits to change
		@param shouldBeSet  whether to turn these bits on or off
	*/
	void setRange (int startBit, int numBits, bool shouldBeSet);

	/** Inserts a bit an a given position, shifting up any bits above it. */
	void insertBit (int bitNumber, bool shouldBeSet);

	/** Returns a range of bits as a new BigInteger.

		e.g. getBitRangeAsInt (0, 64) would return the lowest 64 bits.
		@see getBitRangeAsInt
	*/
	BigInteger getBitRange (int startBit, int numBits) const;

	/** Returns a range of bits as an integer value.

		e.g. getBitRangeAsInt (0, 32) would return the lowest 32 bits.

		Asking for more than 32 bits isn't allowed (obviously) - for that, use
		getBitRange().
	*/
	uint32 getBitRangeAsInt (int startBit, int numBits) const noexcept;

	/** Sets a range of bits to an integer value.

		Copies the given integer onto a range of bits, starting at startBit,
		and using up to numBits of the available bits.
	*/
	void setBitRangeAsInt (int startBit, int numBits, uint32 valueToSet);

	/** Shifts a section of bits left or right.

		@param howManyBitsLeft  how far to move the bits (+ve numbers shift it left, -ve numbers shift it right).
		@param startBit         the first bit to affect - if this is > 0, only bits above that index will be affected.
	*/
	void shiftBits (int howManyBitsLeft, int startBit);

	/** Returns the total number of set bits in the value. */
	int countNumberOfSetBits() const noexcept;

	/** Looks for the index of the next set bit after a given starting point.

		This searches from startIndex (inclusive) upwards for the first set bit,
		and returns its index. If no set bits are found, it returns -1.
	*/
	int findNextSetBit (int startIndex = 0) const noexcept;

	/** Looks for the index of the next clear bit after a given starting point.

		This searches from startIndex (inclusive) upwards for the first clear bit,
		and returns its index.
	*/
	int findNextClearBit (int startIndex = 0) const noexcept;

	/** Returns the index of the highest set bit in the number.
		If the value is zero, this will return -1.
	*/
	int getHighestBit() const noexcept;

	// All the standard arithmetic ops...

	BigInteger& operator+= (const BigInteger& other);
	BigInteger& operator-= (const BigInteger& other);
	BigInteger& operator*= (const BigInteger& other);
	BigInteger& operator/= (const BigInteger& other);
	BigInteger& operator|= (const BigInteger& other);
	BigInteger& operator&= (const BigInteger& other);
	BigInteger& operator^= (const BigInteger& other);
	BigInteger& operator%= (const BigInteger& other);
	BigInteger& operator<<= (int numBitsToShift);
	BigInteger& operator>>= (int numBitsToShift);
	BigInteger& operator++();
	BigInteger& operator--();
	BigInteger operator++ (int);
	BigInteger operator-- (int);

	BigInteger operator-() const;
	BigInteger operator+ (const BigInteger& other) const;
	BigInteger operator- (const BigInteger& other) const;
	BigInteger operator* (const BigInteger& other) const;
	BigInteger operator/ (const BigInteger& other) const;
	BigInteger operator| (const BigInteger& other) const;
	BigInteger operator& (const BigInteger& other) const;
	BigInteger operator^ (const BigInteger& other) const;
	BigInteger operator% (const BigInteger& other) const;
	BigInteger operator<< (int numBitsToShift) const;
	BigInteger operator>> (int numBitsToShift) const;

	bool operator== (const BigInteger& other) const noexcept;
	bool operator!= (const BigInteger& other) const noexcept;
	bool operator<  (const BigInteger& other) const noexcept;
	bool operator<= (const BigInteger& other) const noexcept;
	bool operator>  (const BigInteger& other) const noexcept;
	bool operator>= (const BigInteger& other) const noexcept;

	/** Does a signed comparison of two BigIntegers.

		Return values are:
			- 0 if the numbers are the same
			- < 0 if this number is smaller than the other
			- > 0 if this number is bigger than the other
	*/
	int compare (const BigInteger& other) const noexcept;

	/** Compares the magnitudes of two BigIntegers, ignoring their signs.

		Return values are:
			- 0 if the numbers are the same
			- < 0 if this number is smaller than the other
			- > 0 if this number is bigger than the other
	*/
	int compareAbsolute (const BigInteger& other) const noexcept;

	/** Divides this value by another one and returns the remainder.

		This number is divided by other, leaving the quotient in this number,
		with the remainder being copied to the other BigInteger passed in.
	*/
	void divideBy (const BigInteger& divisor, BigInteger& remainder);

	/** Returns the largest value that will divide both this value and the one passed-in.
	*/
	BigInteger findGreatestCommonDivisor (BigInteger other) const;

	/** Performs a combined exponent and modulo operation.

		This BigInteger's value becomes (this ^ exponent) % modulus.
	*/
	void exponentModulo (const BigInteger& exponent, const BigInteger& modulus);

	/** Performs an inverse modulo on the value.

		i.e. the result is (this ^ -1) mod (modulus).
	*/
	void inverseModulo (const BigInteger& modulus);

	/** Returns true if the value is less than zero.
		@see setNegative, negate
	*/
	bool isNegative() const noexcept;

	/** Changes the sign of the number to be positive or negative.
		@see isNegative, negate
	*/
	void setNegative (bool shouldBeNegative) noexcept;

	/** Inverts the sign of the number.
		@see isNegative, setNegative
	*/
	void negate() noexcept;

	/** Converts the number to a string.

		Specify a base such as 2 (binary), 8 (octal), 10 (decimal), 16 (hex).
		If minimumNumCharacters is greater than 0, the returned string will be
		padded with leading zeros to reach at least that length.
	*/
	String toString (int base, int minimumNumCharacters = 1) const;

	/** Reads the numeric value from a string.

		Specify a base such as 2 (binary), 8 (octal), 10 (decimal), 16 (hex).
		Any invalid characters will be ignored.
	*/
	void parseString (const String& text, int base);

	/** Turns the number into a block of binary data.

		The data is arranged as little-endian, so the first byte of data is the low 8 bits
		of the number, and so on.

		@see loadFromMemoryBlock
	*/
	MemoryBlock toMemoryBlock() const;

	/** Converts a block of raw data into a number.

		The data is arranged as little-endian, so the first byte of data is the low 8 bits
		of the number, and so on.

		@see toMemoryBlock
	*/
	void loadFromMemoryBlock (const MemoryBlock& data);

private:

	HeapBlock <uint32> values;
	size_t numValues;
	int highestBit;
	bool negative;

	void ensureSize (size_t numVals);
	void shiftLeft (int bits, int startBit);
	void shiftRight (int bits, int startBit);

	JUCE_LEAK_DETECTOR (BigInteger);
};

/** Writes a BigInteger to an OutputStream as a UTF8 decimal string. */
OutputStream& JUCE_CALLTYPE operator<< (OutputStream& stream, const BigInteger& value);

#ifndef DOXYGEN
 // For backwards compatibility, BitArray is defined as an alias for BigInteger.
 typedef BigInteger BitArray;
#endif

#endif   // __JUCE_BIGINTEGER_JUCEHEADER__

/*** End of inlined file: juce_BigInteger.h ***/


#endif
#ifndef __JUCE_EXPRESSION_JUCEHEADER__

/*** Start of inlined file: juce_Expression.h ***/
#ifndef __JUCE_EXPRESSION_JUCEHEADER__
#define __JUCE_EXPRESSION_JUCEHEADER__

/**
	A class for dynamically evaluating simple numeric expressions.

	This class can parse a simple C-style string expression involving floating point
	numbers, named symbols and functions. The basic arithmetic operations of +, -, *, /
	are supported, as well as parentheses, and any alphanumeric identifiers are
	assumed to be named symbols which will be resolved when the expression is
	evaluated.

	Expressions which use identifiers and functions require a subclass of
	Expression::Scope to be supplied when evaluating them, and this object
	is expected to be able to resolve the symbol names and perform the functions that
	are used.
*/
class JUCE_API  Expression
{
public:

	/** Creates a simple expression with a value of 0. */
	Expression();

	/** Destructor. */
	~Expression();

	/** Creates a simple expression with a specified constant value. */
	explicit Expression (double constant);

	/** Creates a copy of an expression. */
	Expression (const Expression& other);

	/** Copies another expression. */
	Expression& operator= (const Expression& other);

   #if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
	Expression (Expression&& other) noexcept;
	Expression& operator= (Expression&& other) noexcept;
   #endif

	/** Creates an expression by parsing a string.
		If there's a syntax error in the string, this will throw a ParseError exception.
		@throws ParseError
	*/
	explicit Expression (const String& stringToParse);

	/** Returns a string version of the expression. */
	String toString() const;

	/** Returns an expression which is an addtion operation of two existing expressions. */
	Expression operator+ (const Expression& other) const;
	/** Returns an expression which is a subtraction operation of two existing expressions. */
	Expression operator- (const Expression& other) const;
	/** Returns an expression which is a multiplication operation of two existing expressions. */
	Expression operator* (const Expression& other) const;
	/** Returns an expression which is a division operation of two existing expressions. */
	Expression operator/ (const Expression& other) const;
	/** Returns an expression which performs a negation operation on an existing expression. */
	Expression operator-() const;

	/** Returns an Expression which is an identifier reference. */
	static Expression symbol (const String& symbol);

	/** Returns an Expression which is a function call. */
	static Expression function (const String& functionName, const Array<Expression>& parameters);

	/** Returns an Expression which parses a string from a character pointer, and updates the pointer
		to indicate where it finished.

		The pointer is incremented so that on return, it indicates the character that follows
		the end of the expression that was parsed.

		If there's a syntax error in the string, this will throw a ParseError exception.
		@throws ParseError
	*/
	static Expression parse (String::CharPointerType& stringToParse);

	/** When evaluating an Expression object, this class is used to resolve symbols and
		perform functions that the expression uses.
	*/
	class JUCE_API  Scope
	{
	public:
		Scope();
		virtual ~Scope();

		/** Returns some kind of globally unique ID that identifies this scope. */
		virtual String getScopeUID() const;

		/** Returns the value of a symbol.
			If the symbol is unknown, this can throw an Expression::EvaluationError exception.
			The member value is set to the part of the symbol that followed the dot, if there is
			one, e.g. for "foo.bar", symbol = "foo" and member = "bar".
			@throws Expression::EvaluationError
		*/
		virtual Expression getSymbolValue (const String& symbol) const;

		/** Executes a named function.
			If the function name is unknown, this can throw an Expression::EvaluationError exception.
			@throws Expression::EvaluationError
		*/
		virtual double evaluateFunction (const String& functionName,
										 const double* parameters, int numParameters) const;

		/** Used as a callback by the Scope::visitRelativeScope() method.
			You should never create an instance of this class yourself, it's used by the
			expression evaluation code.
		*/
		class Visitor
		{
		public:
			virtual ~Visitor() {}
			virtual void visit (const Scope&) = 0;
		};

		/** Creates a Scope object for a named scope, and then calls a visitor
			to do some kind of processing with this new scope.

			If the name is valid, this method must create a suitable (temporary) Scope
			object to represent it, and must call the Visitor::visit() method with this
			new scope.
		*/
		virtual void visitRelativeScope (const String& scopeName, Visitor& visitor) const;
	};

	/** Evaluates this expression, without using a Scope.
		Without a Scope, no symbols can be used, and only basic functions such as sin, cos, tan,
		min, max are available.
		To find out about any errors during evaluation, use the other version of this method which
		takes a String parameter.
	*/
	double evaluate() const;

	/** Evaluates this expression, providing a scope that should be able to evaluate any symbols
		or functions that it uses.
		To find out about any errors during evaluation, use the other version of this method which
		takes a String parameter.
	*/
	double evaluate (const Scope& scope) const;

	/** Evaluates this expression, providing a scope that should be able to evaluate any symbols
		or functions that it uses.
	*/
	double evaluate (const Scope& scope, String& evaluationError) const;

	/** Attempts to return an expression which is a copy of this one, but with a constant adjusted
		to make the expression resolve to a target value.

		E.g. if the expression is "x + 10" and x is 5, then asking for a target value of 8 will return
		the expression "x + 3". Obviously some expressions can't be reversed in this way, in which
		case they might just be adjusted by adding a constant to the original expression.

		@throws Expression::EvaluationError
	*/
	Expression adjustedToGiveNewResult (double targetValue, const Scope& scope) const;

	/** Represents a symbol that is used in an Expression. */
	struct Symbol
	{
		Symbol (const String& scopeUID, const String& symbolName);
		bool operator== (const Symbol&) const noexcept;
		bool operator!= (const Symbol&) const noexcept;

		String scopeUID;    /**< The unique ID of the Scope that contains this symbol. */
		String symbolName;  /**< The name of the symbol. */
	};

	/** Returns a copy of this expression in which all instances of a given symbol have been renamed. */
	Expression withRenamedSymbol (const Symbol& oldSymbol, const String& newName, const Scope& scope) const;

	/** Returns true if this expression makes use of the specified symbol.
		If a suitable scope is supplied, the search will dereference and recursively check
		all symbols, so that it can be determined whether this expression relies on the given
		symbol at any level in its evaluation. If the scope parameter is null, this just checks
		whether the expression contains any direct references to the symbol.

		@throws Expression::EvaluationError
	*/
	bool referencesSymbol (const Symbol& symbol, const Scope& scope) const;

	/** Returns true if this expression contains any symbols. */
	bool usesAnySymbols() const;

	/** Returns a list of all symbols that may be needed to resolve this expression in the given scope. */
	void findReferencedSymbols (Array<Symbol>& results, const Scope& scope) const;

	/** An exception that can be thrown by Expression::parse(). */
	class ParseError  : public std::exception
	{
	public:
		ParseError (const String& message);

		String description;
	};

	/** Expression type.
		@see Expression::getType()
	*/
	enum Type
	{
		constantType,
		functionType,
		operatorType,
		symbolType
	};

	/** Returns the type of this expression. */
	Type getType() const noexcept;

	/** If this expression is a symbol, function or operator, this returns its identifier. */
	String getSymbolOrFunction() const;

	/** Returns the number of inputs to this expression.
		@see getInput
	*/
	int getNumInputs() const;

	/** Retrieves one of the inputs to this expression.
		@see getNumInputs
	*/
	Expression getInput (int index) const;

private:

	class Term;
	struct Helpers;
	friend class Term;
	friend struct Helpers;
	friend class ScopedPointer<Term>;
	friend class ReferenceCountedObjectPtr<Term>;
	ReferenceCountedObjectPtr<Term> term;

	explicit Expression (Term*);
};

#endif   // __JUCE_EXPRESSION_JUCEHEADER__

/*** End of inlined file: juce_Expression.h ***/


#endif
#ifndef __JUCE_MATHSFUNCTIONS_JUCEHEADER__

#endif
#ifndef __JUCE_RANDOM_JUCEHEADER__

/*** Start of inlined file: juce_Random.h ***/
#ifndef __JUCE_RANDOM_JUCEHEADER__
#define __JUCE_RANDOM_JUCEHEADER__

/**
	A random number generator.

	You can create a Random object and use it to generate a sequence of random numbers.
*/
class JUCE_API  Random
{
public:

	/** Creates a Random object based on a seed value.

		For a given seed value, the subsequent numbers generated by this object
		will be predictable, so a good idea is to set this value based
		on the time, e.g.

		new Random (Time::currentTimeMillis())
	*/
	explicit Random (int64 seedValue) noexcept;

	/** Creates a Random object using a random seed value.
		Internally, this calls setSeedRandomly() to randomise the seed.
	*/
	Random();

	/** Destructor. */
	~Random() noexcept;

	/** Returns the next random 32 bit integer.

		@returns a random integer from the full range 0x80000000 to 0x7fffffff
	*/
	int nextInt() noexcept;

	/** Returns the next random number, limited to a given range.
		The maxValue parameter may not be negative, or zero.
		@returns a random integer between 0 (inclusive) and maxValue (exclusive).
	*/
	int nextInt (int maxValue) noexcept;

	/** Returns the next 64-bit random number.

		@returns a random integer from the full range 0x8000000000000000 to 0x7fffffffffffffff
	*/
	int64 nextInt64() noexcept;

	/** Returns the next random floating-point number.

		@returns a random value in the range 0 to 1.0
	*/
	float nextFloat() noexcept;

	/** Returns the next random floating-point number.

		@returns a random value in the range 0 to 1.0
	*/
	double nextDouble() noexcept;

	/** Returns the next random boolean value.
	*/
	bool nextBool() noexcept;

	/** Returns a BigInteger containing a random number.

		@returns a random value in the range 0 to (maximumValue - 1).
	*/
	BigInteger nextLargeNumber (const BigInteger& maximumValue);

	/** Sets a range of bits in a BigInteger to random values. */
	void fillBitsRandomly (BigInteger& arrayToChange, int startBit, int numBits);

	/** Resets this Random object to a given seed value. */
	void setSeed (int64 newSeed) noexcept;

	/** Merges this object's seed with another value.
		This sets the seed to be a value created by combining the current seed and this
		new value.
	*/
	void combineSeed (int64 seedValue) noexcept;

	/** Reseeds this generator using a value generated from various semi-random system
		properties like the current time, etc.

		Because this function convolves the time with the last seed value, calling
		it repeatedly will increase the randomness of the final result.
	*/
	void setSeedRandomly();

	/** The overhead of creating a new Random object is fairly small, but if you want to avoid
		it, you can call this method to get a global shared Random object.

		It's not thread-safe though, so threads should use their own Random object, otherwise
		you run the risk of your random numbers becoming.. erm.. randomly corrupted..
	*/
	static Random& getSystemRandom() noexcept;

private:

	int64 seed;

	JUCE_LEAK_DETECTOR (Random);
};

#endif   // __JUCE_RANDOM_JUCEHEADER__

/*** End of inlined file: juce_Random.h ***/


#endif
#ifndef __JUCE_RANGE_JUCEHEADER__

#endif
#ifndef __JUCE_ATOMIC_JUCEHEADER__

#endif
#ifndef __JUCE_BYTEORDER_JUCEHEADER__

#endif
#ifndef __JUCE_HEAPBLOCK_JUCEHEADER__

#endif
#ifndef __JUCE_LEAKEDOBJECTDETECTOR_JUCEHEADER__

#endif
#ifndef __JUCE_MEMORY_JUCEHEADER__

#endif
#ifndef __JUCE_MEMORYBLOCK_JUCEHEADER__

#endif
#ifndef __JUCE_OPTIONALSCOPEDPOINTER_JUCEHEADER__

/*** Start of inlined file: juce_OptionalScopedPointer.h ***/
#ifndef __JUCE_OPTIONALSCOPEDPOINTER_JUCEHEADER__
#define __JUCE_OPTIONALSCOPEDPOINTER_JUCEHEADER__

/**
	Holds a pointer to an object which can optionally be deleted when this pointer
	goes out of scope.

	This acts in many ways like a ScopedPointer, but allows you to specify whether or
	not the object is deleted.

	@see ScopedPointer
*/
template <class ObjectType>
class OptionalScopedPointer
{
public:

	/** Creates an empty OptionalScopedPointer. */
	OptionalScopedPointer() : shouldDelete (false) {}

	/** Creates an OptionalScopedPointer to point to a given object, and specifying whether
		the OptionalScopedPointer will delete it.

		If takeOwnership is true, then the OptionalScopedPointer will act like a ScopedPointer,
		deleting the object when it is itself deleted. If this parameter is false, then the
		OptionalScopedPointer just holds a normal pointer to the object, and won't delete it.
	*/
	OptionalScopedPointer (ObjectType* objectToHold, bool takeOwnership)
		: object (objectToHold), shouldDelete (takeOwnership)
	{
	}

	/** Takes ownership of the object that another OptionalScopedPointer holds.

		Like a normal ScopedPointer, the objectToTransferFrom object will become null,
		as ownership of the managed object is transferred to this object.

		The flag to indicate whether or not to delete the managed object is also
		copied from the source object.
	*/
	OptionalScopedPointer (OptionalScopedPointer& objectToTransferFrom)
		: object (objectToTransferFrom.release()),
		  shouldDelete (objectToTransferFrom.shouldDelete)
	{
	}

	/** Takes ownership of the object that another OptionalScopedPointer holds.

		Like a normal ScopedPointer, the objectToTransferFrom object will become null,
		as ownership of the managed object is transferred to this object.

		The ownership flag that says whether or not to delete the managed object is also
		copied from the source object.
	*/
	OptionalScopedPointer& operator= (OptionalScopedPointer& objectToTransferFrom)
	{
		if (object != objectToTransferFrom.object)
		{
			clear();
			object = objectToTransferFrom.object;
		}

		shouldDelete = objectToTransferFrom.shouldDelete;
		return *this;
	}

	/** The destructor may or may not delete the object that is being held, depending on the
		takeOwnership flag that was specified when the object was first passed into an
		OptionalScopedPointer constructor.
	*/
	~OptionalScopedPointer()
	{
		clear();
	}

	/** Returns the object that this pointer is managing. */
	inline operator ObjectType*() const noexcept                    { return object; }

	/** Returns the object that this pointer is managing. */
	inline ObjectType& operator*() const noexcept                   { return *object; }

	/** Lets you access methods and properties of the object that this pointer is holding. */
	inline ObjectType* operator->() const noexcept                  { return object; }

	/** Removes the current object from this OptionalScopedPointer without deleting it.
		This will return the current object, and set this OptionalScopedPointer to a null pointer.
	*/
	ObjectType* release() noexcept                                  { return object.release(); }

	/** Resets this pointer to null, possibly deleting the object that it holds, if it has
		ownership of it.
	*/
	void clear()
	{
		if (! shouldDelete)
			object.release();
	}

	/** Swaps this object with another OptionalScopedPointer.
		The two objects simply exchange their states.
	*/
	void swapWith (OptionalScopedPointer<ObjectType>& other) noexcept
	{
		object.swapWith (other.object);
		std::swap (shouldDelete, other.shouldDelete);
	}

private:

	ScopedPointer<ObjectType> object;
	bool shouldDelete;
};

#endif   // __JUCE_OPTIONALSCOPEDPOINTER_JUCEHEADER__

/*** End of inlined file: juce_OptionalScopedPointer.h ***/


#endif
#ifndef __JUCE_REFERENCECOUNTEDOBJECT_JUCEHEADER__

#endif
#ifndef __JUCE_SCOPEDPOINTER_JUCEHEADER__

#endif
#ifndef __JUCE_SINGLETON_JUCEHEADER__

/*** Start of inlined file: juce_Singleton.h ***/
#ifndef __JUCE_SINGLETON_JUCEHEADER__
#define __JUCE_SINGLETON_JUCEHEADER__

/**
	Macro to declare member variables and methods for a singleton class.

	To use this, add the line juce_DeclareSingleton (MyClass, doNotRecreateAfterDeletion)
	to the class's definition.

	Then put a macro juce_ImplementSingleton (MyClass) along with the class's
	implementation code.

	It's also a very good idea to also add the call clearSingletonInstance() in your class's
	destructor, in case it is deleted by other means than deleteInstance()

	Clients can then call the static method MyClass::getInstance() to get a pointer
	to the singleton, or MyClass::getInstanceWithoutCreating() which will return 0 if
	no instance currently exists.

	e.g. @code

		class MySingleton
		{
		public:
			MySingleton()
			{
			}

			~MySingleton()
			{
				// this ensures that no dangling pointers are left when the
				// singleton is deleted.
				clearSingletonInstance();
			}

			juce_DeclareSingleton (MySingleton, false)
		};

		juce_ImplementSingleton (MySingleton)

		// example of usage:
		MySingleton* m = MySingleton::getInstance(); // creates the singleton if there isn't already one.

		...

		MySingleton::deleteInstance(); // safely deletes the singleton (if it's been created).

	@endcode

	If doNotRecreateAfterDeletion = true, it won't allow the object to be created more
	than once during the process's lifetime - i.e. after you've created and deleted the
	object, getInstance() will refuse to create another one. This can be useful to stop
	objects being accidentally re-created during your app's shutdown code.

	If you know that your object will only be created and deleted by a single thread, you
	can use the slightly more efficient juce_DeclareSingleton_SingleThreaded() macro instead
	of this one.

	@see juce_ImplementSingleton, juce_DeclareSingleton_SingleThreaded
*/
#define juce_DeclareSingleton(classname, doNotRecreateAfterDeletion) \
\
	static classname* _singletonInstance;  \
	static juce::CriticalSection _singletonLock; \
\
	static classname* JUCE_CALLTYPE getInstance() \
	{ \
		if (_singletonInstance == nullptr) \
		{\
			const juce::ScopedLock sl (_singletonLock); \
\
			if (_singletonInstance == nullptr) \
			{ \
				static bool alreadyInside = false; \
				static bool createdOnceAlready = false; \
\
				const bool problem = alreadyInside || ((doNotRecreateAfterDeletion) && createdOnceAlready); \
				jassert (! problem); \
				if (! problem) \
				{ \
					createdOnceAlready = true; \
					alreadyInside = true; \
					classname* newObject = new classname();  /* (use a stack variable to avoid setting the newObject value before the class has finished its constructor) */ \
					alreadyInside = false; \
\
					_singletonInstance = newObject; \
				} \
			} \
		} \
\
		return _singletonInstance; \
	} \
\
	static inline classname* JUCE_CALLTYPE getInstanceWithoutCreating() noexcept\
	{ \
		return _singletonInstance; \
	} \
\
	static void JUCE_CALLTYPE deleteInstance() \
	{ \
		const juce::ScopedLock sl (_singletonLock); \
		if (_singletonInstance != nullptr) \
		{ \
			classname* const old = _singletonInstance; \
			_singletonInstance = nullptr; \
			delete old; \
		} \
	} \
\
	void clearSingletonInstance() noexcept\
	{ \
		if (_singletonInstance == this) \
			_singletonInstance = nullptr; \
	}

/** This is a counterpart to the juce_DeclareSingleton macro.

	After adding the juce_DeclareSingleton to the class definition, this macro has
	to be used in the cpp file.
*/
#define juce_ImplementSingleton(classname) \
\
	classname* classname::_singletonInstance = nullptr; \
	juce::CriticalSection classname::_singletonLock;

/**
	Macro to declare member variables and methods for a singleton class.

	This is exactly the same as juce_DeclareSingleton, but doesn't use a critical
	section to make access to it thread-safe. If you know that your object will
	only ever be created or deleted by a single thread, then this is a
	more efficient version to use.

	If doNotRecreateAfterDeletion = true, it won't allow the object to be created more
	than once during the process's lifetime - i.e. after you've created and deleted the
	object, getInstance() will refuse to create another one. This can be useful to stop
	objects being accidentally re-created during your app's shutdown code.

	See the documentation for juce_DeclareSingleton for more information about
	how to use it, the only difference being that you have to use
	juce_ImplementSingleton_SingleThreaded instead of juce_ImplementSingleton.

	@see juce_ImplementSingleton_SingleThreaded, juce_DeclareSingleton, juce_DeclareSingleton_SingleThreaded_Minimal
*/
#define juce_DeclareSingleton_SingleThreaded(classname, doNotRecreateAfterDeletion) \
\
	static classname* _singletonInstance;  \
\
	static classname* getInstance() \
	{ \
		if (_singletonInstance == nullptr) \
		{ \
			static bool alreadyInside = false; \
			static bool createdOnceAlready = false; \
\
			const bool problem = alreadyInside || ((doNotRecreateAfterDeletion) && createdOnceAlready); \
			jassert (! problem); \
			if (! problem) \
			{ \
				createdOnceAlready = true; \
				alreadyInside = true; \
				classname* newObject = new classname();  /* (use a stack variable to avoid setting the newObject value before the class has finished its constructor) */ \
				alreadyInside = false; \
\
				_singletonInstance = newObject; \
			} \
		} \
\
		return _singletonInstance; \
	} \
\
	static inline classname* getInstanceWithoutCreating() noexcept\
	{ \
		return _singletonInstance; \
	} \
\
	static void deleteInstance() \
	{ \
		if (_singletonInstance != nullptr) \
		{ \
			classname* const old = _singletonInstance; \
			_singletonInstance = nullptr; \
			delete old; \
		} \
	} \
\
	void clearSingletonInstance() noexcept\
	{ \
		if (_singletonInstance == this) \
			_singletonInstance = nullptr; \
	}

/**
	Macro to declare member variables and methods for a singleton class.

	This is like juce_DeclareSingleton_SingleThreaded, but doesn't do any checking
	for recursion or repeated instantiation. It's intended for use as a lightweight
	version of a singleton, where you're using it in very straightforward
	circumstances and don't need the extra checking.

	Juce use the normal juce_ImplementSingleton_SingleThreaded as the counterpart
	to this declaration, as you would with juce_DeclareSingleton_SingleThreaded.

	See the documentation for juce_DeclareSingleton for more information about
	how to use it, the only difference being that you have to use
	juce_ImplementSingleton_SingleThreaded instead of juce_ImplementSingleton.

	@see juce_ImplementSingleton_SingleThreaded, juce_DeclareSingleton
*/
#define juce_DeclareSingleton_SingleThreaded_Minimal(classname) \
\
	static classname* _singletonInstance;  \
\
	static classname* getInstance() \
	{ \
		if (_singletonInstance == nullptr) \
			_singletonInstance = new classname(); \
\
		return _singletonInstance; \
	} \
\
	static inline classname* getInstanceWithoutCreating() noexcept\
	{ \
		return _singletonInstance; \
	} \
\
	static void deleteInstance() \
	{ \
		if (_singletonInstance != nullptr) \
		{ \
			classname* const old = _singletonInstance; \
			_singletonInstance = nullptr; \
			delete old; \
		} \
	} \
\
	void clearSingletonInstance() noexcept\
	{ \
		if (_singletonInstance == this) \
			_singletonInstance = nullptr; \
	}

/** This is a counterpart to the juce_DeclareSingleton_SingleThreaded macro.

	After adding juce_DeclareSingleton_SingleThreaded or juce_DeclareSingleton_SingleThreaded_Minimal
	to the class definition, this macro has to be used somewhere in the cpp file.
*/
#define juce_ImplementSingleton_SingleThreaded(classname) \
\
	classname* classname::_singletonInstance = nullptr;

#endif   // __JUCE_SINGLETON_JUCEHEADER__

/*** End of inlined file: juce_Singleton.h ***/


#endif
#ifndef __JUCE_WEAKREFERENCE_JUCEHEADER__

/*** Start of inlined file: juce_WeakReference.h ***/
#ifndef __JUCE_WEAKREFERENCE_JUCEHEADER__
#define __JUCE_WEAKREFERENCE_JUCEHEADER__

/**
	This class acts as a pointer which will automatically become null if the object
	to which it points is deleted.

	To accomplish this, the source object needs to cooperate by performing a couple of simple tasks.
	It must embed a WeakReference::Master object, which stores a shared pointer object, and must clear
	this master pointer in its destructor.

	E.g.
	@code
	class MyObject
	{
	public:
		MyObject()
		{
			// If you're planning on using your WeakReferences in a multi-threaded situation, you may choose
			// to create a WeakReference to the object here in the constructor, which will pre-initialise the
			// embedded object, avoiding an (extremely unlikely) race condition that could occur if multiple
			// threads overlap while creating the first WeakReference to it.
		}

		~MyObject()
		{
			// This will zero all the references - you need to call this in your destructor.
			masterReference.clear();
		}

	private:
		// You need to embed a variable of this type, with the name "masterReference" inside your object. If the
		// variable is not public, you should make your class a friend of WeakReference<MyObject> so that the
		// WeakReference class can access it.
		WeakReference<MyObject>::Master masterReference;
		friend class WeakReference<MyObject>;
	};

	// Here's an example of using a pointer..

	MyObject* n = new MyObject();
	WeakReference<MyObject> myObjectRef = n;

	MyObject* pointer1 = myObjectRef;  // returns a valid pointer to 'n'
	delete n;
	MyObject* pointer2 = myObjectRef;  // returns a null pointer
	@endcode

	@see WeakReference::Master
*/
template <class ObjectType, class ReferenceCountingType = ReferenceCountedObject>
class WeakReference
{
public:
	/** Creates a null SafePointer. */
	inline WeakReference() noexcept {}

	/** Creates a WeakReference that points at the given object. */
	WeakReference (ObjectType* const object)  : holder (getRef (object)) {}

	/** Creates a copy of another WeakReference. */
	WeakReference (const WeakReference& other) noexcept         : holder (other.holder) {}

	/** Copies another pointer to this one. */
	WeakReference& operator= (const WeakReference& other)       { holder = other.holder; return *this; }

	/** Copies another pointer to this one. */
	WeakReference& operator= (ObjectType* const newObject)      { holder = getRef (newObject); return *this; }

   #if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
	WeakReference (WeakReference&& other) noexcept              : holder (static_cast <SharedRef&&> (other.holder)) {}
	WeakReference& operator= (WeakReference&& other) noexcept   { holder = static_cast <SharedRef&&> (other.holder); return *this; }
   #endif

	/** Returns the object that this pointer refers to, or null if the object no longer exists. */
	ObjectType* get() const noexcept                            { return holder != nullptr ? holder->get() : nullptr; }

	/** Returns the object that this pointer refers to, or null if the object no longer exists. */
	operator ObjectType*() const noexcept                       { return get(); }

	/** Returns the object that this pointer refers to, or null if the object no longer exists. */
	ObjectType* operator->() noexcept                           { return get(); }

	/** Returns the object that this pointer refers to, or null if the object no longer exists. */
	const ObjectType* operator->() const noexcept               { return get(); }

	/** This returns true if this reference has been pointing at an object, but that object has
		since been deleted.

		If this reference was only ever pointing at a null pointer, this will return false. Using
		operator=() to make this refer to a different object will reset this flag to match the status
		of the reference from which you're copying.
	*/
	bool wasObjectDeleted() const noexcept                      { return holder != nullptr && holder->get() == nullptr; }

	bool operator== (ObjectType* const object) const noexcept   { return get() == object; }
	bool operator!= (ObjectType* const object) const noexcept   { return get() != object; }

	/** This class is used internally by the WeakReference class - don't use it directly
		in your code!
		@see WeakReference
	*/
	class SharedPointer   : public ReferenceCountingType
	{
	public:
		explicit SharedPointer (ObjectType* const owner_) noexcept : owner (owner_) {}

		inline ObjectType* get() const noexcept     { return owner; }
		void clearPointer() noexcept                { owner = nullptr; }

	private:
		ObjectType* volatile owner;

		JUCE_DECLARE_NON_COPYABLE (SharedPointer);
	};

	typedef ReferenceCountedObjectPtr<SharedPointer> SharedRef;

	/**
		This class is embedded inside an object to which you want to attach WeakReference pointers.
		See the WeakReference class notes for an example of how to use this class.
		@see WeakReference
	*/
	class Master
	{
	public:
		Master() noexcept {}

		~Master()
		{
			// You must remember to call clear() in your source object's destructor! See the notes
			// for the WeakReference class for an example of how to do this.
			jassert (sharedPointer == nullptr || sharedPointer->get() == nullptr);
		}

		/** The first call to this method will create an internal object that is shared by all weak
			references to the object.
		*/
		SharedPointer* getSharedPointer (ObjectType* const object)
		{
			if (sharedPointer == nullptr)
			{
				sharedPointer = new SharedPointer (object);
			}
			else
			{
				// You're trying to create a weak reference to an object that has already been deleted!!
				jassert (sharedPointer->get() != nullptr);
			}

			return sharedPointer;
		}

		/** The object that owns this master pointer should call this before it gets destroyed,
			to zero all the references to this object that may be out there. See the WeakReference
			class notes for an example of how to do this.
		*/
		void clear()
		{
			if (sharedPointer != nullptr)
				sharedPointer->clearPointer();
		}

	private:
		SharedRef sharedPointer;

		JUCE_DECLARE_NON_COPYABLE (Master);
	};

private:
	SharedRef holder;

	static inline SharedPointer* getRef (ObjectType* const o)
	{
		return (o != nullptr) ? o->masterReference.getSharedPointer (o) : nullptr;
	}
};

#endif   // __JUCE_WEAKREFERENCE_JUCEHEADER__

/*** End of inlined file: juce_WeakReference.h ***/


#endif
#ifndef __JUCE_RESULT_JUCEHEADER__

#endif
#ifndef __JUCE_UUID_JUCEHEADER__

/*** Start of inlined file: juce_Uuid.h ***/
#ifndef __JUCE_UUID_JUCEHEADER__
#define __JUCE_UUID_JUCEHEADER__

/**
	A universally unique 128-bit identifier.

	This class generates very random unique numbers based on the system time
	and MAC addresses if any are available. It's extremely unlikely that two identical
	UUIDs would ever be created by chance.

	The class includes methods for saving the ID as a string or as raw binary data.
*/
class JUCE_API  Uuid
{
public:

	/** Creates a new unique ID. */
	Uuid();

	/** Destructor. */
	~Uuid() noexcept;

	/** Creates a copy of another UUID. */
	Uuid (const Uuid& other);

	/** Copies another UUID. */
	Uuid& operator= (const Uuid& other);

	/** Returns true if the ID is zero. */
	bool isNull() const noexcept;

	/** Compares two UUIDs. */
	bool operator== (const Uuid& other) const;

	/** Compares two UUIDs. */
	bool operator!= (const Uuid& other) const;

	/** Returns a stringified version of this UUID.

		A Uuid object can later be reconstructed from this string using operator= or
		the constructor that takes a string parameter.

		@returns a 32 character hex string.
	*/
	String toString() const;

	/** Creates an ID from an encoded string version.

		@see toString
	*/
	Uuid (const String& uuidString);

	/** Copies from a stringified UUID.

		The string passed in should be one that was created with the toString() method.
	*/
	Uuid& operator= (const String& uuidString);

	/** Returns a pointer to the internal binary representation of the ID.

		This is an array of 16 bytes. To reconstruct a Uuid from its data, use
		the constructor or operator= method that takes an array of uint8s.
	*/
	const uint8* getRawData() const noexcept                { return value.asBytes; }

	/** Creates a UUID from a 16-byte array.

		@see getRawData
	*/
	Uuid (const uint8* rawData);

	/** Sets this UUID from 16-bytes of raw data. */
	Uuid& operator= (const uint8* rawData);

private:

   #ifndef DOXYGEN
	union
	{
		uint8 asBytes [16];
		int asInt[4];
		int64 asInt64[2];

	} value;
   #endif

	JUCE_LEAK_DETECTOR (Uuid);
};

#endif   // __JUCE_UUID_JUCEHEADER__

/*** End of inlined file: juce_Uuid.h ***/


#endif
#ifndef __JUCE_WINDOWSREGISTRY_JUCEHEADER__

/*** Start of inlined file: juce_WindowsRegistry.h ***/
#ifndef __JUCE_WINDOWSREGISTRY_JUCEHEADER__
#define __JUCE_WINDOWSREGISTRY_JUCEHEADER__

#if JUCE_WINDOWS || DOXYGEN

/**
	Contains some static helper functions for manipulating the MS Windows registry
	(Only available on Windows, of course!)
*/
class WindowsRegistry
{
public:

	/** Returns a string from the registry.

		The path is a string for the entire path of a value in the registry,
		e.g. "HKEY_CURRENT_USER\Software\foo\bar"
	*/
	static String getValue (const String& regValuePath,
							const String& defaultValue = String::empty);

	/** Sets a registry value as a string.

		This will take care of creating any groups needed to get to the given
		registry value.
	*/
	static void setValue (const String& regValuePath,
						  const String& value);

	/** Returns true if the given value exists in the registry. */
	static bool valueExists (const String& regValuePath);

	/** Deletes a registry value. */
	static void deleteValue (const String& regValuePath);

	/** Deletes a registry key (which is registry-talk for 'folder'). */
	static void deleteKey (const String& regKeyPath);

	/** Creates a file association in the registry.

		This lets you set the executable that should be launched by a given file extension.
		@param fileExtension        the file extension to associate, including the
									initial dot, e.g. ".txt"
		@param symbolicDescription  a space-free short token to identify the file type
		@param fullDescription      a human-readable description of the file type
		@param targetExecutable     the executable that should be launched
		@param iconResourceNumber   the icon that gets displayed for the file type will be
									found by looking up this resource number in the
									executable. Pass 0 here to not use an icon
	*/
	static void registerFileAssociation (const String& fileExtension,
										 const String& symbolicDescription,
										 const String& fullDescription,
										 const File& targetExecutable,
										 int iconResourceNumber);

private:
	WindowsRegistry();
	JUCE_DECLARE_NON_COPYABLE (WindowsRegistry);
};

#endif
#endif   // __JUCE_WINDOWSREGISTRY_JUCEHEADER__

/*** End of inlined file: juce_WindowsRegistry.h ***/


#endif
#ifndef __JUCE_MACADDRESS_JUCEHEADER__

/*** Start of inlined file: juce_MACAddress.h ***/
#ifndef __JUCE_MACADDRESS_JUCEHEADER__
#define __JUCE_MACADDRESS_JUCEHEADER__

/**
	A wrapper for a streaming (TCP) socket.

	This allows low-level use of sockets; for an easier-to-use messaging layer on top of
	sockets, you could also try the InterprocessConnection class.

	@see DatagramSocket, InterprocessConnection, InterprocessConnectionServer
*/
class JUCE_API  MACAddress
{
public:

	/** Populates a list of the MAC addresses of all the available network cards. */
	static void findAllAddresses (Array<MACAddress>& results);

	/** Creates a null address (00-00-00-00-00-00). */
	MACAddress();

	/** Creates a copy of another address. */
	MACAddress (const MACAddress& other);

	/** Creates a copy of another address. */
	MACAddress& operator= (const MACAddress& other);

	/** Creates an address from 6 bytes. */
	explicit MACAddress (const uint8 bytes[6]);

	/** Returns a pointer to the 6 bytes that make up this address. */
	const uint8* getBytes() const noexcept        { return asBytes; }

	/** Returns a dash-separated string in the form "11-22-33-44-55-66" */
	String toString() const;

	/** Returns the address in the lower 6 bytes of an int64.

		This uses a little-endian arrangement, with the first byte of the address being
		stored in the least-significant byte of the result value.
	*/
	int64 toInt64() const noexcept;

	/** Returns true if this address is null (00-00-00-00-00-00). */
	bool isNull() const noexcept;

	bool operator== (const MACAddress& other) const noexcept;
	bool operator!= (const MACAddress& other) const noexcept;

private:
   #ifndef DOXYGEN
	union
	{
		uint64 asInt64;
		uint8 asBytes[6];
	};
   #endif
};

#endif   // __JUCE_MACADDRESS_JUCEHEADER__

/*** End of inlined file: juce_MACAddress.h ***/


#endif
#ifndef __JUCE_NAMEDPIPE_JUCEHEADER__

/*** Start of inlined file: juce_NamedPipe.h ***/
#ifndef __JUCE_NAMEDPIPE_JUCEHEADER__
#define __JUCE_NAMEDPIPE_JUCEHEADER__

/**
	A cross-process pipe that can have data written to and read from it.

	Two or more processes can use these for inter-process communication.

	@see InterprocessConnection
*/
class JUCE_API  NamedPipe
{
public:

	/** Creates a NamedPipe. */
	NamedPipe();

	/** Destructor. */
	~NamedPipe();

	/** Tries to open a pipe that already exists.

		Returns true if it succeeds.
	*/
	bool openExisting (const String& pipeName);

	/** Tries to create a new pipe.

		Returns true if it succeeds.
	*/
	bool createNewPipe (const String& pipeName);

	/** Closes the pipe, if it's open. */
	void close();

	/** True if the pipe is currently open. */
	bool isOpen() const;

	/** Returns the last name that was used to try to open this pipe. */
	String getName() const;

	/** Reads data from the pipe.

		This will block until another thread has written enough data into the pipe to fill
		the number of bytes specified, or until another thread calls the cancelPendingReads()
		method.

		If the operation fails, it returns -1, otherwise, it will return the number of
		bytes read.

		If timeOutMilliseconds is less than zero, it will wait indefinitely, otherwise
		this is a maximum timeout for reading from the pipe.
	*/
	int read (void* destBuffer, int maxBytesToRead, int timeOutMilliseconds = 5000);

	/** Writes some data to the pipe.

		If the operation fails, it returns -1, otherwise, it will return the number of
		bytes written.
	*/
	int write (const void* sourceBuffer, int numBytesToWrite,
			   int timeOutMilliseconds = 2000);

	/** If any threads are currently blocked on a read operation, this tells them to abort.
	*/
	void cancelPendingReads();

private:

	class Pimpl;
	ScopedPointer<Pimpl> pimpl;
	String currentPipeName;
	CriticalSection lock;

	bool openInternal (const String& pipeName, const bool createPipe);

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (NamedPipe);
};

#endif   // __JUCE_NAMEDPIPE_JUCEHEADER__

/*** End of inlined file: juce_NamedPipe.h ***/


#endif
#ifndef __JUCE_SOCKET_JUCEHEADER__

/*** Start of inlined file: juce_Socket.h ***/
#ifndef __JUCE_SOCKET_JUCEHEADER__
#define __JUCE_SOCKET_JUCEHEADER__

/**
	A wrapper for a streaming (TCP) socket.

	This allows low-level use of sockets; for an easier-to-use messaging layer on top of
	sockets, you could also try the InterprocessConnection class.

	@see DatagramSocket, InterprocessConnection, InterprocessConnectionServer
*/
class JUCE_API  StreamingSocket
{
public:

	/** Creates an uninitialised socket.

		To connect it, use the connect() method, after which you can read() or write()
		to it.

		To wait for other sockets to connect to this one, the createListener() method
		enters "listener" mode, and can be used to spawn new sockets for each connection
		that comes along.
	*/
	StreamingSocket();

	/** Destructor. */
	~StreamingSocket();

	/** Binds the socket to the specified local port.

		@returns    true on success; false may indicate that another socket is already bound
					on the same port
	*/
	bool bindToPort (int localPortNumber);

	/** Tries to connect the socket to hostname:port.

		If timeOutMillisecs is 0, then this method will block until the operating system
		rejects the connection (which could take a long time).

		@returns true if it succeeds.
		@see isConnected
	*/
	bool connect (const String& remoteHostname,
				  int remotePortNumber,
				  int timeOutMillisecs = 3000);

	/** True if the socket is currently connected. */
	bool isConnected() const noexcept                           { return connected; }

	/** Closes the connection. */
	void close();

	/** Returns the name of the currently connected host. */
	const String& getHostName() const noexcept                  { return hostName; }

	/** Returns the port number that's currently open. */
	int getPort() const noexcept                                { return portNumber; }

	/** True if the socket is connected to this machine rather than over the network. */
	bool isLocal() const noexcept;

	/** Waits until the socket is ready for reading or writing.

		If readyForReading is true, it will wait until the socket is ready for
		reading; if false, it will wait until it's ready for writing.

		If the timeout is < 0, it will wait forever, or else will give up after
		the specified time.

		If the socket is ready on return, this returns 1. If it times-out before
		the socket becomes ready, it returns 0. If an error occurs, it returns -1.
	*/
	int waitUntilReady (bool readyForReading,
						int timeoutMsecs) const;

	/** Reads bytes from the socket.

		If blockUntilSpecifiedAmountHasArrived is true, the method will block until
		maxBytesToRead bytes have been read, (or until an error occurs). If this
		flag is false, the method will return as much data as is currently available
		without blocking.

		@returns the number of bytes read, or -1 if there was an error.
		@see waitUntilReady
	*/
	int read (void* destBuffer, int maxBytesToRead,
			  bool blockUntilSpecifiedAmountHasArrived);

	/** Writes bytes to the socket from a buffer.

		Note that this method will block unless you have checked the socket is ready
		for writing before calling it (see the waitUntilReady() method).

		@returns the number of bytes written, or -1 if there was an error.
	*/
	int write (const void* sourceBuffer, int numBytesToWrite);

	/** Puts this socket into "listener" mode.

		When in this mode, your thread can call waitForNextConnection() repeatedly,
		which will spawn new sockets for each new connection, so that these can
		be handled in parallel by other threads.

		@param portNumber       the port number to listen on
		@param localHostName    the interface address to listen on - pass an empty
								string to listen on all addresses
		@returns    true if it manages to open the socket successfully.

		@see waitForNextConnection
	*/
	bool createListener (int portNumber, const String& localHostName = String::empty);

	/** When in "listener" mode, this waits for a connection and spawns it as a new
		socket.

		The object that gets returned will be owned by the caller.

		This method can only be called after using createListener().

		@see createListener
	*/
	StreamingSocket* waitForNextConnection() const;

private:

	String hostName;
	int volatile portNumber, handle;
	bool connected, isListener;

	StreamingSocket (const String& hostname, int portNumber, int handle);

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (StreamingSocket);
};

/**
	A wrapper for a datagram (UDP) socket.

	This allows low-level use of sockets; for an easier-to-use messaging layer on top of
	sockets, you could also try the InterprocessConnection class.

	@see StreamingSocket, InterprocessConnection, InterprocessConnectionServer
*/
class JUCE_API  DatagramSocket
{
public:

	/**
		Creates an (uninitialised) datagram socket.

		The localPortNumber is the port on which to bind this socket. If this value is 0,
		the port number is assigned by the operating system.

		To use the socket for sending, call the connect() method. This will not immediately
		make a connection, but will save the destination you've provided. After this, you can
		call read() or write().

		If enableBroadcasting is true, the socket will be allowed to send broadcast messages
		(may require extra privileges on linux)

		To wait for other sockets to connect to this one, call waitForNextConnection().
	*/
	DatagramSocket (int localPortNumber,
					bool enableBroadcasting = false);

	/** Destructor. */
	~DatagramSocket();

	/** Binds the socket to the specified local port.

		@returns    true on success; false may indicate that another socket is already bound
					on the same port
	*/
	bool bindToPort (int localPortNumber);

	/** Tries to connect the socket to hostname:port.

		If timeOutMillisecs is 0, then this method will block until the operating system
		rejects the connection (which could take a long time).

		@returns true if it succeeds.
		@see isConnected
	*/
	bool connect (const String& remoteHostname,
				  int remotePortNumber,
				  int timeOutMillisecs = 3000);

	/** True if the socket is currently connected. */
	bool isConnected() const noexcept                           { return connected; }

	/** Closes the connection. */
	void close();

	/** Returns the name of the currently connected host. */
	const String& getHostName() const noexcept                  { return hostName; }

	/** Returns the port number that's currently open. */
	int getPort() const noexcept                                { return portNumber; }

	/** True if the socket is connected to this machine rather than over the network. */
	bool isLocal() const noexcept;

	/** Waits until the socket is ready for reading or writing.

		If readyForReading is true, it will wait until the socket is ready for
		reading; if false, it will wait until it's ready for writing.

		If the timeout is < 0, it will wait forever, or else will give up after
		the specified time.

		If the socket is ready on return, this returns 1. If it times-out before
		the socket becomes ready, it returns 0. If an error occurs, it returns -1.
	*/
	int waitUntilReady (bool readyForReading,
						int timeoutMsecs) const;

	/** Reads bytes from the socket.

		If blockUntilSpecifiedAmountHasArrived is true, the method will block until
		maxBytesToRead bytes have been read, (or until an error occurs). If this
		flag is false, the method will return as much data as is currently available
		without blocking.

		@returns the number of bytes read, or -1 if there was an error.
		@see waitUntilReady
	*/
	int read (void* destBuffer, int maxBytesToRead,
			  bool blockUntilSpecifiedAmountHasArrived);

	/** Writes bytes to the socket from a buffer.

		Note that this method will block unless you have checked the socket is ready
		for writing before calling it (see the waitUntilReady() method).

		@returns the number of bytes written, or -1 if there was an error.
	*/
	int write (const void* sourceBuffer, int numBytesToWrite);

	/** This waits for incoming data to be sent, and returns a socket that can be used
		to read it.

		The object that gets returned is owned by the caller, and can't be used for
		sending, but can be used to read the data.
	*/
	DatagramSocket* waitForNextConnection() const;

private:

	String hostName;
	int volatile portNumber, handle;
	bool connected, allowBroadcast;
	void* serverAddress;

	DatagramSocket (const String& hostname, int portNumber, int handle, int localPortNumber);

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (DatagramSocket);
};

#endif   // __JUCE_SOCKET_JUCEHEADER__

/*** End of inlined file: juce_Socket.h ***/


#endif
#ifndef __JUCE_URL_JUCEHEADER__

/*** Start of inlined file: juce_URL.h ***/
#ifndef __JUCE_URL_JUCEHEADER__
#define __JUCE_URL_JUCEHEADER__

class InputStream;
class XmlElement;

/**
	Represents a URL and has a bunch of useful functions to manipulate it.

	This class can be used to launch URLs in browsers, and also to create
	InputStreams that can read from remote http or ftp sources.
*/
class JUCE_API  URL
{
public:

	/** Creates an empty URL. */
	URL();

	/** Creates a URL from a string. */
	URL (const String& url);

	/** Creates a copy of another URL. */
	URL (const URL& other);

	/** Destructor. */
	~URL();

	/** Copies this URL from another one. */
	URL& operator= (const URL& other);

	/** Compares two URLs.
		All aspects of the URLs must be identical for them to match, including any parameters,
		upload files, etc.
	*/
	bool operator== (const URL&) const;
	bool operator!= (const URL&) const;

	/** Returns a string version of the URL.

		If includeGetParameters is true and any parameters have been set with the
		withParameter() method, then the string will have these appended on the
		end and url-encoded.
	*/
	String toString (bool includeGetParameters) const;

	/** True if it seems to be valid. */
	bool isWellFormed() const;

	/** Returns just the domain part of the URL.

		E.g. for "http://www.xyz.com/foobar", this will return "www.xyz.com".
	*/
	String getDomain() const;

	/** Returns the path part of the URL.

		E.g. for "http://www.xyz.com/foo/bar?x=1", this will return "foo/bar".
	*/
	String getSubPath() const;

	/** Returns the scheme of the URL.

		E.g. for "http://www.xyz.com/foobar", this will return "http". (It won't
		include the colon).
	*/
	String getScheme() const;

	/** Attempts to read a port number from the URL.
		@returns the port number, or 0 if none is explicitly specified.
	*/
	int getPort() const;

	/** Returns a new version of this URL that uses a different sub-path.

		E.g. if the URL is "http://www.xyz.com/foo?x=1" and you call this with
		"bar", it'll return "http://www.xyz.com/bar?x=1".
	*/
	URL withNewSubPath (const String& newPath) const;

	/** Returns a new URL that refers to a sub-path relative to this one.

		E.g. if the URL is "http://www.xyz.com/foo" and you call this with
		"bar", it'll return "http://www.xyz.com/foo/bar". Note that there's no way for
		this method to know whether the original URL is a file or directory, so it's
		up to you to make sure it's a directory. It also won't attempt to be smart about
		the content of the childPath string, so if this string is an absolute URL, it'll
		still just get bolted onto the end of the path.

		@see File::getChildFile
	*/
	URL getChildURL (const String& subPath) const;

	/** Returns a copy of this URL, with a GET or POST parameter added to the end.

		Any control characters in the value will be encoded.

		e.g. calling "withParameter ("amount", "some fish") for the url "www.fish.com"
		would produce a new url whose toString(true) method would return
		"www.fish.com?amount=some+fish".

		@see getParameterNames, getParameterValues
	*/
	URL withParameter (const String& parameterName,
					   const String& parameterValue) const;

	/** Returns a copy of this URl, with a file-upload type parameter added to it.

		When performing a POST where one of your parameters is a binary file, this
		lets you specify the file.

		Note that the filename is stored, but the file itself won't actually be read
		until this URL is later used to create a network input stream.
	*/
	URL withFileToUpload (const String& parameterName,
						  const File& fileToUpload,
						  const String& mimeType) const;

	/** Returns an array of the names of all the URL's parameters.

		E.g. for the url "www.fish.com?type=haddock&amount=some+fish", this array would
		contain two items: "type" and "haddock".

		You can call getParameterValues() to get the corresponding value of each
		parameter. Note that the list can contain multiple parameters with the same name.

		@see getParameterValues, withParameter
	*/
	const StringArray& getParameterNames() const noexcept       { return parameterNames; }

	/** Returns an array of the values of all the URL's parameters.

		E.g. for the url "www.fish.com?type=haddock&amount=some+fish", this array would
		contain two items: "haddock" and "some fish".

		The values returned will have been cleaned up to remove any escape characters.

		You can call getParameterNames() to get the corresponding name of each
		parameter. Note that the list can contain multiple parameters with the same name.

		@see getParameterNames, withParameter
	*/
	const StringArray& getParameterValues() const noexcept      { return parameterValues; }

	/** Returns the set of files that should be uploaded as part of a POST operation.

		This is the set of files that were added to the URL with the withFileToUpload()
		method.
	*/
	const StringPairArray& getFilesToUpload() const;

	/** Returns the set of mime types associated with each of the upload files.
	*/
	const StringPairArray& getMimeTypesOfUploadFiles() const;

	/** Returns a copy of this URL, with a block of data to send as the POST data.

		If you're setting the POST data, be careful not to have any parameters set
		as well, otherwise it'll all get thrown in together, and might not have the
		desired effect.

		If the URL already contains some POST data, this will replace it, rather
		than being appended to it.

		This data will only be used if you specify a post operation when you call
		createInputStream().
	*/
	URL withPOSTData (const String& postData) const;

	/** Returns the data that was set using withPOSTData(). */
	const String& getPostData() const noexcept                  { return postData; }

	/** Tries to launch the system's default browser to open the URL.

		Returns true if this seems to have worked.
	*/
	bool launchInDefaultBrowser() const;

	/** Takes a guess as to whether a string might be a valid website address.

		This isn't foolproof!
	*/
	static bool isProbablyAWebsiteURL (const String& possibleURL);

	/** Takes a guess as to whether a string might be a valid email address.

		This isn't foolproof!
	*/
	static bool isProbablyAnEmailAddress (const String& possibleEmailAddress);

	/** This callback function can be used by the createInputStream() method.

		It allows your app to receive progress updates during a lengthy POST operation. If you
		want to continue the operation, this should return true, or false to abort.
	*/
	typedef bool (OpenStreamProgressCallback) (void* context, int bytesSent, int totalBytes);

	/** Attempts to open a stream that can read from this URL.

		@param usePostCommand   if true, it will try to do use a http 'POST' to pass
								the paramters, otherwise it'll encode them into the
								URL and do a 'GET'.
		@param progressCallback if this is non-zero, it lets you supply a callback function
								to keep track of the operation's progress. This can be useful
								for lengthy POST operations, so that you can provide user feedback.
		@param progressCallbackContext  if a callback is specified, this value will be passed to
								the function
		@param extraHeaders     if not empty, this string is appended onto the headers that
								are used for the request. It must therefore be a valid set of HTML
								header directives, separated by newlines.
		@param connectionTimeOutMs  if 0, this will use whatever default setting the OS chooses. If
								a negative number, it will be infinite. Otherwise it specifies a
								time in milliseconds.
		@param responseHeaders  if this is non-zero, all the (key, value) pairs received as headers
								in the response will be stored in this array
		@returns    an input stream that the caller must delete, or a null pointer if there was an
					error trying to open it.
	 */
	InputStream* createInputStream (bool usePostCommand,
									OpenStreamProgressCallback* progressCallback = nullptr,
									void* progressCallbackContext = nullptr,
									const String& extraHeaders = String::empty,
									int connectionTimeOutMs = 0,
									StringPairArray* responseHeaders = nullptr) const;

	/** Tries to download the entire contents of this URL into a binary data block.

		If it succeeds, this will return true and append the data it read onto the end
		of the memory block.

		@param destData         the memory block to append the new data to
		@param usePostCommand   whether to use a POST command to get the data (uses
								a GET command if this is false)
		@see readEntireTextStream, readEntireXmlStream
	*/
	bool readEntireBinaryStream (MemoryBlock& destData,
								 bool usePostCommand = false) const;

	/** Tries to download the entire contents of this URL as a string.

		If it fails, this will return an empty string, otherwise it will return the
		contents of the downloaded file. If you need to distinguish between a read
		operation that fails and one that returns an empty string, you'll need to use
		a different method, such as readEntireBinaryStream().

		@param usePostCommand   whether to use a POST command to get the data (uses
								a GET command if this is false)
		@see readEntireBinaryStream, readEntireXmlStream
	*/
	String readEntireTextStream (bool usePostCommand = false) const;

	/** Tries to download the entire contents of this URL and parse it as XML.

		If it fails, or if the text that it reads can't be parsed as XML, this will
		return 0.

		When it returns a valid XmlElement object, the caller is responsibile for deleting
		this object when no longer needed.

		@param usePostCommand   whether to use a POST command to get the data (uses
								a GET command if this is false)

		@see readEntireBinaryStream, readEntireTextStream
	*/
	XmlElement* readEntireXmlStream (bool usePostCommand = false) const;

	/** Adds escape sequences to a string to encode any characters that aren't
		legal in a URL.

		E.g. any spaces will be replaced with "%20".

		This is the opposite of removeEscapeChars().

		If isParameter is true, it means that the string is going to be used
		as a parameter, so it also encodes '$' and ',' (which would otherwise
		be legal in a URL.

		@see removeEscapeChars
	*/
	static String addEscapeChars (const String& stringToAddEscapeCharsTo,
								  bool isParameter);

	/** Replaces any escape character sequences in a string with their original
		character codes.

		E.g. any instances of "%20" will be replaced by a space.

		This is the opposite of addEscapeChars().

		@see addEscapeChars
	*/
	static String removeEscapeChars (const String& stringToRemoveEscapeCharsFrom);

private:

	String url, postData;
	StringArray parameterNames, parameterValues;
	StringPairArray filesToUpload, mimeTypes;

	void addParameter (const String&, const String&);

	static InputStream* createNativeStream (const String& address, bool isPost, const MemoryBlock& postData,
											OpenStreamProgressCallback* progressCallback,
											void* progressCallbackContext, const String& headers,
											const int timeOutMs, StringPairArray* responseHeaders);
	JUCE_LEAK_DETECTOR (URL);
};

#endif   // __JUCE_URL_JUCEHEADER__

/*** End of inlined file: juce_URL.h ***/


#endif
#ifndef __JUCE_BUFFEREDINPUTSTREAM_JUCEHEADER__

/*** Start of inlined file: juce_BufferedInputStream.h ***/
#ifndef __JUCE_BUFFEREDINPUTSTREAM_JUCEHEADER__
#define __JUCE_BUFFEREDINPUTSTREAM_JUCEHEADER__

/** Wraps another input stream, and reads from it using an intermediate buffer

	If you're using an input stream such as a file input stream, and making lots of
	small read accesses to it, it's probably sensible to wrap it in one of these,
	so that the source stream gets accessed in larger chunk sizes, meaning less
	work for the underlying stream.
*/
class JUCE_API  BufferedInputStream  : public InputStream
{
public:

	/** Creates a BufferedInputStream from an input source.

		@param sourceStream                 the source stream to read from
		@param bufferSize                   the size of reservoir to use to buffer the source
		@param deleteSourceWhenDestroyed    whether the sourceStream that is passed in should be
											deleted by this object when it is itself deleted.
	*/
	BufferedInputStream (InputStream* sourceStream,
						 int bufferSize,
						 bool deleteSourceWhenDestroyed);

	/** Creates a BufferedInputStream from an input source.

		@param sourceStream     the source stream to read from - the source stream  must not
								be deleted until this object has been destroyed.
		@param bufferSize       the size of reservoir to use to buffer the source
	*/
	BufferedInputStream (InputStream& sourceStream, int bufferSize);

	/** Destructor.

		This may also delete the source stream, if that option was chosen when the
		buffered stream was created.
	*/
	~BufferedInputStream();

	int64 getTotalLength();
	int64 getPosition();
	bool setPosition (int64 newPosition);
	int read (void* destBuffer, int maxBytesToRead);
	String readString();
	bool isExhausted();

private:

	OptionalScopedPointer<InputStream> source;
	int bufferSize;
	int64 position, lastReadPos, bufferStart, bufferOverlap;
	HeapBlock <char> buffer;
	void ensureBuffered();

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (BufferedInputStream);
};

#endif   // __JUCE_BUFFEREDINPUTSTREAM_JUCEHEADER__

/*** End of inlined file: juce_BufferedInputStream.h ***/


#endif
#ifndef __JUCE_FILEINPUTSOURCE_JUCEHEADER__

/*** Start of inlined file: juce_FileInputSource.h ***/
#ifndef __JUCE_FILEINPUTSOURCE_JUCEHEADER__
#define __JUCE_FILEINPUTSOURCE_JUCEHEADER__


/*** Start of inlined file: juce_InputSource.h ***/
#ifndef __JUCE_INPUTSOURCE_JUCEHEADER__
#define __JUCE_INPUTSOURCE_JUCEHEADER__

/**
	A lightweight object that can create a stream to read some kind of resource.

	This may be used to refer to a file, or some other kind of source, allowing a
	caller to create an input stream that can read from it when required.

	@see FileInputSource
*/
class JUCE_API  InputSource
{
public:

	InputSource() noexcept      {}

	/** Destructor. */
	virtual ~InputSource()      {}

	/** Returns a new InputStream to read this item.

		@returns            an inputstream that the caller will delete, or 0 if
							the filename isn't found.
	*/
	virtual InputStream* createInputStream() = 0;

	/** Returns a new InputStream to read an item, relative.

		@param relatedItemPath  the relative pathname of the resource that is required
		@returns            an inputstream that the caller will delete, or 0 if
							the item isn't found.
	*/
	virtual InputStream* createInputStreamFor (const String& relatedItemPath) = 0;

	/** Returns a hash code that uniquely represents this item.
	*/
	virtual int64 hashCode() const = 0;

private:

	JUCE_LEAK_DETECTOR (InputSource);
};

#endif   // __JUCE_INPUTSOURCE_JUCEHEADER__

/*** End of inlined file: juce_InputSource.h ***/

/**
	A type of InputSource that represents a normal file.

	@see InputSource
*/
class JUCE_API  FileInputSource     : public InputSource
{
public:

	FileInputSource (const File& file, bool useFileTimeInHashGeneration = false);
	~FileInputSource();

	InputStream* createInputStream();
	InputStream* createInputStreamFor (const String& relatedItemPath);
	int64 hashCode() const;

private:

	const File file;
	bool useFileTimeInHashGeneration;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (FileInputSource);
};

#endif   // __JUCE_FILEINPUTSOURCE_JUCEHEADER__

/*** End of inlined file: juce_FileInputSource.h ***/


#endif
#ifndef __JUCE_INPUTSOURCE_JUCEHEADER__

#endif
#ifndef __JUCE_INPUTSTREAM_JUCEHEADER__

#endif
#ifndef __JUCE_MEMORYINPUTSTREAM_JUCEHEADER__

/*** Start of inlined file: juce_MemoryInputStream.h ***/
#ifndef __JUCE_MEMORYINPUTSTREAM_JUCEHEADER__
#define __JUCE_MEMORYINPUTSTREAM_JUCEHEADER__

/**
	Allows a block of data and to be accessed as a stream.

	This can either be used to refer to a shared block of memory, or can make its
	own internal copy of the data when the MemoryInputStream is created.
*/
class JUCE_API  MemoryInputStream  : public InputStream
{
public:

	/** Creates a MemoryInputStream.

		@param sourceData               the block of data to use as the stream's source
		@param sourceDataSize           the number of bytes in the source data block
		@param keepInternalCopyOfData   if false, the stream will just keep a pointer to
										the source data, so this data shouldn't be changed
										for the lifetime of the stream; if this parameter is
										true, the stream will make its own copy of the
										data and use that.
	*/
	MemoryInputStream (const void* sourceData,
					   size_t sourceDataSize,
					   bool keepInternalCopyOfData);

	/** Creates a MemoryInputStream.

		@param data                     a block of data to use as the stream's source
		@param keepInternalCopyOfData   if false, the stream will just keep a reference to
										the source data, so this data shouldn't be changed
										for the lifetime of the stream; if this parameter is
										true, the stream will make its own copy of the
										data and use that.
	*/
	MemoryInputStream (const MemoryBlock& data,
					   bool keepInternalCopyOfData);

	/** Destructor. */
	~MemoryInputStream();

	int64 getPosition();
	bool setPosition (int64 pos);
	int64 getTotalLength();
	bool isExhausted();
	int read (void* destBuffer, int maxBytesToRead);

private:

	const char* data;
	size_t dataSize, position;
	HeapBlock<char> internalCopy;

	void createInternalCopy();

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (MemoryInputStream);
};

#endif   // __JUCE_MEMORYINPUTSTREAM_JUCEHEADER__

/*** End of inlined file: juce_MemoryInputStream.h ***/


#endif
#ifndef __JUCE_MEMORYOUTPUTSTREAM_JUCEHEADER__

/*** Start of inlined file: juce_MemoryOutputStream.h ***/
#ifndef __JUCE_MEMORYOUTPUTSTREAM_JUCEHEADER__
#define __JUCE_MEMORYOUTPUTSTREAM_JUCEHEADER__

/**
	Writes data to an internal memory buffer, which grows as required.

	The data that was written into the stream can then be accessed later as
	a contiguous block of memory.
*/
class JUCE_API  MemoryOutputStream  : public OutputStream
{
public:

	/** Creates an empty memory stream ready for writing into.

		@param initialSize  the intial amount of capacity to allocate for writing into
	*/
	MemoryOutputStream (size_t initialSize = 256);

	/** Creates a memory stream for writing into into a pre-existing MemoryBlock object.

		Note that the destination block will always be larger than the amount of data
		that has been written to the stream, because the MemoryOutputStream keeps some
		spare capactity at its end. To trim the block's size down to fit the actual
		data, call flush(), or delete the MemoryOutputStream.

		@param memoryBlockToWriteTo             the block into which new data will be written.
		@param appendToExistingBlockContent     if this is true, the contents of the block will be
												kept, and new data will be appended to it. If false,
												the block will be cleared before use
	*/
	MemoryOutputStream (MemoryBlock& memoryBlockToWriteTo,
						bool appendToExistingBlockContent);

	/** Destructor.
		This will free any data that was written to it.
	*/
	~MemoryOutputStream();

	/** Returns a pointer to the data that has been written to the stream.

		@see getDataSize
	*/
	const void* getData() const noexcept;

	/** Returns the number of bytes of data that have been written to the stream.

		@see getData
	*/
	size_t getDataSize() const noexcept                 { return size; }

	/** Resets the stream, clearing any data that has been written to it so far. */
	void reset() noexcept;

	/** Increases the internal storage capacity to be able to contain at least the specified
		amount of data without needing to be resized.
	*/
	void preallocate (size_t bytesToPreallocate);

	/** Returns a String created from the (UTF8) data that has been written to the stream. */
	String toUTF8() const;

	/** Attempts to detect the encoding of the data and convert it to a string.
		@see String::createStringFromData
	*/
	String toString() const;

	/** Returns a copy of the stream's data as a memory block. */
	MemoryBlock getMemoryBlock() const;

	/** If the stream is writing to a user-supplied MemoryBlock, this will trim any excess
		capacity off the block, so that its length matches the amount of actual data that
		has been written so far.
	*/
	void flush();

	bool write (const void* buffer, int howMany);
	int64 getPosition()                                 { return position; }
	bool setPosition (int64 newPosition);
	int writeFromInputStream (InputStream& source, int64 maxNumBytesToWrite);
	void writeRepeatedByte (uint8 byte, int numTimesToRepeat);

private:

	MemoryBlock& data;
	MemoryBlock internalBlock;
	size_t position, size;

	void trimExternalBlockSize();
	void prepareToWrite (int numBytes);

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (MemoryOutputStream);
};

/** Copies all the data that has been written to a MemoryOutputStream into another stream. */
OutputStream& JUCE_CALLTYPE operator<< (OutputStream& stream, const MemoryOutputStream& streamToRead);

#endif   // __JUCE_MEMORYOUTPUTSTREAM_JUCEHEADER__

/*** End of inlined file: juce_MemoryOutputStream.h ***/


#endif
#ifndef __JUCE_OUTPUTSTREAM_JUCEHEADER__

#endif
#ifndef __JUCE_SUBREGIONSTREAM_JUCEHEADER__

/*** Start of inlined file: juce_SubregionStream.h ***/
#ifndef __JUCE_SUBREGIONSTREAM_JUCEHEADER__
#define __JUCE_SUBREGIONSTREAM_JUCEHEADER__

/** Wraps another input stream, and reads from a specific part of it.

	This lets you take a subsection of a stream and present it as an entire
	stream in its own right.
*/
class JUCE_API  SubregionStream  : public InputStream
{
public:

	/** Creates a SubregionStream from an input source.

		@param sourceStream                 the source stream to read from
		@param startPositionInSourceStream  this is the position in the source stream that
											corresponds to position 0 in this stream
		@param lengthOfSourceStream         this specifies the maximum number of bytes
											from the source stream that will be passed through
											by this stream. When the position of this stream
											exceeds lengthOfSourceStream, it will cause an end-of-stream.
											If the length passed in here is greater than the length
											of the source stream (as returned by getTotalLength()),
											then the smaller value will be used.
											Passing a negative value for this parameter means it
											will keep reading until the source's end-of-stream.
		@param deleteSourceWhenDestroyed    whether the sourceStream that is passed in should be
											deleted by this object when it is itself deleted.
	*/
	SubregionStream (InputStream* sourceStream,
					 int64 startPositionInSourceStream,
					 int64 lengthOfSourceStream,
					 bool deleteSourceWhenDestroyed);

	/** Destructor.

		This may also delete the source stream, if that option was chosen when the
		buffered stream was created.
	*/
	~SubregionStream();

	int64 getTotalLength();
	int64 getPosition();
	bool setPosition (int64 newPosition);
	int read (void* destBuffer, int maxBytesToRead);
	bool isExhausted();

private:
	OptionalScopedPointer<InputStream> source;
	const int64 startPositionInSourceStream, lengthOfSourceStream;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (SubregionStream);
};

#endif   // __JUCE_SUBREGIONSTREAM_JUCEHEADER__

/*** End of inlined file: juce_SubregionStream.h ***/


#endif
#ifndef __JUCE_PLATFORMDEFS_JUCEHEADER__

#endif
#ifndef __JUCE_STANDARDHEADER_JUCEHEADER__

#endif
#ifndef __JUCE_SYSTEMSTATS_JUCEHEADER__

/*** Start of inlined file: juce_SystemStats.h ***/
#ifndef __JUCE_SYSTEMSTATS_JUCEHEADER__
#define __JUCE_SYSTEMSTATS_JUCEHEADER__

/**
	Contains methods for finding out about the current hardware and OS configuration.
*/
class JUCE_API  SystemStats
{
public:

	/** Returns the current version of JUCE,

		See also the JUCE_VERSION, JUCE_MAJOR_VERSION and JUCE_MINOR_VERSION macros.
	*/
	static String getJUCEVersion();

	/** The set of possible results of the getOperatingSystemType() method.
	*/
	enum OperatingSystemType
	{
		UnknownOS   = 0,

		MacOSX      = 0x1000,
		Linux       = 0x2000,
		Android     = 0x3000,

		Win95       = 0x4001,
		Win98       = 0x4002,
		WinNT351    = 0x4103,
		WinNT40     = 0x4104,
		Win2000     = 0x4105,
		WinXP       = 0x4106,
		WinVista    = 0x4107,
		Windows7    = 0x4108,

		Windows     = 0x4000,   /**< To test whether any version of Windows is running,
									 you can use the expression ((getOperatingSystemType() & Windows) != 0). */
		WindowsNT   = 0x0100,   /**< To test whether the platform is Windows NT or later (i.e. not Win95 or 98),
									 you can use the expression ((getOperatingSystemType() & WindowsNT) != 0). */
	};

	/** Returns the type of operating system we're running on.

		@returns one of the values from the OperatingSystemType enum.
		@see getOperatingSystemName
	*/
	static OperatingSystemType getOperatingSystemType();

	/** Returns the name of the type of operating system we're running on.

		@returns a string describing the OS type.
		@see getOperatingSystemType
	*/
	static String getOperatingSystemName();

	/** Returns true if the OS is 64-bit, or false for a 32-bit OS.
	*/
	static bool isOperatingSystem64Bit();

   #if JUCE_MAC || DOXYGEN
	/** OSX ONLY - Returns the current OS version number.
		E.g. if it's running on 10.4, this will be 4, 10.5 will return 5, etc.
	*/
	static int getOSXMinorVersionNumber();
   #endif

	/** Returns the current user's name, if available.
		@see getFullUserName()
	*/
	static String getLogonName();

	/** Returns the current user's full name, if available.
		On some OSes, this may just return the same value as getLogonName().
		@see getLogonName()
	*/
	static String getFullUserName();

	/** Returns the host-name of the computer. */
	static String getComputerName();

	// CPU and memory information..

	/** Returns the approximate CPU speed.

		@returns    the speed in megahertz, e.g. 1500, 2500, 32000 (depending on
					what year you're reading this...)
	*/
	static int getCpuSpeedInMegaherz();

	/** Returns a string to indicate the CPU vendor.

		Might not be known on some systems.
	*/
	static String getCpuVendor();

	/** Checks whether Intel MMX instructions are available. */
	static bool hasMMX() noexcept               { return getCPUFlags().hasMMX; }

	/** Checks whether Intel SSE instructions are available. */
	static bool hasSSE() noexcept               { return getCPUFlags().hasSSE; }

	/** Checks whether Intel SSE2 instructions are available. */
	static bool hasSSE2() noexcept              { return getCPUFlags().hasSSE2; }

	/** Checks whether AMD 3DNOW instructions are available. */
	static bool has3DNow() noexcept             { return getCPUFlags().has3DNow; }

	/** Returns the number of CPUs. */
	static int getNumCpus() noexcept            { return getCPUFlags().numCpus; }

	/** Finds out how much RAM is in the machine.

		@returns    the approximate number of megabytes of memory, or zero if
					something goes wrong when finding out.
	*/
	static int getMemorySizeInMegabytes();

	/** Returns the system page-size.

		This is only used by programmers with beards.
	*/
	static int getPageSize();

private:

	struct CPUFlags
	{
		CPUFlags();

		int numCpus;
		bool hasMMX : 1;
		bool hasSSE : 1;
		bool hasSSE2 : 1;
		bool has3DNow : 1;
	};

	SystemStats();
	static const CPUFlags& getCPUFlags();

	JUCE_DECLARE_NON_COPYABLE (SystemStats);
};

#endif   // __JUCE_SYSTEMSTATS_JUCEHEADER__

/*** End of inlined file: juce_SystemStats.h ***/


#endif
#ifndef __JUCE_TARGETPLATFORM_JUCEHEADER__

#endif
#ifndef __JUCE_CHARACTERFUNCTIONS_JUCEHEADER__

#endif
#ifndef __JUCE_CHARPOINTER_ASCII_JUCEHEADER__

#endif
#ifndef __JUCE_CHARPOINTER_UTF16_JUCEHEADER__

#endif
#ifndef __JUCE_CHARPOINTER_UTF32_JUCEHEADER__

#endif
#ifndef __JUCE_CHARPOINTER_UTF8_JUCEHEADER__

#endif
#ifndef __JUCE_IDENTIFIER_JUCEHEADER__

#endif
#ifndef __JUCE_LOCALISEDSTRINGS_JUCEHEADER__

/*** Start of inlined file: juce_LocalisedStrings.h ***/
#ifndef __JUCE_LOCALISEDSTRINGS_JUCEHEADER__
#define __JUCE_LOCALISEDSTRINGS_JUCEHEADER__

/**
	Used to convert strings to localised foreign-language versions.

	This is basically a look-up table of strings and their translated equivalents.
	It can be loaded from a text file, so that you can supply a set of localised
	versions of strings that you use in your app.

	To use it in your code, simply call the translate() method on each string that
	might have foreign versions, and if none is found, the method will just return
	the original string.

	The translation file should start with some lines specifying a description of
	the language it contains, and also a list of ISO country codes where it might
	be appropriate to use the file. After that, each line of the file should contain
	a pair of quoted strings with an '=' sign.

	E.g. for a french translation, the file might be:

	@code
	language: French
	countries: fr be mc ch lu

	"hello" = "bonjour"
	"goodbye" = "au revoir"
	@endcode

	If the strings need to contain a quote character, they can use '\"' instead, and
	if the first non-whitespace character on a line isn't a quote, then it's ignored,
	(you can use this to add comments).

	Note that this is a singleton class, so don't create or destroy the object directly.
	There's also a TRANS(text) macro defined to make it easy to use the this.

	E.g. @code
	printSomething (TRANS("hello"));
	@endcode

	This macro is used in the Juce classes themselves, so your application has a chance to
	intercept and translate any internal Juce text strings that might be shown. (You can easily
	get a list of all the messages by searching for the TRANS() macro in the Juce source
	code).
*/
class JUCE_API  LocalisedStrings
{
public:

	/** Creates a set of translations from the text of a translation file.

		When you create one of these, you can call setCurrentMappings() to make it
		the set of mappings that the system's using.
	*/
	LocalisedStrings (const String& fileContents);

	/** Creates a set of translations from a file.

		When you create one of these, you can call setCurrentMappings() to make it
		the set of mappings that the system's using.
	*/
	LocalisedStrings (const File& fileToLoad);

	/** Destructor. */
	~LocalisedStrings();

	/** Selects the current set of mappings to be used by the system.

		The object you pass in will be automatically deleted when no longer needed, so
		don't keep a pointer to it. You can also pass in zero to remove the current
		mappings.

		See also the TRANS() macro, which uses the current set to do its translation.

		@see translateWithCurrentMappings
	*/
	static void setCurrentMappings (LocalisedStrings* newTranslations);

	/** Returns the currently selected set of mappings.

		This is the object that was last passed to setCurrentMappings(). It may
		be 0 if none has been created.
	*/
	static LocalisedStrings* getCurrentMappings();

	/** Tries to translate a string using the currently selected set of mappings.

		If no mapping has been set, or if the mapping doesn't contain a translation
		for the string, this will just return the original string.

		See also the TRANS() macro, which uses this method to do its translation.

		@see setCurrentMappings, getCurrentMappings
	*/
	static String translateWithCurrentMappings (const String& text);

	/** Tries to translate a string using the currently selected set of mappings.

		If no mapping has been set, or if the mapping doesn't contain a translation
		for the string, this will just return the original string.

		See also the TRANS() macro, which uses this method to do its translation.

		@see setCurrentMappings, getCurrentMappings
	*/
	static String translateWithCurrentMappings (const char* text);

	/** Attempts to look up a string and return its localised version.
		If the string isn't found in the list, the original string will be returned.
	*/
	String translate (const String& text) const;

	/** Attempts to look up a string and return its localised version.
		If the string isn't found in the list, the resultIfNotFound string will be returned.
	*/
	String translate (const String& text, const String& resultIfNotFound) const;

	/** Returns the name of the language specified in the translation file.

		This is specified in the file using a line starting with "language:", e.g.
		@code
		language: german
		@endcode
	*/
	String getLanguageName() const                        { return languageName; }

	/** Returns the list of suitable country codes listed in the translation file.

		These is specified in the file using a line starting with "countries:", e.g.
		@code
		countries: fr be mc ch lu
		@endcode

		The country codes are supposed to be 2-character ISO complient codes.
	*/
	const StringArray& getCountryCodes() const            { return countryCodes; }

	/** Indicates whether to use a case-insensitive search when looking up a string.
		This defaults to true.
	*/
	void setIgnoresCase (bool shouldIgnoreCase);

private:

	String languageName;
	StringArray countryCodes;
	StringPairArray translations;

	void loadFromText (const String& fileContents);

	JUCE_LEAK_DETECTOR (LocalisedStrings);
};

#ifndef TRANS
 /** Uses the LocalisedStrings class to translate the given string literal.
	 This macro is provided for backwards-compatibility, and just calls the translate()
	 function. In new code, it's recommended that you just call translate() directly
	 instead, and avoid using macros.
	 @see translate(), LocalisedStrings
 */
 #define TRANS(stringLiteral) juce::translate (stringLiteral)
#endif

/** Uses the LocalisedStrings class to translate the given string literal.
	@see LocalisedStrings
*/
String translate (const String& stringLiteral);

/** Uses the LocalisedStrings class to translate the given string literal.
	@see LocalisedStrings
*/
String translate (const char* stringLiteral);

/** Uses the LocalisedStrings class to translate the given string literal.
	@see LocalisedStrings
*/
String translate (const String& stringLiteral, const String& resultIfNotFound);

#endif   // __JUCE_LOCALISEDSTRINGS_JUCEHEADER__

/*** End of inlined file: juce_LocalisedStrings.h ***/


#endif
#ifndef __JUCE_NEWLINE_JUCEHEADER__

#endif
#ifndef __JUCE_STRING_JUCEHEADER__

#endif
#ifndef __JUCE_STRINGARRAY_JUCEHEADER__

#endif
#ifndef __JUCE_STRINGPAIRARRAY_JUCEHEADER__

#endif
#ifndef __JUCE_STRINGPOOL_JUCEHEADER__

/*** Start of inlined file: juce_StringPool.h ***/
#ifndef __JUCE_STRINGPOOL_JUCEHEADER__
#define __JUCE_STRINGPOOL_JUCEHEADER__

/**
	A StringPool holds a set of shared strings, which reduces storage overheads and improves
	comparison speed when dealing with many duplicate strings.

	When you add a string to a pool using getPooledString, it'll return a character
	array containing the same string. This array is owned by the pool, and the same array
	is returned every time a matching string is asked for. This means that it's trivial to
	compare two pooled strings for equality, as you can simply compare their pointers. It
	also cuts down on storage if you're using many copies of the same string.
*/
class JUCE_API  StringPool
{
public:

	/** Creates an empty pool. */
	StringPool() noexcept;

	/** Destructor */
	~StringPool();

	/** Returns a pointer to a copy of the string that is passed in.

		The pool will always return the same pointer when asked for a string that matches it.
		The pool will own all the pointers that it returns, deleting them when the pool itself
		is deleted.
	*/
	String::CharPointerType getPooledString (const String& original);

	/** Returns a pointer to a copy of the string that is passed in.

		The pool will always return the same pointer when asked for a string that matches it.
		The pool will own all the pointers that it returns, deleting them when the pool itself
		is deleted.
	*/
	String::CharPointerType getPooledString (const char* original);

	/** Returns a pointer to a copy of the string that is passed in.

		The pool will always return the same pointer when asked for a string that matches it.
		The pool will own all the pointers that it returns, deleting them when the pool itself
		is deleted.
	*/
	String::CharPointerType getPooledString (const wchar_t* original);

	/** Returns the number of strings in the pool. */
	int size() const noexcept;

	/** Returns one of the strings in the pool, by index. */
	String::CharPointerType operator[] (int index) const noexcept;

private:
	Array <String> strings;
	CriticalSection lock;
};

#endif   // __JUCE_STRINGPOOL_JUCEHEADER__

/*** End of inlined file: juce_StringPool.h ***/


#endif
#ifndef __JUCE_CHILDPROCESS_JUCEHEADER__

/*** Start of inlined file: juce_ChildProcess.h ***/
#ifndef __JUCE_CHILDPROCESS_JUCEHEADER__
#define __JUCE_CHILDPROCESS_JUCEHEADER__

/**
	Launches and monitors a child process.

	This class lets you launch an executable, and read its output. You can also
	use it to check whether the child process has finished.
*/
class JUCE_API  ChildProcess
{
public:

	/** Creates a process object.
		To actually launch the process, use start().
	*/
	ChildProcess();

	/** Destructor.
		Note that deleting this object won't terminate the child process.
	*/
	~ChildProcess();

	/** Attempts to launch a child process command.

		The command should be the name of the executable file, followed by any arguments
		that are required.
		If the process has already been launched, this will launch it again. If a problem
		occurs, the method will return false.
	*/
	bool start (const String& command);

	/** Returns true if the child process is alive. */
	bool isRunning() const;

	/** Attempts to read some output from the child process.
		This will attempt to read up to the given number of bytes of data from the
		process. It returns the number of bytes that were actually read.
	*/
	int readProcessOutput (void* destBuffer, int numBytesToRead);

	/** Blocks until the process has finished, and then returns its complete output
		as a string.
	*/
	String readAllProcessOutput();

	/** Blocks until the process is no longer running. */
	bool waitForProcessToFinish (int timeoutMs) const;

	/** Attempts to kill the child process.
		Returns true if it succeeded. Trying to read from the process after calling this may
		result in undefined behaviour.
	*/
	bool kill();

private:

	class ActiveProcess;
	friend class ScopedPointer<ActiveProcess>;
	ScopedPointer<ActiveProcess> activeProcess;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ChildProcess);
};

#endif   // __JUCE_CHILDPROCESS_JUCEHEADER__

/*** End of inlined file: juce_ChildProcess.h ***/


#endif
#ifndef __JUCE_CRITICALSECTION_JUCEHEADER__

#endif
#ifndef __JUCE_DYNAMICLIBRARY_JUCEHEADER__

/*** Start of inlined file: juce_DynamicLibrary.h ***/
#ifndef __JUCE_DYNAMICLIBRARY_JUCEHEADER__
#define __JUCE_DYNAMICLIBRARY_JUCEHEADER__

/**
	Handles the opening and closing of DLLs.

	This class can be used to open a DLL and get some function pointers from it.
	Since the DLL is freed when this object is deleted, it's handy for managing
	library lifetimes using RAII.
*/
class JUCE_API  DynamicLibrary
{
public:
	/** Creates an unopened DynamicLibrary object.
		Call open() to actually open one.
	*/
	DynamicLibrary() noexcept : handle (nullptr) {}

	/**
	*/
	DynamicLibrary (const String& name) : handle (nullptr) { open (name); }

	/** Destructor.
		If a library is currently open, it will be closed when this object is destroyed.
	*/
	~DynamicLibrary()   { close(); }

	/** Opens a DLL.
		The name and the method by which it gets found is of course platform-specific, and
		may or may not include a path, depending on the OS.
		If a library is already open when this method is called, it will first close the library
		before attempting to load the new one.
		@returns true if the library was successfully found and opened.
	*/
	bool open (const String& name);

	/** Releases the currently-open DLL, or has no effect if none was open. */
	void close();

	/** Tries to find a named function in the currently-open DLL, and returns a pointer to it.
		If no library is open, or if the function isn't found, this will return a null pointer.
	*/
	void* getFunction (const String& functionName) noexcept;

	/** Returns the platform-specific native library handle.
		You'll need to cast this to whatever is appropriate for the OS that's in use.
	*/
	void* getNativeHandle() const noexcept     { return handle; }

private:
	void* handle;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (DynamicLibrary);
};

#endif   // __JUCE_DYNAMICLIBRARY_JUCEHEADER__

/*** End of inlined file: juce_DynamicLibrary.h ***/


#endif
#ifndef __JUCE_INTERPROCESSLOCK_JUCEHEADER__

/*** Start of inlined file: juce_InterProcessLock.h ***/
#ifndef __JUCE_INTERPROCESSLOCK_JUCEHEADER__
#define __JUCE_INTERPROCESSLOCK_JUCEHEADER__

/**
	Acts as a critical section which processes can use to block each other.

	@see CriticalSection
*/
class JUCE_API  InterProcessLock
{
public:

	/** Creates a lock object.

		@param name     a name that processes will use to identify this lock object
	*/
	explicit InterProcessLock (const String& name);

	/** Destructor.

		This will also release the lock if it's currently held by this process.
	*/
	~InterProcessLock();

	/** Attempts to lock the critical section.

		@param timeOutMillisecs     how many milliseconds to wait if the lock
									is already held by another process - a value of
									0 will return immediately, negative values will wait
									forever
		@returns    true if the lock could be gained within the timeout period, or
					false if the timeout expired.
	*/
	bool enter (int timeOutMillisecs = -1);

	/** Releases the lock if it's currently held by this process.
	*/
	void exit();

	/**
		Automatically locks and unlocks an InterProcessLock object.

		This works like a ScopedLock, but using an InterprocessLock rather than
		a CriticalSection.

		@see ScopedLock
	*/
	class ScopedLockType
	{
	public:

		/** Creates a scoped lock.

			As soon as it is created, this will lock the InterProcessLock, and
			when the ScopedLockType object is deleted, the InterProcessLock will
			be unlocked.

			Note that since an InterprocessLock can fail due to errors, you should check
			isLocked() to make sure that the lock was successful before using it.

			Make sure this object is created and deleted by the same thread,
			otherwise there are no guarantees what will happen! Best just to use it
			as a local stack object, rather than creating one with the new() operator.
		*/
		explicit ScopedLockType (InterProcessLock& lock)                    : lock_ (lock) { lockWasSuccessful = lock.enter(); }

		/** Destructor.

			The InterProcessLock will be unlocked when the destructor is called.

			Make sure this object is created and deleted by the same thread,
			otherwise there are no guarantees what will happen!
		*/
		inline ~ScopedLockType()                                            { lock_.exit(); }

		/** Returns true if the InterProcessLock was successfully locked. */
		bool isLocked() const noexcept                                      { return lockWasSuccessful; }

	private:

		InterProcessLock& lock_;
		bool lockWasSuccessful;

		JUCE_DECLARE_NON_COPYABLE (ScopedLockType);
	};

private:

	class Pimpl;
	friend class ScopedPointer <Pimpl>;
	ScopedPointer <Pimpl> pimpl;

	CriticalSection lock;
	String name;

	JUCE_DECLARE_NON_COPYABLE (InterProcessLock);
};

#endif   // __JUCE_INTERPROCESSLOCK_JUCEHEADER__

/*** End of inlined file: juce_InterProcessLock.h ***/


#endif
#ifndef __JUCE_PROCESS_JUCEHEADER__

/*** Start of inlined file: juce_Process.h ***/
#ifndef __JUCE_PROCESS_JUCEHEADER__
#define __JUCE_PROCESS_JUCEHEADER__

/** Represents the current executable's process.

	This contains methods for controlling the current application at the
	process-level.

	@see Thread, JUCEApplication
*/
class JUCE_API  Process
{
public:

	enum ProcessPriority
	{
		LowPriority         = 0,
		NormalPriority      = 1,
		HighPriority        = 2,
		RealtimePriority    = 3
	};

	/** Changes the current process's priority.

		@param priority     the process priority, where
							0=low, 1=normal, 2=high, 3=realtime
	*/
	static void setPriority (const ProcessPriority priority);

	/** Kills the current process immediately.

		This is an emergency process terminator that kills the application
		immediately - it's intended only for use only when something goes
		horribly wrong.

		@see JUCEApplication::quit
	*/
	static void terminate();

	/** Returns true if this application process is the one that the user is
		currently using.
	*/
	static bool isForegroundProcess();

	/** Raises the current process's privilege level.

		Does nothing if this isn't supported by the current OS, or if process
		privilege level is fixed.
	*/
	static void raisePrivilege();

	/** Lowers the current process's privilege level.

		Does nothing if this isn't supported by the current OS, or if process
		privilege level is fixed.
	*/
	static void lowerPrivilege();

	/** Returns true if this process is being hosted by a debugger.
	*/
	static bool JUCE_CALLTYPE isRunningUnderDebugger();

	/** Tries to launch the OS's default reader application for a given file or URL. */
	static bool openDocument (const String& documentURL, const String& parameters);

	/** Tries to launch the OS's default email application to let the user create a message. */
	static bool openEmailWithAttachments (const String& targetEmailAddress,
										  const String& emailSubject,
										  const String& bodyText,
										  const StringArray& filesToAttach);

   #if JUCE_WINDOWS || DOXYGEN

	/** WINDOWS ONLY - This returns the HINSTANCE of the current module.

		The return type is a void* to avoid being dependent on windows.h - just cast
		it to a HINSTANCE to use it.

		In a normal JUCE application, this will be automatically set to the module
		handle of the executable.

		If you've built a DLL and plan to use any JUCE messaging or windowing classes,
		you'll need to make sure you call the setCurrentModuleInstanceHandle()
		to provide the correct module handle in your DllMain() function, because
		the system relies on the correct instance handle when opening windows.
	*/
	static void* JUCE_CALLTYPE getCurrentModuleInstanceHandle() noexcept;

	/** WINDOWS ONLY - Sets a new module handle to be used by the library.

		The parameter type is a void* to avoid being dependent on windows.h, but it actually
		expects a HINSTANCE value.

		@see getCurrentModuleInstanceHandle()
	*/
	static void JUCE_CALLTYPE setCurrentModuleInstanceHandle (void* newHandle) noexcept;

	/** WINDOWS ONLY - Gets the command-line params as a string.
		This is needed to avoid unicode problems with the argc type params.
	*/
	static String JUCE_CALLTYPE getCurrentCommandLineParams();
   #endif

private:
	Process();
	JUCE_DECLARE_NON_COPYABLE (Process);
};

#endif   // __JUCE_PROCESS_JUCEHEADER__

/*** End of inlined file: juce_Process.h ***/


#endif
#ifndef __JUCE_READWRITELOCK_JUCEHEADER__

/*** Start of inlined file: juce_ReadWriteLock.h ***/
#ifndef __JUCE_READWRITELOCK_JUCEHEADER__
#define __JUCE_READWRITELOCK_JUCEHEADER__


/*** Start of inlined file: juce_SpinLock.h ***/
#ifndef __JUCE_SPINLOCK_JUCEHEADER__
#define __JUCE_SPINLOCK_JUCEHEADER__

/**
	A simple spin-lock class that can be used as a simple, low-overhead mutex for
	uncontended situations.

	Note that unlike a CriticalSection, this type of lock is not re-entrant, and may
	be less efficient when used it a highly contended situation, but it's very small and
	requires almost no initialisation.
	It's most appropriate for simple situations where you're only going to hold the
	lock for a very brief time.

	@see CriticalSection
*/
class JUCE_API  SpinLock
{
public:
	inline SpinLock() noexcept {}
	inline ~SpinLock() noexcept {}

	/** Acquires the lock.
		This will block until the lock has been successfully acquired by this thread.
		Note that a SpinLock is NOT re-entrant, and is not smart enough to know whether the
		caller thread already has the lock - so if a thread tries to acquire a lock that it
		already holds, this method will never return!

		It's strongly recommended that you never call this method directly - instead use the
		ScopedLockType class to manage the locking using an RAII pattern instead.
	*/
	void enter() const noexcept;

	/** Attempts to acquire the lock, returning true if this was successful. */
	inline bool tryEnter() const noexcept
	{
		return lock.compareAndSetBool (1, 0);
	}

	/** Releases the lock. */
	inline void exit() const noexcept
	{
		jassert (lock.value == 1); // Agh! Releasing a lock that isn't currently held!
		lock = 0;
	}

	/** Provides the type of scoped lock to use for locking a SpinLock. */
	typedef GenericScopedLock <SpinLock>       ScopedLockType;

	/** Provides the type of scoped unlocker to use with a SpinLock. */
	typedef GenericScopedUnlock <SpinLock>     ScopedUnlockType;

private:

	mutable Atomic<int> lock;

	JUCE_DECLARE_NON_COPYABLE (SpinLock);
};

#endif   // __JUCE_SPINLOCK_JUCEHEADER__

/*** End of inlined file: juce_SpinLock.h ***/


/*** Start of inlined file: juce_WaitableEvent.h ***/
#ifndef __JUCE_WAITABLEEVENT_JUCEHEADER__
#define __JUCE_WAITABLEEVENT_JUCEHEADER__

/**
	Allows threads to wait for events triggered by other threads.

	A thread can call wait() on a WaitableObject, and this will suspend the
	calling thread until another thread wakes it up by calling the signal()
	method.
*/
class JUCE_API  WaitableEvent
{
public:

	/** Creates a WaitableEvent object.

		@param manualReset  If this is false, the event will be reset automatically when the wait()
							method is called. If manualReset is true, then once the event is signalled,
							the only way to reset it will be by calling the reset() method.
	*/
	WaitableEvent (bool manualReset = false) noexcept;

	/** Destructor.

		If other threads are waiting on this object when it gets deleted, this
		can cause nasty errors, so be careful!
	*/
	~WaitableEvent() noexcept;

	/** Suspends the calling thread until the event has been signalled.

		This will wait until the object's signal() method is called by another thread,
		or until the timeout expires.

		After the event has been signalled, this method will return true and if manualReset
		was set to false in the WaitableEvent's constructor, then the event will be reset.

		@param timeOutMilliseconds  the maximum time to wait, in milliseconds. A negative
									value will cause it to wait forever.

		@returns    true if the object has been signalled, false if the timeout expires first.
		@see signal, reset
	*/
	bool wait (int timeOutMilliseconds = -1) const noexcept;

	/** Wakes up any threads that are currently waiting on this object.

		If signal() is called when nothing is waiting, the next thread to call wait()
		will return immediately and reset the signal.

		If the WaitableEvent is manual reset, all current and future threads that wait upon this
		object will be woken, until reset() is explicitly called.

		If the WaitableEvent is automatic reset, and one or more threads is waiting upon the object,
		then one of them will be woken up. If no threads are currently waiting, then the next thread
		to call wait() will be woken up. As soon as a thread is woken, the signal is automatically
		reset.

		@see wait, reset
	*/
	void signal() const noexcept;

	/** Resets the event to an unsignalled state.

		If it's not already signalled, this does nothing.
	*/
	void reset() const noexcept;

private:

	void* internal;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (WaitableEvent);
};

#endif   // __JUCE_WAITABLEEVENT_JUCEHEADER__

/*** End of inlined file: juce_WaitableEvent.h ***/


/*** Start of inlined file: juce_Thread.h ***/
#ifndef __JUCE_THREAD_JUCEHEADER__
#define __JUCE_THREAD_JUCEHEADER__

/**
	Encapsulates a thread.

	Subclasses derive from Thread and implement the run() method, in which they
	do their business. The thread can then be started with the startThread() method
	and controlled with various other methods.

	This class also contains some thread-related static methods, such
	as sleep(), yield(), getCurrentThreadId() etc.

	@see CriticalSection, WaitableEvent, Process, ThreadWithProgressWindow,
		 MessageManagerLock
*/
class JUCE_API  Thread
{
public:

	/**
		Creates a thread.

		When first created, the thread is not running. Use the startThread()
		method to start it.
	*/
	explicit Thread (const String& threadName);

	/** Destructor.

		Deleting a Thread object that is running will only give the thread a
		brief opportunity to stop itself cleanly, so it's recommended that you
		should always call stopThread() with a decent timeout before deleting,
		to avoid the thread being forcibly killed (which is a Bad Thing).
	*/
	virtual ~Thread();

	/** Must be implemented to perform the thread's actual code.

		Remember that the thread must regularly check the threadShouldExit()
		method whilst running, and if this returns true it should return from
		the run() method as soon as possible to avoid being forcibly killed.

		@see threadShouldExit, startThread
	*/
	virtual void run() = 0;

	// Thread control functions..

	/** Starts the thread running.

		This will start the thread's run() method.
		(if it's already started, startThread() won't do anything).

		@see stopThread
	*/
	void startThread();

	/** Starts the thread with a given priority.

		Launches the thread with a given priority, where 0 = lowest, 10 = highest.
		If the thread is already running, its priority will be changed.

		@see startThread, setPriority
	*/
	void startThread (int priority);

	/** Attempts to stop the thread running.

		This method will cause the threadShouldExit() method to return true
		and call notify() in case the thread is currently waiting.

		Hopefully the thread will then respond to this by exiting cleanly, and
		the stopThread method will wait for a given time-period for this to
		happen.

		If the thread is stuck and fails to respond after the time-out, it gets
		forcibly killed, which is a very bad thing to happen, as it could still
		be holding locks, etc. which are needed by other parts of your program.

		@param timeOutMilliseconds  The number of milliseconds to wait for the
									thread to finish before killing it by force. A negative
									value in here will wait forever.
		@see signalThreadShouldExit, threadShouldExit, waitForThreadToExit, isThreadRunning
	*/
	void stopThread (int timeOutMilliseconds);

	/** Returns true if the thread is currently active */
	bool isThreadRunning() const;

	/** Sets a flag to tell the thread it should stop.

		Calling this means that the threadShouldExit() method will then return true.
		The thread should be regularly checking this to see whether it should exit.

		If your thread makes use of wait(), you might want to call notify() after calling
		this method, to interrupt any waits that might be in progress, and allow it
		to reach a point where it can exit.

		@see threadShouldExit
		@see waitForThreadToExit
	*/
	void signalThreadShouldExit();

	/** Checks whether the thread has been told to stop running.

		Threads need to check this regularly, and if it returns true, they should
		return from their run() method at the first possible opportunity.

		@see signalThreadShouldExit
	*/
	inline bool threadShouldExit() const                { return threadShouldExit_; }

	/** Waits for the thread to stop.

		This will waits until isThreadRunning() is false or until a timeout expires.

		@param timeOutMilliseconds  the time to wait, in milliseconds. If this value
									is less than zero, it will wait forever.
		@returns    true if the thread exits, or false if the timeout expires first.
	*/
	bool waitForThreadToExit (int timeOutMilliseconds) const;

	/** Changes the thread's priority.
		May return false if for some reason the priority can't be changed.

		@param priority     the new priority, in the range 0 (lowest) to 10 (highest). A priority
							of 5 is normal.
	*/
	bool setPriority (int priority);

	/** Changes the priority of the caller thread.

		Similar to setPriority(), but this static method acts on the caller thread.
		May return false if for some reason the priority can't be changed.

		@see setPriority
	*/
	static bool setCurrentThreadPriority (int priority);

	/** Sets the affinity mask for the thread.

		This will only have an effect next time the thread is started - i.e. if the
		thread is already running when called, it'll have no effect.

		@see setCurrentThreadAffinityMask
	*/
	void setAffinityMask (uint32 affinityMask);

	/** Changes the affinity mask for the caller thread.

		This will change the affinity mask for the thread that calls this static method.

		@see setAffinityMask
	*/
	static void setCurrentThreadAffinityMask (uint32 affinityMask);

	// this can be called from any thread that needs to pause..
	static void JUCE_CALLTYPE sleep (int milliseconds);

	/** Yields the calling thread's current time-slot. */
	static void JUCE_CALLTYPE yield();

	/** Makes the thread wait for a notification.

		This puts the thread to sleep until either the timeout period expires, or
		another thread calls the notify() method to wake it up.

		A negative time-out value means that the method will wait indefinitely.

		@returns    true if the event has been signalled, false if the timeout expires.
	*/
	bool wait (int timeOutMilliseconds) const;

	/** Wakes up the thread.

		If the thread has called the wait() method, this will wake it up.

		@see wait
	*/
	void notify() const;

	/** A value type used for thread IDs.
		@see getCurrentThreadId(), getThreadId()
	*/
	typedef void* ThreadID;

	/** Returns an id that identifies the caller thread.

		To find the ID of a particular thread object, use getThreadId().

		@returns    a unique identifier that identifies the calling thread.
		@see getThreadId
	*/
	static ThreadID getCurrentThreadId();

	/** Finds the thread object that is currently running.

		Note that the main UI thread (or other non-Juce threads) don't have a Thread
		object associated with them, so this will return 0.
	*/
	static Thread* getCurrentThread();

	/** Returns the ID of this thread.

		That means the ID of this thread object - not of the thread that's calling the method.

		This can change when the thread is started and stopped, and will be invalid if the
		thread's not actually running.

		@see getCurrentThreadId
	*/
	ThreadID getThreadId() const noexcept                           { return threadId_; }

	/** Returns the name of the thread.

		This is the name that gets set in the constructor.
	*/
	const String& getThreadName() const                             { return threadName_; }

	/** Changes the name of the caller thread.
		Different OSes may place different length or content limits on this name.
	*/
	static void setCurrentThreadName (const String& newThreadName);

	/** Returns the number of currently-running threads.

		@returns  the number of Thread objects known to be currently running.
		@see stopAllThreads
	*/
	static int getNumRunningThreads();

	/** Tries to stop all currently-running threads.

		This will attempt to stop all the threads known to be running at the moment.
	*/
	static void stopAllThreads (int timeoutInMillisecs);

private:

	const String threadName_;
	void* volatile threadHandle_;
	ThreadID threadId_;
	CriticalSection startStopLock;
	WaitableEvent startSuspensionEvent_, defaultEvent_;
	int threadPriority_;
	uint32 affinityMask_;
	bool volatile threadShouldExit_;

   #ifndef DOXYGEN
	friend void JUCE_API juce_threadEntryPoint (void*);
   #endif

	void launchThread();
	void closeThreadHandle();
	void killThread();
	void threadEntryPoint();
	static bool setThreadPriority (void*, int priority);

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (Thread);
};

#endif   // __JUCE_THREAD_JUCEHEADER__

/*** End of inlined file: juce_Thread.h ***/

/**
	A critical section that allows multiple simultaneous readers.

	Features of this type of lock are:

	- Multiple readers can hold the lock at the same time, but only one writer
	  can hold it at once.
	- Writers trying to gain the lock will be blocked until all readers and writers
	  have released it
	- Readers trying to gain the lock while a writer is waiting to acquire it will be
	  blocked until the writer has obtained and released it
	- If a thread already has a read lock and tries to obtain a write lock, it will succeed if
	  there are no other readers
	- If a thread already has the write lock and tries to obtain a read lock, this will succeed.
	- Recursive locking is supported.

	@see ScopedReadLock, ScopedWriteLock, CriticalSection
*/
class JUCE_API  ReadWriteLock
{
public:

	/**
		Creates a ReadWriteLock object.
	*/
	ReadWriteLock() noexcept;

	/** Destructor.

		If the object is deleted whilst locked, any subsequent behaviour
		is unpredictable.
	*/
	~ReadWriteLock() noexcept;

	/** Locks this object for reading.

		Multiple threads can simulaneously lock the object for reading, but if another
		thread has it locked for writing, then this will block until it releases the
		lock.

		@see exitRead, ScopedReadLock
	*/
	void enterRead() const noexcept;

	/** Releases the read-lock.

		If the caller thread hasn't got the lock, this can have unpredictable results.

		If the enterRead() method has been called multiple times by the thread, each
		call must be matched by a call to exitRead() before other threads will be allowed
		to take over the lock.

		@see enterRead, ScopedReadLock
	*/
	void exitRead() const noexcept;

	/** Locks this object for writing.

		This will block until any other threads that have it locked for reading or
		writing have released their lock.

		@see exitWrite, ScopedWriteLock
	*/
	void enterWrite() const noexcept;

	/** Tries to lock this object for writing.

		This is like enterWrite(), but doesn't block - it returns true if it manages
		to obtain the lock.

		@see enterWrite
	*/
	bool tryEnterWrite() const noexcept;

	/** Releases the write-lock.

		If the caller thread hasn't got the lock, this can have unpredictable results.

		If the enterWrite() method has been called multiple times by the thread, each
		call must be matched by a call to exit() before other threads will be allowed
		to take over the lock.

		@see enterWrite, ScopedWriteLock
	*/
	void exitWrite() const noexcept;

private:

	SpinLock accessLock;
	WaitableEvent waitEvent;
	mutable int numWaitingWriters, numWriters;
	mutable Thread::ThreadID writerThreadId;
	mutable Array <Thread::ThreadID> readerThreads;

	JUCE_DECLARE_NON_COPYABLE (ReadWriteLock);
};

#endif   // __JUCE_READWRITELOCK_JUCEHEADER__

/*** End of inlined file: juce_ReadWriteLock.h ***/


#endif
#ifndef __JUCE_SCOPEDLOCK_JUCEHEADER__

#endif
#ifndef __JUCE_SCOPEDREADLOCK_JUCEHEADER__

/*** Start of inlined file: juce_ScopedReadLock.h ***/
#ifndef __JUCE_SCOPEDREADLOCK_JUCEHEADER__
#define __JUCE_SCOPEDREADLOCK_JUCEHEADER__

/**
	Automatically locks and unlocks a ReadWriteLock object.

	Use one of these as a local variable to control access to a ReadWriteLock.

	e.g. @code

	ReadWriteLock myLock;

	for (;;)
	{
		const ScopedReadLock myScopedLock (myLock);
		// myLock is now locked

		...do some stuff...

		// myLock gets unlocked here.
	}
	@endcode

	@see ReadWriteLock, ScopedWriteLock
*/
class JUCE_API  ScopedReadLock
{
public:

	/** Creates a ScopedReadLock.

		As soon as it is created, this will call ReadWriteLock::enterRead(), and
		when the ScopedReadLock object is deleted, the ReadWriteLock will
		be unlocked.

		Make sure this object is created and deleted by the same thread,
		otherwise there are no guarantees what will happen! Best just to use it
		as a local stack object, rather than creating one with the new() operator.
	*/
	inline explicit ScopedReadLock (const ReadWriteLock& lock) noexcept   : lock_ (lock) { lock.enterRead(); }

	/** Destructor.

		The ReadWriteLock's exitRead() method will be called when the destructor is called.

		Make sure this object is created and deleted by the same thread,
		otherwise there are no guarantees what will happen!
	*/
	inline ~ScopedReadLock() noexcept                                     { lock_.exitRead(); }

private:

	const ReadWriteLock& lock_;

	JUCE_DECLARE_NON_COPYABLE (ScopedReadLock);
};

#endif   // __JUCE_SCOPEDREADLOCK_JUCEHEADER__

/*** End of inlined file: juce_ScopedReadLock.h ***/


#endif
#ifndef __JUCE_SCOPEDWRITELOCK_JUCEHEADER__

/*** Start of inlined file: juce_ScopedWriteLock.h ***/
#ifndef __JUCE_SCOPEDWRITELOCK_JUCEHEADER__
#define __JUCE_SCOPEDWRITELOCK_JUCEHEADER__

/**
	Automatically locks and unlocks a ReadWriteLock object.

	Use one of these as a local variable to control access to a ReadWriteLock.

	e.g. @code

	ReadWriteLock myLock;

	for (;;)
	{
		const ScopedWriteLock myScopedLock (myLock);
		// myLock is now locked

		...do some stuff...

		// myLock gets unlocked here.
	}
	@endcode

	@see ReadWriteLock, ScopedReadLock
*/
class JUCE_API  ScopedWriteLock
{
public:

	/** Creates a ScopedWriteLock.

		As soon as it is created, this will call ReadWriteLock::enterWrite(), and
		when the ScopedWriteLock object is deleted, the ReadWriteLock will
		be unlocked.

		Make sure this object is created and deleted by the same thread,
		otherwise there are no guarantees what will happen! Best just to use it
		as a local stack object, rather than creating one with the new() operator.
	*/
	inline explicit ScopedWriteLock (const ReadWriteLock& lock) noexcept : lock_ (lock) { lock.enterWrite(); }

	/** Destructor.

		The ReadWriteLock's exitWrite() method will be called when the destructor is called.

		Make sure this object is created and deleted by the same thread,
		otherwise there are no guarantees what will happen!
	*/
	inline ~ScopedWriteLock() noexcept                                   { lock_.exitWrite(); }

private:

	const ReadWriteLock& lock_;

	JUCE_DECLARE_NON_COPYABLE (ScopedWriteLock);
};

#endif   // __JUCE_SCOPEDWRITELOCK_JUCEHEADER__

/*** End of inlined file: juce_ScopedWriteLock.h ***/


#endif
#ifndef __JUCE_SPINLOCK_JUCEHEADER__

#endif
#ifndef __JUCE_THREAD_JUCEHEADER__

#endif
#ifndef __JUCE_THREADLOCALVALUE_JUCEHEADER__

/*** Start of inlined file: juce_ThreadLocalValue.h ***/
#ifndef __JUCE_THREADLOCALVALUE_JUCEHEADER__
#define __JUCE_THREADLOCALVALUE_JUCEHEADER__

/**
	Provides cross-platform support for thread-local objects.

	This class holds an internal list of objects of the templated type, keeping
	an instance for each thread that requests one. The first time a thread attempts
	to access its value, an object is created and added to the list for that thread.

	The templated class for your value could be a primitive type, or any class that
	has a default constructor.

	Once a thread has accessed its object, that object will not be deleted until the
	ThreadLocalValue object itself is deleted, even if its thread exits before that.
	But, because thread ID numbers are used to identify threads, and OSes often re-use
	these ID numbers, value objects will often be implicitly re-used by new threads whose
	ID number is the same as one that was used by an earlier thread.
*/
template <typename Type>
class ThreadLocalValue
{
public:
	/** */
	ThreadLocalValue() noexcept
	{
	}

	/** Destructor.
		When this object is deleted, all the value objects for all threads will be deleted.
	*/
	~ThreadLocalValue()
	{
		for (ObjectHolder* o = first.value; o != nullptr;)
		{
			ObjectHolder* const next = o->next;
			delete o;
			o = next;
		}
	}

	/** Returns a reference to this thread's instance of the value.
		Note that the first time a thread tries to access the value, an instance of the
		value object will be created - so if your value's class has a non-trivial
		constructor, be aware that this method could invoke it.
	*/
	Type& operator*() const noexcept    { return get(); }

	/** Returns a pointer to this thread's instance of the value.
		Note that the first time a thread tries to access the value, an instance of the
		value object will be created - so if your value's class has a non-trivial
		constructor, be aware that this method could invoke it.
	*/
	operator Type*() const noexcept     { return &get(); }

	/** Accesses a method or field of the value object.
		Note that the first time a thread tries to access the value, an instance of the
		value object will be created - so if your value's class has a non-trivial
		constructor, be aware that this method could invoke it.
	*/
	Type* operator->() const noexcept   { return &get(); }

	/** Returns a reference to this thread's instance of the value.
		Note that the first time a thread tries to access the value, an instance of the
		value object will be created - so if your value's class has a non-trivial
		constructor, be aware that this method could invoke it.
	*/
	Type& get() const noexcept
	{
		const Thread::ThreadID threadId = Thread::getCurrentThreadId();

		for (ObjectHolder* o = first.get(); o != nullptr; o = o->next)
			if (o->threadId == threadId)
				return o->object;

		ObjectHolder* const newObject = new ObjectHolder (threadId);

		do
		{
			newObject->next = first.get();
		}
		while (! first.compareAndSetBool (newObject, newObject->next));

		return newObject->object;
	}

private:

	struct ObjectHolder
	{
		ObjectHolder (const Thread::ThreadID& threadId_)
			: threadId (threadId_), object()
		{}

		const Thread::ThreadID threadId;
		ObjectHolder* next;
		Type object;

		JUCE_DECLARE_NON_COPYABLE (ObjectHolder);
	};

	mutable Atomic<ObjectHolder*> first;

	JUCE_DECLARE_NON_COPYABLE (ThreadLocalValue);
};

#endif   // __JUCE_THREADLOCALVALUE_JUCEHEADER__

/*** End of inlined file: juce_ThreadLocalValue.h ***/


#endif
#ifndef __JUCE_THREADPOOL_JUCEHEADER__

/*** Start of inlined file: juce_ThreadPool.h ***/
#ifndef __JUCE_THREADPOOL_JUCEHEADER__
#define __JUCE_THREADPOOL_JUCEHEADER__

class ThreadPool;
class ThreadPoolThread;

/**
	A task that is executed by a ThreadPool object.

	A ThreadPool keeps a list of ThreadPoolJob objects which are executed by
	its threads.

	The runJob() method needs to be implemented to do the task, and if the code that
	does the work takes a significant time to run, it must keep checking the shouldExit()
	method to see if something is trying to interrupt the job. If shouldExit() returns
	true, the runJob() method must return immediately.

	@see ThreadPool, Thread
*/
class JUCE_API  ThreadPoolJob
{
public:

	/** Creates a thread pool job object.

		After creating your job, add it to a thread pool with ThreadPool::addJob().
	*/
	explicit ThreadPoolJob (const String& name);

	/** Destructor. */
	virtual ~ThreadPoolJob();

	/** Returns the name of this job.
		@see setJobName
	*/
	String getJobName() const;

	/** Changes the job's name.
		@see getJobName
	*/
	void setJobName (const String& newName);

	/** These are the values that can be returned by the runJob() method.
	*/
	enum JobStatus
	{
		jobHasFinished = 0,     /**< indicates that the job has finished and can be
									 removed from the pool. */

		jobHasFinishedAndShouldBeDeleted,  /**< indicates that the job has finished and that it
												should be automatically deleted by the pool. */

		jobNeedsRunningAgain    /**< indicates that the job would like to be called
									 again when a thread is free. */
	};

	/** Peforms the actual work that this job needs to do.

		Your subclass must implement this method, in which is does its work.

		If the code in this method takes a significant time to run, it must repeatedly check
		the shouldExit() method to see if something is trying to interrupt the job.
		If shouldExit() ever returns true, the runJob() method must return immediately.

		If this method returns jobHasFinished, then the job will be removed from the pool
		immediately. If it returns jobNeedsRunningAgain, then the job will be left in the
		pool and will get a chance to run again as soon as a thread is free.

		@see shouldExit()
	*/
	virtual JobStatus runJob() = 0;

	/** Returns true if this job is currently running its runJob() method. */
	bool isRunning() const                  { return isActive; }

	/** Returns true if something is trying to interrupt this job and make it stop.

		Your runJob() method must call this whenever it gets a chance, and if it ever
		returns true, the runJob() method must return immediately.

		@see signalJobShouldExit()
	*/
	bool shouldExit() const                 { return shouldStop; }

	/** Calling this will cause the shouldExit() method to return true, and the job
		should (if it's been implemented correctly) stop as soon as possible.

		@see shouldExit()
	*/
	void signalJobShouldExit();

private:
	friend class ThreadPool;
	friend class ThreadPoolThread;
	String jobName;
	ThreadPool* pool;
	bool shouldStop, isActive, shouldBeDeleted;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ThreadPoolJob);
};

/**
	A set of threads that will run a list of jobs.

	When a ThreadPoolJob object is added to the ThreadPool's list, its run() method
	will be called by the next pooled thread that becomes free.

	@see ThreadPoolJob, Thread
*/
class JUCE_API  ThreadPool
{
public:

	/** Creates a thread pool.

		Once you've created a pool, you can give it some things to do with the addJob()
		method.

		@param numberOfThreads              the maximum number of actual threads to run.
		@param startThreadsOnlyWhenNeeded   if this is true, then no threads will be started
											until there are some jobs to run. If false, then
											all the threads will be fired-up immediately so that
											they're ready for action
		@param stopThreadsWhenNotUsedTimeoutMs  if this timeout is > 0, then if any threads have been
											inactive for this length of time, they will automatically
											be stopped until more jobs come along and they're needed
	*/
	ThreadPool (int numberOfThreads,
				bool startThreadsOnlyWhenNeeded = true,
				int stopThreadsWhenNotUsedTimeoutMs = 5000);

	/** Destructor.

		This will attempt to remove all the jobs before deleting, but if you want to
		specify a timeout, you should call removeAllJobs() explicitly before deleting
		the pool.
	*/
	~ThreadPool();

	/** A callback class used when you need to select which ThreadPoolJob objects are suitable
		for some kind of operation.
		@see ThreadPool::removeAllJobs
	*/
	class JUCE_API  JobSelector
	{
	public:
		virtual ~JobSelector() {}

		/** Should return true if the specified thread matches your criteria for whatever
			operation that this object is being used for.

			Any implementation of this method must be extremely fast and thread-safe!
		*/
		virtual bool isJobSuitable (ThreadPoolJob* job) = 0;
	};

	/** Adds a job to the queue.

		Once a job has been added, then the next time a thread is free, it will run
		the job's ThreadPoolJob::runJob() method. Depending on the return value of the
		runJob() method, the pool will either remove the job from the pool or add it to
		the back of the queue to be run again.
	*/
	void addJob (ThreadPoolJob* job);

	/** Tries to remove a job from the pool.

		If the job isn't yet running, this will simply remove it. If it is running, it
		will wait for it to finish.

		If the timeout period expires before the job finishes running, then the job will be
		left in the pool and this will return false. It returns true if the job is sucessfully
		stopped and removed.

		@param job                  the job to remove
		@param interruptIfRunning   if true, then if the job is currently busy, its
									ThreadPoolJob::signalJobShouldExit() method will be called to try
									to interrupt it. If false, then if the job will be allowed to run
									until it stops normally (or the timeout expires)
		@param timeOutMilliseconds  the length of time this method should wait for the job to finish
									before giving up and returning false
	*/
	bool removeJob (ThreadPoolJob* job,
					bool interruptIfRunning,
					int timeOutMilliseconds);

	/** Tries to remove all jobs from the pool.

		@param interruptRunningJobs if true, then all running jobs will have their ThreadPoolJob::signalJobShouldExit()
									methods called to try to interrupt them
		@param timeOutMilliseconds  the length of time this method should wait for all the jobs to finish
									before giving up and returning false
		@param deleteInactiveJobs   if true, any jobs that aren't currently running will be deleted. If false,
									they will simply be removed from the pool. Jobs that are already running when
									this method is called can choose whether they should be deleted by
									returning jobHasFinishedAndShouldBeDeleted from their runJob() method.
		@param selectedJobsToRemove if this is non-zero, the JobSelector object is asked to decide which
									jobs should be removed. If it is zero, all jobs are removed
		@returns    true if all jobs are successfully stopped and removed; false if the timeout period
					expires while waiting for one or more jobs to stop
	*/
	bool removeAllJobs (bool interruptRunningJobs,
						int timeOutMilliseconds,
						bool deleteInactiveJobs = false,
						JobSelector* selectedJobsToRemove = nullptr);

	/** Returns the number of jobs currently running or queued.
	*/
	int getNumJobs() const;

	/** Returns one of the jobs in the queue.

		Note that this can be a very volatile list as jobs might be continuously getting shifted
		around in the list, and this method may return 0 if the index is currently out-of-range.
	*/
	ThreadPoolJob* getJob (int index) const;

	/** Returns true if the given job is currently queued or running.

		@see isJobRunning()
	*/
	bool contains (const ThreadPoolJob* job) const;

	/** Returns true if the given job is currently being run by a thread.
	*/
	bool isJobRunning (const ThreadPoolJob* job) const;

	/** Waits until a job has finished running and has been removed from the pool.

		This will wait until the job is no longer in the pool - i.e. until its
		runJob() method returns ThreadPoolJob::jobHasFinished.

		If the timeout period expires before the job finishes, this will return false;
		it returns true if the job has finished successfully.
	*/
	bool waitForJobToFinish (const ThreadPoolJob* job,
							 int timeOutMilliseconds) const;

	/** Returns a list of the names of all the jobs currently running or queued.

		If onlyReturnActiveJobs is true, only the ones currently running are returned.
	*/
	StringArray getNamesOfAllJobs (bool onlyReturnActiveJobs) const;

	/** Changes the priority of all the threads.

		This will call Thread::setPriority() for each thread in the pool.
		May return false if for some reason the priority can't be changed.
	*/
	bool setThreadPriorities (int newPriority);

private:

	const int threadStopTimeout;
	int priority;
	class ThreadPoolThread;
	friend class OwnedArray <ThreadPoolThread>;
	OwnedArray <ThreadPoolThread> threads;
	Array <ThreadPoolJob*> jobs;

	CriticalSection lock;
	uint32 lastJobEndTime;
	WaitableEvent jobFinishedSignal;

	friend class ThreadPoolThread;
	bool runNextJob();

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ThreadPool);
};

#endif   // __JUCE_THREADPOOL_JUCEHEADER__

/*** End of inlined file: juce_ThreadPool.h ***/


#endif
#ifndef __JUCE_TIMESLICETHREAD_JUCEHEADER__

/*** Start of inlined file: juce_TimeSliceThread.h ***/
#ifndef __JUCE_TIMESLICETHREAD_JUCEHEADER__
#define __JUCE_TIMESLICETHREAD_JUCEHEADER__

class TimeSliceThread;

/**
	Used by the TimeSliceThread class.

	To register your class with a TimeSliceThread, derive from this class and
	use the TimeSliceThread::addTimeSliceClient() method to add it to the list.

	Make sure you always call TimeSliceThread::removeTimeSliceClient() before
	deleting your client!

	@see TimeSliceThread
*/
class JUCE_API  TimeSliceClient
{
public:
	/** Destructor. */
	virtual ~TimeSliceClient()   {}

	/** Called back by a TimeSliceThread.

		When you register this class with it, a TimeSliceThread will repeatedly call
		this method.

		The implementation of this method should use its time-slice to do something that's
		quick - never block for longer than absolutely necessary.

		@returns    Your method should return the number of milliseconds which it would like to wait before being called
					again. Returning 0 will make the thread call again as soon as possible (after possibly servicing
					other busy clients). If you return a value below zero, your client will be removed from the list of clients,
					and won't be called again. The value you specify isn't a guaranteee, and is only used as a hint by the
					thread - the actual time before the next callback may be more or less than specified.
					You can force the TimeSliceThread to wake up and poll again immediately by calling its notify() method.
	*/
	virtual int useTimeSlice() = 0;

private:
	friend class TimeSliceThread;
	Time nextCallTime;
};

/**
	A thread that keeps a list of clients, and calls each one in turn, giving them
	all a chance to run some sort of short task.

	@see TimeSliceClient, Thread
*/
class JUCE_API  TimeSliceThread   : public Thread
{
public:

	/**
		Creates a TimeSliceThread.

		When first created, the thread is not running. Use the startThread()
		method to start it.
	*/
	explicit TimeSliceThread (const String& threadName);

	/** Destructor.

		Deleting a Thread object that is running will only give the thread a
		brief opportunity to stop itself cleanly, so it's recommended that you
		should always call stopThread() with a decent timeout before deleting,
		to avoid the thread being forcibly killed (which is a Bad Thing).
	*/
	~TimeSliceThread();

	/** Adds a client to the list.

		The client's callbacks will start after the number of milliseconds specified
		by millisecondsBeforeStarting (and this may happen before this method has returned).
	*/
	void addTimeSliceClient (TimeSliceClient* client, int millisecondsBeforeStarting = 0);

	/** Removes a client from the list.

		This method will make sure that all callbacks to the client have completely
		finished before the method returns.
	*/
	void removeTimeSliceClient (TimeSliceClient* client);

	/** If the given client is waiting in the queue, it will be moved to the front
		and given a time-slice as soon as possible.
		If the specified client has not been added, nothing will happen.
	*/
	void moveToFrontOfQueue (TimeSliceClient* client);

	/** Returns the number of registered clients. */
	int getNumClients() const;

	/** Returns one of the registered clients. */
	TimeSliceClient* getClient (int index) const;

   #ifndef DOXYGEN
	void run();
   #endif

private:
	CriticalSection callbackLock, listLock;
	Array <TimeSliceClient*> clients;
	TimeSliceClient* clientBeingCalled;

	TimeSliceClient* getNextClient (int index) const;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (TimeSliceThread);
};

#endif   // __JUCE_TIMESLICETHREAD_JUCEHEADER__

/*** End of inlined file: juce_TimeSliceThread.h ***/


#endif
#ifndef __JUCE_WAITABLEEVENT_JUCEHEADER__

#endif
#ifndef __JUCE_PERFORMANCECOUNTER_JUCEHEADER__

/*** Start of inlined file: juce_PerformanceCounter.h ***/
#ifndef __JUCE_PERFORMANCECOUNTER_JUCEHEADER__
#define __JUCE_PERFORMANCECOUNTER_JUCEHEADER__

/** A timer for measuring performance of code and dumping the results to a file.

	e.g. @code

		PerformanceCounter pc ("fish", 50, "/temp/myfishlog.txt");

		for (;;)
		{
			pc.start();

			doSomethingFishy();

			pc.stop();
		}
	@endcode

	In this example, the time of each period between calling start/stop will be
	measured and averaged over 50 runs, and the results printed to a file
	every 50 times round the loop.
*/
class JUCE_API  PerformanceCounter
{
public:

	/** Creates a PerformanceCounter object.

		@param counterName      the name used when printing out the statistics
		@param runsPerPrintout  the number of start/stop iterations before calling
								printStatistics()
		@param loggingFile      a file to dump the results to - if this is File::nonexistent,
								the results are just written to the debugger output
	*/
	PerformanceCounter (const String& counterName,
						int runsPerPrintout = 100,
						const File& loggingFile = File::nonexistent);

	/** Destructor. */
	~PerformanceCounter();

	/** Starts timing.

		@see stop
	*/
	void start();

	/** Stops timing and prints out the results.

		The number of iterations before doing a printout of the
		results is set in the constructor.

		@see start
	*/
	void stop();

	/** Dumps the current metrics to the debugger output and to a file.

		As well as using Logger::outputDebugString to print the results,
		this will write then to the file specified in the constructor (if
		this was valid).
	*/
	void printStatistics();

private:

	String name;
	int numRuns, runsPerPrint;
	double totalTime;
	int64 started;
	File outputFile;
};

#endif   // __JUCE_PERFORMANCECOUNTER_JUCEHEADER__

/*** End of inlined file: juce_PerformanceCounter.h ***/


#endif
#ifndef __JUCE_RELATIVETIME_JUCEHEADER__

#endif
#ifndef __JUCE_TIME_JUCEHEADER__

#endif
#ifndef __JUCE_UNITTEST_JUCEHEADER__

/*** Start of inlined file: juce_UnitTest.h ***/
#ifndef __JUCE_UNITTEST_JUCEHEADER__
#define __JUCE_UNITTEST_JUCEHEADER__

class UnitTestRunner;

/**
	This is a base class for classes that perform a unit test.

	To write a test using this class, your code should look something like this:

	@code
	class MyTest  : public UnitTest
	{
	public:
		MyTest()  : UnitTest ("Foobar testing") {}

		void runTest()
		{
			beginTest ("Part 1");

			expect (myFoobar.doesSomething());
			expect (myFoobar.doesSomethingElse());

			beginTest ("Part 2");

			expect (myOtherFoobar.doesSomething());
			expect (myOtherFoobar.doesSomethingElse());

			...etc..
		}
	};

	// Creating a static instance will automatically add the instance to the array
	// returned by UnitTest::getAllTests(), so the test will be included when you call
	// UnitTestRunner::runAllTests()
	static MyTest test;
	@endcode

	To run a test, use the UnitTestRunner class.

	@see UnitTestRunner
*/
class JUCE_API  UnitTest
{
public:

	/** Creates a test with the given name. */
	explicit UnitTest (const String& name);

	/** Destructor. */
	virtual ~UnitTest();

	/** Returns the name of the test. */
	const String& getName() const noexcept       { return name; }

	/** Runs the test, using the specified UnitTestRunner.
		You shouldn't need to call this method directly - use
		UnitTestRunner::runTests() instead.
	*/
	void performTest (UnitTestRunner* runner);

	/** Returns the set of all UnitTest objects that currently exist. */
	static Array<UnitTest*>& getAllTests();

	/** You can optionally implement this method to set up your test.
		This method will be called before runTest().
	*/
	virtual void initialise();

	/** You can optionally implement this method to clear up after your test has been run.
		This method will be called after runTest() has returned.
	*/
	virtual void shutdown();

	/** Implement this method in your subclass to actually run your tests.

		The content of your implementation should call beginTest() and expect()
		to perform the tests.
	*/
	virtual void runTest() = 0;

	/** Tells the system that a new subsection of tests is beginning.
		This should be called from your runTest() method, and may be called
		as many times as you like, to demarcate different sets of tests.
	*/
	void beginTest (const String& testName);

	/** Checks that the result of a test is true, and logs this result.

		In your runTest() method, you should call this method for each condition that
		you want to check, e.g.

		@code
		void runTest()
		{
			beginTest ("basic tests");
			expect (x + y == 2);
			expect (getThing() == someThing);
			...etc...
		}
		@endcode

		If testResult is true, a pass is logged; if it's false, a failure is logged.
		If the failure message is specified, it will be written to the log if the test fails.
	*/
	void expect (bool testResult, const String& failureMessage = String::empty);

	/** Compares two values, and if they don't match, prints out a message containing the
		expected and actual result values.
	*/
	template <class ValueType>
	void expectEquals (ValueType actual, ValueType expected, String failureMessage = String::empty)
	{
		const bool result = (actual == expected);

		if (! result)
		{
			if (failureMessage.isNotEmpty())
				failureMessage << " -- ";

			failureMessage << "Expected value: " << expected << ", Actual value: " << actual;
		}

		expect (result, failureMessage);
	}

	/** Writes a message to the test log.
		This can only be called from within your runTest() method.
	*/
	void logMessage (const String& message);

private:

	const String name;
	UnitTestRunner* runner;

	JUCE_DECLARE_NON_COPYABLE (UnitTest);
};

/**
	Runs a set of unit tests.

	You can instantiate one of these objects and use it to invoke tests on a set of
	UnitTest objects.

	By using a subclass of UnitTestRunner, you can intercept logging messages and
	perform custom behaviour when each test completes.

	@see UnitTest
*/
class JUCE_API  UnitTestRunner
{
public:

	/** */
	UnitTestRunner();

	/** Destructor. */
	virtual ~UnitTestRunner();

	/** Runs a set of tests.

		The tests are performed in order, and the results are logged. To run all the
		registered UnitTest objects that exist, use runAllTests().
	*/
	void runTests (const Array<UnitTest*>& tests);

	/** Runs all the UnitTest objects that currently exist.
		This calls runTests() for all the objects listed in UnitTest::getAllTests().
	*/
	void runAllTests();

	/** Sets a flag to indicate whether an assertion should be triggered if a test fails.
		This is true by default.
	*/
	void setAssertOnFailure (bool shouldAssert) noexcept;

	/** Sets a flag to indicate whether successful tests should be logged.
		By default, this is set to false, so that only failures will be displayed in the log.
	*/
	void setPassesAreLogged (bool shouldDisplayPasses) noexcept;

	/** Contains the results of a test.

		One of these objects is instantiated each time UnitTest::beginTest() is called, and
		it contains details of the number of subsequent UnitTest::expect() calls that are
		made.
	*/
	struct TestResult
	{
		/** The main name of this test (i.e. the name of the UnitTest object being run). */
		String unitTestName;
		/** The name of the current subcategory (i.e. the name that was set when UnitTest::beginTest() was called). */
		String subcategoryName;

		/** The number of UnitTest::expect() calls that succeeded. */
		int passes;
		/** The number of UnitTest::expect() calls that failed. */
		int failures;

		/** A list of messages describing the failed tests. */
		StringArray messages;
	};

	/** Returns the number of TestResult objects that have been performed.
		@see getResult
	*/
	int getNumResults() const noexcept;

	/** Returns one of the TestResult objects that describes a test that has been run.
		@see getNumResults
	*/
	const TestResult* getResult (int index) const noexcept;

protected:
	/** Called when the list of results changes.
		You can override this to perform some sort of behaviour when results are added.
	*/
	virtual void resultsUpdated();

	/** Logs a message about the current test progress.
		By default this just writes the message to the Logger class, but you could override
		this to do something else with the data.
	*/
	virtual void logMessage (const String& message);

	/** This can be overridden to let the runner know that it should abort the tests
		as soon as possible, e.g. because the thread needs to stop.
	*/
	virtual bool shouldAbortTests();

private:

	friend class UnitTest;

	UnitTest* currentTest;
	String currentSubCategory;
	OwnedArray <TestResult, CriticalSection> results;
	bool assertOnFailure, logPasses;

	void beginNewTest (UnitTest* test, const String& subCategory);
	void endTest();

	void addPass();
	void addFail (const String& failureMessage);

	JUCE_DECLARE_NON_COPYABLE (UnitTestRunner);
};

#endif   // __JUCE_UNITTEST_JUCEHEADER__

/*** End of inlined file: juce_UnitTest.h ***/


#endif
#ifndef __JUCE_XMLDOCUMENT_JUCEHEADER__

/*** Start of inlined file: juce_XmlDocument.h ***/
#ifndef __JUCE_XMLDOCUMENT_JUCEHEADER__
#define __JUCE_XMLDOCUMENT_JUCEHEADER__

class InputSource;

/**
	Parses a text-based XML document and creates an XmlElement object from it.

	The parser will parse DTDs to load external entities but won't
	check the document for validity against the DTD.

	e.g.
	@code

	XmlDocument myDocument (File ("myfile.xml"));
	XmlElement* mainElement = myDocument.getDocumentElement();

	if (mainElement == nullptr)
	{
		String error = myDocument.getLastParseError();
	}
	else
	{
		..use the element
	}

	@endcode

	Or you can use the static helper methods for quick parsing..

	@code
	XmlElement* xml = XmlDocument::parse (myXmlFile);

	if (xml != nullptr && xml->hasTagName ("foobar"))
	{
		...etc
	@endcode

	@see XmlElement
*/
class JUCE_API  XmlDocument
{
public:

	/** Creates an XmlDocument from the xml text.
		The text doesn't actually get parsed until the getDocumentElement() method is called.
	*/
	XmlDocument (const String& documentText);

	/** Creates an XmlDocument from a file.
		The text doesn't actually get parsed until the getDocumentElement() method is called.
	*/
	XmlDocument (const File& file);

	/** Destructor. */
	~XmlDocument();

	/** Creates an XmlElement object to represent the main document node.

		This method will do the actual parsing of the text, and if there's a
		parse error, it may returns 0 (and you can find out the error using
		the getLastParseError() method).

		See also the parse() methods, which provide a shorthand way to quickly
		parse a file or string.

		@param onlyReadOuterDocumentElement     if true, the parser will only read the
												first section of the file, and will only
												return the outer document element - this
												allows quick checking of large files to
												see if they contain the correct type of
												tag, without having to parse the entire file
		@returns    a new XmlElement which the caller will need to delete, or null if
					there was an error.
		@see getLastParseError
	*/
	XmlElement* getDocumentElement (bool onlyReadOuterDocumentElement = false);

	/** Returns the parsing error that occurred the last time getDocumentElement was called.

		@returns the error, or an empty string if there was no error.
	*/
	const String& getLastParseError() const noexcept;

	/** Sets an input source object to use for parsing documents that reference external entities.

		If the document has been created from a file, this probably won't be needed, but
		if you're parsing some text and there might be a DTD that references external
		files, you may need to create a custom input source that can retrieve the
		other files it needs.

		The object that is passed-in will be deleted automatically when no longer needed.

		@see InputSource
	*/
	void setInputSource (InputSource* newSource) noexcept;

	/** Sets a flag to change the treatment of empty text elements.

		If this is true (the default state), then any text elements that contain only
		whitespace characters will be ingored during parsing. If you need to catch
		whitespace-only text, then you should set this to false before calling the
		getDocumentElement() method.
	*/
	void setEmptyTextElementsIgnored (bool shouldBeIgnored) noexcept;

	/** A handy static method that parses a file.
		This is a shortcut for creating an XmlDocument object and calling getDocumentElement() on it.
		@returns    a new XmlElement which the caller will need to delete, or null if there was an error.
	*/
	static XmlElement* parse (const File& file);

	/** A handy static method that parses some XML data.
		This is a shortcut for creating an XmlDocument object and calling getDocumentElement() on it.
		@returns    a new XmlElement which the caller will need to delete, or null if there was an error.
	*/
	static XmlElement* parse (const String& xmlData);

private:
	String originalText;
	String::CharPointerType input;
	bool outOfData, errorOccurred;

	String lastError, dtdText;
	StringArray tokenisedDTD;
	bool needToLoadDTD, ignoreEmptyTextElements;
	ScopedPointer <InputSource> inputSource;

	void setLastError (const String& desc, bool carryOn);
	void skipHeader();
	void skipNextWhiteSpace();
	juce_wchar readNextChar() noexcept;
	XmlElement* readNextElement (bool alsoParseSubElements);
	void readChildElements (XmlElement* parent);
	int findNextTokenLength() noexcept;
	void readQuotedString (String& result);
	void readEntity (String& result);

	String getFileContents (const String& filename) const;
	String expandEntity (const String& entity);
	String expandExternalEntity (const String& entity);
	String getParameterEntity (const String& entity);

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (XmlDocument);
};

#endif   // __JUCE_XMLDOCUMENT_JUCEHEADER__

/*** End of inlined file: juce_XmlDocument.h ***/


#endif
#ifndef __JUCE_XMLELEMENT_JUCEHEADER__

#endif
#ifndef __JUCE_GZIPCOMPRESSOROUTPUTSTREAM_JUCEHEADER__

/*** Start of inlined file: juce_GZIPCompressorOutputStream.h ***/
#ifndef __JUCE_GZIPCOMPRESSOROUTPUTSTREAM_JUCEHEADER__
#define __JUCE_GZIPCOMPRESSOROUTPUTSTREAM_JUCEHEADER__

/**
	A stream which uses zlib to compress the data written into it.

	Important note: When you call flush() on a GZIPCompressorOutputStream,
	the gzip data is closed - this means that no more data can be written to
	it, and any subsequent attempts to call write() will cause an assertion.

	@see GZIPDecompressorInputStream
*/
class JUCE_API  GZIPCompressorOutputStream  : public OutputStream
{
public:

	/** Creates a compression stream.

		@param destStream                       the stream into which the compressed data should
												be written
		@param compressionLevel                 how much to compress the data, between 1 and 9, where
												1 is the fastest/lowest compression, and 9 is the
												slowest/highest compression. Any value outside this range
												indicates that a default compression level should be used.
		@param deleteDestStreamWhenDestroyed    whether or not to delete the destStream object when
												this stream is destroyed
		@param windowBits                       this is used internally to change the window size used
												by zlib - leave it as 0 unless you specifically need to set
												its value for some reason
	*/
	GZIPCompressorOutputStream (OutputStream* destStream,
								int compressionLevel = 0,
								bool deleteDestStreamWhenDestroyed = false,
								int windowBits = 0);

	/** Destructor. */
	~GZIPCompressorOutputStream();

	/** Flushes and closes the stream.
		Note that unlike most streams, when you call flush() on a GZIPCompressorOutputStream,
		the stream is closed - this means that no more data can be written to it, and any
		subsequent attempts to call write() will cause an assertion.
	*/
	void flush();

	int64 getPosition();
	bool setPosition (int64 newPosition);
	bool write (const void* destBuffer, int howMany);

	/** These are preset values that can be used for the constructor's windowBits paramter.
		For more info about this, see the zlib documentation for its windowBits parameter.
	*/
	enum WindowBitsValues
	{
		windowBitsRaw = -15,
		windowBitsGZIP = 15 + 16
	};

private:

	OptionalScopedPointer<OutputStream> destStream;

	class GZIPCompressorHelper;
	friend class ScopedPointer <GZIPCompressorHelper>;
	ScopedPointer <GZIPCompressorHelper> helper;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (GZIPCompressorOutputStream);
};

#endif   // __JUCE_GZIPCOMPRESSOROUTPUTSTREAM_JUCEHEADER__

/*** End of inlined file: juce_GZIPCompressorOutputStream.h ***/


#endif
#ifndef __JUCE_GZIPDECOMPRESSORINPUTSTREAM_JUCEHEADER__

/*** Start of inlined file: juce_GZIPDecompressorInputStream.h ***/
#ifndef __JUCE_GZIPDECOMPRESSORINPUTSTREAM_JUCEHEADER__
#define __JUCE_GZIPDECOMPRESSORINPUTSTREAM_JUCEHEADER__

/**
	This stream will decompress a source-stream using zlib.

	Tip: if you're reading lots of small items from one of these streams, you
		 can increase the performance enormously by passing it through a
		 BufferedInputStream, so that it has to read larger blocks less often.

	@see GZIPCompressorOutputStream
*/
class JUCE_API  GZIPDecompressorInputStream  : public InputStream
{
public:

	/** Creates a decompressor stream.

		@param sourceStream                 the stream to read from
		@param deleteSourceWhenDestroyed    whether or not to delete the source stream
											when this object is destroyed
		@param noWrap                       this is used internally by the ZipFile class
											and should be ignored by user applications
		@param uncompressedStreamLength     if the creator knows the length that the
											uncompressed stream will be, then it can supply this
											value, which will be returned by getTotalLength()
	*/
	GZIPDecompressorInputStream (InputStream* sourceStream,
								 bool deleteSourceWhenDestroyed,
								 bool noWrap = false,
								 int64 uncompressedStreamLength = -1);

	/** Creates a decompressor stream.

		@param sourceStream     the stream to read from - the source stream must not be
								deleted until this object has been destroyed
	*/
	GZIPDecompressorInputStream (InputStream& sourceStream);

	/** Destructor. */
	~GZIPDecompressorInputStream();

	int64 getPosition();
	bool setPosition (int64 pos);
	int64 getTotalLength();
	bool isExhausted();
	int read (void* destBuffer, int maxBytesToRead);

private:
	OptionalScopedPointer<InputStream> sourceStream;
	const int64 uncompressedStreamLength;
	const bool noWrap;
	bool isEof;
	int activeBufferSize;
	int64 originalSourcePos, currentPos;
	HeapBlock <uint8> buffer;

	class GZIPDecompressHelper;
	friend class ScopedPointer <GZIPDecompressHelper>;
	ScopedPointer <GZIPDecompressHelper> helper;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (GZIPDecompressorInputStream);
};

#endif   // __JUCE_GZIPDECOMPRESSORINPUTSTREAM_JUCEHEADER__

/*** End of inlined file: juce_GZIPDecompressorInputStream.h ***/


#endif
#ifndef __JUCE_ZIPFILE_JUCEHEADER__

/*** Start of inlined file: juce_ZipFile.h ***/
#ifndef __JUCE_ZIPFILE_JUCEHEADER__
#define __JUCE_ZIPFILE_JUCEHEADER__

/**
	Decodes a ZIP file from a stream.

	This can enumerate the items in a ZIP file and can create suitable stream objects
	to read each one.
*/
class JUCE_API  ZipFile
{
public:
	/** Creates a ZipFile based for a file. */
	ZipFile (const File& file);

	/** Creates a ZipFile for a given stream.

		@param inputStream                  the stream to read from
		@param deleteStreamWhenDestroyed    if set to true, the object passed-in
											will be deleted when this ZipFile object is deleted
	*/
	ZipFile (InputStream* inputStream, bool deleteStreamWhenDestroyed);

	/** Creates a ZipFile for a given stream.
		The stream will not be owned or deleted by this class - if you want the ZipFile to
		manage the stream's lifetime, use the other constructor.
	*/
	ZipFile (InputStream& inputStream);

	/** Creates a ZipFile for an input source.

		The inputSource object will be owned by the zip file, which will delete
		it later when not needed.
	*/
	ZipFile (InputSource* inputSource);

	/** Destructor. */
	~ZipFile();

	/**
		Contains information about one of the entries in a ZipFile.

		@see ZipFile::getEntry
	*/
	struct ZipEntry
	{
		/** The name of the file, which may also include a partial pathname. */
		String filename;

		/** The file's original size. */
		unsigned int uncompressedSize;

		/** The last time the file was modified. */
		Time fileTime;
	};

	/** Returns the number of items in the zip file. */
	int getNumEntries() const noexcept;

	/** Returns a structure that describes one of the entries in the zip file.

		This may return zero if the index is out of range.

		@see ZipFile::ZipEntry
	*/
	const ZipEntry* getEntry (int index) const noexcept;

	/** Returns the index of the first entry with a given filename.

		This uses a case-sensitive comparison to look for a filename in the
		list of entries. It might return -1 if no match is found.

		@see ZipFile::ZipEntry
	*/
	int getIndexOfFileName (const String& fileName) const noexcept;

	/** Returns a structure that describes one of the entries in the zip file.

		This uses a case-sensitive comparison to look for a filename in the
		list of entries. It might return 0 if no match is found.

		@see ZipFile::ZipEntry
	*/
	const ZipEntry* getEntry (const String& fileName) const noexcept;

	/** Sorts the list of entries, based on the filename.
	*/
	void sortEntriesByFilename();

	/** Creates a stream that can read from one of the zip file's entries.

		The stream that is returned must be deleted by the caller (and
		zero might be returned if a stream can't be opened for some reason).

		The stream must not be used after the ZipFile object that created
		has been deleted.
	*/
	InputStream* createStreamForEntry (int index);

	/** Creates a stream that can read from one of the zip file's entries.

		The stream that is returned must be deleted by the caller (and
		zero might be returned if a stream can't be opened for some reason).

		The stream must not be used after the ZipFile object that created
		has been deleted.
	*/
	InputStream* createStreamForEntry (ZipEntry& entry);

	/** Uncompresses all of the files in the zip file.

		This will expand all the entries into a target directory. The relative
		paths of the entries are used.

		@param targetDirectory      the root folder to uncompress to
		@param shouldOverwriteFiles whether to overwrite existing files with similarly-named ones
		@returns success if the file is successfully unzipped
	*/
	Result uncompressTo (const File& targetDirectory,
						 bool shouldOverwriteFiles = true);

	/** Uncompresses one of the entries from the zip file.

		This will expand the entry and write it in a target directory. The entry's path is used to
		determine which subfolder of the target should contain the new file.

		@param index                the index of the entry to uncompress - this must be a valid index
									between 0 and (getNumEntries() - 1).
		@param targetDirectory      the root folder to uncompress into
		@param shouldOverwriteFiles whether to overwrite existing files with similarly-named ones
		@returns success if all the files are successfully unzipped
	*/
	Result uncompressEntry (int index,
							const File& targetDirectory,
							bool shouldOverwriteFiles = true);

	/** Used to create a new zip file.

		Create a ZipFile::Builder object, and call its addFile() method to add some files,
		then you can write it to a stream with write().

		Currently this just stores the files with no compression.. That will be added
		soon!
	*/
	class Builder
	{
	public:
		Builder();
		~Builder();

		/** Adds a file while should be added to the archive.
			The file isn't read immediately, all the files will be read later when the writeToStream()
			method is called.

			The compressionLevel can be between 0 (no compression), and 9 (maximum compression).
			If the storedPathName parameter is specified, you can customise the partial pathname that
			will be stored for this file.
		*/
		void addFile (const File& fileToAdd, int compressionLevel,
					  const String& storedPathName = String::empty);

		/** Generates the zip file, writing it to the specified stream. */
		bool writeToStream (OutputStream& target) const;

	private:
		class Item;
		friend class OwnedArray<Item>;
		OwnedArray<Item> items;

		JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (Builder);
	};

private:

	class ZipInputStream;
	class ZipEntryHolder;
	friend class ZipInputStream;
	friend class ZipEntryHolder;

	OwnedArray <ZipEntryHolder> entries;
	CriticalSection lock;
	InputStream* inputStream;
	ScopedPointer <InputStream> streamToDelete;
	ScopedPointer <InputSource> inputSource;

   #if JUCE_DEBUG
	struct OpenStreamCounter
	{
		OpenStreamCounter() : numOpenStreams (0) {}
		~OpenStreamCounter();

		int numOpenStreams;
	};

	OpenStreamCounter streamCounter;
   #endif

	void init();

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ZipFile);
};

#endif   // __JUCE_ZIPFILE_JUCEHEADER__

/*** End of inlined file: juce_ZipFile.h ***/


#endif
// END_AUTOINCLUDE

}

#if JUCE_MSVC
 #pragma warning (pop)
 #pragma pack (pop)
#endif

#endif   // __JUCE_CORE_JUCEHEADER__

/*** End of inlined file: juce_core.h ***/


/*** Start of inlined file: juce_events.h ***/
#ifndef __JUCE_EVENTS_JUCEHEADER__
#define __JUCE_EVENTS_JUCEHEADER__

namespace juce
{

// START_AUTOINCLUDE messages, broadcasters, timers,
// interprocess, native/juce_ScopedXLock*
#ifndef __JUCE_APPLICATIONBASE_JUCEHEADER__

/*** Start of inlined file: juce_ApplicationBase.h ***/
#ifndef __JUCE_APPLICATIONBASE_JUCEHEADER__
#define __JUCE_APPLICATIONBASE_JUCEHEADER__

/**
	Abstract base class for application classes.

	This class shouldn't be used directly - you'll normally use JUCEApplication as
	the base for your app, and that inherits from this, adding some more functionality
	to it.

	@see JUCEApplication
*/
class JUCE_API  JUCEApplicationBase
{
protected:

	JUCEApplicationBase();

public:
	/** Destructor. */
	virtual ~JUCEApplicationBase();

	/** Returns the global instance of the application object that's running. */
	static JUCEApplicationBase* getInstance() noexcept          { return appInstance; }

	/** Returns the application's name.
		An application must implement this to name itself.
	*/
	virtual const String getApplicationName() = 0;

	/** Returns the application's version number.
	*/
	virtual const String getApplicationVersion() = 0;

	/** Checks whether multiple instances of the app are allowed.

		If you application class returns true for this, more than one instance is
		permitted to run (except on the Mac where this isn't possible).

		If it's false, the second instance won't start, but it you will still get a
		callback to anotherInstanceStarted() to tell you about this - which
		gives you a chance to react to what the user was trying to do.
	*/
	virtual bool moreThanOneInstanceAllowed() = 0;

	/** Called when the application starts.

		This will be called once to let the application do whatever initialisation
		it needs, create its windows, etc.

		After the method returns, the normal event-dispatch loop will be run,
		until the quit() method is called, at which point the shutdown()
		method will be called to let the application clear up anything it needs
		to delete.

		If during the initialise() method, the application decides not to start-up
		after all, it can just call the quit() method and the event loop won't be run.

		@param commandLineParameters    the line passed in does not include the
										name of the executable, just the parameter list.
		@see shutdown, quit
	*/
	virtual void initialise (const String& commandLineParameters) = 0;

	/* Called to allow the application to clear up before exiting.

	   After JUCEApplication::quit() has been called, the event-dispatch loop will
	   terminate, and this method will get called to allow the app to sort itself
	   out.

	   Be careful that nothing happens in this method that might rely on messages
	   being sent, or any kind of window activity, because the message loop is no
	   longer running at this point.

		@see DeletedAtShutdown
	*/
	virtual void shutdown() = 0;

	/** Indicates that the user has tried to start up another instance of the app.

		This will get called even if moreThanOneInstanceAllowed() is false.
	*/
	virtual void anotherInstanceStarted (const String& commandLine) = 0;

	/** Called when the operating system is trying to close the application.

		The default implementation of this method is to call quit(), but it may
		be overloaded to ignore the request or do some other special behaviour
		instead. For example, you might want to offer the user the chance to save
		their changes before quitting, and give them the chance to cancel.

		If you want to send a quit signal to your app, this is the correct method
		to call, because it means that requests that come from the system get handled
		in the same way as those from your own application code. So e.g. you'd
		call this method from a "quit" item on a menu bar.
	*/
	virtual void systemRequestedQuit() = 0;

	/** If any unhandled exceptions make it through to the message dispatch loop, this
		callback will be triggered, in case you want to log them or do some other
		type of error-handling.

		If the type of exception is derived from the std::exception class, the pointer
		passed-in will be valid. If the exception is of unknown type, this pointer
		will be null.
	*/
	virtual void unhandledException (const std::exception* e,
									 const String& sourceFilename,
									 int lineNumber) = 0;

	/** Returns true if this executable is running as an app (as opposed to being a plugin
		or other kind of shared library. */
	static inline bool isStandaloneApp() noexcept                   { return createInstance != 0; }

   #ifndef DOXYGEN
	static void appWillTerminateByForce();
	typedef JUCEApplicationBase* (*CreateInstanceFunction)();
	static CreateInstanceFunction createInstance;

protected:
	virtual int shutdownApp() = 0;
   #endif

private:

	static JUCEApplicationBase* appInstance;

	JUCE_DECLARE_NON_COPYABLE (JUCEApplicationBase);
};

#endif   // __JUCE_APPLICATIONBASE_JUCEHEADER__

/*** End of inlined file: juce_ApplicationBase.h ***/


#endif
#ifndef __JUCE_CALLBACKMESSAGE_JUCEHEADER__

/*** Start of inlined file: juce_CallbackMessage.h ***/
#ifndef __JUCE_CALLBACKMESSAGE_JUCEHEADER__
#define __JUCE_CALLBACKMESSAGE_JUCEHEADER__


/*** Start of inlined file: juce_Message.h ***/
#ifndef __JUCE_MESSAGE_JUCEHEADER__
#define __JUCE_MESSAGE_JUCEHEADER__

class MessageListener;
class MessageManager;

/** The base class for objects that can be delivered to a MessageListener.

	If you want to send a message that carries some kind of custom data, just
	create a subclass of Message with some appropriate member variables to hold
	your data.

	@see MessageListener, MessageManager, ActionListener, ChangeListener
*/
class JUCE_API  Message  : public ReferenceCountedObject
{
public:

	/** Creates an uninitialised message.

		The class's variables will also be left uninitialised.
	*/
	Message() noexcept;

	/** Destructor. */
	virtual ~Message();

	/** A typedef for pointers to messages. */
	typedef ReferenceCountedObjectPtr <Message> Ptr;

private:
	friend class MessageListener;
	friend class MessageManager;
	MessageListener* messageRecipient;

	// Avoid the leak-detector because for plugins, the host can unload our DLL with undelivered
	// messages still in the system event queue. These aren't harmful, but can cause annoying assertions.
	JUCE_DECLARE_NON_COPYABLE (Message);
};

#endif   // __JUCE_MESSAGE_JUCEHEADER__

/*** End of inlined file: juce_Message.h ***/

/**
	A message that calls a custom function when it gets delivered.

	You can use this class to fire off actions that you want to be performed later
	on the message thread.

	Unlike other Message objects, these don't get sent to a MessageListener, you
	just call the post() method to send them, and when they arrive, your
	messageCallback() method will automatically be invoked.

	Always create an instance of a CallbackMessage on the heap, as it will be
	deleted automatically after the message has been delivered.

	@see MessageListener, MessageManager, ActionListener, ChangeListener
*/
class JUCE_API  CallbackMessage   : public Message
{
public:

	CallbackMessage() noexcept;

	/** Destructor. */
	~CallbackMessage();

	/** Called when the message is delivered.

		You should implement this method and make it do whatever action you want
		to perform.

		Note that like all other messages, this object will be deleted immediately
		after this method has been invoked.
	*/
	virtual void messageCallback() = 0;

	/** Instead of sending this message to a MessageListener, just call this method
		to post it to the event queue.

		After you've called this, this object will belong to the MessageManager,
		which will delete it later. So make sure you don't delete the object yourself,
		call post() more than once, or call post() on a stack-based obect!
	*/
	void post();

private:

	// Avoid the leak-detector because for plugins, the host can unload our DLL with undelivered
	// messages still in the system event queue. These aren't harmful, but can cause annoying assertions.
	JUCE_DECLARE_NON_COPYABLE (CallbackMessage);
};

#endif   // __JUCE_CALLBACKMESSAGE_JUCEHEADER__

/*** End of inlined file: juce_CallbackMessage.h ***/


#endif
#ifndef __JUCE_DELETEDATSHUTDOWN_JUCEHEADER__

/*** Start of inlined file: juce_DeletedAtShutdown.h ***/
#ifndef __JUCE_DELETEDATSHUTDOWN_JUCEHEADER__
#define __JUCE_DELETEDATSHUTDOWN_JUCEHEADER__

/**
	Classes derived from this will be automatically deleted when the application exits.

	After JUCEApplication::shutdown() has been called, any objects derived from
	DeletedAtShutdown which are still in existence will be deleted in the reverse
	order to that in which they were created.

	So if you've got a singleton and don't want to have to explicitly delete it, just
	inherit from this and it'll be taken care of.
*/
class JUCE_API  DeletedAtShutdown
{
protected:
	/** Creates a DeletedAtShutdown object. */
	DeletedAtShutdown();

	/** Destructor.

		It's ok to delete these objects explicitly - it's only the ones left
		dangling at the end that will be deleted automatically.
	*/
	virtual ~DeletedAtShutdown();

public:
	/** Deletes all extant objects.

		This shouldn't be used by applications, as it's called automatically
		in the shutdown code of the JUCEApplication class.
	*/
	static void deleteAll();

private:
	static Array <DeletedAtShutdown*>& getObjects();

	JUCE_DECLARE_NON_COPYABLE (DeletedAtShutdown);
};

#endif   // __JUCE_DELETEDATSHUTDOWN_JUCEHEADER__

/*** End of inlined file: juce_DeletedAtShutdown.h ***/


#endif
#ifndef __JUCE_MESSAGE_JUCEHEADER__

#endif
#ifndef __JUCE_MESSAGELISTENER_JUCEHEADER__

/*** Start of inlined file: juce_MessageListener.h ***/
#ifndef __JUCE_MESSAGELISTENER_JUCEHEADER__
#define __JUCE_MESSAGELISTENER_JUCEHEADER__

/**
	MessageListener subclasses can post and receive Message objects.

	@see Message, MessageManager, ActionListener, ChangeListener
*/
class JUCE_API  MessageListener
{
protected:

	/** Creates a MessageListener. */
	MessageListener() noexcept;

public:

	/** Destructor.

		When a MessageListener is deleted, it removes itself from a global list
		of registered listeners, so that the isValidMessageListener() method
		will no longer return true.
	*/
	virtual ~MessageListener();

	/** This is the callback method that receives incoming messages.

		This is called by the MessageManager from its dispatch loop.

		@see postMessage
	*/
	virtual void handleMessage (const Message& message) = 0;

	/** Sends a message to the message queue, for asynchronous delivery to this listener
		later on.

		This method can be called safely by any thread.

		@param message      the message object to send - this will be deleted
							automatically by the message queue, so don't keep any
							references to it after calling this method.
		@see handleMessage
	*/
	void postMessage (Message* message) const;

	/** Checks whether this MessageListener has been deleted.

		Although not foolproof, this method is safe to call on dangling or null
		pointers. A list of active MessageListeners is kept internally, so this
		checks whether the object is on this list or not.

		Note that it's possible to get a false-positive here, if an object is
		deleted and another is subsequently created that happens to be at the
		exact same memory location, but I can't think of a good way of avoiding
		this.
	*/
	bool isValidMessageListener() const noexcept;
};

#endif   // __JUCE_MESSAGELISTENER_JUCEHEADER__

/*** End of inlined file: juce_MessageListener.h ***/


#endif
#ifndef __JUCE_MESSAGEMANAGER_JUCEHEADER__

/*** Start of inlined file: juce_MessageManager.h ***/
#ifndef __JUCE_MESSAGEMANAGER_JUCEHEADER__
#define __JUCE_MESSAGEMANAGER_JUCEHEADER__

class MessageManagerLock;
class ThreadPoolJob;
class ActionListener;
class ActionBroadcaster;

/** See MessageManager::callFunctionOnMessageThread() for use of this function type
*/
typedef void* (MessageCallbackFunction) (void* userData);

/** Delivers Message objects to MessageListeners, and handles the event-dispatch loop.

	@see Message, MessageListener, MessageManagerLock, JUCEApplication
*/
class JUCE_API  MessageManager
{
public:

	/** Returns the global instance of the MessageManager. */
	static MessageManager* getInstance();

	/** Deletes the global MessageManager instance.
		Does nothing if no instance had been created.
	*/
	static void deleteInstance();

	/** Runs the event dispatch loop until a stop message is posted.

		This method is only intended to be run by the application's startup routine,
		as it blocks, and will only return after the stopDispatchLoop() method has been used.

		@see stopDispatchLoop
	*/
	void runDispatchLoop();

	/** Sends a signal that the dispatch loop should terminate.

		After this is called, the runDispatchLoop() or runDispatchLoopUntil() methods
		will be interrupted and will return.

		@see runDispatchLoop
	*/
	void stopDispatchLoop();

	/** Returns true if the stopDispatchLoop() method has been called.
	*/
	bool hasStopMessageBeenSent() const noexcept        { return quitMessagePosted; }

   #if JUCE_MODAL_LOOPS_PERMITTED
	/** Synchronously dispatches messages until a given time has elapsed.

		Returns false if a quit message has been posted by a call to stopDispatchLoop(),
		otherwise returns true.
	*/
	bool runDispatchLoopUntil (int millisecondsToRunFor);
   #endif

	/** Calls a function using the message-thread.

		This can be used by any thread to cause this function to be called-back
		by the message thread. If it's the message-thread that's calling this method,
		then the function will just be called; if another thread is calling, a message
		will be posted to the queue, and this method will block until that message
		is delivered, the function is called, and the result is returned.

		Be careful not to cause any deadlocks with this! It's easy to do - e.g. if the caller
		thread has a critical section locked, which an unrelated message callback then tries to lock
		before the message thread gets round to processing this callback.

		@param callback     the function to call - its signature must be @code
							void* myCallbackFunction (void*) @endcode
		@param userData     a user-defined pointer that will be passed to the function that gets called
		@returns            the value that the callback function returns.
		@see MessageManagerLock
	*/
	void* callFunctionOnMessageThread (MessageCallbackFunction* callback, void* userData);

	/** Returns true if the caller-thread is the message thread. */
	bool isThisTheMessageThread() const noexcept;

	/** Called to tell the manager that the current thread is the one that's running the dispatch loop.

		(Best to ignore this method unless you really know what you're doing..)
		@see getCurrentMessageThread
	*/
	void setCurrentThreadAsMessageThread();

	/** Returns the ID of the current message thread, as set by setCurrentMessageThread().

		(Best to ignore this method unless you really know what you're doing..)
		@see setCurrentMessageThread
	*/
	Thread::ThreadID getCurrentMessageThread() const noexcept            { return messageThreadId; }

	/** Returns true if the caller thread has currenltly got the message manager locked.

		see the MessageManagerLock class for more info about this.

		This will be true if the caller is the message thread, because that automatically
		gains a lock while a message is being dispatched.
	*/
	bool currentThreadHasLockedMessageManager() const noexcept;

	/** Sends a message to all other JUCE applications that are running.

		@param messageText      the string that will be passed to the actionListenerCallback()
								method of the broadcast listeners in the other app.
		@see registerBroadcastListener, ActionListener
	*/
	static void broadcastMessage (const String& messageText);

	/** Registers a listener to get told about broadcast messages.

		The actionListenerCallback() callback's string parameter
		is the message passed into broadcastMessage().

		@see broadcastMessage
	*/
	void registerBroadcastListener (ActionListener* listener);

	/** Deregisters a broadcast listener. */
	void deregisterBroadcastListener (ActionListener* listener);

   #ifndef DOXYGEN
	// Internal methods - do not use!
	void deliverMessage (Message*);
	void deliverBroadcastMessage (const String&);
	~MessageManager() noexcept;
   #endif

private:

	MessageManager() noexcept;

	friend class MessageListener;
	friend class ChangeBroadcaster;
	friend class ActionBroadcaster;
	friend class CallbackMessage;
	static MessageManager* instance;

	SortedSet <const MessageListener*> messageListeners;
	ScopedPointer <ActionBroadcaster> broadcaster;

	friend class JUCEApplication;
	bool quitMessagePosted, quitMessageReceived;
	Thread::ThreadID messageThreadId;

	friend class MessageManagerLock;
	Thread::ThreadID volatile threadWithLock;
	CriticalSection lockingLock;

	void postMessageToQueue (Message* message);
	static bool postMessageToSystemQueue (Message*);
	static void* exitModalLoopCallback (void*);
	static void doPlatformSpecificInitialisation();
	static void doPlatformSpecificShutdown();
	static bool dispatchNextMessageOnSystemQueue (bool returnIfNoPendingMessages);

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (MessageManager);
};

/** Used to make sure that the calling thread has exclusive access to the message loop.

	Because it's not thread-safe to call any of the Component or other UI classes
	from threads other than the message thread, one of these objects can be used to
	lock the message loop and allow this to be done. The message thread will be
	suspended for the lifetime of the MessageManagerLock object, so create one on
	the stack like this: @code
	void MyThread::run()
	{
		someData = 1234;

		const MessageManagerLock mmLock;
		// the event loop will now be locked so it's safe to make a few calls..

		myComponent->setBounds (newBounds);
		myComponent->repaint();

		// ..the event loop will now be unlocked as the MessageManagerLock goes out of scope
	}
	@endcode

	Obviously be careful not to create one of these and leave it lying around, or
	your app will grind to a halt!

	Another caveat is that using this in conjunction with other CriticalSections
	can create lots of interesting ways of producing a deadlock! In particular, if
	your message thread calls stopThread() for a thread that uses these locks,
	you'll get an (occasional) deadlock..

	@see MessageManager, MessageManager::currentThreadHasLockedMessageManager
*/
class JUCE_API MessageManagerLock
{
public:

	/** Tries to acquire a lock on the message manager.

		The constructor attempts to gain a lock on the message loop, and the lock will be
		kept for the lifetime of this object.

		Optionally, you can pass a thread object here, and while waiting to obtain the lock,
		this method will keep checking whether the thread has been given the
		Thread::signalThreadShouldExit() signal. If this happens, then it will return
		without gaining the lock. If you pass a thread, you must check whether the lock was
		successful by calling lockWasGained(). If this is false, your thread is being told to
		die, so you should take evasive action.

		If you pass nullptr for the thread object, it will wait indefinitely for the lock - be
		careful when doing this, because it's very easy to deadlock if your message thread
		attempts to call stopThread() on a thread just as that thread attempts to get the
		message lock.

		If the calling thread already has the lock, nothing will be done, so it's safe and
		quick to use these locks recursively.

		E.g.
		@code
		void run()
		{
			...

			while (! threadShouldExit())
			{
				MessageManagerLock mml (Thread::getCurrentThread());

				if (! mml.lockWasGained())
					return; // another thread is trying to kill us!

				..do some locked stuff here..
			}

			..and now the MM is now unlocked..
		}
		@endcode

	*/
	MessageManagerLock (Thread* threadToCheckForExitSignal = nullptr);

	/** This has the same behaviour as the other constructor, but takes a ThreadPoolJob
		instead of a thread.

		See the MessageManagerLock (Thread*) constructor for details on how this works.
	*/
	MessageManagerLock (ThreadPoolJob* jobToCheckForExitSignal);

	/** Releases the current thread's lock on the message manager.

		Make sure this object is created and deleted by the same thread,
		otherwise there are no guarantees what will happen!
   */
	~MessageManagerLock() noexcept;

	/** Returns true if the lock was successfully acquired.
		(See the constructor that takes a Thread for more info).
	*/
	bool lockWasGained() const noexcept                     { return locked; }

private:
	class BlockingMessage;
	friend class ReferenceCountedObjectPtr<BlockingMessage>;
	ReferenceCountedObjectPtr<BlockingMessage> blockingMessage;
	bool locked;

	bool attemptLock (Thread*, ThreadPoolJob*);

	JUCE_DECLARE_NON_COPYABLE (MessageManagerLock);
};

#endif   // __JUCE_MESSAGEMANAGER_JUCEHEADER__

/*** End of inlined file: juce_MessageManager.h ***/


#endif
#ifndef __JUCE_ACTIONBROADCASTER_JUCEHEADER__

/*** Start of inlined file: juce_ActionBroadcaster.h ***/
#ifndef __JUCE_ACTIONBROADCASTER_JUCEHEADER__
#define __JUCE_ACTIONBROADCASTER_JUCEHEADER__


/*** Start of inlined file: juce_ActionListener.h ***/
#ifndef __JUCE_ACTIONLISTENER_JUCEHEADER__
#define __JUCE_ACTIONLISTENER_JUCEHEADER__

/**
	Receives callbacks to indicate that some kind of event has occurred.

	Used by various classes, e.g. buttons when they are pressed, to tell listeners
	about something that's happened.

	@see ActionBroadcaster, ChangeListener
*/
class JUCE_API  ActionListener
{
public:
	/** Destructor. */
	virtual ~ActionListener()  {}

	/** Overridden by your subclass to receive the callback.

		@param message  the string that was specified when the event was triggered
						by a call to ActionBroadcaster::sendActionMessage()
	*/
	virtual void actionListenerCallback (const String& message) = 0;
};

#endif   // __JUCE_ACTIONLISTENER_JUCEHEADER__

/*** End of inlined file: juce_ActionListener.h ***/

/** Manages a list of ActionListeners, and can send them messages.

	To quickly add methods to your class that can add/remove action
	listeners and broadcast to them, you can derive from this.

	@see ActionListener, ChangeListener
*/
class JUCE_API  ActionBroadcaster
{
public:

	/** Creates an ActionBroadcaster. */
	ActionBroadcaster();

	/** Destructor. */
	virtual ~ActionBroadcaster();

	/** Adds a listener to the list.
		Trying to add a listener that's already on the list will have no effect.
	*/
	void addActionListener (ActionListener* listener);

	/** Removes a listener from the list.
		If the listener isn't on the list, this won't have any effect.
	*/
	void removeActionListener (ActionListener* listener);

	/** Removes all listeners from the list. */
	void removeAllActionListeners();

	/** Broadcasts a message to all the registered listeners.
		@see ActionListener::actionListenerCallback
	*/
	void sendActionMessage (const String& message) const;

private:

	class CallbackReceiver  : public MessageListener
	{
	public:
		CallbackReceiver();
		void handleMessage (const Message&);

		ActionBroadcaster* owner;
	};

	friend class CallbackReceiver;
	CallbackReceiver callback;
	SortedSet <ActionListener*> actionListeners;
	CriticalSection actionListenerLock;

	JUCE_DECLARE_NON_COPYABLE (ActionBroadcaster);
};

#endif   // __JUCE_ACTIONBROADCASTER_JUCEHEADER__

/*** End of inlined file: juce_ActionBroadcaster.h ***/


#endif
#ifndef __JUCE_ACTIONLISTENER_JUCEHEADER__

#endif
#ifndef __JUCE_ASYNCUPDATER_JUCEHEADER__

/*** Start of inlined file: juce_AsyncUpdater.h ***/
#ifndef __JUCE_ASYNCUPDATER_JUCEHEADER__
#define __JUCE_ASYNCUPDATER_JUCEHEADER__

/**
	Has a callback method that is triggered asynchronously.

	This object allows an asynchronous callback function to be triggered, for
	tasks such as coalescing multiple updates into a single callback later on.

	Basically, one or more calls to the triggerAsyncUpdate() will result in the
	message thread calling handleAsyncUpdate() as soon as it can.
*/
class JUCE_API  AsyncUpdater
{
public:

	/** Creates an AsyncUpdater object. */
	AsyncUpdater();

	/** Destructor.

		If there are any pending callbacks when the object is deleted, these are lost.
	*/
	virtual ~AsyncUpdater();

	/** Causes the callback to be triggered at a later time.

		This method returns immediately, having made sure that a callback
		to the handleAsyncUpdate() method will occur as soon as possible.

		If an update callback is already pending but hasn't happened yet, calls
		to this method will be ignored.

		It's thread-safe to call this method from any number of threads without
		needing to worry about locking.
	*/
	void triggerAsyncUpdate();

	/** This will stop any pending updates from happening.

		If called after triggerAsyncUpdate() and before the handleAsyncUpdate()
		callback happens, this will cancel the handleAsyncUpdate() callback.

		Note that this method simply cancels the next callback - if a callback is already
		in progress on a different thread, this won't block until it finishes, so there's
		no guarantee that the callback isn't still running when you return from
	*/
	void cancelPendingUpdate() noexcept;

	/** If an update has been triggered and is pending, this will invoke it
		synchronously.

		Use this as a kind of "flush" operation - if an update is pending, the
		handleAsyncUpdate() method will be called immediately; if no update is
		pending, then nothing will be done.

		Because this may invoke the callback, this method must only be called on
		the main event thread.
	*/
	void handleUpdateNowIfNeeded();

	/** Returns true if there's an update callback in the pipeline. */
	bool isUpdatePending() const noexcept;

	/** Called back to do whatever your class needs to do.

		This method is called by the message thread at the next convenient time
		after the triggerAsyncUpdate() method has been called.
	*/
	virtual void handleAsyncUpdate() = 0;

private:

	class AsyncUpdaterMessage;
	friend class ReferenceCountedObjectPtr<AsyncUpdaterMessage>;
	ReferenceCountedObjectPtr<AsyncUpdaterMessage> message;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (AsyncUpdater);
};

#endif   // __JUCE_ASYNCUPDATER_JUCEHEADER__

/*** End of inlined file: juce_AsyncUpdater.h ***/


#endif
#ifndef __JUCE_CHANGEBROADCASTER_JUCEHEADER__

/*** Start of inlined file: juce_ChangeBroadcaster.h ***/
#ifndef __JUCE_CHANGEBROADCASTER_JUCEHEADER__
#define __JUCE_CHANGEBROADCASTER_JUCEHEADER__


/*** Start of inlined file: juce_ChangeListener.h ***/
#ifndef __JUCE_CHANGELISTENER_JUCEHEADER__
#define __JUCE_CHANGELISTENER_JUCEHEADER__

class ChangeBroadcaster;

/**
	Receives change event callbacks that are sent out by a ChangeBroadcaster.

	A ChangeBroadcaster keeps a set of listeners to which it broadcasts a message when
	the ChangeBroadcaster::sendChangeMessage() method is called. A subclass of
	ChangeListener is used to receive these callbacks.

	Note that the major difference between an ActionListener and a ChangeListener
	is that for a ChangeListener, multiple changes will be coalesced into fewer
	callbacks, but ActionListeners perform one callback for every event posted.

	@see ChangeBroadcaster, ActionListener
*/
class JUCE_API  ChangeListener
{
public:
	/** Destructor. */
	virtual ~ChangeListener()  {}

	/** Your subclass should implement this method to receive the callback.
		@param source the ChangeBroadcaster that triggered the callback.
	*/
	virtual void changeListenerCallback (ChangeBroadcaster* source) = 0;

   #if JUCE_CATCH_DEPRECATED_CODE_MISUSE
	// This method's signature has changed to take a ChangeBroadcaster parameter - please update your code!
	private: virtual int changeListenerCallback (void*) { return 0; }
   #endif
};

#endif   // __JUCE_CHANGELISTENER_JUCEHEADER__

/*** End of inlined file: juce_ChangeListener.h ***/


/*** Start of inlined file: juce_ListenerList.h ***/
#ifndef __JUCE_LISTENERLIST_JUCEHEADER__
#define __JUCE_LISTENERLIST_JUCEHEADER__

/**
	Holds a set of objects and can invoke a member function callback on each object
	in the set with a single call.

	Use a ListenerList to manage a set of objects which need a callback, and you
	can invoke a member function by simply calling call() or callChecked().

	E.g.
	@code
	class MyListenerType
	{
	public:
		void myCallbackMethod (int foo, bool bar);
	};

	ListenerList <MyListenerType> listeners;
	listeners.add (someCallbackObjects...);

	// This will invoke myCallbackMethod (1234, true) on each of the objects
	// in the list...
	listeners.call (&MyListenerType::myCallbackMethod, 1234, true);
	@endcode

	If you add or remove listeners from the list during one of the callbacks - i.e. while
	it's in the middle of iterating the listeners, then it's guaranteed that no listeners
	will be mistakenly called after they've been removed, but it may mean that some of the
	listeners could be called more than once, or not at all, depending on the list's order.

	Sometimes, there's a chance that invoking one of the callbacks might result in the
	list itself being deleted while it's still iterating - to survive this situation, you can
	use callChecked() instead of call(), passing it a local object to act as a "BailOutChecker".
	The BailOutChecker must implement a method of the form "bool shouldBailOut()", and
	the list will check this after each callback to determine whether it should abort the
	operation. For an example of a bail-out checker, see the Component::BailOutChecker class,
	which can be used to check when a Component has been deleted. See also
	ListenerList::DummyBailOutChecker, which is a dummy checker that always returns false.
*/
template <class ListenerClass,
		  class ArrayType = Array <ListenerClass*> >
class ListenerList
{
	// Horrible macros required to support VC7..
	#ifndef DOXYGEN
	 #if JUCE_VC8_OR_EARLIER
	   #define LL_TEMPLATE(a)   typename P##a, typename Q##a
	   #define LL_PARAM(a)      Q##a& param##a
	 #else
	   #define LL_TEMPLATE(a)   typename P##a
	   #define LL_PARAM(a)      PARAMETER_TYPE(P##a) param##a
	 #endif
	#endif

public:

	/** Creates an empty list. */
	ListenerList()
	{
	}

	/** Destructor. */
	~ListenerList()
	{
	}

	/** Adds a listener to the list.
		A listener can only be added once, so if the listener is already in the list,
		this method has no effect.
		@see remove
	*/
	void add (ListenerClass* const listenerToAdd)
	{
		// Listeners can't be null pointers!
		jassert (listenerToAdd != nullptr);

		if (listenerToAdd != nullptr)
			listeners.addIfNotAlreadyThere (listenerToAdd);
	}

	/** Removes a listener from the list.
		If the listener wasn't in the list, this has no effect.
	*/
	void remove (ListenerClass* const listenerToRemove)
	{
		// Listeners can't be null pointers!
		jassert (listenerToRemove != nullptr);

		listeners.removeValue (listenerToRemove);
	}

	/** Returns the number of registered listeners. */
	int size() const noexcept
	{
		return listeners.size();
	}

	/** Returns true if any listeners are registered. */
	bool isEmpty() const noexcept
	{
		return listeners.size() == 0;
	}

	/** Clears the list. */
	void clear()
	{
		listeners.clear();
	}

	/** Returns true if the specified listener has been added to the list. */
	bool contains (ListenerClass* const listener) const noexcept
	{
		return listeners.contains (listener);
	}

	/** Calls a member function on each listener in the list, with no parameters. */
	void call (void (ListenerClass::*callbackFunction) ())
	{
		callChecked (static_cast <const DummyBailOutChecker&> (DummyBailOutChecker()), callbackFunction);
	}

	/** Calls a member function on each listener in the list, with no parameters and a bail-out-checker.
		See the class description for info about writing a bail-out checker. */
	template <class BailOutCheckerType>
	void callChecked (const BailOutCheckerType& bailOutChecker,
					  void (ListenerClass::*callbackFunction) ())
	{
		for (Iterator<BailOutCheckerType, ThisType> iter (*this); iter.next (bailOutChecker);)
			(iter.getListener()->*callbackFunction) ();
	}

	/** Calls a member function on each listener in the list, with 1 parameter. */
	template <LL_TEMPLATE(1)>
	void call (void (ListenerClass::*callbackFunction) (P1), LL_PARAM(1))
	{
		for (Iterator<DummyBailOutChecker, ThisType> iter (*this); iter.next();)
			(iter.getListener()->*callbackFunction) (param1);
	}

	/** Calls a member function on each listener in the list, with one parameter and a bail-out-checker.
		See the class description for info about writing a bail-out checker. */
	template <class BailOutCheckerType, LL_TEMPLATE(1)>
	void callChecked (const BailOutCheckerType& bailOutChecker,
					  void (ListenerClass::*callbackFunction) (P1),
					  LL_PARAM(1))
	{
		for (Iterator<BailOutCheckerType, ThisType> iter (*this); iter.next (bailOutChecker);)
			(iter.getListener()->*callbackFunction) (param1);
	}

	/** Calls a member function on each listener in the list, with 2 parameters. */
	template <LL_TEMPLATE(1), LL_TEMPLATE(2)>
	void call (void (ListenerClass::*callbackFunction) (P1, P2),
			   LL_PARAM(1), LL_PARAM(2))
	{
		for (Iterator<DummyBailOutChecker, ThisType> iter (*this); iter.next();)
			(iter.getListener()->*callbackFunction) (param1, param2);
	}

	/** Calls a member function on each listener in the list, with 2 parameters and a bail-out-checker.
		See the class description for info about writing a bail-out checker. */
	template <class BailOutCheckerType, LL_TEMPLATE(1), LL_TEMPLATE(2)>
	void callChecked (const BailOutCheckerType& bailOutChecker,
					  void (ListenerClass::*callbackFunction) (P1, P2),
					  LL_PARAM(1), LL_PARAM(2))
	{
		for (Iterator<BailOutCheckerType, ThisType> iter (*this); iter.next (bailOutChecker);)
			(iter.getListener()->*callbackFunction) (param1, param2);
	}

	/** Calls a member function on each listener in the list, with 3 parameters. */
	template <LL_TEMPLATE(1), LL_TEMPLATE(2), LL_TEMPLATE(3)>
	void call (void (ListenerClass::*callbackFunction) (P1, P2, P3),
			   LL_PARAM(1), LL_PARAM(2), LL_PARAM(3))
	{
		for (Iterator<DummyBailOutChecker, ThisType> iter (*this); iter.next();)
			(iter.getListener()->*callbackFunction) (param1, param2, param3);
	}

	/** Calls a member function on each listener in the list, with 3 parameters and a bail-out-checker.
		See the class description for info about writing a bail-out checker. */
	template <class BailOutCheckerType, LL_TEMPLATE(1), LL_TEMPLATE(2), LL_TEMPLATE(3)>
	void callChecked (const BailOutCheckerType& bailOutChecker,
					  void (ListenerClass::*callbackFunction) (P1, P2, P3),
					  LL_PARAM(1), LL_PARAM(2), LL_PARAM(3))
	{
		for (Iterator<BailOutCheckerType, ThisType> iter (*this); iter.next (bailOutChecker);)
			(iter.getListener()->*callbackFunction) (param1, param2, param3);
	}

	/** Calls a member function on each listener in the list, with 4 parameters. */
	template <LL_TEMPLATE(1), LL_TEMPLATE(2), LL_TEMPLATE(3), LL_TEMPLATE(4)>
	void call (void (ListenerClass::*callbackFunction) (P1, P2, P3, P4),
			   LL_PARAM(1), LL_PARAM(2), LL_PARAM(3), LL_PARAM(4))
	{
		for (Iterator<DummyBailOutChecker, ThisType> iter (*this); iter.next();)
			(iter.getListener()->*callbackFunction) (param1, param2, param3, param4);
	}

	/** Calls a member function on each listener in the list, with 4 parameters and a bail-out-checker.
		See the class description for info about writing a bail-out checker. */
	template <class BailOutCheckerType, LL_TEMPLATE(1), LL_TEMPLATE(2), LL_TEMPLATE(3), LL_TEMPLATE(4)>
	void callChecked (const BailOutCheckerType& bailOutChecker,
					  void (ListenerClass::*callbackFunction) (P1, P2, P3, P4),
					  LL_PARAM(1), LL_PARAM(2), LL_PARAM(3), LL_PARAM(4))
	{
		for (Iterator<BailOutCheckerType, ThisType> iter (*this); iter.next (bailOutChecker);)
			(iter.getListener()->*callbackFunction) (param1, param2, param3, param4);
	}

	/** Calls a member function on each listener in the list, with 5 parameters. */
	template <LL_TEMPLATE(1), LL_TEMPLATE(2), LL_TEMPLATE(3), LL_TEMPLATE(4), LL_TEMPLATE(5)>
	void call (void (ListenerClass::*callbackFunction) (P1, P2, P3, P4, P5),
			   LL_PARAM(1), LL_PARAM(2), LL_PARAM(3), LL_PARAM(4), LL_PARAM(5))
	{
		for (Iterator<DummyBailOutChecker, ThisType> iter (*this); iter.next();)
			(iter.getListener()->*callbackFunction) (param1, param2, param3, param4, param5);
	}

	/** Calls a member function on each listener in the list, with 5 parameters and a bail-out-checker.
		See the class description for info about writing a bail-out checker. */
	template <class BailOutCheckerType, LL_TEMPLATE(1), LL_TEMPLATE(2), LL_TEMPLATE(3), LL_TEMPLATE(4), LL_TEMPLATE(5)>
	void callChecked (const BailOutCheckerType& bailOutChecker,
					  void (ListenerClass::*callbackFunction) (P1, P2, P3, P4, P5),
					  LL_PARAM(1), LL_PARAM(2), LL_PARAM(3), LL_PARAM(4), LL_PARAM(5))
	{
		for (Iterator<BailOutCheckerType, ThisType> iter (*this); iter.next (bailOutChecker);)
			(iter.getListener()->*callbackFunction) (param1, param2, param3, param4, param5);
	}

	/** A dummy bail-out checker that always returns false.
		See the ListenerList notes for more info about bail-out checkers.
	*/
	class DummyBailOutChecker
	{
	public:
		inline bool shouldBailOut() const noexcept     { return false; }
	};

	/** Iterates the listeners in a ListenerList. */
	template <class BailOutCheckerType, class ListType>
	class Iterator
	{
	public:

		Iterator (const ListType& list_) noexcept
			: list (list_), index (list_.size())
		{}

		~Iterator() noexcept {}

		bool next() noexcept
		{
			if (index <= 0)
				return false;

			const int listSize = list.size();

			if (--index < listSize)
				return true;

			index = listSize - 1;
			return index >= 0;
		}

		bool next (const BailOutCheckerType& bailOutChecker) noexcept
		{
			return (! bailOutChecker.shouldBailOut()) && next();
		}

		typename ListType::ListenerType* getListener() const noexcept
		{
			return list.getListeners().getUnchecked (index);
		}

	private:
		const ListType& list;
		int index;

		JUCE_DECLARE_NON_COPYABLE (Iterator);
	};

	typedef ListenerList<ListenerClass, ArrayType> ThisType;
	typedef ListenerClass ListenerType;

	const ArrayType& getListeners() const noexcept          { return listeners; }

private:

	ArrayType listeners;

	JUCE_DECLARE_NON_COPYABLE (ListenerList);

	#undef LL_TEMPLATE
	#undef LL_PARAM
};

#endif   // __JUCE_LISTENERLIST_JUCEHEADER__

/*** End of inlined file: juce_ListenerList.h ***/

/**
	Holds a list of ChangeListeners, and sends messages to them when instructed.

	@see ChangeListener
*/
class JUCE_API  ChangeBroadcaster
{
public:

	/** Creates an ChangeBroadcaster. */
	ChangeBroadcaster() noexcept;

	/** Destructor. */
	virtual ~ChangeBroadcaster();

	/** Registers a listener to receive change callbacks from this broadcaster.
		Trying to add a listener that's already on the list will have no effect.
	*/
	void addChangeListener (ChangeListener* listener);

	/** Unregisters a listener from the list.
		If the listener isn't on the list, this won't have any effect.
	*/
	void removeChangeListener (ChangeListener* listener);

	/** Removes all listeners from the list. */
	void removeAllChangeListeners();

	/** Causes an asynchronous change message to be sent to all the registered listeners.

		The message will be delivered asynchronously by the main message thread, so this
		method will return immediately. To call the listeners synchronously use
		sendSynchronousChangeMessage().
	*/
	void sendChangeMessage();

	/** Sends a synchronous change message to all the registered listeners.

		This will immediately call all the listeners that are registered. For thread-safety
		reasons, you must only call this method on the main message thread.

		@see dispatchPendingMessages
	*/
	void sendSynchronousChangeMessage();

	/** If a change message has been sent but not yet dispatched, this will call
		sendSynchronousChangeMessage() to make the callback immediately.

		For thread-safety reasons, you must only call this method on the main message thread.
	*/
	void dispatchPendingMessages();

private:

	class ChangeBroadcasterCallback  : public AsyncUpdater
	{
	public:
		ChangeBroadcasterCallback();
		void handleAsyncUpdate();

		ChangeBroadcaster* owner;
	};

	friend class ChangeBroadcasterCallback;
	ChangeBroadcasterCallback callback;
	ListenerList <ChangeListener> changeListeners;

	void callListeners();

	JUCE_DECLARE_NON_COPYABLE (ChangeBroadcaster);
};

#endif   // __JUCE_CHANGEBROADCASTER_JUCEHEADER__

/*** End of inlined file: juce_ChangeBroadcaster.h ***/


#endif
#ifndef __JUCE_CHANGELISTENER_JUCEHEADER__

#endif
#ifndef __JUCE_LISTENERLIST_JUCEHEADER__

#endif
#ifndef __JUCE_MULTITIMER_JUCEHEADER__

/*** Start of inlined file: juce_MultiTimer.h ***/
#ifndef __JUCE_MULTITIMER_JUCEHEADER__
#define __JUCE_MULTITIMER_JUCEHEADER__


/*** Start of inlined file: juce_Timer.h ***/
#ifndef __JUCE_TIMER_JUCEHEADER__
#define __JUCE_TIMER_JUCEHEADER__

/**
	Makes repeated callbacks to a virtual method at a specified time interval.

	A Timer's timerCallback() method will be repeatedly called at a given
	interval. When you create a Timer object, it will do nothing until the
	startTimer() method is called, which will cause the message thread to
	start making callbacks at the specified interval, until stopTimer() is called
	or the object is deleted.

	The time interval isn't guaranteed to be precise to any more than maybe
	10-20ms, and the intervals may end up being much longer than requested if the
	system is busy. Because the callbacks are made by the main message thread,
	anything that blocks the message queue for a period of time will also prevent
	any timers from running until it can carry on.

	If you need to have a single callback that is shared by multiple timers with
	different frequencies, then the MultiTimer class allows you to do that - its
	structure is very similar to the Timer class, but contains multiple timers
	internally, each one identified by an ID number.

	@see MultiTimer
*/
class JUCE_API  Timer
{
protected:

	/** Creates a Timer.

		When created, the timer is stopped, so use startTimer() to get it going.
	*/
	Timer() noexcept;

	/** Creates a copy of another timer.

		Note that this timer won't be started, even if the one you're copying
		is running.
	*/
	Timer (const Timer& other) noexcept;

public:

	/** Destructor. */
	virtual ~Timer();

	/** The user-defined callback routine that actually gets called periodically.

		It's perfectly ok to call startTimer() or stopTimer() from within this
		callback to change the subsequent intervals.
	*/
	virtual void timerCallback() = 0;

	/** Starts the timer and sets the length of interval required.

		If the timer is already started, this will reset it, so the
		time between calling this method and the next timer callback
		will not be less than the interval length passed in.

		@param  intervalInMilliseconds  the interval to use (any values less than 1 will be
										rounded up to 1)
	*/
	void startTimer (int intervalInMilliseconds) noexcept;

	/** Stops the timer.

		No more callbacks will be made after this method returns.

		If this is called from a different thread, any callbacks that may
		be currently executing may be allowed to finish before the method
		returns.
	*/
	void stopTimer() noexcept;

	/** Checks if the timer has been started.

		@returns true if the timer is running.
	*/
	bool isTimerRunning() const noexcept                    { return periodMs > 0; }

	/** Returns the timer's interval.

		@returns the timer's interval in milliseconds if it's running, or 0 if it's not.
	*/
	int getTimerInterval() const noexcept                   { return periodMs; }

	/** For internal use only: invokes any timers that need callbacks.
		Don't call this unless you really know what you're doing!
	*/
	static void JUCE_CALLTYPE callPendingTimersSynchronously();

private:
	class TimerThread;
	friend class TimerThread;
	int countdownMs, periodMs;
	Timer* previous;
	Timer* next;

	Timer& operator= (const Timer&);
};

#endif   // __JUCE_TIMER_JUCEHEADER__

/*** End of inlined file: juce_Timer.h ***/

/**
	A type of timer class that can run multiple timers with different frequencies,
	all of which share a single callback.

	This class is very similar to the Timer class, but allows you run multiple
	separate timers, where each one has a unique ID number. The methods in this
	class are exactly equivalent to those in Timer, but with the addition of
	this ID number.

	To use it, you need to create a subclass of MultiTimer, implementing the
	timerCallback() method. Then you can start timers with startTimer(), and
	each time the callback is triggered, it passes in the ID of the timer that
	caused it.

	@see Timer
*/
class JUCE_API  MultiTimer
{
protected:

	/** Creates a MultiTimer.

		When created, no timers are running, so use startTimer() to start things off.
	*/
	MultiTimer() noexcept;

	/** Creates a copy of another timer.

		Note that this timer will not contain any running timers, even if the one you're
		copying from was running.
	*/
	MultiTimer (const MultiTimer& other) noexcept;

public:

	/** Destructor. */
	virtual ~MultiTimer();

	/** The user-defined callback routine that actually gets called by each of the
		timers that are running.

		It's perfectly ok to call startTimer() or stopTimer() from within this
		callback to change the subsequent intervals.
	*/
	virtual void timerCallback (int timerId) = 0;

	/** Starts a timer and sets the length of interval required.

		If the timer is already started, this will reset it, so the
		time between calling this method and the next timer callback
		will not be less than the interval length passed in.

		@param timerId                  a unique Id number that identifies the timer to
										start. This is the id that will be passed back
										to the timerCallback() method when this timer is
										triggered
		@param  intervalInMilliseconds  the interval to use (any values less than 1 will be
										rounded up to 1)
	*/
	void startTimer (int timerId, int intervalInMilliseconds) noexcept;

	/** Stops a timer.

		If a timer has been started with the given ID number, it will be cancelled.
		No more callbacks will be made for the specified timer after this method returns.

		If this is called from a different thread, any callbacks that may
		be currently executing may be allowed to finish before the method
		returns.
	*/
	void stopTimer (int timerId) noexcept;

	/** Checks whether a timer has been started for a specified ID.

		@returns true if a timer with the given ID is running.
	*/
	bool isTimerRunning (int timerId) const noexcept;

	/** Returns the interval for a specified timer ID.

		@returns    the timer's interval in milliseconds if it's running, or 0 if it's no timer
					is running for the ID number specified.
	*/
	int getTimerInterval (int timerId) const noexcept;

private:
	class MultiTimerCallback;
	SpinLock timerListLock;
	OwnedArray <MultiTimerCallback> timers;

	MultiTimer& operator= (const MultiTimer&);
};

#endif   // __JUCE_MULTITIMER_JUCEHEADER__

/*** End of inlined file: juce_MultiTimer.h ***/


#endif
#ifndef __JUCE_TIMER_JUCEHEADER__

#endif
#ifndef __JUCE_INTERPROCESSCONNECTION_JUCEHEADER__

/*** Start of inlined file: juce_InterprocessConnection.h ***/
#ifndef __JUCE_INTERPROCESSCONNECTION_JUCEHEADER__
#define __JUCE_INTERPROCESSCONNECTION_JUCEHEADER__

class InterprocessConnectionServer;
class MemoryBlock;

/**
	Manages a simple two-way messaging connection to another process, using either
	a socket or a named pipe as the transport medium.

	To connect to a waiting socket or an open pipe, use the connectToSocket() or
	connectToPipe() methods. If this succeeds, messages can be sent to the other end,
	and incoming messages will result in a callback via the messageReceived()
	method.

	To open a pipe and wait for another client to connect to it, use the createPipe()
	method.

	To act as a socket server and create connections for one or more client, see the
	InterprocessConnectionServer class.

	@see InterprocessConnectionServer, Socket, NamedPipe
*/
class JUCE_API  InterprocessConnection    : public Thread,
											private MessageListener
{
public:

	/** Creates a connection.

		Connections are created manually, connecting them with the connectToSocket()
		or connectToPipe() methods, or they are created automatically by a InterprocessConnectionServer
		when a client wants to connect.

		@param callbacksOnMessageThread     if true, callbacks to the connectionMade(),
											connectionLost() and messageReceived() methods will
											always be made using the message thread; if false,
											these will be called immediately on the connection's
											own thread.
		@param magicMessageHeaderNumber     a magic number to use in the header to check the
											validity of the data blocks being sent and received. This
											can be any number, but the sender and receiver must obviously
											use matching values or they won't recognise each other.
	*/
	InterprocessConnection (bool callbacksOnMessageThread = true,
							uint32 magicMessageHeaderNumber = 0xf2b49e2c);

	/** Destructor. */
	~InterprocessConnection();

	/** Tries to connect this object to a socket.

		For this to work, the machine on the other end needs to have a InterprocessConnectionServer
		object waiting to receive client connections on this port number.

		@param hostName             the host computer, either a network address or name
		@param portNumber           the socket port number to try to connect to
		@param timeOutMillisecs     how long to keep trying before giving up
		@returns true if the connection is established successfully
		@see Socket
	*/
	bool connectToSocket (const String& hostName,
						  int portNumber,
						  int timeOutMillisecs);

	/** Tries to connect the object to an existing named pipe.

		For this to work, another process on the same computer must already have opened
		an InterprocessConnection object and used createPipe() to create a pipe for this
		to connect to.

		You can optionally specify a timeout length to be passed to the NamedPipe::read() method.

		@returns true if it connects successfully.
		@see createPipe, NamedPipe
	*/
	bool connectToPipe (const String& pipeName,
						int pipeReceiveMessageTimeoutMs = -1);

	/** Tries to create a new pipe for other processes to connect to.

		This creates a pipe with the given name, so that other processes can use
		connectToPipe() to connect to the other end.

		You can optionally specify a timeout length to be passed to the NamedPipe::read() method.

		If another process is already using this pipe, this will fail and return false.
	*/
	bool createPipe (const String& pipeName,
					 int pipeReceiveMessageTimeoutMs = -1);

	/** Disconnects and closes any currently-open sockets or pipes. */
	void disconnect();

	/** True if a socket or pipe is currently active. */
	bool isConnected() const;

	/** Returns the socket that this connection is using (or null if it uses a pipe). */
	StreamingSocket* getSocket() const noexcept                 { return socket; }

	/** Returns the pipe that this connection is using (or null if it uses a socket). */
	NamedPipe* getPipe() const noexcept                         { return pipe; }

	/** Returns the name of the machine at the other end of this connection.

		This will return an empty string if the other machine isn't known for
		some reason.
	*/
	String getConnectedHostName() const;

	/** Tries to send a message to the other end of this connection.

		This will fail if it's not connected, or if there's some kind of write error. If
		it succeeds, the connection object at the other end will receive the message by
		a callback to its messageReceived() method.

		@see messageReceived
	*/
	bool sendMessage (const MemoryBlock& message);

	/** Called when the connection is first connected.

		If the connection was created with the callbacksOnMessageThread flag set, then
		this will be called on the message thread; otherwise it will be called on a server
		thread.
	*/
	virtual void connectionMade() = 0;

	/** Called when the connection is broken.

		If the connection was created with the callbacksOnMessageThread flag set, then
		this will be called on the message thread; otherwise it will be called on a server
		thread.
	*/
	virtual void connectionLost() = 0;

	/** Called when a message arrives.

		When the object at the other end of this connection sends us a message with sendMessage(),
		this callback is used to deliver it to us.

		If the connection was created with the callbacksOnMessageThread flag set, then
		this will be called on the message thread; otherwise it will be called on a server
		thread.

		@see sendMessage
	*/
	virtual void messageReceived (const MemoryBlock& message) = 0;

private:

	CriticalSection pipeAndSocketLock;
	ScopedPointer <StreamingSocket> socket;
	ScopedPointer <NamedPipe> pipe;
	bool callbackConnectionState;
	const bool useMessageThread;
	const uint32 magicMessageHeader;
	int pipeReceiveMessageTimeout;

	friend class InterprocessConnectionServer;

	void initialiseWithSocket (StreamingSocket* socket_);
	void initialiseWithPipe (NamedPipe* pipe_);

	void handleMessage (const Message& message);

	void connectionMadeInt();
	void connectionLostInt();
	void deliverDataInt (const MemoryBlock& data);

	bool readNextMessageInt();
	void run();

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (InterprocessConnection);
};

#endif   // __JUCE_INTERPROCESSCONNECTION_JUCEHEADER__

/*** End of inlined file: juce_InterprocessConnection.h ***/


#endif
#ifndef __JUCE_INTERPROCESSCONNECTIONSERVER_JUCEHEADER__

/*** Start of inlined file: juce_InterprocessConnectionServer.h ***/
#ifndef __JUCE_INTERPROCESSCONNECTIONSERVER_JUCEHEADER__
#define __JUCE_INTERPROCESSCONNECTIONSERVER_JUCEHEADER__

/**
	An object that waits for client sockets to connect to a port on this host, and
	creates InterprocessConnection objects for each one.

	To use this, create a class derived from it which implements the createConnectionObject()
	method, so that it creates suitable connection objects for each client that tries
	to connect.

	@see InterprocessConnection
*/
class JUCE_API  InterprocessConnectionServer    : private Thread
{
public:

	/** Creates an uninitialised server object.
	*/
	InterprocessConnectionServer();

	/** Destructor. */
	~InterprocessConnectionServer();

	/** Starts an internal thread which listens on the given port number.

		While this is running, in another process tries to connect with the
		InterprocessConnection::connectToSocket() method, this object will call
		createConnectionObject() to create a connection to that client.

		Use stop() to stop the thread running.

		@see createConnectionObject, stop
	*/
	bool beginWaitingForSocket (int portNumber);

	/** Terminates the listener thread, if it's active.

		@see beginWaitingForSocket
	*/
	void stop();

protected:
	/** Creates a suitable connection object for a client process that wants to
		connect to this one.

		This will be called by the listener thread when a client process tries
		to connect, and must return a new InterprocessConnection object that will
		then run as this end of the connection.

		@see InterprocessConnection
	*/
	virtual InterprocessConnection* createConnectionObject() = 0;

private:

	ScopedPointer <StreamingSocket> socket;

	void run();

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (InterprocessConnectionServer);
};

#endif   // __JUCE_INTERPROCESSCONNECTIONSERVER_JUCEHEADER__

/*** End of inlined file: juce_InterprocessConnectionServer.h ***/


#endif
#ifndef __JUCE_SCOPEDXLOCK_JUCEHEADER__

/*** Start of inlined file: juce_ScopedXLock.h ***/
#ifndef __JUCE_SCOPEDXLOCK_JUCEHEADER__
#define __JUCE_SCOPEDXLOCK_JUCEHEADER__

#if JUCE_LINUX || DOXYGEN

/** A handy class that uses XLockDisplay and XUnlockDisplay to lock the X server
	using RAII (Only available in Linux!).
*/
class ScopedXLock
{
public:
	/** Creating a ScopedXLock object locks the X display.
		This uses XLockDisplay() to grab the display that Juce is using.
	*/
	ScopedXLock();

	/** Deleting a ScopedXLock object unlocks the X display.
		This calls XUnlockDisplay() to release the lock.
	*/
	~ScopedXLock();
};

#endif
#endif   // __JUCE_SCOPEDXLOCK_JUCEHEADER__

/*** End of inlined file: juce_ScopedXLock.h ***/


#endif
// END_AUTOINCLUDE

}

#endif   // __JUCE_EVENTS_JUCEHEADER__

/*** End of inlined file: juce_events.h ***/

/** Config: JUCE_USE_COREIMAGE_LOADER

	On OSX, enabling this flag means that the CoreImage codecs will be used to load
	PNG/JPEG/GIF files. It is enabled by default, but you may want to disable it if
	you'd rather use libpng, libjpeg, etc.
*/
#ifndef JUCE_USE_COREIMAGE_LOADER
 #define JUCE_USE_COREIMAGE_LOADER 1
#endif

/** Config: JUCE_USE_DIRECTWRITE

	Enabling this flag means that DirectWrite will be used when available for font
	management and layout.
*/
#ifndef JUCE_USE_DIRECTWRITE
 #define JUCE_USE_DIRECTWRITE 1
#endif

#ifndef JUCE_INCLUDE_PNGLIB_CODE
 #define JUCE_INCLUDE_PNGLIB_CODE 1
#endif

#ifndef JUCE_INCLUDE_JPEGLIB_CODE
 #define JUCE_INCLUDE_JPEGLIB_CODE 1
#endif

#ifndef USE_COREGRAPHICS_RENDERING
 #define USE_COREGRAPHICS_RENDERING 1
#endif

namespace juce
{

// START_AUTOINCLUDE colour, geometry, placement, contexts, images,
// image_formats, fonts, effects
#ifndef __JUCE_COLOUR_JUCEHEADER__

/*** Start of inlined file: juce_Colour.h ***/
#ifndef __JUCE_COLOUR_JUCEHEADER__
#define __JUCE_COLOUR_JUCEHEADER__


/*** Start of inlined file: juce_PixelFormats.h ***/
#ifndef __JUCE_PIXELFORMATS_JUCEHEADER__
#define __JUCE_PIXELFORMATS_JUCEHEADER__

#ifndef DOXYGEN
 #if JUCE_MSVC
  #pragma pack (push, 1)
  #define PACKED
 #elif JUCE_GCC
  #define PACKED __attribute__((packed))
 #else
  #define PACKED
 #endif
#endif

class PixelRGB;
class PixelAlpha;

/**
	Represents a 32-bit ARGB pixel with premultiplied alpha, and can perform compositing
	operations with it.

	This is used internally by the imaging classes.

	@see PixelRGB
*/
class JUCE_API  PixelARGB
{
public:
	/** Creates a pixel without defining its colour. */
	PixelARGB() noexcept {}
	~PixelARGB() noexcept {}

	/** Creates a pixel from a 32-bit argb value.
	*/
	PixelARGB (const uint32 argb_) noexcept
		: argb (argb_)
	{
	}

	PixelARGB (const uint8 a, const uint8 r, const uint8 g, const uint8 b) noexcept
	{
		components.b = b;
		components.g = g;
		components.r = r;
		components.a = a;
	}

	forcedinline uint32 getARGB() const noexcept                { return argb; }
	forcedinline uint32 getUnpremultipliedARGB() const noexcept { PixelARGB p (argb); p.unpremultiply(); return p.getARGB(); }

	forcedinline uint32 getRB() const noexcept      { return 0x00ff00ff & argb; }
	forcedinline uint32 getAG() const noexcept      { return 0x00ff00ff & (argb >> 8); }

	forcedinline uint8 getAlpha() const noexcept    { return components.a; }
	forcedinline uint8 getRed() const noexcept      { return components.r; }
	forcedinline uint8 getGreen() const noexcept    { return components.g; }
	forcedinline uint8 getBlue() const noexcept     { return components.b; }

	/** Blends another pixel onto this one.

		This takes into account the opacity of the pixel being overlaid, and blends
		it accordingly.
	*/
	template <class Pixel>
	forcedinline void blend (const Pixel& src) noexcept
	{
		uint32 sargb = src.getARGB();
		const uint32 alpha = 0x100 - (sargb >> 24);

		sargb += 0x00ff00ff & ((getRB() * alpha) >> 8);
		sargb += 0xff00ff00 & (getAG() * alpha);

		argb = sargb;
	}

	/** Blends another pixel onto this one.

		This takes into account the opacity of the pixel being overlaid, and blends
		it accordingly.
	*/
	forcedinline void blend (const PixelRGB& src) noexcept;

	/** Blends another pixel onto this one, applying an extra multiplier to its opacity.

		The opacity of the pixel being overlaid is scaled by the extraAlpha factor before
		being used, so this can blend semi-transparently from a PixelRGB argument.
	*/
	template <class Pixel>
	forcedinline void blend (const Pixel& src, uint32 extraAlpha) noexcept
	{
		++extraAlpha;

		uint32 sargb = ((extraAlpha * src.getAG()) & 0xff00ff00)
						 | (((extraAlpha * src.getRB()) >> 8) & 0x00ff00ff);

		const uint32 alpha = 0x100 - (sargb >> 24);

		sargb += 0x00ff00ff & ((getRB() * alpha) >> 8);
		sargb += 0xff00ff00 & (getAG() * alpha);

		argb = sargb;
	}

	/** Blends another pixel with this one, creating a colour that is somewhere
		between the two, as specified by the amount.
	*/
	template <class Pixel>
	forcedinline void tween (const Pixel& src, const uint32 amount) noexcept
	{
		uint32 drb = getRB();
		drb += (((src.getRB() - drb) * amount) >> 8);
		drb &= 0x00ff00ff;

		uint32 dag = getAG();
		dag += (((src.getAG() - dag) * amount) >> 8);
		dag &= 0x00ff00ff;
		dag <<= 8;

		dag |= drb;
		argb = dag;
	}

	/** Copies another pixel colour over this one.

		This doesn't blend it - this colour is simply replaced by the other one.
	*/
	template <class Pixel>
	forcedinline void set (const Pixel& src) noexcept
	{
		argb = src.getARGB();
	}

	/** Replaces the colour's alpha value with another one. */
	forcedinline void setAlpha (const uint8 newAlpha) noexcept
	{
		components.a = newAlpha;
	}

	/** Multiplies the colour's alpha value with another one. */
	forcedinline void multiplyAlpha (int multiplier) noexcept
	{
		++multiplier;

		argb = ((multiplier * getAG()) & 0xff00ff00)
				| (((multiplier * getRB()) >> 8) & 0x00ff00ff);
	}

	forcedinline void multiplyAlpha (const float multiplier) noexcept
	{
		multiplyAlpha ((int) (multiplier * 255.0f));
	}

	/** Sets the pixel's colour from individual components. */
	void setARGB (const uint8 a, const uint8 r, const uint8 g, const uint8 b) noexcept
	{
		components.b = b;
		components.g = g;
		components.r = r;
		components.a = a;
	}

	/** Premultiplies the pixel's RGB values by its alpha. */
	forcedinline void premultiply() noexcept
	{
		const uint32 alpha = components.a;

		if (alpha < 0xff)
		{
			if (alpha == 0)
			{
				components.b = 0;
				components.g = 0;
				components.r = 0;
			}
			else
			{
				components.b = (uint8) ((components.b * alpha + 0x7f) >> 8);
				components.g = (uint8) ((components.g * alpha + 0x7f) >> 8);
				components.r = (uint8) ((components.r * alpha + 0x7f) >> 8);
			}
		}
	}

	/** Unpremultiplies the pixel's RGB values. */
	forcedinline void unpremultiply() noexcept
	{
		const uint32 alpha = components.a;

		if (alpha < 0xff)
		{
			if (alpha == 0)
			{
				components.b = 0;
				components.g = 0;
				components.r = 0;
			}
			else
			{
				components.b = (uint8) jmin ((uint32) 0xff, (components.b * 0xff) / alpha);
				components.g = (uint8) jmin ((uint32) 0xff, (components.g * 0xff) / alpha);
				components.r = (uint8) jmin ((uint32) 0xff, (components.r * 0xff) / alpha);
			}
		}
	}

	forcedinline void desaturate() noexcept
	{
		if (components.a < 0xff && components.a > 0)
		{
			const int newUnpremultipliedLevel = (0xff * ((int) components.r + (int) components.g + (int) components.b) / (3 * components.a));

			components.r = components.g = components.b
				= (uint8) ((newUnpremultipliedLevel * components.a + 0x7f) >> 8);
		}
		else
		{
			components.r = components.g = components.b
				= (uint8) (((int) components.r + (int) components.g + (int) components.b) / 3);
		}
	}

	/** Returns a uint32 which when written to memory, will be in the order r, g, b, a. */
	inline uint32 getInRGBAMemoryOrder() const noexcept
	{
	   #if JUCE_BIG_ENDIAN
		return (((uint32) components.r) << 24) | (((uint32) components.g) << 16) | (((uint32) components.b) << 8) | components.a;
	   #else
		return (((uint32) components.a) << 24) | (((uint32) components.b) << 16) | (((uint32) components.g) << 8) | components.r;
	   #endif
	}

	/** The indexes of the different components in the byte layout of this type of colour. */
   #if JUCE_BIG_ENDIAN
	enum { indexA = 0, indexR = 1, indexG = 2, indexB = 3 };
   #else
	enum { indexA = 3, indexR = 2, indexG = 1, indexB = 0 };
   #endif

private:

	struct Components
	{
	   #if JUCE_BIG_ENDIAN
		uint8 a : 8, r : 8, g : 8, b : 8;
	   #else
		uint8 b, g, r, a;
	   #endif
	} PACKED;

	union
	{
		uint32 argb;
		Components components;
	};
}
#ifndef DOXYGEN
 PACKED
#endif
;

/**
	Represents a 24-bit RGB pixel, and can perform compositing operations on it.

	This is used internally by the imaging classes.

	@see PixelARGB
*/
class JUCE_API  PixelRGB
{
public:
	/** Creates a pixel without defining its colour. */
	PixelRGB() noexcept {}
	~PixelRGB() noexcept {}

	/** Creates a pixel from a 32-bit argb value.

		(The argb format is that used by PixelARGB)
	*/
	PixelRGB (const uint32 argb) noexcept
	{
		r = (uint8) (argb >> 16);
		g = (uint8) (argb >> 8);
		b = (uint8) (argb);
	}

	forcedinline uint32 getARGB() const noexcept                { return 0xff000000 | b | (g << 8) | (r << 16); }
	forcedinline uint32 getUnpremultipliedARGB() const noexcept { return getARGB(); }

	forcedinline uint32 getRB() const noexcept      { return b | (uint32) (r << 16); }
	forcedinline uint32 getAG() const noexcept      { return (uint32) (0xff0000 | g); }

	forcedinline uint8 getAlpha() const noexcept    { return 0xff; }
	forcedinline uint8 getRed() const noexcept      { return r; }
	forcedinline uint8 getGreen() const noexcept    { return g; }
	forcedinline uint8 getBlue() const noexcept     { return b; }

	/** Blends another pixel onto this one.

		This takes into account the opacity of the pixel being overlaid, and blends
		it accordingly.
	*/
	template <class Pixel>
	forcedinline void blend (const Pixel& src) noexcept
	{
		uint32 sargb = src.getARGB();
		const uint32 alpha = 0x100 - (sargb >> 24);

		sargb += 0x00ff00ff & ((getRB() * alpha) >> 8);
		sargb += 0x0000ff00 & (g * alpha);

		r = (uint8) (sargb >> 16);
		g = (uint8) (sargb >> 8);
		b = (uint8) sargb;
	}

	forcedinline void blend (const PixelRGB& src) noexcept
	{
		set (src);
	}

	/** Blends another pixel onto this one, applying an extra multiplier to its opacity.

		The opacity of the pixel being overlaid is scaled by the extraAlpha factor before
		being used, so this can blend semi-transparently from a PixelRGB argument.
	*/
	template <class Pixel>
	forcedinline void blend (const Pixel& src, uint32 extraAlpha) noexcept
	{
		++extraAlpha;
		const uint32 srb = (extraAlpha * src.getRB()) >> 8;
		const uint32 sag = extraAlpha * src.getAG();
		uint32 sargb = (sag & 0xff00ff00) | (srb & 0x00ff00ff);

		const uint32 alpha = 0x100 - (sargb >> 24);

		sargb += 0x00ff00ff & ((getRB() * alpha) >> 8);
		sargb += 0x0000ff00 & (g * alpha);

		b = (uint8) sargb;
		g = (uint8) (sargb >> 8);
		r = (uint8) (sargb >> 16);
	}

	/** Blends another pixel with this one, creating a colour that is somewhere
		between the two, as specified by the amount.
	*/
	template <class Pixel>
	forcedinline void tween (const Pixel& src, const uint32 amount) noexcept
	{
		uint32 drb = getRB();
		drb += (((src.getRB() - drb) * amount) >> 8);

		uint32 dag = getAG();
		dag += (((src.getAG() - dag) * amount) >> 8);

		b = (uint8) drb;
		g = (uint8) dag;
		r = (uint8) (drb >> 16);
	}

	/** Copies another pixel colour over this one.

		This doesn't blend it - this colour is simply replaced by the other one.
		Because PixelRGB has no alpha channel, any alpha value in the source pixel
		is thrown away.
	*/
	template <class Pixel>
	forcedinline void set (const Pixel& src) noexcept
	{
		b = src.getBlue();
		g = src.getGreen();
		r = src.getRed();
	}

	/** This method is included for compatibility with the PixelARGB class. */
	forcedinline void setAlpha (const uint8) noexcept {}

	/** Multiplies the colour's alpha value with another one. */
	forcedinline void multiplyAlpha (int) noexcept {}

	/** Multiplies the colour's alpha value with another one. */
	forcedinline void multiplyAlpha (float) noexcept {}

	/** Sets the pixel's colour from individual components. */
	void setARGB (const uint8, const uint8 r_, const uint8 g_, const uint8 b_) noexcept
	{
		r = r_;
		g = g_;
		b = b_;
	}

	/** Premultiplies the pixel's RGB values by its alpha. */
	forcedinline void premultiply() noexcept {}

	/** Unpremultiplies the pixel's RGB values. */
	forcedinline void unpremultiply() noexcept {}

	forcedinline void desaturate() noexcept
	{
		r = g = b = (uint8) (((int) r + (int) g + (int) b) / 3);
	}

	/** The indexes of the different components in the byte layout of this type of colour. */
   #if JUCE_MAC
	enum { indexR = 0, indexG = 1, indexB = 2 };
   #else
	enum { indexR = 2, indexG = 1, indexB = 0 };
   #endif

private:

   #if JUCE_MAC
	uint8 r, g, b;
   #else
	uint8 b, g, r;
   #endif

}
#ifndef DOXYGEN
 PACKED
#endif
;

forcedinline void PixelARGB::blend (const PixelRGB& src) noexcept
{
	set (src);
}

/**
	Represents an 8-bit single-channel pixel, and can perform compositing operations on it.

	This is used internally by the imaging classes.

	@see PixelARGB, PixelRGB
*/
class JUCE_API  PixelAlpha
{
public:
	/** Creates a pixel without defining its colour. */
	PixelAlpha() noexcept {}
	~PixelAlpha() noexcept {}

	/** Creates a pixel from a 32-bit argb value.

		(The argb format is that used by PixelARGB)
	*/
	PixelAlpha (const uint32 argb) noexcept
	{
		a = (uint8) (argb >> 24);
	}

	forcedinline uint32 getARGB() const noexcept                { return (((uint32) a) << 24) | (((uint32) a) << 16) | (((uint32) a) << 8) | a; }
	forcedinline uint32 getUnpremultipliedARGB() const noexcept { return (((uint32) a) << 24) | 0xffffff; }

	forcedinline uint32 getRB() const noexcept      { return (((uint32) a) << 16) | a; }
	forcedinline uint32 getAG() const noexcept      { return (((uint32) a) << 16) | a; }

	forcedinline uint8 getAlpha() const noexcept    { return a; }
	forcedinline uint8 getRed() const noexcept      { return 0; }
	forcedinline uint8 getGreen() const noexcept    { return 0; }
	forcedinline uint8 getBlue() const noexcept     { return 0; }

	/** Blends another pixel onto this one.

		This takes into account the opacity of the pixel being overlaid, and blends
		it accordingly.
	*/
	template <class Pixel>
	forcedinline void blend (const Pixel& src) noexcept
	{
		const int srcA = src.getAlpha();
		a = (uint8) ((a * (0x100 - srcA) >> 8) + srcA);
	}

	/** Blends another pixel onto this one, applying an extra multiplier to its opacity.

		The opacity of the pixel being overlaid is scaled by the extraAlpha factor before
		being used, so this can blend semi-transparently from a PixelRGB argument.
	*/
	template <class Pixel>
	forcedinline void blend (const Pixel& src, uint32 extraAlpha) noexcept
	{
		++extraAlpha;
		const int srcAlpha = (int) ((extraAlpha * src.getAlpha()) >> 8);
		a = (uint8) ((a * (0x100 - srcAlpha) >> 8) + srcAlpha);
	}

	/** Blends another pixel with this one, creating a colour that is somewhere
		between the two, as specified by the amount.
	*/
	template <class Pixel>
	forcedinline void tween (const Pixel& src, const uint32 amount) noexcept
	{
		a += ((src.getAlpha() - a) * amount) >> 8;
	}

	/** Copies another pixel colour over this one.

		This doesn't blend it - this colour is simply replaced by the other one.
	*/
	template <class Pixel>
	forcedinline void set (const Pixel& src) noexcept
	{
		a = src.getAlpha();
	}

	/** Replaces the colour's alpha value with another one. */
	forcedinline void setAlpha (const uint8 newAlpha) noexcept
	{
		a = newAlpha;
	}

	/** Multiplies the colour's alpha value with another one. */
	forcedinline void multiplyAlpha (int multiplier) noexcept
	{
		++multiplier;
		a = (uint8) ((a * multiplier) >> 8);
	}

	forcedinline void multiplyAlpha (const float multiplier) noexcept
	{
		a = (uint8) (a * multiplier);
	}

	/** Sets the pixel's colour from individual components. */
	forcedinline void setARGB (const uint8 a_, const uint8 /*r*/, const uint8 /*g*/, const uint8 /*b*/) noexcept
	{
		a = a_;
	}

	/** Premultiplies the pixel's RGB values by its alpha. */
	forcedinline void premultiply() noexcept {}

	/** Unpremultiplies the pixel's RGB values. */
	forcedinline void unpremultiply() noexcept {}

	forcedinline void desaturate() noexcept {}

	/** The indexes of the different components in the byte layout of this type of colour. */
	enum { indexA = 0 };

private:

	uint8 a : 8;
}
#ifndef DOXYGEN
 PACKED
#endif
;

#if JUCE_MSVC
 #pragma pack (pop)
#endif

#undef PACKED

#endif   // __JUCE_PIXELFORMATS_JUCEHEADER__

/*** End of inlined file: juce_PixelFormats.h ***/

/**
	Represents a colour, also including a transparency value.

	The colour is stored internally as unsigned 8-bit red, green, blue and alpha values.
*/
class JUCE_API  Colour
{
public:

	/** Creates a transparent black colour. */
	Colour() noexcept;

	/** Creates a copy of another Colour object. */
	Colour (const Colour& other) noexcept;

	/** Creates a colour from a 32-bit ARGB value.

		The format of this number is:
			((alpha << 24) | (red << 16) | (green << 8) | blue).

		All components in the range 0x00 to 0xff.
		An alpha of 0x00 is completely transparent, alpha of 0xff is opaque.

		@see getPixelARGB
	*/
	explicit Colour (uint32 argb) noexcept;

	/** Creates an opaque colour using 8-bit red, green and blue values */
	Colour (uint8 red,
			uint8 green,
			uint8 blue) noexcept;

	/** Creates an opaque colour using 8-bit red, green and blue values */
	static Colour fromRGB (uint8 red,
						   uint8 green,
						   uint8 blue) noexcept;

	/** Creates a colour using 8-bit red, green, blue and alpha values. */
	Colour (uint8 red,
			uint8 green,
			uint8 blue,
			uint8 alpha) noexcept;

	/** Creates a colour using 8-bit red, green, blue and alpha values. */
	static Colour fromRGBA (uint8 red,
							uint8 green,
							uint8 blue,
							uint8 alpha) noexcept;

	/** Creates a colour from 8-bit red, green, and blue values, and a floating-point alpha.

		Alpha of 0.0 is transparent, alpha of 1.0f is opaque.
		Values outside the valid range will be clipped.
	*/
	Colour (uint8 red,
			uint8 green,
			uint8 blue,
			float alpha) noexcept;

	/** Creates a colour using floating point red, green, blue and alpha values.
		Numbers outside the range 0..1 will be clipped.
	*/
	static Colour fromFloatRGBA (float red,
								 float green,
								 float blue,
								 float alpha) noexcept;

	/** Creates a colour using floating point hue, saturation and brightness values, and an 8-bit alpha.

		The floating point values must be between 0.0 and 1.0.
		An alpha of 0x00 is completely transparent, alpha of 0xff is opaque.
		Values outside the valid range will be clipped.
	*/
	Colour (float hue,
			float saturation,
			float brightness,
			uint8 alpha) noexcept;

	/** Creates a colour using floating point hue, saturation, brightness and alpha values.

		All values must be between 0.0 and 1.0.
		Numbers outside the valid range will be clipped.
	*/
	Colour (float hue,
			float saturation,
			float brightness,
			float alpha) noexcept;

	/** Creates a colour using floating point hue, saturation and brightness values, and an 8-bit alpha.

		The floating point values must be between 0.0 and 1.0.
		An alpha of 0x00 is completely transparent, alpha of 0xff is opaque.
		Values outside the valid range will be clipped.
	*/
	static Colour fromHSV (float hue,
						   float saturation,
						   float brightness,
						   float alpha) noexcept;

	/** Destructor. */
	~Colour() noexcept;

	/** Copies another Colour object. */
	Colour& operator= (const Colour& other) noexcept;

	/** Compares two colours. */
	bool operator== (const Colour& other) const noexcept;
	/** Compares two colours. */
	bool operator!= (const Colour& other) const noexcept;

	/** Returns the red component of this colour.

		@returns a value between 0x00 and 0xff.
	*/
	uint8 getRed() const noexcept                       { return argb.getRed(); }

	/** Returns the green component of this colour.

		@returns a value between 0x00 and 0xff.
	*/
	uint8 getGreen() const noexcept                     { return argb.getGreen(); }

	/** Returns the blue component of this colour.

		@returns a value between 0x00 and 0xff.
	*/
	uint8 getBlue() const noexcept                      { return argb.getBlue(); }

	/** Returns the red component of this colour as a floating point value.

		@returns a value between 0.0 and 1.0
	*/
	float getFloatRed() const noexcept;

	/** Returns the green component of this colour as a floating point value.

		@returns a value between 0.0 and 1.0
	*/
	float getFloatGreen() const noexcept;

	/** Returns the blue component of this colour as a floating point value.

		@returns a value between 0.0 and 1.0
	*/
	float getFloatBlue() const noexcept;

	/** Returns a premultiplied ARGB pixel object that represents this colour.
	*/
	const PixelARGB getPixelARGB() const noexcept;

	/** Returns a 32-bit integer that represents this colour.

		The format of this number is:
			((alpha << 24) | (red << 16) | (green << 16) | blue).
	*/
	uint32 getARGB() const noexcept;

	/** Returns the colour's alpha (opacity).

		Alpha of 0x00 is completely transparent, 0xff is completely opaque.
	*/
	uint8 getAlpha() const noexcept                     { return argb.getAlpha(); }

	/** Returns the colour's alpha (opacity) as a floating point value.

		Alpha of 0.0 is completely transparent, 1.0 is completely opaque.
	*/
	float getFloatAlpha() const noexcept;

	/** Returns true if this colour is completely opaque.

		Equivalent to (getAlpha() == 0xff).
	*/
	bool isOpaque() const noexcept;

	/** Returns true if this colour is completely transparent.

		Equivalent to (getAlpha() == 0x00).
	*/
	bool isTransparent() const noexcept;

	/** Returns a colour that's the same colour as this one, but with a new alpha value. */
	Colour withAlpha (uint8 newAlpha) const noexcept;

	/** Returns a colour that's the same colour as this one, but with a new alpha value. */
	Colour withAlpha (float newAlpha) const noexcept;

	/** Returns a colour that's the same colour as this one, but with a modified alpha value.

		The new colour's alpha will be this object's alpha multiplied by the value passed-in.
	*/
	Colour withMultipliedAlpha (float alphaMultiplier) const noexcept;

	/** Returns a colour that is the result of alpha-compositing a new colour over this one.

		If the foreground colour is semi-transparent, it is blended onto this colour
		accordingly.
	*/
	Colour overlaidWith (const Colour& foregroundColour) const noexcept;

	/** Returns a colour that lies somewhere between this one and another.

		If amountOfOther is zero, the result is 100% this colour, if amountOfOther
		is 1.0, the result is 100% of the other colour.
	*/
	Colour interpolatedWith (const Colour& other, float proportionOfOther) const noexcept;

	/** Returns the colour's hue component.
		The value returned is in the range 0.0 to 1.0
	*/
	float getHue() const noexcept;

	/** Returns the colour's saturation component.
		The value returned is in the range 0.0 to 1.0
	*/
	float getSaturation() const noexcept;

	/** Returns the colour's brightness component.
		The value returned is in the range 0.0 to 1.0
	*/
	float getBrightness() const noexcept;

	/** Returns the colour's hue, saturation and brightness components all at once.
		The values returned are in the range 0.0 to 1.0
	*/
	void getHSB (float& hue,
				 float& saturation,
				 float& brightness) const noexcept;

	/** Returns a copy of this colour with a different hue. */
	Colour withHue (float newHue) const noexcept;

	/** Returns a copy of this colour with a different saturation. */
	Colour withSaturation (float newSaturation) const noexcept;

	/** Returns a copy of this colour with a different brightness.
		@see brighter, darker, withMultipliedBrightness
	*/
	Colour withBrightness (float newBrightness) const noexcept;

	/** Returns a copy of this colour with it hue rotated.

		The new colour's hue is ((this->getHue() + amountToRotate) % 1.0)

		@see brighter, darker, withMultipliedBrightness
	*/
	Colour withRotatedHue (float amountToRotate) const noexcept;

	/** Returns a copy of this colour with its saturation multiplied by the given value.

		The new colour's saturation is (this->getSaturation() * multiplier)
		(the result is clipped to legal limits).
	*/
	Colour withMultipliedSaturation (float multiplier) const noexcept;

	/** Returns a copy of this colour with its brightness multiplied by the given value.

		The new colour's saturation is (this->getBrightness() * multiplier)
		(the result is clipped to legal limits).
	*/
	Colour withMultipliedBrightness (float amount) const noexcept;

	/** Returns a brighter version of this colour.

		@param amountBrighter   how much brighter to make it - a value from 0 to 1.0 where 0 is
								unchanged, and higher values make it brighter
		@see withMultipliedBrightness
	*/
	Colour brighter (float amountBrighter = 0.4f) const noexcept;

	/** Returns a darker version of this colour.

		@param amountDarker     how much darker to make it - a value from 0 to 1.0 where 0 is
								unchanged, and higher values make it darker
		@see withMultipliedBrightness
	*/
	Colour darker (float amountDarker = 0.4f) const noexcept;

	/** Returns a colour that will be clearly visible against this colour.

		The amount parameter indicates how contrasting the new colour should
		be, so e.g. Colours::black.contrasting (0.1f) will return a colour
		that's just a little bit lighter; Colours::black.contrasting (1.0f) will
		return white; Colours::white.contrasting (1.0f) will return black, etc.
	*/
	Colour contrasting (float amount = 1.0f) const noexcept;

	/** Returns a colour that contrasts against two colours.

		Looks for a colour that contrasts with both of the colours passed-in.

		Handy for things like choosing a highlight colour in text editors, etc.
	*/
	static Colour contrasting (const Colour& colour1,
							   const Colour& colour2) noexcept;

	/** Returns an opaque shade of grey.

		@param brightness the level of grey to return - 0 is black, 1.0 is white
	*/
	static Colour greyLevel (float brightness) noexcept;

	/** Returns a stringified version of this colour.

		The string can be turned back into a colour using the fromString() method.
	*/
	String toString() const;

	/** Reads the colour from a string that was created with toString().
	*/
	static Colour fromString (const String& encodedColourString);

	/** Returns the colour as a hex string in the form RRGGBB or AARRGGBB. */
	String toDisplayString (bool includeAlphaValue) const;

private:

	PixelARGB argb;
};

#endif   // __JUCE_COLOUR_JUCEHEADER__

/*** End of inlined file: juce_Colour.h ***/


#endif
#ifndef __JUCE_COLOURGRADIENT_JUCEHEADER__

/*** Start of inlined file: juce_ColourGradient.h ***/
#ifndef __JUCE_COLOURGRADIENT_JUCEHEADER__
#define __JUCE_COLOURGRADIENT_JUCEHEADER__


/*** Start of inlined file: juce_Point.h ***/
#ifndef __JUCE_POINT_JUCEHEADER__
#define __JUCE_POINT_JUCEHEADER__


/*** Start of inlined file: juce_AffineTransform.h ***/
#ifndef __JUCE_AFFINETRANSFORM_JUCEHEADER__
#define __JUCE_AFFINETRANSFORM_JUCEHEADER__

/**
	Represents a 2D affine-transformation matrix.

	An affine transformation is a transformation such as a rotation, scale, shear,
	resize or translation.

	These are used for various 2D transformation tasks, e.g. with Path objects.

	@see Path, Point, Line
*/
class JUCE_API  AffineTransform
{
public:

	/** Creates an identity transform. */
	AffineTransform() noexcept;

	/** Creates a copy of another transform. */
	AffineTransform (const AffineTransform& other) noexcept;

	/** Creates a transform from a set of raw matrix values.

		The resulting matrix is:

			(mat00 mat01 mat02)
			(mat10 mat11 mat12)
			(  0     0     1  )
	*/
	AffineTransform (float mat00, float mat01, float mat02,
					 float mat10, float mat11, float mat12) noexcept;

	/** Copies from another AffineTransform object */
	AffineTransform& operator= (const AffineTransform& other) noexcept;

	/** Compares two transforms. */
	bool operator== (const AffineTransform& other) const noexcept;

	/** Compares two transforms. */
	bool operator!= (const AffineTransform& other) const noexcept;

	/** A ready-to-use identity transform, which you can use to append other
		transformations to.

		e.g. @code
		AffineTransform myTransform = AffineTransform::identity.rotated (.5f)
															   .scaled (2.0f);

		@endcode
	*/
	static const AffineTransform identity;

	/** Transforms a 2D co-ordinate using this matrix. */
	template <typename ValueType>
	void transformPoint (ValueType& x, ValueType& y) const noexcept
	{
		const ValueType oldX = x;
		x = static_cast <ValueType> (mat00 * oldX + mat01 * y + mat02);
		y = static_cast <ValueType> (mat10 * oldX + mat11 * y + mat12);
	}

	/** Transforms two 2D co-ordinates using this matrix.
		This is just a shortcut for calling transformPoint() on each of these pairs of
		coordinates in turn. (And putting all the calculations into one function hopefully
		also gives the compiler a bit more scope for pipelining it).
	*/
	template <typename ValueType>
	void transformPoints (ValueType& x1, ValueType& y1,
						  ValueType& x2, ValueType& y2) const noexcept
	{
		const ValueType oldX1 = x1, oldX2 = x2;
		x1 = static_cast <ValueType> (mat00 * oldX1 + mat01 * y1 + mat02);
		y1 = static_cast <ValueType> (mat10 * oldX1 + mat11 * y1 + mat12);
		x2 = static_cast <ValueType> (mat00 * oldX2 + mat01 * y2 + mat02);
		y2 = static_cast <ValueType> (mat10 * oldX2 + mat11 * y2 + mat12);
	}

	/** Transforms three 2D co-ordinates using this matrix.
		This is just a shortcut for calling transformPoint() on each of these pairs of
		coordinates in turn. (And putting all the calculations into one function hopefully
		also gives the compiler a bit more scope for pipelining it).
	*/
	template <typename ValueType>
	void transformPoints (ValueType& x1, ValueType& y1,
						  ValueType& x2, ValueType& y2,
						  ValueType& x3, ValueType& y3) const noexcept
	{
		const ValueType oldX1 = x1, oldX2 = x2, oldX3 = x3;
		x1 = static_cast <ValueType> (mat00 * oldX1 + mat01 * y1 + mat02);
		y1 = static_cast <ValueType> (mat10 * oldX1 + mat11 * y1 + mat12);
		x2 = static_cast <ValueType> (mat00 * oldX2 + mat01 * y2 + mat02);
		y2 = static_cast <ValueType> (mat10 * oldX2 + mat11 * y2 + mat12);
		x3 = static_cast <ValueType> (mat00 * oldX3 + mat01 * y3 + mat02);
		y3 = static_cast <ValueType> (mat10 * oldX3 + mat11 * y3 + mat12);
	}

	/** Returns a new transform which is the same as this one followed by a translation. */
	AffineTransform translated (float deltaX,
								float deltaY) const noexcept;

	/** Returns a new transform which is a translation. */
	static AffineTransform translation (float deltaX,
										float deltaY) noexcept;

	/** Returns a transform which is the same as this one followed by a rotation.

		The rotation is specified by a number of radians to rotate clockwise, centred around
		the origin (0, 0).
	*/
	AffineTransform rotated (float angleInRadians) const noexcept;

	/** Returns a transform which is the same as this one followed by a rotation about a given point.

		The rotation is specified by a number of radians to rotate clockwise, centred around
		the co-ordinates passed in.
	*/
	AffineTransform rotated (float angleInRadians,
							 float pivotX,
							 float pivotY) const noexcept;

	/** Returns a new transform which is a rotation about (0, 0). */
	static AffineTransform rotation (float angleInRadians) noexcept;

	/** Returns a new transform which is a rotation about a given point. */
	static AffineTransform rotation (float angleInRadians,
									 float pivotX,
									 float pivotY) noexcept;

	/** Returns a transform which is the same as this one followed by a re-scaling.
		The scaling is centred around the origin (0, 0).
	*/
	AffineTransform scaled (float factorX,
							float factorY) const noexcept;

	/** Returns a transform which is the same as this one followed by a re-scaling.
		The scaling is centred around the origin provided.
	*/
	AffineTransform scaled (float factorX, float factorY,
							float pivotX, float pivotY) const noexcept;

	/** Returns a new transform which is a re-scale about the origin. */
	static AffineTransform scale (float factorX,
								  float factorY) noexcept;

	/** Returns a new transform which is a re-scale centred around the point provided. */
	static AffineTransform scale (float factorX, float factorY,
								  float pivotX, float pivotY) noexcept;

	/** Returns a transform which is the same as this one followed by a shear.
		The shear is centred around the origin (0, 0).
	*/
	AffineTransform sheared (float shearX, float shearY) const noexcept;

	/** Returns a shear transform, centred around the origin (0, 0). */
	static AffineTransform shear (float shearX, float shearY) noexcept;

	/** Returns a transform that will flip co-ordinates vertically within a window of the given height.
		This is handy for converting between upside-down coordinate systems such as OpenGL or CoreGraphics.
	*/
	static AffineTransform verticalFlip (float height) noexcept;

	/** Returns a matrix which is the inverse operation of this one.

		Some matrices don't have an inverse - in this case, the method will just return
		an identity transform.
	*/
	AffineTransform inverted() const noexcept;

	/** Returns the transform that will map three known points onto three coordinates
		that are supplied.

		This returns the transform that will transform (0, 0) into (x00, y00),
		(1, 0) to (x10, y10), and (0, 1) to (x01, y01).
	*/
	static AffineTransform fromTargetPoints (float x00, float y00,
											 float x10, float y10,
											 float x01, float y01) noexcept;

	/** Returns the transform that will map three specified points onto three target points.
	*/
	static AffineTransform fromTargetPoints (float sourceX1, float sourceY1, float targetX1, float targetY1,
											 float sourceX2, float sourceY2, float targetX2, float targetY2,
											 float sourceX3, float sourceY3, float targetX3, float targetY3) noexcept;

	/** Returns the result of concatenating another transformation after this one. */
	AffineTransform followedBy (const AffineTransform& other) const noexcept;

	/** Returns true if this transform has no effect on points. */
	bool isIdentity() const noexcept;

	/** Returns true if this transform maps to a singularity - i.e. if it has no inverse. */
	bool isSingularity() const noexcept;

	/** Returns true if the transform only translates, and doesn't scale or rotate the
		points. */
	bool isOnlyTranslation() const noexcept;

	/** If this transform is only a translation, this returns the X offset.
		@see isOnlyTranslation
	*/
	float getTranslationX() const noexcept                  { return mat02; }

	/** If this transform is only a translation, this returns the X offset.
		@see isOnlyTranslation
	*/
	float getTranslationY() const noexcept                  { return mat12; }

	/** Returns the approximate scale factor by which lengths will be transformed.
		Obviously a length may be scaled by entirely different amounts depending on its
		direction, so this is only appropriate as a rough guide.
	*/
	float getScaleFactor() const noexcept;

	/* The transform matrix is:

		(mat00 mat01 mat02)
		(mat10 mat11 mat12)
		(  0     0     1  )
	*/
	float mat00, mat01, mat02;
	float mat10, mat11, mat12;

private:

	JUCE_LEAK_DETECTOR (AffineTransform);
};

#endif   // __JUCE_AFFINETRANSFORM_JUCEHEADER__

/*** End of inlined file: juce_AffineTransform.h ***/

/**
	A pair of (x, y) co-ordinates.

	The ValueType template should be a primitive type such as int, float, double,
	rather than a class.

	@see Line, Path, AffineTransform
*/
template <typename ValueType>
class Point
{
public:

	/** Creates a point with co-ordinates (0, 0). */
	Point() noexcept : x(), y() {}

	/** Creates a copy of another point. */
	Point (const Point& other) noexcept : x (other.x), y (other.y)  {}

	/** Creates a point from an (x, y) position. */
	Point (const ValueType initialX, const ValueType initialY) noexcept : x (initialX), y (initialY) {}

	/** Destructor. */
	~Point() noexcept {}

	/** Copies this point from another one. */
	Point& operator= (const Point& other) noexcept                      { x = other.x; y = other.y; return *this; }

	inline bool operator== (const Point& other) const noexcept          { return x == other.x && y == other.y; }
	inline bool operator!= (const Point& other) const noexcept          { return x != other.x || y != other.y; }

	/** Returns true if the point is (0, 0). */
	bool isOrigin() const noexcept                                      { return x == ValueType() && y == ValueType(); }

	/** Returns the point's x co-ordinate. */
	inline ValueType getX() const noexcept                              { return x; }

	/** Returns the point's y co-ordinate. */
	inline ValueType getY() const noexcept                              { return y; }

	/** Sets the point's x co-ordinate. */
	inline void setX (const ValueType newX) noexcept                    { x = newX; }

	/** Sets the point's y co-ordinate. */
	inline void setY (const ValueType newY) noexcept                    { y = newY; }

	/** Returns a point which has the same Y position as this one, but a new X. */
	Point withX (const ValueType newX) const noexcept                   { return Point (newX, y); }

	/** Returns a point which has the same X position as this one, but a new Y. */
	Point withY (const ValueType newY) const noexcept                   { return Point (x, newY); }

	/** Changes the point's x and y co-ordinates. */
	void setXY (const ValueType newX, const ValueType newY) noexcept    { x = newX; y = newY; }

	/** Adds a pair of co-ordinates to this value. */
	void addXY (const ValueType xToAdd, const ValueType yToAdd) noexcept { x += xToAdd; y += yToAdd; }

	/** Returns a point with a given offset from this one. */
	Point translated (const ValueType xDelta, const ValueType yDelta) const noexcept  { return Point (x + xDelta, y + yDelta); }

	/** Adds two points together. */
	Point operator+ (const Point& other) const noexcept                 { return Point (x + other.x, y + other.y); }

	/** Adds another point's co-ordinates to this one. */
	Point& operator+= (const Point& other) noexcept                     { x += other.x; y += other.y; return *this; }

	/** Subtracts one points from another. */
	Point operator- (const Point& other) const noexcept                 { return Point (x - other.x, y - other.y); }

	/** Subtracts another point's co-ordinates to this one. */
	Point& operator-= (const Point& other) noexcept                     { x -= other.x; y -= other.y; return *this; }

	/** Returns a point whose coordinates are multiplied by a given value. */
	Point operator* (const ValueType multiplier) const noexcept         { return Point (x * multiplier, y * multiplier); }

	/** Multiplies the point's co-ordinates by a value. */
	Point& operator*= (const ValueType multiplier) noexcept             { x *= multiplier; y *= multiplier; return *this; }

	/** Returns a point whose coordinates are divided by a given value. */
	Point operator/ (const ValueType divisor) const noexcept            { return Point (x / divisor, y / divisor); }

	/** Divides the point's co-ordinates by a value. */
	Point& operator/= (const ValueType divisor) noexcept                { x /= divisor; y /= divisor; return *this; }

	/** Returns the inverse of this point. */
	Point operator-() const noexcept                                    { return Point (-x, -y); }

	/** Returns the straight-line distance between this point and the origin. */
	ValueType getDistanceFromOrigin() const noexcept                    { return juce_hypot (x, y); }

	/** Returns the straight-line distance between this point and another one. */
	ValueType getDistanceFrom (const Point& other) const noexcept       { return juce_hypot (x - other.x, y - other.y); }

	/** This type will be double if the Point's type is double, otherwise it will be float. */
	typedef typename TypeHelpers::SmallestFloatType<ValueType>::type FloatType;

	/** Returns the angle from this point to another one.

		The return value is the number of radians clockwise from the 12 o'clock direction,
		where this point is the centre and the other point is on the circumference.
	*/
	FloatType getAngleToPoint (const Point& other) const noexcept
		{ return static_cast<FloatType> (std::atan2 (other.x - x, y - other.y)); }

	/** Taking this point to be the centre of a circle, this returns a point on its circumference.
		@param radius   the radius of the circle.
		@param angle    the angle of the point, in radians clockwise from the 12 o'clock position.
	*/
	Point<FloatType> getPointOnCircumference (const float radius, const float angle) const noexcept
		{ return Point<FloatType> (static_cast <FloatType> (x + radius * std::sin (angle)),
								   static_cast <FloatType> (y - radius * std::cos (angle))); }

	/** Taking this point to be the centre of an ellipse, this returns a point on its circumference.
		@param radiusX  the horizontal radius of the circle.
		@param radiusY  the vertical radius of the circle.
		@param angle    the angle of the point, in radians clockwise from the 12 o'clock position.
	*/
	Point<FloatType> getPointOnCircumference (const float radiusX, const float radiusY, const float angle) const noexcept
		{ return Point<FloatType> (static_cast <FloatType> (x + radiusX * std::sin (angle)),
								   static_cast <FloatType> (y - radiusY * std::cos (angle))); }

	/** Uses a transform to change the point's co-ordinates.
		This will only compile if ValueType = float!
		@see AffineTransform::transformPoint
	*/
	void applyTransform (const AffineTransform& transform) noexcept     { transform.transformPoint (x, y); }

	/** Returns the position of this point, if it is transformed by a given AffineTransform. */
	Point transformedBy (const AffineTransform& transform) const noexcept
		{ return Point (transform.mat00 * x + transform.mat01 * y + transform.mat02,
						transform.mat10 * x + transform.mat11 * y + transform.mat12); }

	/** Casts this point to a Point<int> object. */
	Point<int> toInt() const noexcept                             { return Point<int> (static_cast <int> (x), static_cast<int> (y)); }

	/** Casts this point to a Point<float> object. */
	Point<float> toFloat() const noexcept                         { return Point<float> (static_cast <float> (x), static_cast<float> (y)); }

	/** Casts this point to a Point<double> object. */
	Point<double> toDouble() const noexcept                       { return Point<double> (static_cast <double> (x), static_cast<double> (y)); }

	/** Returns the point as a string in the form "x, y". */
	String toString() const                                       { return String (x) + ", " + String (y); }

	ValueType x; /**< The point's X coordinate. */
	ValueType y; /**< The point's Y coordinate. */
};

#endif   // __JUCE_POINT_JUCEHEADER__

/*** End of inlined file: juce_Point.h ***/

/**
	Describes the layout and colours that should be used to paint a colour gradient.

	@see Graphics::setGradientFill
*/
class JUCE_API  ColourGradient
{
public:

	/** Creates a gradient object.

		(x1, y1) is the location to draw with colour1. Likewise (x2, y2) is where
		colour2 should be. In between them there's a gradient.

		If isRadial is true, the colours form a circular gradient with (x1, y1) at
		its centre.

		The alpha transparencies of the colours are used, so note that
		if you blend from transparent to a solid colour, the RGB of the transparent
		colour will become visible in parts of the gradient. e.g. blending
		from Colour::transparentBlack to Colours::white will produce a
		muddy grey colour midway, but Colour::transparentWhite to Colours::white
		will be white all the way across.

		@see ColourGradient
	*/
	ColourGradient (const Colour& colour1, float x1, float y1,
					const Colour& colour2, float x2, float y2,
					bool isRadial);

	/** Creates an uninitialised gradient.

		If you use this constructor instead of the other one, be sure to set all the
		object's public member variables before using it!
	*/
	ColourGradient() noexcept;

	/** Destructor */
	~ColourGradient();

	/** Removes any colours that have been added.

		This will also remove any start and end colours, so the gradient won't work. You'll
		need to add more colours with addColour().
	*/
	void clearColours();

	/** Adds a colour at a point along the length of the gradient.

		This allows the gradient to go through a spectrum of colours, instead of just a
		start and end colour.

		@param proportionAlongGradient      a value between 0 and 1.0, which is the proportion
											of the distance along the line between the two points
											at which the colour should occur.
		@param colour                       the colour that should be used at this point
		@returns the index at which the new point was added
	*/
	int addColour (double proportionAlongGradient,
				   const Colour& colour);

	/** Removes one of the colours from the gradient. */
	void removeColour (int index);

	/** Multiplies the alpha value of all the colours by the given scale factor */
	void multiplyOpacity (float multiplier) noexcept;

	/** Returns the number of colour-stops that have been added. */
	int getNumColours() const noexcept;

	/** Returns the position along the length of the gradient of the colour with this index.

		The index is from 0 to getNumColours() - 1. The return value will be between 0.0 and 1.0
	*/
	double getColourPosition (int index) const noexcept;

	/** Returns the colour that was added with a given index.
		The index is from 0 to getNumColours() - 1.
	*/
	Colour getColour (int index) const noexcept;

	/** Changes the colour at a given index.
		The index is from 0 to getNumColours() - 1.
	*/
	void setColour (int index, const Colour& newColour) noexcept;

	/** Returns the an interpolated colour at any position along the gradient.
		@param position     the position along the gradient, between 0 and 1
	*/
	Colour getColourAtPosition (double position) const noexcept;

	/** Creates a set of interpolated premultiplied ARGB values.
		This will resize the HeapBlock, fill it with the colours, and will return the number of
		colours that it added.
		When calling this, the ColourGradient must have at least 2 colour stops specified.
	*/
	int createLookupTable (const AffineTransform& transform, HeapBlock <PixelARGB>& resultLookupTable) const;

	/** Creates a set of interpolated premultiplied ARGB values.
		This will fill an array of a user-specified size with the gradient, interpolating to fit.
		The numEntries argument specifies the size of the array, and this size must be greater than zero.
		When calling this, the ColourGradient must have at least 2 colour stops specified.
	*/
	void createLookupTable (PixelARGB* resultLookupTable, int numEntries) const noexcept;

	/** Returns true if all colours are opaque. */
	bool isOpaque() const noexcept;

	/** Returns true if all colours are completely transparent. */
	bool isInvisible() const noexcept;

	Point<float> point1, point2;

	/** If true, the gradient should be filled circularly, centred around
		point1, with point2 defining a point on the circumference.

		If false, the gradient is linear between the two points.
	*/
	bool isRadial;

	bool operator== (const ColourGradient& other) const noexcept;
	bool operator!= (const ColourGradient& other) const noexcept;

private:

	struct ColourPoint
	{
		ColourPoint() noexcept {}

		ColourPoint (const double position_, const Colour& colour_) noexcept
			: position (position_), colour (colour_)
		{}

		bool operator== (const ColourPoint& other) const noexcept;
		bool operator!= (const ColourPoint& other) const noexcept;

		double position;
		Colour colour;
	};

	Array <ColourPoint> colours;

	JUCE_LEAK_DETECTOR (ColourGradient);
};

#endif   // __JUCE_COLOURGRADIENT_JUCEHEADER__

/*** End of inlined file: juce_ColourGradient.h ***/


#endif
#ifndef __JUCE_COLOURS_JUCEHEADER__

/*** Start of inlined file: juce_Colours.h ***/
#ifndef __JUCE_COLOURS_JUCEHEADER__
#define __JUCE_COLOURS_JUCEHEADER__

/**
	Contains a set of predefined named colours (mostly standard HTML colours)

	@see Colour, Colours::greyLevel
*/
class Colours
{
public:
	static JUCE_API const Colour

	transparentBlack,   /**< ARGB = 0x00000000 */
	transparentWhite,   /**< ARGB = 0x00ffffff */

	black,              /**< ARGB = 0xff000000 */
	white,              /**< ARGB = 0xffffffff */
	blue,               /**< ARGB = 0xff0000ff */
	grey,               /**< ARGB = 0xff808080 */
	green,              /**< ARGB = 0xff008000 */
	red,                /**< ARGB = 0xffff0000 */
	yellow,             /**< ARGB = 0xffffff00 */

	aliceblue,              antiquewhite,       aqua,               aquamarine,
	azure,                  beige,              bisque,             blanchedalmond,
	blueviolet,             brown,              burlywood,          cadetblue,
	chartreuse,             chocolate,          coral,              cornflowerblue,
	cornsilk,               crimson,            cyan,               darkblue,
	darkcyan,               darkgoldenrod,      darkgrey,           darkgreen,
	darkkhaki,              darkmagenta,        darkolivegreen,     darkorange,
	darkorchid,             darkred,            darksalmon,         darkseagreen,
	darkslateblue,          darkslategrey,      darkturquoise,      darkviolet,
	deeppink,               deepskyblue,        dimgrey,            dodgerblue,
	firebrick,              floralwhite,        forestgreen,        fuchsia,
	gainsboro,              gold,               goldenrod,          greenyellow,
	honeydew,               hotpink,            indianred,          indigo,
	ivory,                  khaki,              lavender,           lavenderblush,
	lemonchiffon,           lightblue,          lightcoral,         lightcyan,
	lightgoldenrodyellow,   lightgreen,         lightgrey,          lightpink,
	lightsalmon,            lightseagreen,      lightskyblue,       lightslategrey,
	lightsteelblue,         lightyellow,        lime,               limegreen,
	linen,                  magenta,            maroon,             mediumaquamarine,
	mediumblue,             mediumorchid,       mediumpurple,       mediumseagreen,
	mediumslateblue,        mediumspringgreen,  mediumturquoise,    mediumvioletred,
	midnightblue,           mintcream,          mistyrose,          navajowhite,
	navy,                   oldlace,            olive,              olivedrab,
	orange,                 orangered,          orchid,             palegoldenrod,
	palegreen,              paleturquoise,      palevioletred,      papayawhip,
	peachpuff,              peru,               pink,               plum,
	powderblue,             purple,             rosybrown,          royalblue,
	saddlebrown,            salmon,             sandybrown,         seagreen,
	seashell,               sienna,             silver,             skyblue,
	slateblue,              slategrey,          snow,               springgreen,
	steelblue,              tan,                teal,               thistle,
	tomato,                 turquoise,          violet,             wheat,
	whitesmoke,             yellowgreen;

	/** Attempts to look up a string in the list of known colour names, and return
		the appropriate colour.

		A non-case-sensitive search is made of the list of predefined colours, and
		if a match is found, that colour is returned. If no match is found, the
		colour passed in as the defaultColour parameter is returned.
	*/
	static JUCE_API Colour findColourForName (const String& colourName,
											  const Colour& defaultColour);

private:

	// this isn't a class you should ever instantiate - it's just here for the
	// static values in it.
	Colours();

	JUCE_DECLARE_NON_COPYABLE (Colours);
};

#endif   // __JUCE_COLOURS_JUCEHEADER__

/*** End of inlined file: juce_Colours.h ***/


#endif
#ifndef __JUCE_FILLTYPE_JUCEHEADER__

/*** Start of inlined file: juce_FillType.h ***/
#ifndef __JUCE_FILLTYPE_JUCEHEADER__
#define __JUCE_FILLTYPE_JUCEHEADER__


/*** Start of inlined file: juce_Image.h ***/
#ifndef __JUCE_IMAGE_JUCEHEADER__
#define __JUCE_IMAGE_JUCEHEADER__


/*** Start of inlined file: juce_GraphicsContext.h ***/
#ifndef __JUCE_GRAPHICSCONTEXT_JUCEHEADER__
#define __JUCE_GRAPHICSCONTEXT_JUCEHEADER__


/*** Start of inlined file: juce_Font.h ***/
#ifndef __JUCE_FONT_JUCEHEADER__
#define __JUCE_FONT_JUCEHEADER__


/*** Start of inlined file: juce_Typeface.h ***/
#ifndef __JUCE_TYPEFACE_JUCEHEADER__
#define __JUCE_TYPEFACE_JUCEHEADER__

class Path;
class Font;
class EdgeTable;
class AffineTransform;

/**
	A typeface represents a size-independent font.

	This base class is abstract, but calling createSystemTypefaceFor() will return
	a platform-specific subclass that can be used.

	The CustomTypeface subclass allow you to build your own typeface, and to
	load and save it in the Juce typeface format.

	Normally you should never need to deal directly with Typeface objects - the Font
	class does everything you typically need for rendering text.

	@see CustomTypeface, Font
*/
class JUCE_API  Typeface  : public SingleThreadedReferenceCountedObject
{
public:

	/** A handy typedef for a pointer to a typeface. */
	typedef ReferenceCountedObjectPtr <Typeface> Ptr;

	/** Returns the name of the typeface.
		@see Font::getTypefaceName
	*/
	const String& getName() const noexcept      { return name; }

	/** Creates a new system typeface. */
	static Ptr createSystemTypefaceFor (const Font& font);

	/** Destructor. */
	virtual ~Typeface();

	/** Returns true if this typeface can be used to render the specified font.
		When called, the font will already have been checked to make sure that its name and
		style flags match the typeface.
	*/
	virtual bool isSuitableForFont (const Font&) const          { return true; }

	/** Returns the ascent of the font, as a proportion of its height.
		The height is considered to always be normalised as 1.0, so this will be a
		value less that 1.0, indicating the proportion of the font that lies above
		its baseline.
	*/
	virtual float getAscent() const = 0;

	/** Returns the descent of the font, as a proportion of its height.
		The height is considered to always be normalised as 1.0, so this will be a
		value less that 1.0, indicating the proportion of the font that lies below
		its baseline.
	*/
	virtual float getDescent() const = 0;

	/** Measures the width of a line of text.

		The distance returned is based on the font having an normalised height of 1.0.

		You should never need to call this directly! Use Font::getStringWidth() instead!
	*/
	virtual float getStringWidth (const String& text) = 0;

	/** Converts a line of text into its glyph numbers and their positions.

		The distances returned are based on the font having an normalised height of 1.0.

		You should never need to call this directly! Use Font::getGlyphPositions() instead!
	*/
	virtual void getGlyphPositions (const String& text, Array <int>& glyphs, Array<float>& xOffsets) = 0;

	/** Returns the outline for a glyph.

		The path returned will be normalised to a font height of 1.0.
	*/
	virtual bool getOutlineForGlyph (int glyphNumber, Path& path) = 0;

	/** Returns a new EdgeTable that contains the path for the givem glyph, with the specified transform applied. */
	virtual EdgeTable* getEdgeTableForGlyph (int glyphNumber, const AffineTransform& transform);

	/** Returns true if the typeface uses hinting. */
	virtual bool isHinted() const                           { return false; }

	/** Changes the number of fonts that are cached in memory. */
	static void setTypefaceCacheSize (int numFontsToCache);

protected:

	String name;

	explicit Typeface (const String& name) noexcept;

	static Ptr getFallbackTypeface();

private:
	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (Typeface);
};

#endif   // __JUCE_TYPEFACE_JUCEHEADER__

/*** End of inlined file: juce_Typeface.h ***/

class LowLevelGraphicsContext;

/**
	Represents a particular font, including its size, style, etc.

	Apart from the typeface to be used, a Font object also dictates whether
	the font is bold, italic, underlined, how big it is, and its kerning and
	horizontal scale factor.

	@see Typeface
*/
class JUCE_API  Font
{
public:

	/** A combination of these values is used by the constructor to specify the
		style of font to use.
	*/
	enum FontStyleFlags
	{
		plain       = 0,    /**< indicates a plain, non-bold, non-italic version of the font. @see setStyleFlags */
		bold        = 1,    /**< boldens the font. @see setStyleFlags */
		italic      = 2,    /**< finds an italic version of the font. @see setStyleFlags */
		underlined  = 4     /**< underlines the font. @see setStyleFlags */
	};

	/** Creates a sans-serif font in a given size.

		@param fontHeight   the height in pixels (can be fractional)
		@param styleFlags   the style to use - this can be a combination of the
							Font::bold, Font::italic and Font::underlined, or
							just Font::plain for the normal style.
		@see FontStyleFlags, getDefaultSansSerifFontName
	*/
	Font (float fontHeight, int styleFlags = plain);

	/** Creates a font with a given typeface and parameters.

		@param typefaceName the name of the typeface to use
		@param fontHeight   the height in pixels (can be fractional)
		@param styleFlags   the style to use - this can be a combination of the
							Font::bold, Font::italic and Font::underlined, or
							just Font::plain for the normal style.
		@see FontStyleFlags, getDefaultSansSerifFontName
	*/
	Font (const String& typefaceName, float fontHeight, int styleFlags);

	/** Creates a copy of another Font object. */
	Font (const Font& other) noexcept;

	/** Creates a font for a typeface. */
	Font (const Typeface::Ptr& typeface);

	/** Creates a basic sans-serif font at a default height.

		You should use one of the other constructors for creating a font that you're planning
		on drawing with - this constructor is here to help initialise objects before changing
		the font's settings later.
	*/
	Font();

   #if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
	Font (Font&& other) noexcept;
	Font& operator= (Font&& other) noexcept;
   #endif

	/** Copies this font from another one. */
	Font& operator= (const Font& other) noexcept;

	bool operator== (const Font& other) const noexcept;
	bool operator!= (const Font& other) const noexcept;

	/** Destructor. */
	~Font() noexcept;

	/** Changes the name of the typeface family.

		e.g. "Arial", "Courier", etc.

		This may also be set to Font::getDefaultSansSerifFontName(), Font::getDefaultSerifFontName(),
		or Font::getDefaultMonospacedFontName(), which are not actual platform-specific font names,
		but are generic names that are used to represent the various default fonts.
		If you need to know the exact typeface name being used, you can call
		Font::getTypeface()->getTypefaceName(), which will give you the platform-specific name.

		If a suitable font isn't found on the machine, it'll just use a default instead.
	*/
	void setTypefaceName (const String& faceName);

	/** Returns the name of the typeface family that this font uses.

		e.g. "Arial", "Courier", etc.

		This may also be set to Font::getDefaultSansSerifFontName(), Font::getDefaultSerifFontName(),
		or Font::getDefaultMonospacedFontName(), which are not actual platform-specific font names,
		but are generic names that are used to represent the various default fonts.

		If you need to know the exact typeface name being used, you can call
		Font::getTypeface()->getTypefaceName(), which will give you the platform-specific name.
	*/
	const String& getTypefaceName() const noexcept;

	/** Returns a typeface name that represents the default sans-serif font.

		This is also the typeface that will be used when a font is created without
		specifying any typeface details.

		Note that this method just returns a generic placeholder string that means "the default
		sans-serif font" - it's not the actual name of this font.

		@see setTypefaceName, getDefaultSerifFontName, getDefaultMonospacedFontName
	*/
	static const String& getDefaultSansSerifFontName();

	/** Returns a typeface name that represents the default sans-serif font.

		Note that this method just returns a generic placeholder string that means "the default
		serif font" - it's not the actual name of this font.

		@see setTypefaceName, getDefaultSansSerifFontName, getDefaultMonospacedFontName
	*/
	static const String& getDefaultSerifFontName();

	/** Returns a typeface name that represents the default sans-serif font.

		Note that this method just returns a generic placeholder string that means "the default
		monospaced font" - it's not the actual name of this font.

		@see setTypefaceName, getDefaultSansSerifFontName, getDefaultSerifFontName
	*/
	static const String& getDefaultMonospacedFontName();

	/** Returns the default system typeface for the given font. */
	static Typeface::Ptr getDefaultTypefaceForFont (const Font& font);

	/** Returns the total height of this font.

		This is the maximum height, from the top of the ascent to the bottom of the
		descenders.

		@see withHeight, setHeightWithoutChangingWidth, getAscent
	*/
	float getHeight() const noexcept;

	/** Returns a copy of this font with a new height. */
	Font withHeight (float height) const;

	/** Changes the font's height.
		@see getHeight, withHeight, setHeightWithoutChangingWidth
	*/
	void setHeight (float newHeight);

	/** Changes the font's height without changing its width.
		This alters the horizontal scale to compensate for the change in height.
	*/
	void setHeightWithoutChangingWidth (float newHeight);

	/** Returns the height of the font above its baseline.
		This is the maximum height from the baseline to the top.
		@see getHeight, getDescent
	*/
	float getAscent() const;

	/** Returns the amount that the font descends below its baseline.
		This is calculated as (getHeight() - getAscent()).
		@see getAscent, getHeight
	*/
	float getDescent() const;

	/** Returns the font's style flags.
		This will return a bitwise-or'ed combination of values from the FontStyleFlags
		enum, to describe whether the font is bold, italic, etc.
		@see FontStyleFlags, withStyle
	*/
	int getStyleFlags() const noexcept;

	/** Returns a copy of this font with the given set of style flags.
		@param styleFlags     a bitwise-or'ed combination of values from the FontStyleFlags enum.
		@see FontStyleFlags, getStyleFlags
	*/
	Font withStyle (int styleFlags) const;

	/** Changes the font's style.
		@param newFlags     a bitwise-or'ed combination of values from the FontStyleFlags enum.
		@see FontStyleFlags, withStyle
	*/
	void setStyleFlags (int newFlags);

	/** Makes the font bold or non-bold. */
	void setBold (bool shouldBeBold);
	/** Returns a copy of this font with the bold attribute set. */
	Font boldened() const;
	/** Returns true if the font is bold. */
	bool isBold() const noexcept;

	/** Makes the font italic or non-italic. */
	void setItalic (bool shouldBeItalic);
	/** Returns a copy of this font with the italic attribute set. */
	Font italicised() const;
	/** Returns true if the font is italic. */
	bool isItalic() const noexcept;

	/** Makes the font underlined or non-underlined. */
	void setUnderline (bool shouldBeUnderlined);
	/** Returns true if the font is underlined. */
	bool isUnderlined() const noexcept;

	/** Returns the font's horizontal scale.

		A value of 1.0 is the normal scale, less than this will be narrower, greater
		than 1.0 will be stretched out.

		@see withHorizontalScale
	*/
	float getHorizontalScale() const noexcept;

	/** Returns a copy of this font with a new horizontal scale.
		@param scaleFactor  a value of 1.0 is the normal scale, less than this will be
							narrower, greater than 1.0 will be stretched out.
		@see getHorizontalScale
	*/
	Font withHorizontalScale (float scaleFactor) const;

	/** Changes the font's horizontal scale factor.
		@param scaleFactor  a value of 1.0 is the normal scale, less than this will be
							narrower, greater than 1.0 will be stretched out.
	*/
	void setHorizontalScale (float scaleFactor);

	/** Returns the font's kerning.

		This is the extra space added between adjacent characters, as a proportion
		of the font's height.

		A value of zero is normal spacing, positive values will spread the letters
		out more, and negative values make them closer together.
	*/
	float getExtraKerningFactor() const noexcept;

	/** Returns a copy of this font with a new kerning factor.
		@param extraKerning     a multiple of the font's height that will be added
								to space between the characters. So a value of zero is
								normal spacing, positive values spread the letters out,
								negative values make them closer together.
	*/
	Font withExtraKerningFactor (float extraKerning) const;

	/** Changes the font's kerning.
		@param extraKerning     a multiple of the font's height that will be added
								to space between the characters. So a value of zero is
								normal spacing, positive values spread the letters out,
								negative values make them closer together.
	*/
	void setExtraKerningFactor (float extraKerning);

	/** Changes all the font's characteristics with one call. */
	void setSizeAndStyle (float newHeight,
						  int newStyleFlags,
						  float newHorizontalScale,
						  float newKerningAmount);

	/** Returns the total width of a string as it would be drawn using this font.

		For a more accurate floating-point result, use getStringWidthFloat().
	*/
	int getStringWidth (const String& text) const;

	/** Returns the total width of a string as it would be drawn using this font.

		@see getStringWidth
	*/
	float getStringWidthFloat (const String& text) const;

	/** Returns the series of glyph numbers and their x offsets needed to represent a string.

		An extra x offset is added at the end of the run, to indicate where the right hand
		edge of the last character is.
	*/
	void getGlyphPositions (const String& text, Array <int>& glyphs, Array <float>& xOffsets) const;

	/** Returns the typeface used by this font.

		Note that the object returned may go out of scope if this font is deleted
		or has its style changed.
	*/
	Typeface* getTypeface() const;

	/** Creates an array of Font objects to represent all the fonts on the system.

		If you just need the names of the typefaces, you can also use
		findAllTypefaceNames() instead.

		@param results  the array to which new Font objects will be added.
	*/
	static void findFonts (Array<Font>& results);

	/** Returns a list of all the available typeface names.

		The names returned can be passed into setTypefaceName().

		You can use this instead of findFonts() if you only need their names, and not
		font objects.
	*/
	static StringArray findAllTypefaceNames();

	/** Returns the name of the typeface to be used for rendering glyphs that aren't found
		in the requested typeface.
	*/
	static const String& getFallbackFontName();

	/** Sets the (platform-specific) name of the typeface to use to find glyphs that aren't
		available in whatever font you're trying to use.
	*/
	static void setFallbackFontName (const String& name);

	/** Creates a string to describe this font.
		The string will contain information to describe the font's typeface, size, and
		style. To recreate the font from this string, use fromString().
	*/
	String toString() const;

	/** Recreates a font from its stringified encoding.
		This method takes a string that was created by toString(), and recreates the
		original font.
	*/
	static Font fromString (const String& fontDescription);

private:

	class SharedFontInternal;
	ReferenceCountedObjectPtr <SharedFontInternal> font;
	void dupeInternalIfShared();

	JUCE_LEAK_DETECTOR (Font);
};

#endif   // __JUCE_FONT_JUCEHEADER__

/*** End of inlined file: juce_Font.h ***/


/*** Start of inlined file: juce_Rectangle.h ***/
#ifndef __JUCE_RECTANGLE_JUCEHEADER__
#define __JUCE_RECTANGLE_JUCEHEADER__

class RectangleList;

/**
	Manages a rectangle and allows geometric operations to be performed on it.

	@see RectangleList, Path, Line, Point
*/
template <typename ValueType>
class Rectangle
{
public:

	/** Creates a rectangle of zero size.

		The default co-ordinates will be (0, 0, 0, 0).
	*/
	Rectangle() noexcept
	  : w(), h()
	{
	}

	/** Creates a copy of another rectangle. */
	Rectangle (const Rectangle& other) noexcept
	  : pos (other.pos), w (other.w), h (other.h)
	{
	}

	/** Creates a rectangle with a given position and size. */
	Rectangle (const ValueType initialX, const ValueType initialY,
			   const ValueType width, const ValueType height) noexcept
	  : pos (initialX, initialY),
		w (width), h (height)
	{
	}

	/** Creates a rectangle with a given size, and a position of (0, 0). */
	Rectangle (const ValueType width, const ValueType height) noexcept
	  : w (width), h (height)
	{
	}

	/** Creates a Rectangle from the positions of two opposite corners. */
	Rectangle (const Point<ValueType>& corner1, const Point<ValueType>& corner2) noexcept
	  : pos (jmin (corner1.x, corner2.x),
			 jmin (corner1.y, corner2.y)),
		w (corner1.x - corner2.x),
		h (corner1.y - corner2.y)
	{
		if (w < ValueType()) w = -w;
		if (h < ValueType()) h = -h;
	}

	/** Creates a Rectangle from a set of left, right, top, bottom coordinates.
		The right and bottom values must be larger than the left and top ones, or the resulting
		rectangle will have a negative size.
	*/
	static Rectangle leftTopRightBottom (const ValueType left, const ValueType top,
										 const ValueType right, const ValueType bottom) noexcept
	{
		return Rectangle (left, top, right - left, bottom - top);
	}

	Rectangle& operator= (const Rectangle& other) noexcept
	{
		pos = other.pos;
		w = other.w; h = other.h;
		return *this;
	}

	/** Destructor. */
	~Rectangle() noexcept {}

	/** Returns true if the rectangle's width and height are both zero or less */
	bool isEmpty() const noexcept                                   { return w <= ValueType() || h <= ValueType(); }

	/** Returns the x co-ordinate of the rectangle's left-hand-side. */
	inline ValueType getX() const noexcept                          { return pos.x; }

	/** Returns the y co-ordinate of the rectangle's top edge. */
	inline ValueType getY() const noexcept                          { return pos.y; }

	/** Returns the width of the rectangle. */
	inline ValueType getWidth() const noexcept                      { return w; }

	/** Returns the height of the rectangle. */
	inline ValueType getHeight() const noexcept                     { return h; }

	/** Returns the x co-ordinate of the rectangle's right-hand-side. */
	inline ValueType getRight() const noexcept                      { return pos.x + w; }

	/** Returns the y co-ordinate of the rectangle's bottom edge. */
	inline ValueType getBottom() const noexcept                     { return pos.y + h; }

	/** Returns the x co-ordinate of the rectangle's centre. */
	ValueType getCentreX() const noexcept                           { return pos.x + w / (ValueType) 2; }

	/** Returns the y co-ordinate of the rectangle's centre. */
	ValueType getCentreY() const noexcept                           { return pos.y + h / (ValueType) 2; }

	/** Returns the centre point of the rectangle. */
	Point<ValueType> getCentre() const noexcept                     { return Point<ValueType> (pos.x + w / (ValueType) 2,
																							   pos.y + h / (ValueType) 2); }

	/** Returns the aspect ratio of the rectangle's width / height.
		If widthOverHeight is true, it returns width / height; if widthOverHeight is false,
		it returns height / width. */
	ValueType getAspectRatio (const bool widthOverHeight = true) const noexcept                     { return widthOverHeight ? w / h : h / w; }

	/** Returns the rectangle's top-left position as a Point. */
	const Point<ValueType>& getPosition() const noexcept                                            { return pos; }

	/** Changes the position of the rectangle's top-left corner (leaving its size unchanged). */
	void setPosition (const Point<ValueType>& newPos) noexcept                                      { pos = newPos; }

	/** Changes the position of the rectangle's top-left corner (leaving its size unchanged). */
	void setPosition (const ValueType newX, const ValueType newY) noexcept                          { pos.setXY (newX, newY); }

	/** Returns a rectangle with the same size as this one, but a new position. */
	Rectangle withPosition (const ValueType newX, const ValueType newY) const noexcept              { return Rectangle (newX, newY, w, h); }

	/** Returns a rectangle with the same size as this one, but a new position. */
	Rectangle withPosition (const Point<ValueType>& newPos) const noexcept                          { return Rectangle (newPos.x, newPos.y, w, h); }

	/** Returns the rectangle's top-left position as a Point. */
	const Point<ValueType>& getTopLeft() const noexcept                                             { return pos; }

	/** Returns the rectangle's top-right position as a Point. */
	Point<ValueType> getTopRight() const noexcept                                                   { return Point<ValueType> (pos.x + w, pos.y); }

	/** Returns the rectangle's bottom-left position as a Point. */
	Point<ValueType> getBottomLeft() const noexcept                                                 { return Point<ValueType> (pos.x, pos.y + h); }

	/** Returns the rectangle's bottom-right position as a Point. */
	Point<ValueType> getBottomRight() const noexcept                                                { return Point<ValueType> (pos.x + w, pos.y + h); }

	/** Changes the rectangle's size, leaving the position of its top-left corner unchanged. */
	void setSize (const ValueType newWidth, const ValueType newHeight) noexcept                     { w = newWidth; h = newHeight; }

	/** Returns a rectangle with the same position as this one, but a new size. */
	Rectangle withSize (const ValueType newWidth, const ValueType newHeight) const noexcept         { return Rectangle (pos.x, pos.y, newWidth, newHeight); }

	/** Changes all the rectangle's co-ordinates. */
	void setBounds (const ValueType newX, const ValueType newY,
					const ValueType newWidth, const ValueType newHeight) noexcept
	{
		pos.x = newX; pos.y = newY; w = newWidth; h = newHeight;
	}

	/** Changes the rectangle's X coordinate */
	void setX (const ValueType newX) noexcept                       { pos.x = newX; }

	/** Changes the rectangle's Y coordinate */
	void setY (const ValueType newY) noexcept                       { pos.y = newY; }

	/** Changes the rectangle's width */
	void setWidth (const ValueType newWidth) noexcept               { w = newWidth; }

	/** Changes the rectangle's height */
	void setHeight (const ValueType newHeight) noexcept             { h = newHeight; }

	/** Returns a rectangle which has the same size and y-position as this one, but with a different x-position. */
	Rectangle withX (const ValueType newX) const noexcept                                     { return Rectangle (newX, pos.y, w, h); }

	/** Returns a rectangle which has the same size and x-position as this one, but with a different y-position. */
	Rectangle withY (const ValueType newY) const noexcept                                     { return Rectangle (pos.x, newY, w, h); }

	/** Returns a rectangle which has the same position and height as this one, but with a different width. */
	Rectangle withWidth (const ValueType newWidth) const noexcept                             { return Rectangle (pos.x, pos.y, newWidth, h); }

	/** Returns a rectangle which has the same position and width as this one, but with a different height. */
	Rectangle withHeight (const ValueType newHeight) const noexcept                           { return Rectangle (pos.x, pos.y, w, newHeight); }

	/** Moves the x position, adjusting the width so that the right-hand edge remains in the same place.
		If the x is moved to be on the right of the current right-hand edge, the width will be set to zero.
		@see withLeft
	*/
	void setLeft (const ValueType newLeft) noexcept
	{
		w = jmax (ValueType(), pos.x + w - newLeft);
		pos.x = newLeft;
	}

	/** Returns a new rectangle with a different x position, but the same right-hand edge as this one.
		If the new x is beyond the right of the current right-hand edge, the width will be set to zero.
		@see setLeft
	*/
	Rectangle withLeft (const ValueType newLeft) const noexcept       { return Rectangle (newLeft, pos.y, jmax (ValueType(), pos.x + w - newLeft), h); }

	/** Moves the y position, adjusting the height so that the bottom edge remains in the same place.
		If the y is moved to be below the current bottom edge, the height will be set to zero.
		@see withTop
	*/
	void setTop (const ValueType newTop) noexcept
	{
		h = jmax (ValueType(), pos.y + h - newTop);
		pos.y = newTop;
	}

	/** Returns a new rectangle with a different y position, but the same bottom edge as this one.
		If the new y is beyond the bottom of the current rectangle, the height will be set to zero.
		@see setTop
	*/
	Rectangle withTop (const ValueType newTop) const noexcept         { return Rectangle (pos.x, newTop, w, jmax (ValueType(), pos.y + h - newTop)); }

	/** Adjusts the width so that the right-hand edge of the rectangle has this new value.
		If the new right is below the current X value, the X will be pushed down to match it.
		@see getRight, withRight
	*/
	void setRight (const ValueType newRight) noexcept
	{
		pos.x = jmin (pos.x, newRight);
		w = newRight - pos.x;
	}

	/** Returns a new rectangle with a different right-hand edge position, but the same left-hand edge as this one.
		If the new right edge is below the current left-hand edge, the width will be set to zero.
		@see setRight
	*/
	Rectangle withRight (const ValueType newRight) const noexcept     { return Rectangle (jmin (pos.x, newRight), pos.y, jmax (ValueType(), newRight - pos.x), h); }

	/** Adjusts the height so that the bottom edge of the rectangle has this new value.
		If the new bottom is lower than the current Y value, the Y will be pushed down to match it.
		@see getBottom, withBottom
	*/
	void setBottom (const ValueType newBottom) noexcept
	{
		pos.y = jmin (pos.y, newBottom);
		h = newBottom - pos.y;
	}

	/** Returns a new rectangle with a different bottom edge position, but the same top edge as this one.
		If the new y is beyond the bottom of the current rectangle, the height will be set to zero.
		@see setBottom
	*/
	Rectangle withBottom (const ValueType newBottom) const noexcept   { return Rectangle (pos.x, jmin (pos.y, newBottom), w, jmax (ValueType(), newBottom - pos.y)); }

	/** Moves the rectangle's position by adding amount to its x and y co-ordinates. */
	void translate (const ValueType deltaX,
					const ValueType deltaY) noexcept
	{
		pos.x += deltaX;
		pos.y += deltaY;
	}

	/** Returns a rectangle which is the same as this one moved by a given amount. */
	Rectangle translated (const ValueType deltaX,
						  const ValueType deltaY) const noexcept
	{
		return Rectangle (pos.x + deltaX, pos.y + deltaY, w, h);
	}

	/** Returns a rectangle which is the same as this one moved by a given amount. */
	Rectangle operator+ (const Point<ValueType>& deltaPosition) const noexcept
	{
		return Rectangle (pos.x + deltaPosition.x, pos.y + deltaPosition.y, w, h);
	}

	/** Moves this rectangle by a given amount. */
	Rectangle& operator+= (const Point<ValueType>& deltaPosition) noexcept
	{
		pos += deltaPosition;
		return *this;
	}

	/** Returns a rectangle which is the same as this one moved by a given amount. */
	Rectangle operator- (const Point<ValueType>& deltaPosition) const noexcept
	{
		return Rectangle (pos.x - deltaPosition.x, pos.y - deltaPosition.y, w, h);
	}

	/** Moves this rectangle by a given amount. */
	Rectangle& operator-= (const Point<ValueType>& deltaPosition) noexcept
	{
		pos -= deltaPosition;
		return *this;
	}

	/** Expands the rectangle by a given amount.

		Effectively, its new size is (x - deltaX, y - deltaY, w + deltaX * 2, h + deltaY * 2).
		@see expanded, reduce, reduced
	*/
	void expand (const ValueType deltaX,
				 const ValueType deltaY) noexcept
	{
		const ValueType nw = jmax (ValueType(), w + deltaX * 2);
		const ValueType nh = jmax (ValueType(), h + deltaY * 2);
		setBounds (pos.x - deltaX, pos.y - deltaY, nw, nh);
	}

	/** Returns a rectangle that is larger than this one by a given amount.

		Effectively, the rectangle returned is (x - deltaX, y - deltaY, w + deltaX * 2, h + deltaY * 2).
		@see expand, reduce, reduced
	*/
	Rectangle expanded (const ValueType deltaX,
						const ValueType deltaY) const noexcept
	{
		const ValueType nw = jmax (ValueType(), w + deltaX * 2);
		const ValueType nh = jmax (ValueType(), h + deltaY * 2);
		return Rectangle (pos.x - deltaX, pos.y - deltaY, nw, nh);
	}

	/** Shrinks the rectangle by a given amount.

		Effectively, its new size is (x + deltaX, y + deltaY, w - deltaX * 2, h - deltaY * 2).
		@see reduced, expand, expanded
	*/
	void reduce (const ValueType deltaX,
				 const ValueType deltaY) noexcept
	{
		expand (-deltaX, -deltaY);
	}

	/** Returns a rectangle that is smaller than this one by a given amount.

		Effectively, the rectangle returned is (x + deltaX, y + deltaY, w - deltaX * 2, h - deltaY * 2).
		@see reduce, expand, expanded
	*/
	Rectangle reduced (const ValueType deltaX,
					   const ValueType deltaY) const noexcept
	{
		return expanded (-deltaX, -deltaY);
	}

	/** Removes a strip from the top of this rectangle, reducing this rectangle
		by the specified amount and returning the section that was removed.

		E.g. if this rectangle is (100, 100, 300, 300) and amountToRemove is 50, this will
		return (100, 100, 300, 50) and leave this rectangle as (100, 150, 300, 250).

		If amountToRemove is greater than the height of this rectangle, it'll be clipped to
		that value.
	*/
	Rectangle removeFromTop (const ValueType amountToRemove) noexcept
	{
		const Rectangle r (pos.x, pos.y, w, jmin (amountToRemove, h));
		pos.y += r.h; h -= r.h;
		return r;
	}

	/** Removes a strip from the left-hand edge of this rectangle, reducing this rectangle
		by the specified amount and returning the section that was removed.

		E.g. if this rectangle is (100, 100, 300, 300) and amountToRemove is 50, this will
		return (100, 100, 50, 300) and leave this rectangle as (150, 100, 250, 300).

		If amountToRemove is greater than the width of this rectangle, it'll be clipped to
		that value.
	*/
	Rectangle removeFromLeft (const ValueType amountToRemove) noexcept
	{
		const Rectangle r (pos.x, pos.y, jmin (amountToRemove, w), h);
		pos.x += r.w; w -= r.w;
		return r;
	}

	/** Removes a strip from the right-hand edge of this rectangle, reducing this rectangle
		by the specified amount and returning the section that was removed.

		E.g. if this rectangle is (100, 100, 300, 300) and amountToRemove is 50, this will
		return (250, 100, 50, 300) and leave this rectangle as (100, 100, 250, 300).

		If amountToRemove is greater than the width of this rectangle, it'll be clipped to
		that value.
	*/
	Rectangle removeFromRight (ValueType amountToRemove) noexcept
	{
		amountToRemove = jmin (amountToRemove, w);
		const Rectangle r (pos.x + w - amountToRemove, pos.y, amountToRemove, h);
		w -= amountToRemove;
		return r;
	}

	/** Removes a strip from the bottom of this rectangle, reducing this rectangle
		by the specified amount and returning the section that was removed.

		E.g. if this rectangle is (100, 100, 300, 300) and amountToRemove is 50, this will
		return (100, 250, 300, 50) and leave this rectangle as (100, 100, 300, 250).

		If amountToRemove is greater than the height of this rectangle, it'll be clipped to
		that value.
	*/
	Rectangle removeFromBottom (ValueType amountToRemove) noexcept
	{
		amountToRemove = jmin (amountToRemove, h);
		const Rectangle r (pos.x, pos.y + h - amountToRemove, w, amountToRemove);
		h -= amountToRemove;
		return r;
	}

	/** Returns true if the two rectangles are identical. */
	bool operator== (const Rectangle& other) const noexcept
	{
		return pos == other.pos && w == other.w && h == other.h;
	}

	/** Returns true if the two rectangles are not identical. */
	bool operator!= (const Rectangle& other) const noexcept
	{
		return pos != other.pos || w != other.w || h != other.h;
	}

	/** Returns true if this co-ordinate is inside the rectangle. */
	bool contains (const ValueType xCoord, const ValueType yCoord) const noexcept
	{
		return xCoord >= pos.x && yCoord >= pos.y && xCoord < pos.x + w && yCoord < pos.y + h;
	}

	/** Returns true if this co-ordinate is inside the rectangle. */
	bool contains (const Point<ValueType>& point) const noexcept
	{
		return point.x >= pos.x && point.y >= pos.y && point.x < pos.x + w && point.y < pos.y + h;
	}

	/** Returns true if this other rectangle is completely inside this one. */
	bool contains (const Rectangle& other) const noexcept
	{
		return pos.x <= other.pos.x && pos.y <= other.pos.y
			&& pos.x + w >= other.pos.x + other.w && pos.y + h >= other.pos.y + other.h;
	}

	/** Returns the nearest point to the specified point that lies within this rectangle. */
	Point<ValueType> getConstrainedPoint (const Point<ValueType>& point) const noexcept
	{
		return Point<ValueType> (jlimit (pos.x, pos.x + w, point.x),
								 jlimit (pos.y, pos.y + h, point.y));
	}

	/** Returns true if any part of another rectangle overlaps this one. */
	bool intersects (const Rectangle& other) const noexcept
	{
		return pos.x + w > other.pos.x
			&& pos.y + h > other.pos.y
			&& pos.x < other.pos.x + other.w
			&& pos.y < other.pos.y + other.h
			&& w > ValueType() && h > ValueType();
	}

	/** Returns the region that is the overlap between this and another rectangle.

		If the two rectangles don't overlap, the rectangle returned will be empty.
	*/
	Rectangle getIntersection (const Rectangle& other) const noexcept
	{
		const ValueType nx = jmax (pos.x, other.pos.x);
		const ValueType ny = jmax (pos.y, other.pos.y);
		const ValueType nw = jmin (pos.x + w, other.pos.x + other.w) - nx;
		const ValueType nh = jmin (pos.y + h, other.pos.y + other.h) - ny;

		if (nw >= ValueType() && nh >= ValueType())
			return Rectangle (nx, ny, nw, nh);

		return Rectangle();
	}

	/** Clips a rectangle so that it lies only within this one.
		This is a non-static version of intersectRectangles().
		Returns false if the two regions didn't overlap.
	*/
	bool intersectRectangle (ValueType& otherX, ValueType& otherY, ValueType& otherW, ValueType& otherH) const noexcept
	{
		const ValueType maxX (jmax (otherX, pos.x));
		otherW = jmin (otherX + otherW, pos.x + w) - maxX;

		if (otherW > ValueType())
		{
			const ValueType maxY (jmax (otherY, pos.y));
			otherH = jmin (otherY + otherH, pos.y + h) - maxY;

			if (otherH > ValueType())
			{
				otherX = maxX; otherY = maxY;
				return true;
			}
		}

		return false;
	}

	/** Returns the smallest rectangle that contains both this one and the one passed-in.

		If either this or the other rectangle are empty, they will not be counted as
		part of the resulting region.
	*/
	Rectangle getUnion (const Rectangle& other) const noexcept
	{
		if (other.isEmpty())  return *this;
		if (isEmpty())        return other;

		const ValueType newX = jmin (pos.x, other.pos.x);
		const ValueType newY = jmin (pos.y, other.pos.y);

		return Rectangle (newX, newY,
						  jmax (pos.x + w, other.pos.x + other.w) - newX,
						  jmax (pos.y + h, other.pos.y + other.h) - newY);
	}

	/** If this rectangle merged with another one results in a simple rectangle, this
		will set this rectangle to the result, and return true.

		Returns false and does nothing to this rectangle if the two rectangles don't overlap,
		or if they form a complex region.
	*/
	bool enlargeIfAdjacent (const Rectangle& other) noexcept
	{
		if (pos.x == other.pos.x && getRight() == other.getRight()
			 && (other.getBottom() >= pos.y && other.pos.y <= getBottom()))
		{
			const ValueType newY = jmin (pos.y, other.pos.y);
			h = jmax (getBottom(), other.getBottom()) - newY;
			pos.y = newY;
			return true;
		}
		else if (pos.y == other.pos.y && getBottom() == other.getBottom()
				  && (other.getRight() >= pos.x && other.pos.x <= getRight()))
		{
			const ValueType newX = jmin (pos.x, other.pos.x);
			w = jmax (getRight(), other.getRight()) - newX;
			pos.x = newX;
			return true;
		}

		return false;
	}

	/** If after removing another rectangle from this one the result is a simple rectangle,
		this will set this object's bounds to be the result, and return true.

		Returns false and does nothing to this rectangle if the two rectangles don't overlap,
		or if removing the other one would form a complex region.
	*/
	bool reduceIfPartlyContainedIn (const Rectangle& other) noexcept
	{
		int inside = 0;
		const ValueType otherR (other.getRight());
		if (pos.x >= other.pos.x && pos.x < otherR) inside = 1;
		const ValueType otherB (other.getBottom());
		if (pos.y >= other.pos.y && pos.y < otherB) inside |= 2;
		const ValueType r (pos.x + w);
		if (r >= other.pos.x && r < otherR) inside |= 4;
		const ValueType b (pos.y + h);
		if (b >= other.pos.y && b < otherB) inside |= 8;

		switch (inside)
		{
			case 1 + 2 + 8:     w = r - otherR; pos.x = otherR; return true;
			case 1 + 2 + 4:     h = b - otherB; pos.y = otherB; return true;
			case 2 + 4 + 8:     w = other.pos.x - pos.x; return true;
			case 1 + 4 + 8:     h = other.pos.y - pos.y; return true;
		}

		return false;
	}

	/** Returns the smallest rectangle that can contain the shape created by applying
		a transform to this rectangle.

		This should only be used on floating point rectangles.
	*/
	Rectangle transformed (const AffineTransform& transform) const noexcept
	{
		float x1 = pos.x,     y1 = pos.y;
		float x2 = pos.x + w, y2 = pos.y;
		float x3 = pos.x,     y3 = pos.y + h;
		float x4 = x2,        y4 = y3;

		transform.transformPoints (x1, y1, x2, y2);
		transform.transformPoints (x3, y3, x4, y4);

		const float rx = jmin (x1, x2, x3, x4);
		const float ry = jmin (y1, y2, y3, y4);

		return Rectangle (rx, ry,
						  jmax (x1, x2, x3, x4) - rx,
						  jmax (y1, y2, y3, y4) - ry);
	}

	/** Returns the smallest integer-aligned rectangle that completely contains this one.
		This is only relevent for floating-point rectangles, of course.
		@see toFloat()
	*/
	Rectangle<int> getSmallestIntegerContainer() const noexcept
	{
		const int x1 = static_cast <int> (std::floor (static_cast<float> (pos.x)));
		const int y1 = static_cast <int> (std::floor (static_cast<float> (pos.y)));
		const int x2 = static_cast <int> (std::ceil  (static_cast<float> (pos.x + w)));
		const int y2 = static_cast <int> (std::ceil  (static_cast<float> (pos.y + h)));

		return Rectangle<int> (x1, y1, x2 - x1, y2 - y1);
	}

	/** Returns the smallest Rectangle that can contain a set of points. */
	static Rectangle findAreaContainingPoints (const Point<ValueType>* const points, const int numPoints) noexcept
	{
		if (numPoints == 0)
			return Rectangle();

		ValueType minX (points[0].x);
		ValueType maxX (minX);
		ValueType minY (points[0].y);
		ValueType maxY (minY);

		for (int i = 1; i < numPoints; ++i)
		{
			minX = jmin (minX, points[i].x);
			maxX = jmax (maxX, points[i].x);
			minY = jmin (minY, points[i].y);
			maxY = jmax (maxY, points[i].y);
		}

		return Rectangle (minX, minY, maxX - minX, maxY - minY);
	}

	/** Casts this rectangle to a Rectangle<float>.
		Obviously this is mainly useful for rectangles that use integer types.
		@see getSmallestIntegerContainer
	*/
	Rectangle<float> toFloat() const noexcept
	{
		return Rectangle<float> (static_cast<float> (pos.x), static_cast<float> (pos.y),
								 static_cast<float> (w),     static_cast<float> (h));
	}

	/** Static utility to intersect two sets of rectangular co-ordinates.
		Returns false if the two regions didn't overlap.
		@see intersectRectangle
	*/
	static bool intersectRectangles (ValueType& x1, ValueType& y1, ValueType& w1, ValueType& h1,
									 const ValueType x2, const ValueType y2, const ValueType w2, const ValueType h2) noexcept
	{
		const ValueType x (jmax (x1, x2));
		w1 = jmin (x1 + w1, x2 + w2) - x;

		if (w1 > ValueType())
		{
			const ValueType y (jmax (y1, y2));
			h1 = jmin (y1 + h1, y2 + h2) - y;

			if (h1 > ValueType())
			{
				x1 = x; y1 = y;
				return true;
			}
		}

		return false;
	}

	/** Creates a string describing this rectangle.

		The string will be of the form "x y width height", e.g. "100 100 400 200".

		Coupled with the fromString() method, this is very handy for things like
		storing rectangles (particularly component positions) in XML attributes.

		@see fromString
	*/
	String toString() const
	{
		String s;
		s.preallocateBytes (32);
		s << pos.x << ' ' << pos.y << ' ' << w << ' ' << h;
		return s;
	}

	/** Parses a string containing a rectangle's details.

		The string should contain 4 integer tokens, in the form "x y width height". They
		can be comma or whitespace separated.

		This method is intended to go with the toString() method, to form an easy way
		of saving/loading rectangles as strings.

		@see toString
	*/
	static Rectangle fromString (const String& stringVersion)
	{
		StringArray toks;
		toks.addTokens (stringVersion.trim(), ",; \t\r\n", String::empty);

		return Rectangle (toks[0].trim().getIntValue(),
						  toks[1].trim().getIntValue(),
						  toks[2].trim().getIntValue(),
						  toks[3].trim().getIntValue());
	}

private:
	friend class RectangleList;
	Point<ValueType> pos;
	ValueType w, h;
};

#endif   // __JUCE_RECTANGLE_JUCEHEADER__

/*** End of inlined file: juce_Rectangle.h ***/


/*** Start of inlined file: juce_PathStrokeType.h ***/
#ifndef __JUCE_PATHSTROKETYPE_JUCEHEADER__
#define __JUCE_PATHSTROKETYPE_JUCEHEADER__


/*** Start of inlined file: juce_Path.h ***/
#ifndef __JUCE_PATH_JUCEHEADER__
#define __JUCE_PATH_JUCEHEADER__


/*** Start of inlined file: juce_Line.h ***/
#ifndef __JUCE_LINE_JUCEHEADER__
#define __JUCE_LINE_JUCEHEADER__

/**
	Represents a line.

	This class contains a bunch of useful methods for various geometric
	tasks.

	The ValueType template parameter should be a primitive type - float or double
	are what it's designed for. Integer types will work in a basic way, but some methods
	that perform mathematical operations may not compile, or they may not produce
	sensible results.

	@see Point, Rectangle, Path, Graphics::drawLine
*/
template <typename ValueType>
class Line
{
public:

	/** Creates a line, using (0, 0) as its start and end points. */
	Line() noexcept {}

	/** Creates a copy of another line. */
	Line (const Line& other) noexcept
		: start (other.start),
		  end (other.end)
	{
	}

	/** Creates a line based on the co-ordinates of its start and end points. */
	Line (ValueType startX, ValueType startY, ValueType endX, ValueType endY) noexcept
		: start (startX, startY),
		  end (endX, endY)
	{
	}

	/** Creates a line from its start and end points. */
	Line (const Point<ValueType>& startPoint,
		  const Point<ValueType>& endPoint) noexcept
		: start (startPoint),
		  end (endPoint)
	{
	}

	/** Copies a line from another one. */
	Line& operator= (const Line& other) noexcept
	{
		start = other.start;
		end = other.end;
		return *this;
	}

	/** Destructor. */
	~Line() noexcept {}

	/** Returns the x co-ordinate of the line's start point. */
	inline ValueType getStartX() const noexcept                             { return start.x; }

	/** Returns the y co-ordinate of the line's start point. */
	inline ValueType getStartY() const noexcept                             { return start.y; }

	/** Returns the x co-ordinate of the line's end point. */
	inline ValueType getEndX() const noexcept                               { return end.x; }

	/** Returns the y co-ordinate of the line's end point. */
	inline ValueType getEndY() const noexcept                               { return end.y; }

	/** Returns the line's start point. */
	inline const Point<ValueType>& getStart() const noexcept                { return start; }

	/** Returns the line's end point. */
	inline const Point<ValueType>& getEnd() const noexcept                  { return end; }

	/** Changes this line's start point */
	void setStart (ValueType newStartX, ValueType newStartY) noexcept       { start.setXY (newStartX, newStartY); }

	/** Changes this line's end point */
	void setEnd (ValueType newEndX, ValueType newEndY) noexcept             { end.setXY (newEndX, newEndY); }

	/** Changes this line's start point */
	void setStart (const Point<ValueType>& newStart) noexcept               { start = newStart; }

	/** Changes this line's end point */
	void setEnd (const Point<ValueType>& newEnd) noexcept                   { end = newEnd; }

	/** Returns a line that is the same as this one, but with the start and end reversed, */
	const Line reversed() const noexcept                                    { return Line (end, start); }

	/** Applies an affine transform to the line's start and end points. */
	void applyTransform (const AffineTransform& transform) noexcept
	{
		start.applyTransform (transform);
		end.applyTransform (transform);
	}

	/** Returns the length of the line. */
	ValueType getLength() const noexcept                                    { return start.getDistanceFrom (end); }

	/** Returns true if the line's start and end x co-ordinates are the same. */
	bool isVertical() const noexcept                                        { return start.x == end.x; }

	/** Returns true if the line's start and end y co-ordinates are the same. */
	bool isHorizontal() const noexcept                                      { return start.y == end.y; }

	/** Returns the line's angle.

		This value is the number of radians clockwise from the 12 o'clock direction,
		where the line's start point is considered to be at the centre.
	*/
	typename Point<ValueType>::FloatType getAngle() const noexcept          { return start.getAngleToPoint (end); }

	/** Compares two lines. */
	bool operator== (const Line& other) const noexcept                      { return start == other.start && end == other.end; }

	/** Compares two lines. */
	bool operator!= (const Line& other) const noexcept                      { return start != other.start || end != other.end; }

	/** Finds the intersection between two lines.

		@param line             the other line
		@param intersection     the position of the point where the lines meet (or
								where they would meet if they were infinitely long)
								the intersection (if the lines intersect). If the lines
								are parallel, this will just be set to the position
								of one of the line's endpoints.
		@returns    true if the line segments intersect; false if they dont. Even if they
					don't intersect, the intersection co-ordinates returned will still
					be valid
	*/
	bool intersects (const Line& line, Point<ValueType>& intersection) const noexcept
	{
		return findIntersection (start, end, line.start, line.end, intersection);
	}

	/** Finds the intersection between two lines.

		@param line     the line to intersect with
		@returns        the point at which the lines intersect, even if this lies beyond the end of the lines
	*/
	Point<ValueType> getIntersection (const Line& line) const noexcept
	{
		Point<ValueType> p;
		findIntersection (start, end, line.start, line.end, p);
		return p;
	}

	/** Returns the location of the point which is a given distance along this line.

		@param distanceFromStart    the distance to move along the line from its
									start point. This value can be negative or longer
									than the line itself
		@see getPointAlongLineProportionally
	*/
	Point<ValueType> getPointAlongLine (ValueType distanceFromStart) const noexcept
	{
		return start + (end - start) * (distanceFromStart / getLength());
	}

	/** Returns a point which is a certain distance along and to the side of this line.

		This effectively moves a given distance along the line, then another distance
		perpendicularly to this, and returns the resulting position.

		@param distanceFromStart    the distance to move along the line from its
									start point. This value can be negative or longer
									than the line itself
		@param perpendicularDistance    how far to move sideways from the line. If you're
									looking along the line from its start towards its
									end, then a positive value here will move to the
									right, negative value move to the left.
	*/
	Point<ValueType> getPointAlongLine (ValueType distanceFromStart,
										ValueType perpendicularDistance) const noexcept
	{
		const Point<ValueType> delta (end - start);
		const double length = juce_hypot ((double) delta.x,
										  (double) delta.y);
		if (length <= 0)
			return start;

		return Point<ValueType> (start.x + static_cast <ValueType> ((delta.x * distanceFromStart - delta.y * perpendicularDistance) / length),
								 start.y + static_cast <ValueType> ((delta.y * distanceFromStart + delta.x * perpendicularDistance) / length));
	}

	/** Returns the location of the point which is a given distance along this line
		proportional to the line's length.

		@param proportionOfLength   the distance to move along the line from its
									start point, in multiples of the line's length.
									So a value of 0.0 will return the line's start point
									and a value of 1.0 will return its end point. (This value
									can be negative or greater than 1.0).
		@see getPointAlongLine
	*/
	Point<ValueType> getPointAlongLineProportionally (ValueType proportionOfLength) const noexcept
	{
		return start + (end - start) * proportionOfLength;
	}

	/** Returns the smallest distance between this line segment and a given point.

		So if the point is close to the line, this will return the perpendicular
		distance from the line; if the point is a long way beyond one of the line's
		end-point's, it'll return the straight-line distance to the nearest end-point.

		pointOnLine receives the position of the point that is found.

		@returns the point's distance from the line
		@see getPositionAlongLineOfNearestPoint
	*/
	ValueType getDistanceFromPoint (const Point<ValueType>& targetPoint,
									Point<ValueType>& pointOnLine) const noexcept
	{
		const Point<ValueType> delta (end - start);
		const double length = delta.x * delta.x + delta.y * delta.y;

		if (length > 0)
		{
			const double prop = ((targetPoint.x - start.x) * delta.x
							   + (targetPoint.y - start.y) * delta.y) / length;

			if (prop >= 0 && prop <= 1.0)
			{
				pointOnLine = start + delta * static_cast <ValueType> (prop);
				return targetPoint.getDistanceFrom (pointOnLine);
			}
		}

		const float fromStart = targetPoint.getDistanceFrom (start);
		const float fromEnd = targetPoint.getDistanceFrom (end);

		if (fromStart < fromEnd)
		{
			pointOnLine = start;
			return fromStart;
		}
		else
		{
			pointOnLine = end;
			return fromEnd;
		}
	}

	/** Finds the point on this line which is nearest to a given point, and
		returns its position as a proportional position along the line.

		@returns    a value 0 to 1.0 which is the distance along this line from the
					line's start to the point which is nearest to the point passed-in. To
					turn this number into a position, use getPointAlongLineProportionally().
		@see getDistanceFromPoint, getPointAlongLineProportionally
	*/
	ValueType findNearestProportionalPositionTo (const Point<ValueType>& point) const noexcept
	{
		const Point<ValueType> delta (end - start);
		const double length = delta.x * delta.x + delta.y * delta.y;

		return length <= 0 ? 0
						   : jlimit (ValueType(), static_cast <ValueType> (1),
									 static_cast <ValueType> ((((point.x - start.x) * delta.x
															  + (point.y - start.y) * delta.y) / length)));
	}

	/** Finds the point on this line which is nearest to a given point.
		@see getDistanceFromPoint, findNearestProportionalPositionTo
	*/
	Point<ValueType> findNearestPointTo (const Point<ValueType>& point) const noexcept
	{
		return getPointAlongLineProportionally (findNearestProportionalPositionTo (point));
	}

	/** Returns true if the given point lies above this line.

		The return value is true if the point's y coordinate is less than the y
		coordinate of this line at the given x (assuming the line extends infinitely
		in both directions).
	*/
	bool isPointAbove (const Point<ValueType>& point) const noexcept
	{
		return start.x != end.x
				&& point.y < ((end.y - start.y)
									* (point.x - start.x)) / (end.x - start.x) + start.y;
	}

	/** Returns a shortened copy of this line.

		This will chop off part of the start of this line by a certain amount, (leaving the
		end-point the same), and return the new line.
	*/
	Line withShortenedStart (ValueType distanceToShortenBy) const noexcept
	{
		return Line (getPointAlongLine (jmin (distanceToShortenBy, getLength())), end);
	}

	/** Returns a shortened copy of this line.

		This will chop off part of the end of this line by a certain amount, (leaving the
		start-point the same), and return the new line.
	*/
	Line withShortenedEnd (ValueType distanceToShortenBy) const noexcept
	{
		const ValueType length = getLength();
		return Line (start, getPointAlongLine (length - jmin (distanceToShortenBy, length)));
	}

private:

	Point<ValueType> start, end;

	static bool findIntersection (const Point<ValueType>& p1, const Point<ValueType>& p2,
								  const Point<ValueType>& p3, const Point<ValueType>& p4,
								  Point<ValueType>& intersection) noexcept
	{
		if (p2 == p3)
		{
			intersection = p2;
			return true;
		}

		const Point<ValueType> d1 (p2 - p1);
		const Point<ValueType> d2 (p4 - p3);
		const ValueType divisor = d1.x * d2.y - d2.x * d1.y;

		if (divisor == 0)
		{
			if (! (d1.isOrigin() || d2.isOrigin()))
			{
				if (d1.y == 0 && d2.y != 0)
				{
					const ValueType along = (p1.y - p3.y) / d2.y;
					intersection = p1.withX (p3.x + along * d2.x);
					return along >= 0 && along <= static_cast <ValueType> (1);
				}
				else if (d2.y == 0 && d1.y != 0)
				{
					const ValueType along = (p3.y - p1.y) / d1.y;
					intersection = p3.withX (p1.x + along * d1.x);
					return along >= 0 && along <= static_cast <ValueType> (1);
				}
				else if (d1.x == 0 && d2.x != 0)
				{
					const ValueType along = (p1.x - p3.x) / d2.x;
					intersection = p1.withY (p3.y + along * d2.y);
					return along >= 0 && along <= static_cast <ValueType> (1);
				}
				else if (d2.x == 0 && d1.x != 0)
				{
					const ValueType along = (p3.x - p1.x) / d1.x;
					intersection = p3.withY (p1.y + along * d1.y);
					return along >= 0 && along <= static_cast <ValueType> (1);
				}
			}

			intersection = (p2 + p3) / static_cast <ValueType> (2);
			return false;
		}

		const ValueType along1 = ((p1.y - p3.y) * d2.x - (p1.x - p3.x) * d2.y) / divisor;
		intersection = p1 + d1 * along1;

		if (along1 < 0 || along1 > static_cast <ValueType> (1))
			return false;

		const ValueType along2 = ((p1.y - p3.y) * d1.x - (p1.x - p3.x) * d1.y) / divisor;
		return along2 >= 0 && along2 <= static_cast <ValueType> (1);
	}
};

#endif   // __JUCE_LINE_JUCEHEADER__

/*** End of inlined file: juce_Line.h ***/


/*** Start of inlined file: juce_Justification.h ***/
#ifndef __JUCE_JUSTIFICATION_JUCEHEADER__
#define __JUCE_JUSTIFICATION_JUCEHEADER__

/**
	Represents a type of justification to be used when positioning graphical items.

	e.g. it indicates whether something should be placed top-left, top-right,
	centred, etc.

	It is used in various places wherever this kind of information is needed.
*/
class JUCE_API  Justification
{
public:

	/** Creates a Justification object using a combination of flags. */
	inline Justification (int flags_) noexcept : flags (flags_) {}

	/** Creates a copy of another Justification object. */
	Justification (const Justification& other) noexcept;

	/** Copies another Justification object. */
	Justification& operator= (const Justification& other) noexcept;

	bool operator== (const Justification& other) const noexcept     { return flags == other.flags; }
	bool operator!= (const Justification& other) const noexcept     { return flags != other.flags; }

	/** Returns the raw flags that are set for this Justification object. */
	inline int getFlags() const noexcept                            { return flags; }

	/** Tests a set of flags for this object.

		@returns true if any of the flags passed in are set on this object.
	*/
	inline bool testFlags (int flagsToTest) const noexcept          { return (flags & flagsToTest) != 0; }

	/** Returns just the flags from this object that deal with vertical layout. */
	int getOnlyVerticalFlags() const noexcept;

	/** Returns just the flags from this object that deal with horizontal layout. */
	int getOnlyHorizontalFlags() const noexcept;

	/** Adjusts the position of a rectangle to fit it into a space.

		The (x, y) position of the rectangle will be updated to position it inside the
		given space according to the justification flags.
	*/
	template <typename ValueType>
	void applyToRectangle (ValueType& x, ValueType& y, ValueType w, ValueType h,
						   ValueType spaceX, ValueType spaceY, ValueType spaceW, ValueType spaceH) const noexcept
	{
		x = spaceX;
		if ((flags & horizontallyCentred) != 0)     x += (spaceW - w) / (ValueType) 2;
		else if ((flags & right) != 0)              x += spaceW - w;

		y = spaceY;
		if ((flags & verticallyCentred) != 0)       y += (spaceH - h) / (ValueType) 2;
		else if ((flags & bottom) != 0)             y += spaceH - h;
	}

	/** Returns the new position of a rectangle that has been justified to fit within a given space.
	*/
	template <typename ValueType>
	const Rectangle<ValueType> appliedToRectangle (const Rectangle<ValueType>& areaToAdjust,
												   const Rectangle<ValueType>& targetSpace) const noexcept
	{
		ValueType x = areaToAdjust.getX(), y = areaToAdjust.getY();
		applyToRectangle (x, y, areaToAdjust.getWidth(), areaToAdjust.getHeight(),
						  targetSpace.getX(), targetSpace.getY(), targetSpace.getWidth(), targetSpace.getHeight());
		return areaToAdjust.withPosition (x, y);
	}

	/** Flag values that can be combined and used in the constructor. */
	enum
	{

		/** Indicates that the item should be aligned against the left edge of the available space. */
		left                            = 1,

		/** Indicates that the item should be aligned against the right edge of the available space. */
		right                           = 2,

		/** Indicates that the item should be placed in the centre between the left and right
			sides of the available space. */
		horizontallyCentred             = 4,

		/** Indicates that the item should be aligned against the top edge of the available space. */
		top                             = 8,

		/** Indicates that the item should be aligned against the bottom edge of the available space. */
		bottom                          = 16,

		/** Indicates that the item should be placed in the centre between the top and bottom
			sides of the available space. */
		verticallyCentred               = 32,

		/** Indicates that lines of text should be spread out to fill the maximum width
			available, so that both margins are aligned vertically.
		*/
		horizontallyJustified           = 64,

		/** Indicates that the item should be centred vertically and horizontally.
			This is equivalent to (horizontallyCentred | verticallyCentred)
		*/
		centred                         = 36,

		/** Indicates that the item should be centred vertically but placed on the left hand side.
			This is equivalent to (left | verticallyCentred)
		*/
		centredLeft                     = 33,

		/** Indicates that the item should be centred vertically but placed on the right hand side.
			This is equivalent to (right | verticallyCentred)
		*/
		centredRight                    = 34,

		/** Indicates that the item should be centred horizontally and placed at the top.
			This is equivalent to (horizontallyCentred | top)
		*/
		centredTop                      = 12,

		/** Indicates that the item should be centred horizontally and placed at the bottom.
			This is equivalent to (horizontallyCentred | bottom)
		*/
		centredBottom                   = 20,

		/** Indicates that the item should be placed in the top-left corner.
			This is equivalent to (left | top)
		*/
		topLeft                         = 9,

		/** Indicates that the item should be placed in the top-right corner.
			This is equivalent to (right | top)
		*/
		topRight                        = 10,

		/** Indicates that the item should be placed in the bottom-left corner.
			This is equivalent to (left | bottom)
		*/
		bottomLeft                      = 17,

		/** Indicates that the item should be placed in the bottom-left corner.
			This is equivalent to (right | bottom)
		*/
		bottomRight                     = 18
	};

private:

	int flags;
};

#endif   // __JUCE_JUSTIFICATION_JUCEHEADER__

/*** End of inlined file: juce_Justification.h ***/

class Image;
class InputStream;
class OutputStream;

/**
	A path is a sequence of lines and curves that may either form a closed shape
	or be open-ended.

	To use a path, you can create an empty one, then add lines and curves to it
	to create shapes, then it can be rendered by a Graphics context or used
	for geometric operations.

	e.g. @code
	Path myPath;

	myPath.startNewSubPath (10.0f, 10.0f);          // move the current position to (10, 10)
	myPath.lineTo (100.0f, 200.0f);                 // draw a line from here to (100, 200)
	myPath.quadraticTo (0.0f, 150.0f, 5.0f, 50.0f); // draw a curve that ends at (5, 50)
	myPath.closeSubPath();                          // close the subpath with a line back to (10, 10)

	// add an ellipse as well, which will form a second sub-path within the path..
	myPath.addEllipse (50.0f, 50.0f, 40.0f, 30.0f);

	// double the width of the whole thing..
	myPath.applyTransform (AffineTransform::scale (2.0f, 1.0f));

	// and draw it to a graphics context with a 5-pixel thick outline.
	g.strokePath (myPath, PathStrokeType (5.0f));

	@endcode

	A path object can actually contain multiple sub-paths, which may themselves
	be open or closed.

	@see PathFlatteningIterator, PathStrokeType, Graphics
*/
class JUCE_API  Path
{
public:

	/** Creates an empty path. */
	Path();

	/** Creates a copy of another path. */
	Path (const Path& other);

	/** Destructor. */
	~Path();

	/** Copies this path from another one. */
	Path& operator= (const Path& other);

   #if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
	Path (Path&& other) noexcept;
	Path& operator= (Path&& other) noexcept;
   #endif

	bool operator== (const Path& other) const noexcept;
	bool operator!= (const Path& other) const noexcept;

	/** Returns true if the path doesn't contain any lines or curves. */
	bool isEmpty() const noexcept;

	/** Returns the smallest rectangle that contains all points within the path.
	*/
	Rectangle<float> getBounds() const noexcept;

	/** Returns the smallest rectangle that contains all points within the path
		after it's been transformed with the given tranasform matrix.
	*/
	Rectangle<float> getBoundsTransformed (const AffineTransform& transform) const noexcept;

	/** Checks whether a point lies within the path.

		This is only relevent for closed paths (see closeSubPath()), and
		may produce false results if used on a path which has open sub-paths.

		The path's winding rule is taken into account by this method.

		The tolerance parameter is the maximum error allowed when flattening the path,
		so this method could return a false positive when your point is up to this distance
		outside the path's boundary.

		@see closeSubPath, setUsingNonZeroWinding
	*/
	bool contains (float x, float y,
				   float tolerance = 1.0f) const;

	/** Checks whether a point lies within the path.

		This is only relevent for closed paths (see closeSubPath()), and
		may produce false results if used on a path which has open sub-paths.

		The path's winding rule is taken into account by this method.

		The tolerance parameter is the maximum error allowed when flattening the path,
		so this method could return a false positive when your point is up to this distance
		outside the path's boundary.

		@see closeSubPath, setUsingNonZeroWinding
	*/
	bool contains (const Point<float>& point,
				   float tolerance = 1.0f) const;

	/** Checks whether a line crosses the path.

		This will return positive if the line crosses any of the paths constituent
		lines or curves. It doesn't take into account whether the line is inside
		or outside the path, or whether the path is open or closed.

		The tolerance parameter is the maximum error allowed when flattening the path,
		so this method could return a false positive when your point is up to this distance
		outside the path's boundary.
	*/
	bool intersectsLine (const Line<float>& line,
						 float tolerance = 1.0f);

	/** Cuts off parts of a line to keep the parts that are either inside or
		outside this path.

		Note that this isn't smart enough to cope with situations where the
		line would need to be cut into multiple pieces to correctly clip against
		a re-entrant shape.

		@param line                     the line to clip
		@param keepSectionOutsidePath   if true, it's the section outside the path
										that will be kept; if false its the section inside
										the path
	*/
	Line<float> getClippedLine (const Line<float>& line, bool keepSectionOutsidePath) const;

	/** Returns the length of the path.
		@see getPointAlongPath
	*/
	float getLength (const AffineTransform& transform = AffineTransform::identity) const;

	/** Returns a point that is the specified distance along the path.
		If the distance is greater than the total length of the path, this will return the
		end point.
		@see getLength
	*/
	Point<float> getPointAlongPath (float distanceFromStart,
									const AffineTransform& transform = AffineTransform::identity) const;

	/** Finds the point along the path which is nearest to a given position.
		This sets pointOnPath to the nearest point, and returns the distance of this point from the start
		of the path.
	*/
	float getNearestPoint (const Point<float>& targetPoint,
						   Point<float>& pointOnPath,
						   const AffineTransform& transform = AffineTransform::identity) const;

	/** Removes all lines and curves, resetting the path completely. */
	void clear() noexcept;

	/** Begins a new subpath with a given starting position.

		This will move the path's current position to the co-ordinates passed in and
		make it ready to draw lines or curves starting from this position.

		After adding whatever lines and curves are needed, you can either
		close the current sub-path using closeSubPath() or call startNewSubPath()
		to move to a new sub-path, leaving the old one open-ended.

		@see lineTo, quadraticTo, cubicTo, closeSubPath
	*/
	void startNewSubPath (float startX, float startY);

	/** Begins a new subpath with a given starting position.

		This will move the path's current position to the co-ordinates passed in and
		make it ready to draw lines or curves starting from this position.

		After adding whatever lines and curves are needed, you can either
		close the current sub-path using closeSubPath() or call startNewSubPath()
		to move to a new sub-path, leaving the old one open-ended.

		@see lineTo, quadraticTo, cubicTo, closeSubPath
	*/
	void startNewSubPath (const Point<float>& start);

	/** Closes a the current sub-path with a line back to its start-point.

		When creating a closed shape such as a triangle, don't use 3 lineTo()
		calls - instead use two lineTo() calls, followed by a closeSubPath()
		to join the final point back to the start.

		This ensures that closes shapes are recognised as such, and this is
		important for tasks like drawing strokes, which needs to know whether to
		draw end-caps or not.

		@see startNewSubPath, lineTo, quadraticTo, cubicTo, closeSubPath
	*/
	void closeSubPath();

	/** Adds a line from the shape's last position to a new end-point.

		This will connect the end-point of the last line or curve that was added
		to a new point, using a straight line.

		See the class description for an example of how to add lines and curves to a path.

		@see startNewSubPath, quadraticTo, cubicTo, closeSubPath
	*/
	void lineTo (float endX, float endY);

	/** Adds a line from the shape's last position to a new end-point.

		This will connect the end-point of the last line or curve that was added
		to a new point, using a straight line.

		See the class description for an example of how to add lines and curves to a path.

		@see startNewSubPath, quadraticTo, cubicTo, closeSubPath
	*/
	void lineTo (const Point<float>& end);

	/** Adds a quadratic bezier curve from the shape's last position to a new position.

		This will connect the end-point of the last line or curve that was added
		to a new point, using a quadratic spline with one control-point.

		See the class description for an example of how to add lines and curves to a path.

		@see startNewSubPath, lineTo, cubicTo, closeSubPath
	*/
	void quadraticTo (float controlPointX,
					  float controlPointY,
					  float endPointX,
					  float endPointY);

	/** Adds a quadratic bezier curve from the shape's last position to a new position.

		This will connect the end-point of the last line or curve that was added
		to a new point, using a quadratic spline with one control-point.

		See the class description for an example of how to add lines and curves to a path.

		@see startNewSubPath, lineTo, cubicTo, closeSubPath
	*/
	void quadraticTo (const Point<float>& controlPoint,
					  const Point<float>& endPoint);

	/** Adds a cubic bezier curve from the shape's last position to a new position.

		This will connect the end-point of the last line or curve that was added
		to a new point, using a cubic spline with two control-points.

		See the class description for an example of how to add lines and curves to a path.

		@see startNewSubPath, lineTo, quadraticTo, closeSubPath
	*/
	void cubicTo (float controlPoint1X,
				  float controlPoint1Y,
				  float controlPoint2X,
				  float controlPoint2Y,
				  float endPointX,
				  float endPointY);

	/** Adds a cubic bezier curve from the shape's last position to a new position.

		This will connect the end-point of the last line or curve that was added
		to a new point, using a cubic spline with two control-points.

		See the class description for an example of how to add lines and curves to a path.

		@see startNewSubPath, lineTo, quadraticTo, closeSubPath
	*/
	void cubicTo (const Point<float>& controlPoint1,
				  const Point<float>& controlPoint2,
				  const Point<float>& endPoint);

	/** Returns the last point that was added to the path by one of the drawing methods.
	*/
	Point<float> getCurrentPosition() const;

	/** Adds a rectangle to the path.
		The rectangle is added as a new sub-path. (Any currently open paths will be left open).
		@see addRoundedRectangle, addTriangle
	*/
	void addRectangle (float x, float y, float width, float height);

	/** Adds a rectangle to the path.
		The rectangle is added as a new sub-path. (Any currently open paths will be left open).
		@see addRoundedRectangle, addTriangle
	*/
	template <typename ValueType>
	void addRectangle (const Rectangle<ValueType>& rectangle)
	{
		addRectangle (static_cast <float> (rectangle.getX()), static_cast <float> (rectangle.getY()),
					  static_cast <float> (rectangle.getWidth()), static_cast <float> (rectangle.getHeight()));
	}

	/** Adds a rectangle with rounded corners to the path.
		The rectangle is added as a new sub-path. (Any currently open paths will be left open).
		@see addRectangle, addTriangle
	*/
	void addRoundedRectangle (float x, float y, float width, float height,
							  float cornerSize);

	/** Adds a rectangle with rounded corners to the path.
		The rectangle is added as a new sub-path. (Any currently open paths will be left open).
		@see addRectangle, addTriangle
	*/
	void addRoundedRectangle (float x, float y, float width, float height,
							  float cornerSizeX,
							  float cornerSizeY);

	/** Adds a rectangle with rounded corners to the path.
		The rectangle is added as a new sub-path. (Any currently open paths will be left open).
		@see addRectangle, addTriangle
	*/
	template <typename ValueType>
	void addRoundedRectangle (const Rectangle<ValueType>& rectangle, float cornerSizeX, float cornerSizeY)
	{
		addRoundedRectangle (static_cast <float> (rectangle.getX()), static_cast <float> (rectangle.getY()),
							 static_cast <float> (rectangle.getWidth()), static_cast <float> (rectangle.getHeight()),
							 cornerSizeX, cornerSizeY);
	}

	/** Adds a rectangle with rounded corners to the path.
		The rectangle is added as a new sub-path. (Any currently open paths will be left open).
		@see addRectangle, addTriangle
	*/
	template <typename ValueType>
	void addRoundedRectangle (const Rectangle<ValueType>& rectangle, float cornerSize)
	{
		addRoundedRectangle (rectangle, cornerSize, cornerSize);
	}

	/** Adds a triangle to the path.

		The triangle is added as a new closed sub-path. (Any currently open paths will be left open).

		Note that whether the vertices are specified in clockwise or anticlockwise
		order will affect how the triangle is filled when it overlaps other
		shapes (the winding order setting will affect this of course).
	*/
	void addTriangle (float x1, float y1,
					  float x2, float y2,
					  float x3, float y3);

	/** Adds a quadrilateral to the path.

		The quad is added as a new closed sub-path. (Any currently open paths will be left open).

		Note that whether the vertices are specified in clockwise or anticlockwise
		order will affect how the quad is filled when it overlaps other
		shapes (the winding order setting will affect this of course).
	*/
	void addQuadrilateral (float x1, float y1,
						   float x2, float y2,
						   float x3, float y3,
						   float x4, float y4);

	/** Adds an ellipse to the path.

		The shape is added as a new sub-path. (Any currently open paths will be left open).

		@see addArc
	*/
	void addEllipse (float x, float y, float width, float height);

	/** Adds an elliptical arc to the current path.

		Note that when specifying the start and end angles, the curve will be drawn either clockwise
		or anti-clockwise according to whether the end angle is greater than the start. This means
		that sometimes you may need to use values greater than 2*Pi for the end angle.

		@param x            the left-hand edge of the rectangle in which the elliptical outline fits
		@param y            the top edge of the rectangle in which the elliptical outline fits
		@param width        the width of the rectangle in which the elliptical outline fits
		@param height       the height of the rectangle in which the elliptical outline fits
		@param fromRadians  the angle (clockwise) in radians at which to start the arc segment (where 0 is the
							top-centre of the ellipse)
		@param toRadians    the angle (clockwise) in radians at which to end the arc segment (where 0 is the
							top-centre of the ellipse). This angle can be greater than 2*Pi, so for example to
							draw a curve clockwise from the 9 o'clock position to the 3 o'clock position via
							12 o'clock, you'd use 1.5*Pi and 2.5*Pi as the start and finish points.
		@param startAsNewSubPath    if true, the arc will begin a new subpath from its starting point; if false,
							it will be added to the current sub-path, continuing from the current postition

		@see addCentredArc, arcTo, addPieSegment, addEllipse
	*/
	void addArc (float x, float y, float width, float height,
				 float fromRadians,
				 float toRadians,
				 bool startAsNewSubPath = false);

	/** Adds an arc which is centred at a given point, and can have a rotation specified.

		Note that when specifying the start and end angles, the curve will be drawn either clockwise
		or anti-clockwise according to whether the end angle is greater than the start. This means
		that sometimes you may need to use values greater than 2*Pi for the end angle.

		@param centreX      the centre x of the ellipse
		@param centreY      the centre y of the ellipse
		@param radiusX      the horizontal radius of the ellipse
		@param radiusY      the vertical radius of the ellipse
		@param rotationOfEllipse    an angle by which the whole ellipse should be rotated about its centre, in radians (clockwise)
		@param fromRadians  the angle (clockwise) in radians at which to start the arc segment (where 0 is the
							top-centre of the ellipse)
		@param toRadians    the angle (clockwise) in radians at which to end the arc segment (where 0 is the
							top-centre of the ellipse). This angle can be greater than 2*Pi, so for example to
							draw a curve clockwise from the 9 o'clock position to the 3 o'clock position via
							12 o'clock, you'd use 1.5*Pi and 2.5*Pi as the start and finish points.
		@param startAsNewSubPath    if true, the arc will begin a new subpath from its starting point; if false,
							it will be added to the current sub-path, continuing from the current postition

		@see addArc, arcTo
	*/
	void addCentredArc (float centreX, float centreY,
						float radiusX, float radiusY,
						float rotationOfEllipse,
						float fromRadians,
						float toRadians,
						bool startAsNewSubPath = false);

	/** Adds a "pie-chart" shape to the path.

		The shape is added as a new sub-path. (Any currently open paths will be
		left open).

		Note that when specifying the start and end angles, the curve will be drawn either clockwise
		or anti-clockwise according to whether the end angle is greater than the start. This means
		that sometimes you may need to use values greater than 2*Pi for the end angle.

		@param x            the left-hand edge of the rectangle in which the elliptical outline fits
		@param y            the top edge of the rectangle in which the elliptical outline fits
		@param width        the width of the rectangle in which the elliptical outline fits
		@param height       the height of the rectangle in which the elliptical outline fits
		@param fromRadians  the angle (clockwise) in radians at which to start the arc segment (where 0 is the
							top-centre of the ellipse)
		@param toRadians    the angle (clockwise) in radians at which to end the arc segment (where 0 is the
							top-centre of the ellipse)
		@param innerCircleProportionalSize  if this is > 0, then the pie will be drawn as a curved band around a hollow
							ellipse at its centre, where this value indicates the inner ellipse's size with
							respect to the outer one.

		@see addArc
	*/
	void addPieSegment (float x, float y,
						float width, float height,
						float fromRadians,
						float toRadians,
						float innerCircleProportionalSize);

	/** Adds a line with a specified thickness.

		The line is added as a new closed sub-path. (Any currently open paths will be
		left open).

		@see addArrow
	*/
	void addLineSegment (const Line<float>& line, float lineThickness);

	/** Adds a line with an arrowhead on the end.
		The arrow is added as a new closed sub-path. (Any currently open paths will be left open).
		@see PathStrokeType::createStrokeWithArrowheads
	*/
	void addArrow (const Line<float>& line,
				   float lineThickness,
				   float arrowheadWidth,
				   float arrowheadLength);

	/** Adds a polygon shape to the path.
		@see addStar
	*/
	void addPolygon (const Point<float>& centre,
					 int numberOfSides,
					 float radius,
					 float startAngle = 0.0f);

	/** Adds a star shape to the path.
		@see addPolygon
	*/
	void addStar (const Point<float>& centre,
				  int numberOfPoints,
				  float innerRadius,
				  float outerRadius,
				  float startAngle = 0.0f);

	/** Adds a speech-bubble shape to the path.

		@param bodyX            the left of the main body area of the bubble
		@param bodyY            the top of the main body area of the bubble
		@param bodyW            the width of the main body area of the bubble
		@param bodyH            the height of the main body area of the bubble
		@param cornerSize       the amount by which to round off the corners of the main body rectangle
		@param arrowTipX        the x position that the tip of the arrow should connect to
		@param arrowTipY        the y position that the tip of the arrow should connect to
		@param whichSide        the side to connect the arrow to: 0 = top, 1 = left, 2 = bottom, 3 = right
		@param arrowPositionAlongEdgeProportional   how far along the edge of the main rectangle the
								arrow's base should be - this is a proportional distance between 0 and 1.0
		@param arrowWidth       how wide the base of the arrow should be where it joins the main rectangle
	*/
	void addBubble (float bodyX, float bodyY,
					float bodyW, float bodyH,
					float cornerSize,
					float arrowTipX,
					float arrowTipY,
					int whichSide,
					float arrowPositionAlongEdgeProportional,
					float arrowWidth);

	/** Adds another path to this one.

		The new path is added as a new sub-path. (Any currently open paths in this
		path will be left open).

		@param pathToAppend     the path to add
	*/
	void addPath (const Path& pathToAppend);

	/** Adds another path to this one, transforming it on the way in.

		The new path is added as a new sub-path, its points being transformed by the given
		matrix before being added.

		@param pathToAppend     the path to add
		@param transformToApply an optional transform to apply to the incoming vertices
	*/
	void addPath (const Path& pathToAppend,
				  const AffineTransform& transformToApply);

	/** Swaps the contents of this path with another one.

		The internal data of the two paths is swapped over, so this is much faster than
		copying it to a temp variable and back.
	*/
	void swapWithPath (Path& other) noexcept;

	/** Applies a 2D transform to all the vertices in the path.

		@see AffineTransform, scaleToFit, getTransformToScaleToFit
	*/
	void applyTransform (const AffineTransform& transform) noexcept;

	/** Rescales this path to make it fit neatly into a given space.

		This is effectively a quick way of calling
		applyTransform (getTransformToScaleToFit (x, y, w, h, preserveProportions))

		@param x                    the x position of the rectangle to fit the path inside
		@param y                    the y position of the rectangle to fit the path inside
		@param width                the width of the rectangle to fit the path inside
		@param height               the height of the rectangle to fit the path inside
		@param preserveProportions  if true, it will fit the path into the space without altering its
									horizontal/vertical scale ratio; if false, it will distort the
									path to fill the specified ratio both horizontally and vertically

		@see applyTransform, getTransformToScaleToFit
	*/
	void scaleToFit (float x, float y, float width, float height,
					 bool preserveProportions) noexcept;

	/** Returns a transform that can be used to rescale the path to fit into a given space.

		@param x                    the x position of the rectangle to fit the path inside
		@param y                    the y position of the rectangle to fit the path inside
		@param width                the width of the rectangle to fit the path inside
		@param height               the height of the rectangle to fit the path inside
		@param preserveProportions  if true, it will fit the path into the space without altering its
									horizontal/vertical scale ratio; if false, it will distort the
									path to fill the specified ratio both horizontally and vertically
		@param justificationType    if the proportions are preseved, the resultant path may be smaller
									than the available rectangle, so this describes how it should be
									positioned within the space.
		@returns                    an appropriate transformation

		@see applyTransform, scaleToFit

	*/
	AffineTransform getTransformToScaleToFit (float x, float y, float width, float height,
											  bool preserveProportions,
											  const Justification& justificationType = Justification::centred) const;

	/** Creates a version of this path where all sharp corners have been replaced by curves.

		Wherever two lines meet at an angle, this will replace the corner with a curve
		of the given radius.
	*/
	Path createPathWithRoundedCorners (float cornerRadius) const;

	/** Changes the winding-rule to be used when filling the path.

		If set to true (which is the default), then the path uses a non-zero-winding rule
		to determine which points are inside the path. If set to false, it uses an
		alternate-winding rule.

		The winding-rule comes into play when areas of the shape overlap other
		areas, and determines whether the overlapping regions are considered to be
		inside or outside.

		Changing this value just sets a flag - it doesn't affect the contents of the
		path.

		@see isUsingNonZeroWinding
	*/
	void setUsingNonZeroWinding (bool isNonZeroWinding) noexcept;

	/** Returns the flag that indicates whether the path should use a non-zero winding rule.

		The default for a new path is true.

		@see setUsingNonZeroWinding
	*/
	bool isUsingNonZeroWinding() const                  { return useNonZeroWinding; }

	/** Iterates the lines and curves that a path contains.

		@see Path, PathFlatteningIterator
	*/
	class JUCE_API  Iterator
	{
	public:

		Iterator (const Path& path);
		~Iterator();

		/** Moves onto the next element in the path.

			If this returns false, there are no more elements. If it returns true,
			the elementType variable will be set to the type of the current element,
			and some of the x and y variables will be filled in with values.
		*/
		bool next();

		enum PathElementType
		{
			startNewSubPath,    /**< For this type, x1 and y1 will be set to indicate the first point in the subpath.  */
			lineTo,             /**< For this type, x1 and y1 indicate the end point of the line.  */
			quadraticTo,        /**< For this type, x1, y1, x2, y2 indicate the control point and endpoint of a quadratic curve. */
			cubicTo,            /**< For this type, x1, y1, x2, y2, x3, y3 indicate the two control points and the endpoint of a cubic curve. */
			closePath           /**< Indicates that the sub-path is being closed. None of the x or y values are valid in this case. */
		};

		PathElementType elementType;

		float x1, y1, x2, y2, x3, y3;

	private:
		const Path& path;
		size_t index;

		JUCE_DECLARE_NON_COPYABLE (Iterator);
	};

	/** Loads a stored path from a data stream.

		The data in the stream must have been written using writePathToStream().

		Note that this will append the stored path to whatever is currently in
		this path, so you might need to call clear() beforehand.

		@see loadPathFromData, writePathToStream
	*/
	void loadPathFromStream (InputStream& source);

	/** Loads a stored path from a block of data.

		This is similar to loadPathFromStream(), but just reads from a block
		of data. Useful if you're including stored shapes in your code as a
		block of static data.

		@see loadPathFromStream, writePathToStream
	*/
	void loadPathFromData (const void* data, size_t numberOfBytes);

	/** Stores the path by writing it out to a stream.

		After writing out a path, you can reload it using loadPathFromStream().

		@see loadPathFromStream, loadPathFromData
	*/
	void writePathToStream (OutputStream& destination) const;

	/** Creates a string containing a textual representation of this path.
		@see restoreFromString
	*/
	String toString() const;

	/** Restores this path from a string that was created with the toString() method.
		@see toString()
	*/
	void restoreFromString (const String& stringVersion);

private:

	friend class PathFlatteningIterator;
	friend class Path::Iterator;
	ArrayAllocationBase <float, DummyCriticalSection> data;
	size_t numElements;
	float pathXMin, pathXMax, pathYMin, pathYMax;
	bool useNonZeroWinding;

	static const float lineMarker;
	static const float moveMarker;
	static const float quadMarker;
	static const float cubicMarker;
	static const float closeSubPathMarker;

	JUCE_LEAK_DETECTOR (Path);
};

#endif   // __JUCE_PATH_JUCEHEADER__

/*** End of inlined file: juce_Path.h ***/

/**
	Describes a type of stroke used to render a solid outline along a path.

	A PathStrokeType object can be used directly to create the shape of an outline
	around a path, and is used by Graphics::strokePath to specify the type of
	stroke to draw.

	@see Path, Graphics::strokePath
*/
class JUCE_API  PathStrokeType
{
public:

	/** The type of shape to use for the corners between two adjacent line segments. */
	enum JointStyle
	{
		mitered,    /**< Indicates that corners should be drawn with sharp joints.
						 Note that for angles that curve back on themselves, drawing a
						 mitre could require extending the point too far away from the
						 path, so a mitre limit is imposed and any corners that exceed it
						 are drawn as bevelled instead. */
		curved,     /**< Indicates that corners should be drawn as rounded-off. */
		beveled     /**< Indicates that corners should be drawn with a line flattening their
						 outside edge. */
	};

	/** The type shape to use for the ends of lines. */
	enum EndCapStyle
	{
		butt,       /**< Ends of lines are flat and don't extend beyond the end point. */
		square,     /**< Ends of lines are flat, but stick out beyond the end point for half
						 the thickness of the stroke. */
		rounded     /**< Ends of lines are rounded-off with a circular shape. */
	};

	/** Creates a stroke type.

		@param strokeThickness      the width of the line to use
		@param jointStyle           the type of joints to use for corners
		@param endStyle             the type of end-caps to use for the ends of open paths.
	*/
	PathStrokeType (float strokeThickness,
					JointStyle jointStyle = mitered,
					EndCapStyle endStyle = butt) noexcept;

	/** Createes a copy of another stroke type. */
	PathStrokeType (const PathStrokeType& other) noexcept;

	/** Copies another stroke onto this one. */
	PathStrokeType& operator= (const PathStrokeType& other) noexcept;

	/** Destructor. */
	~PathStrokeType() noexcept;

	/** Applies this stroke type to a path and returns the resultant stroke as another Path.

		@param destPath         the resultant stroked outline shape will be copied into this path.
								Note that it's ok for the source and destination Paths to be
								the same object, so you can easily turn a path into a stroked version
								of itself.
		@param sourcePath       the path to use as the source
		@param transform        an optional transform to apply to the points from the source path
								as they are being used
		@param extraAccuracy    if this is greater than 1.0, it will subdivide the path to
								a higher resolution, which improves the quality if you'll later want
								to enlarge the stroked path. So for example, if you're planning on drawing
								the stroke at 3x the size that you're creating it, you should set this to 3.

		@see createDashedStroke
	*/
	void createStrokedPath (Path& destPath,
							const Path& sourcePath,
							const AffineTransform& transform = AffineTransform::identity,
							float extraAccuracy = 1.0f) const;

	/** Applies this stroke type to a path, creating a dashed line.

		This is similar to createStrokedPath, but uses the array passed in to
		break the stroke up into a series of dashes.

		@param destPath         the resultant stroked outline shape will be copied into this path.
								Note that it's ok for the source and destination Paths to be
								the same object, so you can easily turn a path into a stroked version
								of itself.
		@param sourcePath       the path to use as the source
		@param dashLengths      An array of alternating on/off lengths. E.g. { 2, 3, 4, 5 } will create
								a line of length 2, then skip a length of 3, then add a line of length 4,
								skip 5, and keep repeating this pattern.
		@param numDashLengths   The number of lengths in the dashLengths array. This should really be
								an even number, otherwise the pattern will get out of step as it
								repeats.
		@param transform        an optional transform to apply to the points from the source path
								as they are being used
		@param extraAccuracy    if this is greater than 1.0, it will subdivide the path to
								a higher resolution, which improves the quality if you'll later want
								to enlarge the stroked path. So for example, if you're planning on drawing
								the stroke at 3x the size that you're creating it, you should set this to 3.
	*/
	void createDashedStroke (Path& destPath,
							 const Path& sourcePath,
							 const float* dashLengths,
							 int numDashLengths,
							 const AffineTransform& transform = AffineTransform::identity,
							 float extraAccuracy = 1.0f) const;

	/** Applies this stroke type to a path and returns the resultant stroke as another Path.

		@param destPath             the resultant stroked outline shape will be copied into this path.
									Note that it's ok for the source and destination Paths to be
									the same object, so you can easily turn a path into a stroked version
									of itself.
		@param sourcePath           the path to use as the source
		@param arrowheadStartWidth  the width of the arrowhead at the start of the path
		@param arrowheadStartLength the length of the arrowhead at the start of the path
		@param arrowheadEndWidth    the width of the arrowhead at the end of the path
		@param arrowheadEndLength   the length of the arrowhead at the end of the path
		@param transform            an optional transform to apply to the points from the source path
									as they are being used
		@param extraAccuracy        if this is greater than 1.0, it will subdivide the path to
									a higher resolution, which improves the quality if you'll later want
									to enlarge the stroked path. So for example, if you're planning on drawing
									the stroke at 3x the size that you're creating it, you should set this to 3.
		@see createDashedStroke
	*/
	void createStrokeWithArrowheads (Path& destPath,
									 const Path& sourcePath,
									 float arrowheadStartWidth, float arrowheadStartLength,
									 float arrowheadEndWidth, float arrowheadEndLength,
									 const AffineTransform& transform = AffineTransform::identity,
									 float extraAccuracy = 1.0f) const;

	/** Returns the stroke thickness. */
	float getStrokeThickness() const noexcept                   { return thickness; }

	/** Sets the stroke thickness. */
	void setStrokeThickness (float newThickness) noexcept       { thickness = newThickness; }

	/** Returns the joint style. */
	JointStyle getJointStyle() const noexcept                   { return jointStyle; }

	/** Sets the joint style. */
	void setJointStyle (JointStyle newStyle) noexcept           { jointStyle = newStyle; }

	/** Returns the end-cap style. */
	EndCapStyle getEndStyle() const noexcept                    { return endStyle; }

	/** Sets the end-cap style. */
	void setEndStyle (EndCapStyle newStyle) noexcept            { endStyle = newStyle; }

	/** Compares the stroke thickness, joint and end styles of two stroke types. */
	bool operator== (const PathStrokeType& other) const noexcept;

	/** Compares the stroke thickness, joint and end styles of two stroke types. */
	bool operator!= (const PathStrokeType& other) const noexcept;

private:

	float thickness;
	JointStyle jointStyle;
	EndCapStyle endStyle;

	JUCE_LEAK_DETECTOR (PathStrokeType);
};

#endif   // __JUCE_PATHSTROKETYPE_JUCEHEADER__

/*** End of inlined file: juce_PathStrokeType.h ***/


/*** Start of inlined file: juce_RectanglePlacement.h ***/
#ifndef __JUCE_RECTANGLEPLACEMENT_JUCEHEADER__
#define __JUCE_RECTANGLEPLACEMENT_JUCEHEADER__

/**
	Defines the method used to postion some kind of rectangular object within
	a rectangular viewport.

	Although similar to Justification, this is more specific, and has some extra
	options.
*/
class JUCE_API  RectanglePlacement
{
public:

	/** Creates a RectanglePlacement object using a combination of flags. */
	inline RectanglePlacement (int flags_) noexcept : flags (flags_) {}

	/** Creates a copy of another RectanglePlacement object. */
	RectanglePlacement (const RectanglePlacement& other) noexcept;

	/** Copies another RectanglePlacement object. */
	RectanglePlacement& operator= (const RectanglePlacement& other) noexcept;

	bool operator== (const RectanglePlacement& other) const noexcept;
	bool operator!= (const RectanglePlacement& other) const noexcept;

	/** Flag values that can be combined and used in the constructor. */
	enum
	{

		/** Indicates that the source rectangle's left edge should be aligned with the left edge of the target rectangle. */
		xLeft                                   = 1,

		/** Indicates that the source rectangle's right edge should be aligned with the right edge of the target rectangle. */
		xRight                                  = 2,

		/** Indicates that the source should be placed in the centre between the left and right
			sides of the available space. */
		xMid                                    = 4,

		/** Indicates that the source's top edge should be aligned with the top edge of the
			destination rectangle. */
		yTop                                    = 8,

		/** Indicates that the source's bottom edge should be aligned with the bottom edge of the
			destination rectangle. */
		yBottom                                 = 16,

		/** Indicates that the source should be placed in the centre between the top and bottom
			sides of the available space. */
		yMid                                    = 32,

		/** If this flag is set, then the source rectangle will be resized to completely fill
			the destination rectangle, and all other flags are ignored.
		*/
		stretchToFit                            = 64,

		/** If this flag is set, then the source rectangle will be resized so that it is the
			minimum size to completely fill the destination rectangle, without changing its
			aspect ratio. This means that some of the source rectangle may fall outside
			the destination.

			If this flag is not set, the source will be given the maximum size at which none
			of it falls outside the destination rectangle.
		*/
		fillDestination                         = 128,

		/** Indicates that the source rectangle can be reduced in size if required, but should
			never be made larger than its original size.
		*/
		onlyReduceInSize                        = 256,

		/** Indicates that the source rectangle can be enlarged if required, but should
			never be made smaller than its original size.
		*/
		onlyIncreaseInSize                      = 512,

		/** Indicates that the source rectangle's size should be left unchanged.
		*/
		doNotResize                             = (onlyIncreaseInSize | onlyReduceInSize),

		/** A shorthand value that is equivalent to (xMid | yMid). */
		centred                                 = 4 + 32
	};

	/** Returns the raw flags that are set for this object. */
	inline int getFlags() const noexcept                            { return flags; }

	/** Tests a set of flags for this object.

		@returns true if any of the flags passed in are set on this object.
	*/
	inline bool testFlags (int flagsToTest) const noexcept          { return (flags & flagsToTest) != 0; }

	/** Adjusts the position and size of a rectangle to fit it into a space.

		The source rectangle co-ordinates will be adjusted so that they fit into
		the destination rectangle based on this object's flags.
	*/
	void applyTo (double& sourceX,
				  double& sourceY,
				  double& sourceW,
				  double& sourceH,
				  double destinationX,
				  double destinationY,
				  double destinationW,
				  double destinationH) const noexcept;

	/** Returns the transform that should be applied to these source co-ordinates to fit them
		into the destination rectangle using the current flags.
	*/
	template <typename ValueType>
	const Rectangle<ValueType> appliedTo (const Rectangle<ValueType>& source,
										  const Rectangle<ValueType>& destination) const noexcept
	{
		double x = source.getX(), y = source.getY(), w = source.getWidth(), h = source.getHeight();
		applyTo (x, y, w, h, static_cast <double> (destination.getX()), static_cast <double> (destination.getY()),
				 static_cast <double> (destination.getWidth()), static_cast <double> (destination.getHeight()));
		return Rectangle<ValueType> (static_cast <ValueType> (x), static_cast <ValueType> (y),
									 static_cast <ValueType> (w), static_cast <ValueType> (h));
	}

	/** Returns the transform that should be applied to these source co-ordinates to fit them
		into the destination rectangle using the current flags.
	*/
	const AffineTransform getTransformToFit (const Rectangle<float>& source,
											 const Rectangle<float>& destination) const noexcept;

private:

	int flags;
};

#endif   // __JUCE_RECTANGLEPLACEMENT_JUCEHEADER__

/*** End of inlined file: juce_RectanglePlacement.h ***/

class LowLevelGraphicsContext;
class Image;
class FillType;
class RectangleList;

/**
	A graphics context, used for drawing a component or image.

	When a Component needs painting, a Graphics context is passed to its
	Component::paint() method, and this you then call methods within this
	object to actually draw the component's content.

	A Graphics can also be created from an image, to allow drawing directly onto
	that image.

	@see Component::paint
*/
class JUCE_API  Graphics
{
public:

	/** Creates a Graphics object to draw directly onto the given image.

		The graphics object that is created will be set up to draw onto the image,
		with the context's clipping area being the entire size of the image, and its
		origin being the image's origin. To draw into a subsection of an image, use the
		reduceClipRegion() and setOrigin() methods.

		Obviously you shouldn't delete the image before this context is deleted.
	*/
	explicit Graphics (const Image& imageToDrawOnto);

	/** Destructor. */
	~Graphics();

	/** Changes the current drawing colour.

		This sets the colour that will now be used for drawing operations - it also
		sets the opacity to that of the colour passed-in.

		If a brush is being used when this method is called, the brush will be deselected,
		and any subsequent drawing will be done with a solid colour brush instead.

		@see setOpacity
	*/
	void setColour (const Colour& newColour);

	/** Changes the opacity to use with the current colour.

		If a solid colour is being used for drawing, this changes its opacity
		to this new value (i.e. it doesn't multiply the colour's opacity by this amount).

		If a gradient is being used, this will have no effect on it.

		A value of 0.0 is completely transparent, 1.0 is completely opaque.
	*/
	void setOpacity (float newOpacity);

	/** Sets the context to use a gradient for its fill pattern.
	*/
	void setGradientFill (const ColourGradient& gradient);

	/** Sets the context to use a tiled image pattern for filling.
		Make sure that you don't delete this image while it's still being used by
		this context!
	*/
	void setTiledImageFill (const Image& imageToUse,
							int anchorX, int anchorY,
							float opacity);

	/** Changes the current fill settings.
		@see setColour, setGradientFill, setTiledImageFill
	*/
	void setFillType (const FillType& newFill);

	/** Changes the font to use for subsequent text-drawing functions.

		Note there's also a setFont (float, int) method to quickly change the size and
		style of the current font.

		@see drawSingleLineText, drawMultiLineText, drawTextAsPath, drawText, drawFittedText
	*/
	void setFont (const Font& newFont);

	/** Changes the size and style of the currently-selected font.

		This is a convenient shortcut that changes the context's current font to a
		different size or style. The typeface won't be changed.

		@see Font
	*/
	void setFont (float newFontHeight, int fontStyleFlags = Font::plain);

	/** Returns the currently selected font. */
	Font getCurrentFont() const;

	/** Draws a one-line text string.

		This will use the current colour (or brush) to fill the text. The font is the last
		one specified by setFont().

		@param text          the string to draw
		@param startX        the position to draw the left-hand edge of the text
		@param baselineY     the position of the text's baseline
		@param justification the horizontal flags indicate which end of the text string is
							 anchored at the specified point.
		@see drawMultiLineText, drawText, drawFittedText, GlyphArrangement::addLineOfText
	*/
	void drawSingleLineText (const String& text,
							 int startX, int baselineY,
							 const Justification& justification = Justification::left) const;

	/** Draws text across multiple lines.

		This will break the text onto a new line where there's a new-line or
		carriage-return character, or at a word-boundary when the text becomes wider
		than the size specified by the maximumLineWidth parameter.

		@see setFont, drawSingleLineText, drawFittedText, GlyphArrangement::addJustifiedText
	*/
	void drawMultiLineText (const String& text,
							int startX, int baselineY,
							int maximumLineWidth) const;

	/** Renders a string of text as a vector path.

		This allows a string to be transformed with an arbitrary AffineTransform and
		rendered using the current colour/brush. It's much slower than the normal text methods
		but more accurate.

		@see setFont
	*/
	void drawTextAsPath (const String& text,
						 const AffineTransform& transform) const;

	/** Draws a line of text within a specified rectangle.

		The text will be positioned within the rectangle based on the justification
		flags passed-in. If the string is too long to fit inside the rectangle, it will
		either be truncated or will have ellipsis added to its end (if the useEllipsesIfTooBig
		flag is true).

		@see drawSingleLineText, drawFittedText, drawMultiLineText, GlyphArrangement::addJustifiedText
	*/
	void drawText (const String& text,
				   int x, int y, int width, int height,
				   const Justification& justificationType,
				   bool useEllipsesIfTooBig) const;

	/** Tries to draw a text string inside a given space.

		This does its best to make the given text readable within the specified rectangle,
		so it useful for labelling things.

		If the text is too big, it'll be squashed horizontally or broken over multiple lines
		if the maximumLinesToUse value allows this. If the text just won't fit into the space,
		it'll cram as much as possible in there, and put some ellipsis at the end to show that
		it's been truncated.

		A Justification parameter lets you specify how the text is laid out within the rectangle,
		both horizontally and vertically.

		The minimumHorizontalScale parameter specifies how much the text can be squashed horizontally
		to try to squeeze it into the space. If you don't want any horizontal scaling to occur, you
		can set this value to 1.0f.

		@see GlyphArrangement::addFittedText
	*/
	void drawFittedText (const String& text,
						 int x, int y, int width, int height,
						 const Justification& justificationFlags,
						 int maximumNumberOfLines,
						 float minimumHorizontalScale = 0.7f) const;

	/** Fills the context's entire clip region with the current colour or brush.

		(See also the fillAll (const Colour&) method which is a quick way of filling
		it with a given colour).
	*/
	void fillAll() const;

	/** Fills the context's entire clip region with a given colour.

		This leaves the context's current colour and brush unchanged, it just
		uses the specified colour temporarily.
	*/
	void fillAll (const Colour& colourToUse) const;

	/** Fills a rectangle with the current colour or brush.

		@see drawRect, fillRoundedRectangle
	*/
	void fillRect (int x, int y, int width, int height) const;

	/** Fills a rectangle with the current colour or brush. */
	void fillRect (const Rectangle<int>& rectangle) const;

	/** Fills a rectangle with the current colour or brush.

		This uses sub-pixel positioning so is slower than the fillRect method which
		takes integer co-ordinates.
	*/
	void fillRect (float x, float y, float width, float height) const;

	/** Uses the current colour or brush to fill a rectangle with rounded corners.

		@see drawRoundedRectangle, Path::addRoundedRectangle
	*/
	void fillRoundedRectangle (float x, float y, float width, float height,
							   float cornerSize) const;

	/** Uses the current colour or brush to fill a rectangle with rounded corners.

		@see drawRoundedRectangle, Path::addRoundedRectangle
	*/
	void fillRoundedRectangle (const Rectangle<float>& rectangle,
							   float cornerSize) const;

	/** Fills a rectangle with a checkerboard pattern, alternating between two colours.
	*/
	void fillCheckerBoard (const Rectangle<int>& area,
						   int checkWidth, int checkHeight,
						   const Colour& colour1, const Colour& colour2) const;

	/** Draws four lines to form a rectangular outline, using the current colour or brush.

		The lines are drawn inside the given rectangle, and greater line thicknesses
		extend inwards.

		@see fillRect
	*/
	void drawRect (int x, int y, int width, int height,
				   int lineThickness = 1) const;

	/** Draws four lines to form a rectangular outline, using the current colour or brush.

		The lines are drawn inside the given rectangle, and greater line thicknesses
		extend inwards.

		@see fillRect
	*/
	void drawRect (float x, float y, float width, float height,
				   float lineThickness = 1.0f) const;

	/** Draws four lines to form a rectangular outline, using the current colour or brush.

		The lines are drawn inside the given rectangle, and greater line thicknesses
		extend inwards.

		@see fillRect
	*/
	void drawRect (const Rectangle<int>& rectangle,
				   int lineThickness = 1) const;

	/** Uses the current colour or brush to draw the outline of a rectangle with rounded corners.

		@see fillRoundedRectangle, Path::addRoundedRectangle
	*/
	void drawRoundedRectangle (float x, float y, float width, float height,
							   float cornerSize, float lineThickness) const;

	/** Uses the current colour or brush to draw the outline of a rectangle with rounded corners.

		@see fillRoundedRectangle, Path::addRoundedRectangle
	*/
	void drawRoundedRectangle (const Rectangle<float>& rectangle,
							   float cornerSize, float lineThickness) const;

	/** Draws a 3D raised (or indented) bevel using two colours.

		The bevel is drawn inside the given rectangle, and greater bevel thicknesses
		extend inwards.

		The top-left colour is used for the top- and left-hand edges of the
		bevel; the bottom-right colour is used for the bottom- and right-hand
		edges.

		If useGradient is true, then the bevel fades out to make it look more curved
		and less angular. If sharpEdgeOnOutside is true, the outside of the bevel is
		sharp, and it fades towards the centre; if sharpEdgeOnOutside is false, then
		the centre edges are sharp and it fades towards the outside.
	*/
	void drawBevel (int x, int y, int width, int height,
					int bevelThickness,
					const Colour& topLeftColour = Colours::white,
					const Colour& bottomRightColour = Colours::black,
					bool useGradient = true,
					bool sharpEdgeOnOutside = true) const;

	/** Draws a pixel using the current colour or brush.
	*/
	void setPixel (int x, int y) const;

	/** Fills an ellipse with the current colour or brush.

		The ellipse is drawn to fit inside the given rectangle.

		@see drawEllipse, Path::addEllipse
	*/
	void fillEllipse (float x, float y, float width, float height) const;

	/** Draws an elliptical stroke using the current colour or brush.

		@see fillEllipse, Path::addEllipse
	*/
	void drawEllipse (float x, float y, float width, float height,
					  float lineThickness) const;

	/** Draws a line between two points.

		The line is 1 pixel wide and drawn with the current colour or brush.
	*/
	void drawLine (float startX, float startY, float endX, float endY) const;

	/** Draws a line between two points with a given thickness.

		@see Path::addLineSegment
	*/
	void drawLine (float startX, float startY, float endX, float endY,
				   float lineThickness) const;

	/** Draws a line between two points.

		The line is 1 pixel wide and drawn with the current colour or brush.
	*/
	void drawLine (const Line<float>& line) const;

	/** Draws a line between two points with a given thickness.

		@see Path::addLineSegment
	*/
	void drawLine (const Line<float>& line, float lineThickness) const;

	/** Draws a dashed line using a custom set of dash-lengths.

		@param line             the line to draw
		@param dashLengths      a series of lengths to specify the on/off lengths - e.g.
								{ 4, 5, 6, 7 } will draw a line of 4 pixels, skip 5 pixels,
								draw 6 pixels, skip 7 pixels, and then repeat.
		@param numDashLengths   the number of elements in the array (this must be an even number).
		@param lineThickness    the thickness of the line to draw
		@param dashIndexToStartFrom     the index in the dash-length array to use for the first segment
		@see PathStrokeType::createDashedStroke
	*/
	void drawDashedLine (const Line<float>& line,
						 const float* dashLengths, int numDashLengths,
						 float lineThickness = 1.0f,
						 int dashIndexToStartFrom = 0) const;

	/** Draws a vertical line of pixels at a given x position.

		The x position is an integer, but the top and bottom of the line can be sub-pixel
		positions, and these will be anti-aliased if necessary.

		The bottom parameter must be greater than or equal to the top parameter.
	*/
	void drawVerticalLine (int x, float top, float bottom) const;

	/** Draws a horizontal line of pixels at a given y position.

		The y position is an integer, but the left and right ends of the line can be sub-pixel
		positions, and these will be anti-aliased if necessary.

		The right parameter must be greater than or equal to the left parameter.
	*/
	void drawHorizontalLine (int y, float left, float right) const;

	/** Fills a path using the currently selected colour or brush.
	*/
	void fillPath (const Path& path,
				   const AffineTransform& transform = AffineTransform::identity) const;

	/** Draws a path's outline using the currently selected colour or brush.
	*/
	void strokePath (const Path& path,
					 const PathStrokeType& strokeType,
					 const AffineTransform& transform = AffineTransform::identity) const;

	/** Draws a line with an arrowhead at its end.

		@param line             the line to draw
		@param lineThickness    the thickness of the line
		@param arrowheadWidth   the width of the arrow head (perpendicular to the line)
		@param arrowheadLength  the length of the arrow head (along the length of the line)
	*/
	void drawArrow (const Line<float>& line,
					float lineThickness,
					float arrowheadWidth,
					float arrowheadLength) const;

	/** Types of rendering quality that can be specified when drawing images.

		@see blendImage, Graphics::setImageResamplingQuality
	*/
	enum ResamplingQuality
	{
		lowResamplingQuality     = 0,    /**< Just uses a nearest-neighbour algorithm for resampling. */
		mediumResamplingQuality  = 1,    /**< Uses bilinear interpolation for upsampling and area-averaging for downsampling. */
		highResamplingQuality    = 2     /**< Uses bicubic interpolation for upsampling and area-averaging for downsampling. */
	};

	/** Changes the quality that will be used when resampling images.

		By default a Graphics object will be set to mediumRenderingQuality.

		@see Graphics::drawImage, Graphics::drawImageTransformed, Graphics::drawImageWithin
	*/
	void setImageResamplingQuality (const ResamplingQuality newQuality);

	/** Draws an image.

		This will draw the whole of an image, positioning its top-left corner at the
		given co-ordinates, and keeping its size the same. This is the simplest image
		drawing method - the others give more control over the scaling and clipping
		of the images.

		Images are composited using the context's current opacity, so if you
		don't want it to be drawn semi-transparently, be sure to call setOpacity (1.0f)
		(or setColour() with an opaque colour) before drawing images.
	*/
	void drawImageAt (const Image& imageToDraw, int topLeftX, int topLeftY,
					  bool fillAlphaChannelWithCurrentBrush = false) const;

	/** Draws part of an image, rescaling it to fit in a given target region.

		The specified area of the source image is rescaled and drawn to fill the
		specifed destination rectangle.

		Images are composited using the context's current opacity, so if you
		don't want it to be drawn semi-transparently, be sure to call setOpacity (1.0f)
		(or setColour() with an opaque colour) before drawing images.

		@param imageToDraw      the image to overlay
		@param destX            the left of the destination rectangle
		@param destY            the top of the destination rectangle
		@param destWidth        the width of the destination rectangle
		@param destHeight       the height of the destination rectangle
		@param sourceX          the left of the rectangle to copy from the source image
		@param sourceY          the top of the rectangle to copy from the source image
		@param sourceWidth      the width of the rectangle to copy from the source image
		@param sourceHeight     the height of the rectangle to copy from the source image
		@param fillAlphaChannelWithCurrentBrush     if true, then instead of drawing the source image's pixels,
													the source image's alpha channel is used as a mask with
													which to fill the destination using the current colour
													or brush. (If the source is has no alpha channel, then
													it will just fill the target with a solid rectangle)
		@see setImageResamplingQuality, drawImageAt, drawImageWithin, fillAlphaMap
	*/
	void drawImage (const Image& imageToDraw,
					int destX, int destY, int destWidth, int destHeight,
					int sourceX, int sourceY, int sourceWidth, int sourceHeight,
					bool fillAlphaChannelWithCurrentBrush = false) const;

	/** Draws an image, having applied an affine transform to it.

		This lets you throw the image around in some wacky ways, rotate it, shear,
		scale it, etc.

		Images are composited using the context's current opacity, so if you
		don't want it to be drawn semi-transparently, be sure to call setOpacity (1.0f)
		(or setColour() with an opaque colour) before drawing images.

		If fillAlphaChannelWithCurrentBrush is set to true, then the image's RGB channels
		are ignored and it is filled with the current brush, masked by its alpha channel.

		If you want to render only a subsection of an image, use Image::getClippedImage() to
		create the section that you need.

		@see setImageResamplingQuality, drawImage
	*/
	void drawImageTransformed (const Image& imageToDraw,
							   const AffineTransform& transform,
							   bool fillAlphaChannelWithCurrentBrush = false) const;

	/** Draws an image to fit within a designated rectangle.

		If the image is too big or too small for the space, it will be rescaled
		to fit as nicely as it can do without affecting its aspect ratio. It will
		then be placed within the target rectangle according to the justification flags
		specified.

		@param imageToDraw              the source image to draw
		@param destX                    top-left of the target rectangle to fit it into
		@param destY                    top-left of the target rectangle to fit it into
		@param destWidth                size of the target rectangle to fit the image into
		@param destHeight               size of the target rectangle to fit the image into
		@param placementWithinTarget    this specifies how the image should be positioned
										within the target rectangle - see the RectanglePlacement
										class for more details about this.
		@param fillAlphaChannelWithCurrentBrush     if true, then instead of drawing the image, just its
													alpha channel will be used as a mask with which to
													draw with the current brush or colour. This is
													similar to fillAlphaMap(), and see also drawImage()
		@see setImageResamplingQuality, drawImage, drawImageTransformed, drawImageAt, RectanglePlacement
	*/
	void drawImageWithin (const Image& imageToDraw,
						  int destX, int destY, int destWidth, int destHeight,
						  const RectanglePlacement& placementWithinTarget,
						  bool fillAlphaChannelWithCurrentBrush = false) const;

	/** Returns the position of the bounding box for the current clipping region.

		@see getClipRegion, clipRegionIntersects
	*/
	Rectangle<int> getClipBounds() const;

	/** Checks whether a rectangle overlaps the context's clipping region.

		If this returns false, no part of the given area can be drawn onto, so this
		method can be used to optimise a component's paint() method, by letting it
		avoid drawing complex objects that aren't within the region being repainted.
	*/
	bool clipRegionIntersects (const Rectangle<int>& area) const;

	/** Intersects the current clipping region with another region.

		@returns true if the resulting clipping region is non-zero in size
		@see setOrigin, clipRegionIntersects
	*/
	bool reduceClipRegion (int x, int y, int width, int height);

	/** Intersects the current clipping region with another region.

		@returns true if the resulting clipping region is non-zero in size
		@see setOrigin, clipRegionIntersects
	*/
	bool reduceClipRegion (const Rectangle<int>& area);

	/** Intersects the current clipping region with a rectangle list region.

		@returns true if the resulting clipping region is non-zero in size
		@see setOrigin, clipRegionIntersects
	*/
	bool reduceClipRegion (const RectangleList& clipRegion);

	/** Intersects the current clipping region with a path.

		@returns true if the resulting clipping region is non-zero in size
		@see reduceClipRegion
	*/
	bool reduceClipRegion (const Path& path, const AffineTransform& transform = AffineTransform::identity);

	/** Intersects the current clipping region with an image's alpha-channel.

		The current clipping path is intersected with the area covered by this image's
		alpha-channel, after the image has been transformed by the specified matrix.

		@param image    the image whose alpha-channel should be used. If the image doesn't
						have an alpha-channel, it is treated as entirely opaque.
		@param transform    a matrix to apply to the image
		@returns true if the resulting clipping region is non-zero in size
		@see reduceClipRegion
	*/
	bool reduceClipRegion (const Image& image, const AffineTransform& transform);

	/** Excludes a rectangle to stop it being drawn into. */
	void excludeClipRegion (const Rectangle<int>& rectangleToExclude);

	/** Returns true if no drawing can be done because the clip region is zero. */
	bool isClipEmpty() const;

	/** Saves the current graphics state on an internal stack.
		To restore the state, use restoreState().
		@see ScopedSaveState
	*/
	void saveState();

	/** Restores a graphics state that was previously saved with saveState().
		@see ScopedSaveState
	*/
	void restoreState();

	/** Uses RAII to save and restore the state of a graphics context.
		On construction, this calls Graphics::saveState(), and on destruction it calls
		Graphics::restoreState() on the Graphics object that you supply.
	*/
	class ScopedSaveState
	{
	public:
		ScopedSaveState (Graphics& g);
		~ScopedSaveState();

	private:
		Graphics& context;

		JUCE_DECLARE_NON_COPYABLE (ScopedSaveState);
	};

	/** Begins rendering to an off-screen bitmap which will later be flattened onto the current
		context with the given opacity.

		The context uses an internal stack of temporary image layers to do this. When you've
		finished drawing to the layer, call endTransparencyLayer() to complete the operation and
		composite the finished layer. Every call to beginTransparencyLayer() MUST be matched
		by a corresponding call to endTransparencyLayer()!

		This call also saves the current state, and endTransparencyLayer() restores it.
	*/
	void beginTransparencyLayer (float layerOpacity);

	/** Completes a drawing operation to a temporary semi-transparent buffer.
		See beginTransparencyLayer() for more details.
	*/
	void endTransparencyLayer();

	/** Moves the position of the context's origin.

		This changes the position that the context considers to be (0, 0) to
		the specified position.

		So if you call setOrigin (100, 100), then the position that was previously
		referred to as (100, 100) will subsequently be considered to be (0, 0).

		@see reduceClipRegion, addTransform
	*/
	void setOrigin (int newOriginX, int newOriginY);

	/** Adds a transformation which will be performed on all the graphics operations that
		the context subsequently performs.

		After calling this, all the coordinates that are passed into the context will be
		transformed by this matrix.

		@see setOrigin
	*/
	void addTransform (const AffineTransform& transform);

	/** Resets the current colour, brush, and font to default settings. */
	void resetToDefaultState();

	/** Returns true if this context is drawing to a vector-based device, such as a printer. */
	bool isVectorDevice() const;

	/** Create a graphics that uses a given low-level renderer.
		For internal use only.
		NB. The context will NOT be deleted by this object when it is deleted.
	*/
	Graphics (LowLevelGraphicsContext* internalContext) noexcept;

	/** @internal */
	LowLevelGraphicsContext* getInternalContext() const noexcept    { return context; }

private:

	LowLevelGraphicsContext* const context;
	ScopedPointer <LowLevelGraphicsContext> contextToDelete;

	bool saveStatePending;
	void saveStateIfPending();

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (Graphics);
};

#endif   // __JUCE_GRAPHICSCONTEXT_JUCEHEADER__

/*** End of inlined file: juce_GraphicsContext.h ***/

class ImageType;
class ImagePixelData;

/**
	Holds a fixed-size bitmap.

	The image is stored in either 24-bit RGB or 32-bit premultiplied-ARGB format.

	To draw into an image, create a Graphics object for it.
	e.g. @code

	// create a transparent 500x500 image..
	Image myImage (Image::RGB, 500, 500, true);

	Graphics g (myImage);
	g.setColour (Colours::red);
	g.fillEllipse (20, 20, 300, 200);  // draws a red ellipse in our image.
	@endcode

	Other useful ways to create an image are with the ImageCache class, or the
	ImageFileFormat, which provides a way to load common image files.

	@see Graphics, ImageFileFormat, ImageCache, ImageConvolutionKernel
*/
class JUCE_API  Image
{
public:

	/**
	*/
	enum PixelFormat
	{
		UnknownFormat,
		RGB,                /**<< each pixel is a 3-byte packed RGB colour value. For byte order, see the PixelRGB class. */
		ARGB,               /**<< each pixel is a 4-byte ARGB premultiplied colour value. For byte order, see the PixelARGB class. */
		SingleChannel       /**<< each pixel is a 1-byte alpha channel value. */
	};

	/** Creates a null image. */
	Image();

	/** Creates an image with a specified size and format.

		The image's internal type will be of the NativeImageType class - to specify a
		different type, use the other constructor, which takes an ImageType to use.

		@param format           the number of colour channels in the image
		@param imageWidth       the desired width of the image, in pixels - this value must be
								greater than zero (otherwise a width of 1 will be used)
		@param imageHeight      the desired width of the image, in pixels - this value must be
								greater than zero (otherwise a height of 1 will be used)
		@param clearImage       if true, the image will initially be cleared to black (if it's RGB)
								or transparent black (if it's ARGB). If false, the image may contain
								junk initially, so you need to make sure you overwrite it thoroughly.
	*/
	Image (PixelFormat format, int imageWidth, int imageHeight, bool clearImage);

	/** Creates an image with a specified size and format.

		@param format           the number of colour channels in the image
		@param imageWidth       the desired width of the image, in pixels - this value must be
								greater than zero (otherwise a width of 1 will be used)
		@param imageHeight      the desired width of the image, in pixels - this value must be
								greater than zero (otherwise a height of 1 will be used)
		@param clearImage       if true, the image will initially be cleared to black (if it's RGB)
								or transparent black (if it's ARGB). If false, the image may contain
								junk initially, so you need to make sure you overwrite it thoroughly.
		@param type             the type of image - this lets you specify the internal format that will
								be used to allocate and manage the image data.
	*/
	Image (PixelFormat format, int imageWidth, int imageHeight, bool clearImage, const ImageType& type);

	/** Creates a shared reference to another image.

		This won't create a duplicate of the image - when Image objects are copied, they simply
		point to the same shared image data. To make sure that an Image object has its own unique,
		unshared internal data, call duplicateIfShared().
	*/
	Image (const Image& other);

	/** Makes this image refer to the same underlying image as another object.

		This won't create a duplicate of the image - when Image objects are copied, they simply
		point to the same shared image data. To make sure that an Image object has its own unique,
		unshared internal data, call duplicateIfShared().
	*/
	Image& operator= (const Image&);

   #if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
	Image (Image&& other) noexcept;
	Image& operator= (Image&&) noexcept;
   #endif

	/** Destructor. */
	~Image();

	/** Returns true if the two images are referring to the same internal, shared image. */
	bool operator== (const Image& other) const noexcept     { return image == other.image; }

	/** Returns true if the two images are not referring to the same internal, shared image. */
	bool operator!= (const Image& other) const noexcept     { return image != other.image; }

	/** Returns true if this image isn't null.
		If you create an Image with the default constructor, it has no size or content, and is null
		until you reassign it to an Image which contains some actual data.
		The isNull() method is the opposite of isValid().
		@see isNull
	*/
	inline bool isValid() const noexcept                    { return image != nullptr; }

	/** Returns true if this image is not valid.
		If you create an Image with the default constructor, it has no size or content, and is null
		until you reassign it to an Image which contains some actual data.
		The isNull() method is the opposite of isValid().
		@see isValid
	*/
	inline bool isNull() const noexcept                     { return image == nullptr; }

	/** A null Image object that can be used when you need to return an invalid image.
		This object is the equivalient to an Image created with the default constructor.
	*/
	static const Image null;

	/** Returns the image's width (in pixels). */
	int getWidth() const noexcept;

	/** Returns the image's height (in pixels). */
	int getHeight() const noexcept;

	/** Returns a rectangle with the same size as this image.
		The rectangle's origin is always (0, 0).
	*/
	Rectangle<int> getBounds() const noexcept;

	/** Returns the image's pixel format. */
	PixelFormat getFormat() const noexcept;

	/** True if the image's format is ARGB. */
	bool isARGB() const noexcept;

	/** True if the image's format is RGB. */
	bool isRGB() const noexcept;

	/** True if the image's format is a single-channel alpha map. */
	bool isSingleChannel() const noexcept;

	/** True if the image contains an alpha-channel. */
	bool hasAlphaChannel() const noexcept;

	/** Clears a section of the image with a given colour.

		This won't do any alpha-blending - it just sets all pixels in the image to
		the given colour (which may be non-opaque if the image has an alpha channel).
	*/
	void clear (const Rectangle<int>& area, const Colour& colourToClearTo = Colour (0x00000000));

	/** Returns a rescaled version of this image.

		A new image is returned which is a copy of this one, rescaled to the given size.

		Note that if the new size is identical to the existing image, this will just return
		a reference to the original image, and won't actually create a duplicate.
	*/
	Image rescaled (int newWidth, int newHeight,
					Graphics::ResamplingQuality quality = Graphics::mediumResamplingQuality) const;

	/** Creates a copy of this image.
		Note that it's usually more efficient to use duplicateIfShared(), because it may not be necessary
		to copy an image if nothing else is using it.
		@see getReferenceCount
	*/
	Image createCopy() const;

	/** Returns a version of this image with a different image format.

		A new image is returned which has been converted to the specified format.

		Note that if the new format is no different to the current one, this will just return
		a reference to the original image, and won't actually create a copy.
	*/
	Image convertedToFormat (PixelFormat newFormat) const;

	/** Makes sure that no other Image objects share the same underlying data as this one.

		If no other Image objects refer to the same shared data as this one, this method has no
		effect. But if there are other references to the data, this will create a new copy of
		the data internally.

		Call this if you want to draw onto the image, but want to make sure that this doesn't
		affect any other code that may be sharing the same data.

		@see getReferenceCount
	*/
	void duplicateIfShared();

	/** Returns an image which refers to a subsection of this image.

		This will not make a copy of the original - the new image will keep a reference to it, so that
		if the original image is changed, the contents of the subsection will also change. Likewise if you
		draw into the subimage, you'll also be drawing onto that area of the original image. Note that if
		you use operator= to make the original Image object refer to something else, the subsection image
		won't pick up this change, it'll remain pointing at the original.

		The area passed-in will be clipped to the bounds of this image, so this may return a smaller
		image than the area you asked for, or even a null image if the area was out-of-bounds.
	*/
	Image getClippedImage (const Rectangle<int>& area) const;

	/** Returns the colour of one of the pixels in the image.

		If the co-ordinates given are beyond the image's boundaries, this will
		return Colours::transparentBlack.

		@see setPixelAt, Image::BitmapData::getPixelColour
	*/
	Colour getPixelAt (int x, int y) const;

	/** Sets the colour of one of the image's pixels.

		If the co-ordinates are beyond the image's boundaries, then nothing will happen.

		Note that this won't do any alpha-blending, it'll just replace the existing pixel
		with the given one. The colour's opacity will be ignored if this image doesn't have
		an alpha-channel.

		@see getPixelAt, Image::BitmapData::setPixelColour
	*/
	void setPixelAt (int x, int y, const Colour& colour);

	/** Changes the opacity of a pixel.

		This only has an effect if the image has an alpha channel and if the
		given co-ordinates are inside the image's boundary.

		The multiplier must be in the range 0 to 1.0, and the current alpha
		at the given co-ordinates will be multiplied by this value.

		@see setPixelAt
	*/
	void multiplyAlphaAt (int x, int y, float multiplier);

	/** Changes the overall opacity of the image.

		This will multiply the alpha value of each pixel in the image by the given
		amount (limiting the resulting alpha values between 0 and 255). This allows
		you to make an image more or less transparent.

		If the image doesn't have an alpha channel, this won't have any effect.
	*/
	void multiplyAllAlphas (float amountToMultiplyBy);

	/** Changes all the colours to be shades of grey, based on their current luminosity.
	*/
	void desaturate();

	/** Retrieves a section of an image as raw pixel data, so it can be read or written to.

		You should only use this class as a last resort - messing about with the internals of
		an image is only recommended for people who really know what they're doing!

		A BitmapData object should be used as a temporary, stack-based object. Don't keep one
		hanging around while the image is being used elsewhere.

		Depending on the way the image class is implemented, this may create a temporary buffer
		which is copied back to the image when the object is deleted, or it may just get a pointer
		directly into the image's raw data.

		You can use the stride and data values in this class directly, but don't alter them!
		The actual format of the pixel data depends on the image's format - see Image::getFormat(),
		and the PixelRGB, PixelARGB and PixelAlpha classes for more info.
	*/
	class BitmapData
	{
	public:
		enum ReadWriteMode
		{
			readOnly,
			writeOnly,
			readWrite
		};

		BitmapData (Image& image, int x, int y, int w, int h, ReadWriteMode mode);
		BitmapData (const Image& image, int x, int y, int w, int h);
		BitmapData (const Image& image, ReadWriteMode mode);
		~BitmapData();

		/** Returns a pointer to the start of a line in the image.
			The co-ordinate you provide here isn't checked, so it's the caller's responsibility to make
			sure it's not out-of-range.
		*/
		inline uint8* getLinePointer (int y) const noexcept                 { return data + y * lineStride; }

		/** Returns a pointer to a pixel in the image.
			The co-ordinates you give here are not checked, so it's the caller's responsibility to make sure they're
			not out-of-range.
		*/
		inline uint8* getPixelPointer (int x, int y) const noexcept         { return data + y * lineStride + x * pixelStride; }

		/** Returns the colour of a given pixel.
			For performance reasons, this won't do any bounds-checking on the coordinates, so it's the caller's
			repsonsibility to make sure they're within the image's size.
		*/
		Colour getPixelColour (int x, int y) const noexcept;

		/** Sets the colour of a given pixel.
			For performance reasons, this won't do any bounds-checking on the coordinates, so it's the caller's
			repsonsibility to make sure they're within the image's size.
		*/
		void setPixelColour (int x, int y, const Colour& colour) const noexcept;

		uint8* data;
		PixelFormat pixelFormat;
		int lineStride, pixelStride, width, height;

		/** Used internally by custom image types to manage pixel data lifetime. */
		class BitmapDataReleaser
		{
		protected:
			BitmapDataReleaser() {}
		public:
			virtual ~BitmapDataReleaser() {}
		};

		ScopedPointer<BitmapDataReleaser> dataReleaser;

	private:
		JUCE_DECLARE_NON_COPYABLE (BitmapData);
	};

	/** Copies a section of the image to somewhere else within itself. */
	void moveImageSection (int destX, int destY,
						   int sourceX, int sourceY,
						   int width, int height);

	/** Creates a RectangleList containing rectangles for all non-transparent pixels
		of the image.

		@param result           the list that will have the area added to it
		@param alphaThreshold   for a semi-transparent image, any pixels whose alpha is
								above this level will be considered opaque
	*/
	void createSolidAreaMask (RectangleList& result,
							  float alphaThreshold = 0.5f) const;

	/** Returns a NamedValueSet that is attached to the image and which can be used for
		associating custom values with it.

		If this is a null image, this will return a null pointer.
	*/
	NamedValueSet* getProperties() const;

	/** Creates a context suitable for drawing onto this image.
		Don't call this method directly! It's used internally by the Graphics class.
	*/
	LowLevelGraphicsContext* createLowLevelContext() const;

	/** Returns the number of Image objects which are currently referring to the same internal
		shared image data.

		@see duplicateIfShared
	*/
	int getReferenceCount() const noexcept;

	/** @internal */
	ImagePixelData* getPixelData() const noexcept       { return image; }

	/** @internal */
	explicit Image (ImagePixelData*);

private:

	ReferenceCountedObjectPtr<ImagePixelData> image;

	JUCE_LEAK_DETECTOR (Image);
};

/**
	This is a base class for holding image data in implementation-specific ways.

	You may never need to use this class directly - it's used internally
	by the Image class to store the actual image data. To access pixel data directly,
	you should use Image::BitmapData rather than this class.

	ImagePixelData objects are created indirectly, by subclasses of ImageType.
	@see Image, ImageType
*/
class JUCE_API  ImagePixelData  : public ReferenceCountedObject
{
public:
	ImagePixelData (Image::PixelFormat, int width, int height);
	~ImagePixelData();

	/** Creates a context that will draw into this image. */
	virtual LowLevelGraphicsContext* createLowLevelContext() = 0;
	/** Creates a copy of this image. */
	virtual ImagePixelData* clone() = 0;
	/** Creates an instance of the type of this image. */
	virtual ImageType* createType() const = 0;
	/** Initialises a BitmapData object. */
	virtual void initialiseBitmapData (Image::BitmapData&, int x, int y, Image::BitmapData::ReadWriteMode) = 0;

	/** The pixel format of the image data. */
	const Image::PixelFormat pixelFormat;
	const int width, height;

	/** User-defined settings that are attached to this image.
		@see Image::getProperties().
	*/
	NamedValueSet userData;

private:
	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ImagePixelData);
};

/**
	This base class is for handlers that control a type of image manipulation format,
	e.g. an in-memory bitmap, an OpenGL image, CoreGraphics image, etc.

	@see SoftwareImageType, NativeImageType, OpenGLImageType
*/
class JUCE_API  ImageType
{
public:
	ImageType();
	virtual ~ImageType();

	/** Creates a new image of this type, and the specified parameters. */
	virtual ImagePixelData* create (Image::PixelFormat format, int width, int height, bool shouldClearImage) const = 0;

	/** Must return a unique number to identify this type. */
	virtual int getTypeID() const = 0;

	/** Returns an image which is a copy of the source image, but using this type of storage mechanism.
		For example, to make sure that an image is stored in-memory, you could use:
		@code myImage = SoftwareImageType().convert (myImage); @endcode
	*/
	virtual Image convert (const Image& source) const;
};

/**
	An image storage type which holds the pixels in-memory as a simple block of values.
	@see ImageType, NativeImageType
*/
class JUCE_API  SoftwareImageType   : public ImageType
{
public:
	SoftwareImageType();
	~SoftwareImageType();

	ImagePixelData* create (Image::PixelFormat, int width, int height, bool clearImage) const;
	int getTypeID() const;
};

/**
	An image storage type which holds the pixels using whatever is the default storage
	format on the current platform.
	@see ImageType, SoftwareImageType
*/
class JUCE_API  NativeImageType   : public ImageType
{
public:
	NativeImageType();
	~NativeImageType();

	ImagePixelData* create (Image::PixelFormat, int width, int height, bool clearImage) const;
	int getTypeID() const;
};

#endif   // __JUCE_IMAGE_JUCEHEADER__

/*** End of inlined file: juce_Image.h ***/

/**
	Represents a colour or fill pattern to use for rendering paths.

	This is used by the Graphics and DrawablePath classes as a way to encapsulate
	a brush type. It can either be a solid colour, a gradient, or a tiled image.

	@see Graphics::setFillType, DrawablePath::setFill
*/
class JUCE_API  FillType
{
public:

	/** Creates a default fill type, of solid black. */
	FillType() noexcept;

	/** Creates a fill type of a solid colour.
		@see setColour
	*/
	FillType (const Colour& colour) noexcept;

	/** Creates a gradient fill type.
		@see setGradient
	*/
	FillType (const ColourGradient& gradient);

	/** Creates a tiled image fill type. The transform allows you to set the scaling, offset
		and rotation of the pattern.
		@see setTiledImage
	*/
	FillType (const Image& image, const AffineTransform& transform) noexcept;

	/** Creates a copy of another FillType. */
	FillType (const FillType& other);

	/** Makes a copy of another FillType. */
	FillType& operator= (const FillType& other);

   #if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
	FillType (FillType&& other) noexcept;
	FillType& operator= (FillType&& other) noexcept;
   #endif

	/** Destructor. */
	~FillType() noexcept;

	/** Returns true if this is a solid colour fill, and not a gradient or image. */
	bool isColour() const noexcept          { return gradient == nullptr && image.isNull(); }

	/** Returns true if this is a gradient fill. */
	bool isGradient() const noexcept        { return gradient != nullptr; }

	/** Returns true if this is a tiled image pattern fill. */
	bool isTiledImage() const noexcept      { return image.isValid(); }

	/** Turns this object into a solid colour fill.
		If the object was an image or gradient, those fields will no longer be valid. */
	void setColour (const Colour& newColour) noexcept;

	/** Turns this object into a gradient fill. */
	void setGradient (const ColourGradient& newGradient);

	/** Turns this object into a tiled image fill type. The transform allows you to set
		the scaling, offset and rotation of the pattern.
	*/
	void setTiledImage (const Image& image, const AffineTransform& transform) noexcept;

	/** Changes the opacity that should be used.
		If the fill is a solid colour, this just changes the opacity of that colour. For
		gradients and image tiles, it changes the opacity that will be used for them.
	*/
	void setOpacity (float newOpacity) noexcept;

	/** Returns the current opacity to be applied to the colour, gradient, or image.
		@see setOpacity
	*/
	float getOpacity() const noexcept       { return colour.getFloatAlpha(); }

	/** Returns true if this fill type is completely transparent. */
	bool isInvisible() const noexcept;

	/** Returns a copy of this fill, adding the specified transform applied to the
		existing transform.
	*/
	FillType transformed (const AffineTransform& transform) const;

	/** The solid colour being used.

		If the fill type is not a solid colour, the alpha channel of this colour indicates
		the opacity that should be used for the fill, and the RGB channels are ignored.
	*/
	Colour colour;

	/** Returns the gradient that should be used for filling.
		This will be zero if the object is some other type of fill.
		If a gradient is active, the overall opacity with which it should be applied
		is indicated by the alpha channel of the colour variable.
	*/
	ScopedPointer <ColourGradient> gradient;

	/** The image that should be used for tiling.
		If an image fill is active, the overall opacity with which it should be applied
		is indicated by the alpha channel of the colour variable.
	*/
	Image image;

	/** The transform that should be applied to the image or gradient that's being drawn. */
	AffineTransform transform;

	bool operator== (const FillType& other) const;
	bool operator!= (const FillType& other) const;

private:
	JUCE_LEAK_DETECTOR (FillType);
};

#endif   // __JUCE_FILLTYPE_JUCEHEADER__

/*** End of inlined file: juce_FillType.h ***/


#endif
#ifndef __JUCE_PIXELFORMATS_JUCEHEADER__

#endif
#ifndef __JUCE_AFFINETRANSFORM_JUCEHEADER__

#endif
#ifndef __JUCE_BORDERSIZE_JUCEHEADER__

/*** Start of inlined file: juce_BorderSize.h ***/
#ifndef __JUCE_BORDERSIZE_JUCEHEADER__
#define __JUCE_BORDERSIZE_JUCEHEADER__

/**
	Specifies a set of gaps to be left around the sides of a rectangle.

	This is basically the size of the spaces at the top, bottom, left and right of
	a rectangle. It's used by various component classes to specify borders.

	@see Rectangle
*/
template <typename ValueType>
class BorderSize
{
public:

	/** Creates a null border.
		All sizes are left as 0.
	*/
	BorderSize() noexcept
		: top(), left(), bottom(), right()
	{
	}

	/** Creates a copy of another border. */
	BorderSize (const BorderSize& other) noexcept
		: top (other.top), left (other.left), bottom (other.bottom), right (other.right)
	{
	}

	/** Creates a border with the given gaps. */
	BorderSize (ValueType topGap, ValueType leftGap, ValueType bottomGap, ValueType rightGap) noexcept
		: top (topGap), left (leftGap), bottom (bottomGap), right (rightGap)
	{
	}

	/** Creates a border with the given gap on all sides. */
	explicit BorderSize (ValueType allGaps) noexcept
		: top (allGaps), left (allGaps), bottom (allGaps), right (allGaps)
	{
	}

	/** Returns the gap that should be left at the top of the region. */
	ValueType getTop() const noexcept                   { return top; }

	/** Returns the gap that should be left at the top of the region. */
	ValueType getLeft() const noexcept                  { return left; }

	/** Returns the gap that should be left at the top of the region. */
	ValueType getBottom() const noexcept                { return bottom; }

	/** Returns the gap that should be left at the top of the region. */
	ValueType getRight() const noexcept                 { return right; }

	/** Returns the sum of the top and bottom gaps. */
	ValueType getTopAndBottom() const noexcept          { return top + bottom; }

	/** Returns the sum of the left and right gaps. */
	ValueType getLeftAndRight() const noexcept          { return left + right; }

	/** Returns true if this border has no thickness along any edge. */
	bool isEmpty() const noexcept                       { return left + right + top + bottom == ValueType(); }

	/** Changes the top gap. */
	void setTop (ValueType newTopGap) noexcept          { top = newTopGap; }

	/** Changes the left gap. */
	void setLeft (ValueType newLeftGap) noexcept        { left = newLeftGap; }

	/** Changes the bottom gap. */
	void setBottom (ValueType newBottomGap) noexcept    { bottom = newBottomGap; }

	/** Changes the right gap. */
	void setRight (ValueType newRightGap) noexcept      { right = newRightGap; }

	/** Returns a rectangle with these borders removed from it. */
	Rectangle<ValueType> subtractedFrom (const Rectangle<ValueType>& original) const noexcept
	{
		return Rectangle<ValueType> (original.getX() + left,
									 original.getY() + top,
									 original.getWidth() - (left + right),
									 original.getHeight() - (top + bottom));
	}

	/** Removes this border from a given rectangle. */
	void subtractFrom (Rectangle<ValueType>& rectangle) const noexcept
	{
		rectangle = subtractedFrom (rectangle);
	}

	/** Returns a rectangle with these borders added around it. */
	Rectangle<ValueType> addedTo (const Rectangle<ValueType>& original) const noexcept
	{
		return Rectangle<ValueType> (original.getX() - left,
									 original.getY() - top,
									 original.getWidth() + (left + right),
									 original.getHeight() + (top + bottom));
	}

	/** Adds this border around a given rectangle. */
	void addTo (Rectangle<ValueType>& rectangle) const noexcept
	{
		rectangle = addedTo (rectangle);
	}

	bool operator== (const BorderSize& other) const noexcept
	{
		return top == other.top && left == other.left && bottom == other.bottom && right == other.right;
	}

	bool operator!= (const BorderSize& other) const noexcept
	{
		return ! operator== (other);
	}

private:

	ValueType top, left, bottom, right;

	JUCE_LEAK_DETECTOR (BorderSize);
};

#endif   // __JUCE_BORDERSIZE_JUCEHEADER__

/*** End of inlined file: juce_BorderSize.h ***/


#endif
#ifndef __JUCE_EDGETABLE_JUCEHEADER__

/*** Start of inlined file: juce_EdgeTable.h ***/
#ifndef __JUCE_EDGETABLE_JUCEHEADER__
#define __JUCE_EDGETABLE_JUCEHEADER__


/*** Start of inlined file: juce_RectangleList.h ***/
#ifndef __JUCE_RECTANGLELIST_JUCEHEADER__
#define __JUCE_RECTANGLELIST_JUCEHEADER__

/**
	Maintains a set of rectangles as a complex region.

	This class allows a set of rectangles to be treated as a solid shape, and can
	add and remove rectangular sections of it, and simplify overlapping or
	adjacent rectangles.

	@see Rectangle
*/
class JUCE_API  RectangleList
{
public:

	/** Creates an empty RectangleList */
	RectangleList() noexcept;

	/** Creates a copy of another list */
	RectangleList (const RectangleList& other);

	/** Creates a list containing just one rectangle. */
	RectangleList (const Rectangle<int>& rect);

	/** Copies this list from another one. */
	RectangleList& operator= (const RectangleList& other);

   #if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
	RectangleList (RectangleList&& other) noexcept;
	RectangleList& operator= (RectangleList&& other) noexcept;
   #endif

	/** Destructor. */
	~RectangleList();

	/** Returns true if the region is empty. */
	bool isEmpty() const noexcept;

	/** Returns the number of rectangles in the list. */
	int getNumRectangles() const noexcept                       { return rects.size(); }

	/** Returns one of the rectangles at a particular index.

		@returns    the rectangle at the index, or an empty rectangle if the
					index is out-of-range.
	*/
	Rectangle<int> getRectangle (int index) const noexcept;

	/** Removes all rectangles to leave an empty region. */
	void clear();

	/** Merges a new rectangle into the list.

		The rectangle being added will first be clipped to remove any parts of it
		that overlap existing rectangles in the list.
	*/
	void add (int x, int y, int width, int height);

	/** Merges a new rectangle into the list.

		The rectangle being added will first be clipped to remove any parts of it
		that overlap existing rectangles in the list, and adjacent rectangles will be
		merged into it.
	*/
	void add (const Rectangle<int>& rect);

	/** Dumbly adds a rectangle to the list without checking for overlaps.

		This simply adds the rectangle to the end, it doesn't merge it or remove
		any overlapping bits.
	*/
	void addWithoutMerging (const Rectangle<int>& rect);

	/** Merges another rectangle list into this one.

		Any overlaps between the two lists will be clipped, so that the result is
		the union of both lists.
	*/
	void add (const RectangleList& other);

	/** Removes a rectangular region from the list.

		Any rectangles in the list which overlap this will be clipped and subdivided
		if necessary.
	*/
	void subtract (const Rectangle<int>& rect);

	/** Removes all areas in another RectangleList from this one.

		Any rectangles in the list which overlap this will be clipped and subdivided
		if necessary.

		@returns true if the resulting list is non-empty.
	*/
	bool subtract (const RectangleList& otherList);

	/** Removes any areas of the region that lie outside a given rectangle.

		Any rectangles in the list which overlap this will be clipped and subdivided
		if necessary.

		Returns true if the resulting region is not empty, false if it is empty.

		@see getIntersectionWith
	*/
	bool clipTo (const Rectangle<int>& rect);

	/** Removes any areas of the region that lie outside a given rectangle list.

		Any rectangles in this object which overlap the specified list will be clipped
		and subdivided if necessary.

		Returns true if the resulting region is not empty, false if it is empty.

		@see getIntersectionWith
	*/
	bool clipTo (const RectangleList& other);

	/** Creates a region which is the result of clipping this one to a given rectangle.

		Unlike the other clipTo method, this one doesn't affect this object - it puts the
		resulting region into the list whose reference is passed-in.

		Returns true if the resulting region is not empty, false if it is empty.

		@see clipTo
	*/
	bool getIntersectionWith (const Rectangle<int>& rect, RectangleList& destRegion) const;

	/** Swaps the contents of this and another list.

		This swaps their internal pointers, so is hugely faster than using copy-by-value
		to swap them.
	*/
	void swapWith (RectangleList& otherList) noexcept;

	/** Checks whether the region contains a given point.

		@returns true if the point lies within one of the rectangles in the list
	*/
	bool containsPoint (int x, int y) const noexcept;

	/** Checks whether the region contains the whole of a given rectangle.

		@returns    true all parts of the rectangle passed in lie within the region
					defined by this object
		@see intersectsRectangle, containsPoint
	*/
	bool containsRectangle (const Rectangle<int>& rectangleToCheck) const;

	/** Checks whether the region contains any part of a given rectangle.

		@returns    true if any part of the rectangle passed in lies within the region
					defined by this object
		@see containsRectangle
	*/
	bool intersectsRectangle (const Rectangle<int>& rectangleToCheck) const noexcept;

	/** Checks whether this region intersects any part of another one.

		@see intersectsRectangle
	*/
	bool intersects (const RectangleList& other) const noexcept;

	/** Returns the smallest rectangle that can enclose the whole of this region. */
	Rectangle<int> getBounds() const noexcept;

	/** Optimises the list into a minimum number of constituent rectangles.

		This will try to combine any adjacent rectangles into larger ones where
		possible, to simplify lists that might have been fragmented by repeated
		add/subtract calls.
	*/
	void consolidate();

	/** Adds an x and y value to all the co-ordinates. */
	void offsetAll (int dx, int dy) noexcept;

	/** Creates a Path object to represent this region. */
	Path toPath() const;

	/** An iterator for accessing all the rectangles in a RectangleList. */
	class JUCE_API  Iterator
	{
	public:

		Iterator (const RectangleList& list) noexcept;
		~Iterator();

		/** Advances to the next rectangle, and returns true if it's not finished.

			Call this before using getRectangle() to find the rectangle that was returned.
		*/
		bool next() noexcept;

		/** Returns the current rectangle. */
		const Rectangle<int>* getRectangle() const noexcept      { return current; }

	private:
		const Rectangle<int>* current;
		const RectangleList& owner;
		int index;

		JUCE_DECLARE_NON_COPYABLE (Iterator);
	};

private:

	friend class Iterator;
	Array <Rectangle<int> > rects;

	JUCE_LEAK_DETECTOR (RectangleList);
};

#endif   // __JUCE_RECTANGLELIST_JUCEHEADER__

/*** End of inlined file: juce_RectangleList.h ***/

class Path;
class Image;

/**
	A table of horizontal scan-line segments - used for rasterising Paths.

	@see Path, Graphics
*/
class JUCE_API  EdgeTable
{
public:

	/** Creates an edge table containing a path.

		A table is created with a fixed vertical range, and only sections of the path
		which lie within this range will be added to the table.

		@param clipLimits               only the region of the path that lies within this area will be added
		@param pathToAdd                the path to add to the table
		@param transform                a transform to apply to the path being added
	*/
	EdgeTable (const Rectangle<int>& clipLimits,
			   const Path& pathToAdd,
			   const AffineTransform& transform);

	/** Creates an edge table containing a rectangle. */
	explicit EdgeTable (const Rectangle<int>& rectangleToAdd);

	/** Creates an edge table containing a rectangle list. */
	explicit EdgeTable (const RectangleList& rectanglesToAdd);

	/** Creates an edge table containing a rectangle. */
	explicit EdgeTable (const Rectangle<float>& rectangleToAdd);

	/** Creates a copy of another edge table. */
	EdgeTable (const EdgeTable& other);

	/** Copies from another edge table. */
	EdgeTable& operator= (const EdgeTable& other);

	/** Destructor. */
	~EdgeTable();

	void clipToRectangle (const Rectangle<int>& r);
	void excludeRectangle (const Rectangle<int>& r);
	void clipToEdgeTable (const EdgeTable& other);
	void clipLineToMask (int x, int y, const uint8* mask, int maskStride, int numPixels);
	bool isEmpty() noexcept;
	const Rectangle<int>& getMaximumBounds() const noexcept      { return bounds; }
	void translate (float dx, int dy) noexcept;

	/** Reduces the amount of space the table has allocated.

		This will shrink the table down to use as little memory as possible - useful for
		read-only tables that get stored and re-used for rendering.
	*/
	void optimiseTable();

	/** Iterates the lines in the table, for rendering.

		This function will iterate each line in the table, and call a user-defined class
		to render each pixel or continuous line of pixels that the table contains.

		@param iterationCallback    this templated class must contain the following methods:
										@code
										inline void setEdgeTableYPos (int y);
										inline void handleEdgeTablePixel (int x, int alphaLevel) const;
										inline void handleEdgeTablePixelFull (int x) const;
										inline void handleEdgeTableLine (int x, int width, int alphaLevel) const;
										inline void handleEdgeTableLineFull (int x, int width) const;
										@endcode
										(these don't necessarily have to be 'const', but it might help it go faster)
	*/
	template <class EdgeTableIterationCallback>
	void iterate (EdgeTableIterationCallback& iterationCallback) const noexcept
	{
		const int* lineStart = table;

		for (int y = 0; y < bounds.getHeight(); ++y)
		{
			const int* line = lineStart;
			lineStart += lineStrideElements;
			int numPoints = line[0];

			if (--numPoints > 0)
			{
				int x = *++line;
				jassert ((x >> 8) >= bounds.getX() && (x >> 8) < bounds.getRight());
				int levelAccumulator = 0;

				iterationCallback.setEdgeTableYPos (bounds.getY() + y);

				while (--numPoints >= 0)
				{
					const int level = *++line;
					jassert (isPositiveAndBelow (level, (int) 256));
					const int endX = *++line;
					jassert (endX >= x);
					const int endOfRun = (endX >> 8);

					if (endOfRun == (x >> 8))
					{
						// small segment within the same pixel, so just save it for the next
						// time round..
						levelAccumulator += (endX - x) * level;
					}
					else
					{
						// plot the fist pixel of this segment, including any accumulated
						// levels from smaller segments that haven't been drawn yet
						levelAccumulator += (0x100 - (x & 0xff)) * level;
						levelAccumulator >>= 8;
						x >>= 8;

						if (levelAccumulator > 0)
						{
							if (levelAccumulator >= 255)
								iterationCallback.handleEdgeTablePixelFull (x);
							else
								iterationCallback.handleEdgeTablePixel (x, levelAccumulator);
						}

						// if there's a run of similar pixels, do it all in one go..
						if (level > 0)
						{
							jassert (endOfRun <= bounds.getRight());
							const int numPix = endOfRun - ++x;

							if (numPix > 0)
								iterationCallback.handleEdgeTableLine (x, numPix, level);
						}

						// save the bit at the end to be drawn next time round the loop.
						levelAccumulator = (endX & 0xff) * level;
					}

					x = endX;
				}

				levelAccumulator >>= 8;

				if (levelAccumulator > 0)
				{
					x >>= 8;
					jassert (x >= bounds.getX() && x < bounds.getRight());

					if (levelAccumulator >= 255)
						iterationCallback.handleEdgeTablePixelFull (x);
					else
						iterationCallback.handleEdgeTablePixel (x, levelAccumulator);
				}
			}
		}
	}

private:

	// table line format: number of points; point0 x, point0 levelDelta, point1 x, point1 levelDelta, etc
	HeapBlock<int> table;
	Rectangle<int> bounds;
	int maxEdgesPerLine, lineStrideElements;
	bool needToCheckEmptinesss;

	void addEdgePoint (int x, int y, int winding);
	void remapTableForNumEdges (int newNumEdgesPerLine);
	void intersectWithEdgeTableLine (int y, const int* otherLine);
	void clipEdgeTableLineToRange (int* line, int x1, int x2) noexcept;
	void sanitiseLevels (bool useNonZeroWinding) noexcept;
	static void copyEdgeTableData (int* dest, int destLineStride, const int* src, int srcLineStride, int numLines) noexcept;

	JUCE_LEAK_DETECTOR (EdgeTable);
};

#endif   // __JUCE_EDGETABLE_JUCEHEADER__

/*** End of inlined file: juce_EdgeTable.h ***/


#endif
#ifndef __JUCE_LINE_JUCEHEADER__

#endif
#ifndef __JUCE_PATH_JUCEHEADER__

#endif
#ifndef __JUCE_PATHITERATOR_JUCEHEADER__

/*** Start of inlined file: juce_PathIterator.h ***/
#ifndef __JUCE_PATHITERATOR_JUCEHEADER__
#define __JUCE_PATHITERATOR_JUCEHEADER__

/**
	Flattens a Path object into a series of straight-line sections.

	Use one of these to iterate through a Path object, and it will convert
	all the curves into line sections so it's easy to render or perform
	geometric operations on.

	@see Path
*/
class JUCE_API  PathFlatteningIterator
{
public:

	/** Creates a PathFlatteningIterator.

		After creation, use the next() method to initialise the fields in the
		object with the first line's position.

		@param path         the path to iterate along
		@param transform    a transform to apply to each point in the path being iterated
		@param tolerance    the amount by which the curves are allowed to deviate from the lines
							into which they are being broken down - a higher tolerance contains
							less lines, so can be generated faster, but will be less smooth.
	*/
	PathFlatteningIterator (const Path& path,
							const AffineTransform& transform = AffineTransform::identity,
							float tolerance = defaultTolerance);

	/** Destructor. */
	~PathFlatteningIterator();

	/** Fetches the next line segment from the path.

		This will update the member variables x1, y1, x2, y2, subPathIndex and closesSubPath
		so that they describe the new line segment.

		@returns false when there are no more lines to fetch.
	*/
	bool next();

	float x1;  /**< The x position of the start of the current line segment. */
	float y1;  /**< The y position of the start of the current line segment. */
	float x2;  /**< The x position of the end of the current line segment. */
	float y2;  /**< The y position of the end of the current line segment. */

	/** Indicates whether the current line segment is closing a sub-path.

		If the current line is the one that connects the end of a sub-path
		back to the start again, this will be true.
	*/
	bool closesSubPath;

	/** The index of the current line within the current sub-path.

		E.g. you can use this to see whether the line is the first one in the
		subpath by seeing if it's 0.
	*/
	int subPathIndex;

	/** Returns true if the current segment is the last in the current sub-path. */
	bool isLastInSubpath() const noexcept;

	/** This is the default value that should be used for the tolerance value (see the constructor parameters). */
	static const float defaultTolerance;

private:

	const Path& path;
	const AffineTransform transform;
	float* points;
	const float toleranceSquared;
	float subPathCloseX, subPathCloseY;
	const bool isIdentityTransform;

	HeapBlock <float> stackBase;
	float* stackPos;
	size_t index, stackSize;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (PathFlatteningIterator);
};

#endif   // __JUCE_PATHITERATOR_JUCEHEADER__

/*** End of inlined file: juce_PathIterator.h ***/


#endif
#ifndef __JUCE_PATHSTROKETYPE_JUCEHEADER__

#endif
#ifndef __JUCE_POINT_JUCEHEADER__

#endif
#ifndef __JUCE_RECTANGLE_JUCEHEADER__

#endif
#ifndef __JUCE_RECTANGLELIST_JUCEHEADER__

#endif
#ifndef __JUCE_JUSTIFICATION_JUCEHEADER__

#endif
#ifndef __JUCE_RECTANGLEPLACEMENT_JUCEHEADER__

#endif
#ifndef __JUCE_GRAPHICSCONTEXT_JUCEHEADER__

#endif
#ifndef __JUCE_LOWLEVELGRAPHICSCONTEXT_JUCEHEADER__

/*** Start of inlined file: juce_LowLevelGraphicsContext.h ***/
#ifndef __JUCE_LOWLEVELGRAPHICSCONTEXT_JUCEHEADER__
#define __JUCE_LOWLEVELGRAPHICSCONTEXT_JUCEHEADER__

class AttributedString;

/**
	Interface class for graphics context objects, used internally by the Graphics class.

	Users are not supposed to create instances of this class directly - do your drawing
	via the Graphics object instead.

	It's a base class for different types of graphics context, that may perform software-based
	or OS-accelerated rendering.

	E.g. the LowLevelGraphicsSoftwareRenderer renders onto an image in memory, but other
	subclasses could render directly to a windows HDC, a Quartz context, or an OpenGL
	context.
*/
class JUCE_API  LowLevelGraphicsContext
{
protected:

	LowLevelGraphicsContext();

public:
	virtual ~LowLevelGraphicsContext();

	/** Returns true if this device is vector-based, e.g. a printer. */
	virtual bool isVectorDevice() const = 0;

	/** Moves the origin to a new position.

		The co-ords are relative to the current origin, and indicate the new position
		of (0, 0).
	*/
	virtual void setOrigin (int x, int y) = 0;
	virtual void addTransform (const AffineTransform& transform) = 0;
	virtual float getScaleFactor() = 0;

	virtual bool clipToRectangle (const Rectangle<int>& r) = 0;
	virtual bool clipToRectangleList (const RectangleList& clipRegion) = 0;
	virtual void excludeClipRectangle (const Rectangle<int>& r) = 0;
	virtual void clipToPath (const Path& path, const AffineTransform& transform) = 0;
	virtual void clipToImageAlpha (const Image& sourceImage, const AffineTransform& transform) = 0;

	virtual bool clipRegionIntersects (const Rectangle<int>& r) = 0;
	virtual Rectangle<int> getClipBounds() const = 0;
	virtual bool isClipEmpty() const = 0;

	virtual void saveState() = 0;
	virtual void restoreState() = 0;

	virtual void beginTransparencyLayer (float opacity) = 0;
	virtual void endTransparencyLayer() = 0;

	virtual void setFill (const FillType& fillType) = 0;
	virtual void setOpacity (float newOpacity) = 0;
	virtual void setInterpolationQuality (Graphics::ResamplingQuality quality) = 0;

	virtual void fillRect (const Rectangle<int>& r, bool replaceExistingContents) = 0;
	virtual void fillPath (const Path& path, const AffineTransform& transform) = 0;

	virtual void drawImage (const Image& sourceImage, const AffineTransform& transform) = 0;

	virtual void drawLine (const Line <float>& line) = 0;
	virtual void drawVerticalLine (int x, float top, float bottom) = 0;
	virtual void drawHorizontalLine (int y, float left, float right) = 0;

	virtual void setFont (const Font& newFont) = 0;
	virtual const Font& getFont() = 0;
	virtual void drawGlyph (int glyphNumber, const AffineTransform& transform) = 0;
	virtual bool drawTextLayout (const AttributedString&, const Rectangle<float>&)  { return false; }
};

#endif   // __JUCE_LOWLEVELGRAPHICSCONTEXT_JUCEHEADER__

/*** End of inlined file: juce_LowLevelGraphicsContext.h ***/


#endif
#ifndef __JUCE_LOWLEVELGRAPHICSPOSTSCRIPTRENDERER_JUCEHEADER__

/*** Start of inlined file: juce_LowLevelGraphicsPostScriptRenderer.h ***/
#ifndef __JUCE_LOWLEVELGRAPHICSPOSTSCRIPTRENDERER_JUCEHEADER__
#define __JUCE_LOWLEVELGRAPHICSPOSTSCRIPTRENDERER_JUCEHEADER__

/**
	An implementation of LowLevelGraphicsContext that turns the drawing operations
	into a PostScript document.

*/
class JUCE_API  LowLevelGraphicsPostScriptRenderer    : public LowLevelGraphicsContext
{
public:

	LowLevelGraphicsPostScriptRenderer (OutputStream& resultingPostScript,
										const String& documentTitle,
										int totalWidth,
										int totalHeight);

	~LowLevelGraphicsPostScriptRenderer();

	bool isVectorDevice() const;
	void setOrigin (int x, int y);
	void addTransform (const AffineTransform& transform);
	float getScaleFactor();

	bool clipToRectangle (const Rectangle<int>& r);
	bool clipToRectangleList (const RectangleList& clipRegion);
	void excludeClipRectangle (const Rectangle<int>& r);
	void clipToPath (const Path& path, const AffineTransform& transform);
	void clipToImageAlpha (const Image& sourceImage, const AffineTransform& transform);

	void saveState();
	void restoreState();

	void beginTransparencyLayer (float opacity);
	void endTransparencyLayer();

	bool clipRegionIntersects (const Rectangle<int>& r);
	Rectangle<int> getClipBounds() const;
	bool isClipEmpty() const;

	void setFill (const FillType& fillType);
	void setOpacity (float opacity);
	void setInterpolationQuality (Graphics::ResamplingQuality quality);

	void fillRect (const Rectangle<int>& r, bool replaceExistingContents);
	void fillPath (const Path& path, const AffineTransform& transform);

	void drawImage (const Image& sourceImage, const AffineTransform& transform);

	void drawLine (const Line <float>& line);

	void drawVerticalLine (int x, float top, float bottom);
	void drawHorizontalLine (int x, float top, float bottom);

	const Font& getFont();
	void setFont (const Font& newFont);
	void drawGlyph (int glyphNumber, const AffineTransform& transform);

protected:

	OutputStream& out;
	int totalWidth, totalHeight;
	bool needToClip;
	Colour lastColour;

	struct SavedState
	{
		SavedState();
		~SavedState();

		RectangleList clip;
		int xOffset, yOffset;
		FillType fillType;
		Font font;

	private:
		SavedState& operator= (const SavedState&);
	};

	OwnedArray <SavedState> stateStack;

	void writeClip();
	void writeColour (const Colour& colour);
	void writePath (const Path& path) const;
	void writeXY (float x, float y) const;
	void writeTransform (const AffineTransform& trans) const;
	void writeImage (const Image& im, int sx, int sy, int maxW, int maxH) const;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (LowLevelGraphicsPostScriptRenderer);
};

#endif   // __JUCE_LOWLEVELGRAPHICSPOSTSCRIPTRENDERER_JUCEHEADER__

/*** End of inlined file: juce_LowLevelGraphicsPostScriptRenderer.h ***/


#endif
#ifndef __JUCE_LOWLEVELGRAPHICSSOFTWARERENDERER_JUCEHEADER__

/*** Start of inlined file: juce_LowLevelGraphicsSoftwareRenderer.h ***/
#ifndef __JUCE_LOWLEVELGRAPHICSSOFTWARERENDERER_JUCEHEADER__
#define __JUCE_LOWLEVELGRAPHICSSOFTWARERENDERER_JUCEHEADER__

#ifndef DOXYGEN

/*** Start of inlined file: juce_RenderingHelpers.h ***/
#ifndef __JUCE_RENDERINGHELPERS_JUCEHEADER__
#define __JUCE_RENDERINGHELPERS_JUCEHEADER__

namespace RenderingHelpers
{

/** Holds either a simple integer translation, or an affine transform.
*/
class TranslationOrTransform
{
public:
	TranslationOrTransform (int xOffset_, int yOffset_) noexcept
		: xOffset (xOffset_), yOffset (yOffset_), isOnlyTranslated (true)
	{
	}

	TranslationOrTransform (const TranslationOrTransform& other) noexcept
		: complexTransform (other.complexTransform),
		  xOffset (other.xOffset), yOffset (other.yOffset),
		  isOnlyTranslated (other.isOnlyTranslated)
	{
	}

	AffineTransform getTransform() const noexcept
	{
		return isOnlyTranslated ? AffineTransform::translation ((float) xOffset, (float) yOffset)
								: complexTransform;
	}

	AffineTransform getTransformWith (const AffineTransform& userTransform) const noexcept
	{
		return isOnlyTranslated ? userTransform.translated ((float) xOffset, (float) yOffset)
								: userTransform.followedBy (complexTransform);
	}

	void setOrigin (const int x, const int y) noexcept
	{
		if (isOnlyTranslated)
		{
			xOffset += x;
			yOffset += y;
		}
		else
		{
			complexTransform = AffineTransform::translation ((float) x, (float) y)
											   .followedBy (complexTransform);
		}
	}

	void addTransform (const AffineTransform& t) noexcept
	{
		if (isOnlyTranslated
			 && t.isOnlyTranslation()
			 && isIntegerTranslation (t))
		{
			xOffset += (int) t.getTranslationX();
			yOffset += (int) t.getTranslationY();
		}
		else
		{
			complexTransform = getTransformWith (t);
			isOnlyTranslated = false;
		}
	}

	float getScaleFactor() const noexcept
	{
		return isOnlyTranslated ? 1.0f : complexTransform.getScaleFactor();
	}

	void moveOriginInDeviceSpace (const int dx, const int dy) noexcept
	{
		if (isOnlyTranslated)
		{
			xOffset += dx;
			yOffset += dy;
		}
		else
		{
			complexTransform = complexTransform.translated ((float) dx, (float) dx);
		}
	}

	template <typename Type>
	Rectangle<Type> translated (const Rectangle<Type>& r) const noexcept
	{
		jassert (isOnlyTranslated);
		return r.translated (static_cast <Type> (xOffset),
							 static_cast <Type> (yOffset));
	}

	Rectangle<int> deviceSpaceToUserSpace (const Rectangle<int>& r) const noexcept
	{
		return isOnlyTranslated ? r.translated (-xOffset, -yOffset)
								: r.toFloat().transformed (complexTransform.inverted()).getSmallestIntegerContainer();
	}

	AffineTransform complexTransform;
	int xOffset, yOffset;
	bool isOnlyTranslated;

private:
	static inline bool isIntegerTranslation (const AffineTransform& t) noexcept
	{
		const int tx = (int) (t.getTranslationX() * 256.0f);
		const int ty = (int) (t.getTranslationY() * 256.0f);
		return ((tx | ty) & 0xf8) == 0;
	}
};

template <class CachedGlyphType, class RenderTargetType>
class GlyphCache  : private DeletedAtShutdown
{
public:
	GlyphCache()
	{
		addNewGlyphSlots (120);
	}

	~GlyphCache()
	{
		getSingletonPointer() = nullptr;
	}

	static GlyphCache& getInstance()
	{
		GlyphCache*& g = getSingletonPointer();

		if (g == nullptr)
			g = new GlyphCache();

		return *g;
	}

	void drawGlyph (RenderTargetType& target, const Font& font, const int glyphNumber, float x, float y)
	{
		++accessCounter;
		CachedGlyphType* glyph = nullptr;

		const ScopedReadLock srl (lock);

		for (int i = glyphs.size(); --i >= 0;)
		{
			CachedGlyphType* const g = glyphs.getUnchecked (i);

			if (g->glyph == glyphNumber && g->font == font)
			{
				glyph = g;
				++hits;
				break;
			}
		}

		if (glyph == nullptr)
		{
			++misses;
			const ScopedWriteLock swl (lock);

			if (hits.value + misses.value > glyphs.size() * 16)
			{
				if (misses.value * 2 > hits.value)
					addNewGlyphSlots (32);

				hits.set (0);
				misses.set (0);
				glyph = glyphs.getLast();
			}
			else
			{
				glyph = findLeastRecentlyUsedGlyph();
			}

			jassert (glyph != nullptr);
			glyph->generate (font, glyphNumber);
		}

		glyph->lastAccessCount = accessCounter.value;
		glyph->draw (target, x, y);
	}

private:
	friend class OwnedArray <CachedGlyphType>;
	OwnedArray <CachedGlyphType> glyphs;
	Atomic<int> accessCounter, hits, misses;
	ReadWriteLock lock;

	void addNewGlyphSlots (int num)
	{
		while (--num >= 0)
			glyphs.add (new CachedGlyphType());
	}

	CachedGlyphType* findLeastRecentlyUsedGlyph() const noexcept
	{
		CachedGlyphType* oldest = glyphs.getLast();
		int oldestCounter = oldest->lastAccessCount;

		for (int i = glyphs.size() - 1; --i >= 0;)
		{
			CachedGlyphType* const glyph = glyphs.getUnchecked(i);

			if (glyph->lastAccessCount <= oldestCounter)
			{
				oldestCounter = glyph->lastAccessCount;
				oldest = glyph;
			}
		}

		return oldest;
	}

	static GlyphCache*& getSingletonPointer() noexcept
	{
		static GlyphCache* g = nullptr;
		return g;
	}

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (GlyphCache);
};

template <class RendererType>
class CachedGlyphEdgeTable
{
public:
	CachedGlyphEdgeTable() : glyph (0), lastAccessCount (0) {}

	void draw (RendererType& state, float x, const float y) const
	{
		if (snapToIntegerCoordinate)
			x = std::floor (x + 0.5f);

		if (edgeTable != nullptr)
			state.fillEdgeTable (*edgeTable, x, roundToInt (y));
	}

	void generate (const Font& newFont, const int glyphNumber)
	{
		font = newFont;
		Typeface* const typeface = newFont.getTypeface();
		snapToIntegerCoordinate = typeface->isHinted();
		glyph = glyphNumber;

		const float fontHeight = font.getHeight();
		edgeTable = typeface->getEdgeTableForGlyph (glyphNumber,
													AffineTransform::scale (fontHeight * font.getHorizontalScale(), fontHeight)
																  #if JUCE_MAC || JUCE_IOS
																	.translated (0.0f, -0.5f)
																  #endif
													);
	}

	Font font;
	int glyph, lastAccessCount;
	bool snapToIntegerCoordinate;

private:
	ScopedPointer <EdgeTable> edgeTable;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (CachedGlyphEdgeTable);
};

template <class StateObjectType>
class SavedStateStack
{
public:
	SavedStateStack (StateObjectType* const initialState) noexcept
		: currentState (initialState)
	{}

	inline StateObjectType* operator->() const noexcept     { return currentState; }
	inline StateObjectType& operator*()  const noexcept     { return *currentState; }

	void save()
	{
		stack.add (new StateObjectType (*currentState));
	}

	void restore()
	{
		StateObjectType* const top = stack.getLast();

		if (top != nullptr)
		{
			currentState = top;
			stack.removeLast (1, false);
		}
		else
		{
			jassertfalse; // trying to pop with an empty stack!
		}
	}

	void beginTransparencyLayer (float opacity)
	{
		save();
		currentState = currentState->beginTransparencyLayer (opacity);
	}

	void endTransparencyLayer()
	{
		const ScopedPointer<StateObjectType> finishedTransparencyLayer (currentState);
		restore();
		currentState->endTransparencyLayer (*finishedTransparencyLayer);
	}

private:
	ScopedPointer<StateObjectType> currentState;
	OwnedArray<StateObjectType> stack;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (SavedStateStack);
};

// Calculates the alpha values and positions for rendering the edges of a non-pixel
// aligned rectangle.
struct FloatRectangleRasterisingInfo
{
	FloatRectangleRasterisingInfo (const Rectangle<float>& area)
		: left   (roundToInt (256.0f * area.getX())),
		  top    (roundToInt (256.0f * area.getY())),
		  right  (roundToInt (256.0f * area.getRight())),
		  bottom (roundToInt (256.0f * area.getBottom()))
	{
		if ((top >> 8) == (bottom >> 8))
		{
			topAlpha = bottom - top;
			bottomAlpha = 0;
			totalTop = top >> 8;
			totalBottom = bottom = top = totalTop + 1;
		}
		else
		{
			if ((top & 255) == 0)
			{
				topAlpha = 0;
				top = totalTop = (top >> 8);
			}
			else
			{
				topAlpha = 255 - (top & 255);
				totalTop = (top >> 8);
				top = totalTop + 1;
			}

			bottomAlpha = bottom & 255;
			bottom >>= 8;
			totalBottom = bottom + (bottomAlpha != 0 ? 1 : 0);
		}

		if ((left >> 8) == (right >> 8))
		{
			leftAlpha = right - left;
			rightAlpha = 0;
			totalLeft = (left >> 8);
			totalRight = right = left = totalLeft + 1;
		}
		else
		{
			if ((left & 255) == 0)
			{
				leftAlpha = 0;
				left = totalLeft = (left >> 8);
			}
			else
			{
				leftAlpha = 255 - (left & 255);
				totalLeft = (left >> 8);
				left = totalLeft + 1;
			}

			rightAlpha = right & 255;
			right >>= 8;
			totalRight = right + (rightAlpha != 0 ? 1 : 0);
		}
	}

	template <class Callback>
	void iterate (Callback& callback) const
	{
		if (topAlpha != 0)       callback (totalLeft, totalTop, totalRight - totalLeft, 1, topAlpha);
		if (bottomAlpha != 0)    callback (totalLeft, bottom,   totalRight - totalLeft, 1, bottomAlpha);
		if (leftAlpha != 0)      callback (totalLeft, totalTop, 1, totalBottom - totalTop, leftAlpha);
		if (rightAlpha != 0)     callback (right,     totalTop, 1, totalBottom - totalTop, rightAlpha);

		callback (left, top, right - left, bottom - top, 255);
	}

	inline bool isOnePixelWide() const noexcept            { return right - left == 1 && leftAlpha + rightAlpha == 0; }

	inline int getTopLeftCornerAlpha() const noexcept      { return (topAlpha * leftAlpha) >> 8; }
	inline int getTopRightCornerAlpha() const noexcept     { return (topAlpha * rightAlpha) >> 8; }
	inline int getBottomLeftCornerAlpha() const noexcept   { return (bottomAlpha * leftAlpha) >> 8; }
	inline int getBottomRightCornerAlpha() const noexcept  { return (bottomAlpha * rightAlpha) >> 8; }

	int left, top, right, bottom;  // bounds of the solid central area, excluding anti-aliased edges
	int totalTop, totalLeft, totalBottom, totalRight; // bounds of the total area, including edges
	int topAlpha, leftAlpha, bottomAlpha, rightAlpha; // alpha of each anti-aliased edge
};

}

#endif   // __JUCE_RENDERINGHELPERS_JUCEHEADER__

/*** End of inlined file: juce_RenderingHelpers.h ***/


#endif

/**
	A lowest-common-denominator implementation of LowLevelGraphicsContext that does all
	its rendering in memory.

	User code is not supposed to create instances of this class directly - do all your
	rendering via the Graphics class instead.
*/
class JUCE_API  LowLevelGraphicsSoftwareRenderer    : public LowLevelGraphicsContext
{
public:

	LowLevelGraphicsSoftwareRenderer (const Image& imageToRenderOn);
	LowLevelGraphicsSoftwareRenderer (const Image& imageToRenderOn, const Point<int>& origin, const RectangleList& initialClip);
	~LowLevelGraphicsSoftwareRenderer();

	bool isVectorDevice() const;
	void setOrigin (int x, int y);
	void addTransform (const AffineTransform&);
	float getScaleFactor();
	bool clipToRectangle (const Rectangle<int>&);
	bool clipToRectangleList (const RectangleList&);
	void excludeClipRectangle (const Rectangle<int>&);
	void clipToPath (const Path&, const AffineTransform&);
	void clipToImageAlpha (const Image&, const AffineTransform&);
	bool clipRegionIntersects (const Rectangle<int>&);
	Rectangle<int> getClipBounds() const;
	bool isClipEmpty() const;

	void saveState();
	void restoreState();

	void beginTransparencyLayer (float opacity);
	void endTransparencyLayer();

	void setFill (const FillType&);
	void setOpacity (float opacity);
	void setInterpolationQuality (Graphics::ResamplingQuality);

	void fillRect (const Rectangle<int>&, bool replaceExistingContents);
	void fillPath (const Path&, const AffineTransform&);

	void drawImage (const Image&, const AffineTransform&);

	void drawLine (const Line <float>& line);

	void drawVerticalLine (int x, float top, float bottom);
	void drawHorizontalLine (int x, float top, float bottom);

	void setFont (const Font&);
	const Font& getFont();
	void drawGlyph (int glyphNumber, float x, float y);
	void drawGlyph (int glyphNumber, const AffineTransform&);

   #ifndef DOXYGEN
	class SavedState;
   #endif

protected:
	RenderingHelpers::SavedStateStack<SavedState> savedState;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (LowLevelGraphicsSoftwareRenderer);
};

#endif   // __JUCE_LOWLEVELGRAPHICSSOFTWARERENDERER_JUCEHEADER__

/*** End of inlined file: juce_LowLevelGraphicsSoftwareRenderer.h ***/


#endif
#ifndef __JUCE_IMAGE_JUCEHEADER__

#endif
#ifndef __JUCE_IMAGECACHE_JUCEHEADER__

/*** Start of inlined file: juce_ImageCache.h ***/
#ifndef __JUCE_IMAGECACHE_JUCEHEADER__
#define __JUCE_IMAGECACHE_JUCEHEADER__

/**
	A global cache of images that have been loaded from files or memory.

	If you're loading an image and may need to use the image in more than one
	place, this is used to allow the same image to be shared rather than loading
	multiple copies into memory.

	Another advantage is that after images are released, they will be kept in
	memory for a few seconds before it is actually deleted, so if you're repeatedly
	loading/deleting the same image, it'll reduce the chances of having to reload it
	each time.

	@see Image, ImageFileFormat
*/
class JUCE_API  ImageCache
{
public:

	/** Loads an image from a file, (or just returns the image if it's already cached).

		If the cache already contains an image that was loaded from this file,
		that image will be returned. Otherwise, this method will try to load the
		file, add it to the cache, and return it.

		Remember that the image returned is shared, so drawing into it might
		affect other things that are using it! If you want to draw on it, first
		call Image::duplicateIfShared()

		@param file     the file to try to load
		@returns        the image, or null if it there was an error loading it
		@see getFromMemory, getFromCache, ImageFileFormat::loadFrom
	*/
	static Image getFromFile (const File& file);

	/** Loads an image from an in-memory image file, (or just returns the image if it's already cached).

		If the cache already contains an image that was loaded from this block of memory,
		that image will be returned. Otherwise, this method will try to load the
		file, add it to the cache, and return it.

		Remember that the image returned is shared, so drawing into it might
		affect other things that are using it! If you want to draw on it, first
		call Image::duplicateIfShared()

		@param imageData    the block of memory containing the image data
		@param dataSize     the data size in bytes
		@returns            the image, or an invalid image if it there was an error loading it
		@see getFromMemory, getFromCache, ImageFileFormat::loadFrom
	*/
	static Image getFromMemory (const void* imageData, int dataSize);

	/** Checks the cache for an image with a particular hashcode.

		If there's an image in the cache with this hashcode, it will be returned,
		otherwise it will return an invalid image.

		@param hashCode the hash code that was associated with the image by addImageToCache()
		@see addImageToCache
	*/
	static Image getFromHashCode (int64 hashCode);

	/** Adds an image to the cache with a user-defined hash-code.

		The image passed-in will be referenced (not copied) by the cache, so it's probably
		a good idea not to draw into it after adding it, otherwise this will affect all
		instances of it that may be in use.

		@param image    the image to add
		@param hashCode the hash-code to associate with it
		@see getFromHashCode
	*/
	static void addImageToCache (const Image& image, int64 hashCode);

	/** Changes the amount of time before an unused image will be removed from the cache.
		By default this is about 5 seconds.
	*/
	static void setCacheTimeout (int millisecs);

private:

	class Pimpl;
	friend class Pimpl;

	ImageCache();
	~ImageCache();

	JUCE_DECLARE_NON_COPYABLE (ImageCache);
};

#endif   // __JUCE_IMAGECACHE_JUCEHEADER__

/*** End of inlined file: juce_ImageCache.h ***/


#endif
#ifndef __JUCE_IMAGECONVOLUTIONKERNEL_JUCEHEADER__

/*** Start of inlined file: juce_ImageConvolutionKernel.h ***/
#ifndef __JUCE_IMAGECONVOLUTIONKERNEL_JUCEHEADER__
#define __JUCE_IMAGECONVOLUTIONKERNEL_JUCEHEADER__

/**
	Represents a filter kernel to use in convoluting an image.

	@see Image::applyConvolution
*/
class JUCE_API  ImageConvolutionKernel
{
public:

	/** Creates an empty convulution kernel.

		@param size     the length of each dimension of the kernel, so e.g. if the size
						is 5, it will create a 5x5 kernel
	*/
	ImageConvolutionKernel (int size);

	/** Destructor. */
	~ImageConvolutionKernel();

	/** Resets all values in the kernel to zero. */
	void clear();

	/** Returns one of the kernel values. */
	float getKernelValue (int x, int y) const noexcept;

	/** Sets the value of a specific cell in the kernel.

		The x and y parameters must be in the range 0 < x < getKernelSize().

		@see setOverallSum
	*/
	void setKernelValue (int x, int y, float value) noexcept;

	/** Rescales all values in the kernel to make the total add up to a fixed value.

		This will multiply all values in the kernel by (desiredTotalSum / currentTotalSum).
	*/
	void setOverallSum (float desiredTotalSum);

	/** Multiplies all values in the kernel by a value. */
	void rescaleAllValues (float multiplier);

	/** Intialises the kernel for a gaussian blur.

		@param blurRadius   this may be larger or smaller than the kernel's actual
							size but this will obviously be wasteful or clip at the
							edges. Ideally the kernel should be just larger than
							(blurRadius * 2).
	*/
	void createGaussianBlur (float blurRadius);

	/** Returns the size of the kernel.

		E.g. if it's a 3x3 kernel, this returns 3.
	*/
	int getKernelSize() const               { return size; }

	/** Applies the kernel to an image.

		@param destImage        the image that will receive the resultant convoluted pixels.
		@param sourceImage      the source image to read from - this can be the same image as
								the destination, but if different, it must be exactly the same
								size and format.
		@param destinationArea  the region of the image to apply the filter to
	*/
	void applyToImage (Image& destImage,
					   const Image& sourceImage,
					   const Rectangle<int>& destinationArea) const;

private:

	HeapBlock <float> values;
	const int size;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ImageConvolutionKernel);
};

#endif   // __JUCE_IMAGECONVOLUTIONKERNEL_JUCEHEADER__

/*** End of inlined file: juce_ImageConvolutionKernel.h ***/


#endif
#ifndef __JUCE_IMAGEFILEFORMAT_JUCEHEADER__

/*** Start of inlined file: juce_ImageFileFormat.h ***/
#ifndef __JUCE_IMAGEFILEFORMAT_JUCEHEADER__
#define __JUCE_IMAGEFILEFORMAT_JUCEHEADER__

/**
	Base-class for codecs that can read and write image file formats such
	as PNG, JPEG, etc.

	This class also contains static methods to make it easy to load images
	from files, streams or from memory.

	@see Image, ImageCache
*/
class JUCE_API  ImageFileFormat
{
protected:

	/** Creates an ImageFormat. */
	ImageFileFormat()                   {}

public:
	/** Destructor. */
	virtual ~ImageFileFormat()          {}

	/** Returns a description of this file format.

		E.g. "JPEG", "PNG"
	*/
	virtual String getFormatName() = 0;

	/** Returns true if the given stream seems to contain data that this format
		understands.

		The format class should only read the first few bytes of the stream and sniff
		for header bytes that it understands.

		@see decodeImage
	*/
	virtual bool canUnderstand (InputStream& input) = 0;

	/** Tries to decode and return an image from the given stream.

		This will be called for an image format after calling its canUnderStand() method
		to see if it can handle the stream.

		@param input    the stream to read the data from. The stream will be positioned
						at the start of the image data (but this may not necessarily
						be position 0)
		@returns        the image that was decoded, or an invalid image if it fails.
		@see loadFrom
	*/
	virtual Image decodeImage (InputStream& input) = 0;

	/** Attempts to write an image to a stream.

		To specify extra information like encoding quality, there will be appropriate parameters
		in the subclasses of the specific file types.

		@returns        true if it nothing went wrong.
	*/
	virtual bool writeImageToStream (const Image& sourceImage,
									 OutputStream& destStream) = 0;

	/** Tries the built-in decoders to see if it can find one to read this stream.

		There are currently built-in decoders for PNG, JPEG and GIF formats.

		The object that is returned should not be deleted by the caller.

		@see canUnderstand, decodeImage, loadFrom
	*/
	static ImageFileFormat* findImageFormatForStream (InputStream& input);

	/** Tries to load an image from a stream.

		This will use the findImageFormatForStream() method to locate a suitable
		codec, and use that to load the image.

		@returns        the image that was decoded, or an invalid image if it fails.
	*/
	static Image loadFrom (InputStream& input);

	/** Tries to load an image from a file.

		This will use the findImageFormatForStream() method to locate a suitable
		codec, and use that to load the image.

		@returns        the image that was decoded, or an invalid image if it fails.
	*/
	static Image loadFrom (const File& file);

	/** Tries to load an image from a block of raw image data.

		This will use the findImageFormatForStream() method to locate a suitable
		codec, and use that to load the image.

		@returns        the image that was decoded, or an invalid image if it fails.
	*/
	static Image loadFrom (const void* rawData,
						   size_t numBytesOfData);

};

/**
	A subclass of ImageFileFormat for reading and writing PNG files.

	@see ImageFileFormat, JPEGImageFormat
*/
class JUCE_API  PNGImageFormat  : public ImageFileFormat
{
public:

	PNGImageFormat();
	~PNGImageFormat();

	String getFormatName();
	bool canUnderstand (InputStream& input);
	Image decodeImage (InputStream& input);
	bool writeImageToStream (const Image& sourceImage, OutputStream& destStream);
};

/**
	A subclass of ImageFileFormat for reading and writing JPEG files.

	@see ImageFileFormat, PNGImageFormat
*/
class JUCE_API  JPEGImageFormat  : public ImageFileFormat
{
public:

	JPEGImageFormat();
	~JPEGImageFormat();

	/** Specifies the quality to be used when writing a JPEG file.

		@param newQuality  a value 0 to 1.0, where 0 is low quality, 1.0 is best, or
						   any negative value is "default" quality
	*/
	void setQuality (float newQuality);

	String getFormatName();
	bool canUnderstand (InputStream& input);
	Image decodeImage (InputStream& input);
	bool writeImageToStream (const Image& sourceImage, OutputStream& destStream);

private:
	float quality;
};

/**
	A subclass of ImageFileFormat for reading GIF files.

	@see ImageFileFormat, PNGImageFormat, JPEGImageFormat
*/
class JUCE_API  GIFImageFormat  : public ImageFileFormat
{
public:

	GIFImageFormat();
	~GIFImageFormat();

	String getFormatName();
	bool canUnderstand (InputStream& input);
	Image decodeImage (InputStream& input);
	bool writeImageToStream (const Image& sourceImage, OutputStream& destStream);
};

#endif   // __JUCE_IMAGEFILEFORMAT_JUCEHEADER__

/*** End of inlined file: juce_ImageFileFormat.h ***/


#endif
#ifndef __JUCE_ATTRIBUTEDSTRING_JUCEHEADER__

/*** Start of inlined file: juce_AttributedString.h ***/
#ifndef __JUCE_ATTRIBUTEDSTRING_JUCEHEADER__
#define __JUCE_ATTRIBUTEDSTRING_JUCEHEADER__

/**
	A text string with a set of colour/font settings that are associated with sub-ranges
	of the text.

	An attributed string lets you create a string with varied fonts, colours, word-wrapping,
	layout, etc., and draw it using AttributedString::draw().

	@see TextLayout
*/
class JUCE_API  AttributedString
{
public:
	/** Creates an empty attributed string. */
	AttributedString();

	/** Creates an attributed string with the given text. */
	explicit AttributedString (const String& text);

	AttributedString (const AttributedString&);
	AttributedString& operator= (const AttributedString&);
   #if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
	AttributedString (AttributedString&&) noexcept;
	AttributedString& operator= (AttributedString&&) noexcept;
   #endif

	/** Destructor. */
	~AttributedString();

	/** Returns the complete text of this attributed string. */
	const String& getText() const noexcept                  { return text; }

	/** Replaces all the text.
		This will change the text, but won't affect any of the colour or font attributes
		that have been added.
	*/
	void setText (const String& newText);

	/** Appends some text (with a default font and colour). */
	void append (const String& textToAppend);
	/** Appends some text, with a specified font, and the default colour (black). */
	void append (const String& textToAppend, const Font& font);
	/** Appends some text, with a specified colour, and the default font. */
	void append (const String& textToAppend, const Colour& colour);
	/** Appends some text, with a specified font and colour. */
	void append (const String& textToAppend, const Font& font, const Colour& colour);

	/** Resets the string, clearing all text and attributes.
		Note that this won't affect global settings like the justification type,
		word-wrap mode, etc.
	*/
	void clear();

	/** Draws this string within the given area.
		The layout of the string within the rectangle is controlled by the justification
		value passed to setJustification().
	*/
	void draw (Graphics& g, const Rectangle<float>& area) const;

	/** Returns the justification that should be used for laying-out the text.
		This may include both vertical and horizontal flags.
	*/
	Justification getJustification() const noexcept         { return justification; }

	/** Sets the justification that should be used for laying-out the text.
		This may include both vertical and horizontal flags.
	*/
	void setJustification (const Justification& newJustification) noexcept;

	/** Types of word-wrap behaviour.
		@see getWordWrap, setWordWrap
	*/
	enum WordWrap
	{
		none,   /**< No word-wrapping: lines extend indefinitely. */
		byWord, /**< Lines are wrapped on a word boundary. */
		byChar, /**< Lines are wrapped on a character boundary. */
	};

	/** Returns the word-wrapping behaviour. */
	WordWrap getWordWrap() const noexcept                   { return wordWrap; }

	/** Sets the word-wrapping behaviour. */
	void setWordWrap (WordWrap newWordWrap) noexcept;

	/** Types of reading direction that can be used.
		@see getReadingDirection, setReadingDirection
	*/
	enum ReadingDirection
	{
		natural,
		leftToRight,
		rightToLeft,
	};

	/** Returns the reading direction for the text. */
	ReadingDirection getReadingDirection() const noexcept   { return readingDirection; }

	/** Sets the reading direction that should be used for the text. */
	void setReadingDirection (ReadingDirection newReadingDirection) noexcept;

	/** Returns the extra line-spacing distance. */
	float getLineSpacing() const noexcept                   { return lineSpacing; }

	/** Sets an extra line-spacing distance. */
	void setLineSpacing (float newLineSpacing) noexcept;

	/** An attribute that has been applied to a range of characters in an AttributedString. */
	class JUCE_API  Attribute
	{
	public:
		/** Creates an attribute that changes the colour for a range of characters.
			@see AttributedString::setColour()
		*/
		Attribute (const Range<int>& range, const Colour& colour);

		/** Creates an attribute that changes the font for a range of characters.
			@see AttributedString::setFont()
		*/
		Attribute (const Range<int>& range, const Font& font);

		Attribute (const Attribute&);
		~Attribute();

		/** If this attribute specifies a font, this returns it; otherwise it returns nullptr. */
		const Font* getFont() const noexcept            { return font; }

		/** If this attribute specifies a colour, this returns it; otherwise it returns nullptr. */
		const Colour* getColour() const noexcept        { return colour; }

		/** The range of characters to which this attribute will be applied. */
		const Range<int> range;

	private:
		ScopedPointer<Font> font;
		ScopedPointer<Colour> colour;

		Attribute& operator= (const Attribute&);

		JUCE_LEAK_DETECTOR (Attribute);
	};

	/** Returns the number of attributes that have been added to this string. */
	int getNumAttributes() const noexcept                       { return attributes.size(); }

	/** Returns one of the string's attributes.
		The index provided must be less than getNumAttributes(), and >= 0.
	*/
	const Attribute* getAttribute (int index) const noexcept    { return attributes.getUnchecked (index); }

	/** Adds a colour attribute for the specified range. */
	void setColour (const Range<int>& range, const Colour& colour);

	/** Removes all existing colour attributes, and applies this colour to the whole string. */
	void setColour (const Colour& colour);

	/** Adds a font attribute for the specified range. */
	void setFont (const Range<int>& range, const Font& font);

	/** Removes all existing font attributes, and applies this font to the whole string. */
	void setFont (const Font& font);

private:
	String text;
	float lineSpacing;
	Justification justification;
	WordWrap wordWrap;
	ReadingDirection readingDirection;
	OwnedArray<Attribute> attributes;

	JUCE_LEAK_DETECTOR (AttributedString);
};

#endif   // __JUCE_ATTRIBUTEDSTRING_JUCEHEADER__

/*** End of inlined file: juce_AttributedString.h ***/


#endif
#ifndef __JUCE_CUSTOMTYPEFACE_JUCEHEADER__

/*** Start of inlined file: juce_CustomTypeface.h ***/
#ifndef __JUCE_CUSTOMTYPEFACE_JUCEHEADER__
#define __JUCE_CUSTOMTYPEFACE_JUCEHEADER__

class InputStream;
class OutputStream;

/**
	A typeface that can be populated with custom glyphs.

	You can create a CustomTypeface if you need one that contains your own glyphs,
	or if you need to load a typeface from a Juce-formatted binary stream.

	If you want to create a copy of a native face, you can use addGlyphsFromOtherTypeface()
	to copy glyphs into this face.

	@see Typeface, Font
*/
class JUCE_API  CustomTypeface  : public Typeface
{
public:

	/** Creates a new, empty typeface. */
	CustomTypeface();

	/** Loads a typeface from a previously saved stream.
		The stream must have been created by writeToStream().
		@see writeToStream
	*/
	explicit CustomTypeface (InputStream& serialisedTypefaceStream);

	/** Destructor. */
	~CustomTypeface();

	/** Resets this typeface, deleting all its glyphs and settings. */
	void clear();

	/** Sets the vital statistics for the typeface.
		@param name     the typeface's name
		@param ascent   the ascent - this is normalised to a height of 1.0 and this is
						the value that will be returned by Typeface::getAscent(). The
						descent is assumed to be (1.0 - ascent)
		@param isBold   should be true if the typeface is bold
		@param isItalic should be true if the typeface is italic
		@param defaultCharacter     the character to be used as a replacement if there's
						no glyph available for the character that's being drawn
	*/
	void setCharacteristics (const String& name, float ascent,
							 bool isBold, bool isItalic,
							 juce_wchar defaultCharacter) noexcept;

	/** Adds a glyph to the typeface.

		The path that is passed in is normalised so that the font height is 1.0, and its
		origin is the anchor point of the character on its baseline.

		The width is the nominal width of the character, and any extra kerning values that
		are specified will be added to this width.
	*/
	void addGlyph (juce_wchar character, const Path& path, float width) noexcept;

	/** Specifies an extra kerning amount to be used between a pair of characters.
		The amount will be added to the nominal width of the first character when laying out a string.
	*/
	void addKerningPair (juce_wchar char1, juce_wchar char2, float extraAmount) noexcept;

	/** Adds a range of glyphs from another typeface.
		This will attempt to pull in the paths and kerning information from another typeface and
		add it to this one.
	*/
	void addGlyphsFromOtherTypeface (Typeface& typefaceToCopy, juce_wchar characterStartIndex, int numCharacters) noexcept;

	/** Saves this typeface as a Juce-formatted font file.
		A CustomTypeface can be created to reload the data that is written - see the CustomTypeface
		constructor.
	*/
	bool writeToStream (OutputStream& outputStream);

	// The following methods implement the basic Typeface behaviour.
	float getAscent() const;
	float getDescent() const;
	float getStringWidth (const String& text);
	void getGlyphPositions (const String& text, Array <int>& glyphs, Array<float>& xOffsets);
	bool getOutlineForGlyph (int glyphNumber, Path& path);
	EdgeTable* getEdgeTableForGlyph (int glyphNumber, const AffineTransform& transform);

protected:

	juce_wchar defaultCharacter;
	float ascent;
	bool isBold, isItalic;

	/** If a subclass overrides this, it can load glyphs into the font on-demand.
		When methods such as getGlyphPositions() or getOutlineForGlyph() are asked for a
		particular character and there's no corresponding glyph, they'll call this
		method so that a subclass can try to add that glyph, returning true if it
		manages to do so.
	*/
	virtual bool loadGlyphIfPossible (juce_wchar characterNeeded);

private:

	class GlyphInfo;
	friend class OwnedArray<GlyphInfo>;
	OwnedArray <GlyphInfo> glyphs;
	short lookupTable [128];

	GlyphInfo* findGlyph (const juce_wchar character, bool loadIfNeeded) noexcept;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (CustomTypeface);
};

#endif   // __JUCE_CUSTOMTYPEFACE_JUCEHEADER__

/*** End of inlined file: juce_CustomTypeface.h ***/


#endif
#ifndef __JUCE_FONT_JUCEHEADER__

#endif
#ifndef __JUCE_GLYPHARRANGEMENT_JUCEHEADER__

/*** Start of inlined file: juce_GlyphArrangement.h ***/
#ifndef __JUCE_GLYPHARRANGEMENT_JUCEHEADER__
#define __JUCE_GLYPHARRANGEMENT_JUCEHEADER__

/**
	A glyph from a particular font, with a particular size, style,
	typeface and position.

	You should rarely need to use this class directly - for most purposes, the
	GlyphArrangement class will do what you need for text layout.

	@see GlyphArrangement, Font
*/
class JUCE_API  PositionedGlyph
{
public:

	PositionedGlyph (const Font& font, juce_wchar character, int glyphNumber,
					 float anchorX, float baselineY, float width, bool isWhitespace);

	PositionedGlyph (const PositionedGlyph& other);
	PositionedGlyph& operator= (const PositionedGlyph& other);
	~PositionedGlyph();

	/** Returns the character the glyph represents. */
	juce_wchar getCharacter() const noexcept    { return character; }
	/** Checks whether the glyph is actually empty. */
	bool isWhitespace() const noexcept          { return whitespace; }

	/** Returns the position of the glyph's left-hand edge. */
	float getLeft() const noexcept              { return x; }
	/** Returns the position of the glyph's right-hand edge. */
	float getRight() const noexcept             { return x + w; }
	/** Returns the y position of the glyph's baseline. */
	float getBaselineY() const noexcept         { return y; }
	/** Returns the y position of the top of the glyph. */
	float getTop() const                        { return y - font.getAscent(); }
	/** Returns the y position of the bottom of the glyph. */
	float getBottom() const                     { return y + font.getDescent(); }
	/** Returns the bounds of the glyph. */
	Rectangle<float> getBounds() const          { return Rectangle<float> (x, getTop(), w, font.getHeight()); }

	/** Shifts the glyph's position by a relative amount. */
	void moveBy (float deltaX, float deltaY);

	/** Draws the glyph into a graphics context. */
	void draw (const Graphics& g) const;

	/** Draws the glyph into a graphics context, with an extra transform applied to it. */
	void draw (const Graphics& g, const AffineTransform& transform) const;

	/** Returns the path for this glyph.

		@param path     the glyph's outline will be appended to this path
	*/
	void createPath (Path& path) const;

	/** Checks to see if a point lies within this glyph. */
	bool hitTest (float x, float y) const;

private:

	friend class GlyphArrangement;
	Font font;
	juce_wchar character;
	int glyph;
	float x, y, w;
	bool whitespace;

	JUCE_LEAK_DETECTOR (PositionedGlyph);
};

/**
	A set of glyphs, each with a position.

	You can create a GlyphArrangement, text to it and then draw it onto a
	graphics context. It's used internally by the text methods in the
	Graphics class, but can be used directly if more control is needed.

	@see Font, PositionedGlyph
*/
class JUCE_API  GlyphArrangement
{
public:

	/** Creates an empty arrangement. */
	GlyphArrangement();

	/** Takes a copy of another arrangement. */
	GlyphArrangement (const GlyphArrangement& other);

	/** Copies another arrangement onto this one.
		To add another arrangement without clearing this one, use addGlyphArrangement().
	*/
	GlyphArrangement& operator= (const GlyphArrangement& other);

	/** Destructor. */
	~GlyphArrangement();

	/** Returns the total number of glyphs in the arrangement. */
	int getNumGlyphs() const noexcept                           { return glyphs.size(); }

	/** Returns one of the glyphs from the arrangement.

		@param index    the glyph's index, from 0 to (getNumGlyphs() - 1). Be
						careful not to pass an out-of-range index here, as it
						doesn't do any bounds-checking.
	*/
	PositionedGlyph& getGlyph (int index) const;

	/** Clears all text from the arrangement and resets it.
	*/
	void clear();

	/** Appends a line of text to the arrangement.

		This will add the text as a single line, where x is the left-hand edge of the
		first character, and y is the position for the text's baseline.

		If the text contains new-lines or carriage-returns, this will ignore them - use
		addJustifiedText() to add multi-line arrangements.
	*/
	void addLineOfText (const Font& font,
						const String& text,
						float x, float y);

	/** Adds a line of text, truncating it if it's wider than a specified size.

		This is the same as addLineOfText(), but if the line's width exceeds the value
		specified in maxWidthPixels, it will be truncated using either ellipsis (i.e. dots: "..."),
		if useEllipsis is true, or if this is false, it will just drop any subsequent characters.
	*/
	void addCurtailedLineOfText (const Font& font,
								 const String& text,
								 float x, float y,
								 float maxWidthPixels,
								 bool useEllipsis);

	/** Adds some multi-line text, breaking lines at word-boundaries if they are too wide.

		This will add text to the arrangement, breaking it into new lines either where there
		is a new-line or carriage-return character in the text, or where a line's width
		exceeds the value set in maxLineWidth.

		Each line that is added will be laid out using the flags set in horizontalLayout, so
		the lines can be left- or right-justified, or centred horizontally in the space
		between x and (x + maxLineWidth).

		The y co-ordinate is the position of the baseline of the first line of text - subsequent
		lines will be placed below it, separated by a distance of font.getHeight().
	*/
	void addJustifiedText (const Font& font,
						   const String& text,
						   float x, float y,
						   float maxLineWidth,
						   const Justification& horizontalLayout);

	/** Tries to fit some text withing a given space.

		This does its best to make the given text readable within the specified rectangle,
		so it useful for labelling things.

		If the text is too big, it'll be squashed horizontally or broken over multiple lines
		if the maximumLinesToUse value allows this. If the text just won't fit into the space,
		it'll cram as much as possible in there, and put some ellipsis at the end to show that
		it's been truncated.

		A Justification parameter lets you specify how the text is laid out within the rectangle,
		both horizontally and vertically.

		@see Graphics::drawFittedText
	*/
	void addFittedText (const Font& font,
						const String& text,
						float x, float y, float width, float height,
						const Justification& layout,
						int maximumLinesToUse,
						float minimumHorizontalScale = 0.7f);

	/** Appends another glyph arrangement to this one. */
	void addGlyphArrangement (const GlyphArrangement& other);

	/** Appends a custom glyph to the arrangement. */
	void addGlyph (const PositionedGlyph& glyph);

	/** Draws this glyph arrangement to a graphics context.

		This uses cached bitmaps so is much faster than the draw (Graphics&, const AffineTransform&)
		method, which renders the glyphs as filled vectors.
	*/
	void draw (const Graphics& g) const;

	/** Draws this glyph arrangement to a graphics context.

		This renders the paths as filled vectors, so is far slower than the draw (Graphics&)
		method for non-transformed arrangements.
	*/
	void draw (const Graphics& g, const AffineTransform& transform) const;

	/** Converts the set of glyphs into a path.

		@param path     the glyphs' outlines will be appended to this path
	*/
	void createPath (Path& path) const;

	/** Looks for a glyph that contains the given co-ordinate.

		@returns the index of the glyph, or -1 if none were found.
	*/
	int findGlyphIndexAt (float x, float y) const;

	/** Finds the smallest rectangle that will enclose a subset of the glyphs.

		@param startIndex               the first glyph to test
		@param numGlyphs                the number of glyphs to include; if this is < 0, all glyphs after
										startIndex will be included
		@param includeWhitespace        if true, the extent of any whitespace characters will also
										be taken into account
	*/
	Rectangle<float> getBoundingBox (int startIndex, int numGlyphs, bool includeWhitespace) const;

	/** Shifts a set of glyphs by a given amount.

		@param startIndex   the first glyph to transform
		@param numGlyphs    the number of glyphs to move; if this is < 0, all glyphs after
							startIndex will be used
		@param deltaX       the amount to add to their x-positions
		@param deltaY       the amount to add to their y-positions
	*/
	void moveRangeOfGlyphs (int startIndex, int numGlyphs,
							float deltaX, float deltaY);

	/** Removes a set of glyphs from the arrangement.

		@param startIndex   the first glyph to remove
		@param numGlyphs    the number of glyphs to remove; if this is < 0, all glyphs after
							startIndex will be deleted
	*/
	void removeRangeOfGlyphs (int startIndex, int numGlyphs);

	/** Expands or compresses a set of glyphs horizontally.

		@param startIndex               the first glyph to transform
		@param numGlyphs                the number of glyphs to stretch; if this is < 0, all glyphs after
										startIndex will be used
		@param horizontalScaleFactor    how much to scale their horizontal width by
	*/
	void stretchRangeOfGlyphs (int startIndex, int numGlyphs,
							   float horizontalScaleFactor);

	/** Justifies a set of glyphs within a given space.

		This moves the glyphs as a block so that the whole thing is located within the
		given rectangle with the specified layout.

		If the Justification::horizontallyJustified flag is specified, each line will
		be stretched out to fill the specified width.
	*/
	void justifyGlyphs (int startIndex, int numGlyphs,
						float x, float y, float width, float height,
						const Justification& justification);

private:

	OwnedArray <PositionedGlyph> glyphs;

	int insertEllipsis (const Font&, float maxXPos, int startIndex, int endIndex);
	int fitLineIntoSpace (int start, int numGlyphs, float x, float y, float w, float h, const Font&,
						  const Justification&, float minimumHorizontalScale);
	void spreadOutLine (int start, int numGlyphs, float targetWidth);

	JUCE_LEAK_DETECTOR (GlyphArrangement);
};

#endif   // __JUCE_GLYPHARRANGEMENT_JUCEHEADER__

/*** End of inlined file: juce_GlyphArrangement.h ***/


#endif
#ifndef __JUCE_TEXTLAYOUT_JUCEHEADER__

/*** Start of inlined file: juce_TextLayout.h ***/
#ifndef __JUCE_TEXTLAYOUT_JUCEHEADER__
#define __JUCE_TEXTLAYOUT_JUCEHEADER__

class Graphics;

/**
	A Pre-formatted piece of text, which may contain multiple fonts and colours.

	A TextLayout is created from an AttributedString, and once created can be
	quickly drawn into a Graphics context.

	@see AttributedString
*/
class JUCE_API  TextLayout
{
public:
	/** Creates an empty layout.
		Having created a TextLayout, you can populate it using createLayout() or
		createLayoutWithBalancedLineLengths().
	*/
	TextLayout();
	TextLayout (const TextLayout&);
	TextLayout& operator= (const TextLayout&);
   #if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
	TextLayout (TextLayout&& other) noexcept;
	TextLayout& operator= (TextLayout&&) noexcept;
   #endif

	/** Destructor. */
	~TextLayout();

	/** Creates a layout from the given attributed string.
		This will replace any data that is currently stored in the layout.
	*/
	void createLayout (const AttributedString& text, float maxWidth);

	/** Creates a layout, attempting to choose a width which results in lines
		of a similar length.

		This will be slower than the normal createLayout method, but produces a
		tidier result.
	*/
	void createLayoutWithBalancedLineLengths (const AttributedString& text, float maxWidth);

	/** Draws the layout within the specified area.
		The position of the text within the rectangle is controlled by the justification
		flags set in the original AttributedString that was used to create this layout.
	*/
	void draw (Graphics& g, const Rectangle<float>& area) const;

	/** A positioned glyph. */
	class JUCE_API  Glyph
	{
	public:
		Glyph (int glyphCode, const Point<float>& anchor, float width) noexcept;
		Glyph (const Glyph&) noexcept;
		Glyph& operator= (const Glyph&) noexcept;
		~Glyph() noexcept;

		/** The code number of this glyph. */
		int glyphCode;

		/** The glyph's anchor point - this is relative to the line's origin.
			@see TextLayout::Line::lineOrigin
		*/
		Point<float> anchor;

		float width;

	private:
		JUCE_LEAK_DETECTOR (Glyph);
	};

	/** A sequence of glyphs with a common font and colour. */
	class JUCE_API  Run
	{
	public:
		Run() noexcept;
		Run (const Run&);
		Run (const Range<int>& stringRange, int numGlyphsToPreallocate);
		~Run() noexcept;

		Font font;              /**< The run's font. */
		Colour colour;          /**< The run's colour. */
		Array<Glyph> glyphs;    /**< The glyphs in this run. */
		Range<int> stringRange; /**< The character range that this run represents in the
									 original string that was used to create it. */
	private:
		Run& operator= (const Run&);
		JUCE_LEAK_DETECTOR (Run);
	};

	/** A line containing a sequence of glyph-runs. */
	class JUCE_API  Line
	{
	public:
		Line() noexcept;
		Line (const Line&);
		Line (const Range<int>& stringRange, const Point<float>& lineOrigin,
			  float ascent, float descent, float leading, int numRunsToPreallocate);
		~Line() noexcept;

		/** Returns the X position range which contains all the glyphs in this line. */
		Range<float> getLineBoundsX() const noexcept;

		OwnedArray<Run> runs;           /**< The glyph-runs in this line. */
		Range<int> stringRange;         /**< The character range that this line represents in the
											 original string that was used to create it. */
		Point<float> lineOrigin;        /**< The line's baseline origin. */
		float ascent, descent, leading;

	private:
		Line& operator= (const Line&);
		JUCE_LEAK_DETECTOR (Line);
	};

	/** Returns the maximum width of the content. */
	float getWidth() const noexcept     { return width; }

	/** Returns the maximum height of the content. */
	float getHeight() const noexcept;

	/** Returns the number of lines in the layout. */
	int getNumLines() const noexcept    { return lines.size(); }

	/** Returns one of the lines. */
	Line& getLine (int index) const;

	/** Adds a line to the layout. The layout will take ownership of this line object
		and will delete it when it is no longer needed. */
	void addLine (Line* line);

	/** Pre-allocates space for the specified number of lines. */
	void ensureStorageAllocated (int numLinesNeeded);

private:
	OwnedArray<Line> lines;
	float width;
	Justification justification;

	void createStandardLayout (const AttributedString&);
	bool createNativeLayout (const AttributedString&);
	void recalculateWidth();

	JUCE_LEAK_DETECTOR (TextLayout);
};

#endif   // __JUCE_TEXTLAYOUT_JUCEHEADER__

/*** End of inlined file: juce_TextLayout.h ***/


#endif
#ifndef __JUCE_TYPEFACE_JUCEHEADER__

#endif
#ifndef __JUCE_DROPSHADOWEFFECT_JUCEHEADER__

/*** Start of inlined file: juce_DropShadowEffect.h ***/
#ifndef __JUCE_DROPSHADOWEFFECT_JUCEHEADER__
#define __JUCE_DROPSHADOWEFFECT_JUCEHEADER__


/*** Start of inlined file: juce_ImageEffectFilter.h ***/
#ifndef __JUCE_IMAGEEFFECTFILTER_JUCEHEADER__
#define __JUCE_IMAGEEFFECTFILTER_JUCEHEADER__

/**
	A graphical effect filter that can be applied to components.

	An ImageEffectFilter can be applied to the image that a component
	paints before it hits the screen.

	This is used for adding effects like shadows, blurs, etc.

	@see Component::setComponentEffect
*/
class JUCE_API  ImageEffectFilter
{
public:

	/** Overridden to render the effect.

		The implementation of this method must use the image that is passed in
		as its source, and should render its output to the graphics context passed in.

		@param sourceImage      the image that the source component has just rendered with
								its paint() method. The image may or may not have an alpha
								channel, depending on whether the component is opaque.
		@param destContext      the graphics context to use to draw the resultant image.
		@param alpha            the alpha with which to draw the resultant image to the
								target context
	*/
	virtual void applyEffect (Image& sourceImage,
							  Graphics& destContext,
							  float alpha) = 0;

	/** Destructor. */
	virtual ~ImageEffectFilter() {}

};

#endif   // __JUCE_IMAGEEFFECTFILTER_JUCEHEADER__

/*** End of inlined file: juce_ImageEffectFilter.h ***/

/**
	An effect filter that adds a drop-shadow behind the image's content.

	(This will only work on images/components that aren't opaque, of course).

	When added to a component, this effect will draw a soft-edged
	shadow based on what gets drawn inside it. The shadow will also
	be applied to the component's children.

	For speed, this doesn't use a proper gaussian blur, but cheats by
	using a simple bilinear filter. If you need a really high-quality
	shadow, check out ImageConvolutionKernel::createGaussianBlur()

	@see Component::setComponentEffect
*/
class JUCE_API  DropShadowEffect  : public ImageEffectFilter
{
public:

	/** Creates a default drop-shadow effect.

		To customise the shadow's appearance, use the setShadowProperties()
		method.
	*/
	DropShadowEffect();

	/** Destructor. */
	~DropShadowEffect();

	/** Sets up parameters affecting the shadow's appearance.

		@param newRadius        the (approximate) radius of the blur used
		@param newOpacity       the opacity with which the shadow is rendered
		@param newShadowOffsetX allows the shadow to be shifted in relation to the
								component's contents
		@param newShadowOffsetY allows the shadow to be shifted in relation to the
								component's contents
	*/
	void setShadowProperties (float newRadius,
							  float newOpacity,
							  int newShadowOffsetX,
							  int newShadowOffsetY);

	/** @internal */
	void applyEffect (Image& sourceImage, Graphics& destContext, float alpha);

private:

	int offsetX, offsetY;
	float radius, opacity;

	JUCE_LEAK_DETECTOR (DropShadowEffect);
};

#endif   // __JUCE_DROPSHADOWEFFECT_JUCEHEADER__

/*** End of inlined file: juce_DropShadowEffect.h ***/


#endif
#ifndef __JUCE_GLOWEFFECT_JUCEHEADER__

/*** Start of inlined file: juce_GlowEffect.h ***/
#ifndef __JUCE_GLOWEFFECT_JUCEHEADER__
#define __JUCE_GLOWEFFECT_JUCEHEADER__

/**
	A component effect that adds a coloured blur around the component's contents.

	(This will only work on non-opaque components).

	@see Component::setComponentEffect, DropShadowEffect
*/
class JUCE_API  GlowEffect  : public ImageEffectFilter
{
public:

	/** Creates a default 'glow' effect.

		To customise its appearance, use the setGlowProperties() method.
	*/
	GlowEffect();

	/** Destructor. */
	~GlowEffect();

	/** Sets the glow's radius and colour.

		The radius is how large the blur should be, and the colour is
		used to render it (for a less intense glow, lower the colour's
		opacity).
	*/
	void setGlowProperties (float newRadius,
							const Colour& newColour);

	/** @internal */
	void applyEffect (Image& sourceImage, Graphics& destContext, float alpha);

private:

	float radius;
	Colour colour;

	JUCE_LEAK_DETECTOR (GlowEffect);
};

#endif   // __JUCE_GLOWEFFECT_JUCEHEADER__

/*** End of inlined file: juce_GlowEffect.h ***/


#endif
#ifndef __JUCE_IMAGEEFFECTFILTER_JUCEHEADER__

#endif
// END_AUTOINCLUDE

}

#endif   // __JUCE_GRAPHICS_JUCEHEADER__

/*** End of inlined file: juce_graphics.h ***/


/*** Start of inlined file: juce_data_structures.h ***/
#ifndef __JUCE_DATA_STRUCTURES_JUCEHEADER__
#define __JUCE_DATA_STRUCTURES_JUCEHEADER__

namespace juce
{

// START_AUTOINCLUDE values, undomanager, app_properties
#ifndef __JUCE_VALUE_JUCEHEADER__

/*** Start of inlined file: juce_Value.h ***/
#ifndef __JUCE_VALUE_JUCEHEADER__
#define __JUCE_VALUE_JUCEHEADER__

/**
	Represents a shared variant value.

	A Value object contains a reference to a var object, and can get and set its value.
	Listeners can be attached to be told when the value is changed.

	The Value class is a wrapper around a shared, reference-counted underlying data
	object - this means that multiple Value objects can all refer to the same piece of
	data, allowing all of them to be notified when any of them changes it.

	When you create a Value with its default constructor, it acts as a wrapper around a
	simple var object, but by creating a Value that refers to a custom subclass of ValueSource,
	you can map the Value onto any kind of underlying data.
*/
class JUCE_API  Value
{
public:

	/** Creates an empty Value, containing a void var. */
	Value();

	/** Creates a Value that refers to the same value as another one.

		Note that this doesn't make a copy of the other value - both this and the other
		Value will share the same underlying value, so that when either one alters it, both
		will see it change.
	*/
	Value (const Value& other);

	/** Creates a Value that is set to the specified value. */
	explicit Value (const var& initialValue);

   #if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
	Value (Value&& other) noexcept;
	Value& operator= (Value&& other) noexcept;
   #endif

	/** Destructor. */
	~Value();

	/** Returns the current value. */
	var getValue() const;

	/** Returns the current value. */
	operator var() const;

	/** Returns the value as a string.

		This is alternative to writing things like "myValue.getValue().toString()".
	*/
	String toString() const;

	/** Sets the current value.

		You can also use operator= to set the value.

		If there are any listeners registered, they will be notified of the
		change asynchronously.
	*/
	void setValue (const var& newValue);

	/** Sets the current value.

		This is the same as calling setValue().

		If there are any listeners registered, they will be notified of the
		change asynchronously.
	*/
	Value& operator= (const var& newValue);

	/** Makes this object refer to the same underlying ValueSource as another one.

		Once this object has been connected to another one, changing either one
		will update the other.

		Existing listeners will still be registered after you call this method, and
		they'll continue to receive messages when the new value changes.
	*/
	void referTo (const Value& valueToReferTo);

	/** Returns true if this value and the other one are references to the same value.
	*/
	bool refersToSameSourceAs (const Value& other) const;

	/** Compares two values.
		This is a compare-by-value comparison, so is effectively the same as
		saying (this->getValue() == other.getValue()).
	*/
	bool operator== (const Value& other) const;

	/** Compares two values.
		This is a compare-by-value comparison, so is effectively the same as
		saying (this->getValue() != other.getValue()).
	*/
	bool operator!= (const Value& other) const;

	/** Receives callbacks when a Value object changes.
		@see Value::addListener
	*/
	class JUCE_API  Listener
	{
	public:
		Listener()          {}
		virtual ~Listener() {}

		/** Called when a Value object is changed.

			Note that the Value object passed as a parameter may not be exactly the same
			object that you registered the listener with - it might be a copy that refers
			to the same underlying ValueSource. To find out, you can call Value::refersToSameSourceAs().
		*/
		virtual void valueChanged (Value& value) = 0;
	};

	/** Adds a listener to receive callbacks when the value changes.

		The listener is added to this specific Value object, and not to the shared
		object that it refers to. When this object is deleted, all the listeners will
		be lost, even if other references to the same Value still exist. So when you're
		adding a listener, make sure that you add it to a ValueTree instance that will last
		for as long as you need the listener. In general, you'd never want to add a listener
		to a local stack-based ValueTree, but more likely to one that's a member variable.

		@see removeListener
	*/
	void addListener (Listener* listener);

	/** Removes a listener that was previously added with addListener(). */
	void removeListener (Listener* listener);

	/**
		Used internally by the Value class as the base class for its shared value objects.

		The Value class is essentially a reference-counted pointer to a shared instance
		of a ValueSource object. If you're feeling adventurous, you can create your own custom
		ValueSource classes to allow Value objects to represent your own custom data items.
	*/
	class JUCE_API  ValueSource   : public SingleThreadedReferenceCountedObject,
									public AsyncUpdater
	{
	public:
		ValueSource();
		virtual ~ValueSource();

		/** Returns the current value of this object. */
		virtual var getValue() const = 0;

		/** Changes the current value.
			This must also trigger a change message if the value actually changes.
		*/
		virtual void setValue (const var& newValue) = 0;

		/** Delivers a change message to all the listeners that are registered with
			this value.

			If dispatchSynchronously is true, the method will call all the listeners
			before returning; otherwise it'll dispatch a message and make the call later.
		*/
		void sendChangeMessage (bool dispatchSynchronously);

	protected:

		friend class Value;
		SortedSet <Value*> valuesWithListeners;

		void handleAsyncUpdate();

		JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ValueSource);
	};

	/** Creates a Value object that uses this valueSource object as its underlying data. */
	explicit Value (ValueSource* valueSource);

	/** Returns the ValueSource that this value is referring to. */
	ValueSource& getValueSource() noexcept          { return *value; }

private:

	friend class ValueSource;
	ReferenceCountedObjectPtr <ValueSource> value;
	ListenerList <Listener> listeners;

	void callListeners();

	// This is disallowed to avoid confusion about whether it should
	// do a by-value or by-reference copy.
	Value& operator= (const Value& other);
};

/** Writes a Value to an OutputStream as a UTF8 string. */
OutputStream& JUCE_CALLTYPE operator<< (OutputStream& stream, const Value& value);

/** This typedef is just for compatibility with old code - newer code should use the Value::Listener class directly. */
typedef Value::Listener ValueListener;

#endif   // __JUCE_VALUE_JUCEHEADER__

/*** End of inlined file: juce_Value.h ***/


#endif
#ifndef __JUCE_VALUETREE_JUCEHEADER__

/*** Start of inlined file: juce_ValueTree.h ***/
#ifndef __JUCE_VALUETREE_JUCEHEADER__
#define __JUCE_VALUETREE_JUCEHEADER__


/*** Start of inlined file: juce_UndoManager.h ***/
#ifndef __JUCE_UNDOMANAGER_JUCEHEADER__
#define __JUCE_UNDOMANAGER_JUCEHEADER__


/*** Start of inlined file: juce_UndoableAction.h ***/
#ifndef __JUCE_UNDOABLEACTION_JUCEHEADER__
#define __JUCE_UNDOABLEACTION_JUCEHEADER__

/**
	Used by the UndoManager class to store an action which can be done
	and undone.

	@see UndoManager
*/
class JUCE_API  UndoableAction
{
protected:
	/** Creates an action. */
	UndoableAction() noexcept   {}

public:
	/** Destructor. */
	virtual ~UndoableAction()   {}

	/** Overridden by a subclass to perform the action.

		This method is called by the UndoManager, and shouldn't be used directly by
		applications.

		Be careful not to make any calls in a perform() method that could call
		recursively back into the UndoManager::perform() method

		@returns    true if the action could be performed.
		@see UndoManager::perform
	*/
	virtual bool perform() = 0;

	/** Overridden by a subclass to undo the action.

		This method is called by the UndoManager, and shouldn't be used directly by
		applications.

		Be careful not to make any calls in an undo() method that could call
		recursively back into the UndoManager::perform() method

		@returns    true if the action could be undone without any errors.
		@see UndoManager::perform
	*/
	virtual bool undo() = 0;

	/** Returns a value to indicate how much memory this object takes up.

		Because the UndoManager keeps a list of UndoableActions, this is used
		to work out how much space each one will take up, so that the UndoManager
		can work out how many to keep.

		The default value returned here is 10 - units are arbitrary and
		don't have to be accurate.

		@see UndoManager::getNumberOfUnitsTakenUpByStoredCommands,
			 UndoManager::setMaxNumberOfStoredUnits
	*/
	virtual int getSizeInUnits()    { return 10; }

	/** Allows multiple actions to be coalesced into a single action object, to reduce storage space.

		If possible, this method should create and return a single action that does the same job as
		this one followed by the supplied action.

		If it's not possible to merge the two actions, the method should return zero.
	*/
	virtual UndoableAction* createCoalescedAction (UndoableAction* nextAction)  { (void) nextAction; return nullptr; }
};

#endif   // __JUCE_UNDOABLEACTION_JUCEHEADER__

/*** End of inlined file: juce_UndoableAction.h ***/

/**
	Manages a list of undo/redo commands.

	An UndoManager object keeps a list of past actions and can use these actions
	to move backwards and forwards through an undo history.

	To use it, create subclasses of UndoableAction which perform all the
	actions you need, then when you need to actually perform an action, create one
	and pass it to the UndoManager's perform() method.

	The manager also uses the concept of 'transactions' to group the actions
	together - all actions performed between calls to beginNewTransaction() are
	grouped together and are all undone/redone as a group.

	The UndoManager is a ChangeBroadcaster, so listeners can register to be told
	when actions are performed or undone.

	@see UndoableAction
*/
class JUCE_API  UndoManager  : public ChangeBroadcaster
{
public:

	/** Creates an UndoManager.

		@param maxNumberOfUnitsToKeep       each UndoableAction object returns a value
											to indicate how much storage it takes up
											(UndoableAction::getSizeInUnits()), so this
											lets you specify the maximum total number of
											units that the undomanager is allowed to
											keep in memory before letting the older actions
											drop off the end of the list.
		@param minimumTransactionsToKeep    this specifies the minimum number of transactions
											that will be kept, even if this involves exceeding
											the amount of space specified in maxNumberOfUnitsToKeep
	*/
	UndoManager (int maxNumberOfUnitsToKeep = 30000,
				 int minimumTransactionsToKeep = 30);

	/** Destructor. */
	~UndoManager();

	/** Deletes all stored actions in the list. */
	void clearUndoHistory();

	/** Returns the current amount of space to use for storing UndoableAction objects.

		@see setMaxNumberOfStoredUnits
	*/
	int getNumberOfUnitsTakenUpByStoredCommands() const;

	/** Sets the amount of space that can be used for storing UndoableAction objects.

		@param maxNumberOfUnitsToKeep       each UndoableAction object returns a value
											to indicate how much storage it takes up
											(UndoableAction::getSizeInUnits()), so this
											lets you specify the maximum total number of
											units that the undomanager is allowed to
											keep in memory before letting the older actions
											drop off the end of the list.
		@param minimumTransactionsToKeep    this specifies the minimum number of transactions
											that will be kept, even if this involves exceeding
											the amount of space specified in maxNumberOfUnitsToKeep
		@see getNumberOfUnitsTakenUpByStoredCommands
	*/
	void setMaxNumberOfStoredUnits (int maxNumberOfUnitsToKeep,
									int minimumTransactionsToKeep);

	/** Performs an action and adds it to the undo history list.

		@param action   the action to perform - this will be deleted by the UndoManager
						when no longer needed
		@param actionName   if this string is non-empty, the current transaction will be
							given this name; if it's empty, the current transaction name will
							be left unchanged. See setCurrentTransactionName()
		@returns true if the command succeeds - see UndoableAction::perform
		@see beginNewTransaction
	*/
	bool perform (UndoableAction* action,
				  const String& actionName = String::empty);

	/** Starts a new group of actions that together will be treated as a single transaction.

		All actions that are passed to the perform() method between calls to this
		method are grouped together and undone/redone together by a single call to
		undo() or redo().

		@param actionName   a description of the transaction that is about to be
							performed
	*/
	void beginNewTransaction (const String& actionName = String::empty);

	/** Changes the name stored for the current transaction.

		Each transaction is given a name when the beginNewTransaction() method is
		called, but this can be used to change that name without starting a new
		transaction.
	*/
	void setCurrentTransactionName (const String& newName);

	/** Returns true if there's at least one action in the list to undo.

		@see getUndoDescription, undo, canRedo
	*/
	bool canUndo() const;

	/** Returns the description of the transaction that would be next to get undone.

		The description returned is the one that was passed into beginNewTransaction
		before the set of actions was performed.

		@see undo
	*/
	String getUndoDescription() const;

	/** Tries to roll-back the last transaction.

		@returns    true if the transaction can be undone, and false if it fails, or
					if there aren't any transactions to undo
	*/
	bool undo();

	/** Tries to roll-back any actions that were added to the current transaction.

		This will perform an undo() only if there are some actions in the undo list
		that were added after the last call to beginNewTransaction().

		This is useful because it lets you call beginNewTransaction(), then
		perform an operation which may or may not actually perform some actions, and
		then call this method to get rid of any actions that might have been done
		without it rolling back the previous transaction if nothing was actually
		done.

		@returns true if any actions were undone.
	*/
	bool undoCurrentTransactionOnly();

	/** Returns a list of the UndoableAction objects that have been performed during the
		transaction that is currently open.

		Effectively, this is the list of actions that would be undone if undoCurrentTransactionOnly()
		were to be called now.

		The first item in the list is the earliest action performed.
	*/
	void getActionsInCurrentTransaction (Array <const UndoableAction*>& actionsFound) const;

	/** Returns the number of UndoableAction objects that have been performed during the
		transaction that is currently open.
		@see getActionsInCurrentTransaction
	*/
	int getNumActionsInCurrentTransaction() const;

	/** Returns true if there's at least one action in the list to redo.

		@see getRedoDescription, redo, canUndo
	*/
	bool canRedo() const;

	/** Returns the description of the transaction that would be next to get redone.

		The description returned is the one that was passed into beginNewTransaction
		before the set of actions was performed.

		@see redo
	*/
	String getRedoDescription() const;

	/** Tries to redo the last transaction that was undone.

		@returns    true if the transaction can be redone, and false if it fails, or
					if there aren't any transactions to redo
	*/
	bool redo();

private:

	OwnedArray <OwnedArray <UndoableAction> > transactions;
	StringArray transactionNames;
	String currentTransactionName;
	int totalUnitsStored, maxNumUnitsToKeep, minimumTransactionsToKeep, nextIndex;
	bool newTransaction, reentrancyCheck;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (UndoManager);
};

#endif   // __JUCE_UNDOMANAGER_JUCEHEADER__

/*** End of inlined file: juce_UndoManager.h ***/

/**
	A powerful tree structure that can be used to hold free-form data, and which can
	handle its own undo and redo behaviour.

	A ValueTree contains a list of named properties as var objects, and also holds
	any number of sub-trees.

	Create ValueTree objects on the stack, and don't be afraid to copy them around, as
	they're simply a lightweight reference to a shared data container. Creating a copy
	of another ValueTree simply creates a new reference to the same underlying object - to
	make a separate, deep copy of a tree you should explicitly call createCopy().

	Each ValueTree has a type name, in much the same way as an XmlElement has a tag name,
	and much of the structure of a ValueTree is similar to an XmlElement tree.
	You can convert a ValueTree to and from an XmlElement, and as long as the XML doesn't
	contain text elements, the conversion works well and makes a good serialisation
	format. They can also be serialised to a binary format, which is very fast and compact.

	All the methods that change data take an optional UndoManager, which will be used
	to track any changes to the object. For this to work, you have to be careful to
	consistently always use the same UndoManager for all operations to any node inside
	the tree.

	A ValueTree can only be a child of one parent at a time, so if you're moving one from
	one tree to another, be careful to always remove it first, before adding it. This
	could also mess up your undo/redo chain, so be wary! In a debug build you should hit
	assertions if you try to do anything dangerous, but there are still plenty of ways it
	could go wrong.

	Listeners can be added to a ValueTree to be told when properies change and when
	nodes are added or removed.

	@see var, XmlElement
*/
class JUCE_API  ValueTree
{
public:

	/** Creates an empty, invalid ValueTree.

		A ValueTree that is created with this constructor can't actually be used for anything,
		it's just a default 'null' ValueTree that can be returned to indicate some sort of failure.
		To create a real one, use the constructor that takes a string.

		@see ValueTree::invalid
	*/
	ValueTree() noexcept;

	/** Creates an empty ValueTree with the given type name.
		Like an XmlElement, each ValueTree node has a type, which you can access with
		getType() and hasType().
	*/
	explicit ValueTree (const Identifier& type);

	/** Creates a reference to another ValueTree. */
	ValueTree (const ValueTree& other);

	/** Makes this object reference another node. */
	ValueTree& operator= (const ValueTree& other);

   #if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
	ValueTree (ValueTree&& other) noexcept;
	ValueTree& operator= (ValueTree&& other) noexcept;
   #endif

	/** Destructor. */
	~ValueTree();

	/** Returns true if both this and the other tree node refer to the same underlying structure.
		Note that this isn't a value comparison - two independently-created trees which
		contain identical data are not considered equal.
	*/
	bool operator== (const ValueTree& other) const noexcept;

	/** Returns true if this and the other node refer to different underlying structures.
		Note that this isn't a value comparison - two independently-created trees which
		contain identical data are not considered equal.
	*/
	bool operator!= (const ValueTree& other) const noexcept;

	/** Performs a deep comparison between the properties and children of two trees.
		If all the properties and children of the two trees are the same (recursively), this
		returns true.
		The normal operator==() only checks whether two trees refer to the same shared data
		structure, so use this method if you need to do a proper value comparison.
	*/
	bool isEquivalentTo (const ValueTree& other) const;

	/** Returns true if this node refers to some valid data.
		It's hard to create an invalid node, but you might get one returned, e.g. by an out-of-range
		call to getChild().
	*/
	bool isValid() const                            { return object != nullptr; }

	/** Returns a deep copy of this tree and all its sub-nodes. */
	ValueTree createCopy() const;

	/** Returns the type of this node.
		The type is specified when the ValueTree is created.
		@see hasType
	*/
	Identifier getType() const;

	/** Returns true if the node has this type.
		The comparison is case-sensitive.
	*/
	bool hasType (const Identifier& typeName) const;

	/** Returns the value of a named property.
		If no such property has been set, this will return a void variant.
		You can also use operator[] to get a property.
		@see var, setProperty, hasProperty
	*/
	const var& getProperty (const Identifier& name) const;

	/** Returns the value of a named property, or a user-specified default if the property doesn't exist.
		If no such property has been set, this will return the value of defaultReturnValue.
		You can also use operator[] and getProperty to get a property.
		@see var, getProperty, setProperty, hasProperty
	*/
	var getProperty (const Identifier& name, const var& defaultReturnValue) const;

	/** Returns the value of a named property.
		If no such property has been set, this will return a void variant. This is the same as
		calling getProperty().
		@see getProperty
	*/
	const var& operator[] (const Identifier& name) const;

	/** Changes a named property of the node.
		The name identifier must not be an empty string.
		If the undoManager parameter is non-null, its UndoManager::perform() method will be used,
		so that this change can be undone.
		@see var, getProperty, removeProperty
		@returns a reference to the value tree, so that you can daisy-chain calls to this method.
	*/
	ValueTree& setProperty (const Identifier& name, const var& newValue, UndoManager* undoManager);

	/** Returns true if the node contains a named property. */
	bool hasProperty (const Identifier& name) const;

	/** Removes a property from the node.
		If the undoManager parameter is non-null, its UndoManager::perform() method will be used,
		so that this change can be undone.
	*/
	void removeProperty (const Identifier& name, UndoManager* undoManager);

	/** Removes all properties from the node.
		If the undoManager parameter is non-null, its UndoManager::perform() method will be used,
		so that this change can be undone.
	*/
	void removeAllProperties (UndoManager* undoManager);

	/** Returns the total number of properties that the node contains.
		@see getProperty.
	*/
	int getNumProperties() const;

	/** Returns the identifier of the property with a given index.
		@see getNumProperties
	*/
	Identifier getPropertyName (int index) const;

	/** Returns a Value object that can be used to control and respond to one of the tree's properties.

		The Value object will maintain a reference to this tree, and will use the undo manager when
		it needs to change the value. Attaching a Value::Listener to the value object will provide
		callbacks whenever the property changes.
	*/
	Value getPropertyAsValue (const Identifier& name, UndoManager* undoManager);

	/** Returns the number of child nodes belonging to this one.
		@see getChild
	*/
	int getNumChildren() const;

	/** Returns one of this node's child nodes.
		If the index is out of range, it'll return an invalid node. (See isValid() to find out
		whether a node is valid).
	*/
	ValueTree getChild (int index) const;

	/** Returns the first child node with the speficied type name.
		If no such node is found, it'll return an invalid node. (See isValid() to find out
		whether a node is valid).
		@see getOrCreateChildWithName
	*/
	ValueTree getChildWithName (const Identifier& type) const;

	/** Returns the first child node with the speficied type name, creating and adding
		a child with this name if there wasn't already one there.

		The only time this will return an invalid object is when the object that you're calling
		the method on is itself invalid.
		@see getChildWithName
	*/
	ValueTree getOrCreateChildWithName (const Identifier& type, UndoManager* undoManager);

	/** Looks for the first child node that has the speficied property value.

		This will scan the child nodes in order, until it finds one that has property that matches
		the specified value.

		If no such node is found, it'll return an invalid node. (See isValid() to find out
		whether a node is valid).
	*/
	ValueTree getChildWithProperty (const Identifier& propertyName, const var& propertyValue) const;

	/** Adds a child to this node.

		Make sure that the child is removed from any former parent node before calling this, or
		you'll hit an assertion.

		If the index is < 0 or greater than the current number of child nodes, the new node will
		be added at the end of the list.

		If the undoManager parameter is non-null, its UndoManager::perform() method will be used,
		so that this change can be undone.
	*/
	void addChild (const ValueTree& child, int index, UndoManager* undoManager);

	/** Removes the specified child from this node's child-list.
		If the undoManager parameter is non-null, its UndoManager::perform() method will be used,
		so that this change can be undone.
	*/
	void removeChild (const ValueTree& child, UndoManager* undoManager);

	/** Removes a child from this node's child-list.
		If the undoManager parameter is non-null, its UndoManager::perform() method will be used,
		so that this change can be undone.
	*/
	void removeChild (int childIndex, UndoManager* undoManager);

	/** Removes all child-nodes from this node.
		If the undoManager parameter is non-null, its UndoManager::perform() method will be used,
		so that this change can be undone.
	*/
	void removeAllChildren (UndoManager* undoManager);

	/** Moves one of the children to a different index.

		This will move the child to a specified index, shuffling along any intervening
		items as required. So for example, if you have a list of { 0, 1, 2, 3, 4, 5 }, then
		calling move (2, 4) would result in { 0, 1, 3, 4, 2, 5 }.

		@param currentIndex     the index of the item to be moved. If this isn't a
								valid index, then nothing will be done
		@param newIndex         the index at which you'd like this item to end up. If this
								is less than zero, the value will be moved to the end
								of the list
		@param undoManager      the optional UndoManager to use to store this transaction
	*/
	void moveChild (int currentIndex, int newIndex, UndoManager* undoManager);

	/** Returns true if this node is anywhere below the specified parent node.
		This returns true if the node is a child-of-a-child, as well as a direct child.
	*/
	bool isAChildOf (const ValueTree& possibleParent) const;

	/** Returns the index of a child item in this parent.
		If the child isn't found, this returns -1.
	*/
	int indexOf (const ValueTree& child) const;

	/** Returns the parent node that contains this one.
		If the node has no parent, this will return an invalid node. (See isValid() to find out
		whether a node is valid).
	*/
	ValueTree getParent() const;

	/** Returns one of this node's siblings in its parent's child list.

		The delta specifies how far to move through the list, so a value of 1 would return the node
		that follows this one, -1 would return the node before it, 0 will return this node itself, etc.
		If the requested position is beyond the range of available nodes, this will return ValueTree::invalid.
	*/
	ValueTree getSibling (int delta) const;

	/** Creates an XmlElement that holds a complete image of this node and all its children.

		If this node is invalid, this may return 0. Otherwise, the XML that is produced can
		be used to recreate a similar node by calling fromXml()
		@see fromXml
	*/
	XmlElement* createXml() const;

	/** Tries to recreate a node from its XML representation.

		This isn't designed to cope with random XML data - for a sensible result, it should only
		be fed XML that was created by the createXml() method.
	*/
	static ValueTree fromXml (const XmlElement& xml);

	/** Stores this tree (and all its children) in a binary format.

		Once written, the data can be read back with readFromStream().

		It's much faster to load/save your tree in binary form than as XML, but
		obviously isn't human-readable.
	*/
	void writeToStream (OutputStream& output);

	/** Reloads a tree from a stream that was written with writeToStream(). */
	static ValueTree readFromStream (InputStream& input);

	/** Reloads a tree from a data block that was written with writeToStream(). */
	static ValueTree readFromData (const void* data, size_t numBytes);

	/** Reloads a tree from a data block that was written with writeToStream() and
		then zipped using GZIPCompressorOutputStream.
	*/
	static ValueTree readFromGZIPData (const void* data, size_t numBytes);

	/** Listener class for events that happen to a ValueTree.

		To get events from a ValueTree, make your class implement this interface, and use
		ValueTree::addListener() and ValueTree::removeListener() to register it.
	*/
	class JUCE_API  Listener
	{
	public:
		/** Destructor. */
		virtual ~Listener() {}

		/** This method is called when a property of this node (or of one of its sub-nodes) has
			changed.

			The tree parameter indicates which tree has had its property changed, and the property
			parameter indicates the property.

			Note that when you register a listener to a tree, it will receive this callback for
			property changes in that tree, and also for any of its children, (recursively, at any depth).
			If your tree has sub-trees but you only want to know about changes to the top level tree,
			simply check the tree parameter in this callback to make sure it's the tree you're interested in.
		*/
		virtual void valueTreePropertyChanged (ValueTree& treeWhosePropertyHasChanged,
											   const Identifier& property) = 0;

		/** This method is called when a child sub-tree is added.

			Note that when you register a listener to a tree, it will receive this callback for
			child changes in both that tree and any of its children, (recursively, at any depth).
			If your tree has sub-trees but you only want to know about changes to the top level tree,
			just check the parentTree parameter to make sure it's the one that you're interested in.
		*/
		virtual void valueTreeChildAdded (ValueTree& parentTree,
										  ValueTree& childWhichHasBeenAdded) = 0;

		/** This method is called when a child sub-tree is removed.

			Note that when you register a listener to a tree, it will receive this callback for
			child changes in both that tree and any of its children, (recursively, at any depth).
			If your tree has sub-trees but you only want to know about changes to the top level tree,
			just check the parentTree parameter to make sure it's the one that you're interested in.
		*/
		virtual void valueTreeChildRemoved (ValueTree& parentTree,
											ValueTree& childWhichHasBeenRemoved) = 0;

		/** This method is called when a tree's children have been re-shuffled.

			Note that when you register a listener to a tree, it will receive this callback for
			child changes in both that tree and any of its children, (recursively, at any depth).
			If your tree has sub-trees but you only want to know about changes to the top level tree,
			just check the parameter to make sure it's the tree that you're interested in.
		*/
		virtual void valueTreeChildOrderChanged (ValueTree& parentTreeWhoseChildrenHaveMoved) = 0;

		/** This method is called when a tree has been added or removed from a parent node.

			This callback happens when the tree to which the listener was registered is added or
			removed from a parent. Unlike the other callbacks, it applies only to the tree to which
			the listener is registered, and not to any of its children.
		*/
		virtual void valueTreeParentChanged (ValueTree& treeWhoseParentHasChanged) = 0;
	};

	/** Adds a listener to receive callbacks when this node is changed.

		The listener is added to this specific ValueTree object, and not to the shared
		object that it refers to. When this object is deleted, all the listeners will
		be lost, even if other references to the same ValueTree still exist. And if you
		use the operator= to make this refer to a different ValueTree, any listeners will
		begin listening to changes to the new tree instead of the old one.

		When you're adding a listener, make sure that you add it to a ValueTree instance that
		will last for as long as you need the listener. In general, you'd never want to add a
		listener to a local stack-based ValueTree, and would usually add one to a member variable.

		@see removeListener
	*/
	void addListener (Listener* listener);

	/** Removes a listener that was previously added with addListener(). */
	void removeListener (Listener* listener);

	/** Causes a property-change callback to be triggered for the specified property,
		calling any listeners that are registered.
	*/
	void sendPropertyChangeMessage (const Identifier& property);

	/** This method uses a comparator object to sort the tree's children into order.

		The object provided must have a method of the form:
		@code
		int compareElements (const ValueTree& first, const ValueTree& second);
		@endcode

		..and this method must return:
		  - a value of < 0 if the first comes before the second
		  - a value of 0 if the two objects are equivalent
		  - a value of > 0 if the second comes before the first

		To improve performance, the compareElements() method can be declared as static or const.

		@param comparator   the comparator to use for comparing elements.
		@param undoManager  optional UndoManager for storing the changes
		@param retainOrderOfEquivalentItems     if this is true, then items which the comparator says are
							equivalent will be kept in the order in which they currently appear in the array.
							This is slower to perform, but may be important in some cases. If it's false, a
							faster algorithm is used, but equivalent elements may be rearranged.
	*/
	template <typename ElementComparator>
	void sort (ElementComparator& comparator, UndoManager* undoManager, bool retainOrderOfEquivalentItems)
	{
		if (object != nullptr)
		{
			OwnedArray<ValueTree> sortedList;
			createListOfChildren (sortedList);
			ComparatorAdapter <ElementComparator> adapter (comparator);
			sortedList.sort (adapter, retainOrderOfEquivalentItems);
			reorderChildren (sortedList, undoManager);
		}
	}

	/** An invalid ValueTree that can be used if you need to return one as an error condition, etc.
		This invalid object is equivalent to ValueTree created with its default constructor.
	*/
	static const ValueTree invalid;

private:

	class SharedObject;
	friend class SharedObject;

	ReferenceCountedObjectPtr<SharedObject> object;
	ListenerList<Listener> listeners;

	template <typename ElementComparator>
	struct ComparatorAdapter
	{
		ComparatorAdapter (ElementComparator& comparator_) noexcept : comparator (comparator_) {}

		int compareElements (const ValueTree* const first, const ValueTree* const second)
		{
			return comparator.compareElements (*first, *second);
		}

	private:
		ElementComparator& comparator;
		JUCE_DECLARE_NON_COPYABLE (ComparatorAdapter);
	};

	void createListOfChildren (OwnedArray<ValueTree>&) const;
	void reorderChildren (const OwnedArray<ValueTree>&, UndoManager*);

	explicit ValueTree (SharedObject*);
};

#endif   // __JUCE_VALUETREE_JUCEHEADER__

/*** End of inlined file: juce_ValueTree.h ***/


#endif
#ifndef __JUCE_UNDOABLEACTION_JUCEHEADER__

#endif
#ifndef __JUCE_UNDOMANAGER_JUCEHEADER__

#endif
#ifndef __JUCE_APPLICATIONPROPERTIES_JUCEHEADER__

/*** Start of inlined file: juce_ApplicationProperties.h ***/
#ifndef __JUCE_APPLICATIONPROPERTIES_JUCEHEADER__
#define __JUCE_APPLICATIONPROPERTIES_JUCEHEADER__


/*** Start of inlined file: juce_PropertiesFile.h ***/
#ifndef __JUCE_PROPERTIESFILE_JUCEHEADER__
#define __JUCE_PROPERTIESFILE_JUCEHEADER__

/** Wrapper on a file that stores a list of key/value data pairs.

	Useful for storing application settings, etc. See the PropertySet class for
	the interfaces that read and write values.

	Not designed for very large amounts of data, as it keeps all the values in
	memory and writes them out to disk lazily when they are changed.

	Because this class derives from ChangeBroadcaster, ChangeListeners can be registered
	with it, and these will be signalled when a value changes.

	@see PropertySet
*/
class JUCE_API  PropertiesFile  : public PropertySet,
								  public ChangeBroadcaster,
								  private Timer
{
public:

	enum StorageFormat
	{
		storeAsBinary,
		storeAsCompressedBinary,
		storeAsXML
	};

	struct JUCE_API  Options
	{
		/** Creates an empty Options structure.
			You'll need to fill-in the data memebers appropriately before using this structure.
		*/
		Options();

		/** The name of your application - this is used to help generate the path and filename
			at which the properties file will be stored. */
		String applicationName;

		/** The suffix to use for your properties file.
			It doesn't really matter what this is - you may want to use ".settings" or
			".properties" or something.
		*/
		String filenameSuffix;

		/** The name of a subfolder in which you'd like your properties file to live.
			See the getDefaultFile() method for more details about how this is used.
		*/
		String folderName;

		/** If you're using properties files on a Mac, you must set this value - failure to
			do so will cause a runtime assertion.

			The PropertiesFile class always used to put its settings files in "Library/Preferences", but Apple
			have changed their advice, and now stipulate that settings should go in "Library/Application Support".

			Because older apps would be broken by a silent change in this class's behaviour, you must now
			explicitly set the osxLibrarySubFolder value to indicate which path you want to use.

			In newer apps, you should always set this to "Application Support".

			If your app needs to load settings files that were created by older versions of juce and
			you want to maintain backwards-compatibility, then you can set this to "Preferences".
			But.. for better Apple-compliance, the recommended approach would be to write some code that
			finds your old settings files in ~/Library/Preferences, moves them to ~/Library/Application Support,
			and then uses the new path.
		*/
		String osxLibrarySubFolder;

		/** If true, the file will be created in a location that's shared between users.
			The default constructor initialises this value to false.
		*/
		bool commonToAllUsers;

		/** If true, this means that property names are matched in a case-insensitive manner.
			See the PropertySet constructor for more info.
			The default constructor initialises this value to false.
		*/
		bool ignoreCaseOfKeyNames;

		/** If this is zero or greater, then after a value is changed, the object will wait
			for this amount of time and then save the file. If this zero, the file will be
			written to disk immediately on being changed (which might be slow, as it'll re-write
			synchronously each time a value-change method is called). If it is less than zero,
			the file won't be saved until save() or saveIfNeeded() are explicitly called.
			The default constructor sets this to a reasonable value of a few seconds, so you
			only need to change it if you need a special case.
		*/
		int millisecondsBeforeSaving;

		/** Specifies whether the file should be written as XML, binary, etc.
			The default constructor sets this to storeAsXML, so you only need to set it explicitly
			if you want to use a different format.
		*/
		StorageFormat storageFormat;

		/** An optional InterprocessLock object that will be used to prevent multiple threads or
			processes from writing to the file at the same time. The PropertiesFile will keep a
			pointer to this object but will not take ownership of it - the caller is responsible for
			making sure that the lock doesn't get deleted before the PropertiesFile has been deleted.
			The default constructor initialises this value to nullptr, so you don't need to touch it
			unless you want to use a lock.
		*/
		InterProcessLock* processLock;

		/** This can be called to suggest a file that should be used, based on the values
			in this structure.

			So on a Mac, this will return a file called:
			~/Library/[osxLibrarySubFolder]/[folderName]/[applicationName].[filenameSuffix]

			On Windows it'll return something like:
			C:\\Documents and Settings\\username\\Application Data\\[folderName]\\[applicationName].[filenameSuffix]

			On Linux it'll return
			~/.[folderName]/[applicationName].[filenameSuffix]

			If the folderName variable is empty, it'll use the app name for this (or omit the
			folder name on the Mac).

			The paths will also vary depending on whether commonToAllUsers is true.
		*/
		File getDefaultFile() const;
	};

	/** Creates a PropertiesFile object.
		The file used will be chosen by calling PropertiesFile::Options::getDefaultFile()
		for the options provided. To set the file explicitly, use the other constructor.
	*/
	explicit PropertiesFile (const Options& options);

	/** Creates a PropertiesFile object.
		Unlike the other constructor, this one allows you to explicitly set the file that you
		want to be used, rather than using the default one.
	*/
	PropertiesFile (const File& file,
					const Options& options);

	/** Destructor.
		When deleted, the file will first call saveIfNeeded() to flush any changes to disk.
	*/
	~PropertiesFile();

	/** Returns true if this file was created from a valid (or non-existent) file.
		If the file failed to load correctly because it was corrupt or had insufficient
		access, this will be false.
	*/
	bool isValidFile() const noexcept               { return loadedOk; }

	/** This will flush all the values to disk if they've changed since the last
		time they were saved.

		Returns false if it fails to write to the file for some reason (maybe because
		it's read-only or the directory doesn't exist or something).

		@see save
	*/
	bool saveIfNeeded();

	/** This will force a write-to-disk of the current values, regardless of whether
		anything has changed since the last save.

		Returns false if it fails to write to the file for some reason (maybe because
		it's read-only or the directory doesn't exist or something).

		@see saveIfNeeded
	*/
	bool save();

	/** Returns true if the properties have been altered since the last time they were saved.
		The file is flagged as needing to be saved when you change a value, but you can
		explicitly set this flag with setNeedsToBeSaved().
	*/
	bool needsToBeSaved() const;

	/** Explicitly sets the flag to indicate whether the file needs saving or not.
		@see needsToBeSaved
	*/
	void setNeedsToBeSaved (bool needsToBeSaved);

	/** Returns the file that's being used. */
	File getFile() const                              { return file; }

protected:
	/** @internal */
	virtual void propertyChanged();

private:

	File file;
	Options options;
	bool loadedOk, needsWriting;

	typedef const ScopedPointer<InterProcessLock::ScopedLockType> ProcessScopedLock;
	InterProcessLock::ScopedLockType* createProcessLock() const;

	void timerCallback();
	void initialise();

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (PropertiesFile);
};

#endif   // __JUCE_PROPERTIESFILE_JUCEHEADER__

/*** End of inlined file: juce_PropertiesFile.h ***/

/**
	Manages a collection of properties.

	This is a slightly higher-level wrapper for managing PropertiesFile objects.

	It holds two different PropertiesFile objects internally, one for user-specific
	settings (stored in your user directory), and one for settings that are common to
	all users (stored in a folder accessible to all users).

	The class manages the creation of these files on-demand, allowing access via the
	getUserSettings() and getCommonSettings() methods. It also has a few handy
	methods like testWriteAccess() to check that the files can be saved.

	After creating an instance of an ApplicationProperties object, you should first
	of all call setStorageParameters() to tell it the parameters to use to create
	its files.

	@see PropertiesFile
*/
class JUCE_API  ApplicationProperties
{
public:

	/**
		Creates an ApplicationProperties object.

		Before using it, you must call setStorageParameters() to give it the info
		it needs to create the property files.
	*/
	ApplicationProperties();

	/** Destructor. */
	~ApplicationProperties();

	/** Gives the object the information it needs to create the appropriate properties files.
		See the PropertiesFile::Options class for details about what options you need to set.
	*/
	void setStorageParameters (const PropertiesFile::Options& options);

	/** Returns the user settings file.

		The first time this is called, it will create and load the properties file.

		Note that when you search the user PropertiesFile for a value that it doesn't contain,
		the common settings are used as a second-chance place to look. This is done via the
		PropertySet::setFallbackPropertySet() method - by default the common settings are set
		to the fallback for the user settings.

		@see getCommonSettings
	*/
	PropertiesFile* getUserSettings();

	/** Returns the common settings file.

		The first time this is called, it will create and load the properties file.

		@param returnUserPropsIfReadOnly  if this is true, and the common properties file is
							read-only (e.g. because the user doesn't have permission to write
							to shared files), then this will return the user settings instead,
							(like getUserSettings() would do). This is handy if you'd like to
							write a value to the common settings, but if that's no possible,
							then you'd rather write to the user settings than none at all.
							If returnUserPropsIfReadOnly is false, this method will always return
							the common settings, even if any changes to them can't be saved.
		@see getUserSettings
	*/
	PropertiesFile* getCommonSettings (bool returnUserPropsIfReadOnly);

	/** Saves both files if they need to be saved.

		@see PropertiesFile::saveIfNeeded
	*/
	bool saveIfNeeded();

	/** Flushes and closes both files if they are open.

		This flushes any pending changes to disk with PropertiesFile::saveIfNeeded()
		and closes both files. They will then be re-opened the next time getUserSettings()
		or getCommonSettings() is called.
	*/
	void closeFiles();

private:

	PropertiesFile::Options options;
	ScopedPointer <PropertiesFile> userProps, commonProps;
	int commonSettingsAreReadOnly;

	void openFiles();

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ApplicationProperties);
};

#endif   // __JUCE_APPLICATIONPROPERTIES_JUCEHEADER__

/*** End of inlined file: juce_ApplicationProperties.h ***/


#endif
#ifndef __JUCE_PROPERTIESFILE_JUCEHEADER__

#endif
// END_AUTOINCLUDE

}

#endif   // __JUCE_DATA_STRUCTURES_JUCEHEADER__

/*** End of inlined file: juce_data_structures.h ***/

/** Config: JUCE_ENABLE_REPAINT_DEBUGGING
	If this option is turned on, each area of the screen that gets repainted will
	flash in a random colour, so that you can see exactly which bits of your
	components are being drawn.
*/
#ifndef JUCE_ENABLE_REPAINT_DEBUGGING
 #define JUCE_ENABLE_REPAINT_DEBUGGING 0
#endif

/** JUCE_USE_XINERAMA: Enables Xinerama multi-monitor support (Linux only).
	Unless you specifically want to disable this, it's best to leave this option turned on.
*/
#ifndef JUCE_USE_XINERAMA
 #define JUCE_USE_XINERAMA 1
#endif

/** Config: JUCE_USE_XSHM
	Enables X shared memory for faster rendering on Linux. This is best left turned on
	unless you have a good reason to disable it.
*/
#ifndef JUCE_USE_XSHM
 #define JUCE_USE_XSHM 1
#endif

/** Config: JUCE_USE_XRENDER
	Enables XRender to allow semi-transparent windowing on Linux.
*/
#ifndef JUCE_USE_XRENDER
 #define JUCE_USE_XRENDER 0
#endif

/** Config: JUCE_USE_XCURSOR
	Uses XCursor to allow ARGB cursor on Linux. This is best left turned on unless you have
	a good reason to disable it.
*/
#ifndef JUCE_USE_XCURSOR
 #define JUCE_USE_XCURSOR 1
#endif

namespace juce
{

// START_AUTOINCLUDE components, mouse, keyboard, buttons, drawables,
// filebrowser, layout, lookandfeel, menus, positioning, properties,
// widgets, windows, commands, application, misc
#ifndef __JUCE_CACHEDCOMPONENTIMAGE_JUCEHEADER__

/*** Start of inlined file: juce_CachedComponentImage.h ***/
#ifndef __JUCE_CACHEDCOMPONENTIMAGE_JUCEHEADER__
#define __JUCE_CACHEDCOMPONENTIMAGE_JUCEHEADER__

class Component;

/**
	Base class used internally for structures that can store cached images of
	component state.

	Most people are unlikely to ever need to know about this class - it's really
	only for power-users!

	@see Component::setCachedComponentImage
*/
class JUCE_API  CachedComponentImage
{
public:
	CachedComponentImage() noexcept {}
	virtual ~CachedComponentImage() {}

	/** Called as part of the parent component's paint method, this must draw
		the given component into the target graphics context, using the cached
		version where possible.
	*/
	virtual void paint (Graphics&) = 0;

	/** Invalidates all cached image data. */
	virtual void invalidateAll() = 0;

	/** Invalidates a section of the cached image data. */
	virtual void invalidate (const Rectangle<int>& area) = 0;

	/** Called to indicate that the component is no longer active, so
		any cached data should be released if possible.
	*/
	virtual void releaseResources() = 0;
};

#endif   // __JUCE_CACHEDCOMPONENTIMAGE_JUCEHEADER__

/*** End of inlined file: juce_CachedComponentImage.h ***/


#endif
#ifndef __JUCE_COMPONENT_JUCEHEADER__

/*** Start of inlined file: juce_Component.h ***/
#ifndef __JUCE_COMPONENT_JUCEHEADER__
#define __JUCE_COMPONENT_JUCEHEADER__


/*** Start of inlined file: juce_MouseCursor.h ***/
#ifndef __JUCE_MOUSECURSOR_JUCEHEADER__
#define __JUCE_MOUSECURSOR_JUCEHEADER__

class Image;
class ComponentPeer;
class Component;

/**
	Represents a mouse cursor image.

	This object can either be used to represent one of the standard mouse
	cursor shapes, or a custom one generated from an image.
*/
class JUCE_API  MouseCursor
{
public:

	/** The set of available standard mouse cursors. */
	enum StandardCursorType
	{
		NoCursor = 0,                   /**< An invisible cursor. */
		NormalCursor,                   /**< The stardard arrow cursor. */

		WaitCursor,                     /**< The normal hourglass or spinning-beachball 'busy' cursor. */
		IBeamCursor,                    /**< A vertical I-beam for positioning within text. */
		CrosshairCursor,                /**< A pair of crosshairs. */
		CopyingCursor,                  /**< The normal arrow cursor, but with a "+" on it to indicate
											 that you're dragging a copy of something. */

		PointingHandCursor,             /**< A hand with a pointing finger, for clicking on web-links. */
		DraggingHandCursor,             /**< An open flat hand for dragging heavy objects around. */

		LeftRightResizeCursor,          /**< An arrow pointing left and right. */
		UpDownResizeCursor,             /**< an arrow pointing up and down. */
		UpDownLeftRightResizeCursor,    /**< An arrow pointing up, down, left and right. */

		TopEdgeResizeCursor,            /**< A platform-specific cursor for resizing the top-edge of a window. */
		BottomEdgeResizeCursor,         /**< A platform-specific cursor for resizing the bottom-edge of a window. */
		LeftEdgeResizeCursor,           /**< A platform-specific cursor for resizing the left-edge of a window. */
		RightEdgeResizeCursor,          /**< A platform-specific cursor for resizing the right-edge of a window. */
		TopLeftCornerResizeCursor,      /**< A platform-specific cursor for resizing the top-left-corner of a window. */
		TopRightCornerResizeCursor,     /**< A platform-specific cursor for resizing the top-right-corner of a window. */
		BottomLeftCornerResizeCursor,   /**< A platform-specific cursor for resizing the bottom-left-corner of a window. */
		BottomRightCornerResizeCursor   /**< A platform-specific cursor for resizing the bottom-right-corner of a window. */
	};

	/** Creates the standard arrow cursor. */
	MouseCursor();

	/** Creates one of the standard mouse cursor */
	MouseCursor (StandardCursorType type);

	/** Creates a custom cursor from an image.

		@param image    the image to use for the cursor - if this is bigger than the
						system can manage, it might get scaled down first, and might
						also have to be turned to black-and-white if it can't do colour
						cursors.
		@param hotSpotX the x position of the cursor's hotspot within the image
		@param hotSpotY the y position of the cursor's hotspot within the image
	*/
	MouseCursor (const Image& image, int hotSpotX, int hotSpotY);

	/** Creates a copy of another cursor object. */
	MouseCursor (const MouseCursor& other);

	/** Copies this cursor from another object. */
	MouseCursor& operator= (const MouseCursor& other);

	/** Destructor. */
	~MouseCursor();

   #if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
	MouseCursor (MouseCursor&& other) noexcept;
	MouseCursor& operator= (MouseCursor&& other) noexcept;
   #endif

	/** Checks whether two mouse cursors are the same.

		For custom cursors, two cursors created from the same image won't be
		recognised as the same, only MouseCursor objects that have been
		copied from the same object.
	*/
	bool operator== (const MouseCursor& other) const noexcept;

	/** Checks whether two mouse cursors are the same.

		For custom cursors, two cursors created from the same image won't be
		recognised as the same, only MouseCursor objects that have been
		copied from the same object.
	*/
	bool operator!= (const MouseCursor& other) const noexcept;

	/** Makes the system show its default 'busy' cursor.

		This will turn the system cursor to an hourglass or spinning beachball
		until the next time the mouse is moved, or hideWaitCursor() is called.

		This is handy if the message loop is about to block for a couple of
		seconds while busy and you want to give the user feedback about this.

		@see MessageManager::setTimeBeforeShowingWaitCursor
	*/
	static void showWaitCursor();

	/** If showWaitCursor has been called, this will return the mouse to its
		normal state.

		This will look at what component is under the mouse, and update the
		cursor to be the correct one for that component.

		@see showWaitCursor
	*/
	static void hideWaitCursor();

private:

	class SharedCursorHandle;
	friend class SharedCursorHandle;
	SharedCursorHandle* cursorHandle;

	friend class MouseInputSourceInternal;
	void showInWindow (ComponentPeer* window) const;
	void showInAllWindows() const;
	void* getHandle() const noexcept;

	static void* createMouseCursorFromImage (const Image& image, int hotspotX, int hotspotY);
	static void* createStandardMouseCursor (MouseCursor::StandardCursorType type);
	static void deleteMouseCursor (void* cursorHandle, bool isStandard);

	JUCE_LEAK_DETECTOR (MouseCursor);
};

#endif   // __JUCE_MOUSECURSOR_JUCEHEADER__

/*** End of inlined file: juce_MouseCursor.h ***/


/*** Start of inlined file: juce_MouseListener.h ***/
#ifndef __JUCE_MOUSELISTENER_JUCEHEADER__
#define __JUCE_MOUSELISTENER_JUCEHEADER__

class MouseEvent;

/**
	A MouseListener can be registered with a component to receive callbacks
	about mouse events that happen to that component.

	@see Component::addMouseListener, Component::removeMouseListener
*/
class JUCE_API  MouseListener
{
public:
	/** Destructor. */
	virtual ~MouseListener()  {}

	/** Called when the mouse moves inside a component.

		If the mouse button isn't pressed and the mouse moves over a component,
		this will be called to let the component react to this.

		A component will always get a mouseEnter callback before a mouseMove.

		@param e    details about the position and status of the mouse event, including
					the source component in which it occurred
		@see mouseEnter, mouseExit, mouseDrag, contains
	*/
	virtual void mouseMove          (const MouseEvent& e);

	/** Called when the mouse first enters a component.

		If the mouse button isn't pressed and the mouse moves into a component,
		this will be called to let the component react to this.

		When the mouse button is pressed and held down while being moved in
		or out of a component, no mouseEnter or mouseExit callbacks are made - only
		mouseDrag messages are sent to the component that the mouse was originally
		clicked on, until the button is released.

		@param e    details about the position and status of the mouse event, including
					the source component in which it occurred
		@see mouseExit, mouseDrag, mouseMove, contains
	*/
	virtual void mouseEnter         (const MouseEvent& e);

	/** Called when the mouse moves out of a component.

		This will be called when the mouse moves off the edge of this
		component.

		If the mouse button was pressed, and it was then dragged off the
		edge of the component and released, then this callback will happen
		when the button is released, after the mouseUp callback.

		@param e    details about the position and status of the mouse event, including
					the source component in which it occurred
		@see mouseEnter, mouseDrag, mouseMove, contains
	*/
	virtual void mouseExit          (const MouseEvent& e);

	/** Called when a mouse button is pressed.

		The MouseEvent object passed in contains lots of methods for finding out
		which button was pressed, as well as which modifier keys (e.g. shift, ctrl)
		were held down at the time.

		Once a button is held down, the mouseDrag method will be called when the
		mouse moves, until the button is released.

		@param e    details about the position and status of the mouse event, including
					the source component in which it occurred
		@see mouseUp, mouseDrag, mouseDoubleClick, contains
	*/
	virtual void mouseDown          (const MouseEvent& e);

	/** Called when the mouse is moved while a button is held down.

		When a mouse button is pressed inside a component, that component
		receives mouseDrag callbacks each time the mouse moves, even if the
		mouse strays outside the component's bounds.

		@param e    details about the position and status of the mouse event, including
					the source component in which it occurred
		@see mouseDown, mouseUp, mouseMove, contains, setDragRepeatInterval
	*/
	virtual void mouseDrag          (const MouseEvent& e);

	/** Called when a mouse button is released.

		A mouseUp callback is sent to the component in which a button was pressed
		even if the mouse is actually over a different component when the
		button is released.

		The MouseEvent object passed in contains lots of methods for finding out
		which buttons were down just before they were released.

		@param e    details about the position and status of the mouse event, including
					the source component in which it occurred
		@see mouseDown, mouseDrag, mouseDoubleClick, contains
	*/
	virtual void mouseUp            (const MouseEvent& e);

	/** Called when a mouse button has been double-clicked on a component.

		The MouseEvent object passed in contains lots of methods for finding out
		which button was pressed, as well as which modifier keys (e.g. shift, ctrl)
		were held down at the time.

		@param e    details about the position and status of the mouse event, including
					the source component in which it occurred
		@see mouseDown, mouseUp
	*/
	virtual void mouseDoubleClick   (const MouseEvent& e);

	/** Called when the mouse-wheel is moved.

		This callback is sent to the component that the mouse is over when the
		wheel is moved.

		If not overridden, the component will forward this message to its parent, so
		that parent components can collect mouse-wheel messages that happen to
		child components which aren't interested in them.

		@param e    details about the position and status of the mouse event, including
					the source component in which it occurred
		@param wheelIncrementX   the speed and direction of the horizontal scroll-wheel - a positive
								 value means the wheel has been pushed to the right, negative means it
								 was pushed to the left
		@param wheelIncrementY   the speed and direction of the vertical scroll-wheel - a positive
								 value means the wheel has been pushed upwards, negative means it
								 was pushed downwards
	*/
	virtual void mouseWheelMove     (const MouseEvent& e,
									 float wheelIncrementX,
									 float wheelIncrementY);
};

#endif   // __JUCE_MOUSELISTENER_JUCEHEADER__

/*** End of inlined file: juce_MouseListener.h ***/


/*** Start of inlined file: juce_MouseEvent.h ***/
#ifndef __JUCE_MOUSEEVENT_JUCEHEADER__
#define __JUCE_MOUSEEVENT_JUCEHEADER__

class Component;
class MouseInputSource;

/*** Start of inlined file: juce_ModifierKeys.h ***/
#ifndef __JUCE_MODIFIERKEYS_JUCEHEADER__
#define __JUCE_MODIFIERKEYS_JUCEHEADER__

/**
	Represents the state of the mouse buttons and modifier keys.

	This is used both by mouse events and by KeyPress objects to describe
	the state of keys such as shift, control, alt, etc.

	@see KeyPress, MouseEvent::mods
*/
class JUCE_API  ModifierKeys
{
public:

	/** Creates a ModifierKeys object with no flags set. */
	ModifierKeys() noexcept;

	/** Creates a ModifierKeys object from a raw set of flags.

		@param flags to represent the keys that are down
		@see    shiftModifier, ctrlModifier, altModifier, leftButtonModifier,
				rightButtonModifier, commandModifier, popupMenuClickModifier
	*/
	ModifierKeys (int flags) noexcept;

	/** Creates a copy of another object. */
	ModifierKeys (const ModifierKeys& other) noexcept;

	/** Copies this object from another one. */
	ModifierKeys& operator= (const ModifierKeys& other) noexcept;

	/** Checks whether the 'command' key flag is set (or 'ctrl' on Windows/Linux).

		This is a platform-agnostic way of checking for the operating system's
		preferred command-key modifier - so on the Mac it tests for the Apple key, on
		Windows/Linux, it's actually checking for the CTRL key.
	*/
	inline bool isCommandDown() const noexcept          { return testFlags (commandModifier); }

	/** Checks whether the user is trying to launch a pop-up menu.

		This checks for platform-specific modifiers that might indicate that the user
		is following the operating system's normal method of showing a pop-up menu.

		So on Windows/Linux, this method is really testing for a right-click.
		On the Mac, it tests for either the CTRL key being down, or a right-click.
	*/
	inline bool isPopupMenu() const noexcept            { return testFlags (popupMenuClickModifier); }

	/** Checks whether the flag is set for the left mouse-button. */
	inline bool isLeftButtonDown() const noexcept       { return testFlags (leftButtonModifier); }

	/** Checks whether the flag is set for the right mouse-button.

		Note that for detecting popup-menu clicks, you should be using isPopupMenu() instead, as
		this is platform-independent (and makes your code more explanatory too).
	*/
	inline bool isRightButtonDown() const noexcept      { return testFlags (rightButtonModifier); }

	inline bool isMiddleButtonDown() const noexcept     { return testFlags (middleButtonModifier); }

	/** Tests for any of the mouse-button flags. */
	inline bool isAnyMouseButtonDown() const noexcept   { return testFlags (allMouseButtonModifiers); }

	/** Tests for any of the modifier key flags. */
	inline bool isAnyModifierKeyDown() const noexcept   { return testFlags ((shiftModifier | ctrlModifier | altModifier | commandModifier)); }

	/** Checks whether the shift key's flag is set. */
	inline bool isShiftDown() const noexcept            { return testFlags (shiftModifier); }

	/** Checks whether the CTRL key's flag is set.

		Remember that it's better to use the platform-agnostic routines to test for command-key and
		popup-menu modifiers.

		@see isCommandDown, isPopupMenu
	*/
	inline bool isCtrlDown() const noexcept             { return testFlags (ctrlModifier); }

	/** Checks whether the shift key's flag is set. */
	inline bool isAltDown() const noexcept              { return testFlags (altModifier); }

	/** Flags that represent the different keys. */
	enum Flags
	{
		/** Indicates no modifier keys. */
		noModifiers                             = 0,

		/** Shift key flag. */
		shiftModifier                           = 1,

		/** CTRL key flag. */
		ctrlModifier                            = 2,

		/** ALT key flag. */
		altModifier                             = 4,

		/** Left mouse button flag. */
		leftButtonModifier                      = 16,

		/** Right mouse button flag. */
		rightButtonModifier                     = 32,

		/** Middle mouse button flag. */
		middleButtonModifier                    = 64,

	   #if JUCE_MAC
		/** Command key flag - on windows this is the same as the CTRL key flag. */
		commandModifier                         = 8,

		/** Popup menu flag - on windows this is the same as rightButtonModifier, on the
			Mac it's the same as (rightButtonModifier | ctrlModifier). */
		popupMenuClickModifier                  = rightButtonModifier | ctrlModifier,
	   #else
		/** Command key flag - on windows this is the same as the CTRL key flag. */
		commandModifier                         = ctrlModifier,

		/** Popup menu flag - on windows this is the same as rightButtonModifier, on the
			Mac it's the same as (rightButtonModifier | ctrlModifier). */
		popupMenuClickModifier                  = rightButtonModifier,
	   #endif

		/** Represents a combination of all the shift, alt, ctrl and command key modifiers. */
		allKeyboardModifiers                    = shiftModifier | ctrlModifier | altModifier | commandModifier,

		/** Represents a combination of all the mouse buttons at once. */
		allMouseButtonModifiers                 = leftButtonModifier | rightButtonModifier | middleButtonModifier,
	};

	/** Returns a copy of only the mouse-button flags */
	ModifierKeys withOnlyMouseButtons() const noexcept                  { return ModifierKeys (flags & allMouseButtonModifiers); }

	/** Returns a copy of only the non-mouse flags */
	ModifierKeys withoutMouseButtons() const noexcept                   { return ModifierKeys (flags & ~allMouseButtonModifiers); }

	bool operator== (const ModifierKeys& other) const noexcept          { return flags == other.flags; }
	bool operator!= (const ModifierKeys& other) const noexcept          { return flags != other.flags; }

	/** Returns the raw flags for direct testing. */
	inline int getRawFlags() const noexcept                             { return flags; }

	inline const ModifierKeys withoutFlags (int rawFlagsToClear) const noexcept { return ModifierKeys (flags & ~rawFlagsToClear); }
	inline const ModifierKeys withFlags (int rawFlagsToSet) const noexcept      { return ModifierKeys (flags | rawFlagsToSet); }

	/** Tests a combination of flags and returns true if any of them are set. */
	inline bool testFlags (const int flagsToTest) const noexcept        { return (flags & flagsToTest) != 0; }

	/** Returns the total number of mouse buttons that are down. */
	int getNumMouseButtonsDown() const noexcept;

	/** Creates a ModifierKeys object to represent the last-known state of the
		keyboard and mouse buttons.

		@see getCurrentModifiersRealtime
	*/
	static ModifierKeys getCurrentModifiers() noexcept;

	/** Creates a ModifierKeys object to represent the current state of the
		keyboard and mouse buttons.

		This isn't often needed and isn't recommended, but will actively check all the
		mouse and key states rather than just returning their last-known state like
		getCurrentModifiers() does.

		This is only needed in special circumstances for up-to-date modifier information
		at times when the app's event loop isn't running normally.

		Another reason to avoid this method is that it's not stateless, and calling it may
		update the value returned by getCurrentModifiers(), which could cause subtle changes
		in the behaviour of some components.
	*/
	static ModifierKeys getCurrentModifiersRealtime() noexcept;

private:

	int flags;

	friend class ComponentPeer;
	friend class MouseInputSource;
	friend class MouseInputSourceInternal;

	static ModifierKeys currentModifiers;
	static void updateCurrentModifiers() noexcept;
};

#endif   // __JUCE_MODIFIERKEYS_JUCEHEADER__

/*** End of inlined file: juce_ModifierKeys.h ***/


/**
	Contains position and status information about a mouse event.

	@see MouseListener, Component::mouseMove, Component::mouseEnter, Component::mouseExit,
		 Component::mouseDown, Component::mouseUp, Component::mouseDrag
*/
class JUCE_API  MouseEvent
{
public:

	/** Creates a MouseEvent.

		Normally an application will never need to use this.

		@param source           the source that's invoking the event
		@param position         the position of the mouse, relative to the component that is passed-in
		@param modifiers        the key modifiers at the time of the event
		@param eventComponent   the component that the mouse event applies to
		@param originator       the component that originally received the event
		@param eventTime        the time the event happened
		@param mouseDownPos     the position of the corresponding mouse-down event (relative to the component that is passed-in).
								If there isn't a corresponding mouse-down (e.g. for a mouse-move), this will just be
								the same as the current mouse-x position.
		@param mouseDownTime    the time at which the corresponding mouse-down event happened
								If there isn't a corresponding mouse-down (e.g. for a mouse-move), this will just be
								the same as the current mouse-event time.
		@param numberOfClicks   how many clicks, e.g. a double-click event will be 2, a triple-click will be 3, etc
		@param mouseWasDragged  whether the mouse has been dragged significantly since the previous mouse-down
	*/
	MouseEvent (MouseInputSource& source,
				const Point<int>& position,
				const ModifierKeys& modifiers,
				Component* eventComponent,
				Component* originator,
				const Time& eventTime,
				const Point<int> mouseDownPos,
				const Time& mouseDownTime,
				int numberOfClicks,
				bool mouseWasDragged) noexcept;

	/** Destructor. */
	~MouseEvent() noexcept;

	/** The x-position of the mouse when the event occurred.

		This value is relative to the top-left of the component to which the
		event applies (as indicated by the MouseEvent::eventComponent field).
	*/
	const int x;

	/** The y-position of the mouse when the event occurred.

		This value is relative to the top-left of the component to which the
		event applies (as indicated by the MouseEvent::eventComponent field).
	*/
	const int y;

	/** The key modifiers associated with the event.

		This will let you find out which mouse buttons were down, as well as which
		modifier keys were held down.

		When used for mouse-up events, this will indicate the state of the mouse buttons
		just before they were released, so that you can tell which button they let go of.
	*/
	const ModifierKeys mods;

	/** The component that this event applies to.

		This is usually the component that the mouse was over at the time, but for mouse-drag
		events the mouse could actually be over a different component and the events are
		still sent to the component that the button was originally pressed on.

		The x and y member variables are relative to this component's position.

		If you use getEventRelativeTo() to retarget this object to be relative to a different
		component, this pointer will be updated, but originalComponent remains unchanged.

		@see originalComponent
	*/
	Component* const eventComponent;

	/** The component that the event first occurred on.

		If you use getEventRelativeTo() to retarget this object to be relative to a different
		component, this value remains unchanged to indicate the first component that received it.

		@see eventComponent
	*/
	Component* const originalComponent;

	/** The time that this mouse-event occurred. */
	const Time eventTime;

	/** The source device that generated this event. */
	MouseInputSource& source;

	/** Returns the x co-ordinate of the last place that a mouse was pressed.

		The co-ordinate is relative to the component specified in MouseEvent::component.

		@see getDistanceFromDragStart, getDistanceFromDragStartX, mouseWasClicked
	*/
	int getMouseDownX() const noexcept;

	/** Returns the y co-ordinate of the last place that a mouse was pressed.

		The co-ordinate is relative to the component specified in MouseEvent::component.

		@see getDistanceFromDragStart, getDistanceFromDragStartX, mouseWasClicked
	*/
	int getMouseDownY() const noexcept;

	/** Returns the co-ordinates of the last place that a mouse was pressed.

		The co-ordinates are relative to the component specified in MouseEvent::component.

		@see getDistanceFromDragStart, getDistanceFromDragStartX, mouseWasClicked
	*/
	Point<int> getMouseDownPosition() const noexcept;

	/** Returns the straight-line distance between where the mouse is now and where it
		was the last time the button was pressed.

		This is quite handy for things like deciding whether the user has moved far enough
		for it to be considered a drag operation.

		@see getDistanceFromDragStartX
	*/
	int getDistanceFromDragStart() const noexcept;

	/** Returns the difference between the mouse's current x postion and where it was
		when the button was last pressed.

		@see getDistanceFromDragStart
	*/
	int getDistanceFromDragStartX() const noexcept;

	/** Returns the difference between the mouse's current y postion and where it was
		when the button was last pressed.

		@see getDistanceFromDragStart
	*/
	int getDistanceFromDragStartY() const noexcept;

	/** Returns the difference between the mouse's current postion and where it was
		when the button was last pressed.

		@see getDistanceFromDragStart
	*/
	Point<int> getOffsetFromDragStart() const noexcept;

	/** Returns true if the mouse has just been clicked.

		Used in either your mouseUp() or mouseDrag() methods, this will tell you whether
		the user has dragged the mouse more than a few pixels from the place where the
		mouse-down occurred.

		Once they have dragged it far enough for this method to return false, it will continue
		to return false until the mouse-up, even if they move the mouse back to the same
		position where they originally pressed it. This means that it's very handy for
		objects that can either be clicked on or dragged, as you can use it in the mouseDrag()
		callback to ignore any small movements they might make while clicking.

		@returns    true if the mouse wasn't dragged by more than a few pixels between
					the last time the button was pressed and released.
	*/
	bool mouseWasClicked() const noexcept;

	/** For a click event, the number of times the mouse was clicked in succession.

		So for example a double-click event will return 2, a triple-click 3, etc.
	*/
	int getNumberOfClicks() const noexcept                              { return numberOfClicks; }

	/** Returns the time that the mouse button has been held down for.

		If called from a mouseDrag or mouseUp callback, this will return the
		number of milliseconds since the corresponding mouseDown event occurred.
		If called in other contexts, e.g. a mouseMove, then the returned value
		may be 0 or an undefined value.
	*/
	int getLengthOfMousePress() const noexcept;

	/** The position of the mouse when the event occurred.

		This position is relative to the top-left of the component to which the
		event applies (as indicated by the MouseEvent::eventComponent field).
	*/
	Point<int> getPosition() const noexcept;

	/** Returns the mouse x position of this event, in global screen co-ordinates.

		The co-ordinates are relative to the top-left of the main monitor.

		@see getScreenPosition
	*/
	int getScreenX() const;

	/** Returns the mouse y position of this event, in global screen co-ordinates.

		The co-ordinates are relative to the top-left of the main monitor.

		@see getScreenPosition
	*/
	int getScreenY() const;

	/** Returns the mouse position of this event, in global screen co-ordinates.

		The co-ordinates are relative to the top-left of the main monitor.

		@see getMouseDownScreenPosition
	*/
	Point<int> getScreenPosition() const;

	/** Returns the x co-ordinate at which the mouse button was last pressed.

		The co-ordinates are relative to the top-left of the main monitor.

		@see getMouseDownScreenPosition
	*/
	int getMouseDownScreenX() const;

	/** Returns the y co-ordinate at which the mouse button was last pressed.

		The co-ordinates are relative to the top-left of the main monitor.

		@see getMouseDownScreenPosition
	*/
	int getMouseDownScreenY() const;

	/** Returns the co-ordinates at which the mouse button was last pressed.

		The co-ordinates are relative to the top-left of the main monitor.

		@see getScreenPosition
	*/
	Point<int> getMouseDownScreenPosition() const;

	/** Creates a version of this event that is relative to a different component.

		The x and y positions of the event that is returned will have been
		adjusted to be relative to the new component.
		The component pointer that is passed-in must not be null.
	*/
	MouseEvent getEventRelativeTo (Component* newComponent) const noexcept;

	/** Creates a copy of this event with a different position.
		All other members of the event object are the same, but the x and y are
		replaced with these new values.
	*/
	MouseEvent withNewPosition (const Point<int>& newPosition) const noexcept;

	/** Changes the application-wide setting for the double-click time limit.

		This is the maximum length of time between mouse-clicks for it to be
		considered a double-click. It's used by the Component class.

		@see getDoubleClickTimeout, MouseListener::mouseDoubleClick
	*/
	static void setDoubleClickTimeout (int timeOutMilliseconds) noexcept;

	/** Returns the application-wide setting for the double-click time limit.

		This is the maximum length of time between mouse-clicks for it to be
		considered a double-click. It's used by the Component class.

		@see setDoubleClickTimeout, MouseListener::mouseDoubleClick
	*/
	static int getDoubleClickTimeout() noexcept;

private:

	const Point<int> mouseDownPos;
	const Time mouseDownTime;
	const uint8 numberOfClicks, wasMovedSinceMouseDown;

	MouseEvent& operator= (const MouseEvent&);
};

#endif   // __JUCE_MOUSEEVENT_JUCEHEADER__

/*** End of inlined file: juce_MouseEvent.h ***/


/*** Start of inlined file: juce_ComponentListener.h ***/
#ifndef __JUCE_COMPONENTLISTENER_JUCEHEADER__
#define __JUCE_COMPONENTLISTENER_JUCEHEADER__

class Component;

/**
	Gets informed about changes to a component's hierarchy or position.

	To monitor a component for changes, register a subclass of ComponentListener
	with the component using Component::addComponentListener().

	Be sure to deregister listeners before you delete them!

	@see Component::addComponentListener, Component::removeComponentListener
*/
class JUCE_API  ComponentListener
{
public:
	/** Destructor. */
	virtual ~ComponentListener()  {}

	/** Called when the component's position or size changes.

		@param component    the component that was moved or resized
		@param wasMoved     true if the component's top-left corner has just moved
		@param wasResized   true if the component's width or height has just changed
		@see Component::setBounds, Component::resized, Component::moved
	*/
	virtual void componentMovedOrResized (Component& component,
										  bool wasMoved,
										  bool wasResized);

	/** Called when the component is brought to the top of the z-order.

		@param component    the component that was moved
		@see Component::toFront, Component::broughtToFront
	*/
	virtual void componentBroughtToFront (Component& component);

	/** Called when the component is made visible or invisible.

		@param component    the component that changed
		@see Component::setVisible
	*/
	virtual void componentVisibilityChanged (Component& component);

	/** Called when the component has children added or removed.

		@param component    the component whose children were changed
		@see Component::childrenChanged, Component::addChildComponent,
			 Component::removeChildComponent
	*/
	virtual void componentChildrenChanged (Component& component);

	/** Called to indicate that the component's parents have changed.

		When a component is added or removed from its parent, all of its children
		will produce this notification (recursively - so all children of its
		children will also be called as well).

		@param component    the component that this listener is registered with
		@see Component::parentHierarchyChanged
	*/
	virtual void componentParentHierarchyChanged (Component& component);

	/** Called when the component's name is changed.

		@see Component::setName, Component::getName
	*/
	virtual void componentNameChanged (Component& component);

	/** Called when the component is in the process of being deleted.

		This callback is made from inside the destructor, so be very, very cautious
		about what you do in here.

		In particular, bear in mind that it's the Component base class's destructor that calls
		this - so if the object that's being deleted is a subclass of Component, then the
		subclass layers of the object will already have been destructed when it gets to this
		point!
	*/
	virtual void componentBeingDeleted (Component& component);
};

#endif   // __JUCE_COMPONENTLISTENER_JUCEHEADER__

/*** End of inlined file: juce_ComponentListener.h ***/


/*** Start of inlined file: juce_KeyListener.h ***/
#ifndef __JUCE_KEYLISTENER_JUCEHEADER__
#define __JUCE_KEYLISTENER_JUCEHEADER__


/*** Start of inlined file: juce_KeyPress.h ***/
#ifndef __JUCE_KEYPRESS_JUCEHEADER__
#define __JUCE_KEYPRESS_JUCEHEADER__

/**
	Represents a key press, including any modifier keys that are needed.

	E.g. a KeyPress might represent CTRL+C, SHIFT+ALT+H, Spacebar, Escape, etc.

	@see Component, KeyListener, Button::addShortcut, KeyPressMappingManager
*/
class JUCE_API  KeyPress
{
public:

	/** Creates an (invalid) KeyPress.

		@see isValid
	*/
	KeyPress() noexcept;

	/** Creates a KeyPress for a key and some modifiers.

		e.g.
		CTRL+C would be: KeyPress ('c', ModifierKeys::ctrlModifier)
		SHIFT+Escape would be: KeyPress (KeyPress::escapeKey, ModifierKeys::shiftModifier)

		@param keyCode      a code that represents the key - this value must be
							one of special constants listed in this class, or an
							8-bit character code such as a letter (case is ignored),
							digit or a simple key like "," or ".". Note that this
							isn't the same as the textCharacter parameter, so for example
							a keyCode of 'a' and a shift-key modifier should have a
							textCharacter value of 'A'.
		@param modifiers    the modifiers to associate with the keystroke
		@param textCharacter    the character that would be printed if someone typed
							this keypress into a text editor. This value may be
							null if the keypress is a non-printing character
		@see getKeyCode, isKeyCode, getModifiers
	*/
	KeyPress (int keyCode,
			  const ModifierKeys& modifiers,
			  juce_wchar textCharacter) noexcept;

	/** Creates a keypress with a keyCode but no modifiers or text character.
	*/
	KeyPress (int keyCode) noexcept;

	/** Creates a copy of another KeyPress. */
	KeyPress (const KeyPress& other) noexcept;

	/** Copies this KeyPress from another one. */
	KeyPress& operator= (const KeyPress& other) noexcept;

	/** Compares two KeyPress objects. */
	bool operator== (const KeyPress& other) const noexcept;

	/** Compares two KeyPress objects. */
	bool operator!= (const KeyPress& other) const noexcept;

	/** Returns true if this is a valid KeyPress.

		A null keypress can be created by the default constructor, in case it's
		needed.
	*/
	bool isValid() const noexcept                               { return keyCode != 0; }

	/** Returns the key code itself.

		This will either be one of the special constants defined in this class,
		or an 8-bit character code.
	*/
	int getKeyCode() const noexcept                             { return keyCode; }

	/** Returns the key modifiers.

		@see ModifierKeys
	*/
	ModifierKeys getModifiers() const noexcept                  { return mods; }

	/** Returns the character that is associated with this keypress.

		This is the character that you'd expect to see printed if you press this
		keypress in a text editor or similar component.
	*/
	juce_wchar getTextCharacter() const noexcept                { return textCharacter; }

	/** Checks whether the KeyPress's key is the same as the one provided, without checking
		the modifiers.

		The values for key codes can either be one of the special constants defined in
		this class, or an 8-bit character code.

		@see getKeyCode
	*/
	bool isKeyCode (int keyCodeToCompare) const noexcept        { return keyCode == keyCodeToCompare; }

	/** Converts a textual key description to a KeyPress.

		This attempts to decode a textual version of a keypress, e.g. "CTRL + C" or "SPACE".

		This isn't designed to cope with any kind of input, but should be given the
		strings that are created by the getTextDescription() method.

		If the string can't be parsed, the object returned will be invalid.

		@see getTextDescription
	*/
	static KeyPress createFromDescription (const String& textVersion);

	/** Creates a textual description of the key combination.

		e.g. "CTRL + C" or "DELETE".

		To store a keypress in a file, use this method, along with createFromDescription()
		to retrieve it later.
	*/
	String getTextDescription() const;

	/** Creates a textual description of the key combination, using unicode icon symbols if possible.

		On OSX, this uses the Apple symbols for command, option, shift, etc, instead of the textual
		modifier key descriptions that are returned by getTextDescription()
	*/
	String getTextDescriptionWithIcons() const;

	/** Checks whether the user is currently holding down the keys that make up this
		KeyPress.

		Note that this will return false if any extra modifier keys are
		down - e.g. if the keypress is CTRL+X and the user is actually holding CTRL+ALT+x
		then it will be false.
	*/
	bool isCurrentlyDown() const;

	/** Checks whether a particular key is held down, irrespective of modifiers.

		The values for key codes can either be one of the special constants defined in
		this class, or an 8-bit character code.
	*/
	static bool isKeyCurrentlyDown (int keyCode);

	// Key codes
	//
	// Note that the actual values of these are platform-specific and may change
	// without warning, so don't store them anywhere as constants. For persisting/retrieving
	// KeyPress objects, use getTextDescription() and createFromDescription() instead.
	//

	static const int spaceKey;      /**< key-code for the space bar */
	static const int escapeKey;     /**< key-code for the escape key */
	static const int returnKey;     /**< key-code for the return key*/
	static const int tabKey;        /**< key-code for the tab key*/

	static const int deleteKey;     /**< key-code for the delete key (not backspace) */
	static const int backspaceKey;  /**< key-code for the backspace key */
	static const int insertKey;     /**< key-code for the insert key */

	static const int upKey;         /**< key-code for the cursor-up key */
	static const int downKey;       /**< key-code for the cursor-down key */
	static const int leftKey;       /**< key-code for the cursor-left key */
	static const int rightKey;      /**< key-code for the cursor-right key */
	static const int pageUpKey;     /**< key-code for the page-up key */
	static const int pageDownKey;   /**< key-code for the page-down key */
	static const int homeKey;       /**< key-code for the home key */
	static const int endKey;        /**< key-code for the end key */

	static const int F1Key;         /**< key-code for the F1 key */
	static const int F2Key;         /**< key-code for the F2 key */
	static const int F3Key;         /**< key-code for the F3 key */
	static const int F4Key;         /**< key-code for the F4 key */
	static const int F5Key;         /**< key-code for the F5 key */
	static const int F6Key;         /**< key-code for the F6 key */
	static const int F7Key;         /**< key-code for the F7 key */
	static const int F8Key;         /**< key-code for the F8 key */
	static const int F9Key;         /**< key-code for the F9 key */
	static const int F10Key;        /**< key-code for the F10 key */
	static const int F11Key;        /**< key-code for the F11 key */
	static const int F12Key;        /**< key-code for the F12 key */
	static const int F13Key;        /**< key-code for the F13 key */
	static const int F14Key;        /**< key-code for the F14 key */
	static const int F15Key;        /**< key-code for the F15 key */
	static const int F16Key;        /**< key-code for the F16 key */

	static const int numberPad0;     /**< key-code for the 0 on the numeric keypad. */
	static const int numberPad1;     /**< key-code for the 1 on the numeric keypad. */
	static const int numberPad2;     /**< key-code for the 2 on the numeric keypad. */
	static const int numberPad3;     /**< key-code for the 3 on the numeric keypad. */
	static const int numberPad4;     /**< key-code for the 4 on the numeric keypad. */
	static const int numberPad5;     /**< key-code for the 5 on the numeric keypad. */
	static const int numberPad6;     /**< key-code for the 6 on the numeric keypad. */
	static const int numberPad7;     /**< key-code for the 7 on the numeric keypad. */
	static const int numberPad8;     /**< key-code for the 8 on the numeric keypad. */
	static const int numberPad9;     /**< key-code for the 9 on the numeric keypad. */

	static const int numberPadAdd;            /**< key-code for the add sign on the numeric keypad. */
	static const int numberPadSubtract;       /**< key-code for the subtract sign on the numeric keypad. */
	static const int numberPadMultiply;       /**< key-code for the multiply sign on the numeric keypad. */
	static const int numberPadDivide;         /**< key-code for the divide sign on the numeric keypad. */
	static const int numberPadSeparator;      /**< key-code for the comma on the numeric keypad. */
	static const int numberPadDecimalPoint;   /**< key-code for the decimal point sign on the numeric keypad. */
	static const int numberPadEquals;         /**< key-code for the equals key on the numeric keypad. */
	static const int numberPadDelete;         /**< key-code for the delete key on the numeric keypad. */

	static const int playKey;        /**< key-code for a multimedia 'play' key, (not all keyboards will have one) */
	static const int stopKey;        /**< key-code for a multimedia 'stop' key, (not all keyboards will have one) */
	static const int fastForwardKey; /**< key-code for a multimedia 'fast-forward' key, (not all keyboards will have one) */
	static const int rewindKey;      /**< key-code for a multimedia 'rewind' key, (not all keyboards will have one) */

private:

	int keyCode;
	ModifierKeys mods;
	juce_wchar textCharacter;

	JUCE_LEAK_DETECTOR (KeyPress);
};

#endif   // __JUCE_KEYPRESS_JUCEHEADER__

/*** End of inlined file: juce_KeyPress.h ***/

class Component;

/**
	Receives callbacks when keys are pressed.

	You can add a key listener to a component to be informed when that component
	gets key events. See the Component::addListener method for more details.

	@see KeyPress, Component::addKeyListener, KeyPressMappingManager
*/
class JUCE_API  KeyListener
{
public:
	/** Destructor. */
	virtual ~KeyListener()  {}

	/** Called to indicate that a key has been pressed.

		If your implementation returns true, then the key event is considered to have
		been consumed, and will not be passed on to any other components. If it returns
		false, then the key will be passed to other components that might want to use it.

		@param key                      the keystroke, including modifier keys
		@param originatingComponent     the component that received the key event
		@see keyStateChanged, Component::keyPressed
	*/
	virtual bool keyPressed (const KeyPress& key,
							 Component* originatingComponent) = 0;

	/** Called when any key is pressed or released.

		When this is called, classes that might be interested in
		the state of one or more keys can use KeyPress::isKeyCurrentlyDown() to
		check whether their key has changed.

		If your implementation returns true, then the key event is considered to have
		been consumed, and will not be passed on to any other components. If it returns
		false, then the key will be passed to other components that might want to use it.

		@param originatingComponent     the component that received the key event
		@param isKeyDown                true if a key is being pressed, false if one is being released
		@see KeyPress, Component::keyStateChanged
	*/
	virtual bool keyStateChanged (bool isKeyDown, Component* originatingComponent);
};

#endif   // __JUCE_KEYLISTENER_JUCEHEADER__

/*** End of inlined file: juce_KeyListener.h ***/


/*** Start of inlined file: juce_KeyboardFocusTraverser.h ***/
#ifndef __JUCE_KEYBOARDFOCUSTRAVERSER_JUCEHEADER__
#define __JUCE_KEYBOARDFOCUSTRAVERSER_JUCEHEADER__

class Component;

/**
	Controls the order in which focus moves between components.

	The default algorithm used by this class to work out the order of traversal
	is as follows:
	- if two components both have an explicit focus order specified, then the
	  one with the lowest number comes first (see the Component::setExplicitFocusOrder()
	  method).
	- any component with an explicit focus order greater than 0 comes before ones
	  that don't have an order specified.
	- any unspecified components are traversed in a left-to-right, then top-to-bottom
	  order.

	If you need traversal in a more customised way, you can create a subclass
	of KeyboardFocusTraverser that uses your own algorithm, and use
	Component::createFocusTraverser() to create it.

	@see Component::setExplicitFocusOrder, Component::createFocusTraverser
*/
class JUCE_API  KeyboardFocusTraverser
{
public:
	KeyboardFocusTraverser();

	/** Destructor. */
	virtual ~KeyboardFocusTraverser();

	/** Returns the component that should be given focus after the specified one
		when moving "forwards".

		The default implementation will return the next component which is to the
		right of or below this one.

		This may return 0 if there's no suitable candidate.
	*/
	virtual Component* getNextComponent (Component* current);

	/** Returns the component that should be given focus after the specified one
		when moving "backwards".

		The default implementation will return the next component which is to the
		left of or above this one.

		This may return 0 if there's no suitable candidate.
	*/
	virtual Component* getPreviousComponent (Component* current);

	/** Returns the component that should receive focus be default within the given
		parent component.

		The default implementation will just return the foremost child component that
		wants focus.

		This may return 0 if there's no suitable candidate.
	*/
	virtual Component* getDefaultComponent (Component* parentComponent);
};

#endif   // __JUCE_KEYBOARDFOCUSTRAVERSER_JUCEHEADER__

/*** End of inlined file: juce_KeyboardFocusTraverser.h ***/


/*** Start of inlined file: juce_ModalComponentManager.h ***/
#ifndef __JUCE_MODALCOMPONENTMANAGER_JUCEHEADER__
#define __JUCE_MODALCOMPONENTMANAGER_JUCEHEADER__

/**
	Manages the system's stack of modal components.

	Normally you'll just use the Component methods to invoke modal states in components,
	and won't have to deal with this class directly, but this is the singleton object that's
	used internally to manage the stack.

	@see Component::enterModalState, Component::exitModalState, Component::isCurrentlyModal,
		 Component::getCurrentlyModalComponent, Component::isCurrentlyBlockedByAnotherModalComponent
*/
class JUCE_API  ModalComponentManager   : public AsyncUpdater,
										  public DeletedAtShutdown
{
public:

	/** Receives callbacks when a modal component is dismissed.

		You can register a callback using Component::enterModalState() or
		ModalComponentManager::attachCallback().

		For some quick ways of creating callback objects, see the ModalCallbackFunction class.
		@see ModalCallbackFunction
	*/
	class Callback
	{
	public:
		/** */
		Callback() {}

		/** Destructor. */
		virtual ~Callback() {}

		/** Called to indicate that a modal component has been dismissed.

			You can register a callback using Component::enterModalState() or
			ModalComponentManager::attachCallback().

			The returnValue parameter is the value that was passed to Component::exitModalState()
			when the component was dismissed.

			The callback object will be deleted shortly after this method is called.
		*/
		virtual void modalStateFinished (int returnValue) = 0;
	};

	/** Returns the number of components currently being shown modally.
		@see getModalComponent
	*/
	int getNumModalComponents() const;

	/** Returns one of the components being shown modally.
		An index of 0 is the most recently-shown, topmost component.
	*/
	Component* getModalComponent (int index) const;

	/** Returns true if the specified component is in a modal state. */
	bool isModal (Component* component) const;

	/** Returns true if the specified component is currently the topmost modal component. */
	bool isFrontModalComponent (Component* component) const;

	/** Adds a new callback that will be called when the specified modal component is dismissed.

		If the component is modal, then when it is dismissed, either by being hidden, or by calling
		Component::exitModalState(), then the Callback::modalStateFinished() method will be
		called.

		Each component can have any number of callbacks associated with it, and this one is added
		to that list.

		The object that is passed in will be deleted by the manager when it's no longer needed. If
		the given component is not currently modal, the callback object is deleted immediately and
		no action is taken.
	*/
	void attachCallback (Component* component, Callback* callback);

	/** Brings any modal components to the front. */
	void bringModalComponentsToFront (bool topOneShouldGrabFocus = true);

   #if JUCE_MODAL_LOOPS_PERMITTED
	/** Runs the event loop until the currently topmost modal component is dismissed, and
		returns the exit code for that component.
	*/
	int runEventLoopForCurrentComponent();
   #endif

	juce_DeclareSingleton_SingleThreaded_Minimal (ModalComponentManager);

protected:
	/** Creates a ModalComponentManager.
		You shouldn't ever call the constructor - it's a singleton, so use ModalComponentManager::getInstance()
	*/
	ModalComponentManager();

	/** Destructor. */
	~ModalComponentManager();

	/** @internal */
	void handleAsyncUpdate();

private:

	class ModalItem;
	class ReturnValueRetriever;

	friend class Component;
	friend class OwnedArray <ModalItem>;
	OwnedArray <ModalItem> stack;

	void startModal (Component*, bool autoDelete);
	void endModal (Component*, int returnValue);
	void endModal (Component*);

	JUCE_DECLARE_NON_COPYABLE (ModalComponentManager);
};

/**
	This class provides some handy utility methods for creating ModalComponentManager::Callback
	objects that will invoke a static function with some parameters when a modal component is dismissed.
*/
class ModalCallbackFunction
{
public:

	/** This is a utility function to create a ModalComponentManager::Callback that will
		call a static function with a parameter.

		The function that you supply must take two parameters - the first being an int, which is
		the result code that was used when the modal component was dismissed, and the second
		can be a custom type. Note that this custom value will be copied and stored, so it must
		be a primitive type or a class that provides copy-by-value semantics.

		E.g. @code
		static void myCallbackFunction (int modalResult, double customValue)
		{
			if (modalResult == 1)
				doSomethingWith (customValue);
		}

		Component* someKindOfComp;
		...
		someKindOfComp->enterModalState (ModalCallbackFunction::create (myCallbackFunction, 3.0));
		@endcode
		@see ModalComponentManager::Callback
	*/
	template <typename ParamType>
	static ModalComponentManager::Callback* create (void (*functionToCall) (int, ParamType),
													ParamType parameterValue)
	{
		return new FunctionCaller1 <ParamType> (functionToCall, parameterValue);
	}

	/** This is a utility function to create a ModalComponentManager::Callback that will
		call a static function with two custom parameters.

		The function that you supply must take three parameters - the first being an int, which is
		the result code that was used when the modal component was dismissed, and the next two are
		your custom types. Note that these custom values will be copied and stored, so they must
		be primitive types or classes that provide copy-by-value semantics.

		E.g. @code
		static void myCallbackFunction (int modalResult, double customValue1, String customValue2)
		{
			if (modalResult == 1)
				doSomethingWith (customValue1, customValue2);
		}

		Component* someKindOfComp;
		...
		someKindOfComp->enterModalState (ModalCallbackFunction::create (myCallbackFunction, 3.0, String ("xyz")));
		@endcode
		@see ModalComponentManager::Callback
	*/
	template <typename ParamType1, typename ParamType2>
	static ModalComponentManager::Callback* withParam (void (*functionToCall) (int, ParamType1, ParamType2),
													   ParamType1 parameterValue1,
													   ParamType2 parameterValue2)
	{
		return new FunctionCaller2 <ParamType1, ParamType2> (functionToCall, parameterValue1, parameterValue2);
	}

	/** This is a utility function to create a ModalComponentManager::Callback that will
		call a static function with a component.

		The function that you supply must take two parameters - the first being an int, which is
		the result code that was used when the modal component was dismissed, and the second
		can be a Component class. The component will be stored as a WeakReference, so that if it gets
		deleted before this callback is invoked, the pointer that is passed to the function will be null.

		E.g. @code
		static void myCallbackFunction (int modalResult, Slider* mySlider)
		{
			if (modalResult == 1 && mySlider != nullptr) // (must check that mySlider isn't null in case it was deleted..)
				mySlider->setValue (0.0);
		}

		Component* someKindOfComp;
		Slider* mySlider;
		...
		someKindOfComp->enterModalState (ModalCallbackFunction::forComponent (myCallbackFunction, mySlider));
		@endcode
		@see ModalComponentManager::Callback
	*/
	template <class ComponentType>
	static ModalComponentManager::Callback* forComponent (void (*functionToCall) (int, ComponentType*),
														  ComponentType* component)
	{
		return new ComponentCaller1 <ComponentType> (functionToCall, component);
	}

	/** Creates a ModalComponentManager::Callback that will call a static function with a component.

		The function that you supply must take three parameters - the first being an int, which is
		the result code that was used when the modal component was dismissed, the second being a Component
		class, and the third being a custom type (which must be a primitive type or have copy-by-value semantics).
		The component will be stored as a WeakReference, so that if it gets deleted before this callback is
		invoked, the pointer that is passed into the function will be null.

		E.g. @code
		static void myCallbackFunction (int modalResult, Slider* mySlider, String customParam)
		{
			if (modalResult == 1 && mySlider != nullptr) // (must check that mySlider isn't null in case it was deleted..)
				mySlider->setName (customParam);
		}

		Component* someKindOfComp;
		Slider* mySlider;
		...
		someKindOfComp->enterModalState (ModalCallbackFunction::forComponent (myCallbackFunction, mySlider, String ("hello")));
		@endcode
		@see ModalComponentManager::Callback
	*/
	template <class ComponentType, typename ParamType>
	static ModalComponentManager::Callback* forComponent (void (*functionToCall) (int, ComponentType*, ParamType),
														  ComponentType* component,
														  ParamType param)
	{
		return new ComponentCaller2 <ComponentType, ParamType> (functionToCall, component, param);
	}

private:

	template <typename ParamType>
	class FunctionCaller1  : public ModalComponentManager::Callback
	{
	public:
		typedef void (*FunctionType) (int, ParamType);

		FunctionCaller1 (FunctionType& function_, ParamType& param_)
			: function (function_), param (param_) {}

		void modalStateFinished (int returnValue)  { function (returnValue, param); }

	private:
		const FunctionType function;
		ParamType param;

		JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (FunctionCaller1);
	};

	template <typename ParamType1, typename ParamType2>
	class FunctionCaller2  : public ModalComponentManager::Callback
	{
	public:
		typedef void (*FunctionType) (int, ParamType1, ParamType2);

		FunctionCaller2 (FunctionType& function_, ParamType1& param1_, ParamType2& param2_)
			: function (function_), param1 (param1_), param2 (param2_) {}

		void modalStateFinished (int returnValue)   { function (returnValue, param1, param2); }

	private:
		const FunctionType function;
		ParamType1 param1;
		ParamType2 param2;

		JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (FunctionCaller2);
	};

	template <typename ComponentType>
	class ComponentCaller1  : public ModalComponentManager::Callback
	{
	public:
		typedef void (*FunctionType) (int, ComponentType*);

		ComponentCaller1 (FunctionType& function_, ComponentType* comp_)
			: function (function_), comp (comp_) {}

		void modalStateFinished (int returnValue)
		{
			function (returnValue, static_cast <ComponentType*> (comp.get()));
		}

	private:
		const FunctionType function;
		WeakReference<Component> comp;

		JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ComponentCaller1);
	};

	template <typename ComponentType, typename ParamType1>
	class ComponentCaller2  : public ModalComponentManager::Callback
	{
	public:
		typedef void (*FunctionType) (int, ComponentType*, ParamType1);

		ComponentCaller2 (FunctionType& function_, ComponentType* comp_, ParamType1 param1_)
			: function (function_), comp (comp_), param1 (param1_) {}

		void modalStateFinished (int returnValue)
		{
			function (returnValue, static_cast <ComponentType*> (comp.get()), param1);
		}

	private:
		const FunctionType function;
		WeakReference<Component> comp;
		ParamType1 param1;

		JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ComponentCaller2);
	};

	ModalCallbackFunction();
	~ModalCallbackFunction();
	JUCE_DECLARE_NON_COPYABLE (ModalCallbackFunction);
};

#endif   // __JUCE_MODALCOMPONENTMANAGER_JUCEHEADER__

/*** End of inlined file: juce_ModalComponentManager.h ***/

class LookAndFeel;
class MouseInputSource;
class MouseInputSourceInternal;
class ComponentPeer;
class MarkerList;
class RelativeRectangle;
class CachedComponentImage;

/**
	The base class for all JUCE user-interface objects.

*/
class JUCE_API  Component  : public MouseListener
{
public:

	/** Creates a component.

		To get it to actually appear, you'll also need to:
		- Either add it to a parent component or use the addToDesktop() method to
		  make it a desktop window
		- Set its size and position to something sensible
		- Use setVisible() to make it visible

		And for it to serve any useful purpose, you'll need to write a
		subclass of Component or use one of the other types of component from
		the library.
	*/
	Component();

	/** Destructor.

		Note that when a component is deleted, any child components it contains are NOT
		automatically deleted. It's your responsibilty to manage their lifespan - you
		may want to use helper methods like deleteAllChildren(), or less haphazard
		approaches like using ScopedPointers or normal object aggregation to manage them.

		If the component being deleted is currently the child of another one, then during
		deletion, it will be removed from its parent, and the parent will receive a childrenChanged()
		callback. Any ComponentListener objects that have registered with it will also have their
		ComponentListener::componentBeingDeleted() methods called.
	*/
	virtual ~Component();

	/** Creates a component, setting its name at the same time.

		@see getName, setName
	*/
	explicit Component (const String& componentName);

	/** Returns the name of this component.

		@see setName
	*/
	const String& getName() const noexcept                  { return componentName; }

	/** Sets the name of this component.

		When the name changes, all registered ComponentListeners will receive a
		ComponentListener::componentNameChanged() callback.

		@see getName
	*/
	virtual void setName (const String& newName);

	/** Returns the ID string that was set by setComponentID().
		@see setComponentID, findChildWithID
	*/
	const String& getComponentID() const noexcept           { return componentID; }

	/** Sets the component's ID string.
		You can retrieve the ID using getComponentID().
		@see getComponentID, findChildWithID
	*/
	void setComponentID (const String& newID);

	/** Makes the component visible or invisible.

		This method will show or hide the component.
		Note that components default to being non-visible when first created.
		Also note that visible components won't be seen unless all their parent components
		are also visible.

		This method will call visibilityChanged() and also componentVisibilityChanged()
		for any component listeners that are interested in this component.

		@param shouldBeVisible  whether to show or hide the component
		@see isVisible, isShowing, visibilityChanged, ComponentListener::componentVisibilityChanged
	*/
	virtual void setVisible (bool shouldBeVisible);

	/** Tests whether the component is visible or not.

		this doesn't necessarily tell you whether this comp is actually on the screen
		because this depends on whether all the parent components are also visible - use
		isShowing() to find this out.

		@see isShowing, setVisible
	*/
	bool isVisible() const noexcept                         { return flags.visibleFlag; }

	/** Called when this component's visiblility changes.

		@see setVisible, isVisible
	*/
	virtual void visibilityChanged();

	/** Tests whether this component and all its parents are visible.

		@returns    true only if this component and all its parents are visible.
		@see isVisible
	*/
	bool isShowing() const;

	/** Makes this component appear as a window on the desktop.

		Note that before calling this, you should make sure that the component's opacity is
		set correctly using setOpaque(). If the component is non-opaque, the windowing
		system will try to create a special transparent window for it, which will generally take
		a lot more CPU to operate (and might not even be possible on some platforms).

		If the component is inside a parent component at the time this method is called, it
		will be first be removed from that parent. Likewise if a component on the desktop
		is subsequently added to another component, it'll be removed from the desktop.

		@param windowStyleFlags             a combination of the flags specified in the
											ComponentPeer::StyleFlags enum, which define the
											window's characteristics.
		@param nativeWindowToAttachTo       this allows an OS object to be passed-in as the window
											in which the juce component should place itself. On Windows,
											this would be a HWND, a HIViewRef on the Mac. Not necessarily
											supported on all platforms, and best left as 0 unless you know
											what you're doing
		@see removeFromDesktop, isOnDesktop, userTriedToCloseWindow,
			 getPeer, ComponentPeer::setMinimised, ComponentPeer::StyleFlags,
			 ComponentPeer::getStyleFlags, ComponentPeer::setFullScreen
	*/
	virtual void addToDesktop (int windowStyleFlags,
							   void* nativeWindowToAttachTo = nullptr);

	/** If the component is currently showing on the desktop, this will hide it.

		You can also use setVisible() to hide a desktop window temporarily, but
		removeFromDesktop() will free any system resources that are being used up.

		@see addToDesktop, isOnDesktop
	*/
	void removeFromDesktop();

	/** Returns true if this component is currently showing on the desktop.

		@see addToDesktop, removeFromDesktop
	*/
	bool isOnDesktop() const noexcept;

	/** Returns the heavyweight window that contains this component.

		If this component is itself on the desktop, this will return the window
		object that it is using. Otherwise, it will return the window of
		its top-level parent component.

		This may return 0 if there isn't a desktop component.

		@see addToDesktop, isOnDesktop
	*/
	ComponentPeer* getPeer() const;

	/** For components on the desktop, this is called if the system wants to close the window.

		This is a signal that either the user or the system wants the window to close. The
		default implementation of this method will trigger an assertion to warn you that your
		component should do something about it, but you can override this to ignore the event
		if you want.
	*/
	virtual void userTriedToCloseWindow();

	/** Called for a desktop component which has just been minimised or un-minimised.

		This will only be called for components on the desktop.

		@see getPeer, ComponentPeer::setMinimised, ComponentPeer::isMinimised
	*/
	virtual void minimisationStateChanged (bool isNowMinimised);

	/** Brings the component to the front of its siblings.

		If some of the component's siblings have had their 'always-on-top' flag set,
		then they will still be kept in front of this one (unless of course this
		one is also 'always-on-top').

		@param shouldAlsoGainFocus  if true, this will also try to assign keyboard focus
									to the component (see grabKeyboardFocus() for more details)
		@see toBack, toBehind, setAlwaysOnTop
	*/
	void toFront (bool shouldAlsoGainFocus);

	/** Changes this component's z-order to be at the back of all its siblings.

		If the component is set to be 'always-on-top', it will only be moved to the
		back of the other other 'always-on-top' components.

		@see toFront, toBehind, setAlwaysOnTop
	*/
	void toBack();

	/** Changes this component's z-order so that it's just behind another component.

		@see toFront, toBack
	*/
	void toBehind (Component* other);

	/** Sets whether the component should always be kept at the front of its siblings.

		@see isAlwaysOnTop
	*/
	void setAlwaysOnTop (bool shouldStayOnTop);

	/** Returns true if this component is set to always stay in front of its siblings.

		@see setAlwaysOnTop
	*/
	bool isAlwaysOnTop() const noexcept;

	/** Returns the x coordinate of the component's left edge.
		This is a distance in pixels from the left edge of the component's parent.

		Note that if you've used setTransform() to apply a transform, then the component's
		bounds will no longer be a direct reflection of the position at which it appears within
		its parent, as the transform will be applied to its bounding box.
	*/
	inline int getX() const noexcept                        { return bounds.getX(); }

	/** Returns the y coordinate of the top of this component.
		This is a distance in pixels from the top edge of the component's parent.

		Note that if you've used setTransform() to apply a transform, then the component's
		bounds will no longer be a direct reflection of the position at which it appears within
		its parent, as the transform will be applied to its bounding box.
	*/
	inline int getY() const noexcept                        { return bounds.getY(); }

	/** Returns the component's width in pixels. */
	inline int getWidth() const noexcept                    { return bounds.getWidth(); }

	/** Returns the component's height in pixels. */
	inline int getHeight() const noexcept                   { return bounds.getHeight(); }

	/** Returns the x coordinate of the component's right-hand edge.
		This is a distance in pixels from the left edge of the component's parent.

		Note that if you've used setTransform() to apply a transform, then the component's
		bounds will no longer be a direct reflection of the position at which it appears within
		its parent, as the transform will be applied to its bounding box.
	*/
	int getRight() const noexcept                           { return bounds.getRight(); }

	/** Returns the component's top-left position as a Point. */
	const Point<int>& getPosition() const noexcept          { return bounds.getPosition(); }

	/** Returns the y coordinate of the bottom edge of this component.
		This is a distance in pixels from the top edge of the component's parent.

		Note that if you've used setTransform() to apply a transform, then the component's
		bounds will no longer be a direct reflection of the position at which it appears within
		its parent, as the transform will be applied to its bounding box.
	*/
	int getBottom() const noexcept                          { return bounds.getBottom(); }

	/** Returns this component's bounding box.
		The rectangle returned is relative to the top-left of the component's parent.

		Note that if you've used setTransform() to apply a transform, then the component's
		bounds will no longer be a direct reflection of the position at which it appears within
		its parent, as the transform will be applied to its bounding box.
	*/
	const Rectangle<int>& getBounds() const noexcept        { return bounds; }

	/** Returns the component's bounds, relative to its own origin.
		This is like getBounds(), but returns the rectangle in local coordinates, In practice, it'll
		return a rectangle with position (0, 0), and the same size as this component.
	*/
	Rectangle<int> getLocalBounds() const noexcept;

	/** Returns the area of this component's parent which this component covers.

		The returned area is relative to the parent's coordinate space.
		If the component has an affine transform specified, then the resulting area will be
		the smallest rectangle that fully covers the component's transformed bounding box.
		If this component has no parent, the return value will simply be the same as getBounds().
	*/
	Rectangle<int> getBoundsInParent() const noexcept;

	/** Returns the region of this component that's not obscured by other, opaque components.

		The RectangleList that is returned represents the area of this component
		which isn't covered by opaque child components.

		If includeSiblings is true, it will also take into account any siblings
		that may be overlapping the component.
	*/
	void getVisibleArea (RectangleList& result, bool includeSiblings) const;

	/** Returns this component's x coordinate relative the the screen's top-left origin.
		@see getX, localPointToGlobal
	*/
	int getScreenX() const;

	/** Returns this component's y coordinate relative the the screen's top-left origin.
		@see getY, localPointToGlobal
	*/
	int getScreenY() const;

	/** Returns the position of this component's top-left corner relative to the screen's top-left.
		@see getScreenBounds
	*/
	Point<int> getScreenPosition() const;

	/** Returns the bounds of this component, relative to the screen's top-left.
		@see getScreenPosition
	*/
	Rectangle<int> getScreenBounds() const;

	/** Converts a point to be relative to this component's coordinate space.

		This takes a point relative to a different component, and returns its position relative to this
		component. If the sourceComponent parameter is null, the source point is assumed to be a global
		screen coordinate.
	*/
	Point<int> getLocalPoint (const Component* sourceComponent,
							  const Point<int>& pointRelativeToSourceComponent) const;

	/** Converts a rectangle to be relative to this component's coordinate space.

		This takes a rectangle that is relative to a different component, and returns its position relative
		to this component. If the sourceComponent parameter is null, the source rectangle is assumed to be
		a screen coordinate.

		If you've used setTransform() to apply one or more transforms to components, then the source rectangle
		may not actually be rectanglular when converted to the target space, so in that situation this will return
		the smallest rectangle that fully contains the transformed area.
	*/
	Rectangle<int> getLocalArea (const Component* sourceComponent,
								 const Rectangle<int>& areaRelativeToSourceComponent) const;

	/** Converts a point relative to this component's top-left into a screen coordinate.
		@see getLocalPoint, localAreaToGlobal
	*/
	Point<int> localPointToGlobal (const Point<int>& localPoint) const;

	/** Converts a rectangle from this component's coordinate space to a screen coordinate.

		If you've used setTransform() to apply one or more transforms to components, then the source rectangle
		may not actually be rectanglular when converted to the target space, so in that situation this will return
		the smallest rectangle that fully contains the transformed area.
		@see getLocalPoint, localPointToGlobal
	*/
	Rectangle<int> localAreaToGlobal (const Rectangle<int>& localArea) const;

	/** Moves the component to a new position.

		Changes the component's top-left position (without changing its size).
		The position is relative to the top-left of the component's parent.

		If the component actually moves, this method will make a synchronous call to moved().

		Note that if you've used setTransform() to apply a transform, then the component's
		bounds will no longer be a direct reflection of the position at which it appears within
		its parent, as the transform will be applied to whatever bounds you set for it.

		@see setBounds, ComponentListener::componentMovedOrResized
	*/
	void setTopLeftPosition (int x, int y);

	/** Moves the component to a new position.

		Changes the component's top-left position (without changing its size).
		The position is relative to the top-left of the component's parent.

		If the component actually moves, this method will make a synchronous call to moved().

		Note that if you've used setTransform() to apply a transform, then the component's
		bounds will no longer be a direct reflection of the position at which it appears within
		its parent, as the transform will be applied to whatever bounds you set for it.

		@see setBounds, ComponentListener::componentMovedOrResized
	*/
	void setTopLeftPosition (const Point<int>& newTopLeftPosition);

	/** Moves the component to a new position.

		Changes the position of the component's top-right corner (keeping it the same size).
		The position is relative to the top-left of the component's parent.

		If the component actually moves, this method will make a synchronous call to moved().

		Note that if you've used setTransform() to apply a transform, then the component's
		bounds will no longer be a direct reflection of the position at which it appears within
		its parent, as the transform will be applied to whatever bounds you set for it.
	*/
	void setTopRightPosition (int x, int y);

	/** Changes the size of the component.

		A synchronous call to resized() will be occur if the size actually changes.

		Note that if you've used setTransform() to apply a transform, then the component's
		bounds will no longer be a direct reflection of the position at which it appears within
		its parent, as the transform will be applied to whatever bounds you set for it.
	*/
	void setSize (int newWidth, int newHeight);

	/** Changes the component's position and size.

		The coordinates are relative to the top-left of the component's parent, or relative
		to the origin of the screen is the component is on the desktop.

		If this method changes the component's top-left position, it will make a synchronous
		call to moved(). If it changes the size, it will also make a call to resized().

		Note that if you've used setTransform() to apply a transform, then the component's
		bounds will no longer be a direct reflection of the position at which it appears within
		its parent, as the transform will be applied to whatever bounds you set for it.

		@see setTopLeftPosition, setSize, ComponentListener::componentMovedOrResized
	*/
	void setBounds (int x, int y, int width, int height);

	/** Changes the component's position and size.

		The coordinates are relative to the top-left of the component's parent, or relative
		to the origin of the screen is the component is on the desktop.

		If this method changes the component's top-left position, it will make a synchronous
		call to moved(). If it changes the size, it will also make a call to resized().

		Note that if you've used setTransform() to apply a transform, then the component's
		bounds will no longer be a direct reflection of the position at which it appears within
		its parent, as the transform will be applied to whatever bounds you set for it.

		@see setBounds
	*/
	void setBounds (const Rectangle<int>& newBounds);

	/** Changes the component's position and size.

		This is similar to the other setBounds() methods, but uses RelativeRectangle::applyToComponent()
		to set the position, This uses a Component::Positioner to make sure that any dynamic
		expressions are used in the RelativeRectangle will be automatically re-applied to the
		component's bounds when the source values change. See RelativeRectangle::applyToComponent()
		for more details.

		When using relative expressions, the following symbols are available:
		 - "left", "right", "top", "bottom" refer to the position of those edges in this component, so
		   e.g. for a component whose width is always 100, you might set the right edge to the "left + 100".
		 - "[id].left", "[id].right", "[id].top", "[id].bottom", "[id].width", "[id].height", where [id] is
		   the identifier of one of this component's siblings. A component's identifier is set with
		   Component::setComponentID(). So for example if you want your component to always be 50 pixels to the
		   right of the one called "xyz", you could set your left edge to be "xyz.right + 50".
		 - Instead of an [id], you can use the name "parent" to refer to this component's parent. Like
		   any other component, these values are relative to their component's parent, so "parent.right" won't be
		   very useful for positioning a component because it refers to a position with the parent's parent.. but
		   "parent.width" can be used for setting positions relative to the parent's size. E.g. to make a 10x10
		   component which remains 1 pixel away from its parent's bottom-right, you could use
		   "right - 10, bottom - 10, parent.width - 1, parent.height - 1".
		 - The name of one of the parent component's markers can also be used as a symbol. For markers to be
		   used, the parent component must implement its Component::getMarkers() method, and return at least one
		   valid MarkerList. So if you want your component's top edge to be 10 pixels below the
		   marker called "foobar", you'd set it to "foobar + 10".

		See the Expression class for details about the operators that are supported, but for example
		if you wanted to make your component remain centred within its parent with a size of 100, 100,
		you could express it as:
		@code myComp.setBounds (RelativeBounds ("parent.width / 2 - 50, parent.height / 2 - 50, left + 100, top + 100"));
		@endcode
		..or an alternative way to achieve the same thing:
		@code myComp.setBounds (RelativeBounds ("right - 100, bottom - 100, parent.width / 2 + 50, parent.height / 2 + 50"));
		@endcode

		Or if you wanted a 100x100 component whose top edge is lined up to a marker called "topMarker" and
		which is positioned 50 pixels to the right of another component called "otherComp", you could write:
		@code myComp.setBounds (RelativeBounds ("otherComp.right + 50, topMarker, left + 100, top + 100"));
		@endcode

		Be careful not to make your coordinate expressions recursive, though, or exceptions and assertions will
		be thrown!

		@see setBounds, RelativeRectangle::applyToComponent(), Expression
	*/
	void setBounds (const RelativeRectangle& newBounds);

	/** Sets the component's bounds with an expression.
		The string is parsed as a RelativeRectangle expression - see the notes for
		Component::setBounds (const RelativeRectangle&) for more information. This method is
		basically just a shortcut for writing setBounds (RelativeRectangle ("..."))
	*/
	void setBounds (const String& newBoundsExpression);

	/** Changes the component's position and size in terms of fractions of its parent's size.

		The values are factors of the parent's size, so for example
		setBoundsRelative (0.2f, 0.2f, 0.5f, 0.5f) would give it half the
		width and height of the parent, with its top-left position 20% of
		the way across and down the parent.

		@see setBounds
	*/
	void setBoundsRelative (float proportionalX, float proportionalY,
							float proportionalWidth, float proportionalHeight);

	/** Changes the component's position and size based on the amount of space to leave around it.

		This will position the component within its parent, leaving the specified number of
		pixels around each edge.

		@see setBounds
	*/
	void setBoundsInset (const BorderSize<int>& borders);

	/** Positions the component within a given rectangle, keeping its proportions
		unchanged.

		If onlyReduceInSize is false, the component will be resized to fill as much of the
		rectangle as possible without changing its aspect ratio (the component's
		current size is used to determine its aspect ratio, so a zero-size component
		won't work here). If onlyReduceInSize is true, it will only be resized if it's
		too big to fit inside the rectangle.

		It will then be positioned within the rectangle according to the justification flags
		specified.

		@see setBounds
	*/
	void setBoundsToFit (int x, int y, int width, int height,
						 const Justification& justification,
						 bool onlyReduceInSize);

	/** Changes the position of the component's centre.

		Leaves the component's size unchanged, but sets the position of its centre
		relative to its parent's top-left.

		@see setBounds
	*/
	void setCentrePosition (int x, int y);

	/** Changes the position of the component's centre.

		Leaves the position unchanged, but positions its centre relative to its
		parent's size. E.g. setCentreRelative (0.5f, 0.5f) would place it centrally in
		its parent.
	*/
	void setCentreRelative (float x, float y);

	/** Changes the component's size and centres it within its parent.

		After changing the size, the component will be moved so that it's
		centred within its parent. If the component is on the desktop (or has no
		parent component), then it'll be centred within the main monitor area.
	*/
	void centreWithSize (int width, int height);

	/** Sets a transform matrix to be applied to this component.

		If you set a transform for a component, the component's position will be warped by it, relative to
		the component's parent's top-left origin. This means that the values you pass into setBounds() will no
		longer reflect the actual area within the parent that the component covers, as the bounds will be
		transformed and the component will probably end up actually appearing somewhere else within its parent.

		When using transforms you need to be extremely careful when converting coordinates between the
		coordinate spaces of different components or the screen - you should always use getLocalPoint(),
		getLocalArea(), etc to do this, and never just manually add a component's position to a point in order to
		convert it between different components (but I'm sure you would never have done that anyway...).

		Currently, transforms are not supported for desktop windows, so the transform will be ignored if you
		put a component on the desktop.

		To remove a component's transform, simply pass AffineTransform::identity as the parameter to this method.
	*/
	void setTransform (const AffineTransform& transform);

	/** Returns the transform that is currently being applied to this component.
		For more details about transforms, see setTransform().
		@see setTransform
	*/
	AffineTransform getTransform() const;

	/** Returns true if a non-identity transform is being applied to this component.
		For more details about transforms, see setTransform().
		@see setTransform
	*/
	bool isTransformed() const noexcept;

	/** Returns a proportion of the component's width.

		This is a handy equivalent of (getWidth() * proportion).
	*/
	int proportionOfWidth (float proportion) const noexcept;

	/** Returns a proportion of the component's height.

		This is a handy equivalent of (getHeight() * proportion).
	*/
	int proportionOfHeight (float proportion) const noexcept;

	/** Returns the width of the component's parent.

		If the component has no parent (i.e. if it's on the desktop), this will return
		the width of the screen.
	*/
	int getParentWidth() const noexcept;

	/** Returns the height of the component's parent.

		If the component has no parent (i.e. if it's on the desktop), this will return
		the height of the screen.
	*/
	int getParentHeight() const noexcept;

	/** Returns the screen coordinates of the monitor that contains this component.

		If there's only one monitor, this will return its size - if there are multiple
		monitors, it will return the area of the monitor that contains the component's
		centre.
	*/
	Rectangle<int> getParentMonitorArea() const;

	/** Returns the number of child components that this component contains.

		@see getChildComponent, getIndexOfChildComponent
	*/
	int getNumChildComponents() const noexcept;

	/** Returns one of this component's child components, by it index.

		The component with index 0 is at the back of the z-order, the one at the
		front will have index (getNumChildComponents() - 1).

		If the index is out-of-range, this will return a null pointer.

		@see getNumChildComponents, getIndexOfChildComponent
	*/
	Component* getChildComponent (int index) const noexcept;

	/** Returns the index of this component in the list of child components.

		A value of 0 means it is first in the list (i.e. behind all other components). Higher
		values are further towards the front.

		Returns -1 if the component passed-in is not a child of this component.

		@see getNumChildComponents, getChildComponent, addChildComponent, toFront, toBack, toBehind
	*/
	int getIndexOfChildComponent (const Component* child) const noexcept;

	/** Looks for a child component with the specified ID.
		@see setComponentID, getComponentID
	*/
	Component* findChildWithID (const String& componentID) const noexcept;

	/** Adds a child component to this one.

		Adding a child component does not mean that the component will own or delete the child - it's
		your responsibility to delete the component. Note that it's safe to delete a component
		without first removing it from its parent - doing so will automatically remove it and
		send out the appropriate notifications before the deletion completes.

		If the child is already a child of this component, then no action will be taken, and its
		z-order will be left unchanged.

		@param child    the new component to add. If the component passed-in is already
						the child of another component, it'll first be removed from it current parent.
		@param zOrder   The index in the child-list at which this component should be inserted.
						A value of -1 will insert it in front of the others, 0 is the back.
		@see removeChildComponent, addAndMakeVisible, addChildAndSetID, getChild, ComponentListener::componentChildrenChanged
	*/
	void addChildComponent (Component* child, int zOrder = -1);

	/** Adds a child component to this one, and also makes the child visible if it isn't.

		Quite a useful function, this is just the same as calling setVisible (true) on the child
		and then addChildComponent(). See addChildComponent() for more details.
	*/
	void addAndMakeVisible (Component* child, int zOrder = -1);

	/** Adds a child component to this one, makes it visible, and sets its component ID.
		@see addAndMakeVisible, addChildComponent
	*/
	void addChildAndSetID (Component* child, const String& componentID);

	/** Removes one of this component's child-components.

		If the child passed-in isn't actually a child of this component (either because
		it's invalid or is the child of a different parent), then no action is taken.

		Note that removing a child will not delete it! But it's ok to delete a component
		without first removing it - doing so will automatically remove it and send out the
		appropriate notifications before the deletion completes.

		@see addChildComponent, ComponentListener::componentChildrenChanged
	*/
	void removeChildComponent (Component* childToRemove);

	/** Removes one of this component's child-components by index.

		This will return a pointer to the component that was removed, or null if
		the index was out-of-range.

		Note that removing a child will not delete it! But it's ok to delete a component
		without first removing it - doing so will automatically remove it and send out the
		appropriate notifications before the deletion completes.

		@see addChildComponent, ComponentListener::componentChildrenChanged
	*/
	Component* removeChildComponent (int childIndexToRemove);

	/** Removes all this component's children.

		Note that this won't delete them! To do that, use deleteAllChildren() instead.
	*/
	void removeAllChildren();

	/** Removes all this component's children, and deletes them.

		@see removeAllChildren
	*/
	void deleteAllChildren();

	/** Returns the component which this component is inside.

		If this is the highest-level component or hasn't yet been added to
		a parent, this will return null.
	*/
	Component* getParentComponent() const noexcept                  { return parentComponent; }

	/** Searches the parent components for a component of a specified class.

		For example findParentComponentOfClass \<MyComp\>() would return the first parent
		component that can be dynamically cast to a MyComp, or will return 0 if none
		of the parents are suitable.

		N.B. The dummy parameter is needed to work around a VC6 compiler bug.
	*/
	template <class TargetClass>
	TargetClass* findParentComponentOfClass (TargetClass* const dummyParameter = nullptr) const
	{
		(void) dummyParameter;
		Component* p = parentComponent;
		while (p != nullptr)
		{
			TargetClass* target = dynamic_cast <TargetClass*> (p);
			if (target != nullptr)
				return target;

			p = p->parentComponent;
		}

		return nullptr;
	}

	/** Returns the highest-level component which contains this one or its parents.

		This will search upwards in the parent-hierarchy from this component, until it
		finds the highest one that doesn't have a parent (i.e. is on the desktop or
		not yet added to a parent), and will return that.
	*/
	Component* getTopLevelComponent() const noexcept;

	/** Checks whether a component is anywhere inside this component or its children.

		This will recursively check through this component's children to see if the
		given component is anywhere inside.
	*/
	bool isParentOf (const Component* possibleChild) const noexcept;

	/** Called to indicate that the component's parents have changed.

		When a component is added or removed from its parent, this method will
		be called on all of its children (recursively - so all children of its
		children will also be called as well).

		Subclasses can override this if they need to react to this in some way.

		@see getParentComponent, isShowing, ComponentListener::componentParentHierarchyChanged
	*/
	virtual void parentHierarchyChanged();

	/** Subclasses can use this callback to be told when children are added or removed.

		@see parentHierarchyChanged
	*/
	virtual void childrenChanged();

	/** Tests whether a given point inside the component.

		Overriding this method allows you to create components which only intercept
		mouse-clicks within a user-defined area.

		This is called to find out whether a particular x, y coordinate is
		considered to be inside the component or not, and is used by methods such
		as contains() and getComponentAt() to work out which component
		the mouse is clicked on.

		Components with custom shapes will probably want to override it to perform
		some more complex hit-testing.

		The default implementation of this method returns either true or false,
		depending on the value that was set by calling setInterceptsMouseClicks() (true
		is the default return value).

		Note that the hit-test region is not related to the opacity with which
		areas of a component are painted.

		Applications should never call hitTest() directly - instead use the
		contains() method, because this will also test for occlusion by the
		component's parent.

		Note that for components on the desktop, this method will be ignored, because it's
		not always possible to implement this behaviour on all platforms.

		@param x    the x coordinate to test, relative to the left hand edge of this
					component. This value is guaranteed to be greater than or equal to
					zero, and less than the component's width
		@param y    the y coordinate to test, relative to the top edge of this
					component. This value is guaranteed to be greater than or equal to
					zero, and less than the component's height
		@returns    true if the click is considered to be inside the component
		@see setInterceptsMouseClicks, contains
	*/
	virtual bool hitTest (int x, int y);

	/** Changes the default return value for the hitTest() method.

		Setting this to false is an easy way to make a component pass its mouse-clicks
		through to the components behind it.

		When a component is created, the default setting for this is true.

		@param allowClicksOnThisComponent   if true, hitTest() will always return true; if false, it will
											return false (or true for child components if allowClicksOnChildComponents
											is true)
		@param allowClicksOnChildComponents if this is true and allowClicksOnThisComponent is false, then child
											components can be clicked on as normal but clicks on this component pass
											straight through; if this is false and allowClicksOnThisComponent
											is false, then neither this component nor any child components can
											be clicked on
		@see hitTest, getInterceptsMouseClicks
	*/
	void setInterceptsMouseClicks (bool allowClicksOnThisComponent,
								   bool allowClicksOnChildComponents) noexcept;

	/** Retrieves the current state of the mouse-click interception flags.

		On return, the two parameters are set to the state used in the last call to
		setInterceptsMouseClicks().

		@see setInterceptsMouseClicks
	*/
	void getInterceptsMouseClicks (bool& allowsClicksOnThisComponent,
								   bool& allowsClicksOnChildComponents) const noexcept;

	/** Returns true if a given point lies within this component or one of its children.

		Never override this method! Use hitTest to create custom hit regions.

		@param localPoint    the coordinate to test, relative to this component's top-left.
		@returns    true if the point is within the component's hit-test area, but only if
					that part of the component isn't clipped by its parent component. Note
					that this won't take into account any overlapping sibling components
					which might be in the way - for that, see reallyContains()
		@see hitTest, reallyContains, getComponentAt
	*/
	bool contains (const Point<int>& localPoint);

	/** Returns true if a given point lies in this component, taking any overlapping
		siblings into account.

		@param localPoint    the coordinate to test, relative to this component's top-left.
		@param returnTrueIfWithinAChild     if the point actually lies within a child of this component,
											this determines whether that is counted as a hit.
		@see contains, getComponentAt
	*/
	bool reallyContains (const Point<int>& localPoint, bool returnTrueIfWithinAChild);

	/** Returns the component at a certain point within this one.

		@param x    the x coordinate to test, relative to this component's left edge.
		@param y    the y coordinate to test, relative to this component's top edge.
		@returns    the component that is at this position - which may be 0, this component,
					or one of its children. Note that overlapping siblings that might actually
					be in the way are not taken into account by this method - to account for these,
					instead call getComponentAt on the top-level parent of this component.
		@see hitTest, contains, reallyContains
	*/
	Component* getComponentAt (int x, int y);

	/** Returns the component at a certain point within this one.

		@param position  the coordinate to test, relative to this component's top-left.
		@returns    the component that is at this position - which may be 0, this component,
					or one of its children. Note that overlapping siblings that might actually
					be in the way are not taken into account by this method - to account for these,
					instead call getComponentAt on the top-level parent of this component.
		@see hitTest, contains, reallyContains
	*/
	Component* getComponentAt (const Point<int>& position);

	/** Marks the whole component as needing to be redrawn.

		Calling this will not do any repainting immediately, but will mark the component
		as 'dirty'. At some point in the near future the operating system will send a paint
		message, which will redraw all the dirty regions of all components.
		There's no guarantee about how soon after calling repaint() the redraw will actually
		happen, and other queued events may be delivered before a redraw is done.

		If the setBufferedToImage() method has been used to cause this component to use a
		buffer, the repaint() call will invalidate the cached buffer. If setCachedComponentImage()
		has been used to provide a custom image cache, that cache will be invalidated appropriately.

		To redraw just a subsection of the component rather than the whole thing,
		use the repaint (int, int, int, int) method.

		@see paint
	*/
	void repaint();

	/** Marks a subsection of this component as needing to be redrawn.

		Calling this will not do any repainting immediately, but will mark the given region
		of the component as 'dirty'. At some point in the near future the operating system
		will send a paint message, which will redraw all the dirty regions of all components.
		There's no guarantee about how soon after calling repaint() the redraw will actually
		happen, and other queued events may be delivered before a redraw is done.

		The region that is passed in will be clipped to keep it within the bounds of this
		component.

		@see repaint()
	*/
	void repaint (int x, int y, int width, int height);

	/** Marks a subsection of this component as needing to be redrawn.

		Calling this will not do any repainting immediately, but will mark the given region
		of the component as 'dirty'. At some point in the near future the operating system
		will send a paint message, which will redraw all the dirty regions of all components.
		There's no guarantee about how soon after calling repaint() the redraw will actually
		happen, and other queued events may be delivered before a redraw is done.

		The region that is passed in will be clipped to keep it within the bounds of this
		component.

		@see repaint()
	*/
	void repaint (const Rectangle<int>& area);

	/** Makes the component use an internal buffer to optimise its redrawing.

		Setting this flag to true will cause the component to allocate an
		internal buffer into which it paints itself, so that when asked to
		redraw itself, it can use this buffer rather than actually calling the
		paint() method.

		The buffer is kept until the repaint() method is called directly on
		this component (or until it is resized), when the image is invalidated
		and then redrawn the next time the component is painted.

		Note that only the drawing that happens within the component's paint()
		method is drawn into the buffer, it's child components are not buffered, and
		nor is the paintOverChildren() method.

		@see repaint, paint, createComponentSnapshot
	*/
	void setBufferedToImage (bool shouldBeBuffered);

	/** Generates a snapshot of part of this component.

		This will return a new Image, the size of the rectangle specified,
		containing a snapshot of the specified area of the component and all
		its children.

		The image may or may not have an alpha-channel, depending on whether the
		image is opaque or not.

		If the clipImageToComponentBounds parameter is true and the area is greater than
		the size of the component, it'll be clipped. If clipImageToComponentBounds is false
		then parts of the component beyond its bounds can be drawn.

		@see paintEntireComponent
	*/
	Image createComponentSnapshot (const Rectangle<int>& areaToGrab,
								   bool clipImageToComponentBounds = true);

	/** Draws this component and all its subcomponents onto the specified graphics
		context.

		You should very rarely have to use this method, it's simply there in case you need
		to draw a component with a custom graphics context for some reason, e.g. for
		creating a snapshot of the component.

		It calls paint(), paintOverChildren() and recursively calls paintEntireComponent()
		on its children in order to render the entire tree.

		The graphics context may be left in an undefined state after this method returns,
		so you may need to reset it if you're going to use it again.

		If ignoreAlphaLevel is false, then the component will be drawn with the opacity level
		specified by getAlpha(); if ignoreAlphaLevel is true, then this will be ignored and
		an alpha of 1.0 will be used.
	*/
	void paintEntireComponent (Graphics& context, bool ignoreAlphaLevel);

	/** This allows you to indicate that this component doesn't require its graphics
		context to be clipped when it is being painted.

		Most people will never need to use this setting, but in situations where you have a very large
		number of simple components being rendered, and where they are guaranteed never to do any drawing
		beyond their own boundaries, setting this to true will reduce the overhead involved in clipping
		the graphics context that gets passed to the component's paint() callback.
		If you enable this mode, you'll need to make sure your paint method doesn't call anything like
		Graphics::fillAll(), and doesn't draw beyond the component's bounds, because that'll produce
		artifacts. Your component also can't have any child components that may be placed beyond its
		bounds.
	*/
	void setPaintingIsUnclipped (bool shouldPaintWithoutClipping) noexcept;

	/** Adds an effect filter to alter the component's appearance.

		When a component has an effect filter set, then this is applied to the
		results of its paint() method. There are a few preset effects, such as
		a drop-shadow or glow, but they can be user-defined as well.

		The effect that is passed in will not be deleted by the component - the
		caller must take care of deleting it.

		To remove an effect from a component, pass a null pointer in as the parameter.

		@see ImageEffectFilter, DropShadowEffect, GlowEffect
	*/
	void setComponentEffect (ImageEffectFilter* newEffect);

	/** Returns the current component effect.

		@see setComponentEffect
	*/
	ImageEffectFilter* getComponentEffect() const noexcept              { return effect; }

	/** Finds the appropriate look-and-feel to use for this component.

		If the component hasn't had a look-and-feel explicitly set, this will
		return the parent's look-and-feel, or just the default one if there's no
		parent.

		@see setLookAndFeel, lookAndFeelChanged
	*/
	LookAndFeel& getLookAndFeel() const noexcept;

	/** Sets the look and feel to use for this component.

		This will also change the look and feel for any child components that haven't
		had their look set explicitly.

		The object passed in will not be deleted by the component, so it's the caller's
		responsibility to manage it. It may be used at any time until this component
		has been deleted.

		Calling this method will also invoke the sendLookAndFeelChange() method.

		@see getLookAndFeel, lookAndFeelChanged
	*/
	void setLookAndFeel (LookAndFeel* newLookAndFeel);

	/** Called to let the component react to a change in the look-and-feel setting.

		When the look-and-feel is changed for a component, this will be called in
		all its child components, recursively.

		It can also be triggered manually by the sendLookAndFeelChange() method, in case
		an application uses a LookAndFeel class that might have changed internally.

		@see sendLookAndFeelChange, getLookAndFeel
	*/
	virtual void lookAndFeelChanged();

	/** Calls the lookAndFeelChanged() method in this component and all its children.

		This will recurse through the children and their children, calling lookAndFeelChanged()
		on them all.

		@see lookAndFeelChanged
	*/
	void sendLookAndFeelChange();

	/** Indicates whether any parts of the component might be transparent.

		Components that always paint all of their contents with solid colour and
		thus completely cover any components behind them should use this method
		to tell the repaint system that they are opaque.

		This information is used to optimise drawing, because it means that
		objects underneath opaque windows don't need to be painted.

		By default, components are considered transparent, unless this is used to
		make it otherwise.

		@see isOpaque, getVisibleArea
	*/
	void setOpaque (bool shouldBeOpaque);

	/** Returns true if no parts of this component are transparent.

		@returns the value that was set by setOpaque, (the default being false)
		@see setOpaque
	*/
	bool isOpaque() const noexcept;

	/** Indicates whether the component should be brought to the front when clicked.

		Setting this flag to true will cause the component to be brought to the front
		when the mouse is clicked somewhere inside it or its child components.

		Note that a top-level desktop window might still be brought to the front by the
		operating system when it's clicked, depending on how the OS works.

		By default this is set to false.

		@see setMouseClickGrabsKeyboardFocus
	*/
	void setBroughtToFrontOnMouseClick (bool shouldBeBroughtToFront) noexcept;

	/** Indicates whether the component should be brought to the front when clicked-on.

		@see setBroughtToFrontOnMouseClick
	*/
	bool isBroughtToFrontOnMouseClick() const noexcept;

	// Keyboard focus methods

	/** Sets a flag to indicate whether this component needs keyboard focus or not.

		By default components aren't actually interested in gaining the
		focus, but this method can be used to turn this on.

		See the grabKeyboardFocus() method for details about the way a component
		is chosen to receive the focus.

		@see grabKeyboardFocus, getWantsKeyboardFocus
	*/
	void setWantsKeyboardFocus (bool wantsFocus) noexcept;

	/** Returns true if the component is interested in getting keyboard focus.

		This returns the flag set by setWantsKeyboardFocus(). The default
		setting is false.

		@see setWantsKeyboardFocus
	*/
	bool getWantsKeyboardFocus() const noexcept;

	/** Chooses whether a click on this component automatically grabs the focus.

		By default this is set to true, but you might want a component which can
		be focused, but where you don't want the user to be able to affect it directly
		by clicking.
	*/
	void setMouseClickGrabsKeyboardFocus (bool shouldGrabFocus);

	/** Returns the last value set with setMouseClickGrabsKeyboardFocus().

		See setMouseClickGrabsKeyboardFocus() for more info.
	*/
	bool getMouseClickGrabsKeyboardFocus() const noexcept;

	/** Tries to give keyboard focus to this component.

		When the user clicks on a component or its grabKeyboardFocus()
		method is called, the following procedure is used to work out which
		component should get it:

		- if the component that was clicked on actually wants focus (as indicated
		  by calling getWantsKeyboardFocus), it gets it.
		- if the component itself doesn't want focus, it will try to pass it
		  on to whichever of its children is the default component, as determined by
		  KeyboardFocusTraverser::getDefaultComponent()
		- if none of its children want focus at all, it will pass it up to its
		  parent instead, unless it's a top-level component without a parent,
		  in which case it just takes the focus itself.

		@see setWantsKeyboardFocus, getWantsKeyboardFocus, hasKeyboardFocus,
			 getCurrentlyFocusedComponent, focusGained, focusLost,
			 keyPressed, keyStateChanged
	*/
	void grabKeyboardFocus();

	/** Returns true if this component currently has the keyboard focus.

		@param trueIfChildIsFocused     if this is true, then the method returns true if
										either this component or any of its children (recursively)
										have the focus. If false, the method only returns true if
										this component has the focus.

		@see grabKeyboardFocus, setWantsKeyboardFocus, getCurrentlyFocusedComponent,
			 focusGained, focusLost
	*/
	bool hasKeyboardFocus (bool trueIfChildIsFocused) const;

	/** Returns the component that currently has the keyboard focus.

		@returns the focused component, or null if nothing is focused.
	*/
	static Component* JUCE_CALLTYPE getCurrentlyFocusedComponent() noexcept;

	/** Tries to move the keyboard focus to one of this component's siblings.

		This will try to move focus to either the next or previous component. (This
		is the method that is used when shifting focus by pressing the tab key).

		Components for which getWantsKeyboardFocus() returns false are not looked at.

		@param moveToNext   if true, the focus will move forwards; if false, it will
							move backwards
		@see grabKeyboardFocus, setFocusContainer, setWantsKeyboardFocus
	*/
	void moveKeyboardFocusToSibling (bool moveToNext);

	/** Creates a KeyboardFocusTraverser object to use to determine the logic by
		which focus should be passed from this component.

		The default implementation of this method will return a default
		KeyboardFocusTraverser if this component is a focus container (as determined
		by the setFocusContainer() method). If the component isn't a focus
		container, then it will recursively ask its parents for a KeyboardFocusTraverser.

		If you overrride this to return a custom KeyboardFocusTraverser, then
		this component and all its sub-components will use the new object to
		make their focusing decisions.

		The method should return a new object, which the caller is required to
		delete when no longer needed.
	*/
	virtual KeyboardFocusTraverser* createFocusTraverser();

	/** Returns the focus order of this component, if one has been specified.

		By default components don't have a focus order - in that case, this
		will return 0. Lower numbers indicate that the component will be
		earlier in the focus traversal order.

		To change the order, call setExplicitFocusOrder().

		The focus order may be used by the KeyboardFocusTraverser class as part of
		its algorithm for deciding the order in which components should be traversed.
		See the KeyboardFocusTraverser class for more details on this.

		@see moveKeyboardFocusToSibling, createFocusTraverser, KeyboardFocusTraverser
	*/
	int getExplicitFocusOrder() const;

	/** Sets the index used in determining the order in which focusable components
		should be traversed.

		A value of 0 or less is taken to mean that no explicit order is wanted, and
		that traversal should use other factors, like the component's position.

		@see getExplicitFocusOrder, moveKeyboardFocusToSibling
	*/
	void setExplicitFocusOrder (int newFocusOrderIndex);

	/** Indicates whether this component is a parent for components that can have
		their focus traversed.

		This flag is used by the default implementation of the createFocusTraverser()
		method, which uses the flag to find the first parent component (of the currently
		focused one) which wants to be a focus container.

		So using this method to set the flag to 'true' causes this component to
		act as the top level within which focus is passed around.

		@see isFocusContainer, createFocusTraverser, moveKeyboardFocusToSibling
	*/
	void setFocusContainer (bool shouldBeFocusContainer) noexcept;

	/** Returns true if this component has been marked as a focus container.

		See setFocusContainer() for more details.

		@see setFocusContainer, moveKeyboardFocusToSibling, createFocusTraverser
	*/
	bool isFocusContainer() const noexcept;

	/** Returns true if the component (and all its parents) are enabled.

		Components are enabled by default, and can be disabled with setEnabled(). Exactly
		what difference this makes to the component depends on the type. E.g. buttons
		and sliders will choose to draw themselves differently, etc.

		Note that if one of this component's parents is disabled, this will always
		return false, even if this component itself is enabled.

		@see setEnabled, enablementChanged
	*/
	bool isEnabled() const noexcept;

	/** Enables or disables this component.

		Disabling a component will also cause all of its child components to become
		disabled.

		Similarly, enabling a component which is inside a disabled parent
		component won't make any difference until the parent is re-enabled.

		@see isEnabled, enablementChanged
	*/
	void setEnabled (bool shouldBeEnabled);

	/** Callback to indicate that this component has been enabled or disabled.

		This can be triggered by one of the component's parent components
		being enabled or disabled, as well as changes to the component itself.

		The default implementation of this method does nothing; your class may
		wish to repaint itself or something when this happens.

		@see setEnabled, isEnabled
	*/
	virtual void enablementChanged();

	/** Changes the transparency of this component.
		When painted, the entire component and all its children will be rendered
		with this as the overall opacity level, where 0 is completely invisible, and
		1.0 is fully opaque (i.e. normal).

		@see getAlpha
	*/
	void setAlpha (float newAlpha);

	/** Returns the component's current transparancy level.
		See setAlpha() for more details.
	*/
	float getAlpha() const;

	/** Changes the mouse cursor shape to use when the mouse is over this component.

		Note that the cursor set by this method can be overridden by the getMouseCursor
		method.

		@see MouseCursor
	*/
	void setMouseCursor (const MouseCursor& cursorType);

	/** Returns the mouse cursor shape to use when the mouse is over this component.

		The default implementation will return the cursor that was set by setCursor()
		but can be overridden for more specialised purposes, e.g. returning different
		cursors depending on the mouse position.

		@see MouseCursor
	*/
	virtual MouseCursor getMouseCursor();

	/** Forces the current mouse cursor to be updated.

		If you're overriding the getMouseCursor() method to control which cursor is
		displayed, then this will only be checked each time the user moves the mouse. So
		if you want to force the system to check that the cursor being displayed is
		up-to-date (even if the mouse is just sitting there), call this method.

		(If you're changing the cursor using setMouseCursor(), you don't need to bother
		calling this).
	*/
	void updateMouseCursor() const;

	/** Components can override this method to draw their content.

		The paint() method gets called when a region of a component needs redrawing,
		either because the component's repaint() method has been called, or because
		something has happened on the screen that means a section of a window needs
		to be redrawn.

		Any child components will draw themselves over whatever this method draws. If
		you need to paint over the top of your child components, you can also implement
		the paintOverChildren() method to do this.

		If you want to cause a component to redraw itself, this is done asynchronously -
		calling the repaint() method marks a region of the component as "dirty", and the
		paint() method will automatically be called sometime later, by the message thread,
		to paint any bits that need refreshing. In Juce (and almost all modern UI frameworks),
		you never redraw something synchronously.

		You should never need to call this method directly - to take a snapshot of the
		component you could use createComponentSnapshot() or paintEntireComponent().

		@param g    the graphics context that must be used to do the drawing operations.
		@see repaint, paintOverChildren, Graphics
	*/
	virtual void paint (Graphics& g);

	/** Components can override this method to draw over the top of their children.

		For most drawing operations, it's better to use the normal paint() method,
		but if you need to overlay something on top of the children, this can be
		used.

		@see paint, Graphics
	*/
	virtual void paintOverChildren (Graphics& g);

	/** Called when the mouse moves inside this component.

		If the mouse button isn't pressed and the mouse moves over a component,
		this will be called to let the component react to this.

		A component will always get a mouseEnter callback before a mouseMove.

		@param e    details about the position and status of the mouse event
		@see mouseEnter, mouseExit, mouseDrag, contains
	*/
	virtual void mouseMove         (const MouseEvent& e);

	/** Called when the mouse first enters this component.

		If the mouse button isn't pressed and the mouse moves into a component,
		this will be called to let the component react to this.

		When the mouse button is pressed and held down while being moved in
		or out of a component, no mouseEnter or mouseExit callbacks are made - only
		mouseDrag messages are sent to the component that the mouse was originally
		clicked on, until the button is released.

		If you're writing a component that needs to repaint itself when the mouse
		enters and exits, it might be quicker to use the setRepaintsOnMouseActivity()
		method.

		@param e    details about the position and status of the mouse event
		@see mouseExit, mouseDrag, mouseMove, contains
	*/
	virtual void mouseEnter        (const MouseEvent& e);

	/** Called when the mouse moves out of this component.

		This will be called when the mouse moves off the edge of this
		component.

		If the mouse button was pressed, and it was then dragged off the
		edge of the component and released, then this callback will happen
		when the button is released, after the mouseUp callback.

		If you're writing a component that needs to repaint itself when the mouse
		enters and exits, it might be quicker to use the setRepaintsOnMouseActivity()
		method.

		@param e    details about the position and status of the mouse event
		@see mouseEnter, mouseDrag, mouseMove, contains
	*/
	virtual void mouseExit         (const MouseEvent& e);

	/** Called when a mouse button is pressed while it's over this component.

		The MouseEvent object passed in contains lots of methods for finding out
		which button was pressed, as well as which modifier keys (e.g. shift, ctrl)
		were held down at the time.

		Once a button is held down, the mouseDrag method will be called when the
		mouse moves, until the button is released.

		@param e    details about the position and status of the mouse event
		@see mouseUp, mouseDrag, mouseDoubleClick, contains
	*/
	virtual void mouseDown         (const MouseEvent& e);

	/** Called when the mouse is moved while a button is held down.

		When a mouse button is pressed inside a component, that component
		receives mouseDrag callbacks each time the mouse moves, even if the
		mouse strays outside the component's bounds.

		If you want to be able to drag things off the edge of a component
		and have the component scroll when you get to the edges, the
		beginDragAutoRepeat() method might be useful.

		@param e    details about the position and status of the mouse event
		@see mouseDown, mouseUp, mouseMove, contains, beginDragAutoRepeat
	*/
	virtual void mouseDrag         (const MouseEvent& e);

	/** Called when a mouse button is released.

		A mouseUp callback is sent to the component in which a button was pressed
		even if the mouse is actually over a different component when the
		button is released.

		The MouseEvent object passed in contains lots of methods for finding out
		which buttons were down just before they were released.

		@param e    details about the position and status of the mouse event
		@see mouseDown, mouseDrag, mouseDoubleClick, contains
	*/
	virtual void mouseUp           (const MouseEvent& e);

	/** Called when a mouse button has been double-clicked in this component.

		The MouseEvent object passed in contains lots of methods for finding out
		which button was pressed, as well as which modifier keys (e.g. shift, ctrl)
		were held down at the time.

		For altering the time limit used to detect double-clicks,
		see MouseEvent::setDoubleClickTimeout.

		@param e    details about the position and status of the mouse event
		@see mouseDown, mouseUp, MouseEvent::setDoubleClickTimeout,
			 MouseEvent::getDoubleClickTimeout
	*/
	virtual void mouseDoubleClick  (const MouseEvent& e);

	/** Called when the mouse-wheel is moved.

		This callback is sent to the component that the mouse is over when the
		wheel is moved.

		If not overridden, the component will forward this message to its parent, so
		that parent components can collect mouse-wheel messages that happen to
		child components which aren't interested in them.

		@param e                details about the position and status of the mouse event
		@param wheelIncrementX   the speed and direction of the horizontal scroll-wheel - a positive
								 value means the wheel has been pushed to the right, negative means it
								 was pushed to the left
		@param wheelIncrementY   the speed and direction of the vertical scroll-wheel - a positive
								 value means the wheel has been pushed upwards, negative means it
								 was pushed downwards
	*/
	virtual void mouseWheelMove    (const MouseEvent& e,
									float wheelIncrementX,
									float wheelIncrementY);

	/** Ensures that a non-stop stream of mouse-drag events will be sent during the
		current mouse-drag operation.

		This allows you to make sure that mouseDrag() events are sent continuously, even
		when the mouse isn't moving. This can be useful for things like auto-scrolling
		components when the mouse is near an edge.

		Call this method during a mouseDown() or mouseDrag() callback, specifying the
		minimum interval between consecutive mouse drag callbacks. The callbacks
		will continue until the mouse is released, and then the interval will be reset,
		so you need to make sure it's called every time you begin a drag event.
		Passing an interval of 0 or less will cancel the auto-repeat.

		@see mouseDrag, Desktop::beginDragAutoRepeat
	*/
	static void beginDragAutoRepeat (int millisecondsBetweenCallbacks);

	/** Causes automatic repaints when the mouse enters or exits this component.

		If turned on, then when the mouse enters/exits, or when the button is pressed/released
		on the component, it will trigger a repaint.

		This is handy for things like buttons that need to draw themselves differently when
		the mouse moves over them, and it avoids having to override all the different mouse
		callbacks and call repaint().

		@see mouseEnter, mouseExit, mouseDown, mouseUp
	*/
	void setRepaintsOnMouseActivity (bool shouldRepaint) noexcept;

	/** Registers a listener to be told when mouse events occur in this component.

		If you need to get informed about mouse events in a component but can't or
		don't want to override its methods, you can attach any number of listeners
		to the component, and these will get told about the events in addition to
		the component's own callbacks being called.

		Note that a MouseListener can also be attached to more than one component.

		@param newListener                              the listener to register
		@param wantsEventsForAllNestedChildComponents   if true, the listener will receive callbacks
														for events that happen to any child component
														within this component, including deeply-nested
														child components. If false, it will only be
														told about events that this component handles.
		@see MouseListener, removeMouseListener
	*/
	void addMouseListener (MouseListener* newListener,
						   bool wantsEventsForAllNestedChildComponents);

	/** Deregisters a mouse listener.
		@see addMouseListener, MouseListener
	*/
	void removeMouseListener (MouseListener* listenerToRemove);

	/** Adds a listener that wants to hear about keypresses that this component receives.

		The listeners that are registered with a component are called by its keyPressed() or
		keyStateChanged() methods (assuming these haven't been overridden to do something else).

		If you add an object as a key listener, be careful to remove it when the object
		is deleted, or the component will be left with a dangling pointer.

		@see keyPressed, keyStateChanged, removeKeyListener
	*/
	void addKeyListener (KeyListener* newListener);

	/** Removes a previously-registered key listener.

		@see addKeyListener
	*/
	void removeKeyListener (KeyListener* listenerToRemove);

	/** Called when a key is pressed.

		When a key is pressed, the component that has the keyboard focus will have this
		method called. Remember that a component will only be given the focus if its
		setWantsKeyboardFocus() method has been used to enable this.

		If your implementation returns true, the event will be consumed and not passed
		on to any other listeners. If it returns false, the key will be passed to any
		KeyListeners that have been registered with this component. As soon as one of these
		returns true, the process will stop, but if they all return false, the event will
		be passed upwards to this component's parent, and so on.

		The default implementation of this method does nothing and returns false.

		@see keyStateChanged, getCurrentlyFocusedComponent, addKeyListener
	*/
	virtual bool keyPressed (const KeyPress& key);

	/** Called when a key is pressed or released.

		Whenever a key on the keyboard is pressed or released (including modifier keys
		like shift and ctrl), this method will be called on the component that currently
		has the keyboard focus. Remember that a component will only be given the focus if
		its setWantsKeyboardFocus() method has been used to enable this.

		If your implementation returns true, the event will be consumed and not passed
		on to any other listeners. If it returns false, then any KeyListeners that have
		been registered with this component will have their keyStateChanged methods called.
		As soon as one of these returns true, the process will stop, but if they all return
		false, the event will be passed upwards to this component's parent, and so on.

		The default implementation of this method does nothing and returns false.

		To find out which keys are up or down at any time, see the KeyPress::isKeyCurrentlyDown()
		method.

		@param isKeyDown    true if a key has been pressed; false if it has been released

		@see keyPressed, KeyPress, getCurrentlyFocusedComponent, addKeyListener
	*/
	virtual bool keyStateChanged (bool isKeyDown);

	/** Called when a modifier key is pressed or released.

		Whenever the shift, control, alt or command keys are pressed or released,
		this method will be called on the component that currently has the keyboard focus.
		Remember that a component will only be given the focus if its setWantsKeyboardFocus()
		method has been used to enable this.

		The default implementation of this method actually calls its parent's modifierKeysChanged
		method, so that focused components which aren't interested in this will give their
		parents a chance to act on the event instead.

		@see keyStateChanged, ModifierKeys
	*/
	virtual void modifierKeysChanged (const ModifierKeys& modifiers);

	/** Enumeration used by the focusChanged() and focusLost() methods. */
	enum FocusChangeType
	{
		focusChangedByMouseClick,   /**< Means that the user clicked the mouse to change focus. */
		focusChangedByTabKey,       /**< Means that the user pressed the tab key to move the focus. */
		focusChangedDirectly        /**< Means that the focus was changed by a call to grabKeyboardFocus(). */
	};

	/** Called to indicate that this component has just acquired the keyboard focus.

		@see focusLost, setWantsKeyboardFocus, getCurrentlyFocusedComponent, hasKeyboardFocus
	*/
	virtual void focusGained (FocusChangeType cause);

	/** Called to indicate that this component has just lost the keyboard focus.

		@see focusGained, setWantsKeyboardFocus, getCurrentlyFocusedComponent, hasKeyboardFocus
	*/
	virtual void focusLost (FocusChangeType cause);

	/** Called to indicate that one of this component's children has been focused or unfocused.

		Essentially this means that the return value of a call to hasKeyboardFocus (true) has
		changed. It happens when focus moves from one of this component's children (at any depth)
		to a component that isn't contained in this one, (or vice-versa).

		@see focusGained, setWantsKeyboardFocus, getCurrentlyFocusedComponent, hasKeyboardFocus
	*/
	virtual void focusOfChildComponentChanged (FocusChangeType cause);

	/** Returns true if the mouse is currently over this component.

		If the mouse isn't over the component, this will return false, even if the
		mouse is currently being dragged - so you can use this in your mouseDrag
		method to find out whether it's really over the component or not.

		Note that when the mouse button is being held down, then the only component
		for which this method will return true is the one that was originally
		clicked on.

		If includeChildren is true, then this will also return true if the mouse is over
		any of the component's children (recursively) as well as the component itself.

		@see isMouseButtonDown. isMouseOverOrDragging, mouseDrag
	*/
	bool isMouseOver (bool includeChildren = false) const;

	/** Returns true if the mouse button is currently held down in this component.

		Note that this is a test to see whether the mouse is being pressed in this
		component, so it'll return false if called on component A when the mouse
		is actually being dragged in component B.

		@see isMouseButtonDownAnywhere, isMouseOver, isMouseOverOrDragging
	*/
	bool isMouseButtonDown() const;

	/** True if the mouse is over this component, or if it's being dragged in this component.

		This is a handy equivalent to (isMouseOver() || isMouseButtonDown()).

		@see isMouseOver, isMouseButtonDown, isMouseButtonDownAnywhere
	*/
	bool isMouseOverOrDragging() const;

	/** Returns true if a mouse button is currently down.

		Unlike isMouseButtonDown, this will test the current state of the
		buttons without regard to which component (if any) it has been
		pressed in.

		@see isMouseButtonDown, ModifierKeys
	*/
	static bool JUCE_CALLTYPE isMouseButtonDownAnywhere() noexcept;

	/** Returns the mouse's current position, relative to this component.
		The return value is relative to the component's top-left corner.
	*/
	Point<int> getMouseXYRelative() const;

	/** Called when this component's size has been changed.

		A component can implement this method to do things such as laying out its
		child components when its width or height changes.

		The method is called synchronously as a result of the setBounds or setSize
		methods, so repeatedly changing a components size will repeatedly call its
		resized method (unlike things like repainting, where multiple calls to repaint
		are coalesced together).

		If the component is a top-level window on the desktop, its size could also
		be changed by operating-system factors beyond the application's control.

		@see moved, setSize
	*/
	virtual void resized();

	/** Called when this component's position has been changed.

		This is called when the position relative to its parent changes, not when
		its absolute position on the screen changes (so it won't be called for
		all child components when a parent component is moved).

		The method is called synchronously as a result of the setBounds, setTopLeftPosition
		or any of the other repositioning methods, and like resized(), it will be
		called each time those methods are called.

		If the component is a top-level window on the desktop, its position could also
		be changed by operating-system factors beyond the application's control.

		@see resized, setBounds
	*/
	virtual void moved();

	/** Called when one of this component's children is moved or resized.

		If the parent wants to know about changes to its immediate children (not
		to children of its children), this is the method to override.

		@see moved, resized, parentSizeChanged
	*/
	virtual void childBoundsChanged (Component* child);

	/** Called when this component's immediate parent has been resized.

		If the component is a top-level window, this indicates that the screen size
		has changed.

		@see childBoundsChanged, moved, resized
	*/
	virtual void parentSizeChanged();

	/** Called when this component has been moved to the front of its siblings.

		The component may have been brought to the front by the toFront() method, or
		by the operating system if it's a top-level window.

		@see toFront
	*/
	virtual void broughtToFront();

	/** Adds a listener to be told about changes to the component hierarchy or position.

		Component listeners get called when this component's size, position or children
		change - see the ComponentListener class for more details.

		@param newListener  the listener to register - if this is already registered, it
							will be ignored.
		@see ComponentListener, removeComponentListener
	*/
	void addComponentListener (ComponentListener* newListener);

	/** Removes a component listener.

		@see addComponentListener
	*/
	void removeComponentListener (ComponentListener* listenerToRemove);

	/** Dispatches a numbered message to this component.

		This is a quick and cheap way of allowing simple asynchronous messages to
		be sent to components. It's also safe, because if the component that you
		send the message to is a null or dangling pointer, this won't cause an error.

		The command ID is later delivered to the component's handleCommandMessage() method by
		the application's message queue.

		@see handleCommandMessage
	*/
	void postCommandMessage (int commandId);

	/** Called to handle a command that was sent by postCommandMessage().

		This is called by the message thread when a command message arrives, and
		the component can override this method to process it in any way it needs to.

		@see postCommandMessage
	*/
	virtual void handleCommandMessage (int commandId);

	/** Runs a component modally, waiting until the loop terminates.

		This method first makes the component visible, brings it to the front and
		gives it the keyboard focus.

		It then runs a loop, dispatching messages from the system message queue, but
		blocking all mouse or keyboard messages from reaching any components other
		than this one and its children.

		This loop continues until the component's exitModalState() method is called (or
		the component is deleted), and then this method returns, returning the value
		passed into exitModalState().

		@see enterModalState, exitModalState, isCurrentlyModal, getCurrentlyModalComponent,
			 isCurrentlyBlockedByAnotherModalComponent, ModalComponentManager
	*/
   #if JUCE_MODAL_LOOPS_PERMITTED
	int runModalLoop();
   #endif

	/** Puts the component into a modal state.

		This makes the component modal, so that messages are blocked from reaching
		any components other than this one and its children, but unlike runModalLoop(),
		this method returns immediately.

		If takeKeyboardFocus is true, the component will use grabKeyboardFocus() to
		get the focus, which is usually what you'll want it to do. If not, it will leave
		the focus unchanged.

		The callback is an optional object which will receive a callback when the modal
		component loses its modal status, either by being hidden or when exitModalState()
		is called. If you pass an object in here, the system will take care of deleting it
		later, after making the callback

		If deleteWhenDismissed is true, then when it is dismissed, the component will be
		deleted and then the callback will be called. (This will safely handle the situation
		where the component is deleted before its exitModalState() method is called).

		@see exitModalState, runModalLoop, ModalComponentManager::attachCallback
	*/
	void enterModalState (bool takeKeyboardFocus = true,
						  ModalComponentManager::Callback* callback = nullptr,
						  bool deleteWhenDismissed = false);

	/** Ends a component's modal state.

		If this component is currently modal, this will turn of its modalness, and return
		a value to the runModalLoop() method that might have be running its modal loop.

		@see runModalLoop, enterModalState, isCurrentlyModal
	*/
	void exitModalState (int returnValue);

	/** Returns true if this component is the modal one.

		It's possible to have nested modal components, e.g. a pop-up dialog box
		that launches another pop-up, but this will only return true for
		the one at the top of the stack.

		@see getCurrentlyModalComponent
	*/
	bool isCurrentlyModal() const noexcept;

	/** Returns the number of components that are currently in a modal state.
		@see getCurrentlyModalComponent
	 */
	static int JUCE_CALLTYPE getNumCurrentlyModalComponents() noexcept;

	/** Returns one of the components that are currently modal.

		The index specifies which of the possible modal components to return. The order
		of the components in this list is the reverse of the order in which they became
		modal - so the component at index 0 is always the active component, and the others
		are progressively earlier ones that are themselves now blocked by later ones.

		@returns the modal component, or null if no components are modal (or if the
				index is out of range)
		@see getNumCurrentlyModalComponents, runModalLoop, isCurrentlyModal
	*/
	static Component* JUCE_CALLTYPE getCurrentlyModalComponent (int index = 0) noexcept;

	/** Checks whether there's a modal component somewhere that's stopping this one
		from receiving messages.

		If there is a modal component, its canModalEventBeSentToComponent() method
		will be called to see if it will still allow this component to receive events.

		@see runModalLoop, getCurrentlyModalComponent
	*/
	bool isCurrentlyBlockedByAnotherModalComponent() const;

	/** When a component is modal, this callback allows it to choose which other
		components can still receive events.

		When a modal component is active and the user clicks on a non-modal component,
		this method is called on the modal component, and if it returns true, the
		event is allowed to reach its target. If it returns false, the event is blocked
		and the inputAttemptWhenModal() callback is made.

		It called by the isCurrentlyBlockedByAnotherModalComponent() method. The default
		implementation just returns false in all cases.
	*/
	virtual bool canModalEventBeSentToComponent (const Component* targetComponent);

	/** Called when the user tries to click on a component that is blocked by another
		modal component.

		When a component is modal and the user clicks on one of the other components,
		the modal component will receive this callback.

		The default implementation of this method will play a beep, and bring the currently
		modal component to the front, but it can be overridden to do other tasks.

		@see isCurrentlyBlockedByAnotherModalComponent, canModalEventBeSentToComponent
	*/
	virtual void inputAttemptWhenModal();

	/** Returns the set of properties that belong to this component.
		Each component has a NamedValueSet object which you can use to attach arbitrary
		items of data to it.
	*/
	NamedValueSet& getProperties() noexcept                             { return properties; }

	/** Returns the set of properties that belong to this component.
		Each component has a NamedValueSet object which you can use to attach arbitrary
		items of data to it.
	*/
	const NamedValueSet& getProperties() const noexcept                 { return properties; }

	/** Looks for a colour that has been registered with the given colour ID number.

		If a colour has been set for this ID number using setColour(), then it is
		returned. If none has been set, the method will try calling the component's
		LookAndFeel class's findColour() method. If none has been registered with the
		look-and-feel either, it will just return black.

		The colour IDs for various purposes are stored as enums in the components that
		they are relevent to - for an example, see Slider::ColourIds,
		Label::ColourIds, TextEditor::ColourIds, TreeView::ColourIds, etc.

		@see setColour, isColourSpecified, colourChanged, LookAndFeel::findColour, LookAndFeel::setColour
	*/
	Colour findColour (int colourId, bool inheritFromParent = false) const;

	/** Registers a colour to be used for a particular purpose.

		Changing a colour will cause a synchronous callback to the colourChanged()
		method, which your component can override if it needs to do something when
		colours are altered.

		For more details about colour IDs, see the comments for findColour().

		@see findColour, isColourSpecified, colourChanged, LookAndFeel::findColour, LookAndFeel::setColour
	*/
	void setColour (int colourId, const Colour& colour);

	/** If a colour has been set with setColour(), this will remove it.

		This allows you to make a colour revert to its default state.
	*/
	void removeColour (int colourId);

	/** Returns true if the specified colour ID has been explicitly set for this
		component using the setColour() method.
	*/
	bool isColourSpecified (int colourId) const;

	/** This looks for any colours that have been specified for this component,
		and copies them to the specified target component.
	*/
	void copyAllExplicitColoursTo (Component& target) const;

	/** This method is called when a colour is changed by the setColour() method.

		@see setColour, findColour
	*/
	virtual void colourChanged();

	/** Components can implement this method to provide a MarkerList.
		The default implementation of this method returns 0, but you can override it to
		return a pointer to the component's marker list. If xAxis is true, it should
		return the X marker list; if false, it should return the Y markers.
	*/
	virtual MarkerList* getMarkers (bool xAxis);

	/** Returns the underlying native window handle for this component.

		This is platform-dependent and strictly for power-users only!
	*/
	void* getWindowHandle() const;

	/** Holds a pointer to some type of Component, which automatically becomes null if
		the component is deleted.

		If you're using a component which may be deleted by another event that's outside
		of your control, use a SafePointer instead of a normal pointer to refer to it,
		and you can test whether it's null before using it to see if something has deleted
		it.

		The ComponentType typedef must be Component, or some subclass of Component.

		You may also want to use a WeakReference<Component> object for the same purpose.
	*/
	template <class ComponentType>
	class SafePointer
	{
	public:
		/** Creates a null SafePointer. */
		SafePointer() noexcept {}

		/** Creates a SafePointer that points at the given component. */
		SafePointer (ComponentType* const component)        : weakRef (component) {}

		/** Creates a copy of another SafePointer. */
		SafePointer (const SafePointer& other) noexcept     : weakRef (other.weakRef) {}

		/** Copies another pointer to this one. */
		SafePointer& operator= (const SafePointer& other)           { weakRef = other.weakRef; return *this; }

		/** Copies another pointer to this one. */
		SafePointer& operator= (ComponentType* const newComponent)  { weakRef = newComponent; return *this; }

		/** Returns the component that this pointer refers to, or null if the component no longer exists. */
		ComponentType* getComponent() const noexcept        { return dynamic_cast <ComponentType*> (weakRef.get()); }

		/** Returns the component that this pointer refers to, or null if the component no longer exists. */
		operator ComponentType*() const noexcept            { return getComponent(); }

		/** Returns the component that this pointer refers to, or null if the component no longer exists. */
		ComponentType* operator->() noexcept                { return getComponent(); }

		/** Returns the component that this pointer refers to, or null if the component no longer exists. */
		const ComponentType* operator->() const noexcept    { return getComponent(); }

		/** If the component is valid, this deletes it and sets this pointer to null. */
		void deleteAndZero()                                { delete getComponent(); jassert (getComponent() == nullptr); }

		bool operator== (ComponentType* component) const noexcept   { return weakRef == component; }
		bool operator!= (ComponentType* component) const noexcept   { return weakRef != component; }

	private:
		WeakReference<Component> weakRef;
	};

	/** A class to keep an eye on a component and check for it being deleted.

		This is designed for use with the ListenerList::callChecked() methods, to allow
		the list iterator to stop cleanly if the component is deleted by a listener callback
		while the list is still being iterated.
	*/
	class JUCE_API  BailOutChecker
	{
	public:
		/** Creates a checker that watches one component. */
		BailOutChecker (Component* component);

		/** Returns true if either of the two components have been deleted since this object was created. */
		bool shouldBailOut() const noexcept;

	private:
		const WeakReference<Component> safePointer;

		JUCE_DECLARE_NON_COPYABLE (BailOutChecker);
	};

	/**
		Base class for objects that can be used to automatically position a component according to
		some kind of algorithm.

		The component class simply holds onto a reference to a Positioner, but doesn't actually do
		anything with it - all the functionality must be implemented by the positioner itself (e.g.
		it might choose to watch some kind of value and move the component when the value changes).
	*/
	class JUCE_API  Positioner
	{
	public:
		/** Creates a Positioner which can control the specified component. */
		explicit Positioner (Component& component) noexcept;
		/** Destructor. */
		virtual ~Positioner() {}

		/** Returns the component that this positioner controls. */
		Component& getComponent() const noexcept    { return component; }

		/** Attempts to set the component's position to the given rectangle.
			Unlike simply calling Component::setBounds(), this may involve the positioner
			being smart enough to adjust itself to fit the new bounds, e.g. a RelativeRectangle's
			positioner may try to reverse the expressions used to make them fit these new coordinates.
		*/
		virtual void applyNewBounds (const Rectangle<int>& newBounds) = 0;

	private:
		Component& component;

		JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (Positioner);
	};

	/** Returns the Positioner object that has been set for this component.
		@see setPositioner()
	*/
	Positioner* getPositioner() const noexcept;

	/** Sets a new Positioner object for this component.
		If there's currently another positioner set, it will be deleted. The object that is passed in
		will be deleted automatically by this component when it's no longer required. Pass a null pointer
		to clear the current positioner.
		@see getPositioner()
	*/
	void setPositioner (Positioner* newPositioner);

	/** Gives the component a CachedComponentImage that should be used to buffer its painting.
		The object that is passed-in will be owned by this component, and will be deleted automatically
		later on.
		@see setBufferedToImage
	*/
	void setCachedComponentImage (CachedComponentImage* newCachedImage);

	/** Returns the object that was set by setCachedComponentImage().
		@see setCachedComponentImage
	*/
	CachedComponentImage* getCachedComponentImage() const noexcept  { return cachedImage; }

   #ifndef DOXYGEN
	// These methods are deprecated - use localPointToGlobal, getLocalPoint, getLocalPoint, etc instead.
	JUCE_DEPRECATED (Point<int> relativePositionToGlobal (const Point<int>&) const);
	JUCE_DEPRECATED (Point<int> globalPositionToRelative (const Point<int>&) const);
	JUCE_DEPRECATED (Point<int> relativePositionToOtherComponent (const Component*, const Point<int>&) const);
   #endif

private:

	friend class ComponentPeer;
	friend class MouseInputSource;
	friend class MouseInputSourceInternal;

   #ifndef DOXYGEN
	static Component* currentlyFocusedComponent;

	String componentName, componentID;
	Component* parentComponent;
	Rectangle<int> bounds;
	ScopedPointer <Positioner> positioner;
	ScopedPointer <AffineTransform> affineTransform;
	Array <Component*> childComponentList;
	LookAndFeel* lookAndFeel;
	MouseCursor cursor;
	ImageEffectFilter* effect;
	ScopedPointer <CachedComponentImage> cachedImage;

	class MouseListenerList;
	friend class MouseListenerList;
	friend class ScopedPointer <MouseListenerList>;
	ScopedPointer <MouseListenerList> mouseListeners;
	ScopedPointer <Array <KeyListener*> > keyListeners;
	ListenerList <ComponentListener> componentListeners;
	NamedValueSet properties;

	friend class WeakReference<Component>;
	WeakReference<Component>::Master masterReference;

	struct ComponentFlags
	{
		bool hasHeavyweightPeerFlag     : 1;
		bool visibleFlag                : 1;
		bool opaqueFlag                 : 1;
		bool ignoresMouseClicksFlag     : 1;
		bool allowChildMouseClicksFlag  : 1;
		bool wantsFocusFlag             : 1;
		bool isFocusContainerFlag       : 1;
		bool dontFocusOnMouseClickFlag  : 1;
		bool alwaysOnTopFlag            : 1;
		bool bufferToImageFlag          : 1;
		bool bringToFrontOnClickFlag    : 1;
		bool repaintOnMouseActivityFlag : 1;
		bool currentlyModalFlag         : 1;
		bool isDisabledFlag             : 1;
		bool childCompFocusedFlag       : 1;
		bool dontClipGraphicsFlag       : 1;
	  #if JUCE_DEBUG
		bool isInsidePaintCall          : 1;
	  #endif
	};

	union
	{
		uint32 componentFlags;
		ComponentFlags flags;
	};

	uint8 componentTransparency;

	void internalMouseEnter (MouseInputSource&, const Point<int>&, const Time&);
	void internalMouseExit  (MouseInputSource&, const Point<int>&, const Time&);
	void internalMouseDown  (MouseInputSource&, const Point<int>&, const Time&);
	void internalMouseUp    (MouseInputSource&, const Point<int>&, const Time&, const ModifierKeys& oldModifiers);
	void internalMouseDrag  (MouseInputSource&, const Point<int>&, const Time&);
	void internalMouseMove  (MouseInputSource&, const Point<int>&, const Time&);
	void internalMouseWheel (MouseInputSource&, const Point<int>&, const Time&, float amountX, float amountY);
	void internalBroughtToFront();
	void internalFocusGain (const FocusChangeType, const WeakReference<Component>&);
	void internalFocusGain (const FocusChangeType);
	void internalFocusLoss (const FocusChangeType);
	void internalChildFocusChange (FocusChangeType, const WeakReference<Component>&);
	void internalModalInputAttempt();
	void internalModifierKeysChanged();
	void internalChildrenChanged();
	void internalHierarchyChanged();
	void internalRepaint (const Rectangle<int>&);
	void internalRepaintUnchecked (const Rectangle<int>&, bool);
	Component* removeChildComponent (int index, bool sendParentEvents, bool sendChildEvents);
	void moveChildInternal (int sourceIndex, int destIndex);
	void paintComponentAndChildren (Graphics&);
	void paintWithinParentContext (Graphics&);
	void sendMovedResizedMessages (bool wasMoved, bool wasResized);
	void repaintParent();
	void sendFakeMouseMove() const;
	void takeKeyboardFocus (const FocusChangeType);
	void grabFocusInternal (const FocusChangeType, bool canTryParent);
	static void giveAwayFocus (bool sendFocusLossEvent);
	void sendEnablementChangeMessage();
	void sendVisibilityChangeMessage();

	struct ComponentHelpers;
	friend struct ComponentHelpers;

	/* Components aren't allowed to have copy constructors, as this would mess up parent hierarchies.
	   You might need to give your subclasses a private dummy constructor to avoid compiler warnings.
	*/
	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (Component);

   #if JUCE_CATCH_DEPRECATED_CODE_MISUSE
	// This is included here just to cause a compile error if your code is still handling
	// drag-and-drop with this method. If so, just update it to use the new FileDragAndDropTarget
	// class, which is easy (just make your class inherit from FileDragAndDropTarget, and
	// implement its methods instead of this Component method).
	virtual void filesDropped (const StringArray&, int, int) {}

	// This is included here to cause an error if you use or overload it - it has been deprecated in
	// favour of contains (const Point<int>&)
	void contains (int, int);
   #endif

protected:

	/** @internal */
	virtual ComponentPeer* createNewPeer (int styleFlags, void* nativeWindowToAttachTo);
   #endif
};

#endif   // __JUCE_COMPONENT_JUCEHEADER__

/*** End of inlined file: juce_Component.h ***/


#endif
#ifndef __JUCE_COMPONENTLISTENER_JUCEHEADER__

#endif
#ifndef __JUCE_DESKTOP_JUCEHEADER__

/*** Start of inlined file: juce_Desktop.h ***/
#ifndef __JUCE_DESKTOP_JUCEHEADER__
#define __JUCE_DESKTOP_JUCEHEADER__


/*** Start of inlined file: juce_ComponentAnimator.h ***/
#ifndef __JUCE_COMPONENTANIMATOR_JUCEHEADER__
#define __JUCE_COMPONENTANIMATOR_JUCEHEADER__

/**
	Animates a set of components, moving them to a new position and/or fading their
	alpha levels.

	To animate a component, create a ComponentAnimator instance or (preferably) use the
	global animator object provided by Desktop::getAnimator(), and call its animateComponent()
	method to commence the movement.

	If you're using your own ComponentAnimator instance, you'll need to make sure it isn't
	deleted before it finishes moving the components, or they'll be abandoned before reaching their
	destinations.

	It's ok to delete components while they're being animated - the animator will detect this
	and safely stop using them.

	The class is a ChangeBroadcaster and sends a notification when any components
	start or finish being animated.

	@see Desktop::getAnimator
*/
class JUCE_API  ComponentAnimator  : public ChangeBroadcaster,
									 private Timer
{
public:

	/** Creates a ComponentAnimator. */
	ComponentAnimator();

	/** Destructor. */
	~ComponentAnimator();

	/** Starts a component moving from its current position to a specified position.

		If the component is already in the middle of an animation, that will be abandoned,
		and a new animation will begin, moving the component from its current location.

		The start and end speed parameters let you apply some acceleration to the component's
		movement.

		@param component            the component to move
		@param finalBounds          the destination bounds to which the component should move. To leave the
									component in the same place, just pass component->getBounds() for this value
		@param finalAlpha           the alpha value that the component should have at the end of the animation
		@param animationDurationMilliseconds    how long the animation should last, in milliseconds
		@param useProxyComponent    if true, this means the component should be replaced by an internally
									managed temporary component which is a snapshot of the original component.
									This avoids the component having to paint itself as it moves, so may
									be more efficient. This option also allows you to delete the original
									component immediately after starting the animation, because the animation
									can proceed without it. If you use a proxy, the original component will be
									made invisible by this call, and then will become visible again at the end
									of the animation. It'll also mean that the proxy component will be temporarily
									added to the component's parent, so avoid it if this might confuse the parent
									component, or if there's a chance the parent might decide to delete its children.
		@param startSpeed           a value to indicate the relative start speed of the animation. If this is 0,
									the component will start by accelerating from rest; higher values mean that it
									will have an initial speed greater than zero. If the value if greater than 1, it
									will decelerate towards the middle of its journey. To move the component at a
									constant rate for its entire animation, set both the start and end speeds to 1.0
		@param endSpeed             a relative speed at which the component should be moving when the animation finishes.
									If this is 0, the component will decelerate to a standstill at its final position;
									higher values mean the component will still be moving when it stops. To move the component
									at a constant rate for its entire animation, set both the start and end speeds to 1.0
	*/
	void animateComponent (Component* component,
						   const Rectangle<int>& finalBounds,
						   float finalAlpha,
						   int animationDurationMilliseconds,
						   bool useProxyComponent,
						   double startSpeed,
						   double endSpeed);

	/** Begins a fade-out of this components alpha level.
		This is a quick way of invoking animateComponent() with a target alpha value of 0.0f, using
		a proxy. You're safe to delete the component after calling this method, and this won't
		interfere with the animation's progress.
	*/
	void fadeOut (Component* component, int millisecondsToTake);

	/** Begins a fade-in of a component.
		This is a quick way of invoking animateComponent() with a target alpha value of 1.0f.
	*/
	void fadeIn (Component* component, int millisecondsToTake);

	/** Stops a component if it's currently being animated.

		If moveComponentToItsFinalPosition is true, then the component will
		be immediately moved to its destination position and size. If false, it will be
		left in whatever location it currently occupies.
	*/
	void cancelAnimation (Component* component,
						  bool moveComponentToItsFinalPosition);

	/** Clears all of the active animations.

		If moveComponentsToTheirFinalPositions is true, all the components will
		be immediately set to their final positions. If false, they will be
		left in whatever locations they currently occupy.
	*/
	void cancelAllAnimations (bool moveComponentsToTheirFinalPositions);

	/** Returns the destination position for a component.

		If the component is being animated, this will return the target position that
		was specified when animateComponent() was called.

		If the specified component isn't currently being animated, this method will just
		return its current position.
	*/
	Rectangle<int> getComponentDestination (Component* component);

	/** Returns true if the specified component is currently being animated. */
	bool isAnimating (Component* component) const noexcept;

	/** Returns true if any components are currently being animated. */
	bool isAnimating() const noexcept;

private:

	class AnimationTask;
	OwnedArray <AnimationTask> tasks;
	uint32 lastTime;

	AnimationTask* findTaskFor (Component* component) const noexcept;
	void timerCallback();

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ComponentAnimator);
};

#endif   // __JUCE_COMPONENTANIMATOR_JUCEHEADER__

/*** End of inlined file: juce_ComponentAnimator.h ***/

class MouseInputSource;
class MouseInputSourceInternal;
class MouseListener;

/**
	Classes can implement this interface and register themselves with the Desktop class
	to receive callbacks when the currently focused component changes.

	@see Desktop::addFocusChangeListener, Desktop::removeFocusChangeListener
*/
class JUCE_API  FocusChangeListener
{
public:
	/** Destructor. */
	virtual ~FocusChangeListener()  {}

	/** Callback to indicate that the currently focused component has changed. */
	virtual void globalFocusChanged (Component* focusedComponent) = 0;
};

/**
	Describes and controls aspects of the computer's desktop.

*/
class JUCE_API  Desktop  : private DeletedAtShutdown,
						   private Timer,
						   private AsyncUpdater
{
public:

	/** There's only one dektop object, and this method will return it.
	*/
	static Desktop& JUCE_CALLTYPE getInstance();

	/** Returns a list of the positions of all the monitors available.

		The first rectangle in the list will be the main monitor area.

		If clippedToWorkArea is true, it will exclude any areas like the taskbar on Windows,
		or the menu bar on Mac. If clippedToWorkArea is false, the entire monitor area is returned.
	*/
	RectangleList getAllMonitorDisplayAreas (bool clippedToWorkArea = true) const;

	/** Returns the position and size of the main monitor.

		If clippedToWorkArea is true, it will exclude any areas like the taskbar on Windows,
		or the menu bar on Mac. If clippedToWorkArea is false, the entire monitor area is returned.
	*/
	Rectangle<int> getMainMonitorArea (bool clippedToWorkArea = true) const noexcept;

	/** Returns the position and size of the monitor which contains this co-ordinate.

		If none of the monitors contains the point, this will just return the
		main monitor.

		If clippedToWorkArea is true, it will exclude any areas like the taskbar on Windows,
		or the menu bar on Mac. If clippedToWorkArea is false, the entire monitor area is returned.
	*/
	Rectangle<int> getMonitorAreaContaining (const Point<int>& position, bool clippedToWorkArea = true) const;

	/** Returns the mouse position.

		The co-ordinates are relative to the top-left of the main monitor.

		Note that this is just a shortcut for calling getMainMouseSource().getScreenPosition(), and
		you should only resort to grabbing the global mouse position if there's really no
		way to get the coordinates via a mouse event callback instead.
	*/
	static Point<int> getMousePosition();

	/** Makes the mouse pointer jump to a given location.

		The co-ordinates are relative to the top-left of the main monitor.
	*/
	static void setMousePosition (const Point<int>& newPosition);

	/** Returns the last position at which a mouse button was pressed.

		Note that this is just a shortcut for calling getMainMouseSource().getLastMouseDownPosition(),
		and in a multi-touch environment, it doesn't make much sense. ALWAYS prefer to
		get this information via other means, such as MouseEvent::getMouseDownScreenPosition()
		if possible, and only ever call this as a last resort.
	*/
	static Point<int> getLastMouseDownPosition();

	/** Returns the number of times the mouse button has been clicked since the
		app started.

		Each mouse-down event increments this number by 1.
	*/
	static int getMouseButtonClickCounter();

	/** This lets you prevent the screensaver from becoming active.

		Handy if you're running some sort of presentation app where having a screensaver
		appear would be annoying.

		Pass false to disable the screensaver, and true to re-enable it. (Note that this
		won't enable a screensaver unless the user has actually set one up).

		The disablement will only happen while the Juce application is the foreground
		process - if another task is running in front of it, then the screensaver will
		be unaffected.

		@see isScreenSaverEnabled
	*/
	static void setScreenSaverEnabled (bool isEnabled);

	/** Returns true if the screensaver has not been turned off.

		This will return the last value passed into setScreenSaverEnabled(). Note that
		it won't tell you whether the user is actually using a screen saver, just
		whether this app is deliberately preventing one from running.

		@see setScreenSaverEnabled
	*/
	static bool isScreenSaverEnabled();

	/** Registers a MouseListener that will receive all mouse events that occur on
		any component.

		@see removeGlobalMouseListener
	*/
	void addGlobalMouseListener (MouseListener* listener);

	/** Unregisters a MouseListener that was added with the addGlobalMouseListener()
		method.

		@see addGlobalMouseListener
	*/
	void removeGlobalMouseListener (MouseListener* listener);

	/** Registers a MouseListener that will receive a callback whenever the focused
		component changes.
	*/
	void addFocusChangeListener (FocusChangeListener* listener);

	/** Unregisters a listener that was added with addFocusChangeListener(). */
	void removeFocusChangeListener (FocusChangeListener* listener);

	/** Takes a component and makes it full-screen, removing the taskbar, dock, etc.

		The component must already be on the desktop for this method to work. It will
		be resized to completely fill the screen and any extraneous taskbars, menu bars,
		etc will be hidden.

		To exit kiosk mode, just call setKioskModeComponent (nullptr). When this is called,
		the component that's currently being used will be resized back to the size
		and position it was in before being put into this mode.

		If allowMenusAndBars is true, things like the menu and dock (on mac) are still
		allowed to pop up when the mouse moves onto them. If this is false, it'll try
		to hide as much on-screen paraphenalia as possible.
	*/
	void setKioskModeComponent (Component* componentToUse,
								bool allowMenusAndBars = true);

	/** Returns the component that is currently being used in kiosk-mode.

		This is the component that was last set by setKioskModeComponent(). If none
		has been set, this returns 0.
	*/
	Component* getKioskModeComponent() const noexcept               { return kioskModeComponent; }

	/** Returns the number of components that are currently active as top-level
		desktop windows.

		@see getComponent, Component::addToDesktop
	*/
	int getNumComponents() const noexcept;

	/** Returns one of the top-level desktop window components.

		The index is from 0 to getNumComponents() - 1. This could return 0 if the
		index is out-of-range.

		@see getNumComponents, Component::addToDesktop
	*/
	Component* getComponent (int index) const noexcept;

	/** Finds the component at a given screen location.

		This will drill down into top-level windows to find the child component at
		the given position.

		Returns 0 if the co-ordinates are inside a non-Juce window.
	*/
	Component* findComponentAt (const Point<int>& screenPosition) const;

	/** The Desktop object has a ComponentAnimator instance which can be used for performing
		your animations.

		Having a single shared ComponentAnimator object makes it more efficient when multiple
		components are being moved around simultaneously. It's also more convenient than having
		to manage your own instance of one.

		@see ComponentAnimator
	*/
	ComponentAnimator& getAnimator() noexcept                       { return animator; }

	/** Returns the current default look-and-feel for components which don't have one
		explicitly set.
		@see setDefaultLookAndFeel
	*/
	LookAndFeel& getDefaultLookAndFeel() noexcept;

	/** Changes the default look-and-feel.
		@param newDefaultLookAndFeel    the new look-and-feel object to use - if this is
										set to nullptr, it will revert to using the system's
										default one. The object passed-in must be deleted by the
										caller when it's no longer needed.
		@see getDefaultLookAndFeel
	*/
	void setDefaultLookAndFeel (LookAndFeel* newDefaultLookAndFeel);

	/** Returns the number of MouseInputSource objects the system has at its disposal.
		In a traditional single-mouse system, there might be only one object. On a multi-touch
		system, there could be one input source per potential finger.
		To find out how many mouse events are currently happening, use getNumDraggingMouseSources().
		@see getMouseSource
	*/
	int getNumMouseSources() const noexcept                         { return mouseSources.size(); }

	/** Returns one of the system's MouseInputSource objects.
		The index should be from 0 to getNumMouseSources() - 1. Out-of-range indexes will return
		a null pointer.
		In a traditional single-mouse system, there might be only one object. On a multi-touch
		system, there could be one input source per potential finger.
	*/
	MouseInputSource* getMouseSource (int index) const noexcept     { return mouseSources [index]; }

	/** Returns the main mouse input device that the system is using.
		@see getNumMouseSources()
	*/
	MouseInputSource& getMainMouseSource() const noexcept           { return *mouseSources.getUnchecked(0); }

	/** Returns the number of mouse-sources that are currently being dragged.
		In a traditional single-mouse system, this will be 0 or 1, depending on whether a
		juce component has the button down on it. In a multi-touch system, this could
		be any number from 0 to the number of simultaneous touches that can be detected.
	*/
	int getNumDraggingMouseSources() const noexcept;

	/** Returns one of the mouse sources that's currently being dragged.
		The index should be between 0 and getNumDraggingMouseSources() - 1. If the index is
		out of range, or if no mice or fingers are down, this will return a null pointer.
	*/
	MouseInputSource* getDraggingMouseSource (int index) const noexcept;

	/** Ensures that a non-stop stream of mouse-drag events will be sent during the
		current mouse-drag operation.

		This allows you to make sure that mouseDrag() events are sent continuously, even
		when the mouse isn't moving. This can be useful for things like auto-scrolling
		components when the mouse is near an edge.

		Call this method during a mouseDown() or mouseDrag() callback, specifying the
		minimum interval between consecutive mouse drag callbacks. The callbacks
		will continue until the mouse is released, and then the interval will be reset,
		so you need to make sure it's called every time you begin a drag event.
		Passing an interval of 0 or less will cancel the auto-repeat.

		@see mouseDrag
	*/
	void beginDragAutoRepeat (int millisecondsBetweenCallbacks);

	/** In a tablet device which can be turned around, this is used to inidicate the orientation. */
	enum DisplayOrientation
	{
		upright                 = 1,  /**< Indicates that the display is the normal way up. */
		upsideDown              = 2,  /**< Indicates that the display is upside-down. */
		rotatedClockwise        = 4,  /**< Indicates that the display is turned 90 degrees clockwise from its upright position. */
		rotatedAntiClockwise    = 8,  /**< Indicates that the display is turned 90 degrees anti-clockwise from its upright position. */

		allOrientations         = 1 + 2 + 4 + 8   /**< A combination of all the orientation values */
	};

	/** In a tablet device which can be turned around, this returns the current orientation. */
	DisplayOrientation getCurrentOrientation() const;

	/** Sets which orientations the display is allowed to auto-rotate to.

		For devices that support rotating desktops, this lets you specify which of the orientations your app can use.

		The parameter is a bitwise or-ed combination of the values in DisplayOrientation, and must contain at least one
		set bit.
	*/
	void setOrientationsEnabled (int allowedOrientations);

	/** Returns whether the display is allowed to auto-rotate to the given orientation.
		Each orientation can be enabled using setOrientationEnabled(). By default, all orientations are allowed.
	*/
	bool isOrientationEnabled (DisplayOrientation orientation) const noexcept;

	/** Tells this object to refresh its idea of what the screen resolution is.

		(Called internally by the native code).
	*/
	void refreshMonitorSizes();

	/** True if the OS supports semitransparent windows */
	static bool canUseSemiTransparentWindows() noexcept;

private:

	static Desktop* instance;

	friend class Component;
	friend class ComponentPeer;
	friend class MouseInputSource;
	friend class MouseInputSourceInternal;
	friend class DeletedAtShutdown;
	friend class TopLevelWindowManager;

	OwnedArray <MouseInputSource> mouseSources;
	void createMouseInputSources();

	ListenerList <MouseListener> mouseListeners;
	ListenerList <FocusChangeListener> focusListeners;

	Array <Component*> desktopComponents;
	Array <Rectangle<int> > monitorCoordsClipped, monitorCoordsUnclipped;

	Point<int> lastFakeMouseMove;
	void sendMouseMove();

	int mouseClickCounter;
	void incrementMouseClickCounter() noexcept;

	ScopedPointer<Timer> dragRepeater;

	ScopedPointer<LookAndFeel> defaultLookAndFeel;
	WeakReference<LookAndFeel> currentLookAndFeel;

	Component* kioskModeComponent;
	Rectangle<int> kioskComponentOriginalBounds;

	int allowedOrientations;

	ComponentAnimator animator;

	void timerCallback();
	void resetTimer();
	ListenerList <MouseListener>& getMouseListeners();

	int getNumDisplayMonitors() const noexcept;
	Rectangle<int> getDisplayMonitorCoordinates (int index, bool clippedToWorkArea) const noexcept;
	static void getCurrentMonitorPositions (Array <Rectangle<int> >&, const bool clipToWorkArea);

	void addDesktopComponent (Component*);
	void removeDesktopComponent (Component*);
	void componentBroughtToFront (Component*);

	static void setKioskComponent (Component*, bool enableOrDisable, bool allowMenusAndBars);

	void triggerFocusCallback();
	void handleAsyncUpdate();

	Desktop();
	~Desktop();

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (Desktop);
};

#endif   // __JUCE_DESKTOP_JUCEHEADER__

/*** End of inlined file: juce_Desktop.h ***/


#endif
#ifndef __JUCE_MODALCOMPONENTMANAGER_JUCEHEADER__

#endif
#ifndef __JUCE_COMPONENTDRAGGER_JUCEHEADER__

/*** Start of inlined file: juce_ComponentDragger.h ***/
#ifndef __JUCE_COMPONENTDRAGGER_JUCEHEADER__
#define __JUCE_COMPONENTDRAGGER_JUCEHEADER__


/*** Start of inlined file: juce_ComponentBoundsConstrainer.h ***/
#ifndef __JUCE_COMPONENTBOUNDSCONSTRAINER_JUCEHEADER__
#define __JUCE_COMPONENTBOUNDSCONSTRAINER_JUCEHEADER__

/**
	A class that imposes restrictions on a Component's size or position.

	This is used by classes such as ResizableCornerComponent,
	ResizableBorderComponent and ResizableWindow.

	The base class can impose some basic size and position limits, but you can
	also subclass this for custom uses.

	@see ResizableCornerComponent, ResizableBorderComponent, ResizableWindow
*/
class JUCE_API  ComponentBoundsConstrainer
{
public:

	/** When first created, the object will not impose any restrictions on the components. */
	ComponentBoundsConstrainer() noexcept;

	/** Destructor. */
	virtual ~ComponentBoundsConstrainer();

	/** Imposes a minimum width limit. */
	void setMinimumWidth (int minimumWidth) noexcept;

	/** Returns the current minimum width. */
	int getMinimumWidth() const noexcept                        { return minW; }

	/** Imposes a maximum width limit. */
	void setMaximumWidth (int maximumWidth) noexcept;

	/** Returns the current maximum width. */
	int getMaximumWidth() const noexcept                        { return maxW; }

	/** Imposes a minimum height limit. */
	void setMinimumHeight (int minimumHeight) noexcept;

	/** Returns the current minimum height. */
	int getMinimumHeight() const noexcept                       { return minH; }

	/** Imposes a maximum height limit. */
	void setMaximumHeight (int maximumHeight) noexcept;

	/** Returns the current maximum height. */
	int getMaximumHeight() const noexcept                       { return maxH; }

	/** Imposes a minimum width and height limit. */
	void setMinimumSize (int minimumWidth,
						 int minimumHeight) noexcept;

	/** Imposes a maximum width and height limit. */
	void setMaximumSize (int maximumWidth,
						 int maximumHeight) noexcept;

	/** Set all the maximum and minimum dimensions. */
	void setSizeLimits (int minimumWidth,
						int minimumHeight,
						int maximumWidth,
						int maximumHeight) noexcept;

	/** Sets the amount by which the component is allowed to go off-screen.

		The values indicate how many pixels must remain on-screen when dragged off
		one of its parent's edges, so e.g. if minimumWhenOffTheTop is set to 10, then
		when the component goes off the top of the screen, its y-position will be
		clipped so that there are always at least 10 pixels on-screen. In other words,
		the lowest y-position it can take would be (10 - the component's height).

		If you pass 0 or less for one of these amounts, the component is allowed
		to move beyond that edge completely, with no restrictions at all.

		If you pass a very large number (i.e. larger that the dimensions of the
		component itself), then the component won't be allowed to overlap that
		edge at all. So e.g. setting minimumWhenOffTheLeft to 0xffffff will mean that
		the component will bump into the left side of the screen and go no further.
	*/
	void setMinimumOnscreenAmounts (int minimumWhenOffTheTop,
									int minimumWhenOffTheLeft,
									int minimumWhenOffTheBottom,
									int minimumWhenOffTheRight) noexcept;

	/** Returns the minimum distance the bounds can be off-screen. @see setMinimumOnscreenAmounts */
	int getMinimumWhenOffTheTop() const noexcept        { return minOffTop; }
	/** Returns the minimum distance the bounds can be off-screen. @see setMinimumOnscreenAmounts */
	int getMinimumWhenOffTheLeft() const noexcept       { return minOffLeft; }
	/** Returns the minimum distance the bounds can be off-screen. @see setMinimumOnscreenAmounts */
	int getMinimumWhenOffTheBottom() const noexcept     { return minOffBottom; }
	/** Returns the minimum distance the bounds can be off-screen. @see setMinimumOnscreenAmounts */
	int getMinimumWhenOffTheRight() const noexcept      { return minOffRight; }

	/** Specifies a width-to-height ratio that the resizer should always maintain.

		If the value is 0, no aspect ratio is enforced. If it's non-zero, the width
		will always be maintained as this multiple of the height.

		@see setResizeLimits
	*/
	void setFixedAspectRatio (double widthOverHeight) noexcept;

	/** Returns the aspect ratio that was set with setFixedAspectRatio().

		If no aspect ratio is being enforced, this will return 0.
	*/
	double getFixedAspectRatio() const noexcept;

	/** This callback changes the given co-ordinates to impose whatever the current
		constraints are set to be.

		@param bounds               the target position that should be examined and adjusted
		@param previousBounds       the component's current size
		@param limits               the region in which the component can be positioned
		@param isStretchingTop      whether the top edge of the component is being resized
		@param isStretchingLeft     whether the left edge of the component is being resized
		@param isStretchingBottom   whether the bottom edge of the component is being resized
		@param isStretchingRight    whether the right edge of the component is being resized
	*/
	virtual void checkBounds (Rectangle<int>& bounds,
							  const Rectangle<int>& previousBounds,
							  const Rectangle<int>& limits,
							  bool isStretchingTop,
							  bool isStretchingLeft,
							  bool isStretchingBottom,
							  bool isStretchingRight);

	/** This callback happens when the resizer is about to start dragging. */
	virtual void resizeStart();

	/** This callback happens when the resizer has finished dragging. */
	virtual void resizeEnd();

	/** Checks the given bounds, and then sets the component to the corrected size. */
	void setBoundsForComponent (Component* component,
								const Rectangle<int>& bounds,
								bool isStretchingTop,
								bool isStretchingLeft,
								bool isStretchingBottom,
								bool isStretchingRight);

	/** Performs a check on the current size of a component, and moves or resizes
		it if it fails the constraints.
	*/
	void checkComponentBounds (Component* component);

	/** Called by setBoundsForComponent() to apply a new constrained size to a
		component.

		By default this just calls setBounds(), but is virtual in case it's needed for
		extremely cunning purposes.
	*/
	virtual void applyBoundsToComponent (Component* component,
										 const Rectangle<int>& bounds);

private:

	int minW, maxW, minH, maxH;
	int minOffTop, minOffLeft, minOffBottom, minOffRight;
	double aspectRatio;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ComponentBoundsConstrainer);
};

#endif   // __JUCE_COMPONENTBOUNDSCONSTRAINER_JUCEHEADER__

/*** End of inlined file: juce_ComponentBoundsConstrainer.h ***/

/**
	An object to take care of the logic for dragging components around with the mouse.

	Very easy to use - in your mouseDown() callback, call startDraggingComponent(),
	then in your mouseDrag() callback, call dragComponent().

	When starting a drag, you can give it a ComponentBoundsConstrainer to use
	to limit the component's position and keep it on-screen.

	e.g. @code
	class MyDraggableComp
	{
		ComponentDragger myDragger;

		void mouseDown (const MouseEvent& e)
		{
			myDragger.startDraggingComponent (this, e);
		}

		void mouseDrag (const MouseEvent& e)
		{
			myDragger.dragComponent (this, e, nullptr);
		}
	};
	@endcode
*/
class JUCE_API  ComponentDragger
{
public:

	/** Creates a ComponentDragger. */
	ComponentDragger();

	/** Destructor. */
	virtual ~ComponentDragger();

	/** Call this from your component's mouseDown() method, to prepare for dragging.

		@param componentToDrag      the component that you want to drag
		@param e                    the mouse event that is triggering the drag
		@see dragComponent
	*/
	void startDraggingComponent (Component* componentToDrag,
								 const MouseEvent& e);

	/** Call this from your mouseDrag() callback to move the component.

		This will move the component, but will first check the validity of the
		component's new position using the checkPosition() method, which you
		can override if you need to enforce special positioning limits on the
		component.

		@param componentToDrag      the component that you want to drag
		@param e                    the current mouse-drag event
		@param constrainer          an optional constrainer object that should be used
									to apply limits to the component's position. Pass
									null if you don't want to contrain the movement.
		@see startDraggingComponent
	*/
	void dragComponent (Component* componentToDrag,
						const MouseEvent& e,
						ComponentBoundsConstrainer* constrainer);

private:

	Point<int> mouseDownWithinTarget;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ComponentDragger);
};

#endif   // __JUCE_COMPONENTDRAGGER_JUCEHEADER__

/*** End of inlined file: juce_ComponentDragger.h ***/


#endif
#ifndef __JUCE_DRAGANDDROPCONTAINER_JUCEHEADER__

/*** Start of inlined file: juce_DragAndDropContainer.h ***/
#ifndef __JUCE_DRAGANDDROPCONTAINER_JUCEHEADER__
#define __JUCE_DRAGANDDROPCONTAINER_JUCEHEADER__


/*** Start of inlined file: juce_DragAndDropTarget.h ***/
#ifndef __JUCE_DRAGANDDROPTARGET_JUCEHEADER__
#define __JUCE_DRAGANDDROPTARGET_JUCEHEADER__

/**
	Components derived from this class can have things dropped onto them by a DragAndDropContainer.

	To create a component that can receive things drag-and-dropped by a DragAndDropContainer,
	derive your component from this class, and make sure that it is somewhere inside a
	DragAndDropContainer component.

	Note: If all that you need to do is to respond to files being drag-and-dropped from
	the operating system onto your component, you don't need any of these classes: instead
	see the FileDragAndDropTarget class.

	@see DragAndDropContainer, FileDragAndDropTarget
*/
class JUCE_API  DragAndDropTarget
{
public:
	/** Destructor. */
	virtual ~DragAndDropTarget()  {}

	/** Contains details about the source of a drag-and-drop operation.
		The contents of this
	*/
	class JUCE_API  SourceDetails
	{
	public:
		/** Creates a SourceDetails object from its various settings. */
		SourceDetails (const var& description, Component* sourceComponent, const Point<int>& localPosition) noexcept;

		/** A descriptor for the drag - this is set DragAndDropContainer::startDragging(). */
		var description;

		/** The component from the drag operation was started. */
		WeakReference<Component> sourceComponent;

		/** The local position of the mouse, relative to the target component.
			Note that for calls such as isInterestedInDragSource(), this may be a null position.
		*/
		Point<int> localPosition;
	};

	/** Callback to check whether this target is interested in the type of object being
		dragged.

		@param dragSourceDetails    contains information about the source of the drag operation.
		@returns                    true if this component wants to receive the other callbacks regarging this
									type of object; if it returns false, no other callbacks will be made.
	*/
	virtual bool isInterestedInDragSource (const SourceDetails& dragSourceDetails) = 0;

	/** Callback to indicate that something is being dragged over this component.

		This gets called when the user moves the mouse into this component while dragging
		something.

		Use this callback as a trigger to make your component repaint itself to give the
		user feedback about whether the item can be dropped here or not.

		@param dragSourceDetails    contains information about the source of the drag operation.
		@see itemDragExit
	*/
	virtual void itemDragEnter (const SourceDetails& dragSourceDetails);

	/** Callback to indicate that the user is dragging something over this component.

		This gets called when the user moves the mouse over this component while dragging
		something. Normally overriding itemDragEnter() and itemDragExit() are enough, but
		this lets you know what happens in-between.

		@param dragSourceDetails    contains information about the source of the drag operation.
	*/
	virtual void itemDragMove (const SourceDetails& dragSourceDetails);

	/** Callback to indicate that something has been dragged off the edge of this component.

		This gets called when the user moves the mouse out of this component while dragging
		something.

		If you've used itemDragEnter() to repaint your component and give feedback, use this
		as a signal to repaint it in its normal state.

		@param dragSourceDetails    contains information about the source of the drag operation.
		@see itemDragEnter
	*/
	virtual void itemDragExit (const SourceDetails& dragSourceDetails);

	/** Callback to indicate that the user has dropped something onto this component.

		When the user drops an item this get called, and you can use the description to
		work out whether your object wants to deal with it or not.

		Note that after this is called, the itemDragExit method may not be called, so you should
		clean up in here if there's anything you need to do when the drag finishes.

		@param dragSourceDetails    contains information about the source of the drag operation.
	*/
	virtual void itemDropped (const SourceDetails& dragSourceDetails) = 0;

	/** Overriding this allows the target to tell the drag container whether to
		draw the drag image while the cursor is over it.

		By default it returns true, but if you return false, then the normal drag
		image will not be shown when the cursor is over this target.
	*/
	virtual bool shouldDrawDragImageWhenOver();

private:
   #if JUCE_CATCH_DEPRECATED_CODE_MISUSE
	// The parameters for these methods have changed - please update your code!
	virtual void isInterestedInDragSource (const String&, Component*) {}
	virtual int itemDragEnter (const String&, Component*, int, int) { return 0; }
	virtual int itemDragMove (const String&, Component*, int, int) { return 0; }
	virtual int itemDragExit (const String&, Component*) { return 0; }
	virtual int itemDropped (const String&, Component*, int, int) { return 0; }
   #endif
};

#endif   // __JUCE_DRAGANDDROPTARGET_JUCEHEADER__

/*** End of inlined file: juce_DragAndDropTarget.h ***/

/**
	Enables drag-and-drop behaviour for a component and all its sub-components.

	For a component to be able to make or receive drag-and-drop events, one of its parent
	components must derive from this class. It's probably best for the top-level
	component to implement it.

	Then to start a drag operation, any sub-component can just call the startDragging()
	method, and this object will take over, tracking the mouse and sending appropriate
	callbacks to any child components derived from DragAndDropTarget which the mouse
	moves over.

	Note: If all that you need to do is to respond to files being drag-and-dropped from
	the operating system onto your component, you don't need any of these classes: you can do this
	simply by overriding Component::filesDropped().

	@see DragAndDropTarget
*/
class JUCE_API  DragAndDropContainer
{
public:

	/** Creates a DragAndDropContainer.

		The object that derives from this class must also be a Component.
	*/
	DragAndDropContainer();

	/** Destructor. */
	virtual ~DragAndDropContainer();

	/** Begins a drag-and-drop operation.

		This starts a drag-and-drop operation - call it when the user drags the
		mouse in your drag-source component, and this object will track mouse
		movements until the user lets go of the mouse button, and will send
		appropriate messages to DragAndDropTarget objects that the mouse moves
		over.

		findParentDragContainerFor() is a handy method to call to find the
		drag container to use for a component.

		@param sourceDescription    a string or value to use as the description of the thing being dragged -
									this will be passed to the objects that might be dropped-onto so they can
									decide whether they want to handle it
		@param sourceComponent      the component that is being dragged
		@param dragImage            the image to drag around underneath the mouse. If this is a null image,
									a snapshot of the sourceComponent will be used instead.
		@param allowDraggingToOtherJuceWindows   if true, the dragged component will appear as a desktop
									window, and can be dragged to DragAndDropTargets that are the
									children of components other than this one.
		@param imageOffsetFromMouse if an image has been passed-in, this specifies the offset
									at which the image should be drawn from the mouse. If it isn't
									specified, then the image will be centred around the mouse. If
									an image hasn't been passed-in, this will be ignored.
	*/
	void startDragging (const var& sourceDescription,
						Component* sourceComponent,
						const Image& dragImage = Image::null,
						bool allowDraggingToOtherJuceWindows = false,
						const Point<int>* imageOffsetFromMouse = nullptr);

	/** Returns true if something is currently being dragged. */
	bool isDragAndDropActive() const;

	/** Returns the description of the thing that's currently being dragged.

		If nothing's being dragged, this will return an empty string, otherwise it's the
		string that was passed into startDragging().

		@see startDragging
	*/
	String getCurrentDragDescription() const;

	/** Utility to find the DragAndDropContainer for a given Component.

		This will search up this component's parent hierarchy looking for the first
		parent component which is a DragAndDropContainer.

		It's useful when a component wants to call startDragging but doesn't know
		the DragAndDropContainer it should to use.

		Obviously this may return 0 if it doesn't find a suitable component.
	*/
	static DragAndDropContainer* findParentDragContainerFor (Component* childComponent);

	/** This performs a synchronous drag-and-drop of a set of files to some external
		application.

		You can call this function in response to a mouseDrag callback, and it will
		block, running its own internal message loop and tracking the mouse, while it
		uses a native operating system drag-and-drop operation to move or copy some
		files to another application.

		@param files            a list of filenames to drag
		@param canMoveFiles     if true, the app that receives the files is allowed to move the files to a new location
								(if this is appropriate). If false, the receiver is expected to make a copy of them.
		@returns        true if the files were successfully dropped somewhere, or false if it
						was interrupted
		@see performExternalDragDropOfText
	*/
	static bool performExternalDragDropOfFiles (const StringArray& files, bool canMoveFiles);

	/** This performs a synchronous drag-and-drop of a block of text to some external
		application.

		You can call this function in response to a mouseDrag callback, and it will
		block, running its own internal message loop and tracking the mouse, while it
		uses a native operating system drag-and-drop operation to move or copy some
		text to another application.

		@param text     the text to copy
		@returns        true if the text was successfully dropped somewhere, or false if it
						was interrupted
		@see performExternalDragDropOfFiles
	*/
	static bool performExternalDragDropOfText (const String& text);

protected:
	/** Override this if you want to be able to perform an external drag a set of files
		when the user drags outside of this container component.

		This method will be called when a drag operation moves outside the Juce-based window,
		and if you want it to then perform a file drag-and-drop, add the filenames you want
		to the array passed in, and return true.

		@param sourceDetails    information about the source of the drag operation
		@param files            on return, the filenames you want to drag
		@param canMoveFiles     on return, true if it's ok for the receiver to move the files; false if
								it must make a copy of them (see the performExternalDragDropOfFiles() method)
		@see performExternalDragDropOfFiles
	*/
	virtual bool shouldDropFilesWhenDraggedExternally (const DragAndDropTarget::SourceDetails& sourceDetails,
													   StringArray& files, bool& canMoveFiles);

private:

	friend class DragImageComponent;
	ScopedPointer <Component> dragImageComponent;
	String currentDragDesc;

	JUCE_DEPRECATED (virtual bool shouldDropFilesWhenDraggedExternally (const String&, Component*, StringArray&, bool&)) { return false; }

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (DragAndDropContainer);
};

#endif   // __JUCE_DRAGANDDROPCONTAINER_JUCEHEADER__

/*** End of inlined file: juce_DragAndDropContainer.h ***/


#endif
#ifndef __JUCE_DRAGANDDROPTARGET_JUCEHEADER__

#endif
#ifndef __JUCE_FILEDRAGANDDROPTARGET_JUCEHEADER__

/*** Start of inlined file: juce_FileDragAndDropTarget.h ***/
#ifndef __JUCE_FILEDRAGANDDROPTARGET_JUCEHEADER__
#define __JUCE_FILEDRAGANDDROPTARGET_JUCEHEADER__

/**
	Components derived from this class can have files dropped onto them by an external application.

	@see DragAndDropContainer
*/
class JUCE_API  FileDragAndDropTarget
{
public:
	/** Destructor. */
	virtual ~FileDragAndDropTarget()  {}

	/** Callback to check whether this target is interested in the set of files being offered.

		Note that this will be called repeatedly when the user is dragging the mouse around over your
		component, so don't do anything time-consuming in here, like opening the files to have a look
		inside them!

		@param files        the set of (absolute) pathnames of the files that the user is dragging
		@returns            true if this component wants to receive the other callbacks regarging this
							type of object; if it returns false, no other callbacks will be made.
	*/
	virtual bool isInterestedInFileDrag (const StringArray& files) = 0;

	/** Callback to indicate that some files are being dragged over this component.

		This gets called when the user moves the mouse into this component while dragging.

		Use this callback as a trigger to make your component repaint itself to give the
		user feedback about whether the files can be dropped here or not.

		@param files        the set of (absolute) pathnames of the files that the user is dragging
		@param x            the mouse x position, relative to this component
		@param y            the mouse y position, relative to this component
	*/
	virtual void fileDragEnter (const StringArray& files, int x, int y);

	/** Callback to indicate that the user is dragging some files over this component.

		This gets called when the user moves the mouse over this component while dragging.
		Normally overriding itemDragEnter() and itemDragExit() are enough, but
		this lets you know what happens in-between.

		@param files        the set of (absolute) pathnames of the files that the user is dragging
		@param x            the mouse x position, relative to this component
		@param y            the mouse y position, relative to this component
	*/
	virtual void fileDragMove (const StringArray& files, int x, int y);

	/** Callback to indicate that the mouse has moved away from this component.

		This gets called when the user moves the mouse out of this component while dragging
		the files.

		If you've used fileDragEnter() to repaint your component and give feedback, use this
		as a signal to repaint it in its normal state.

		@param files        the set of (absolute) pathnames of the files that the user is dragging
	*/
	virtual void fileDragExit (const StringArray& files);

	/** Callback to indicate that the user has dropped the files onto this component.

		When the user drops the files, this get called, and you can use the files in whatever
		way is appropriate.

		Note that after this is called, the fileDragExit method may not be called, so you should
		clean up in here if there's anything you need to do when the drag finishes.

		@param files        the set of (absolute) pathnames of the files that the user is dragging
		@param x            the mouse x position, relative to this component
		@param y            the mouse y position, relative to this component
	*/
	virtual void filesDropped (const StringArray& files, int x, int y) = 0;
};

#endif   // __JUCE_FILEDRAGANDDROPTARGET_JUCEHEADER__

/*** End of inlined file: juce_FileDragAndDropTarget.h ***/


#endif
#ifndef __JUCE_LASSOCOMPONENT_JUCEHEADER__

/*** Start of inlined file: juce_LassoComponent.h ***/
#ifndef __JUCE_LASSOCOMPONENT_JUCEHEADER__
#define __JUCE_LASSOCOMPONENT_JUCEHEADER__


/*** Start of inlined file: juce_SelectedItemSet.h ***/
#ifndef __JUCE_SELECTEDITEMSET_JUCEHEADER__
#define __JUCE_SELECTEDITEMSET_JUCEHEADER__

/** Manages a list of selectable items.

	Use one of these to keep a track of things that the user has highlighted, like
	icons or things in a list.

	The class is templated so that you can use it to hold either a set of pointers
	to objects, or a set of ID numbers or handles, for cases where each item may
	not always have a corresponding object.

	To be informed when items are selected/deselected, register a ChangeListener with
	this object.

	@see SelectableObject
*/
template <class SelectableItemType>
class JUCE_API  SelectedItemSet   : public ChangeBroadcaster
{
public:

	typedef SelectableItemType ItemType;
	typedef PARAMETER_TYPE (SelectableItemType) ParameterType;

	/** Creates an empty set. */
	SelectedItemSet()
	{
	}

	/** Creates a set based on an array of items. */
	explicit SelectedItemSet (const Array <SelectableItemType>& items)
		: selectedItems (items)
	{
	}

	/** Creates a copy of another set. */
	SelectedItemSet (const SelectedItemSet& other)
		: selectedItems (other.selectedItems)
	{
	}

	/** Creates a copy of another set. */
	SelectedItemSet& operator= (const SelectedItemSet& other)
	{
		if (selectedItems != other.selectedItems)
		{
			selectedItems = other.selectedItems;
			changed();
		}

		return *this;
	}

	/** Clears any other currently selected items, and selects this item.

		If this item is already the only thing selected, no change notification
		will be sent out.

		@see addToSelection, addToSelectionBasedOnModifiers
	*/
	void selectOnly (ParameterType item)
	{
		if (isSelected (item))
		{
			for (int i = selectedItems.size(); --i >= 0;)
			{
				if (selectedItems.getUnchecked(i) != item)
				{
					deselect (selectedItems.getUnchecked(i));
					i = jmin (i, selectedItems.size());
				}
			}
		}
		else
		{
			deselectAll();
			changed();

			selectedItems.add (item);
			itemSelected (item);
		}
	}

	/** Selects an item.

		If the item is already selected, no change notification will be sent out.

		@see selectOnly, addToSelectionBasedOnModifiers
	*/
	void addToSelection (ParameterType item)
	{
		if (! isSelected (item))
		{
			changed();

			selectedItems.add (item);
			itemSelected (item);
		}
	}

	/** Selects or deselects an item.

		This will use the modifier keys to decide whether to deselect other items
		first.

		So if the shift key is held down, the item will be added without deselecting
		anything (same as calling addToSelection() )

		If no modifiers are down, the current selection will be cleared first (same
		as calling selectOnly() )

		If the ctrl (or command on the Mac) key is held down, the item will be toggled -
		so it'll be added to the set unless it's already there, in which case it'll be
		deselected.

		If the items that you're selecting can also be dragged, you may need to use the
		addToSelectionOnMouseDown() and addToSelectionOnMouseUp() calls to handle the
		subtleties of this kind of usage.

		@see selectOnly, addToSelection, addToSelectionOnMouseDown, addToSelectionOnMouseUp
	*/
	void addToSelectionBasedOnModifiers (ParameterType item,
										 const ModifierKeys& modifiers)
	{
		if (modifiers.isShiftDown())
		{
			addToSelection (item);
		}
		else if (modifiers.isCommandDown())
		{
			if (isSelected (item))
				deselect (item);
			else
				addToSelection (item);
		}
		else
		{
			selectOnly (item);
		}
	}

	/** Selects or deselects items that can also be dragged, based on a mouse-down event.

		If you call addToSelectionOnMouseDown() at the start of your mouseDown event,
		and then call addToSelectionOnMouseUp() at the end of your mouseUp event, this
		makes it easy to handle multiple-selection of sets of objects that can also
		be dragged.

		For example, if you have several items already selected, and you click on
		one of them (without dragging), then you'd expect this to deselect the other, and
		just select the item you clicked on. But if you had clicked on this item and
		dragged it, you'd have expected them all to stay selected.

		When you call this method, you'll need to store the boolean result, because the
		addToSelectionOnMouseUp() method will need to be know this value.

		@see addToSelectionOnMouseUp, addToSelectionBasedOnModifiers
	*/
	bool addToSelectionOnMouseDown (ParameterType item,
									const ModifierKeys& modifiers)
	{
		if (isSelected (item))
			return ! modifiers.isPopupMenu();

		addToSelectionBasedOnModifiers (item, modifiers);
		return false;
	}

	/** Selects or deselects items that can also be dragged, based on a mouse-up event.

		Call this during a mouseUp callback, when you have previously called the
		addToSelectionOnMouseDown() method during your mouseDown event.

		See addToSelectionOnMouseDown() for more info

		@param item             the item to select (or deselect)
		@param modifiers        the modifiers from the mouse-up event
		@param wasItemDragged   true if your item was dragged during the mouse click
		@param resultOfMouseDownSelectMethod    this is the boolean return value that came
								back from the addToSelectionOnMouseDown() call that you
								should have made during the matching mouseDown event
	*/
	void addToSelectionOnMouseUp (ParameterType item,
								  const ModifierKeys& modifiers,
								  const bool wasItemDragged,
								  const bool resultOfMouseDownSelectMethod)
	{
		if (resultOfMouseDownSelectMethod && ! wasItemDragged)
			addToSelectionBasedOnModifiers (item, modifiers);
	}

	/** Deselects an item. */
	void deselect (ParameterType item)
	{
		const int i = selectedItems.indexOf (item);

		if (i >= 0)
		{
			changed();
			itemDeselected (selectedItems.remove (i));
		}
	}

	/** Deselects all items. */
	void deselectAll()
	{
		if (selectedItems.size() > 0)
		{
			changed();

			for (int i = selectedItems.size(); --i >= 0;)
			{
				itemDeselected (selectedItems.remove (i));
				i = jmin (i, selectedItems.size());
			}
		}
	}

	/** Returns the number of currently selected items.

		@see getSelectedItem
	*/
	int getNumSelected() const noexcept
	{
		return selectedItems.size();
	}

	/** Returns one of the currently selected items.

		Returns 0 if the index is out-of-range.

		@see getNumSelected
	*/
	SelectableItemType getSelectedItem (const int index) const noexcept
	{
		return selectedItems [index];
	}

	/** True if this item is currently selected. */
	bool isSelected (ParameterType item) const noexcept
	{
		return selectedItems.contains (item);
	}

	const Array <SelectableItemType>& getItemArray() const noexcept         { return selectedItems; }

	/** Can be overridden to do special handling when an item is selected.

		For example, if the item is an object, you might want to call it and tell
		it that it's being selected.
	*/
	virtual void itemSelected (SelectableItemType item)                     { (void) item; }

	/** Can be overridden to do special handling when an item is deselected.

		For example, if the item is an object, you might want to call it and tell
		it that it's being deselected.
	*/
	virtual void itemDeselected (SelectableItemType item)                   { (void) item; }

	/** Used internally, but can be called to force a change message to be sent to the ChangeListeners.
	*/
	void changed (const bool synchronous = false)
	{
		if (synchronous)
			sendSynchronousChangeMessage();
		else
			sendChangeMessage();
	}

private:

	Array <SelectableItemType> selectedItems;

	JUCE_LEAK_DETECTOR (SelectedItemSet <SelectableItemType>);
};

#endif   // __JUCE_SELECTEDITEMSET_JUCEHEADER__

/*** End of inlined file: juce_SelectedItemSet.h ***/

/**
	A class used by the LassoComponent to manage the things that it selects.

	This allows the LassoComponent to find out which items are within the lasso,
	and to change the list of selected items.

	@see LassoComponent, SelectedItemSet
*/
template <class SelectableItemType>
class LassoSource
{
public:
	/** Destructor. */
	virtual ~LassoSource() {}

	/** Returns the set of items that lie within a given lassoable region.

		Your implementation of this method must find all the relevent items that lie
		within the given rectangle. and add them to the itemsFound array.

		The co-ordinates are relative to the top-left of the lasso component's parent
		component. (i.e. they are the same as the size and position of the lasso
		component itself).
	*/
	virtual void findLassoItemsInArea (Array <SelectableItemType>& itemsFound,
									   const Rectangle<int>& area) = 0;

	/** Returns the SelectedItemSet that the lasso should update.

		This set will be continuously updated by the LassoComponent as it gets
		dragged around, so make sure that you've got a ChangeListener attached to
		the set so that your UI objects will know when the selection changes and
		be able to update themselves appropriately.
	*/
	virtual SelectedItemSet <SelectableItemType>& getLassoSelection() = 0;
};

/**
	A component that acts as a rectangular selection region, which you drag with
	the mouse to select groups of objects (in conjunction with a SelectedItemSet).

	To use one of these:

	- In your mouseDown or mouseDrag event, add the LassoComponent to your parent
	  component, and call its beginLasso() method, giving it a
	  suitable LassoSource object that it can use to find out which items are in
	  the active area.

	- Each time your parent component gets a mouseDrag event, call dragLasso()
	  to update the lasso's position - it will use its LassoSource to calculate and
	  update the current selection.

	- After the drag has finished and you get a mouseUp callback, you should call
	  endLasso() to clean up. This will make the lasso component invisible, and you
	  can remove it from the parent component, or delete it.

	The class takes into account the modifier keys that are being held down while
	the lasso is being dragged, so if shift is pressed, then any lassoed items will
	be added to the original selection; if ctrl or command is pressed, they will be
	xor'ed with any previously selected items.

	@see LassoSource, SelectedItemSet
*/
template <class SelectableItemType>
class LassoComponent  : public Component
{
public:

	/** Creates a Lasso component.

		The fill colour is used to fill the lasso'ed rectangle, and the outline
		colour is used to draw a line around its edge.
	*/
	explicit LassoComponent (const int outlineThickness_ = 1)
		: source (nullptr),
		  outlineThickness (outlineThickness_)
	{
	}

	/** Destructor. */
	~LassoComponent()
	{
	}

	/** Call this in your mouseDown event, to initialise a drag.

		Pass in a suitable LassoSource object which the lasso will use to find
		the items and change the selection.

		After using this method to initialise the lasso, repeatedly call dragLasso()
		in your component's mouseDrag callback.

		@see dragLasso, endLasso, LassoSource
	*/
	void beginLasso (const MouseEvent& e,
					 LassoSource <SelectableItemType>* const lassoSource)
	{
		jassert (source == nullptr);  // this suggests that you didn't call endLasso() after the last drag...
		jassert (lassoSource != nullptr); // the source can't be null!
		jassert (getParentComponent() != nullptr);  // you need to add this to a parent component for it to work!

		source = lassoSource;

		if (lassoSource != nullptr)
			originalSelection = lassoSource->getLassoSelection().getItemArray();

		setSize (0, 0);
		dragStartPos = e.getMouseDownPosition();
	}

	/** Call this in your mouseDrag event, to update the lasso's position.

		This must be repeatedly calling when the mouse is dragged, after you've
		first initialised the lasso with beginLasso().

		This method takes into account the modifier keys that are being held down, so
		if shift is pressed, then the lassoed items will be added to any that were
		previously selected; if ctrl or command is pressed, then they will be xor'ed
		with previously selected items.

		@see beginLasso, endLasso
	*/
	void dragLasso (const MouseEvent& e)
	{
		if (source != nullptr)
		{
			setBounds (Rectangle<int> (dragStartPos, e.getPosition()));
			setVisible (true);

			Array <SelectableItemType> itemsInLasso;
			source->findLassoItemsInArea (itemsInLasso, getBounds());

			if (e.mods.isShiftDown())
			{
				itemsInLasso.removeValuesIn (originalSelection); //  to avoid duplicates
				itemsInLasso.addArray (originalSelection);
			}
			else if (e.mods.isCommandDown() || e.mods.isAltDown())
			{
				Array <SelectableItemType> originalMinusNew (originalSelection);
				originalMinusNew.removeValuesIn (itemsInLasso);

				itemsInLasso.removeValuesIn (originalSelection);
				itemsInLasso.addArray (originalMinusNew);
			}

			source->getLassoSelection() = SelectedItemSet <SelectableItemType> (itemsInLasso);
		}
	}

	/** Call this in your mouseUp event, after the lasso has been dragged.

		@see beginLasso, dragLasso
	*/
	void endLasso()
	{
		source = nullptr;
		originalSelection.clear();
		setVisible (false);
	}

	/** A set of colour IDs to use to change the colour of various aspects of the label.

		These constants can be used either via the Component::setColour(), or LookAndFeel::setColour()
		methods.

		Note that you can also use the constants from TextEditor::ColourIds to change the
		colour of the text editor that is opened when a label is editable.

		@see Component::setColour, Component::findColour, LookAndFeel::setColour, LookAndFeel::findColour
	*/
	enum ColourIds
	{
		lassoFillColourId       = 0x1000440, /**< The colour to fill the lasso rectangle with. */
		lassoOutlineColourId    = 0x1000441, /**< The colour to draw the outline with. */
	};

	/** @internal */
	void paint (Graphics& g)
	{
		g.fillAll (findColour (lassoFillColourId));

		g.setColour (findColour (lassoOutlineColourId));
		g.drawRect (0, 0, getWidth(), getHeight(), outlineThickness);

		// this suggests that you've left a lasso comp lying around after the
		// mouse drag has finished.. Be careful to call endLasso() when you get a
		// mouse-up event.
		jassert (isMouseButtonDownAnywhere());
	}

	/** @internal */
	bool hitTest (int, int)             { return false; }

private:

	Array <SelectableItemType> originalSelection;
	LassoSource <SelectableItemType>* source;
	int outlineThickness;
	Point<int> dragStartPos;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (LassoComponent);
};

#endif   // __JUCE_LASSOCOMPONENT_JUCEHEADER__

/*** End of inlined file: juce_LassoComponent.h ***/


#endif
#ifndef __JUCE_MOUSECURSOR_JUCEHEADER__

#endif
#ifndef __JUCE_MOUSEEVENT_JUCEHEADER__

#endif
#ifndef __JUCE_MOUSEINPUTSOURCE_JUCEHEADER__

/*** Start of inlined file: juce_MouseInputSource.h ***/
#ifndef __JUCE_MOUSEINPUTSOURCE_JUCEHEADER__
#define __JUCE_MOUSEINPUTSOURCE_JUCEHEADER__

class MouseInputSourceInternal;

/**
	Represents a linear source of mouse events from a mouse device or individual finger
	in a multi-touch environment.

	Each MouseEvent object contains a reference to the MouseInputSource that generated
	it. In an environment with a single mouse for input, all events will come from the
	same source, but in a multi-touch system, there may be multiple MouseInputSource
	obects active, each representing a stream of events coming from a particular finger.

	Events coming from a single MouseInputSource are always sent in a fixed and predictable
	order: a mouseMove will never be called without a mouseEnter having been sent beforehand,
	the only events that can happen between a mouseDown and its corresponding mouseUp are
	mouseDrags, etc.
	When there are multiple touches arriving from multiple MouseInputSources, their
	event streams may arrive in an interleaved order, so you should use the getIndex()
	method to find out which finger each event came from.

	@see MouseEvent
*/
class JUCE_API  MouseInputSource
{
public:

	/** Creates a MouseInputSource.
		You should never actually create a MouseInputSource in your own code - the
		library takes care of managing these objects.
	*/
	MouseInputSource (int index, bool isMouseDevice);

	/** Destructor. */
	~MouseInputSource();

	/** Returns true if this object represents a normal desk-based mouse device. */
	bool isMouse() const;

	/** Returns true if this object represents a source of touch events - i.e. a finger or stylus. */
	bool isTouch() const;

	/** Returns true if this source has an on-screen pointer that can hover over
		items without clicking them.
	*/
	bool canHover() const;

	/** Returns true if this source may have a scroll wheel. */
	bool hasMouseWheel() const;

	/** Returns this source's index in the global list of possible sources.
		If the system only has a single mouse, there will only be a single MouseInputSource
		with an index of 0.

		If the system supports multi-touch input, then the index will represent a finger
		number, starting from 0. When the first touch event begins, it will have finger
		number 0, and then if a second touch happens while the first is still down, it
		will have index 1, etc.
	*/
	int getIndex() const;

	/** Returns true if this device is currently being pressed. */
	bool isDragging() const;

	/** Returns the last-known screen position of this source. */
	Point<int> getScreenPosition() const;

	/** Returns a set of modifiers that indicate which buttons are currently
		held down on this device.
	*/
	ModifierKeys getCurrentModifiers() const;

	/** Returns the component that was last known to be under this pointer. */
	Component* getComponentUnderMouse() const;

	/** Tells the device to dispatch a mouse-move or mouse-drag event.
		This is asynchronous - the event will occur on the message thread.
	*/
	void triggerFakeMove() const;

	/** Returns the number of clicks that should be counted as belonging to the
		current mouse event.
		So the mouse is currently down and it's the second click of a double-click, this
		will return 2.
	*/
	int getNumberOfMultipleClicks() const noexcept;

	/** Returns the time at which the last mouse-down occurred. */
	Time getLastMouseDownTime() const noexcept;

	/** Returns the screen position at which the last mouse-down occurred. */
	Point<int> getLastMouseDownPosition() const noexcept;

	/** Returns true if this mouse is currently down, and if it has been dragged more
		than a couple of pixels from the place it was pressed.
	*/
	bool hasMouseMovedSignificantlySincePressed() const noexcept;

	/** Returns true if this input source uses a visible mouse cursor. */
	bool hasMouseCursor() const noexcept;

	/** Changes the mouse cursor, (if there is one). */
	void showMouseCursor (const MouseCursor& cursor);

	/** Hides the mouse cursor (if there is one). */
	void hideCursor();

	/** Un-hides the mouse cursor if it was hidden by hideCursor(). */
	void revealCursor();

	/** Forces an update of the mouse cursor for whatever component it's currently over. */
	void forceMouseCursorUpdate();

	/** Returns true if this mouse can be moved indefinitely in any direction without running out of space. */
	bool canDoUnboundedMovement() const noexcept;

	/** Allows the mouse to move beyond the edges of the screen.

		Calling this method when the mouse button is currently pressed will remove the cursor
		from the screen and allow the mouse to (seem to) move beyond the edges of the screen.

		This means that the co-ordinates returned to mouseDrag() will be unbounded, and this
		can be used for things like custom slider controls or dragging objects around, where
		movement would be otherwise be limited by the mouse hitting the edges of the screen.

		The unbounded mode is automatically turned off when the mouse button is released, or
		it can be turned off explicitly by calling this method again.

		@param isEnabled                            whether to turn this mode on or off
		@param keepCursorVisibleUntilOffscreen      if set to false, the cursor will immediately be
													hidden; if true, it will only be hidden when it
													is moved beyond the edge of the screen
	*/
	void enableUnboundedMouseMovement (bool isEnabled, bool keepCursorVisibleUntilOffscreen = false);

	/** @internal */
	void handleEvent (ComponentPeer* peer, const Point<int>& positionWithinPeer, int64 time, const ModifierKeys& mods);
	/** @internal */
	void handleWheel (ComponentPeer* peer, const Point<int>& positionWithinPeer, int64 time, float x, float y);

private:

	friend class Desktop;
	friend class ComponentPeer;
	friend class MouseInputSourceInternal;
	ScopedPointer<MouseInputSourceInternal> pimpl;

	static Point<int> getCurrentMousePosition();

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (MouseInputSource);
};

#endif   // __JUCE_MOUSEINPUTSOURCE_JUCEHEADER__

/*** End of inlined file: juce_MouseInputSource.h ***/


#endif
#ifndef __JUCE_MOUSELISTENER_JUCEHEADER__

#endif
#ifndef __JUCE_SELECTEDITEMSET_JUCEHEADER__

#endif
#ifndef __JUCE_TOOLTIPCLIENT_JUCEHEADER__

/*** Start of inlined file: juce_TooltipClient.h ***/
#ifndef __JUCE_TOOLTIPCLIENT_JUCEHEADER__
#define __JUCE_TOOLTIPCLIENT_JUCEHEADER__

/**
	Components that want to use pop-up tooltips should implement this interface.

	A TooltipWindow will wait for the mouse to hover over a component that
	implements the TooltipClient interface, and when it finds one, it will display
	the tooltip returned by its getTooltip() method.

	@see TooltipWindow, SettableTooltipClient
*/
class JUCE_API  TooltipClient
{
public:
	/** Destructor. */
	virtual ~TooltipClient()  {}

	/** Returns the string that this object wants to show as its tooltip. */
	virtual String getTooltip() = 0;
};

/**
	An implementation of TooltipClient that stores the tooltip string and a method
	for changing it.

	This makes it easy to add a tooltip to a custom component, by simply adding this
	as a base class and calling setTooltip().

	Many of the Juce widgets already use this as a base class to implement their
	tooltips.

	@see TooltipClient, TooltipWindow
*/
class JUCE_API  SettableTooltipClient   : public TooltipClient
{
public:

	/** Destructor. */
	virtual ~SettableTooltipClient()                                {}

	/** Assigns a new tooltip to this object. */
	virtual void setTooltip (const String& newTooltip)              { tooltipString = newTooltip; }

	/** Returns the tooltip assigned to this object. */
	virtual String getTooltip()                                     { return tooltipString; }

protected:
	SettableTooltipClient() {}

private:
	String tooltipString;
};

#endif   // __JUCE_TOOLTIPCLIENT_JUCEHEADER__

/*** End of inlined file: juce_TooltipClient.h ***/


#endif
#ifndef __JUCE_CARETCOMPONENT_JUCEHEADER__

/*** Start of inlined file: juce_CaretComponent.h ***/
#ifndef __JUCE_CARETCOMPONENT_JUCEHEADER__
#define __JUCE_CARETCOMPONENT_JUCEHEADER__

/**
*/
class JUCE_API  CaretComponent   : public Component,
								   public Timer
{
public:

	/** Creates the caret component.
		The keyFocusOwner is an optional component which the caret will check, making
		itself visible only when the keyFocusOwner has keyboard focus.
	*/
	CaretComponent (Component* keyFocusOwner);

	/** Destructor. */
	~CaretComponent();

	/** Sets the caret's position to place it next to the given character.
		The area is the rectangle containing the entire character that the caret is
		positioned on, so by default a vertical-line caret may choose to just show itself
		at the left of this area. You can override this method to customise its size.
		This method will also force the caret to reset its timer and become visible (if
		appropriate), so that as it moves, you can see where it is.
	*/
	virtual void setCaretPosition (const Rectangle<int>& characterArea);

	/** A set of colour IDs to use to change the colour of various aspects of the caret.
		These constants can be used either via the Component::setColour(), or LookAndFeel::setColour()
		methods.
		@see Component::setColour, Component::findColour, LookAndFeel::setColour, LookAndFeel::findColour
	*/
	enum ColourIds
	{
		caretColourId    = 0x1000204, /**< The colour with which to draw the caret. */
	};

	/** @internal */
	void paint (Graphics& g);
	/** @internal */
	void timerCallback();

private:
	Component* owner;
	bool shouldBeShown() const;

	JUCE_DECLARE_NON_COPYABLE (CaretComponent);
};

#endif   // __JUCE_CARETCOMPONENT_JUCEHEADER__

/*** End of inlined file: juce_CaretComponent.h ***/


#endif
#ifndef __JUCE_KEYBOARDFOCUSTRAVERSER_JUCEHEADER__

#endif
#ifndef __JUCE_KEYLISTENER_JUCEHEADER__

#endif
#ifndef __JUCE_KEYPRESS_JUCEHEADER__

#endif
#ifndef __JUCE_MODIFIERKEYS_JUCEHEADER__

#endif
#ifndef __JUCE_SYSTEMCLIPBOARD_JUCEHEADER__

/*** Start of inlined file: juce_SystemClipboard.h ***/
#ifndef __JUCE_SYSTEMCLIPBOARD_JUCEHEADER__
#define __JUCE_SYSTEMCLIPBOARD_JUCEHEADER__

/**
	Handles reading/writing to the system's clipboard.
*/
class JUCE_API  SystemClipboard
{
public:
	/** Copies a string of text onto the clipboard */
	static void copyTextToClipboard (const String& text);

	/** Gets the current clipboard's contents.

		Obviously this might have come from another app, so could contain
		anything..
	*/
	static String getTextFromClipboard();
};

#endif   // __JUCE_SYSTEMCLIPBOARD_JUCEHEADER__

/*** End of inlined file: juce_SystemClipboard.h ***/


#endif
#ifndef __JUCE_TEXTEDITORKEYMAPPER_JUCEHEADER__

/*** Start of inlined file: juce_TextEditorKeyMapper.h ***/
#ifndef __JUCE_TEXTEDITORKEYMAPPER_JUCEHEADER__
#define __JUCE_TEXTEDITORKEYMAPPER_JUCEHEADER__

/** This class is used to invoke a range of text-editor navigation methods on
	an object, based upon a keypress event.

	It's currently used internally by the TextEditor and CodeEditorComponent.
*/
template <class CallbackClass>
struct TextEditorKeyMapper
{
	/** Checks the keypress and invokes one of a range of navigation functions that
		the target class must implement, based on the key event.
	*/
	static bool invokeKeyFunction (CallbackClass& target, const KeyPress& key)
	{
		const bool isShiftDown   = key.getModifiers().isShiftDown();
		const bool ctrlOrAltDown = key.getModifiers().isCtrlDown() || key.getModifiers().isAltDown();

		if (key == KeyPress (KeyPress::downKey, ModifierKeys::ctrlModifier, 0) && target.scrollUp())   return true;
		if (key == KeyPress (KeyPress::upKey,   ModifierKeys::ctrlModifier, 0) && target.scrollDown()) return true;

	   #if JUCE_MAC
		if (key.getModifiers().isCommandDown())
		{
			if (key.isKeyCode (KeyPress::upKey))        return target.moveCaretToTop (isShiftDown);
			if (key.isKeyCode (KeyPress::downKey))      return target.moveCaretToEnd (isShiftDown);
			if (key.isKeyCode (KeyPress::leftKey))      return target.moveCaretToStartOfLine (isShiftDown);
			if (key.isKeyCode (KeyPress::rightKey))     return target.moveCaretToEndOfLine (isShiftDown);
		}
	   #endif

		if (key.isKeyCode (KeyPress::upKey))        return target.moveCaretUp (isShiftDown);
		if (key.isKeyCode (KeyPress::downKey))      return target.moveCaretDown (isShiftDown);
		if (key.isKeyCode (KeyPress::leftKey))      return target.moveCaretLeft (ctrlOrAltDown, isShiftDown);
		if (key.isKeyCode (KeyPress::rightKey))     return target.moveCaretRight (ctrlOrAltDown, isShiftDown);
		if (key.isKeyCode (KeyPress::pageUpKey))    return target.pageUp (isShiftDown);
		if (key.isKeyCode (KeyPress::pageDownKey))  return target.pageDown (isShiftDown);

		if (key.isKeyCode (KeyPress::homeKey))  return ctrlOrAltDown ? target.moveCaretToTop (isShiftDown)
																	 : target.moveCaretToStartOfLine (isShiftDown);
		if (key.isKeyCode (KeyPress::endKey))   return ctrlOrAltDown ? target.moveCaretToEnd (isShiftDown)
																	 : target.moveCaretToEndOfLine (isShiftDown);

		if (key == KeyPress ('c', ModifierKeys::commandModifier, 0)
			  || key == KeyPress (KeyPress::insertKey, ModifierKeys::ctrlModifier, 0))
			return target.copyToClipboard();

		if (key == KeyPress ('x', ModifierKeys::commandModifier, 0)
			  || key == KeyPress (KeyPress::deleteKey, ModifierKeys::shiftModifier, 0))
			return target.cutToClipboard();

		if (key == KeyPress ('v', ModifierKeys::commandModifier, 0)
			  || key == KeyPress (KeyPress::insertKey, ModifierKeys::shiftModifier, 0))
			return target.pasteFromClipboard();

		if (key.isKeyCode (KeyPress::backspaceKey))     return target.deleteBackwards (ctrlOrAltDown);
		if (key.isKeyCode (KeyPress::deleteKey))        return target.deleteForwards (ctrlOrAltDown);

		if (key == KeyPress ('a', ModifierKeys::commandModifier, 0))
			return target.selectAll();

		if (key == KeyPress ('z', ModifierKeys::commandModifier, 0))
			return target.undo();

		if (key == KeyPress ('y', ModifierKeys::commandModifier, 0)
			 || key == KeyPress ('z', ModifierKeys::commandModifier | ModifierKeys::shiftModifier, 0))
			return target.redo();

		return false;
	}
};

#endif   // __JUCE_TEXTEDITORKEYMAPPER_JUCEHEADER__

/*** End of inlined file: juce_TextEditorKeyMapper.h ***/


#endif
#ifndef __JUCE_TEXTINPUTTARGET_JUCEHEADER__

/*** Start of inlined file: juce_TextInputTarget.h ***/
#ifndef __JUCE_TEXTINPUTTARGET_JUCEHEADER__
#define __JUCE_TEXTINPUTTARGET_JUCEHEADER__

/**
	An abstract base class which can be implemented by components that function as
	text editors.

	This class allows different types of text editor component to provide a uniform
	interface, which can be used by things like OS-specific input methods, on-screen
	keyboards, etc.
*/
class JUCE_API  TextInputTarget
{
public:

	/** */
	TextInputTarget() {}

	/** Destructor. */
	virtual ~TextInputTarget() {}

	/** Returns true if this input target is currently accepting input.
		For example, a text editor might return false if it's in read-only mode.
	*/
	virtual bool isTextInputActive() const = 0;

	/** Returns the extents of the selected text region, or an empty range if
		nothing is selected,
	*/
	virtual Range<int> getHighlightedRegion() const = 0;

	/** Sets the currently-selected text region. */
	virtual void setHighlightedRegion (const Range<int>& newRange) = 0;

	/** Sets a number of temporarily underlined sections.
		This is needed by MS Windows input method UI.
	*/
	virtual void setTemporaryUnderlining (const Array <Range<int> >& underlinedRegions) = 0;

	/** Returns a specified sub-section of the text. */
	virtual String getTextInRange (const Range<int>& range) const = 0;

	/** Inserts some text, overwriting the selected text region, if there is one. */
	virtual void insertTextAtCaret (const String& textToInsert) = 0;

	/** Returns the position of the caret, relative to the component's origin. */
	virtual Rectangle<int> getCaretRectangle() = 0;
};

#endif   // __JUCE_TEXTINPUTTARGET_JUCEHEADER__

/*** End of inlined file: juce_TextInputTarget.h ***/


#endif
#ifndef __JUCE_ARROWBUTTON_JUCEHEADER__

/*** Start of inlined file: juce_ArrowButton.h ***/
#ifndef __JUCE_ARROWBUTTON_JUCEHEADER__
#define __JUCE_ARROWBUTTON_JUCEHEADER__


/*** Start of inlined file: juce_Button.h ***/
#ifndef __JUCE_BUTTON_JUCEHEADER__
#define __JUCE_BUTTON_JUCEHEADER__


/*** Start of inlined file: juce_ApplicationCommandManager.h ***/
#ifndef __JUCE_APPLICATIONCOMMANDMANAGER_JUCEHEADER__
#define __JUCE_APPLICATIONCOMMANDMANAGER_JUCEHEADER__


/*** Start of inlined file: juce_ApplicationCommandTarget.h ***/
#ifndef __JUCE_APPLICATIONCOMMANDTARGET_JUCEHEADER__
#define __JUCE_APPLICATIONCOMMANDTARGET_JUCEHEADER__


/*** Start of inlined file: juce_ApplicationCommandInfo.h ***/
#ifndef __JUCE_APPLICATIONCOMMANDINFO_JUCEHEADER__
#define __JUCE_APPLICATIONCOMMANDINFO_JUCEHEADER__


/*** Start of inlined file: juce_ApplicationCommandID.h ***/
#ifndef __JUCE_APPLICATIONCOMMANDID_JUCEHEADER__
#define __JUCE_APPLICATIONCOMMANDID_JUCEHEADER__

/** A type used to hold the unique ID for an application command.

	This is a numeric type, so it can be stored as an integer.

	@see ApplicationCommandInfo, ApplicationCommandManager,
		 ApplicationCommandTarget, KeyPressMappingSet
*/
typedef int CommandID;

/** A set of general-purpose application command IDs.

	Because these commands are likely to be used in most apps, they're defined
	here to help different apps to use the same numeric values for them.

	Of course you don't have to use these, but some of them are used internally by
	Juce - e.g. the quit ID is recognised as a command by the JUCEApplication class.

	@see ApplicationCommandInfo, ApplicationCommandManager,
		 ApplicationCommandTarget, KeyPressMappingSet
*/
namespace StandardApplicationCommandIDs
{
	/** This command ID should be used to send a "Quit the App" command.

		This command is recognised by the JUCEApplication class, so if it is invoked
		and no other ApplicationCommandTarget handles the event first, the JUCEApplication
		object will catch it and call JUCEApplication::systemRequestedQuit().
	*/
	static const CommandID  quit           = 0x1001;

	/** The command ID that should be used to send a "Delete" command. */
	static const CommandID  del            = 0x1002;

	/** The command ID that should be used to send a "Cut" command. */
	static const CommandID  cut            = 0x1003;

	/** The command ID that should be used to send a "Copy to clipboard" command. */
	static const CommandID  copy           = 0x1004;

	/** The command ID that should be used to send a "Paste from clipboard" command. */
	static const CommandID  paste          = 0x1005;

	/** The command ID that should be used to send a "Select all" command. */
	static const CommandID  selectAll      = 0x1006;

	/** The command ID that should be used to send a "Deselect all" command. */
	static const CommandID  deselectAll    = 0x1007;
}

#endif   // __JUCE_APPLICATIONCOMMANDID_JUCEHEADER__

/*** End of inlined file: juce_ApplicationCommandID.h ***/

/**
	Holds information describing an application command.

	This object is used to pass information about a particular command, such as its
	name, description and other usage flags.

	When an ApplicationCommandTarget is asked to provide information about the commands
	it can perform, this is the structure gets filled-in to describe each one.

	@see ApplicationCommandTarget, ApplicationCommandTarget::getCommandInfo(),
		 ApplicationCommandManager
*/
struct JUCE_API  ApplicationCommandInfo
{

	explicit ApplicationCommandInfo (CommandID commandID) noexcept;

	/** Sets a number of the structures values at once.

		The meanings of each of the parameters is described below, in the appropriate
		member variable's description.
	*/
	void setInfo (const String& shortName,
				  const String& description,
				  const String& categoryName,
				  int flags) noexcept;

	/** An easy way to set or remove the isDisabled bit in the structure's flags field.

		If isActive is true, the flags member has the isDisabled bit cleared; if isActive
		is false, the bit is set.
	*/
	void setActive (bool isActive) noexcept;

	/** An easy way to set or remove the isTicked bit in the structure's flags field.
	*/
	void setTicked (bool isTicked) noexcept;

	/** Handy method for adding a keypress to the defaultKeypresses array.

		This is just so you can write things like:
		@code
		myinfo.addDefaultKeypress ('s', ModifierKeys::commandModifier);
		@endcode
		instead of
		@code
		myinfo.defaultKeypresses.add (KeyPress ('s', ModifierKeys::commandModifier));
		@endcode
	*/
	void addDefaultKeypress (int keyCode,
							 const ModifierKeys& modifiers) noexcept;

	/** The command's unique ID number.
	*/
	CommandID commandID;

	/** A short name to describe the command.

		This should be suitable for use in menus, on buttons that trigger the command, etc.

		You can use the setInfo() method to quickly set this and some of the command's
		other properties.
	*/
	String shortName;

	/** A longer description of the command.

		This should be suitable for use in contexts such as a KeyMappingEditorComponent or
		pop-up tooltip describing what the command does.

		You can use the setInfo() method to quickly set this and some of the command's
		other properties.
	*/
	String description;

	/** A named category that the command fits into.

		You can give your commands any category you like, and these will be displayed in
		contexts such as the KeyMappingEditorComponent, where the category is used to group
		commands together.

		You can use the setInfo() method to quickly set this and some of the command's
		other properties.
	*/
	String categoryName;

	/** A list of zero or more keypresses that should be used as the default keys for
		this command.

		Methods such as KeyPressMappingSet::resetToDefaultMappings() will use the keypresses in
		this list to initialise the default set of key-to-command mappings.

		@see addDefaultKeypress
	*/
	Array <KeyPress> defaultKeypresses;

	/** Flags describing the ways in which this command should be used.

		A bitwise-OR of these values is stored in the ApplicationCommandInfo::flags
		variable.
	*/
	enum CommandFlags
	{
		/** Indicates that the command can't currently be performed.

			The ApplicationCommandTarget::getCommandInfo() method must set this flag if it's
			not currently permissable to perform the command. If the flag is set, then
			components that trigger the command, e.g. PopupMenu, may choose to grey-out the
			command or show themselves as not being enabled.

			@see ApplicationCommandInfo::setActive
		*/
		isDisabled                  = 1 << 0,

		/** Indicates that the command should have a tick next to it on a menu.

			If your command is shown on a menu and this is set, it'll show a tick next to
			it. Other components such as buttons may also use this flag to indicate that it
			is a value that can be toggled, and is currently in the 'on' state.

			@see ApplicationCommandInfo::setTicked
		*/
		isTicked                    = 1 << 1,

		/** If this flag is present, then when a KeyPressMappingSet invokes the command,
			it will call the command twice, once on key-down and again on key-up.

			@see ApplicationCommandTarget::InvocationInfo
		*/
		wantsKeyUpDownCallbacks     = 1 << 2,

		/** If this flag is present, then a KeyMappingEditorComponent will not display the
			command in its list.
		*/
		hiddenFromKeyEditor         = 1 << 3,

		/** If this flag is present, then a KeyMappingEditorComponent will display the
			command in its list, but won't allow the assigned keypress to be changed.
		*/
		readOnlyInKeyEditor         = 1 << 4,

		/** If this flag is present and the command is invoked from a keypress, then any
			buttons or menus that are also connected to the command will not flash to
			indicate that they've been triggered.
		*/
		dontTriggerVisualFeedback   = 1 << 5
	};

	/** A bitwise-OR of the values specified in the CommandFlags enum.

		You can use the setInfo() method to quickly set this and some of the command's
		other properties.
	*/
	int flags;
};

#endif   // __JUCE_APPLICATIONCOMMANDINFO_JUCEHEADER__

/*** End of inlined file: juce_ApplicationCommandInfo.h ***/

class Component;

/**
	A command target publishes a list of command IDs that it can perform.

	An ApplicationCommandManager despatches commands to targets, which must be
	able to provide information about what commands they can handle.

	To create a target, you'll need to inherit from this class, implementing all of
	its pure virtual methods.

	For info about how a target is chosen to receive a command, see
	ApplicationCommandManager::getFirstCommandTarget().

	@see ApplicationCommandManager, ApplicationCommandInfo
*/
class JUCE_API  ApplicationCommandTarget
{
public:

	/** Creates a command target. */
	ApplicationCommandTarget();

	/** Destructor. */
	virtual ~ApplicationCommandTarget();

	/**
	*/
	struct JUCE_API  InvocationInfo
	{

		InvocationInfo (const CommandID commandID);

		/** The UID of the command that should be performed. */
		CommandID commandID;

		/** The command's flags.

			See ApplicationCommandInfo for a description of these flag values.
		*/
		int commandFlags;

		/** The types of context in which the command might be called. */
		enum InvocationMethod
		{
			direct = 0,     /**< The command is being invoked directly by a piece of code. */
			fromKeyPress,   /**< The command is being invoked by a key-press. */
			fromMenu,       /**< The command is being invoked by a menu selection. */
			fromButton      /**< The command is being invoked by a button click. */
		};

		/** The type of event that triggered this command. */
		InvocationMethod invocationMethod;

		/** If triggered by a keypress or menu, this will be the component that had the
			keyboard focus at the time.

			If triggered by a button, it may be set to that component, or it may be null.
		*/
		Component* originatingComponent;

		/** The keypress that was used to invoke it.

			Note that this will be an invalid keypress if the command was invoked
			by some other means than a keyboard shortcut.
		*/
		KeyPress keyPress;

		/** True if the callback is being invoked when the key is pressed,
			false if the key is being released.

			@see KeyPressMappingSet::addCommand()
		*/
		bool isKeyDown;

		/** If the key is being released, this indicates how long it had been held
			down for.

			(Only relevant if isKeyDown is false.)
		*/
		int millisecsSinceKeyPressed;
	};

	/** This must return the next target to try after this one.

		When a command is being sent, and the first target can't handle
		that command, this method is used to determine the next target that should
		be tried.

		It may return 0 if it doesn't know of another target.

		If your target is a Component, you would usually use the findFirstTargetParentComponent()
		method to return a parent component that might want to handle it.

		@see invoke
	*/
	virtual ApplicationCommandTarget* getNextCommandTarget() = 0;

	/** This must return a complete list of commands that this target can handle.

		Your target should add all the command IDs that it handles to the array that is
		passed-in.
	*/
	virtual void getAllCommands (Array <CommandID>& commands) = 0;

	/** This must provide details about one of the commands that this target can perform.

		This will be called with one of the command IDs that the target provided in its
		getAllCommands() methods.

		It should fill-in all appropriate fields of the ApplicationCommandInfo structure with
		suitable information about the command. (The commandID field will already have been filled-in
		by the caller).

		The easiest way to set the info is using the ApplicationCommandInfo::setInfo() method to
		set all the fields at once.

		If the command is currently inactive for some reason, this method must use
		ApplicationCommandInfo::setActive() to make that clear, (or it should set the isDisabled
		bit of the ApplicationCommandInfo::flags field).

		Any default key-presses for the command should be appended to the
		ApplicationCommandInfo::defaultKeypresses field.

		Note that if you change something that affects the status of the commands
		that would be returned by this method (e.g. something that makes some commands
		active or inactive), you should call ApplicationCommandManager::commandStatusChanged()
		to cause the manager to refresh its status.
	*/
	virtual void getCommandInfo (CommandID commandID, ApplicationCommandInfo& result) = 0;

	/** This must actually perform the specified command.

		If this target is able to perform the command specified by the commandID field of the
		InvocationInfo structure, then it should do so, and must return true.

		If it can't handle this command, it should return false, which tells the caller to pass
		the command on to the next target in line.

		@see invoke, ApplicationCommandManager::invoke
	*/
	virtual bool perform (const InvocationInfo& info) = 0;

	/** Makes this target invoke a command.

		Your code can call this method to invoke a command on this target, but normally
		you'd call it indirectly via ApplicationCommandManager::invoke() or
		ApplicationCommandManager::invokeDirectly().

		If this target can perform the given command, it will call its perform() method to
		do so. If not, then getNextCommandTarget() will be used to determine the next target
		to try, and the command will be passed along to it.

		@param invocationInfo       this must be correctly filled-in, describing the context for
									the invocation.
		@param asynchronously       if false, the command will be performed before this method returns.
									If true, a message will be posted so that the command will be performed
									later on the message thread, and this method will return immediately.
		@see perform, ApplicationCommandManager::invoke
	*/
	bool invoke (const InvocationInfo& invocationInfo,
				 const bool asynchronously);

	/** Invokes a given command directly on this target.

		This is just an easy way to call invoke() without having to fill out the InvocationInfo
		structure.
	*/
	bool invokeDirectly (const CommandID commandID,
						 const bool asynchronously);

	/** Searches this target and all subsequent ones for the first one that can handle
		the specified command.

		This will use getNextCommandTarget() to determine the chain of targets to try
		after this one.
	*/
	ApplicationCommandTarget* getTargetForCommand (const CommandID commandID);

	/** Checks whether this command can currently be performed by this target.

		This will return true only if a call to getCommandInfo() doesn't set the
		isDisabled flag to indicate that the command is inactive.
	*/
	bool isCommandActive (const CommandID commandID);

	/** If this object is a Component, this method will seach upwards in its current
		UI hierarchy for the next parent component that implements the
		ApplicationCommandTarget class.

		If your target is a Component, this is a very handy method to use in your
		getNextCommandTarget() implementation.
	*/
	ApplicationCommandTarget* findFirstTargetParentComponent();

private:

	class MessageTarget;
	friend class MessageTarget;
	friend class ScopedPointer<MessageTarget>;
	ScopedPointer<MessageTarget> messageInvoker;

	bool tryToInvoke (const InvocationInfo& info, bool async);

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ApplicationCommandTarget);
};

#endif   // __JUCE_APPLICATIONCOMMANDTARGET_JUCEHEADER__

/*** End of inlined file: juce_ApplicationCommandTarget.h ***/

class KeyPressMappingSet;
class ApplicationCommandManagerListener;
class Desktop;

/**
	One of these objects holds a list of all the commands your app can perform,
	and despatches these commands when needed.

	Application commands are a good way to trigger actions in your app, e.g. "Quit",
	"Copy", "Paste", etc. Menus, buttons and keypresses can all be given commands
	to invoke automatically, which means you don't have to handle the result of a menu
	or button click manually. Commands are despatched to ApplicationCommandTarget objects
	which can choose which events they want to handle.

	This architecture also allows for nested ApplicationCommandTargets, so that for example
	you could have two different objects, one inside the other, both of which can respond to
	a "delete" command. Depending on which one has focus, the command will be sent to the
	appropriate place, regardless of whether it was triggered by a menu, keypress or some other
	method.

	To set up your app to use commands, you'll need to do the following:

	- Create a global ApplicationCommandManager to hold the list of all possible
	  commands. (This will also manage a set of key-mappings for them).

	- Make some of your UI components (or other objects) inherit from ApplicationCommandTarget.
	  This allows the object to provide a list of commands that it can perform, and
	  to handle them.

	- Register each type of command using ApplicationCommandManager::registerAllCommandsForTarget(),
	  or ApplicationCommandManager::registerCommand().

	- If you want key-presses to trigger your commands, use the ApplicationCommandManager::getKeyMappings()
	  method to access the key-mapper object, which you will need to register as a key-listener
	  in whatever top-level component you're using. See the KeyPressMappingSet class for more help
	  about setting this up.

	- Use methods such as PopupMenu::addCommandItem() or Button::setCommandToTrigger() to
	  cause these commands to be invoked automatically.

	- Commands can be invoked directly by your code using ApplicationCommandManager::invokeDirectly().

	When a command is invoked, the ApplicationCommandManager will try to choose the best
	ApplicationCommandTarget to receive the specified command. To do this it will use the
	current keyboard focus to see which component might be interested, and will search the
	component hierarchy for those that also implement the ApplicationCommandTarget interface.
	If an ApplicationCommandTarget isn't interested in the command that is being invoked, then
	the next one in line will be tried (see the ApplicationCommandTarget::getNextCommandTarget()
	method), and so on until ApplicationCommandTarget::getNextCommandTarget() returns 0. At this
	point if the command still hasn't been performed, it will be passed to the current
	JUCEApplication object (which is itself an ApplicationCommandTarget).

	To exert some custom control over which ApplicationCommandTarget is chosen to invoke a command,
	you can override the ApplicationCommandManager::getFirstCommandTarget() method and choose
	the object yourself.

	@see ApplicationCommandTarget, ApplicationCommandInfo
*/
class JUCE_API  ApplicationCommandManager   : private AsyncUpdater,
											  private FocusChangeListener
{
public:

	/** Creates an ApplicationCommandManager.

		Once created, you'll need to register all your app's commands with it, using
		ApplicationCommandManager::registerAllCommandsForTarget() or
		ApplicationCommandManager::registerCommand().
	*/
	ApplicationCommandManager();

	/** Destructor.

		Make sure that you don't delete this if pointers to it are still being used by
		objects such as PopupMenus or Buttons.
	*/
	virtual ~ApplicationCommandManager();

	/** Clears the current list of all commands.

		Note that this will also clear the contents of the KeyPressMappingSet.
	*/
	void clearCommands();

	/** Adds a command to the list of registered commands.

		@see registerAllCommandsForTarget
	*/
	void registerCommand (const ApplicationCommandInfo& newCommand);

	/** Adds all the commands that this target publishes to the manager's list.

		This will use ApplicationCommandTarget::getAllCommands() and ApplicationCommandTarget::getCommandInfo()
		to get details about all the commands that this target can do, and will call
		registerCommand() to add each one to the manger's list.

		@see registerCommand
	*/
	void registerAllCommandsForTarget (ApplicationCommandTarget* target);

	/** Removes the command with a specified ID.

		Note that this will also remove any key mappings that are mapped to the command.
	*/
	void removeCommand (CommandID commandID);

	/** This should be called to tell the manager that one of its registered commands may have changed
		its active status.

		Because the command manager only finds out whether a command is active or inactive by querying
		the current ApplicationCommandTarget, this is used to tell it that things may have changed. It
		allows things like buttons to update their enablement, etc.

		This method will cause an asynchronous call to ApplicationCommandManagerListener::applicationCommandListChanged()
		for any registered listeners.
	*/
	void commandStatusChanged();

	/** Returns the number of commands that have been registered.

		@see registerCommand
	*/
	int getNumCommands() const noexcept                                             { return commands.size(); }

	/** Returns the details about one of the registered commands.

		The index is between 0 and (getNumCommands() - 1).
	*/
	const ApplicationCommandInfo* getCommandForIndex (int index) const noexcept     { return commands [index]; }

	/** Returns the details about a given command ID.

		This will search the list of registered commands for one with the given command
		ID number, and return its associated info. If no matching command is found, this
		will return 0.
	*/
	const ApplicationCommandInfo* getCommandForID (CommandID commandID) const noexcept;

	/** Returns the name field for a command.

		An empty string is returned if no command with this ID has been registered.
		@see getDescriptionOfCommand
	*/
	String getNameOfCommand (CommandID commandID) const noexcept;

	/** Returns the description field for a command.

		An empty string is returned if no command with this ID has been registered. If the
		command has no description, this will return its short name field instead.

		@see getNameOfCommand
	*/
	String getDescriptionOfCommand (CommandID commandID) const noexcept;

	/** Returns the list of categories.

		This will go through all registered commands, and return a list of all the distict
		categoryName values from their ApplicationCommandInfo structure.

		@see getCommandsInCategory()
	*/
	StringArray getCommandCategories() const;

	/** Returns a list of all the command UIDs in a particular category.

		@see getCommandCategories()
	*/
	Array<CommandID> getCommandsInCategory (const String& categoryName) const;

	/** Returns the manager's internal set of key mappings.

		This object can be used to edit the keypresses. To actually link this object up
		to invoke commands when a key is pressed, see the comments for the KeyPressMappingSet
		class.

		@see KeyPressMappingSet
	*/
	KeyPressMappingSet* getKeyMappings() const noexcept                         { return keyMappings; }

	/** Invokes the given command directly, sending it to the default target.

		This is just an easy way to call invoke() without having to fill out the InvocationInfo
		structure.
	*/
	bool invokeDirectly (CommandID commandID, bool asynchronously);

	/** Sends a command to the default target.

		This will choose a target using getFirstCommandTarget(), and send the specified command
		to it using the ApplicationCommandTarget::invoke() method. This means that if the
		first target can't handle the command, it will be passed on to targets further down the
		chain (see ApplicationCommandTarget::invoke() for more info).

		@param invocationInfo       this must be correctly filled-in, describing the context for
									the invocation.
		@param asynchronously       if false, the command will be performed before this method returns.
									If true, a message will be posted so that the command will be performed
									later on the message thread, and this method will return immediately.

		@see ApplicationCommandTarget::invoke
	*/
	bool invoke (const ApplicationCommandTarget::InvocationInfo& invocationInfo,
				 bool asynchronously);

	/** Chooses the ApplicationCommandTarget to which a command should be sent.

		Whenever the manager needs to know which target a command should be sent to, it calls
		this method to determine the first one to try.

		By default, this method will return the target that was set by calling setFirstCommandTarget().
		If no target is set, it will return the result of findDefaultComponentTarget().

		If you need to make sure all commands go via your own custom target, then you can
		either use setFirstCommandTarget() to specify a single target, or override this method
		if you need more complex logic to choose one.

		It may return 0 if no targets are available.

		@see getTargetForCommand, invoke, invokeDirectly
	*/
	virtual ApplicationCommandTarget* getFirstCommandTarget (CommandID commandID);

	/** Sets a target to be returned by getFirstCommandTarget().

		If this is set to 0, then getFirstCommandTarget() will by default return the
		result of findDefaultComponentTarget().

		If you use this to set a target, make sure you call setFirstCommandTarget (0) before
		deleting the target object.
	*/
	void setFirstCommandTarget (ApplicationCommandTarget* newTarget) noexcept;

	/** Tries to find the best target to use to perform a given command.

		This will call getFirstCommandTarget() to find the preferred target, and will
		check whether that target can handle the given command. If it can't, then it'll use
		ApplicationCommandTarget::getNextCommandTarget() to find the next one to try, and
		so on until no more are available.

		If no targets are found that can perform the command, this method will return 0.

		If a target is found, then it will get the target to fill-in the upToDateInfo
		structure with the latest info about that command, so that the caller can see
		whether the command is disabled, ticked, etc.
	*/
	ApplicationCommandTarget* getTargetForCommand (CommandID commandID,
												   ApplicationCommandInfo& upToDateInfo);

	/** Registers a listener that will be called when various events occur. */
	void addListener (ApplicationCommandManagerListener* listener);

	/** Deregisters a previously-added listener. */
	void removeListener (ApplicationCommandManagerListener* listener);

	/** Looks for a suitable command target based on which Components have the keyboard focus.

		This is used by the default implementation of ApplicationCommandTarget::getFirstCommandTarget(),
		but is exposed here in case it's useful.

		It tries to pick the best ApplicationCommandTarget by looking at focused components, top level
		windows, etc., and using the findTargetForComponent() method.
	*/
	static ApplicationCommandTarget* findDefaultComponentTarget();

	/** Examines this component and all its parents in turn, looking for the first one
		which is a ApplicationCommandTarget.

		Returns the first ApplicationCommandTarget that it finds, or 0 if none of them implement
		that class.
	*/
	static ApplicationCommandTarget* findTargetForComponent (Component* component);

private:

	OwnedArray <ApplicationCommandInfo> commands;
	ListenerList <ApplicationCommandManagerListener> listeners;
	ScopedPointer <KeyPressMappingSet> keyMappings;
	ApplicationCommandTarget* firstTarget;

	void sendListenerInvokeCallback (const ApplicationCommandTarget::InvocationInfo& info);
	void handleAsyncUpdate();
	void globalFocusChanged (Component*);

   #if JUCE_CATCH_DEPRECATED_CODE_MISUSE
	// This is just here to cause a compile error in old code that hasn't been changed to use the new
	// version of this method.
	virtual short getFirstCommandTarget() { return 0; }
   #endif

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ApplicationCommandManager);
};

/**
	A listener that receives callbacks from an ApplicationCommandManager when
	commands are invoked or the command list is changed.

	@see ApplicationCommandManager::addListener, ApplicationCommandManager::removeListener

*/
class JUCE_API  ApplicationCommandManagerListener
{
public:

	/** Destructor. */
	virtual ~ApplicationCommandManagerListener()  {}

	/** Called when an app command is about to be invoked. */
	virtual void applicationCommandInvoked (const ApplicationCommandTarget::InvocationInfo& info) = 0;

	/** Called when commands are registered or deregistered from the
		command manager, or when commands are made active or inactive.

		Note that if you're using this to watch for changes to whether a command is disabled,
		you'll need to make sure that ApplicationCommandManager::commandStatusChanged() is called
		whenever the status of your command might have changed.
	*/
	virtual void applicationCommandListChanged() = 0;
};

#endif   // __JUCE_APPLICATIONCOMMANDMANAGER_JUCEHEADER__

/*** End of inlined file: juce_ApplicationCommandManager.h ***/


/*** Start of inlined file: juce_TooltipWindow.h ***/
#ifndef __JUCE_TOOLTIPWINDOW_JUCEHEADER__
#define __JUCE_TOOLTIPWINDOW_JUCEHEADER__

/**
	A window that displays a pop-up tooltip when the mouse hovers over another component.

	To enable tooltips in your app, just create a single instance of a TooltipWindow
	object.

	The TooltipWindow object will then stay invisible, waiting until the mouse
	hovers for the specified length of time - it will then see if it's currently
	over a component which implements the TooltipClient interface, and if so,
	it will make itself visible to show the tooltip in the appropriate place.

	@see TooltipClient, SettableTooltipClient
*/
class JUCE_API  TooltipWindow  : public Component,
								 private Timer
{
public:

	/** Creates a tooltip window.

		Make sure your app only creates one instance of this class, otherwise you'll
		get multiple overlaid tooltips appearing. The window will initially be invisible
		and will make itself visible when it needs to display a tip.

		To change the style of tooltips, see the LookAndFeel class for its tooltip
		methods.

		@param parentComponent  if set to 0, the TooltipWindow will appear on the desktop,
								otherwise the tooltip will be added to the given parent
								component.
		@param millisecondsBeforeTipAppears     the time for which the mouse has to stay still
												before a tooltip will be shown

		@see TooltipClient, LookAndFeel::drawTooltip, LookAndFeel::getTooltipSize
	*/
	explicit TooltipWindow (Component* parentComponent = nullptr,
							int millisecondsBeforeTipAppears = 700);

	/** Destructor. */
	~TooltipWindow();

	/** Changes the time before the tip appears.
		This lets you change the value that was set in the constructor.
	*/
	void setMillisecondsBeforeTipAppears (int newTimeMs = 700) noexcept;

	/** A set of colour IDs to use to change the colour of various aspects of the tooltip.

		These constants can be used either via the Component::setColour(), or LookAndFeel::setColour()
		methods.

		@see Component::setColour, Component::findColour, LookAndFeel::setColour, LookAndFeel::findColour
	*/
	enum ColourIds
	{
		backgroundColourId      = 0x1001b00,    /**< The colour to fill the background with. */
		textColourId            = 0x1001c00,    /**< The colour to use for the text. */
		outlineColourId         = 0x1001c10     /**< The colour to use to draw an outline around the tooltip. */
	};

private:

	int millisecondsBeforeTipAppears;
	Point<int> lastMousePos;
	int mouseClicks;
	unsigned int lastCompChangeTime, lastHideTime;
	Component* lastComponentUnderMouse;
	bool changedCompsSinceShown;
	String tipShowing, lastTipUnderMouse;

	void paint (Graphics& g);
	void mouseEnter (const MouseEvent& e);
	void timerCallback();

	static String getTipFor (Component* c);
	void showFor (const String& tip);
	void hide();

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (TooltipWindow);
};

#endif   // __JUCE_TOOLTIPWINDOW_JUCEHEADER__

/*** End of inlined file: juce_TooltipWindow.h ***/


/*** Start of inlined file: juce_ComponentBuilder.h ***/
#ifndef __JUCE_COMPONENTBUILDER_JUCEHEADER__
#define __JUCE_COMPONENTBUILDER_JUCEHEADER__

/**
	Loads and maintains a tree of Components from a ValueTree that represents them.

	To allow the state of a tree of components to be saved as a ValueTree and re-loaded,
	this class lets you register a set of type-handlers for the different components that
	are involved, and then uses these types to re-create a set of components from its
	stored state.

	Essentially, to use this, you need to create a ComponentBuilder with your ValueTree,
	then use registerTypeHandler() to give it a set of type handlers that can cope with
	all the items in your tree. Then you can call getComponent() to build the component.
	Once you've got the component you can either take it and delete the ComponentBuilder
	object, or if you keep the ComponentBuilder around, it'll monitor any changes in the
	ValueTree and automatically update the component to reflect these changes.
*/
class JUCE_API  ComponentBuilder  : public ValueTree::Listener
{
public:
	/** Creates a ComponentBuilder that will use the given state.
		Once you've created your builder, you should use registerTypeHandler() to register some
		type handlers for it, and then you can call createComponent() or getManagedComponent()
		to get the actual component.
	*/
	explicit ComponentBuilder (const ValueTree& state);

	/** Creates a builder that doesn't have a state object. */
	ComponentBuilder();

	/** Destructor. */
	~ComponentBuilder();

	/** This is the ValueTree data object that the builder is working with. */
	ValueTree state;

	/** Returns the builder's component (creating it if necessary).

		The first time that this method is called, the builder will attempt to create a component
		from the ValueTree, so you must have registered some suitable type handlers before calling
		this. If there's a problem and the component can't be created, this method returns 0.

		The component that is returned is owned by this ComponentBuilder, so you can put it inside
		your own parent components, but don't delete it! The ComponentBuilder will delete it automatically
		when the builder is destroyed. If you want to get a component that you can delete yourself,
		call createComponent() instead.

		The ComponentBuilder will update this component if any changes are made to the ValueTree, so if
		there's a chance that the tree might change, be careful not to keep any pointers to sub-components,
		as they may be changed or removed.
	*/
	Component* getManagedComponent();

	/** Creates and returns a new instance of the component that the ValueTree represents.
		The caller is responsible for using and deleting the object that is returned. Unlike
		getManagedComponent(), the component that is returned will not be updated by the builder.
	*/
	Component* createComponent();

	/**
		The class is a base class for objects that manage the loading of a type of component
		from a ValueTree.

		To store and re-load a tree of components as a ValueTree, each component type must have
		a TypeHandler to represent it.

		@see ComponentBuilder::registerTypeHandler(), Drawable::registerDrawableTypeHandlers()
	*/
	class JUCE_API  TypeHandler
	{
	public:

		/** Creates a TypeHandler.
			The valueTreeType must be the type name of the ValueTrees that this handler can parse.
		*/
		explicit TypeHandler (const Identifier& valueTreeType);

		/** Destructor. */
		virtual ~TypeHandler();

		/** Returns the type of the ValueTrees that this handler can parse. */
		const Identifier type;

		/** Returns the builder that this type is registered with. */
		ComponentBuilder* getBuilder() const noexcept;

		/** This method must create a new component from the given state, add it to the specified
			parent component (which may be null), and return it.

			The ValueTree will have been pre-checked to make sure that its type matches the type
			that this handler supports.

			There's no need to set the new Component's ID to match that of the state - the builder
			will take care of that itself.
		*/
		virtual Component* addNewComponentFromState (const ValueTree& state, Component* parent) = 0;

		/** This method must update an existing component from a new ValueTree state.

			A component that has been created with addNewComponentFromState() may need to be updated
			if the ValueTree changes, so this method is used to do that. Your implementation must do
			whatever's necessary to update the component from the new state provided.

			The ValueTree will have been pre-checked to make sure that its type matches the type
			that this handler supports, and the component will have been created by this type's
			addNewComponentFromState() method.
		*/
		virtual void updateComponentFromState (Component* component, const ValueTree& state) = 0;

	private:

		friend class ComponentBuilder;
		ComponentBuilder* builder;

		JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (TypeHandler);
	};

	/** Adds a type handler that the builder can use when trying to load components.
		@see Drawable::registerDrawableTypeHandlers()
	*/
	void registerTypeHandler (TypeHandler* type);

	/** Tries to find a registered type handler that can load a component from the given ValueTree. */
	TypeHandler* getHandlerForState (const ValueTree& state) const;

	/** Returns the number of registered type handlers.
		@see getHandler, registerTypeHandler
	*/
	int getNumHandlers() const noexcept;

	/** Returns one of the registered type handlers.
		@see getNumHandlers, registerTypeHandler
	*/
	TypeHandler* getHandler (int index) const noexcept;

	/** Registers handlers for various standard juce components. */
	void registerStandardComponentTypes();

	/** This class is used when references to images need to be stored in ValueTrees.

		An instance of an ImageProvider provides a mechanism for converting an Image to/from
		a reference, which may be a file, URL, ID string, or whatever system is appropriate in
		your app.

		When you're loading components from a ValueTree that may need a way of loading images, you
		should call ComponentBuilder::setImageProvider() to supply a suitable provider before
		trying to load the component.

		@see ComponentBuilder::setImageProvider()
	*/
	class JUCE_API  ImageProvider
	{
	public:
		ImageProvider() {}
		virtual ~ImageProvider() {}

		/** Retrieves the image associated with this identifier, which could be any
			kind of string, number, filename, etc.

			The image that is returned will be owned by the caller, but it may come
			from the ImageCache.
		*/
		virtual Image getImageForIdentifier (const var& imageIdentifier) = 0;

		/** Returns an identifier to be used to refer to a given image.
			This is used when a reference to an image is stored in a ValueTree.
		*/
		virtual var getIdentifierForImage (const Image& image) = 0;
	};

	/** Gives the builder an ImageProvider object that the type handlers can use when
		loading images from stored references.

		The object that is passed in is not owned by the builder, so the caller must delete
		it when it is no longer needed, but not while the builder may still be using it. To
		clear the image provider, just call setImageProvider (nullptr).
	*/
	void setImageProvider (ImageProvider* newImageProvider) noexcept;

	/** Returns the current image provider that this builder is using, or 0 if none has been set. */
	ImageProvider* getImageProvider() const noexcept;

	/** Updates the children of a parent component by updating them from the children of
		a given ValueTree.
	*/
	void updateChildComponents (Component& parent, const ValueTree& children);

	/** An identifier for the property of the ValueTrees that is used to store a unique ID
		for that component.
	*/
	static const Identifier idProperty;

	/**
	*/
	static void initialiseFromValueTree (Component& component,
										 const ValueTree& state,
										 ImageProvider* imageProvider);

	/** @internal */
	void valueTreePropertyChanged (ValueTree& treeWhosePropertyHasChanged, const Identifier& property);
	/** @internal */
	void valueTreeChildAdded (ValueTree& parentTree, ValueTree& childWhichHasBeenAdded);
	/** @internal */
	void valueTreeChildRemoved (ValueTree& parentTree, ValueTree& childWhichHasBeenRemoved);
	/** @internal */
	void valueTreeChildOrderChanged (ValueTree& parentTree);
	/** @internal */
	void valueTreeParentChanged (ValueTree& treeWhoseParentHasChanged);
	/** @internal */
	static void refreshBasicComponentProperties (Component&, const ValueTree&);
	/** @internal */
	static RelativeRectangle getComponentBounds (const ValueTree&);

private:

	OwnedArray <TypeHandler> types;
	ScopedPointer<Component> component;
	ImageProvider* imageProvider;
   #if JUCE_DEBUG
	WeakReference<Component> componentRef;
   #endif

	static const Identifier positionID;
	void initialiseRecursively (Component&, const ValueTree&);

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ComponentBuilder);
};

#endif   // __JUCE_COMPONENTBUILDER_JUCEHEADER__

/*** End of inlined file: juce_ComponentBuilder.h ***/

/**
	A base class for buttons.

	This contains all the logic for button behaviours such as enabling/disabling,
	responding to shortcut keystrokes, auto-repeating when held down, toggle-buttons
	and radio groups, etc.

	@see TextButton, DrawableButton, ToggleButton
*/
class JUCE_API  Button  : public Component,
						  public SettableTooltipClient,
						  public ApplicationCommandManagerListener,
						  public ValueListener,
						  private KeyListener
{
protected:

	/** Creates a button.

		@param buttonName           the text to put in the button (the component's name is also
									initially set to this string, but these can be changed later
									using the setName() and setButtonText() methods)
	*/
	explicit Button (const String& buttonName);

public:
	/** Destructor. */
	virtual ~Button();

	/** Changes the button's text.

		@see getButtonText
	*/
	void setButtonText (const String& newText);

	/** Returns the text displayed in the button.

		@see setButtonText
	*/
	const String& getButtonText() const               { return text; }

	/** Returns true if the button is currently being held down by the mouse.

		@see isOver
	*/
	bool isDown() const noexcept;

	/** Returns true if the mouse is currently over the button.

		This will be also be true if the mouse is being held down.

		@see isDown
	*/
	bool isOver() const noexcept;

	/** A button has an on/off state associated with it, and this changes that.

		By default buttons are 'off' and for simple buttons that you click to perform
		an action you won't change this. Toggle buttons, however will want to
		change their state when turned on or off.

		@param shouldBeOn               whether to set the button's toggle state to be on or
										off. If it's a member of a button group, this will
										always try to turn it on, and to turn off any other
										buttons in the group
		@param sendChangeNotification   if true, a callback will be made to clicked(); if false
										the button will be repainted but no notification will
										be sent
		@see getToggleState, setRadioGroupId
	*/
	void setToggleState (bool shouldBeOn,
						 bool sendChangeNotification);

	/** Returns true if the button in 'on'.

		By default buttons are 'off' and for simple buttons that you click to perform
		an action you won't change this. Toggle buttons, however will want to
		change their state when turned on or off.

		@see setToggleState
	*/
	bool getToggleState() const noexcept                        { return isOn.getValue(); }

	/** Returns the Value object that represents the botton's toggle state.
		You can use this Value object to connect the button's state to external values or setters,
		either by taking a copy of the Value, or by using Value::referTo() to make it point to
		your own Value object.
		@see getToggleState, Value
	*/
	Value& getToggleStateValue()                                { return isOn; }

	/** This tells the button to automatically flip the toggle state when
		the button is clicked.

		If set to true, then before the clicked() callback occurs, the toggle-state
		of the button is flipped.
	*/
	void setClickingTogglesState (bool shouldToggle) noexcept;

	/** Returns true if this button is set to be an automatic toggle-button.

		This returns the last value that was passed to setClickingTogglesState().
	*/
	bool getClickingTogglesState() const noexcept;

	/** Enables the button to act as a member of a mutually-exclusive group
		of 'radio buttons'.

		If the group ID is set to a non-zero number, then this button will
		act as part of a group of buttons with the same ID, only one of
		which can be 'on' at the same time. Note that when it's part of
		a group, clicking a toggle-button that's 'on' won't turn it off.

		To find other buttons with the same ID, this button will search through
		its sibling components for ToggleButtons, so all the buttons for a
		particular group must be placed inside the same parent component.

		Set the group ID back to zero if you want it to act as a normal toggle
		button again.

		@see getRadioGroupId
	*/
	void setRadioGroupId (int newGroupId);

	/** Returns the ID of the group to which this button belongs.

		(See setRadioGroupId() for an explanation of this).
	*/
	int getRadioGroupId() const noexcept                        { return radioGroupId; }

	/**
		Used to receive callbacks when a button is clicked.

		@see Button::addListener, Button::removeListener
	*/
	class JUCE_API  Listener
	{
	public:
		/** Destructor. */
		virtual ~Listener()                                     {}

		/** Called when the button is clicked. */
		virtual void buttonClicked (Button* button) = 0;

		/** Called when the button's state changes. */
		virtual void buttonStateChanged (Button*)               {}
	};

	/** Registers a listener to receive events when this button's state changes.
		If the listener is already registered, this will not register it again.
		@see removeListener
	*/
	void addListener (Listener* newListener);

	/** Removes a previously-registered button listener
		@see addListener
	*/
	void removeListener (Listener* listener);

	/** Causes the button to act as if it's been clicked.

		This will asynchronously make the button draw itself going down and up, and
		will then call back the clicked() method as if mouse was clicked on it.

		@see clicked
	*/
	virtual void triggerClick();

	/** Sets a command ID for this button to automatically invoke when it's clicked.

		When the button is pressed, it will use the given manager to trigger the
		command ID.

		Obviously be careful that the ApplicationCommandManager doesn't get deleted
		before this button is. To disable the command triggering, call this method and
		pass 0 for the parameters.

		If generateTooltip is true, then the button's tooltip will be automatically
		generated based on the name of this command and its current shortcut key.

		@see addShortcut, getCommandID
	*/
	void setCommandToTrigger (ApplicationCommandManager* commandManagerToUse,
							  int commandID,
							  bool generateTooltip);

	/** Returns the command ID that was set by setCommandToTrigger().
	*/
	int getCommandID() const noexcept               { return commandID; }

	/** Assigns a shortcut key to trigger the button.

		The button registers itself with its top-level parent component for keypresses.

		Note that a different way of linking buttons to keypresses is by using the
		setCommandToTrigger() method to invoke a command.

		@see clearShortcuts
	*/
	void addShortcut (const KeyPress& key);

	/** Removes all key shortcuts that had been set for this button.

		@see addShortcut
	*/
	void clearShortcuts();

	/** Returns true if the given keypress is a shortcut for this button.

		@see addShortcut
	*/
	bool isRegisteredForShortcut (const KeyPress& key) const;

	/** Sets an auto-repeat speed for the button when it is held down.

		(Auto-repeat is disabled by default).

		@param initialDelayInMillisecs      how long to wait after the mouse is pressed before
											triggering the next click. If this is zero, auto-repeat
											is disabled
		@param repeatDelayInMillisecs       the frequently subsequent repeated clicks should be
											triggered
		@param minimumDelayInMillisecs      if this is greater than 0, the auto-repeat speed will
											get faster, the longer the button is held down, up to the
											minimum interval specified here
	*/
	void setRepeatSpeed (int initialDelayInMillisecs,
						 int repeatDelayInMillisecs,
						 int minimumDelayInMillisecs = -1) noexcept;

	/** Sets whether the button click should happen when the mouse is pressed or released.

		By default the button is only considered to have been clicked when the mouse is
		released, but setting this to true will make it call the clicked() method as soon
		as the button is pressed.

		This is useful if the button is being used to show a pop-up menu, as it allows
		the click to be used as a drag onto the menu.
	*/
	void setTriggeredOnMouseDown (bool isTriggeredOnMouseDown) noexcept;

	/** Returns the number of milliseconds since the last time the button
		went into the 'down' state.
	*/
	uint32 getMillisecondsSinceButtonDown() const noexcept;

	/** Sets the tooltip for this button.

		@see TooltipClient, TooltipWindow
	*/
	void setTooltip (const String& newTooltip);

	// (implementation of the TooltipClient method)
	String getTooltip();

	/** A combination of these flags are used by setConnectedEdges().
	*/
	enum ConnectedEdgeFlags
	{
		ConnectedOnLeft = 1,
		ConnectedOnRight = 2,
		ConnectedOnTop = 4,
		ConnectedOnBottom = 8
	};

	/** Hints about which edges of the button might be connected to adjoining buttons.

		The value passed in is a bitwise combination of any of the values in the
		ConnectedEdgeFlags enum.

		E.g. if you are placing two buttons adjacent to each other, you could use this to
		indicate which edges are touching, and the LookAndFeel might choose to drawn them
		without rounded corners on the edges that connect. It's only a hint, so the
		LookAndFeel can choose to ignore it if it's not relevent for this type of
		button.
	*/
	void setConnectedEdges (int connectedEdgeFlags);

	/** Returns the set of flags passed into setConnectedEdges(). */
	int getConnectedEdgeFlags() const noexcept                  { return connectedEdgeFlags; }

	/** Indicates whether the button adjoins another one on its left edge.
		@see setConnectedEdges
	*/
	bool isConnectedOnLeft() const noexcept                     { return (connectedEdgeFlags & ConnectedOnLeft) != 0; }

	/** Indicates whether the button adjoins another one on its right edge.
		@see setConnectedEdges
	*/
	bool isConnectedOnRight() const noexcept                    { return (connectedEdgeFlags & ConnectedOnRight) != 0; }

	/** Indicates whether the button adjoins another one on its top edge.
		@see setConnectedEdges
	*/
	bool isConnectedOnTop() const noexcept                      { return (connectedEdgeFlags & ConnectedOnTop) != 0; }

	/** Indicates whether the button adjoins another one on its bottom edge.
		@see setConnectedEdges
	*/
	bool isConnectedOnBottom() const noexcept                   { return (connectedEdgeFlags & ConnectedOnBottom) != 0; }

	/** Used by setState(). */
	enum ButtonState
	{
		buttonNormal,
		buttonOver,
		buttonDown
	};

	/** Can be used to force the button into a particular state.

		This only changes the button's appearance, it won't trigger a click, or stop any mouse-clicks
		from happening.

		The state that you set here will only last until it is automatically changed when the mouse
		enters or exits the button, or the mouse-button is pressed or released.
	*/
	void setState (const ButtonState newState);

	struct Ids
	{
		static const Identifier text, radioGroup,
								connectedLeft, connectedRight, connectedTop, connectedBottom;
	};

	void refreshFromValueTree (const ValueTree&, ComponentBuilder&);
	static int getConnectedFlags (const ValueTree& state);

	// These are deprecated - please use addListener() and removeListener() instead!
	JUCE_DEPRECATED (void addButtonListener (Listener*));
	JUCE_DEPRECATED (void removeButtonListener (Listener*));

protected:

	/** This method is called when the button has been clicked.

		Subclasses can override this to perform whatever they actions they need
		to do.

		Alternatively, a ButtonListener can be added to the button, and these listeners
		will be called when the click occurs.

		@see triggerClick
	*/
	virtual void clicked();

	/** This method is called when the button has been clicked.

		By default it just calls clicked(), but you might want to override it to handle
		things like clicking when a modifier key is pressed, etc.

		@see ModifierKeys
	*/
	virtual void clicked (const ModifierKeys& modifiers);

	/** Subclasses should override this to actually paint the button's contents.

		It's better to use this than the paint method, because it gives you information
		about the over/down state of the button.

		@param g                    the graphics context to use
		@param isMouseOverButton    true if the button is either in the 'over' or
									'down' state
		@param isButtonDown         true if the button should be drawn in the 'down' position
	*/
	virtual void paintButton (Graphics& g,
							  bool isMouseOverButton,
							  bool isButtonDown) = 0;

	/** Called when the button's up/down/over state changes.

		Subclasses can override this if they need to do something special when the button
		goes up or down.

		@see isDown, isOver
	*/
	virtual void buttonStateChanged();

	/** @internal */
	virtual void internalClickCallback (const ModifierKeys& modifiers);
	/** @internal */
	void handleCommandMessage (int commandId);
	/** @internal */
	void mouseEnter (const MouseEvent& e);
	/** @internal */
	void mouseExit (const MouseEvent& e);
	/** @internal */
	void mouseDown (const MouseEvent& e);
	/** @internal */
	void mouseDrag (const MouseEvent& e);
	/** @internal */
	void mouseUp (const MouseEvent& e);
	/** @internal */
	bool keyPressed (const KeyPress& key);
	/** @internal */
	bool keyPressed (const KeyPress& key, Component* originatingComponent);
	/** @internal */
	bool keyStateChanged (bool isKeyDown, Component* originatingComponent);
	/** @internal */
	void paint (Graphics& g);
	/** @internal */
	void parentHierarchyChanged();
	/** @internal */
	void visibilityChanged();
	/** @internal */
	void focusGained (FocusChangeType cause);
	/** @internal */
	void focusLost (FocusChangeType cause);
	/** @internal */
	void enablementChanged();
	/** @internal */
	void applicationCommandInvoked (const ApplicationCommandTarget::InvocationInfo&);
	/** @internal */
	void applicationCommandListChanged();
	/** @internal */
	void valueChanged (Value& value);

private:

	Array <KeyPress> shortcuts;
	WeakReference<Component> keySource;
	String text;
	ListenerList <Listener> buttonListeners;

	class RepeatTimer;
	friend class RepeatTimer;
	friend class ScopedPointer <RepeatTimer>;
	ScopedPointer <RepeatTimer> repeatTimer;
	uint32 buttonPressTime, lastRepeatTime;
	ApplicationCommandManager* commandManagerToUse;
	int autoRepeatDelay, autoRepeatSpeed, autoRepeatMinimumDelay;
	int radioGroupId, commandID, connectedEdgeFlags;
	ButtonState buttonState;

	Value isOn;
	bool lastToggleState : 1;
	bool clickTogglesState : 1;
	bool needsToRelease : 1;
	bool needsRepainting : 1;
	bool isKeyDown : 1;
	bool triggerOnMouseDown : 1;
	bool generateTooltip : 1;

	void repeatTimerCallback();
	RepeatTimer& getRepeatTimer();

	ButtonState updateState();
	ButtonState updateState (bool isOver, bool isDown);
	bool isShortcutPressed() const;
	void turnOffOtherButtonsInGroup (bool sendChangeNotification);

	void flashButtonState();
	void sendClickMessage (const ModifierKeys& modifiers);
	void sendStateMessage();

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (Button);
};

#ifndef DOXYGEN
 /** This typedef is just for compatibility with old code and VC6 - newer code should use Button::Listener instead. */
 typedef Button::Listener ButtonListener;
#endif

#endif   // __JUCE_BUTTON_JUCEHEADER__

/*** End of inlined file: juce_Button.h ***/

/**
	A button with an arrow in it.

	@see Button
*/
class JUCE_API  ArrowButton  : public Button
{
public:

	/** Creates an ArrowButton.

		@param buttonName       the name to give the button
		@param arrowDirection   the direction the arrow should point in, where 0.0 is
								pointing right, 0.25 is down, 0.5 is left, 0.75 is up
		@param arrowColour      the colour to use for the arrow
	*/
	ArrowButton (const String& buttonName,
				 float arrowDirection,
				 const Colour& arrowColour);

	/** Destructor. */
	~ArrowButton();

protected:

	/** @internal */
	void paintButton (Graphics& g,
					  bool isMouseOverButton,
					  bool isButtonDown);

	/** @internal */
	void buttonStateChanged();

private:

	Colour colour;
	DropShadowEffect shadow;
	Path path;
	int offset;

	void updateShadowAndOffset();

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ArrowButton);
};

#endif   // __JUCE_ARROWBUTTON_JUCEHEADER__

/*** End of inlined file: juce_ArrowButton.h ***/


#endif
#ifndef __JUCE_BUTTON_JUCEHEADER__

#endif
#ifndef __JUCE_DRAWABLEBUTTON_JUCEHEADER__

/*** Start of inlined file: juce_DrawableButton.h ***/
#ifndef __JUCE_DRAWABLEBUTTON_JUCEHEADER__
#define __JUCE_DRAWABLEBUTTON_JUCEHEADER__


/*** Start of inlined file: juce_Drawable.h ***/
#ifndef __JUCE_DRAWABLE_JUCEHEADER__
#define __JUCE_DRAWABLE_JUCEHEADER__


/*** Start of inlined file: juce_RelativeCoordinate.h ***/
#ifndef __JUCE_RELATIVECOORDINATE_JUCEHEADER__
#define __JUCE_RELATIVECOORDINATE_JUCEHEADER__

/**
	Expresses a coordinate as a dynamically evaluated expression.

	@see RelativePoint, RelativeRectangle
*/
class JUCE_API  RelativeCoordinate
{
public:

	/** Creates a zero coordinate. */
	RelativeCoordinate();
	RelativeCoordinate (const Expression& expression);
	RelativeCoordinate (const RelativeCoordinate& other);
	RelativeCoordinate& operator= (const RelativeCoordinate& other);

   #if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
	RelativeCoordinate (RelativeCoordinate&& other) noexcept;
	RelativeCoordinate& operator= (RelativeCoordinate&& other) noexcept;
   #endif

	/** Creates an absolute position from the parent origin on either the X or Y axis.

		@param absoluteDistanceFromOrigin   the distance from the origin
	*/
	RelativeCoordinate (double absoluteDistanceFromOrigin);

	/** Recreates a coordinate from a string description.
		The string will be parsed by ExpressionParser::parse().
		@param stringVersion    the expression to use
		@see toString
	*/
	RelativeCoordinate (const String& stringVersion);

	/** Destructor. */
	~RelativeCoordinate();

	bool operator== (const RelativeCoordinate& other) const noexcept;
	bool operator!= (const RelativeCoordinate& other) const noexcept;

	/** Calculates the absolute position of this coordinate.

		You'll need to provide a suitable Expression::Scope for looking up any coordinates that may
		be needed to calculate the result.
	*/
	double resolve (const Expression::Scope* evaluationScope) const;

	/** Returns true if this coordinate uses the specified coord name at any level in its evaluation.
		This will recursively check any coordinates upon which this one depends.
	*/
	bool references (const String& coordName, const Expression::Scope* evaluationScope) const;

	/** Returns true if there's a recursive loop when trying to resolve this coordinate's position. */
	bool isRecursive (const Expression::Scope* evaluationScope) const;

	/** Returns true if this coordinate depends on any other coordinates for its position. */
	bool isDynamic() const;

	/** Changes the value of this coord to make it resolve to the specified position.

		Calling this will leave the anchor points unchanged, but will set this coordinate's absolute
		or relative position to whatever value is necessary to make its resultant position
		match the position that is provided.
	*/
	void moveToAbsolute (double absoluteTargetPosition, const Expression::Scope* evaluationScope);

	/** Returns the expression that defines this coordinate. */
	const Expression& getExpression() const         { return term; }

	/** Returns a string which represents this coordinate.
		For details of the string syntax, see the constructor notes.
	*/
	String toString() const;

	/** A set of static strings that are commonly used by the RelativeCoordinate class.

		As well as avoiding using string literals in your code, using these preset values
		has the advantage that all instances of the same string will share the same, reference-counted
		String object, so if you have thousands of points which all refer to the same
		anchor points, this can save a significant amount of memory allocation.
	*/
	struct Strings
	{
		static const String parent;         /**< "parent" */
		static const String left;           /**< "left" */
		static const String right;          /**< "right" */
		static const String top;            /**< "top" */
		static const String bottom;         /**< "bottom" */
		static const String x;              /**< "x" */
		static const String y;              /**< "y" */
		static const String width;          /**< "width" */
		static const String height;         /**< "height" */
	};

	struct StandardStrings
	{
		enum Type
		{
			left, right, top, bottom,
			x, y, width, height,
			parent,
			unknown
		};

		static Type getTypeOf (const String& s) noexcept;
	};

private:

	Expression term;
};

#endif   // __JUCE_RELATIVECOORDINATE_JUCEHEADER__

/*** End of inlined file: juce_RelativeCoordinate.h ***/


/*** Start of inlined file: juce_RelativeCoordinatePositioner.h ***/
#ifndef __JUCE_RELATIVECOORDINATEPOSITIONER_JUCEHEADER__
#define __JUCE_RELATIVECOORDINATEPOSITIONER_JUCEHEADER__


/*** Start of inlined file: juce_RelativePoint.h ***/
#ifndef __JUCE_RELATIVEPOINT_JUCEHEADER__
#define __JUCE_RELATIVEPOINT_JUCEHEADER__

/**
	An X-Y position stored as a pair of RelativeCoordinate values.

	@see RelativeCoordinate, RelativeRectangle
*/
class JUCE_API  RelativePoint
{
public:
	/** Creates a point at the origin. */
	RelativePoint();

	/** Creates an absolute point, relative to the origin. */
	RelativePoint (const Point<float>& absolutePoint);

	/** Creates an absolute point, relative to the origin. */
	RelativePoint (float absoluteX, float absoluteY);

	/** Creates an absolute point from two coordinates. */
	RelativePoint (const RelativeCoordinate& x, const RelativeCoordinate& y);

	/** Creates a point from a stringified representation.
		The string must contain a pair of coordinates, separated by space or a comma. The syntax for the coordinate
		strings is explained in the RelativeCoordinate class.
		@see toString
	*/
	RelativePoint (const String& stringVersion);

	bool operator== (const RelativePoint& other) const noexcept;
	bool operator!= (const RelativePoint& other) const noexcept;

	/** Calculates the absolute position of this point.

		You'll need to provide a suitable Expression::Scope for looking up any coordinates that may
		be needed to calculate the result.
	*/
	const Point<float> resolve (const Expression::Scope* evaluationContext) const;

	/** Changes the values of this point's coordinates to make it resolve to the specified position.

		Calling this will leave any anchor points unchanged, but will set any absolute
		or relative positions to whatever values are necessary to make the resultant position
		match the position that is provided.
	*/
	void moveToAbsolute (const Point<float>& newPos, const Expression::Scope* evaluationContext);

	/** Returns a string which represents this point.
		This returns a comma-separated pair of coordinates. For details of the string syntax used by the
		coordinates, see the RelativeCoordinate constructor notes.
		The string that is returned can be passed to the RelativePoint constructor to recreate the point.
	*/
	String toString() const;

	/** Returns true if this point depends on any other coordinates for its position. */
	bool isDynamic() const;

	// The actual X and Y coords...
	RelativeCoordinate x, y;
};

#endif   // __JUCE_RELATIVEPOINT_JUCEHEADER__

/*** End of inlined file: juce_RelativePoint.h ***/


/*** Start of inlined file: juce_MarkerList.h ***/
#ifndef __JUCE_MARKERLIST_JUCEHEADER__
#define __JUCE_MARKERLIST_JUCEHEADER__

class Component;

/**
	Holds a set of named marker points along a one-dimensional axis.

	This class is used to store sets of X and Y marker points in components.
	@see Component::getMarkers().
*/
class JUCE_API  MarkerList
{
public:

	/** Creates an empty marker list. */
	MarkerList();
	/** Creates a copy of another marker list. */
	MarkerList (const MarkerList& other);
	/** Copies another marker list to this one. */
	MarkerList& operator= (const MarkerList& other);
	/** Destructor. */
	~MarkerList();

	/** Represents a marker in a MarkerList. */
	class JUCE_API  Marker
	{
	public:
		/** Creates a copy of another Marker. */
		Marker (const Marker& other);
		/** Creates a Marker with a given name and position. */
		Marker (const String& name, const RelativeCoordinate& position);

		/** The marker's name. */
		String name;

		/** The marker's position.

			The expression used to define the coordinate may use the names of other
			markers, so that markers can be linked in arbitrary ways, but be careful
			not to create recursive loops of markers whose positions are based on each
			other! It can also refer to "parent.right" and "parent.bottom" so that you
			can set markers which are relative to the size of the component that contains
			them.

			To resolve the coordinate, you can use the MarkerList::getMarkerPosition() method.
		*/
		RelativeCoordinate position;

		/** Returns true if both the names and positions of these two markers match. */
		bool operator== (const Marker&) const noexcept;
		/** Returns true if either the name or position of these two markers differ. */
		bool operator!= (const Marker&) const noexcept;
	};

	/** Returns the number of markers in the list. */
	int getNumMarkers() const noexcept;

	/** Returns one of the markers in the list, by its index. */
	const Marker* getMarker (int index) const noexcept;

	/** Returns a named marker, or 0 if no such name is found.
		Note that name comparisons are case-sensitive.
	*/
	const Marker* getMarker (const String& name) const noexcept;

	/** Evaluates the given marker and returns its absolute position.
		The parent component must be supplied in case the marker's expression refers to
		the size of its parent component.
	*/
	double getMarkerPosition (const Marker& marker, Component* parentComponent) const;

	/** Sets the position of a marker.

		If the name already exists, then the existing marker is moved; if it doesn't exist, then a
		new marker is added.
	*/
	void setMarker (const String& name, const RelativeCoordinate& position);

	/** Deletes the marker at the given list index. */
	void removeMarker (int index);

	/** Deletes the marker with the given name. */
	void removeMarker (const String& name);

	/** Returns true if all the markers in these two lists match exactly. */
	bool operator== (const MarkerList& other) const noexcept;
	/** Returns true if not all the markers in these two lists match exactly. */
	bool operator!= (const MarkerList& other) const noexcept;

	/**
		A class for receiving events when changes are made to a MarkerList.

		You can register a MarkerList::Listener with a MarkerList using the MarkerList::addListener()
		method, and it will be called when markers are moved, added, or deleted.

		@see MarkerList::addListener, MarkerList::removeListener
	*/
	class JUCE_API  Listener
	{
	public:
		/** Destructor. */
		virtual ~Listener() {}

		/** Called when something in the given marker list changes. */
		virtual void markersChanged (MarkerList* markerList) = 0;

		/** Called when the given marker list is being deleted. */
		virtual void markerListBeingDeleted (MarkerList* markerList);
	};

	/** Registers a listener that will be called when the markers are changed. */
	void addListener (Listener* listener);

	/** Deregisters a previously-registered listener. */
	void removeListener (Listener* listener);

	/** Synchronously calls markersChanged() on all the registered listeners. */
	void markersHaveChanged();

	/** Forms a wrapper around a ValueTree that can be used for storing a MarkerList. */
	class ValueTreeWrapper
	{
	public:
		ValueTreeWrapper (const ValueTree& state);

		ValueTree& getState() noexcept      { return state; }
		int getNumMarkers() const;
		ValueTree getMarkerState (int index) const;
		ValueTree getMarkerState (const String& name) const;
		bool containsMarker (const ValueTree& state) const;
		MarkerList::Marker getMarker (const ValueTree& state) const;
		void setMarker (const MarkerList::Marker& marker, UndoManager* undoManager);
		void removeMarker (const ValueTree& state, UndoManager* undoManager);

		void applyTo (MarkerList& markerList);
		void readFrom (const MarkerList& markerList, UndoManager* undoManager);

		static const Identifier markerTag, nameProperty, posProperty;

	private:
		ValueTree state;
	};

private:

	OwnedArray<Marker> markers;
	ListenerList<Listener> listeners;

	Marker* getMarkerByName (const String& name) const noexcept;

	JUCE_LEAK_DETECTOR (MarkerList);
};

#endif   // __JUCE_MARKERLIST_JUCEHEADER__

/*** End of inlined file: juce_MarkerList.h ***/

/**
	Base class for Component::Positioners that are based upon relative coordinates.
*/
class JUCE_API  RelativeCoordinatePositionerBase  : public Component::Positioner,
													public ComponentListener,
													public MarkerList::Listener
{
public:
	RelativeCoordinatePositionerBase (Component& component_);
	~RelativeCoordinatePositionerBase();

	void componentMovedOrResized (Component&, bool, bool);
	void componentParentHierarchyChanged (Component&);
	void componentChildrenChanged (Component& component);
	void componentBeingDeleted (Component& component);
	void markersChanged (MarkerList*);
	void markerListBeingDeleted (MarkerList* markerList);

	void apply();

	bool addCoordinate (const RelativeCoordinate& coord);
	bool addPoint (const RelativePoint& point);

	/** Used for resolving a RelativeCoordinate expression in the context of a component. */
	class ComponentScope  : public Expression::Scope
	{
	public:
		ComponentScope (Component& component_);

		Expression getSymbolValue (const String& symbol) const;
		void visitRelativeScope (const String& scopeName, Visitor& visitor) const;
		String getScopeUID() const;

	protected:
		Component& component;

		Component* findSiblingComponent (const String& componentID) const;

	private:
		JUCE_DECLARE_NON_COPYABLE (ComponentScope);
	};

protected:
	virtual bool registerCoordinates() = 0;
	virtual void applyToComponentBounds() = 0;

private:
	class DependencyFinderScope;
	friend class DependencyFinderScope;
	Array <Component*> sourceComponents;
	Array <MarkerList*> sourceMarkerLists;
	bool registeredOk;

	void registerComponentListener (Component& comp);
	void registerMarkerListListener (MarkerList* const list);
	void unregisterListeners();

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (RelativeCoordinatePositionerBase);
};

#endif   // __JUCE_RELATIVECOORDINATEPOSITIONER_JUCEHEADER__

/*** End of inlined file: juce_RelativeCoordinatePositioner.h ***/

class DrawableComposite;

/**
	The base class for objects which can draw themselves, e.g. polygons, images, etc.

	@see DrawableComposite, DrawableImage, DrawablePath, DrawableText
*/
class JUCE_API  Drawable  : public Component
{
protected:

	/** The base class can't be instantiated directly.

		@see DrawableComposite, DrawableImage, DrawablePath, DrawableText
	*/
	Drawable();

public:
	/** Destructor. */
	virtual ~Drawable();

	/** Creates a deep copy of this Drawable object.

		Use this to create a new copy of this and any sub-objects in the tree.
	*/
	virtual Drawable* createCopy() const = 0;

	/** Renders this Drawable object.

		Note that the preferred way to render a drawable in future is by using it
		as a component and adding it to a parent, so you might want to consider that
		before using this method.

		@see drawWithin
	*/
	void draw (Graphics& g, float opacity,
			   const AffineTransform& transform = AffineTransform::identity) const;

	/** Renders the Drawable at a given offset within the Graphics context.

		The co-ordinates passed-in are used to translate the object relative to its own
		origin before drawing it - this is basically a quick way of saying:

		@code
		draw (g, AffineTransform::translation (x, y)).
		@endcode

		Note that the preferred way to render a drawable in future is by using it
		as a component and adding it to a parent, so you might want to consider that
		before using this method.
	*/
	void drawAt (Graphics& g, float x, float y, float opacity) const;

	/** Renders the Drawable within a rectangle, scaling it to fit neatly inside without
		changing its aspect-ratio.

		The object can placed arbitrarily within the rectangle based on a Justification type,
		and can either be made as big as possible, or just reduced to fit.

		Note that the preferred way to render a drawable in future is by using it
		as a component and adding it to a parent, so you might want to consider that
		before using this method.

		@param g                        the graphics context to render onto
		@param destArea                 the target rectangle to fit the drawable into
		@param placement                defines the alignment and rescaling to use to fit
										this object within the target rectangle.
		@param opacity                  the opacity to use, in the range 0 to 1.0
	*/
	void drawWithin (Graphics& g,
					 const Rectangle<float>& destArea,
					 const RectanglePlacement& placement,
					 float opacity) const;

	/** Resets any transformations on this drawable, and positions its origin within
		its parent component.
	*/
	void setOriginWithOriginalSize (const Point<float>& originWithinParent);

	/** Sets a transform for this drawable that will position it within the specified
		area of its parent component.
	*/
	void setTransformToFit (const Rectangle<float>& areaInParent, const RectanglePlacement& placement);

	/** Returns the DrawableComposite that contains this object, if there is one. */
	DrawableComposite* getParent() const;

	/** Tries to turn some kind of image file into a drawable.

		The data could be an image that the ImageFileFormat class understands, or it
		could be SVG.
	*/
	static Drawable* createFromImageData (const void* data, size_t numBytes);

	/** Tries to turn a stream containing some kind of image data into a drawable.

		The data could be an image that the ImageFileFormat class understands, or it
		could be SVG.
	*/
	static Drawable* createFromImageDataStream (InputStream& dataSource);

	/** Tries to turn a file containing some kind of image data into a drawable.

		The data could be an image that the ImageFileFormat class understands, or it
		could be SVG.
	*/
	static Drawable* createFromImageFile (const File& file);

	/** Attempts to parse an SVG (Scalable Vector Graphics) document, and to turn this
		into a Drawable tree.

		The object returned must be deleted by the caller. If something goes wrong
		while parsing, it may return 0.

		SVG is a pretty large and complex spec, and this doesn't aim to be a full
		implementation, but it can return the basic vector objects.
	*/
	static Drawable* createFromSVG (const XmlElement& svgDocument);

	/** Tries to create a Drawable from a previously-saved ValueTree.
		The ValueTree must have been created by the createValueTree() method.
		If there are any images used within the drawable, you'll need to provide a valid
		ImageProvider object that can be used to retrieve these images from whatever type
		of identifier is used to represent them.
		Internally, this uses a ComponentBuilder, and registerDrawableTypeHandlers().
	*/
	static Drawable* createFromValueTree (const ValueTree& tree, ComponentBuilder::ImageProvider* imageProvider);

	/** Creates a ValueTree to represent this Drawable.
		The ValueTree that is returned can be turned back into a Drawable with createFromValueTree().
		If there are any images used in this drawable, you'll need to provide a valid ImageProvider
		object that can be used to create storable representations of them.
	*/
	virtual ValueTree createValueTree (ComponentBuilder::ImageProvider* imageProvider) const = 0;

	/** Returns the area that this drawble covers.
		The result is expressed in this drawable's own coordinate space, and does not take
		into account any transforms that may be applied to the component.
	*/
	virtual Rectangle<float> getDrawableBounds() const = 0;

	/** Internal class used to manage ValueTrees that represent Drawables. */
	class ValueTreeWrapperBase
	{
	public:
		ValueTreeWrapperBase (const ValueTree& state);

		ValueTree& getState() noexcept          { return state; }

		String getID() const;
		void setID (const String& newID);

		ValueTree state;
	};

	/** Registers a set of ComponentBuilder::TypeHandler objects that can be used to
		load all the different Drawable types from a saved state.
		@see ComponentBuilder::registerTypeHandler()
	*/
	static void registerDrawableTypeHandlers (ComponentBuilder& componentBuilder);

protected:

	friend class DrawableComposite;
	friend class DrawableShape;

	/** @internal */
	void transformContextToCorrectOrigin (Graphics& g);
	/** @internal */
	void parentHierarchyChanged();
	/** @internal */
	void setBoundsToEnclose (const Rectangle<float>& area);

	Point<int> originRelativeToComponent;

  #ifndef DOXYGEN
	/** Internal utility class used by Drawables. */
	template <class DrawableType>
	class Positioner  : public RelativeCoordinatePositionerBase
	{
	public:
		Positioner (DrawableType& component_)
			: RelativeCoordinatePositionerBase (component_),
			  owner (component_)
		{}

		bool registerCoordinates()      { return owner.registerCoordinates (*this); }
		void applyToComponentBounds()
		{
			ComponentScope scope (getComponent());
			owner.recalculateCoordinates (&scope);
		}

		void applyNewBounds (const Rectangle<int>&)
		{
			jassertfalse; // drawables can't be resized directly!
		}

	private:
		DrawableType& owner;

		JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (Positioner);
	};
  #endif

private:
	void nonConstDraw (Graphics& g, float opacity, const AffineTransform& transform);

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (Drawable);
};

#endif   // __JUCE_DRAWABLE_JUCEHEADER__

/*** End of inlined file: juce_Drawable.h ***/

/**
	A button that displays a Drawable.

	Up to three Drawable objects can be given to this button, to represent the
	'normal', 'over' and 'down' states.

	@see Button
*/
class JUCE_API  DrawableButton  : public Button
{
public:

	enum ButtonStyle
	{
		ImageFitted,                /**< The button will just display the images, but will resize and centre them to fit inside it. */
		ImageRaw,                   /**< The button will just display the images in their normal size and position.
										 This leaves it up to the caller to make sure the images are the correct size and position for the button. */
		ImageAboveTextLabel,        /**< Draws the button as a text label across the bottom with the image resized and scaled to fit above it. */
		ImageOnButtonBackground     /**< Draws the button as a standard rounded-rectangle button with the image on top. */
	};

	/** Creates a DrawableButton.

		After creating one of these, use setImages() to specify the drawables to use.

		@param buttonName           the name to give the component
		@param buttonStyle          the layout to use

		@see ButtonStyle, setButtonStyle, setImages
	*/
	DrawableButton (const String& buttonName,
					ButtonStyle buttonStyle);

	/** Destructor. */
	~DrawableButton();

	/** Sets up the images to draw for the various button states.

		The button will keep its own internal copies of these drawables.

		@param normalImage      the thing to draw for the button's 'normal' state. An internal copy
								will be made of the object passed-in if it is non-zero.
		@param overImage        the thing to draw for the button's 'over' state - if this is
								zero, the button's normal image will be used when the mouse is
								over it. An internal copy will be made of the object passed-in
								if it is non-zero.
		@param downImage        the thing to draw for the button's 'down' state - if this is
								zero, the 'over' image will be used instead (or the normal image
								as a last resort). An internal copy will be made of the object
								passed-in if it is non-zero.
		@param disabledImage    an image to draw when the button is disabled. If this is zero,
								the normal image will be drawn with a reduced opacity instead.
								An internal copy will be made of the object passed-in if it is
								non-zero.
		@param normalImageOn    same as the normalImage, but this is used when the button's toggle
								state is 'on'. If this is 0, the normal image is used instead
		@param overImageOn      same as the overImage, but this is used when the button's toggle
								state is 'on'. If this is 0, the normalImageOn is drawn instead
		@param downImageOn      same as the downImage, but this is used when the button's toggle
								state is 'on'. If this is 0, the overImageOn is drawn instead
		@param disabledImageOn  same as the disabledImage, but this is used when the button's toggle
								state is 'on'. If this is 0, the normal image will be drawn instead
								with a reduced opacity
	*/
	void setImages (const Drawable* normalImage,
					const Drawable* overImage = nullptr,
					const Drawable* downImage = nullptr,
					const Drawable* disabledImage = nullptr,
					const Drawable* normalImageOn = nullptr,
					const Drawable* overImageOn = nullptr,
					const Drawable* downImageOn = nullptr,
					const Drawable* disabledImageOn = nullptr);

	/** Changes the button's style.

		@see ButtonStyle
	*/
	void setButtonStyle (ButtonStyle newStyle);

	/** Changes the button's background colours.

		The toggledOffColour is the colour to use when the button's toggle state
		is off, and toggledOnColour when it's on.

		For an ImageOnly or ImageAboveTextLabel style, the background colour is
		used to fill the background of the component.

		For an ImageOnButtonBackground style, the colour is used to draw the
		button's lozenge shape and exactly how the colour's used will depend
		on the LookAndFeel.
	*/
	void setBackgroundColours (const Colour& toggledOffColour,
							   const Colour& toggledOnColour);

	/** Returns the current background colour being used.

		@see setBackgroundColour
	*/
	const Colour& getBackgroundColour() const noexcept;

	/** Gives the button an optional amount of space around the edge of the drawable.

		This will only apply to ImageFitted or ImageRaw styles, it won't affect the
		ones on a button background. If the button is too small for the given gap, a
		smaller gap will be used.

		By default there's a gap of about 3 pixels.
	*/
	void setEdgeIndent (int numPixelsIndent);

	/** Returns the image that the button is currently displaying. */
	Drawable* getCurrentImage() const noexcept;
	Drawable* getNormalImage() const noexcept;
	Drawable* getOverImage() const noexcept;
	Drawable* getDownImage() const noexcept;

	/** A set of colour IDs to use to change the colour of various aspects of the link.

		These constants can be used either via the Component::setColour(), or LookAndFeel::setColour()
		methods.

		@see Component::setColour, Component::findColour, LookAndFeel::setColour, LookAndFeel::findColour
	*/
	enum ColourIds
	{
		textColourId             = 0x1004010, /**< The colour to use for the URL text. */
	};

protected:

	/** @internal */
	void paintButton (Graphics& g,
					  bool isMouseOverButton,
					  bool isButtonDown);
	/** @internal */
	void buttonStateChanged();
	/** @internal */
	void resized();
	/** @internal */
	void enablementChanged();

private:

	ButtonStyle style;
	ScopedPointer <Drawable> normalImage, overImage, downImage, disabledImage;
	ScopedPointer <Drawable> normalImageOn, overImageOn, downImageOn, disabledImageOn;
	Drawable* currentImage;
	Colour backgroundOff, backgroundOn;
	int edgeIndent;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (DrawableButton);
};

#endif   // __JUCE_DRAWABLEBUTTON_JUCEHEADER__

/*** End of inlined file: juce_DrawableButton.h ***/


#endif
#ifndef __JUCE_HYPERLINKBUTTON_JUCEHEADER__

/*** Start of inlined file: juce_HyperlinkButton.h ***/
#ifndef __JUCE_HYPERLINKBUTTON_JUCEHEADER__
#define __JUCE_HYPERLINKBUTTON_JUCEHEADER__

/**
	A button showing an underlined weblink, that will launch the link
	when it's clicked.

	@see Button
*/
class JUCE_API  HyperlinkButton  : public Button
{
public:

	/** Creates a HyperlinkButton.

		@param linkText     the text that will be displayed in the button - this is
							also set as the Component's name, but the text can be
							changed later with the Button::getButtonText() method
		@param linkURL      the URL to launch when the user clicks the button
	*/
	HyperlinkButton (const String& linkText,
					 const URL& linkURL);

	/** Creates a HyperlinkButton. */
	HyperlinkButton();

	/** Destructor. */
	~HyperlinkButton();

	/** Changes the font to use for the text.

		If resizeToMatchComponentHeight is true, the font's height will be adjusted
		to match the size of the component.
	*/
	void setFont (const Font& newFont,
				  bool resizeToMatchComponentHeight,
				  const Justification& justificationType = Justification::horizontallyCentred);

	/** A set of colour IDs to use to change the colour of various aspects of the link.

		These constants can be used either via the Component::setColour(), or LookAndFeel::setColour()
		methods.

		@see Component::setColour, Component::findColour, LookAndFeel::setColour, LookAndFeel::findColour
	*/
	enum ColourIds
	{
		textColourId             = 0x1001f00, /**< The colour to use for the URL text. */
	};

	/** Changes the URL that the button will trigger. */
	void setURL (const URL& newURL) noexcept;

	/** Returns the URL that the button will trigger. */
	const URL& getURL() const noexcept                          { return url; }

	/** Resizes the button horizontally to fit snugly around the text.

		This won't affect the button's height.
	*/
	void changeWidthToFitText();

	struct Ids
	{
		static const Identifier tagType, text, url;
	};

	void refreshFromValueTree (const ValueTree&, ComponentBuilder&);

protected:

	/** @internal */
	void clicked();
	/** @internal */
	void colourChanged();
	/** @internal */
	void paintButton (Graphics& g,
					  bool isMouseOverButton,
					  bool isButtonDown);

private:

	URL url;
	Font font;
	bool resizeFont;
	Justification justification;

	Font getFontToUse() const;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (HyperlinkButton);
};

#endif   // __JUCE_HYPERLINKBUTTON_JUCEHEADER__

/*** End of inlined file: juce_HyperlinkButton.h ***/


#endif
#ifndef __JUCE_IMAGEBUTTON_JUCEHEADER__

/*** Start of inlined file: juce_ImageButton.h ***/
#ifndef __JUCE_IMAGEBUTTON_JUCEHEADER__
#define __JUCE_IMAGEBUTTON_JUCEHEADER__

/**
	As the title suggests, this is a button containing an image.

	The colour and transparency of the image can be set to vary when the
	button state changes.

	@see Button, ShapeButton, TextButton
*/
class JUCE_API  ImageButton  : public Button
{
public:

	/** Creates an ImageButton.

		Use setImage() to specify the image to use. The colours and opacities that
		are specified here can be changed later using setDrawingOptions().

		@param name                 the name to give the component
	*/
	explicit ImageButton (const String& name = String::empty);

	/** Destructor. */
	~ImageButton();

	/** Sets up the images to draw in various states.

		@param resizeButtonNowToFitThisImage        if true, the button will be immediately
													resized to the same dimensions as the normal image
		@param rescaleImagesWhenButtonSizeChanges   if true, the image will be rescaled to fit the
													button when the button's size changes
		@param preserveImageProportions             if true then any rescaling of the image to fit
													the button will keep the image's x and y proportions
													correct - i.e. it won't distort its shape, although
													this might create gaps around the edges
		@param normalImage                          the image to use when the button is in its normal state.
													button no longer needs it.
		@param imageOpacityWhenNormal               the opacity to use when drawing the normal image.
		@param overlayColourWhenNormal              an overlay colour to use to fill the alpha channel of the
													normal image - if this colour is transparent, no overlay
													will be drawn. The overlay will be drawn over the top of the
													image, so you can basically add a solid or semi-transparent
													colour to the image to brighten or darken it
		@param overImage                            the image to use when the mouse is over the button. If
													you want to use the same image as was set in the normalImage
													parameter, this value can be a null image.
		@param imageOpacityWhenOver                 the opacity to use when drawing the image when the mouse
													is over the button
		@param overlayColourWhenOver                an overlay colour to use to fill the alpha channel of the
													image when the mouse is over - if this colour is transparent,
													no overlay will be drawn
		@param downImage                            an image to use when the button is pressed down. If set
													to a null image, the 'over' image will be drawn instead (or the
													normal image if there isn't an 'over' image either).
		@param imageOpacityWhenDown                 the opacity to use when drawing the image when the button
													is pressed
		@param overlayColourWhenDown                an overlay colour to use to fill the alpha channel of the
													image when the button is pressed down - if this colour is
													transparent, no overlay will be drawn
		@param hitTestAlphaThreshold                if set to zero, the mouse is considered to be over the button
													whenever it's inside the button's bounding rectangle. If
													set to values higher than 0, the mouse will only be
													considered to be over the image when the value of the
													image's alpha channel at that position is greater than
													this level.
	*/
	void setImages (bool resizeButtonNowToFitThisImage,
					bool rescaleImagesWhenButtonSizeChanges,
					bool preserveImageProportions,
					const Image& normalImage,
					float imageOpacityWhenNormal,
					const Colour& overlayColourWhenNormal,
					const Image& overImage,
					float imageOpacityWhenOver,
					const Colour& overlayColourWhenOver,
					const Image& downImage,
					float imageOpacityWhenDown,
					const Colour& overlayColourWhenDown,
					float hitTestAlphaThreshold = 0.0f);

	/** Returns the currently set 'normal' image. */
	Image getNormalImage() const;

	/** Returns the image that's drawn when the mouse is over the button.

		If a valid 'over' image has been set, this will return it; otherwise it'll
		just return the normal image.
	*/
	Image getOverImage() const;

	/** Returns the image that's drawn when the button is held down.

		If a valid 'down' image has been set, this will return it; otherwise it'll
		return the 'over' image or normal image, depending on what's available.
	*/
	Image getDownImage() const;

	struct Ids
	{
		static const Identifier tagType, upImage, overImage, downImage,
								upOverlay, overOverlay, downOverlay,
								upOpacity, overOpacity, downOpacity;
	};

	void refreshFromValueTree (const ValueTree&, ComponentBuilder&);

protected:

	/** @internal */
	bool hitTest (int x, int y);
	/** @internal */
	void paintButton (Graphics& g,
					  bool isMouseOverButton,
					  bool isButtonDown);

private:

	bool scaleImageToFit, preserveProportions;
	uint8 alphaThreshold;
	Rectangle<int> imageBounds;
	Image normalImage, overImage, downImage;
	float normalOpacity, overOpacity, downOpacity;
	Colour normalOverlay, overOverlay, downOverlay;

	Image getCurrentImage() const;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ImageButton);
};

#endif   // __JUCE_IMAGEBUTTON_JUCEHEADER__

/*** End of inlined file: juce_ImageButton.h ***/


#endif
#ifndef __JUCE_SHAPEBUTTON_JUCEHEADER__

/*** Start of inlined file: juce_ShapeButton.h ***/
#ifndef __JUCE_SHAPEBUTTON_JUCEHEADER__
#define __JUCE_SHAPEBUTTON_JUCEHEADER__

/**
	A button that contains a filled shape.

	@see Button, ImageButton, TextButton, ArrowButton
*/
class JUCE_API  ShapeButton  : public Button
{
public:

	/** Creates a ShapeButton.

		@param name             a name to give the component - see Component::setName()
		@param normalColour     the colour to fill the shape with when the mouse isn't over
		@param overColour       the colour to use when the mouse is over the shape
		@param downColour       the colour to use when the button is in the pressed-down state
	*/
	ShapeButton (const String& name,
				 const Colour& normalColour,
				 const Colour& overColour,
				 const Colour& downColour);

	/** Destructor. */
	~ShapeButton();

	/** Sets the shape to use.

		@param newShape                 the shape to use
		@param resizeNowToFitThisShape  if true, the button will be resized to fit the shape's bounds
		@param maintainShapeProportions if true, the shape's proportions will be kept fixed when
										the button is resized
		@param hasDropShadow            if true, the button will be given a drop-shadow effect
	*/
	void setShape (const Path& newShape,
				   bool resizeNowToFitThisShape,
				   bool maintainShapeProportions,
				   bool hasDropShadow);

	/** Set the colours to use for drawing the shape.

		@param normalColour     the colour to fill the shape with when the mouse isn't over
		@param overColour       the colour to use when the mouse is over the shape
		@param downColour       the colour to use when the button is in the pressed-down state
	*/
	void setColours (const Colour& normalColour,
					 const Colour& overColour,
					 const Colour& downColour);

	/** Sets up an outline to draw around the shape.

		@param outlineColour        the colour to use
		@param outlineStrokeWidth   the thickness of line to draw
	*/
	void setOutline (const Colour& outlineColour,
					 float outlineStrokeWidth);

protected:
	/** @internal */
	void paintButton (Graphics& g,
					  bool isMouseOverButton,
					  bool isButtonDown);

private:

	Colour normalColour, overColour, downColour, outlineColour;
	DropShadowEffect shadow;
	Path shape;
	bool maintainShapeProportions;
	float outlineWidth;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ShapeButton);
};

#endif   // __JUCE_SHAPEBUTTON_JUCEHEADER__

/*** End of inlined file: juce_ShapeButton.h ***/


#endif
#ifndef __JUCE_TEXTBUTTON_JUCEHEADER__

/*** Start of inlined file: juce_TextButton.h ***/
#ifndef __JUCE_TEXTBUTTON_JUCEHEADER__
#define __JUCE_TEXTBUTTON_JUCEHEADER__

/**
	A button that uses the standard lozenge-shaped background with a line of
	text on it.

	@see Button, DrawableButton
*/
class JUCE_API  TextButton  : public Button
{
public:

	/** Creates a TextButton.

		@param buttonName           the text to put in the button (the component's name is also
									initially set to this string, but these can be changed later
									using the setName() and setButtonText() methods)
		@param toolTip              an optional string to use as a toolip

		@see Button
	*/
	TextButton (const String& buttonName = String::empty,
				const String& toolTip = String::empty);

	/** Destructor. */
	~TextButton();

	/** A set of colour IDs to use to change the colour of various aspects of the button.

		These constants can be used either via the Component::setColour(), or LookAndFeel::setColour()
		methods.

		@see Component::setColour, Component::findColour, LookAndFeel::setColour, LookAndFeel::findColour
	*/
	enum ColourIds
	{
		buttonColourId                  = 0x1000100,  /**< The colour used to fill the button shape (when the button is toggled
														   'off'). The look-and-feel class might re-interpret this to add
														   effects, etc. */
		buttonOnColourId                = 0x1000101,  /**< The colour used to fill the button shape (when the button is toggled
														   'on'). The look-and-feel class might re-interpret this to add
														   effects, etc. */
		textColourOffId                 = 0x1000102,  /**< The colour to use for the button's text when the button's toggle state is "off". */
		textColourOnId                  = 0x1000103   /**< The colour to use for the button's text.when the button's toggle state is "on". */
	};

	/** Resizes the button to fit neatly around its current text.

		If newHeight is >= 0, the button's height will be changed to this
		value. If it's less than zero, its height will be unaffected.
	*/
	void changeWidthToFitText (int newHeight = -1);

	/** This can be overridden to use different fonts than the default one.

		Note that you'll need to set the font's size appropriately, too.
	*/
	virtual Font getFont();

	struct Ids
	{
		static const Identifier tagType;
	};

protected:
	/** @internal */
	void paintButton (Graphics& g, bool isMouseOverButton, bool isButtonDown);
	/** @internal */
	void colourChanged();

private:

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (TextButton);
};

#endif   // __JUCE_TEXTBUTTON_JUCEHEADER__

/*** End of inlined file: juce_TextButton.h ***/


#endif
#ifndef __JUCE_TOGGLEBUTTON_JUCEHEADER__

/*** Start of inlined file: juce_ToggleButton.h ***/
#ifndef __JUCE_TOGGLEBUTTON_JUCEHEADER__
#define __JUCE_TOGGLEBUTTON_JUCEHEADER__

/**
	A button that can be toggled on/off.

	All buttons can be toggle buttons, but this lets you create one of the
	standard ones which has a tick-box and a text label next to it.

	@see Button, DrawableButton, TextButton
*/
class JUCE_API  ToggleButton  : public Button
{
public:

	/** Creates a ToggleButton.

		@param buttonText   the text to put in the button (the component's name is also
							initially set to this string, but these can be changed later
							using the setName() and setButtonText() methods)
	*/
	explicit ToggleButton (const String& buttonText = String::empty);

	/** Destructor. */
	~ToggleButton();

	/** Resizes the button to fit neatly around its current text.

		The button's height won't be affected, only its width.
	*/
	void changeWidthToFitText();

	/** A set of colour IDs to use to change the colour of various aspects of the button.

		These constants can be used either via the Component::setColour(), or LookAndFeel::setColour()
		methods.

		@see Component::setColour, Component::findColour, LookAndFeel::setColour, LookAndFeel::findColour
	*/
	enum ColourIds
	{
		textColourId                    = 0x1006501   /**< The colour to use for the button's text. */
	};

	struct Ids
	{
		static const Identifier tagType;
	};

protected:
	/** @internal */
	void paintButton (Graphics& g,
					  bool isMouseOverButton,
					  bool isButtonDown);

	/** @internal */
	void colourChanged();

private:

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ToggleButton);
};

#endif   // __JUCE_TOGGLEBUTTON_JUCEHEADER__

/*** End of inlined file: juce_ToggleButton.h ***/


#endif
#ifndef __JUCE_TOOLBARBUTTON_JUCEHEADER__

/*** Start of inlined file: juce_ToolbarButton.h ***/
#ifndef __JUCE_TOOLBARBUTTON_JUCEHEADER__
#define __JUCE_TOOLBARBUTTON_JUCEHEADER__


/*** Start of inlined file: juce_ToolbarItemComponent.h ***/
#ifndef __JUCE_TOOLBARITEMCOMPONENT_JUCEHEADER__
#define __JUCE_TOOLBARITEMCOMPONENT_JUCEHEADER__


/*** Start of inlined file: juce_Toolbar.h ***/
#ifndef __JUCE_TOOLBAR_JUCEHEADER__
#define __JUCE_TOOLBAR_JUCEHEADER__

class ToolbarItemComponent;
class ToolbarItemFactory;

/**
	A toolbar component.

	A toolbar contains a horizontal or vertical strip of ToolbarItemComponents,
	and looks after their order and layout.

	Items (icon buttons or other custom components) are added to a toolbar using a
	ToolbarItemFactory - each type of item is given a unique ID number, and a
	toolbar might contain more than one instance of a particular item type.

	Toolbars can be interactively customised, allowing the user to drag the items
	around, and to drag items onto or off the toolbar, using the ToolbarItemPalette
	component as a source of new items.

	@see ToolbarItemFactory, ToolbarItemComponent, ToolbarItemPalette
*/
class JUCE_API  Toolbar   : public Component,
							public DragAndDropContainer,
							public DragAndDropTarget,
							private ButtonListener  // (can't use Button::Listener due to idiotic VC2005 bug)
{
public:

	/** Creates an empty toolbar component.

		To add some icons or other components to your toolbar, you'll need to
		create a ToolbarItemFactory class that can create a suitable set of
		ToolbarItemComponents.

		@see ToolbarItemFactory, ToolbarItemComponents
	*/
	Toolbar();

	/** Destructor.

		Any items on the bar will be deleted when the toolbar is deleted.
	*/
	~Toolbar();

	/** Changes the bar's orientation.
		@see isVertical
	*/
	void setVertical (bool shouldBeVertical);

	/** Returns true if the bar is set to be vertical, or false if it's horizontal.

		You can change the bar's orientation with setVertical().
	*/
	bool isVertical() const noexcept                 { return vertical; }

	/** Returns the depth of the bar.

		If the bar is horizontal, this will return its height; if it's vertical, it
		will return its width.

		@see getLength
	*/
	int getThickness() const noexcept;

	/** Returns the length of the bar.

		If the bar is horizontal, this will return its width; if it's vertical, it
		will return its height.

		@see getThickness
	*/
	int getLength() const noexcept;

	/** Deletes all items from the bar.
	*/
	void clear();

	/** Adds an item to the toolbar.

		The factory's ToolbarItemFactory::createItem() will be called by this method
		to create the component that will actually be added to the bar.

		The new item will be inserted at the specified index (if the index is -1, it
		will be added to the right-hand or bottom end of the bar).

		Once added, the component will be automatically deleted by this object when it
		is no longer needed.

		@see ToolbarItemFactory
	*/
	void addItem (ToolbarItemFactory& factory,
				  int itemId,
				  int insertIndex = -1);

	/** Deletes one of the items from the bar.
	*/
	void removeToolbarItem (int itemIndex);

	/** Returns the number of items currently on the toolbar.

		@see getItemId, getItemComponent
	*/
	int getNumItems() const noexcept;

	/** Returns the ID of the item with the given index.

		If the index is less than zero or greater than the number of items,
		this will return 0.

		@see getNumItems
	*/
	int getItemId (int itemIndex) const noexcept;

	/** Returns the component being used for the item with the given index.

		If the index is less than zero or greater than the number of items,
		this will return 0.

		@see getNumItems
	*/
	ToolbarItemComponent* getItemComponent (int itemIndex) const noexcept;

	/** Clears this toolbar and adds to it the default set of items that the specified
		factory creates.

		@see ToolbarItemFactory::getDefaultItemSet
	*/
	void addDefaultItems (ToolbarItemFactory& factoryToUse);

	/** Options for the way items should be displayed.
		@see setStyle, getStyle
	*/
	enum ToolbarItemStyle
	{
		iconsOnly,       /**< Means that the toolbar should just contain icons. */
		iconsWithText,   /**< Means that the toolbar should have text labels under each icon. */
		textOnly         /**< Means that the toolbar only display text labels for each item. */
	};

	/** Returns the toolbar's current style.
		@see ToolbarItemStyle, setStyle
	*/
	ToolbarItemStyle getStyle() const noexcept               { return toolbarStyle; }

	/** Changes the toolbar's current style.
		@see ToolbarItemStyle, getStyle, ToolbarItemComponent::setStyle
	*/
	void setStyle (const ToolbarItemStyle& newStyle);

	/** Flags used by the showCustomisationDialog() method. */
	enum CustomisationFlags
	{
		allowIconsOnlyChoice            = 1,    /**< If this flag is specified, the customisation dialog can
													 show the "icons only" option on its choice of toolbar styles. */
		allowIconsWithTextChoice        = 2,    /**< If this flag is specified, the customisation dialog can
													 show the "icons with text" option on its choice of toolbar styles. */
		allowTextOnlyChoice             = 4,    /**< If this flag is specified, the customisation dialog can
													 show the "text only" option on its choice of toolbar styles. */
		showResetToDefaultsButton       = 8,    /**< If this flag is specified, the customisation dialog can
													 show a button to reset the toolbar to its default set of items. */

		allCustomisationOptionsEnabled = (allowIconsOnlyChoice | allowIconsWithTextChoice | allowTextOnlyChoice | showResetToDefaultsButton)
	};

	/** Pops up a modal dialog box that allows this toolbar to be customised by the user.

		The dialog contains a ToolbarItemPalette and various controls for editing other
		aspects of the toolbar. The dialog box will be opened modally, but the method will
		return immediately.

		The factory is used to determine the set of items that will be shown on the
		palette.

		The optionFlags parameter is a bitwise-or of values from the CustomisationFlags
		enum.

		@see ToolbarItemPalette
	*/
	void showCustomisationDialog (ToolbarItemFactory& factory,
								  int optionFlags = allCustomisationOptionsEnabled);

	/** Turns on or off the toolbar's editing mode, in which its items can be
		rearranged by the user.

		(In most cases it's easier just to use showCustomisationDialog() instead of
		trying to enable editing directly).

		@see ToolbarItemPalette
	*/
	void setEditingActive (bool editingEnabled);

	/** A set of colour IDs to use to change the colour of various aspects of the toolbar.

		These constants can be used either via the Component::setColour(), or LookAndFeel::setColour()
		methods.

		@see Component::setColour, Component::findColour, LookAndFeel::setColour, LookAndFeel::findColour
	*/
	enum ColourIds
	{
		backgroundColourId          = 0x1003200,  /**< A colour to use to fill the toolbar's background. For
													   more control over this, override LookAndFeel::paintToolbarBackground(). */
		separatorColourId           = 0x1003210,  /**< A colour to use to draw the separator lines. */

		buttonMouseOverBackgroundColourId = 0x1003220,  /**< A colour used to paint the background of buttons when the mouse is
															 over them. */
		buttonMouseDownBackgroundColourId = 0x1003230,  /**< A colour used to paint the background of buttons when the mouse is
															 held down on them. */

		labelTextColourId           = 0x1003240,        /**< A colour to use for drawing the text under buttons
															 when the style is set to iconsWithText or textOnly. */

		editingModeOutlineColourId  = 0x1003250   /**< A colour to use for an outline around buttons when
													   the customisation dialog is active and the mouse moves over them. */
	};

	/** Returns a string that represents the toolbar's current set of items.

		This lets you later restore the same item layout using restoreFromString().

		@see restoreFromString
	*/
	String toString() const;

	/** Restores a set of items that was previously stored in a string by the toString()
		method.

		The factory object is used to create any item components that are needed.

		@see toString
	*/
	bool restoreFromString (ToolbarItemFactory& factoryToUse,
							const String& savedVersion);

	/** @internal */
	void paint (Graphics& g);
	/** @internal */
	void resized();
	/** @internal */
	void buttonClicked (Button*);
	/** @internal */
	void mouseDown (const MouseEvent&);
	/** @internal */
	bool isInterestedInDragSource (const SourceDetails&);
	/** @internal */
	void itemDragMove (const SourceDetails&);
	/** @internal */
	void itemDragExit (const SourceDetails&);
	/** @internal */
	void itemDropped (const SourceDetails&);
	/** @internal */
	void updateAllItemPositions (bool animate);
	/** @internal */
	static ToolbarItemComponent* createItem (ToolbarItemFactory&, int itemId);

private:

	ScopedPointer<Button> missingItemsButton;
	bool vertical, isEditingActive;
	ToolbarItemStyle toolbarStyle;
	class MissingItemsComponent;
	friend class MissingItemsComponent;
	OwnedArray <ToolbarItemComponent> items;

	friend class ItemDragAndDropOverlayComponent;
	static const char* const toolbarDragDescriptor;

	void addItemInternal (ToolbarItemFactory& factory, int itemId, int insertIndex);

	ToolbarItemComponent* getNextActiveComponent (int index, int delta) const;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (Toolbar);
};

#endif   // __JUCE_TOOLBAR_JUCEHEADER__

/*** End of inlined file: juce_Toolbar.h ***/

class ItemDragAndDropOverlayComponent;

/**
	A component that can be used as one of the items in a Toolbar.

	Each of the items on a toolbar must be a component derived from ToolbarItemComponent,
	and these objects are always created by a ToolbarItemFactory - see the ToolbarItemFactory
	class for further info about creating them.

	The ToolbarItemComponent class is actually a button, but can be used to hold non-button
	components too. To do this, set the value of isBeingUsedAsAButton to false when
	calling the constructor, and override contentAreaChanged(), in which you can position
	any sub-components you need to add.

	To add basic buttons without writing a special subclass, have a look at the
	ToolbarButton class.

	@see ToolbarButton, Toolbar, ToolbarItemFactory
*/
class JUCE_API  ToolbarItemComponent  : public Button
{
public:

	/** Constructor.

		@param itemId       the ID of the type of toolbar item which this represents
		@param labelText    the text to display if the toolbar's style is set to
							Toolbar::iconsWithText or Toolbar::textOnly
		@param isBeingUsedAsAButton     set this to false if you don't want the button
							to draw itself with button over/down states when the mouse
							moves over it or clicks
	*/
	ToolbarItemComponent (int itemId,
						  const String& labelText,
						  bool isBeingUsedAsAButton);

	/** Destructor. */
	~ToolbarItemComponent();

	/** Returns the item type ID that this component represents.
		This value is in the constructor.
	*/
	int getItemId() const noexcept                                  { return itemId; }

	/** Returns the toolbar that contains this component, or 0 if it's not currently
		inside one.
	*/
	Toolbar* getToolbar() const;

	/** Returns true if this component is currently inside a toolbar which is vertical.
		@see Toolbar::isVertical
	*/
	bool isToolbarVertical() const;

	/** Returns the current style setting of this item.

		Styles are listed in the Toolbar::ToolbarItemStyle enum.
		@see setStyle, Toolbar::getStyle
	*/
	Toolbar::ToolbarItemStyle getStyle() const noexcept             { return toolbarStyle; }

	/** Changes the current style setting of this item.

		Styles are listed in the Toolbar::ToolbarItemStyle enum, and are automatically updated
		by the toolbar that holds this item.

		@see setStyle, Toolbar::setStyle
	*/
	virtual void setStyle (const Toolbar::ToolbarItemStyle& newStyle);

	/** Returns the area of the component that should be used to display the button image or
		other contents of the item.

		This content area may change when the item's style changes, and may leave a space around the
		edge of the component where the text label can be shown.

		@see contentAreaChanged
	*/
	const Rectangle<int>& getContentArea() const noexcept           { return contentArea; }

	/** This method must return the size criteria for this item, based on a given toolbar
		size and orientation.

		The preferredSize, minSize and maxSize values must all be set by your implementation
		method. If the toolbar is horizontal, these will be the width of the item; for a vertical
		toolbar, they refer to the item's height.

		The preferredSize is the size that the component would like to be, and this must be
		between the min and max sizes. For a fixed-size item, simply set all three variables to
		the same value.

		The toolbarThickness parameter tells you the depth of the toolbar - the same as calling
		Toolbar::getThickness().

		The isToolbarVertical parameter tells you whether the bar is oriented horizontally or
		vertically.
	*/
	virtual bool getToolbarItemSizes (int toolbarThickness,
									  bool isToolbarVertical,
									  int& preferredSize,
									  int& minSize,
									  int& maxSize) = 0;

	/** Your subclass should use this method to draw its content area.

		The graphics object that is passed-in will have been clipped and had its origin
		moved to fit the content area as specified get getContentArea(). The width and height
		parameters are the width and height of the content area.

		If the component you're writing isn't a button, you can just do nothing in this method.
	*/
	virtual void paintButtonArea (Graphics& g,
								  int width, int height,
								  bool isMouseOver, bool isMouseDown) = 0;

	/** Callback to indicate that the content area of this item has changed.

		This might be because the component was resized, or because the style changed and
		the space needed for the text label is different.

		See getContentArea() for a description of what the area is.
	*/
	virtual void contentAreaChanged (const Rectangle<int>& newBounds) = 0;

	/** Editing modes.
		These are used by setEditingMode(), but will be rarely needed in user code.
	*/
	enum ToolbarEditingMode
	{
		normalMode = 0,     /**< Means that the component is active, inside a toolbar. */
		editableOnToolbar,  /**< Means that the component is on a toolbar, but the toolbar is in
								 customisation mode, and the items can be dragged around. */
		editableOnPalette   /**< Means that the component is on an new-item palette, so it can be
								 dragged onto a toolbar to add it to that bar.*/
	};

	/** Changes the editing mode of this component.

		This is used by the ToolbarItemPalette and related classes for making the items draggable,
		and is unlikely to be of much use in end-user-code.
	*/
	void setEditingMode (const ToolbarEditingMode newMode);

	/** Returns the current editing mode of this component.

		This is used by the ToolbarItemPalette and related classes for making the items draggable,
		and is unlikely to be of much use in end-user-code.
	*/
	ToolbarEditingMode getEditingMode() const noexcept                  { return mode; }

	/** @internal */
	void paintButton (Graphics& g, bool isMouseOver, bool isMouseDown);
	/** @internal */
	void resized();

private:
	friend class Toolbar;
	friend class ItemDragAndDropOverlayComponent;
	const int itemId;
	ToolbarEditingMode mode;
	Toolbar::ToolbarItemStyle toolbarStyle;
	ScopedPointer <Component> overlayComp;
	int dragOffsetX, dragOffsetY;
	bool isActive, isBeingDragged, isBeingUsedAsAButton;
	Rectangle<int> contentArea;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ToolbarItemComponent);
};

#endif   // __JUCE_TOOLBARITEMCOMPONENT_JUCEHEADER__

/*** End of inlined file: juce_ToolbarItemComponent.h ***/

/**
	A type of button designed to go on a toolbar.

	This simple button can have two Drawable objects specified - one for normal
	use and another one (optionally) for the button's "on" state if it's a
	toggle button.

	@see Toolbar, ToolbarItemFactory, ToolbarItemComponent, Drawable, Button
*/
class JUCE_API  ToolbarButton   : public ToolbarItemComponent
{
public:

	/** Creates a ToolbarButton.

		@param itemId       the ID for this toolbar item type. This is passed through to the
							ToolbarItemComponent constructor
		@param labelText    the text to display on the button (if the toolbar is using a style
							that shows text labels). This is passed through to the
							ToolbarItemComponent constructor
		@param normalImage  a drawable object that the button should use as its icon. The object
							that is passed-in here will be kept by this object and will be
							deleted when no longer needed or when this button is deleted.
		@param toggledOnImage  a drawable object that the button can use as its icon if the button
							is in a toggled-on state (see the Button::getToggleState() method). If
							0 is passed-in here, then the normal image will be used instead, regardless
							of the toggle state. The object that is passed-in here will be kept by
							this object and will be deleted when no longer needed or when this button
							is deleted.
	*/
	ToolbarButton (int itemId,
				   const String& labelText,
				   Drawable* normalImage,
				   Drawable* toggledOnImage);

	/** Destructor. */
	~ToolbarButton();

	/** @internal */
	bool getToolbarItemSizes (int toolbarDepth, bool isToolbarVertical, int& preferredSize,
							  int& minSize, int& maxSize);
	/** @internal */
	void paintButtonArea (Graphics& g, int width, int height, bool isMouseOver, bool isMouseDown);
	/** @internal */
	void contentAreaChanged (const Rectangle<int>& newBounds);
	/** @internal */
	void buttonStateChanged();
	/** @internal */
	void resized();
	/** @internal */
	void enablementChanged();

private:

	ScopedPointer<Drawable> normalImage, toggledOnImage;
	Drawable* currentImage;

	void updateDrawable();

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ToolbarButton);
};

#endif   // __JUCE_TOOLBARBUTTON_JUCEHEADER__

/*** End of inlined file: juce_ToolbarButton.h ***/


#endif
#ifndef __JUCE_DRAWABLE_JUCEHEADER__

#endif
#ifndef __JUCE_DRAWABLECOMPOSITE_JUCEHEADER__

/*** Start of inlined file: juce_DrawableComposite.h ***/
#ifndef __JUCE_DRAWABLECOMPOSITE_JUCEHEADER__
#define __JUCE_DRAWABLECOMPOSITE_JUCEHEADER__


/*** Start of inlined file: juce_RelativeParallelogram.h ***/
#ifndef __JUCE_RELATIVEPARALLELOGRAM_JUCEHEADER__
#define __JUCE_RELATIVEPARALLELOGRAM_JUCEHEADER__

/**
	A parallelogram defined by three RelativePoint positions.

	@see RelativePoint, RelativeCoordinate
*/
class JUCE_API  RelativeParallelogram
{
public:

	RelativeParallelogram();
	RelativeParallelogram (const Rectangle<float>& simpleRectangle);
	RelativeParallelogram (const RelativePoint& topLeft, const RelativePoint& topRight, const RelativePoint& bottomLeft);
	RelativeParallelogram (const String& topLeft, const String& topRight, const String& bottomLeft);
	~RelativeParallelogram();

	void resolveThreePoints (Point<float>* points, Expression::Scope* scope) const;
	void resolveFourCorners (Point<float>* points, Expression::Scope* scope) const;
	const Rectangle<float> getBounds (Expression::Scope* scope) const;
	void getPath (Path& path, Expression::Scope* scope) const;
	const AffineTransform resetToPerpendicular (Expression::Scope* scope);
	bool isDynamic() const;

	bool operator== (const RelativeParallelogram& other) const noexcept;
	bool operator!= (const RelativeParallelogram& other) const noexcept;

	static const Point<float> getInternalCoordForPoint (const Point<float>* parallelogramCorners, Point<float> point) noexcept;
	static const Point<float> getPointForInternalCoord (const Point<float>* parallelogramCorners, const Point<float>& internalPoint) noexcept;
	static const Rectangle<float> getBoundingBox (const Point<float>* parallelogramCorners) noexcept;

	RelativePoint topLeft, topRight, bottomLeft;
};

#endif   // __JUCE_RELATIVEPARALLELOGRAM_JUCEHEADER__

/*** End of inlined file: juce_RelativeParallelogram.h ***/


/*** Start of inlined file: juce_RelativeRectangle.h ***/
#ifndef __JUCE_RELATIVERECTANGLE_JUCEHEADER__
#define __JUCE_RELATIVERECTANGLE_JUCEHEADER__

class Component;

/**
	An rectangle stored as a set of RelativeCoordinate values.

	The rectangle's top, left, bottom and right edge positions are each stored as a RelativeCoordinate.

	@see RelativeCoordinate, RelativePoint
*/
class JUCE_API  RelativeRectangle
{
public:

	/** Creates a zero-size rectangle at the origin. */
	RelativeRectangle();

	/** Creates an absolute rectangle, relative to the origin. */
	explicit RelativeRectangle (const Rectangle<float>& rect);

	/** Creates a rectangle from four coordinates. */
	RelativeRectangle (const RelativeCoordinate& left, const RelativeCoordinate& right,
					   const RelativeCoordinate& top, const RelativeCoordinate& bottom);

	/** Creates a rectangle from a stringified representation.
		The string must contain a sequence of 4 coordinates, separated by commas, in the order
		left, top, right, bottom. The syntax for the coordinate strings is explained in the
		RelativeCoordinate class.
		@see toString
	*/
	explicit RelativeRectangle (const String& stringVersion);

	bool operator== (const RelativeRectangle& other) const noexcept;
	bool operator!= (const RelativeRectangle& other) const noexcept;

	/** Calculates the absolute position of this rectangle.

		You'll need to provide a suitable Expression::Scope for looking up any coordinates that may
		be needed to calculate the result.
	*/
	const Rectangle<float> resolve (const Expression::Scope* scope) const;

	/** Changes the values of this rectangle's coordinates to make it resolve to the specified position.

		Calling this will leave any anchor points unchanged, but will set any absolute
		or relative positions to whatever values are necessary to make the resultant position
		match the position that is provided.
	*/
	void moveToAbsolute (const Rectangle<float>& newPos, const Expression::Scope* scope);

	/** Returns true if this rectangle depends on any external symbols for its position.
		Coordinates that refer to symbols based on "this" are assumed not to be dynamic.
	*/
	bool isDynamic() const;

	/** Returns a string which represents this point.
		This returns a comma-separated list of coordinates, in the order left, top, right, bottom. For details of
		the string syntax used by the coordinates, see the RelativeCoordinate constructor notes.
		The string that is returned can be passed to the RelativeRectangle constructor to recreate the rectangle.
	*/
	String toString() const;

	/** Renames a symbol if it is used by any of the coordinates.
		This calls Expression::withRenamedSymbol() on the rectangle's coordinates.
	*/
	void renameSymbol (const Expression::Symbol& oldSymbol, const String& newName, const Expression::Scope& scope);

	/** Creates and sets an appropriate Component::Positioner object for the given component, which will
		keep it positioned with this rectangle.
	*/
	void applyToComponent (Component& component) const;

	// The actual rectangle coords...
	RelativeCoordinate left, right, top, bottom;
};

#endif   // __JUCE_RELATIVERECTANGLE_JUCEHEADER__

/*** End of inlined file: juce_RelativeRectangle.h ***/

/**
	A drawable object which acts as a container for a set of other Drawables.

	@see Drawable
*/
class JUCE_API  DrawableComposite  : public Drawable
{
public:

	/** Creates a composite Drawable. */
	DrawableComposite();

	/** Creates a copy of a DrawableComposite. */
	DrawableComposite (const DrawableComposite& other);

	/** Destructor. */
	~DrawableComposite();

	/** Sets the parallelogram that defines the target position of the content rectangle when the drawable is rendered.
		@see setContentArea
	*/
	void setBoundingBox (const RelativeParallelogram& newBoundingBox);

	/** Returns the parallelogram that defines the target position of the content rectangle when the drawable is rendered.
		@see setBoundingBox
	*/
	const RelativeParallelogram& getBoundingBox() const noexcept            { return bounds; }

	/** Changes the bounding box transform to match the content area, so that any sub-items will
		be drawn at their untransformed positions.
	*/
	void resetBoundingBoxToContentArea();

	/** Returns the main content rectangle.
		The content area is actually defined by the markers named "left", "right", "top" and
		"bottom", but this method is a shortcut that returns them all at once.
		@see contentLeftMarkerName, contentRightMarkerName, contentTopMarkerName, contentBottomMarkerName
	*/
	RelativeRectangle getContentArea() const;

	/** Changes the main content area.
		The content area is actually defined by the markers named "left", "right", "top" and
		"bottom", but this method is a shortcut that sets them all at once.
		@see setBoundingBox, contentLeftMarkerName, contentRightMarkerName, contentTopMarkerName, contentBottomMarkerName
	*/
	void setContentArea (const RelativeRectangle& newArea);

	/** Resets the content area and the bounding transform to fit around the area occupied
		by the child components (ignoring any markers).
	*/
	void resetContentAreaAndBoundingBoxToFitChildren();

	/** The name of the marker that defines the left edge of the content area. */
	static const char* const contentLeftMarkerName;
	/** The name of the marker that defines the right edge of the content area. */
	static const char* const contentRightMarkerName;
	/** The name of the marker that defines the top edge of the content area. */
	static const char* const contentTopMarkerName;
	/** The name of the marker that defines the bottom edge of the content area. */
	static const char* const contentBottomMarkerName;

	/** @internal */
	Drawable* createCopy() const;
	/** @internal */
	void refreshFromValueTree (const ValueTree& tree, ComponentBuilder& builder);
	/** @internal */
	ValueTree createValueTree (ComponentBuilder::ImageProvider* imageProvider) const;
	/** @internal */
	static const Identifier valueTreeType;
	/** @internal */
	Rectangle<float> getDrawableBounds() const;
	/** @internal */
	void childBoundsChanged (Component*);
	/** @internal */
	void childrenChanged();
	/** @internal */
	void parentHierarchyChanged();
	/** @internal */
	MarkerList* getMarkers (bool xAxis);

	/** Internally-used class for wrapping a DrawableComposite's state into a ValueTree. */
	class ValueTreeWrapper   : public Drawable::ValueTreeWrapperBase
	{
	public:
		ValueTreeWrapper (const ValueTree& state);

		ValueTree getChildList() const;
		ValueTree getChildListCreating (UndoManager* undoManager);

		RelativeParallelogram getBoundingBox() const;
		void setBoundingBox (const RelativeParallelogram& newBounds, UndoManager* undoManager);
		void resetBoundingBoxToContentArea (UndoManager* undoManager);

		RelativeRectangle getContentArea() const;
		void setContentArea (const RelativeRectangle& newArea, UndoManager* undoManager);

		MarkerList::ValueTreeWrapper getMarkerList (bool xAxis) const;
		MarkerList::ValueTreeWrapper getMarkerListCreating (bool xAxis, UndoManager* undoManager);

		static const Identifier topLeft, topRight, bottomLeft;

	private:
		static const Identifier childGroupTag, markerGroupTagX, markerGroupTagY;
	};

private:

	RelativeParallelogram bounds;
	MarkerList markersX, markersY;
	bool updateBoundsReentrant;

	friend class Drawable::Positioner<DrawableComposite>;
	bool registerCoordinates (RelativeCoordinatePositionerBase&);
	void recalculateCoordinates (Expression::Scope*);

	void updateBoundsToFitChildren();

	DrawableComposite& operator= (const DrawableComposite&);
	JUCE_LEAK_DETECTOR (DrawableComposite);
};

#endif   // __JUCE_DRAWABLECOMPOSITE_JUCEHEADER__

/*** End of inlined file: juce_DrawableComposite.h ***/


#endif
#ifndef __JUCE_DRAWABLEIMAGE_JUCEHEADER__

/*** Start of inlined file: juce_DrawableImage.h ***/
#ifndef __JUCE_DRAWABLEIMAGE_JUCEHEADER__
#define __JUCE_DRAWABLEIMAGE_JUCEHEADER__

/**
	A drawable object which is a bitmap image.

	@see Drawable
*/
class JUCE_API  DrawableImage  : public Drawable
{
public:

	DrawableImage();
	DrawableImage (const DrawableImage& other);

	/** Destructor. */
	~DrawableImage();

	/** Sets the image that this drawable will render. */
	void setImage (const Image& imageToUse);

	/** Returns the current image. */
	const Image& getImage() const noexcept                      { return image; }

	/** Sets the opacity to use when drawing the image. */
	void setOpacity (float newOpacity);

	/** Returns the image's opacity. */
	float getOpacity() const noexcept                           { return opacity; }

	/** Sets a colour to draw over the image's alpha channel.

		By default this is transparent so isn't drawn, but if you set a non-transparent
		colour here, then it will be overlaid on the image, using the image's alpha
		channel as a mask.

		This is handy for doing things like darkening or lightening an image by overlaying
		it with semi-transparent black or white.
	*/
	void setOverlayColour (const Colour& newOverlayColour);

	/** Returns the overlay colour. */
	const Colour& getOverlayColour() const noexcept             { return overlayColour; }

	/** Sets the bounding box within which the image should be displayed. */
	void setBoundingBox (const RelativeParallelogram& newBounds);

	/** Returns the position to which the image's top-left corner should be remapped in the target
		coordinate space when rendering this object.
		@see setTransform
	*/
	const RelativeParallelogram& getBoundingBox() const noexcept        { return bounds; }

	/** @internal */
	void paint (Graphics& g);
	/** @internal */
	bool hitTest (int x, int y);
	/** @internal */
	Drawable* createCopy() const;
	/** @internal */
	Rectangle<float> getDrawableBounds() const;
	/** @internal */
	void refreshFromValueTree (const ValueTree& tree, ComponentBuilder& builder);
	/** @internal */
	ValueTree createValueTree (ComponentBuilder::ImageProvider* imageProvider) const;
	/** @internal */
	static const Identifier valueTreeType;

	/** Internally-used class for wrapping a DrawableImage's state into a ValueTree. */
	class ValueTreeWrapper   : public Drawable::ValueTreeWrapperBase
	{
	public:
		ValueTreeWrapper (const ValueTree& state);

		var getImageIdentifier() const;
		void setImageIdentifier (const var& newIdentifier, UndoManager* undoManager);
		Value getImageIdentifierValue (UndoManager* undoManager);

		float getOpacity() const;
		void setOpacity (float newOpacity, UndoManager* undoManager);
		Value getOpacityValue (UndoManager* undoManager);

		Colour getOverlayColour() const;
		void setOverlayColour (const Colour& newColour, UndoManager* undoManager);
		Value getOverlayColourValue (UndoManager* undoManager);

		RelativeParallelogram getBoundingBox() const;
		void setBoundingBox (const RelativeParallelogram& newBounds, UndoManager* undoManager);

		static const Identifier opacity, overlay, image, topLeft, topRight, bottomLeft;
	};

private:

	Image image;
	float opacity;
	Colour overlayColour;
	RelativeParallelogram bounds;

	friend class Drawable::Positioner<DrawableImage>;
	bool registerCoordinates (RelativeCoordinatePositionerBase&);
	void recalculateCoordinates (Expression::Scope*);

	DrawableImage& operator= (const DrawableImage&);
	JUCE_LEAK_DETECTOR (DrawableImage);
};

#endif   // __JUCE_DRAWABLEIMAGE_JUCEHEADER__

/*** End of inlined file: juce_DrawableImage.h ***/


#endif
#ifndef __JUCE_DRAWABLEPATH_JUCEHEADER__

/*** Start of inlined file: juce_DrawablePath.h ***/
#ifndef __JUCE_DRAWABLEPATH_JUCEHEADER__
#define __JUCE_DRAWABLEPATH_JUCEHEADER__


/*** Start of inlined file: juce_DrawableShape.h ***/
#ifndef __JUCE_DRAWABLESHAPE_JUCEHEADER__
#define __JUCE_DRAWABLESHAPE_JUCEHEADER__

/**
	A base class implementing common functionality for Drawable classes which
	consist of some kind of filled and stroked outline.

	@see DrawablePath, DrawableRectangle
*/
class JUCE_API  DrawableShape   : public Drawable
{
protected:

	DrawableShape();
	DrawableShape (const DrawableShape&);

public:
	/** Destructor. */
	~DrawableShape();

	/** A FillType wrapper that allows the gradient coordinates to be implemented using RelativePoint.
	*/
	class RelativeFillType
	{
	public:
		RelativeFillType();
		RelativeFillType (const FillType& fill);
		RelativeFillType (const RelativeFillType&);
		RelativeFillType& operator= (const RelativeFillType&);

		bool operator== (const RelativeFillType&) const;
		bool operator!= (const RelativeFillType&) const;

		bool isDynamic() const;
		bool recalculateCoords (Expression::Scope* scope);

		void writeTo (ValueTree& v, ComponentBuilder::ImageProvider*, UndoManager*) const;
		bool readFrom (const ValueTree& v, ComponentBuilder::ImageProvider*);

		FillType fill;
		RelativePoint gradientPoint1, gradientPoint2, gradientPoint3;
	};

	/** Sets a fill type for the path.
		This colour is used to fill the path - if you don't want the path to be
		filled (e.g. if you're just drawing an outline), set this to a transparent
		colour.

		@see setPath, setStrokeFill
	*/
	void setFill (const FillType& newFill);

	/** Sets a fill type for the path.
		This colour is used to fill the path - if you don't want the path to be
		filled (e.g. if you're just drawing an outline), set this to a transparent
		colour.

		@see setPath, setStrokeFill
	*/
	void setFill (const RelativeFillType& newFill);

	/** Returns the current fill type.
		@see setFill
	*/
	const RelativeFillType& getFill() const noexcept                { return mainFill; }

	/** Sets the fill type with which the outline will be drawn.
		@see setFill
	*/
	void setStrokeFill (const FillType& newStrokeFill);

	/** Sets the fill type with which the outline will be drawn.
		@see setFill
	*/
	void setStrokeFill (const RelativeFillType& newStrokeFill);

	/** Returns the current stroke fill.
		@see setStrokeFill
	*/
	const RelativeFillType& getStrokeFill() const noexcept          { return strokeFill; }

	/** Changes the properties of the outline that will be drawn around the path.
		If the stroke has 0 thickness, no stroke will be drawn.
		@see setStrokeThickness, setStrokeColour
	*/
	void setStrokeType (const PathStrokeType& newStrokeType);

	/** Changes the stroke thickness.
		This is a shortcut for calling setStrokeType.
	*/
	void setStrokeThickness (float newThickness);

	/** Returns the current outline style. */
	const PathStrokeType& getStrokeType() const noexcept            { return strokeType; }

	/** @internal */
	class FillAndStrokeState  : public  Drawable::ValueTreeWrapperBase
	{
	public:
		FillAndStrokeState (const ValueTree& state);

		ValueTree getFillState (const Identifier& fillOrStrokeType);
		RelativeFillType getFill (const Identifier& fillOrStrokeType, ComponentBuilder::ImageProvider*) const;
		void setFill (const Identifier& fillOrStrokeType, const RelativeFillType& newFill,
					  ComponentBuilder::ImageProvider*, UndoManager*);

		PathStrokeType getStrokeType() const;
		void setStrokeType (const PathStrokeType& newStrokeType, UndoManager*);

		static const Identifier type, colour, colours, fill, stroke, path, jointStyle, capStyle, strokeWidth,
								gradientPoint1, gradientPoint2, gradientPoint3, radial, imageId, imageOpacity;
	};

	/** @internal */
	Rectangle<float> getDrawableBounds() const;
	/** @internal */
	void paint (Graphics& g);
	/** @internal */
	bool hitTest (int x, int y);

protected:

	/** Called when the cached path should be updated. */
	void pathChanged();
	/** Called when the cached stroke should be updated. */
	void strokeChanged();
	/** True if there's a stroke with a non-zero thickness and non-transparent colour. */
	bool isStrokeVisible() const noexcept;
	/** Updates the details from a FillAndStrokeState object, returning true if something changed. */
	void refreshFillTypes (const FillAndStrokeState& newState, ComponentBuilder::ImageProvider*);
	/** Writes the stroke and fill details to a FillAndStrokeState object. */
	void writeTo (FillAndStrokeState& state, ComponentBuilder::ImageProvider*, UndoManager*) const;

	PathStrokeType strokeType;
	Path path, strokePath;

private:
	class RelativePositioner;
	RelativeFillType mainFill, strokeFill;
	ScopedPointer<RelativeCoordinatePositionerBase> mainFillPositioner, strokeFillPositioner;

	void setFillInternal (RelativeFillType& fill, const RelativeFillType& newFill,
						  ScopedPointer<RelativeCoordinatePositionerBase>& positioner);

	DrawableShape& operator= (const DrawableShape&);
};

#endif   // __JUCE_DRAWABLESHAPE_JUCEHEADER__

/*** End of inlined file: juce_DrawableShape.h ***/


/*** Start of inlined file: juce_RelativePointPath.h ***/
#ifndef __JUCE_RELATIVEPOINTPATH_JUCEHEADER__
#define __JUCE_RELATIVEPOINTPATH_JUCEHEADER__

class DrawablePath;

/**
	A path object that consists of RelativePoint coordinates rather than the normal fixed ones.

	One of these paths can be converted into a Path object for drawing and manipulation, but
	unlike a Path, its points can be dynamic instead of just fixed.

	@see RelativePoint, RelativeCoordinate
*/
class JUCE_API  RelativePointPath
{
public:

	RelativePointPath();
	RelativePointPath (const RelativePointPath& other);
	explicit RelativePointPath (const Path& path);
	~RelativePointPath();

	bool operator== (const RelativePointPath& other) const noexcept;
	bool operator!= (const RelativePointPath& other) const noexcept;

	/** Resolves this points in this path and adds them to a normal Path object. */
	void createPath (Path& path, Expression::Scope* scope) const;

	/** Returns true if the path contains any non-fixed points. */
	bool containsAnyDynamicPoints() const;

	/** Quickly swaps the contents of this path with another. */
	void swapWith (RelativePointPath& other) noexcept;

	/** The types of element that may be contained in this path.
		@see RelativePointPath::ElementBase
	*/
	enum ElementType
	{
		nullElement,
		startSubPathElement,
		closeSubPathElement,
		lineToElement,
		quadraticToElement,
		cubicToElement
	};

	/** Base class for the elements that make up a RelativePointPath.
	*/
	class JUCE_API  ElementBase
	{
	public:
		ElementBase (ElementType type);
		virtual ~ElementBase() {}
		virtual ValueTree createTree() const = 0;
		virtual void addToPath (Path& path, Expression::Scope*) const = 0;
		virtual RelativePoint* getControlPoints (int& numPoints) = 0;
		virtual ElementBase* clone() const = 0;
		bool isDynamic();

		const ElementType type;

	private:
		JUCE_DECLARE_NON_COPYABLE (ElementBase);
	};

	class JUCE_API  StartSubPath  : public ElementBase
	{
	public:
		StartSubPath (const RelativePoint& pos);
		ValueTree createTree() const;
		void addToPath (Path& path, Expression::Scope*) const;
		RelativePoint* getControlPoints (int& numPoints);
		ElementBase* clone() const;

		RelativePoint startPos;

	private:
		JUCE_DECLARE_NON_COPYABLE (StartSubPath);
	};

	class JUCE_API  CloseSubPath  : public ElementBase
	{
	public:
		CloseSubPath();
		ValueTree createTree() const;
		void addToPath (Path& path, Expression::Scope*) const;
		RelativePoint* getControlPoints (int& numPoints);
		ElementBase* clone() const;

	private:
		JUCE_DECLARE_NON_COPYABLE (CloseSubPath);
	};

	class JUCE_API  LineTo  : public ElementBase
	{
	public:
		LineTo (const RelativePoint& endPoint);
		ValueTree createTree() const;
		void addToPath (Path& path, Expression::Scope*) const;
		RelativePoint* getControlPoints (int& numPoints);
		ElementBase* clone() const;

		RelativePoint endPoint;

	private:
		JUCE_DECLARE_NON_COPYABLE (LineTo);
	};

	class JUCE_API  QuadraticTo  : public ElementBase
	{
	public:
		QuadraticTo (const RelativePoint& controlPoint, const RelativePoint& endPoint);
		ValueTree createTree() const;
		void addToPath (Path& path, Expression::Scope*) const;
		RelativePoint* getControlPoints (int& numPoints);
		ElementBase* clone() const;

		RelativePoint controlPoints[2];

	private:
		JUCE_DECLARE_NON_COPYABLE (QuadraticTo);
	};

	class JUCE_API  CubicTo  : public ElementBase
	{
	public:
		CubicTo (const RelativePoint& controlPoint1, const RelativePoint& controlPoint2, const RelativePoint& endPoint);
		ValueTree createTree() const;
		void addToPath (Path& path, Expression::Scope*) const;
		RelativePoint* getControlPoints (int& numPoints);
		ElementBase* clone() const;

		RelativePoint controlPoints[3];

	private:
		JUCE_DECLARE_NON_COPYABLE (CubicTo);
	};

	void addElement (ElementBase* newElement);

	OwnedArray <ElementBase> elements;
	bool usesNonZeroWinding;

private:
	class Positioner;
	friend class Positioner;
	bool containsDynamicPoints;

	void applyTo (DrawablePath& path) const;

	RelativePointPath& operator= (const RelativePointPath&);
	JUCE_LEAK_DETECTOR (RelativePointPath);
};

#endif   // __JUCE_RELATIVEPOINTPATH_JUCEHEADER__

/*** End of inlined file: juce_RelativePointPath.h ***/

/**
	A drawable object which renders a filled or outlined shape.

	For details on how to change the fill and stroke, see the DrawableShape class.

	@see Drawable, DrawableShape
*/
class JUCE_API  DrawablePath  : public DrawableShape
{
public:

	/** Creates a DrawablePath. */
	DrawablePath();
	DrawablePath (const DrawablePath& other);

	/** Destructor. */
	~DrawablePath();

	/** Changes the path that will be drawn.
		@see setFillColour, setStrokeType
	*/
	void setPath (const Path& newPath);

	/** Sets the path using a RelativePointPath.
		Calling this will set up a Component::Positioner to automatically update the path
		if any of the points in the source path are dynamic.
	*/
	void setPath (const RelativePointPath& newPath);

	/** Returns the current path. */
	const Path& getPath() const;

	/** Returns the current path for the outline. */
	const Path& getStrokePath() const;

	/** @internal */
	Drawable* createCopy() const;
	/** @internal */
	void refreshFromValueTree (const ValueTree& tree, ComponentBuilder& builder);
	/** @internal */
	ValueTree createValueTree (ComponentBuilder::ImageProvider* imageProvider) const;
	/** @internal */
	static const Identifier valueTreeType;

	/** Internally-used class for wrapping a DrawablePath's state into a ValueTree. */
	class ValueTreeWrapper   : public DrawableShape::FillAndStrokeState
	{
	public:
		ValueTreeWrapper (const ValueTree& state);

		bool usesNonZeroWinding() const;
		void setUsesNonZeroWinding (bool b, UndoManager* undoManager);

		class Element
		{
		public:
			explicit Element (const ValueTree& state);
			~Element();

			const Identifier getType() const noexcept   { return state.getType(); }
			int getNumControlPoints() const noexcept;

			RelativePoint getControlPoint (int index) const;
			Value getControlPointValue (int index, UndoManager*);
			RelativePoint getStartPoint() const;
			RelativePoint getEndPoint() const;
			void setControlPoint (int index, const RelativePoint& point, UndoManager*);
			float getLength (Expression::Scope*) const;

			ValueTreeWrapper getParent() const;
			Element getPreviousElement() const;

			String getModeOfEndPoint() const;
			void setModeOfEndPoint (const String& newMode, UndoManager*);

			void convertToLine (UndoManager*);
			void convertToCubic (Expression::Scope*, UndoManager*);
			void convertToPathBreak (UndoManager* undoManager);
			ValueTree insertPoint (const Point<float>& targetPoint, Expression::Scope*, UndoManager*);
			void removePoint (UndoManager* undoManager);
			float findProportionAlongLine (const Point<float>& targetPoint, Expression::Scope*) const;

			static const Identifier mode, startSubPathElement, closeSubPathElement,
									lineToElement, quadraticToElement, cubicToElement;
			static const char* cornerMode;
			static const char* roundedMode;
			static const char* symmetricMode;

			ValueTree state;
		};

		ValueTree getPathState();

		void readFrom (const RelativePointPath& path, UndoManager* undoManager);
		void writeTo (RelativePointPath& path) const;

		static const Identifier nonZeroWinding, point1, point2, point3;
	};

private:

	ScopedPointer<RelativePointPath> relativePath;

	class RelativePositioner;
	friend class RelativePositioner;
	void applyRelativePath (const RelativePointPath&, Expression::Scope*);

	DrawablePath& operator= (const DrawablePath&);
	JUCE_LEAK_DETECTOR (DrawablePath);
};

#endif   // __JUCE_DRAWABLEPATH_JUCEHEADER__

/*** End of inlined file: juce_DrawablePath.h ***/


#endif
#ifndef __JUCE_DRAWABLERECTANGLE_JUCEHEADER__

/*** Start of inlined file: juce_DrawableRectangle.h ***/
#ifndef __JUCE_DRAWABLERECTANGLE_JUCEHEADER__
#define __JUCE_DRAWABLERECTANGLE_JUCEHEADER__

/**
	A Drawable object which draws a rectangle.

	For details on how to change the fill and stroke, see the DrawableShape class.

	@see Drawable, DrawableShape
*/
class JUCE_API  DrawableRectangle  : public DrawableShape
{
public:

	DrawableRectangle();
	DrawableRectangle (const DrawableRectangle& other);

	/** Destructor. */
	~DrawableRectangle();

	/** Sets the rectangle's bounds. */
	void setRectangle (const RelativeParallelogram& newBounds);

	/** Returns the rectangle's bounds. */
	const RelativeParallelogram& getRectangle() const noexcept          { return bounds; }

	/** Returns the corner size to be used. */
	const RelativePoint& getCornerSize() const noexcept                 { return cornerSize; }

	/** Sets a new corner size for the rectangle */
	void setCornerSize (const RelativePoint& newSize);

	/** @internal */
	Drawable* createCopy() const;
	/** @internal */
	void refreshFromValueTree (const ValueTree& tree, ComponentBuilder& builder);
	/** @internal */
	ValueTree createValueTree (ComponentBuilder::ImageProvider* imageProvider) const;
	/** @internal */
	static const Identifier valueTreeType;

	/** Internally-used class for wrapping a DrawableRectangle's state into a ValueTree. */
	class ValueTreeWrapper   : public DrawableShape::FillAndStrokeState
	{
	public:
		ValueTreeWrapper (const ValueTree& state);

		RelativeParallelogram getRectangle() const;
		void setRectangle (const RelativeParallelogram& newBounds, UndoManager*);

		void setCornerSize (const RelativePoint& cornerSize, UndoManager*);
		RelativePoint getCornerSize() const;
		Value getCornerSizeValue (UndoManager*);

		static const Identifier topLeft, topRight, bottomLeft, cornerSize;
	};

private:
	friend class Drawable::Positioner<DrawableRectangle>;

	RelativeParallelogram bounds;
	RelativePoint cornerSize;

	void rebuildPath();
	bool registerCoordinates (RelativeCoordinatePositionerBase&);
	void recalculateCoordinates (Expression::Scope*);

	DrawableRectangle& operator= (const DrawableRectangle&);
	JUCE_LEAK_DETECTOR (DrawableRectangle);
};

#endif   // __JUCE_DRAWABLERECTANGLE_JUCEHEADER__

/*** End of inlined file: juce_DrawableRectangle.h ***/


#endif
#ifndef __JUCE_DRAWABLESHAPE_JUCEHEADER__

#endif
#ifndef __JUCE_DRAWABLETEXT_JUCEHEADER__

/*** Start of inlined file: juce_DrawableText.h ***/
#ifndef __JUCE_DRAWABLETEXT_JUCEHEADER__
#define __JUCE_DRAWABLETEXT_JUCEHEADER__

/**
	A drawable object which renders a line of text.

	@see Drawable
*/
class JUCE_API  DrawableText  : public Drawable
{
public:

	/** Creates a DrawableText object. */
	DrawableText();
	DrawableText (const DrawableText& other);

	/** Destructor. */
	~DrawableText();

	/** Sets the text to display.*/
	void setText (const String& newText);

	/** Sets the colour of the text. */
	void setColour (const Colour& newColour);

	/** Returns the current text colour. */
	const Colour& getColour() const noexcept                { return colour; }

	/** Sets the font to use.
		Note that the font height and horizontal scale are set as RelativeCoordinates using
		setFontHeight and setFontHorizontalScale. If applySizeAndScale is true, then these height
		and scale values will be changed to match the dimensions of the font supplied;
		if it is false, then the new font object's height and scale are ignored.
	*/
	void setFont (const Font& newFont, bool applySizeAndScale);

	/** Changes the justification of the text within the bounding box. */
	void setJustification (const Justification& newJustification);

	/** Returns the parallelogram that defines the text bounding box. */
	const RelativeParallelogram& getBoundingBox() const noexcept        { return bounds; }

	/** Sets the bounding box that contains the text. */
	void setBoundingBox (const RelativeParallelogram& newBounds);

	const RelativeCoordinate& getFontHeight() const                     { return fontHeight; }
	void setFontHeight (const RelativeCoordinate& newHeight);

	const RelativeCoordinate& getFontHorizontalScale() const            { return fontHScale; }
	void setFontHorizontalScale (const RelativeCoordinate& newScale);

	/** @internal */
	void paint (Graphics& g);
	/** @internal */
	Drawable* createCopy() const;
	/** @internal */
	void refreshFromValueTree (const ValueTree& tree, ComponentBuilder& builder);
	/** @internal */
	ValueTree createValueTree (ComponentBuilder::ImageProvider* imageProvider) const;
	/** @internal */
	static const Identifier valueTreeType;
	/** @internal */
	Rectangle<float> getDrawableBounds() const;

	/** Internally-used class for wrapping a DrawableText's state into a ValueTree. */
	class ValueTreeWrapper   : public Drawable::ValueTreeWrapperBase
	{
	public:
		ValueTreeWrapper (const ValueTree& state);

		String getText() const;
		void setText (const String& newText, UndoManager* undoManager);
		Value getTextValue (UndoManager* undoManager);

		Colour getColour() const;
		void setColour (const Colour& newColour, UndoManager* undoManager);

		Justification getJustification() const;
		void setJustification (const Justification& newJustification, UndoManager* undoManager);

		Font getFont() const;
		void setFont (const Font& newFont, UndoManager* undoManager);
		Value getFontValue (UndoManager* undoManager);

		RelativeParallelogram getBoundingBox() const;
		void setBoundingBox (const RelativeParallelogram& newBounds, UndoManager* undoManager);

		RelativeCoordinate getFontHeight() const;
		void setFontHeight (const RelativeCoordinate& newHeight, UndoManager* undoManager);

		RelativeCoordinate getFontHorizontalScale() const;
		void setFontHorizontalScale (const RelativeCoordinate& newScale, UndoManager* undoManager);

		static const Identifier text, colour, font, justification, topLeft, topRight, bottomLeft, fontHeight, fontHScale;
	};

private:

	RelativeParallelogram bounds;
	RelativeCoordinate fontHeight, fontHScale;
	Point<float> resolvedPoints[3];
	Font font, scaledFont;
	String text;
	Colour colour;
	Justification justification;

	friend class Drawable::Positioner<DrawableText>;
	bool registerCoordinates (RelativeCoordinatePositionerBase&);
	void recalculateCoordinates (Expression::Scope*);
	void refreshBounds();
	const AffineTransform getArrangementAndTransform (GlyphArrangement& glyphs) const;

	DrawableText& operator= (const DrawableText&);
	JUCE_LEAK_DETECTOR (DrawableText);
};

#endif   // __JUCE_DRAWABLETEXT_JUCEHEADER__

/*** End of inlined file: juce_DrawableText.h ***/


#endif
#ifndef __JUCE_DIRECTORYCONTENTSDISPLAYCOMPONENT_JUCEHEADER__

/*** Start of inlined file: juce_DirectoryContentsDisplayComponent.h ***/
#ifndef __JUCE_DIRECTORYCONTENTSDISPLAYCOMPONENT_JUCEHEADER__
#define __JUCE_DIRECTORYCONTENTSDISPLAYCOMPONENT_JUCEHEADER__


/*** Start of inlined file: juce_DirectoryContentsList.h ***/
#ifndef __JUCE_DIRECTORYCONTENTSLIST_JUCEHEADER__
#define __JUCE_DIRECTORYCONTENTSLIST_JUCEHEADER__


/*** Start of inlined file: juce_FileFilter.h ***/
#ifndef __JUCE_FILEFILTER_JUCEHEADER__
#define __JUCE_FILEFILTER_JUCEHEADER__

/**
	Interface for deciding which files are suitable for something.

	For example, this is used by DirectoryContentsList to select which files
	go into the list.

	@see WildcardFileFilter, DirectoryContentsList, FileListComponent, FileBrowserComponent
*/
class JUCE_API  FileFilter
{
public:

	/** Creates a filter with the given description.

		The description can be returned later with the getDescription() method.
	*/
	FileFilter (const String& filterDescription);

	/** Destructor. */
	virtual ~FileFilter();

	/** Returns the description that the filter was created with. */
	const String& getDescription() const noexcept;

	/** Should return true if this file is suitable for inclusion in whatever context
		the object is being used.
	*/
	virtual bool isFileSuitable (const File& file) const = 0;

	/** Should return true if this directory is suitable for inclusion in whatever context
		the object is being used.
	*/
	virtual bool isDirectorySuitable (const File& file) const = 0;

protected:

	String description;
};

#endif   // __JUCE_FILEFILTER_JUCEHEADER__

/*** End of inlined file: juce_FileFilter.h ***/

/**
	A class to asynchronously scan for details about the files in a directory.

	This keeps a list of files and some information about them, using a background
	thread to scan for more files. As files are found, it broadcasts change messages
	to tell any listeners.

	@see FileListComponent, FileBrowserComponent
*/
class JUCE_API  DirectoryContentsList   : public ChangeBroadcaster,
										  public TimeSliceClient
{
public:

	/** Creates a directory list.

		To set the directory it should point to, use setDirectory(), which will
		also start it scanning for files on the background thread.

		When the background thread finds and adds new files to this list, the
		ChangeBroadcaster class will send a change message, so you can register
		listeners and update them when the list changes.

		@param fileFilter       an optional filter to select which files are
								included in the list. If this is 0, then all files
								and directories are included. Make sure that the
								filter doesn't get deleted during the lifetime of this
								object
		@param threadToUse      a thread object that this list can use
								to scan for files as a background task. Make sure
								that the thread you give it has been started, or you
								won't get any files!
	*/
	DirectoryContentsList (const FileFilter* fileFilter,
						   TimeSliceThread& threadToUse);

	/** Destructor. */
	~DirectoryContentsList();

	/** Sets the directory to look in for files.

		If the directory that's passed in is different to the current one, this will
		also start the background thread scanning it for files.
	*/
	void setDirectory (const File& directory,
					   bool includeDirectories,
					   bool includeFiles);

	/** Returns the directory that's currently being used. */
	const File& getDirectory() const;

	/** Clears the list, and stops the thread scanning for files. */
	void clear();

	/** Clears the list and restarts scanning the directory for files. */
	void refresh();

	/** True if the background thread hasn't yet finished scanning for files. */
	bool isStillLoading() const;

	/** Tells the list whether or not to ignore hidden files.

		By default these are ignored.
	*/
	void setIgnoresHiddenFiles (bool shouldIgnoreHiddenFiles);

	/** Returns true if hidden files are ignored.
		@see setIgnoresHiddenFiles
	*/
	bool ignoresHiddenFiles() const;

	/** Contains cached information about one of the files in a DirectoryContentsList.
	*/
	struct FileInfo
	{

		/** The filename.

			This isn't a full pathname, it's just the last part of the path, same as you'd
			get from File::getFileName().

			To get the full pathname, use DirectoryContentsList::getDirectory().getChildFile (filename).
		*/
		String filename;

		/** File size in bytes. */
		int64 fileSize;

		/** File modification time.

			As supplied by File::getLastModificationTime().
		*/
		Time modificationTime;

		/** File creation time.

			As supplied by File::getCreationTime().
		*/
		Time creationTime;

		/** True if the file is a directory. */
		bool isDirectory;

		/** True if the file is read-only. */
		bool isReadOnly;
	};

	/** Returns the number of files currently available in the list.

		The info about one of these files can be retrieved with getFileInfo() or
		getFile().

		Obviously as the background thread runs and scans the directory for files, this
		number will change.

		@see getFileInfo, getFile
	*/
	int getNumFiles() const;

	/** Returns the cached information about one of the files in the list.

		If the index is in-range, this will return true and will copy the file's details
		to the structure that is passed-in.

		If it returns false, then the index wasn't in range, and the structure won't
		be affected.

		@see getNumFiles, getFile
	*/
	bool getFileInfo (int index, FileInfo& resultInfo) const;

	/** Returns one of the files in the list.

		@param index    should be less than getNumFiles(). If this is out-of-range, the
						return value will be File::nonexistent
		@see getNumFiles, getFileInfo
	*/
	File getFile (int index) const;

	/** Returns the file filter being used.

		The filter is specified in the constructor.
	*/
	const FileFilter* getFilter() const                     { return fileFilter; }

	/** Returns true if the list contains the specified file. */
	bool contains (const File&) const;

	/** @internal */
	int useTimeSlice();
	/** @internal */
	TimeSliceThread& getTimeSliceThread()                   { return thread; }
	/** @internal */
	static int compareElements (const DirectoryContentsList::FileInfo* first,
								const DirectoryContentsList::FileInfo* second);

private:
	File root;
	const FileFilter* fileFilter;
	TimeSliceThread& thread;
	int fileTypeFlags;

	CriticalSection fileListLock;
	OwnedArray <FileInfo> files;

	ScopedPointer <DirectoryIterator> fileFindHandle;
	bool volatile shouldStop;

	void stopSearching();
	void changed();
	bool checkNextFile (bool& hasChanged);
	bool addFile (const File& file, bool isDir,
				  const int64 fileSize, const Time& modTime,
				  const Time& creationTime, bool isReadOnly);
	void setTypeFlags (int newFlags);

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (DirectoryContentsList);
};

#endif   // __JUCE_DIRECTORYCONTENTSLIST_JUCEHEADER__

/*** End of inlined file: juce_DirectoryContentsList.h ***/


/*** Start of inlined file: juce_FileBrowserListener.h ***/
#ifndef __JUCE_FILEBROWSERLISTENER_JUCEHEADER__
#define __JUCE_FILEBROWSERLISTENER_JUCEHEADER__

/**
	A listener for user selection events in a file browser.

	This is used by a FileBrowserComponent or FileListComponent.
*/
class JUCE_API  FileBrowserListener
{
public:

	/** Destructor. */
	virtual ~FileBrowserListener();

	/** Callback when the user selects a different file in the browser. */
	virtual void selectionChanged() = 0;

	/** Callback when the user clicks on a file in the browser. */
	virtual void fileClicked (const File& file, const MouseEvent& e) = 0;

	/** Callback when the user double-clicks on a file in the browser. */
	virtual void fileDoubleClicked (const File& file) = 0;

	/** Callback when the browser's root folder changes. */
	virtual void browserRootChanged (const File& newRoot) = 0;
};

#endif   // __JUCE_FILEBROWSERLISTENER_JUCEHEADER__

/*** End of inlined file: juce_FileBrowserListener.h ***/

/**
	A base class for components that display a list of the files in a directory.

	@see DirectoryContentsList
*/
class JUCE_API  DirectoryContentsDisplayComponent
{
public:

	/** Creates a DirectoryContentsDisplayComponent for a given list of files. */
	DirectoryContentsDisplayComponent (DirectoryContentsList& listToShow);

	/** Destructor. */
	virtual ~DirectoryContentsDisplayComponent();

	/** Returns the number of files the user has got selected.
		@see getSelectedFile
	*/
	virtual int getNumSelectedFiles() const = 0;

	/** Returns one of the files that the user has currently selected.
		The index should be in the range 0 to (getNumSelectedFiles() - 1).
		@see getNumSelectedFiles
	*/
	virtual File getSelectedFile (int index) const = 0;

	/** Deselects any selected files. */
	virtual void deselectAllFiles() = 0;

	/** Scrolls this view to the top. */
	virtual void scrollToTop() = 0;

	/** If the specified file is in the list, it will become the only selected item
		(and if the file isn't in the list, all other items will be deselected). */
	virtual void setSelectedFile (const File&) = 0;

	/** Adds a listener to be told when files are selected or clicked.
		@see removeListener
	*/
	void addListener (FileBrowserListener* listener);

	/** Removes a listener.
		@see addListener
	*/
	void removeListener (FileBrowserListener* listener);

	/** A set of colour IDs to use to change the colour of various aspects of the list.

		These constants can be used either via the Component::setColour(), or LookAndFeel::setColour()
		methods.

		@see Component::setColour, Component::findColour, LookAndFeel::setColour, LookAndFeel::findColour
	*/
	enum ColourIds
	{
		highlightColourId      = 0x1000540, /**< The colour to use to fill a highlighted row of the list. */
		textColourId           = 0x1000541, /**< The colour for the text. */
	};

	/** @internal */
	void sendSelectionChangeMessage();
	/** @internal */
	void sendDoubleClickMessage (const File& file);
	/** @internal */
	void sendMouseClickMessage (const File& file, const MouseEvent& e);

protected:

	DirectoryContentsList& fileList;
	ListenerList <FileBrowserListener> listeners;

private:
	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (DirectoryContentsDisplayComponent);
};

#endif   // __JUCE_DIRECTORYCONTENTSDISPLAYCOMPONENT_JUCEHEADER__

/*** End of inlined file: juce_DirectoryContentsDisplayComponent.h ***/


#endif
#ifndef __JUCE_DIRECTORYCONTENTSLIST_JUCEHEADER__

#endif
#ifndef __JUCE_FILEBROWSERCOMPONENT_JUCEHEADER__

/*** Start of inlined file: juce_FileBrowserComponent.h ***/
#ifndef __JUCE_FILEBROWSERCOMPONENT_JUCEHEADER__
#define __JUCE_FILEBROWSERCOMPONENT_JUCEHEADER__


/*** Start of inlined file: juce_FilePreviewComponent.h ***/
#ifndef __JUCE_FILEPREVIEWCOMPONENT_JUCEHEADER__
#define __JUCE_FILEPREVIEWCOMPONENT_JUCEHEADER__

/**
	Base class for components that live inside a file chooser dialog box and
	show previews of the files that get selected.

	One of these allows special extra information to be displayed for files
	in a dialog box as the user selects them. Each time the current file or
	directory is changed, the selectedFileChanged() method will be called
	to allow it to update itself appropriately.

	@see FileChooser, ImagePreviewComponent
*/
class JUCE_API  FilePreviewComponent  : public Component
{
public:

	/** Creates a FilePreviewComponent. */
	FilePreviewComponent();

	/** Destructor. */
	~FilePreviewComponent();

	/** Called to indicate that the user's currently selected file has changed.

		@param newSelectedFile  the newly selected file or directory, which may be
								File::nonexistent if none is selected.
	*/
	virtual void selectedFileChanged (const File& newSelectedFile) = 0;

private:

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (FilePreviewComponent);
};

#endif   // __JUCE_FILEPREVIEWCOMPONENT_JUCEHEADER__

/*** End of inlined file: juce_FilePreviewComponent.h ***/


/*** Start of inlined file: juce_TextEditor.h ***/
#ifndef __JUCE_TEXTEDITOR_JUCEHEADER__
#define __JUCE_TEXTEDITOR_JUCEHEADER__


/*** Start of inlined file: juce_Viewport.h ***/
#ifndef __JUCE_VIEWPORT_JUCEHEADER__
#define __JUCE_VIEWPORT_JUCEHEADER__


/*** Start of inlined file: juce_ScrollBar.h ***/
#ifndef __JUCE_SCROLLBAR_JUCEHEADER__
#define __JUCE_SCROLLBAR_JUCEHEADER__

/**
	A scrollbar component.

	To use a scrollbar, set up its total range using the setRangeLimits() method - this
	sets the range of values it can represent. Then you can use setCurrentRange() to
	change the position and size of the scrollbar's 'thumb'.

	Registering a ScrollBar::Listener with the scrollbar will allow you to find out when
	the user moves it, and you can use the getCurrentRangeStart() to find out where
	they moved it to.

	The scrollbar will adjust its own visibility according to whether its thumb size
	allows it to actually be scrolled.

	For most purposes, it's probably easier to use a ViewportContainer or ListBox
	instead of handling a scrollbar directly.

	@see ScrollBar::Listener
*/
class JUCE_API  ScrollBar  : public Component,
							 public AsyncUpdater,
							 private Timer
{
public:

	/** Creates a Scrollbar.

		@param isVertical           whether it should be a vertical or horizontal bar
		@param buttonsAreVisible    whether to show the up/down or left/right buttons
	*/
	ScrollBar (bool isVertical,
			   bool buttonsAreVisible = true);

	/** Destructor. */
	~ScrollBar();

	/** Returns true if the scrollbar is vertical, false if it's horizontal. */
	bool isVertical() const noexcept                                { return vertical; }

	/** Changes the scrollbar's direction.

		You'll also need to resize the bar appropriately - this just changes its internal
		layout.

		@param shouldBeVertical     true makes it vertical; false makes it horizontal.
	*/
	void setOrientation (bool shouldBeVertical);

	/** Shows or hides the scrollbar's buttons. */
	void setButtonVisibility (bool buttonsAreVisible);

	/** Tells the scrollbar whether to make itself invisible when not needed.

		The default behaviour is for a scrollbar to become invisible when the thumb
		fills the whole of its range (i.e. when it can't be moved). Setting this
		value to false forces the bar to always be visible.
		@see autoHides()
	*/
	void setAutoHide (bool shouldHideWhenFullRange);

	/** Returns true if this scrollbar is set to auto-hide when its thumb is as big
		as its maximum range.
		@see setAutoHide
	*/
	bool autoHides() const noexcept;

	/** Sets the minimum and maximum values that the bar will move between.

		The bar's thumb will always be constrained so that the entire thumb lies
		within this range.

		@see setCurrentRange
	*/
	void setRangeLimits (const Range<double>& newRangeLimit);

	/** Sets the minimum and maximum values that the bar will move between.

		The bar's thumb will always be constrained so that the entire thumb lies
		within this range.

		@see setCurrentRange
	*/
	void setRangeLimits (double minimum, double maximum);

	/** Returns the current limits on the thumb position.
		@see setRangeLimits
	*/
	const Range<double> getRangeLimit() const noexcept              { return totalRange; }

	/** Returns the lower value that the thumb can be set to.

		This is the value set by setRangeLimits().
	*/
	double getMinimumRangeLimit() const noexcept                    { return totalRange.getStart(); }

	/** Returns the upper value that the thumb can be set to.

		This is the value set by setRangeLimits().
	*/
	double getMaximumRangeLimit() const noexcept                    { return totalRange.getEnd(); }

	/** Changes the position of the scrollbar's 'thumb'.

		If this method call actually changes the scrollbar's position, it will trigger an
		asynchronous call to ScrollBar::Listener::scrollBarMoved() for all the listeners that
		are registered.

		@see getCurrentRange. setCurrentRangeStart
	*/
	void setCurrentRange (const Range<double>& newRange);

	/** Changes the position of the scrollbar's 'thumb'.

		This sets both the position and size of the thumb - to just set the position without
		changing the size, you can use setCurrentRangeStart().

		If this method call actually changes the scrollbar's position, it will trigger an
		asynchronous call to ScrollBar::Listener::scrollBarMoved() for all the listeners that
		are registered.

		@param newStart     the top (or left) of the thumb, in the range
							getMinimumRangeLimit() <= newStart <= getMaximumRangeLimit(). If the
							value is beyond these limits, it will be clipped.
		@param newSize      the size of the thumb, such that
							getMinimumRangeLimit() <= newStart + newSize <= getMaximumRangeLimit(). If the
							size is beyond these limits, it will be clipped.
		@see setCurrentRangeStart, getCurrentRangeStart, getCurrentRangeSize
	*/
	void setCurrentRange (double newStart, double newSize);

	/** Moves the bar's thumb position.

		This will move the thumb position without changing the thumb size. Note
		that the maximum thumb start position is (getMaximumRangeLimit() - getCurrentRangeSize()).

		If this method call actually changes the scrollbar's position, it will trigger an
		asynchronous call to ScrollBar::Listener::scrollBarMoved() for all the listeners that
		are registered.

		@see setCurrentRange
	*/
	void setCurrentRangeStart (double newStart);

	/** Returns the current thumb range.
		@see getCurrentRange, setCurrentRange
	*/
	const Range<double> getCurrentRange() const noexcept            { return visibleRange; }

	/** Returns the position of the top of the thumb.
		@see getCurrentRange, setCurrentRangeStart
	*/
	double getCurrentRangeStart() const noexcept                    { return visibleRange.getStart(); }

	/** Returns the current size of the thumb.
		@see getCurrentRange, setCurrentRange
	*/
	double getCurrentRangeSize() const noexcept                     { return visibleRange.getLength(); }

	/** Sets the amount by which the up and down buttons will move the bar.

		The value here is in terms of the total range, and is added or subtracted
		from the thumb position when the user clicks an up/down (or left/right) button.
	*/
	void setSingleStepSize (double newSingleStepSize);

	/** Moves the scrollbar by a number of single-steps.

		This will move the bar by a multiple of its single-step interval (as
		specified using the setSingleStepSize() method).

		A positive value here will move the bar down or to the right, a negative
		value moves it up or to the left.
	*/
	void moveScrollbarInSteps (int howManySteps);

	/** Moves the scroll bar up or down in pages.

		This will move the bar by a multiple of its current thumb size, effectively
		doing a page-up or down.

		A positive value here will move the bar down or to the right, a negative
		value moves it up or to the left.
	*/
	void moveScrollbarInPages (int howManyPages);

	/** Scrolls to the top (or left).

		This is the same as calling setCurrentRangeStart (getMinimumRangeLimit());
	*/
	void scrollToTop();

	/** Scrolls to the bottom (or right).

		This is the same as calling setCurrentRangeStart (getMaximumRangeLimit() - getCurrentRangeSize());
	*/
	void scrollToBottom();

	/** Changes the delay before the up and down buttons autorepeat when they are held
		down.

		For an explanation of what the parameters are for, see Button::setRepeatSpeed().

		@see Button::setRepeatSpeed
	*/
	void setButtonRepeatSpeed (int initialDelayInMillisecs,
							   int repeatDelayInMillisecs,
							   int minimumDelayInMillisecs = -1);

	/** A set of colour IDs to use to change the colour of various aspects of the component.

		These constants can be used either via the Component::setColour(), or LookAndFeel::setColour()
		methods.

		@see Component::setColour, Component::findColour, LookAndFeel::setColour, LookAndFeel::findColour
	*/
	enum ColourIds
	{
		backgroundColourId          = 0x1000300,    /**< The background colour of the scrollbar. */
		thumbColourId               = 0x1000400,    /**< A base colour to use for the thumb. The look and feel will probably use variations on this colour. */
		trackColourId               = 0x1000401     /**< A base colour to use for the slot area of the bar. The look and feel will probably use variations on this colour. */
	};

	/**
		A class for receiving events from a ScrollBar.

		You can register a ScrollBar::Listener with a ScrollBar using the ScrollBar::addListener()
		method, and it will be called when the bar's position changes.

		@see ScrollBar::addListener, ScrollBar::removeListener
	*/
	class JUCE_API  Listener
	{
	public:
		/** Destructor. */
		virtual ~Listener() {}

		/** Called when a ScrollBar is moved.

			@param scrollBarThatHasMoved    the bar that has moved
			@param newRangeStart            the new range start of this bar
		*/
		virtual void scrollBarMoved (ScrollBar* scrollBarThatHasMoved,
									 double newRangeStart) = 0;
	};

	/** Registers a listener that will be called when the scrollbar is moved. */
	void addListener (Listener* listener);

	/** Deregisters a previously-registered listener. */
	void removeListener (Listener* listener);

	/** @internal */
	bool keyPressed (const KeyPress& key);
	/** @internal */
	void mouseWheelMove (const MouseEvent& e, float wheelIncrementX, float wheelIncrementY);
	/** @internal */
	void lookAndFeelChanged();
	/** @internal */
	void handleAsyncUpdate();
	/** @internal */
	void mouseDown (const MouseEvent& e);
	/** @internal */
	void mouseDrag (const MouseEvent& e);
	/** @internal */
	void mouseUp   (const MouseEvent& e);
	/** @internal */
	void paint (Graphics& g);
	/** @internal */
	void resized();

private:

	Range <double> totalRange, visibleRange;
	double singleStepSize, dragStartRange;
	int thumbAreaStart, thumbAreaSize, thumbStart, thumbSize;
	int dragStartMousePos, lastMousePos;
	int initialDelayInMillisecs, repeatDelayInMillisecs, minimumDelayInMillisecs;
	bool vertical, isDraggingThumb, autohides;
	class ScrollbarButton;
	friend class ScopedPointer<ScrollbarButton>;
	ScopedPointer<ScrollbarButton> upButton, downButton;
	ListenerList <Listener> listeners;

	void updateThumbPosition();
	void timerCallback();

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ScrollBar);
};

/** This typedef is just for compatibility with old code - newer code should use the ScrollBar::Listener class directly. */
typedef ScrollBar::Listener ScrollBarListener;

#endif   // __JUCE_SCROLLBAR_JUCEHEADER__

/*** End of inlined file: juce_ScrollBar.h ***/

/**
	A Viewport is used to contain a larger child component, and allows the child
	to be automatically scrolled around.

	To use a Viewport, just create one and set the component that goes inside it
	using the setViewedComponent() method. When the child component changes size,
	the Viewport will adjust its scrollbars accordingly.

	A subclass of the viewport can be created which will receive calls to its
	visibleAreaChanged() method when the subcomponent changes position or size.

*/
class JUCE_API  Viewport  : public Component,
							private ComponentListener,
							private ScrollBar::Listener
{
public:

	/** Creates a Viewport.

		The viewport is initially empty - use the setViewedComponent() method to
		add a child component for it to manage.
	*/
	explicit Viewport (const String& componentName = String::empty);

	/** Destructor. */
	~Viewport();

	/** Sets the component that this viewport will contain and scroll around.

		This will add the given component to this Viewport and position it at (0, 0).

		(Don't add or remove any child components directly using the normal
		Component::addChildComponent() methods).

		@param newViewedComponent   the component to add to this viewport, or null to remove
									the current component.
		@param deleteComponentWhenNoLongerNeeded    if true, the component will be deleted
									automatically when the viewport is deleted or when a different
									component is added. If false, the caller must manage the lifetime
									of the component
		@see getViewedComponent
	*/
	void setViewedComponent (Component* newViewedComponent,
							 bool deleteComponentWhenNoLongerNeeded = true);

	/** Returns the component that's currently being used inside the Viewport.

		@see setViewedComponent
	*/
	Component* getViewedComponent() const noexcept                  { return contentComp; }

	/** Changes the position of the viewed component.

		The inner component will be moved so that the pixel at the top left of
		the viewport will be the pixel at position (xPixelsOffset, yPixelsOffset)
		within the inner component.

		This will update the scrollbars and might cause a call to visibleAreaChanged().

		@see getViewPositionX, getViewPositionY, setViewPositionProportionately
	*/
	void setViewPosition (int xPixelsOffset, int yPixelsOffset);

	/** Changes the position of the viewed component.

		The inner component will be moved so that the pixel at the top left of
		the viewport will be the pixel at the specified coordinates within the
		inner component.

		This will update the scrollbars and might cause a call to visibleAreaChanged().

		@see getViewPositionX, getViewPositionY, setViewPositionProportionately
	*/
	void setViewPosition (const Point<int>& newPosition);

	/** Changes the view position as a proportion of the distance it can move.

		The values here are from 0.0 to 1.0 - where (0, 0) would put the
		visible area in the top-left, and (1, 1) would put it as far down and
		to the right as it's possible to go whilst keeping the child component
		on-screen.
	*/
	void setViewPositionProportionately (double proportionX, double proportionY);

	/** If the specified position is at the edges of the viewport, this method scrolls
		the viewport to bring that position nearer to the centre.

		Call this if you're dragging an object inside a viewport and want to make it scroll
		when the user approaches an edge. You might also find Component::beginDragAutoRepeat()
		useful when auto-scrolling.

		@param mouseX       the x position, relative to the Viewport's top-left
		@param mouseY       the y position, relative to the Viewport's top-left
		@param distanceFromEdge     specifies how close to an edge the position needs to be
							before the viewport should scroll in that direction
		@param maximumSpeed the maximum number of pixels that the viewport is allowed
							to scroll by.
		@returns            true if the viewport was scrolled
	*/
	bool autoScroll (int mouseX, int mouseY, int distanceFromEdge, int maximumSpeed);

	/** Returns the position within the child component of the top-left of its visible area.
	*/
	const Point<int>& getViewPosition() const noexcept      { return lastVisibleArea.getPosition(); }

	/** Returns the position within the child component of the top-left of its visible area.
		@see getViewWidth, setViewPosition
	*/
	int getViewPositionX() const noexcept                   { return lastVisibleArea.getX(); }

	/** Returns the position within the child component of the top-left of its visible area.
		@see getViewHeight, setViewPosition
	*/
	int getViewPositionY() const noexcept                   { return lastVisibleArea.getY(); }

	/** Returns the width of the visible area of the child component.

		This may be less than the width of this Viewport if there's a vertical scrollbar
		or if the child component is itself smaller.
	*/
	int getViewWidth() const noexcept                       { return lastVisibleArea.getWidth(); }

	/** Returns the height of the visible area of the child component.

		This may be less than the height of this Viewport if there's a horizontal scrollbar
		or if the child component is itself smaller.
	*/
	int getViewHeight() const noexcept                      { return lastVisibleArea.getHeight(); }

	/** Returns the width available within this component for the contents.

		This will be the width of the viewport component minus the width of a
		vertical scrollbar (if visible).
	*/
	int getMaximumVisibleWidth() const;

	/** Returns the height available within this component for the contents.

		This will be the height of the viewport component minus the space taken up
		by a horizontal scrollbar (if visible).
	*/
	int getMaximumVisibleHeight() const;

	/** Callback method that is called when the visible area changes.

		This will be called when the visible area is moved either be scrolling or
		by calls to setViewPosition(), etc.
	*/
	virtual void visibleAreaChanged (const Rectangle<int>& newVisibleArea);

	/** Callback method that is called when the viewed component is added, removed or swapped. */
	virtual void viewedComponentChanged (Component* newComponent);

	/** Turns scrollbars on or off.

		If set to false, the scrollbars won't ever appear. When true (the default)
		they will appear only when needed.
	*/
	void setScrollBarsShown (bool showVerticalScrollbarIfNeeded,
							 bool showHorizontalScrollbarIfNeeded);

	/** True if the vertical scrollbar is enabled.
		@see setScrollBarsShown
	*/
	bool isVerticalScrollBarShown() const noexcept              { return showVScrollbar; }

	/** True if the horizontal scrollbar is enabled.
		@see setScrollBarsShown
	*/
	bool isHorizontalScrollBarShown() const noexcept            { return showHScrollbar; }

	/** Changes the width of the scrollbars.

		If this isn't specified, the default width from the LookAndFeel class will be used.

		@see LookAndFeel::getDefaultScrollbarWidth
	*/
	void setScrollBarThickness (int thickness);

	/** Returns the thickness of the scrollbars.

		@see setScrollBarThickness
	*/
	int getScrollBarThickness() const;

	/** Changes the distance that a single-step click on a scrollbar button
		will move the viewport.
	*/
	void setSingleStepSizes (int stepX, int stepY);

	/** Shows or hides the buttons on any scrollbars that are used.

		@see ScrollBar::setButtonVisibility
	*/
	void setScrollBarButtonVisibility (bool buttonsVisible);

	/** Returns a pointer to the scrollbar component being used.
		Handy if you need to customise the bar somehow.
	*/
	ScrollBar* getVerticalScrollBar() noexcept                  { return &verticalScrollBar; }

	/** Returns a pointer to the scrollbar component being used.
		Handy if you need to customise the bar somehow.
	*/
	ScrollBar* getHorizontalScrollBar() noexcept                { return &horizontalScrollBar; }

	struct Ids
	{
		static const Identifier showScrollBarV, showScrollBarH, scrollBarWidth;
	};

	void refreshFromValueTree (const ValueTree&, ComponentBuilder&);

	/** @internal */
	void resized();
	/** @internal */
	void scrollBarMoved (ScrollBar* scrollBarThatHasMoved, double newRangeStart);
	/** @internal */
	void mouseWheelMove (const MouseEvent& e, float wheelIncrementX, float wheelIncrementY);
	/** @internal */
	bool keyPressed (const KeyPress& key);
	/** @internal */
	void componentMovedOrResized (Component& component, bool wasMoved, bool wasResized);
	/** @internal */
	bool useMouseWheelMoveIfNeeded (const MouseEvent& e, float wheelIncrementX, float wheelIncrementY);

private:

	WeakReference<Component> contentComp;
	Rectangle<int> lastVisibleArea;
	int scrollBarThickness;
	int singleStepX, singleStepY;
	bool showHScrollbar, showVScrollbar, deleteContent;
	Component contentHolder;
	ScrollBar verticalScrollBar;
	ScrollBar horizontalScrollBar;
	Point<int> viewportPosToCompPos (const Point<int>&) const;

	void updateVisibleArea();
	void deleteContentComp();

   #if JUCE_CATCH_DEPRECATED_CODE_MISUSE
	// If you get an error here, it's because this method's parameters have changed! See the new definition above..
	virtual int visibleAreaChanged (int, int, int, int) { return 0; }
   #endif

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (Viewport);
};

#endif   // __JUCE_VIEWPORT_JUCEHEADER__

/*** End of inlined file: juce_Viewport.h ***/


/*** Start of inlined file: juce_PopupMenu.h ***/
#ifndef __JUCE_POPUPMENU_JUCEHEADER__
#define __JUCE_POPUPMENU_JUCEHEADER__

/** Creates and displays a popup-menu.

	To show a popup-menu, you create one of these, add some items to it, then
	call its show() method, which returns the id of the item the user selects.

	E.g. @code
	void MyWidget::mouseDown (const MouseEvent& e)
	{
		PopupMenu m;
		m.addItem (1, "item 1");
		m.addItem (2, "item 2");

		const int result = m.show();

		if (result == 0)
		{
			// user dismissed the menu without picking anything
		}
		else if (result == 1)
		{
			// user picked item 1
		}
		else if (result == 2)
		{
			// user picked item 2
		}
	}
	@endcode

	Submenus are easy too: @code

	void MyWidget::mouseDown (const MouseEvent& e)
	{
		PopupMenu subMenu;
		subMenu.addItem (1, "item 1");
		subMenu.addItem (2, "item 2");

		PopupMenu mainMenu;
		mainMenu.addItem (3, "item 3");
		mainMenu.addSubMenu ("other choices", subMenu);

		const int result = m.show();

		...etc
	}
	@endcode
*/
class JUCE_API  PopupMenu
{
private:
	class Window;

public:

	/** Creates an empty popup menu. */
	PopupMenu();

	/** Creates a copy of another menu. */
	PopupMenu (const PopupMenu& other);

	/** Destructor. */
	~PopupMenu();

	/** Copies this menu from another one. */
	PopupMenu& operator= (const PopupMenu& other);

   #if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
	PopupMenu (PopupMenu&& other) noexcept;
	PopupMenu& operator= (PopupMenu&& other) noexcept;
   #endif

	/** Resets the menu, removing all its items. */
	void clear();

	/** Appends a new text item for this menu to show.

		@param itemResultId     the number that will be returned from the show() method
								if the user picks this item. The value should never be
								zero, because that's used to indicate that the user didn't
								select anything.
		@param itemText         the text to show.
		@param isEnabled        if false, the item will be shown 'greyed-out' and can't be picked
		@param isTicked         if true, the item will be shown with a tick next to it
		@param iconToUse        if this is non-zero, it should be an image that will be
								displayed to the left of the item. This method will take its
								own copy of the image passed-in, so there's no need to keep
								it hanging around.

		@see addSeparator, addColouredItem, addCustomItem, addSubMenu
	*/
	void addItem (int itemResultId,
				  const String& itemText,
				  bool isEnabled = true,
				  bool isTicked = false,
				  const Image& iconToUse = Image::null);

	/** Adds an item that represents one of the commands in a command manager object.

		@param commandManager       the manager to use to trigger the command and get information
									about it
		@param commandID            the ID of the command
		@param displayName          if this is non-empty, then this string will be used instead of
									the command's registered name
	*/
	void addCommandItem (ApplicationCommandManager* commandManager,
						 int commandID,
						 const String& displayName = String::empty);

	/** Appends a text item with a special colour.

		This is the same as addItem(), but specifies a colour to use for the
		text, which will override the default colours that are used by the
		current look-and-feel. See addItem() for a description of the parameters.
	*/
	void addColouredItem (int itemResultId,
						  const String& itemText,
						  const Colour& itemTextColour,
						  bool isEnabled = true,
						  bool isTicked = false,
						  const Image& iconToUse = Image::null);

	/** Appends a custom menu item that can't be used to trigger a result.

		This will add a user-defined component to use as a menu item. Unlike the
		addCustomItem() method that takes a PopupMenu::CustomComponent, this version
		can't trigger a result from it, so doesn't take a menu ID. It also doesn't
		delete the component when it's finished, so it's the caller's responsibility
		to manage the component that is passed-in.

		if triggerMenuItemAutomaticallyWhenClicked is true, the menu itself will handle
		detection of a mouse-click on your component, and use that to trigger the
		menu ID specified in itemResultId. If this is false, the menu item can't
		be triggered, so itemResultId is not used.

		@see CustomComponent
	*/
	void addCustomItem (int itemResultId,
						Component* customComponent,
						int idealWidth, int idealHeight,
						bool triggerMenuItemAutomaticallyWhenClicked);

	/** Appends a sub-menu.

		If the menu that's passed in is empty, it will appear as an inactive item.
	*/
	void addSubMenu (const String& subMenuName,
					 const PopupMenu& subMenu,
					 bool isEnabled = true,
					 const Image& iconToUse = Image::null,
					 bool isTicked = false);

	/** Appends a separator to the menu, to help break it up into sections.

		The menu class is smart enough not to display separators at the top or bottom
		of the menu, and it will replace mutliple adjacent separators with a single
		one, so your code can be quite free and easy about adding these, and it'll
		always look ok.
	*/
	void addSeparator();

	/** Adds a non-clickable text item to the menu.

		This is a bold-font items which can be used as a header to separate the items
		into named groups.
	*/
	void addSectionHeader (const String& title);

	/** Returns the number of items that the menu currently contains.

		(This doesn't count separators).
	*/
	int getNumItems() const noexcept;

	/** Returns true if the menu contains a command item that triggers the given command. */
	bool containsCommandItem (int commandID) const;

	/** Returns true if the menu contains any items that can be used. */
	bool containsAnyActiveItems() const noexcept;

	/** Class used to create a set of options to pass to the show() method.
		You can chain together a series of calls to this class's methods to create
		a set of whatever options you want to specify.
		E.g. @code
		PopupMenu menu;
		...
		menu.showMenu (PopupMenu::Options().withMaximumWidth (100),
										   .withMaximumNumColumns (3)
										   .withTargetComponent (myComp));
		@endcode
	*/
	class JUCE_API  Options
	{
	public:
		Options();

		Options withTargetComponent (Component* targetComponent) const noexcept;
		Options withTargetScreenArea (const Rectangle<int>& targetArea) const noexcept;
		Options withMinimumWidth (int minWidth) const noexcept;
		Options withMaximumNumColumns (int maxNumColumns) const noexcept;
		Options withStandardItemHeight (int standardHeight) const noexcept;
		Options withItemThatMustBeVisible (int idOfItemToBeVisible) const noexcept;

	private:
		friend class PopupMenu;
		friend class PopupMenu::Window;
		Rectangle<int> targetArea;
		Component* targetComponent;
		int visibleItemID, minWidth, maxColumns, standardHeight;
	};

   #if JUCE_MODAL_LOOPS_PERMITTED
	/** Displays the menu and waits for the user to pick something.

		This will display the menu modally, and return the ID of the item that the
		user picks. If they click somewhere off the menu to get rid of it without
		choosing anything, this will return 0.

		The current location of the mouse will be used as the position to show the
		menu - to explicitly set the menu's position, use showAt() instead. Depending
		on where this point is on the screen, the menu will appear above, below or
		to the side of the point.

		@param itemIdThatMustBeVisible  if you set this to the ID of one of the menu items,
										then when the menu first appears, it will make sure
										that this item is visible. So if the menu has too many
										items to fit on the screen, it will be scrolled to a
										position where this item is visible.
		@param minimumWidth             a minimum width for the menu, in pixels. It may be wider
										than this if some items are too long to fit.
		@param maximumNumColumns        if there are too many items to fit on-screen in a single
										vertical column, the menu may be laid out as a series of
										columns - this is the maximum number allowed. To use the
										default value for this (probably about 7), you can pass
										in zero.
		@param standardItemHeight       if this is non-zero, it will be used as the standard
										height for menu items (apart from custom items)
		@param callback                 if this is non-zero, the menu will be launched asynchronously,
										returning immediately, and the callback will receive a
										call when the menu is either dismissed or has an item
										selected. This object will be owned and deleted by the
										system, so make sure that it works safely and that any
										pointers that it uses are safely within scope.
		@see showAt
	*/
	int show (int itemIdThatMustBeVisible = 0,
			  int minimumWidth = 0,
			  int maximumNumColumns = 0,
			  int standardItemHeight = 0,
			  ModalComponentManager::Callback* callback = nullptr);

	/** Displays the menu at a specific location.

		This is the same as show(), but uses a specific location (in global screen
		co-ordinates) rather than the current mouse position.

		The screenAreaToAttachTo parameter indicates a screen area to which the menu
		will be adjacent. Depending on where this is, the menu will decide which edge to
		attach itself to, in order to fit itself fully on-screen. If you just want to
		trigger a menu at a specific point, you can pass in a rectangle of size (0, 0)
		with the position that you want.

		@see show()
	*/
	int showAt (const Rectangle<int>& screenAreaToAttachTo,
				int itemIdThatMustBeVisible = 0,
				int minimumWidth = 0,
				int maximumNumColumns = 0,
				int standardItemHeight = 0,
				ModalComponentManager::Callback* callback = nullptr);

	/** Displays the menu as if it's attached to a component such as a button.

		This is similar to showAt(), but will position it next to the given component, e.g.
		so that the menu's edge is aligned with that of the component. This is intended for
		things like buttons that trigger a pop-up menu.
	*/
	int showAt (Component* componentToAttachTo,
				int itemIdThatMustBeVisible = 0,
				int minimumWidth = 0,
				int maximumNumColumns = 0,
				int standardItemHeight = 0,
				ModalComponentManager::Callback* callback = nullptr);

	/** Displays and runs the menu modally, with a set of options.
	*/
	int showMenu (const Options& options);
   #endif

	/** Runs the menu asynchronously, with a user-provided callback that will receive the result. */
	void showMenuAsync (const Options& options,
						ModalComponentManager::Callback* callback);

	/** Closes any menus that are currently open.

		This might be useful if you have a situation where your window is being closed
		by some means other than a user action, and you'd like to make sure that menus
		aren't left hanging around.
	*/
	static bool JUCE_CALLTYPE dismissAllActiveMenus();

	/** Specifies a look-and-feel for the menu and any sub-menus that it has.

		This can be called before show() if you need a customised menu. Be careful
		not to delete the LookAndFeel object before the menu has been deleted.
	*/
	void setLookAndFeel (LookAndFeel* newLookAndFeel);

	/** A set of colour IDs to use to change the colour of various aspects of the menu.

		These constants can be used either via the LookAndFeel::setColour()
		method for the look and feel that is set for this menu with setLookAndFeel()

		@see setLookAndFeel, LookAndFeel::setColour, LookAndFeel::findColour
	*/
	enum ColourIds
	{
		backgroundColourId             = 0x1000700,  /**< The colour to fill the menu's background with. */
		textColourId                   = 0x1000600,  /**< The colour for normal menu item text, (unless the
														  colour is specified when the item is added). */
		headerTextColourId             = 0x1000601,  /**< The colour for section header item text (see the
														  addSectionHeader() method). */
		highlightedBackgroundColourId  = 0x1000900,  /**< The colour to fill the background of the currently
														  highlighted menu item. */
		highlightedTextColourId        = 0x1000800,  /**< The colour to use for the text of the currently
														  highlighted item. */
	};

	/**
		Allows you to iterate through the items in a pop-up menu, and examine
		their properties.

		To use this, just create one and repeatedly call its next() method. When this
		returns true, all the member variables of the iterator are filled-out with
		information describing the menu item. When it returns false, the end of the
		list has been reached.
	*/
	class JUCE_API  MenuItemIterator
	{
	public:

		/** Creates an iterator that will scan through the items in the specified
			menu.

			Be careful not to add any items to a menu while it is being iterated,
			or things could get out of step.
		*/
		MenuItemIterator (const PopupMenu& menu);

		/** Destructor. */
		~MenuItemIterator();

		/** Returns true if there is another item, and sets up all this object's
			member variables to reflect that item's properties.
		*/
		bool next();

		String itemName;
		const PopupMenu* subMenu;
		int itemId;
		bool isSeparator;
		bool isTicked;
		bool isEnabled;
		bool isCustomComponent;
		bool isSectionHeader;
		const Colour* customColour;
		Image customImage;
		ApplicationCommandManager* commandManager;

	private:

		const PopupMenu& menu;
		int index;

		JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (MenuItemIterator);
	};

	/** A user-defined copmonent that can be used as an item in a popup menu.
		@see PopupMenu::addCustomItem
	*/
	class JUCE_API  CustomComponent  : public Component,
									   public SingleThreadedReferenceCountedObject
	{
	public:
		/** Creates a custom item.
			If isTriggeredAutomatically is true, then the menu will automatically detect
			a mouse-click on this component and use that to invoke the menu item. If it's
			false, then it's up to your class to manually trigger the item when it wants to.
		*/
		CustomComponent (bool isTriggeredAutomatically = true);

		/** Destructor. */
		~CustomComponent();

		/** Returns a rectangle with the size that this component would like to have.

			Note that the size which this method returns isn't necessarily the one that
			the menu will give it, as the items will be stretched to have a uniform width.
		*/
		virtual void getIdealSize (int& idealWidth, int& idealHeight) = 0;

		/** Dismisses the menu, indicating that this item has been chosen.

			This will cause the menu to exit from its modal state, returning
			this item's id as the result.
		*/
		void triggerMenuItem();

		/** Returns true if this item should be highlighted because the mouse is over it.
			You can call this method in your paint() method to find out whether
			to draw a highlight.
		*/
		bool isItemHighlighted() const noexcept                 { return isHighlighted; }

		/** @internal */
		bool isTriggeredAutomatically() const noexcept          { return triggeredAutomatically; }
		/** @internal */
		void setHighlighted (bool shouldBeHighlighted);

	private:

		bool isHighlighted, triggeredAutomatically;

		JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (CustomComponent);
	};

	/** Appends a custom menu item.

		This will add a user-defined component to use as a menu item. The component
		passed in will be deleted by this menu when it's no longer needed.

		@see CustomComponent
	*/
	void addCustomItem (int itemResultId, CustomComponent* customComponent);

private:

	class Item;
	class ItemComponent;

	friend class MenuItemIterator;
	friend class ItemComponent;
	friend class Window;
	friend class CustomComponent;
	friend class MenuBarComponent;
	friend class OwnedArray <Item>;
	friend class OwnedArray <ItemComponent>;
	friend class ScopedPointer <Window>;

	OwnedArray <Item> items;
	LookAndFeel* lookAndFeel;

	Component* createWindow (const Options&, ApplicationCommandManager**) const;
	int showWithOptionalCallback (const Options&, ModalComponentManager::Callback*, bool);

	JUCE_LEAK_DETECTOR (PopupMenu);
};

#endif   // __JUCE_POPUPMENU_JUCEHEADER__

/*** End of inlined file: juce_PopupMenu.h ***/

/**
	A component containing text that can be edited.

	A TextEditor can either be in single- or multi-line mode, and supports mixed
	fonts and colours.

	@see TextEditor::Listener, Label
*/
class JUCE_API  TextEditor  : public Component,
							  public TextInputTarget,
							  public SettableTooltipClient
{
public:

	/** Creates a new, empty text editor.

		@param componentName        the name to pass to the component for it to use as its name
		@param passwordCharacter    if this is not zero, this character will be used as a replacement
									for all characters that are drawn on screen - e.g. to create
									a password-style textbox containing circular blobs instead of text,
									you could set this value to 0x25cf, which is the unicode character
									for a black splodge (not all fonts include this, though), or 0x2022,
									which is a bullet (probably the best choice for linux).
	*/
	explicit TextEditor (const String& componentName = String::empty,
						 juce_wchar passwordCharacter = 0);

	/** Destructor. */
	virtual ~TextEditor();

	/** Puts the editor into either multi- or single-line mode.

		By default, the editor will be in single-line mode, so use this if you need a multi-line
		editor.

		See also the setReturnKeyStartsNewLine() method, which will also need to be turned
		on if you want a multi-line editor with line-breaks.

		@see isMultiLine, setReturnKeyStartsNewLine
	*/
	void setMultiLine (bool shouldBeMultiLine,
					   bool shouldWordWrap = true);

	/** Returns true if the editor is in multi-line mode.
	*/
	bool isMultiLine() const;

	/** Changes the behaviour of the return key.

		If set to true, the return key will insert a new-line into the text; if false
		it will trigger a call to the TextEditor::Listener::textEditorReturnKeyPressed()
		method. By default this is set to false, and when true it will only insert
		new-lines when in multi-line mode (see setMultiLine()).
	*/
	void setReturnKeyStartsNewLine (bool shouldStartNewLine);

	/** Returns the value set by setReturnKeyStartsNewLine().

		See setReturnKeyStartsNewLine() for more info.
	*/
	bool getReturnKeyStartsNewLine() const                      { return returnKeyStartsNewLine; }

	/** Indicates whether the tab key should be accepted and used to input a tab character,
		or whether it gets ignored.

		By default the tab key is ignored, so that it can be used to switch keyboard focus
		between components.
	*/
	void setTabKeyUsedAsCharacter (bool shouldTabKeyBeUsed);

	/** Returns true if the tab key is being used for input.
		@see setTabKeyUsedAsCharacter
	*/
	bool isTabKeyUsedAsCharacter() const                        { return tabKeyUsed; }

	/** Changes the editor to read-only mode.

		By default, the text editor is not read-only. If you're making it read-only, you
		might also want to call setCaretVisible (false) to get rid of the caret.

		The text can still be highlighted and copied when in read-only mode.

		@see isReadOnly, setCaretVisible
	*/
	void setReadOnly (bool shouldBeReadOnly);

	/** Returns true if the editor is in read-only mode.
	*/
	bool isReadOnly() const;

	/** Makes the caret visible or invisible.
		By default the caret is visible.
		@see setCaretColour, setCaretPosition
	*/
	void setCaretVisible (bool shouldBeVisible);

	/** Returns true if the caret is enabled.
		@see setCaretVisible
	*/
	bool isCaretVisible() const                                 { return caret != nullptr; }

	/** Enables/disables a vertical scrollbar.

		(This only applies when in multi-line mode). When the text gets too long to fit
		in the component, a scrollbar can appear to allow it to be scrolled. Even when
		this is enabled, the scrollbar will be hidden unless it's needed.

		By default the scrollbar is enabled.
	*/
	void setScrollbarsShown (bool shouldBeEnabled);

	/** Returns true if scrollbars are enabled.
		@see setScrollbarsShown
	*/
	bool areScrollbarsShown() const                                 { return scrollbarVisible; }

	/** Changes the password character used to disguise the text.

		@param passwordCharacter    if this is not zero, this character will be used as a replacement
									for all characters that are drawn on screen - e.g. to create
									a password-style textbox containing circular blobs instead of text,
									you could set this value to 0x25cf, which is the unicode character
									for a black splodge (not all fonts include this, though), or 0x2022,
									which is a bullet (probably the best choice for linux).
	*/
	void setPasswordCharacter (juce_wchar passwordCharacter);

	/** Returns the current password character.
		@see setPasswordCharacter
	*/
	juce_wchar getPasswordCharacter() const                         { return passwordCharacter; }

	/** Allows a right-click menu to appear for the editor.

		(This defaults to being enabled).

		If enabled, right-clicking (or command-clicking on the Mac) will pop up a menu
		of options such as cut/copy/paste, undo/redo, etc.
	*/
	void setPopupMenuEnabled (bool menuEnabled);

	/** Returns true if the right-click menu is enabled.
		@see setPopupMenuEnabled
	*/
	bool isPopupMenuEnabled() const                                 { return popupMenuEnabled; }

	/** Returns true if a popup-menu is currently being displayed.
	*/
	bool isPopupMenuCurrentlyActive() const                         { return menuActive; }

	/** A set of colour IDs to use to change the colour of various aspects of the editor.

		These constants can be used either via the Component::setColour(), or LookAndFeel::setColour()
		methods.

		@see Component::setColour, Component::findColour, LookAndFeel::setColour, LookAndFeel::findColour
	*/
	enum ColourIds
	{
		backgroundColourId       = 0x1000200, /**< The colour to use for the text component's background - this can be
												   transparent if necessary. */

		textColourId             = 0x1000201, /**< The colour that will be used when text is added to the editor. Note
												   that because the editor can contain multiple colours, calling this
												   method won't change the colour of existing text - to do that, call
												   applyFontToAllText() after calling this method.*/

		highlightColourId        = 0x1000202, /**< The colour with which to fill the background of highlighted sections of
												   the text - this can be transparent if you don't want to show any
												   highlighting.*/

		highlightedTextColourId  = 0x1000203, /**< The colour with which to draw the text in highlighted sections. */

		outlineColourId          = 0x1000205, /**< If this is non-transparent, it will be used to draw a box around
												   the edge of the component. */

		focusedOutlineColourId   = 0x1000206, /**< If this is non-transparent, it will be used to draw a box around
												   the edge of the component when it has focus. */

		shadowColourId           = 0x1000207, /**< If this is non-transparent, it'll be used to draw an inner shadow
												   around the edge of the editor. */
	};

	/** Sets the font to use for newly added text.

		This will change the font that will be used next time any text is added or entered
		into the editor. It won't change the font of any existing text - to do that, use
		applyFontToAllText() instead.

		@see applyFontToAllText
	*/
	void setFont (const Font& newFont);

	/** Applies a font to all the text in the editor.

		This will also set the current font to use for any new text that's added.

		@see setFont
	*/
	void applyFontToAllText (const Font& newFont);

	/** Returns the font that's currently being used for new text.

		@see setFont
	*/
	const Font& getFont() const;

	/** If set to true, focusing on the editor will highlight all its text.

		(Set to false by default).

		This is useful for boxes where you expect the user to re-enter all the
		text when they focus on the component, rather than editing what's already there.
	*/
	void setSelectAllWhenFocused (bool b);

	/** Sets limits on the characters that can be entered.

		@param maxTextLength        if this is > 0, it sets a maximum length limit; if 0, no
									limit is set
		@param allowedCharacters    if this is non-empty, then only characters that occur in
									this string are allowed to be entered into the editor.
	*/
	void setInputRestrictions (int maxTextLength,
							   const String& allowedCharacters = String::empty);

	/** When the text editor is empty, it can be set to display a message.

		This is handy for things like telling the user what to type in the box - the
		string is only displayed, it's not taken to actually be the contents of
		the editor.
	*/
	void setTextToShowWhenEmpty (const String& text, const Colour& colourToUse);

	/** Changes the size of the scrollbars that are used.

		Handy if you need smaller scrollbars for a small text box.
	*/
	void setScrollBarThickness (int newThicknessPixels);

	/** Shows or hides the buttons on any scrollbars that are used.

		@see ScrollBar::setButtonVisibility
	*/
	void setScrollBarButtonVisibility (bool buttonsVisible);

	/**
		Receives callbacks from a TextEditor component when it changes.

		@see TextEditor::addListener
	*/
	class JUCE_API  Listener
	{
	public:
		/** Destructor. */
		virtual ~Listener()  {}

		/** Called when the user changes the text in some way. */
		virtual void textEditorTextChanged (TextEditor& editor);

		/** Called when the user presses the return key. */
		virtual void textEditorReturnKeyPressed (TextEditor& editor);

		/** Called when the user presses the escape key. */
		virtual void textEditorEscapeKeyPressed (TextEditor& editor);

		/** Called when the text editor loses focus. */
		virtual void textEditorFocusLost (TextEditor& editor);
	};

	/** Registers a listener to be told when things happen to the text.

		@see removeListener
	*/
	void addListener (Listener* newListener);

	/** Deregisters a listener.

		@see addListener
	*/
	void removeListener (Listener* listenerToRemove);

	/** Returns the entire contents of the editor. */
	String getText() const;

	/** Returns a section of the contents of the editor. */
	String getTextInRange (const Range<int>& textRange) const;

	/** Returns true if there are no characters in the editor.

		This is more efficient than calling getText().isEmpty().
	*/
	bool isEmpty() const;

	/** Sets the entire content of the editor.

		This will clear the editor and insert the given text (using the current text colour
		and font). You can set the current text colour using
		@code setColour (TextEditor::textColourId, ...);
		@endcode

		@param newText                  the text to add
		@param sendTextChangeMessage    if true, this will cause a change message to
										be sent to all the listeners.
		@see insertText
	*/
	void setText (const String& newText,
				  bool sendTextChangeMessage = true);

	/** Returns a Value object that can be used to get or set the text.

		Bear in mind that this operate quite slowly if your text box contains large
		amounts of text, as it needs to dynamically build the string that's involved. It's
		best used for small text boxes.
	*/
	Value& getTextValue();

	/** Inserts some text at the current caret position.

		If a section of the text is highlighted, it will be replaced by
		this string, otherwise it will be inserted.

		To delete a section of text, you can use setHighlightedRegion() to
		highlight it, and call insertTextAtCursor (String::empty).

		@see setCaretPosition, getCaretPosition, setHighlightedRegion
	*/
	void insertTextAtCaret (const String& textToInsert);

	/** Deletes all the text from the editor. */
	void clear();

	/** Deletes the currently selected region.
		This doesn't copy the deleted section to the clipboard - if you need to do that, call copy() first.
		@see copy, paste, SystemClipboard
	*/
	void cut();

	/** Copies the currently selected region to the clipboard.
		@see cut, paste, SystemClipboard
	*/
	void copy();

	/** Pastes the contents of the clipboard into the editor at the caret position.
		@see cut, copy, SystemClipboard
	*/
	void paste();

	/** Returns the current index of the caret.
		@see setCaretPosition
	*/
	int getCaretPosition() const;

	/** Moves the caret to be in front of a given character.
		@see getCaretPosition, moveCaretToEnd
	*/
	void setCaretPosition (int newIndex);

	/** Moves the caret to be the end of all the text.
		@see setCaretPosition
	*/
	void moveCaretToEnd();

	/** Attempts to scroll the text editor so that the caret ends up at
		a specified position.

		This won't affect the caret's position within the text, it tries to scroll
		the entire editor vertically and horizontally so that the caret is sitting
		at the given position (relative to the top-left of this component).

		Depending on the amount of text available, it might not be possible to
		scroll far enough for the caret to reach this exact position, but it
		will go as far as it can in that direction.
	*/
	void scrollEditorToPositionCaret (int desiredCaretX, int desiredCaretY);

	/** Get the graphical position of the caret.

		The rectangle returned is relative to the component's top-left corner.
		@see scrollEditorToPositionCaret
	*/
	Rectangle<int> getCaretRectangle();

	/** Selects a section of the text. */
	void setHighlightedRegion (const Range<int>& newSelection);

	/** Returns the range of characters that are selected.
		If nothing is selected, this will return an empty range.
		@see setHighlightedRegion
	*/
	Range<int> getHighlightedRegion() const                   { return selection; }

	/** Returns the section of text that is currently selected. */
	String getHighlightedText() const;

	/** Finds the index of the character at a given position.

		The co-ordinates are relative to the component's top-left.
	*/
	int getTextIndexAt (int x, int y);

	/** Counts the number of characters in the text.

		This is quicker than getting the text as a string if you just need to know
		the length.
	*/
	int getTotalNumChars() const;

	/** Returns the total width of the text, as it is currently laid-out.

		This may be larger than the size of the TextEditor, and can change when
		the TextEditor is resized or the text changes.
	*/
	int getTextWidth() const;

	/** Returns the maximum height of the text, as it is currently laid-out.

		This may be larger than the size of the TextEditor, and can change when
		the TextEditor is resized or the text changes.
	*/
	int getTextHeight() const;

	/** Changes the size of the gap at the top and left-edge of the editor.

		By default there's a gap of 4 pixels.
	*/
	void setIndents (int newLeftIndent, int newTopIndent);

	/** Changes the size of border left around the edge of the component.

		@see getBorder
	*/
	void setBorder (const BorderSize<int>& border);

	/** Returns the size of border around the edge of the component.

		@see setBorder
	*/
	BorderSize<int> getBorder() const;

	/** Used to disable the auto-scrolling which keeps the caret visible.

		If true (the default), the editor will scroll when the caret moves offscreen. If
		set to false, it won't.
	*/
	void setScrollToShowCursor (bool shouldScrollToShowCaret);

	/** @internal */
	void paint (Graphics& g);
	/** @internal */
	void paintOverChildren (Graphics& g);
	/** @internal */
	void mouseDown (const MouseEvent& e);
	/** @internal */
	void mouseUp (const MouseEvent& e);
	/** @internal */
	void mouseDrag (const MouseEvent& e);
	/** @internal */
	void mouseDoubleClick (const MouseEvent& e);
	/** @internal */
	void mouseWheelMove (const MouseEvent& e, float wheelIncrementX, float wheelIncrementY);
	/** @internal */
	bool keyPressed (const KeyPress& key);
	/** @internal */
	bool keyStateChanged (bool isKeyDown);
	/** @internal */
	void focusGained (FocusChangeType cause);
	/** @internal */
	void focusLost (FocusChangeType cause);
	/** @internal */
	void resized();
	/** @internal */
	void enablementChanged();
	/** @internal */
	void colourChanged();
	/** @internal */
	void lookAndFeelChanged();
	/** @internal */
	bool isTextInputActive() const;
	/** @internal */
	void setTemporaryUnderlining (const Array <Range<int> >&);

	bool moveCaretLeft (bool moveInWholeWordSteps, bool selecting);
	bool moveCaretRight (bool moveInWholeWordSteps, bool selecting);
	bool moveCaretUp (bool selecting);
	bool moveCaretDown (bool selecting);
	bool pageUp (bool selecting);
	bool pageDown (bool selecting);
	bool scrollDown();
	bool scrollUp();
	bool moveCaretToTop (bool selecting);
	bool moveCaretToStartOfLine (bool selecting);
	bool moveCaretToEnd (bool selecting);
	bool moveCaretToEndOfLine (bool selecting);
	bool deleteBackwards (bool moveInWholeWordSteps);
	bool deleteForwards (bool moveInWholeWordSteps);
	bool copyToClipboard();
	bool cutToClipboard();
	bool pasteFromClipboard();
	bool selectAll();
	bool undo();
	bool redo();

	/** This adds the items to the popup menu.

		By default it adds the cut/copy/paste items, but you can override this if
		you need to replace these with your own items.

		If you want to add your own items to the existing ones, you can override this,
		call the base class's addPopupMenuItems() method, then append your own items.

		When the menu has been shown, performPopupMenuAction() will be called to
		perform the item that the user has chosen.

		The default menu items will be added using item IDs in the range
		0x7fff0000 - 0x7fff1000, so you should avoid those values for your own
		menu IDs.

		If this was triggered by a mouse-click, the mouseClickEvent parameter will be
		a pointer to the info about it, or may be null if the menu is being triggered
		by some other means.

		@see performPopupMenuAction, setPopupMenuEnabled, isPopupMenuEnabled
	*/
	virtual void addPopupMenuItems (PopupMenu& menuToAddTo,
									const MouseEvent* mouseClickEvent);

	/** This is called to perform one of the items that was shown on the popup menu.

		If you've overridden addPopupMenuItems(), you should also override this
		to perform the actions that you've added.

		If you've overridden addPopupMenuItems() but have still left the default items
		on the menu, remember to call the superclass's performPopupMenuAction()
		so that it can perform the default actions if that's what the user clicked on.

		@see addPopupMenuItems, setPopupMenuEnabled, isPopupMenuEnabled
	*/
	virtual void performPopupMenuAction (int menuItemID);

	struct Ids
	{
		static const Identifier tagType, text, font, mode, readOnly, scrollbarsShown,
								caretVisible, popupMenuEnabled;
	};

	void refreshFromValueTree (const ValueTree&, ComponentBuilder&);

protected:

	/** Scrolls the minimum distance needed to get the caret into view. */
	void scrollToMakeSureCursorIsVisible();

	/** @internal */
	void moveCaret (int newCaretPos);

	/** @internal */
	void moveCaretTo (int newPosition, bool isSelecting);

	/** Used internally to dispatch a text-change message. */
	void textChanged();

	/** Begins a new transaction in the UndoManager. */
	void newTransaction();

	/** Used internally to trigger an undo or redo. */
	void doUndoRedo (bool isRedo);

	/** Can be overridden to intercept return key presses directly */
	virtual void returnPressed();

	/** Can be overridden to intercept escape key presses directly */
	virtual void escapePressed();

	/** @internal */
	void handleCommandMessage (int commandId);

private:

	class Iterator;
	class UniformTextSection;
	class TextHolderComponent;
	class InsertAction;
	class RemoveAction;
	friend class InsertAction;
	friend class RemoveAction;

	ScopedPointer <Viewport> viewport;
	TextHolderComponent* textHolder;
	BorderSize<int> borderSize;

	bool readOnly                   : 1;
	bool multiline                  : 1;
	bool wordWrap                   : 1;
	bool returnKeyStartsNewLine     : 1;
	bool popupMenuEnabled           : 1;
	bool selectAllTextWhenFocused   : 1;
	bool scrollbarVisible           : 1;
	bool wasFocused                 : 1;
	bool keepCaretOnScreen          : 1;
	bool tabKeyUsed                 : 1;
	bool menuActive                 : 1;
	bool valueTextNeedsUpdating     : 1;

	UndoManager undoManager;
	ScopedPointer<CaretComponent> caret;
	int maxTextLength;
	Range<int> selection;
	int leftIndent, topIndent;
	unsigned int lastTransactionTime;
	Font currentFont;
	mutable int totalNumChars;
	int caretPosition;
	Array <UniformTextSection*> sections;
	String textToShowWhenEmpty;
	Colour colourForTextWhenEmpty;
	juce_wchar passwordCharacter;
	Value textValue;

	enum
	{
		notDragging,
		draggingSelectionStart,
		draggingSelectionEnd
	} dragType;

	String allowedCharacters;
	ListenerList <Listener> listeners;
	Array <Range<int> > underlinedSections;

	void coalesceSimilarSections();
	void splitSection (int sectionIndex, int charToSplitAt);
	void clearInternal (UndoManager* um);
	void insert (const String& text, int insertIndex, const Font& font,
				 const Colour& colour, UndoManager* um, int caretPositionToMoveTo);
	void reinsert (int insertIndex, const Array <UniformTextSection*>& sections);
	void remove (const Range<int>& range, UndoManager* um, int caretPositionToMoveTo);
	void getCharPosition (int index, float& x, float& y, float& lineHeight) const;
	void updateCaretPosition();
	void updateValueFromText();
	void textWasChangedByValue();
	int indexAtPosition (float x, float y);
	int findWordBreakAfter (int position) const;
	int findWordBreakBefore (int position) const;
	bool moveCaretWithTransation (int newPos, bool selecting);
	friend class TextHolderComponent;
	friend class TextEditorViewport;
	void drawContent (Graphics& g);
	void updateTextHolderSize();
	float getWordWrapWidth() const;
	void timerCallbackInt();
	void repaintText (const Range<int>& range);
	void scrollByLines (int deltaLines);
	bool undoOrRedo (bool shouldUndo);
	UndoManager* getUndoManager() noexcept;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (TextEditor);
};

/** This typedef is just for compatibility with old code - newer code should use the TextEditor::Listener class directly. */
typedef TextEditor::Listener TextEditorListener;

#endif   // __JUCE_TEXTEDITOR_JUCEHEADER__

/*** End of inlined file: juce_TextEditor.h ***/


/*** Start of inlined file: juce_ComboBox.h ***/
#ifndef __JUCE_COMBOBOX_JUCEHEADER__
#define __JUCE_COMBOBOX_JUCEHEADER__


/*** Start of inlined file: juce_Label.h ***/
#ifndef __JUCE_LABEL_JUCEHEADER__
#define __JUCE_LABEL_JUCEHEADER__

/**
	A component that displays a text string, and can optionally become a text
	editor when clicked.
*/
class JUCE_API  Label  : public Component,
						 public SettableTooltipClient,
						 protected TextEditorListener,
						 private ComponentListener,
						 private ValueListener
{
public:

	/** Creates a Label.

		@param componentName    the name to give the component
		@param labelText        the text to show in the label
	*/
	Label (const String& componentName = String::empty,
		   const String& labelText = String::empty);

	/** Destructor. */
	~Label();

	/** Changes the label text.

		If broadcastChangeMessage is true and the new text is different to the current
		text, then the class will broadcast a change message to any Label::Listener objects
		that are registered.
	*/
	void setText (const String& newText, bool broadcastChangeMessage);

	/** Returns the label's current text.

		@param returnActiveEditorContents   if this is true and the label is currently
											being edited, then this method will return the
											text as it's being shown in the editor. If false,
											then the value returned here won't be updated until
											the user has finished typing and pressed the return
											key.
	*/
	String getText (bool returnActiveEditorContents = false) const;

	/** Returns the text content as a Value object.
		You can call Value::referTo() on this object to make the label read and control
		a Value object that you supply.
	*/
	Value& getTextValue()                               { return textValue; }

	/** Changes the font to use to draw the text.

		@see getFont
	*/
	void setFont (const Font& newFont);

	/** Returns the font currently being used.

		@see setFont
	*/
	const Font& getFont() const noexcept;

	/** A set of colour IDs to use to change the colour of various aspects of the label.

		These constants can be used either via the Component::setColour(), or LookAndFeel::setColour()
		methods.

		Note that you can also use the constants from TextEditor::ColourIds to change the
		colour of the text editor that is opened when a label is editable.

		@see Component::setColour, Component::findColour, LookAndFeel::setColour, LookAndFeel::findColour
	*/
	enum ColourIds
	{
		backgroundColourId     = 0x1000280, /**< The background colour to fill the label with. */
		textColourId           = 0x1000281, /**< The colour for the text. */
		outlineColourId        = 0x1000282  /**< An optional colour to use to draw a border around the label.
												 Leave this transparent to not have an outline. */
	};

	/** Sets the style of justification to be used for positioning the text.

		(The default is Justification::centredLeft)
	*/
	void setJustificationType (const Justification& justification);

	/** Returns the type of justification, as set in setJustificationType(). */
	Justification getJustificationType() const noexcept                         { return justification; }

	/** Changes the gap that is left between the edge of the component and the text.
		By default there's a small gap left at the sides of the component to allow for
		the drawing of the border, but you can change this if necessary.
	*/
	void setBorderSize (int horizontalBorder, int verticalBorder);

	/** Returns the size of the horizontal gap being left around the text.
	*/
	int getHorizontalBorderSize() const noexcept                                { return horizontalBorderSize; }

	/** Returns the size of the vertical gap being left around the text.
	*/
	int getVerticalBorderSize() const noexcept                                  { return verticalBorderSize; }

	/** Makes this label "stick to" another component.

		This will cause the label to follow another component around, staying
		either to its left or above it.

		@param owner    the component to follow
		@param onLeft   if true, the label will stay on the left of its component; if
						false, it will stay above it.
	*/
	void attachToComponent (Component* owner, bool onLeft);

	/** If this label has been attached to another component using attachToComponent, this
		returns the other component.

		Returns 0 if the label is not attached.
	*/
	Component* getAttachedComponent() const;

	/** If the label is attached to the left of another component, this returns true.

		Returns false if the label is above the other component. This is only relevent if
		attachToComponent() has been called.
	*/
	bool isAttachedOnLeft() const noexcept                                      { return leftOfOwnerComp; }

	/** Specifies the minimum amount that the font can be squashed horizantally before it starts
		using ellipsis.

		@see Graphics::drawFittedText
	*/
	void setMinimumHorizontalScale (float newScale);

	float getMinimumHorizontalScale() const noexcept                            { return minimumHorizontalScale; }

	/**
		A class for receiving events from a Label.

		You can register a Label::Listener with a Label using the Label::addListener()
		method, and it will be called when the text of the label changes, either because
		of a call to Label::setText() or by the user editing the text (if the label is
		editable).

		@see Label::addListener, Label::removeListener
	*/
	class JUCE_API  Listener
	{
	public:
		/** Destructor. */
		virtual ~Listener() {}

		/** Called when a Label's text has changed.
		*/
		virtual void labelTextChanged (Label* labelThatHasChanged) = 0;
	};

	/** Registers a listener that will be called when the label's text changes. */
	void addListener (Listener* listener);

	/** Deregisters a previously-registered listener. */
	void removeListener (Listener* listener);

	/** Makes the label turn into a TextEditor when clicked.

		By default this is turned off.

		If turned on, then single- or double-clicking will turn the label into
		an editor. If the user then changes the text, then the ChangeBroadcaster
		base class will be used to send change messages to any listeners that
		have registered.

		If the user changes the text, the textWasEdited() method will be called
		afterwards, and subclasses can override this if they need to do anything
		special.

		@param editOnSingleClick            if true, just clicking once on the label will start editing the text
		@param editOnDoubleClick            if true, a double-click is needed to start editing
		@param lossOfFocusDiscardsChanges   if true, clicking somewhere else while the text is being
											edited will discard any changes; if false, then this will
											commit the changes.
		@see showEditor, setEditorColours, TextEditor
	*/
	void setEditable (bool editOnSingleClick,
					  bool editOnDoubleClick = false,
					  bool lossOfFocusDiscardsChanges = false);

	/** Returns true if this option was set using setEditable(). */
	bool isEditableOnSingleClick() const noexcept                       { return editSingleClick; }

	/** Returns true if this option was set using setEditable(). */
	bool isEditableOnDoubleClick() const noexcept                       { return editDoubleClick; }

	/** Returns true if this option has been set in a call to setEditable(). */
	bool doesLossOfFocusDiscardChanges() const noexcept                 { return lossOfFocusDiscardsChanges; }

	/** Returns true if the user can edit this label's text. */
	bool isEditable() const noexcept                                    { return editSingleClick || editDoubleClick; }

	/** Makes the editor appear as if the label had been clicked by the user.

		@see textWasEdited, setEditable
	*/
	void showEditor();

	/** Hides the editor if it was being shown.

		@param discardCurrentEditorContents     if true, the label's text will be
												reset to whatever it was before the editor
												was shown; if false, the current contents of the
												editor will be used to set the label's text
												before it is hidden.
	*/
	void hideEditor (bool discardCurrentEditorContents);

	/** Returns true if the editor is currently focused and active. */
	bool isBeingEdited() const noexcept;

	struct Ids
	{
		static const Identifier tagType, text, font, editMode, justification, focusLossDiscardsChanges;
	};

	void refreshFromValueTree (const ValueTree&, ComponentBuilder&);

protected:

	/** Creates the TextEditor component that will be used when the user has clicked on the label.
		Subclasses can override this if they need to customise this component in some way.
	*/
	virtual TextEditor* createEditorComponent();

	/** Called after the user changes the text. */
	virtual void textWasEdited();

	/** Called when the text has been altered. */
	virtual void textWasChanged();

	/** Called when the text editor has just appeared, due to a user click or other focus change. */
	virtual void editorShown (TextEditor* editorComponent);

	/** Called when the text editor is going to be deleted, after editing has finished. */
	virtual void editorAboutToBeHidden (TextEditor* editorComponent);

	/** @internal */
	void paint (Graphics& g);
	/** @internal */
	void resized();
	/** @internal */
	void mouseUp (const MouseEvent& e);
	/** @internal */
	void mouseDoubleClick (const MouseEvent& e);
	/** @internal */
	void componentMovedOrResized (Component& component, bool wasMoved, bool wasResized);
	/** @internal */
	void componentParentHierarchyChanged (Component& component);
	/** @internal */
	void componentVisibilityChanged (Component& component);
	/** @internal */
	void inputAttemptWhenModal();
	/** @internal */
	void focusGained (FocusChangeType);
	/** @internal */
	void enablementChanged();
	/** @internal */
	KeyboardFocusTraverser* createFocusTraverser();
	/** @internal */
	void textEditorTextChanged (TextEditor& editor);
	/** @internal */
	void textEditorReturnKeyPressed (TextEditor& editor);
	/** @internal */
	void textEditorEscapeKeyPressed (TextEditor& editor);
	/** @internal */
	void textEditorFocusLost (TextEditor& editor);
	/** @internal */
	void colourChanged();
	/** @internal */
	void valueChanged (Value&);

private:

	Value textValue;
	String lastTextValue;
	Font font;
	Justification justification;
	ScopedPointer<TextEditor> editor;
	ListenerList<Listener> listeners;
	WeakReference<Component> ownerComponent;
	int horizontalBorderSize, verticalBorderSize;
	float minimumHorizontalScale;
	bool editSingleClick : 1;
	bool editDoubleClick : 1;
	bool lossOfFocusDiscardsChanges : 1;
	bool leftOfOwnerComp : 1;

	bool updateFromTextEditorContents (TextEditor&);
	void callChangeListeners();

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (Label);
};

/** This typedef is just for compatibility with old code - newer code should use the Label::Listener class directly. */
typedef Label::Listener LabelListener;

#endif   // __JUCE_LABEL_JUCEHEADER__

/*** End of inlined file: juce_Label.h ***/

/**
	A component that lets the user choose from a drop-down list of choices.

	The combo-box has a list of text strings, each with an associated id number,
	that will be shown in the drop-down list when the user clicks on the component.

	The currently selected choice is displayed in the combo-box, and this can
	either be read-only text, or editable.

	To find out when the user selects a different item or edits the text, you
	can register a ComboBox::Listener to receive callbacks.

	@see ComboBox::Listener
*/
class JUCE_API  ComboBox  : public Component,
							public SettableTooltipClient,
							public LabelListener,  // (can't use Label::Listener due to idiotic VC2005 bug)
							public ValueListener,
							private AsyncUpdater
{
public:

	/** Creates a combo-box.

		On construction, the text field will be empty, so you should call the
		setSelectedId() or setText() method to choose the initial value before
		displaying it.

		@param componentName    the name to set for the component (see Component::setName())
	*/
	explicit ComboBox (const String& componentName = String::empty);

	/** Destructor. */
	~ComboBox();

	/** Sets whether the test in the combo-box is editable.

		The default state for a new ComboBox is non-editable, and can only be changed
		by choosing from the drop-down list.
	*/
	void setEditableText (bool isEditable);

	/** Returns true if the text is directly editable.
		@see setEditableText
	*/
	bool isTextEditable() const noexcept;

	/** Sets the style of justification to be used for positioning the text.

		The default is Justification::centredLeft. The text is displayed using a
		Label component inside the ComboBox.
	*/
	void setJustificationType (const Justification& justification);

	/** Returns the current justification for the text box.
		@see setJustificationType
	*/
	Justification getJustificationType() const noexcept;

	/** Adds an item to be shown in the drop-down list.

		@param newItemText      the text of the item to show in the list
		@param newItemId        an associated ID number that can be set or retrieved - see
								getSelectedId() and setSelectedId(). Note that this value can not
								be 0!
		@see setItemEnabled, addSeparator, addSectionHeading, removeItem, getNumItems, getItemText, getItemId
	*/
	void addItem (const String& newItemText, int newItemId);

	/** Adds an array of items to the drop-down list.
		The item ID of each item will be its index in the StringArray + firstItemIdOffset.
	*/
	void addItemList (const StringArray& items, int firstItemIdOffset);

	/** Adds a separator line to the drop-down list.

		This is like adding a separator to a popup menu. See PopupMenu::addSeparator().
	*/
	void addSeparator();

	/** Adds a heading to the drop-down list, so that you can group the items into
		different sections.

		The headings are indented slightly differently to set them apart from the
		items on the list, and obviously can't be selected. You might want to add
		separators between your sections too.

		@see addItem, addSeparator
	*/
	void addSectionHeading (const String& headingName);

	/** This allows items in the drop-down list to be selectively disabled.

		When you add an item, it's enabled by default, but you can call this
		method to change its status.

		If you disable an item which is already selected, this won't change the
		current selection - it just stops the user choosing that item from the list.
	*/
	void setItemEnabled (int itemId, bool shouldBeEnabled);

	/** Returns true if the given item is enabled. */
	bool isItemEnabled (int itemId) const noexcept;

	/** Changes the text for an existing item.
	*/
	void changeItemText (int itemId, const String& newText);

	/** Removes all the items from the drop-down list.

		If this call causes the content to be cleared, then a change-message
		will be broadcast unless dontSendChangeMessage is true.

		@see addItem, removeItem, getNumItems
	*/
	void clear (bool dontSendChangeMessage = false);

	/** Returns the number of items that have been added to the list.

		Note that this doesn't include headers or separators.
	*/
	int getNumItems() const noexcept;

	/** Returns the text for one of the items in the list.
		Note that this doesn't include headers or separators.
		@param index    the item's index from 0 to (getNumItems() - 1)
	*/
	String getItemText (int index) const;

	/** Returns the ID for one of the items in the list.

		Note that this doesn't include headers or separators.

		@param index    the item's index from 0 to (getNumItems() - 1)
	*/
	int getItemId (int index) const noexcept;

	/** Returns the index in the list of a particular item ID.
		If no such ID is found, this will return -1.
	*/
	int indexOfItemId (int itemId) const noexcept;

	/** Returns the ID of the item that's currently shown in the box.

		If no item is selected, or if the text is editable and the user
		has entered something which isn't one of the items in the list, then
		this will return 0.

		@see setSelectedId, getSelectedItemIndex, getText
	*/
	int getSelectedId() const noexcept;

	/** Returns a Value object that can be used to get or set the selected item's ID.

		You can call Value::referTo() on this object to make the combo box control
		another Value object.
	*/
	Value& getSelectedIdAsValue()                       { return currentId; }

	/** Sets one of the items to be the current selection.

		This will set the ComboBox's text to that of the item that matches
		this ID.

		@param newItemId                the new item to select
		@param dontSendChangeMessage    if set to true, this method won't trigger a
										change notification
		@see getSelectedId, setSelectedItemIndex, setText
	*/
	void setSelectedId (int newItemId, bool dontSendChangeMessage = false);

	/** Returns the index of the item that's currently shown in the box.

		If no item is selected, or if the text is editable and the user
		has entered something which isn't one of the items in the list, then
		this will return -1.

		@see setSelectedItemIndex, getSelectedId, getText
	*/
	int getSelectedItemIndex() const;

	/** Sets one of the items to be the current selection.

		This will set the ComboBox's text to that of the item at the given
		index in the list.

		@param newItemIndex             the new item to select
		@param dontSendChangeMessage    if set to true, this method won't trigger a
										change notification
		@see getSelectedItemIndex, setSelectedId, setText
	*/
	void setSelectedItemIndex (int newItemIndex, bool dontSendChangeMessage = false);

	/** Returns the text that is currently shown in the combo-box's text field.

		If the ComboBox has editable text, then this text may have been edited
		by the user; otherwise it will be one of the items from the list, or
		possibly an empty string if nothing was selected.

		@see setText, getSelectedId, getSelectedItemIndex
	*/
	String getText() const;

	/** Sets the contents of the combo-box's text field.

		The text passed-in will be set as the current text regardless of whether
		it is one of the items in the list. If the current text isn't one of the
		items, then getSelectedId() will return -1, otherwise it wil return
		the approriate ID.

		@param newText                  the text to select
		@param dontSendChangeMessage    if set to true, this method won't trigger a
										change notification
		@see getText
	*/
	void setText (const String& newText, bool dontSendChangeMessage = false);

	/** Programmatically opens the text editor to allow the user to edit the current item.

		This is the same effect as when the box is clicked-on.
		@see Label::showEditor();
	*/
	void showEditor();

	/** Pops up the combo box's list. */
	void showPopup();

	/**
		A class for receiving events from a ComboBox.

		You can register a ComboBox::Listener with a ComboBox using the ComboBox::addListener()
		method, and it will be called when the selected item in the box changes.

		@see ComboBox::addListener, ComboBox::removeListener
	*/
	class JUCE_API  Listener
	{
	public:
		/** Destructor. */
		virtual ~Listener() {}

		/** Called when a ComboBox has its selected item changed. */
		virtual void comboBoxChanged (ComboBox* comboBoxThatHasChanged) = 0;
	};

	/** Registers a listener that will be called when the box's content changes. */
	void addListener (Listener* listener);

	/** Deregisters a previously-registered listener. */
	void removeListener (Listener* listener);

	/** Sets a message to display when there is no item currently selected.

		@see getTextWhenNothingSelected
	*/
	void setTextWhenNothingSelected (const String& newMessage);

	/** Returns the text that is shown when no item is selected.

		@see setTextWhenNothingSelected
	*/
	String getTextWhenNothingSelected() const;

	/** Sets the message to show when there are no items in the list, and the user clicks
		on the drop-down box.

		By default it just says "no choices", but this lets you change it to something more
		meaningful.
	*/
	void setTextWhenNoChoicesAvailable (const String& newMessage);

	/** Returns the text shown when no items have been added to the list.
		@see setTextWhenNoChoicesAvailable
	*/
	String getTextWhenNoChoicesAvailable() const;

	/** Gives the ComboBox a tooltip. */
	void setTooltip (const String& newTooltip);

	/** A set of colour IDs to use to change the colour of various aspects of the combo box.

		These constants can be used either via the Component::setColour(), or LookAndFeel::setColour()
		methods.

		To change the colours of the menu that pops up

		@see Component::setColour, Component::findColour, LookAndFeel::setColour, LookAndFeel::findColour
	*/
	enum ColourIds
	{
		backgroundColourId  = 0x1000b00,    /**< The background colour to fill the box with. */
		textColourId        = 0x1000a00,    /**< The colour for the text in the box. */
		outlineColourId     = 0x1000c00,    /**< The colour for an outline around the box. */
		buttonColourId      = 0x1000d00,    /**< The base colour for the button (a LookAndFeel class will probably use variations on this). */
		arrowColourId       = 0x1000e00,    /**< The colour for the arrow shape that pops up the menu */
	};

	struct Ids
	{
		static const Identifier tagType, items, editable, textJustification, unselectedText, noItemsText;
	};

	void refreshFromValueTree (const ValueTree&, ComponentBuilder&);

	/** @internal */
	void labelTextChanged (Label*);
	/** @internal */
	void enablementChanged();
	/** @internal */
	void colourChanged();
	/** @internal */
	void focusGained (Component::FocusChangeType cause);
	/** @internal */
	void focusLost (Component::FocusChangeType cause);
	/** @internal */
	void handleAsyncUpdate();
	/** @internal */
	String getTooltip()                                       { return label->getTooltip(); }
	/** @internal */
	void mouseDown (const MouseEvent&);
	/** @internal */
	void mouseDrag (const MouseEvent&);
	/** @internal */
	void mouseUp (const MouseEvent&);
	/** @internal */
	void lookAndFeelChanged();
	/** @internal */
	void paint (Graphics&);
	/** @internal */
	void resized();
	/** @internal */
	bool keyStateChanged (bool isKeyDown);
	/** @internal */
	bool keyPressed (const KeyPress&);
	/** @internal */
	void valueChanged (Value&);

private:

	struct ItemInfo
	{
		ItemInfo (const String& name, int itemId, bool isEnabled, bool isHeading);
		bool isSeparator() const noexcept;
		bool isRealItem() const noexcept;

		String name;
		int itemId;
		bool isEnabled : 1, isHeading : 1;
	};

	OwnedArray <ItemInfo> items;
	Value currentId;
	int lastCurrentId;
	bool isButtonDown, separatorPending, menuActive, textIsCustom;
	ListenerList <Listener> listeners;
	ScopedPointer<Label> label;
	String textWhenNothingSelected, noChoicesMessage;

	ItemInfo* getItemForId (int itemId) const noexcept;
	ItemInfo* getItemForIndex (int index) const noexcept;
	bool selectIfEnabled (int index);
	static void popupMenuFinishedCallback (int, ComboBox*);

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ComboBox);
};

/** This typedef is just for compatibility with old code - newer code should use the ComboBox::Listener class directly. */
typedef ComboBox::Listener ComboBoxListener;

#endif   // __JUCE_COMBOBOX_JUCEHEADER__

/*** End of inlined file: juce_ComboBox.h ***/

/**
	A component for browsing and selecting a file or directory to open or save.

	This contains a FileListComponent and adds various boxes and controls for
	navigating and selecting a file. It can work in different modes so that it can
	be used for loading or saving a file, or for choosing a directory.

	@see FileChooserDialogBox, FileChooser, FileListComponent
*/
class JUCE_API  FileBrowserComponent  : public Component,
										private FileBrowserListener,
										private TextEditorListener,
										private ButtonListener,
										private ComboBoxListener,  // (can't use ComboBox::Listener due to idiotic VC2005 bug)
										private FileFilter
{
public:

	/** Various options for the browser.

		A combination of these is passed into the FileBrowserComponent constructor.
	*/
	enum FileChooserFlags
	{
		openMode                = 1,    /**< specifies that the component should allow the user to
											 choose an existing file with the intention of opening it. */
		saveMode                = 2,    /**< specifies that the component should allow the user to specify
											 the name of a file that will be used to save something. */
		canSelectFiles          = 4,    /**< specifies that the user can select files (can be used in
											 conjunction with canSelectDirectories). */
		canSelectDirectories    = 8,    /**< specifies that the user can select directories (can be used in
											 conjuction with canSelectFiles). */
		canSelectMultipleItems  = 16,   /**< specifies that the user can select multiple items. */
		useTreeView             = 32,   /**< specifies that a tree-view should be shown instead of a file list. */
		filenameBoxIsReadOnly   = 64    /**< specifies that the user can't type directly into the filename box. */
	};

	/** Creates a FileBrowserComponent.

		@param flags                    A combination of flags from the FileChooserFlags enumeration, used to
										specify the component's behaviour. The flags must contain either openMode
										or saveMode, and canSelectFiles and/or canSelectDirectories.
		@param initialFileOrDirectory   The file or directory that should be selected when the component begins.
										If this is File::nonexistent, a default directory will be chosen.
		@param fileFilter               an optional filter to use to determine which files are shown.
										If this is nullptr then all files are displayed. Note that a pointer
										is kept internally to this object, so make sure that it is not deleted
										before the FileBrowserComponent object is deleted.
		@param previewComp              an optional preview component that will be used to show previews of
										files that the user selects
	*/
	FileBrowserComponent (int flags,
						  const File& initialFileOrDirectory,
						  const FileFilter* fileFilter,
						  FilePreviewComponent* previewComp);

	/** Destructor. */
	~FileBrowserComponent();

	/** Returns the number of files that the user has got selected.
		If multiple select isn't active, this will only be 0 or 1. To get the complete
		list of files they've chosen, pass an index to getCurrentFile().
	*/
	int getNumSelectedFiles() const noexcept;

	/** Returns one of the files that the user has chosen.
		If the box has multi-select enabled, the index lets you specify which of the files
		to get - see getNumSelectedFiles() to find out how many files were chosen.
		@see getHighlightedFile
	*/
	File getSelectedFile (int index) const noexcept;

	/** Deselects any files that are currently selected.
	*/
	void deselectAllFiles();

	/** Returns true if the currently selected file(s) are usable.

		This can be used to decide whether the user can press "ok" for the
		current file. What it does depends on the mode, so for example in an "open"
		mode, this only returns true if a file has been selected and if it exists.
		In a "save" mode, a non-existent file would also be valid.
	*/
	bool currentFileIsValid() const;

	/** This returns the last item in the view that the user has highlighted.
		This may be different from getCurrentFile(), which returns the value
		that is shown in the filename box, and if there are multiple selections,
		this will only return one of them.
		@see getSelectedFile
	*/
	File getHighlightedFile() const noexcept;

	/** Returns the directory whose contents are currently being shown in the listbox. */
	const File& getRoot() const;

	/** Changes the directory that's being shown in the listbox. */
	void setRoot (const File& newRootDirectory);

	/** Changes the name that is currently shown in the filename box. */
	void setFileName (const String& newName);

	/** Equivalent to pressing the "up" button to browse the parent directory. */
	void goUp();

	/** Refreshes the directory that's currently being listed. */
	void refresh();

	/** Changes the filter that's being used to sift the files. */
	void setFileFilter (const FileFilter* newFileFilter);

	/** Returns a verb to describe what should happen when the file is accepted.

		E.g. if browsing in "load file" mode, this will be "Open", if in "save file"
		mode, it'll be "Save", etc.
	*/
	virtual String getActionVerb() const;

	/** Returns true if the saveMode flag was set when this component was created.
	*/
	bool isSaveMode() const noexcept;

	/** Sets the label that will be displayed next to the filename entry box.
		By default this is just "file", but you might want to change it to something more
		appropriate for your app.
	*/
	void setFilenameBoxLabel (const String& name);

	/** Adds a listener to be told when the user selects and clicks on files.
		@see removeListener
	*/
	void addListener (FileBrowserListener* listener);

	/** Removes a listener.
		@see addListener
	*/
	void removeListener (FileBrowserListener* listener);

	/** @internal */
	void resized();
	/** @internal */
	void buttonClicked (Button*);
	/** @internal */
	void comboBoxChanged (ComboBox*);
	/** @internal */
	void textEditorTextChanged (TextEditor&);
	/** @internal */
	void textEditorReturnKeyPressed (TextEditor&);
	/** @internal */
	void textEditorEscapeKeyPressed (TextEditor&);
	/** @internal */
	void textEditorFocusLost (TextEditor&);
	/** @internal */
	bool keyPressed (const KeyPress&);
	/** @internal */
	void selectionChanged();
	/** @internal */
	void fileClicked (const File&, const MouseEvent&);
	/** @internal */
	void fileDoubleClicked (const File&);
	/** @internal */
	void browserRootChanged (const File&);
	/** @internal */
	bool isFileSuitable (const File&) const;
	/** @internal */
	bool isDirectorySuitable (const File&) const;

	/** @internal */
	FilePreviewComponent* getPreviewComponent() const noexcept;

	/** @internal */
	DirectoryContentsDisplayComponent* getDisplayComponent() const noexcept;

protected:
	/** Returns a list of names and paths for the default places the user might want to look.
		Use an empty string to indicate a section break.
	*/
	virtual void getRoots (StringArray& rootNames, StringArray& rootPaths);

	/** Updates the items in the dropdown list of recent paths with the values from getRoots(). */
	void resetRecentPaths();

private:

	ScopedPointer <DirectoryContentsList> fileList;
	const FileFilter* fileFilter;

	int flags;
	File currentRoot;
	Array<File> chosenFiles;
	ListenerList <FileBrowserListener> listeners;

	ScopedPointer<DirectoryContentsDisplayComponent> fileListComponent;
	FilePreviewComponent* previewComp;
	ComboBox currentPathBox;
	TextEditor filenameBox;
	Label fileLabel;
	ScopedPointer<Button> goUpButton;

	TimeSliceThread thread;

	void sendListenerChangeMessage();
	bool isFileOrDirSuitable (const File& f) const;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (FileBrowserComponent);
};

#endif   // __JUCE_FILEBROWSERCOMPONENT_JUCEHEADER__

/*** End of inlined file: juce_FileBrowserComponent.h ***/


#endif
#ifndef __JUCE_FILEBROWSERLISTENER_JUCEHEADER__

#endif
#ifndef __JUCE_FILECHOOSER_JUCEHEADER__

/*** Start of inlined file: juce_FileChooser.h ***/
#ifndef __JUCE_FILECHOOSER_JUCEHEADER__
#define __JUCE_FILECHOOSER_JUCEHEADER__

/**
	Creates a dialog box to choose a file or directory to load or save.

	To use a FileChooser:
	- create one (as a local stack variable is the neatest way)
	- call one of its browseFor.. methods
	- if this returns true, the user has selected a file, so you can retrieve it
	  with the getResult() method.

	e.g. @code
	void loadMooseFile()
	{
		FileChooser myChooser ("Please select the moose you want to load...",
							   File::getSpecialLocation (File::userHomeDirectory),
							   "*.moose");

		if (myChooser.browseForFileToOpen())
		{
			File mooseFile (myChooser.getResult());

			loadMoose (mooseFile);
		}
	}
	@endcode
*/
class JUCE_API  FileChooser
{
public:

	/** Creates a FileChooser.

		After creating one of these, use one of the browseFor... methods to display it.

		@param dialogBoxTitle           a text string to display in the dialog box to
										tell the user what's going on
		@param initialFileOrDirectory   the file or directory that should be selected when
										the dialog box opens. If this parameter is set to
										File::nonexistent, a sensible default directory
										will be used instead.
		@param filePatternsAllowed      a set of file patterns to specify which files can be
										selected - each pattern should be separated by a
										comma or semi-colon, e.g. "*" or "*.jpg;*.gif". An
										empty string means that all files are allowed
		@param useOSNativeDialogBox     if true, then a native dialog box will be used if
										possible; if false, then a Juce-based browser dialog
										box will always be used
		@see browseForFileToOpen, browseForFileToSave, browseForDirectory
	*/
	FileChooser (const String& dialogBoxTitle,
				 const File& initialFileOrDirectory = File::nonexistent,
				 const String& filePatternsAllowed = String::empty,
				 bool useOSNativeDialogBox = true);

	/** Destructor. */
	~FileChooser();

	/** Shows a dialog box to choose a file to open.

		This will display the dialog box modally, using an "open file" mode, so that
		it won't allow non-existent files or directories to be chosen.

		@param previewComponent   an optional component to display inside the dialog
								  box to show special info about the files that the user
								  is browsing. The component will not be deleted by this
								  object, so the caller must take care of it.
		@returns    true if the user selected a file, in which case, use the getResult()
					method to find out what it was. Returns false if they cancelled instead.
		@see browseForFileToSave, browseForDirectory
	*/
	bool browseForFileToOpen (FilePreviewComponent* previewComponent = 0);

	/** Same as browseForFileToOpen, but allows the user to select multiple files.

		The files that are returned can be obtained by calling getResults(). See
		browseForFileToOpen() for more info about the behaviour of this method.
	*/
	bool browseForMultipleFilesToOpen (FilePreviewComponent* previewComponent = 0);

	/** Shows a dialog box to choose a file to save.

		This will display the dialog box modally, using an "save file" mode, so it
		will allow non-existent files to be chosen, but not directories.

		@param warnAboutOverwritingExistingFiles     if true, the dialog box will ask
					the user if they're sure they want to overwrite a file that already
					exists
		@returns    true if the user chose a file and pressed 'ok', in which case, use
					the getResult() method to find out what the file was. Returns false
					if they cancelled instead.
		@see browseForFileToOpen, browseForDirectory
	*/
	bool browseForFileToSave (bool warnAboutOverwritingExistingFiles);

	/** Shows a dialog box to choose a directory.

		This will display the dialog box modally, using an "open directory" mode, so it
		will only allow directories to be returned, not files.

		@returns    true if the user chose a directory and pressed 'ok', in which case, use
					the getResult() method to find out what they chose. Returns false
					if they cancelled instead.
		@see browseForFileToOpen, browseForFileToSave
	*/
	bool browseForDirectory();

	/** Same as browseForFileToOpen, but allows the user to select multiple files and directories.

		The files that are returned can be obtained by calling getResults(). See
		browseForFileToOpen() for more info about the behaviour of this method.
	*/
	bool browseForMultipleFilesOrDirectories (FilePreviewComponent* previewComponent = 0);

	/** Returns the last file that was chosen by one of the browseFor methods.

		After calling the appropriate browseFor... method, this method lets you
		find out what file or directory they chose.

		Note that the file returned is only valid if the browse method returned true (i.e.
		if the user pressed 'ok' rather than cancelling).

		If you're using a multiple-file select, then use the getResults() method instead,
		to obtain the list of all files chosen.

		@see getResults
	*/
	File getResult() const;

	/** Returns a list of all the files that were chosen during the last call to a
		browse method.

		This array may be empty if no files were chosen, or can contain multiple entries
		if multiple files were chosen.

		@see getResult
	*/
	const Array<File>& getResults() const;

private:

	String title, filters;
	File startingFile;
	Array<File> results;
	bool useNativeDialogBox;

	bool showDialog (bool selectsDirectories, bool selectsFiles, bool isSave,
					 bool warnAboutOverwritingExistingFiles, bool selectMultipleFiles,
					 FilePreviewComponent* previewComponent);

	static void showPlatformDialog (Array<File>& results, const String& title, const File& file,
									const String& filters, bool selectsDirectories, bool selectsFiles,
									bool isSave, bool warnAboutOverwritingExistingFiles, bool selectMultipleFiles,
									FilePreviewComponent* previewComponent);
	static bool isPlatformDialogAvailable();

	JUCE_LEAK_DETECTOR (FileChooser);
};

#endif   // __JUCE_FILECHOOSER_JUCEHEADER__

/*** End of inlined file: juce_FileChooser.h ***/


#endif
#ifndef __JUCE_FILECHOOSERDIALOGBOX_JUCEHEADER__

/*** Start of inlined file: juce_FileChooserDialogBox.h ***/
#ifndef __JUCE_FILECHOOSERDIALOGBOX_JUCEHEADER__
#define __JUCE_FILECHOOSERDIALOGBOX_JUCEHEADER__


/*** Start of inlined file: juce_ResizableWindow.h ***/
#ifndef __JUCE_RESIZABLEWINDOW_JUCEHEADER__
#define __JUCE_RESIZABLEWINDOW_JUCEHEADER__


/*** Start of inlined file: juce_TopLevelWindow.h ***/
#ifndef __JUCE_TOPLEVELWINDOW_JUCEHEADER__
#define __JUCE_TOPLEVELWINDOW_JUCEHEADER__


/*** Start of inlined file: juce_DropShadower.h ***/
#ifndef __JUCE_DROPSHADOWER_JUCEHEADER__
#define __JUCE_DROPSHADOWER_JUCEHEADER__

/**
	Adds a drop-shadow to a component.

	This object creates and manages a set of components which sit around a
	component, creating a gaussian shadow around it. The components will track
	the position of the component and if it's brought to the front they'll also
	follow this.

	For desktop windows you don't need to use this class directly - just
	set the Component::windowHasDropShadow flag when calling
	Component::addToDesktop(), and the system will create one of these if it's
	needed (which it obviously isn't on the Mac, for example).
*/
class JUCE_API  DropShadower  : public ComponentListener
{
public:

	/** Creates a DropShadower.

		@param alpha        the opacity of the shadows, from 0 to 1.0
		@param xOffset      the horizontal displacement of the shadow, in pixels
		@param yOffset      the vertical displacement of the shadow, in pixels
		@param blurRadius   the radius of the blur to use for creating the shadow
	*/
	DropShadower (float alpha = 0.5f,
				  int xOffset = 1,
				  int yOffset = 5,
				  float blurRadius = 10.0f);

	/** Destructor. */
	virtual ~DropShadower();

	/** Attaches the DropShadower to the component you want to shadow. */
	void setOwner (Component* componentToFollow);

	/** @internal */
	void componentMovedOrResized (Component& component, bool wasMoved, bool wasResized);
	/** @internal */
	void componentBroughtToFront (Component& component);
	/** @internal */
	void componentParentHierarchyChanged (Component& component);
	/** @internal */
	void componentVisibilityChanged (Component& component);

private:

	Component* owner;
	OwnedArray<Component> shadowWindows;
	Image shadowImageSections[12];
	const int xOffset, yOffset;
	const float alpha, blurRadius;
	bool reentrant;

	void updateShadows();
	void setShadowImage (const Image& src, int num, int w, int h, int sx, int sy);
	void bringShadowWindowsToFront();

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (DropShadower);
};

#endif   // __JUCE_DROPSHADOWER_JUCEHEADER__

/*** End of inlined file: juce_DropShadower.h ***/

/**
	A base class for top-level windows.

	This class is used for components that are considered a major part of your
	application - e.g. ResizableWindow, DocumentWindow, DialogWindow, AlertWindow,
	etc. Things like menus that pop up briefly aren't derived from it.

	A TopLevelWindow is probably on the desktop, but this isn't mandatory - it
	could itself be the child of another component.

	The class manages a list of all instances of top-level windows that are in use,
	and each one is also given the concept of being "active". The active window is
	one that is actively being used by the user. This isn't quite the same as the
	component with the keyboard focus, because there may be a popup menu or other
	temporary window which gets keyboard focus while the active top level window is
	unchanged.

	A top-level window also has an optional drop-shadow.

	@see ResizableWindow, DocumentWindow, DialogWindow
*/
class JUCE_API  TopLevelWindow  : public Component
{
public:

	/** Creates a TopLevelWindow.

		@param name                 the name to give the component
		@param addToDesktop         if true, the window will be automatically added to the
									desktop; if false, you can use it as a child component
	*/
	TopLevelWindow (const String& name, bool addToDesktop);

	/** Destructor. */
	~TopLevelWindow();

	/** True if this is currently the TopLevelWindow that is actively being used.

		This isn't quite the same as having keyboard focus, because the focus may be
		on a child component or a temporary pop-up menu, etc, while this window is
		still considered to be active.

		@see activeWindowStatusChanged
	*/
	bool isActiveWindow() const noexcept                    { return windowIsActive_; }

	/** This will set the bounds of the window so that it's centred in front of another
		window.

		If your app has a few windows open and want to pop up a dialog box for one of
		them, you can use this to show it in front of the relevent parent window, which
		is a bit neater than just having it appear in the middle of the screen.

		If componentToCentreAround is 0, then the currently active TopLevelWindow will
		be used instead. If no window is focused, it'll just default to the middle of the
		screen.
	*/
	void centreAroundComponent (Component* componentToCentreAround,
								int width, int height);

	/** Turns the drop-shadow on and off. */
	void setDropShadowEnabled (bool useShadow);

	/** True if drop-shadowing is enabled. */
	bool isDropShadowEnabled() const noexcept               { return useDropShadow; }

	/** Sets whether an OS-native title bar will be used, or a Juce one.

		@see isUsingNativeTitleBar
	*/
	void setUsingNativeTitleBar (bool useNativeTitleBar);

	/** Returns true if the window is currently using an OS-native title bar.

		@see setUsingNativeTitleBar
	*/
	bool isUsingNativeTitleBar() const noexcept             { return useNativeTitleBar && isOnDesktop(); }

	/** Returns the number of TopLevelWindow objects currently in use.

		@see getTopLevelWindow
	*/
	static int getNumTopLevelWindows() noexcept;

	/** Returns one of the TopLevelWindow objects currently in use.

		The index is 0 to (getNumTopLevelWindows() - 1).
	*/
	static TopLevelWindow* getTopLevelWindow (int index) noexcept;

	/** Returns the currently-active top level window.

		There might not be one, of course, so this can return 0.
	*/
	static TopLevelWindow* getActiveTopLevelWindow() noexcept;

	/** @internal */
	virtual void addToDesktop (int windowStyleFlags, void* nativeWindowToAttachTo = nullptr);

protected:

	/** This callback happens when this window becomes active or inactive.

		@see isActiveWindow
	*/
	virtual void activeWindowStatusChanged();

	/** @internal */
	void focusOfChildComponentChanged (FocusChangeType cause);
	/** @internal */
	void parentHierarchyChanged();
	/** @internal */
	virtual int getDesktopWindowStyleFlags() const;
	/** @internal */
	void recreateDesktopWindow();
	/** @internal */
	void visibilityChanged();

private:
	friend class TopLevelWindowManager;
	bool useDropShadow, useNativeTitleBar, windowIsActive_;
	ScopedPointer <DropShadower> shadower;

	void setWindowActive (bool isNowActive);

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (TopLevelWindow);
};

#endif   // __JUCE_TOPLEVELWINDOW_JUCEHEADER__

/*** End of inlined file: juce_TopLevelWindow.h ***/


/*** Start of inlined file: juce_ResizableBorderComponent.h ***/
#ifndef __JUCE_RESIZABLEBORDERCOMPONENT_JUCEHEADER__
#define __JUCE_RESIZABLEBORDERCOMPONENT_JUCEHEADER__

/**
	A component that resizes its parent component when dragged.

	This component forms a frame around the edge of a component, allowing it to
	be dragged by the edges or corners to resize it - like the way windows are
	resized in MSWindows or Linux.

	To use it, just add it to your component, making it fill the entire parent component
	(there's a mouse hit-test that only traps mouse-events which land around the
	edge of the component, so it's even ok to put it on top of any other components
	you're using). Make sure you rescale the resizer component to fill the parent
	each time the parent's size changes.

	@see ResizableCornerComponent
*/
class JUCE_API  ResizableBorderComponent  : public Component
{
public:

	/** Creates a resizer.

		Pass in the target component which you want to be resized when this one is
		dragged.

		The target component will usually be a parent of the resizer component, but this
		isn't mandatory.

		Remember that when the target component is resized, it'll need to move and
		resize this component to keep it in place, as this won't happen automatically.

		If the constrainer parameter is non-zero, then this object will be used to enforce
		limits on the size and position that the component can be stretched to. Make sure
		that the constrainer isn't deleted while still in use by this object.

		@see ComponentBoundsConstrainer
	*/
	ResizableBorderComponent (Component* componentToResize,
							  ComponentBoundsConstrainer* constrainer);

	/** Destructor. */
	~ResizableBorderComponent();

	/** Specifies how many pixels wide the draggable edges of this component are.

		@see getBorderThickness
	*/
	void setBorderThickness (const BorderSize<int>& newBorderSize);

	/** Returns the number of pixels wide that the draggable edges of this component are.

		@see setBorderThickness
	*/
	BorderSize<int> getBorderThickness() const;

	/** Represents the different sections of a resizable border, which allow it to
		resized in different ways.
	*/
	class Zone
	{
	public:

		enum Zones
		{
			centre  = 0,
			left    = 1,
			top     = 2,
			right   = 4,
			bottom  = 8
		};

		/** Creates a Zone from a combination of the flags in \enum Zones. */
		explicit Zone (int zoneFlags = 0) noexcept;
		Zone (const Zone& other) noexcept;
		Zone& operator= (const Zone& other) noexcept;

		bool operator== (const Zone& other) const noexcept;
		bool operator!= (const Zone& other) const noexcept;

		/** Given a point within a rectangle with a resizable border, this returns the
			zone that the point lies within.
		*/
		static const Zone fromPositionOnBorder (const Rectangle<int>& totalSize,
												const BorderSize<int>& border,
												const Point<int>& position);

		/** Returns an appropriate mouse-cursor for this resize zone. */
		MouseCursor getMouseCursor() const noexcept;

		/** Returns true if dragging this zone will move the enire object without resizing it. */
		bool isDraggingWholeObject() const noexcept     { return zone == centre; }
		/** Returns true if dragging this zone will move the object's left edge. */
		bool isDraggingLeftEdge() const noexcept        { return (zone & left) != 0; }
		/** Returns true if dragging this zone will move the object's right edge. */
		bool isDraggingRightEdge() const noexcept       { return (zone & right) != 0; }
		/** Returns true if dragging this zone will move the object's top edge. */
		bool isDraggingTopEdge() const noexcept         { return (zone & top) != 0; }
		/** Returns true if dragging this zone will move the object's bottom edge. */
		bool isDraggingBottomEdge() const noexcept      { return (zone & bottom) != 0; }

		/** Resizes this rectangle by the given amount, moving just the edges that this zone
			applies to.
		*/
		template <typename ValueType>
		const Rectangle<ValueType> resizeRectangleBy (Rectangle<ValueType> original,
													  const Point<ValueType>& distance) const noexcept
		{
			if (isDraggingWholeObject())
				return original + distance;

			if (isDraggingLeftEdge())
				original.setLeft (jmin (original.getRight(), original.getX() + distance.x));

			if (isDraggingRightEdge())
				original.setWidth (jmax (ValueType(), original.getWidth() + distance.x));

			if (isDraggingTopEdge())
				original.setTop (jmin (original.getBottom(), original.getY() + distance.y));

			if (isDraggingBottomEdge())
				original.setHeight (jmax (ValueType(), original.getHeight() + distance.y));

			return original;
		}

		/** Returns the raw flags for this zone. */
		int getZoneFlags() const noexcept               { return zone; }

	private:

		int zone;
	};

protected:

	/** @internal */
	void paint (Graphics& g);
	/** @internal */
	void mouseEnter (const MouseEvent& e);
	/** @internal */
	void mouseMove (const MouseEvent& e);
	/** @internal */
	void mouseDown (const MouseEvent& e);
	/** @internal */
	void mouseDrag (const MouseEvent& e);
	/** @internal */
	void mouseUp (const MouseEvent& e);
	/** @internal */
	bool hitTest (int x, int y);

private:
	WeakReference<Component> component;
	ComponentBoundsConstrainer* constrainer;
	BorderSize<int> borderSize;
	Rectangle<int> originalBounds;
	Zone mouseZone;

	void updateMouseZone (const MouseEvent& e);

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ResizableBorderComponent);
};

#endif   // __JUCE_RESIZABLEBORDERCOMPONENT_JUCEHEADER__

/*** End of inlined file: juce_ResizableBorderComponent.h ***/


/*** Start of inlined file: juce_ResizableCornerComponent.h ***/
#ifndef __JUCE_RESIZABLECORNERCOMPONENT_JUCEHEADER__
#define __JUCE_RESIZABLECORNERCOMPONENT_JUCEHEADER__

/** A component that resizes a parent component when dragged.

	This is the small triangular stripey resizer component you get in the bottom-right
	of windows (more commonly on the Mac than Windows). Put one in the corner of
	a larger component and it will automatically resize its parent when it gets dragged
	around.

	@see ResizableFrameComponent
*/
class JUCE_API  ResizableCornerComponent  : public Component
{
public:

	/** Creates a resizer.

		Pass in the target component which you want to be resized when this one is
		dragged.

		The target component will usually be a parent of the resizer component, but this
		isn't mandatory.

		Remember that when the target component is resized, it'll need to move and
		resize this component to keep it in place, as this won't happen automatically.

		If the constrainer parameter is non-zero, then this object will be used to enforce
		limits on the size and position that the component can be stretched to. Make sure
		that the constrainer isn't deleted while still in use by this object. If you
		pass a zero in here, no limits will be put on the sizes it can be stretched to.

		@see ComponentBoundsConstrainer
	*/
	ResizableCornerComponent (Component* componentToResize,
							  ComponentBoundsConstrainer* constrainer);

	/** Destructor. */
	~ResizableCornerComponent();

protected:

	/** @internal */
	void paint (Graphics& g);
	/** @internal */
	void mouseDown (const MouseEvent& e);
	/** @internal */
	void mouseDrag (const MouseEvent& e);
	/** @internal */
	void mouseUp (const MouseEvent& e);
	/** @internal */
	bool hitTest (int x, int y);

private:

	WeakReference<Component> component;
	ComponentBoundsConstrainer* constrainer;
	Rectangle<int> originalBounds;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ResizableCornerComponent);
};

#endif   // __JUCE_RESIZABLECORNERCOMPONENT_JUCEHEADER__

/*** End of inlined file: juce_ResizableCornerComponent.h ***/

/**
	A base class for top-level windows that can be dragged around and resized.

	To add content to the window, use its setContentOwned() or setContentNonOwned() methods
	to give it a component that will remain positioned inside it (leaving a gap around
	the edges for a border).

	It's not advisable to add child components directly to a ResizableWindow: put them
	inside your content component instead. And overriding methods like resized(), moved(), etc
	is also not recommended - instead override these methods for your content component.
	(If for some obscure reason you do need to override these methods, always remember to
	call the super-class's resized() method too, otherwise it'll fail to lay out the window
	decorations correctly).

	By default resizing isn't enabled - use the setResizable() method to enable it and
	to choose the style of resizing to use.

	@see TopLevelWindow
*/
class JUCE_API  ResizableWindow  : public TopLevelWindow
{
public:

	/** Creates a ResizableWindow.

		This constructor doesn't specify a background colour, so the LookAndFeel's default
		background colour will be used.

		@param name                 the name to give the component
		@param addToDesktop         if true, the window will be automatically added to the
									desktop; if false, you can use it as a child component
	*/
	ResizableWindow (const String& name,
					 bool addToDesktop);

	/** Creates a ResizableWindow.

		@param name                 the name to give the component
		@param backgroundColour     the colour to use for filling the window's background.
		@param addToDesktop         if true, the window will be automatically added to the
									desktop; if false, you can use it as a child component
	*/
	ResizableWindow (const String& name,
					 const Colour& backgroundColour,
					 bool addToDesktop);

	/** Destructor.
		If a content component has been set with setContentOwned(), it will be deleted.
	*/
	~ResizableWindow();

	/** Returns the colour currently being used for the window's background.

		As a convenience the window will fill itself with this colour, but you
		can override the paint() method if you need more customised behaviour.

		This method is the same as retrieving the colour for ResizableWindow::backgroundColourId.

		@see setBackgroundColour
	*/
	Colour getBackgroundColour() const noexcept;

	/** Changes the colour currently being used for the window's background.

		As a convenience the window will fill itself with this colour, but you
		can override the paint() method if you need more customised behaviour.

		Note that the opaque state of this window is altered by this call to reflect
		the opacity of the colour passed-in. On window systems which can't support
		semi-transparent windows this might cause problems, (though it's unlikely you'll
		be using this class as a base for a semi-transparent component anyway).

		You can also use the ResizableWindow::backgroundColourId colour id to set
		this colour.

		@see getBackgroundColour
	*/
	void setBackgroundColour (const Colour& newColour);

	/** Make the window resizable or fixed.

		@param shouldBeResizable            whether it's resizable at all
		@param useBottomRightCornerResizer  if true, it'll add a ResizableCornerComponent at the
											bottom-right; if false, it'll use a ResizableBorderComponent
											around the edge
		@see setResizeLimits, isResizable
	*/
	void setResizable (bool shouldBeResizable,
					   bool useBottomRightCornerResizer);

	/** True if resizing is enabled.

		@see setResizable
	*/
	bool isResizable() const noexcept;

	/** This sets the maximum and minimum sizes for the window.

		If the window's current size is outside these limits, it will be resized to
		make sure it's within them.

		Calling setBounds() on the component will bypass any size checking - it's only when
		the window is being resized by the user that these values are enforced.

		@see setResizable, setFixedAspectRatio
	*/
	void setResizeLimits (int newMinimumWidth,
						  int newMinimumHeight,
						  int newMaximumWidth,
						  int newMaximumHeight) noexcept;

	/** Returns the bounds constrainer object that this window is using.

		You can access this to change its properties.
	*/
	ComponentBoundsConstrainer* getConstrainer() noexcept           { return constrainer; }

	/** Sets the bounds-constrainer object to use for resizing and dragging this window.

		A pointer to the object you pass in will be kept, but it won't be deleted
		by this object, so it's the caller's responsiblity to manage it.

		If you pass 0, then no contraints will be placed on the positioning of the window.
	*/
	void setConstrainer (ComponentBoundsConstrainer* newConstrainer);

	/** Calls the window's setBounds method, after first checking these bounds
		with the current constrainer.

		@see setConstrainer
	*/
	void setBoundsConstrained (const Rectangle<int>& bounds);

	/** Returns true if the window is currently in full-screen mode.

		@see setFullScreen
	*/
	bool isFullScreen() const;

	/** Puts the window into full-screen mode, or restores it to its normal size.

		If true, the window will become full-screen; if false, it will return to the
		last size it was before being made full-screen.

		@see isFullScreen
	*/
	void setFullScreen (bool shouldBeFullScreen);

	/** Returns true if the window is currently minimised.

		@see setMinimised
	*/
	bool isMinimised() const;

	/** Minimises the window, or restores it to its previous position and size.

		When being un-minimised, it'll return to the last position and size it
		was in before being minimised.

		@see isMinimised
	*/
	void setMinimised (bool shouldMinimise);

	/** Adds the window to the desktop using the default flags. */
	void addToDesktop();

	/** Returns a string which encodes the window's current size and position.

		This string will encapsulate the window's size, position, and whether it's
		in full-screen mode. It's intended for letting your application save and
		restore a window's position.

		Use the restoreWindowStateFromString() to restore from a saved state.

		@see restoreWindowStateFromString
	*/
	String getWindowStateAsString();

	/** Restores the window to a previously-saved size and position.

		This restores the window's size, positon and full-screen status from an
		string that was previously created with the getWindowStateAsString()
		method.

		@returns false if the string wasn't a valid window state
		@see getWindowStateAsString
	*/
	bool restoreWindowStateFromString (const String& previousState);

	/** Returns the current content component.

		This will be the component set by setContentOwned() or setContentNonOwned, or 0 if none
		has yet been specified.

		@see setContentOwned, setContentNonOwned
	*/
	Component* getContentComponent() const noexcept                 { return contentComponent; }

	/** Changes the current content component.

		This sets a component that will be placed in the centre of the ResizableWindow,
		(leaving a space around the edge for the border).

		You should never add components directly to a ResizableWindow (or any of its subclasses)
		with addChildComponent(). Instead, add them to the content component.

		@param newContentComponent  the new component to use - this component will be deleted when it's
									no longer needed (i.e. when the window is deleted or a new content
									component is set for it). To set a component that this window will not
									delete, call setContentNonOwned() instead.
		@param resizeToFitWhenContentChangesSize  if true, then the ResizableWindow will maintain its size
									such that it always fits around the size of the content component. If false,
									the new content will be resized to fit the current space available.
	*/
	void setContentOwned (Component* newContentComponent,
						  bool resizeToFitWhenContentChangesSize);

	/** Changes the current content component.

		This sets a component that will be placed in the centre of the ResizableWindow,
		(leaving a space around the edge for the border).

		You should never add components directly to a ResizableWindow (or any of its subclasses)
		with addChildComponent(). Instead, add them to the content component.

		@param newContentComponent  the new component to use - this component will NOT be deleted by this
									component, so it's the caller's responsibility to manage its lifetime (it's
									ok to delete it while this window is still using it). To set a content
									component that the window will delete, call setContentOwned() instead.
		@param resizeToFitWhenContentChangesSize  if true, then the ResizableWindow will maintain its size
									such that it always fits around the size of the content component. If false,
									the new content will be resized to fit the current space available.
	*/
	void setContentNonOwned (Component* newContentComponent,
							 bool resizeToFitWhenContentChangesSize);

	/** Removes the current content component.
		If the previous content component was added with setContentOwned(), it will also be deleted. If
		it was added with setContentNonOwned(), it will simply be removed from this component.
	*/
	void clearContentComponent();

	/** Changes the window so that the content component ends up with the specified size.

		This is basically a setSize call on the window, but which adds on the borders,
		so you can specify the content component's target size.
	*/
	void setContentComponentSize (int width, int height);

	/** Returns the width of the frame to use around the window.
		@see getContentComponentBorder
	*/
	virtual BorderSize<int> getBorderThickness();

	/** Returns the insets to use when positioning the content component.
		@see getBorderThickness
	*/
	virtual BorderSize<int> getContentComponentBorder();

	/** A set of colour IDs to use to change the colour of various aspects of the window.

		These constants can be used either via the Component::setColour(), or LookAndFeel::setColour()
		methods.

		@see Component::setColour, Component::findColour, LookAndFeel::setColour, LookAndFeel::findColour
	*/
	enum ColourIds
	{
		backgroundColourId          = 0x1005700,  /**< A colour to use to fill the window's background. */
	};

	/** @deprecated - use setContentOwned() and setContentNonOwned() instead. */
	JUCE_DEPRECATED (void setContentComponent (Component* newContentComponent,
											   bool deleteOldOne = true,
											   bool resizeToFit = false));

protected:

	/** @internal */
	void paint (Graphics& g);
	/** (if overriding this, make sure you call ResizableWindow::resized() in your subclass) */
	void moved();
	/** (if overriding this, make sure you call ResizableWindow::resized() in your subclass) */
	void resized();
	/** @internal */
	void mouseDown (const MouseEvent& e);
	/** @internal */
	void mouseDrag (const MouseEvent& e);
	/** @internal */
	void lookAndFeelChanged();
	/** @internal */
	void childBoundsChanged (Component* child);
	/** @internal */
	void parentSizeChanged();
	/** @internal */
	void visibilityChanged();
	/** @internal */
	void activeWindowStatusChanged();
	/** @internal */
	int getDesktopWindowStyleFlags() const;

   #if JUCE_DEBUG
	/** Overridden to warn people about adding components directly to this component
		instead of using setContentOwned().

		If you know what you're doing and are sure you really want to add a component, specify
		a base-class method call to Component::addAndMakeVisible(), to side-step this warning.
	*/
	void addChildComponent (Component* child, int zOrder = -1);
	/** Overridden to warn people about adding components directly to this component
		instead of using setContentOwned().

		If you know what you're doing and are sure you really want to add a component, specify
		a base-class method call to Component::addAndMakeVisible(), to side-step this warning.
	*/
	void addAndMakeVisible (Component* child, int zOrder = -1);
   #endif

	ScopedPointer <ResizableCornerComponent> resizableCorner;
	ScopedPointer <ResizableBorderComponent> resizableBorder;

private:

	Component::SafePointer <Component> contentComponent;
	bool ownsContentComponent, resizeToFitContent, fullscreen;
	ComponentDragger dragger;
	Rectangle<int> lastNonFullScreenPos;
	ComponentBoundsConstrainer defaultConstrainer;
	ComponentBoundsConstrainer* constrainer;
	#if JUCE_DEBUG
	bool hasBeenResized;
	#endif

	void initialise (bool addToDesktop);
	void updateLastPos();
	void setContent (Component*, bool takeOwnership, bool resizeToFit);

   #if JUCE_CATCH_DEPRECATED_CODE_MISUSE
	// The parameters for these methods have changed - please update your code!
	JUCE_DEPRECATED (void getBorderThickness (int& left, int& top, int& right, int& bottom));
	JUCE_DEPRECATED (void getContentComponentBorder (int& left, int& top, int& right, int& bottom));
   #endif

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ResizableWindow);
};

#endif   // __JUCE_RESIZABLEWINDOW_JUCEHEADER__

/*** End of inlined file: juce_ResizableWindow.h ***/


/*** Start of inlined file: juce_AlertWindow.h ***/
#ifndef __JUCE_ALERTWINDOW_JUCEHEADER__
#define __JUCE_ALERTWINDOW_JUCEHEADER__


/*** Start of inlined file: juce_ProgressBar.h ***/
#ifndef __JUCE_PROGRESSBAR_JUCEHEADER__
#define __JUCE_PROGRESSBAR_JUCEHEADER__

/**
	A progress bar component.

	To use this, just create one and make it visible. It'll run its own timer
	to keep an eye on a variable that you give it, and will automatically
	redraw itself when the variable changes.

	For an easy way of running a background task with a dialog box showing its
	progress, see the ThreadWithProgressWindow class.

	@see ThreadWithProgressWindow
*/
class JUCE_API  ProgressBar  : public Component,
							   public SettableTooltipClient,
							   private Timer
{
public:

	/** Creates a ProgressBar.

		@param progress     pass in a reference to a double that you're going to
							update with your task's progress. The ProgressBar will
							monitor the value of this variable and will redraw itself
							when the value changes. The range is from 0 to 1.0. Obviously
							you'd better be careful not to delete this variable while the
							ProgressBar still exists!
	*/
	explicit ProgressBar (double& progress);

	/** Destructor. */
	~ProgressBar();

	/** Turns the percentage display on or off.

		By default this is on, and the progress bar will display a text string showing
		its current percentage.
	*/
	void setPercentageDisplay (bool shouldDisplayPercentage);

	/** Gives the progress bar a string to display inside it.

		If you call this, it will turn off the percentage display.
		@see setPercentageDisplay
	*/
	void setTextToDisplay (const String& text);

	/** A set of colour IDs to use to change the colour of various aspects of the bar.

		These constants can be used either via the Component::setColour(), or LookAndFeel::setColour()
		methods.

		@see Component::setColour, Component::findColour, LookAndFeel::setColour, LookAndFeel::findColour
	*/
	enum ColourIds
	{
		backgroundColourId              = 0x1001900,    /**< The background colour, behind the bar. */
		foregroundColourId              = 0x1001a00,    /**< The colour to use to draw the bar itself. LookAndFeel
															 classes will probably use variations on this colour. */
	};

protected:

	/** @internal */
	void paint (Graphics& g);
	/** @internal */
	void lookAndFeelChanged();
	/** @internal */
	void visibilityChanged();
	/** @internal */
	void colourChanged();

private:
	double& progress;
	double currentValue;
	bool displayPercentage;
	String displayedMessage, currentMessage;
	uint32 lastCallbackTime;

	void timerCallback();

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ProgressBar);
};

#endif   // __JUCE_PROGRESSBAR_JUCEHEADER__

/*** End of inlined file: juce_ProgressBar.h ***/

/** A window that displays a message and has buttons for the user to react to it.

	For simple dialog boxes with just a couple of buttons on them, there are
	some static methods for running these.

	For more complex dialogs, an AlertWindow can be created, then it can have some
	buttons and components added to it, and its runModalLoop() method is then used to
	show it. The value returned by runModalLoop() shows which button the
	user pressed to dismiss the box.

	@see ThreadWithProgressWindow
*/
class JUCE_API  AlertWindow  : public TopLevelWindow,
							   private ButtonListener  // (can't use Button::Listener due to idiotic VC2005 bug)
{
public:

	/** The type of icon to show in the dialog box. */
	enum AlertIconType
	{
		NoIcon,         /**< No icon will be shown on the dialog box. */
		QuestionIcon,   /**< A question-mark icon, for dialog boxes that need the
							 user to answer a question. */
		WarningIcon,    /**< An exclamation mark to indicate that the dialog is a
							 warning about something and shouldn't be ignored. */
		InfoIcon        /**< An icon that indicates that the dialog box is just
							 giving the user some information, which doesn't require
							 a response from them. */
	};

	/** Creates an AlertWindow.

		@param title    the headline to show at the top of the dialog box
		@param message  a longer, more descriptive message to show underneath the
						headline
		@param iconType the type of icon to display
		@param associatedComponent   if this is non-null, it specifies the component that the
						alert window should be associated with. Depending on the look
						and feel, this might be used for positioning of the alert window.
	*/
	AlertWindow (const String& title,
				 const String& message,
				 AlertIconType iconType,
				 Component* associatedComponent = nullptr);

	/** Destroys the AlertWindow */
	~AlertWindow();

	/** Returns the type of alert icon that was specified when the window
		was created. */
	AlertIconType getAlertType() const noexcept             { return alertIconType; }

	/** Changes the dialog box's message.

		This will also resize the window to fit the new message if required.
	*/
	void setMessage (const String& message);

	/** Adds a button to the window.

		@param name         the text to show on the button
		@param returnValue  the value that should be returned from runModalLoop()
							if this is the button that the user presses.
		@param shortcutKey1 an optional key that can be pressed to trigger this button
		@param shortcutKey2 a second optional key that can be pressed to trigger this button
	*/
	void addButton (const String& name,
					int returnValue,
					const KeyPress& shortcutKey1 = KeyPress(),
					const KeyPress& shortcutKey2 = KeyPress());

	/** Returns the number of buttons that the window currently has. */
	int getNumButtons() const;

	/** Invokes a click of one of the buttons. */
	void triggerButtonClick (const String& buttonName);

	/** If set to true and the window contains no buttons, then pressing the escape key will make
		the alert cancel its modal state.
		By default this setting is true - turn it off if you don't want the box to respond to
		the escape key. Note that it is ignored if you have any buttons, and in that case you
		should give the buttons appropriate keypresses to trigger cancelling if you want to.
	*/
	void setEscapeKeyCancels (bool shouldEscapeKeyCancel);

	/** Adds a textbox to the window for entering strings.

		@param name             an internal name for the text-box. This is the name to pass to
								the getTextEditorContents() method to find out what the
								user typed-in.
		@param initialContents  a string to show in the text box when it's first shown
		@param onScreenLabel    if this is non-empty, it will be displayed next to the
								text-box to label it.
		@param isPasswordBox    if true, the text editor will display asterisks instead of
								the actual text
		@see getTextEditorContents
	*/
	void addTextEditor (const String& name,
						const String& initialContents,
						const String& onScreenLabel = String::empty,
						bool isPasswordBox = false);

	/** Returns the contents of a named textbox.

		After showing an AlertWindow that contains a text editor, this can be
		used to find out what the user has typed into it.

		@param nameOfTextEditor     the name of the text box that you're interested in
		@see addTextEditor
	*/
	String getTextEditorContents (const String& nameOfTextEditor) const;

	/** Returns a pointer to a textbox that was added with addTextEditor(). */
	TextEditor* getTextEditor (const String& nameOfTextEditor) const;

	/** Adds a drop-down list of choices to the box.

		After the box has been shown, the getComboBoxComponent() method can
		be used to find out which item the user picked.

		@param name     the label to use for the drop-down list
		@param items    the list of items to show in it
		@param onScreenLabel    if this is non-empty, it will be displayed next to the
								combo-box to label it.
		@see getComboBoxComponent
	*/
	void addComboBox (const String& name,
					  const StringArray& items,
					  const String& onScreenLabel = String::empty);

	/** Returns a drop-down list that was added to the AlertWindow.

		@param nameOfList   the name that was passed into the addComboBox() method
							when creating the drop-down
		@returns the ComboBox component, or 0 if none was found for the given name.
	*/
	ComboBox* getComboBoxComponent (const String& nameOfList) const;

	/** Adds a block of text.

		This is handy for adding a multi-line note next to a textbox or combo-box,
		to provide more details about what's going on.
	*/
	void addTextBlock (const String& text);

	/** Adds a progress-bar to the window.

		@param progressValue    a variable that will be repeatedly checked while the
								dialog box is visible, to see how far the process has
								got. The value should be in the range 0 to 1.0
	*/
	void addProgressBarComponent (double& progressValue);

	/** Adds a user-defined component to the dialog box.

		@param component    the component to add - its size should be set up correctly
							before it is passed in. The caller is responsible for deleting
							the component later on - the AlertWindow won't delete it.
	*/
	void addCustomComponent (Component* component);

	/** Returns the number of custom components in the dialog box.

		@see getCustomComponent, addCustomComponent
	*/
	int getNumCustomComponents() const;

	/** Returns one of the custom components in the dialog box.

		@param index    a value 0 to (getNumCustomComponents() - 1). Out-of-range indexes
						will return 0
		@see getNumCustomComponents, addCustomComponent
	*/
	Component* getCustomComponent (int index) const;

	/** Removes one of the custom components in the dialog box.

		Note that this won't delete it, it just removes the component from the window

		@param index    a value 0 to (getNumCustomComponents() - 1). Out-of-range indexes
						will return 0
		@returns        the component that was removed (or null)
		@see getNumCustomComponents, addCustomComponent
	*/
	Component* removeCustomComponent (int index);

	/** Returns true if the window contains any components other than just buttons.*/
	bool containsAnyExtraComponents() const;

	// easy-to-use message box functions:

	/** Shows a dialog box that just has a message and a single button to get rid of it.

		If the callback parameter is null, the box is shown modally, and the method will
		block until the user has clicked the button (or pressed the escape or return keys).
		If the callback parameter is non-null, the box will be displayed and placed into a
		modal state, but this method will return immediately, and the callback will be invoked
		later when the user dismisses the box.

		@param iconType     the type of icon to show
		@param title        the headline to show at the top of the box
		@param message      a longer, more descriptive message to show underneath the
							headline
		@param buttonText   the text to show in the button - if this string is empty, the
							default string "ok" (or a localised version) will be used.
		@param associatedComponent   if this is non-null, it specifies the component that the
							alert window should be associated with. Depending on the look
							and feel, this might be used for positioning of the alert window.
	*/
   #if JUCE_MODAL_LOOPS_PERMITTED
	static void JUCE_CALLTYPE showMessageBox (AlertIconType iconType,
											  const String& title,
											  const String& message,
											  const String& buttonText = String::empty,
											  Component* associatedComponent = nullptr);
   #endif

	/** Shows a dialog box that just has a message and a single button to get rid of it.

		If the callback parameter is null, the box is shown modally, and the method will
		block until the user has clicked the button (or pressed the escape or return keys).
		If the callback parameter is non-null, the box will be displayed and placed into a
		modal state, but this method will return immediately, and the callback will be invoked
		later when the user dismisses the box.

		@param iconType     the type of icon to show
		@param title        the headline to show at the top of the box
		@param message      a longer, more descriptive message to show underneath the
							headline
		@param buttonText   the text to show in the button - if this string is empty, the
							default string "ok" (or a localised version) will be used.
		@param associatedComponent   if this is non-null, it specifies the component that the
							alert window should be associated with. Depending on the look
							and feel, this might be used for positioning of the alert window.
	*/
	static void JUCE_CALLTYPE showMessageBoxAsync (AlertIconType iconType,
												   const String& title,
												   const String& message,
												   const String& buttonText = String::empty,
												   Component* associatedComponent = nullptr);

	/** Shows a dialog box with two buttons.

		Ideal for ok/cancel or yes/no choices. The return key can also be used
		to trigger the first button, and the escape key for the second button.

		If the callback parameter is null, the box is shown modally, and the method will
		block until the user has clicked the button (or pressed the escape or return keys).
		If the callback parameter is non-null, the box will be displayed and placed into a
		modal state, but this method will return immediately, and the callback will be invoked
		later when the user dismisses the box.

		@param iconType     the type of icon to show
		@param title        the headline to show at the top of the box
		@param message      a longer, more descriptive message to show underneath the
							headline
		@param button1Text  the text to show in the first button - if this string is
							empty, the default string "ok" (or a localised version of it)
							will be used.
		@param button2Text  the text to show in the second button - if this string is
							empty, the default string "cancel" (or a localised version of it)
							will be used.
		@param associatedComponent   if this is non-null, it specifies the component that the
							alert window should be associated with. Depending on the look
							and feel, this might be used for positioning of the alert window.
		@param callback     if this is non-null, the menu will be launched asynchronously,
							returning immediately, and the callback will receive a call to its
							modalStateFinished() when the box is dismissed, with its parameter
							being 1 if the ok button was pressed, or 0 for cancel, The callback object
							will be owned and deleted by the system, so make sure that it works
							safely and doesn't keep any references to objects that might be deleted
							before it gets called.
		@returns true if button 1 was clicked, false if it was button 2. If the callback parameter
				 is not null, the method always returns false, and the user's choice is delivered
				 later by the callback.
	*/
	static bool JUCE_CALLTYPE showOkCancelBox (AlertIconType iconType,
											   const String& title,
											   const String& message,
											#if JUCE_MODAL_LOOPS_PERMITTED
											   const String& button1Text = String::empty,
											   const String& button2Text = String::empty,
											   Component* associatedComponent = nullptr,
											   ModalComponentManager::Callback* callback = nullptr);
											#else
											   const String& button1Text,
											   const String& button2Text,
											   Component* associatedComponent,
											   ModalComponentManager::Callback* callback);
											#endif

	/** Shows a dialog box with three buttons.

		Ideal for yes/no/cancel boxes.

		The escape key can be used to trigger the third button.

		If the callback parameter is null, the box is shown modally, and the method will
		block until the user has clicked the button (or pressed the escape or return keys).
		If the callback parameter is non-null, the box will be displayed and placed into a
		modal state, but this method will return immediately, and the callback will be invoked
		later when the user dismisses the box.

		@param iconType     the type of icon to show
		@param title        the headline to show at the top of the box
		@param message      a longer, more descriptive message to show underneath the
							headline
		@param button1Text  the text to show in the first button - if an empty string, then
							"yes" will be used (or a localised version of it)
		@param button2Text  the text to show in the first button - if an empty string, then
							"no" will be used (or a localised version of it)
		@param button3Text  the text to show in the first button - if an empty string, then
							"cancel" will be used (or a localised version of it)
		@param associatedComponent   if this is non-null, it specifies the component that the
							alert window should be associated with. Depending on the look
							and feel, this might be used for positioning of the alert window.
		@param callback     if this is non-null, the menu will be launched asynchronously,
							returning immediately, and the callback will receive a call to its
							modalStateFinished() when the box is dismissed, with its parameter
							being 1 if the "yes" button was pressed, 2 for the "no" button, or 0
							if it was cancelled, The callback object will be owned and deleted by the
							system, so make sure that it works safely and doesn't keep any references
							to objects that might be deleted before it gets called.

		@returns If the callback parameter has been set, this returns 0. Otherwise, it
				 returns one of the following values:
				 - 0 if the third button was pressed (normally used for 'cancel')
				 - 1 if the first button was pressed (normally used for 'yes')
				 - 2 if the middle button was pressed (normally used for 'no')
	*/
	static int JUCE_CALLTYPE showYesNoCancelBox (AlertIconType iconType,
												 const String& title,
												 const String& message,
											   #if JUCE_MODAL_LOOPS_PERMITTED
												 const String& button1Text = String::empty,
												 const String& button2Text = String::empty,
												 const String& button3Text = String::empty,
												 Component* associatedComponent = nullptr,
												 ModalComponentManager::Callback* callback = nullptr);
											   #else
												 const String& button1Text,
												 const String& button2Text,
												 const String& button3Text,
												 Component* associatedComponent,
												 ModalComponentManager::Callback* callback);
											   #endif

	/** Shows an operating-system native dialog box.

		@param title        the title to use at the top
		@param bodyText     the longer message to show
		@param isOkCancel   if true, this will show an ok/cancel box, if false,
							it'll show a box with just an ok button
		@returns true if the ok button was pressed, false if they pressed cancel.
	*/
   #if JUCE_MODAL_LOOPS_PERMITTED
	static bool JUCE_CALLTYPE showNativeDialogBox (const String& title,
												   const String& bodyText,
												   bool isOkCancel);
   #endif

	/** A set of colour IDs to use to change the colour of various aspects of the alert box.

		These constants can be used either via the Component::setColour(), or LookAndFeel::setColour()
		methods.

		@see Component::setColour, Component::findColour, LookAndFeel::setColour, LookAndFeel::findColour
	*/
	enum ColourIds
	{
		backgroundColourId          = 0x1001800,  /**< The background colour for the window. */
		textColourId                = 0x1001810,  /**< The colour for the text. */
		outlineColourId             = 0x1001820   /**< An optional colour to use to draw a border around the window. */
	};

protected:

	/** @internal */
	void paint (Graphics& g);
	/** @internal */
	void mouseDown (const MouseEvent& e);
	/** @internal */
	void mouseDrag (const MouseEvent& e);
	/** @internal */
	bool keyPressed (const KeyPress& key);
	/** @internal */
	void buttonClicked (Button* button);
	/** @internal */
	void lookAndFeelChanged();
	/** @internal */
	void userTriedToCloseWindow();
	/** @internal */
	int getDesktopWindowStyleFlags() const;

private:

	String text;
	TextLayout textLayout;
	AlertIconType alertIconType;
	ComponentBoundsConstrainer constrainer;
	ComponentDragger dragger;
	Rectangle<int> textArea;
	OwnedArray<TextButton> buttons;
	OwnedArray<TextEditor> textBoxes;
	OwnedArray<ComboBox> comboBoxes;
	OwnedArray<ProgressBar> progressBars;
	Array<Component*> customComps;
	OwnedArray<Component> textBlocks;
	Array<Component*> allComps;
	StringArray textboxNames, comboBoxNames;
	Component* associatedComponent;
	bool escapeKeyCancels;

	void updateLayout (bool onlyIncreaseSize);

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (AlertWindow);
};

#endif   // __JUCE_ALERTWINDOW_JUCEHEADER__

/*** End of inlined file: juce_AlertWindow.h ***/

/**
	A file open/save dialog box.

	This is a Juce-based file dialog box; to use a native file chooser, see the
	FileChooser class.

	To use one of these, create it and call its show() method. e.g.

	@code
	{
		WildcardFileFilter wildcardFilter ("*.foo", String::empty, "Foo files");

		FileBrowserComponent browser (FileBrowserComponent::canSelectFiles,
									  File::nonexistent,
									  &wildcardFilter,
									  nullptr);

		FileChooserDialogBox dialogBox ("Open some kind of file",
										"Please choose some kind of file that you want to open...",
										browser,
										false,
										Colours::lightgrey);

		if (dialogBox.show())
		{
			File selectedFile = browser.getSelectedFile (0);

			...etc..
		}
	}
	@endcode

	@see FileChooser
*/
class JUCE_API  FileChooserDialogBox : public ResizableWindow,
									   public ButtonListener,  // (can't use Button::Listener due to idiotic VC2005 bug)
									   public FileBrowserListener
{
public:

	/** Creates a file chooser box.

		@param title            the main title to show at the top of the box
		@param instructions     an optional longer piece of text to show below the title in
								a smaller font, describing in more detail what's required.
		@param browserComponent a FileBrowserComponent that will be shown inside this dialog
								box. Make sure you delete this after (but not before!) the
								dialog box has been deleted.
		@param warnAboutOverwritingExistingFiles     if true, then the user will be asked to confirm
								if they try to select a file that already exists. (This
								flag is only used when saving files)
		@param backgroundColour the background colour for the top level window

		@see FileBrowserComponent, FilePreviewComponent
	*/
	FileChooserDialogBox (const String& title,
						  const String& instructions,
						  FileBrowserComponent& browserComponent,
						  bool warnAboutOverwritingExistingFiles,
						  const Colour& backgroundColour);

	/** Destructor. */
	~FileChooserDialogBox();

   #if JUCE_MODAL_LOOPS_PERMITTED
	/** Displays and runs the dialog box modally.

		This will show the box with the specified size, returning true if the user
		pressed 'ok', or false if they cancelled.

		Leave the width or height as 0 to use the default size
	*/
	bool show (int width = 0, int height = 0);

	/** Displays and runs the dialog box modally.

		This will show the box with the specified size at the specified location,
		returning true if the user pressed 'ok', or false if they cancelled.

		Leave the width or height as 0 to use the default size.
	*/
	bool showAt (int x, int y, int width, int height);
   #endif

	/** Sets the size of this dialog box to its default and positions it either in the
		centre of the screen, or centred around a component that is provided.
	*/
	void centreWithDefaultSize (Component* componentToCentreAround = 0);

	/** A set of colour IDs to use to change the colour of various aspects of the box.

		These constants can be used either via the Component::setColour(), or LookAndFeel::setColour()
		methods.

		@see Component::setColour, Component::findColour, LookAndFeel::setColour, LookAndFeel::findColour
	*/
	enum ColourIds
	{
		titleTextColourId      = 0x1000850, /**< The colour to use to draw the box's title. */
	};

	/** @internal */
	void buttonClicked (Button*);
	/** @internal */
	void closeButtonPressed();
	/** @internal */
	void selectionChanged();
	/** @internal */
	void fileClicked (const File&, const MouseEvent&);
	/** @internal */
	void fileDoubleClicked (const File&);
	/** @internal */
	void browserRootChanged (const File&);

private:
	class ContentComponent;
	ContentComponent* content;
	const bool warnAboutOverwritingExistingFiles;

	void okButtonPressed();
	void createNewFolder();
	void createNewFolderConfirmed (const String& name);

	static void okToOverwriteFileCallback (int result, FileChooserDialogBox*);
	static void createNewFolderCallback (int result, FileChooserDialogBox*, Component::SafePointer<AlertWindow>);

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (FileChooserDialogBox);
};

#endif   // __JUCE_FILECHOOSERDIALOGBOX_JUCEHEADER__

/*** End of inlined file: juce_FileChooserDialogBox.h ***/


#endif
#ifndef __JUCE_FILEFILTER_JUCEHEADER__

#endif
#ifndef __JUCE_FILELISTCOMPONENT_JUCEHEADER__

/*** Start of inlined file: juce_FileListComponent.h ***/
#ifndef __JUCE_FILELISTCOMPONENT_JUCEHEADER__
#define __JUCE_FILELISTCOMPONENT_JUCEHEADER__


/*** Start of inlined file: juce_ListBox.h ***/
#ifndef __JUCE_LISTBOX_JUCEHEADER__
#define __JUCE_LISTBOX_JUCEHEADER__

/**
	A subclass of this is used to drive a ListBox.

	@see ListBox
*/
class JUCE_API  ListBoxModel
{
public:

	/** Destructor. */
	virtual ~ListBoxModel()  {}

	/** This has to return the number of items in the list.

		@see ListBox::getNumRows()
	*/
	virtual int getNumRows() = 0;

	/** This method must be implemented to draw a row of the list.
	*/
	virtual void paintListBoxItem (int rowNumber,
								   Graphics& g,
								   int width, int height,
								   bool rowIsSelected) = 0;

	/** This is used to create or update a custom component to go in a row of the list.

		Any row may contain a custom component, or can just be drawn with the paintListBoxItem() method
		and handle mouse clicks with listBoxItemClicked().

		This method will be called whenever a custom component might need to be updated - e.g.
		when the table is changed, or TableListBox::updateContent() is called.

		If you don't need a custom component for the specified row, then return 0.

		If you do want a custom component, and the existingComponentToUpdate is null, then
		this method must create a suitable new component and return it.

		If the existingComponentToUpdate is non-null, it will be a pointer to a component previously created
		by this method. In this case, the method must either update it to make sure it's correctly representing
		the given row (which may be different from the one that the component was created for), or it can
		delete this component and return a new one.

		The component that your method returns will be deleted by the ListBox when it is no longer needed.
	*/
	virtual Component* refreshComponentForRow (int rowNumber, bool isRowSelected,
											   Component* existingComponentToUpdate);

	/** This can be overridden to react to the user clicking on a row.

		@see listBoxItemDoubleClicked
	*/
	virtual void listBoxItemClicked (int row, const MouseEvent& e);

	/** This can be overridden to react to the user double-clicking on a row.

		@see listBoxItemClicked
	*/
	virtual void listBoxItemDoubleClicked (int row, const MouseEvent& e);

	/** This can be overridden to react to the user double-clicking on a part of the list where
		there are no rows.

		@see listBoxItemClicked
	*/
	virtual void backgroundClicked();

	/** Override this to be informed when rows are selected or deselected.

		This will be called whenever a row is selected or deselected. If a range of
		rows is selected all at once, this will just be called once for that event.

		@param lastRowSelected      the last row that the user selected. If no
									rows are currently selected, this may be -1.
	*/
	virtual void selectedRowsChanged (int lastRowSelected);

	/** Override this to be informed when the delete key is pressed.

		If no rows are selected when they press the key, this won't be called.

		@param lastRowSelected   the last row that had been selected when they pressed the
								 key - if there are multiple selections, this might not be
								 very useful
	*/
	virtual void deleteKeyPressed (int lastRowSelected);

	/** Override this to be informed when the return key is pressed.

		If no rows are selected when they press the key, this won't be called.

		@param lastRowSelected   the last row that had been selected when they pressed the
								 key - if there are multiple selections, this might not be
								  very useful
	*/
	virtual void returnKeyPressed (int lastRowSelected);

	/** Override this to be informed when the list is scrolled.

		This might be caused by the user moving the scrollbar, or by programmatic changes
		to the list position.
	*/
	virtual void listWasScrolled();

	/** To allow rows from your list to be dragged-and-dropped, implement this method.

		If this returns a non-null variant then when the user drags a row, the listbox will
		try to find a DragAndDropContainer in its parent hierarchy, and will use it to trigger
		a drag-and-drop operation, using this string as the source description, with the listbox
		itself as the source component.

		@see DragAndDropContainer::startDragging
	*/
	virtual var getDragSourceDescription (const SparseSet<int>& currentlySelectedRows);

	/** You can override this to provide tool tips for specific rows.
		@see TooltipClient
	*/
	virtual String getTooltipForRow (int row);
};

/**
	A list of items that can be scrolled vertically.

	To create a list, you'll need to create a subclass of ListBoxModel. This can
	either paint each row of the list and respond to events via callbacks, or for
	more specialised tasks, it can supply a custom component to fill each row.

	@see ComboBox, TableListBox
*/
class JUCE_API  ListBox  : public Component,
						   public SettableTooltipClient
{
public:

	/** Creates a ListBox.

		The model pointer passed-in can be null, in which case you can set it later
		with setModel().
	*/
	ListBox (const String& componentName = String::empty,
			 ListBoxModel* model = nullptr);

	/** Destructor. */
	~ListBox();

	/** Changes the current data model to display. */
	void setModel (ListBoxModel* newModel);

	/** Returns the current list model. */
	ListBoxModel* getModel() const noexcept                     { return model; }

	/** Causes the list to refresh its content.

		Call this when the number of rows in the list changes, or if you want it
		to call refreshComponentForRow() on all the row components.

		This must only be called from the main message thread.
	*/
	void updateContent();

	/** Turns on multiple-selection of rows.

		By default this is disabled.

		When your row component gets clicked you'll need to call the
		selectRowsBasedOnModifierKeys() method to tell the list that it's been
		clicked and to get it to do the appropriate selection based on whether
		the ctrl/shift keys are held down.
	*/
	void setMultipleSelectionEnabled (bool shouldBeEnabled);

	/** Makes the list react to mouse moves by selecting the row that the mouse if over.

		This function is here primarily for the ComboBox class to use, but might be
		useful for some other purpose too.
	*/
	void setMouseMoveSelectsRows (bool shouldSelect);

	/** Selects a row.

		If the row is already selected, this won't do anything.

		@param rowNumber                the row to select
		@param dontScrollToShowThisRow  if true, the list's position won't change; if false and
										the selected row is off-screen, it'll scroll to make
										sure that row is on-screen
		@param deselectOthersFirst      if true and there are multiple selections, these will
										first be deselected before this item is selected
		@see isRowSelected, selectRowsBasedOnModifierKeys, flipRowSelection, deselectRow,
			 deselectAllRows, selectRangeOfRows
	*/
	void selectRow (int rowNumber,
					bool dontScrollToShowThisRow = false,
					bool deselectOthersFirst = true);

	/** Selects a set of rows.

		This will add these rows to the current selection, so you might need to
		clear the current selection first with deselectAllRows()

		@param firstRow     the first row to select (inclusive)
		@param lastRow      the last row to select (inclusive)
	*/
	void selectRangeOfRows (int firstRow,
							int lastRow);

	/** Deselects a row.

		If it's not currently selected, this will do nothing.

		@see selectRow, deselectAllRows
	*/
	void deselectRow (int rowNumber);

	/** Deselects any currently selected rows.

		@see deselectRow
	*/
	void deselectAllRows();

	/** Selects or deselects a row.

		If the row's currently selected, this deselects it, and vice-versa.
	*/
	void flipRowSelection (int rowNumber);

	/** Returns a sparse set indicating the rows that are currently selected.
		@see setSelectedRows
	*/
	SparseSet<int> getSelectedRows() const;

	/** Sets the rows that should be selected, based on an explicit set of ranges.

		If sendNotificationEventToModel is true, the ListBoxModel::selectedRowsChanged()
		method will be called. If it's false, no notification will be sent to the model.

		@see getSelectedRows
	*/
	void setSelectedRows (const SparseSet<int>& setOfRowsToBeSelected,
						  bool sendNotificationEventToModel = true);

	/** Checks whether a row is selected.
	*/
	bool isRowSelected (int rowNumber) const;

	/** Returns the number of rows that are currently selected.

		@see getSelectedRow, isRowSelected, getLastRowSelected
	*/
	int getNumSelectedRows() const;

	/** Returns the row number of a selected row.

		This will return the row number of the Nth selected row. The row numbers returned will
		be sorted in order from low to high.

		@param index    the index of the selected row to return, (from 0 to getNumSelectedRows() - 1)
		@returns        the row number, or -1 if the index was out of range or if there aren't any rows
						selected
		@see getNumSelectedRows, isRowSelected, getLastRowSelected
	*/
	int getSelectedRow (int index = 0) const;

	/** Returns the last row that the user selected.

		This isn't the same as the highest row number that is currently selected - if the user
		had multiply-selected rows 10, 5 and then 6 in that order, this would return 6.

		If nothing is selected, it will return -1.
	*/
	int getLastRowSelected() const;

	/** Multiply-selects rows based on the modifier keys.

		If no modifier keys are down, this will select the given row and
		deselect any others.

		If the ctrl (or command on the Mac) key is down, it'll flip the
		state of the selected row.

		If the shift key is down, it'll select up to the given row from the
		last row selected.

		@see selectRow
	*/
	void selectRowsBasedOnModifierKeys (int rowThatWasClickedOn,
										const ModifierKeys& modifiers,
										bool isMouseUpEvent);

	/** Scrolls the list to a particular position.

		The proportion is between 0 and 1.0, so 0 scrolls to the top of the list,
		1.0 scrolls to the bottom.

		If the total number of rows all fit onto the screen at once, then this
		method won't do anything.

		@see getVerticalPosition
	*/
	void setVerticalPosition (double newProportion);

	/** Returns the current vertical position as a proportion of the total.

		This can be used in conjunction with setVerticalPosition() to save and restore
		the list's position. It returns a value in the range 0 to 1.

		@see setVerticalPosition
	*/
	double getVerticalPosition() const;

	/** Scrolls if necessary to make sure that a particular row is visible.
	*/
	void scrollToEnsureRowIsOnscreen (int row);

	/** Returns a pointer to the vertical scrollbar. */
	ScrollBar* getVerticalScrollBar() const noexcept;

	/** Returns a pointer to the horizontal scrollbar. */
	ScrollBar* getHorizontalScrollBar() const noexcept;

	/** Finds the row index that contains a given x,y position.
		The position is relative to the ListBox's top-left.
		If no row exists at this position, the method will return -1.
		@see getComponentForRowNumber
	*/
	int getRowContainingPosition (int x, int y) const noexcept;

	/** Finds a row index that would be the most suitable place to insert a new
		item for a given position.

		This is useful when the user is e.g. dragging and dropping onto the listbox,
		because it lets you easily choose the best position to insert the item that
		they drop, based on where they drop it.

		If the position is out of range, this will return -1. If the position is
		beyond the end of the list, it will return getNumRows() to indicate the end
		of the list.

		@see getComponentForRowNumber
	*/
	int getInsertionIndexForPosition (int x, int y) const noexcept;

	/** Returns the position of one of the rows, relative to the top-left of
		the listbox.

		This may be off-screen, and the range of the row number that is passed-in is
		not checked to see if it's a valid row.
	*/
	Rectangle<int> getRowPosition (int rowNumber,
								   bool relativeToComponentTopLeft) const noexcept;

	/** Finds the row component for a given row in the list.

		The component returned will have been created using createRowComponent().

		If the component for this row is off-screen or if the row is out-of-range,
		this will return 0.

		@see getRowContainingPosition
	*/
	Component* getComponentForRowNumber (int rowNumber) const noexcept;

	/** Returns the row number that the given component represents.
		If the component isn't one of the list's rows, this will return -1.
	*/
	int getRowNumberOfComponent (Component* rowComponent) const noexcept;

	/** Returns the width of a row (which may be less than the width of this component
		if there's a scrollbar).
	*/
	int getVisibleRowWidth() const noexcept;

	/** Sets the height of each row in the list.
		The default height is 22 pixels.
		@see getRowHeight
	*/
	void setRowHeight (int newHeight);

	/** Returns the height of a row in the list.
		@see setRowHeight
	*/
	int getRowHeight() const noexcept                   { return rowHeight; }

	/** Returns the number of rows actually visible.

		This is the number of whole rows which will fit on-screen, so the value might
		be more than the actual number of rows in the list.
	*/
	int getNumRowsOnScreen() const noexcept;

	/** A set of colour IDs to use to change the colour of various aspects of the label.

		These constants can be used either via the Component::setColour(), or LookAndFeel::setColour()
		methods.

		@see Component::setColour, Component::findColour, LookAndFeel::setColour, LookAndFeel::findColour
	*/
	enum ColourIds
	{
		backgroundColourId      = 0x1002800, /**< The background colour to fill the list with.
												  Make this transparent if you don't want the background to be filled. */
		outlineColourId         = 0x1002810, /**< An optional colour to use to draw a border around the list.
												  Make this transparent to not have an outline. */
		textColourId            = 0x1002820  /**< The preferred colour to use for drawing text in the listbox. */
	};

	/** Sets the thickness of a border that will be drawn around the box.

		To set the colour of the outline, use @code setColour (ListBox::outlineColourId, colourXYZ); @endcode
		@see outlineColourId
	*/
	void setOutlineThickness (int outlineThickness);

	/** Returns the thickness of outline that will be drawn around the listbox.

		@see setOutlineColour
	*/
	int getOutlineThickness() const noexcept            { return outlineThickness; }

	/** Sets a component that the list should use as a header.

		This will position the given component at the top of the list, maintaining the
		height of the component passed-in, but rescaling it horizontally to match the
		width of the items in the listbox.

		The component will be deleted when setHeaderComponent() is called with a
		different component, or when the listbox is deleted.
	*/
	void setHeaderComponent (Component* newHeaderComponent);

	/** Changes the width of the rows in the list.

		This can be used to make the list's row components wider than the list itself - the
		width of the rows will be either the width of the list or this value, whichever is
		greater, and if the rows become wider than the list, a horizontal scrollbar will
		appear.

		The default value for this is 0, which means that the rows will always
		be the same width as the list.
	*/
	void setMinimumContentWidth (int newMinimumWidth);

	/** Returns the space currently available for the row items, taking into account
		borders, scrollbars, etc.
	*/
	int getVisibleContentWidth() const noexcept;

	/** Repaints one of the rows.

		This does not invoke updateContent(), it just invokes a straightforward repaint
		for the area covered by this row.
	*/
	void repaintRow (int rowNumber) noexcept;

	/** This fairly obscure method creates an image that just shows the currently
		selected row components.

		It's a handy method for doing drag-and-drop, as it can be passed to the
		DragAndDropContainer for use as the drag image.

		Note that it will make the row components temporarily invisible, so if you're
		using custom components this could affect them if they're sensitive to that
		sort of thing.

		@see Component::createComponentSnapshot
	*/
	virtual Image createSnapshotOfSelectedRows (int& x, int& y);

	/** Returns the viewport that this ListBox uses.

		You may need to use this to change parameters such as whether scrollbars
		are shown, etc.
	*/
	Viewport* getViewport() const noexcept;

	struct Ids
	{
		static const Identifier rowHeight, borderThickness;
	};

	void refreshFromValueTree (const ValueTree&, ComponentBuilder&);

	/** @internal */
	bool keyPressed (const KeyPress&);
	/** @internal */
	bool keyStateChanged (bool isKeyDown);
	/** @internal */
	void paint (Graphics&);
	/** @internal */
	void paintOverChildren (Graphics&);
	/** @internal */
	void resized();
	/** @internal */
	void visibilityChanged();
	/** @internal */
	void mouseWheelMove (const MouseEvent&, float wheelIncrementX, float wheelIncrementY);
	/** @internal */
	void mouseMove (const MouseEvent&);
	/** @internal */
	void mouseExit (const MouseEvent&);
	/** @internal */
	void mouseUp (const MouseEvent&);
	/** @internal */
	void colourChanged();
	/** @internal */
	void startDragAndDrop (const MouseEvent&, const var& dragDescription, bool allowDraggingToOtherWindows);

private:

	class ListViewport;
	friend class ListViewport;
	friend class TableListBox;
	ListBoxModel* model;
	ScopedPointer<ListViewport> viewport;
	ScopedPointer<Component> headerComponent;
	int totalItems, rowHeight, minimumRowWidth;
	int outlineThickness;
	int lastRowSelected;
	bool mouseMoveSelects, multipleSelection, hasDoneInitialUpdate;
	SparseSet <int> selected;

	void selectRowInternal (int rowNumber, bool dontScrollToShowThisRow,
							bool deselectOthersFirst, bool isMouseClick);

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ListBox);
};

#endif   // __JUCE_LISTBOX_JUCEHEADER__

/*** End of inlined file: juce_ListBox.h ***/


/*** Start of inlined file: juce_TreeView.h ***/
#ifndef __JUCE_TREEVIEW_JUCEHEADER__
#define __JUCE_TREEVIEW_JUCEHEADER__

class TreeView;

/**
	An item in a treeview.

	A TreeViewItem can either be a leaf-node in the tree, or it can contain its
	own sub-items.

	To implement an item that contains sub-items, override the itemOpennessChanged()
	method so that when it is opened, it adds the new sub-items to itself using the
	addSubItem method. Depending on the nature of the item it might choose to only
	do this the first time it's opened, or it might want to refresh itself each time.
	It also has the option of deleting its sub-items when it is closed, or leaving them
	in place.
*/
class JUCE_API  TreeViewItem
{
public:

	/** Constructor. */
	TreeViewItem();

	/** Destructor. */
	virtual ~TreeViewItem();

	/** Returns the number of sub-items that have been added to this item.

		Note that this doesn't mean much if the node isn't open.

		@see getSubItem, mightContainSubItems, addSubItem
	*/
	int getNumSubItems() const noexcept;

	/** Returns one of the item's sub-items.

		Remember that the object returned might get deleted at any time when its parent
		item is closed or refreshed, depending on the nature of the items you're using.

		@see getNumSubItems
	*/
	TreeViewItem* getSubItem (int index) const noexcept;

	/** Removes any sub-items. */
	void clearSubItems();

	/** Adds a sub-item.

		@param newItem  the object to add to the item's sub-item list. Once added, these can be
						found using getSubItem(). When the items are later removed with
						removeSubItem() (or when this item is deleted), they will be deleted.
		@param insertPosition   the index which the new item should have when it's added. If this
								value is less than 0, the item will be added to the end of the list.
	*/
	void addSubItem (TreeViewItem* newItem, int insertPosition = -1);

	/** Removes one of the sub-items.

		@param index        the item to remove
		@param deleteItem   if true, the item that is removed will also be deleted.
	*/
	void removeSubItem (int index, bool deleteItem = true);

	/** Returns the TreeView to which this item belongs. */
	TreeView* getOwnerView() const noexcept             { return ownerView; }

	/** Returns the item within which this item is contained. */
	TreeViewItem* getParentItem() const noexcept        { return parentItem; }

	/** True if this item is currently open in the treeview. */
	bool isOpen() const noexcept;

	/** Opens or closes the item.

		When opened or closed, the item's itemOpennessChanged() method will be called,
		and a subclass should use this callback to create and add any sub-items that
		it needs to.

		@see itemOpennessChanged, mightContainSubItems
	*/
	void setOpen (bool shouldBeOpen);

	/** True if this item is currently selected.

		Use this when painting the node, to decide whether to draw it as selected or not.
	*/
	bool isSelected() const noexcept;

	/** Selects or deselects the item.

		This will cause a callback to itemSelectionChanged()
	*/
	void setSelected (bool shouldBeSelected,
					  bool deselectOtherItemsFirst);

	/** Returns the rectangle that this item occupies.

		If relativeToTreeViewTopLeft is true, the co-ordinates are relative to the
		top-left of the TreeView comp, so this will depend on the scroll-position of
		the tree. If false, it is relative to the top-left of the topmost item in the
		tree (so this would be unaffected by scrolling the view).
	*/
	Rectangle<int> getItemPosition (bool relativeToTreeViewTopLeft) const noexcept;

	/** Sends a signal to the treeview to make it refresh itself.

		Call this if your items have changed and you want the tree to update to reflect
		this.
	*/
	void treeHasChanged() const noexcept;

	/** Sends a repaint message to redraw just this item.

		Note that you should only call this if you want to repaint a superficial change. If
		you're altering the tree's nodes, you should instead call treeHasChanged().
	*/
	void repaintItem() const;

	/** Returns the row number of this item in the tree.

		The row number of an item will change according to which items are open.

		@see TreeView::getNumRowsInTree(), TreeView::getItemOnRow()
	*/
	int getRowNumberInTree() const noexcept;

	/** Returns true if all the item's parent nodes are open.

		This is useful to check whether the item might actually be visible or not.
	*/
	bool areAllParentsOpen() const noexcept;

	/** Changes whether lines are drawn to connect any sub-items to this item.

		By default, line-drawing is turned on.
	*/
	void setLinesDrawnForSubItems (bool shouldDrawLines) noexcept;

	/** Tells the tree whether this item can potentially be opened.

		If your item could contain sub-items, this should return true; if it returns
		false then the tree will not try to open the item. This determines whether or
		not the item will be drawn with a 'plus' button next to it.
	*/
	virtual bool mightContainSubItems() = 0;

	/** Returns a string to uniquely identify this item.

		If you're planning on using the TreeView::getOpennessState() method, then
		these strings will be used to identify which nodes are open. The string
		should be unique amongst the item's sibling items, but it's ok for there
		to be duplicates at other levels of the tree.

		If you're not going to store the state, then it's ok not to bother implementing
		this method.
	*/
	virtual String getUniqueName() const;

	/** Called when an item is opened or closed.

		When setOpen() is called and the item has specified that it might
		have sub-items with the mightContainSubItems() method, this method
		is called to let the item create or manage its sub-items.

		So when this is called with isNowOpen set to true (i.e. when the item is being
		opened), a subclass might choose to use clearSubItems() and addSubItem() to
		refresh its sub-item list.

		When this is called with isNowOpen set to false, the subclass might want
		to use clearSubItems() to save on space, or it might choose to leave them,
		depending on the nature of the tree.

		You could also use this callback as a trigger to start a background process
		which asynchronously creates sub-items and adds them, if that's more
		appropriate for the task in hand.

		@see mightContainSubItems
	*/
	virtual void itemOpennessChanged (bool isNowOpen);

	/** Must return the width required by this item.

		If your item needs to have a particular width in pixels, return that value; if
		you'd rather have it just fill whatever space is available in the treeview,
		return -1.

		If all your items return -1, no horizontal scrollbar will be shown, but if any
		items have fixed widths and extend beyond the width of the treeview, a
		scrollbar will appear.

		Each item can be a different width, but if they change width, you should call
		treeHasChanged() to update the tree.
	*/
	virtual int getItemWidth() const                                { return -1; }

	/** Must return the height required by this item.

		This is the height in pixels that the item will take up. Items in the tree
		can be different heights, but if they change height, you should call
		treeHasChanged() to update the tree.
	*/
	virtual int getItemHeight() const                               { return 20; }

	/** You can override this method to return false if you don't want to allow the
		user to select this item.
	*/
	virtual bool canBeSelected() const                              { return true; }

	/** Creates a component that will be used to represent this item.

		You don't have to implement this method - if it returns 0 then no component
		will be used for the item, and you can just draw it using the paintItem()
		callback. But if you do return a component, it will be positioned in the
		treeview so that it can be used to represent this item.

		The component returned will be managed by the treeview, so always return
		a new component, and don't keep a reference to it, as the treeview will
		delete it later when it goes off the screen or is no longer needed. Also
		bear in mind that if the component keeps a reference to the item that
		created it, that item could be deleted before the component. Its position
		and size will be completely managed by the tree, so don't attempt to move it
		around.

		Something you may want to do with your component is to give it a pointer to
		the TreeView that created it. This is perfectly safe, and there's no danger
		of it becoming a dangling pointer because the TreeView will always delete
		the component before it is itself deleted.

		As long as you stick to these rules you can return whatever kind of
		component you like. It's most useful if you're doing things like drag-and-drop
		of items, or want to use a Label component to edit item names, etc.
	*/
	virtual Component* createItemComponent()                        { return nullptr; }

	/** Draws the item's contents.

		You can choose to either implement this method and draw each item, or you
		can use createItemComponent() to create a component that will represent the
		item.

		If all you need in your tree is to be able to draw the items and detect when
		the user selects or double-clicks one of them, it's probably enough to
		use paintItem(), itemClicked() and itemDoubleClicked(). If you need more
		complicated interactions, you may need to use createItemComponent() instead.

		@param g        the graphics context to draw into
		@param width    the width of the area available for drawing
		@param height   the height of the area available for drawing
	*/
	virtual void paintItem (Graphics& g, int width, int height);

	/** Draws the item's open/close button.

		If you don't implement this method, the default behaviour is to
		call LookAndFeel::drawTreeviewPlusMinusBox(), but you can override
		it for custom effects.
	*/
	virtual void paintOpenCloseButton (Graphics& g, int width, int height, bool isMouseOver);

	/** Called when the user clicks on this item.

		If you're using createItemComponent() to create a custom component for the
		item, the mouse-clicks might not make it through to the treeview, but this
		is how you find out about clicks when just drawing each item individually.

		The associated mouse-event details are passed in, so you can find out about
		which button, where it was, etc.

		@see itemDoubleClicked
	*/
	virtual void itemClicked (const MouseEvent& e);

	/** Called when the user double-clicks on this item.

		If you're using createItemComponent() to create a custom component for the
		item, the mouse-clicks might not make it through to the treeview, but this
		is how you find out about clicks when just drawing each item individually.

		The associated mouse-event details are passed in, so you can find out about
		which button, where it was, etc.

		If not overridden, the base class method here will open or close the item as
		if the 'plus' button had been clicked.

		@see itemClicked
	*/
	virtual void itemDoubleClicked (const MouseEvent& e);

	/** Called when the item is selected or deselected.

		Use this if you want to do something special when the item's selectedness
		changes. By default it'll get repainted when this happens.
	*/
	virtual void itemSelectionChanged (bool isNowSelected);

	/** The item can return a tool tip string here if it wants to.
		@see TooltipClient
	*/
	virtual String getTooltip();

	/** To allow items from your treeview to be dragged-and-dropped, implement this method.

		If this returns a non-null variant then when the user drags an item, the treeview will
		try to find a DragAndDropContainer in its parent hierarchy, and will use it to trigger
		a drag-and-drop operation, using this string as the source description, with the treeview
		itself as the source component.

		If you need more complex drag-and-drop behaviour, you can use custom components for
		the items, and use those to trigger the drag.

		To accept drag-and-drop in your tree, see isInterestedInDragSource(),
		isInterestedInFileDrag(), etc.

		@see DragAndDropContainer::startDragging
	*/
	virtual var getDragSourceDescription();

	/** If you want your item to be able to have files drag-and-dropped onto it, implement this
		method and return true.

		If you return true and allow some files to be dropped, you'll also need to implement the
		filesDropped() method to do something with them.

		Note that this will be called often, so make your implementation very quick! There's
		certainly no time to try opening the files and having a think about what's inside them!

		For responding to internal drag-and-drop of other types of object, see isInterestedInDragSource().
		@see FileDragAndDropTarget::isInterestedInFileDrag, isInterestedInDragSource
	*/
	virtual bool isInterestedInFileDrag (const StringArray& files);

	/** When files are dropped into this item, this callback is invoked.

		For this to work, you'll need to have also implemented isInterestedInFileDrag().
		The insertIndex value indicates where in the list of sub-items the files were dropped.
		If files are dropped onto an area of the tree where there are no visible items, this
		method is called on the root item of the tree, with an insert index of 0.
		@see FileDragAndDropTarget::filesDropped, isInterestedInFileDrag
	*/
	virtual void filesDropped (const StringArray& files, int insertIndex);

	/** If you want your item to act as a DragAndDropTarget, implement this method and return true.

		If you implement this method, you'll also need to implement itemDropped() in order to handle
		the items when they are dropped.
		To respond to drag-and-drop of files from external applications, see isInterestedInFileDrag().
		@see DragAndDropTarget::isInterestedInDragSource, itemDropped
	*/
	virtual bool isInterestedInDragSource (const DragAndDropTarget::SourceDetails& dragSourceDetails);

	/** When a things are dropped into this item, this callback is invoked.

		For this to work, you need to have also implemented isInterestedInDragSource().
		The insertIndex value indicates where in the list of sub-items the new items should be placed.
		If files are dropped onto an area of the tree where there are no visible items, this
		method is called on the root item of the tree, with an insert index of 0.
		@see isInterestedInDragSource, DragAndDropTarget::itemDropped
	*/
	virtual void itemDropped (const DragAndDropTarget::SourceDetails& dragSourceDetails, int insertIndex);

	/** Sets a flag to indicate that the item wants to be allowed
		to draw all the way across to the left edge of the treeview.

		By default this is false, which means that when the paintItem()
		method is called, its graphics context is clipped to only allow
		drawing within the item's rectangle. If this flag is set to true,
		then the graphics context isn't clipped on its left side, so it
		can draw all the way across to the left margin. Note that the
		context will still have its origin in the same place though, so
		the coordinates of anything to its left will be negative. It's
		mostly useful if you want to draw a wider bar behind the
		highlighted item.
	*/
	void setDrawsInLeftMargin (bool canDrawInLeftMargin) noexcept;

	/** Saves the current state of open/closed nodes so it can be restored later.

		This takes a snapshot of which sub-nodes have been explicitly opened or closed,
		and records it as XML. To identify node objects it uses the
		TreeViewItem::getUniqueName() method to create named paths. This
		means that the same state of open/closed nodes can be restored to a
		completely different instance of the tree, as long as it contains nodes
		whose unique names are the same.

		You'd normally want to use TreeView::getOpennessState() rather than call it
		for a specific item, but this can be handy if you need to briefly save the state
		for a section of the tree.

		The caller is responsible for deleting the object that is returned.
		@see TreeView::getOpennessState, restoreOpennessState
	*/
	XmlElement* getOpennessState() const noexcept;

	/** Restores the openness of this item and all its sub-items from a saved state.

		See TreeView::restoreOpennessState for more details.

		You'd normally want to use TreeView::restoreOpennessState() rather than call it
		for a specific item, but this can be handy if you need to briefly save the state
		for a section of the tree.

		@see TreeView::restoreOpennessState, getOpennessState
	*/
	void restoreOpennessState (const XmlElement& xml) noexcept;

	/** Returns the index of this item in its parent's sub-items. */
	int getIndexInParent() const noexcept;

	/** Returns true if this item is the last of its parent's sub-itens. */
	bool isLastOfSiblings() const noexcept;

	/** Creates a string that can be used to uniquely retrieve this item in the tree.

		The string that is returned can be passed to TreeView::findItemFromIdentifierString().
		The string takes the form of a path, constructed from the getUniqueName() of this
		item and all its parents, so these must all be correctly implemented for it to work.
		@see TreeView::findItemFromIdentifierString, getUniqueName
	*/
	String getItemIdentifierString() const;

	/**
		This handy class takes a copy of a TreeViewItem's openness when you create it,
		and restores that openness state when its destructor is called.

		This can very handy when you're refreshing sub-items - e.g.
		@code
		void MyTreeViewItem::updateChildItems()
		{
			OpennessRestorer openness (*this);  //  saves the openness state here..

			clearSubItems();

			// add a bunch of sub-items here which may or may not be the same as the ones that
			// were previously there
			addSubItem (...

			// ..and at this point, the old openness is restored, so any items that haven't
			// changed will have their old openness retained.
		}
		@endcode
	*/
	class OpennessRestorer
	{
	public:
		OpennessRestorer (TreeViewItem& treeViewItem);
		~OpennessRestorer();

	private:
		TreeViewItem& treeViewItem;
		ScopedPointer <XmlElement> oldOpenness;

		JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (OpennessRestorer);
	};

private:

	TreeView* ownerView;
	TreeViewItem* parentItem;
	OwnedArray <TreeViewItem> subItems;
	int y, itemHeight, totalHeight, itemWidth, totalWidth;
	int uid;
	bool selected           : 1;
	bool redrawNeeded       : 1;
	bool drawLinesInside    : 1;
	bool drawsInLeftMargin  : 1;
	unsigned int openness   : 2;

	friend class TreeView;
	friend class TreeViewContentComponent;

	void updatePositions (int newY);
	int getIndentX() const noexcept;
	void setOwnerView (TreeView*) noexcept;
	void paintRecursively (Graphics&, int width);
	TreeViewItem* getTopLevelItem() noexcept;
	TreeViewItem* findItemRecursively (int y) noexcept;
	TreeViewItem* getDeepestOpenParentItem() noexcept;
	int getNumRows() const noexcept;
	TreeViewItem* getItemOnRow (int index) noexcept;
	void deselectAllRecursively();
	int countSelectedItemsRecursively (int depth) const noexcept;
	TreeViewItem* getSelectedItemWithIndex (int index) noexcept;
	TreeViewItem* getNextVisibleItem (bool recurse) const noexcept;
	TreeViewItem* findItemFromIdentifierString (const String&);

   #if JUCE_CATCH_DEPRECATED_CODE_MISUSE
	// The parameters for these methods have changed - please update your code!
	virtual void isInterestedInDragSource (const String&, Component*) {}
	virtual int itemDropped (const String&, Component*, int) { return 0; }
   #endif

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (TreeViewItem);
};

/**
	A tree-view component.

	Use one of these to hold and display a structure of TreeViewItem objects.

*/
class JUCE_API  TreeView  : public Component,
							public SettableTooltipClient,
							public FileDragAndDropTarget,
							public DragAndDropTarget
{
public:

	/** Creates an empty treeview.

		Once you've got a treeview component, you'll need to give it something to
		display, using the setRootItem() method.
	*/
	TreeView (const String& componentName = String::empty);

	/** Destructor. */
	~TreeView();

	/** Sets the item that is displayed in the treeview.

		A tree has a single root item which contains as many sub-items as it needs. If
		you want the tree to contain a number of root items, you should still use a single
		root item above these, but hide it using setRootItemVisible().

		You can pass in 0 to this method to clear the tree and remove its current root item.

		The object passed in will not be deleted by the treeview, it's up to the caller
		to delete it when no longer needed. BUT make absolutely sure that you don't delete
		this item until you've removed it from the tree, either by calling setRootItem (nullptr),
		or by deleting the tree first. You can also use deleteRootItem() as a quick way
		to delete it.
	*/
	void setRootItem (TreeViewItem* newRootItem);

	/** Returns the tree's root item.

		This will be the last object passed to setRootItem(), or 0 if none has been set.
	*/
	TreeViewItem* getRootItem() const noexcept                      { return rootItem; }

	/** This will remove and delete the current root item.

		It's a convenient way of deleting the item and calling setRootItem (nullptr).
	*/
	void deleteRootItem();

	/** Changes whether the tree's root item is shown or not.

		If the root item is hidden, only its sub-items will be shown in the treeview - this
		lets you make the tree look as if it's got many root items. If it's hidden, this call
		will also make sure the root item is open (otherwise the treeview would look empty).
	*/
	void setRootItemVisible (bool shouldBeVisible);

	/** Returns true if the root item is visible.

		@see setRootItemVisible
	*/
	bool isRootItemVisible() const noexcept                         { return rootItemVisible; }

	/** Sets whether items are open or closed by default.

		Normally, items are closed until the user opens them, but you can use this
		to make them default to being open until explicitly closed.

		@see areItemsOpenByDefault
	*/
	void setDefaultOpenness (bool isOpenByDefault);

	/** Returns true if the tree's items default to being open.

		@see setDefaultOpenness
	*/
	bool areItemsOpenByDefault() const noexcept                     { return defaultOpenness; }

	/** This sets a flag to indicate that the tree can be used for multi-selection.

		You can always select multiple items internally by calling the
		TreeViewItem::setSelected() method, but this flag indicates whether the user
		is allowed to multi-select by clicking on the tree.

		By default it is disabled.

		@see isMultiSelectEnabled
	*/
	void setMultiSelectEnabled (bool canMultiSelect);

	/** Returns whether multi-select has been enabled for the tree.

		@see setMultiSelectEnabled
	*/
	bool isMultiSelectEnabled() const noexcept                      { return multiSelectEnabled; }

	/** Sets a flag to indicate whether to hide the open/close buttons.

		@see areOpenCloseButtonsVisible
	*/
	void setOpenCloseButtonsVisible (bool shouldBeVisible);

	/** Returns whether open/close buttons are shown.

		@see setOpenCloseButtonsVisible
	*/
	bool areOpenCloseButtonsVisible() const noexcept                { return openCloseButtonsVisible; }

	/** Deselects any items that are currently selected. */
	void clearSelectedItems();

	/** Returns the number of items that are currently selected.
		If maximumDepthToSearchTo is >= 0, it lets you specify a maximum depth to which the
		tree will be recursed.
		@see getSelectedItem, clearSelectedItems
	*/
	int getNumSelectedItems (int maximumDepthToSearchTo = -1) const noexcept;

	/** Returns one of the selected items in the tree.

		@param index    the index, 0 to (getNumSelectedItems() - 1)
	*/
	TreeViewItem* getSelectedItem (int index) const noexcept;

	/** Returns the number of rows the tree is using.

		This will depend on which items are open.

		@see TreeViewItem::getRowNumberInTree()
	*/
	int getNumRowsInTree() const;

	/** Returns the item on a particular row of the tree.

		If the index is out of range, this will return 0.

		@see getNumRowsInTree, TreeViewItem::getRowNumberInTree()
	*/
	TreeViewItem* getItemOnRow (int index) const;

	/** Returns the item that contains a given y position.
		The y is relative to the top of the TreeView component.
	*/
	TreeViewItem* getItemAt (int yPosition) const noexcept;

	/** Tries to scroll the tree so that this item is on-screen somewhere. */
	void scrollToKeepItemVisible (TreeViewItem* item);

	/** Returns the treeview's Viewport object. */
	Viewport* getViewport() const noexcept;

	/** Returns the number of pixels by which each nested level of the tree is indented.
		@see setIndentSize
	*/
	int getIndentSize() const noexcept                              { return indentSize; }

	/** Changes the distance by which each nested level of the tree is indented.
		@see getIndentSize
	*/
	void setIndentSize (int newIndentSize);

	/** Searches the tree for an item with the specified identifier.
		The identifer string must have been created by calling TreeViewItem::getItemIdentifierString().
		If no such item exists, this will return false. If the item is found, all of its items
		will be automatically opened.
	*/
	TreeViewItem* findItemFromIdentifierString (const String& identifierString) const;

	/** Saves the current state of open/closed nodes so it can be restored later.

		This takes a snapshot of which nodes have been explicitly opened or closed,
		and records it as XML. To identify node objects it uses the
		TreeViewItem::getUniqueName() method to create named paths. This
		means that the same state of open/closed nodes can be restored to a
		completely different instance of the tree, as long as it contains nodes
		whose unique names are the same.

		The caller is responsible for deleting the object that is returned.

		@param alsoIncludeScrollPosition    if this is true, the state will also
											include information about where the
											tree has been scrolled to vertically,
											so this can also be restored
		@see restoreOpennessState
	*/
	XmlElement* getOpennessState (bool alsoIncludeScrollPosition) const;

	/** Restores a previously saved arrangement of open/closed nodes.

		This will try to restore a snapshot of the tree's state that was created by
		the getOpennessState() method. If any of the nodes named in the original
		XML aren't present in this tree, they will be ignored.

		If restoreStoredSelection is true, it will also try to re-select any items that
		were selected in the stored state.

		@see getOpennessState
	*/
	void restoreOpennessState (const XmlElement& newState,
							   bool restoreStoredSelection);

	/** A set of colour IDs to use to change the colour of various aspects of the treeview.

		These constants can be used either via the Component::setColour(), or LookAndFeel::setColour()
		methods.

		@see Component::setColour, Component::findColour, LookAndFeel::setColour, LookAndFeel::findColour
	*/
	enum ColourIds
	{
		backgroundColourId            = 0x1000500, /**< A background colour to fill the component with. */
		linesColourId                 = 0x1000501, /**< The colour to draw the lines with.*/
		dragAndDropIndicatorColourId  = 0x1000502  /**< The colour to use for the drag-and-drop target position indicator. */
	};

	/** @internal */
	void paint (Graphics& g);
	/** @internal */
	void resized();
	/** @internal */
	bool keyPressed (const KeyPress& key);
	/** @internal */
	void colourChanged();
	/** @internal */
	void enablementChanged();
	/** @internal */
	bool isInterestedInFileDrag (const StringArray& files);
	/** @internal */
	void fileDragEnter (const StringArray& files, int x, int y);
	/** @internal */
	void fileDragMove (const StringArray& files, int x, int y);
	/** @internal */
	void fileDragExit (const StringArray& files);
	/** @internal */
	void filesDropped (const StringArray& files, int x, int y);
	/** @internal */
	bool isInterestedInDragSource (const SourceDetails&);
	/** @internal */
	void itemDragEnter (const SourceDetails&);
	/** @internal */
	void itemDragMove (const SourceDetails&);
	/** @internal */
	void itemDragExit (const SourceDetails&);
	/** @internal */
	void itemDropped (const SourceDetails&);

private:
	friend class TreeViewItem;
	friend class TreeViewContentComponent;
	class TreeViewport;
	class InsertPointHighlight;
	class TargetGroupHighlight;
	friend class ScopedPointer<TreeViewport>;
	friend class ScopedPointer<InsertPointHighlight>;
	friend class ScopedPointer<TargetGroupHighlight>;
	ScopedPointer<TreeViewport> viewport;
	CriticalSection nodeAlterationLock;
	TreeViewItem* rootItem;
	ScopedPointer<InsertPointHighlight> dragInsertPointHighlight;
	ScopedPointer<TargetGroupHighlight> dragTargetGroupHighlight;
	int indentSize;
	bool defaultOpenness : 1;
	bool needsRecalculating : 1;
	bool rootItemVisible : 1;
	bool multiSelectEnabled : 1;
	bool openCloseButtonsVisible : 1;

	void itemsChanged() noexcept;
	void recalculateIfNeeded();
	void moveSelectedRow (int delta);
	void updateButtonUnderMouse (const MouseEvent&);
	void showDragHighlight (TreeViewItem*, int insertIndex, int x, int y) noexcept;
	void hideDragHighlight() noexcept;
	void handleDrag (const StringArray& files, const SourceDetails&);
	void handleDrop (const StringArray& files, const SourceDetails&);
	TreeViewItem* getInsertPosition (int& x, int& y, int& insertIndex,
									 const StringArray& files, const SourceDetails&) const noexcept;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (TreeView);
};

#endif   // __JUCE_TREEVIEW_JUCEHEADER__

/*** End of inlined file: juce_TreeView.h ***/

/**
	A component that displays the files in a directory as a listbox.

	This implements the DirectoryContentsDisplayComponent base class so that
	it can be used in a FileBrowserComponent.

	To attach a listener to it, use its DirectoryContentsDisplayComponent base
	class and the FileBrowserListener class.

	@see DirectoryContentsList, FileTreeComponent
*/
class JUCE_API  FileListComponent  : public ListBox,
									 public DirectoryContentsDisplayComponent,
									 private ListBoxModel,
									 private ChangeListener
{
public:

	/** Creates a listbox to show the contents of a specified directory.
	*/
	FileListComponent (DirectoryContentsList& listToShow);

	/** Destructor. */
	~FileListComponent();

	/** Returns the number of files the user has got selected.
		@see getSelectedFile
	*/
	int getNumSelectedFiles() const;

	/** Returns one of the files that the user has currently selected.
		The index should be in the range 0 to (getNumSelectedFiles() - 1).
		@see getNumSelectedFiles
	*/
	File getSelectedFile (int index = 0) const;

	/** Deselects any files that are currently selected. */
	void deselectAllFiles();

	/** Scrolls to the top of the list. */
	void scrollToTop();

	/** If the specified file is in the list, it will become the only selected item
		(and if the file isn't in the list, all other items will be deselected). */
	void setSelectedFile (const File&);

	/** @internal */
	void changeListenerCallback (ChangeBroadcaster*);
	/** @internal */
	int getNumRows();
	/** @internal */
	void paintListBoxItem (int, Graphics&, int, int, bool);
	/** @internal */
	Component* refreshComponentForRow (int rowNumber, bool isRowSelected, Component* existingComponentToUpdate);
	/** @internal */
	void selectedRowsChanged (int lastRowSelected);
	/** @internal */
	void deleteKeyPressed (int currentSelectedRow);
	/** @internal */
	void returnKeyPressed (int currentSelectedRow);

private:

	File lastDirectory;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (FileListComponent);
};

#endif   // __JUCE_FILELISTCOMPONENT_JUCEHEADER__

/*** End of inlined file: juce_FileListComponent.h ***/


#endif
#ifndef __JUCE_FILENAMECOMPONENT_JUCEHEADER__

/*** Start of inlined file: juce_FilenameComponent.h ***/
#ifndef __JUCE_FILENAMECOMPONENT_JUCEHEADER__
#define __JUCE_FILENAMECOMPONENT_JUCEHEADER__

class FilenameComponent;

/**
	Listens for events happening to a FilenameComponent.

	Use FilenameComponent::addListener() and FilenameComponent::removeListener() to
	register one of these objects for event callbacks when the filename is changed.

	@see FilenameComponent
*/
class JUCE_API  FilenameComponentListener
{
public:
	/** Destructor. */
	virtual ~FilenameComponentListener() {}

	/** This method is called after the FilenameComponent's file has been changed. */
	virtual void filenameComponentChanged (FilenameComponent* fileComponentThatHasChanged) = 0;
};

/**
	Shows a filename as an editable text box, with a 'browse' button and a
	drop-down list for recently selected files.

	A handy component for dialogue boxes where you want the user to be able to
	select a file or directory.

	Attach an FilenameComponentListener using the addListener() method, and it will
	get called each time the user changes the filename, either by browsing for a file
	and clicking 'ok', or by typing a new filename into the box and pressing return.

	@see FileChooser, ComboBox
*/
class JUCE_API  FilenameComponent  : public Component,
									 public SettableTooltipClient,
									 public FileDragAndDropTarget,
									 private AsyncUpdater,
									 private ButtonListener,  // (can't use Button::Listener due to idiotic VC2005 bug)
									 private ComboBoxListener
{
public:

	/** Creates a FilenameComponent.

		@param name             the name for this component.
		@param currentFile      the file to initially show in the box
		@param canEditFilename  if true, the user can manually edit the filename; if false,
								they can only change it by browsing for a new file
		@param isDirectory      if true, the file will be treated as a directory, and
								an appropriate directory browser used
		@param isForSaving      if true, the file browser will allow non-existent files to
								be picked, as the file is assumed to be used for saving rather
								than loading
		@param fileBrowserWildcard  a wildcard pattern to use in the file browser - e.g. "*.txt;*.foo".
								If an empty string is passed in, then the pattern is assumed to be "*"
		@param enforcedSuffix   if this is non-empty, it is treated as a suffix that will be added
								to any filenames that are entered or chosen
		@param textWhenNothingSelected  the message to display in the box before any filename is entered. (This
								will only appear if the initial file isn't valid)
	*/
	FilenameComponent (const String& name,
					   const File& currentFile,
					   bool canEditFilename,
					   bool isDirectory,
					   bool isForSaving,
					   const String& fileBrowserWildcard,
					   const String& enforcedSuffix,
					   const String& textWhenNothingSelected);

	/** Destructor. */
	~FilenameComponent();

	/** Returns the currently displayed filename. */
	File getCurrentFile() const;

	/** Changes the current filename.

		If addToRecentlyUsedList is true, the filename will also be added to the
		drop-down list of recent files.

		If sendChangeNotification is false, then the listeners won't be told of the
		change.
	*/
	void setCurrentFile (File newFile,
						 bool addToRecentlyUsedList,
						 bool sendChangeNotification = true);

	/** Changes whether the use can type into the filename box.
	*/
	void setFilenameIsEditable (bool shouldBeEditable);

	/** Sets a file or directory to be the default starting point for the browser to show.

		This is only used if the current file hasn't been set.
	*/
	void setDefaultBrowseTarget (const File& newDefaultDirectory);

	/** Returns all the entries on the recent files list.

		This can be used in conjunction with setRecentlyUsedFilenames() for saving the
		state of this list.

		@see setRecentlyUsedFilenames
	*/
	StringArray getRecentlyUsedFilenames() const;

	/** Sets all the entries on the recent files list.

		This can be used in conjunction with getRecentlyUsedFilenames() for saving the
		state of this list.

		@see getRecentlyUsedFilenames, addRecentlyUsedFile
	*/
	void setRecentlyUsedFilenames (const StringArray& filenames);

	/** Adds an entry to the recently-used files dropdown list.

		If the file is already in the list, it will be moved to the top. A limit
		is also placed on the number of items that are kept in the list.

		@see getRecentlyUsedFilenames, setRecentlyUsedFilenames, setMaxNumberOfRecentFiles
	*/
	void addRecentlyUsedFile (const File& file);

	/** Changes the limit for the number of files that will be stored in the recent-file list.
	*/
	void setMaxNumberOfRecentFiles (int newMaximum);

	/** Changes the text shown on the 'browse' button.

		By default this button just says "..." but you can change it. The button itself
		can be changed using the look-and-feel classes, so it might not actually have any
		text on it.
	*/
	void setBrowseButtonText (const String& browseButtonText);

	/** Adds a listener that will be called when the selected file is changed. */
	void addListener (FilenameComponentListener* listener);

	/** Removes a previously-registered listener. */
	void removeListener (FilenameComponentListener* listener);

	/** Gives the component a tooltip. */
	void setTooltip (const String& newTooltip);

	/** @internal */
	void paintOverChildren (Graphics& g);
	/** @internal */
	void resized();
	/** @internal */
	void lookAndFeelChanged();
	/** @internal */
	bool isInterestedInFileDrag (const StringArray& files);
	/** @internal */
	void filesDropped (const StringArray& files, int, int);
	/** @internal */
	void fileDragEnter (const StringArray& files, int, int);
	/** @internal */
	void fileDragExit (const StringArray& files);

private:

	ComboBox filenameBox;
	String lastFilename;
	ScopedPointer<Button> browseButton;
	int maxRecentFiles;
	bool isDir, isSaving, isFileDragOver;
	String wildcard, enforcedSuffix, browseButtonText;
	ListenerList <FilenameComponentListener> listeners;
	File defaultBrowseFile;

	void comboBoxChanged (ComboBox*);
	void buttonClicked (Button* button);
	void handleAsyncUpdate();

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (FilenameComponent);
};

#endif   // __JUCE_FILENAMECOMPONENT_JUCEHEADER__

/*** End of inlined file: juce_FilenameComponent.h ***/


#endif
#ifndef __JUCE_FILEPREVIEWCOMPONENT_JUCEHEADER__

#endif
#ifndef __JUCE_FILESEARCHPATHLISTCOMPONENT_JUCEHEADER__

/*** Start of inlined file: juce_FileSearchPathListComponent.h ***/
#ifndef __JUCE_FILESEARCHPATHLISTCOMPONENT_JUCEHEADER__
#define __JUCE_FILESEARCHPATHLISTCOMPONENT_JUCEHEADER__

/**
	Shows a set of file paths in a list, allowing them to be added, removed or
	re-ordered.

	@see FileSearchPath
*/
class JUCE_API  FileSearchPathListComponent  : public Component,
											   public SettableTooltipClient,
											   public FileDragAndDropTarget,
											   private ButtonListener,  // (can't use Button::Listener due to idiotic VC2005 bug)
											   private ListBoxModel
{
public:

	/** Creates an empty FileSearchPathListComponent. */
	FileSearchPathListComponent();

	/** Destructor. */
	~FileSearchPathListComponent();

	/** Returns the path as it is currently shown. */
	const FileSearchPath& getPath() const noexcept                  { return path; }

	/** Changes the current path. */
	void setPath (const FileSearchPath& newPath);

	/** Sets a file or directory to be the default starting point for the browser to show.

		This is only used if the current file hasn't been set.
	*/
	void setDefaultBrowseTarget (const File& newDefaultDirectory);

	/** A set of colour IDs to use to change the colour of various aspects of the label.

		These constants can be used either via the Component::setColour(), or LookAndFeel::setColour()
		methods.

		@see Component::setColour, Component::findColour, LookAndFeel::setColour, LookAndFeel::findColour
	*/
	enum ColourIds
	{
		backgroundColourId      = 0x1004100, /**< The background colour to fill the component with.
												  Make this transparent if you don't want the background to be filled. */
	};

	/** @internal */
	int getNumRows();
	/** @internal */
	void paintListBoxItem (int rowNumber, Graphics& g, int width, int height, bool rowIsSelected);
	/** @internal */
	void deleteKeyPressed (int lastRowSelected);
	/** @internal */
	void returnKeyPressed (int lastRowSelected);
	/** @internal */
	void listBoxItemDoubleClicked (int row, const MouseEvent&);
	/** @internal */
	void selectedRowsChanged (int lastRowSelected);
	/** @internal */
	void resized();
	/** @internal */
	void paint (Graphics& g);
	/** @internal */
	bool isInterestedInFileDrag (const StringArray& files);
	/** @internal */
	void filesDropped (const StringArray& files, int, int);
	/** @internal */
	void buttonClicked (Button* button);

private:

	FileSearchPath path;
	File defaultBrowseTarget;

	ListBox listBox;
	TextButton addButton, removeButton, changeButton;
	DrawableButton upButton, downButton;

	void changed();
	void updateButtons();

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (FileSearchPathListComponent);
};

#endif   // __JUCE_FILESEARCHPATHLISTCOMPONENT_JUCEHEADER__

/*** End of inlined file: juce_FileSearchPathListComponent.h ***/


#endif
#ifndef __JUCE_FILETREECOMPONENT_JUCEHEADER__

/*** Start of inlined file: juce_FileTreeComponent.h ***/
#ifndef __JUCE_FILETREECOMPONENT_JUCEHEADER__
#define __JUCE_FILETREECOMPONENT_JUCEHEADER__

/**
	A component that displays the files in a directory as a treeview.

	This implements the DirectoryContentsDisplayComponent base class so that
	it can be used in a FileBrowserComponent.

	To attach a listener to it, use its DirectoryContentsDisplayComponent base
	class and the FileBrowserListener class.

	@see DirectoryContentsList, FileListComponent
*/
class JUCE_API  FileTreeComponent  : public TreeView,
									 public DirectoryContentsDisplayComponent
{
public:

	/** Creates a listbox to show the contents of a specified directory.
	*/
	FileTreeComponent (DirectoryContentsList& listToShow);

	/** Destructor. */
	~FileTreeComponent();

	/** Returns the number of files the user has got selected.
		@see getSelectedFile
	*/
	int getNumSelectedFiles() const                 { return TreeView::getNumSelectedItems(); }

	/** Returns one of the files that the user has currently selected.
		The index should be in the range 0 to (getNumSelectedFiles() - 1).
		@see getNumSelectedFiles
	*/
	File getSelectedFile (int index = 0) const;

	/** Deselects any files that are currently selected. */
	void deselectAllFiles();

	/** Scrolls the list to the top. */
	void scrollToTop();

	/** If the specified file is in the list, it will become the only selected item
		(and if the file isn't in the list, all other items will be deselected). */
	void setSelectedFile (const File&);

	/** Updates the files in the list. */
	void refresh();

	/** Setting a name for this allows tree items to be dragged.

		The string that you pass in here will be returned by the getDragSourceDescription()
		of the items in the tree. For more info, see TreeViewItem::getDragSourceDescription().
	*/
	void setDragAndDropDescription (const String& description);

	/** Returns the last value that was set by setDragAndDropDescription().
	*/
	const String& getDragAndDropDescription() const noexcept     { return dragAndDropDescription; }

private:

	String dragAndDropDescription;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (FileTreeComponent);
};

#endif   // __JUCE_FILETREECOMPONENT_JUCEHEADER__

/*** End of inlined file: juce_FileTreeComponent.h ***/


#endif
#ifndef __JUCE_IMAGEPREVIEWCOMPONENT_JUCEHEADER__

/*** Start of inlined file: juce_ImagePreviewComponent.h ***/
#ifndef __JUCE_IMAGEPREVIEWCOMPONENT_JUCEHEADER__
#define __JUCE_IMAGEPREVIEWCOMPONENT_JUCEHEADER__

/**
	A simple preview component that shows thumbnails of image files.

	@see FileChooserDialogBox, FilePreviewComponent
*/
class JUCE_API  ImagePreviewComponent  : public FilePreviewComponent,
										 private Timer
{
public:

	/** Creates an ImagePreviewComponent. */
	ImagePreviewComponent();

	/** Destructor. */
	~ImagePreviewComponent();

	/** @internal */
	void selectedFileChanged (const File& newSelectedFile);
	/** @internal */
	void paint (Graphics& g);
	/** @internal */
	void timerCallback();

private:
	File fileToLoad;
	Image currentThumbnail;
	String currentDetails;

	void getThumbSize (int& w, int& h) const;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ImagePreviewComponent);
};

#endif   // __JUCE_IMAGEPREVIEWCOMPONENT_JUCEHEADER__

/*** End of inlined file: juce_ImagePreviewComponent.h ***/


#endif
#ifndef __JUCE_WILDCARDFILEFILTER_JUCEHEADER__

/*** Start of inlined file: juce_WildcardFileFilter.h ***/
#ifndef __JUCE_WILDCARDFILEFILTER_JUCEHEADER__
#define __JUCE_WILDCARDFILEFILTER_JUCEHEADER__

/**
	A type of FileFilter that works by wildcard pattern matching.

	This filter only allows files that match one of the specified patterns, but
	allows all directories through.

	@see FileFilter, DirectoryContentsList, FileListComponent, FileBrowserComponent
*/
class JUCE_API  WildcardFileFilter  : public FileFilter
{
public:

	/**
		Creates a wildcard filter for one or more patterns.

		The wildcardPatterns parameter is a comma or semicolon-delimited set of
		patterns, e.g. "*.wav;*.aiff" would look for files ending in either .wav
		or .aiff.

		Passing an empty string as a pattern will fail to match anything, so by leaving
		either the file or directory pattern parameter empty means you can control
		whether files or directories are found.

		The description is a name to show the user in a list of possible patterns, so
		for the wav/aiff example, your description might be "audio files".
	*/
	WildcardFileFilter (const String& fileWildcardPatterns,
						const String& directoryWildcardPatterns,
						const String& description);

	/** Destructor. */
	~WildcardFileFilter();

	/** Returns true if the filename matches one of the patterns specified. */
	bool isFileSuitable (const File& file) const;

	/** This always returns true. */
	bool isDirectorySuitable (const File& file) const;

private:

	StringArray fileWildcards, directoryWildcards;

	static void parse (const String& pattern, StringArray& result);
	static bool match (const File& file, const StringArray& wildcards);

	JUCE_LEAK_DETECTOR (WildcardFileFilter);
};

#endif   // __JUCE_WILDCARDFILEFILTER_JUCEHEADER__

/*** End of inlined file: juce_WildcardFileFilter.h ***/


#endif
#ifndef __JUCE_COMPONENTANIMATOR_JUCEHEADER__

#endif
#ifndef __JUCE_COMPONENTBOUNDSCONSTRAINER_JUCEHEADER__

#endif
#ifndef __JUCE_COMPONENTBUILDER_JUCEHEADER__

#endif
#ifndef __JUCE_COMPONENTMOVEMENTWATCHER_JUCEHEADER__

/*** Start of inlined file: juce_ComponentMovementWatcher.h ***/
#ifndef __JUCE_COMPONENTMOVEMENTWATCHER_JUCEHEADER__
#define __JUCE_COMPONENTMOVEMENTWATCHER_JUCEHEADER__

/** An object that watches for any movement of a component or any of its parent components.

	This makes it easy to check when a component is moved relative to its top-level
	peer window. The normal Component::moved() method is only called when a component
	moves relative to its immediate parent, and sometimes you want to know if any of
	components higher up the tree have moved (which of course will affect the overall
	position of all their sub-components).

	It also includes a callback that lets you know when the top-level peer is changed.

	This class is used by specialised components like OpenGLComponent or QuickTimeComponent
	because they need to keep their custom windows in the right place and respond to
	changes in the peer.
*/
class JUCE_API  ComponentMovementWatcher    : public ComponentListener
{
public:

	/** Creates a ComponentMovementWatcher to watch a given target component. */
	ComponentMovementWatcher (Component* component);

	/** Destructor. */
	~ComponentMovementWatcher();

	/** This callback happens when the component that is being watched is moved
		relative to its top-level peer window, or when it is resized. */
	virtual void componentMovedOrResized (bool wasMoved, bool wasResized) = 0;

	/** This callback happens when the component's top-level peer is changed. */
	virtual void componentPeerChanged() = 0;

	/** This callback happens when the component's visibility state changes, possibly due to
		one of its parents being made visible or invisible.
	*/
	virtual void componentVisibilityChanged() = 0;

	/** @internal */
	void componentParentHierarchyChanged (Component& component);
	/** @internal */
	void componentMovedOrResized (Component& component, bool wasMoved, bool wasResized);
	/** @internal */
	void componentBeingDeleted (Component& component);
	/** @internal */
	void componentVisibilityChanged (Component& component);

private:

	WeakReference<Component> component;
	uint32 lastPeerID;
	Array <Component*> registeredParentComps;
	bool reentrant, wasShowing;
	Rectangle<int> lastBounds;

	void unregister();
	void registerWithParentComps();

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ComponentMovementWatcher);
};

#endif   // __JUCE_COMPONENTMOVEMENTWATCHER_JUCEHEADER__

/*** End of inlined file: juce_ComponentMovementWatcher.h ***/


#endif
#ifndef __JUCE_GROUPCOMPONENT_JUCEHEADER__

/*** Start of inlined file: juce_GroupComponent.h ***/
#ifndef __JUCE_GROUPCOMPONENT_JUCEHEADER__
#define __JUCE_GROUPCOMPONENT_JUCEHEADER__

/**
	A component that draws an outline around itself and has an optional title at
	the top, for drawing an outline around a group of controls.

*/
class JUCE_API  GroupComponent    : public Component
{
public:

	/** Creates a GroupComponent.

		@param componentName    the name to give the component
		@param labelText        the text to show at the top of the outline
	*/
	GroupComponent (const String& componentName = String::empty,
					const String& labelText = String::empty);

	/** Destructor. */
	~GroupComponent();

	/** Changes the text that's shown at the top of the component. */
	void setText (const String& newText);

	/** Returns the currently displayed text label. */
	String getText() const;

	/** Sets the positioning of the text label.

		(The default is Justification::left)

		@see getTextLabelPosition
	*/
	void setTextLabelPosition (const Justification& justification);

	/** Returns the current text label position.

		@see setTextLabelPosition
	*/
	const Justification getTextLabelPosition() const noexcept           { return justification; }

	/** A set of colour IDs to use to change the colour of various aspects of the component.

		These constants can be used either via the Component::setColour(), or LookAndFeel::setColour()
		methods.

		@see Component::setColour, Component::findColour, LookAndFeel::setColour, LookAndFeel::findColour
	*/
	enum ColourIds
	{
		outlineColourId     = 0x1005400,    /**< The colour to use for drawing the line around the edge. */
		textColourId        = 0x1005410     /**< The colour to use to draw the text label. */
	};

	struct Ids
	{
		static const Identifier tagType, text, justification;
	};

	void refreshFromValueTree (const ValueTree&, ComponentBuilder&);

	/** @internal */
	void paint (Graphics& g);
	/** @internal */
	void enablementChanged();
	/** @internal */
	void colourChanged();

private:
	String text;
	Justification justification;

	JUCE_DECLARE_NON_COPYABLE (GroupComponent);
};

#endif   // __JUCE_GROUPCOMPONENT_JUCEHEADER__

/*** End of inlined file: juce_GroupComponent.h ***/


#endif
#ifndef __JUCE_MULTIDOCUMENTPANEL_JUCEHEADER__

/*** Start of inlined file: juce_MultiDocumentPanel.h ***/
#ifndef __JUCE_MULTIDOCUMENTPANEL_JUCEHEADER__
#define __JUCE_MULTIDOCUMENTPANEL_JUCEHEADER__


/*** Start of inlined file: juce_TabbedComponent.h ***/
#ifndef __JUCE_TABBEDCOMPONENT_JUCEHEADER__
#define __JUCE_TABBEDCOMPONENT_JUCEHEADER__


/*** Start of inlined file: juce_TabbedButtonBar.h ***/
#ifndef __JUCE_TABBEDBUTTONBAR_JUCEHEADER__
#define __JUCE_TABBEDBUTTONBAR_JUCEHEADER__

class TabbedButtonBar;

/** In a TabbedButtonBar, this component is used for each of the buttons.

	If you want to create a TabbedButtonBar with custom tab components, derive
	your component from this class, and override the TabbedButtonBar::createTabButton()
	method to create it instead of the default one.

	@see TabbedButtonBar
*/
class JUCE_API  TabBarButton  : public Button
{
public:

	/** Creates the tab button. */
	TabBarButton (const String& name, TabbedButtonBar& ownerBar);

	/** Destructor. */
	~TabBarButton();

	/** Chooses the best length for the tab, given the specified depth.

		If the tab is horizontal, this should return its width, and the depth
		specifies its height. If it's vertical, it should return the height, and
		the depth is actually its width.
	*/
	virtual int getBestTabLength (int depth);

	void paintButton (Graphics& g, bool isMouseOverButton, bool isButtonDown);
	void clicked (const ModifierKeys& mods);
	bool hitTest (int x, int y);

protected:

	friend class TabbedButtonBar;
	TabbedButtonBar& owner;
	int overlapPixels;
	DropShadowEffect shadow;

	/** Returns an area of the component that's safe to draw in.

		This deals with the orientation of the tabs, which affects which side is
		touching the tabbed box's content component.
	*/
	Rectangle<int> getActiveArea();

	/** Returns this tab's index in its tab bar. */
	int getIndex() const;

private:

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (TabBarButton);
};

/**
	A vertical or horizontal bar containing tabs that you can select.

	You can use one of these to generate things like a dialog box that has
	tabbed pages you can flip between. Attach a ChangeListener to the
	button bar to be told when the user changes the page.

	An easier method than doing this is to use a TabbedComponent, which
	contains its own TabbedButtonBar and which takes care of the layout
	and other housekeeping.

	@see TabbedComponent
*/
class JUCE_API  TabbedButtonBar  : public Component,
								   public ChangeBroadcaster
{
public:

	/** The placement of the tab-bar

		@see setOrientation, getOrientation
	*/
	enum Orientation
	{
		TabsAtTop,
		TabsAtBottom,
		TabsAtLeft,
		TabsAtRight
	};

	/** Creates a TabbedButtonBar with a given placement.

		You can change the orientation later if you need to.
	*/
	TabbedButtonBar (Orientation orientation);

	/** Destructor. */
	~TabbedButtonBar();

	/** Changes the bar's orientation.

		This won't change the bar's actual size - you'll need to do that yourself,
		but this determines which direction the tabs go in, and which side they're
		stuck to.
	*/
	void setOrientation (Orientation orientation);

	/** Returns the current orientation.

		@see setOrientation
	*/
	Orientation getOrientation() const noexcept                     { return orientation; }

	/** Changes the minimum scale factor to which the tabs can be compressed when trying to
		fit a lot of tabs on-screen.
	*/
	void setMinimumTabScaleFactor (double newMinimumScale);

	/** Deletes all the tabs from the bar.

		@see addTab
	*/
	void clearTabs();

	/** Adds a tab to the bar.

		Tabs are added in left-to-right reading order.

		If this is the first tab added, it'll also be automatically selected.
	*/
	void addTab (const String& tabName,
				 const Colour& tabBackgroundColour,
				 int insertIndex = -1);

	/** Changes the name of one of the tabs. */
	void setTabName (int tabIndex,
					 const String& newName);

	/** Gets rid of one of the tabs. */
	void removeTab (int tabIndex);

	/** Moves a tab to a new index in the list.

		Pass -1 as the index to move it to the end of the list.
	*/
	void moveTab (int currentIndex, int newIndex);

	/** Returns the number of tabs in the bar. */
	int getNumTabs() const;

	/** Returns a list of all the tab names in the bar. */
	StringArray getTabNames() const;

	/** Changes the currently selected tab.

		This will send a change message and cause a synchronous callback to
		the currentTabChanged() method. (But if the given tab is already selected,
		nothing will be done).

		To deselect all the tabs, use an index of -1.
	*/
	void setCurrentTabIndex (int newTabIndex, bool sendChangeMessage = true);

	/** Returns the name of the currently selected tab.

		This could be an empty string if none are selected.
	*/
	String getCurrentTabName() const;

	/** Returns the index of the currently selected tab.

		This could return -1 if none are selected.
	*/
	int getCurrentTabIndex() const noexcept                             { return currentTabIndex; }

	/** Returns the button for a specific tab.

		The button that is returned may be deleted later by this component, so don't hang
		on to the pointer that is returned. A null pointer may be returned if the index is
		out of range.
	*/
	TabBarButton* getTabButton (int index) const;

	/** Returns the index of a TabBarButton if it belongs to this bar. */
	int indexOfTabButton (const TabBarButton* button) const;

	/** Callback method to indicate the selected tab has been changed.

		@see setCurrentTabIndex
	*/
	virtual void currentTabChanged (int newCurrentTabIndex,
									const String& newCurrentTabName);

	/** Callback method to indicate that the user has right-clicked on a tab.

		(Or ctrl-clicked on the Mac)
	*/
	virtual void popupMenuClickOnTab (int tabIndex, const String& tabName);

	/** Returns the colour of a tab.

		This is the colour that was specified in addTab().
	*/
	Colour getTabBackgroundColour (int tabIndex);

	/** Changes the background colour of a tab.

		@see addTab, getTabBackgroundColour
	*/
	void setTabBackgroundColour (int tabIndex, const Colour& newColour);

	/** A set of colour IDs to use to change the colour of various aspects of the component.

		These constants can be used either via the Component::setColour(), or LookAndFeel::setColour()
		methods.

		@see Component::setColour, Component::findColour, LookAndFeel::setColour, LookAndFeel::findColour
	*/
	enum ColourIds
	{
		tabOutlineColourId              = 0x1005812,    /**< The colour to use to draw an outline around the tabs.  */
		tabTextColourId                 = 0x1005813,    /**< The colour to use to draw the tab names. If this isn't specified,
															 the look and feel will choose an appropriate colour. */
		frontOutlineColourId            = 0x1005814,    /**< The colour to use to draw an outline around the currently-selected tab.  */
		frontTextColourId               = 0x1005815,    /**< The colour to use to draw the currently-selected tab name. If
															 this isn't specified, the look and feel will choose an appropriate
															 colour. */
	};

	/** @internal */
	void resized();
	/** @internal */
	void lookAndFeelChanged();

protected:

	/** This creates one of the tabs.

		If you need to use custom tab components, you can override this method and
		return your own class instead of the default.
	*/
	virtual TabBarButton* createTabButton (const String& tabName, int tabIndex);

private:
	Orientation orientation;

	struct TabInfo
	{
		ScopedPointer<TabBarButton> component;
		String name;
		Colour colour;
	};

	OwnedArray <TabInfo> tabs;

	double minimumScale;
	int currentTabIndex;

	class BehindFrontTabComp;
	friend class BehindFrontTabComp;
	friend class ScopedPointer<BehindFrontTabComp>;
	ScopedPointer<BehindFrontTabComp> behindFrontTab;
	ScopedPointer<Button> extraTabsButton;

	void showExtraItemsMenu();
	static void extraItemsMenuCallback (int, TabbedButtonBar*);

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (TabbedButtonBar);
};

#endif   // __JUCE_TABBEDBUTTONBAR_JUCEHEADER__

/*** End of inlined file: juce_TabbedButtonBar.h ***/

/**
	A component with a TabbedButtonBar along one of its sides.

	This makes it easy to create a set of tabbed pages, just add a bunch of tabs
	with addTab(), and this will take care of showing the pages for you when the
	user clicks on a different tab.

	@see TabbedButtonBar
*/
class JUCE_API  TabbedComponent  : public Component
{
public:

	/** Creates a TabbedComponent, specifying where the tabs should be placed.

		Once created, add some tabs with the addTab() method.
	*/
	explicit TabbedComponent (TabbedButtonBar::Orientation orientation);

	/** Destructor. */
	~TabbedComponent();

	/** Changes the placement of the tabs.

		This will rearrange the layout to place the tabs along the appropriate
		side of this component, and will shift the content component accordingly.

		@see TabbedButtonBar::setOrientation
	*/
	void setOrientation (TabbedButtonBar::Orientation orientation);

	/** Returns the current tab placement.

		@see setOrientation, TabbedButtonBar::getOrientation
	*/
	TabbedButtonBar::Orientation getOrientation() const noexcept;

	/** Specifies how many pixels wide or high the tab-bar should be.

		If the tabs are placed along the top or bottom, this specified the height
		of the bar; if they're along the left or right edges, it'll be the width
		of the bar.
	*/
	void setTabBarDepth (int newDepth);

	/** Returns the current thickness of the tab bar.

		@see setTabBarDepth
	*/
	int getTabBarDepth() const noexcept                         { return tabDepth; }

	/** Specifies the thickness of an outline that should be drawn around the content component.

		If this thickness is > 0, a line will be drawn around the three sides of the content
		component which don't touch the tab-bar, and the content component will be inset by this amount.

		To set the colour of the line, use setColour (outlineColourId, ...).
	*/
	void setOutline (int newThickness);

	/** Specifies a gap to leave around the edge of the content component.

		Each edge of the content component will be indented by the given number of pixels.
	*/
	void setIndent (int indentThickness);

	/** Removes all the tabs from the bar.

		@see TabbedButtonBar::clearTabs
	*/
	void clearTabs();

	/** Adds a tab to the tab-bar.

		The component passed in will be shown for the tab, and if deleteComponentWhenNotNeeded
		is true, it will be deleted when the tab is removed or when this object is
		deleted.

		@see TabbedButtonBar::addTab
	*/
	void addTab (const String& tabName,
				 const Colour& tabBackgroundColour,
				 Component* contentComponent,
				 bool deleteComponentWhenNotNeeded,
				 int insertIndex = -1);

	/** Changes the name of one of the tabs. */
	void setTabName (int tabIndex, const String& newName);

	/** Gets rid of one of the tabs. */
	void removeTab (int tabIndex);

	/** Returns the number of tabs in the bar. */
	int getNumTabs() const;

	/** Returns a list of all the tab names in the bar. */
	StringArray getTabNames() const;

	/** Returns the content component that was added for the given index.

		Be sure not to use or delete the components that are returned, as this may interfere
		with the TabbedComponent's use of them.
	*/
	Component* getTabContentComponent (int tabIndex) const noexcept;

	/** Returns the colour of one of the tabs. */
	Colour getTabBackgroundColour (int tabIndex) const noexcept;

	/** Changes the background colour of one of the tabs. */
	void setTabBackgroundColour (int tabIndex, const Colour& newColour);

	/** Changes the currently-selected tab.

		To deselect all the tabs, pass -1 as the index.

		@see TabbedButtonBar::setCurrentTabIndex
	*/
	void setCurrentTabIndex (int newTabIndex, bool sendChangeMessage = true);

	/** Returns the index of the currently selected tab.

		@see addTab, TabbedButtonBar::getCurrentTabIndex()
	*/
	int getCurrentTabIndex() const;

	/** Returns the name of the currently selected tab.

		@see addTab, TabbedButtonBar::getCurrentTabName()
	*/
	String getCurrentTabName() const;

	/** Returns the current component that's filling the panel.

		This will return 0 if there isn't one.
	*/
	Component* getCurrentContentComponent() const noexcept          { return panelComponent; }

	/** Callback method to indicate the selected tab has been changed.

		@see setCurrentTabIndex
	*/
	virtual void currentTabChanged (int newCurrentTabIndex,
									const String& newCurrentTabName);

	/** Callback method to indicate that the user has right-clicked on a tab.

		(Or ctrl-clicked on the Mac)
	*/
	virtual void popupMenuClickOnTab (int tabIndex,
									  const String& tabName);

	/** Returns the tab button bar component that is being used.
	*/
	TabbedButtonBar& getTabbedButtonBar() const noexcept            { return *tabs; }

	/** A set of colour IDs to use to change the colour of various aspects of the component.

		These constants can be used either via the Component::setColour(), or LookAndFeel::setColour()
		methods.

		@see Component::setColour, Component::findColour, LookAndFeel::setColour, LookAndFeel::findColour
	*/
	enum ColourIds
	{
		backgroundColourId          = 0x1005800,    /**< The colour to fill the background behind the tabs. */
		outlineColourId             = 0x1005801,    /**< The colour to use to draw an outline around the content.
														 (See setOutline)  */
	};

	/** @internal */
	void paint (Graphics& g);
	/** @internal */
	void resized();
	/** @internal */
	void lookAndFeelChanged();

protected:

	/** This creates one of the tab buttons.

		If you need to use custom tab components, you can override this method and
		return your own class instead of the default.
	*/
	virtual TabBarButton* createTabButton (const String& tabName, int tabIndex);

	/** @internal */
	ScopedPointer<TabbedButtonBar> tabs;

private:

	Array <WeakReference<Component> > contentComponents;
	WeakReference<Component> panelComponent;
	int tabDepth;
	int outlineThickness, edgeIndent;

	class ButtonBar;
	friend class ButtonBar;
	void changeCallback (int newCurrentTabIndex, const String& newTabName);

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (TabbedComponent);
};

#endif   // __JUCE_TABBEDCOMPONENT_JUCEHEADER__

/*** End of inlined file: juce_TabbedComponent.h ***/


/*** Start of inlined file: juce_DocumentWindow.h ***/
#ifndef __JUCE_DOCUMENTWINDOW_JUCEHEADER__
#define __JUCE_DOCUMENTWINDOW_JUCEHEADER__


/*** Start of inlined file: juce_MenuBarModel.h ***/
#ifndef __JUCE_MENUBARMODEL_JUCEHEADER__
#define __JUCE_MENUBARMODEL_JUCEHEADER__

/**
	A class for controlling MenuBar components.

	This class is used to tell a MenuBar what menus to show, and to respond
	to a menu being selected.

	@see MenuBarModel::Listener, MenuBarComponent, PopupMenu
*/
class JUCE_API  MenuBarModel      : private AsyncUpdater,
									private ApplicationCommandManagerListener
{
public:

	MenuBarModel() noexcept;

	/** Destructor. */
	virtual ~MenuBarModel();

	/** Call this when some of your menu items have changed.

		This method will cause a callback to any MenuBarListener objects that
		are registered with this model.

		If this model is displaying items from an ApplicationCommandManager, you
		can use the setApplicationCommandManagerToWatch() method to cause
		change messages to be sent automatically when the ApplicationCommandManager
		is changed.

		@see addListener, removeListener, MenuBarListener
	*/
	void menuItemsChanged();

	/** Tells the menu bar to listen to the specified command manager, and to update
		itself when the commands change.

		This will also allow it to flash a menu name when a command from that menu
		is invoked using a keystroke.
	*/
	void setApplicationCommandManagerToWatch (ApplicationCommandManager* manager) noexcept;

	/** A class to receive callbacks when a MenuBarModel changes.

		@see MenuBarModel::addListener, MenuBarModel::removeListener, MenuBarModel::menuItemsChanged
	*/
	class JUCE_API  Listener
	{
	public:
		/** Destructor. */
		virtual ~Listener() {}

		/** This callback is made when items are changed in the menu bar model.
		*/
		virtual void menuBarItemsChanged (MenuBarModel* menuBarModel) = 0;

		/** This callback is made when an application command is invoked that
			is represented by one of the items in the menu bar model.
		*/
		virtual void menuCommandInvoked (MenuBarModel* menuBarModel,
										 const ApplicationCommandTarget::InvocationInfo& info) = 0;
	};

	/** Registers a listener for callbacks when the menu items in this model change.

		The listener object will get callbacks when this object's menuItemsChanged()
		method is called.

		@see removeListener
	*/
	void addListener (Listener* listenerToAdd) noexcept;

	/** Removes a listener.

		@see addListener
	*/
	void removeListener (Listener* listenerToRemove) noexcept;

	/** This method must return a list of the names of the menus. */
	virtual const StringArray getMenuBarNames() = 0;

	/** This should return the popup menu to display for a given top-level menu.

		@param topLevelMenuIndex    the index of the top-level menu to show
		@param menuName             the name of the top-level menu item to show
	*/
	virtual const PopupMenu getMenuForIndex (int topLevelMenuIndex,
											 const String& menuName) = 0;

	/** This is called when a menu item has been clicked on.

		@param menuItemID           the item ID of the PopupMenu item that was selected
		@param topLevelMenuIndex    the index of the top-level menu from which the item was
									chosen (just in case you've used duplicate ID numbers
									on more than one of the popup menus)
	*/
	virtual void menuItemSelected (int menuItemID,
								   int topLevelMenuIndex) = 0;

   #if JUCE_MAC || DOXYGEN
	/** MAC ONLY - Sets the model that is currently being shown as the main
		menu bar at the top of the screen on the Mac.

		You can pass 0 to stop the current model being displayed. Be careful
		not to delete a model while it is being used.

		An optional extra menu can be specified, containing items to add to the top of
		the apple menu. (Confusingly, the 'apple' menu isn't the one with a picture of
		an apple, it's the one next to it, with your application's name at the top
		and the services menu etc on it). When one of these items is selected, the
		menu bar model will be used to invoke it, and in the menuItemSelected() callback
		the topLevelMenuIndex parameter will be -1. If you pass in an extraAppleMenuItems
		object then newMenuBarModel must be non-null.
	*/
	static void setMacMainMenu (MenuBarModel* newMenuBarModel,
								const PopupMenu* extraAppleMenuItems = nullptr);

	/** MAC ONLY - Returns the menu model that is currently being shown as
		the main menu bar.
	*/
	static MenuBarModel* getMacMainMenu();
   #endif

	/** @internal */
	void applicationCommandInvoked (const ApplicationCommandTarget::InvocationInfo& info);
	/** @internal */
	void applicationCommandListChanged();
	/** @internal */
	void handleAsyncUpdate();

private:
	ApplicationCommandManager* manager;
	ListenerList <Listener> listeners;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (MenuBarModel);
};

/** This typedef is just for compatibility with old code - newer code should use the MenuBarModel::Listener class directly. */
typedef MenuBarModel::Listener MenuBarModelListener;

#endif   // __JUCE_MENUBARMODEL_JUCEHEADER__

/*** End of inlined file: juce_MenuBarModel.h ***/

/**
	A resizable window with a title bar and maximise, minimise and close buttons.

	This subclass of ResizableWindow creates a fairly standard type of window with
	a title bar and various buttons. The name of the component is shown in the
	title bar, and an icon can optionally be specified with setIcon().

	All the methods available to a ResizableWindow are also available to this,
	so it can easily be made resizable, minimised, maximised, etc.

	It's not advisable to add child components directly to a DocumentWindow: put them
	inside your content component instead. And overriding methods like resized(), moved(), etc
	is also not recommended - instead override these methods for your content component.
	(If for some obscure reason you do need to override these methods, always remember to
	call the super-class's resized() method too, otherwise it'll fail to lay out the window
	decorations correctly).

	You can also automatically add a menu bar to the window, using the setMenuBar()
	method.

	@see ResizableWindow, DialogWindow
*/
class JUCE_API  DocumentWindow   : public ResizableWindow
{
public:

	/** The set of available button-types that can be put on the title bar.

		@see setTitleBarButtonsRequired
	*/
	enum TitleBarButtons
	{
		minimiseButton = 1,
		maximiseButton = 2,
		closeButton = 4,

		/** A combination of all the buttons above. */
		allButtons = 7
	};

	/** Creates a DocumentWindow.

		@param name             the name to give the component - this is also
								the title shown at the top of the window. To change
								this later, use setName()
		@param backgroundColour the colour to use for filling the window's background.
		@param requiredButtons  specifies which of the buttons (close, minimise, maximise)
								should be shown on the title bar. This value is a bitwise
								combination of values from the TitleBarButtons enum. Note
								that it can be "allButtons" to get them all. You
								can change this later with the setTitleBarButtonsRequired()
								method, which can also specify where they are positioned.
		@param addToDesktop     if true, the window will be automatically added to the
								desktop; if false, you can use it as a child component
		@see TitleBarButtons
	*/
	DocumentWindow (const String& name,
					const Colour& backgroundColour,
					int requiredButtons,
					bool addToDesktop = true);

	/** Destructor.
		If a content component has been set with setContentOwned(), it will be deleted.
	*/
	~DocumentWindow();

	/** Changes the component's name.

		(This is overridden from Component::setName() to cause a repaint, as
		the name is what gets drawn across the window's title bar).
	*/
	void setName (const String& newName);

	/** Sets an icon to show in the title bar, next to the title.

		A copy is made internally of the image, so the caller can delete the
		image after calling this. If 0 is passed-in, any existing icon will be
		removed.
	*/
	void setIcon (const Image& imageToUse);

	/** Changes the height of the title-bar. */
	void setTitleBarHeight (int newHeight);

	/** Returns the current title bar height. */
	int getTitleBarHeight() const;

	/** Changes the set of title-bar buttons being shown.

		@param requiredButtons  specifies which of the buttons (close, minimise, maximise)
								should be shown on the title bar. This value is a bitwise
								combination of values from the TitleBarButtons enum. Note
								that it can be "allButtons" to get them all.
		@param positionTitleBarButtonsOnLeft    if true, the buttons should go at the
								left side of the bar; if false, they'll be placed at the right
	*/
	void setTitleBarButtonsRequired (int requiredButtons,
									 bool positionTitleBarButtonsOnLeft);

	/** Sets whether the title should be centred within the window.

		If true, the title text is shown in the middle of the title-bar; if false,
		it'll be shown at the left of the bar.
	*/
	void setTitleBarTextCentred (bool textShouldBeCentred);

	/** Creates a menu inside this window.

		@param menuBarModel     this specifies a MenuBarModel that should be used to
								generate the contents of a menu bar that will be placed
								just below the title bar, and just above any content
								component. If this value is zero, any existing menu bar
								will be removed from the component; if non-zero, one will
								be added if it's required.
		@param menuBarHeight    the height of the menu bar component, if one is needed. Pass a value of zero
								or less to use the look-and-feel's default size.
	*/
	void setMenuBar (MenuBarModel* menuBarModel,
					 int menuBarHeight = 0);

	/** Returns the current menu bar component, or null if there isn't one.
		This is probably a MenuBarComponent, unless a custom one has been set using
		setMenuBarComponent().
	*/
	Component* getMenuBarComponent() const noexcept;

	/** Replaces the current menu bar with a custom component.
		The component will be owned and deleted by the document window.
	*/
	void setMenuBarComponent (Component* newMenuBarComponent);

	/** This method is called when the user tries to close the window.

		This is triggered by the user clicking the close button, or using some other
		OS-specific key shortcut or OS menu for getting rid of a window.

		If the window is just a pop-up, you should override this closeButtonPressed()
		method and make it delete the window in whatever way is appropriate for your
		app. E.g. you might just want to call "delete this".

		If your app is centred around this window such that the whole app should quit when
		the window is closed, then you will probably want to use this method as an opportunity
		to call JUCEApplication::quit(), and leave the window to be deleted later by your
		JUCEApplication::shutdown() method. (Doing it this way means that your window will
		still get cleaned-up if the app is quit by some other means (e.g. a cmd-Q on the mac
		or closing it via the taskbar icon on Windows).

		(Note that the DocumentWindow class overrides Component::userTriedToCloseWindow() and
		redirects it to call this method, so any methods of closing the window that are
		caught by userTriedToCloseWindow() will also end up here).
	*/
	virtual void closeButtonPressed();

	/** Callback that is triggered when the minimise button is pressed.

		The default implementation of this calls ResizableWindow::setMinimised(), but
		you can override it to do more customised behaviour.
	*/
	virtual void minimiseButtonPressed();

	/** Callback that is triggered when the maximise button is pressed, or when the
		title-bar is double-clicked.

		The default implementation of this calls ResizableWindow::setFullScreen(), but
		you can override it to do more customised behaviour.
	*/
	virtual void maximiseButtonPressed();

	/** Returns the close button, (or 0 if there isn't one). */
	Button* getCloseButton() const noexcept;

	/** Returns the minimise button, (or 0 if there isn't one). */
	Button* getMinimiseButton() const noexcept;

	/** Returns the maximise button, (or 0 if there isn't one). */
	Button* getMaximiseButton() const noexcept;

	/** A set of colour IDs to use to change the colour of various aspects of the window.

		These constants can be used either via the Component::setColour(), or LookAndFeel::setColour()
		methods.

		@see Component::setColour, Component::findColour, LookAndFeel::setColour, LookAndFeel::findColour
	*/
	enum ColourIds
	{
		textColourId                = 0x1005701,  /**< The colour to draw any text with. It's up to the look
													   and feel class how this is used. */
	};

   #ifndef DOXYGEN
	/** @internal */
	void paint (Graphics& g);
	/** @internal */
	void resized();
	/** @internal */
	void lookAndFeelChanged();
	/** @internal */
	BorderSize<int> getBorderThickness();
	/** @internal */
	BorderSize<int> getContentComponentBorder();
	/** @internal */
	void mouseDoubleClick (const MouseEvent& e);
	/** @internal */
	void userTriedToCloseWindow();
	/** @internal */
	void activeWindowStatusChanged();
	/** @internal */
	int getDesktopWindowStyleFlags() const;
	/** @internal */
	void parentHierarchyChanged();
	/** @internal */
	Rectangle<int> getTitleBarArea();
   #endif

private:

	int titleBarHeight, menuBarHeight, requiredButtons;
	bool positionTitleBarButtonsOnLeft, drawTitleTextCentred;
	ScopedPointer <Button> titleBarButtons [3];
	Image titleBarIcon;
	ScopedPointer <Component> menuBar;
	MenuBarModel* menuBarModel;

	class ButtonListenerProxy;
	friend class ScopedPointer <ButtonListenerProxy>;
	ScopedPointer <ButtonListenerProxy> buttonListener;

	void repaintTitleBar();

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (DocumentWindow);
};

#endif   // __JUCE_DOCUMENTWINDOW_JUCEHEADER__

/*** End of inlined file: juce_DocumentWindow.h ***/

class MultiDocumentPanel;
class MDITabbedComponentInternal;

/**
	This is a derivative of DocumentWindow that is used inside a MultiDocumentPanel
	component.

	It's like a normal DocumentWindow but has some extra functionality to make sure
	everything works nicely inside a MultiDocumentPanel.

	@see MultiDocumentPanel
*/
class JUCE_API  MultiDocumentPanelWindow  : public DocumentWindow
{
public:

	/**
	*/
	MultiDocumentPanelWindow (const Colour& backgroundColour);

	/** Destructor. */
	~MultiDocumentPanelWindow();

	/** @internal */
	void maximiseButtonPressed();
	/** @internal */
	void closeButtonPressed();
	/** @internal */
	void activeWindowStatusChanged();
	/** @internal */
	void broughtToFront();

private:

	void updateOrder();
	MultiDocumentPanel* getOwner() const noexcept;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (MultiDocumentPanelWindow);
};

/**
	A component that contains a set of other components either in floating windows
	or tabs.

	This acts as a panel that can be used to hold a set of open document windows, with
	different layout modes.

	Use addDocument() and closeDocument() to add or remove components from the
	panel - never use any of the Component methods to access the panel's child
	components directly, as these are managed internally.
*/
class JUCE_API  MultiDocumentPanel  : public Component,
									  private ComponentListener
{
public:

	/** Creates an empty panel.

		Use addDocument() and closeDocument() to add or remove components from the
		panel - never use any of the Component methods to access the panel's child
		components directly, as these are managed internally.
	*/
	MultiDocumentPanel();

	/** Destructor.

		When deleted, this will call closeAllDocuments (false) to make sure all its
		components are deleted. If you need to make sure all documents are saved
		before closing, then you should call closeAllDocuments (true) and check that
		it returns true before deleting the panel.
	*/
	~MultiDocumentPanel();

	/** Tries to close all the documents.

		If checkItsOkToCloseFirst is true, then the tryToCloseDocument() method will
		be called for each open document, and any of these calls fails, this method
		will stop and return false, leaving some documents still open.

		If checkItsOkToCloseFirst is false, then all documents will be closed
		unconditionally.

		@see closeDocument
	*/
	bool closeAllDocuments (bool checkItsOkToCloseFirst);

	/** Adds a document component to the panel.

		If the number of documents would exceed the limit set by setMaximumNumDocuments() then
		this will fail and return false. (If it does fail, the component passed-in will not be
		deleted, even if deleteWhenRemoved was set to true).

		The MultiDocumentPanel will deal with creating a window border to go around your component,
		so just pass in the bare content component here, no need to give it a ResizableWindow
		or DocumentWindow.

		@param component            the component to add
		@param backgroundColour     the background colour to use to fill the component's
									window or tab
		@param deleteWhenRemoved    if true, then when the component is removed by closeDocument()
									or closeAllDocuments(), then it will be deleted. If false, then
									the caller must handle the component's deletion
	*/
	bool addDocument (Component* component,
					  const Colour& backgroundColour,
					  bool deleteWhenRemoved);

	/** Closes one of the documents.

		If checkItsOkToCloseFirst is true, then the tryToCloseDocument() method will
		be called, and if it fails, this method will return false without closing the
		document.

		If checkItsOkToCloseFirst is false, then the documents will be closed
		unconditionally.

		The component will be deleted if the deleteWhenRemoved parameter was set to
		true when it was added with addDocument.

		@see addDocument, closeAllDocuments
	*/
	bool closeDocument (Component* component,
						bool checkItsOkToCloseFirst);

	/** Returns the number of open document windows.

		@see getDocument
	*/
	int getNumDocuments() const noexcept;

	/** Returns one of the open documents.

		The order of the documents in this array may change when they are added, removed
		or moved around.

		@see getNumDocuments
	*/
	Component* getDocument (int index) const noexcept;

	/** Returns the document component that is currently focused or on top.

		If currently using floating windows, then this will be the component in the currently
		active window, or the top component if none are active.

		If it's currently in tabbed mode, then it'll return the component in the active tab.

		@see setActiveDocument
	*/
	Component* getActiveDocument() const noexcept;

	/** Makes one of the components active and brings it to the top.

		@see getActiveDocument
	*/
	void setActiveDocument (Component* component);

	/** Callback which gets invoked when the currently-active document changes. */
	virtual void activeDocumentChanged();

	/** Sets a limit on how many windows can be open at once.

		If this is zero or less there's no limit (the default). addDocument() will fail
		if this number is exceeded.
	*/
	void setMaximumNumDocuments (int maximumNumDocuments);

	/** Sets an option to make the document fullscreen if there's only one document open.

		If set to true, then if there's only one document, it'll fill the whole of this
		component without tabs or a window border. If false, then tabs or a window
		will always be shown, even if there's only one document. If there's more than
		one document open, then this option makes no difference.
	*/
	void useFullscreenWhenOneDocument (bool shouldUseTabs);

	/** Returns the result of the last time useFullscreenWhenOneDocument() was called.
	*/
	bool isFullscreenWhenOneDocument() const noexcept;

	/** The different layout modes available. */
	enum LayoutMode
	{
		FloatingWindows,            /**< In this mode, there are overlapping DocumentWindow components for each document. */
		MaximisedWindowsWithTabs    /**< In this mode, a TabbedComponent is used to show one document at a time. */
	};

	/** Changes the panel's mode.

		@see LayoutMode, getLayoutMode
	*/
	void setLayoutMode (LayoutMode newLayoutMode);

	/** Returns the current layout mode. */
	LayoutMode getLayoutMode() const noexcept                           { return mode; }

	/** Sets the background colour for the whole panel.

		Each document has its own background colour, but this is the one used to fill the areas
		behind them.
	*/
	void setBackgroundColour (const Colour& newBackgroundColour);

	/** Returns the current background colour.

		@see setBackgroundColour
	*/
	const Colour& getBackgroundColour() const noexcept                  { return backgroundColour; }

	/** If the panel is being used in tabbed mode, this returns the TabbedComponent that's involved. */
	TabbedComponent* getCurrentTabbedComponent() const noexcept         { return tabComponent; }

	/** A subclass must override this to say whether its currently ok for a document
		to be closed.

		This method is called by closeDocument() and closeAllDocuments() to indicate that
		a document should be saved if possible, ready for it to be closed.

		If this method returns true, then it means the document is ok and can be closed.

		If it returns false, then it means that the closeDocument() method should stop
		and not close.

		Normally, you'd use this method to ask the user if they want to save any changes,
		then return true if the save operation went ok. If the user cancelled the save
		operation you could return false here to abort the close operation.

		If your component is based on the FileBasedDocument class, then you'd probably want
		to call FileBasedDocument::saveIfNeededAndUserAgrees() and return true if this returned
		FileBasedDocument::savedOk

		@see closeDocument, FileBasedDocument::saveIfNeededAndUserAgrees()
	*/
	virtual bool tryToCloseDocument (Component* component) = 0;

	/** Creates a new window to be used for a document.

		The default implementation of this just returns a basic MultiDocumentPanelWindow object,
		but you might want to override it to return a custom component.
	*/
	virtual MultiDocumentPanelWindow* createNewDocumentWindow();

	/** @internal */
	void paint (Graphics& g);
	/** @internal */
	void resized();
	/** @internal */
	void componentNameChanged (Component&);

private:

	LayoutMode mode;
	Array <Component*> components;
	ScopedPointer<TabbedComponent> tabComponent;
	Colour backgroundColour;
	int maximumNumDocuments, numDocsBeforeTabsUsed;

	friend class MultiDocumentPanelWindow;
	friend class MDITabbedComponentInternal;

	Component* getContainerComp (Component* c) const;
	void updateOrder();

	void addWindow (Component* component);

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (MultiDocumentPanel);
};

#endif   // __JUCE_MULTIDOCUMENTPANEL_JUCEHEADER__

/*** End of inlined file: juce_MultiDocumentPanel.h ***/


#endif
#ifndef __JUCE_RESIZABLEBORDERCOMPONENT_JUCEHEADER__

#endif
#ifndef __JUCE_RESIZABLECORNERCOMPONENT_JUCEHEADER__

#endif
#ifndef __JUCE_RESIZABLEEDGECOMPONENT_JUCEHEADER__

/*** Start of inlined file: juce_ResizableEdgeComponent.h ***/
#ifndef __JUCE_RESIZABLEEDGECOMPONENT_JUCEHEADER__
#define __JUCE_RESIZABLEEDGECOMPONENT_JUCEHEADER__

/**
	A component that resizes its parent component when dragged.

	This component forms a bar along one edge of a component, allowing it to
	be dragged by that edges to resize it.

	To use it, just add it to your component, positioning it along the appropriate
	edge. Make sure you reposition the resizer component each time the parent's size
	changes, to keep it in the correct position.

	@see ResizbleBorderComponent, ResizableCornerComponent
*/
class JUCE_API  ResizableEdgeComponent  : public Component
{
public:

	enum Edge
	{
		leftEdge,   /**< Indicates a vertical bar that can be dragged left/right to move the component's left-hand edge. */
		rightEdge,  /**< Indicates a vertical bar that can be dragged left/right to move the component's right-hand edge. */
		topEdge,    /**< Indicates a horizontal bar that can be dragged up/down to move the top of the component. */
		bottomEdge  /**< Indicates a horizontal bar that can be dragged up/down to move the bottom of the component. */
	};

	/** Creates a resizer bar.

		Pass in the target component which you want to be resized when this one is
		dragged. The target component will usually be this component's parent, but this
		isn't mandatory.

		Remember that when the target component is resized, it'll need to move and
		resize this component to keep it in place, as this won't happen automatically.

		If the constrainer parameter is non-zero, then this object will be used to enforce
		limits on the size and position that the component can be stretched to. Make sure
		that the constrainer isn't deleted while still in use by this object.

		@see ComponentBoundsConstrainer
	*/
	ResizableEdgeComponent (Component* componentToResize,
							ComponentBoundsConstrainer* constrainer,
							Edge edgeToResize);

	/** Destructor. */
	~ResizableEdgeComponent();

	bool isVertical() const noexcept;

protected:

	/** @internal */
	void paint (Graphics& g);
	/** @internal */
	void mouseDown (const MouseEvent& e);
	/** @internal */
	void mouseDrag (const MouseEvent& e);
	/** @internal */
	void mouseUp (const MouseEvent& e);

private:
	WeakReference<Component> component;
	ComponentBoundsConstrainer* constrainer;
	Rectangle<int> originalBounds;
	const Edge edge;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ResizableEdgeComponent);
};

#endif   // __JUCE_RESIZABLEEDGECOMPONENT_JUCEHEADER__

/*** End of inlined file: juce_ResizableEdgeComponent.h ***/


#endif
#ifndef __JUCE_SCROLLBAR_JUCEHEADER__

#endif
#ifndef __JUCE_STRETCHABLELAYOUTMANAGER_JUCEHEADER__

/*** Start of inlined file: juce_StretchableLayoutManager.h ***/
#ifndef __JUCE_STRETCHABLELAYOUTMANAGER_JUCEHEADER__
#define __JUCE_STRETCHABLELAYOUTMANAGER_JUCEHEADER__

/**
	For laying out a set of components, where the components have preferred sizes
	and size limits, but where they are allowed to stretch to fill the available
	space.

	For example, if you have a component containing several other components, and
	each one should be given a share of the total size, you could use one of these
	to resize the child components when the parent component is resized. Then
	you could add a StretchableLayoutResizerBar to easily let the user rescale them.

	A StretchableLayoutManager operates only in one dimension, so if you have a set
	of components stacked vertically on top of each other, you'd use one to manage their
	heights. To build up complex arrangements of components, e.g. for applications
	with multiple nested panels, you would use more than one StretchableLayoutManager.
	E.g. by using two (one vertical, one horizontal), you could create a resizable
	spreadsheet-style table.

	E.g.
	@code
	class MyComp  : public Component
	{
		StretchableLayoutManager myLayout;

		MyComp()
		{
			myLayout.setItemLayout (0,          // for item 0
									50, 100,    // must be between 50 and 100 pixels in size
									-0.6);      // and its preferred size is 60% of the total available space

			myLayout.setItemLayout (1,          // for item 1
									-0.2, -0.6, // size must be between 20% and 60% of the available space
									50);        // and its preferred size is 50 pixels
		}

		void resized()
		{
			// make a list of two of our child components that we want to reposition
			Component* comps[] = { myComp1, myComp2 };

			// this will position the 2 components, one above the other, to fit
			// vertically into the rectangle provided.
			myLayout.layOutComponents (comps, 2,
									   0, 0, getWidth(), getHeight(),
									   true);
		}
	};
	@endcode

	@see StretchableLayoutResizerBar
*/
class JUCE_API  StretchableLayoutManager
{
public:

	/** Creates an empty layout.

		You'll need to add some item properties to the layout before it can be used
		to resize things - see setItemLayout().
	*/
	StretchableLayoutManager();

	/** Destructor. */
	~StretchableLayoutManager();

	/** For a numbered item, this sets its size limits and preferred size.

		@param itemIndex        the index of the item to change.
		@param minimumSize      the minimum size that this item is allowed to be - a positive number
								indicates an absolute size in pixels. A negative number indicates a
								proportion of the available space (e.g -0.5 is 50%)
		@param maximumSize      the maximum size that this item is allowed to be - a positive number
								indicates an absolute size in pixels. A negative number indicates a
								proportion of the available space
		@param preferredSize    the size that this item would like to be, if there's enough room. A
								positive number indicates an absolute size in pixels. A negative number
								indicates a proportion of the available space
		@see getItemLayout
	*/
	void setItemLayout (int itemIndex,
						double minimumSize,
						double maximumSize,
						double preferredSize);

	/** For a numbered item, this returns its size limits and preferred size.

		@param itemIndex        the index of the item.
		@param minimumSize      the minimum size that this item is allowed to be - a positive number
								indicates an absolute size in pixels. A negative number indicates a
								proportion of the available space (e.g -0.5 is 50%)
		@param maximumSize      the maximum size that this item is allowed to be - a positive number
								indicates an absolute size in pixels. A negative number indicates a
								proportion of the available space
		@param preferredSize    the size that this item would like to be, if there's enough room. A
								positive number indicates an absolute size in pixels. A negative number
								indicates a proportion of the available space
		@returns false if the item's properties hadn't been set
		@see setItemLayout
	*/
	bool getItemLayout (int itemIndex,
						double& minimumSize,
						double& maximumSize,
						double& preferredSize) const;

	/** Clears all the properties that have been set with setItemLayout() and resets
		this object to its initial state.
	*/
	void clearAllItems();

	/** Takes a set of components that correspond to the layout's items, and positions
		them to fill a space.

		This will try to give each item its preferred size, whether that's a relative size
		or an absolute one.

		@param components       an array of components that correspond to each of the
								numbered items that the StretchableLayoutManager object
								has been told about with setItemLayout()
		@param numComponents    the number of components in the array that is passed-in. This
								should be the same as the number of items this object has been
								told about.
		@param x                the left of the rectangle in which the components should
								be laid out
		@param y                the top of the rectangle in which the components should
								be laid out
		@param width            the width of the rectangle in which the components should
								be laid out
		@param height           the height of the rectangle in which the components should
								be laid out
		@param vertically       if true, the components will be positioned in a vertical stack,
								so that they fill the height of the rectangle. If false, they
								will be placed side-by-side in a horizontal line, filling the
								available width
		@param resizeOtherDimension     if true, this means that the components will have their
								other dimension resized to fit the space - i.e. if the 'vertically'
								parameter is true, their x-positions and widths are adjusted to fit
								the x and width parameters; if 'vertically' is false, their y-positions
								and heights are adjusted to fit the y and height parameters.
	*/
	void layOutComponents (Component** components,
						   int numComponents,
						   int x, int y, int width, int height,
						   bool vertically,
						   bool resizeOtherDimension);

	/** Returns the current position of one of the items.

		This is only a valid call after layOutComponents() has been called, as it
		returns the last position that this item was placed at. If the layout was
		vertical, the value returned will be the y position of the top of the item,
		relative to the top of the rectangle in which the items were placed (so for
		example, item 0 will always have position of 0, even in the rectangle passed
		in to layOutComponents() wasn't at y = 0). If the layout was done horizontally,
		the position returned is the item's left-hand position, again relative to the
		x position of the rectangle used.

		@see getItemCurrentSize, setItemPosition
	*/
	int getItemCurrentPosition (int itemIndex) const;

	/** Returns the current size of one of the items.

		This is only meaningful after layOutComponents() has been called, as it
		returns the last size that this item was given. If the layout was done
		vertically, it'll return the item's height in pixels; if it was horizontal,
		it'll return its width.

		@see getItemCurrentRelativeSize
	*/
	int getItemCurrentAbsoluteSize (int itemIndex) const;

	/** Returns the current size of one of the items.

		This is only meaningful after layOutComponents() has been called, as it
		returns the last size that this item was given. If the layout was done
		vertically, it'll return a negative value representing the item's height relative
		to the last size used for laying the components out; if the layout was done
		horizontally it'll be the proportion of its width.

		@see getItemCurrentAbsoluteSize
	*/
	double getItemCurrentRelativeSize (int itemIndex) const;

	/** Moves one of the items, shifting along any other items as necessary in
		order to get it to the desired position.

		Calling this method will also update the preferred sizes of the items it
		shuffles along, so that they reflect their new positions.

		(This is the method that a StretchableLayoutResizerBar uses to shift the items
		about when it's dragged).

		@param itemIndex        the item to move
		@param newPosition      the absolute position that you'd like this item to move
								to. The item might not be able to always reach exactly this position,
								because other items may have minimum sizes that constrain how
								far it can go
	*/
	void setItemPosition (int itemIndex,
						  int newPosition);

private:

	struct ItemLayoutProperties
	{
		int itemIndex;
		int currentSize;
		double minSize, maxSize, preferredSize;
	};

	OwnedArray <ItemLayoutProperties> items;
	int totalSize;

	static int sizeToRealSize (double size, int totalSpace);
	ItemLayoutProperties* getInfoFor (int itemIndex) const;
	void setTotalSize (int newTotalSize);
	int fitComponentsIntoSpace (int startIndex, int endIndex, int availableSpace, int startPos);
	int getMinimumSizeOfItems (int startIndex, int endIndex) const;
	int getMaximumSizeOfItems (int startIndex, int endIndex) const;
	void updatePrefSizesToMatchCurrentPositions();

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (StretchableLayoutManager);
};

#endif   // __JUCE_STRETCHABLELAYOUTMANAGER_JUCEHEADER__

/*** End of inlined file: juce_StretchableLayoutManager.h ***/


#endif
#ifndef __JUCE_STRETCHABLELAYOUTRESIZERBAR_JUCEHEADER__

/*** Start of inlined file: juce_StretchableLayoutResizerBar.h ***/
#ifndef __JUCE_STRETCHABLELAYOUTRESIZERBAR_JUCEHEADER__
#define __JUCE_STRETCHABLELAYOUTRESIZERBAR_JUCEHEADER__

/**
	A component that acts as one of the vertical or horizontal bars you see being
	used to resize panels in a window.

	One of these acts with a StretchableLayoutManager to resize the other components.

	@see StretchableLayoutManager
*/
class JUCE_API  StretchableLayoutResizerBar  : public Component
{
public:

	/** Creates a resizer bar for use on a specified layout.

		@param layoutToUse          the layout that will be affected when this bar
									is dragged
		@param itemIndexInLayout    the item index in the layout that corresponds to
									this bar component. You'll need to set up the item
									properties in a suitable way for a divider bar, e.g.
									for an 8-pixel wide bar which, you could call
									myLayout->setItemLayout (barIndex, 8, 8, 8)
		@param isBarVertical        true if it's an upright bar that you drag left and
									right; false for a horizontal one that you drag up and
									down
	*/
	StretchableLayoutResizerBar (StretchableLayoutManager* layoutToUse,
								 int itemIndexInLayout,
								 bool isBarVertical);

	/** Destructor. */
	~StretchableLayoutResizerBar();

	/** This is called when the bar is dragged.

		This method must update the positions of any components whose position is
		determined by the StretchableLayoutManager, because they might have just
		moved.

		The default implementation calls the resized() method of this component's
		parent component, because that's often where you're likely to apply the
		layout, but it can be overridden for more specific needs.
	*/
	virtual void hasBeenMoved();

	/** @internal */
	void paint (Graphics& g);
	/** @internal */
	void mouseDown (const MouseEvent& e);
	/** @internal */
	void mouseDrag (const MouseEvent& e);

private:

	StretchableLayoutManager* layout;
	int itemIndex, mouseDownPos;
	bool isVertical;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (StretchableLayoutResizerBar);
};

#endif   // __JUCE_STRETCHABLELAYOUTRESIZERBAR_JUCEHEADER__

/*** End of inlined file: juce_StretchableLayoutResizerBar.h ***/


#endif
#ifndef __JUCE_STRETCHABLEOBJECTRESIZER_JUCEHEADER__

/*** Start of inlined file: juce_StretchableObjectResizer.h ***/
#ifndef __JUCE_STRETCHABLEOBJECTRESIZER_JUCEHEADER__
#define __JUCE_STRETCHABLEOBJECTRESIZER_JUCEHEADER__

/**
	A utility class for fitting a set of objects whose sizes can vary between
	a minimum and maximum size, into a space.

	This is a trickier algorithm than it would first seem, so I've put it in this
	class to allow it to be shared by various bits of code.

	To use it, create one of these objects, call addItem() to add the list of items
	you need, then call resizeToFit(), which will change all their sizes. You can
	then retrieve the new sizes with getItemSize() and getNumItems().

	It's currently used by the TableHeaderComponent for stretching out the table
	headings to fill the table's width.
*/
class StretchableObjectResizer
{
public:

	/** Creates an empty object resizer. */
	StretchableObjectResizer();

	/** Destructor. */
	~StretchableObjectResizer();

	/** Adds an item to the list.

		The order parameter lets you specify groups of items that are resized first when some
		space needs to be found. Those items with an order of 0 will be the first ones to be
		resized, and if that doesn't provide enough space to meet the requirements, the algorithm
		will then try resizing the items with an order of 1, then 2, and so on.
	*/
	void addItem (double currentSize,
				  double minSize,
				  double maxSize,
				  int order = 0);

	/** Resizes all the items to fit this amount of space.

		This will attempt to fit them in without exceeding each item's miniumum and
		maximum sizes. In cases where none of the items can be expanded or enlarged any
		further, the final size may be greater or less than the size passed in.

		After calling this method, you can retrieve the new sizes with the getItemSize()
		method.
	*/
	void resizeToFit (double targetSize);

	/** Returns the number of items that have been added. */
	int getNumItems() const noexcept                        { return items.size(); }

	/** Returns the size of one of the items. */
	double getItemSize (int index) const noexcept;

private:

	struct Item
	{
		double size;
		double minSize;
		double maxSize;
		int order;
	};

	OwnedArray <Item> items;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (StretchableObjectResizer);
};

#endif   // __JUCE_STRETCHABLEOBJECTRESIZER_JUCEHEADER__

/*** End of inlined file: juce_StretchableObjectResizer.h ***/


#endif
#ifndef __JUCE_TABBEDBUTTONBAR_JUCEHEADER__

#endif
#ifndef __JUCE_TABBEDCOMPONENT_JUCEHEADER__

#endif
#ifndef __JUCE_VIEWPORT_JUCEHEADER__

#endif
#ifndef __JUCE_LOOKANDFEEL_JUCEHEADER__

/*** Start of inlined file: juce_LookAndFeel.h ***/
#ifndef __JUCE_LOOKANDFEEL_JUCEHEADER__
#define __JUCE_LOOKANDFEEL_JUCEHEADER__


/*** Start of inlined file: juce_Slider.h ***/
#ifndef __JUCE_SLIDER_JUCEHEADER__
#define __JUCE_SLIDER_JUCEHEADER__

/**
	A slider control for changing a value.

	The slider can be horizontal, vertical, or rotary, and can optionally have
	a text-box inside it to show an editable display of the current value.

	To use it, create a Slider object and use the setSliderStyle() method
	to set up the type you want. To set up the text-entry box, use setTextBoxStyle().

	To define the values that it can be set to, see the setRange() and setValue() methods.

	There are also lots of custom tweaks you can do by subclassing and overriding
	some of the virtual methods, such as changing the scaling, changing the format of
	the text display, custom ways of limiting the values, etc.

	You can register Slider::Listener objects with a slider, and they'll be called when
	the value changes.

	@see Slider::Listener
*/
class JUCE_API  Slider  : public Component,
						  public SettableTooltipClient,
						  public AsyncUpdater,
						  public ButtonListener,  // (can't use Button::Listener due to idiotic VC2005 bug)
						  public LabelListener,
						  public ValueListener
{
public:

	/** Creates a slider.

		When created, you'll need to set up the slider's style and range with setSliderStyle(),
		setRange(), etc.
	*/
	explicit Slider (const String& componentName = String::empty);

	/** Destructor. */
	~Slider();

	/** The types of slider available.

		@see setSliderStyle, setRotaryParameters
	*/
	enum SliderStyle
	{
		LinearHorizontal,       /**< A traditional horizontal slider. */
		LinearVertical,         /**< A traditional vertical slider. */
		LinearBar,              /**< A horizontal bar slider with the text label drawn on top of it. */
		Rotary,                 /**< A rotary control that you move by dragging the mouse in a circular motion, like a knob.
									 @see setRotaryParameters */
		RotaryHorizontalDrag,   /**< A rotary control that you move by dragging the mouse left-to-right.
									 @see setRotaryParameters */
		RotaryVerticalDrag,     /**< A rotary control that you move by dragging the mouse up-and-down.
									 @see setRotaryParameters */
		IncDecButtons,          /**< A pair of buttons that increment or decrement the slider's value by the increment set in setRange(). */

		TwoValueHorizontal,     /**< A horizontal slider that has two thumbs instead of one, so it can show a minimum and maximum value.
									 @see setMinValue, setMaxValue */
		TwoValueVertical,       /**< A vertical slider that has two thumbs instead of one, so it can show a minimum and maximum value.
									 @see setMinValue, setMaxValue */

		ThreeValueHorizontal,   /**< A horizontal slider that has three thumbs instead of one, so it can show a minimum and maximum
									 value, with the current value being somewhere between them.
									 @see setMinValue, setMaxValue */
		ThreeValueVertical,     /**< A vertical slider that has three thumbs instead of one, so it can show a minimum and maximum
									 value, with the current value being somewhere between them.
									 @see setMinValue, setMaxValue */
	};

	/** Changes the type of slider interface being used.

		@param newStyle         the type of interface
		@see setRotaryParameters, setVelocityBasedMode,
	*/
	void setSliderStyle (SliderStyle newStyle);

	/** Returns the slider's current style.

		@see setSliderStyle
	*/
	SliderStyle getSliderStyle() const noexcept                 { return style; }

	/** Changes the properties of a rotary slider.

		@param startAngleRadians        the angle (in radians, clockwise from the top) at which
										the slider's minimum value is represented
		@param endAngleRadians          the angle (in radians, clockwise from the top) at which
										the slider's maximum value is represented. This must be
										greater than startAngleRadians
		@param stopAtEnd                if true, then when the slider is dragged around past the
										minimum or maximum, it'll stop there; if false, it'll wrap
										back to the opposite value
	*/
	void setRotaryParameters (float startAngleRadians,
							  float endAngleRadians,
							  bool stopAtEnd);

	/** Sets the distance the mouse has to move to drag the slider across
		the full extent of its range.

		This only applies when in modes like RotaryHorizontalDrag, where it's using
		relative mouse movements to adjust the slider.
	*/
	void setMouseDragSensitivity (int distanceForFullScaleDrag);

	/** Returns the current sensitivity value set by setMouseDragSensitivity(). */
	int getMouseDragSensitivity() const noexcept                { return pixelsForFullDragExtent; }

	/** Changes the way the the mouse is used when dragging the slider.

		If true, this will turn on velocity-sensitive dragging, so that
		the faster the mouse moves, the bigger the movement to the slider. This
		helps when making accurate adjustments if the slider's range is quite large.

		If false, the slider will just try to snap to wherever the mouse is.
	*/
	void setVelocityBasedMode (bool isVelocityBased);

	/** Returns true if velocity-based mode is active.
		@see setVelocityBasedMode
	*/
	bool getVelocityBasedMode() const noexcept                  { return isVelocityBased; }

	/** Changes aspects of the scaling used when in velocity-sensitive mode.

		These apply when you've used setVelocityBasedMode() to turn on velocity mode,
		or if you're holding down ctrl.

		@param sensitivity      higher values than 1.0 increase the range of acceleration used
		@param threshold        the minimum number of pixels that the mouse needs to move for it
								to be treated as a movement
		@param offset           values greater than 0.0 increase the minimum speed that will be used when
								the threshold is reached
		@param userCanPressKeyToSwapMode    if true, then the user can hold down the ctrl or command
								key to toggle velocity-sensitive mode
	*/
	void setVelocityModeParameters (double sensitivity = 1.0,
									int threshold = 1,
									double offset = 0.0,
									bool userCanPressKeyToSwapMode = true);

	/** Returns the velocity sensitivity setting.
		@see setVelocityModeParameters
	*/
	double getVelocitySensitivity() const noexcept              { return velocityModeSensitivity; }

	/** Returns the velocity threshold setting.
		@see setVelocityModeParameters
	*/
	int getVelocityThreshold() const noexcept                   { return velocityModeThreshold; }

	/** Returns the velocity offset setting.
		@see setVelocityModeParameters
	*/
	double getVelocityOffset() const noexcept                   { return velocityModeOffset; }

	/** Returns the velocity user key setting.
		@see setVelocityModeParameters
	*/
	bool getVelocityModeIsSwappable() const noexcept            { return userKeyOverridesVelocity; }

	/** Sets up a skew factor to alter the way values are distributed.

		You may want to use a range of values on the slider where more accuracy
		is required towards one end of the range, so this will logarithmically
		spread the values across the length of the slider.

		If the factor is < 1.0, the lower end of the range will fill more of the
		slider's length; if the factor is > 1.0, the upper end of the range
		will be expanded instead. A factor of 1.0 doesn't skew it at all.

		To set the skew position by using a mid-point, use the setSkewFactorFromMidPoint()
		method instead.

		@see getSkewFactor, setSkewFactorFromMidPoint
	*/
	void setSkewFactor (double factor);

	/** Sets up a skew factor to alter the way values are distributed.

		This allows you to specify the slider value that should appear in the
		centre of the slider's visible range.

		@see setSkewFactor, getSkewFactor
	 */
	void setSkewFactorFromMidPoint (double sliderValueToShowAtMidPoint);

	/** Returns the current skew factor.

		See setSkewFactor for more info.

		@see setSkewFactor, setSkewFactorFromMidPoint
	*/
	double getSkewFactor() const noexcept                       { return skewFactor; }

	/** Used by setIncDecButtonsMode().
	*/
	enum IncDecButtonMode
	{
		incDecButtonsNotDraggable,
		incDecButtonsDraggable_AutoDirection,
		incDecButtonsDraggable_Horizontal,
		incDecButtonsDraggable_Vertical
	};

	/** When the style is IncDecButtons, this lets you turn on a mode where the mouse
		can be dragged on the buttons to drag the values.

		By default this is turned off. When enabled, clicking on the buttons still works
		them as normal, but by holding down the mouse on a button and dragging it a little
		distance, it flips into a mode where the value can be dragged. The drag direction can
		either be set explicitly to be vertical or horizontal, or can be set to
		incDecButtonsDraggable_AutoDirection so that it depends on whether the buttons
		are side-by-side or above each other.
	*/
	void setIncDecButtonsMode (IncDecButtonMode mode);

	/** The position of the slider's text-entry box.

		@see setTextBoxStyle
	*/
	enum TextEntryBoxPosition
	{
		NoTextBox,              /**< Doesn't display a text box.  */
		TextBoxLeft,            /**< Puts the text box to the left of the slider, vertically centred.  */
		TextBoxRight,           /**< Puts the text box to the right of the slider, vertically centred.  */
		TextBoxAbove,           /**< Puts the text box above the slider, horizontally centred.  */
		TextBoxBelow            /**< Puts the text box below the slider, horizontally centred.  */
	};

	/** Changes the location and properties of the text-entry box.

		@param newPosition          where it should go (or NoTextBox to not have one at all)
		@param isReadOnly           if true, it's a read-only display
		@param textEntryBoxWidth    the width of the text-box in pixels. Make sure this leaves enough
									room for the slider as well!
		@param textEntryBoxHeight   the height of the text-box in pixels. Make sure this leaves enough
									room for the slider as well!

		@see setTextBoxIsEditable, getValueFromText, getTextFromValue
	*/
	void setTextBoxStyle (TextEntryBoxPosition newPosition,
						  bool isReadOnly,
						  int textEntryBoxWidth,
						  int textEntryBoxHeight);

	/** Returns the status of the text-box.
		@see setTextBoxStyle
	*/
	const TextEntryBoxPosition getTextBoxPosition() const noexcept          { return textBoxPos; }

	/** Returns the width used for the text-box.
		@see setTextBoxStyle
	*/
	int getTextBoxWidth() const noexcept                                    { return textBoxWidth; }

	/** Returns the height used for the text-box.
		@see setTextBoxStyle
	*/
	int getTextBoxHeight() const noexcept                                   { return textBoxHeight; }

	/** Makes the text-box editable.

		By default this is true, and the user can enter values into the textbox,
		but it can be turned off if that's not suitable.

		@see setTextBoxStyle, getValueFromText, getTextFromValue
	*/
	void setTextBoxIsEditable (bool shouldBeEditable);

	/** Returns true if the text-box is read-only.
		@see setTextBoxStyle
	*/
	bool isTextBoxEditable() const                                          { return editableText; }

	/** If the text-box is editable, this will give it the focus so that the user can
		type directly into it.

		This is basically the effect as the user clicking on it.
	*/
	void showTextBox();

	/** If the text-box currently has focus and is being edited, this resets it and takes keyboard
		focus away from it.

		@param discardCurrentEditorContents     if true, the slider's value will be left
												unchanged; if false, the current contents of the
												text editor will be used to set the slider position
												before it is hidden.
	*/
	void hideTextBox (bool discardCurrentEditorContents);

	/** Changes the slider's current value.

		This will trigger a callback to Slider::Listener::sliderValueChanged() for any listeners
		that are registered, and will synchronously call the valueChanged() method in case subclasses
		want to handle it.

		@param newValue                 the new value to set - this will be restricted by the
										minimum and maximum range, and will be snapped to the
										nearest interval if one has been set
		@param sendUpdateMessage        if false, a change to the value will not trigger a call to
										any Slider::Listeners or the valueChanged() method
		@param sendMessageSynchronously if true, then a call to the Slider::Listeners will be made
										synchronously; if false, it will be asynchronous
	*/
	void setValue (double newValue,
				   bool sendUpdateMessage = true,
				   bool sendMessageSynchronously = false);

	/** Returns the slider's current value. */
	double getValue() const;

	/** Returns the Value object that represents the slider's current position.
		You can use this Value object to connect the slider's position to external values or setters,
		either by taking a copy of the Value, or by using Value::referTo() to make it point to
		your own Value object.
		@see Value, getMaxValue, getMinValueObject
	*/
	Value& getValueObject()                                                 { return currentValue; }

	/** Sets the limits that the slider's value can take.

		@param newMinimum   the lowest value allowed
		@param newMaximum   the highest value allowed
		@param newInterval  the steps in which the value is allowed to increase - if this
							is not zero, the value will always be (newMinimum + (newInterval * an integer)).
	*/
	void setRange (double newMinimum,
				   double newMaximum,
				   double newInterval = 0);

	/** Returns the current maximum value.
		@see setRange
	*/
	double getMaximum() const                                               { return maximum; }

	/** Returns the current minimum value.
		@see setRange
	*/
	double getMinimum() const                                               { return minimum; }

	/** Returns the current step-size for values.
		@see setRange
	*/
	double getInterval() const                                              { return interval; }

	/** For a slider with two or three thumbs, this returns the lower of its values.

		For a two-value slider, the values are controlled with getMinValue() and getMaxValue().
		A slider with three values also uses the normal getValue() and setValue() methods to
		control the middle value.

		@see setMinValue, getMaxValue, TwoValueHorizontal, TwoValueVertical, ThreeValueHorizontal, ThreeValueVertical
	*/
	double getMinValue() const;

	/** For a slider with two or three thumbs, this returns the lower of its values.
		You can use this Value object to connect the slider's position to external values or setters,
		either by taking a copy of the Value, or by using Value::referTo() to make it point to
		your own Value object.
		@see Value, getMinValue, getMaxValueObject
	*/
	Value& getMinValueObject() noexcept                                     { return valueMin; }

	/** For a slider with two or three thumbs, this sets the lower of its values.

		This will trigger a callback to Slider::Listener::sliderValueChanged() for any listeners
		that are registered, and will synchronously call the valueChanged() method in case subclasses
		want to handle it.

		@param newValue                 the new value to set - this will be restricted by the
										minimum and maximum range, and will be snapped to the nearest
										interval if one has been set.
		@param sendUpdateMessage        if false, a change to the value will not trigger a call to
										any Slider::Listeners or the valueChanged() method
		@param sendMessageSynchronously if true, then a call to the Slider::Listeners will be made
										synchronously; if false, it will be asynchronous
		@param allowNudgingOfOtherValues  if false, this value will be restricted to being below the
										max value (in a two-value slider) or the mid value (in a three-value
										slider). If false, then if this value goes beyond those values,
										it will push them along with it.
		@see getMinValue, setMaxValue, setValue
	*/
	void setMinValue (double newValue,
					  bool sendUpdateMessage = true,
					  bool sendMessageSynchronously = false,
					  bool allowNudgingOfOtherValues = false);

	/** For a slider with two or three thumbs, this returns the higher of its values.

		For a two-value slider, the values are controlled with getMinValue() and getMaxValue().
		A slider with three values also uses the normal getValue() and setValue() methods to
		control the middle value.

		@see getMinValue, TwoValueHorizontal, TwoValueVertical, ThreeValueHorizontal, ThreeValueVertical
	*/
	double getMaxValue() const;

	/** For a slider with two or three thumbs, this returns the higher of its values.
		You can use this Value object to connect the slider's position to external values or setters,
		either by taking a copy of the Value, or by using Value::referTo() to make it point to
		your own Value object.
		@see Value, getMaxValue, getMinValueObject
	*/
	Value& getMaxValueObject() noexcept                                     { return valueMax; }

	/** For a slider with two or three thumbs, this sets the lower of its values.

		This will trigger a callback to Slider::Listener::sliderValueChanged() for any listeners
		that are registered, and will synchronously call the valueChanged() method in case subclasses
		want to handle it.

		@param newValue                 the new value to set - this will be restricted by the
										minimum and maximum range, and will be snapped to the nearest
										interval if one has been set.
		@param sendUpdateMessage        if false, a change to the value will not trigger a call to
										any Slider::Listeners or the valueChanged() method
		@param sendMessageSynchronously if true, then a call to the Slider::Listeners will be made
										synchronously; if false, it will be asynchronous
		@param allowNudgingOfOtherValues  if false, this value will be restricted to being above the
										min value (in a two-value slider) or the mid value (in a three-value
										slider). If false, then if this value goes beyond those values,
										it will push them along with it.
		@see getMaxValue, setMinValue, setValue
	*/
	void setMaxValue (double newValue,
					  bool sendUpdateMessage = true,
					  bool sendMessageSynchronously = false,
					  bool allowNudgingOfOtherValues = false);

	/** For a slider with two or three thumbs, this sets the minimum and maximum thumb positions.

		This will trigger a callback to Slider::Listener::sliderValueChanged() for any listeners
		that are registered, and will synchronously call the valueChanged() method in case subclasses
		want to handle it.

		@param newMinValue              the new minimum value to set - this will be snapped to the
										nearest interval if one has been set.
		@param newMaxValue              the new minimum value to set - this will be snapped to the
										nearest interval if one has been set.
		@param sendUpdateMessage        if false, a change to the value will not trigger a call to
										any Slider::Listeners or the valueChanged() method
		@param sendMessageSynchronously if true, then a call to the Slider::Listeners will be made
										synchronously; if false, it will be asynchronous
		@see setMaxValue, setMinValue, setValue
	*/
	void setMinAndMaxValues (double newMinValue, double newMaxValue,
							 bool sendUpdateMessage = true,
							 bool sendMessageSynchronously = false);

	/** A class for receiving callbacks from a Slider.

		To be told when a slider's value changes, you can register a Slider::Listener
		object using Slider::addListener().

		@see Slider::addListener, Slider::removeListener
	*/
	class JUCE_API  Listener
	{
	public:

		/** Destructor. */
		virtual ~Listener() {}

		/** Called when the slider's value is changed.

			This may be caused by dragging it, or by typing in its text entry box,
			or by a call to Slider::setValue().

			You can find out the new value using Slider::getValue().

			@see Slider::valueChanged
		*/
		virtual void sliderValueChanged (Slider* slider) = 0;

		/** Called when the slider is about to be dragged.

			This is called when a drag begins, then it's followed by multiple calls
			to sliderValueChanged(), and then sliderDragEnded() is called after the
			user lets go.

			@see sliderDragEnded, Slider::startedDragging
		*/
		virtual void sliderDragStarted (Slider* slider);

		/** Called after a drag operation has finished.

			@see sliderDragStarted, Slider::stoppedDragging
		*/
		virtual void sliderDragEnded (Slider* slider);
	};

	/** Adds a listener to be called when this slider's value changes. */
	void addListener (Listener* listener);

	/** Removes a previously-registered listener. */
	void removeListener (Listener* listener);

	/** This lets you choose whether double-clicking moves the slider to a given position.

		By default this is turned off, but it's handy if you want a double-click to act
		as a quick way of resetting a slider. Just pass in the value you want it to
		go to when double-clicked.

		@see getDoubleClickReturnValue
	*/
	void setDoubleClickReturnValue (bool isDoubleClickEnabled,
									double valueToSetOnDoubleClick);

	/** Returns the values last set by setDoubleClickReturnValue() method.

		Sets isEnabled to true if double-click is enabled, and returns the value
		that was set.

		@see setDoubleClickReturnValue
	*/
	double getDoubleClickReturnValue (bool& isEnabled) const;

	/** Tells the slider whether to keep sending change messages while the user
		is dragging the slider.

		If set to true, a change message will only be sent when the user has
		dragged the slider and let go. If set to false (the default), then messages
		will be continuously sent as they drag it while the mouse button is still
		held down.
	*/
	void setChangeNotificationOnlyOnRelease (bool onlyNotifyOnRelease);

	/** This lets you change whether the slider thumb jumps to the mouse position
		when you click.

		By default, this is true. If it's false, then the slider moves with relative
		motion when you drag it.

		This only applies to linear bars, and won't affect two- or three- value
		sliders.
	*/
	void setSliderSnapsToMousePosition (bool shouldSnapToMouse);

	/** Returns true if setSliderSnapsToMousePosition() has been enabled. */
	bool getSliderSnapsToMousePosition() const noexcept         { return snapsToMousePos; }

	/** If enabled, this gives the slider a pop-up bubble which appears while the
		slider is being dragged.

		This can be handy if your slider doesn't have a text-box, so that users can
		see the value just when they're changing it.

		If you pass a component as the parentComponentToUse parameter, the pop-up
		bubble will be added as a child of that component when it's needed. If you
		pass 0, the pop-up will be placed on the desktop instead (note that it's a
		transparent window, so if you're using an OS that can't do transparent windows
		you'll have to add it to a parent component instead).
	*/
	void setPopupDisplayEnabled (bool isEnabled,
								 Component* parentComponentToUse);

	/** If a popup display is enabled and is currently visible, this returns the component
		that is being shown, or nullptr if none is currently in use.
		@see setPopupDisplayEnabled
	*/
	Component* getCurrentPopupDisplay() const noexcept;

	/** If this is set to true, then right-clicking on the slider will pop-up
		a menu to let the user change the way it works.

		By default this is turned off, but when turned on, the menu will include
		things like velocity sensitivity, and for rotary sliders, whether they
		use a linear or rotary mouse-drag to move them.
	*/
	void setPopupMenuEnabled (bool menuEnabled);

	/** This can be used to stop the mouse scroll-wheel from moving the slider.

		By default it's enabled.
	*/
	void setScrollWheelEnabled (bool enabled);

	/** Returns a number to indicate which thumb is currently being dragged by the
		mouse.

		This will return 0 for the main thumb, 1 for the minimum-value thumb, 2 for
		the maximum-value thumb, or -1 if none is currently down.
	*/
	int getThumbBeingDragged() const noexcept               { return sliderBeingDragged; }

	/** Callback to indicate that the user is about to start dragging the slider.

		@see Slider::Listener::sliderDragStarted
	*/
	virtual void startedDragging();

	/** Callback to indicate that the user has just stopped dragging the slider.

		@see Slider::Listener::sliderDragEnded
	*/
	virtual void stoppedDragging();

	/** Callback to indicate that the user has just moved the slider.

		@see Slider::Listener::sliderValueChanged
	*/
	virtual void valueChanged();

	/** Subclasses can override this to convert a text string to a value.

		When the user enters something into the text-entry box, this method is
		called to convert it to a value.

		The default routine just tries to convert it to a double.

		@see getTextFromValue
	*/
	virtual double getValueFromText (const String& text);

	/** Turns the slider's current value into a text string.

		Subclasses can override this to customise the formatting of the text-entry box.

		The default implementation just turns the value into a string, using
		a number of decimal places based on the range interval. If a suffix string
		has been set using setTextValueSuffix(), this will be appended to the text.

		@see getValueFromText
	*/
	virtual String getTextFromValue (double value);

	/** Sets a suffix to append to the end of the numeric value when it's displayed as
		a string.

		This is used by the default implementation of getTextFromValue(), and is just
		appended to the numeric value. For more advanced formatting, you can override
		getTextFromValue() and do something else.
	*/
	void setTextValueSuffix (const String& suffix);

	/** Returns the suffix that was set by setTextValueSuffix(). */
	String getTextValueSuffix() const;

	/** Allows a user-defined mapping of distance along the slider to its value.

		The default implementation for this performs the skewing operation that
		can be set up in the setSkewFactor() method. Override it if you need
		some kind of custom mapping instead, but make sure you also implement the
		inverse function in valueToProportionOfLength().

		@param proportion       a value 0 to 1.0, indicating a distance along the slider
		@returns                the slider value that is represented by this position
		@see valueToProportionOfLength
	*/
	virtual double proportionOfLengthToValue (double proportion);

	/** Allows a user-defined mapping of value to the position of the slider along its length.

		The default implementation for this performs the skewing operation that
		can be set up in the setSkewFactor() method. Override it if you need
		some kind of custom mapping instead, but make sure you also implement the
		inverse function in proportionOfLengthToValue().

		@param value            a valid slider value, between the range of values specified in
								setRange()
		@returns                a value 0 to 1.0 indicating the distance along the slider that
								represents this value
		@see proportionOfLengthToValue
	*/
	virtual double valueToProportionOfLength (double value);

	/** Returns the X or Y coordinate of a value along the slider's length.

		If the slider is horizontal, this will be the X coordinate of the given
		value, relative to the left of the slider. If it's vertical, then this will
		be the Y coordinate, relative to the top of the slider.

		If the slider is rotary, this will throw an assertion and return 0. If the
		value is out-of-range, it will be constrained to the length of the slider.
	*/
	float getPositionOfValue (double value);

	/** This can be overridden to allow the slider to snap to user-definable values.

		If overridden, it will be called when the user tries to move the slider to
		a given position, and allows a subclass to sanity-check this value, possibly
		returning a different value to use instead.

		@param attemptedValue       the value the user is trying to enter
		@param userIsDragging       true if the user is dragging with the mouse; false if
									they are entering the value using the text box
		@returns                    the value to use instead
	*/
	virtual double snapValue (double attemptedValue, bool userIsDragging);

	/** This can be called to force the text box to update its contents.

		(Not normally needed, as this is done automatically).
	*/
	void updateText();

	/** True if the slider moves horizontally. */
	bool isHorizontal() const;
	/** True if the slider moves vertically. */
	bool isVertical() const;

	/** A set of colour IDs to use to change the colour of various aspects of the slider.

		These constants can be used either via the Component::setColour(), or LookAndFeel::setColour()
		methods.

		@see Component::setColour, Component::findColour, LookAndFeel::setColour, LookAndFeel::findColour
	*/
	enum ColourIds
	{
		backgroundColourId          = 0x1001200,  /**< A colour to use to fill the slider's background. */
		thumbColourId               = 0x1001300,  /**< The colour to draw the thumb with. It's up to the look
													   and feel class how this is used. */
		trackColourId               = 0x1001310,  /**< The colour to draw the groove that the thumb moves along. */
		rotarySliderFillColourId    = 0x1001311,  /**< For rotary sliders, this colour fills the outer curve. */
		rotarySliderOutlineColourId = 0x1001312,  /**< For rotary sliders, this colour is used to draw the outer curve's outline. */

		textBoxTextColourId         = 0x1001400,  /**< The colour for the text in the text-editor box used for editing the value. */
		textBoxBackgroundColourId   = 0x1001500,  /**< The background colour for the text-editor box. */
		textBoxHighlightColourId    = 0x1001600,  /**< The text highlight colour for the text-editor box. */
		textBoxOutlineColourId      = 0x1001700   /**< The colour to use for a border around the text-editor box. */
	};

	struct Ids
	{
		static const Identifier tagType, min, max, interval, type, editable,
								textBoxPos, textBoxWidth, textBoxHeight, skew;
	};

	void refreshFromValueTree (const ValueTree&, ComponentBuilder&);

protected:

	/** @internal */
	void labelTextChanged (Label*);
	/** @internal */
	void paint (Graphics& g);
	/** @internal */
	void resized();
	/** @internal */
	void mouseDown (const MouseEvent& e);
	/** @internal */
	void mouseUp (const MouseEvent& e);
	/** @internal */
	void mouseDrag (const MouseEvent& e);
	/** @internal */
	void mouseDoubleClick (const MouseEvent& e);
	/** @internal */
	void mouseWheelMove (const MouseEvent& e, float wheelIncrementX, float wheelIncrementY);
	/** @internal */
	void modifierKeysChanged (const ModifierKeys& modifiers);
	/** @internal */
	void buttonClicked (Button* button);
	/** @internal */
	void lookAndFeelChanged();
	/** @internal */
	void enablementChanged();
	/** @internal */
	void focusOfChildComponentChanged (FocusChangeType cause);
	/** @internal */
	void handleAsyncUpdate();
	/** @internal */
	void colourChanged();
	/** @internal */
	void valueChanged (Value& value);

	/** Returns the best number of decimal places to use when displaying numbers.
		This is calculated from the slider's interval setting.
	*/
	int getNumDecimalPlacesToDisplay() const noexcept       { return numDecimalPlaces; }

private:

	ListenerList <Listener> listeners;
	Value currentValue, valueMin, valueMax;
	double lastCurrentValue, lastValueMin, lastValueMax;
	double minimum, maximum, interval, doubleClickReturnValue;
	double valueWhenLastDragged, valueOnMouseDown, skewFactor, lastAngle;
	double velocityModeSensitivity, velocityModeOffset, minMaxDiff;
	int velocityModeThreshold;
	float rotaryStart, rotaryEnd;
	int numDecimalPlaces;
	Point<int> mouseDragStartPos, mousePosWhenLastDragged;
	int sliderRegionStart, sliderRegionSize;
	int sliderBeingDragged;
	int pixelsForFullDragExtent;
	Rectangle<int> sliderRect;
	String textSuffix;

	SliderStyle style;
	TextEntryBoxPosition textBoxPos;
	int textBoxWidth, textBoxHeight;
	IncDecButtonMode incDecButtonMode;

	bool editableText : 1, doubleClickToValue : 1;
	bool isVelocityBased : 1, userKeyOverridesVelocity : 1, rotaryStop : 1;
	bool incDecButtonsSideBySide : 1, sendChangeOnlyOnRelease : 1, popupDisplayEnabled : 1;
	bool menuEnabled : 1, menuShown : 1, mouseWasHidden : 1, incDecDragged : 1;
	bool scrollWheelEnabled : 1, snapsToMousePos : 1;
	ScopedPointer<Label> valueBox;
	ScopedPointer<Button> incButton, decButton;

	class PopupDisplayComponent;
	friend class PopupDisplayComponent;
	friend class ScopedPointer <PopupDisplayComponent>;
	ScopedPointer <PopupDisplayComponent> popupDisplay;
	Component* parentForPopupDisplay;

	void showPopupMenu();
	int getThumbIndexAt (const MouseEvent&);
	void handleRotaryDrag (const MouseEvent&);
	void handleAbsoluteDrag (const MouseEvent&);
	void handleVelocityDrag (const MouseEvent&);
	float getLinearSliderPos (double value);
	void restoreMouseIfHidden();
	void sendDragStart();
	void sendDragEnd();
	double constrainedValue (double value) const;
	void triggerChangeMessage (bool synchronous);
	bool incDecDragDirectionIsHorizontal() const;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (Slider);
};

/** This typedef is just for compatibility with old code - newer code should use the Slider::Listener class directly. */
typedef Slider::Listener SliderListener;

#endif   // __JUCE_SLIDER_JUCEHEADER__

/*** End of inlined file: juce_Slider.h ***/

class ToggleButton;
class TextButton;
class AlertWindow;
class TextLayout;
class ScrollBar;
class ComboBox;
class Button;
class FilenameComponent;
class DocumentWindow;
class ResizableWindow;
class GroupComponent;
class MenuBarComponent;
class DropShadower;
class GlyphArrangement;
class PropertyComponent;
class TableHeaderComponent;
class Toolbar;
class ToolbarItemComponent;
class PopupMenu;
class ProgressBar;
class FileBrowserComponent;
class DirectoryContentsDisplayComponent;
class FilePreviewComponent;
class ImageButton;
class CallOutBox;
class Drawable;
class CaretComponent;

/**
	LookAndFeel objects define the appearance of all the JUCE widgets, and subclasses
	can be used to apply different 'skins' to the application.

*/
class JUCE_API  LookAndFeel
{
public:

	/** Creates the default JUCE look and feel. */
	LookAndFeel();

	/** Destructor. */
	virtual ~LookAndFeel();

	/** Returns the current default look-and-feel for a component to use when it
		hasn't got one explicitly set.

		@see setDefaultLookAndFeel
	*/
	static LookAndFeel& getDefaultLookAndFeel() noexcept;

	/** Changes the default look-and-feel.

		@param newDefaultLookAndFeel    the new look-and-feel object to use - if this is
										set to null, it will revert to using the default one. The
										object passed-in must be deleted by the caller when
										it's no longer needed.
		@see getDefaultLookAndFeel
	*/
	static void setDefaultLookAndFeel (LookAndFeel* newDefaultLookAndFeel) noexcept;

	/** Looks for a colour that has been registered with the given colour ID number.

		If a colour has been set for this ID number using setColour(), then it is
		returned. If none has been set, it will just return Colours::black.

		The colour IDs for various purposes are stored as enums in the components that
		they are relevent to - for an example, see Slider::ColourIds,
		Label::ColourIds, TextEditor::ColourIds, TreeView::ColourIds, etc.

		If you're looking up a colour for use in drawing a component, it's usually
		best not to call this directly, but to use the Component::findColour() method
		instead. That will first check whether a suitable colour has been registered
		directly with the component, and will fall-back on calling the component's
		LookAndFeel's findColour() method if none is found.

		@see setColour, Component::findColour, Component::setColour
	*/
	Colour findColour (int colourId) const noexcept;

	/** Registers a colour to be used for a particular purpose.

		For more details, see the comments for findColour().

		@see findColour, Component::findColour, Component::setColour
	*/
	void setColour (int colourId, const Colour& colour) noexcept;

	/** Returns true if the specified colour ID has been explicitly set using the
		setColour() method.
	*/
	bool isColourSpecified (int colourId) const noexcept;

	virtual const Typeface::Ptr getTypefaceForFont (const Font& font);

	/** Allows you to change the default sans-serif font.

		If you need to supply your own Typeface object for any of the default fonts, rather
		than just supplying the name (e.g. if you want to use an embedded font), then
		you should instead override getTypefaceForFont() to create and return the typeface.
	*/
	void setDefaultSansSerifTypefaceName (const String& newName);

	/** Override this to get the chance to swap a component's mouse cursor for a
		customised one.
	*/
	virtual MouseCursor getMouseCursorFor (Component& component);

	// Creates a new graphics context object.
	virtual LowLevelGraphicsContext* createGraphicsContext (const Image& imageToRenderOn,
															const Point<int>& origin,
															const RectangleList& initialClip);

	/** Draws the lozenge-shaped background for a standard button. */
	virtual void drawButtonBackground (Graphics& g,
									   Button& button,
									   const Colour& backgroundColour,
									   bool isMouseOverButton,
									   bool isButtonDown);

	virtual const Font getFontForTextButton (TextButton& button);

	/** Draws the text for a TextButton. */
	virtual void drawButtonText (Graphics& g,
								 TextButton& button,
								 bool isMouseOverButton,
								 bool isButtonDown);

	/** Draws the contents of a standard ToggleButton. */
	virtual void drawToggleButton (Graphics& g,
								   ToggleButton& button,
								   bool isMouseOverButton,
								   bool isButtonDown);

	virtual void changeToggleButtonWidthToFitText (ToggleButton& button);

	virtual void drawTickBox (Graphics& g,
							  Component& component,
							  float x, float y, float w, float h,
							  bool ticked,
							  bool isEnabled,
							  bool isMouseOverButton,
							  bool isButtonDown);

	/* AlertWindow handling..
	*/
	virtual AlertWindow* createAlertWindow (const String& title,
											const String& message,
											const String& button1,
											const String& button2,
											const String& button3,
											AlertWindow::AlertIconType iconType,
											int numButtons,
											Component* associatedComponent);

	virtual void drawAlertBox (Graphics& g,
							   AlertWindow& alert,
							   const Rectangle<int>& textArea,
							   TextLayout& textLayout);

	virtual int getAlertBoxWindowFlags();

	virtual int getAlertWindowButtonHeight();

	virtual const Font getAlertWindowMessageFont();
	virtual const Font getAlertWindowFont();

	void setUsingNativeAlertWindows (bool shouldUseNativeAlerts);
	bool isUsingNativeAlertWindows();

	/** Draws a progress bar.

		If the progress value is less than 0 or greater than 1.0, this should draw a spinning
		bar that fills the whole space (i.e. to say that the app is still busy but the progress
		isn't known). It can use the current time as a basis for playing an animation.

		(Used by progress bars in AlertWindow).
	*/
	virtual void drawProgressBar (Graphics& g, ProgressBar& progressBar,
								  int width, int height,
								  double progress, const String& textToShow);

	// Draws a small image that spins to indicate that something's happening..
	// This method should use the current time to animate itself, so just keep
	// repainting it every so often.
	virtual void drawSpinningWaitAnimation (Graphics& g, const Colour& colour,
											int x, int y, int w, int h);

	/** Draws one of the buttons on a scrollbar.

		@param g                    the context to draw into
		@param scrollbar            the bar itself
		@param width                the width of the button
		@param height               the height of the button
		@param buttonDirection      the direction of the button, where 0 = up, 1 = right, 2 = down, 3 = left
		@param isScrollbarVertical  true if it's a vertical bar, false if horizontal
		@param isMouseOverButton    whether the mouse is currently over the button (also true if it's held down)
		@param isButtonDown         whether the mouse button's held down
	*/
	virtual void drawScrollbarButton (Graphics& g,
									  ScrollBar& scrollbar,
									  int width, int height,
									  int buttonDirection,
									  bool isScrollbarVertical,
									  bool isMouseOverButton,
									  bool isButtonDown);

	/** Draws the thumb area of a scrollbar.

		@param g                    the context to draw into
		@param scrollbar            the bar itself
		@param x                    the x position of the left edge of the thumb area to draw in
		@param y                    the y position of the top edge of the thumb area to draw in
		@param width                the width of the thumb area to draw in
		@param height               the height of the thumb area to draw in
		@param isScrollbarVertical  true if it's a vertical bar, false if horizontal
		@param thumbStartPosition   for vertical bars, the y co-ordinate of the top of the
									thumb, or its x position for horizontal bars
		@param thumbSize            for vertical bars, the height of the thumb, or its width for
									horizontal bars. This may be 0 if the thumb shouldn't be drawn.
		@param isMouseOver          whether the mouse is over the thumb area, also true if the mouse is
									currently dragging the thumb
		@param isMouseDown          whether the mouse is currently dragging the scrollbar
	*/
	virtual void drawScrollbar (Graphics& g,
								ScrollBar& scrollbar,
								int x, int y,
								int width, int height,
								bool isScrollbarVertical,
								int thumbStartPosition,
								int thumbSize,
								bool isMouseOver,
								bool isMouseDown);

	/** Returns the component effect to use for a scrollbar */
	virtual ImageEffectFilter* getScrollbarEffect();

	/** Returns the minimum length in pixels to use for a scrollbar thumb. */
	virtual int getMinimumScrollbarThumbSize (ScrollBar& scrollbar);

	/** Returns the default thickness to use for a scrollbar. */
	virtual int getDefaultScrollbarWidth();

	/** Returns the length in pixels to use for a scrollbar button. */
	virtual int getScrollbarButtonSize (ScrollBar& scrollbar);

	/** Returns a tick shape for use in yes/no boxes, etc. */
	virtual const Path getTickShape (float height);
	/** Returns a cross shape for use in yes/no boxes, etc. */
	virtual const Path getCrossShape (float height);

	/** Draws the + or - box in a treeview. */
	virtual void drawTreeviewPlusMinusBox (Graphics& g, int x, int y, int w, int h, bool isPlus, bool isMouseOver);

	virtual void fillTextEditorBackground (Graphics& g, int width, int height, TextEditor& textEditor);
	virtual void drawTextEditorOutline (Graphics& g, int width, int height, TextEditor& textEditor);

	virtual CaretComponent* createCaretComponent (Component* keyFocusOwner);

	// These return a pointer to an internally cached drawable - make sure you don't keep
	// a copy of this pointer anywhere, as it may become invalid in the future.
	virtual const Drawable* getDefaultFolderImage();
	virtual const Drawable* getDefaultDocumentFileImage();

	virtual void createFileChooserHeaderText (const String& title,
											  const String& instructions,
											  GlyphArrangement& destArrangement,
											  int width);

	virtual void drawFileBrowserRow (Graphics& g, int width, int height,
									 const String& filename, Image* icon,
									 const String& fileSizeDescription,
									 const String& fileTimeDescription,
									 bool isDirectory,
									 bool isItemSelected,
									 int itemIndex,
									 DirectoryContentsDisplayComponent& component);

	virtual Button* createFileBrowserGoUpButton();

	virtual void layoutFileBrowserComponent (FileBrowserComponent& browserComp,
											 DirectoryContentsDisplayComponent* fileListComponent,
											 FilePreviewComponent* previewComp,
											 ComboBox* currentPathBox,
											 TextEditor* filenameBox,
											 Button* goUpButton);

	virtual void drawBubble (Graphics& g,
							 float tipX, float tipY,
							 float boxX, float boxY, float boxW, float boxH);

	/** Fills the background of a popup menu component. */
	virtual void drawPopupMenuBackground (Graphics& g, int width, int height);

	/** Draws one of the items in a popup menu. */
	virtual void drawPopupMenuItem (Graphics& g,
									int width, int height,
									bool isSeparator,
									bool isActive,
									bool isHighlighted,
									bool isTicked,
									bool hasSubMenu,
									const String& text,
									const String& shortcutKeyText,
									Image* image,
									const Colour* const textColour);

	/** Returns the size and style of font to use in popup menus. */
	virtual const Font getPopupMenuFont();

	virtual void drawPopupMenuUpDownArrow (Graphics& g,
										   int width, int height,
										   bool isScrollUpArrow);

	/** Finds the best size for an item in a popup menu. */
	virtual void getIdealPopupMenuItemSize (const String& text,
											bool isSeparator,
											int standardMenuItemHeight,
											int& idealWidth,
											int& idealHeight);

	virtual int getMenuWindowFlags();

	virtual void drawMenuBarBackground (Graphics& g, int width, int height,
										bool isMouseOverBar,
										MenuBarComponent& menuBar);

	virtual int getMenuBarItemWidth (MenuBarComponent& menuBar, int itemIndex, const String& itemText);

	virtual const Font getMenuBarFont (MenuBarComponent& menuBar, int itemIndex, const String& itemText);

	virtual void drawMenuBarItem (Graphics& g,
								  int width, int height,
								  int itemIndex,
								  const String& itemText,
								  bool isMouseOverItem,
								  bool isMenuOpen,
								  bool isMouseOverBar,
								  MenuBarComponent& menuBar);

	virtual void drawComboBox (Graphics& g, int width, int height,
							   bool isButtonDown,
							   int buttonX, int buttonY,
							   int buttonW, int buttonH,
							   ComboBox& box);

	virtual const Font getComboBoxFont (ComboBox& box);

	virtual Label* createComboBoxTextBox (ComboBox& box);

	virtual void positionComboBoxText (ComboBox& box, Label& labelToPosition);

	virtual void drawLabel (Graphics& g, Label& label);

	virtual void drawLinearSlider (Graphics& g,
								   int x, int y,
								   int width, int height,
								   float sliderPos,
								   float minSliderPos,
								   float maxSliderPos,
								   const Slider::SliderStyle style,
								   Slider& slider);

	virtual void drawLinearSliderBackground (Graphics& g,
											 int x, int y,
											 int width, int height,
											 float sliderPos,
											 float minSliderPos,
											 float maxSliderPos,
											 const Slider::SliderStyle style,
											 Slider& slider);

	virtual void drawLinearSliderThumb (Graphics& g,
										int x, int y,
										int width, int height,
										float sliderPos,
										float minSliderPos,
										float maxSliderPos,
										const Slider::SliderStyle style,
										Slider& slider);

	virtual int getSliderThumbRadius (Slider& slider);

	virtual void drawRotarySlider (Graphics& g,
								   int x, int y,
								   int width, int height,
								   float sliderPosProportional,
								   float rotaryStartAngle,
								   float rotaryEndAngle,
								   Slider& slider);

	virtual Button* createSliderButton (bool isIncrement);
	virtual Label* createSliderTextBox (Slider& slider);

	virtual ImageEffectFilter* getSliderEffect();

	virtual void getTooltipSize (const String& tipText, int& width, int& height);

	virtual void drawTooltip (Graphics& g, const String& text, int width, int height);

	virtual Button* createFilenameComponentBrowseButton (const String& text);

	virtual void layoutFilenameComponent (FilenameComponent& filenameComp,
										  ComboBox* filenameBox, Button* browseButton);

	virtual void drawCornerResizer (Graphics& g,
									int w, int h,
									bool isMouseOver,
									bool isMouseDragging);

	virtual void drawResizableFrame (Graphics& g,
									int w, int h,
									const BorderSize<int>& borders);

	virtual void fillResizableWindowBackground (Graphics& g, int w, int h,
												const BorderSize<int>& border,
												ResizableWindow& window);

	virtual void drawResizableWindowBorder (Graphics& g,
											int w, int h,
											const BorderSize<int>& border,
											ResizableWindow& window);

	virtual void drawDocumentWindowTitleBar (DocumentWindow& window,
											 Graphics& g, int w, int h,
											 int titleSpaceX, int titleSpaceW,
											 const Image* icon,
											 bool drawTitleTextOnLeft);

	virtual Button* createDocumentWindowButton (int buttonType);

	virtual void positionDocumentWindowButtons (DocumentWindow& window,
												int titleBarX, int titleBarY,
												int titleBarW, int titleBarH,
												Button* minimiseButton,
												Button* maximiseButton,
												Button* closeButton,
												bool positionTitleBarButtonsOnLeft);

	virtual int getDefaultMenuBarHeight();

	virtual DropShadower* createDropShadowerForComponent (Component* component);

	virtual void drawStretchableLayoutResizerBar (Graphics& g,
												  int w, int h,
												  bool isVerticalBar,
												  bool isMouseOver,
												  bool isMouseDragging);

	virtual void drawGroupComponentOutline (Graphics& g, int w, int h,
											const String& text,
											const Justification& position,
											GroupComponent& group);

	virtual void createTabButtonShape (Path& p,
									   int width, int height,
									   int tabIndex,
									   const String& text,
									   Button& button,
									   TabbedButtonBar::Orientation orientation,
									   bool isMouseOver,
									   bool isMouseDown,
									   bool isFrontTab);

	virtual void fillTabButtonShape (Graphics& g,
									 const Path& path,
									 const Colour& preferredBackgroundColour,
									 int tabIndex,
									 const String& text,
									 Button& button,
									 TabbedButtonBar::Orientation orientation,
									 bool isMouseOver,
									 bool isMouseDown,
									 bool isFrontTab);

	virtual void drawTabButtonText (Graphics& g,
									int x, int y, int w, int h,
									const Colour& preferredBackgroundColour,
									int tabIndex,
									const String& text,
									Button& button,
									TabbedButtonBar::Orientation orientation,
									bool isMouseOver,
									bool isMouseDown,
									bool isFrontTab);

	virtual int getTabButtonOverlap (int tabDepth);
	virtual int getTabButtonSpaceAroundImage();

	virtual int getTabButtonBestWidth (int tabIndex,
									   const String& text,
									   int tabDepth,
									   Button& button);

	virtual void drawTabButton (Graphics& g,
								int w, int h,
								const Colour& preferredColour,
								int tabIndex,
								const String& text,
								Button& button,
								TabbedButtonBar::Orientation orientation,
								bool isMouseOver,
								bool isMouseDown,
								bool isFrontTab);

	virtual void drawTabAreaBehindFrontButton (Graphics& g,
											   int w, int h,
											   TabbedButtonBar& tabBar,
											   TabbedButtonBar::Orientation orientation);

	virtual Button* createTabBarExtrasButton();

	virtual void drawImageButton (Graphics& g, Image* image,
								  int imageX, int imageY, int imageW, int imageH,
								  const Colour& overlayColour,
								  float imageOpacity,
								  ImageButton& button);

	virtual void drawTableHeaderBackground (Graphics& g, TableHeaderComponent& header);

	virtual void drawTableHeaderColumn (Graphics& g, const String& columnName, int columnId,
										int width, int height,
										bool isMouseOver, bool isMouseDown,
										int columnFlags);

	virtual void paintToolbarBackground (Graphics& g, int width, int height, Toolbar& toolbar);

	virtual Button* createToolbarMissingItemsButton (Toolbar& toolbar);

	virtual void paintToolbarButtonBackground (Graphics& g, int width, int height,
											   bool isMouseOver, bool isMouseDown,
											   ToolbarItemComponent& component);

	virtual void paintToolbarButtonLabel (Graphics& g, int x, int y, int width, int height,
										  const String& text, ToolbarItemComponent& component);

	virtual void drawPropertyPanelSectionHeader (Graphics& g, const String& name,
												 bool isOpen, int width, int height);

	virtual void drawPropertyComponentBackground (Graphics& g, int width, int height,
												  PropertyComponent& component);

	virtual void drawPropertyComponentLabel (Graphics& g, int width, int height,
											 PropertyComponent& component);

	virtual const Rectangle<int> getPropertyComponentContentPosition (PropertyComponent& component);

	virtual void drawCallOutBoxBackground (CallOutBox& box, Graphics& g, const Path& path);

	virtual void drawLevelMeter (Graphics& g, int width, int height, float level);

	virtual void drawKeymapChangeButton (Graphics& g, int width, int height, Button& button, const String& keyDescription);

	/** Plays the system's default 'beep' noise, to alert the user about something very important.
	*/
	virtual void playAlertSound();

	/** Utility function to draw a shiny, glassy circle (for round LED-type buttons). */
	static void drawGlassSphere (Graphics& g,
								 float x, float y,
								 float diameter,
								 const Colour& colour,
								 float outlineThickness) noexcept;

	static void drawGlassPointer (Graphics& g,
								  float x, float y,
								  float diameter,
								  const Colour& colour, float outlineThickness,
								  int direction) noexcept;

	/** Utility function to draw a shiny, glassy oblong (for text buttons). */
	static void drawGlassLozenge (Graphics& g,
								  float x, float y,
								  float width, float height,
								  const Colour& colour,
								  float outlineThickness,
								  float cornerSize,
								  bool flatOnLeft, bool flatOnRight,
								  bool flatOnTop, bool flatOnBottom) noexcept;

	static Drawable* loadDrawableFromData (const void* data, size_t numBytes);

private:

	friend class WeakReference<LookAndFeel>;
	WeakReference<LookAndFeel>::Master masterReference;

	Array <int> colourIds;
	Array <Colour> colours;

	// default typeface names
	String defaultSans, defaultSerif, defaultFixed;

	ScopedPointer<Drawable> folderImage, documentImage;

	bool useNativeAlertWindows;

	void drawShinyButtonShape (Graphics& g,
							   float x, float y, float w, float h, float maxCornerSize,
							   const Colour& baseColour,
							   float strokeWidth,
							   bool flatOnLeft,
							   bool flatOnRight,
							   bool flatOnTop,
							   bool flatOnBottom) noexcept;

	// This has been deprecated - see the new parameter list..
	virtual int drawFileBrowserRow (Graphics&, int, int, const String&, Image*, const String&, const String&, bool, bool, int) { return 0; }

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (LookAndFeel);
};

#endif   // __JUCE_LOOKANDFEEL_JUCEHEADER__

/*** End of inlined file: juce_LookAndFeel.h ***/


#endif
#ifndef __JUCE_MENUBARCOMPONENT_JUCEHEADER__

/*** Start of inlined file: juce_MenuBarComponent.h ***/
#ifndef __JUCE_MENUBARCOMPONENT_JUCEHEADER__
#define __JUCE_MENUBARCOMPONENT_JUCEHEADER__

/**
	A menu bar component.

	@see MenuBarModel
*/
class JUCE_API  MenuBarComponent  : public Component,
									private MenuBarModel::Listener,
									private Timer
{
public:

	/** Creates a menu bar.

		@param model        the model object to use to control this bar. You can
							pass 0 into this if you like, and set the model later
							using the setModel() method
	*/
	MenuBarComponent (MenuBarModel* model);

	/** Destructor. */
	~MenuBarComponent();

	/** Changes the model object to use to control the bar.

		This can be a null pointer, in which case the bar will be empty. Don't delete the object
		that is passed-in while it's still being used by this MenuBar.
	*/
	void setModel (MenuBarModel* newModel);

	/** Returns the current menu bar model being used.
	*/
	MenuBarModel* getModel() const noexcept;

	/** Pops up one of the menu items.

		This lets you manually open one of the menus - it could be triggered by a
		key shortcut, for example.
	*/
	void showMenu (int menuIndex);

	/** @internal */
	void paint (Graphics& g);
	/** @internal */
	void resized();
	/** @internal */
	void mouseEnter (const MouseEvent& e);
	/** @internal */
	void mouseExit (const MouseEvent& e);
	/** @internal */
	void mouseDown (const MouseEvent& e);
	/** @internal */
	void mouseDrag (const MouseEvent& e);
	/** @internal */
	void mouseUp (const MouseEvent& e);
	/** @internal */
	void mouseMove (const MouseEvent& e);
	/** @internal */
	void handleCommandMessage (int commandId);
	/** @internal */
	bool keyPressed (const KeyPress& key);
	/** @internal */
	void menuBarItemsChanged (MenuBarModel* menuBarModel);
	/** @internal */
	void menuCommandInvoked (MenuBarModel* menuBarModel,
							 const ApplicationCommandTarget::InvocationInfo& info);

private:

	MenuBarModel* model;

	StringArray menuNames;
	Array<int> xPositions;
	Point<int> lastMousePos;
	int itemUnderMouse, currentPopupIndex, topLevelIndexClicked;

	int getItemAt (const Point<int>&);
	void setItemUnderMouse (int index);
	void setOpenItem (int index);
	void updateItemUnderMouse (const Point<int>&);
	void timerCallback();
	void repaintMenuItem (int index);
	void menuDismissed (int topLevelIndex, int itemId);
	static void menuBarMenuDismissedCallback (int, MenuBarComponent*, int);

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (MenuBarComponent);
};

#endif   // __JUCE_MENUBARCOMPONENT_JUCEHEADER__

/*** End of inlined file: juce_MenuBarComponent.h ***/


#endif
#ifndef __JUCE_MENUBARMODEL_JUCEHEADER__

#endif
#ifndef __JUCE_POPUPMENU_JUCEHEADER__

#endif
#ifndef __JUCE_MARKERLIST_JUCEHEADER__

#endif
#ifndef __JUCE_RELATIVECOORDINATE_JUCEHEADER__

#endif
#ifndef __JUCE_RELATIVECOORDINATEPOSITIONER_JUCEHEADER__

#endif
#ifndef __JUCE_RELATIVEPARALLELOGRAM_JUCEHEADER__

#endif
#ifndef __JUCE_RELATIVEPOINT_JUCEHEADER__

#endif
#ifndef __JUCE_RELATIVEPOINTPATH_JUCEHEADER__

#endif
#ifndef __JUCE_RELATIVERECTANGLE_JUCEHEADER__

#endif
#ifndef __JUCE_BOOLEANPROPERTYCOMPONENT_JUCEHEADER__

/*** Start of inlined file: juce_BooleanPropertyComponent.h ***/
#ifndef __JUCE_BOOLEANPROPERTYCOMPONENT_JUCEHEADER__
#define __JUCE_BOOLEANPROPERTYCOMPONENT_JUCEHEADER__


/*** Start of inlined file: juce_PropertyComponent.h ***/
#ifndef __JUCE_PROPERTYCOMPONENT_JUCEHEADER__
#define __JUCE_PROPERTYCOMPONENT_JUCEHEADER__

class EditableProperty;

/**
	A base class for a component that goes in a PropertyPanel and displays one of
	an item's properties.

	Subclasses of this are used to display a property in various forms, e.g. a
	ChoicePropertyComponent shows its value as a combo box; a SliderPropertyComponent
	shows its value as a slider; a TextPropertyComponent as a text box, etc.

	A subclass must implement the refresh() method which will be called to tell the
	component to update itself, and is also responsible for calling this it when the
	item that it refers to is changed.

	@see PropertyPanel, TextPropertyComponent, SliderPropertyComponent,
		 ChoicePropertyComponent, ButtonPropertyComponent, BooleanPropertyComponent
*/
class JUCE_API  PropertyComponent  : public Component,
									 public SettableTooltipClient
{
public:

	/** Creates a PropertyComponent.

		@param propertyName     the name is stored as this component's name, and is
								used as the name displayed next to this component in
								a property panel
		@param preferredHeight  the height that the component should be given - some
								items may need to be larger than a normal row height.
								This value can also be set if a subclass changes the
								preferredHeight member variable.
	*/
	PropertyComponent (const String& propertyName,
					   int preferredHeight = 25);

	/** Destructor. */
	~PropertyComponent();

	/** Returns this item's preferred height.

		This value is specified either in the constructor or by a subclass changing the
		preferredHeight member variable.
	*/
	int getPreferredHeight() const noexcept                 { return preferredHeight; }

	void setPreferredHeight (int newHeight) noexcept        { preferredHeight = newHeight; }

	/** Updates the property component if the item it refers to has changed.

		A subclass must implement this method, and other objects may call it to
		force it to refresh itself.

		The subclass should be economical in the amount of work is done, so for
		example it should check whether it really needs to do a repaint rather than
		just doing one every time this method is called, as it may be called when
		the value being displayed hasn't actually changed.
	*/
	virtual void refresh() = 0;

	/** The default paint method fills the background and draws a label for the
		item's name.

		@see LookAndFeel::drawPropertyComponentBackground(), LookAndFeel::drawPropertyComponentLabel()
	*/
	void paint (Graphics& g);

	/** The default resize method positions any child component to the right of this
		one, based on the look and feel's default label size.
	*/
	void resized();

	/** By default, this just repaints the component. */
	void enablementChanged();

protected:
	/** Used by the PropertyPanel to determine how high this component needs to be.
		A subclass can update this value in its constructor but shouldn't alter it later
		as changes won't necessarily be picked up.
	*/
	int preferredHeight;

private:

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (PropertyComponent);
};

#endif   // __JUCE_PROPERTYCOMPONENT_JUCEHEADER__

/*** End of inlined file: juce_PropertyComponent.h ***/

/**
	A PropertyComponent that contains an on/off toggle button.

	This type of property component can be used if you have a boolean value to
	toggle on/off.

	@see PropertyComponent
*/
class JUCE_API  BooleanPropertyComponent  : public PropertyComponent,
											private ButtonListener // (can't use Button::Listener due to idiotic VC2005 bug)
{
protected:

	/** Creates a button component.

		If you use this constructor, you must override the getState() and setState()
		methods.

		@param propertyName         the property name to be passed to the PropertyComponent
		@param buttonTextWhenTrue   the text shown in the button when the value is true
		@param buttonTextWhenFalse  the text shown in the button when the value is false
	*/
	BooleanPropertyComponent (const String& propertyName,
							  const String& buttonTextWhenTrue,
							  const String& buttonTextWhenFalse);

public:
	/** Creates a button component.

		@param valueToControl       a Value object that this property should refer to.
		@param propertyName         the property name to be passed to the PropertyComponent
		@param buttonText           the text shown in the ToggleButton component
	*/
	BooleanPropertyComponent (const Value& valueToControl,
							  const String& propertyName,
							  const String& buttonText);

	/** Destructor. */
	~BooleanPropertyComponent();

	/** Called to change the state of the boolean value. */
	virtual void setState (bool newState);

	/** Must return the current value of the property. */
	virtual bool getState() const;

	/** @internal */
	void paint (Graphics& g);
	/** @internal */
	void refresh();
	/** @internal */
	void buttonClicked (Button*);

private:
	ToggleButton button;
	String onText, offText;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (BooleanPropertyComponent);
};

#endif   // __JUCE_BOOLEANPROPERTYCOMPONENT_JUCEHEADER__

/*** End of inlined file: juce_BooleanPropertyComponent.h ***/


#endif
#ifndef __JUCE_BUTTONPROPERTYCOMPONENT_JUCEHEADER__

/*** Start of inlined file: juce_ButtonPropertyComponent.h ***/
#ifndef __JUCE_BUTTONPROPERTYCOMPONENT_JUCEHEADER__
#define __JUCE_BUTTONPROPERTYCOMPONENT_JUCEHEADER__

/**
	A PropertyComponent that contains a button.

	This type of property component can be used if you need a button to trigger some
	kind of action.

	@see PropertyComponent
*/
class JUCE_API  ButtonPropertyComponent  : public PropertyComponent,
										   private ButtonListener // (can't use Button::Listener due to idiotic VC2005 bug)
{
public:

	/** Creates a button component.

		@param propertyName         the property name to be passed to the PropertyComponent
		@param triggerOnMouseDown   this is passed to the Button::setTriggeredOnMouseDown() method
	*/
	ButtonPropertyComponent (const String& propertyName,
							 bool triggerOnMouseDown);

	/** Destructor. */
	~ButtonPropertyComponent();

	/** Called when the user clicks the button.
	*/
	virtual void buttonClicked() = 0;

	/** Returns the string that should be displayed in the button.

		If you need to change this string, call refresh() to update the component.
	*/
	virtual String getButtonText() const = 0;

	/** @internal */
	void refresh();
	/** @internal */
	void buttonClicked (Button*);

private:
	TextButton button;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ButtonPropertyComponent);
};

#endif   // __JUCE_BUTTONPROPERTYCOMPONENT_JUCEHEADER__

/*** End of inlined file: juce_ButtonPropertyComponent.h ***/


#endif
#ifndef __JUCE_CHOICEPROPERTYCOMPONENT_JUCEHEADER__

/*** Start of inlined file: juce_ChoicePropertyComponent.h ***/
#ifndef __JUCE_CHOICEPROPERTYCOMPONENT_JUCEHEADER__
#define __JUCE_CHOICEPROPERTYCOMPONENT_JUCEHEADER__

/**
	A PropertyComponent that shows its value as a combo box.

	This type of property component contains a list of options and has a
	combo box to choose one.

	Your subclass's constructor must add some strings to the choices StringArray
	and these are shown in the list.

	The getIndex() method will be called to find out which option is the currently
	selected one. If you call refresh() it will call getIndex() to check whether
	the value has changed, and will update the combo box if needed.

	If the user selects a different item from the list, setIndex() will be
	called to let your class process this.

	@see PropertyComponent, PropertyPanel
*/
class JUCE_API  ChoicePropertyComponent    : public PropertyComponent,
											 private ComboBoxListener  // (can't use ComboBox::Listener due to idiotic VC2005 bug)
{
protected:
	/** Creates the component.

		Your subclass's constructor must add a list of options to the choices
		member variable.
	*/
	ChoicePropertyComponent (const String& propertyName);

public:
	/** Creates the component.

		@param valueToControl       the value that the combo box will read and control
		@param propertyName         the name of the property
		@param choices              the list of possible values that the drop-down list will contain
		@param correspondingValues  a list of values corresponding to each item in the 'choices' StringArray.
									These are the values that will be read and written to the
									valueToControl value. This array must contain the same number of items
									as the choices array
	*/
	ChoicePropertyComponent (const Value& valueToControl,
							 const String& propertyName,
							 const StringArray& choices,
							 const Array <var>& correspondingValues);

	/** Destructor. */
	~ChoicePropertyComponent();

	/** Called when the user selects an item from the combo box.

		Your subclass must use this callback to update the value that this component
		represents. The index is the index of the chosen item in the choices
		StringArray.
	*/
	virtual void setIndex (int newIndex);

	/** Returns the index of the item that should currently be shown.

		This is the index of the item in the choices StringArray that will be
		shown.
	*/
	virtual int getIndex() const;

	/** Returns the list of options. */
	const StringArray& getChoices() const;

	/** @internal */
	void refresh();
	/** @internal */
	void comboBoxChanged (ComboBox*);

protected:
	/** The list of options that will be shown in the combo box.

		Your subclass must populate this array in its constructor. If any empty
		strings are added, these will be replaced with horizontal separators (see
		ComboBox::addSeparator() for more info).
	*/
	StringArray choices;

private:
	ComboBox comboBox;
	bool isCustomClass;

	class RemapperValueSource;
	void createComboBox();

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ChoicePropertyComponent);
};

#endif   // __JUCE_CHOICEPROPERTYCOMPONENT_JUCEHEADER__

/*** End of inlined file: juce_ChoicePropertyComponent.h ***/


#endif
#ifndef __JUCE_PROPERTYCOMPONENT_JUCEHEADER__

#endif
#ifndef __JUCE_PROPERTYPANEL_JUCEHEADER__

/*** Start of inlined file: juce_PropertyPanel.h ***/
#ifndef __JUCE_PROPERTYPANEL_JUCEHEADER__
#define __JUCE_PROPERTYPANEL_JUCEHEADER__

/**
	A panel that holds a list of PropertyComponent objects.

	This panel displays a list of PropertyComponents, and allows them to be organised
	into collapsible sections.

	To use, simply create one of these and add your properties to it with addProperties()
	or addSection().

	@see PropertyComponent
*/
class JUCE_API  PropertyPanel  : public Component
{
public:

	/** Creates an empty property panel. */
	PropertyPanel();

	/** Destructor. */
	~PropertyPanel();

	/** Deletes all property components from the panel.
	*/
	void clear();

	/** Adds a set of properties to the panel.

		The components in the list will be owned by this object and will be automatically
		deleted later on when no longer needed.

		These properties are added without them being inside a named section. If you
		want them to be kept together in a collapsible section, use addSection() instead.
	*/
	void addProperties (const Array <PropertyComponent*>& newPropertyComponents);

	/** Adds a set of properties to the panel.

		These properties are added at the bottom of the list, under a section heading with
		a plus/minus button that allows it to be opened and closed.

		The components in the list will be owned by this object and will be automatically
		deleted later on when no longer needed.

		To add properies without them being in a section, use addProperties().
	*/
	void addSection (const String& sectionTitle,
					 const Array <PropertyComponent*>& newPropertyComponents,
					 bool shouldSectionInitiallyBeOpen = true);

	/** Calls the refresh() method of all PropertyComponents in the panel */
	void refreshAll() const;

	/** Returns a list of all the names of sections in the panel.

		These are the sections that have been added with addSection().
	*/
	StringArray getSectionNames() const;

	/** Returns true if the section at this index is currently open.

		The index is from 0 up to the number of items returned by getSectionNames().
	*/
	bool isSectionOpen (int sectionIndex) const;

	/** Opens or closes one of the sections.

		The index is from 0 up to the number of items returned by getSectionNames().
	*/
	void setSectionOpen (int sectionIndex, bool shouldBeOpen);

	/** Enables or disables one of the sections.

		The index is from 0 up to the number of items returned by getSectionNames().
	*/
	void setSectionEnabled (int sectionIndex, bool shouldBeEnabled);

	/** Saves the current state of open/closed sections so it can be restored later.

		The caller is responsible for deleting the object that is returned.

		To restore this state, use restoreOpennessState().

		@see restoreOpennessState
	*/
	XmlElement* getOpennessState() const;

	/** Restores a previously saved arrangement of open/closed sections.

		This will try to restore a snapshot of the panel's state that was created by
		the getOpennessState() method. If any of the sections named in the original
		XML aren't present, they will be ignored.

		@see getOpennessState
	*/
	void restoreOpennessState (const XmlElement& newState);

	/** Sets a message to be displayed when there are no properties in the panel.

		The default message is "nothing selected".
	*/
	void setMessageWhenEmpty (const String& newMessage);

	/** Returns the message that is displayed when there are no properties.
		@see setMessageWhenEmpty
	*/
	const String& getMessageWhenEmpty() const;

	/** @internal */
	void paint (Graphics& g);
	/** @internal */
	void resized();

private:
	Viewport viewport;
	class PropertyHolderComponent;
	PropertyHolderComponent* propertyHolderComponent;
	String messageWhenEmpty;

	void updatePropHolderLayout() const;
	void updatePropHolderLayout (int width) const;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (PropertyPanel);
};

#endif   // __JUCE_PROPERTYPANEL_JUCEHEADER__

/*** End of inlined file: juce_PropertyPanel.h ***/


#endif
#ifndef __JUCE_SLIDERPROPERTYCOMPONENT_JUCEHEADER__

/*** Start of inlined file: juce_SliderPropertyComponent.h ***/
#ifndef __JUCE_SLIDERPROPERTYCOMPONENT_JUCEHEADER__
#define __JUCE_SLIDERPROPERTYCOMPONENT_JUCEHEADER__

/**
	A PropertyComponent that shows its value as a slider.

	@see PropertyComponent, Slider
*/
class JUCE_API  SliderPropertyComponent   : public PropertyComponent,
											private SliderListener  // (can't use Slider::Listener due to idiotic VC2005 bug)
{
protected:

	/** Creates the property component.

		The ranges, interval and skew factor are passed to the Slider component.

		If you need to customise the slider in other ways, your constructor can
		access the slider member variable and change it directly.
	*/
	SliderPropertyComponent (const String& propertyName,
							 double rangeMin,
							 double rangeMax,
							 double interval,
							 double skewFactor = 1.0);

public:

	/** Creates the property component.

		The ranges, interval and skew factor are passed to the Slider component.

		If you need to customise the slider in other ways, your constructor can
		access the slider member variable and change it directly.
	*/
	SliderPropertyComponent (const Value& valueToControl,
							 const String& propertyName,
							 double rangeMin,
							 double rangeMax,
							 double interval,
							 double skewFactor = 1.0);

	/** Destructor. */
	~SliderPropertyComponent();

	/** Called when the user moves the slider to change its value.

		Your subclass must use this method to update whatever item this property
		represents.
	*/
	virtual void setValue (double newValue);

	/** Returns the value that the slider should show. */
	virtual double getValue() const;

	/** @internal */
	void refresh();
	/** @internal */
	void sliderValueChanged (Slider*);

protected:
	/** The slider component being used in this component.
		Your subclass has access to this in case it needs to customise it in some way.
	*/
	Slider slider;

private:

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (SliderPropertyComponent);
};

#endif   // __JUCE_SLIDERPROPERTYCOMPONENT_JUCEHEADER__

/*** End of inlined file: juce_SliderPropertyComponent.h ***/


#endif
#ifndef __JUCE_TEXTPROPERTYCOMPONENT_JUCEHEADER__

/*** Start of inlined file: juce_TextPropertyComponent.h ***/
#ifndef __JUCE_TEXTPROPERTYCOMPONENT_JUCEHEADER__
#define __JUCE_TEXTPROPERTYCOMPONENT_JUCEHEADER__

/**
	A PropertyComponent that shows its value as editable text.

	@see PropertyComponent
*/
class JUCE_API  TextPropertyComponent  : public PropertyComponent
{
protected:

	/** Creates a text property component.

		The maxNumChars is used to set the length of string allowable, and isMultiLine
		sets whether the text editor allows carriage returns.

		@see TextEditor
	*/
	TextPropertyComponent (const String& propertyName,
						   int maxNumChars,
						   bool isMultiLine);

public:
	/** Creates a text property component.

		The maxNumChars is used to set the length of string allowable, and isMultiLine
		sets whether the text editor allows carriage returns.

		@see TextEditor
	*/
	TextPropertyComponent (const Value& valueToControl,
						   const String& propertyName,
						   int maxNumChars,
						   bool isMultiLine);

	/** Destructor. */
	~TextPropertyComponent();

	/** Called when the user edits the text.

		Your subclass must use this callback to change the value of whatever item
		this property component represents.
	*/
	virtual void setText (const String& newText);

	/** Returns the text that should be shown in the text editor.
	*/
	virtual String getText() const;

	/** @internal */
	void refresh();
	/** @internal */
	void textWasEdited();

private:
	ScopedPointer<Label> textEditor;

	void createEditor (int maxNumChars, bool isMultiLine);

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (TextPropertyComponent);
};

#endif   // __JUCE_TEXTPROPERTYCOMPONENT_JUCEHEADER__

/*** End of inlined file: juce_TextPropertyComponent.h ***/


#endif
#ifndef __JUCE_COMBOBOX_JUCEHEADER__

#endif
#ifndef __JUCE_IMAGECOMPONENT_JUCEHEADER__

/*** Start of inlined file: juce_ImageComponent.h ***/
#ifndef __JUCE_IMAGECOMPONENT_JUCEHEADER__
#define __JUCE_IMAGECOMPONENT_JUCEHEADER__

/**
	A component that simply displays an image.

	Use setImage to give it an image, and it'll display it - simple as that!
*/
class JUCE_API  ImageComponent  : public Component,
								  public SettableTooltipClient
{
public:

	/** Creates an ImageComponent. */
	ImageComponent (const String& componentName = String::empty);

	/** Destructor. */
	~ImageComponent();

	/** Sets the image that should be displayed. */
	void setImage (const Image& newImage);

	/** Sets the image that should be displayed, and its placement within the component. */
	void setImage (const Image& newImage,
				   const RectanglePlacement& placementToUse);

	/** Returns the current image. */
	const Image& getImage() const;

	/** Sets the method of positioning that will be used to fit the image within the component's bounds.
		By default the positioning is centred, and will fit the image inside the component's bounds
		whilst keeping its aspect ratio correct, but you can change it to whatever layout you need.
	*/
	void setImagePlacement (const RectanglePlacement& newPlacement);

	/** Returns the current image placement. */
	const RectanglePlacement getImagePlacement() const;

	struct Ids
	{
		static const Identifier tagType, image, placement;
	};

	void refreshFromValueTree (const ValueTree&, ComponentBuilder&);
	static RectanglePlacement getPlacement (const ValueTree& state);

	/** @internal */
	void paint (Graphics& g);

private:
	Image image;
	RectanglePlacement placement;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ImageComponent);
};

#endif   // __JUCE_IMAGECOMPONENT_JUCEHEADER__

/*** End of inlined file: juce_ImageComponent.h ***/


#endif
#ifndef __JUCE_LABEL_JUCEHEADER__

#endif
#ifndef __JUCE_LISTBOX_JUCEHEADER__

#endif
#ifndef __JUCE_PROGRESSBAR_JUCEHEADER__

#endif
#ifndef __JUCE_SLIDER_JUCEHEADER__

#endif
#ifndef __JUCE_TABLEHEADERCOMPONENT_JUCEHEADER__

/*** Start of inlined file: juce_TableHeaderComponent.h ***/
#ifndef __JUCE_TABLEHEADERCOMPONENT_JUCEHEADER__
#define __JUCE_TABLEHEADERCOMPONENT_JUCEHEADER__

/**
	A component that displays a strip of column headings for a table, and allows these
	to be resized, dragged around, etc.

	This is just the component that goes at the top of a table. You can use it
	directly for custom components, or to create a simple table, use the
	TableListBox class.

	To use one of these, create it and use addColumn() to add all the columns that you need.
	Each column must be given a unique ID number that's used to refer to it.

	@see TableListBox, TableHeaderComponent::Listener
*/
class JUCE_API  TableHeaderComponent   : public Component,
										 private AsyncUpdater
{
public:

	/** Creates an empty table header.
	*/
	TableHeaderComponent();

	/** Destructor. */
	~TableHeaderComponent();

	/** A combination of these flags are passed into the addColumn() method to specify
		the properties of a column.
	*/
	enum ColumnPropertyFlags
	{
		visible                     = 1,    /**< If this is set, the column will be shown; if not, it will be hidden until the user enables it with the pop-up menu. */
		resizable                   = 2,    /**< If this is set, the column can be resized by dragging it. */
		draggable                   = 4,    /**< If this is set, the column can be dragged around to change its order in the table. */
		appearsOnColumnMenu         = 8,    /**< If this is set, the column will be shown on the pop-up menu allowing it to be hidden/shown. */
		sortable                    = 16,   /**< If this is set, then clicking on the column header will set it to be the sort column, and clicking again will reverse the order. */
		sortedForwards              = 32,   /**< If this is set, the column is currently the one by which the table is sorted (forwards). */
		sortedBackwards             = 64,   /**< If this is set, the column is currently the one by which the table is sorted (backwards). */

		/** This set of default flags is used as the default parameter value in addColumn(). */
		defaultFlags                = (visible | resizable | draggable | appearsOnColumnMenu | sortable),

		/** A quick way of combining flags for a column that's not resizable. */
		notResizable                = (visible | draggable | appearsOnColumnMenu | sortable),

		/** A quick way of combining flags for a column that's not resizable or sortable. */
		notResizableOrSortable      = (visible | draggable | appearsOnColumnMenu),

		/** A quick way of combining flags for a column that's not sortable. */
		notSortable                 = (visible | resizable | draggable | appearsOnColumnMenu)
	};

	/** Adds a column to the table.

		This will add a column, and asynchronously call the tableColumnsChanged() method of any
		registered listeners.

		@param columnName       the name of the new column. It's ok to have two or more columns with the same name
		@param columnId         an ID for this column. The ID can be any number apart from 0, but every column must have
								a unique ID. This is used to identify the column later on, after the user may have
								changed the order that they appear in
		@param width            the initial width of the column, in pixels
		@param maximumWidth     a maximum width that the column can take when the user is resizing it. This only applies
								if the 'resizable' flag is specified for this column
		@param minimumWidth     a minimum width that the column can take when the user is resizing it. This only applies
								if the 'resizable' flag is specified for this column
		@param propertyFlags    a combination of some of the values from the ColumnPropertyFlags enum, to define the
								properties of this column
		@param insertIndex      the index at which the column should be added. A value of 0 puts it at the start (left-hand side)
								and -1 puts it at the end (right-hand size) of the table. Note that the index the index within
								all columns, not just the index amongst those that are currently visible
	*/
	void addColumn (const String& columnName,
					int columnId,
					int width,
					int minimumWidth = 30,
					int maximumWidth = -1,
					int propertyFlags = defaultFlags,
					int insertIndex = -1);

	/** Removes a column with the given ID.

		If there is such a column, this will asynchronously call the tableColumnsChanged() method of any
		registered listeners.
	*/
	void removeColumn (int columnIdToRemove);

	/** Deletes all columns from the table.

		If there are any columns to remove, this will asynchronously call the tableColumnsChanged() method of any
		registered listeners.
	*/
	void removeAllColumns();

	/** Returns the number of columns in the table.

		If onlyCountVisibleColumns is true, this will return the number of visible columns; otherwise it'll
		return the total number of columns, including hidden ones.

		@see isColumnVisible
	*/
	int getNumColumns (bool onlyCountVisibleColumns) const;

	/** Returns the name for a column.
		@see setColumnName
	*/
	String getColumnName (int columnId) const;

	/** Changes the name of a column. */
	void setColumnName (int columnId, const String& newName);

	/** Moves a column to a different index in the table.

		@param columnId             the column to move
		@param newVisibleIndex      the target index for it, from 0 to the number of columns currently visible.
	*/
	void moveColumn (int columnId, int newVisibleIndex);

	/** Returns the width of one of the columns.
	*/
	int getColumnWidth (int columnId) const;

	/** Changes the width of a column.

		This will cause an asynchronous callback to the tableColumnsResized() method of any registered listeners.
	*/
	void setColumnWidth (int columnId, int newWidth);

	/** Shows or hides a column.

		This can cause an asynchronous callback to the tableColumnsChanged() method of any registered listeners.
		@see isColumnVisible
	*/
	void setColumnVisible (int columnId, bool shouldBeVisible);

	/** Returns true if this column is currently visible.
		@see setColumnVisible
	*/
	bool isColumnVisible (int columnId) const;

	/** Changes the column which is the sort column.

		This can cause an asynchronous callback to the tableSortOrderChanged() method of any registered listeners.

		If this method doesn't actually change the column ID, then no re-sort will take place (you can
		call reSortTable() to force a re-sort to happen if you've modified the table's contents).

		@see getSortColumnId, isSortedForwards, reSortTable
	*/
	void setSortColumnId (int columnId, bool sortForwards);

	/** Returns the column ID by which the table is currently sorted, or 0 if it is unsorted.

		@see setSortColumnId, isSortedForwards
	*/
	int getSortColumnId() const;

	/** Returns true if the table is currently sorted forwards, or false if it's backwards.
		@see setSortColumnId
	*/
	bool isSortedForwards() const;

	/** Triggers a re-sort of the table according to the current sort-column.

		If you modifiy the table's contents, you can call this to signal that the table needs
		to be re-sorted.

		(This doesn't do any sorting synchronously - it just asynchronously sends a call to the
		tableSortOrderChanged() method of any listeners).
	*/
	void reSortTable();

	/** Returns the total width of all the visible columns in the table.
	*/
	int getTotalWidth() const;

	/** Returns the index of a given column.

		If there's no such column ID, this will return -1.

		If onlyCountVisibleColumns is true, this will return the index amoungst the visible columns;
		otherwise it'll return the index amongst all the columns, including any hidden ones.
	*/
	int getIndexOfColumnId (int columnId, bool onlyCountVisibleColumns) const;

	/** Returns the ID of the column at a given index.

		If onlyCountVisibleColumns is true, this will count the index amoungst the visible columns;
		otherwise it'll count it amongst all the columns, including any hidden ones.

		If the index is out-of-range, it'll return 0.
	*/
	int getColumnIdOfIndex (int index, bool onlyCountVisibleColumns) const;

	/** Returns the rectangle containing of one of the columns.

		The index is an index from 0 to the number of columns that are currently visible (hidden
		ones are not counted). It returns a rectangle showing the position of the column relative
		to this component's top-left. If the index is out-of-range, an empty rectangle is retrurned.
	*/
	Rectangle<int> getColumnPosition (int index) const;

	/** Finds the column ID at a given x-position in the component.

		If there is a column at this point this returns its ID, or if not, it will return 0.
	*/
	int getColumnIdAtX (int xToFind) const;

	/** If set to true, this indicates that the columns should be expanded or shrunk to fill the
		entire width of the component.

		By default this is disabled. Turning it on also means that when resizing a column, those
		on the right will be squashed to fit.
	*/
	void setStretchToFitActive (bool shouldStretchToFit);

	/** Returns true if stretch-to-fit has been enabled.
		@see setStretchToFitActive
	*/
	bool isStretchToFitActive() const;

	/** If stretch-to-fit is enabled, this will resize all the columns to make them fit into the
		specified width, keeping their relative proportions the same.

		If the minimum widths of the columns are too wide to fit into this space, it may
		actually end up wider.
	*/
	void resizeAllColumnsToFit (int targetTotalWidth);

	/** Enables or disables the pop-up menu.

		The default menu allows the user to show or hide columns. You can add custom
		items to this menu by overloading the addMenuItems() and reactToMenuItem() methods.

		By default the menu is enabled.

		@see isPopupMenuActive, addMenuItems, reactToMenuItem
	*/
	void setPopupMenuActive (bool hasMenu);

	/** Returns true if the pop-up menu is enabled.
		@see setPopupMenuActive
	*/
	bool isPopupMenuActive() const;

	/** Returns a string that encapsulates the table's current layout.

		This can be restored later using restoreFromString(). It saves the order of
		the columns, the currently-sorted column, and the widths.

		@see restoreFromString
	*/
	String toString() const;

	/** Restores the state of the table, based on a string previously created with
		toString().

		@see toString
	*/
	void restoreFromString (const String& storedVersion);

	/**
		Receives events from a TableHeaderComponent when columns are resized, moved, etc.

		You can register one of these objects for table events using TableHeaderComponent::addListener()
		and TableHeaderComponent::removeListener().

		@see TableHeaderComponent
	*/
	class JUCE_API  Listener
	{
	public:

		Listener() {}

		/** Destructor. */
		virtual ~Listener() {}

		/** This is called when some of the table's columns are added, removed, hidden,
			or rearranged.
		*/
		virtual void tableColumnsChanged (TableHeaderComponent* tableHeader) = 0;

		/** This is called when one or more of the table's columns are resized.
		*/
		virtual void tableColumnsResized (TableHeaderComponent* tableHeader) = 0;

		/** This is called when the column by which the table should be sorted is changed.
		*/
		virtual void tableSortOrderChanged (TableHeaderComponent* tableHeader) = 0;

		/** This is called when the user begins or ends dragging one of the columns around.

			When the user starts dragging a column, this is called with the ID of that
			column. When they finish dragging, it is called again with 0 as the ID.
		*/
		virtual void tableColumnDraggingChanged (TableHeaderComponent* tableHeader,
												 int columnIdNowBeingDragged);
	};

	/** Adds a listener to be informed about things that happen to the header. */
	void addListener (Listener* newListener);

	/** Removes a previously-registered listener. */
	void removeListener (Listener* listenerToRemove);

	/** This can be overridden to handle a mouse-click on one of the column headers.

		The default implementation will use this click to call getSortColumnId() and
		change the sort order.
	*/
	virtual void columnClicked (int columnId, const ModifierKeys& mods);

	/** This can be overridden to add custom items to the pop-up menu.

		If you override this, you should call the superclass's method to add its
		column show/hide items, if you want them on the menu as well.

		Then to handle the result, override reactToMenuItem().

		@see reactToMenuItem
	*/
	virtual void addMenuItems (PopupMenu& menu, int columnIdClicked);

	/** Override this to handle any custom items that you have added to the
		pop-up menu with an addMenuItems() override.

		If the menuReturnId isn't one of your own custom menu items, you'll need to
		call TableHeaderComponent::reactToMenuItem() to allow the base class to
		handle the items that it had added.

		@see addMenuItems
	*/
	virtual void reactToMenuItem (int menuReturnId, int columnIdClicked);

	/** @internal */
	void paint (Graphics& g);
	/** @internal */
	void resized();
	/** @internal */
	void mouseMove (const MouseEvent&);
	/** @internal */
	void mouseEnter (const MouseEvent&);
	/** @internal */
	void mouseExit (const MouseEvent&);
	/** @internal */
	void mouseDown (const MouseEvent&);
	/** @internal */
	void mouseDrag (const MouseEvent&);
	/** @internal */
	void mouseUp (const MouseEvent&);
	/** @internal */
	MouseCursor getMouseCursor();

	/** Can be overridden for more control over the pop-up menu behaviour. */
	virtual void showColumnChooserMenu (int columnIdClicked);

private:
	struct ColumnInfo
	{
		String name;
		int id, propertyFlags, width, minimumWidth, maximumWidth;
		double lastDeliberateWidth;

		bool isVisible() const;
	};

	OwnedArray <ColumnInfo> columns;
	Array <Listener*> listeners;
	ScopedPointer <Component> dragOverlayComp;

	bool columnsChanged, columnsResized, sortChanged, menuActive, stretchToFit;
	int columnIdBeingResized, columnIdBeingDragged, initialColumnWidth;
	int columnIdUnderMouse, draggingColumnOffset, draggingColumnOriginalIndex, lastDeliberateWidth;

	ColumnInfo* getInfoForId (int columnId) const;
	int visibleIndexToTotalIndex (int visibleIndex) const;
	void sendColumnsChanged();
	void handleAsyncUpdate();
	void beginDrag (const MouseEvent&);
	void endDrag (int finalIndex);
	int getResizeDraggerAt (int mouseX) const;
	void updateColumnUnderMouse (const MouseEvent&);
	void setColumnUnderMouse (int columnId);
	void resizeColumnsToFit (int firstColumnIndex, int targetTotalWidth);

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (TableHeaderComponent);
};

/** This typedef is just for compatibility with old code - newer code should use the TableHeaderComponent::Listener class directly. */
typedef TableHeaderComponent::Listener TableHeaderListener;

#endif   // __JUCE_TABLEHEADERCOMPONENT_JUCEHEADER__

/*** End of inlined file: juce_TableHeaderComponent.h ***/


#endif
#ifndef __JUCE_TABLELISTBOX_JUCEHEADER__

/*** Start of inlined file: juce_TableListBox.h ***/
#ifndef __JUCE_TABLELISTBOX_JUCEHEADER__
#define __JUCE_TABLELISTBOX_JUCEHEADER__

/**
	One of these is used by a TableListBox as the data model for the table's contents.

	The virtual methods that you override in this class take care of drawing the
	table cells, and reacting to events.

	@see TableListBox
*/
class JUCE_API  TableListBoxModel
{
public:

	TableListBoxModel()  {}

	/** Destructor. */
	virtual ~TableListBoxModel()  {}

	/** This must return the number of rows currently in the table.

		If the number of rows changes, you must call TableListBox::updateContent() to
		cause it to refresh the list.
	*/
	virtual int getNumRows() = 0;

	/** This must draw the background behind one of the rows in the table.

		The graphics context has its origin at the row's top-left, and your method
		should fill the area specified by the width and height parameters.
	*/
	virtual void paintRowBackground (Graphics& g,
									 int rowNumber,
									 int width, int height,
									 bool rowIsSelected) = 0;

	/** This must draw one of the cells.

		The graphics context's origin will already be set to the top-left of the cell,
		whose size is specified by (width, height).
	*/
	virtual void paintCell (Graphics& g,
							int rowNumber,
							int columnId,
							int width, int height,
							bool rowIsSelected) = 0;

	/** This is used to create or update a custom component to go in a cell.

		Any cell may contain a custom component, or can just be drawn with the paintCell() method
		and handle mouse clicks with cellClicked().

		This method will be called whenever a custom component might need to be updated - e.g.
		when the table is changed, or TableListBox::updateContent() is called.

		If you don't need a custom component for the specified cell, then return 0.

		If you do want a custom component, and the existingComponentToUpdate is null, then
		this method must create a new component suitable for the cell, and return it.

		If the existingComponentToUpdate is non-null, it will be a pointer to a component previously created
		by this method. In this case, the method must either update it to make sure it's correctly representing
		the given cell (which may be different from the one that the component was created for), or it can
		delete this component and return a new one.
	*/
	virtual Component* refreshComponentForCell (int rowNumber, int columnId, bool isRowSelected,
												Component* existingComponentToUpdate);

	/** This callback is made when the user clicks on one of the cells in the table.

		The mouse event's coordinates will be relative to the entire table row.
		@see cellDoubleClicked, backgroundClicked
	*/
	virtual void cellClicked (int rowNumber, int columnId, const MouseEvent& e);

	/** This callback is made when the user clicks on one of the cells in the table.

		The mouse event's coordinates will be relative to the entire table row.
		@see cellClicked, backgroundClicked
	*/
	virtual void cellDoubleClicked (int rowNumber, int columnId, const MouseEvent& e);

	/** This can be overridden to react to the user double-clicking on a part of the list where
		there are no rows.

		@see cellClicked
	*/
	virtual void backgroundClicked();

	/** This callback is made when the table's sort order is changed.

		This could be because the user has clicked a column header, or because the
		TableHeaderComponent::setSortColumnId() method was called.

		If you implement this, your method should re-sort the table using the given
		column as the key.
	*/
	virtual void sortOrderChanged (int newSortColumnId, bool isForwards);

	/** Returns the best width for one of the columns.

		If you implement this method, you should measure the width of all the items
		in this column, and return the best size.

		Returning 0 means that the column shouldn't be changed.

		This is used by TableListBox::autoSizeColumn() and TableListBox::autoSizeAllColumns().
	*/
	virtual int getColumnAutoSizeWidth (int columnId);

	/** Returns a tooltip for a particular cell in the table.
	*/
	virtual String getCellTooltip (int rowNumber, int columnId);

	/** Override this to be informed when rows are selected or deselected.

		@see ListBox::selectedRowsChanged()
	*/
	virtual void selectedRowsChanged (int lastRowSelected);

	/** Override this to be informed when the delete key is pressed.

		@see ListBox::deleteKeyPressed()
	*/
	virtual void deleteKeyPressed (int lastRowSelected);

	/** Override this to be informed when the return key is pressed.

		@see ListBox::returnKeyPressed()
	*/
	virtual void returnKeyPressed (int lastRowSelected);

	/** Override this to be informed when the list is scrolled.

		This might be caused by the user moving the scrollbar, or by programmatic changes
		to the list position.
	*/
	virtual void listWasScrolled();

	/** To allow rows from your table to be dragged-and-dropped, implement this method.

		If this returns a non-null variant then when the user drags a row, the table will try to
		find a DragAndDropContainer in its parent hierarchy, and will use it to trigger a
		drag-and-drop operation, using this string as the source description, and the listbox
		itself as the source component.

		@see getDragSourceCustomData, DragAndDropContainer::startDragging
	*/
	virtual var getDragSourceDescription (const SparseSet<int>& currentlySelectedRows);
};

/**
	A table of cells, using a TableHeaderComponent as its header.

	This component makes it easy to create a table by providing a TableListBoxModel as
	the data source.

	@see TableListBoxModel, TableHeaderComponent
*/
class JUCE_API  TableListBox   : public ListBox,
								 private ListBoxModel,
								 private TableHeaderComponent::Listener
{
public:

	/** Creates a TableListBox.

		The model pointer passed-in can be null, in which case you can set it later
		with setModel().
	*/
	TableListBox (const String& componentName = String::empty,
				  TableListBoxModel* model = 0);

	/** Destructor. */
	~TableListBox();

	/** Changes the TableListBoxModel that is being used for this table.
	*/
	void setModel (TableListBoxModel* newModel);

	/** Returns the model currently in use. */
	TableListBoxModel* getModel() const                             { return model; }

	/** Returns the header component being used in this table. */
	TableHeaderComponent& getHeader() const                         { return *header; }

	/** Sets the header component to use for the table.
		The table will take ownership of the component that you pass in, and will delete it
		when it's no longer needed.
	*/
	void setHeader (TableHeaderComponent* newHeader);

	/** Changes the height of the table header component.
		@see getHeaderHeight
	*/
	void setHeaderHeight (int newHeight);

	/** Returns the height of the table header.
		@see setHeaderHeight
	*/
	int getHeaderHeight() const;

	/** Resizes a column to fit its contents.

		This uses TableListBoxModel::getColumnAutoSizeWidth() to find the best width,
		and applies that to the column.

		@see autoSizeAllColumns, TableHeaderComponent::setColumnWidth
	*/
	void autoSizeColumn (int columnId);

	/** Calls autoSizeColumn() for all columns in the table. */
	void autoSizeAllColumns();

	/** Enables or disables the auto size options on the popup menu.

		By default, these are enabled.
	*/
	void setAutoSizeMenuOptionShown (bool shouldBeShown);

	/** True if the auto-size options should be shown on the menu.
		@see setAutoSizeMenuOptionsShown
	*/
	bool isAutoSizeMenuOptionShown() const;

	/** Returns the position of one of the cells in the table.

		If relativeToComponentTopLeft is true, the co-ordinates are relative to
		the table component's top-left. The row number isn't checked to see if it's
		in-range, but the column ID must exist or this will return an empty rectangle.

		If relativeToComponentTopLeft is false, the co-ords are relative to the
		top-left of the table's top-left cell.
	*/
	Rectangle<int> getCellPosition (int columnId, int rowNumber,
									bool relativeToComponentTopLeft) const;

	/** Returns the component that currently represents a given cell.
		If the component for this cell is off-screen or if the position is out-of-range,
		this may return 0.
		@see getCellPosition
	*/
	Component* getCellComponent (int columnId, int rowNumber) const;

	/** Scrolls horizontally if necessary to make sure that a particular column is visible.

		@see ListBox::scrollToEnsureRowIsOnscreen
	*/
	void scrollToEnsureColumnIsOnscreen (int columnId);

	/** @internal */
	int getNumRows();
	/** @internal */
	void paintListBoxItem (int, Graphics&, int, int, bool);
	/** @internal */
	Component* refreshComponentForRow (int rowNumber, bool isRowSelected, Component* existingComponentToUpdate);
	/** @internal */
	void selectedRowsChanged (int lastRowSelected);
	/** @internal */
	void deleteKeyPressed (int currentSelectedRow);
	/** @internal */
	void returnKeyPressed (int currentSelectedRow);
	/** @internal */
	void backgroundClicked();
	/** @internal */
	void listWasScrolled();
	/** @internal */
	void tableColumnsChanged (TableHeaderComponent*);
	/** @internal */
	void tableColumnsResized (TableHeaderComponent*);
	/** @internal */
	void tableSortOrderChanged (TableHeaderComponent*);
	/** @internal */
	void tableColumnDraggingChanged (TableHeaderComponent*, int);
	/** @internal */
	void resized();

private:

	TableHeaderComponent* header;
	TableListBoxModel* model;
	int columnIdNowBeingDragged;
	bool autoSizeOptionsShown;

	void updateColumnComponents() const;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (TableListBox);
};

#endif   // __JUCE_TABLELISTBOX_JUCEHEADER__

/*** End of inlined file: juce_TableListBox.h ***/


#endif
#ifndef __JUCE_TEXTEDITOR_JUCEHEADER__

#endif
#ifndef __JUCE_TOOLBAR_JUCEHEADER__

#endif
#ifndef __JUCE_TOOLBARITEMCOMPONENT_JUCEHEADER__

#endif
#ifndef __JUCE_TOOLBARITEMFACTORY_JUCEHEADER__

/*** Start of inlined file: juce_ToolbarItemFactory.h ***/
#ifndef __JUCE_TOOLBARITEMFACTORY_JUCEHEADER__
#define __JUCE_TOOLBARITEMFACTORY_JUCEHEADER__

/**
	A factory object which can create ToolbarItemComponent objects.

	A subclass of ToolbarItemFactory publishes a set of types of toolbar item
	that it can create.

	Each type of item is identified by a unique ID, and multiple instances of an
	item type can exist at once (even on the same toolbar, e.g. spacers or separator
	bars).

	@see Toolbar, ToolbarItemComponent, ToolbarButton
*/
class JUCE_API  ToolbarItemFactory
{
public:

	ToolbarItemFactory();

	/** Destructor. */
	virtual ~ToolbarItemFactory();

	/** A set of reserved item ID values, used for the built-in item types.
	*/
	enum SpecialItemIds
	{
		separatorBarId      = -1,   /**< The item ID for a vertical (or horizontal) separator bar that
										 can be placed between sets of items to break them into groups. */
		spacerId            = -2,   /**< The item ID for a fixed-width space that can be placed between
										 items.*/
		flexibleSpacerId    = -3    /**< The item ID for a gap that pushes outwards against the things on
										 either side of it, filling any available space. */
	};

	/** Must return a list of the IDs for all the item types that this factory can create.

		The ids should be added to the array that is passed-in.

		An item ID can be any integer you choose, except for 0, which is considered a null ID,
		and the predefined IDs in the SpecialItemIds enum.

		You should also add the built-in types (separatorBarId, spacerId and flexibleSpacerId)
		to this list if you want your toolbar to be able to contain those items.

		The list returned here is used by the ToolbarItemPalette class to obtain its list
		of available items, and their order on the palette will reflect the order in which
		they appear on this list.

		@see ToolbarItemPalette
	*/
	virtual void getAllToolbarItemIds (Array <int>& ids) = 0;

	/** Must return the set of items that should be added to a toolbar as its default set.

		This method is used by Toolbar::addDefaultItems() to determine which items to
		create.

		The items that your method adds to the array that is passed-in will be added to the
		toolbar in the same order. Items can appear in the list more than once.
	*/
	virtual void getDefaultItemSet (Array <int>& ids) = 0;

	/** Must create an instance of one of the items that the factory lists in its
		getAllToolbarItemIds() method.

		The itemId parameter can be any of the values listed by your getAllToolbarItemIds()
		method, except for the built-in item types from the SpecialItemIds enum, which
		are created internally by the toolbar code.

		Try not to keep a pointer to the object that is returned, as it will be deleted
		automatically by the toolbar, and remember that multiple instances of the same
		item type are likely to exist at the same time.
	*/
	virtual ToolbarItemComponent* createItem (int itemId) = 0;
};

#endif   // __JUCE_TOOLBARITEMFACTORY_JUCEHEADER__

/*** End of inlined file: juce_ToolbarItemFactory.h ***/


#endif
#ifndef __JUCE_TOOLBARITEMPALETTE_JUCEHEADER__

/*** Start of inlined file: juce_ToolbarItemPalette.h ***/
#ifndef __JUCE_TOOLBARITEMPALETTE_JUCEHEADER__
#define __JUCE_TOOLBARITEMPALETTE_JUCEHEADER__

/**
	A component containing a list of toolbar items, which the user can drag onto
	a toolbar to add them.

	You can use this class directly, but it's a lot easier to call Toolbar::showCustomisationDialog(),
	which automatically shows one of these in a dialog box with lots of extra controls.

	@see Toolbar
*/
class JUCE_API  ToolbarItemPalette    : public Component,
										public DragAndDropContainer
{
public:

	/** Creates a palette of items for a given factory, with the aim of adding them
		to the specified toolbar.

		The ToolbarItemFactory::getAllToolbarItemIds() method is used to create the
		set of items that are shown in this palette.

		The toolbar and factory must not be deleted while this object exists.
	*/
	ToolbarItemPalette (ToolbarItemFactory& factory,
						Toolbar* toolbar);

	/** Destructor. */
	~ToolbarItemPalette();

	/** @internal */
	void resized();

private:
	ToolbarItemFactory& factory;
	Toolbar* toolbar;
	Viewport viewport;
	OwnedArray <ToolbarItemComponent> items;

	friend class Toolbar;
	void replaceComponent (ToolbarItemComponent* comp);
	void addComponent (int itemId, int index);

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ToolbarItemPalette);
};

#endif   // __JUCE_TOOLBARITEMPALETTE_JUCEHEADER__

/*** End of inlined file: juce_ToolbarItemPalette.h ***/


#endif
#ifndef __JUCE_TREEVIEW_JUCEHEADER__

#endif
#ifndef __JUCE_ALERTWINDOW_JUCEHEADER__

#endif
#ifndef __JUCE_CALLOUTBOX_JUCEHEADER__

/*** Start of inlined file: juce_CallOutBox.h ***/
#ifndef __JUCE_CALLOUTBOX_JUCEHEADER__
#define __JUCE_CALLOUTBOX_JUCEHEADER__

/**
	A box with a small arrow that can be used as a temporary pop-up window to show
	extra controls when a button or other component is clicked.

	Using one of these is similar to having a popup menu attached to a button or
	other component - but it looks fancier, and has an arrow that can indicate the
	object that it applies to.

	Normally, you'd create one of these on the stack and run it modally, e.g.

	@code
	void mouseUp (const MouseEvent& e)
	{
		MyContentComponent content;
		content.setSize (300, 300);

		CallOutBox callOut (content, *this, nullptr);
		callOut.runModalLoop();
	}
	@endcode

	The call-out will resize and position itself when the content changes size.
*/
class JUCE_API  CallOutBox    : public Component
{
public:

	/** Creates a CallOutBox.

		@param contentComponent     the component to display inside the call-out. This should
									already have a size set (although the call-out will also
									update itself when the component's size is changed later).
									Obviously this component must not be deleted until the
									call-out box has been deleted.
		@param componentToPointTo   the component that the call-out's arrow should point towards
		@param parentComponent      if non-zero, this is the component to add the call-out to. If
									this is zero, the call-out will be added to the desktop.
	*/
	CallOutBox (Component& contentComponent,
				Component& componentToPointTo,
				Component* parentComponent);

	/** Destructor. */
	~CallOutBox();

	/** Changes the length of the arrow. */
	void setArrowSize (float newSize);

	/** Updates the position and size of the box.

		You shouldn't normally need to call this, unless you need more precise control over the
		layout.

		@param newAreaToPointTo     the rectangle to make the box's arrow point to
		@param newAreaToFitIn       the area within which the box's position should be constrained
	*/
	void updatePosition (const Rectangle<int>& newAreaToPointTo,
						 const Rectangle<int>& newAreaToFitIn);

	/** @internal */
	void paint (Graphics& g);
	/** @internal */
	void resized();
	/** @internal */
	void moved();
	/** @internal */
	void childBoundsChanged (Component*);
	/** @internal */
	bool hitTest (int x, int y);
	/** @internal */
	void inputAttemptWhenModal();
	/** @internal */
	bool keyPressed (const KeyPress& key);
	/** @internal */
	void handleCommandMessage (int commandId);

private:

	int borderSpace;
	float arrowSize;
	Component& content;
	Path outline;
	Point<float> targetPoint;
	Rectangle<int> availableArea, targetArea;
	Image background;

	void refreshPath();

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (CallOutBox);
};

#endif   // __JUCE_CALLOUTBOX_JUCEHEADER__

/*** End of inlined file: juce_CallOutBox.h ***/


#endif
#ifndef __JUCE_COMPONENTPEER_JUCEHEADER__

/*** Start of inlined file: juce_ComponentPeer.h ***/
#ifndef __JUCE_COMPONENTPEER_JUCEHEADER__
#define __JUCE_COMPONENTPEER_JUCEHEADER__

class ComponentBoundsConstrainer;

/**
	The Component class uses a ComponentPeer internally to create and manage a real
	operating-system window.

	This is an abstract base class - the platform specific code contains implementations of
	it for the various platforms.

	User-code should very rarely need to have any involvement with this class.

	@see Component::createNewPeer
*/
class JUCE_API  ComponentPeer
{
public:

	/** A combination of these flags is passed to the ComponentPeer constructor. */
	enum StyleFlags
	{
		windowAppearsOnTaskbar      = (1 << 0),    /**< Indicates that the window should have a corresponding
														entry on the taskbar (ignored on MacOSX) */
		windowIsTemporary           = (1 << 1),    /**< Indicates that the window is a temporary popup, like a menu,
														tooltip, etc. */
		windowIgnoresMouseClicks    = (1 << 2),    /**< Indicates that the window should let mouse clicks pass
														through it (may not be possible on some platforms). */
		windowHasTitleBar           = (1 << 3),    /**< Indicates that the window should have a normal OS-specific
														title bar and frame\. if not specified, the window will be
														borderless. */
		windowIsResizable           = (1 << 4),    /**< Indicates that the window should have a resizable border. */
		windowHasMinimiseButton     = (1 << 5),    /**< Indicates that if the window has a title bar, it should have a
														minimise button on it. */
		windowHasMaximiseButton     = (1 << 6),    /**< Indicates that if the window has a title bar, it should have a
														maximise button on it. */
		windowHasCloseButton        = (1 << 7),    /**< Indicates that if the window has a title bar, it should have a
														close button on it. */
		windowHasDropShadow         = (1 << 8),    /**< Indicates that the window should have a drop-shadow (this may
														not be possible on all platforms). */
		windowRepaintedExplictly    = (1 << 9),    /**< Not intended for public use - this tells a window not to
														do its own repainting, but only to repaint when the
														performAnyPendingRepaintsNow() method is called. */
		windowIgnoresKeyPresses     = (1 << 10),   /**< Tells the window not to catch any keypresses. This can
														be used for things like plugin windows, to stop them interfering
														with the host's shortcut keys */
		windowIsSemiTransparent     = (1 << 31)    /**< Not intended for public use - makes a window transparent. */

	};

	/** Creates a peer.

		The component is the one that we intend to represent, and the style flags are
		a combination of the values in the StyleFlags enum
	*/
	ComponentPeer (Component* component, int styleFlags);

	/** Destructor. */
	virtual ~ComponentPeer();

	/** Returns the component being represented by this peer. */
	Component* getComponent() const noexcept                { return component; }

	/** Returns the set of style flags that were set when the window was created.

		@see Component::addToDesktop
	*/
	int getStyleFlags() const noexcept                      { return styleFlags; }

	/** Returns a unique ID for this peer.
		Each peer that is created is given a different ID.
	*/
	uint32 getUniqueID() const noexcept                     { return uniqueID; }

	/** Returns the raw handle to whatever kind of window is being used.

		On windows, this is probably a HWND, on the mac, it's likely to be a WindowRef,
		but rememeber there's no guarantees what you'll get back.
	*/
	virtual void* getNativeHandle() const = 0;

	/** Shows or hides the window. */
	virtual void setVisible (bool shouldBeVisible) = 0;

	/** Changes the title of the window. */
	virtual void setTitle (const String& title) = 0;

	/** Moves the window without changing its size.

		If the native window is contained in another window, then the co-ordinates are
		relative to the parent window's origin, not the screen origin.

		This should result in a callback to handleMovedOrResized().
	*/
	virtual void setPosition (int x, int y) = 0;

	/** Resizes the window without changing its position.

		This should result in a callback to handleMovedOrResized().
	*/
	virtual void setSize (int w, int h) = 0;

	/** Moves and resizes the window.

		If the native window is contained in another window, then the co-ordinates are
		relative to the parent window's origin, not the screen origin.

		This should result in a callback to handleMovedOrResized().
	*/
	virtual void setBounds (int x, int y, int w, int h, bool isNowFullScreen) = 0;

	/** Returns the current position and size of the window.

		If the native window is contained in another window, then the co-ordinates are
		relative to the parent window's origin, not the screen origin.
	*/
	virtual Rectangle<int> getBounds() const = 0;

	/** Returns the x-position of this window, relative to the screen's origin. */
	virtual Point<int> getScreenPosition() const = 0;

	/** Converts a position relative to the top-left of this component to screen co-ordinates. */
	virtual Point<int> localToGlobal (const Point<int>& relativePosition) = 0;

	/** Converts a rectangle relative to the top-left of this component to screen co-ordinates. */
	virtual Rectangle<int> localToGlobal (const Rectangle<int>& relativePosition);

	/** Converts a screen co-ordinate to a position relative to the top-left of this component. */
	virtual Point<int> globalToLocal (const Point<int>& screenPosition) = 0;

	/** Converts a screen area to a position relative to the top-left of this component. */
	virtual Rectangle<int> globalToLocal (const Rectangle<int>& screenPosition);

	/** Minimises the window. */
	virtual void setMinimised (bool shouldBeMinimised) = 0;

	/** True if the window is currently minimised. */
	virtual bool isMinimised() const = 0;

	/** Enable/disable fullscreen mode for the window. */
	virtual void setFullScreen (bool shouldBeFullScreen) = 0;

	/** True if the window is currently full-screen. */
	virtual bool isFullScreen() const = 0;

	/** Sets the size to restore to if fullscreen mode is turned off. */
	void setNonFullScreenBounds (const Rectangle<int>& newBounds) noexcept;

	/** Returns the size to restore to if fullscreen mode is turned off. */
	const Rectangle<int>& getNonFullScreenBounds() const noexcept;

	/** Attempts to change the icon associated with this window.
	*/
	virtual void setIcon (const Image& newIcon) = 0;

	/** Sets a constrainer to use if the peer can resize itself.

		The constrainer won't be deleted by this object, so the caller must manage its lifetime.
	*/
	void setConstrainer (ComponentBoundsConstrainer* newConstrainer) noexcept;

	/** Returns the current constrainer, if one has been set. */
	ComponentBoundsConstrainer* getConstrainer() const noexcept             { return constrainer; }

	/** Checks if a point is in the window.

		Coordinates are relative to the top-left of this window. If trueIfInAChildWindow
		is false, then this returns false if the point is actually inside a child of this
		window.
	*/
	virtual bool contains (const Point<int>& position, bool trueIfInAChildWindow) const = 0;

	/** Returns the size of the window frame that's around this window.

		Whether or not the window has a normal window frame depends on the flags
		that were set when the window was created by Component::addToDesktop()
	*/
	virtual BorderSize<int> getFrameSize() const = 0;

	/** This is called when the window's bounds change.

		A peer implementation must call this when the window is moved and resized, so that
		this method can pass the message on to the component.
	*/
	void handleMovedOrResized();

	/** This is called if the screen resolution changes.

		A peer implementation must call this if the monitor arrangement changes or the available
		screen size changes.
	*/
	void handleScreenSizeChange();

	/** This is called to repaint the component into the given context. */
	void handlePaint (LowLevelGraphicsContext& contextToPaintTo);

	/** Sets this window to either be always-on-top or normal.

		Some kinds of window might not be able to do this, so should return false.
	*/
	virtual bool setAlwaysOnTop (bool alwaysOnTop) = 0;

	/** Brings the window to the top, optionally also giving it focus. */
	virtual void toFront (bool makeActive) = 0;

	/** Moves the window to be just behind another one. */
	virtual void toBehind (ComponentPeer* other) = 0;

	/** Called when the window is brought to the front, either by the OS or by a call
		to toFront().
	*/
	void handleBroughtToFront();

	/** True if the window has the keyboard focus. */
	virtual bool isFocused() const = 0;

	/** Tries to give the window keyboard focus. */
	virtual void grabFocus() = 0;

	/** Called when the window gains keyboard focus. */
	void handleFocusGain();
	/** Called when the window loses keyboard focus. */
	void handleFocusLoss();

	Component* getLastFocusedSubcomponent() const noexcept;

	/** Called when a key is pressed.

		For keycode info, see the KeyPress class.
		Returns true if the keystroke was used.
	*/
	bool handleKeyPress (int keyCode, juce_wchar textCharacter);

	/** Called whenever a key is pressed or released.
		Returns true if the keystroke was used.
	*/
	bool handleKeyUpOrDown (bool isKeyDown);

	/** Called whenever a modifier key is pressed or released. */
	void handleModifierKeysChange();

	/** Tells the window that text input may be required at the given position.
		This may cause things like a virtual on-screen keyboard to appear, depending
		on the OS.
	*/
	virtual void textInputRequired (const Point<int>& position) = 0;

	/** If there's some kind of OS input-method in progress, this should dismiss it. */
	virtual void dismissPendingTextInput();

	/** Returns the currently focused TextInputTarget, or null if none is found. */
	TextInputTarget* findCurrentTextInputTarget();

	/** Invalidates a region of the window to be repainted asynchronously. */
	virtual void repaint (const Rectangle<int>& area) = 0;

	/** This can be called (from the message thread) to cause the immediate redrawing
		of any areas of this window that need repainting.

		You shouldn't ever really need to use this, it's mainly for special purposes
		like supporting audio plugins where the host's event loop is out of our control.
	*/
	virtual void performAnyPendingRepaintsNow() = 0;

	/** Changes the window's transparency. */
	virtual void setAlpha (float newAlpha) = 0;

	void handleMouseEvent (int touchIndex, const Point<int>& positionWithinPeer, const ModifierKeys& newMods, int64 time);
	void handleMouseWheel (int touchIndex, const Point<int>& positionWithinPeer, int64 time, float x, float y);

	void handleUserClosingWindow();

	bool handleFileDragMove (const StringArray& files, const Point<int>& position);
	bool handleFileDragExit (const StringArray& files);
	bool handleFileDragDrop (const StringArray& files, const Point<int>& position);

	/** Resets the masking region.

		The subclass should call this every time it's about to call the handlePaint
		method.

		@see addMaskedRegion
	*/
	void clearMaskedRegion();

	/** Adds a rectangle to the set of areas not to paint over.

		A component can call this on its peer during its paint() method, to signal
		that the painting code should ignore a given region. The reason
		for this is to stop embedded windows (such as OpenGL) getting painted over.

		The masked region is cleared each time before a paint happens, so a component
		will have to make sure it calls this every time it's painted.
	*/
	void addMaskedRegion (const Rectangle<int>& area);

	/** Returns the number of currently-active peers.

		@see getPeer
	*/
	static int getNumPeers() noexcept;

	/** Returns one of the currently-active peers.

		@see getNumPeers
	*/
	static ComponentPeer* getPeer (int index) noexcept;

	/** Checks if this peer object is valid.

		@see getNumPeers
	*/
	static bool isValidPeer (const ComponentPeer* peer) noexcept;

	virtual StringArray getAvailableRenderingEngines();
	virtual int getCurrentRenderingEngine() const;
	virtual void setCurrentRenderingEngine (int index);

protected:

	Component* const component;
	const int styleFlags;
	RectangleList maskedRegion;
	Rectangle<int> lastNonFullscreenBounds;
	uint32 lastPaintTime;
	ComponentBoundsConstrainer* constrainer;

	static void updateCurrentModifiers() noexcept;

private:

	WeakReference<Component> lastFocusedComponent, dragAndDropTargetComponent;
	Component* lastDragAndDropCompUnderMouse;
	const uint32 uniqueID;
	bool fakeMouseMessageSent : 1, isWindowMinimised : 1;

	friend class Component;
	friend class Desktop;
	static ComponentPeer* getPeerFor (const Component* component) noexcept;

	void setLastDragDropTarget (Component* comp);

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ComponentPeer);
};

#endif   // __JUCE_COMPONENTPEER_JUCEHEADER__

/*** End of inlined file: juce_ComponentPeer.h ***/


#endif
#ifndef __JUCE_DIALOGWINDOW_JUCEHEADER__

/*** Start of inlined file: juce_DialogWindow.h ***/
#ifndef __JUCE_DIALOGWINDOW_JUCEHEADER__
#define __JUCE_DIALOGWINDOW_JUCEHEADER__

/**
	A dialog-box style window.

	This class is a convenient way of creating a DocumentWindow with a close button
	that can be triggered by pressing the escape key.

	Any of the methods available to a DocumentWindow or ResizableWindow are also
	available to this, so it can be made resizable, have a menu bar, etc.

	To add items to the box, see the ResizableWindow::setContentOwned() or
	ResizableWindow::setContentNonOwned() methods. Don't add components directly to this
	class - always put them in a content component!

	You'll need to override the DocumentWindow::closeButtonPressed() method to handle
	the user clicking the close button - for more info, see the DocumentWindow
	help.

	@see DocumentWindow, ResizableWindow
*/
class JUCE_API  DialogWindow   : public DocumentWindow
{
public:

	/** Creates a DialogWindow.

		@param name                 the name to give the component - this is also
									the title shown at the top of the window. To change
									this later, use setName()
		@param backgroundColour     the colour to use for filling the window's background.
		@param escapeKeyTriggersCloseButton if true, then pressing the escape key will cause the
											close button to be triggered
		@param addToDesktop         if true, the window will be automatically added to the
									desktop; if false, you can use it as a child component
	*/
	DialogWindow (const String& name,
				  const Colour& backgroundColour,
				  bool escapeKeyTriggersCloseButton,
				  bool addToDesktop = true);

	/** Destructor.
		If a content component has been set with setContentOwned(), it will be deleted.
	*/
	~DialogWindow();

	/** Easy way of quickly showing a dialog box containing a given component.

		This will open and display a DialogWindow containing a given component, making it
		modal, but returning immediately to allow the dialog to finish in its own time. If
		you want to block and run a modal loop until the dialog is dismissed, use showModalDialog()
		instead.

		To close the dialog programatically, you should call exitModalState (returnValue) on
		the DialogWindow that is created. To find a pointer to this window from your
		contentComponent, you can do something like this:
		@code
		Dialogwindow* dw = contentComponent->findParentComponentOfClass ((DialogWindow*) nullptr);

		if (dw != nullptr)
			dw->exitModalState (1234);
		@endcode

		@param dialogTitle          the dialog box's title
		@param contentComponent     the content component for the dialog box. Make sure
									that this has been set to the size you want it to
									be before calling this method. The component won't
									be deleted by this call, so you can re-use it or delete
									it afterwards
		@param componentToCentreAround  if this is non-zero, it indicates a component that
									you'd like to show this dialog box in front of. See the
									DocumentWindow::centreAroundComponent() method for more
									info on this parameter
		@param backgroundColour     a colour to use for the dialog box's background colour
		@param escapeKeyTriggersCloseButton if true, then pressing the escape key will cause the
											close button to be triggered
		@param shouldBeResizable    if true, the dialog window has either a resizable border, or
									a corner resizer
		@param useBottomRightCornerResizer     if shouldBeResizable is true, this indicates whether
									to use a border or corner resizer component. See ResizableWindow::setResizable()
	*/
	static void showDialog (const String& dialogTitle,
							Component* contentComponent,
							Component* componentToCentreAround,
							const Colour& backgroundColour,
							bool escapeKeyTriggersCloseButton,
							bool shouldBeResizable = false,
							bool useBottomRightCornerResizer = false);

	/** Easy way of quickly showing a dialog box containing a given component.

		This will open and display a DialogWindow containing a given component, returning
		when the user clicks its close button.

		It returns the value that was returned by the dialog box's runModalLoop() call.

		To close the dialog programatically, you should call exitModalState (returnValue) on
		the DialogWindow that is created. To find a pointer to this window from your
		contentComponent, you can do something like this:
		@code
		Dialogwindow* dw = contentComponent->findParentComponentOfClass ((DialogWindow*) nullptr);

		if (dw != nullptr)
			dw->exitModalState (1234);
		@endcode

		@param dialogTitle          the dialog box's title
		@param contentComponent     the content component for the dialog box. Make sure
									that this has been set to the size you want it to
									be before calling this method. The component won't
									be deleted by this call, so you can re-use it or delete
									it afterwards
		@param componentToCentreAround  if this is non-zero, it indicates a component that
									you'd like to show this dialog box in front of. See the
									DocumentWindow::centreAroundComponent() method for more
									info on this parameter
		@param backgroundColour     a colour to use for the dialog box's background colour
		@param escapeKeyTriggersCloseButton if true, then pressing the escape key will cause the
											close button to be triggered
		@param shouldBeResizable    if true, the dialog window has either a resizable border, or
									a corner resizer
		@param useBottomRightCornerResizer     if shouldBeResizable is true, this indicates whether
									to use a border or corner resizer component. See ResizableWindow::setResizable()
	*/
   #if JUCE_MODAL_LOOPS_PERMITTED || DOXYGEN
	static int showModalDialog (const String& dialogTitle,
								Component* contentComponent,
								Component* componentToCentreAround,
								const Colour& backgroundColour,
								bool escapeKeyTriggersCloseButton,
								bool shouldBeResizable = false,
								bool useBottomRightCornerResizer = false);
   #endif

protected:
	/** @internal */
	void resized();

private:

	bool escapeKeyTriggersCloseButton;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (DialogWindow);
};

#endif   // __JUCE_DIALOGWINDOW_JUCEHEADER__

/*** End of inlined file: juce_DialogWindow.h ***/


#endif
#ifndef __JUCE_DOCUMENTWINDOW_JUCEHEADER__

#endif
#ifndef __JUCE_NATIVEMESSAGEBOX_JUCEHEADER__

/*** Start of inlined file: juce_NativeMessageBox.h ***/
#ifndef __JUCE_NATIVEMESSAGEBOX_JUCEHEADER__
#define __JUCE_NATIVEMESSAGEBOX_JUCEHEADER__

class NativeMessageBox
{
public:
	/** Shows a dialog box that just has a message and a single 'ok' button to close it.

		If the callback parameter is null, the box is shown modally, and the method will
		block until the user has clicked the button (or pressed the escape or return keys).
		If the callback parameter is non-null, the box will be displayed and placed into a
		modal state, but this method will return immediately, and the callback will be invoked
		later when the user dismisses the box.

		@param iconType     the type of icon to show
		@param title        the headline to show at the top of the box
		@param message      a longer, more descriptive message to show underneath the title
		@param associatedComponent   if this is non-null, it specifies the component that the
							alert window should be associated with. Depending on the look
							and feel, this might be used for positioning of the alert window.
	*/
   #if JUCE_MODAL_LOOPS_PERMITTED
	static void JUCE_CALLTYPE showMessageBox (AlertWindow::AlertIconType iconType,
											  const String& title,
											  const String& message,
											  Component* associatedComponent = nullptr);
   #endif

	/** Shows a dialog box that just has a message and a single 'ok' button to close it.

		If the callback parameter is null, the box is shown modally, and the method will
		block until the user has clicked the button (or pressed the escape or return keys).
		If the callback parameter is non-null, the box will be displayed and placed into a
		modal state, but this method will return immediately, and the callback will be invoked
		later when the user dismisses the box.

		@param iconType     the type of icon to show
		@param title        the headline to show at the top of the box
		@param message      a longer, more descriptive message to show underneath the title
		@param associatedComponent   if this is non-null, it specifies the component that the
							alert window should be associated with. Depending on the look
							and feel, this might be used for positioning of the alert window.
	*/
	static void JUCE_CALLTYPE showMessageBoxAsync (AlertWindow::AlertIconType iconType,
												   const String& title,
												   const String& message,
												   Component* associatedComponent = nullptr);

	/** Shows a dialog box with two buttons.

		Ideal for ok/cancel or yes/no choices. The return key can also be used
		to trigger the first button, and the escape key for the second button.

		If the callback parameter is null, the box is shown modally, and the method will
		block until the user has clicked the button (or pressed the escape or return keys).
		If the callback parameter is non-null, the box will be displayed and placed into a
		modal state, but this method will return immediately, and the callback will be invoked
		later when the user dismisses the box.

		@param iconType     the type of icon to show
		@param title        the headline to show at the top of the box
		@param message      a longer, more descriptive message to show underneath the title
		@param associatedComponent   if this is non-null, it specifies the component that the
							alert window should be associated with. Depending on the look
							and feel, this might be used for positioning of the alert window.
		@param callback     if this is non-null, the menu will be launched asynchronously,
							returning immediately, and the callback will receive a call to its
							modalStateFinished() when the box is dismissed, with its parameter
							being 1 if the ok button was pressed, or 0 for cancel, The callback object
							will be owned and deleted by the system, so make sure that it works
							safely and doesn't keep any references to objects that might be deleted
							before it gets called.
		@returns true if button 1 was clicked, false if it was button 2. If the callback parameter
				 is not null, the method always returns false, and the user's choice is delivered
				 later by the callback.
	*/
	static bool JUCE_CALLTYPE showOkCancelBox (AlertWindow::AlertIconType iconType,
											   const String& title,
											   const String& message,
											#if JUCE_MODAL_LOOPS_PERMITTED
											   Component* associatedComponent = nullptr,
											   ModalComponentManager::Callback* callback = nullptr);
											#else
											   Component* associatedComponent,
											   ModalComponentManager::Callback* callback);
											#endif

	/** Shows a dialog box with three buttons.

		Ideal for yes/no/cancel boxes.

		The escape key can be used to trigger the third button.

		If the callback parameter is null, the box is shown modally, and the method will
		block until the user has clicked the button (or pressed the escape or return keys).
		If the callback parameter is non-null, the box will be displayed and placed into a
		modal state, but this method will return immediately, and the callback will be invoked
		later when the user dismisses the box.

		@param iconType     the type of icon to show
		@param title        the headline to show at the top of the box
		@param message      a longer, more descriptive message to show underneath the title
		@param associatedComponent   if this is non-null, it specifies the component that the
							alert window should be associated with. Depending on the look
							and feel, this might be used for positioning of the alert window.
		@param callback     if this is non-null, the menu will be launched asynchronously,
							returning immediately, and the callback will receive a call to its
							modalStateFinished() when the box is dismissed, with its parameter
							being 1 if the "yes" button was pressed, 2 for the "no" button, or 0
							if it was cancelled, The callback object will be owned and deleted by the
							system, so make sure that it works safely and doesn't keep any references
							to objects that might be deleted before it gets called.

		@returns If the callback parameter has been set, this returns 0. Otherwise, it returns one
				 of the following values:
				 - 0 if 'cancel' was pressed
				 - 1 if 'yes' was pressed
				 - 2 if 'no' was pressed
	*/
	static int JUCE_CALLTYPE showYesNoCancelBox (AlertWindow::AlertIconType iconType,
												 const String& title,
												 const String& message,
											   #if JUCE_MODAL_LOOPS_PERMITTED
												 Component* associatedComponent = nullptr,
												 ModalComponentManager::Callback* callback = nullptr);
											   #else
												 Component* associatedComponent,
												 ModalComponentManager::Callback* callback);
											   #endif
};

#endif   // __JUCE_NATIVEMESSAGEBOX_JUCEHEADER__

/*** End of inlined file: juce_NativeMessageBox.h ***/


#endif
#ifndef __JUCE_RESIZABLEWINDOW_JUCEHEADER__

#endif
#ifndef __JUCE_THREADWITHPROGRESSWINDOW_JUCEHEADER__

/*** Start of inlined file: juce_ThreadWithProgressWindow.h ***/
#ifndef __JUCE_THREADWITHPROGRESSWINDOW_JUCEHEADER__
#define __JUCE_THREADWITHPROGRESSWINDOW_JUCEHEADER__

/**
	A thread that automatically pops up a modal dialog box with a progress bar
	and cancel button while it's busy running.

	These are handy for performing some sort of task while giving the user feedback
	about how long there is to go, etc.

	E.g. @code
	class MyTask  : public ThreadWithProgressWindow
	{
	public:
		MyTask()    : ThreadWithProgressWindow ("busy...", true, true)
		{
		}

		~MyTask()
		{
		}

		void run()
		{
			for (int i = 0; i < thingsToDo; ++i)
			{
				// must check this as often as possible, because this is
				// how we know if the user's pressed 'cancel'
				if (threadShouldExit())
					break;

				// this will update the progress bar on the dialog box
				setProgress (i / (double) thingsToDo);

				//   ... do the business here...
			}
		}
	};

	void doTheTask()
	{
		MyTask m;

		if (m.runThread())
		{
			// thread finished normally..
		}
		else
		{
			// user pressed the cancel button..
		}
	}

	@endcode

	@see Thread, AlertWindow
*/
class JUCE_API  ThreadWithProgressWindow  : public Thread,
											private Timer
{
public:

	/** Creates the thread.

		Initially, the dialog box won't be visible, it'll only appear when the
		runThread() method is called.

		@param windowTitle              the title to go at the top of the dialog box
		@param hasProgressBar           whether the dialog box should have a progress bar (see
										setProgress() )
		@param hasCancelButton          whether the dialog box should have a cancel button
		@param timeOutMsWhenCancelling  when 'cancel' is pressed, this is how long to wait for
										the thread to stop before killing it forcibly (see
										Thread::stopThread() )
		@param cancelButtonText         the text that should be shown in the cancel button
										(if it has one)
	*/
	ThreadWithProgressWindow (const String& windowTitle,
							  bool hasProgressBar,
							  bool hasCancelButton,
							  int timeOutMsWhenCancelling = 10000,
							  const String& cancelButtonText = "Cancel");

	/** Destructor. */
	~ThreadWithProgressWindow();

	/** Starts the thread and waits for it to finish.

		This will start the thread, make the dialog box appear, and wait until either
		the thread finishes normally, or until the cancel button is pressed.

		Before returning, the dialog box will be hidden.

		@param threadPriority   the priority to use when starting the thread - see
								Thread::startThread() for values
		@returns true if the thread finished normally; false if the user pressed cancel
	*/
	bool runThread (int threadPriority = 5);

	/** The thread should call this periodically to update the position of the progress bar.

		@param newProgress  the progress, from 0.0 to 1.0
		@see setStatusMessage
	*/
	void setProgress (double newProgress);

	/** The thread can call this to change the message that's displayed in the dialog box.
	*/
	void setStatusMessage (const String& newStatusMessage);

	/** Returns the AlertWindow that is being used.
	*/
	AlertWindow* getAlertWindow() const noexcept        { return alertWindow; }

private:

	void timerCallback();

	double progress;
	ScopedPointer <AlertWindow> alertWindow;
	String message;
	CriticalSection messageLock;
	const int timeOutMsWhenCancelling;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ThreadWithProgressWindow);
};

#endif   // __JUCE_THREADWITHPROGRESSWINDOW_JUCEHEADER__

/*** End of inlined file: juce_ThreadWithProgressWindow.h ***/


#endif
#ifndef __JUCE_TOOLTIPWINDOW_JUCEHEADER__

#endif
#ifndef __JUCE_TOPLEVELWINDOW_JUCEHEADER__

#endif
#ifndef __JUCE_APPLICATIONCOMMANDID_JUCEHEADER__

#endif
#ifndef __JUCE_APPLICATIONCOMMANDINFO_JUCEHEADER__

#endif
#ifndef __JUCE_APPLICATIONCOMMANDMANAGER_JUCEHEADER__

#endif
#ifndef __JUCE_APPLICATIONCOMMANDTARGET_JUCEHEADER__

#endif
#ifndef __JUCE_KEYPRESSMAPPINGSET_JUCEHEADER__

/*** Start of inlined file: juce_KeyPressMappingSet.h ***/
#ifndef __JUCE_KEYPRESSMAPPINGSET_JUCEHEADER__
#define __JUCE_KEYPRESSMAPPINGSET_JUCEHEADER__

/**
	Manages and edits a list of keypresses, which it uses to invoke the appropriate
	command in a ApplicationCommandManager.

	Normally, you won't actually create a KeyPressMappingSet directly, because
	each ApplicationCommandManager contains its own KeyPressMappingSet, so typically
	you'd create yourself an ApplicationCommandManager, and call its
	ApplicationCommandManager::getKeyMappings() method to get a pointer to its
	KeyPressMappingSet.

	For one of these to actually use keypresses, you'll need to add it as a KeyListener
	to the top-level component for which you want to handle keystrokes. So for example:

	@code
	class MyMainWindow  : public Component
	{
		ApplicationCommandManager* myCommandManager;

	public:
		MyMainWindow()
		{
			myCommandManager = new ApplicationCommandManager();

			// first, make sure the command manager has registered all the commands that its
			// targets can perform..
			myCommandManager->registerAllCommandsForTarget (myCommandTarget1);
			myCommandManager->registerAllCommandsForTarget (myCommandTarget2);

			// this will use the command manager to initialise the KeyPressMappingSet with
			// the default keypresses that were specified when the targets added their commands
			// to the manager.
			myCommandManager->getKeyMappings()->resetToDefaultMappings();

			// having set up the default key-mappings, you might now want to load the last set
			// of mappings that the user configured.
			myCommandManager->getKeyMappings()->restoreFromXml (lastSavedKeyMappingsXML);

			// Now tell our top-level window to send any keypresses that arrive to the
			// KeyPressMappingSet, which will use them to invoke the appropriate commands.
			addKeyListener (myCommandManager->getKeyMappings());
		}

		...
	}
	@endcode

	KeyPressMappingSet derives from ChangeBroadcaster so that interested parties can
	register to be told when a command or mapping is added, removed, etc.

	There's also a UI component called KeyMappingEditorComponent that can be used
	to easily edit the key mappings.

	@see Component::addKeyListener(), KeyMappingEditorComponent, ApplicationCommandManager
*/
class JUCE_API  KeyPressMappingSet  : public KeyListener,
									  public ChangeBroadcaster,
									  public FocusChangeListener
{
public:

	/** Creates a KeyPressMappingSet for a given command manager.

		Normally, you won't actually create a KeyPressMappingSet directly, because
		each ApplicationCommandManager contains its own KeyPressMappingSet, so the
		best thing to do is to create your ApplicationCommandManager, and use the
		ApplicationCommandManager::getKeyMappings() method to access its mappings.

		When a suitable keypress happens, the manager's invoke() method will be
		used to invoke the appropriate command.

		@see ApplicationCommandManager
	*/
	explicit KeyPressMappingSet (ApplicationCommandManager* commandManager);

	/** Creates an copy of a KeyPressMappingSet. */
	KeyPressMappingSet (const KeyPressMappingSet& other);

	/** Destructor. */
	~KeyPressMappingSet();

	ApplicationCommandManager* getCommandManager() const noexcept       { return commandManager; }

	/** Returns a list of keypresses that are assigned to a particular command.

		@param commandID        the command's ID
	*/
	Array<KeyPress> getKeyPressesAssignedToCommand (CommandID commandID) const;

	/** Assigns a keypress to a command.

		If the keypress is already assigned to a different command, it will first be
		removed from that command, to avoid it triggering multiple functions.

		@param commandID    the ID of the command that you want to add a keypress to. If
							this is 0, the keypress will be removed from anything that it
							was previously assigned to, but not re-assigned
		@param newKeyPress  the new key-press
		@param insertIndex  if this is less than zero, the key will be appended to the
							end of the list of keypresses; otherwise the new keypress will
							be inserted into the existing list at this index
	*/
	void addKeyPress (CommandID commandID,
					  const KeyPress& newKeyPress,
					  int insertIndex = -1);

	/** Reset all mappings to the defaults, as dictated by the ApplicationCommandManager.

		@see resetToDefaultMapping
	*/
	void resetToDefaultMappings();

	/** Resets all key-mappings to the defaults for a particular command.

		@see resetToDefaultMappings
	*/
	void resetToDefaultMapping (CommandID commandID);

	/** Removes all keypresses that are assigned to any commands. */
	void clearAllKeyPresses();

	/** Removes all keypresses that are assigned to a particular command. */
	void clearAllKeyPresses (CommandID commandID);

	/** Removes one of the keypresses that are assigned to a command.

		See the getKeyPressesAssignedToCommand() for the list of keypresses to
		which the keyPressIndex refers.
	*/
	void removeKeyPress (CommandID commandID, int keyPressIndex);

	/** Removes a keypress from any command that it may be assigned to.
	*/
	void removeKeyPress (const KeyPress& keypress);

	/** Returns true if the given command is linked to this key. */
	bool containsMapping (CommandID commandID, const KeyPress& keyPress) const noexcept;

	/** Looks for a command that corresponds to a keypress.

		@returns the UID of the command or 0 if none was found
	*/
	CommandID findCommandForKeyPress (const KeyPress& keyPress) const noexcept;

	/** Tries to recreate the mappings from a previously stored state.

		The XML passed in must have been created by the createXml() method.

		If the stored state makes any reference to commands that aren't
		currently available, these will be ignored.

		If the set of mappings being loaded was a set of differences (using createXml (true)),
		then this will call resetToDefaultMappings() and then merge the saved mappings
		on top. If the saved set was created with createXml (false), then this method
		will first clear all existing mappings and load the saved ones as a complete set.

		@returns true if it manages to load the XML correctly
		@see createXml
	*/
	bool restoreFromXml (const XmlElement& xmlVersion);

	/** Creates an XML representation of the current mappings.

		This will produce a lump of XML that can be later reloaded using
		restoreFromXml() to recreate the current mapping state.

		The object that is returned must be deleted by the caller.

		@param saveDifferencesFromDefaultSet    if this is false, then all keypresses
							will be saved into the XML. If it's true, then the XML will
							only store the differences between the current mappings and
							the default mappings you'd get from calling resetToDefaultMappings().
							The advantage of saving a set of differences from the default is that
							if you change the default mappings (in a new version of your app, for
							example), then these will be merged into a user's saved preferences.

		@see restoreFromXml
	*/
	XmlElement* createXml (bool saveDifferencesFromDefaultSet) const;

	/** @internal */
	bool keyPressed (const KeyPress& key, Component* originatingComponent);
	/** @internal */
	bool keyStateChanged (bool isKeyDown, Component* originatingComponent);
	/** @internal */
	void globalFocusChanged (Component* focusedComponent);

private:

	ApplicationCommandManager* commandManager;

	struct CommandMapping
	{
		CommandID commandID;
		Array <KeyPress> keypresses;
		bool wantsKeyUpDownCallbacks;
	};

	OwnedArray <CommandMapping> mappings;

	struct KeyPressTime
	{
		KeyPress key;
		uint32 timeWhenPressed;
	};

	OwnedArray <KeyPressTime> keysDown;

	void handleMessage (const Message& message);

	void invokeCommand (const CommandID commandID,
						const KeyPress& keyPress,
						const bool isKeyDown,
						const int millisecsSinceKeyPressed,
						Component* const originatingComponent) const;

	KeyPressMappingSet& operator= (const KeyPressMappingSet&);
	JUCE_LEAK_DETECTOR (KeyPressMappingSet);
};

#endif   // __JUCE_KEYPRESSMAPPINGSET_JUCEHEADER__

/*** End of inlined file: juce_KeyPressMappingSet.h ***/


#endif
#ifndef __JUCE_APPLICATION_JUCEHEADER__

/*** Start of inlined file: juce_Application.h ***/
#ifndef __JUCE_APPLICATION_JUCEHEADER__
#define __JUCE_APPLICATION_JUCEHEADER__

/**
	An instance of this class is used to specify initialisation and shutdown
	code for the application.

	An application that wants to run in the JUCE framework needs to declare a
	subclass of JUCEApplication and implement its various pure virtual methods.

	It then needs to use the START_JUCE_APPLICATION macro somewhere in a cpp file
	to declare an instance of this class and generate a suitable platform-specific
	main() function.

	e.g. @code
		class MyJUCEApp  : public JUCEApplication
		{
		public:
			MyJUCEApp()
			{
			}

			~MyJUCEApp()
			{
			}

			void initialise (const String& commandLine)
			{
				myMainWindow = new MyApplicationWindow();
				myMainWindow->setBounds (100, 100, 400, 500);
				myMainWindow->setVisible (true);
			}

			void shutdown()
			{
				myMainWindow = 0;
			}

			const String getApplicationName()
			{
				return "Super JUCE-o-matic";
			}

			const String getApplicationVersion()
			{
				return "1.0";
			}

		private:
			ScopedPointer <MyApplicationWindow> myMainWindow;
		};

		// this creates wrapper code to actually launch the app properly.
		START_JUCE_APPLICATION (MyJUCEApp)
	@endcode

	@see MessageManager
*/
class JUCE_API  JUCEApplication  : public JUCEApplicationBase,
								   public ApplicationCommandTarget
{
protected:

	/** Constructs a JUCE app object.

		If subclasses implement a constructor or destructor, they shouldn't call any
		JUCE code in there - put your startup/shutdown code in initialise() and
		shutdown() instead.
	*/
	JUCEApplication();

public:
	/** Destructor.

		If subclasses implement a constructor or destructor, they shouldn't call any
		JUCE code in there - put your startup/shutdown code in initialise() and
		shutdown() instead.
	*/
	virtual ~JUCEApplication();

	/** Returns the global instance of the application object being run. */
	static JUCEApplication* getInstance() noexcept          { return dynamic_cast <JUCEApplication*> (JUCEApplicationBase::getInstance()); }

	/** Returns true if the application hasn't yet completed its initialise() method
		and entered the main event loop.

		This is handy for things like splash screens to know when the app's up-and-running
		properly.
	*/
	bool isInitialising() const noexcept                    { return stillInitialising; }

	/** Returns the application's name.

		An application must implement this to name itself.
	*/
	virtual const String getApplicationName() = 0;

	/** Returns the application's version number.
	*/
	virtual const String getApplicationVersion() = 0;

	/** Checks whether multiple instances of the app are allowed.

		If you application class returns true for this, more than one instance is
		permitted to run (except on OSX where the OS automatically stops you launching
		a second instance of an app without explicitly starting it from the command-line).

		If it's false, the second instance won't start, but it you will still get a
		callback to anotherInstanceStarted() to tell you about this - which
		gives you a chance to react to what the user was trying to do.
	*/
	virtual bool moreThanOneInstanceAllowed();

	/** Indicates that the user has tried to start up another instance of the app.

		This will get called even if moreThanOneInstanceAllowed() is false.
	*/
	virtual void anotherInstanceStarted (const String& commandLine);

	/** Called when the operating system is trying to close the application.

		The default implementation of this method is to call quit(), but it may
		be overloaded to ignore the request or do some other special behaviour
		instead. For example, you might want to offer the user the chance to save
		their changes before quitting, and give them the chance to cancel.

		If you want to send a quit signal to your app, this is the correct method
		to call, because it means that requests that come from the system get handled
		in the same way as those from your own application code. So e.g. you'd
		call this method from a "quit" item on a menu bar.
	*/
	virtual void systemRequestedQuit();

	/** If any unhandled exceptions make it through to the message dispatch loop, this
		callback will be triggered, in case you want to log them or do some other
		type of error-handling.

		If the type of exception is derived from the std::exception class, the pointer
		passed-in will be valid. If the exception is of unknown type, this pointer
		will be null.
	*/
	virtual void unhandledException (const std::exception* e,
									 const String& sourceFilename,
									 int lineNumber);

	/** Signals that the main message loop should stop and the application should terminate.

		This isn't synchronous, it just posts a quit message to the main queue, and
		when this message arrives, the message loop will stop, the shutdown() method
		will be called, and the app will exit.

		Note that this will cause an unconditional quit to happen, so if you need an
		extra level before this, e.g. to give the user the chance to save their work
		and maybe cancel the quit, you'll need to handle this in the systemRequestedQuit()
		method - see that method's help for more info.

		@see MessageManager
	*/
	static void quit();

	/** Sets the value that should be returned as the application's exit code when the
		app quits.

		This is the value that's returned by the main() function. Normally you'd leave this
		as 0 unless you want to indicate an error code.

		@see getApplicationReturnValue
	*/
	void setApplicationReturnValue (int newReturnValue) noexcept;

	/** Returns the value that has been set as the application's exit code.
		@see setApplicationReturnValue
	*/
	int getApplicationReturnValue() const noexcept                  { return appReturnValue; }

	/** Returns the application's command line parameters. */
	const String& getCommandLineParameters() const noexcept         { return commandLineParameters; }

	/** Returns true if this executable is running as an app (as opposed to being a plugin
		or other kind of shared library. */
	static inline bool isStandaloneApp() noexcept                   { return createInstance != 0; }

	/** @internal */
	ApplicationCommandTarget* getNextCommandTarget();
	/** @internal */
	void getCommandInfo (CommandID commandID, ApplicationCommandInfo& result);
	/** @internal */
	void getAllCommands (Array <CommandID>& commands);
	/** @internal */
	bool perform (const InvocationInfo& info);

   #ifndef DOXYGEN
	// The following methods are internal calls - not for public use.
	static int main (const String& commandLine);
	static int main (int argc, const char* argv[]);
	static void sendUnhandledException (const std::exception* e, const char* sourceFile, int lineNumber);
	bool initialiseApp (const String& commandLine);
	int shutdownApp();
   #endif

private:

	String commandLineParameters;
	ScopedPointer<InterProcessLock> appLock;
	ScopedPointer<ActionListener> broadcastCallback;
	int appReturnValue;
	bool stillInitialising;

	JUCE_DECLARE_NON_COPYABLE (JUCEApplication);
};

#endif   // __JUCE_APPLICATION_JUCEHEADER__

/*** End of inlined file: juce_Application.h ***/


#endif
#ifndef __JUCE_INITIALISATION_JUCEHEADER__

/*** Start of inlined file: juce_Initialisation.h ***/
#ifndef __JUCE_INITIALISATION_JUCEHEADER__
#define __JUCE_INITIALISATION_JUCEHEADER__

/** Initialises Juce's GUI classes.

	If you're embedding Juce into an application that uses its own event-loop rather
	than using the START_JUCE_APPLICATION macro, call this function before making any
	Juce calls, to make sure things are initialised correctly.

	Note that if you're creating a Juce DLL for Windows, you may also need to call the
	Process::setCurrentModuleInstanceHandle() method.

	@see shutdownJuce_GUI()
*/
JUCE_API void JUCE_CALLTYPE  initialiseJuce_GUI();

/** Clears up any static data being used by Juce's GUI classes.

	If you're embedding Juce into an application that uses its own event-loop rather
	than using the START_JUCE_APPLICATION macro, call this function in your shutdown
	code to clean up any juce objects that might be lying around.

	@see initialiseJuce_GUI()
*/
JUCE_API void JUCE_CALLTYPE  shutdownJuce_GUI();

/** A utility object that helps you initialise and shutdown Juce correctly
	using an RAII pattern.

	When an instance of this class is created, it calls initialiseJuce_GUI(),
	and when it's deleted, it calls shutdownJuce_GUI(), which lets you easily
	make sure that these functions are matched correctly.

	This class is particularly handy to use at the beginning of a console app's
	main() function, because it'll take care of shutting down whenever you return
	from the main() call.

	@see ScopedJuceInitialiser_NonGUI
*/
class ScopedJuceInitialiser_GUI
{
public:
	/** The constructor simply calls initialiseJuce_GUI(). */
	ScopedJuceInitialiser_GUI()         { initialiseJuce_GUI(); }

	/** The destructor simply calls shutdownJuce_GUI(). */
	~ScopedJuceInitialiser_GUI()        { shutdownJuce_GUI(); }
};

/*
	To start a JUCE app, use this macro: START_JUCE_APPLICATION (AppSubClass) where
	AppSubClass is the name of a class derived from JUCEApplication.

	See the JUCEApplication class documentation (juce_Application.h) for more details.

*/
#if JUCE_ANDROID
  #define START_JUCE_APPLICATION(AppClass) \
	juce::JUCEApplication* juce_CreateApplication() { return new AppClass(); }

#elif defined (JUCE_GCC) || defined (__MWERKS__)

  #define START_JUCE_APPLICATION(AppClass) \
	static juce::JUCEApplicationBase* juce_CreateApplication() { return new AppClass(); } \
	int main (int argc, char* argv[]) \
	{ \
		juce::JUCEApplication::createInstance = &juce_CreateApplication; \
		return juce::JUCEApplication::main (argc, (const char**) argv); \
	}

#elif JUCE_WINDOWS

  #ifdef _CONSOLE
	#define START_JUCE_APPLICATION(AppClass) \
		static juce::JUCEApplicationBase* juce_CreateApplication() { return new AppClass(); } \
		int main (int, char* argv[]) \
		{ \
			juce::JUCEApplication::createInstance = &juce_CreateApplication; \
			return juce::JUCEApplication::main (juce::Process::getCurrentCommandLineParams()); \
		}
  #elif ! defined (_AFXDLL)
	#ifdef _WINDOWS_
	  #define START_JUCE_APPLICATION(AppClass) \
		  static juce::JUCEApplicationBase* juce_CreateApplication() { return new AppClass(); } \
		  int WINAPI WinMain (HINSTANCE, HINSTANCE, LPSTR, int) \
		  { \
			  juce::JUCEApplication::createInstance = &juce_CreateApplication; \
			  return juce::JUCEApplication::main (juce::Process::getCurrentCommandLineParams()); \
		  }
	#else
	  #define START_JUCE_APPLICATION(AppClass) \
		  static juce::JUCEApplicationBase* juce_CreateApplication() { return new AppClass(); } \
		  int __stdcall WinMain (void*, void*, const char*, int) \
		  { \
			  juce::JUCEApplication::createInstance = &juce_CreateApplication; \
			  return juce::JUCEApplication::main (juce::Process::getCurrentCommandLineParams()); \
		  }
	#endif
  #endif

#endif

#endif   // __JUCE_INITIALISATION_JUCEHEADER__

/*** End of inlined file: juce_Initialisation.h ***/


#endif
#ifndef __JUCE_BUBBLECOMPONENT_JUCEHEADER__

/*** Start of inlined file: juce_BubbleComponent.h ***/
#ifndef __JUCE_BUBBLECOMPONENT_JUCEHEADER__
#define __JUCE_BUBBLECOMPONENT_JUCEHEADER__

/**
	A component for showing a message or other graphics inside a speech-bubble-shaped
	outline, pointing at a location on the screen.

	This is a base class that just draws and positions the bubble shape, but leaves
	the drawing of any content up to a subclass. See BubbleMessageComponent for a subclass
	that draws a text message.

	To use it, create your subclass, then either add it to a parent component or
	put it on the desktop with addToDesktop (0), use setPosition() to
	resize and position it, then make it visible.

	@see BubbleMessageComponent
*/
class JUCE_API  BubbleComponent  : public Component
{
protected:

	/** Creates a BubbleComponent.

		Your subclass will need to implement the getContentSize() and paintContent()
		methods to draw the bubble's contents.
	*/
	BubbleComponent();

public:
	/** Destructor. */
	~BubbleComponent();

	/** A list of permitted placements for the bubble, relative to the co-ordinates
		at which it should be pointing.

		@see setAllowedPlacement
	*/
	enum BubblePlacement
	{
		above   = 1,
		below   = 2,
		left    = 4,
		right   = 8
	};

	/** Tells the bubble which positions it's allowed to put itself in, relative to the
		point at which it's pointing.

		By default when setPosition() is called, the bubble will place itself either
		above, below, left, or right of the target area. You can pass in a bitwise-'or' of
		the values in BubblePlacement to restrict this choice.

		E.g. if you only want your bubble to appear above or below the target area,
		use setAllowedPlacement (above | below);

		@see BubblePlacement
	*/
	void setAllowedPlacement (int newPlacement);

	/** Moves and resizes the bubble to point at a given component.

		This will resize the bubble to fit its content, then find a position for it
		so that it's next to, but doesn't overlap the given component.

		It'll put itself either above, below, or to the side of the component depending
		on where there's the most space, honouring any restrictions that were set
		with setAllowedPlacement().
	*/
	void setPosition (Component* componentToPointTo);

	/** Moves and resizes the bubble to point at a given point.

		This will resize the bubble to fit its content, then position it
		so that the tip of the bubble points to the given co-ordinate. The co-ordinates
		are relative to either the bubble component's parent component if it has one, or
		they are screen co-ordinates if not.

		It'll put itself either above, below, or to the side of this point, depending
		on where there's the most space, honouring any restrictions that were set
		with setAllowedPlacement().
	*/
	void setPosition (int arrowTipX,
					  int arrowTipY);

	/** Moves and resizes the bubble to point at a given rectangle.

		This will resize the bubble to fit its content, then find a position for it
		so that it's next to, but doesn't overlap the given rectangle. The rectangle's
		co-ordinates are relative to either the bubble component's parent component
		if it has one, or they are screen co-ordinates if not.

		It'll put itself either above, below, or to the side of the component depending
		on where there's the most space, honouring any restrictions that were set
		with setAllowedPlacement().
	*/
	void setPosition (const Rectangle<int>& rectangleToPointTo);

protected:

	/** Subclasses should override this to return the size of the content they
		want to draw inside the bubble.
	*/
	virtual void getContentSize (int& width, int& height) = 0;

	/** Subclasses should override this to draw their bubble's contents.

		The graphics object's clip region and the dimensions passed in here are
		set up to paint just the rectangle inside the bubble.
	*/
	virtual void paintContent (Graphics& g, int width, int height) = 0;

public:
	/** @internal */
	void paint (Graphics& g);

private:
	Rectangle<int> content;
	int side, allowablePlacements;
	float arrowTipX, arrowTipY;
	DropShadowEffect shadow;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (BubbleComponent);
};

#endif   // __JUCE_BUBBLECOMPONENT_JUCEHEADER__

/*** End of inlined file: juce_BubbleComponent.h ***/


#endif
#ifndef __JUCE_DROPSHADOWER_JUCEHEADER__

#endif
// END_AUTOINCLUDE

}

#endif   // __JUCE_GUI_BASICS_JUCEHEADER__

/*** End of inlined file: juce_gui_basics.h ***/

#if JUCE_MODULE_AVAILABLE_juce_opengl

/*** Start of inlined file: juce_opengl.h ***/
#ifndef __JUCE_OPENGL_JUCEHEADER__
#define __JUCE_OPENGL_JUCEHEADER__


/*** Start of inlined file: juce_gui_extra.h ***/
#ifndef __JUCE_GUI_EXTRA_JUCEHEADER__
#define __JUCE_GUI_EXTRA_JUCEHEADER__

/** Config: JUCE_WEB_BROWSER
	This lets you disable the WebBrowserComponent class (Mac and Windows).
	If you're not using any embedded web-pages, turning this off may reduce your code size.
*/
#ifndef JUCE_WEB_BROWSER
 #define JUCE_WEB_BROWSER 1
#endif

namespace juce
{

// START_AUTOINCLUDE documents, code_editor, embedding, lookandfeel, misc
#ifndef __JUCE_FILEBASEDDOCUMENT_JUCEHEADER__

/*** Start of inlined file: juce_FileBasedDocument.h ***/
#ifndef __JUCE_FILEBASEDDOCUMENT_JUCEHEADER__
#define __JUCE_FILEBASEDDOCUMENT_JUCEHEADER__

/**
	A class to take care of the logic involved with the loading/saving of some kind
	of document.

	There's quite a lot of tedious logic involved in writing all the load/save/save-as
	functions you need for documents that get saved to a file, so this class attempts
	to abstract most of the boring stuff.

	Your subclass should just implement all the pure virtual methods, and you can
	then use the higher-level public methods to do the load/save dialogs, to warn the user
	about overwriting files, etc.

	The document object keeps track of whether it has changed since it was last saved or
	loaded, so when you change something, call its changed() method. This will set a
	flag so it knows it needs saving, and will also broadcast a change message using the
	ChangeBroadcaster base class.

	@see ChangeBroadcaster
*/
class JUCE_API FileBasedDocument  : public ChangeBroadcaster
{
public:
	/** Creates a FileBasedDocument.

		@param fileExtension            the extension to use when loading/saving files, e.g. ".doc"
		@param fileWildCard             the wildcard to use in file dialogs, e.g. "*.doc"
		@param openFileDialogTitle      the title to show on an open-file dialog, e.g. "Choose a file to open.."
		@param saveFileDialogTitle      the title to show on an save-file dialog, e.g. "Choose a file to save as.."
	*/
	FileBasedDocument (const String& fileExtension,
					   const String& fileWildCard,
					   const String& openFileDialogTitle,
					   const String& saveFileDialogTitle);

	/** Destructor. */
	virtual ~FileBasedDocument();

	/** Returns true if the changed() method has been called since the file was
		last saved or loaded.

		@see resetChangedFlag, changed
	*/
	bool hasChangedSinceSaved() const                           { return changedSinceSave; }

	/** Called to indicate that the document has changed and needs saving.

		This method will also trigger a change message to be sent out using the
		ChangeBroadcaster base class.

		After calling the method, the hasChangedSinceSaved() method will return true, until
		it is reset either by saving to a file or using the resetChangedFlag() method.

		@see hasChangedSinceSaved, resetChangedFlag
	*/
	virtual void changed();

	/** Sets the state of the 'changed' flag.

		The 'changed' flag is set to true when the changed() method is called - use this method
		to reset it or to set it without also broadcasting a change message.

		@see changed, hasChangedSinceSaved
	*/
	void setChangedFlag (bool hasChanged);

	/** Tries to open a file.

		If the file opens correctly, the document's file (see the getFile() method) is set
		to this new one; if it fails, the document's file is left unchanged, and optionally
		a message box is shown telling the user there was an error.

		@returns true if the new file loaded successfully
		@see loadDocument, loadFromUserSpecifiedFile
	*/
	bool loadFrom (const File& fileToLoadFrom,
				   bool showMessageOnFailure);

	/** Asks the user for a file and tries to load it.

		This will pop up a dialog box using the title, file extension and
		wildcard specified in the document's constructor, and asks the user
		for a file. If they pick one, the loadFrom() method is used to
		try to load it, optionally showing a message if it fails.

		@returns    true if a file was loaded; false if the user cancelled or if they
					picked a file which failed to load correctly
		@see loadFrom
	*/
	bool loadFromUserSpecifiedFile (bool showMessageOnFailure);

	/** A set of possible outcomes of one of the save() methods
	*/
	enum SaveResult
	{
		savedOk = 0,            /**< indicates that a file was saved successfully. */
		userCancelledSave,      /**< indicates that the user aborted the save operation. */
		failedToWriteToFile     /**< indicates that it tried to write to a file but this failed. */
	};

	/** Tries to save the document to the last file it was saved or loaded from.

		This will always try to write to the file, even if the document isn't flagged as
		having changed.

		@param askUserForFileIfNotSpecified     if there's no file currently specified and this is
												true, it will prompt the user to pick a file, as if
												saveAsInteractive() was called.
		@param showMessageOnFailure             if true it will show a warning message when if the
												save operation fails
		@see saveIfNeededAndUserAgrees, saveAs, saveAsInteractive
	*/
	SaveResult save (bool askUserForFileIfNotSpecified,
					 bool showMessageOnFailure);

	/** If the file needs saving, it'll ask the user if that's what they want to do, and save
		it if they say yes.

		If you've got a document open and want to close it (e.g. to quit the app), this is the
		method to call.

		If the document doesn't need saving it'll return the value savedOk so
		you can go ahead and delete the document.

		If it does need saving it'll prompt the user, and if they say "discard changes" it'll
		return savedOk, so again, you can safely delete the document.

		If the user clicks "cancel", it'll return userCancelledSave, so if you can abort the
		close-document operation.

		And if they click "save changes", it'll try to save and either return savedOk, or
		failedToWriteToFile if there was a problem.

		@see save, saveAs, saveAsInteractive
	*/
	SaveResult saveIfNeededAndUserAgrees();

	/** Tries to save the document to a specified file.

		If this succeeds, it'll also change the document's internal file (as returned by
		the getFile() method). If it fails, the file will be left unchanged.

		@param newFile                      the file to try to write to
		@param warnAboutOverwritingExistingFiles    if true and the file exists, it'll ask
											the user first if they want to overwrite it
		@param askUserForFileIfNotSpecified if the file is non-existent and this is true, it'll
											use the saveAsInteractive() method to ask the user for a
											filename
		@param showMessageOnFailure         if true and the write operation fails, it'll show
											a message box to warn the user
		@see saveIfNeededAndUserAgrees, save, saveAsInteractive
	*/
	SaveResult saveAs (const File& newFile,
					   bool warnAboutOverwritingExistingFiles,
					   bool askUserForFileIfNotSpecified,
					   bool showMessageOnFailure);

	/** Prompts the user for a filename and tries to save to it.

		This will pop up a dialog box using the title, file extension and
		wildcard specified in the document's constructor, and asks the user
		for a file. If they pick one, the saveAs() method is used to try to save
		to this file.

		@param warnAboutOverwritingExistingFiles    if true and the file exists, it'll ask
											the user first if they want to overwrite it
		@see saveIfNeededAndUserAgrees, save, saveAs
	*/
	SaveResult saveAsInteractive (bool warnAboutOverwritingExistingFiles);

	/** Returns the file that this document was last successfully saved or loaded from.

		When the document object is created, this will be set to File::nonexistent.

		It is changed when one of the load or save methods is used, or when setFile()
		is used to explicitly set it.
	*/
	const File& getFile() const                             { return documentFile; }

	/** Sets the file that this document thinks it was loaded from.

		This won't actually load anything - it just changes the file stored internally.

		@see getFile
	*/
	void setFile (const File& newFile);

protected:

	/** Overload this to return the title of the document.

		This is used in message boxes, filenames and file choosers, so it should be
		something sensible.
	*/
	virtual const String getDocumentTitle() = 0;

	/** This method should try to load your document from the given file.

		If it fails, it should return an error message. If it succeeds, it should return
		an empty string.
	*/
	virtual const String loadDocument (const File& file) = 0;

	/** This method should try to write your document to the given file.

		If it fails, it should return an error message. If it succeeds, it should return
		an empty string.
	*/
	virtual const String saveDocument (const File& file) = 0;

	/** This is used for dialog boxes to make them open at the last folder you
		were using.

		getLastDocumentOpened() and setLastDocumentOpened() are used to store
		the last document that was used - you might want to store this value
		in a static variable, or even in your application's properties. It should
		be a global setting rather than a property of this object.

		This method works very well in conjunction with a RecentlyOpenedFilesList
		object to manage your recent-files list.

		As a default value, it's ok to return File::nonexistent, and the document
		object will use a sensible one instead.

		@see RecentlyOpenedFilesList
	*/
	virtual const File getLastDocumentOpened() = 0;

	/** This is used for dialog boxes to make them open at the last folder you
		were using.

		getLastDocumentOpened() and setLastDocumentOpened() are used to store
		the last document that was used - you might want to store this value
		in a static variable, or even in your application's properties. It should
		be a global setting rather than a property of this object.

		This method works very well in conjunction with a RecentlyOpenedFilesList
		object to manage your recent-files list.

		@see RecentlyOpenedFilesList
	*/
	virtual void setLastDocumentOpened (const File& file) = 0;

   #if JUCE_MODAL_LOOPS_PERMITTED
	/** This is called by saveAsInteractive() to allow you to optionally customise the
		filename that the user is presented with in the save dialog.
		The defaultFile parameter is an initial suggestion based on what the class knows
		about the current document - you can return a variation on this file with a different
		extension, etc, or just return something completely different.
	*/
	virtual File getSuggestedSaveAsFile (const File& defaultFile);
   #endif

private:

	File documentFile;
	bool changedSinceSave;
	String fileExtension, fileWildcard, openFileDialogTitle, saveFileDialogTitle;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (FileBasedDocument);
};

#endif   // __JUCE_FILEBASEDDOCUMENT_JUCEHEADER__

/*** End of inlined file: juce_FileBasedDocument.h ***/


#endif
#ifndef __JUCE_CODEDOCUMENT_JUCEHEADER__

/*** Start of inlined file: juce_CodeDocument.h ***/
#ifndef __JUCE_CODEDOCUMENT_JUCEHEADER__
#define __JUCE_CODEDOCUMENT_JUCEHEADER__

class CodeDocumentLine;

/**
	A class for storing and manipulating a source code file.

	When using a CodeEditorComponent, it takes one of these as its source object.

	The CodeDocument stores its content as an array of lines, which makes it
	quick to insert and delete.

	@see CodeEditorComponent
*/
class JUCE_API  CodeDocument
{
public:
	/** Creates a new, empty document.
	*/
	CodeDocument();

	/** Destructor. */
	~CodeDocument();

	/** A position in a code document.

		Using this class you can find a position in a code document and quickly get its
		character position, line, and index. By calling setPositionMaintained (true), the
		position is automatically updated when text is inserted or deleted in the document,
		so that it maintains its original place in the text.
	*/
	class JUCE_API  Position
	{
	public:
		/** Creates an uninitialised postion.
			Don't attempt to call any methods on this until you've given it an owner document
			to refer to!
		*/
		Position() noexcept;

		/** Creates a position based on a line and index in a document.

			Note that this index is NOT the column number, it's the number of characters from the
			start of the line. The "column" number isn't quite the same, because if the line
			contains any tab characters, the relationship of the index to its visual column depends on
			the number of spaces per tab being used!

			Lines are numbered from zero, and if the line or index are beyond the bounds of the document,
			they will be adjusted to keep them within its limits.
		*/
		Position (const CodeDocument* ownerDocument,
				  int line, int indexInLine) noexcept;

		/** Creates a position based on a character index in a document.
			This position is placed at the specified number of characters from the start of the
			document. The line and column are auto-calculated.

			If the position is beyond the range of the document, it'll be adjusted to keep it
			inside.
		*/
		Position (const CodeDocument* ownerDocument,
				  int charactersFromStartOfDocument) noexcept;

		/** Creates a copy of another position.

			This will copy the position, but the new object will not be set to maintain its position,
			even if the source object was set to do so.
		*/
		Position (const Position& other) noexcept;

		/** Destructor. */
		~Position();

		Position& operator= (const Position& other);
		bool operator== (const Position& other) const noexcept;
		bool operator!= (const Position& other) const noexcept;

		/** Points this object at a new position within the document.

			If the position is beyond the range of the document, it'll be adjusted to keep it
			inside.
			@see getPosition, setLineAndIndex
		*/
		void setPosition (int charactersFromStartOfDocument);

		/** Returns the position as the number of characters from the start of the document.
			@see setPosition, getLineNumber, getIndexInLine
		*/
		int getPosition() const noexcept            { return characterPos; }

		/** Moves the position to a new line and index within the line.

			Note that the index is NOT the column at which the position appears in an editor.
			If the line contains any tab characters, the relationship of the index to its
			visual position depends on the number of spaces per tab being used!

			Lines are numbered from zero, and if the line or index are beyond the bounds of the document,
			they will be adjusted to keep them within its limits.
		*/
		void setLineAndIndex (int newLine, int newIndexInLine);

		/** Returns the line number of this position.
			The first line in the document is numbered zero, not one!
		*/
		int getLineNumber() const noexcept          { return line; }

		/** Returns the number of characters from the start of the line.

			Note that this value is NOT the column at which the position appears in an editor.
			If the line contains any tab characters, the relationship of the index to its
			visual position depends on the number of spaces per tab being used!
		*/
		int getIndexInLine() const noexcept         { return indexInLine; }

		/** Allows the position to be automatically updated when the document changes.

			If this is set to true, the positon will register with its document so that
			when the document has text inserted or deleted, this position will be automatically
			moved to keep it at the same position in the text.
		*/
		void setPositionMaintained (bool isMaintained);

		/** Moves the position forwards or backwards by the specified number of characters.
			@see movedBy
		*/
		void moveBy (int characterDelta);

		/** Returns a position which is the same as this one, moved by the specified number of
			characters.
			@see moveBy
		*/
		const Position movedBy (int characterDelta) const;

		/** Returns a position which is the same as this one, moved up or down by the specified
			number of lines.
			@see movedBy
		*/
		const Position movedByLines (int deltaLines) const;

		/** Returns the character in the document at this position.
			@see getLineText
		*/
		const juce_wchar getCharacter() const;

		/** Returns the line from the document that this position is within.
			@see getCharacter, getLineNumber
		*/
		String getLineText() const;

	private:
		CodeDocument* owner;
		int characterPos, line, indexInLine;
		bool positionMaintained;
	};

	/** Returns the full text of the document. */
	String getAllContent() const;

	/** Returns a section of the document's text. */
	String getTextBetween (const Position& start, const Position& end) const;

	/** Returns a line from the document. */
	String getLine (int lineIndex) const noexcept;

	/** Returns the number of characters in the document. */
	int getNumCharacters() const noexcept;

	/** Returns the number of lines in the document. */
	int getNumLines() const noexcept                    { return lines.size(); }

	/** Returns the number of characters in the longest line of the document. */
	int getMaximumLineLength() noexcept;

	/** Deletes a section of the text.

		This operation is undoable.
	*/
	void deleteSection (const Position& startPosition, const Position& endPosition);

	/** Inserts some text into the document at a given position.

		This operation is undoable.
	*/
	void insertText (const Position& position, const String& text);

	/** Clears the document and replaces it with some new text.

		This operation is undoable - if you're trying to completely reset the document, you
		might want to also call clearUndoHistory() and setSavePoint() after using this method.
	*/
	void replaceAllContent (const String& newContent);

	/** Replaces the editor's contents with the contents of a stream.
		This will also reset the undo history and save point marker.
	*/
	bool loadFromStream (InputStream& stream);

	/** Writes the editor's current contents to a stream. */
	bool writeToStream (OutputStream& stream);

	/** Returns the preferred new-line characters for the document.
		This will be either "\n", "\r\n", or (rarely) "\r".
		@see setNewLineCharacters
	*/
	String getNewLineCharacters() const noexcept          { return newLineChars; }

	/** Sets the new-line characters that the document should use.
		The string must be either "\n", "\r\n", or (rarely) "\r".
		@see getNewLineCharacters
	*/
	void setNewLineCharacters (const String& newLine) noexcept;

	/** Begins a new undo transaction.

		The document itself will not call this internally, so relies on whatever is using the
		document to periodically call this to break up the undo sequence into sensible chunks.
		@see UndoManager::beginNewTransaction
	*/
	void newTransaction();

	/** Undo the last operation.
		@see UndoManager::undo
	*/
	void undo();

	/** Redo the last operation.
		@see UndoManager::redo
	*/
	void redo();

	/** Clears the undo history.
		@see UndoManager::clearUndoHistory
	*/
	void clearUndoHistory();

	/** Returns the document's UndoManager */
	UndoManager& getUndoManager() noexcept              { return undoManager; }

	/** Makes a note that the document's current state matches the one that is saved.

		After this has been called, hasChangedSinceSavePoint() will return false until
		the document has been altered, and then it'll start returning true. If the document is
		altered, but then undone until it gets back to this state, hasChangedSinceSavePoint()
		will again return false.

		@see hasChangedSinceSavePoint
	*/
	void setSavePoint() noexcept;

	/** Returns true if the state of the document differs from the state it was in when
		setSavePoint() was last called.

		@see setSavePoint
	*/
	bool hasChangedSinceSavePoint() const noexcept;

	/** Searches for a word-break. */
	const Position findWordBreakAfter (const Position& position) const noexcept;

	/** Searches for a word-break. */
	const Position findWordBreakBefore (const Position& position) const noexcept;

	/** An object that receives callbacks from the CodeDocument when its text changes.
		@see CodeDocument::addListener, CodeDocument::removeListener
	*/
	class JUCE_API  Listener
	{
	public:
		Listener() {}
		virtual ~Listener() {}

		/** Called by a CodeDocument when it is altered.
		*/
		virtual void codeDocumentChanged (const Position& affectedTextStart,
										  const Position& affectedTextEnd) = 0;
	};

	/** Registers a listener object to receive callbacks when the document changes.
		If the listener is already registered, this method has no effect.
		@see removeListener
	*/
	void addListener (Listener* listener) noexcept;

	/** Deregisters a listener.
		@see addListener
	*/
	void removeListener (Listener* listener) noexcept;

	/** Iterates the text in a CodeDocument.

		This class lets you read characters from a CodeDocument. It's designed to be used
		by a SyntaxAnalyser object.

		@see CodeDocument, SyntaxAnalyser
	*/
	class JUCE_API  Iterator
	{
	public:
		Iterator (CodeDocument* document);
		Iterator (const Iterator& other);
		Iterator& operator= (const Iterator& other) noexcept;
		~Iterator() noexcept;

		/** Reads the next character and returns it.
			@see peekNextChar
		*/
		juce_wchar nextChar();

		/** Reads the next character without advancing the current position. */
		juce_wchar peekNextChar() const;

		/** Advances the position by one character. */
		void skip();

		/** Returns the position of the next character as its position within the
			whole document.
		*/
		int getPosition() const noexcept        { return position; }

		/** Skips over any whitespace characters until the next character is non-whitespace. */
		void skipWhitespace();

		/** Skips forward until the next character will be the first character on the next line */
		void skipToEndOfLine();

		/** Returns the line number of the next character. */
		int getLine() const noexcept            { return line; }

		/** Returns true if the iterator has reached the end of the document. */
		bool isEOF() const noexcept;

	private:
		CodeDocument* document;
		mutable String::CharPointerType charPointer;
		int line, position;
	};

private:

	friend class CodeDocumentInsertAction;
	friend class CodeDocumentDeleteAction;
	friend class Iterator;
	friend class Position;

	OwnedArray <CodeDocumentLine> lines;
	Array <Position*> positionsToMaintain;
	UndoManager undoManager;
	int currentActionIndex, indexOfSavedState;
	int maximumLineLength;
	ListenerList <Listener> listeners;
	String newLineChars;

	void sendListenerChangeMessage (int startLine, int endLine);

	void insert (const String& text, int insertPos, bool undoable);
	void remove (int startPos, int endPos, bool undoable);
	void checkLastLineStatus();

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (CodeDocument);
};

#endif   // __JUCE_CODEDOCUMENT_JUCEHEADER__

/*** End of inlined file: juce_CodeDocument.h ***/


#endif
#ifndef __JUCE_CODEEDITORCOMPONENT_JUCEHEADER__

/*** Start of inlined file: juce_CodeEditorComponent.h ***/
#ifndef __JUCE_CODEEDITORCOMPONENT_JUCEHEADER__
#define __JUCE_CODEEDITORCOMPONENT_JUCEHEADER__


/*** Start of inlined file: juce_CodeTokeniser.h ***/
#ifndef __JUCE_CODETOKENISER_JUCEHEADER__
#define __JUCE_CODETOKENISER_JUCEHEADER__

/**
	A base class for tokenising code so that the syntax can be displayed in a
	code editor.

	@see CodeDocument, CodeEditorComponent
*/
class JUCE_API  CodeTokeniser
{
public:
	CodeTokeniser()                 {}
	virtual ~CodeTokeniser()        {}

	/** Reads the next token from the source and returns its token type.

		This must leave the source pointing to the first character in the
		next token.
	*/
	virtual int readNextToken (CodeDocument::Iterator& source) = 0;

	/** Returns a list of the names of the token types this analyser uses.

		The index in this list must match the token type numbers that are
		returned by readNextToken().
	*/
	virtual StringArray getTokenTypes() = 0;

	/** Returns a suggested syntax highlighting colour for a specified
		token type.
	*/
	virtual Colour getDefaultColour (int tokenType) = 0;

private:

	JUCE_LEAK_DETECTOR (CodeTokeniser);
};

#endif   // __JUCE_CODETOKENISER_JUCEHEADER__

/*** End of inlined file: juce_CodeTokeniser.h ***/

/**
	A text editor component designed specifically for source code.

	This is designed to handle syntax highlighting and fast editing of very large
	files.
*/
class JUCE_API  CodeEditorComponent   : public Component,
										public TextInputTarget,
										public Timer,
										public ScrollBar::Listener,
										public CodeDocument::Listener,
										public AsyncUpdater
{
public:

	/** Creates an editor for a document.

		The tokeniser object is optional - pass 0 to disable syntax highlighting.
		The object that you pass in is not owned or deleted by the editor - you must
		make sure that it doesn't get deleted while this component is still using it.

		@see CodeDocument
	*/
	CodeEditorComponent (CodeDocument& document,
						 CodeTokeniser* codeTokeniser);

	/** Destructor. */
	~CodeEditorComponent();

	/** Returns the code document that this component is editing. */
	CodeDocument& getDocument() const noexcept          { return document; }

	/** Loads the given content into the document.
		This will completely reset the CodeDocument object, clear its undo history,
		and fill it with this text.
	*/
	void loadContent (const String& newContent);

	/** Returns the standard character width. */
	float getCharWidth() const noexcept                         { return charWidth; }

	/** Returns the height of a line of text, in pixels. */
	int getLineHeight() const noexcept                          { return lineHeight; }

	/** Returns the number of whole lines visible on the screen,
		This doesn't include a cut-off line that might be visible at the bottom if the
		component's height isn't an exact multiple of the line-height.
	*/
	int getNumLinesOnScreen() const noexcept                    { return linesOnScreen; }

	/** Returns the number of whole columns visible on the screen.
		This doesn't include any cut-off columns at the right-hand edge.
	*/
	int getNumColumnsOnScreen() const noexcept                  { return columnsOnScreen; }

	/** Returns the current caret position. */
	CodeDocument::Position getCaretPos() const                  { return caretPos; }

	/** Returns the position of the caret, relative to the editor's origin. */
	Rectangle<int> getCaretRectangle();

	/** Moves the caret.
		If selecting is true, the section of the document between the current
		caret position and the new one will become selected. If false, any currently
		selected region will be deselected.
	*/
	void moveCaretTo (const CodeDocument::Position& newPos, bool selecting);

	/** Returns the on-screen position of a character in the document.
		The rectangle returned is relative to this component's top-left origin.
	*/
	Rectangle<int> getCharacterBounds (const CodeDocument::Position& pos) const;

	/** Finds the character at a given on-screen position.
		The co-ordinates are relative to this component's top-left origin.
	*/
	CodeDocument::Position getPositionAt (int x, int y);

	bool moveCaretLeft (bool moveInWholeWordSteps, bool selecting);
	bool moveCaretRight (bool moveInWholeWordSteps, bool selecting);
	bool moveCaretUp (bool selecting);
	bool moveCaretDown (bool selecting);
	bool scrollDown();
	bool scrollUp();
	bool pageUp (bool selecting);
	bool pageDown (bool selecting);
	bool moveCaretToTop (bool selecting);
	bool moveCaretToStartOfLine (bool selecting);
	bool moveCaretToEnd (bool selecting);
	bool moveCaretToEndOfLine (bool selecting);
	bool deleteBackwards (bool moveInWholeWordSteps);
	bool deleteForwards (bool moveInWholeWordSteps);
	bool copyToClipboard();
	bool cutToClipboard();
	bool pasteFromClipboard();
	bool undo();
	bool redo();

	bool selectAll();
	void deselectAll();

	void scrollToLine (int newFirstLineOnScreen);
	void scrollBy (int deltaLines);
	void scrollToColumn (int newFirstColumnOnScreen);
	void scrollToKeepCaretOnScreen();

	void insertTextAtCaret (const String& textToInsert);
	void insertTabAtCaret();

	Range<int> getHighlightedRegion() const;
	void setHighlightedRegion (const Range<int>& newRange);
	String getTextInRange (const Range<int>& range) const;

	/** Changes the current tab settings.
		This lets you change the tab size and whether pressing the tab key inserts a
		tab character, or its equivalent number of spaces.
	*/
	void setTabSize (int numSpacesPerTab, bool insertSpacesInsteadOfTabCharacters);

	/** Returns the current number of spaces per tab.
		@see setTabSize
	*/
	int getTabSize() const noexcept                     { return spacesPerTab; }

	/** Returns true if the tab key will insert spaces instead of actual tab characters.
		@see setTabSize
	*/
	bool areSpacesInsertedForTabs() const               { return useSpacesForTabs; }

	/** Changes the font.
		Make sure you only use a fixed-width font, or this component will look pretty nasty!
	*/
	void setFont (const Font& newFont);

	/** Returns the font that the editor is using. */
	const Font& getFont() const noexcept                { return font; }

	/** Resets the syntax highlighting colours to the default ones provided by the
		code tokeniser.
		@see CodeTokeniser::getDefaultColour
	*/
	void resetToDefaultColours();

	/** Changes one of the syntax highlighting colours.
		The token type values are dependent on the tokeniser being used - use
		CodeTokeniser::getTokenTypes() to get a list of the token types.
		@see getColourForTokenType
	*/
	void setColourForTokenType (int tokenType, const Colour& colour);

	/** Returns one of the syntax highlighting colours.
		The token type values are dependent on the tokeniser being used - use
		CodeTokeniser::getTokenTypes() to get a list of the token types.
		@see setColourForTokenType
	*/
	Colour getColourForTokenType (int tokenType) const;

	/** A set of colour IDs to use to change the colour of various aspects of the editor.

		These constants can be used either via the Component::setColour(), or LookAndFeel::setColour()
		methods.

		@see Component::setColour, Component::findColour, LookAndFeel::setColour, LookAndFeel::findColour
	*/
	enum ColourIds
	{
		backgroundColourId          = 0x1004500,  /**< A colour to use to fill the editor's background. */
		highlightColourId           = 0x1004502,  /**< The colour to use for the highlighted background under
													   selected text. */
		defaultTextColourId         = 0x1004503   /**< The colour to use for text when no syntax colouring is
													   enabled. */
	};

	/** Changes the size of the scrollbars. */
	void setScrollbarThickness (int thickness);

	/** Returns the thickness of the scrollbars. */
	int getScrollbarThickness() const noexcept          { return scrollbarThickness; }

	/** @internal */
	void resized();
	/** @internal */
	void paint (Graphics& g);
	/** @internal */
	bool keyPressed (const KeyPress& key);
	/** @internal */
	void mouseDown (const MouseEvent& e);
	/** @internal */
	void mouseDrag (const MouseEvent& e);
	/** @internal */
	void mouseUp (const MouseEvent& e);
	/** @internal */
	void mouseDoubleClick (const MouseEvent& e);
	/** @internal */
	void mouseWheelMove (const MouseEvent& e, float wheelIncrementX, float wheelIncrementY);
	/** @internal */
	void focusGained (FocusChangeType cause);
	/** @internal */
	void focusLost (FocusChangeType cause);
	/** @internal */
	void timerCallback();
	/** @internal */
	void scrollBarMoved (ScrollBar* scrollBarThatHasMoved, double newRangeStart);
	/** @internal */
	void handleAsyncUpdate();
	/** @internal */
	void codeDocumentChanged (const CodeDocument::Position& affectedTextStart,
							  const CodeDocument::Position& affectedTextEnd);
	/** @internal */
	bool isTextInputActive() const;
	/** @internal */
	void setTemporaryUnderlining (const Array <Range<int> >&);

private:

	CodeDocument& document;

	Font font;
	int firstLineOnScreen, gutter, spacesPerTab;
	float charWidth;
	int lineHeight, linesOnScreen, columnsOnScreen;
	int scrollbarThickness, columnToTryToMaintain;
	bool useSpacesForTabs;
	double xOffset;

	CodeDocument::Position caretPos;
	CodeDocument::Position selectionStart, selectionEnd;

	ScopedPointer<CaretComponent> caret;
	ScrollBar verticalScrollBar, horizontalScrollBar;

	enum DragType
	{
		notDragging,
		draggingSelectionStart,
		draggingSelectionEnd
	};

	DragType dragType;

	CodeTokeniser* codeTokeniser;
	Array <Colour> coloursForTokenCategories;

	class CodeEditorLine;
	OwnedArray <CodeEditorLine> lines;
	void rebuildLineTokens();

	OwnedArray <CodeDocument::Iterator> cachedIterators;
	void clearCachedIterators (int firstLineToBeInvalid);
	void updateCachedIterators (int maxLineNum);
	void getIteratorForPosition (int position, CodeDocument::Iterator& result);
	void moveLineDelta (int delta, bool selecting);

	void updateCaretPosition();
	void updateScrollBars();
	void scrollToLineInternal (int line);
	void scrollToColumnInternal (double column);
	void newTransaction();
	void cut();

	int indexToColumn (int line, int index) const noexcept;
	int columnToIndex (int line, int column) const noexcept;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (CodeEditorComponent);
};

#endif   // __JUCE_CODEEDITORCOMPONENT_JUCEHEADER__

/*** End of inlined file: juce_CodeEditorComponent.h ***/


#endif
#ifndef __JUCE_CODETOKENISER_JUCEHEADER__

#endif
#ifndef __JUCE_CPLUSPLUSCODETOKENISER_JUCEHEADER__

/*** Start of inlined file: juce_CPlusPlusCodeTokeniser.h ***/
#ifndef __JUCE_CPLUSPLUSCODETOKENISER_JUCEHEADER__
#define __JUCE_CPLUSPLUSCODETOKENISER_JUCEHEADER__

/**
	A simple lexical analyser for syntax colouring of C++ code.

	@see SyntaxAnalyser, CodeEditorComponent, CodeDocument
*/
class JUCE_API  CPlusPlusCodeTokeniser    : public CodeTokeniser
{
public:

	CPlusPlusCodeTokeniser();
	~CPlusPlusCodeTokeniser();

	enum TokenType
	{
		tokenType_error = 0,
		tokenType_comment,
		tokenType_builtInKeyword,
		tokenType_identifier,
		tokenType_integerLiteral,
		tokenType_floatLiteral,
		tokenType_stringLiteral,
		tokenType_operator,
		tokenType_bracket,
		tokenType_punctuation,
		tokenType_preprocessor
	};

	int readNextToken (CodeDocument::Iterator& source);
	StringArray getTokenTypes();
	Colour getDefaultColour (int tokenType);

	/** This is a handy method for checking whether a string is a c++ reserved keyword. */
	static bool isReservedKeyword (const String& token) noexcept;

private:

	JUCE_LEAK_DETECTOR (CPlusPlusCodeTokeniser);
};

#endif   // __JUCE_CPLUSPLUSCODETOKENISER_JUCEHEADER__

/*** End of inlined file: juce_CPlusPlusCodeTokeniser.h ***/


#endif
#ifndef __JUCE_ACTIVEXCONTROLCOMPONENT_JUCEHEADER__

/*** Start of inlined file: juce_ActiveXControlComponent.h ***/
#ifndef __JUCE_ACTIVEXCONTROLCOMPONENT_JUCEHEADER__
#define __JUCE_ACTIVEXCONTROLCOMPONENT_JUCEHEADER__

#if JUCE_WINDOWS || DOXYGEN

/**
	A Windows-specific class that can create and embed an ActiveX control inside
	itself.

	To use it, create one of these, put it in place and make sure it's visible in a
	window, then use createControl() to instantiate an ActiveX control. The control
	will then be moved and resized to follow the movements of this component.

	Of course, since the control is a heavyweight window, it'll obliterate any
	juce components that may overlap this component, but that's life.
*/
class JUCE_API  ActiveXControlComponent   : public Component
{
public:

	/** Create an initially-empty container. */
	ActiveXControlComponent();

	/** Destructor. */
	~ActiveXControlComponent();

	/** Tries to create an ActiveX control and embed it in this peer.

		The peer controlIID is a pointer to an IID structure - it's treated
		as a void* because when including the Juce headers, you might not always
		have included windows.h first, in which case IID wouldn't be defined.

		e.g. @code
		const IID myIID = __uuidof (QTControl);
		myControlComp->createControl (&myIID);
		@endcode
	*/
	bool createControl (const void* controlIID);

	/** Deletes the ActiveX control, if one has been created.
	*/
	void deleteControl();

	/** Returns true if a control is currently in use. */
	bool isControlOpen() const noexcept                 { return control != nullptr; }

	/** Does a QueryInterface call on the embedded control object.

		This allows you to cast the control to whatever type of COM object you need.

		The iid parameter is a pointer to an IID structure - it's treated
		as a void* because when including the Juce headers, you might not always
		have included windows.h first, in which case IID wouldn't be defined, but
		you should just pass a pointer to an IID.

		e.g. @code
		const IID iid = __uuidof (IOleWindow);

		IOleWindow* oleWindow = (IOleWindow*) myControlComp->queryInterface (&iid);

		if (oleWindow != nullptr)
		{
			HWND hwnd;
			oleWindow->GetWindow (&hwnd);

			...

			oleWindow->Release();
		}
		@endcode
	*/
	void* queryInterface (const void* iid) const;

	/** Set this to false to stop mouse events being allowed through to the control.
	*/
	void setMouseEventsAllowed (bool eventsCanReachControl);

	/** Returns true if mouse events are allowed to get through to the control.
	*/
	bool areMouseEventsAllowed() const noexcept                 { return mouseEventsAllowed; }

	/** @internal */
	void paint (Graphics& g);

private:
	class Pimpl;
	friend class ScopedPointer <Pimpl>;
	ScopedPointer <Pimpl> control;
	bool mouseEventsAllowed;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ActiveXControlComponent);
};

#endif

#endif   // __JUCE_ACTIVEXCONTROLCOMPONENT_JUCEHEADER__

/*** End of inlined file: juce_ActiveXControlComponent.h ***/


#endif
#ifndef __JUCE_NSVIEWCOMPONENT_JUCEHEADER__

/*** Start of inlined file: juce_NSViewComponent.h ***/
#ifndef __JUCE_NSVIEWCOMPONENT_JUCEHEADER__
#define __JUCE_NSVIEWCOMPONENT_JUCEHEADER__

#if JUCE_MAC || DOXYGEN

/**
	A Mac-specific class that can create and embed an NSView inside itself.

	To use it, create one of these, put it in place and make sure it's visible in a
	window, then use setView() to assign an NSView to it. The view will then be
	moved and resized to follow the movements of this component.

	Of course, since the view is a native object, it'll obliterate any
	juce components that may overlap this component, but that's life.
*/
class JUCE_API  NSViewComponent   : public Component
{
public:

	/** Create an initially-empty container. */
	NSViewComponent();

	/** Destructor. */
	~NSViewComponent();

	/** Assigns an NSView to this peer.

		The view will be retained and released by this component for as long as
		it is needed. To remove the current view, just call setView (nullptr).

		Note: a void* is used here to avoid including the cocoa headers as
		part of the juce.h, but the method expects an NSView*.
	*/
	void setView (void* nsView);

	/** Returns the current NSView.

		Note: a void* is returned here to avoid the needing to include the cocoa
		headers, so you should just cast the return value to an NSView*.
	*/
	void* getView() const;

	/** Resizes this component to fit the view that it contains. */
	void resizeToFitView();

	/** @internal */
	void paint (Graphics& g);

private:
	class Pimpl;
	friend class Pimpl;
	ScopedPointer<Pimpl> pimpl;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (NSViewComponent);
};

#endif
#endif   // __JUCE_NSVIEWCOMPONENT_JUCEHEADER__

/*** End of inlined file: juce_NSViewComponent.h ***/


#endif
#ifndef __JUCE_UIVIEWCOMPONENT_JUCEHEADER__

/*** Start of inlined file: juce_UIViewComponent.h ***/
#ifndef __JUCE_UIVIEWCOMPONENT_JUCEHEADER__
#define __JUCE_UIVIEWCOMPONENT_JUCEHEADER__

#if JUCE_IOS || DOXYGEN

/**
	An iOS-specific class that can create and embed an UIView inside itself.

	To use it, create one of these, put it in place and make sure it's visible in a
	window, then use setView() to assign an NSView to it. The view will then be
	moved and resized to follow the movements of this component.

	Of course, since the view is a native object, it'll obliterate any
	juce components that may overlap this component, but that's life.
*/
class JUCE_API  UIViewComponent   : public Component
{
public:

	/** Create an initially-empty container. */
	UIViewComponent();

	/** Destructor. */
	~UIViewComponent();

	/** Assigns an UIView to this peer.

		The view will be retained and released by this component for as long as
		it is needed. To remove the current view, just call setView (nullptr).

		Note: a void* is used here to avoid including the cocoa headers as
		part of the juce.h, but the method expects an UIView*.
	*/
	void setView (void* uiView);

	/** Returns the current UIView.

		Note: a void* is returned here to avoid the needing to include the cocoa
		headers, so you should just cast the return value to an UIView*.
	*/
	void* getView() const;

	/** Resizes this component to fit the view that it contains. */
	void resizeToFitView();

	/** @internal */
	void paint (Graphics& g);

private:
	class Pimpl;
	friend class Pimpl;
	ScopedPointer<Pimpl> pimpl;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (UIViewComponent);
};

#endif
#endif   // __JUCE_UIVIEWCOMPONENT_JUCEHEADER__

/*** End of inlined file: juce_UIViewComponent.h ***/


#endif
#ifndef __JUCE_OLDSCHOOLLOOKANDFEEL_JUCEHEADER__

/*** Start of inlined file: juce_OldSchoolLookAndFeel.h ***/
#ifndef __JUCE_OLDSCHOOLLOOKANDFEEL_JUCEHEADER__
#define __JUCE_OLDSCHOOLLOOKANDFEEL_JUCEHEADER__

/**
	The original Juce look-and-feel.

*/
class JUCE_API  OldSchoolLookAndFeel    : public LookAndFeel
{
public:

	/** Creates the default JUCE look and feel. */
	OldSchoolLookAndFeel();

	/** Destructor. */
	virtual ~OldSchoolLookAndFeel();

	/** Draws the lozenge-shaped background for a standard button. */
	virtual void drawButtonBackground (Graphics& g,
									   Button& button,
									   const Colour& backgroundColour,
									   bool isMouseOverButton,
									   bool isButtonDown);

	/** Draws the contents of a standard ToggleButton. */
	virtual void drawToggleButton (Graphics& g,
								   ToggleButton& button,
								   bool isMouseOverButton,
								   bool isButtonDown);

	virtual void drawTickBox (Graphics& g,
							  Component& component,
							  float x, float y, float w, float h,
							  bool ticked,
							  bool isEnabled,
							  bool isMouseOverButton,
							  bool isButtonDown);

	virtual void drawProgressBar (Graphics& g, ProgressBar& progressBar,
								  int width, int height,
								  double progress, const String& textToShow);

	virtual void drawScrollbarButton (Graphics& g,
									  ScrollBar& scrollbar,
									  int width, int height,
									  int buttonDirection,
									  bool isScrollbarVertical,
									  bool isMouseOverButton,
									  bool isButtonDown);

	virtual void drawScrollbar (Graphics& g,
								ScrollBar& scrollbar,
								int x, int y,
								int width, int height,
								bool isScrollbarVertical,
								int thumbStartPosition,
								int thumbSize,
								bool isMouseOver,
								bool isMouseDown);

	virtual ImageEffectFilter* getScrollbarEffect();

	virtual void drawTextEditorOutline (Graphics& g,
										int width, int height,
										TextEditor& textEditor);

	/** Fills the background of a popup menu component. */
	virtual void drawPopupMenuBackground (Graphics& g, int width, int height);

	virtual void drawMenuBarBackground (Graphics& g, int width, int height,
										bool isMouseOverBar,
										MenuBarComponent& menuBar);

	virtual void drawComboBox (Graphics& g, int width, int height,
							   bool isButtonDown,
							   int buttonX, int buttonY,
							   int buttonW, int buttonH,
							   ComboBox& box);

	virtual const Font getComboBoxFont (ComboBox& box);

	virtual void drawLinearSlider (Graphics& g,
								   int x, int y,
								   int width, int height,
								   float sliderPos,
								   float minSliderPos,
								   float maxSliderPos,
								   const Slider::SliderStyle style,
								   Slider& slider);

	virtual int getSliderThumbRadius (Slider& slider);

	virtual Button* createSliderButton (bool isIncrement);

	virtual ImageEffectFilter* getSliderEffect();

	virtual void drawCornerResizer (Graphics& g,
									int w, int h,
									bool isMouseOver,
									bool isMouseDragging);

	virtual Button* createDocumentWindowButton (int buttonType);

	virtual void positionDocumentWindowButtons (DocumentWindow& window,
												int titleBarX, int titleBarY,
												int titleBarW, int titleBarH,
												Button* minimiseButton,
												Button* maximiseButton,
												Button* closeButton,
												bool positionTitleBarButtonsOnLeft);

private:

	DropShadowEffect scrollbarShadow;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (OldSchoolLookAndFeel);
};

#endif   // __JUCE_OLDSCHOOLLOOKANDFEEL_JUCEHEADER__

/*** End of inlined file: juce_OldSchoolLookAndFeel.h ***/


#endif
#ifndef __JUCE_APPLEREMOTE_JUCEHEADER__

/*** Start of inlined file: juce_AppleRemote.h ***/
#ifndef __JUCE_APPLEREMOTE_JUCEHEADER__
#define __JUCE_APPLEREMOTE_JUCEHEADER__

#if JUCE_MAC || DOXYGEN
/**
	Receives events from an Apple IR remote control device (Only available in OSX!).

	To use it, just create a subclass of this class, implementing the buttonPressed()
	callback, then call start() and stop() to start or stop receiving events.
*/
class JUCE_API  AppleRemoteDevice
{
public:

	AppleRemoteDevice();
	virtual ~AppleRemoteDevice();

	/** The set of buttons that may be pressed.
		@see buttonPressed
	*/
	enum ButtonType
	{
		menuButton = 0,     /**< The menu button (if it's held for a short time). */
		playButton,         /**< The play button. */
		plusButton,         /**< The plus or volume-up button. */
		minusButton,        /**< The minus or volume-down button. */
		rightButton,        /**< The right button (if it's held for a short time). */
		leftButton,         /**< The left button (if it's held for a short time). */
		rightButton_Long,   /**< The right button (if it's held for a long time). */
		leftButton_Long,    /**< The menu button (if it's held for a long time). */
		menuButton_Long,    /**< The menu button (if it's held for a long time). */
		playButtonSleepMode,
		switched
	};

	/** Override this method to receive the callback about a button press.

		The callback will happen on the application's message thread.

		Some buttons trigger matching up and down events, in which the isDown parameter
		will be true and then false. Others only send a single event when the
		button is pressed.
	*/
	virtual void buttonPressed (ButtonType buttonId, bool isDown) = 0;

	/** Starts the device running and responding to events.

		Returns true if it managed to open the device.

		@param inExclusiveMode  if true, the remote will be grabbed exclusively for this app,
								and will not be available to any other part of the system. If
								false, it will be shared with other apps.
		@see stop
	*/
	bool start (bool inExclusiveMode);

	/** Stops the device running.
		@see start
	*/
	void stop();

	/** Returns true if the device has been started successfully.
	*/
	bool isActive() const;

	/** Returns the ID number of the remote, if it has sent one.
	*/
	int getRemoteId() const                     { return remoteId; }

	/** @internal */
	void handleCallbackInternal();

private:
	void* device;
	void* queue;
	int remoteId;

	bool open (bool openInExclusiveMode);

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (AppleRemoteDevice);
};

#endif
#endif   // __JUCE_APPLEREMOTE_JUCEHEADER__

/*** End of inlined file: juce_AppleRemote.h ***/


#endif
#ifndef __JUCE_BUBBLEMESSAGECOMPONENT_JUCEHEADER__

/*** Start of inlined file: juce_BubbleMessageComponent.h ***/
#ifndef __JUCE_BUBBLEMESSAGECOMPONENT_JUCEHEADER__
#define __JUCE_BUBBLEMESSAGECOMPONENT_JUCEHEADER__

/**
	A speech-bubble component that displays a short message.

	This can be used to show a message with the tail of the speech bubble
	pointing to a particular component or location on the screen.

	@see BubbleComponent
*/
class JUCE_API  BubbleMessageComponent  : public BubbleComponent,
										  private Timer
{
public:

	/** Creates a bubble component.

		After creating one a BubbleComponent, do the following:
		- add it to an appropriate parent component, or put it on the
		  desktop with Component::addToDesktop (0).
		- use the showAt() method to show a message.
		- it will make itself invisible after it times-out (and can optionally
		  also delete itself), or you can reuse it somewhere else by calling
		  showAt() again.
	*/
	BubbleMessageComponent (int fadeOutLengthMs = 150);

	/** Destructor. */
	~BubbleMessageComponent();

	/** Shows a message bubble at a particular position.

		This shows the bubble with its stem pointing to the given location
		(co-ordinates being relative to its parent component).

		For details about exactly how it decides where to position itself, see
		BubbleComponent::updatePosition().

		@param x                                the x co-ordinate of end of the bubble's tail
		@param y                                the y co-ordinate of end of the bubble's tail
		@param message                          the text to display
		@param numMillisecondsBeforeRemoving    how long to leave it on the screen before removing itself
												from its parent compnent. If this is 0 or less, it
												will stay there until manually removed.
		@param removeWhenMouseClicked           if this is true, the bubble will disappear as soon as a
												mouse button is pressed (anywhere on the screen)
		@param deleteSelfAfterUse               if true, then the component will delete itself after
												it becomes invisible
	*/
	void showAt (int x, int y,
				 const String& message,
				 int numMillisecondsBeforeRemoving,
				 bool removeWhenMouseClicked = true,
				 bool deleteSelfAfterUse = false);

	/** Shows a message bubble next to a particular component.

		This shows the bubble with its stem pointing at the given component.

		For details about exactly how it decides where to position itself, see
		BubbleComponent::updatePosition().

		@param component                        the component that you want to point at
		@param message                          the text to display
		@param numMillisecondsBeforeRemoving    how long to leave it on the screen before removing itself
												from its parent compnent. If this is 0 or less, it
												will stay there until manually removed.
		@param removeWhenMouseClicked           if this is true, the bubble will disappear as soon as a
												mouse button is pressed (anywhere on the screen)
		@param deleteSelfAfterUse               if true, then the component will delete itself after
												it becomes invisible
	*/
	void showAt (Component* component,
				 const String& message,
				 int numMillisecondsBeforeRemoving,
				 bool removeWhenMouseClicked = true,
				 bool deleteSelfAfterUse = false);

	/** @internal */
	void getContentSize (int& w, int& h);
	/** @internal */
	void paintContent (Graphics& g, int w, int h);
	/** @internal */
	void timerCallback();

private:

	int fadeOutLength, mouseClickCounter;
	TextLayout textLayout;
	int64 expiryTime;
	bool deleteAfterUse;

	void createLayout (const String&);
	void init (int numMillisecondsBeforeRemoving,
			   bool removeWhenMouseClicked,
			   bool deleteSelfAfterUse);

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (BubbleMessageComponent);
};

#endif   // __JUCE_BUBBLEMESSAGECOMPONENT_JUCEHEADER__

/*** End of inlined file: juce_BubbleMessageComponent.h ***/


#endif
#ifndef __JUCE_COLOURSELECTOR_JUCEHEADER__

/*** Start of inlined file: juce_ColourSelector.h ***/
#ifndef __JUCE_COLOURSELECTOR_JUCEHEADER__
#define __JUCE_COLOURSELECTOR_JUCEHEADER__

/**
	A component that lets the user choose a colour.

	This shows RGB sliders and a colourspace that the user can pick colours from.

	This class is also a ChangeBroadcaster, so listeners can register to be told
	when the colour changes.
*/
class JUCE_API  ColourSelector  : public Component,
								  public ChangeBroadcaster,
								  protected SliderListener
{
public:

	/** Options for the type of selector to show. These are passed into the constructor. */
	enum ColourSelectorOptions
	{
		showAlphaChannel    = 1 << 0,   /**< if set, the colour's alpha channel can be changed as well as its RGB. */

		showColourAtTop     = 1 << 1,   /**< if set, a swatch of the colour is shown at the top of the component. */
		showSliders         = 1 << 2,   /**< if set, RGB sliders are shown at the bottom of the component. */
		showColourspace     = 1 << 3    /**< if set, a big HSV selector is shown. */
	};

	/** Creates a ColourSelector object.

		The flags are a combination of values from the ColourSelectorOptions enum, specifying
		which of the selector's features should be visible.

		The edgeGap value specifies the amount of space to leave around the edge.

		gapAroundColourSpaceComponent indicates how much of a gap to put around the
		colourspace and hue selector components.
	*/
	ColourSelector (int sectionsToShow = (showAlphaChannel | showColourAtTop | showSliders | showColourspace),
					int edgeGap = 4,
					int gapAroundColourSpaceComponent = 7);

	/** Destructor. */
	~ColourSelector();

	/** Returns the colour that the user has currently selected.

		The ColourSelector class is also a ChangeBroadcaster, so listeners can
		register to be told when the colour changes.

		@see setCurrentColour
	*/
	Colour getCurrentColour() const;

	/** Changes the colour that is currently being shown.
	*/
	void setCurrentColour (const Colour& newColour);

	/** Tells the selector how many preset colour swatches you want to have on the component.

		To enable swatches, you'll need to override getNumSwatches(), getSwatchColour(), and
		setSwatchColour(), to return the number of colours you want, and to set and retrieve
		their values.
	*/
	virtual int getNumSwatches() const;

	/** Called by the selector to find out the colour of one of the swatches.

		Your subclass should return the colour of the swatch with the given index.

		To enable swatches, you'll need to override getNumSwatches(), getSwatchColour(), and
		setSwatchColour(), to return the number of colours you want, and to set and retrieve
		their values.
	*/
	virtual Colour getSwatchColour (int index) const;

	/** Called by the selector when the user puts a new colour into one of the swatches.

		Your subclass should change the colour of the swatch with the given index.

		To enable swatches, you'll need to override getNumSwatches(), getSwatchColour(), and
		setSwatchColour(), to return the number of colours you want, and to set and retrieve
		their values.
	*/
	virtual void setSwatchColour (int index, const Colour& newColour) const;

	/** A set of colour IDs to use to change the colour of various aspects of the keyboard.

		These constants can be used either via the Component::setColour(), or LookAndFeel::setColour()
		methods.

		@see Component::setColour, Component::findColour, LookAndFeel::setColour, LookAndFeel::findColour
	*/
	enum ColourIds
	{
		backgroundColourId              = 0x1007000,    /**< the colour used to fill the component's background. */
		labelTextColourId               = 0x1007001     /**< the colour used for the labels next to the sliders. */
	};

private:

	class ColourSpaceView;
	class HueSelectorComp;
	class SwatchComponent;
	friend class ColourSpaceView;
	friend class ScopedPointer<ColourSpaceView>;
	friend class HueSelectorComp;
	friend class ScopedPointer<HueSelectorComp>;

	Colour colour;
	float h, s, v;
	ScopedPointer<Slider> sliders[4];
	ScopedPointer<ColourSpaceView> colourSpace;
	ScopedPointer<HueSelectorComp> hueSelector;
	OwnedArray <SwatchComponent> swatchComponents;
	const int flags;
	int edgeGap;
	Rectangle<int> previewArea;

	void setHue (float newH);
	void setSV (float newS, float newV);
	void updateHSV();
	void update();
	void sliderValueChanged (Slider*);
	void paint (Graphics& g);
	void resized();

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ColourSelector);

   #if JUCE_CATCH_DEPRECATED_CODE_MISUSE
	// This constructor is here temporarily to prevent old code compiling, because the parameters
	// have changed - if you get an error here, update your code to use the new constructor instead..
	ColourSelector (bool);
   #endif
};

#endif   // __JUCE_COLOURSELECTOR_JUCEHEADER__

/*** End of inlined file: juce_ColourSelector.h ***/


#endif
#ifndef __JUCE_KEYMAPPINGEDITORCOMPONENT_JUCEHEADER__

/*** Start of inlined file: juce_KeyMappingEditorComponent.h ***/
#ifndef __JUCE_KEYMAPPINGEDITORCOMPONENT_JUCEHEADER__
#define __JUCE_KEYMAPPINGEDITORCOMPONENT_JUCEHEADER__

/**
	A component to allow editing of the keymaps stored by a KeyPressMappingSet
	object.

	@see KeyPressMappingSet
*/
class JUCE_API  KeyMappingEditorComponent  : public Component
{
public:

	/** Creates a KeyMappingEditorComponent.

		@param mappingSet   this is the set of mappings to display and edit. Make sure the
							mappings object is not deleted before this component!
		@param showResetToDefaultButton     if true, then at the bottom of the list, the
											component will include a 'reset to defaults' button.
	*/
	KeyMappingEditorComponent (KeyPressMappingSet& mappingSet,
							   bool showResetToDefaultButton);

	/** Destructor. */
	virtual ~KeyMappingEditorComponent();

	/** Sets up the colours to use for parts of the component.

		@param mainBackground       colour to use for most of the background
		@param textColour           colour to use for the text
	*/
	void setColours (const Colour& mainBackground,
					 const Colour& textColour);

	/** Returns the KeyPressMappingSet that this component is acting upon. */
	KeyPressMappingSet& getMappings() const noexcept                { return mappings; }

	/** Can be overridden if some commands need to be excluded from the list.

		By default this will use the KeyPressMappingSet's shouldCommandBeVisibleInEditor()
		method to decide what to return, but you can override it to handle special cases.
	*/
	virtual bool shouldCommandBeIncluded (CommandID commandID);

	/** Can be overridden to indicate that some commands are shown as read-only.

		By default this will use the KeyPressMappingSet's shouldCommandBeReadOnlyInEditor()
		method to decide what to return, but you can override it to handle special cases.
	*/
	virtual bool isCommandReadOnly (CommandID commandID);

	/** This can be overridden to let you change the format of the string used
		to describe a keypress.

		This is handy if you're using non-standard KeyPress objects, e.g. for custom
		keys that are triggered by something else externally. If you override the
		method, be sure to let the base class's method handle keys you're not
		interested in.
	*/
	virtual String getDescriptionForKeyPress (const KeyPress& key);

	/** A set of colour IDs to use to change the colour of various aspects of the editor.

		These constants can be used either via the Component::setColour(), or LookAndFeel::setColour()
		methods.

		To change the colours of the menu that pops up

		@see Component::setColour, Component::findColour, LookAndFeel::setColour, LookAndFeel::findColour
	*/
	enum ColourIds
	{
		backgroundColourId  = 0x100ad00,    /**< The background colour to fill the editor background. */
		textColourId        = 0x100ad01,    /**< The colour for the text. */
	};

	/** @internal */
	void parentHierarchyChanged();
	/** @internal */
	void resized();

private:

	KeyPressMappingSet& mappings;
	TreeView tree;
	TextButton resetButton;

	class TopLevelItem;
	class ChangeKeyButton;
	class MappingItem;
	class CategoryItem;
	class ItemComponent;
	friend class TopLevelItem;
	friend class OwnedArray <ChangeKeyButton>;
	friend class ScopedPointer<TopLevelItem>;
	ScopedPointer<TopLevelItem> treeItem;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (KeyMappingEditorComponent);
};

#endif   // __JUCE_KEYMAPPINGEDITORCOMPONENT_JUCEHEADER__

/*** End of inlined file: juce_KeyMappingEditorComponent.h ***/


#endif
#ifndef __JUCE_PREFERENCESPANEL_JUCEHEADER__

/*** Start of inlined file: juce_PreferencesPanel.h ***/
#ifndef __JUCE_PREFERENCESPANEL_JUCEHEADER__
#define __JUCE_PREFERENCESPANEL_JUCEHEADER__

/**
	A component with a set of buttons at the top for changing between pages of
	preferences.

	This is just a handy way of writing a Mac-style preferences panel where you
	have a row of buttons along the top for the different preference categories,
	each button having an icon above its name. Clicking these will show an
	appropriate prefs page below it.

	You can either put one of these inside your own component, or just use the
	showInDialogBox() method to show it in a window and run it modally.

	To use it, just add a set of named pages with the addSettingsPage() method,
	and implement the createComponentForPage() method to create suitable components
	for each of these pages.
*/
class JUCE_API  PreferencesPanel  : public Component,
									private ButtonListener // (can't use Button::Listener due to idiotic VC2005 bug)
{
public:

	/** Creates an empty panel.

		Use addSettingsPage() to add some pages to it in your constructor.
	*/
	PreferencesPanel();

	/** Destructor. */
	~PreferencesPanel();

	/** Creates a page using a set of drawables to define the page's icon.

		Note that the other version of this method is much easier if you're using
		an image instead of a custom drawable.

		@param pageTitle    the name of this preferences page - you'll need to
							make sure your createComponentForPage() method creates
							a suitable component when it is passed this name
		@param normalIcon   the drawable to display in the page's button normally
		@param overIcon     the drawable to display in the page's button when the mouse is over
		@param downIcon     the drawable to display in the page's button when the button is down
		@see DrawableButton
	*/
	void addSettingsPage (const String& pageTitle,
						  const Drawable* normalIcon,
						  const Drawable* overIcon,
						  const Drawable* downIcon);

	/** Creates a page using a set of drawables to define the page's icon.

		The other version of this method gives you more control over the icon, but this
		one is much easier if you're just loading it from a file.

		@param pageTitle        the name of this preferences page - you'll need to
								make sure your createComponentForPage() method creates
								a suitable component when it is passed this name
		@param imageData        a block of data containing an image file, e.g. a jpeg, png or gif.
								For this to look good, you'll probably want to use a nice
								transparent png file.
		@param imageDataSize    the size of the image data, in bytes
	*/
	void addSettingsPage (const String& pageTitle,
						  const void* imageData,
						  int imageDataSize);

	/** Utility method to display this panel in a DialogWindow.

		Calling this will create a DialogWindow containing this panel with the
		given size and title, and will run it modally, returning when the user
		closes the dialog box.
	*/
	void showInDialogBox (const String& dialogTitle,
						  int dialogWidth,
						  int dialogHeight,
						  const Colour& backgroundColour = Colours::white);

	/** Subclasses must override this to return a component for each preferences page.

		The subclass should return a pointer to a new component representing the named
		page, which the panel will then display.

		The panel will delete the component later when the user goes to another page
		or deletes the panel.
	*/
	virtual Component* createComponentForPage (const String& pageName) = 0;

	/** Changes the current page being displayed. */
	void setCurrentPage (const String& pageName);

	/** Returns the size of the buttons shown along the top. */
	int getButtonSize() const noexcept;

	/** Changes the size of the buttons shown along the top. */
	void setButtonSize (int newSize);

	/** @internal */
	void resized();
	/** @internal */
	void paint (Graphics& g);
	/** @internal */
	void buttonClicked (Button* button);

private:

	String currentPageName;
	ScopedPointer <Component> currentPage;
	OwnedArray<DrawableButton> buttons;
	int buttonSize;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (PreferencesPanel);
};

#endif   // __JUCE_PREFERENCESPANEL_JUCEHEADER__

/*** End of inlined file: juce_PreferencesPanel.h ***/


#endif
#ifndef __JUCE_RECENTLYOPENEDFILESLIST_JUCEHEADER__

/*** Start of inlined file: juce_RecentlyOpenedFilesList.h ***/
#ifndef __JUCE_RECENTLYOPENEDFILESLIST_JUCEHEADER__
#define __JUCE_RECENTLYOPENEDFILESLIST_JUCEHEADER__

/**
	Manages a set of files for use as a list of recently-opened documents.

	This is a handy class for holding your list of recently-opened documents, with
	helpful methods for things like purging any non-existent files, automatically
	adding them to a menu, and making persistence easy.

	@see File, FileBasedDocument
*/
class JUCE_API  RecentlyOpenedFilesList
{
public:

	/** Creates an empty list.
	*/
	RecentlyOpenedFilesList();

	/** Destructor. */
	~RecentlyOpenedFilesList();

	/** Sets a limit for the number of files that will be stored in the list.

		When addFile() is called, then if there is no more space in the list, the
		least-recently added file will be dropped.

		@see getMaxNumberOfItems
	*/
	void setMaxNumberOfItems (int newMaxNumber);

	/** Returns the number of items that this list will store.
		@see setMaxNumberOfItems
	*/
	int getMaxNumberOfItems() const noexcept                            { return maxNumberOfItems; }

	/** Returns the number of files in the list.

		The most recently added file is always at index 0.
	*/
	int getNumFiles() const;

	/** Returns one of the files in the list.

		The most recently added file is always at index 0.
	*/
	File getFile (int index) const;

	/** Returns an array of all the absolute pathnames in the list.
	*/
	const StringArray& getAllFilenames() const noexcept                 { return files; }

	/** Clears all the files from the list. */
	void clear();

	/** Adds a file to the list.

		The file will be added at index 0. If this file is already in the list, it will
		be moved up to index 0, but a file can only appear once in the list.

		If the list already contains the maximum number of items that is permitted, the
		least-recently added file will be dropped from the end.
	*/
	void addFile (const File& file);

	/** Removes a file from the list. */
	void removeFile (const File& file);

	/** Checks each of the files in the list, removing any that don't exist.

		You might want to call this after reloading a list of files, or before putting them
		on a menu.
	*/
	void removeNonExistentFiles();

	/** Adds entries to a menu, representing each of the files in the list.

		This is handy for creating an "open recent file..." menu in your app. The
		menu items are numbered consecutively starting with the baseItemId value,
		and can either be added as complete pathnames, or just the last part of the
		filename.

		If dontAddNonExistentFiles is true, then each file will be checked and only those
		that exist will be added.

		If filesToAvoid is non-zero, then it is considered to be a zero-terminated array of
		pointers to file objects. Any files that appear in this list will not be added to the
		menu - the reason for this is that you might have a number of files already open, so
		might not want these to be shown in the menu.

		It returns the number of items that were added.
	*/
	int createPopupMenuItems (PopupMenu& menuToAddItemsTo,
							  int baseItemId,
							  bool showFullPaths,
							  bool dontAddNonExistentFiles,
							  const File** filesToAvoid = nullptr);

	/** Returns a string that encapsulates all the files in the list.

		The string that is returned can later be passed into restoreFromString() in
		order to recreate the list. This is handy for persisting your list, e.g. in
		a PropertiesFile object.

		@see restoreFromString
	*/
	String toString() const;

	/** Restores the list from a previously stringified version of the list.

		Pass in a stringified version created with toString() in order to persist/restore
		your list.

		@see toString
	*/
	void restoreFromString (const String& stringifiedVersion);

private:

	StringArray files;
	int maxNumberOfItems;

	JUCE_LEAK_DETECTOR (RecentlyOpenedFilesList);
};

#endif   // __JUCE_RECENTLYOPENEDFILESLIST_JUCEHEADER__

/*** End of inlined file: juce_RecentlyOpenedFilesList.h ***/


#endif
#ifndef __JUCE_SPLASHSCREEN_JUCEHEADER__

/*** Start of inlined file: juce_SplashScreen.h ***/
#ifndef __JUCE_SPLASHSCREEN_JUCEHEADER__
#define __JUCE_SPLASHSCREEN_JUCEHEADER__

/** A component for showing a splash screen while your app starts up.

	This will automatically position itself, and delete itself when the app has
	finished initialising (it uses the JUCEApplication::isInitialising() to detect
	this).

	To use it, just create one of these in your JUCEApplication::initialise() method,
	call its show() method and let the object delete itself later.

	E.g. @code

	void MyApp::initialise (const String& commandLine)
	{
		SplashScreen* splash = new SplashScreen();

		splash->show ("welcome to my app",
					  ImageCache::getFromFile (File ("/foobar/splash.jpg")),
					  4000, false);

		.. no need to delete the splash screen - it'll do that itself.
	}

	@endcode
*/
class JUCE_API  SplashScreen  : public Component,
								public Timer,
								private DeletedAtShutdown
{
public:

	/** Creates a SplashScreen object.

		After creating one of these (or your subclass of it), call one of the show()
		methods to display it.
	*/
	SplashScreen();

	/** Destructor. */
	~SplashScreen();

	/** Creates a SplashScreen object that will display an image.

		As soon as this is called, the SplashScreen will be displayed in the centre of the
		screen. This method will also dispatch any pending messages to make sure that when
		it returns, the splash screen has been completely drawn, and your initialisation
		code can carry on.

		@param title            the name to give the component
		@param backgroundImage  an image to draw on the component. The component's size
								will be set to the size of this image, and if the image is
								semi-transparent, the component will be made semi-transparent
								too. This image will be deleted (or released from the ImageCache
								if that's how it was created) by the splash screen object when
								it is itself deleted.
		@param minimumTimeToDisplayFor    how long (in milliseconds) the splash screen
								should stay visible for. If the initialisation takes longer than
								this time, the splash screen will wait for it to finish before
								disappearing, but if initialisation is very quick, this lets
								you make sure that people get a good look at your splash.
		@param useDropShadow    if true, the window will have a drop shadow
		@param removeOnMouseClick   if true, the window will go away as soon as the user clicks
								the mouse (anywhere)
	*/
	void show (const String& title,
			   const Image& backgroundImage,
			   int minimumTimeToDisplayFor,
			   bool useDropShadow,
			   bool removeOnMouseClick = true);

	/** Creates a SplashScreen object with a specified size.

		For a custom splash screen, you can use this method to display it at a certain size
		and then override the paint() method yourself to do whatever's necessary.

		As soon as this is called, the SplashScreen will be displayed in the centre of the
		screen. This method will also dispatch any pending messages to make sure that when
		it returns, the splash screen has been completely drawn, and your initialisation
		code can carry on.

		@param title            the name to give the component
		@param width            the width to use
		@param height           the height to use
		@param minimumTimeToDisplayFor    how long (in milliseconds) the splash screen
								should stay visible for. If the initialisation takes longer than
								this time, the splash screen will wait for it to finish before
								disappearing, but if initialisation is very quick, this lets
								you make sure that people get a good look at your splash.
		@param useDropShadow    if true, the window will have a drop shadow
		@param removeOnMouseClick   if true, the window will go away as soon as the user clicks
								the mouse (anywhere)
	*/
	void show (const String& title,
			   int width,
			   int height,
			   int minimumTimeToDisplayFor,
			   bool useDropShadow,
			   bool removeOnMouseClick = true);

	/** @internal */
	void paint (Graphics& g);
	/** @internal */
	void timerCallback();

private:

	Image backgroundImage;
	Time earliestTimeToDelete;
	int originalClickCounter;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (SplashScreen);
};

#endif   // __JUCE_SPLASHSCREEN_JUCEHEADER__

/*** End of inlined file: juce_SplashScreen.h ***/


#endif
#ifndef __JUCE_SYSTEMTRAYICONCOMPONENT_JUCEHEADER__

/*** Start of inlined file: juce_SystemTrayIconComponent.h ***/
#ifndef __JUCE_SYSTEMTRAYICONCOMPONENT_JUCEHEADER__
#define __JUCE_SYSTEMTRAYICONCOMPONENT_JUCEHEADER__

#if JUCE_WINDOWS || JUCE_LINUX || DOXYGEN

/**
	On Windows and Linux only, this component sits in the taskbar tray as a small icon.

	To use it, just create one of these components, but don't attempt to make it
	visible, add it to a parent, or put it on the desktop.

	You can then call setIconImage() to create an icon for it in the taskbar.

	To change the icon's tooltip, you can use setIconTooltip().

	To respond to mouse-events, you can override the normal mouseDown(),
	mouseUp(), mouseDoubleClick() and mouseMove() methods, and although the x, y
	position will not be valid, you can use this to respond to clicks. Traditionally
	you'd use a left-click to show your application's window, and a right-click
	to show a pop-up menu.
*/
class JUCE_API  SystemTrayIconComponent  : public Component
{
public:

	SystemTrayIconComponent();

	/** Destructor. */
	~SystemTrayIconComponent();

	/** Changes the image shown in the taskbar.
	*/
	void setIconImage (const Image& newImage);

	/** Changes the tooltip that Windows shows above the icon. */
	void setIconTooltip (const String& tooltip);

   #if JUCE_LINUX
	/** @internal */
	void paint (Graphics& g);
   #endif

private:

	class Pimpl;
	ScopedPointer<Pimpl> pimpl;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (SystemTrayIconComponent);
};

#endif
#endif   // __JUCE_SYSTEMTRAYICONCOMPONENT_JUCEHEADER__

/*** End of inlined file: juce_SystemTrayIconComponent.h ***/


#endif
#ifndef __JUCE_WEBBROWSERCOMPONENT_JUCEHEADER__

/*** Start of inlined file: juce_WebBrowserComponent.h ***/
#ifndef __JUCE_WEBBROWSERCOMPONENT_JUCEHEADER__
#define __JUCE_WEBBROWSERCOMPONENT_JUCEHEADER__

#if JUCE_WEB_BROWSER || DOXYGEN

#if ! DOXYGEN
 class WebBrowserComponentInternal;
#endif

/**
	A component that displays an embedded web browser.

	The browser itself will be platform-dependent. On the Mac, probably Safari, on
	Windows, probably IE.

*/
class JUCE_API  WebBrowserComponent      : public Component
{
public:

	/** Creates a WebBrowserComponent.

		Once it's created and visible, send the browser to a URL using goToURL().

		@param unloadPageWhenBrowserIsHidden  if this is true, then when the browser
							component is taken offscreen, it'll clear the current page
							and replace it with a blank page - this can be handy to stop
							the browser using resources in the background when it's not
							actually being used.
	*/
	explicit WebBrowserComponent (bool unloadPageWhenBrowserIsHidden = true);

	/** Destructor. */
	~WebBrowserComponent();

	/** Sends the browser to a particular URL.

		@param url      the URL to go to.
		@param headers  an optional set of parameters to put in the HTTP header. If
						you supply this, it should be a set of string in the form
						"HeaderKey: HeaderValue"
		@param postData an optional block of data that will be attached to the HTTP
						POST request
	*/
	void goToURL (const String& url,
				  const StringArray* headers = nullptr,
				  const MemoryBlock* postData = nullptr);

	/** Stops the current page loading.
	*/
	void stop();

	/** Sends the browser back one page.
	*/
	void goBack();

	/** Sends the browser forward one page.
	*/
	void goForward();

	/** Refreshes the browser.
	*/
	void refresh();

	/** This callback is called when the browser is about to navigate
		to a new location.

		You can override this method to perform some action when the user
		tries to go to a particular URL. To allow the operation to carry on,
		return true, or return false to stop the navigation happening.
	*/
	virtual bool pageAboutToLoad (const String& newURL);

	/** This callback happens when the browser has finished loading a page. */
	virtual void pageFinishedLoading (const String& url);

	/** @internal */
	void paint (Graphics& g);
	/** @internal */
	void resized();
	/** @internal */
	void parentHierarchyChanged();
	/** @internal */
	void visibilityChanged();

private:

	WebBrowserComponentInternal* browser;
	bool blankPageShown, unloadPageWhenBrowserIsHidden;
	String lastURL;
	StringArray lastHeaders;
	MemoryBlock lastPostData;

	void reloadLastURL();
	void checkWindowAssociation();

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (WebBrowserComponent);
};

#endif
#endif   // __JUCE_WEBBROWSERCOMPONENT_JUCEHEADER__

/*** End of inlined file: juce_WebBrowserComponent.h ***/


#endif
// END_AUTOINCLUDE

}

#endif   // __JUCE_GUI_EXTRA_JUCEHEADER__

/*** End of inlined file: juce_gui_extra.h ***/

#undef JUCE_OPENGL
#define JUCE_OPENGL 1

#if JUCE_IOS || JUCE_ANDROID
 #define JUCE_OPENGL_ES 1
 #define JUCE_USE_OPENGL_FIXED_FUNCTION 0
#endif

#if JUCE_WINDOWS
 #ifndef APIENTRY
  #define APIENTRY __stdcall
  #define CLEAR_TEMP_APIENTRY 1
 #endif
 #ifndef WINGDIAPI
  #define WINGDIAPI __declspec(dllimport)
  #define CLEAR_TEMP_WINGDIAPI 1
 #endif
 #include <gl/GL.h>
 #ifdef CLEAR_TEMP_WINGDIAPI
  #undef WINGDIAPI
  #undef CLEAR_TEMP_WINGDIAPI
 #endif
 #ifdef CLEAR_TEMP_APIENTRY
  #undef APIENTRY
  #undef CLEAR_TEMP_APIENTRY
 #endif
#elif JUCE_LINUX
 #include <GL/gl.h>
 #undef KeyPress
#elif JUCE_IOS
 #include <OpenGLES/ES1/gl.h>
 #include <OpenGLES/ES1/glext.h>
#elif JUCE_MAC
 #include <OpenGL/gl.h>
 #include "OpenGL/glext.h"
#elif JUCE_ANDROID
 #include <GLES2/gl2.h>
#endif

#if (JUCE_MAC || JUCE_WINDOWS || JUCE_LINUX) && ! defined (JUCE_USE_OPENGL_SHADERS)
 #define JUCE_USE_OPENGL_SHADERS 1
#endif

#ifndef JUCE_USE_OPENGL_FIXED_FUNCTION
 #define JUCE_USE_OPENGL_FIXED_FUNCTION 1
#endif

namespace juce
{


/*** Start of inlined file: juce_OpenGLHelpers.h ***/
#ifndef __JUCE_OPENGLHELPERS_JUCEHEADER__
#define __JUCE_OPENGLHELPERS_JUCEHEADER__

class OpenGLTexture;
class OpenGLFrameBuffer;

/**
	A set of miscellaneous openGL helper functions.
*/
class JUCE_API  OpenGLHelpers
{
public:
	/** Clears the GL error state. */
	static void resetErrorState();

	/** Returns true if the current thread has an active OpenGL context. */
	static bool isContextActive();

	/** Clears the current context using the given colour. */
	static void clear (const Colour& colour);

	static void enableScissorTest (const Rectangle<int>& clip);

	/** Checks whether the current context supports the specified extension. */
	static bool isExtensionSupported (const char* extensionName);

	/** Returns the address of a named GL extension function */
	static void* getExtensionFunction (const char* functionName);

   #if JUCE_USE_OPENGL_FIXED_FUNCTION
	/** Sets the current colour using a JUCE colour. */
	static void setColour (const Colour& colour);

	/** Gives the current context an orthoganal rendering mode for 2D drawing into the given size. */
	static void prepareFor2D (int width, int height);

	/** This does the same job as gluPerspective(). */
	static void setPerspective (double fovy, double aspect, double zNear, double zFar);

	static void applyTransform (const AffineTransform& t);

	static void applyMatrix (const float matrixValues[16]);
   #if ! JUCE_OPENGL_ES
	static void applyMatrix (const double matrixValues[16]);
   #endif

	/** Draws a 2D quad with the specified corner points. */
	static void drawQuad2D (float x1, float y1,
							float x2, float y2,
							float x3, float y3,
							float x4, float y4,
							const Colour& colour);

	/** Draws a 3D quad with the specified corner points. */
	static void drawQuad3D (float x1, float y1, float z1,
							float x2, float y2, float z2,
							float x3, float y3, float z3,
							float x4, float y4, float z4,
							const Colour& colour);
	static void drawTriangleStrip (const GLfloat* const vertices, const GLfloat* const textureCoords, const int numVertices) noexcept;

	static void drawTriangleStrip (const GLfloat* const vertices, const GLfloat* const textureCoords,
								   const int numVertices, const GLuint textureID) noexcept;

	static void drawTextureQuad (GLuint textureID, const Rectangle<int>& rect);

	static void fillRectWithTexture (const Rectangle<int>& rect, GLuint textureID, const float alpha);

	/** Fills a rectangle with the specified colour. */
	static void fillRectWithColour (const Rectangle<int>& rect,
									const Colour& colour);

	static void fillRect (const Rectangle<int>& rect);
   #endif
};

/**
	Used as a local object while rendering, this will create a temporary texture ID
	from an image in the quickest way possible.

	If the image is backed by an OpenGL framebuffer, it will use that directly; otherwise,
	this object will create a temporary texture or framebuffer and copy the image.
*/
class JUCE_API  OpenGLTextureFromImage
{
public:
	OpenGLTextureFromImage (const Image& image);
	~OpenGLTextureFromImage();

	GLuint textureID;
	const int imageWidth, imageHeight;
	float fullWidthProportion, fullHeightProportion;

private:
	ScopedPointer<OpenGLTexture> texture;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (OpenGLTextureFromImage);
};

#endif   // __JUCE_OPENGLHELPERS_JUCEHEADER__

/*** End of inlined file: juce_OpenGLHelpers.h ***/

// START_AUTOINCLUDE opengl
#ifndef __JUCE_DRAGGABLE3DORIENTATION_JUCEHEADER__

/*** Start of inlined file: juce_Draggable3DOrientation.h ***/
#ifndef __JUCE_DRAGGABLE3DORIENTATION_JUCEHEADER__
#define __JUCE_DRAGGABLE3DORIENTATION_JUCEHEADER__


/*** Start of inlined file: juce_Quaternion.h ***/
#ifndef __JUCE_QUATERNION_JUCEHEADER__
#define __JUCE_QUATERNION_JUCEHEADER__


/*** Start of inlined file: juce_Matrix3D.h ***/
#ifndef __JUCE_MATRIX3D_JUCEHEADER__
#define __JUCE_MATRIX3D_JUCEHEADER__

/**
	A 4x4 transformation matrix.

	@see AffineTransform
*/
template <typename Type>
class Matrix3D
{
public:
	Matrix3D() noexcept
	{
		zeromem (mat, sizeof (mat));
		mat[0] = mat[1 + 1 * 4] = mat[2 + 2 * 4] = mat[3 + 3 * 4] = (Type) 1;
	}

	Matrix3D (const Matrix3D& other) noexcept
	{
		memcpy (mat, other.mat, sizeof (mat));
	}

	Matrix3D (const AffineTransform& transform) noexcept
	{
		mat[0]  = transform.mat00;  mat[1] =  transform.mat10;  mat[2]  = 0;         mat[3]  = 0;
		mat[4]  = transform.mat01;  mat[5] =  transform.mat11;  mat[6]  = 0;         mat[7]  = 0;
		mat[8]  = 0;                mat[9] =  0;                mat[10] = (Type) 1;  mat[11] = 0;
		mat[12] = transform.mat02;  mat[13] = transform.mat12;  mat[14] = 0;         mat[15] = (Type) 1;
	}

	Matrix3D (const Type* values) noexcept
	{
		memcpy (mat, values, sizeof (mat));
	}

	Matrix3D (const Type& m00, const Type& m10, const Type& m20, const Type& m30,
			  const Type& m01, const Type& m11, const Type& m21, const Type& m31,
			  const Type& m02, const Type& m12, const Type& m22, const Type& m32,
			  const Type& m03, const Type& m13, const Type& m23, const Type& m33) noexcept
	{
		mat[0]  = m00;  mat[1]  = m10;  mat[2]  = m20;  mat[3]  = m30;
		mat[4]  = m01;  mat[5]  = m11;  mat[6]  = m21;  mat[7]  = m31;
		mat[8]  = m02;  mat[9]  = m12;  mat[10] = m22;  mat[11] = m32;
		mat[12] = m03;  mat[13] = m13;  mat[14] = m23;  mat[15] = m33;
	}

	Matrix3D& operator= (const Matrix3D& other) noexcept
	{
		memcpy (mat, other.mat, sizeof (mat));
		return *this;
	}

   #if JUCE_USE_OPENGL_FIXED_FUNCTION
	/** Multiplies the active OpenGL context's matrix by this one. */
	void applyToOpenGL() const noexcept
	{
		OpenGLHelpers::applyMatrix (mat);
	}
   #endif

	/** The 4x4 matrix values. These are stored in the standard OpenGL order. */
	Type mat[16];
};

#endif   // __JUCE_MATRIX3D_JUCEHEADER__

/*** End of inlined file: juce_Matrix3D.h ***/


/*** Start of inlined file: juce_Vector3D.h ***/
#ifndef __JUCE_VECTOR3D_JUCEHEADER__
#define __JUCE_VECTOR3D_JUCEHEADER__

/**
	A three-coordinate vector.
*/
template <typename Type>
class Vector3D
{
public:
	Vector3D() noexcept  : x(), y(), z() {}
	Vector3D (const Type& xValue, const Type& yValue, const Type& zValue) noexcept  : x (xValue), y (yValue), z (zValue) {}
	Vector3D (const Vector3D& other) noexcept   : x (other.x), y (other.y), z (other.z) {}
	Vector3D& operator= (const Vector3D& other) noexcept     { x = other.x;  y = other.y;  z = other.z;  return *this; }

	/** Returns a vector that lies along the X axis. */
	static Vector3D xAxis() noexcept        { return Vector3D ((Type) 1, 0, 0); }
	/** Returns a vector that lies along the Y axis. */
	static Vector3D yAxis() noexcept        { return Vector3D (0, (Type) 1, 0); }
	/** Returns a vector that lies along the Z axis. */
	static Vector3D zAxis() noexcept        { return Vector3D (0, 0, (Type) 1); }

	Vector3D& operator+= (const Vector3D& other) noexcept        { x += other.x;  y += other.y;  z += other.z;  return *this; }
	Vector3D& operator-= (const Vector3D& other) noexcept        { x -= other.x;  y -= other.y;  z -= other.z;  return *this; }
	Vector3D& operator*= (const Type& scaleFactor) noexcept      { x *= scaleFactor;  y *= scaleFactor;  z *= scaleFactor;  return *this; }
	Vector3D& operator/= (const Type& scaleFactor) noexcept      { x /= scaleFactor;  y /= scaleFactor;  z /= scaleFactor;  return *this; }

	Vector3D operator+ (const Vector3D& other) const noexcept    { return Vector3D (x + other.x, y + other.y, z + other.z); }
	Vector3D operator- (const Vector3D& other) const noexcept    { return Vector3D (x - other.x, y - other.y, z - other.z); }
	Vector3D operator* (const Type& scaleFactor) const noexcept  { return Vector3D (x * scaleFactor, y * scaleFactor, z * scaleFactor); }
	Vector3D operator/ (const Type& scaleFactor) const noexcept  { return Vector3D (x / scaleFactor, y / scaleFactor, z / scaleFactor); }
	Vector3D operator-() const noexcept                          { return Vector3D (-x, -y, -z); }

	/** Returns the dot-product of these two vectors. */
	Type operator* (const Vector3D& other) const noexcept        { return x * other.x + y * other.y + z * other.z; }

	/** Returns the cross-product of these two vectors. */
	Vector3D operator^ (const Vector3D& other) const noexcept    { return Vector3D (y * other.z - z * other.y, z * other.x - x * other.z, x * other.y - y * other.x); }

	Type length() const noexcept            { return std::sqrt (lengthSquared()); }
	Type lengthSquared() const noexcept     { return x * x + y * y + z * z; }

	Vector3D normalised() const noexcept    { return *this / length(); }

	/** Returns true if the vector is practically equal to the origin. */
	bool lengthIsBelowEpsilon() const noexcept
	{
		const Type epsilon (std::numeric_limits<Type>::epsilon());
		return ! (x < -epsilon || x > epsilon || y < -epsilon || y > epsilon || z < -epsilon || z > epsilon);
	}

	Type x, y, z;
};

#endif   // __JUCE_VECTOR3D_JUCEHEADER__

/*** End of inlined file: juce_Vector3D.h ***/

/**
	Holds a quaternion (a 3D vector and a scalar value).
*/
template <typename Type>
class Quaternion
{
public:
	Quaternion() noexcept  : scalar() {}
	Quaternion (const Quaternion& other) noexcept                                     : vector (other.vector), scalar (other.scalar) {}
	Quaternion (const Vector3D<Type>& vector_, const Type& scalar_) noexcept          : vector (vector_), scalar (scalar_) {}
	Quaternion (const Type& x, const Type& y, const Type& z, const Type& w) noexcept  : vector (x, y, z), scalar (w) {}

	/** Creates a quaternion from an angle and an axis. */
	static Quaternion fromAngle (const Type& angle, const Vector3D<Type>& axis) noexcept
	{
		return Quaternion (axis.normalised() * std::sin (angle / (Type) 2), std::cos (angle / (Type) 2));
	}

	Quaternion& operator= (const Quaternion& other) noexcept
	{
		vector = other.vector;
		scalar = other.scalar;
		return *this;
	}

	Quaternion& operator*= (const Quaternion& other) noexcept
	{
		const Type oldScalar (scalar);
		scalar = (scalar * other.scalar) - (vector * other.vector);
		vector = (other.vector * oldScalar) + (vector * other.scalar) + (vector ^ other.vector);
		return *this;
	}

	Type length() const noexcept        { return std::sqrt (normal()); }
	Type normal() const noexcept        { return scalar * scalar + vector.lengthSquared(); }

	Quaternion normalised() const noexcept
	{
		const Type len (length());
		jassert (len > 0);
		return Quaternion (vector / len, scalar / len);
	}

	/** Returns the matrix that will perform the rotation specified by this quaternion. */
	Matrix3D<Type> getRotationMatrix() const noexcept
	{
		const Type norm (normal());
		const Type s (norm > 0 ? ((Type) 2) / norm : 0);
		const Type xs (s * vector.x),  ys (s * vector.y),  zs (s * vector.z);
		const Type wx (xs * scalar),   wy (ys * scalar),   wz (zs * scalar);
		const Type xx (xs * vector.x), xy (ys * vector.x), xz (zs * vector.x);
		const Type yy (ys * vector.y), yz (zs * vector.y), zz (zs * vector.z);

		return Matrix3D<Type> (((Type) 1) - (yy + zz), xy - wz, xz + wy, 0,
							   xy + wz, ((Type) 1) - (xx+ zz),  yz - wx, 0,
							   xz - wy, yz + wx, ((Type) 1) - (xx + yy), 0,
							   0, 0, 0, (Type) 1);
	}

	/** The vector part of the quaternion. */
	Vector3D<Type> vector;

	/** The scalar part of the quaternion. */
	Type scalar;
};

#endif   // __JUCE_QUATERNION_JUCEHEADER__

/*** End of inlined file: juce_Quaternion.h ***/

/**
	Stores a 3D orientation, which can be rotated by dragging with the mouse.
*/
class Draggable3DOrientation
{
public:
	typedef Vector3D<GLfloat> VectorType;

	/** Creates a Draggable3DOrientation, initially set up to be aligned along the X axis. */
	Draggable3DOrientation (float objectRadius = 0.5f) noexcept
		: radius (jmax (0.1f, objectRadius)),
		  quaternion (VectorType::xAxis(), 0)
	{
	}

	/** Resets the orientation, specifying the axis to align it along. */
	void reset (const VectorType& axis) noexcept
	{
		quaternion = QuaternionType (axis, 0);
	}

	/** Sets the viewport area within which mouse-drag positions will occur.
		You'll need to set this rectangle before calling mouseDown. The centre of the
		rectangle is assumed to be the centre of the object that will be rotated, and
		the size of the rectangle will be used to scale the object radius - see setRadius().
	*/
	void setViewport (const Rectangle<int>& newArea) noexcept
	{
		area = newArea;
	}

	/** Sets the size of the rotated object, as a proportion of the viewport's size.
		@see setViewport
	*/
	void setRadius (float newRadius) noexcept
	{
		radius = jmax (0.1f, newRadius);
	}

	/** Begins a mouse-drag operation.
		You must call this before any calls to mouseDrag(). The position that is supplied
		will be treated as being relative to the centre of the rectangle passed to setViewport().
	*/
	template <typename Type>
	void mouseDown (const Point<Type>& mousePos) noexcept
	{
		lastMouse = mousePosToProportion (mousePos.toFloat());
	}

	/** Continues a mouse-drag operation.
		After calling mouseDown() to begin a drag sequence, you can call this method
		to continue it.
	*/
	template <typename Type>
	void mouseDrag (const Point<Type>& mousePos) noexcept
	{
		const VectorType oldPos (projectOnSphere (lastMouse));
		lastMouse = mousePosToProportion (mousePos.toFloat());
		const VectorType newPos (projectOnSphere (lastMouse));

		quaternion *= rotationFromMove (oldPos, newPos);
	}

	/** Returns the matrix that should be used to apply the current orientation.
		@see applyToOpenGLMatrix
	*/
	Matrix3D<GLfloat> getRotationMatrix() const noexcept
	{
		return quaternion.getRotationMatrix();
	}

   #if JUCE_USE_OPENGL_FIXED_FUNCTION
	/** Applies this rotation to the active OpenGL context's matrix. */
	void applyToOpenGLMatrix() const noexcept
	{
		getRotationMatrix().applyToOpenGL();
	}
   #endif

private:
	typedef Quaternion<GLfloat> QuaternionType;
	Rectangle<int> area;
	float radius;
	QuaternionType quaternion;
	Point<float> lastMouse;

	Point<float> mousePosToProportion (const Point<float>& mousePos) const noexcept
	{
		const int scale = (jmin (area.getWidth(), area.getHeight()) / 2);

		// You must call setViewport() to give this object a valid window size before
		// calling any of the mouse input methods!
		jassert (scale > 0);

		return Point<float> ((mousePos.x - area.getCentreX()) / scale,
							 (area.getCentreY() - mousePos.y) / scale);
	}

	VectorType projectOnSphere (const Point<float>& pos) const noexcept
	{
		const GLfloat radiusSquared = radius * radius;
		const GLfloat xySquared = pos.x * pos.x + pos.y * pos.y;

		return VectorType (pos.x, pos.y,
						   xySquared < radiusSquared * 0.5f ? std::sqrt (radiusSquared - xySquared)
															: (radiusSquared / (2.0f * std::sqrt (xySquared))));
	}

	QuaternionType rotationFromMove (const VectorType& from, const VectorType& to) const noexcept
	{
		VectorType rotationAxis (to ^ from);

		if (rotationAxis.lengthIsBelowEpsilon())
			rotationAxis = VectorType::xAxis();

		const GLfloat d = jlimit (-1.0f, 1.0f, (from - to).length() / (2.0f * radius));

		return QuaternionType::fromAngle (2.0f * std::asin (d), rotationAxis);
	}
};

#endif   // __JUCE_DRAGGABLE3DORIENTATION_JUCEHEADER__

/*** End of inlined file: juce_Draggable3DOrientation.h ***/


#endif
#ifndef __JUCE_MATRIX3D_JUCEHEADER__

#endif
#ifndef __JUCE_OPENGLCOMPONENT_JUCEHEADER__

/*** Start of inlined file: juce_OpenGLComponent.h ***/
#ifndef __JUCE_OPENGLCOMPONENT_JUCEHEADER__
#define __JUCE_OPENGLCOMPONENT_JUCEHEADER__


/*** Start of inlined file: juce_OpenGLContext.h ***/
#ifndef __JUCE_OPENGLCONTEXT_JUCEHEADER__
#define __JUCE_OPENGLCONTEXT_JUCEHEADER__


/*** Start of inlined file: juce_OpenGLPixelFormat.h ***/
#ifndef __JUCE_OPENGLPIXELFORMAT_JUCEHEADER__
#define __JUCE_OPENGLPIXELFORMAT_JUCEHEADER__

/**
	Represents the various properties of an OpenGL bitmap format.

	@see OpenGLComponent::setPixelFormat
*/
class JUCE_API  OpenGLPixelFormat
{
public:

	/** Creates an OpenGLPixelFormat.

		The default constructor just initialises the object as a simple 8-bit
		RGBA format.
	*/
	OpenGLPixelFormat (int bitsPerRGBComponent = 8,
					   int alphaBits = 8,
					   int depthBufferBits = 16,
					   int stencilBufferBits = 0) noexcept;

	OpenGLPixelFormat (const OpenGLPixelFormat&) noexcept;
	OpenGLPixelFormat& operator= (const OpenGLPixelFormat&) noexcept;
	bool operator== (const OpenGLPixelFormat&) const noexcept;

	int redBits;          /**< The number of bits per pixel to use for the red channel. */
	int greenBits;        /**< The number of bits per pixel to use for the green channel. */
	int blueBits;         /**< The number of bits per pixel to use for the blue channel. */
	int alphaBits;        /**< The number of bits per pixel to use for the alpha channel. */

	int depthBufferBits;      /**< The number of bits per pixel to use for a depth buffer. */
	int stencilBufferBits;    /**< The number of bits per pixel to use for a stencil buffer. */

	int accumulationBufferRedBits;    /**< The number of bits per pixel to use for an accumulation buffer's red channel. */
	int accumulationBufferGreenBits;  /**< The number of bits per pixel to use for an accumulation buffer's green channel. */
	int accumulationBufferBlueBits;   /**< The number of bits per pixel to use for an accumulation buffer's blue channel. */
	int accumulationBufferAlphaBits;  /**< The number of bits per pixel to use for an accumulation buffer's alpha channel. */

	uint8 multisamplingLevel;         /**< The number of samples to use for full-scene multisampled anti-aliasing (if available). */

private:
	JUCE_LEAK_DETECTOR (OpenGLPixelFormat);
};

#endif   // __JUCE_OPENGLPIXELFORMAT_JUCEHEADER__

/*** End of inlined file: juce_OpenGLPixelFormat.h ***/


/*** Start of inlined file: juce_OpenGLExtensions.h ***/
#ifndef __JUCE_OPENGLEXTENSIONS_JUCEHEADER__
#define __JUCE_OPENGLEXTENSIONS_JUCEHEADER__

/** @internal This macro contains a list of GL extension functions that need to be dynamically loaded on Windows/Linux.
	@see OpenGLExtensionFunctions
*/
#define JUCE_GL_BASIC_EXTENSION_FUNCTIONS(USE_FUNCTION) \
	USE_FUNCTION (glActiveTexture,          void, (GLenum p1), (p1))\
	USE_FUNCTION (glBindBuffer,             void, (GLenum p1, GLuint p2), (p1, p2))\
	USE_FUNCTION (glDeleteBuffers,          void, (GLsizei p1, const GLuint* p2), (p1, p2))\
	USE_FUNCTION (glGenBuffers,             void, (GLsizei p1, GLuint* p2), (p1, p2))\
	USE_FUNCTION (glBufferData,             void, (GLenum p1, GLsizeiptr p2, const GLvoid* p3, GLenum p4), (p1, p2, p3, p4))\
	USE_FUNCTION (glBufferSubData,          void, (GLenum p1, GLintptr p2, GLsizeiptr p3, const GLvoid* p4), (p1, p2, p3, p4))\
	USE_FUNCTION (glIsRenderbuffer,         GLboolean, (GLuint p1), (p1))\
	USE_FUNCTION (glBindRenderbuffer,       void, (GLenum p1, GLuint p2), (p1, p2))\
	USE_FUNCTION (glDeleteRenderbuffers,    void, (GLsizei p1, const GLuint* p2), (p1, p2))\
	USE_FUNCTION (glGenRenderbuffers,       void, (GLsizei p1, GLuint* p2), (p1, p2))\
	USE_FUNCTION (glRenderbufferStorage,    void, (GLenum p1, GLenum p2, GLsizei p3, GLsizei p4), (p1, p2, p3, p4))\
	USE_FUNCTION (glGetRenderbufferParameteriv,  void, (GLenum p1, GLenum p2, GLint* p3), (p1, p2, p3))\
	USE_FUNCTION (glIsFramebuffer,          GLboolean, (GLuint p1), (p1))\
	USE_FUNCTION (glBindFramebuffer,        void, (GLenum p1, GLuint p2), (p1, p2))\
	USE_FUNCTION (glDeleteFramebuffers,     void, (GLsizei p1, const GLuint* p2), (p1, p2))\
	USE_FUNCTION (glGenFramebuffers,        void, (GLsizei p1, GLuint* p2), (p1, p2))\
	USE_FUNCTION (glCheckFramebufferStatus, GLenum, (GLenum p1), (p1))\
	USE_FUNCTION (glFramebufferTexture2D,   void, (GLenum p1, GLenum p2, GLenum p3, GLuint p4, GLint p5), (p1, p2, p3, p4, p5))\
	USE_FUNCTION (glFramebufferRenderbuffer,  void, (GLenum p1, GLenum p2, GLenum p3, GLuint p4), (p1, p2, p3, p4))\
	USE_FUNCTION (glGetFramebufferAttachmentParameteriv, void, (GLenum p1, GLenum p2, GLenum p3, GLint* p4), (p1, p2, p3, p4))

#if JUCE_USE_OPENGL_SHADERS
 #define JUCE_GL_EXTENSION_FUNCTIONS1(USE_FUNCTION) JUCE_GL_BASIC_EXTENSION_FUNCTIONS(USE_FUNCTION) \
	USE_FUNCTION (glCreateProgram,          GLuint, (), ())\
	USE_FUNCTION (glDeleteProgram,          void, (GLuint p1), (p1))\
	USE_FUNCTION (glCreateShader,           GLuint, (GLenum p1), (p1))\
	USE_FUNCTION (glDeleteShader,           void, (GLuint p1), (p1))\
	USE_FUNCTION (glShaderSource,           void, (GLuint p1, GLsizei p2, const GLchar** p3, const GLint* p4), (p1, p2, p3, p4))\
	USE_FUNCTION (glCompileShader,          void, (GLuint p1), (p1))\
	USE_FUNCTION (glAttachShader,           void, (GLuint p1, GLuint p2), (p1, p2))\
	USE_FUNCTION (glLinkProgram,            void, (GLuint p1), (p1))\
	USE_FUNCTION (glUseProgram,             void, (GLuint p1), (p1))\
	USE_FUNCTION (glGetShaderiv,            void, (GLuint p1, GLenum p2, GLint* p3), (p1, p2, p3))\
	USE_FUNCTION (glGetShaderInfoLog,       void, (GLuint p1, GLsizei p2, GLsizei* p3, GLchar* p4), (p1, p2, p3, p4))\
	USE_FUNCTION (glGetProgramInfoLog,      void, (GLuint p1, GLsizei p2, GLsizei* p3, GLchar* p4), (p1, p2, p3, p4))\
	USE_FUNCTION (glGetProgramiv,           void, (GLuint p1, GLenum p2, GLint* p3), (p1, p2, p3))\
	USE_FUNCTION (glGetUniformLocation,     GLint, (GLuint p1, const GLchar* p2), (p1, p2))\
	USE_FUNCTION (glGetAttribLocation,      GLint, (GLuint p1, const GLchar* p2), (p1, p2))\
	USE_FUNCTION (glVertexAttribPointer,    void, (GLuint p1, GLint p2, GLenum p3, GLboolean p4, GLsizei p5, const GLvoid* p6), (p1, p2, p3, p4, p5, p6))\
	USE_FUNCTION (glEnableVertexAttribArray,  void, (GLuint p1), (p1))\
	USE_FUNCTION (glDisableVertexAttribArray, void, (GLuint p1), (p1))\
	USE_FUNCTION (glUniform1f,              void, (GLint p1, GLfloat p2), (p1, p2))\
	USE_FUNCTION (glUniform1i,              void, (GLint p1, GLint p2), (p1, p2))\
	USE_FUNCTION (glUniform2f,              void, (GLint p1, GLfloat p2, GLfloat p3), (p1, p2, p3))\
	USE_FUNCTION (glUniform3f,              void, (GLint p1, GLfloat p2, GLfloat p3, GLfloat p4), (p1, p2, p3, p4))\
	USE_FUNCTION (glUniform4f,              void, (GLint p1, GLfloat p2, GLfloat p3, GLfloat p4, GLfloat p5), (p1, p2, p3, p4, p5))\
	USE_FUNCTION (glUniform4i,              void, (GLint p1, GLint p2, GLint p3, GLint p4, GLint p5), (p1, p2, p3, p4, p5))\
	USE_FUNCTION (glUniform1fv,             void, (GLint p1, GLsizei p2, const GLfloat* p3), (p1, p2, p3))
#else
 #define JUCE_GL_EXTENSION_FUNCTIONS1(USE_FUNCTION) JUCE_GL_BASIC_EXTENSION_FUNCTIONS(USE_FUNCTION)
#endif

#if JUCE_USE_OPENGL_FIXED_FUNCTION
 #define JUCE_GL_EXTENSION_FUNCTIONS(USE_FUNCTION) JUCE_GL_EXTENSION_FUNCTIONS1(USE_FUNCTION) \
	USE_FUNCTION (glClientActiveTexture,    void, (GLenum p1), (p1))
#else
 #define JUCE_GL_EXTENSION_FUNCTIONS(USE_FUNCTION) JUCE_GL_EXTENSION_FUNCTIONS1(USE_FUNCTION)
#endif

/** This class contains a generated list of OpenGL extension functions, which are either dynamically loaded
	for a specific GL context, or simply call-through to the appropriate OS function where available.
*/
struct OpenGLExtensionFunctions
{
	void initialise();

   #if JUCE_WINDOWS && ! DOXYGEN
	typedef char GLchar;
	typedef pointer_sized_int GLsizeiptr;
	typedef pointer_sized_int GLintptr;
   #endif

   #if JUCE_WINDOWS || JUCE_LINUX
	#if JUCE_WINDOWS
	 #define JUCE_GL_STDCALL __stdcall
	#else
	 #define JUCE_GL_STDCALL
	#endif

	#define JUCE_DECLARE_GL_FUNCTION(name, returnType, params, callparams) typedef returnType (JUCE_GL_STDCALL *type_ ## name) params; type_ ## name name;
   #elif JUCE_OPENGL_ES
	#define JUCE_DECLARE_GL_FUNCTION(name, returnType, params, callparams) inline static returnType name params;
   #else
	#define JUCE_DECLARE_GL_FUNCTION(name, returnType, params, callparams) inline static returnType name params { return ::name callparams; }
   #endif

	JUCE_GL_EXTENSION_FUNCTIONS (JUCE_DECLARE_GL_FUNCTION)
	#undef JUCE_DECLARE_GL_FUNCTION
};

#endif   // __JUCE_OPENGLEXTENSIONS_JUCEHEADER__

/*** End of inlined file: juce_OpenGLExtensions.h ***/

/**
	A base class for types of OpenGL context.

	An OpenGLComponent will supply its own context for drawing in its window.
*/
class JUCE_API  OpenGLContext
{
public:

	/** Destructor. */
	virtual ~OpenGLContext();

	/** Makes this context the currently active one. */
	virtual bool makeActive() const noexcept = 0;
	/** If this context is currently active, it is disactivated. */
	virtual bool makeInactive() const noexcept = 0;
	/** Returns true if this context is currently active. */
	virtual bool isActive() const noexcept = 0;

	/** Swaps the buffers (if the context can do this). */
	virtual void swapBuffers() = 0;

	/** Sets whether the context checks the vertical sync before swapping.

		The value is the number of frames to allow between buffer-swapping. This is
		fairly system-dependent, but 0 turns off syncing, 1 makes it swap on frame-boundaries,
		and greater numbers indicate that it should swap less often.

		Returns true if it sets the value successfully.
	*/
	virtual bool setSwapInterval (int numFramesPerSwap) = 0;

	/** Returns the current swap-sync interval.
		See setSwapInterval() for info about the value returned.
	*/
	virtual int getSwapInterval() const = 0;

	/** Returns an OS-dependent handle to the raw GL context.

		On win32, this will be a HGLRC; on the Mac, an NSOpenGLContext; on Linux,
		a GLXContext.
	*/
	virtual void* getRawContext() const noexcept = 0;

	/** Returns the width of this context */
	virtual int getWidth() const = 0;
	/** Returns the height of this context */
	virtual int getHeight() const = 0;

	/** If this context is backed by a frame buffer, this returns its ID number, or
		0 if the context has no accessible framebuffer.
	*/
	virtual unsigned int getFrameBufferID() const = 0;

	/** Checks whether the current context supports the specified extension. */
	bool isExtensionSupported (const char* const extensionName);

	/** Returns true if shaders can be used in this context. */
	virtual bool areShadersAvailable() const;

	/** Returns the context that's currently in active use by the calling thread.

		Returns 0 if there isn't an active context.
	*/
	static OpenGLContext* getCurrentContext();

	/** This property set allows you to attach persisent values to the context. */
	NamedValueSet properties;

	/** This structure holds a set of dynamically loaded GL functions for use on this context. */
	OpenGLExtensionFunctions extensions;

	/** Draws the currently selected texture into this context at its original size.
		@param targetClipArea  the target area to draw into (in top-left origin coords)
		@param anchorPosAndTextureSize  the position of this rectangle is the texture's top-left
										anchor position in the target space, and the size must be
										the total size of the texture.
	*/
	void copyTexture (const Rectangle<int>& targetClipArea,
					  const Rectangle<int>& anchorPosAndTextureSize);

protected:

	OpenGLContext() noexcept;

private:
	mutable int shaderLanguageAvailable;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (OpenGLContext);
};

#endif   // __JUCE_OPENGLCONTEXT_JUCEHEADER__

/*** End of inlined file: juce_OpenGLContext.h ***/

#if JUCE_MAC && ! defined (DOXYGEN)
 typedef NSViewComponent OpenGLBaseType;
#else
 typedef Component OpenGLBaseType;
#endif

class OpenGLGraphicsContext;
#if JUCE_ANDROID
class AndroidGLContext;
#endif

/**
	A component that contains an OpenGL canvas.

	Override this, add it to whatever component you want to, and use the renderOpenGL()
	method to draw its contents.

	Important note! When using a GL component with a background thread, your sub-class
	must call stopRenderThread() in its destructor. See stopRenderThread() for
	more details.
*/
class JUCE_API  OpenGLComponent  : public OpenGLBaseType
{
public:

	/** These flags can be combined and passed to the OpenGLComponent constructor to
		specify various options.
	*/
	enum OpenGLFlags
	{
		/** This value can be used if you want your OpenGLComponent to use the
			default settings.
		*/
		openGLDefault = 8,

	   #if JUCE_IOS || JUCE_ANDROID
		openGLES1 = 1,  /**< This selects openGL ES 1.0 */
		openGLES2 = 2,  /**< This selects openGL ES 2.0 */
	   #endif

		/** If this flag is enabled, the component will launch a background thread to
			perform the rendering. If this flag is not enabled, then renderOpenGL()
			will be invoked on the main event thread when the component has been told to
			repaint, or after triggerRepaint() has been called.

			Important note! When using a background thread, your sub-class MUST call
			stopRenderThread() in its destructor. See stopRenderThread() for
			more details.
		*/
		useBackgroundThread = 4,

		/** If this flag is enabled, then any sub-components of the OpenGLComponent
			will be correctly overlaid on top of the GL content, and its paint() method will
			be able to render over it. If you're not using sub-components, you can disable
			this flag, which will eliminate some overhead.
		*/
		allowSubComponents = 8
	};

	/** Creates an OpenGLComponent.
		The flags parameter should be a combination of the values in the
		OpenGLFlags enum.
	*/
	OpenGLComponent (int flags = openGLDefault);

	/** Destructor. */
	~OpenGLComponent();

	/** Changes the pixel format used by this component. */
	void setPixelFormat (const OpenGLPixelFormat& formatToUse);

	/** Specifies an OpenGL context which should be shared with the one that this
		component is using.

		This is an OpenGL feature that lets two contexts share their texture data.

		Note that this pointer is stored by the component, and when the component
		needs to recreate its internal context for some reason, the same context
		will be used again to share lists. So if you pass a context in here,
		don't delete the context while this component is still using it! You can
		call shareWith (nullptr) to stop this component from sharing with it.
	*/
	void shareWith (OpenGLContext* contextToShareListsWith);

	/** Returns the context that this component is sharing with.
		@see shareWith
	*/
	OpenGLContext* getShareContext() const noexcept     { return contextToShareListsWith; }

	/** Flips the openGL buffers over. */
	void swapBuffers();

	/** Returns true if the component is performing the rendering on a background thread.
		This property is specified in the constructor.
	*/
	inline bool isUsingDedicatedThread() const noexcept        { return (flags & useBackgroundThread) != 0; }

	/** Shuts down the rendering thread.
		This must be called by your sub-class's destructor, to make sure that all rendering
		callbacks have stopped before your class starts to be destroyed.
	*/
	void stopRenderThread();

	/** This callback is where your subclass should draw its openGL content.

		When this is called, makeCurrentContextActive() will already have been called
		for you, so you just need to draw.
	*/
	virtual void renderOpenGL() = 0;

	/** This method is called when the component creates a new OpenGL context.

		A new context may be created when the component is first used, or when it
		is moved to a different window, or when the window is hidden and re-shown,
		etc.

		You can use this callback as an opportunity to set up things like textures
		that your context needs.

		New contexts are created on-demand by the makeCurrentContextActive() method - so
		if the context is deleted, e.g. by changing the pixel format or window, no context
		will be created until the next call to makeCurrentContextActive(), which will
		synchronously create one and call this method. This means that if you're using
		a non-GUI thread for rendering, you can make sure this method is be called by
		your renderer thread.

		When this callback happens, the context will already have been made current
		using the makeCurrentContextActive() method, so there's no need to call it
		again in your code.
	*/
	virtual void newOpenGLContextCreated();

	/** This method is called when the component shuts down its OpenGL context.

		You can use this callback to delete textures and any other OpenGL objects you
		created in the component's context. Be aware: if you are using a render
		thread, this may be called on the thread.

		When this callback happens, the context will have been made current
		using the makeCurrentContextActive() method, so there's no need to call it
		again in your code.
	 */
	virtual void releaseOpenGLContext();

	/** Returns the context that will draw into this component.

		This may return 0 if the component is currently invisible or hasn't currently
		got a context. The context object can be deleted and a new one created during
		the lifetime of this component, and there may be times when it doesn't have one.

		@see newOpenGLContextCreated()
	*/
	OpenGLContext* getCurrentContext() const noexcept           { return context; }

	/** Makes this component the currently active openGL context.

		If this returns false, then the context isn't active, so you should avoid
		making any calls.

		This call may actually create a context if one isn't currently initialised. If
		it does this, it will also synchronously call the newOpenGLContextCreated()
		method to let you initialise it as necessary.

		@see releaseAsRenderingTarget
	*/
	bool makeCurrentRenderingTarget();

	/** Stops the current component being the active OpenGL context.
		This is the opposite of makeCurrentRenderingTarget()
		@see makeCurrentRenderingTarget
	*/
	void releaseAsRenderingTarget();

	/** Causes a repaint to be invoked asynchronously.
		This has a similar effect to calling repaint(), and triggers a callback to
		renderOpenGL(), but unlike repaint(), it does not mark any of the component's
		children as needing a redraw, which means that their cached state can be re-used
		if possible.
	*/
	void triggerRepaint();

	/** This returns a critical section that can be used to lock the current context.

		Because the context that is used by this component can change, e.g. when the
		component is shown or hidden, then if you're rendering to it on a background
		thread, this allows you to lock the context for the duration of your rendering
		routine.
	*/
	CriticalSection& getContextLock() noexcept      { return contextLock; }

	/** Delete the context.
		You should only need to call this if you've written a custom thread - if so, make
		sure that your thread calls this before it terminates.
	*/
	void deleteContext();

	/** Tries to synchronously delete and re-create the context.
		If the context doesn't exist already, this will try to create one.
		If it exists, it'll first delete the existing one, and create a new one.
		You may need to call this if you require a temporary context for some reason
		before the normal call to newOpenGLContextCreated() is made.

		@returns true if a new context has been successfully created - this may not be
		possible on all platforms.
	*/
	bool rebuildContext();

	/** If this component is backed by a frame buffer, this returns its ID number, or
		0 if the component has no accessible framebuffer.
	*/
	unsigned int getFrameBufferID() const;

	/** Returns the native handle of an embedded heavyweight window, if there is one.

		E.g. On windows, this will return the HWND of the sub-window containing
		the opengl context, on the mac it'll be the NSOpenGLView.
	*/
	void* getNativeWindowHandle() const;

	/** @internal */
	void paint (Graphics&);

private:
	const int flags;

	class OpenGLComponentRenderThread;
	friend class OpenGLComponentRenderThread;
	friend class ScopedPointer <OpenGLComponentRenderThread>;
	ScopedPointer <OpenGLComponentRenderThread> renderThread;

	class OpenGLComponentWatcher;
	friend class OpenGLComponentWatcher;
	friend class ScopedPointer <OpenGLComponentWatcher>;
	ScopedPointer <OpenGLComponentWatcher> componentWatcher;
	ScopedPointer <OpenGLContext> context;
	OpenGLContext* contextToShareListsWith;

	CriticalSection contextLock;
	OpenGLPixelFormat preferredPixelFormat;
	bool needToUpdateViewport, needToDeleteContext, needToRepaint;

	class OpenGLCachedComponentImage;
	friend class OpenGLCachedComponentImage;
	OpenGLCachedComponentImage* cachedImage;

	OpenGLContext* createContext();
	void updateContext();
	void updateContextPosition();
	void recreateContextAsync();
	void updateEmbeddedPosition (const Rectangle<int>&);
	void startRenderThread();
	bool performRender();
	void paintSelf (OpenGLGraphicsContext&);

	int renderAndSwapBuffers();  // (This method has been deprecated)

   #if JUCE_ANDROID
	friend class AndroidGLContext;
   #endif

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (OpenGLComponent);
};

#endif   // __JUCE_OPENGLCOMPONENT_JUCEHEADER__

/*** End of inlined file: juce_OpenGLComponent.h ***/


#endif
#ifndef __JUCE_OPENGLCONTEXT_JUCEHEADER__

#endif
#ifndef __JUCE_OPENGLFRAMEBUFFER_JUCEHEADER__

/*** Start of inlined file: juce_OpenGLFrameBuffer.h ***/
#ifndef __JUCE_OPENGLFRAMEBUFFER_JUCEHEADER__
#define __JUCE_OPENGLFRAMEBUFFER_JUCEHEADER__

/**
	Creates an openGL frame buffer.
*/
class JUCE_API  OpenGLFrameBuffer
{
public:
	/** Creates an uninitialised buffer.
		To actually allocate the buffer, use initialise().
	*/
	OpenGLFrameBuffer();

	/** Destructor. */
	~OpenGLFrameBuffer();

	/** Tries to allocates a buffer of the given size.
		Note that a valid openGL context must be selected when you call this method,
		or it will fail.
	*/
	bool initialise (OpenGLContext& context, int width, int height);

	/** Tries to allocates a buffer containing a copy of a given image.
		Note that a valid openGL context must be selected when you call this method,
		or it will fail.
	*/
	bool initialise (OpenGLContext& context, const Image& content);

	/** Tries to allocate a copy of another framebuffer.
	*/
	bool initialise (OpenGLFrameBuffer& other);

	/** Releases the buffer, if one has been allocated.
		Any saved state that was created with saveAndRelease() will also be freed by this call.
	*/
	void release();

	/** If the framebuffer is active, this will save a stashed copy of its contents in main memory,
		and will release the GL buffer.
		After saving, the original state can be restored again by calling reloadSavedCopy().
	*/
	void saveAndRelease();

	/** Restores the framebuffer content that was previously saved using saveAndRelease().
		After saving to main memory, the original state can be restored by calling restoreToGPUMemory().
	*/
	bool reloadSavedCopy (OpenGLContext& context);

	/** Returns true if a valid buffer has been allocated. */
	bool isValid() const noexcept                       { return pimpl != nullptr; }

	/** Returns the width of the buffer. */
	int getWidth() const noexcept;

	/** Returns the height of the buffer. */
	int getHeight() const noexcept;

	/** Returns the texture ID number for using this buffer as a texture. */
	GLuint getTextureID() const noexcept;

	/** Selects this buffer as the current OpenGL rendering target. */
	bool makeCurrentRenderingTarget();

	/** Deselects this buffer as the current OpenGL rendering target. */
	void releaseAsRenderingTarget();

	/** Returns the current frame buffer ID for the current context. */
	static GLuint getCurrentFrameBufferTarget();

	/** Clears the framebuffer with the specified colour. */
	void clear (const Colour& colour);

	/** Selects the framebuffer as the current target, and clears it to transparent. */
	void makeCurrentAndClear();

   #if JUCE_USE_OPENGL_FIXED_FUNCTION
	/** Draws this framebuffer onto the current context, with the specified corner positions. */
	void draw2D (float x1, float y1,
				 float x2, float y2,
				 float x3, float y3,
				 float x4, float y4,
				 const Colour& colour) const;

	/** Draws this framebuffer onto the current context, with the specified corner positions. */
	void draw3D (float x1, float y1, float z1,
				 float x2, float y2, float z2,
				 float x3, float y3, float z3,
				 float x4, float y4, float z4,
				 const Colour& colour) const;

	/** Draws the framebuffer at a given position. */
	void drawAt (float x1, float y1) const;
   #endif

	/** Reads an area of pixels from the framebuffer into a 32-bit ARGB pixel array.
		The lineStride is measured as a number of pixels, not bytes - pass a stride
		of 0 to indicate a packed array.
	*/
	bool readPixels (PixelARGB* targetData, const Rectangle<int>& sourceArea);

	/** Writes an area of pixels into the framebuffer from a specified pixel array.
		The lineStride is measured as a number of pixels, not bytes - pass a stride
		of 0 to indicate a packed array.
	*/
	bool writePixels (const PixelARGB* srcData, const Rectangle<int>& targetArea);

private:
	class Pimpl;
	friend class ScopedPointer<Pimpl>;
	ScopedPointer<Pimpl> pimpl;

	class SavedState;
	friend class ScopedPointer<SavedState>;
	ScopedPointer<SavedState> savedState;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (OpenGLFrameBuffer);
};

#endif   // __JUCE_OPENGLFRAMEBUFFER_JUCEHEADER__

/*** End of inlined file: juce_OpenGLFrameBuffer.h ***/


#endif
#ifndef __JUCE_OPENGLGRAPHICSCONTEXT_JUCEHEADER__

/*** Start of inlined file: juce_OpenGLGraphicsContext.h ***/
#ifndef __JUCE_OPENGLGRAPHICSCONTEXT_JUCEHEADER__
#define __JUCE_OPENGLGRAPHICSCONTEXT_JUCEHEADER__

/** A LowLevelGraphicsContext for rendering into an OpenGL framebuffer or window.
*/
class JUCE_API  OpenGLGraphicsContext   : public LowLevelGraphicsContext
{
public:
	explicit OpenGLGraphicsContext (OpenGLComponent& target);
	OpenGLGraphicsContext (OpenGLContext& context, OpenGLFrameBuffer& target);
	OpenGLGraphicsContext (OpenGLContext& context, unsigned int frameBufferID, int width, int height);
	~OpenGLGraphicsContext();

	bool isVectorDevice() const;
	void setOrigin (int x, int y);
	void addTransform (const AffineTransform&);
	float getScaleFactor();
	bool clipToRectangle (const Rectangle<int>&);
	bool clipToRectangleList (const RectangleList&);
	void excludeClipRectangle (const Rectangle<int>&);
	void clipToPath (const Path& path, const AffineTransform&);
	void clipToImageAlpha (const Image& sourceImage, const AffineTransform&);
	bool clipRegionIntersects (const Rectangle<int>&);
	Rectangle<int> getClipBounds() const;
	bool isClipEmpty() const;

	void saveState();
	void restoreState();

	void beginTransparencyLayer (float opacity);
	void endTransparencyLayer();

	void setFill (const FillType& fillType);
	void setOpacity (float newOpacity);
	void setInterpolationQuality (Graphics::ResamplingQuality);

	void fillRect (const Rectangle<int>& r, bool replaceExistingContents);
	void fillPath (const Path& path, const AffineTransform& transform);
	void drawImage (const Image& sourceImage, const AffineTransform& transform);
	void drawLine (const Line <float>& line);
	void drawVerticalLine (int x, float top, float bottom);
	void drawHorizontalLine (int y, float left, float right);

	void setFont (const Font&);
	const Font& getFont();

	void drawGlyph (int glyphNumber, const AffineTransform&);

   #ifndef DOXYGEN
	class SavedState;
	class GLState;
   #endif

private:
	ScopedPointer<GLState> glState;
	RenderingHelpers::SavedStateStack<SavedState> stack;
};

#endif   // __JUCE_OPENGLGRAPHICSCONTEXT_JUCEHEADER__

/*** End of inlined file: juce_OpenGLGraphicsContext.h ***/


#endif
#ifndef __JUCE_OPENGLHELPERS_JUCEHEADER__

#endif
#ifndef __JUCE_OPENGLIMAGE_JUCEHEADER__

/*** Start of inlined file: juce_OpenGLImage.h ***/
#ifndef __JUCE_OPENGLIMAGE_JUCEHEADER__
#define __JUCE_OPENGLIMAGE_JUCEHEADER__

/**
	A type of ImagePixelData that stores its image data in an OpenGL
	framebuffer, allowing a JUCE Image object to wrap a framebuffer.

	By creating an Image from an instance of an OpenGLFrameBufferImage,
	you can then use a Graphics object to draw into the framebuffer using normal
	JUCE 2D operations.

	@see Image, ImageType, ImagePixelData, OpenGLFrameBuffer
*/
class JUCE_API  OpenGLImageType     : public ImageType
{
public:
	OpenGLImageType();
	~OpenGLImageType();

	ImagePixelData* create (Image::PixelFormat, int width, int height, bool shouldClearImage) const;
	int getTypeID() const;

	static OpenGLFrameBuffer* getFrameBufferFrom (const Image&);
};

#endif   // __JUCE_OPENGLIMAGE_JUCEHEADER__

/*** End of inlined file: juce_OpenGLImage.h ***/


#endif
#ifndef __JUCE_OPENGLPIXELFORMAT_JUCEHEADER__

#endif
#ifndef __JUCE_OPENGLSHADERPROGRAM_JUCEHEADER__

/*** Start of inlined file: juce_OpenGLShaderProgram.h ***/
#ifndef __JUCE_OPENGLSHADERPROGRAM_JUCEHEADER__
#define __JUCE_OPENGLSHADERPROGRAM_JUCEHEADER__

/**
	Manages an OpenGL shader program.
*/
class JUCE_API  OpenGLShaderProgram
{
public:
	OpenGLShaderProgram (const OpenGLContext& context) noexcept;
	~OpenGLShaderProgram() noexcept;

	/** Returns the version of GLSL that the current context supports.
		E.g.
		@code
		if (OpenGLShaderProgram::getLanguageVersion() > 1.199)
		{
			// ..do something that requires GLSL 1.2 or above..
		}
		@endcode
	*/
	static double getLanguageVersion();

	/** Compiles and adds a shader to this program.

		After adding all your shaders, remember to call link() to link them into
		a usable program.

		If your app is built in debug mode, this method will assert if the program
		fails to compile correctly.

		The shaderType parameter could be GL_VERTEX_SHADER, GL_FRAGMENT_SHADER, etc.

		@returns  true if the shader compiled successfully. If not, you can call
				  getLastError() to find out what happened.
	*/
	bool addShader (const char* const shaderSourceCode, GLenum shaderType);

	/** Links all the compiled shaders into a usable program.
		If your app is built in debug mode, this method will assert if the program
		fails to link correctly.
		@returns  true if the program linked successfully. If not, you can call
				  getLastError() to find out what happened.
	*/
	bool link() noexcept;

	/** Get the output for the last shader compilation or link that failed. */
	const String& getLastError() const noexcept            { return errorLog; }

	/** Selects this program into the current context. */
	void use() const noexcept;

	/** Represents an openGL uniform value.
		After a program has been linked, you can create Uniform objects to let you
		set the uniforms that your shaders use.

		Be careful not to call the set() functions unless the appropriate program
		is loaded into the current context.
	*/
	struct Uniform
	{
		/** Initialises a uniform.
			The program must have been successfully linked when this
			constructor is called.
		*/
		Uniform (const OpenGLShaderProgram& program, const char* uniformName);

		/** Sets a float uniform. */
		void set (GLfloat n1) const noexcept;
		/** Sets an int uniform. */
		void set (GLint n1) const noexcept;
		/** Sets a vec2 uniform. */
		void set (GLfloat n1, GLfloat n2) const noexcept;
		/** Sets a vec3 uniform. */
		void set (GLfloat n1, GLfloat n2, GLfloat n3) const noexcept;
		/** Sets a vec4 uniform. */
		void set (GLfloat n1, GLfloat n2, GLfloat n3, float n4) const noexcept;
		/** Sets an ivec4 uniform. */
		void set (GLint n1, GLint n2, GLint n3, GLint n4) const noexcept;
		/** Sets a vector float uniform. */
		void set (const GLfloat* values, int numValues) const noexcept;

		/** The uniform's ID number.
			If the uniform couldn't be found, this value will be < 0.
		*/
		GLint uniformID;

	private:
		const OpenGLContext& context;

		JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (Uniform);
	};

	/** Represents an openGL vertex attribute value.
		After a program has been linked, you can create Attribute objects to let you
		set the attributes that your vertex shaders use.
	*/
	struct Attribute
	{
		/** Initialises an attribute.
			The program must have been successfully linked when this
			constructor is called.
		*/
		Attribute (const OpenGLShaderProgram& program, const char* attributeName);

		/** The attribute's ID number.
			If the uniform couldn't be found, this value will be < 0.
		*/
		GLint attributeID;
	};

	/** The ID number of the compiled program. */
	GLuint programID;

private:
	const OpenGLContext& context;
	String errorLog;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (OpenGLShaderProgram);
};

#endif   // __JUCE_OPENGLSHADERPROGRAM_JUCEHEADER__

/*** End of inlined file: juce_OpenGLShaderProgram.h ***/


#endif
#ifndef __JUCE_OPENGLTEXTURE_JUCEHEADER__

/*** Start of inlined file: juce_OpenGLTexture.h ***/
#ifndef __JUCE_OPENGLTEXTURE_JUCEHEADER__
#define __JUCE_OPENGLTEXTURE_JUCEHEADER__

/**
	Creates an openGL texture from an Image.
*/
class JUCE_API  OpenGLTexture
{
public:
	OpenGLTexture();
	~OpenGLTexture();

	/** Creates a texture from the given image.

		Note that if the image's dimensions aren't a power-of-two, the texture may
		be created with a larger size.

		The image will be arranged so that its top-left corner is at texture
		coordinate (0, 1).
	*/
	void loadImage (const Image& image);

	/** Creates a texture from a raw array of pixels.
		The width and height provided must be valid - i.e. power-of-two unless
		the underlying GL system allows otherwise.
		The data is sent directly to the OpenGL driver without being flipped vertically,
		so the first pixel will be mapped onto texture coordinate (0, 0).
		bottom-left corner of the texture
	*/
	void loadARGB (const PixelARGB* pixels, int width, int height);

	/** Creates a texture from a raw array of pixels.
		This is like loadARGB, but will vertically flip the data so that the first
		pixel ends up at texture coordinate (0, 1), and if the width and height are
		not powers-of-two, it will compensate by using a larger texture size.
	*/
	void loadARGBFlipped (const PixelARGB* pixels, int width, int height);

	/** Creates an alpha-channel texture from an array of alpha values.
		The width and height provided must be valid - i.e. power-of-two unless
		the underlying GL system allows otherwise.
		The data is sent directly to the OpenGL driver without being flipped vertically,
		so the first pixel will be mapped onto texture coordinate (0, 0).
		bottom-left corner of the texture
	*/
	void loadAlpha (const uint8* pixels, int width, int height);

	/** Frees the texture, if there is one. */
	void release();

	/** Binds the texture to the currently selected openGL context. */
	void bind() const;

	/** Unbinds the texture to the currently selected openGL context. */
	void unbind() const;

   #if JUCE_USE_OPENGL_FIXED_FUNCTION
	/** Draws this texture into the current context, with the specified corner positions. */
	void draw2D (float x1, float y1,
				 float x2, float y2,
				 float x3, float y3,
				 float x4, float y4,
				 const Colour& colour) const;

	/** Draws this texture into the current context, with the specified corner positions. */
	void draw3D (float x1, float y1, float z1,
				 float x2, float y2, float z2,
				 float x3, float y3, float z3,
				 float x4, float y4, float z4,
				 const Colour& colour) const;
   #endif

	/** Returns the GL texture ID number. */
	GLuint getTextureID() const noexcept        { return textureID; }

	int getWidth() const noexcept               { return width; }
	int getHeight() const noexcept              { return height; }

	/** Returns true if a texture can be created with the given size.
		Some systems may require that the sizes are powers-of-two.
	*/
	static bool isValidSize (int width, int height);

private:
	GLuint textureID;
	int width, height;

	void create (int w, int h, const void*, GLenum type);

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (OpenGLTexture);
};

#endif   // __JUCE_OPENGLTEXTURE_JUCEHEADER__

/*** End of inlined file: juce_OpenGLTexture.h ***/


#endif
#ifndef __JUCE_QUATERNION_JUCEHEADER__

#endif
#ifndef __JUCE_VECTOR3D_JUCEHEADER__

#endif
// END_AUTOINCLUDE

}

#endif   // __JUCE_OPENGL_JUCEHEADER__

/*** End of inlined file: juce_opengl.h ***/


#endif

#if JUCE_MAC
 #import <WebKit/WebKit.h>
 #define Point CarbonDummyPointName
 #define Component CarbonDummyCompName
 #import <Carbon/Carbon.h> // still needed for SetSystemUIMode()
 #undef Point
 #undef Component

#elif JUCE_WINDOWS
 #include <windowsx.h>
 #include <vfw.h>
 #include <commdlg.h>

 #if JUCE_WEB_BROWSER
  #include <Exdisp.h>
  #include <exdispid.h>
 #endif

 #if JUCE_MSVC && ! JUCE_DONT_AUTOLINK_TO_WIN32_LIBRARIES
  #pragma comment(lib, "vfw32.lib")
  #pragma comment(lib, "imm32.lib")
 #endif

 #if JUCE_OPENGL
  #if JUCE_MSVC && ! JUCE_DONT_AUTOLINK_TO_WIN32_LIBRARIES
   #pragma comment(lib, "OpenGL32.Lib")
   #pragma comment(lib, "GlU32.Lib")
  #endif
 #endif

 #if JUCE_QUICKTIME && JUCE_MSVC && ! JUCE_DONT_AUTOLINK_TO_WIN32_LIBRARIES
  #pragma comment (lib, "QTMLClient.lib")
 #endif

 #if JUCE_DIRECT2D && JUCE_MSVC && ! JUCE_DONT_AUTOLINK_TO_WIN32_LIBRARIES
  #pragma comment (lib, "Dwrite.lib")
  #pragma comment (lib, "D2d1.lib")
 #endif

 #if JUCE_MINGW
  #include <Imm.h>
 #endif

#elif JUCE_LINUX
 #include <X11/Xlib.h>
 #include <X11/Xatom.h>
 #include <X11/Xresource.h>
 #include <X11/Xutil.h>
 #include <X11/Xmd.h>
 #include <X11/keysym.h>
 #include <X11/cursorfont.h>

 #if JUCE_USE_XINERAMA
  /* If you're trying to use Xinerama, you'll need to install the "libxinerama-dev" package..  */
  #include <X11/extensions/Xinerama.h>
 #endif

 #if JUCE_USE_XSHM
  #include <X11/extensions/XShm.h>
  #include <sys/shm.h>
  #include <sys/ipc.h>
 #endif

 #if JUCE_USE_XRENDER
  // If you're missing these headers, try installing the libxrender-dev and libxcomposite-dev
  #include <X11/extensions/Xrender.h>
  #include <X11/extensions/Xcomposite.h>
 #endif

 #if JUCE_USE_XCURSOR
  // If you're missing this header, try installing the libxcursor-dev package
  #include <X11/Xcursor/Xcursor.h>
 #endif

 #undef SIZEOF
 #undef KeyPress
#endif

namespace juce
{

// START_AUTOINCLUDE components/*.cpp, mouse/*.cpp, keyboard/*.cpp, buttons/*.cpp,
// drawables/*.cpp, filebrowser/*.cpp, layout/*.cpp, lookandfeel/*.cpp,
// menus/*.cpp, positioning/*.cpp, properties/*.cpp, widgets/*.cpp,
// windows/*.cpp, commands/*.cpp, application/*.cpp, misc/*.cpp

/*** Start of inlined file: juce_Component.cpp ***/
/*
  ==============================================================================

   This file is part of the JUCE library - "Jules' Utility Class Extensions"
   Copyright 2004-11 by Raw Material Software Ltd.

  ------------------------------------------------------------------------------

   JUCE can be redistributed and/or modified under the terms of the GNU General
   Public License (Version 2), as published by the Free Software Foundation.
   A copy of the license is included in the JUCE distribution, or can be found
   online at www.gnu.org/licenses.

   JUCE is distributed in the hope that it will be useful, but WITHOUT ANY
   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
   A PARTICULAR PURPOSE.  See the GNU General Public License for more details.

  ------------------------------------------------------------------------------

   To release a closed-source product which uses JUCE, commercial licenses are
   available: visit www.rawmaterialsoftware.com/juce for more information.

  ==============================================================================
*/

#define CHECK_MESSAGE_MANAGER_IS_LOCKED     jassert (MessageManager::getInstance()->currentThreadHasLockedMessageManager());

Component* Component::currentlyFocusedComponent = nullptr;

class Component::MouseListenerList
{
public:
	MouseListenerList() noexcept
		: numDeepMouseListeners (0)
	{
	}

	void addListener (MouseListener* const newListener, const bool wantsEventsForAllNestedChildComponents)
	{
		if (! listeners.contains (newListener))
		{
			if (wantsEventsForAllNestedChildComponents)
			{
				listeners.insert (0, newListener);
				++numDeepMouseListeners;
			}
			else
			{
				listeners.add (newListener);
			}
		}
	}

	void removeListener (MouseListener* const listenerToRemove)
	{
		const int index = listeners.indexOf (listenerToRemove);

		if (index >= 0)
		{
			if (index < numDeepMouseListeners)
				--numDeepMouseListeners;

			listeners.remove (index);
		}
	}

	static void sendMouseEvent (Component& comp, Component::BailOutChecker& checker,
								void (MouseListener::*eventMethod) (const MouseEvent&), const MouseEvent& e)
	{
		if (checker.shouldBailOut())
			return;

		{
			MouseListenerList* const list = comp.mouseListeners;

			if (list != nullptr)
			{
				for (int i = list->listeners.size(); --i >= 0;)
				{
					(list->listeners.getUnchecked(i)->*eventMethod) (e);

					if (checker.shouldBailOut())
						return;

					i = jmin (i, list->listeners.size());
				}
			}
		}

		Component* p = comp.parentComponent;

		while (p != nullptr)
		{
			MouseListenerList* const list = p->mouseListeners;

			if (list != nullptr && list->numDeepMouseListeners > 0)
			{
				BailOutChecker2 checker2 (checker, p);

				for (int i = list->numDeepMouseListeners; --i >= 0;)
				{
					(list->listeners.getUnchecked(i)->*eventMethod) (e);

					if (checker2.shouldBailOut())
						return;

					i = jmin (i, list->numDeepMouseListeners);
				}
			}

			p = p->parentComponent;
		}
	}

	static void sendWheelEvent (Component& comp, Component::BailOutChecker& checker, const MouseEvent& e,
								const float wheelIncrementX, const float wheelIncrementY)
	{
		{
			MouseListenerList* const list = comp.mouseListeners;

			if (list != nullptr)
			{
				for (int i = list->listeners.size(); --i >= 0;)
				{
					list->listeners.getUnchecked(i)->mouseWheelMove (e, wheelIncrementX, wheelIncrementY);

					if (checker.shouldBailOut())
						return;

					i = jmin (i, list->listeners.size());
				}
			}
		}

		Component* p = comp.parentComponent;

		while (p != nullptr)
		{
			MouseListenerList* const list = p->mouseListeners;

			if (list != nullptr && list->numDeepMouseListeners > 0)
			{
				BailOutChecker2 checker2 (checker, p);

				for (int i = list->numDeepMouseListeners; --i >= 0;)
				{
					list->listeners.getUnchecked(i)->mouseWheelMove (e, wheelIncrementX, wheelIncrementY);

					if (checker2.shouldBailOut())
						return;

					i = jmin (i, list->numDeepMouseListeners);
				}
			}

			p = p->parentComponent;
		}
	}

private:
	Array <MouseListener*> listeners;
	int numDeepMouseListeners;

	class BailOutChecker2
	{
	public:
		BailOutChecker2 (Component::BailOutChecker& checker_, Component* const component)
			: checker (checker_), safePointer (component)
		{
		}

		bool shouldBailOut() const noexcept
		{
			return checker.shouldBailOut() || safePointer == 0;
		}

	private:
		Component::BailOutChecker& checker;
		const WeakReference<Component> safePointer;

		JUCE_DECLARE_NON_COPYABLE (BailOutChecker2);
	};

	JUCE_DECLARE_NON_COPYABLE (MouseListenerList);
};

struct Component::ComponentHelpers
{
   #if JUCE_MODAL_LOOPS_PERMITTED
	static void* runModalLoopCallback (void* userData)
	{
		return (void*) (pointer_sized_int) static_cast <Component*> (userData)->runModalLoop();
	}
   #endif

	static Identifier getColourPropertyId (const int colourId)
	{
		String s;
		s.preallocateBytes (32);
		s << "jcclr_" << String::toHexString (colourId);
		return s;
	}

	static inline bool hitTest (Component& comp, const Point<int>& localPoint)
	{
		return isPositiveAndBelow (localPoint.x, comp.getWidth())
				 && isPositiveAndBelow (localPoint.y, comp.getHeight())
				 && comp.hitTest (localPoint.x, localPoint.y);
	}

	static Point<int> convertFromParentSpace (const Component& comp, const Point<int>& pointInParentSpace)
	{
		if (comp.affineTransform == nullptr)
			return pointInParentSpace - comp.getPosition();

		return pointInParentSpace.toFloat().transformedBy (comp.affineTransform->inverted()).toInt() - comp.getPosition();
	}

	static Rectangle<int> convertFromParentSpace (const Component& comp, const Rectangle<int>& areaInParentSpace)
	{
		if (comp.affineTransform == nullptr)
			return areaInParentSpace - comp.getPosition();

		return areaInParentSpace.toFloat().transformed (comp.affineTransform->inverted()).getSmallestIntegerContainer() - comp.getPosition();
	}

	static Point<int> convertToParentSpace (const Component& comp, const Point<int>& pointInLocalSpace)
	{
		if (comp.affineTransform == nullptr)
			return pointInLocalSpace + comp.getPosition();

		return (pointInLocalSpace + comp.getPosition()).toFloat().transformedBy (*comp.affineTransform).toInt();
	}

	static Rectangle<int> convertToParentSpace (const Component& comp, const Rectangle<int>& areaInLocalSpace)
	{
		if (comp.affineTransform == nullptr)
			return areaInLocalSpace + comp.getPosition();

		return (areaInLocalSpace + comp.getPosition()).toFloat().transformed (*comp.affineTransform).getSmallestIntegerContainer();
	}

	template <typename Type>
	static Type convertFromDistantParentSpace (const Component* parent, const Component& target, const Type& coordInParent)
	{
		const Component* const directParent = target.getParentComponent();
		jassert (directParent != nullptr);

		if (directParent == parent)
			return convertFromParentSpace (target, coordInParent);

		return convertFromParentSpace (target, convertFromDistantParentSpace (parent, *directParent, coordInParent));
	}

	template <typename Type>
	static Type convertCoordinate (const Component* target, const Component* source, Type p)
	{
		while (source != nullptr)
		{
			if (source == target)
				return p;

			if (source->isParentOf (target))
				return convertFromDistantParentSpace (source, *target, p);

			if (source->isOnDesktop())
			{
				p = source->getPeer()->localToGlobal (p);
				source = nullptr;
			}
			else
			{
				p = convertToParentSpace (*source, p);
				source = source->getParentComponent();
			}
		}

		jassert (source == nullptr);
		if (target == nullptr)
			return p;

		const Component* const topLevelComp = target->getTopLevelComponent();

		if (topLevelComp->isOnDesktop())
			p = topLevelComp->getPeer()->globalToLocal (p);
		else
			p = convertFromParentSpace (*topLevelComp, p);

		if (topLevelComp == target)
			return p;

		return convertFromDistantParentSpace (topLevelComp, *target, p);
	}

	static Rectangle<int> getUnclippedArea (const Component& comp)
	{
		Rectangle<int> r (comp.getLocalBounds());

		Component* const p = comp.getParentComponent();

		if (p != nullptr)
			r = r.getIntersection (convertFromParentSpace (comp, getUnclippedArea (*p)));

		return r;
	}

	static void clipObscuredRegions (const Component& comp, Graphics& g, const Rectangle<int>& clipRect, const Point<int>& delta)
	{
		for (int i = comp.childComponentList.size(); --i >= 0;)
		{
			const Component& child = *comp.childComponentList.getUnchecked(i);

			if (child.isVisible() && ! child.isTransformed())
			{
				const Rectangle<int> newClip (clipRect.getIntersection (child.bounds));

				if (! newClip.isEmpty())
				{
					if (child.isOpaque() && child.componentTransparency == 0)
					{
						g.excludeClipRegion (newClip + delta);
					}
					else
					{
						const Point<int> childPos (child.getPosition());
						clipObscuredRegions (child, g, newClip - childPos, childPos + delta);
					}
				}
			}
		}
	}

	static void subtractObscuredRegions (const Component& comp, RectangleList& result,
										 const Point<int>& delta,
										 const Rectangle<int>& clipRect,
										 const Component* const compToAvoid)
	{
		for (int i = comp.childComponentList.size(); --i >= 0;)
		{
			const Component* const c = comp.childComponentList.getUnchecked(i);

			if (c != compToAvoid && c->isVisible())
			{
				if (c->isOpaque() && c->componentTransparency == 0)
				{
					Rectangle<int> childBounds (c->bounds.getIntersection (clipRect));
					childBounds.translate (delta.x, delta.y);

					result.subtract (childBounds);
				}
				else
				{
					Rectangle<int> newClip (clipRect.getIntersection (c->bounds));
					newClip.translate (-c->getX(), -c->getY());

					subtractObscuredRegions (*c, result, c->getPosition() + delta,
											 newClip, compToAvoid);
				}
			}
		}
	}

	static Rectangle<int> getParentOrMainMonitorBounds (const Component& comp)
	{
		return comp.getParentComponent() != nullptr ? comp.getParentComponent()->getLocalBounds()
													: Desktop::getInstance().getMainMonitorArea();
	}
};

class StandardCachedComponentImage  : public CachedComponentImage
{
public:
	StandardCachedComponentImage (Component& owner_) noexcept : owner (owner_) {}

	void paint (Graphics& g)
	{
		const Rectangle<int> bounds (owner.getLocalBounds());

		if (image.isNull() || image.getBounds() != bounds)
		{
			image = Image (owner.isOpaque() ? Image::RGB : Image::ARGB,
						   jmax (1, bounds.getWidth()), jmax (1, bounds.getHeight()), ! owner.isOpaque());

			validArea.clear();
		}

		{
			Graphics imG (image);
			LowLevelGraphicsContext* const lg = imG.getInternalContext();

			for (RectangleList::Iterator i (validArea); i.next();)
				lg->excludeClipRectangle (*i.getRectangle());

			if (! lg->isClipEmpty())
			{
				if (! owner.isOpaque())
				{
					lg->setFill (Colours::transparentBlack);
					lg->fillRect (bounds, true);
					lg->setFill (Colours::black);
				}

				owner.paintEntireComponent (imG, true);
			}
		}

		validArea = bounds;

		g.setColour (Colours::black.withAlpha (owner.getAlpha()));
		g.drawImageAt (image, 0, 0);
	}

	void invalidateAll()
	{
		validArea.clear();
	}

	void invalidate (const Rectangle<int>& area)
	{
		validArea.subtract (area);
	}

	void releaseResources()
	{
		image = Image::null;
	}

private:
	Image image;
	RectangleList validArea;
	Component& owner;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (StandardCachedComponentImage);
};

Component::Component()
  : parentComponent (nullptr),
	lookAndFeel (nullptr),
	effect (nullptr),
	componentFlags (0),
	componentTransparency (0)
{
}

Component::Component (const String& name)
  : componentName (name),
	parentComponent (nullptr),
	lookAndFeel (nullptr),
	effect (nullptr),
	componentFlags (0),
	componentTransparency (0)
{
}

Component::~Component()
{
	static_jassert (sizeof (flags) <= sizeof (componentFlags));

	componentListeners.call (&ComponentListener::componentBeingDeleted, *this);

	masterReference.clear();

	while (childComponentList.size() > 0)
		removeChildComponent (childComponentList.size() - 1, false, true);

	if (parentComponent != nullptr)
		parentComponent->removeChildComponent (parentComponent->childComponentList.indexOf (this), true, false);
	else if (currentlyFocusedComponent == this || isParentOf (currentlyFocusedComponent))
		giveAwayFocus (currentlyFocusedComponent != this);

	if (flags.hasHeavyweightPeerFlag)
		removeFromDesktop();

	// Something has added some children to this component during its destructor! Not a smart idea!
	jassert (childComponentList.size() == 0);
}

void Component::setName (const String& name)
{
	// if component methods are being called from threads other than the message
	// thread, you'll need to use a MessageManagerLock object to make sure it's thread-safe.
	CHECK_MESSAGE_MANAGER_IS_LOCKED

	if (componentName != name)
	{
		componentName = name;

		if (flags.hasHeavyweightPeerFlag)
		{
			ComponentPeer* const peer = getPeer();

			jassert (peer != nullptr);
			if (peer != nullptr)
				peer->setTitle (name);
		}

		BailOutChecker checker (this);
		componentListeners.callChecked (checker, &ComponentListener::componentNameChanged, *this);
	}
}

void Component::setComponentID (const String& newID)
{
	componentID = newID;
}

void Component::setVisible (bool shouldBeVisible)
{
	if (flags.visibleFlag != shouldBeVisible)
	{
		// if component methods are being called from threads other than the message
		// thread, you'll need to use a MessageManagerLock object to make sure it's thread-safe.
		CHECK_MESSAGE_MANAGER_IS_LOCKED

		const WeakReference<Component> safePointer (this);
		flags.visibleFlag = shouldBeVisible;

		if (shouldBeVisible)
			repaint();
		else
			repaintParent();

		sendFakeMouseMove();

		if (! shouldBeVisible)
		{
			if (cachedImage != nullptr)
				cachedImage->releaseResources();

			if (currentlyFocusedComponent == this || isParentOf (currentlyFocusedComponent))
			{
				if (parentComponent != nullptr)
					parentComponent->grabKeyboardFocus();
				else
					giveAwayFocus (true);
			}
		}

		if (safePointer != nullptr)
		{
			sendVisibilityChangeMessage();

			if (safePointer != nullptr && flags.hasHeavyweightPeerFlag)
			{
				ComponentPeer* const peer = getPeer();

				jassert (peer != nullptr);
				if (peer != nullptr)
				{
					peer->setVisible (shouldBeVisible);
					internalHierarchyChanged();
				}
			}
		}
	}
}

void Component::visibilityChanged()
{
}

void Component::sendVisibilityChangeMessage()
{
	BailOutChecker checker (this);

	visibilityChanged();

	if (! checker.shouldBailOut())
		componentListeners.callChecked (checker, &ComponentListener::componentVisibilityChanged, *this);
}

bool Component::isShowing() const
{
	if (flags.visibleFlag)
	{
		if (parentComponent != nullptr)
		{
			return parentComponent->isShowing();
		}
		else
		{
			const ComponentPeer* const peer = getPeer();

			return peer != nullptr && ! peer->isMinimised();
		}
	}

	return false;
}

void* Component::getWindowHandle() const
{
	const ComponentPeer* const peer = getPeer();

	if (peer != nullptr)
		return peer->getNativeHandle();

	return nullptr;
}

void Component::addToDesktop (int styleWanted, void* nativeWindowToAttachTo)
{
	// if component methods are being called from threads other than the message
	// thread, you'll need to use a MessageManagerLock object to make sure it's thread-safe.
	CHECK_MESSAGE_MANAGER_IS_LOCKED

	if (isOpaque())
		styleWanted &= ~ComponentPeer::windowIsSemiTransparent;
	else
		styleWanted |= ComponentPeer::windowIsSemiTransparent;

	int currentStyleFlags = 0;

	// don't use getPeer(), so that we only get the peer that's specifically
	// for this comp, and not for one of its parents.
	ComponentPeer* peer = ComponentPeer::getPeerFor (this);

	if (peer != nullptr)
		currentStyleFlags = peer->getStyleFlags();

	if (styleWanted != currentStyleFlags || ! flags.hasHeavyweightPeerFlag)
	{
		const WeakReference<Component> safePointer (this);

	   #if JUCE_LINUX
		// it's wise to give the component a non-zero size before
		// putting it on the desktop, as X windows get confused by this, and
		// a (1, 1) minimum size is enforced here.
		setSize (jmax (1, getWidth()),
				 jmax (1, getHeight()));
	   #endif

		const Point<int> topLeft (getScreenPosition());

		bool wasFullscreen = false;
		bool wasMinimised = false;
		ComponentBoundsConstrainer* currentConstainer = nullptr;
		Rectangle<int> oldNonFullScreenBounds;

		if (peer != nullptr)
		{
			wasFullscreen = peer->isFullScreen();
			wasMinimised = peer->isMinimised();
			currentConstainer = peer->getConstrainer();
			oldNonFullScreenBounds = peer->getNonFullScreenBounds();

			removeFromDesktop();

			setTopLeftPosition (topLeft);
		}

		if (parentComponent != nullptr)
			parentComponent->removeChildComponent (this);

		if (safePointer != nullptr)
		{
			flags.hasHeavyweightPeerFlag = true;

			peer = createNewPeer (styleWanted, nativeWindowToAttachTo);

			Desktop::getInstance().addDesktopComponent (this);

			bounds.setPosition (topLeft);
			peer->setBounds (topLeft.x, topLeft.y, getWidth(), getHeight(), false);
			peer->setVisible (isVisible());

			peer = ComponentPeer::getPeerFor (this);
			if (peer == nullptr)
				return;

			if (wasFullscreen)
			{
				peer->setFullScreen (true);
				peer->setNonFullScreenBounds (oldNonFullScreenBounds);
			}

			if (wasMinimised)
				peer->setMinimised (true);

		   #if JUCE_WINDOWS
			if (isAlwaysOnTop())
				peer->setAlwaysOnTop (true);
		   #endif

			peer->setConstrainer (currentConstainer);

			repaint();
			internalHierarchyChanged();
		}
	}
}

void Component::removeFromDesktop()
{
	// if component methods are being called from threads other than the message
	// thread, you'll need to use a MessageManagerLock object to make sure it's thread-safe.
	CHECK_MESSAGE_MANAGER_IS_LOCKED

	if (flags.hasHeavyweightPeerFlag)
	{
		ComponentPeer* const peer = ComponentPeer::getPeerFor (this);

		flags.hasHeavyweightPeerFlag = false;

		jassert (peer != nullptr);
		delete peer;

		Desktop::getInstance().removeDesktopComponent (this);
	}
}

bool Component::isOnDesktop() const noexcept
{
	return flags.hasHeavyweightPeerFlag;
}

void Component::userTriedToCloseWindow()
{
	/* This means that the user's trying to get rid of your window with the 'close window' system
	   menu option (on windows) or possibly the task manager - you should really handle this
	   and delete or hide your component in an appropriate way.

	   If you want to ignore the event and don't want to trigger this assertion, just override
	   this method and do nothing.
	*/
	jassertfalse;
}

void Component::minimisationStateChanged (bool)
{
}

void Component::setOpaque (const bool shouldBeOpaque)
{
	if (shouldBeOpaque != flags.opaqueFlag)
	{
		flags.opaqueFlag = shouldBeOpaque;

		if (flags.hasHeavyweightPeerFlag)
		{
			const ComponentPeer* const peer = ComponentPeer::getPeerFor (this);

			if (peer != nullptr)
			{
				// to make it recreate the heavyweight window
				addToDesktop (peer->getStyleFlags());
			}
		}

		repaint();
	}
}

bool Component::isOpaque() const noexcept
{
	return flags.opaqueFlag;
}

void Component::setCachedComponentImage (CachedComponentImage* newCachedImage)
{
	cachedImage = newCachedImage;
}

void Component::setBufferedToImage (const bool shouldBeBuffered)
{
	// This assertion means that this component is already using a custom CachedComponentImage,
	// so by calling setBufferedToImage, you'll be deleting the custom one - this is almost certainly
	// not what you wanted to happen... If you really do know what you're doing here, and want to
	// avoid this assertion, just call setCachedComponentImage (nullptr) before setBufferedToImage().
	jassert (cachedImage == nullptr || dynamic_cast <StandardCachedComponentImage*> (cachedImage.get()) != nullptr);

	if (shouldBeBuffered)
	{
		if (cachedImage == nullptr)
			cachedImage = new StandardCachedComponentImage (*this);
	}
	else
	{
		cachedImage = nullptr;
	}
}

void Component::moveChildInternal (const int sourceIndex, const int destIndex)
{
	if (sourceIndex != destIndex)
	{
		Component* const c = childComponentList.getUnchecked (sourceIndex);
		jassert (c != nullptr);
		c->repaintParent();

		childComponentList.move (sourceIndex, destIndex);

		sendFakeMouseMove();
		internalChildrenChanged();
	}
}

void Component::toFront (const bool setAsForeground)
{
	// if component methods are being called from threads other than the message
	// thread, you'll need to use a MessageManagerLock object to make sure it's thread-safe.
	CHECK_MESSAGE_MANAGER_IS_LOCKED

	if (flags.hasHeavyweightPeerFlag)
	{
		ComponentPeer* const peer = getPeer();

		if (peer != nullptr)
		{
			peer->toFront (setAsForeground);

			if (setAsForeground && ! hasKeyboardFocus (true))
				grabKeyboardFocus();
		}
	}
	else if (parentComponent != nullptr)
	{
		const Array<Component*>& childList = parentComponent->childComponentList;

		if (childList.getLast() != this)
		{
			const int index = childList.indexOf (this);

			if (index >= 0)
			{
				int insertIndex = -1;

				if (! flags.alwaysOnTopFlag)
				{
					insertIndex = childList.size() - 1;

					while (insertIndex > 0 && childList.getUnchecked (insertIndex)->isAlwaysOnTop())
						--insertIndex;
				}

				parentComponent->moveChildInternal (index, insertIndex);
			}
		}

		if (setAsForeground)
		{
			internalBroughtToFront();
			grabKeyboardFocus();
		}
	}
}

void Component::toBehind (Component* const other)
{
	if (other != nullptr && other != this)
	{
		// the two components must belong to the same parent..
		jassert (parentComponent == other->parentComponent);

		if (parentComponent != nullptr)
		{
			const Array<Component*>& childList = parentComponent->childComponentList;
			const int index = childList.indexOf (this);

			if (index >= 0 && childList [index + 1] != other)
			{
				int otherIndex = childList.indexOf (other);

				if (otherIndex >= 0)
				{
					if (index < otherIndex)
						--otherIndex;

					parentComponent->moveChildInternal (index, otherIndex);
				}
			}
		}
		else if (isOnDesktop())
		{
			jassert (other->isOnDesktop());

			if (other->isOnDesktop())
			{
				ComponentPeer* const us = getPeer();
				ComponentPeer* const them = other->getPeer();

				jassert (us != nullptr && them != nullptr);
				if (us != nullptr && them != nullptr)
					us->toBehind (them);
			}
		}
	}
}

void Component::toBack()
{
	if (isOnDesktop())
	{
		jassertfalse; //xxx need to add this to native window
	}
	else if (parentComponent != nullptr)
	{
		const Array<Component*>& childList = parentComponent->childComponentList;

		if (childList.getFirst() != this)
		{
			const int index = childList.indexOf (this);

			if (index > 0)
			{
				int insertIndex = 0;

				if (flags.alwaysOnTopFlag)
					while (insertIndex < childList.size() && ! childList.getUnchecked (insertIndex)->isAlwaysOnTop())
						++insertIndex;

				parentComponent->moveChildInternal (index, insertIndex);
			}
		}
	}
}

void Component::setAlwaysOnTop (const bool shouldStayOnTop)
{
	if (shouldStayOnTop != flags.alwaysOnTopFlag)
	{
		BailOutChecker checker (this);

		flags.alwaysOnTopFlag = shouldStayOnTop;

		if (isOnDesktop())
		{
			ComponentPeer* const peer = getPeer();

			jassert (peer != nullptr);
			if (peer != nullptr)
			{
				if (! peer->setAlwaysOnTop (shouldStayOnTop))
				{
					// some kinds of peer can't change their always-on-top status, so
					// for these, we'll need to create a new window
					const int oldFlags = peer->getStyleFlags();
					removeFromDesktop();
					addToDesktop (oldFlags);
				}
			}
		}

		if (shouldStayOnTop && ! checker.shouldBailOut())
			toFront (false);

		if (! checker.shouldBailOut())
			internalHierarchyChanged();
	}
}

bool Component::isAlwaysOnTop() const noexcept
{
	return flags.alwaysOnTopFlag;
}

int Component::proportionOfWidth (const float proportion) const noexcept
{
	return roundToInt (proportion * bounds.getWidth());
}

int Component::proportionOfHeight (const float proportion) const noexcept
{
	return roundToInt (proportion * bounds.getHeight());
}

int Component::getParentWidth() const noexcept
{
	return parentComponent != nullptr ? parentComponent->getWidth()
									  : getParentMonitorArea().getWidth();
}

int Component::getParentHeight() const noexcept
{
	return parentComponent != nullptr ? parentComponent->getHeight()
									  : getParentMonitorArea().getHeight();
}

int Component::getScreenX() const   { return getScreenPosition().x; }
int Component::getScreenY() const   { return getScreenPosition().y; }

Point<int> Component::getScreenPosition() const       { return localPointToGlobal (Point<int>()); }
Rectangle<int> Component::getScreenBounds() const     { return localAreaToGlobal (getLocalBounds()); }

Point<int> Component::getLocalPoint (const Component* source, const Point<int>& point) const
{
	return ComponentHelpers::convertCoordinate (this, source, point);
}

Rectangle<int> Component::getLocalArea (const Component* source, const Rectangle<int>& area) const
{
	return ComponentHelpers::convertCoordinate (this, source, area);
}

Point<int> Component::localPointToGlobal (const Point<int>& point) const
{
	return ComponentHelpers::convertCoordinate (nullptr, this, point);
}

Rectangle<int> Component::localAreaToGlobal (const Rectangle<int>& area) const
{
	return ComponentHelpers::convertCoordinate (nullptr, this, area);
}

/* Deprecated methods... */
Point<int> Component::relativePositionToGlobal (const Point<int>& relativePosition) const
{
	return localPointToGlobal (relativePosition);
}

Point<int> Component::globalPositionToRelative (const Point<int>& screenPosition) const
{
	return getLocalPoint (nullptr, screenPosition);
}

Point<int> Component::relativePositionToOtherComponent (const Component* const targetComponent, const Point<int>& positionRelativeToThis) const
{
	return targetComponent == nullptr ? localPointToGlobal (positionRelativeToThis)
									  : targetComponent->getLocalPoint (this, positionRelativeToThis);
}

void Component::setBounds (const int x, const int y, int w, int h)
{
	// if component methods are being called from threads other than the message
	// thread, you'll need to use a MessageManagerLock object to make sure it's thread-safe.
	CHECK_MESSAGE_MANAGER_IS_LOCKED

	if (w < 0) w = 0;
	if (h < 0) h = 0;

	const bool wasResized  = (getWidth() != w || getHeight() != h);
	const bool wasMoved    = (getX() != x || getY() != y);

   #if JUCE_DEBUG
	// It's a very bad idea to try to resize a window during its paint() method!
	jassert (! (flags.isInsidePaintCall && wasResized && isOnDesktop()));
   #endif

	if (wasMoved || wasResized)
	{
		const bool showing = isShowing();
		if (showing)
		{
			// send a fake mouse move to trigger enter/exit messages if needed..
			sendFakeMouseMove();

			if (! flags.hasHeavyweightPeerFlag)
				repaintParent();
		}

		bounds.setBounds (x, y, w, h);

		if (showing)
		{
			if (wasResized)
				repaint();
			else if (! flags.hasHeavyweightPeerFlag)
				repaintParent();
		}
		else if (cachedImage != nullptr)
		{
			cachedImage->invalidateAll();
		}

		if (flags.hasHeavyweightPeerFlag)
		{
			ComponentPeer* const peer = getPeer();

			if (peer != nullptr)
			{
				if (wasMoved && wasResized)
					peer->setBounds (getX(), getY(), getWidth(), getHeight(), false);
				else if (wasMoved)
					peer->setPosition (getX(), getY());
				else if (wasResized)
					peer->setSize (getWidth(), getHeight());
			}
		}

		sendMovedResizedMessages (wasMoved, wasResized);
	}
}

void Component::sendMovedResizedMessages (const bool wasMoved, const bool wasResized)
{
	BailOutChecker checker (this);

	if (wasMoved)
	{
		moved();

		if (checker.shouldBailOut())
			return;
	}

	if (wasResized)
	{
		resized();

		if (checker.shouldBailOut())
			return;

		for (int i = childComponentList.size(); --i >= 0;)
		{
			childComponentList.getUnchecked(i)->parentSizeChanged();

			if (checker.shouldBailOut())
				return;

			i = jmin (i, childComponentList.size());
		}
	}

	if (parentComponent != nullptr)
		parentComponent->childBoundsChanged (this);

	if (! checker.shouldBailOut())
		componentListeners.callChecked (checker, &ComponentListener::componentMovedOrResized,
										*this, wasMoved, wasResized);
}

void Component::setSize (const int w, const int h)
{
	setBounds (getX(), getY(), w, h);
}

void Component::setTopLeftPosition (const int x, const int y)
{
	setBounds (x, y, getWidth(), getHeight());
}

void Component::setTopLeftPosition (const Point<int>& pos)
{
	setBounds (pos.x, pos.y, getWidth(), getHeight());
}

void Component::setTopRightPosition (const int x, const int y)
{
	setTopLeftPosition (x - getWidth(), y);
}

void Component::setBounds (const Rectangle<int>& r)
{
	setBounds (r.getX(), r.getY(), r.getWidth(), r.getHeight());
}

void Component::setBounds (const RelativeRectangle& newBounds)
{
	newBounds.applyToComponent (*this);
}

void Component::setBounds (const String& newBoundsExpression)
{
	setBounds (RelativeRectangle (newBoundsExpression));
}

void Component::setBoundsRelative (const float x, const float y,
								   const float w, const float h)
{
	const int pw = getParentWidth();
	const int ph = getParentHeight();

	setBounds (roundToInt (x * pw),
			   roundToInt (y * ph),
			   roundToInt (w * pw),
			   roundToInt (h * ph));
}

void Component::setCentrePosition (const int x, const int y)
{
	setTopLeftPosition (x - getWidth() / 2,
						y - getHeight() / 2);
}

void Component::setCentreRelative (const float x, const float y)
{
	setCentrePosition (roundToInt (getParentWidth() * x),
					   roundToInt (getParentHeight() * y));
}

void Component::centreWithSize (const int width, const int height)
{
	const Rectangle<int> parentArea (ComponentHelpers::getParentOrMainMonitorBounds (*this));

	setBounds (parentArea.getCentreX() - width / 2,
			   parentArea.getCentreY() - height / 2,
			   width, height);
}

void Component::setBoundsInset (const BorderSize<int>& borders)
{
	setBounds (borders.subtractedFrom (ComponentHelpers::getParentOrMainMonitorBounds (*this)));
}

void Component::setBoundsToFit (int x, int y, int width, int height,
								const Justification& justification,
								const bool onlyReduceInSize)
{
	// it's no good calling this method unless both the component and
	// target rectangle have a finite size.
	jassert (getWidth() > 0 && getHeight() > 0 && width > 0 && height > 0);

	if (getWidth() > 0 && getHeight() > 0
		 && width > 0 && height > 0)
	{
		int newW, newH;

		if (onlyReduceInSize && getWidth() <= width && getHeight() <= height)
		{
			newW = getWidth();
			newH = getHeight();
		}
		else
		{
			const double imageRatio = getHeight() / (double) getWidth();
			const double targetRatio = height / (double) width;

			if (imageRatio <= targetRatio)
			{
				newW = width;
				newH = jmin (height, roundToInt (newW * imageRatio));
			}
			else
			{
				newH = height;
				newW = jmin (width, roundToInt (newH / imageRatio));
			}
		}

		if (newW > 0 && newH > 0)
			setBounds (justification.appliedToRectangle (Rectangle<int> (newW, newH),
														 Rectangle<int> (x, y, width, height)));
	}
}

bool Component::isTransformed() const noexcept
{
	return affineTransform != nullptr;
}

void Component::setTransform (const AffineTransform& newTransform)
{
	// If you pass in a transform with no inverse, the component will have no dimensions,
	// and there will be all sorts of maths errors when converting coordinates.
	jassert (! newTransform.isSingularity());

	if (newTransform.isIdentity())
	{
		if (affineTransform != nullptr)
		{
			repaint();
			affineTransform = nullptr;
			repaint();

			sendMovedResizedMessages (false, false);
		}
	}
	else if (affineTransform == nullptr)
	{
		repaint();
		affineTransform = new AffineTransform (newTransform);
		repaint();
		sendMovedResizedMessages (false, false);
	}
	else if (*affineTransform != newTransform)
	{
		repaint();
		*affineTransform = newTransform;
		repaint();
		sendMovedResizedMessages (false, false);
	}
}

AffineTransform Component::getTransform() const
{
	return affineTransform != nullptr ? *affineTransform : AffineTransform::identity;
}

bool Component::hitTest (int x, int y)
{
	if (! flags.ignoresMouseClicksFlag)
		return true;

	if (flags.allowChildMouseClicksFlag)
	{
		for (int i = childComponentList.size(); --i >= 0;)
		{
			Component& child = *childComponentList.getUnchecked (i);

			if (child.isVisible()
				 && ComponentHelpers::hitTest (child, ComponentHelpers::convertFromParentSpace (child, Point<int> (x, y))))
				return true;
		}
	}

	return false;
}

void Component::setInterceptsMouseClicks (const bool allowClicks,
										  const bool allowClicksOnChildComponents) noexcept
{
	flags.ignoresMouseClicksFlag = ! allowClicks;
	flags.allowChildMouseClicksFlag = allowClicksOnChildComponents;
}

void Component::getInterceptsMouseClicks (bool& allowsClicksOnThisComponent,
										  bool& allowsClicksOnChildComponents) const noexcept
{
	allowsClicksOnThisComponent = ! flags.ignoresMouseClicksFlag;
	allowsClicksOnChildComponents = flags.allowChildMouseClicksFlag;
}

bool Component::contains (const Point<int>& point)
{
	if (ComponentHelpers::hitTest (*this, point))
	{
		if (parentComponent != nullptr)
		{
			return parentComponent->contains (ComponentHelpers::convertToParentSpace (*this, point));
		}
		else if (flags.hasHeavyweightPeerFlag)
		{
			const ComponentPeer* const peer = getPeer();

			if (peer != nullptr)
				return peer->contains (point, true);
		}
	}

	return false;
}

bool Component::reallyContains (const Point<int>& point, const bool returnTrueIfWithinAChild)
{
	if (! contains (point))
		return false;

	Component* const top = getTopLevelComponent();
	const Component* const compAtPosition = top->getComponentAt (top->getLocalPoint (this, point));

	return (compAtPosition == this) || (returnTrueIfWithinAChild && isParentOf (compAtPosition));
}

Component* Component::getComponentAt (const Point<int>& position)
{
	if (flags.visibleFlag && ComponentHelpers::hitTest (*this, position))
	{
		for (int i = childComponentList.size(); --i >= 0;)
		{
			Component* child = childComponentList.getUnchecked(i);
			child = child->getComponentAt (ComponentHelpers::convertFromParentSpace (*child, position));

			if (child != nullptr)
				return child;
		}

		return this;
	}

	return nullptr;
}

Component* Component::getComponentAt (const int x, const int y)
{
	return getComponentAt (Point<int> (x, y));
}

void Component::addChildComponent (Component* const child, int zOrder)
{
	// if component methods are being called from threads other than the message
	// thread, you'll need to use a MessageManagerLock object to make sure it's thread-safe.
	CHECK_MESSAGE_MANAGER_IS_LOCKED

	if (child != nullptr && child->parentComponent != this)
	{
		if (child->parentComponent != nullptr)
			child->parentComponent->removeChildComponent (child);
		else
			child->removeFromDesktop();

		child->parentComponent = this;

		if (child->isVisible())
			child->repaintParent();

		if (! child->isAlwaysOnTop())
		{
			if (zOrder < 0 || zOrder > childComponentList.size())
				zOrder = childComponentList.size();

			while (zOrder > 0)
			{
				if (! childComponentList.getUnchecked (zOrder - 1)->isAlwaysOnTop())
					break;

				--zOrder;
			}
		}

		childComponentList.insert (zOrder, child);

		child->internalHierarchyChanged();
		internalChildrenChanged();
	}
}

void Component::addAndMakeVisible (Component* const child, int zOrder)
{
	if (child != nullptr)
	{
		child->setVisible (true);
		addChildComponent (child, zOrder);
	}
}

void Component::addChildAndSetID (Component* const child, const String& componentID)
{
	if (child != nullptr)
	{
		child->setComponentID (componentID);
		addAndMakeVisible (child);
	}
}

void Component::removeChildComponent (Component* const child)
{
	removeChildComponent (childComponentList.indexOf (child), true, true);
}

Component* Component::removeChildComponent (const int index)
{
	return removeChildComponent (index, true, true);
}

Component* Component::removeChildComponent (const int index, bool sendParentEvents, const bool sendChildEvents)
{
	// if component methods are being called from threads other than the message
	// thread, you'll need to use a MessageManagerLock object to make sure it's thread-safe.
	CHECK_MESSAGE_MANAGER_IS_LOCKED

	Component* const child = childComponentList [index];

	if (child != nullptr)
	{
		sendParentEvents = sendParentEvents && child->isShowing();

		if (sendParentEvents)
		{
			sendFakeMouseMove();

			if (child->isVisible())
				child->repaintParent();
		}

		childComponentList.remove (index);
		child->parentComponent = nullptr;

		if (child->cachedImage != nullptr)
			child->cachedImage->releaseResources();

		// (NB: there are obscure situations where child->isShowing() = false, but it still has the focus)
		if (currentlyFocusedComponent == child || child->isParentOf (currentlyFocusedComponent))
		{
			if (sendParentEvents)
			{
				const WeakReference<Component> thisPointer (this);

				giveAwayFocus (sendChildEvents || currentlyFocusedComponent != child);

				if (thisPointer == nullptr)
					return child;

				grabKeyboardFocus();
			}
			else
			{
				giveAwayFocus (sendChildEvents || currentlyFocusedComponent != child);
			}
		}

		if (sendChildEvents)
			child->internalHierarchyChanged();

		if (sendParentEvents)
			internalChildrenChanged();
	}

	return child;
}

void Component::removeAllChildren()
{
	while (childComponentList.size() > 0)
		removeChildComponent (childComponentList.size() - 1);
}

void Component::deleteAllChildren()
{
	while (childComponentList.size() > 0)
		delete (removeChildComponent (childComponentList.size() - 1));
}

int Component::getNumChildComponents() const noexcept
{
	return childComponentList.size();
}

Component* Component::getChildComponent (const int index) const noexcept
{
	return childComponentList [index];
}

int Component::getIndexOfChildComponent (const Component* const child) const noexcept
{
	return childComponentList.indexOf (const_cast <Component*> (child));
}

Component* Component::findChildWithID (const String& targetID) const noexcept
{
	for (int i = childComponentList.size(); --i >= 0;)
	{
		Component* const c = childComponentList.getUnchecked(i);
		if (c->componentID == targetID)
			return c;
	}

	return nullptr;
}

Component* Component::getTopLevelComponent() const noexcept
{
	const Component* comp = this;

	while (comp->parentComponent != nullptr)
		comp = comp->parentComponent;

	return const_cast <Component*> (comp);
}

bool Component::isParentOf (const Component* possibleChild) const noexcept
{
	while (possibleChild != nullptr)
	{
		possibleChild = possibleChild->parentComponent;

		if (possibleChild == this)
			return true;
	}

	return false;
}

void Component::parentHierarchyChanged()
{
}

void Component::childrenChanged()
{
}

void Component::internalChildrenChanged()
{
	if (componentListeners.isEmpty())
	{
		childrenChanged();
	}
	else
	{
		BailOutChecker checker (this);

		childrenChanged();

		if (! checker.shouldBailOut())
			componentListeners.callChecked (checker, &ComponentListener::componentChildrenChanged, *this);
	}
}

void Component::internalHierarchyChanged()
{
	BailOutChecker checker (this);

	parentHierarchyChanged();

	if (checker.shouldBailOut())
		return;

	componentListeners.callChecked (checker, &ComponentListener::componentParentHierarchyChanged, *this);

	if (checker.shouldBailOut())
		return;

	for (int i = childComponentList.size(); --i >= 0;)
	{
		childComponentList.getUnchecked (i)->internalHierarchyChanged();

		if (checker.shouldBailOut())
		{
			// you really shouldn't delete the parent component during a callback telling you
			// that it's changed..
			jassertfalse;
			return;
		}

		i = jmin (i, childComponentList.size());
	}
}

#if JUCE_MODAL_LOOPS_PERMITTED
int Component::runModalLoop()
{
	if (! MessageManager::getInstance()->isThisTheMessageThread())
	{
		// use a callback so this can be called from non-gui threads
		return (int) (pointer_sized_int) MessageManager::getInstance()
										   ->callFunctionOnMessageThread (&ComponentHelpers::runModalLoopCallback, this);
	}

	if (! isCurrentlyModal())
		enterModalState (true);

	return ModalComponentManager::getInstance()->runEventLoopForCurrentComponent();
}
#endif

void Component::enterModalState (const bool shouldTakeKeyboardFocus,
								 ModalComponentManager::Callback* callback,
								 const bool deleteWhenDismissed)
{
	// if component methods are being called from threads other than the message
	// thread, you'll need to use a MessageManagerLock object to make sure it's thread-safe.
	CHECK_MESSAGE_MANAGER_IS_LOCKED

	// Check for an attempt to make a component modal when it already is!
	// This can cause nasty problems..
	jassert (! flags.currentlyModalFlag);

	if (! isCurrentlyModal())
	{
		ModalComponentManager* const mcm = ModalComponentManager::getInstance();
		mcm->startModal (this, deleteWhenDismissed);
		mcm->attachCallback (this, callback);

		flags.currentlyModalFlag = true;
		setVisible (true);

		if (shouldTakeKeyboardFocus)
			grabKeyboardFocus();
	}
}

void Component::exitModalState (const int returnValue)
{
	if (flags.currentlyModalFlag)
	{
		if (MessageManager::getInstance()->isThisTheMessageThread())
		{
			ModalComponentManager::getInstance()->endModal (this, returnValue);
			flags.currentlyModalFlag = false;

			ModalComponentManager::getInstance()->bringModalComponentsToFront();
		}
		else
		{
			class ExitModalStateMessage   : public CallbackMessage
			{
			public:
				ExitModalStateMessage (Component* const target_, const int result_)
					: target (target_), result (result_)   {}

				void messageCallback()
				{
					if (target.get() != nullptr) // (get() required for VS2003 bug)
						target->exitModalState (result);
				}

			private:
				WeakReference<Component> target;
				int result;
			};

			(new ExitModalStateMessage (this, returnValue))->post();
		}
	}
}

bool Component::isCurrentlyModal() const noexcept
{
	return flags.currentlyModalFlag
			&& getCurrentlyModalComponent() == this;
}

bool Component::isCurrentlyBlockedByAnotherModalComponent() const
{
	Component* const mc = getCurrentlyModalComponent();

	return ! (mc == nullptr || mc == this || mc->isParentOf (this)
			   || mc->canModalEventBeSentToComponent (this));
}

int JUCE_CALLTYPE Component::getNumCurrentlyModalComponents() noexcept
{
	return ModalComponentManager::getInstance()->getNumModalComponents();
}

Component* JUCE_CALLTYPE Component::getCurrentlyModalComponent (int index) noexcept
{
	return ModalComponentManager::getInstance()->getModalComponent (index);
}

void Component::setBroughtToFrontOnMouseClick (const bool shouldBeBroughtToFront) noexcept
{
	flags.bringToFrontOnClickFlag = shouldBeBroughtToFront;
}

bool Component::isBroughtToFrontOnMouseClick() const noexcept
{
	return flags.bringToFrontOnClickFlag;
}

void Component::setMouseCursor (const MouseCursor& newCursor)
{
	if (cursor != newCursor)
	{
		cursor = newCursor;

		if (flags.visibleFlag)
			updateMouseCursor();
	}
}

MouseCursor Component::getMouseCursor()
{
	return cursor;
}

void Component::updateMouseCursor() const
{
	Desktop::getInstance().getMainMouseSource().forceMouseCursorUpdate();
}

void Component::setRepaintsOnMouseActivity (const bool shouldRepaint) noexcept
{
	flags.repaintOnMouseActivityFlag = shouldRepaint;
}

void Component::setAlpha (const float newAlpha)
{
	const uint8 newIntAlpha = (uint8) (255 - jlimit (0, 255, roundToInt (newAlpha * 255.0)));

	if (componentTransparency != newIntAlpha)
	{
		componentTransparency = newIntAlpha;

		if (flags.hasHeavyweightPeerFlag)
		{
			ComponentPeer* const peer = getPeer();

			if (peer != nullptr)
				peer->setAlpha (newAlpha);
		}
		else
		{
			repaint();
		}
	}
}

float Component::getAlpha() const
{
	return (255 - componentTransparency) / 255.0f;
}

void Component::repaint()
{
	internalRepaintUnchecked (getLocalBounds(), true);
}

void Component::repaint (const int x, const int y, const int w, const int h)
{
	internalRepaint (Rectangle<int> (x, y, w, h));
}

void Component::repaint (const Rectangle<int>& area)
{
	internalRepaint (area);
}

void Component::repaintParent()
{
	if (parentComponent != nullptr)
		parentComponent->internalRepaint (ComponentHelpers::convertToParentSpace (*this, getLocalBounds()));
}

void Component::internalRepaint (const Rectangle<int>& area)
{
	const Rectangle<int> r (area.getIntersection (getLocalBounds()));

	if (! r.isEmpty())
		internalRepaintUnchecked (r, false);
}

void Component::internalRepaintUnchecked (const Rectangle<int>& area, const bool isEntireComponent)
{
	// if component methods are being called from threads other than the message
	// thread, you'll need to use a MessageManagerLock object to make sure it's thread-safe.
	CHECK_MESSAGE_MANAGER_IS_LOCKED

	if (flags.visibleFlag)
	{
		if (flags.hasHeavyweightPeerFlag)
		{
			ComponentPeer* const peer = getPeer();

			if (peer != nullptr)
				peer->repaint (area);
		}
		else
		{
			if (cachedImage != nullptr)
			{
				if (isEntireComponent)
					cachedImage->invalidateAll();
				else
					cachedImage->invalidate (area);
			}

			if (parentComponent != nullptr)
				parentComponent->internalRepaint (ComponentHelpers::convertToParentSpace (*this, area));
		}
	}
}

void Component::paintWithinParentContext (Graphics& g)
{
	g.setOrigin (getX(), getY());

	if (cachedImage != nullptr)
		cachedImage->paint (g);
	else
		paintEntireComponent (g, false);
}

void Component::paintComponentAndChildren (Graphics& g)
{
	const Rectangle<int> clipBounds (g.getClipBounds());

	if (flags.dontClipGraphicsFlag)
	{
		paint (g);
	}
	else
	{
		g.saveState();
		ComponentHelpers::clipObscuredRegions (*this, g, clipBounds, Point<int>());

		if (! g.isClipEmpty())
			paint (g);

		g.restoreState();
	}

	for (int i = 0; i < childComponentList.size(); ++i)
	{
		Component& child = *childComponentList.getUnchecked (i);

		if (child.isVisible())
		{
			if (child.affineTransform != nullptr)
			{
				g.saveState();
				g.addTransform (*child.affineTransform);

				if ((child.flags.dontClipGraphicsFlag && ! g.isClipEmpty()) || g.reduceClipRegion (child.getBounds()))
					child.paintWithinParentContext (g);

				g.restoreState();
			}
			else if (clipBounds.intersects (child.getBounds()))
			{
				g.saveState();

				if (child.flags.dontClipGraphicsFlag)
				{
					child.paintWithinParentContext (g);
				}
				else if (g.reduceClipRegion (child.getBounds()))
				{
					bool nothingClipped = true;

					for (int j = i + 1; j < childComponentList.size(); ++j)
					{
						const Component& sibling = *childComponentList.getUnchecked (j);

						if (sibling.flags.opaqueFlag && sibling.isVisible() && sibling.affineTransform == nullptr)
						{
							nothingClipped = false;
							g.excludeClipRegion (sibling.getBounds());
						}
					}

					if (nothingClipped || ! g.isClipEmpty())
						child.paintWithinParentContext (g);
				}

				g.restoreState();
			}
		}
	}

	g.saveState();
	paintOverChildren (g);
	g.restoreState();
}

void Component::paintEntireComponent (Graphics& g, const bool ignoreAlphaLevel)
{
   #if JUCE_DEBUG
	flags.isInsidePaintCall = true;
   #endif

	if (effect != nullptr)
	{
		Image effectImage (flags.opaqueFlag ? Image::RGB : Image::ARGB,
						   getWidth(), getHeight(), ! flags.opaqueFlag);
		{
			Graphics g2 (effectImage);
			paintComponentAndChildren (g2);
		}

		effect->applyEffect (effectImage, g, ignoreAlphaLevel ? 1.0f : getAlpha());
	}
	else if (componentTransparency > 0 && ! ignoreAlphaLevel)
	{
		if (componentTransparency < 255)
		{
			g.beginTransparencyLayer (getAlpha());
			paintComponentAndChildren (g);
			g.endTransparencyLayer();
		}
	}
	else
	{
		paintComponentAndChildren (g);
	}

   #if JUCE_DEBUG
	flags.isInsidePaintCall = false;
   #endif
}

void Component::setPaintingIsUnclipped (const bool shouldPaintWithoutClipping) noexcept
{
	flags.dontClipGraphicsFlag = shouldPaintWithoutClipping;
}

Image Component::createComponentSnapshot (const Rectangle<int>& areaToGrab,
										  const bool clipImageToComponentBounds)
{
	Rectangle<int> r (areaToGrab);

	if (clipImageToComponentBounds)
		r = r.getIntersection (getLocalBounds());

	Image componentImage (flags.opaqueFlag ? Image::RGB : Image::ARGB,
						  jmax (1, r.getWidth()),
						  jmax (1, r.getHeight()),
						  true);

	Graphics imageContext (componentImage);
	imageContext.setOrigin (-r.getX(), -r.getY());
	paintEntireComponent (imageContext, true);

	return componentImage;
}

void Component::setComponentEffect (ImageEffectFilter* const newEffect)
{
	if (effect != newEffect)
	{
		effect = newEffect;
		repaint();
	}
}

LookAndFeel& Component::getLookAndFeel() const noexcept
{
	const Component* c = this;

	do
	{
		if (c->lookAndFeel != nullptr)
			return *(c->lookAndFeel);

		c = c->parentComponent;
	}
	while (c != nullptr);

	return LookAndFeel::getDefaultLookAndFeel();
}

void Component::setLookAndFeel (LookAndFeel* const newLookAndFeel)
{
	if (lookAndFeel != newLookAndFeel)
	{
		lookAndFeel = newLookAndFeel;
		sendLookAndFeelChange();
	}
}

void Component::lookAndFeelChanged()
{
}

void Component::sendLookAndFeelChange()
{
	repaint();

	const WeakReference<Component> safePointer (this);

	lookAndFeelChanged();

	if (safePointer != nullptr)
	{
		for (int i = childComponentList.size(); --i >= 0;)
		{
			childComponentList.getUnchecked (i)->sendLookAndFeelChange();

			if (safePointer == nullptr)
				return;

			i = jmin (i, childComponentList.size());
		}
	}
}

Colour Component::findColour (const int colourId, const bool inheritFromParent) const
{
	const var* const v = properties.getVarPointer (ComponentHelpers::getColourPropertyId (colourId));

	if (v != nullptr)
		return Colour ((uint32) static_cast <int> (*v));

	if (inheritFromParent && parentComponent != nullptr
		 && (lookAndFeel == nullptr || ! lookAndFeel->isColourSpecified (colourId)))
		return parentComponent->findColour (colourId, true);

	return getLookAndFeel().findColour (colourId);
}

bool Component::isColourSpecified (const int colourId) const
{
	return properties.contains (ComponentHelpers::getColourPropertyId (colourId));
}

void Component::removeColour (const int colourId)
{
	if (properties.remove (ComponentHelpers::getColourPropertyId (colourId)))
		colourChanged();
}

void Component::setColour (const int colourId, const Colour& colour)
{
	if (properties.set (ComponentHelpers::getColourPropertyId (colourId), (int) colour.getARGB()))
		colourChanged();
}

void Component::copyAllExplicitColoursTo (Component& target) const
{
	bool changed = false;

	for (int i = properties.size(); --i >= 0;)
	{
		const Identifier name (properties.getName(i));

		if (name.toString().startsWith ("jcclr_"))
			if (target.properties.set (name, properties [name]))
				changed = true;
	}

	if (changed)
		target.colourChanged();
}

void Component::colourChanged()
{
}

MarkerList* Component::getMarkers (bool /*xAxis*/)
{
	return nullptr;
}

Component::Positioner::Positioner (Component& component_) noexcept
	: component (component_)
{
}

Component::Positioner* Component::getPositioner() const noexcept
{
	return positioner;
}

void Component::setPositioner (Positioner* newPositioner)
{
	// You can only assign a positioner to the component that it was created for!
	jassert (newPositioner == nullptr || this == &(newPositioner->getComponent()));
	positioner = newPositioner;
}

Rectangle<int> Component::getLocalBounds() const noexcept
{
	return Rectangle<int> (getWidth(), getHeight());
}

Rectangle<int> Component::getBoundsInParent() const noexcept
{
	return affineTransform == nullptr ? bounds
									  : bounds.toFloat().transformed (*affineTransform).getSmallestIntegerContainer();
}

void Component::getVisibleArea (RectangleList& result, const bool includeSiblings) const
{
	result.clear();
	const Rectangle<int> unclipped (ComponentHelpers::getUnclippedArea (*this));

	if (! unclipped.isEmpty())
	{
		result.add (unclipped);

		if (includeSiblings)
		{
			const Component* const c = getTopLevelComponent();

			ComponentHelpers::subtractObscuredRegions (*c, result, getLocalPoint (c, Point<int>()),
													   c->getLocalBounds(), this);
		}

		ComponentHelpers::subtractObscuredRegions (*this, result, Point<int>(), unclipped, nullptr);
		result.consolidate();
	}
}

void Component::mouseEnter (const MouseEvent&)
{
	// base class does nothing
}

void Component::mouseExit (const MouseEvent&)
{
	// base class does nothing
}

void Component::mouseDown (const MouseEvent&)
{
	// base class does nothing
}

void Component::mouseUp (const MouseEvent&)
{
	// base class does nothing
}

void Component::mouseDrag (const MouseEvent&)
{
	// base class does nothing
}

void Component::mouseMove (const MouseEvent&)
{
	// base class does nothing
}

void Component::mouseDoubleClick (const MouseEvent&)
{
	// base class does nothing
}

void Component::mouseWheelMove (const MouseEvent& e, float wheelIncrementX, float wheelIncrementY)
{
	// the base class just passes this event up to its parent..

	if (parentComponent != nullptr)
		parentComponent->mouseWheelMove (e.getEventRelativeTo (parentComponent),
										 wheelIncrementX, wheelIncrementY);
}

void Component::resized()
{
	// base class does nothing
}

void Component::moved()
{
	// base class does nothing
}

void Component::childBoundsChanged (Component*)
{
	// base class does nothing
}

void Component::parentSizeChanged()
{
	// base class does nothing
}

void Component::addComponentListener (ComponentListener* const newListener)
{
	// if component methods are being called from threads other than the message
	// thread, you'll need to use a MessageManagerLock object to make sure it's thread-safe.
	CHECK_MESSAGE_MANAGER_IS_LOCKED

	componentListeners.add (newListener);
}

void Component::removeComponentListener (ComponentListener* const listenerToRemove)
{
	componentListeners.remove (listenerToRemove);
}

void Component::inputAttemptWhenModal()
{
	ModalComponentManager::getInstance()->bringModalComponentsToFront();
	getLookAndFeel().playAlertSound();
}

bool Component::canModalEventBeSentToComponent (const Component*)
{
	return false;
}

void Component::internalModalInputAttempt()
{
	Component* const current = getCurrentlyModalComponent();

	if (current != nullptr)
		current->inputAttemptWhenModal();
}

void Component::paint (Graphics&)
{
	// all painting is done in the subclasses

	jassert (! isOpaque()); // if your component's opaque, you've gotta paint it!
}

void Component::paintOverChildren (Graphics&)
{
	// all painting is done in the subclasses
}

void Component::postCommandMessage (const int commandId)
{
	class CustomCommandMessage   : public CallbackMessage
	{
	public:
		CustomCommandMessage (Component* const target_, const int commandId_)
			: target (target_), commandId (commandId_) {}

		void messageCallback()
		{
			if (target.get() != nullptr)  // (get() required for VS2003 bug)
				target->handleCommandMessage (commandId);
		}

	private:
		WeakReference<Component> target;
		int commandId;
	};

	(new CustomCommandMessage (this, commandId))->post();
}

void Component::handleCommandMessage (int)
{
	// used by subclasses
}

void Component::addMouseListener (MouseListener* const newListener,
								  const bool wantsEventsForAllNestedChildComponents)
{
	// if component methods are being called from threads other than the message
	// thread, you'll need to use a MessageManagerLock object to make sure it's thread-safe.
	CHECK_MESSAGE_MANAGER_IS_LOCKED

	// If you register a component as a mouselistener for itself, it'll receive all the events
	// twice - once via the direct callback that all components get anyway, and then again as a listener!
	jassert ((newListener != this) || wantsEventsForAllNestedChildComponents);

	if (mouseListeners == nullptr)
		mouseListeners = new MouseListenerList();

	mouseListeners->addListener (newListener, wantsEventsForAllNestedChildComponents);
}

void Component::removeMouseListener (MouseListener* const listenerToRemove)
{
	// if component methods are being called from threads other than the message
	// thread, you'll need to use a MessageManagerLock object to make sure it's thread-safe.
	CHECK_MESSAGE_MANAGER_IS_LOCKED

	if (mouseListeners != nullptr)
		mouseListeners->removeListener (listenerToRemove);
}

void Component::internalMouseEnter (MouseInputSource& source, const Point<int>& relativePos, const Time& time)
{
	if (isCurrentlyBlockedByAnotherModalComponent())
	{
		// if something else is modal, always just show a normal mouse cursor
		source.showMouseCursor (MouseCursor::NormalCursor);
		return;
	}

	if (flags.repaintOnMouseActivityFlag)
		repaint();

	BailOutChecker checker (this);

	const MouseEvent me (source, relativePos, source.getCurrentModifiers(),
						 this, this, time, relativePos, time, 0, false);
	mouseEnter (me);

	if (checker.shouldBailOut())
		return;

	Desktop::getInstance().getMouseListeners().callChecked (checker, &MouseListener::mouseEnter, me);

	MouseListenerList::sendMouseEvent (*this, checker, &MouseListener::mouseEnter, me);
}

void Component::internalMouseExit (MouseInputSource& source, const Point<int>& relativePos, const Time& time)
{
	if (flags.repaintOnMouseActivityFlag)
		repaint();

	BailOutChecker checker (this);

	const MouseEvent me (source, relativePos, source.getCurrentModifiers(),
						 this, this, time, relativePos, time, 0, false);

	mouseExit (me);

	if (checker.shouldBailOut())
		return;

	Desktop::getInstance().getMouseListeners().callChecked (checker, &MouseListener::mouseExit, me);

	MouseListenerList::sendMouseEvent (*this, checker, &MouseListener::mouseExit, me);
}

void Component::internalMouseDown (MouseInputSource& source, const Point<int>& relativePos, const Time& time)
{
	Desktop& desktop = Desktop::getInstance();

	BailOutChecker checker (this);

	if (isCurrentlyBlockedByAnotherModalComponent())
	{
		internalModalInputAttempt();

		if (checker.shouldBailOut())
			return;

		// If processing the input attempt has exited the modal loop, we'll allow the event
		// to be delivered..
		if (isCurrentlyBlockedByAnotherModalComponent())
		{
			// allow blocked mouse-events to go to global listeners..
			const MouseEvent me (source, relativePos, source.getCurrentModifiers(),
								 this, this, time, relativePos, time,
								 source.getNumberOfMultipleClicks(), false);

			desktop.getMouseListeners().callChecked (checker, &MouseListener::mouseDown, me);
			return;
		}
	}

	for (Component* c = this; c != nullptr; c = c->parentComponent)
	{
		if (c->isBroughtToFrontOnMouseClick())
		{
			c->toFront (true);

			if (checker.shouldBailOut())
				return;
		}
	}

	if (! flags.dontFocusOnMouseClickFlag)
	{
		grabFocusInternal (focusChangedByMouseClick, true);

		if (checker.shouldBailOut())
			return;
	}

	if (flags.repaintOnMouseActivityFlag)
		repaint();

	const MouseEvent me (source, relativePos, source.getCurrentModifiers(),
						 this, this, time, relativePos, time,
						 source.getNumberOfMultipleClicks(), false);
	mouseDown (me);

	if (checker.shouldBailOut())
		return;

	desktop.getMouseListeners().callChecked (checker, &MouseListener::mouseDown, me);

	MouseListenerList::sendMouseEvent (*this, checker, &MouseListener::mouseDown, me);
}

void Component::internalMouseUp (MouseInputSource& source, const Point<int>& relativePos, const Time& time, const ModifierKeys& oldModifiers)
{
	BailOutChecker checker (this);

	if (flags.repaintOnMouseActivityFlag)
		repaint();

	const MouseEvent me (source, relativePos,
						 oldModifiers, this, this, time,
						 getLocalPoint (nullptr, source.getLastMouseDownPosition()),
						 source.getLastMouseDownTime(),
						 source.getNumberOfMultipleClicks(),
						 source.hasMouseMovedSignificantlySincePressed());

	mouseUp (me);

	if (checker.shouldBailOut())
		return;

	Desktop& desktop = Desktop::getInstance();
	desktop.getMouseListeners().callChecked (checker, &MouseListener::mouseUp, me);

	MouseListenerList::sendMouseEvent (*this, checker, &MouseListener::mouseUp, me);

	if (checker.shouldBailOut())
		return;

	// check for double-click
	if (me.getNumberOfClicks() >= 2)
	{
		mouseDoubleClick (me);

		if (checker.shouldBailOut())
			return;

		desktop.mouseListeners.callChecked (checker, &MouseListener::mouseDoubleClick, me);
		MouseListenerList::sendMouseEvent (*this, checker, &MouseListener::mouseDoubleClick, me);
	}
}

void Component::internalMouseDrag (MouseInputSource& source, const Point<int>& relativePos, const Time& time)
{
	BailOutChecker checker (this);

	const MouseEvent me (source, relativePos,
						 source.getCurrentModifiers(), this, this, time,
						 getLocalPoint (nullptr, source.getLastMouseDownPosition()),
						 source.getLastMouseDownTime(),
						 source.getNumberOfMultipleClicks(),
						 source.hasMouseMovedSignificantlySincePressed());

	mouseDrag (me);

	if (checker.shouldBailOut())
		return;

	Desktop::getInstance().getMouseListeners().callChecked (checker, &MouseListener::mouseDrag, me);

	MouseListenerList::sendMouseEvent (*this, checker, &MouseListener::mouseDrag, me);
}

void Component::internalMouseMove (MouseInputSource& source, const Point<int>& relativePos, const Time& time)
{
	Desktop& desktop = Desktop::getInstance();
	BailOutChecker checker (this);

	const MouseEvent me (source, relativePos, source.getCurrentModifiers(),
						 this, this, time, relativePos, time, 0, false);

	if (isCurrentlyBlockedByAnotherModalComponent())
	{
		// allow blocked mouse-events to go to global listeners..
		desktop.sendMouseMove();
	}
	else
	{
		mouseMove (me);

		if (checker.shouldBailOut())
			return;

		desktop.getMouseListeners().callChecked (checker, &MouseListener::mouseMove, me);

		MouseListenerList::sendMouseEvent (*this, checker, &MouseListener::mouseMove, me);
	}
}

void Component::internalMouseWheel (MouseInputSource& source, const Point<int>& relativePos,
									const Time& time, const float amountX, const float amountY)
{
	Desktop& desktop = Desktop::getInstance();
	BailOutChecker checker (this);

	const float wheelIncrementX = amountX / 256.0f;
	const float wheelIncrementY = amountY / 256.0f;

	const MouseEvent me (source, relativePos, source.getCurrentModifiers(),
						 this, this, time, relativePos, time, 0, false);

	if (isCurrentlyBlockedByAnotherModalComponent())
	{
		// allow blocked mouse-events to go to global listeners..
		desktop.mouseListeners.callChecked (checker, &MouseListener::mouseWheelMove, me, wheelIncrementX, wheelIncrementY);
	}
	else
	{
		mouseWheelMove (me, wheelIncrementX, wheelIncrementY);

		if (checker.shouldBailOut())
			return;

		desktop.mouseListeners.callChecked (checker, &MouseListener::mouseWheelMove, me, wheelIncrementX, wheelIncrementY);

		if (! checker.shouldBailOut())
			MouseListenerList::sendWheelEvent (*this, checker, me, wheelIncrementX, wheelIncrementY);
	}
}

void Component::sendFakeMouseMove() const
{
	MouseInputSource& mainMouse = Desktop::getInstance().getMainMouseSource();

	if (! mainMouse.isDragging())
		mainMouse.triggerFakeMove();
}

void Component::beginDragAutoRepeat (const int interval)
{
	Desktop::getInstance().beginDragAutoRepeat (interval);
}

void Component::broughtToFront()
{
}

void Component::internalBroughtToFront()
{
	if (flags.hasHeavyweightPeerFlag)
		Desktop::getInstance().componentBroughtToFront (this);

	BailOutChecker checker (this);
	broughtToFront();

	if (checker.shouldBailOut())
		return;

	componentListeners.callChecked (checker, &ComponentListener::componentBroughtToFront, *this);

	if (checker.shouldBailOut())
		return;

	// When brought to the front and there's a modal component blocking this one,
	// we need to bring the modal one to the front instead..
	Component* const cm = getCurrentlyModalComponent();

	if (cm != nullptr && cm->getTopLevelComponent() != getTopLevelComponent())
		ModalComponentManager::getInstance()->bringModalComponentsToFront (false); // very important that this is false, otherwise in Windows,
																				   // non-front components can't get focus when another modal comp is
																				   // active, and therefore can't receive mouse-clicks
}

void Component::focusGained (FocusChangeType)
{
	// base class does nothing
}

void Component::internalFocusGain (const FocusChangeType cause)
{
	internalFocusGain (cause, WeakReference<Component> (this));
}

void Component::internalFocusGain (const FocusChangeType cause, const WeakReference<Component>& safePointer)
{
	focusGained (cause);

	if (safePointer != nullptr)
		internalChildFocusChange (cause, safePointer);
}

void Component::focusLost (FocusChangeType)
{
	// base class does nothing
}

void Component::internalFocusLoss (const FocusChangeType cause)
{
	const WeakReference<Component> safePointer (this);

	focusLost (focusChangedDirectly);

	if (safePointer != nullptr)
		internalChildFocusChange (cause, safePointer);
}

void Component::focusOfChildComponentChanged (FocusChangeType /*cause*/)
{
	// base class does nothing
}

void Component::internalChildFocusChange (FocusChangeType cause, const WeakReference<Component>& safePointer)
{
	const bool childIsNowFocused = hasKeyboardFocus (true);

	if (flags.childCompFocusedFlag != childIsNowFocused)
	{
		flags.childCompFocusedFlag = childIsNowFocused;

		focusOfChildComponentChanged (cause);

		if (safePointer == nullptr)
			return;
	}

	if (parentComponent != nullptr)
		parentComponent->internalChildFocusChange (cause, WeakReference<Component> (parentComponent));
}

bool Component::isEnabled() const noexcept
{
	return (! flags.isDisabledFlag)
			&& (parentComponent == nullptr || parentComponent->isEnabled());
}

void Component::setEnabled (const bool shouldBeEnabled)
{
	if (flags.isDisabledFlag == shouldBeEnabled)
	{
		flags.isDisabledFlag = ! shouldBeEnabled;

		// if any parent components are disabled, setting our flag won't make a difference,
		// so no need to send a change message
		if (parentComponent == nullptr || parentComponent->isEnabled())
			sendEnablementChangeMessage();
	}
}

void Component::sendEnablementChangeMessage()
{
	const WeakReference<Component> safePointer (this);

	enablementChanged();

	if (safePointer == nullptr)
		return;

	for (int i = getNumChildComponents(); --i >= 0;)
	{
		Component* const c = getChildComponent (i);

		if (c != nullptr)
		{
			c->sendEnablementChangeMessage();

			if (safePointer == nullptr)
				return;
		}
	}
}

void Component::enablementChanged()
{
}

void Component::setWantsKeyboardFocus (const bool wantsFocus) noexcept
{
	flags.wantsFocusFlag = wantsFocus;
}

void Component::setMouseClickGrabsKeyboardFocus (const bool shouldGrabFocus)
{
	flags.dontFocusOnMouseClickFlag = ! shouldGrabFocus;
}

bool Component::getMouseClickGrabsKeyboardFocus() const noexcept
{
	return ! flags.dontFocusOnMouseClickFlag;
}

bool Component::getWantsKeyboardFocus() const noexcept
{
	return flags.wantsFocusFlag && ! flags.isDisabledFlag;
}

void Component::setFocusContainer (const bool shouldBeFocusContainer) noexcept
{
	flags.isFocusContainerFlag = shouldBeFocusContainer;
}

bool Component::isFocusContainer() const noexcept
{
	return flags.isFocusContainerFlag;
}

static const Identifier juce_explicitFocusOrderId ("_jexfo");

int Component::getExplicitFocusOrder() const
{
	return properties [juce_explicitFocusOrderId];
}

void Component::setExplicitFocusOrder (const int newFocusOrderIndex)
{
	properties.set (juce_explicitFocusOrderId, newFocusOrderIndex);
}

KeyboardFocusTraverser* Component::createFocusTraverser()
{
	if (flags.isFocusContainerFlag || parentComponent == nullptr)
		return new KeyboardFocusTraverser();

	return parentComponent->createFocusTraverser();
}

void Component::takeKeyboardFocus (const FocusChangeType cause)
{
	// give the focus to this component
	if (currentlyFocusedComponent != this)
	{
		// get the focus onto our desktop window
		ComponentPeer* const peer = getPeer();

		if (peer != nullptr)
		{
			const WeakReference<Component> safePointer (this);
			peer->grabFocus();

			if (peer->isFocused() && currentlyFocusedComponent != this)
			{
				WeakReference<Component> componentLosingFocus (currentlyFocusedComponent);
				currentlyFocusedComponent = this;

				Desktop::getInstance().triggerFocusCallback();

				// call this after setting currentlyFocusedComponent so that the one that's
				// losing it has a chance to see where focus is going
				if (componentLosingFocus != nullptr)
					componentLosingFocus->internalFocusLoss (cause);

				if (currentlyFocusedComponent == this)
					internalFocusGain (cause, safePointer);
			}
		}
	}
}

void Component::grabFocusInternal (const FocusChangeType cause, const bool canTryParent)
{
	if (isShowing())
	{
		if (flags.wantsFocusFlag && (isEnabled() || parentComponent == nullptr))
		{
			takeKeyboardFocus (cause);
		}
		else
		{
			if (isParentOf (currentlyFocusedComponent)
				 && currentlyFocusedComponent->isShowing())
			{
				// do nothing if the focused component is actually a child of ours..
			}
			else
			{
				// find the default child component..
				ScopedPointer <KeyboardFocusTraverser> traverser (createFocusTraverser());

				if (traverser != nullptr)
				{
					Component* const defaultComp = traverser->getDefaultComponent (this);
					traverser = nullptr;

					if (defaultComp != nullptr)
					{
						defaultComp->grabFocusInternal (cause, false);
						return;
					}
				}

				if (canTryParent && parentComponent != nullptr)
				{
					// if no children want it and we're allowed to try our parent comp,
					// then pass up to parent, which will try our siblings.
					parentComponent->grabFocusInternal (cause, true);
				}
			}
		}
	}
}

void Component::grabKeyboardFocus()
{
	// if component methods are being called from threads other than the message
	// thread, you'll need to use a MessageManagerLock object to make sure it's thread-safe.
	CHECK_MESSAGE_MANAGER_IS_LOCKED

	grabFocusInternal (focusChangedDirectly, true);
}

void Component::moveKeyboardFocusToSibling (const bool moveToNext)
{
	// if component methods are being called from threads other than the message
	// thread, you'll need to use a MessageManagerLock object to make sure it's thread-safe.
	CHECK_MESSAGE_MANAGER_IS_LOCKED

	if (parentComponent != nullptr)
	{
		ScopedPointer <KeyboardFocusTraverser> traverser (createFocusTraverser());

		if (traverser != nullptr)
		{
			Component* const nextComp = moveToNext ? traverser->getNextComponent (this)
												   : traverser->getPreviousComponent (this);
			traverser = nullptr;

			if (nextComp != nullptr)
			{
				if (nextComp->isCurrentlyBlockedByAnotherModalComponent())
				{
					const WeakReference<Component> nextCompPointer (nextComp);
					internalModalInputAttempt();

					if (nextCompPointer == nullptr || nextComp->isCurrentlyBlockedByAnotherModalComponent())
						return;
				}

				nextComp->grabFocusInternal (focusChangedByTabKey, true);
				return;
			}
		}

		parentComponent->moveKeyboardFocusToSibling (moveToNext);
	}
}

bool Component::hasKeyboardFocus (const bool trueIfChildIsFocused) const
{
	return (currentlyFocusedComponent == this)
			|| (trueIfChildIsFocused && isParentOf (currentlyFocusedComponent));
}

Component* JUCE_CALLTYPE Component::getCurrentlyFocusedComponent() noexcept
{
	return currentlyFocusedComponent;
}

void Component::giveAwayFocus (const bool sendFocusLossEvent)
{
	Component* const componentLosingFocus = currentlyFocusedComponent;
	currentlyFocusedComponent = nullptr;

	if (sendFocusLossEvent && componentLosingFocus != nullptr)
		componentLosingFocus->internalFocusLoss (focusChangedDirectly);

	Desktop::getInstance().triggerFocusCallback();
}

bool Component::isMouseOver (const bool includeChildren) const
{
	const Desktop& desktop = Desktop::getInstance();

	for (int i = desktop.getNumMouseSources(); --i >= 0;)
	{
		const MouseInputSource* const mi = desktop.getMouseSource(i);

		Component* const c = mi->getComponentUnderMouse();

		if ((c == this || (includeChildren && isParentOf (c)))
			  && c->reallyContains (c->getLocalPoint (nullptr, mi->getScreenPosition()), false))
			return true;
	}

	return false;
}

bool Component::isMouseButtonDown() const
{
	const Desktop& desktop = Desktop::getInstance();

	for (int i = desktop.getNumMouseSources(); --i >= 0;)
	{
		const MouseInputSource* const mi = desktop.getMouseSource(i);

		if (mi->isDragging() && mi->getComponentUnderMouse() == this)
			return true;
	}

	return false;
}

bool Component::isMouseOverOrDragging() const
{
	const Desktop& desktop = Desktop::getInstance();

	for (int i = desktop.getNumMouseSources(); --i >= 0;)
		if (desktop.getMouseSource(i)->getComponentUnderMouse() == this)
			return true;

	return false;
}

bool JUCE_CALLTYPE Component::isMouseButtonDownAnywhere() noexcept
{
	return ModifierKeys::getCurrentModifiers().isAnyMouseButtonDown();
}

Point<int> Component::getMouseXYRelative() const
{
	return getLocalPoint (nullptr, Desktop::getMousePosition());
}

Rectangle<int> Component::getParentMonitorArea() const
{
	return Desktop::getInstance().getMonitorAreaContaining (getScreenBounds().getCentre());
}

void Component::addKeyListener (KeyListener* const newListener)
{
	if (keyListeners == nullptr)
		keyListeners = new Array <KeyListener*>();

	keyListeners->addIfNotAlreadyThere (newListener);
}

void Component::removeKeyListener (KeyListener* const listenerToRemove)
{
	if (keyListeners != nullptr)
		keyListeners->removeValue (listenerToRemove);
}

bool Component::keyPressed (const KeyPress&)
{
	return false;
}

bool Component::keyStateChanged (const bool /*isKeyDown*/)
{
	return false;
}

void Component::modifierKeysChanged (const ModifierKeys& modifiers)
{
	if (parentComponent != nullptr)
		parentComponent->modifierKeysChanged (modifiers);
}

void Component::internalModifierKeysChanged()
{
	sendFakeMouseMove();

	modifierKeysChanged (ModifierKeys::getCurrentModifiers());
}

ComponentPeer* Component::getPeer() const
{
	if (flags.hasHeavyweightPeerFlag)
		return ComponentPeer::getPeerFor (this);
	else if (parentComponent == nullptr)
		return nullptr;

	return parentComponent->getPeer();
}

Component::BailOutChecker::BailOutChecker (Component* const component)
	: safePointer (component)
{
	jassert (component != nullptr);
}

bool Component::BailOutChecker::shouldBailOut() const noexcept
{
	return safePointer == nullptr;
}

/*** End of inlined file: juce_Component.cpp ***/



/*** Start of inlined file: juce_ComponentListener.cpp ***/
void ComponentListener::componentMovedOrResized (Component&, bool, bool)    {}
void ComponentListener::componentBroughtToFront (Component&)                {}
void ComponentListener::componentVisibilityChanged (Component&)             {}
void ComponentListener::componentChildrenChanged (Component&)               {}
void ComponentListener::componentParentHierarchyChanged (Component&)        {}
void ComponentListener::componentNameChanged (Component&)                   {}
void ComponentListener::componentBeingDeleted (Component&)                  {}

/*** End of inlined file: juce_ComponentListener.cpp ***/


/*** Start of inlined file: juce_Desktop.cpp ***/
Desktop::Desktop()
	: mouseClickCounter (0),
	  kioskModeComponent (nullptr),
	  allowedOrientations (allOrientations)
{
	createMouseInputSources();
	refreshMonitorSizes();
}

Desktop::~Desktop()
{
	setScreenSaverEnabled (true);

	jassert (instance == this);
	instance = nullptr;

	// doh! If you don't delete all your windows before exiting, you're going to
	// be leaking memory!
	jassert (desktopComponents.size() == 0);
}

Desktop& JUCE_CALLTYPE Desktop::getInstance()
{
	if (instance == nullptr)
		instance = new Desktop();

	return *instance;
}

Desktop* Desktop::instance = nullptr;

void Desktop::refreshMonitorSizes()
{
	Array <Rectangle<int> > oldClipped, oldUnclipped;
	oldClipped.swapWithArray (monitorCoordsClipped);
	oldUnclipped.swapWithArray (monitorCoordsUnclipped);

	getCurrentMonitorPositions (monitorCoordsClipped, true);
	getCurrentMonitorPositions (monitorCoordsUnclipped, false);
	jassert (monitorCoordsClipped.size() == monitorCoordsUnclipped.size());

	if (oldClipped != monitorCoordsClipped
		 || oldUnclipped != monitorCoordsUnclipped)
	{
		for (int i = ComponentPeer::getNumPeers(); --i >= 0;)
		{
			ComponentPeer* const p = ComponentPeer::getPeer (i);
			if (p != nullptr)
				p->handleScreenSizeChange();
		}
	}
}

int Desktop::getNumDisplayMonitors() const noexcept
{
	return monitorCoordsClipped.size();
}

Rectangle<int> Desktop::getDisplayMonitorCoordinates (const int index, const bool clippedToWorkArea) const noexcept
{
	return clippedToWorkArea ? monitorCoordsClipped [index]
							 : monitorCoordsUnclipped [index];
}

RectangleList Desktop::getAllMonitorDisplayAreas (const bool clippedToWorkArea) const
{
	RectangleList rl;

	for (int i = 0; i < getNumDisplayMonitors(); ++i)
		rl.addWithoutMerging (getDisplayMonitorCoordinates (i, clippedToWorkArea));

	return rl;
}

Rectangle<int> Desktop::getMainMonitorArea (const bool clippedToWorkArea) const noexcept
{
	return getDisplayMonitorCoordinates (0, clippedToWorkArea);
}

Rectangle<int> Desktop::getMonitorAreaContaining (const Point<int>& position, const bool clippedToWorkArea) const
{
	Rectangle<int> best (getMainMonitorArea (clippedToWorkArea));
	double bestDistance = 1.0e10;

	for (int i = getNumDisplayMonitors(); --i >= 0;)
	{
		const Rectangle<int> rect (getDisplayMonitorCoordinates (i, clippedToWorkArea));

		if (rect.contains (position))
			return rect;

		const double distance = rect.getCentre().getDistanceFrom (position);

		if (distance < bestDistance)
		{
			bestDistance = distance;
			best = rect;
		}
	}

	return best;
}

int Desktop::getNumComponents() const noexcept
{
	return desktopComponents.size();
}

Component* Desktop::getComponent (const int index) const noexcept
{
	return desktopComponents [index];
}

Component* Desktop::findComponentAt (const Point<int>& screenPosition) const
{
	for (int i = desktopComponents.size(); --i >= 0;)
	{
		Component* const c = desktopComponents.getUnchecked(i);

		if (c->isVisible())
		{
			const Point<int> relative (c->getLocalPoint (nullptr, screenPosition));

			if (c->contains (relative))
				return c->getComponentAt (relative);
		}
	}

	return nullptr;
}

LookAndFeel& Desktop::getDefaultLookAndFeel() noexcept
{
	if (currentLookAndFeel == nullptr)
	{
		if (defaultLookAndFeel == nullptr)
			defaultLookAndFeel = new LookAndFeel();

		currentLookAndFeel = defaultLookAndFeel;
	}

	return *currentLookAndFeel;
}

void Desktop::setDefaultLookAndFeel (LookAndFeel* newDefaultLookAndFeel)
{
	currentLookAndFeel = newDefaultLookAndFeel;

	for (int i = getNumComponents(); --i >= 0;)
	{
		Component* const c = getComponent (i);

		if (c != nullptr)
			c->sendLookAndFeelChange();
	}
}

void Desktop::addDesktopComponent (Component* const c)
{
	jassert (c != nullptr);
	jassert (! desktopComponents.contains (c));
	desktopComponents.addIfNotAlreadyThere (c);
}

void Desktop::removeDesktopComponent (Component* const c)
{
	desktopComponents.removeValue (c);
}

void Desktop::componentBroughtToFront (Component* const c)
{
	const int index = desktopComponents.indexOf (c);
	jassert (index >= 0);

	if (index >= 0)
	{
		int newIndex = -1;

		if (! c->isAlwaysOnTop())
		{
			newIndex = desktopComponents.size();

			while (newIndex > 0 && desktopComponents.getUnchecked (newIndex - 1)->isAlwaysOnTop())
				--newIndex;

			--newIndex;
		}

		desktopComponents.move (index, newIndex);
	}
}

Point<int> Desktop::getMousePosition()
{
	return getInstance().getMainMouseSource().getScreenPosition();
}

Point<int> Desktop::getLastMouseDownPosition()
{
	return getInstance().getMainMouseSource().getLastMouseDownPosition();
}

int Desktop::getMouseButtonClickCounter()
{
	return getInstance().mouseClickCounter;
}

void Desktop::incrementMouseClickCounter() noexcept
{
	++mouseClickCounter;
}

int Desktop::getNumDraggingMouseSources() const noexcept
{
	int num = 0;
	for (int i = mouseSources.size(); --i >= 0;)
		if (mouseSources.getUnchecked(i)->isDragging())
			++num;

	return num;
}

MouseInputSource* Desktop::getDraggingMouseSource (int index) const noexcept
{
	int num = 0;
	for (int i = mouseSources.size(); --i >= 0;)
	{
		MouseInputSource* const mi = mouseSources.getUnchecked(i);

		if (mi->isDragging())
		{
			if (index == num)
				return mi;

			++num;
		}
	}

	return nullptr;
}

class MouseDragAutoRepeater  : public Timer
{
public:
	MouseDragAutoRepeater() {}

	void timerCallback()
	{
		Desktop& desktop = Desktop::getInstance();
		int numMiceDown = 0;

		for (int i = desktop.getNumMouseSources(); --i >= 0;)
		{
			MouseInputSource* const source = desktop.getMouseSource(i);
			if (source->isDragging())
			{
				source->triggerFakeMove();
				++numMiceDown;
			}
		}

		if (numMiceDown == 0)
			desktop.beginDragAutoRepeat (0);
	}

private:
	JUCE_DECLARE_NON_COPYABLE (MouseDragAutoRepeater);
};

void Desktop::beginDragAutoRepeat (const int interval)
{
	if (interval > 0)
	{
		if (dragRepeater == nullptr)
			dragRepeater = new MouseDragAutoRepeater();

		if (dragRepeater->getTimerInterval() != interval)
			dragRepeater->startTimer (interval);
	}
	else
	{
		dragRepeater = nullptr;
	}
}

void Desktop::addFocusChangeListener (FocusChangeListener* const listener)
{
	focusListeners.add (listener);
}

void Desktop::removeFocusChangeListener (FocusChangeListener* const listener)
{
	focusListeners.remove (listener);
}

void Desktop::triggerFocusCallback()
{
	triggerAsyncUpdate();
}

void Desktop::handleAsyncUpdate()
{
	// The component may be deleted during this operation, but we'll use a SafePointer rather than a
	// BailOutChecker so that any remaining listeners will still get a callback (with a null pointer).
	WeakReference<Component> currentFocus (Component::getCurrentlyFocusedComponent());
	focusListeners.call (&FocusChangeListener::globalFocusChanged, currentFocus);
}

void Desktop::resetTimer()
{
	if (mouseListeners.size() == 0)
		stopTimer();
	else
		startTimer (100);

	lastFakeMouseMove = getMousePosition();
}

ListenerList <MouseListener>& Desktop::getMouseListeners()
{
	resetTimer();
	return mouseListeners;
}

void Desktop::addGlobalMouseListener (MouseListener* const listener)
{
	mouseListeners.add (listener);
	resetTimer();
}

void Desktop::removeGlobalMouseListener (MouseListener* const listener)
{
	mouseListeners.remove (listener);
	resetTimer();
}

void Desktop::timerCallback()
{
	if (lastFakeMouseMove != getMousePosition())
		sendMouseMove();
}

void Desktop::sendMouseMove()
{
	if (! mouseListeners.isEmpty())
	{
		startTimer (20);

		lastFakeMouseMove = getMousePosition();

		Component* const target = findComponentAt (lastFakeMouseMove);

		if (target != nullptr)
		{
			Component::BailOutChecker checker (target);
			const Point<int> pos (target->getLocalPoint (nullptr, lastFakeMouseMove));
			const Time now (Time::getCurrentTime());

			const MouseEvent me (getMainMouseSource(), pos, ModifierKeys::getCurrentModifiers(),
								 target, target, now, pos, now, 0, false);

			if (me.mods.isAnyMouseButtonDown())
				mouseListeners.callChecked (checker, &MouseListener::mouseDrag, me);
			else
				mouseListeners.callChecked (checker, &MouseListener::mouseMove, me);
		}
	}
}

void Desktop::setKioskModeComponent (Component* componentToUse, const bool allowMenusAndBars)
{
	if (kioskModeComponent != componentToUse)
	{
		// agh! Don't delete or remove a component from the desktop while it's still the kiosk component!
		jassert (kioskModeComponent == nullptr || ComponentPeer::getPeerFor (kioskModeComponent) != nullptr);

		if (kioskModeComponent != nullptr)
		{
			setKioskComponent (kioskModeComponent, false, allowMenusAndBars);

			kioskModeComponent->setBounds (kioskComponentOriginalBounds);
		}

		kioskModeComponent = componentToUse;

		if (kioskModeComponent != nullptr)
		{
			// Only components that are already on the desktop can be put into kiosk mode!
			jassert (ComponentPeer::getPeerFor (kioskModeComponent) != nullptr);

			kioskComponentOriginalBounds = kioskModeComponent->getBounds();

			setKioskComponent (kioskModeComponent, true, allowMenusAndBars);
		}
	}
}

void Desktop::setOrientationsEnabled (const int newOrientations)
{
	// Dodgy set of flags being passed here! Make sure you specify at least one permitted orientation.
	jassert (newOrientations != 0 && (newOrientations & ~allOrientations) == 0);

	allowedOrientations = newOrientations;
}

bool Desktop::isOrientationEnabled (const DisplayOrientation orientation) const noexcept
{
	// Make sure you only pass one valid flag in here...
	jassert (orientation == upright || orientation == upsideDown || orientation == rotatedClockwise || orientation ==  rotatedAntiClockwise);

	return (allowedOrientations & orientation) != 0;
}

/*** End of inlined file: juce_Desktop.cpp ***/


/*** Start of inlined file: juce_ModalComponentManager.cpp ***/
class ModalComponentManager::ModalItem  : public ComponentMovementWatcher
{
public:
	ModalItem (Component* const comp, const bool autoDelete_)
		: ComponentMovementWatcher (comp),
		  component (comp), returnValue (0),
		  isActive (true), autoDelete (autoDelete_)
	{
		jassert (comp != nullptr);
	}

	void componentMovedOrResized (bool, bool) {}

	void componentPeerChanged()
	{
		if (! component->isShowing())
			cancel();
	}

	void componentVisibilityChanged()
	{
		if (! component->isShowing())
			cancel();
	}

	void componentBeingDeleted (Component& comp)
	{
		ComponentMovementWatcher::componentBeingDeleted (comp);

		if (component == &comp || comp.isParentOf (component))
		{
			autoDelete = false;
			cancel();
		}
	}

	void cancel()
	{
		if (isActive)
		{
			isActive = false;
			ModalComponentManager::getInstance()->triggerAsyncUpdate();
		}
	}

	Component* component;
	OwnedArray<Callback> callbacks;
	int returnValue;
	bool isActive, autoDelete;

private:
	JUCE_DECLARE_NON_COPYABLE (ModalItem);
};

ModalComponentManager::ModalComponentManager()
{
}

ModalComponentManager::~ModalComponentManager()
{
	clearSingletonInstance();
}

juce_ImplementSingleton_SingleThreaded (ModalComponentManager);

void ModalComponentManager::startModal (Component* component, bool autoDelete)
{
	if (component != nullptr)
		stack.add (new ModalItem (component, autoDelete));
}

void ModalComponentManager::attachCallback (Component* component, Callback* callback)
{
	if (callback != nullptr)
	{
		ScopedPointer<Callback> callbackDeleter (callback);

		for (int i = stack.size(); --i >= 0;)
		{
			ModalItem* const item = stack.getUnchecked(i);

			if (item->component == component)
			{
				item->callbacks.add (callback);
				callbackDeleter.release();
				break;
			}
		}
	}
}

void ModalComponentManager::endModal (Component* component)
{
	for (int i = stack.size(); --i >= 0;)
	{
		ModalItem* const item = stack.getUnchecked(i);

		if (item->component == component)
			item->cancel();
	}
}

void ModalComponentManager::endModal (Component* component, int returnValue)
{
	for (int i = stack.size(); --i >= 0;)
	{
		ModalItem* const item = stack.getUnchecked(i);

		if (item->component == component)
		{
			item->returnValue = returnValue;
			item->cancel();
		}
	}
}

int ModalComponentManager::getNumModalComponents() const
{
	int n = 0;
	for (int i = 0; i < stack.size(); ++i)
		if (stack.getUnchecked(i)->isActive)
			++n;

	return n;
}

Component* ModalComponentManager::getModalComponent (const int index) const
{
	int n = 0;
	for (int i = stack.size(); --i >= 0;)
	{
		const ModalItem* const item = stack.getUnchecked(i);
		if (item->isActive)
			if (n++ == index)
				return item->component;
	}

	return nullptr;
}

bool ModalComponentManager::isModal (Component* const comp) const
{
	for (int i = stack.size(); --i >= 0;)
	{
		const ModalItem* const item = stack.getUnchecked(i);
		if (item->isActive && item->component == comp)
			return true;
	}

	return false;
}

bool ModalComponentManager::isFrontModalComponent (Component* const comp) const
{
	return comp == getModalComponent (0);
}

void ModalComponentManager::handleAsyncUpdate()
{
	for (int i = stack.size(); --i >= 0;)
	{
		const ModalItem* const item = stack.getUnchecked(i);

		if (! item->isActive)
		{
			ScopedPointer<ModalItem> deleter (stack.removeAndReturn (i));
			Component::SafePointer<Component> compToDelete (item->autoDelete ? item->component : nullptr);

			for (int j = item->callbacks.size(); --j >= 0;)
				item->callbacks.getUnchecked(j)->modalStateFinished (item->returnValue);

			compToDelete.deleteAndZero();
		}
	}
}

void ModalComponentManager::bringModalComponentsToFront (bool topOneShouldGrabFocus)
{
	ComponentPeer* lastOne = nullptr;

	for (int i = 0; i < getNumModalComponents(); ++i)
	{
		Component* const c = getModalComponent (i);

		if (c == nullptr)
			break;

		ComponentPeer* peer = c->getPeer();

		if (peer != nullptr && peer != lastOne)
		{
			if (lastOne == nullptr)
			{
				peer->toFront (topOneShouldGrabFocus);

				if (topOneShouldGrabFocus)
					peer->grabFocus();
			}
			else
				peer->toBehind (lastOne);

			lastOne = peer;
		}
	}
}

#if JUCE_MODAL_LOOPS_PERMITTED
class ModalComponentManager::ReturnValueRetriever     : public ModalComponentManager::Callback
{
public:
	ReturnValueRetriever (int& value_, bool& finished_) : value (value_), finished (finished_) {}

	void modalStateFinished (int returnValue)
	{
		finished = true;
		value = returnValue;
	}

private:
	int& value;
	bool& finished;

	JUCE_DECLARE_NON_COPYABLE (ReturnValueRetriever);
};

int ModalComponentManager::runEventLoopForCurrentComponent()
{
	// This can only be run from the message thread!
	jassert (MessageManager::getInstance()->isThisTheMessageThread());

	Component* currentlyModal = getModalComponent (0);

	if (currentlyModal == nullptr)
		return 0;

	WeakReference<Component> prevFocused (Component::getCurrentlyFocusedComponent());

	int returnValue = 0;
	bool finished = false;
	attachCallback (currentlyModal, new ReturnValueRetriever (returnValue, finished));

	JUCE_TRY
	{
		while (! finished)
		{
			if  (! MessageManager::getInstance()->runDispatchLoopUntil (20))
				break;
		}
	}
	JUCE_CATCH_EXCEPTION

	if (prevFocused != nullptr)
		prevFocused->grabKeyboardFocus();

	return returnValue;
}
#endif

/*** End of inlined file: juce_ModalComponentManager.cpp ***/


/*** Start of inlined file: juce_ComponentDragger.cpp ***/
ComponentDragger::ComponentDragger() {}
ComponentDragger::~ComponentDragger() {}

void ComponentDragger::startDraggingComponent (Component* const componentToDrag, const MouseEvent& e)
{
	jassert (componentToDrag != nullptr);
	jassert (e.mods.isAnyMouseButtonDown()); // The event has to be a drag event!

	if (componentToDrag != nullptr)
		mouseDownWithinTarget = e.getEventRelativeTo (componentToDrag).getMouseDownPosition();
}

void ComponentDragger::dragComponent (Component* const componentToDrag, const MouseEvent& e,
									  ComponentBoundsConstrainer* const constrainer)
{
	jassert (componentToDrag != nullptr);
	jassert (e.mods.isAnyMouseButtonDown()); // The event has to be a drag event!

	if (componentToDrag != nullptr)
	{
		Rectangle<int> bounds (componentToDrag->getBounds());

		// If the component is a window, multiple mouse events can get queued while it's in the same position,
		// so their coordinates become wrong after the first one moves the window, so in that case, we'll use
		// the current mouse position instead of the one that the event contains...
		if (componentToDrag->isOnDesktop())
			bounds += componentToDrag->getMouseXYRelative() - mouseDownWithinTarget;
		else
			bounds += e.getEventRelativeTo (componentToDrag).getPosition() - mouseDownWithinTarget;

		if (constrainer != nullptr)
			constrainer->setBoundsForComponent (componentToDrag, bounds, false, false, false, false);
		else
			componentToDrag->setBounds (bounds);
	}
}

/*** End of inlined file: juce_ComponentDragger.cpp ***/


/*** Start of inlined file: juce_DragAndDropContainer.cpp ***/
bool juce_performDragDropFiles (const StringArray&, const bool copyFiles, bool& shouldStop);
bool juce_performDragDropText (const String&, bool& shouldStop);

class DragImageComponent  : public Component,
							public Timer
{
public:
	DragImageComponent (const Image& im,
						const var& desc,
						Component* const sourceComponent,
						Component* const mouseDragSource_,
						DragAndDropContainer& owner_,
						const Point<int>& imageOffset_)
		: sourceDetails (desc, sourceComponent, Point<int>()),
		  image (im),
		  owner (owner_),
		  mouseDragSource (mouseDragSource_),
		  imageOffset (imageOffset_),
		  hasCheckedForExternalDrag (false),
		  isDoingExternalDrag (false)
	{
		setSize (im.getWidth(), im.getHeight());

		if (mouseDragSource == nullptr)
			mouseDragSource = sourceComponent;

		mouseDragSource->addMouseListener (this, false);

		startTimer (200);

		setInterceptsMouseClicks (false, false);
		setAlwaysOnTop (true);
	}

	~DragImageComponent()
	{
		if (owner.dragImageComponent == this)
			owner.dragImageComponent.release();

		if (mouseDragSource != nullptr)
		{
			mouseDragSource->removeMouseListener (this);

			DragAndDropTarget* const current = getCurrentlyOver();

			if (current != nullptr && current->isInterestedInDragSource (sourceDetails))
				current->itemDragExit (sourceDetails);
		}
	}

	void paint (Graphics& g)
	{
		if (isOpaque())
			g.fillAll (Colours::white);

		g.setOpacity (1.0f);
		g.drawImageAt (image, 0, 0);
	}

	void mouseUp (const MouseEvent& e)
	{
		if (e.originalComponent != this)
		{
			if (mouseDragSource != nullptr)
				mouseDragSource->removeMouseListener (this);

			// (note: use a local copy of this in case the callback runs
			// a modal loop and deletes this object before the method completes)
			DragAndDropTarget::SourceDetails details (sourceDetails);
			DragAndDropTarget* finalTarget = nullptr;

			if (! isDoingExternalDrag)
			{
				const bool wasVisible = isVisible();
				setVisible (false);
				finalTarget = findTarget (e.getScreenPosition(), details.localPosition);

				if (wasVisible) // fade the component and remove it - it'll be deleted later by the timer callback
					dismissWithAnimation (finalTarget == nullptr);
			}

			if (getParentComponent() != nullptr)
				getParentComponent()->removeChildComponent (this);

			if (finalTarget != nullptr)
			{
				currentlyOverComp = nullptr;
				finalTarget->itemDropped (details);
			}

			// careful - this object could now be deleted..
		}
	}

	void mouseDrag (const MouseEvent& e)
	{
		if (e.originalComponent != this)
			updateLocation (true, e.getScreenPosition());
	}

	void updateLocation (const bool canDoExternalDrag, const Point<int>& screenPos)
	{
		DragAndDropTarget::SourceDetails details (sourceDetails);

		setNewScreenPos (screenPos);

		DragAndDropTarget* const newTarget = findTarget (screenPos, details.localPosition);
		Component* newTargetComp = dynamic_cast <Component*> (newTarget);

		setVisible (newTarget == nullptr || newTarget->shouldDrawDragImageWhenOver());

		if (newTargetComp != currentlyOverComp)
		{
			DragAndDropTarget* const lastTarget = getCurrentlyOver();

			if (lastTarget != nullptr && details.sourceComponent != nullptr
				  && lastTarget->isInterestedInDragSource (details))
				lastTarget->itemDragExit (details);

			currentlyOverComp = newTargetComp;

			if (newTarget != nullptr
				  && newTarget->isInterestedInDragSource (details))
				newTarget->itemDragEnter (details);
		}

		sendDragMove (details);

		if (canDoExternalDrag && getCurrentlyOver() == nullptr)
			checkForExternalDrag (details, screenPos);
	}

	void timerCallback()
	{
		if (sourceDetails.sourceComponent == nullptr)
		{
			delete this;
		}
		else if (! isMouseButtonDownAnywhere())
		{
			if (mouseDragSource != nullptr)
				mouseDragSource->removeMouseListener (this);

			delete this;
		}
	}

private:
	DragAndDropTarget::SourceDetails sourceDetails;
	Image image;
	DragAndDropContainer& owner;
	WeakReference<Component> mouseDragSource, currentlyOverComp;
	const Point<int> imageOffset;
	bool hasCheckedForExternalDrag, isDoingExternalDrag;

	DragAndDropTarget* getCurrentlyOver() const noexcept
	{
		return dynamic_cast <DragAndDropTarget*> (currentlyOverComp.get());
	}

	DragAndDropTarget* findTarget (const Point<int>& screenPos, Point<int>& relativePos) const
	{
		Component* hit = getParentComponent();

		if (hit == nullptr)
			hit = Desktop::getInstance().findComponentAt (screenPos);
		else
			hit = hit->getComponentAt (hit->getLocalPoint (nullptr, screenPos));

		// (note: use a local copy of this in case the callback runs
		// a modal loop and deletes this object before the method completes)
		const DragAndDropTarget::SourceDetails details (sourceDetails);

		while (hit != nullptr)
		{
			DragAndDropTarget* const ddt = dynamic_cast <DragAndDropTarget*> (hit);

			if (ddt != nullptr && ddt->isInterestedInDragSource (details))
			{
				relativePos = hit->getLocalPoint (nullptr, screenPos);
				return ddt;
			}

			hit = hit->getParentComponent();
		}

		return nullptr;
	}

	void setNewScreenPos (const Point<int>& screenPos)
	{
		Point<int> newPos (screenPos - imageOffset);

		if (getParentComponent() != nullptr)
			newPos = getParentComponent()->getLocalPoint (nullptr, newPos);

		setTopLeftPosition (newPos);
	}

	void sendDragMove (DragAndDropTarget::SourceDetails& details) const
	{
		DragAndDropTarget* const target = getCurrentlyOver();

		if (target != nullptr && target->isInterestedInDragSource (details))
			target->itemDragMove (details);
	}

	void checkForExternalDrag (DragAndDropTarget::SourceDetails& details, const Point<int>& screenPos)
	{
		if (! hasCheckedForExternalDrag)
		{
			if (Desktop::getInstance().findComponentAt (screenPos) == nullptr)
			{
				hasCheckedForExternalDrag = true;
				StringArray files;
				bool canMoveFiles = false;

				if (owner.shouldDropFilesWhenDraggedExternally (details, files, canMoveFiles)
					 && files.size() > 0)
				{
					WeakReference<Component> thisWeakRef (this);
					setVisible (false);
					isDoingExternalDrag = true;

					if (ModifierKeys::getCurrentModifiersRealtime().isAnyMouseButtonDown())
						DragAndDropContainer::performExternalDragDropOfFiles (files, canMoveFiles);

					delete thisWeakRef.get();
					return;
				}
			}
		}
	}

	void dismissWithAnimation (const bool shouldSnapBack)
	{
		setVisible (true);
		ComponentAnimator& animator = Desktop::getInstance().getAnimator();

		if (shouldSnapBack && sourceDetails.sourceComponent != nullptr)
		{
			const Point<int> target (sourceDetails.sourceComponent->localPointToGlobal (sourceDetails.sourceComponent->getLocalBounds().getCentre()));
			const Point<int> ourCentre (localPointToGlobal (getLocalBounds().getCentre()));

			animator.animateComponent (this,
									   getBounds() + (target - ourCentre),
									   0.0f, 120,
									   true, 1.0, 1.0);
		}
		else
		{
			animator.fadeOut (this, 120);
		}
	}

	JUCE_DECLARE_NON_COPYABLE (DragImageComponent);
};

DragAndDropContainer::DragAndDropContainer()
{
}

DragAndDropContainer::~DragAndDropContainer()
{
	dragImageComponent = nullptr;
}

void DragAndDropContainer::startDragging (const var& sourceDescription,
										  Component* sourceComponent,
										  const Image& dragImage_,
										  const bool allowDraggingToExternalWindows,
										  const Point<int>* imageOffsetFromMouse)
{
	Image dragImage (dragImage_);

	if (dragImageComponent == nullptr)
	{
		Component* const thisComp = dynamic_cast <Component*> (this);

		if (thisComp == nullptr)
		{
			jassertfalse;   // Your DragAndDropContainer needs to be a Component!
			return;
		}

		MouseInputSource* draggingSource = Desktop::getInstance().getDraggingMouseSource (0);

		if (draggingSource == nullptr || ! draggingSource->isDragging())
		{
			jassertfalse;   // You must call startDragging() from within a mouseDown or mouseDrag callback!
			return;
		}

		const Point<int> lastMouseDown (Desktop::getLastMouseDownPosition());
		Point<int> imageOffset;

		if (dragImage.isNull())
		{
			dragImage = sourceComponent->createComponentSnapshot (sourceComponent->getLocalBounds())
							.convertedToFormat (Image::ARGB);

			dragImage.multiplyAllAlphas (0.6f);

			const int lo = 150;
			const int hi = 400;

			Point<int> relPos (sourceComponent->getLocalPoint (nullptr, lastMouseDown));
			Point<int> clipped (dragImage.getBounds().getConstrainedPoint (relPos));
			Random random;

			for (int y = dragImage.getHeight(); --y >= 0;)
			{
				const double dy = (y - clipped.getY()) * (y - clipped.getY());

				for (int x = dragImage.getWidth(); --x >= 0;)
				{
					const int dx = x - clipped.getX();
					const int distance = roundToInt (std::sqrt (dx * dx + dy));

					if (distance > lo)
					{
						const float alpha = (distance > hi) ? 0
															: (hi - distance) / (float) (hi - lo)
															   + random.nextFloat() * 0.008f;

						dragImage.multiplyAlphaAt (x, y, alpha);
					}
				}
			}

			imageOffset = clipped;
		}
		else
		{
			if (imageOffsetFromMouse == nullptr)
				imageOffset = dragImage.getBounds().getCentre();
			else
				imageOffset = dragImage.getBounds().getConstrainedPoint (-*imageOffsetFromMouse);
		}

		dragImageComponent = new DragImageComponent (dragImage, sourceDescription, sourceComponent,
													 draggingSource->getComponentUnderMouse(), *this, imageOffset);

		currentDragDesc = sourceDescription;

		if (allowDraggingToExternalWindows)
		{
			if (! Desktop::canUseSemiTransparentWindows())
				dragImageComponent->setOpaque (true);

			dragImageComponent->addToDesktop (ComponentPeer::windowIgnoresMouseClicks
											   | ComponentPeer::windowIsTemporary
											   | ComponentPeer::windowIgnoresKeyPresses);
		}
		else
			thisComp->addChildComponent (dragImageComponent);

		static_cast <DragImageComponent*> (dragImageComponent.get())->updateLocation (false, lastMouseDown);
		dragImageComponent->setVisible (true);

	   #if JUCE_WINDOWS
		// Under heavy load, the layered window's paint callback can often be lost by the OS,
		// so forcing a repaint at least once makes sure that the window becomes visible..
		ComponentPeer* const peer = dragImageComponent->getPeer();
		if (peer != nullptr)
			peer->performAnyPendingRepaintsNow();
	   #endif
	}
}

bool DragAndDropContainer::isDragAndDropActive() const
{
	return dragImageComponent != nullptr;
}

String DragAndDropContainer::getCurrentDragDescription() const
{
	return dragImageComponent != nullptr ? currentDragDesc
										 : String::empty;
}

DragAndDropContainer* DragAndDropContainer::findParentDragContainerFor (Component* c)
{
	return c == nullptr ? nullptr : c->findParentComponentOfClass ((DragAndDropContainer*) nullptr);
}

bool DragAndDropContainer::shouldDropFilesWhenDraggedExternally (const DragAndDropTarget::SourceDetails&, StringArray&, bool&)
{
	return false;
}

DragAndDropTarget::SourceDetails::SourceDetails (const var& description_, Component* sourceComponent_, const Point<int>& localPosition_) noexcept
	: description (description_),
	  sourceComponent (sourceComponent_),
	  localPosition (localPosition_)
{
}

void DragAndDropTarget::itemDragEnter (const SourceDetails&)  {}
void DragAndDropTarget::itemDragMove  (const SourceDetails&)  {}
void DragAndDropTarget::itemDragExit  (const SourceDetails&)  {}
bool DragAndDropTarget::shouldDrawDragImageWhenOver()         { return true; }

void FileDragAndDropTarget::fileDragEnter (const StringArray&, int, int)  {}
void FileDragAndDropTarget::fileDragMove  (const StringArray&, int, int)  {}
void FileDragAndDropTarget::fileDragExit  (const StringArray&)            {}

/*** End of inlined file: juce_DragAndDropContainer.cpp ***/


/*** Start of inlined file: juce_MouseCursor.cpp ***/
class MouseCursor::SharedCursorHandle
{
public:
	explicit SharedCursorHandle (const MouseCursor::StandardCursorType type)
		: handle (createStandardMouseCursor (type)),
		  refCount (1),
		  standardType (type),
		  isStandard (true)
	{
	}

	SharedCursorHandle (const Image& image, const int hotSpotX, const int hotSpotY)
		: handle (createMouseCursorFromImage (image, hotSpotX, hotSpotY)),
		  refCount (1),
		  standardType (MouseCursor::NormalCursor),
		  isStandard (false)
	{
	}

	~SharedCursorHandle()
	{
		deleteMouseCursor (handle, isStandard);
	}

	static SharedCursorHandle* createStandard (const MouseCursor::StandardCursorType type)
	{
		const SpinLock::ScopedLockType sl (lock);

		for (int i = 0; i < getCursors().size(); ++i)
		{
			SharedCursorHandle* const sc = getCursors().getUnchecked(i);

			if (sc->standardType == type)
				return sc->retain();
		}

		SharedCursorHandle* const sc = new SharedCursorHandle (type);
		getCursors().add (sc);
		return sc;
	}

	SharedCursorHandle* retain() noexcept
	{
		++refCount;
		return this;
	}

	void release()
	{
		if (--refCount == 0)
		{
			if (isStandard)
			{
				const SpinLock::ScopedLockType sl (lock);
				getCursors().removeValue (this);
			}

			delete this;
		}
	}

	void* getHandle() const noexcept        { return handle; }

private:

	void* const handle;
	Atomic <int> refCount;
	const MouseCursor::StandardCursorType standardType;
	const bool isStandard;
	static SpinLock lock;

	static Array <SharedCursorHandle*>& getCursors()
	{
		static Array <SharedCursorHandle*> cursors;
		return cursors;
	}

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (SharedCursorHandle);
};

SpinLock MouseCursor::SharedCursorHandle::lock;

MouseCursor::MouseCursor()
	: cursorHandle (nullptr)
{
}

MouseCursor::MouseCursor (const StandardCursorType type)
	: cursorHandle (type != MouseCursor::NormalCursor ? SharedCursorHandle::createStandard (type) : 0)
{
}

MouseCursor::MouseCursor (const Image& image, const int hotSpotX, const int hotSpotY)
	: cursorHandle (new SharedCursorHandle (image, hotSpotX, hotSpotY))
{
}

MouseCursor::MouseCursor (const MouseCursor& other)
	: cursorHandle (other.cursorHandle == nullptr ? nullptr : other.cursorHandle->retain())
{
}

MouseCursor::~MouseCursor()
{
	if (cursorHandle != nullptr)
		cursorHandle->release();
}

MouseCursor& MouseCursor::operator= (const MouseCursor& other)
{
	if (other.cursorHandle != nullptr)
		other.cursorHandle->retain();

	if (cursorHandle != nullptr)
		cursorHandle->release();

	cursorHandle = other.cursorHandle;
	return *this;
}

#if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
MouseCursor::MouseCursor (MouseCursor&& other) noexcept
	: cursorHandle (other.cursorHandle)
{
	other.cursorHandle = nullptr;
}

MouseCursor& MouseCursor::operator= (MouseCursor&& other) noexcept
{
	std::swap (cursorHandle, other.cursorHandle);
	return *this;
}
#endif

bool MouseCursor::operator== (const MouseCursor& other) const noexcept
{
	return getHandle() == other.getHandle();
}

bool MouseCursor::operator!= (const MouseCursor& other) const noexcept
{
	return getHandle() != other.getHandle();
}

void* MouseCursor::getHandle() const noexcept
{
	return cursorHandle != nullptr ? cursorHandle->getHandle() : nullptr;
}

void MouseCursor::showWaitCursor()
{
	Desktop::getInstance().getMainMouseSource().showMouseCursor (MouseCursor::WaitCursor);
}

void MouseCursor::hideWaitCursor()
{
	Desktop::getInstance().getMainMouseSource().revealCursor();
}

/*** End of inlined file: juce_MouseCursor.cpp ***/


/*** Start of inlined file: juce_MouseEvent.cpp ***/
MouseEvent::MouseEvent (MouseInputSource& source_,
						const Point<int>& position,
						const ModifierKeys& mods_,
						Component* const eventComponent_,
						Component* const originator,
						const Time& eventTime_,
						const Point<int> mouseDownPos_,
						const Time& mouseDownTime_,
						const int numberOfClicks_,
						const bool mouseWasDragged) noexcept
	: x (position.x),
	  y (position.y),
	  mods (mods_),
	  eventComponent (eventComponent_),
	  originalComponent (originator),
	  eventTime (eventTime_),
	  source (source_),
	  mouseDownPos (mouseDownPos_),
	  mouseDownTime (mouseDownTime_),
	  numberOfClicks ((uint8) numberOfClicks_),
	  wasMovedSinceMouseDown ((uint8) (mouseWasDragged ? 1 : 0))
{
}

MouseEvent::~MouseEvent() noexcept
{
}

MouseEvent MouseEvent::getEventRelativeTo (Component* const otherComponent) const noexcept
{
	jassert (otherComponent != nullptr);

	return MouseEvent (source, otherComponent->getLocalPoint (eventComponent, getPosition()),
					   mods, otherComponent, originalComponent, eventTime,
					   otherComponent->getLocalPoint (eventComponent, mouseDownPos),
					   mouseDownTime, numberOfClicks, wasMovedSinceMouseDown != 0);
}

MouseEvent MouseEvent::withNewPosition (const Point<int>& newPosition) const noexcept
{
	return MouseEvent (source, newPosition, mods, eventComponent, originalComponent,
					   eventTime, mouseDownPos, mouseDownTime,
					   numberOfClicks, wasMovedSinceMouseDown != 0);
}

bool MouseEvent::mouseWasClicked() const noexcept
{
	return wasMovedSinceMouseDown == 0;
}

int MouseEvent::getLengthOfMousePress() const noexcept
{
	if (mouseDownTime.toMilliseconds() > 0)
		return jmax (0, (int) (eventTime - mouseDownTime).inMilliseconds());

	return 0;
}

Point<int> MouseEvent::getPosition() const noexcept             { return Point<int> (x, y); }
Point<int> MouseEvent::getScreenPosition() const                { return eventComponent->localPointToGlobal (getPosition()); }

Point<int> MouseEvent::getMouseDownPosition() const noexcept    { return mouseDownPos; }
Point<int> MouseEvent::getMouseDownScreenPosition() const       { return eventComponent->localPointToGlobal (mouseDownPos); }

Point<int> MouseEvent::getOffsetFromDragStart() const noexcept  { return getPosition() - mouseDownPos; }
int MouseEvent::getDistanceFromDragStart() const noexcept       { return mouseDownPos.getDistanceFrom (getPosition()); }

int MouseEvent::getMouseDownX() const noexcept                  { return mouseDownPos.x; }
int MouseEvent::getMouseDownY() const noexcept                  { return mouseDownPos.y; }

int MouseEvent::getDistanceFromDragStartX() const noexcept      { return x - mouseDownPos.x; }
int MouseEvent::getDistanceFromDragStartY() const noexcept      { return y - mouseDownPos.y; }

int MouseEvent::getScreenX() const                              { return getScreenPosition().x; }
int MouseEvent::getScreenY() const                              { return getScreenPosition().y; }

int MouseEvent::getMouseDownScreenX() const                     { return getMouseDownScreenPosition().x; }
int MouseEvent::getMouseDownScreenY() const                     { return getMouseDownScreenPosition().y; }

static int doubleClickTimeOutMs = 400;

int MouseEvent::getDoubleClickTimeout() noexcept                        { return doubleClickTimeOutMs; }
void MouseEvent::setDoubleClickTimeout (const int newTime) noexcept     { doubleClickTimeOutMs = newTime; }

/*** End of inlined file: juce_MouseEvent.cpp ***/


/*** Start of inlined file: juce_MouseInputSource.cpp ***/
class MouseInputSourceInternal   : public AsyncUpdater
{
public:

	MouseInputSourceInternal (MouseInputSource& source_, const int index_, const bool isMouseDevice_)
		: index (index_), isMouseDevice (isMouseDevice_), source (source_), lastPeer (nullptr),
		  isUnboundedMouseModeOn (false), isCursorVisibleUntilOffscreen (false), currentCursorHandle (nullptr),
		  mouseEventCounter (0)
	{
	}

	bool isDragging() const noexcept
	{
		return buttonState.isAnyMouseButtonDown();
	}

	Component* getComponentUnderMouse() const
	{
		return static_cast <Component*> (componentUnderMouse);
	}

	ModifierKeys getCurrentModifiers() const
	{
		return ModifierKeys::getCurrentModifiers().withoutMouseButtons().withFlags (buttonState.getRawFlags());
	}

	ComponentPeer* getPeer()
	{
		if (! ComponentPeer::isValidPeer (lastPeer))
			lastPeer = nullptr;

		return lastPeer;
	}

	Component* findComponentAt (const Point<int>& screenPos)
	{
		ComponentPeer* const peer = getPeer();

		if (peer != nullptr)
		{
			Component* const comp = peer->getComponent();
			const Point<int> relativePos (comp->getLocalPoint (nullptr, screenPos));

			// (the contains() call is needed to test for overlapping desktop windows)
			if (comp->contains (relativePos))
				return comp->getComponentAt (relativePos);
		}

		return nullptr;
	}

	Point<int> getScreenPosition() const
	{
		// This needs to return the live position if possible, but it mustn't update the lastScreenPos
		// value, because that can cause continuity problems.
		return unboundedMouseOffset + (isMouseDevice ? MouseInputSource::getCurrentMousePosition()
													 : lastScreenPos);
	}

	void sendMouseEnter (Component* const comp, const Point<int>& screenPos, const Time& time)
	{
		//DBG ("Mouse " + String (source.getIndex()) + " enter: " + comp->getLocalPoint (nullptr, screenPos).toString() + " - Comp: " + String::toHexString ((int) comp));
		comp->internalMouseEnter (source, comp->getLocalPoint (nullptr, screenPos), time);
	}

	void sendMouseExit (Component* const comp, const Point<int>& screenPos, const Time& time)
	{
		//DBG ("Mouse " + String (source.getIndex()) + " exit: " + comp->getLocalPoint (nullptr, screenPos).toString() + " - Comp: " + String::toHexString ((int) comp));
		comp->internalMouseExit (source, comp->getLocalPoint (nullptr, screenPos), time);
	}

	void sendMouseMove (Component* const comp, const Point<int>& screenPos, const Time& time)
	{
		//DBG ("Mouse " + String (source.getIndex()) + " move: " + comp->getLocalPoint (nullptr, screenPos).toString() + " - Comp: " + String::toHexString ((int) comp));
		comp->internalMouseMove (source, comp->getLocalPoint (nullptr, screenPos), time);
	}

	void sendMouseDown (Component* const comp, const Point<int>& screenPos, const Time& time)
	{
		//DBG ("Mouse " + String (source.getIndex()) + " down: " + comp->getLocalPoint (nullptr, screenPos).toString() + " - Comp: " + String::toHexString ((int) comp));
		comp->internalMouseDown (source, comp->getLocalPoint (nullptr, screenPos), time);
	}

	void sendMouseDrag (Component* const comp, const Point<int>& screenPos, const Time& time)
	{
		//DBG ("Mouse " + String (source.getIndex()) + " drag: " + comp->getLocalPoint (nullptr, screenPos).toString() + " - Comp: " + String::toHexString ((int) comp));
		comp->internalMouseDrag (source, comp->getLocalPoint (nullptr, screenPos), time);
	}

	void sendMouseUp (Component* const comp, const Point<int>& screenPos, const Time& time, const ModifierKeys& oldMods)
	{
		//DBG ("Mouse " + String (source.getIndex()) + " up: " + comp->getLocalPoint (nullptr, screenPos).toString() + " - Comp: " + String::toHexString ((int) comp));
		comp->internalMouseUp (source, comp->getLocalPoint (nullptr, screenPos), time, oldMods);
	}

	void sendMouseWheel (Component* const comp, const Point<int>& screenPos, const Time& time, float x, float y)
	{
		//DBG ("Mouse " + String (source.getIndex()) + " wheel: " + comp->getLocalPoint (nullptr, screenPos).toString() + " - Comp: " + String::toHexString ((int) comp));
		comp->internalMouseWheel (source, comp->getLocalPoint (nullptr, screenPos), time, x, y);
	}

	// (returns true if the button change caused a modal event loop)
	bool setButtons (const Point<int>& screenPos, const Time& time, const ModifierKeys& newButtonState)
	{
		if (buttonState == newButtonState)
			return false;

		// (avoid sending a spurious mouse-drag when we receive a mouse-up)
		if (! (isDragging() && ! newButtonState.isAnyMouseButtonDown()))
			setScreenPos (screenPos, time, false);

		// (ignore secondary clicks when there's already a button down)
		if (buttonState.isAnyMouseButtonDown() == newButtonState.isAnyMouseButtonDown())
		{
			buttonState = newButtonState;
			return false;
		}

		const int lastCounter = mouseEventCounter;

		if (buttonState.isAnyMouseButtonDown())
		{
			Component* const current = getComponentUnderMouse();

			if (current != nullptr)
			{
				const ModifierKeys oldMods (getCurrentModifiers());
				buttonState = newButtonState; // must change this before calling sendMouseUp, in case it runs a modal loop

				sendMouseUp (current, screenPos + unboundedMouseOffset, time, oldMods);
			}

			enableUnboundedMouseMovement (false, false);
		}

		buttonState = newButtonState;

		if (buttonState.isAnyMouseButtonDown())
		{
			Desktop::getInstance().incrementMouseClickCounter();

			Component* const current = getComponentUnderMouse();

			if (current != nullptr)
			{
				registerMouseDown (screenPos, time, current, buttonState);
				sendMouseDown (current, screenPos, time);
			}
		}

		return lastCounter != mouseEventCounter;
	}

	void setComponentUnderMouse (Component* const newComponent, const Point<int>& screenPos, const Time& time)
	{
		Component* current = getComponentUnderMouse();

		if (newComponent != current)
		{
			WeakReference<Component> safeNewComp (newComponent);
			const ModifierKeys originalButtonState (buttonState);

			if (current != nullptr)
			{
				WeakReference<Component> safeOldComp (current);
				setButtons (screenPos, time, ModifierKeys());

				if (safeOldComp != nullptr)
				{
					componentUnderMouse = safeNewComp;
					sendMouseExit (safeOldComp, screenPos, time);
				}

				buttonState = originalButtonState;
			}

			current = componentUnderMouse = safeNewComp;

			if (current != nullptr)
				sendMouseEnter (current, screenPos, time);

			revealCursor (false);
			setButtons (screenPos, time, originalButtonState);
		}
	}

	void setPeer (ComponentPeer* const newPeer, const Point<int>& screenPos, const Time& time)
	{
		ModifierKeys::updateCurrentModifiers();

		if (newPeer != lastPeer)
		{
			setComponentUnderMouse (nullptr, screenPos, time);
			lastPeer = newPeer;
			setComponentUnderMouse (findComponentAt (screenPos), screenPos, time);
		}
	}

	void setScreenPos (const Point<int>& newScreenPos, const Time& time, const bool forceUpdate)
	{
		if (! isDragging())
			setComponentUnderMouse (findComponentAt (newScreenPos), newScreenPos, time);

		if (newScreenPos != lastScreenPos || forceUpdate)
		{
			cancelPendingUpdate();

			lastScreenPos = newScreenPos;
			Component* const current = getComponentUnderMouse();

			if (current != nullptr)
			{
				if (isDragging())
				{
					registerMouseDrag (newScreenPos);
					sendMouseDrag (current, newScreenPos + unboundedMouseOffset, time);

					if (isUnboundedMouseModeOn)
						handleUnboundedDrag (current);
				}
				else
				{
					sendMouseMove (current, newScreenPos, time);
				}
			}

			revealCursor (false);
		}
	}

	void handleEvent (ComponentPeer* const newPeer, const Point<int>& positionWithinPeer, const Time& time, const ModifierKeys& newMods)
	{
		jassert (newPeer != nullptr);
		lastTime = time;
		++mouseEventCounter;
		const Point<int> screenPos (newPeer->localToGlobal (positionWithinPeer));

		if (isDragging() && newMods.isAnyMouseButtonDown())
		{
			setScreenPos (screenPos, time, false);
		}
		else
		{
			setPeer (newPeer, screenPos, time);

			ComponentPeer* peer = getPeer();
			if (peer != nullptr)
			{
				if (setButtons (screenPos, time, newMods))
					return; // some modal events have been dispatched, so the current event is now out-of-date

				peer = getPeer();
				if (peer != nullptr)
					setScreenPos (screenPos, time, false);
			}
		}
	}

	void handleWheel (ComponentPeer* const peer, const Point<int>& positionWithinPeer, const Time& time, float x, float y)
	{
		jassert (peer != nullptr);
		lastTime = time;
		++mouseEventCounter;
		const Point<int> screenPos (peer->localToGlobal (positionWithinPeer));

		setPeer (peer, screenPos, time);
		setScreenPos (screenPos, time, false);
		triggerFakeMove();

		if (! isDragging())
		{
			Component* current = getComponentUnderMouse();
			if (current != nullptr)
				sendMouseWheel (current, screenPos, time, x, y);
		}
	}

	Time getLastMouseDownTime() const noexcept
	{
		return Time (mouseDowns[0].time);
	}

	Point<int> getLastMouseDownPosition() const noexcept
	{
		return mouseDowns[0].position;
	}

	int getNumberOfMultipleClicks() const noexcept
	{
		int numClicks = 0;

		if (mouseDowns[0].time != Time())
		{
			if (! mouseMovedSignificantlySincePressed)
				++numClicks;

			for (int i = 1; i < numElementsInArray (mouseDowns); ++i)
			{
				if (mouseDowns[0].canBePartOfMultipleClickWith (mouseDowns[i], MouseEvent::getDoubleClickTimeout() * jmin (i, 2)))
					++numClicks;
				else
					break;
			}
		}

		return numClicks;
	}

	bool hasMouseMovedSignificantlySincePressed() const noexcept
	{
		return mouseMovedSignificantlySincePressed
				|| lastTime > mouseDowns[0].time + RelativeTime::milliseconds (300);
	}

	void triggerFakeMove()
	{
		triggerAsyncUpdate();
	}

	void handleAsyncUpdate()
	{
		setScreenPos (lastScreenPos, jmax (lastTime, Time::getCurrentTime()), true);
	}

	void enableUnboundedMouseMovement (bool enable, bool keepCursorVisibleUntilOffscreen)
	{
		enable = enable && isDragging();
		isCursorVisibleUntilOffscreen = keepCursorVisibleUntilOffscreen;

		if (enable != isUnboundedMouseModeOn)
		{
			if ((! enable) && ((! isCursorVisibleUntilOffscreen) || ! unboundedMouseOffset.isOrigin()))
			{
				// when released, return the mouse to within the component's bounds
				Component* current = getComponentUnderMouse();
				if (current != nullptr)
					Desktop::setMousePosition (current->getScreenBounds()
												 .getConstrainedPoint (lastScreenPos));
			}

			isUnboundedMouseModeOn = enable;
			unboundedMouseOffset = Point<int>();

			revealCursor (true);
		}
	}

	void handleUnboundedDrag (Component* current)
	{
		const Rectangle<int> screenArea (current->getParentMonitorArea().expanded (-2, -2));

		if (! screenArea.contains (lastScreenPos))
		{
			const Point<int> componentCentre (current->getScreenBounds().getCentre());
			unboundedMouseOffset += (lastScreenPos - componentCentre);
			Desktop::setMousePosition (componentCentre);
		}
		else if (isCursorVisibleUntilOffscreen
				  && (! unboundedMouseOffset.isOrigin())
				  && screenArea.contains (lastScreenPos + unboundedMouseOffset))
		{
			Desktop::setMousePosition (lastScreenPos + unboundedMouseOffset);
			unboundedMouseOffset = Point<int>();
		}
	}

	void showMouseCursor (MouseCursor cursor, bool forcedUpdate)
	{
		if (isUnboundedMouseModeOn && ((! unboundedMouseOffset.isOrigin()) || ! isCursorVisibleUntilOffscreen))
		{
			cursor = MouseCursor::NoCursor;
			forcedUpdate = true;
		}

		if (forcedUpdate || cursor.getHandle() != currentCursorHandle)
		{
			currentCursorHandle = cursor.getHandle();
			cursor.showInWindow (getPeer());
		}
	}

	void hideCursor()
	{
		showMouseCursor (MouseCursor::NoCursor, true);
	}

	void revealCursor (bool forcedUpdate)
	{
		MouseCursor mc (MouseCursor::NormalCursor);

		Component* current = getComponentUnderMouse();
		if (current != nullptr)
			mc = current->getLookAndFeel().getMouseCursorFor (*current);

		showMouseCursor (mc, forcedUpdate);
	}

	const int index;
	const bool isMouseDevice;
	Point<int> lastScreenPos;
	ModifierKeys buttonState;

private:
	MouseInputSource& source;
	WeakReference<Component> componentUnderMouse;
	ComponentPeer* lastPeer;

	Point<int> unboundedMouseOffset;
	bool isUnboundedMouseModeOn, isCursorVisibleUntilOffscreen;
	void* currentCursorHandle;
	int mouseEventCounter;

	struct RecentMouseDown
	{
		RecentMouseDown()  : component (nullptr)
		{
		}

		Point<int> position;
		Time time;
		Component* component;
		ModifierKeys buttons;

		bool canBePartOfMultipleClickWith (const RecentMouseDown& other, const int maxTimeBetweenMs) const
		{
			return time - other.time < RelativeTime::milliseconds (maxTimeBetweenMs)
					&& abs (position.x - other.position.x) < 8
					&& abs (position.y - other.position.y) < 8
					&& buttons == other.buttons;;
		}
	};

	RecentMouseDown mouseDowns[4];
	bool mouseMovedSignificantlySincePressed;
	Time lastTime;

	void registerMouseDown (const Point<int>& screenPos, const Time& time,
							Component* const component, const ModifierKeys& modifiers) noexcept
	{
		for (int i = numElementsInArray (mouseDowns); --i > 0;)
			mouseDowns[i] = mouseDowns[i - 1];

		mouseDowns[0].position = screenPos;
		mouseDowns[0].time = time;
		mouseDowns[0].component = component;
		mouseDowns[0].buttons = modifiers.withOnlyMouseButtons();
		mouseMovedSignificantlySincePressed = false;
	}

	void registerMouseDrag (const Point<int>& screenPos) noexcept
	{
		mouseMovedSignificantlySincePressed = mouseMovedSignificantlySincePressed
			   || mouseDowns[0].position.getDistanceFrom (screenPos) >= 4;
	}

	JUCE_DECLARE_NON_COPYABLE (MouseInputSourceInternal);
};

MouseInputSource::MouseInputSource (const int index, const bool isMouseDevice)
{
	pimpl = new MouseInputSourceInternal (*this, index, isMouseDevice);
}

MouseInputSource::~MouseInputSource()
{
}

bool MouseInputSource::isMouse() const                                  { return pimpl->isMouseDevice; }
bool MouseInputSource::isTouch() const                                  { return ! isMouse(); }
bool MouseInputSource::canHover() const                                 { return isMouse(); }
bool MouseInputSource::hasMouseWheel() const                            { return isMouse(); }
int MouseInputSource::getIndex() const                                  { return pimpl->index; }
bool MouseInputSource::isDragging() const                               { return pimpl->isDragging(); }
Point<int> MouseInputSource::getScreenPosition() const                  { return pimpl->getScreenPosition(); }
ModifierKeys MouseInputSource::getCurrentModifiers() const              { return pimpl->getCurrentModifiers(); }
Component* MouseInputSource::getComponentUnderMouse() const             { return pimpl->getComponentUnderMouse(); }
void MouseInputSource::triggerFakeMove() const                          { pimpl->triggerFakeMove(); }
int MouseInputSource::getNumberOfMultipleClicks() const noexcept        { return pimpl->getNumberOfMultipleClicks(); }
Time MouseInputSource::getLastMouseDownTime() const noexcept            { return pimpl->getLastMouseDownTime(); }
Point<int> MouseInputSource::getLastMouseDownPosition() const noexcept  { return pimpl->getLastMouseDownPosition(); }
bool MouseInputSource::hasMouseMovedSignificantlySincePressed() const noexcept  { return pimpl->hasMouseMovedSignificantlySincePressed(); }
bool MouseInputSource::canDoUnboundedMovement() const noexcept          { return isMouse(); }
void MouseInputSource::enableUnboundedMouseMovement (bool isEnabled, bool keepCursorVisibleUntilOffscreen)    { pimpl->enableUnboundedMouseMovement (isEnabled, keepCursorVisibleUntilOffscreen); }
bool MouseInputSource::hasMouseCursor() const noexcept                  { return isMouse(); }
void MouseInputSource::showMouseCursor (const MouseCursor& cursor)      { pimpl->showMouseCursor (cursor, false); }
void MouseInputSource::hideCursor()                                     { pimpl->hideCursor(); }
void MouseInputSource::revealCursor()                                   { pimpl->revealCursor (false); }
void MouseInputSource::forceMouseCursorUpdate()                         { pimpl->revealCursor (true); }

void MouseInputSource::handleEvent (ComponentPeer* peer, const Point<int>& positionWithinPeer, const int64 time, const ModifierKeys& mods)
{
	pimpl->handleEvent (peer, positionWithinPeer, Time (time), mods.withOnlyMouseButtons());
}

void MouseInputSource::handleWheel (ComponentPeer* const peer, const Point<int>& positionWithinPeer, const int64 time, const float x, const float y)
{
	pimpl->handleWheel (peer, positionWithinPeer, Time (time), x, y);
}

/*** End of inlined file: juce_MouseInputSource.cpp ***/


/*** Start of inlined file: juce_MouseListener.cpp ***/
void MouseListener::mouseEnter (const MouseEvent&) {}
void MouseListener::mouseExit (const MouseEvent&)  {}
void MouseListener::mouseDown (const MouseEvent&)  {}
void MouseListener::mouseUp (const MouseEvent&)    {}
void MouseListener::mouseDrag (const MouseEvent&)  {}
void MouseListener::mouseMove (const MouseEvent&)  {}
void MouseListener::mouseDoubleClick (const MouseEvent&) {}
void MouseListener::mouseWheelMove (const MouseEvent&, float, float) {}

/*** End of inlined file: juce_MouseListener.cpp ***/


/*** Start of inlined file: juce_CaretComponent.cpp ***/
CaretComponent::CaretComponent (Component* const keyFocusOwner)
	: owner (keyFocusOwner)
{
	setAlwaysOnTop (true);
	setInterceptsMouseClicks (false, false);
}

CaretComponent::~CaretComponent()
{
}

void CaretComponent::paint (Graphics& g)
{
	g.fillAll (findColour (caretColourId, true));
}

void CaretComponent::timerCallback()
{
	setVisible (shouldBeShown() && ! isVisible());
}

void CaretComponent::setCaretPosition (const Rectangle<int>& characterArea)
{
	startTimer (380);
	setVisible (shouldBeShown());
	setBounds (characterArea.withWidth (2));
}

bool CaretComponent::shouldBeShown() const
{
	return owner == nullptr || (owner->hasKeyboardFocus (true)
								 && ! owner->isCurrentlyBlockedByAnotherModalComponent());
}

/*** End of inlined file: juce_CaretComponent.cpp ***/


/*** Start of inlined file: juce_KeyboardFocusTraverser.cpp ***/
namespace KeyboardFocusHelpers
{
	// This will sort a set of components, so that they are ordered in terms of
	// left-to-right and then top-to-bottom.
	struct ScreenPositionComparator
	{
		static int compareElements (const Component* const first, const Component* const second)
		{
			const int explicitOrder1 = getOrder (first);
			const int explicitOrder2 = getOrder (second);

			if (explicitOrder1 != explicitOrder2)
				return explicitOrder1 - explicitOrder2;

			const int yDiff = first->getY() - second->getY();

			return yDiff == 0 ? first->getX() - second->getX()
							  : yDiff;
		}

		static int getOrder (const Component* const c)
		{
			const int order = c->getExplicitFocusOrder();
			return order > 0 ? order : (std::numeric_limits<int>::max() / 2);
		}
	};

	static void findAllFocusableComponents (Component* const parent, Array <Component*>& comps)
	{
		if (parent->getNumChildComponents() > 0)
		{
			Array <Component*> localComps;
			ScreenPositionComparator comparator;

			int i;
			for (i = parent->getNumChildComponents(); --i >= 0;)
			{
				Component* const c = parent->getChildComponent (i);

				if (c->isVisible() && c->isEnabled())
					localComps.addSorted (comparator, c);
			}

			for (i = 0; i < localComps.size(); ++i)
			{
				Component* const c = localComps.getUnchecked (i);

				if (c->getWantsKeyboardFocus())
					comps.add (c);

				if (! c->isFocusContainer())
					findAllFocusableComponents (c, comps);
			}
		}
	}

	Component* findFocusContainer (Component* c)
	{
		c = c->getParentComponent();

		if (c != nullptr)
			while (c->getParentComponent() != nullptr && ! c->isFocusContainer())
				c = c->getParentComponent();

		return c;
	}

	Component* getIncrementedComponent (Component* const current, const int delta)
	{
		Component* focusContainer = findFocusContainer (current);

		if (focusContainer != nullptr)
		{
			Array <Component*> comps;
			KeyboardFocusHelpers::findAllFocusableComponents (focusContainer, comps);

			if (comps.size() > 0)
			{
				const int index = comps.indexOf (current);
				return comps [(index + comps.size() + delta) % comps.size()];
			}
		}

		return nullptr;
	}
}

KeyboardFocusTraverser::KeyboardFocusTraverser() {}
KeyboardFocusTraverser::~KeyboardFocusTraverser() {}

Component* KeyboardFocusTraverser::getNextComponent (Component* current)
{
	jassert (current != nullptr);
	return KeyboardFocusHelpers::getIncrementedComponent (current, 1);
}

Component* KeyboardFocusTraverser::getPreviousComponent (Component* current)
{
	jassert (current != nullptr);
	return KeyboardFocusHelpers::getIncrementedComponent (current, -1);
}

Component* KeyboardFocusTraverser::getDefaultComponent (Component* parentComponent)
{
	Array <Component*> comps;

	if (parentComponent != nullptr)
		KeyboardFocusHelpers::findAllFocusableComponents (parentComponent, comps);

	return comps.getFirst();
}

/*** End of inlined file: juce_KeyboardFocusTraverser.cpp ***/


/*** Start of inlined file: juce_KeyListener.cpp ***/
bool KeyListener::keyStateChanged (const bool, Component*)
{
	return false;
}

/*** End of inlined file: juce_KeyListener.cpp ***/


/*** Start of inlined file: juce_KeyPress.cpp ***/
KeyPress::KeyPress() noexcept
	: keyCode (0),
	  textCharacter (0)
{
}

KeyPress::KeyPress (const int keyCode_,
					const ModifierKeys& mods_,
					const juce_wchar textCharacter_) noexcept
	: keyCode (keyCode_),
	  mods (mods_),
	  textCharacter (textCharacter_)
{
}

KeyPress::KeyPress (const int keyCode_) noexcept
	: keyCode (keyCode_),
	  textCharacter (0)
{
}

KeyPress::KeyPress (const KeyPress& other) noexcept
	: keyCode (other.keyCode),
	  mods (other.mods),
	  textCharacter (other.textCharacter)
{
}

KeyPress& KeyPress::operator= (const KeyPress& other) noexcept
{
	keyCode = other.keyCode;
	mods = other.mods;
	textCharacter = other.textCharacter;

	return *this;
}

bool KeyPress::operator== (const KeyPress& other) const noexcept
{
	return mods.getRawFlags() == other.mods.getRawFlags()
			&& (textCharacter == other.textCharacter
				 || textCharacter == 0
				 || other.textCharacter == 0)
			&& (keyCode == other.keyCode
				 || (keyCode < 256
					  && other.keyCode < 256
					  && CharacterFunctions::toLowerCase ((juce_wchar) keyCode)
						   == CharacterFunctions::toLowerCase ((juce_wchar) other.keyCode)));
}

bool KeyPress::operator!= (const KeyPress& other) const noexcept
{
	return ! operator== (other);
}

bool KeyPress::isCurrentlyDown() const
{
	return isKeyCurrentlyDown (keyCode)
			&& (ModifierKeys::getCurrentModifiers().getRawFlags() & ModifierKeys::allKeyboardModifiers)
				  == (mods.getRawFlags() & ModifierKeys::allKeyboardModifiers);
}

namespace KeyPressHelpers
{
	struct KeyNameAndCode
	{
		const char* name;
		int code;
	};

	const KeyNameAndCode translations[] =
	{
		{ "spacebar",       KeyPress::spaceKey },
		{ "return",         KeyPress::returnKey },
		{ "escape",         KeyPress::escapeKey },
		{ "backspace",      KeyPress::backspaceKey },
		{ "cursor left",    KeyPress::leftKey },
		{ "cursor right",   KeyPress::rightKey },
		{ "cursor up",      KeyPress::upKey },
		{ "cursor down",    KeyPress::downKey },
		{ "page up",        KeyPress::pageUpKey },
		{ "page down",      KeyPress::pageDownKey },
		{ "home",           KeyPress::homeKey },
		{ "end",            KeyPress::endKey },
		{ "delete",         KeyPress::deleteKey },
		{ "insert",         KeyPress::insertKey },
		{ "tab",            KeyPress::tabKey },
		{ "play",           KeyPress::playKey },
		{ "stop",           KeyPress::stopKey },
		{ "fast forward",   KeyPress::fastForwardKey },
		{ "rewind",         KeyPress::rewindKey }
	};

	struct ModifierDescription
	{
		const char* name;
		int flag;
	};

	static const ModifierDescription modifierNames[] =
	{
		{ "ctrl",      ModifierKeys::ctrlModifier },
		{ "control",   ModifierKeys::ctrlModifier },
		{ "ctl",       ModifierKeys::ctrlModifier },
		{ "shift",     ModifierKeys::shiftModifier },
		{ "shft",      ModifierKeys::shiftModifier },
		{ "alt",       ModifierKeys::altModifier },
		{ "option",    ModifierKeys::altModifier },
		{ "command",   ModifierKeys::commandModifier },
		{ "cmd",       ModifierKeys::commandModifier }
	};

	const char* numberPadPrefix() noexcept      { return "numpad "; }

	int getNumpadKeyCode (const String& desc)
	{
		if (desc.containsIgnoreCase (numberPadPrefix()))
		{
			const juce_wchar lastChar = desc.trimEnd().getLastCharacter();

			switch (lastChar)
			{
				case '0': case '1': case '2': case '3': case '4':
				case '5': case '6': case '7': case '8': case '9':
					return (int) (KeyPress::numberPad0 + lastChar - '0');

				case '+':   return KeyPress::numberPadAdd;
				case '-':   return KeyPress::numberPadSubtract;
				case '*':   return KeyPress::numberPadMultiply;
				case '/':   return KeyPress::numberPadDivide;
				case '.':   return KeyPress::numberPadDecimalPoint;
				case '=':   return KeyPress::numberPadEquals;

				default:    break;
			}

			if (desc.endsWith ("separator"))  return KeyPress::numberPadSeparator;
			if (desc.endsWith ("delete"))     return KeyPress::numberPadDelete;
		}

		return 0;
	}

   #if JUCE_MAC
	struct OSXSymbolReplacement
	{
		const char* text;
		juce_wchar symbol;
	};

	const OSXSymbolReplacement osxSymbols[] =
	{
		{ "shift + ",     0x21e7 },
		{ "command + ",   0x2318 },
		{ "option + ",    0x2325 },
		{ "ctrl + ",      0x2303 },
		{ "return",       0x23ce },
		{ "cursor left",  0x2190 },
		{ "cursor right", 0x2192 },
		{ "cursor up",    0x2191 },
		{ "cursor down",  0x2193 },
		{ "backspace",    0x232b },
		{ "delete",       0x2326 }
	};
   #endif
}

KeyPress KeyPress::createFromDescription (const String& desc)
{
	int modifiers = 0;

	for (int i = 0; i < numElementsInArray (KeyPressHelpers::modifierNames); ++i)
		if (desc.containsWholeWordIgnoreCase (KeyPressHelpers::modifierNames[i].name))
			modifiers |= KeyPressHelpers::modifierNames[i].flag;

	int key = 0;

	for (int i = 0; i < numElementsInArray (KeyPressHelpers::translations); ++i)
	{
		if (desc.containsWholeWordIgnoreCase (String (KeyPressHelpers::translations[i].name)))
		{
			key = KeyPressHelpers::translations[i].code;
			break;
		}
	}

	if (key == 0)
		key = KeyPressHelpers::getNumpadKeyCode (desc);

	if (key == 0)
	{
		// see if it's a function key..
		if (! desc.containsChar ('#')) // avoid mistaking hex-codes like "#f1"
			for (int i = 1; i <= 12; ++i)
				if (desc.containsWholeWordIgnoreCase ("f" + String (i)))
					key = F1Key + i - 1;

		if (key == 0)
		{
			// give up and use the hex code..
			const int hexCode = desc.fromFirstOccurrenceOf ("#", false, false)
									.retainCharacters ("0123456789abcdefABCDEF")
									.getHexValue32();

			if (hexCode > 0)
				key = hexCode;
			else
				key = (int) CharacterFunctions::toUpperCase (desc.getLastCharacter());
		}
	}

	return KeyPress (key, ModifierKeys (modifiers), 0);
}

String KeyPress::getTextDescription() const
{
	String desc;

	if (keyCode > 0)
	{
		// some keyboard layouts use a shift-key to get the slash, but in those cases, we
		// want to store it as being a slash, not shift+whatever.
		if (textCharacter == '/')
			return "/";

		if (mods.isCtrlDown())
			desc << "ctrl + ";

		if (mods.isShiftDown())
			desc << "shift + ";

	   #if JUCE_MAC
		if (mods.isAltDown())
			desc << "option + ";

		// only do this on the mac, because on Windows ctrl and command are the same,
		// and this would get confusing
		if (mods.isCommandDown())
			desc << "command + ";
	   #else
		if (mods.isAltDown())
			desc << "alt + ";
	   #endif

		for (int i = 0; i < numElementsInArray (KeyPressHelpers::translations); ++i)
			if (keyCode == KeyPressHelpers::translations[i].code)
				return desc + KeyPressHelpers::translations[i].name;

		if (keyCode >= F1Key && keyCode <= F16Key)                  desc << 'F' << (1 + keyCode - F1Key);
		else if (keyCode >= numberPad0 && keyCode <= numberPad9)    desc << KeyPressHelpers::numberPadPrefix() << (keyCode - numberPad0);
		else if (keyCode >= 33 && keyCode < 176)        desc += CharacterFunctions::toUpperCase ((juce_wchar) keyCode);
		else if (keyCode == numberPadAdd)               desc << KeyPressHelpers::numberPadPrefix() << '+';
		else if (keyCode == numberPadSubtract)          desc << KeyPressHelpers::numberPadPrefix() << '-';
		else if (keyCode == numberPadMultiply)          desc << KeyPressHelpers::numberPadPrefix() << '*';
		else if (keyCode == numberPadDivide)            desc << KeyPressHelpers::numberPadPrefix() << '/';
		else if (keyCode == numberPadSeparator)         desc << KeyPressHelpers::numberPadPrefix() << "separator";
		else if (keyCode == numberPadDecimalPoint)      desc << KeyPressHelpers::numberPadPrefix() << '.';
		else if (keyCode == numberPadDelete)            desc << KeyPressHelpers::numberPadPrefix() << "delete";
		else                                            desc << '#' << String::toHexString (keyCode);
	}

	return desc;
}

String KeyPress::getTextDescriptionWithIcons() const
{
   #if JUCE_MAC
	String s (getTextDescription());

	for (int i = 0; i < numElementsInArray (KeyPressHelpers::osxSymbols); ++i)
		s = s.replace (KeyPressHelpers::osxSymbols[i].text,
					   String::charToString (KeyPressHelpers::osxSymbols[i].symbol));

	return s;
   #else
	return getTextDescription();
   #endif
}

/*** End of inlined file: juce_KeyPress.cpp ***/


/*** Start of inlined file: juce_ModifierKeys.cpp ***/
ModifierKeys::ModifierKeys() noexcept
	: flags (0)
{
}

ModifierKeys::ModifierKeys (const int flags_) noexcept
	: flags (flags_)
{
}

ModifierKeys::ModifierKeys (const ModifierKeys& other) noexcept
	: flags (other.flags)
{
}

ModifierKeys& ModifierKeys::operator= (const ModifierKeys& other) noexcept
{
	flags = other.flags;
	return *this;
}

ModifierKeys ModifierKeys::currentModifiers;

ModifierKeys ModifierKeys::getCurrentModifiers() noexcept
{
	return currentModifiers;
}

int ModifierKeys::getNumMouseButtonsDown() const noexcept
{
	int num = 0;

	if (isLeftButtonDown())     ++num;
	if (isRightButtonDown())    ++num;
	if (isMiddleButtonDown())   ++num;

	return num;
}

/*** End of inlined file: juce_ModifierKeys.cpp ***/


/*** Start of inlined file: juce_ArrowButton.cpp ***/
ArrowButton::ArrowButton (const String& name,
						  float arrowDirectionInRadians,
						  const Colour& arrowColour)
   : Button (name),
	 colour (arrowColour)
{
	path.lineTo (0.0f, 1.0f);
	path.lineTo (1.0f, 0.5f);
	path.closeSubPath();

	path.applyTransform (AffineTransform::rotation (float_Pi * 2.0f * arrowDirectionInRadians,
													0.5f, 0.5f));

	setComponentEffect (&shadow);
	updateShadowAndOffset();
}

ArrowButton::~ArrowButton()
{
}

void ArrowButton::paintButton (Graphics& g,
							   bool /*isMouseOverButton*/,
							   bool /*isButtonDown*/)
{
	g.setColour (colour);

	g.fillPath (path, path.getTransformToScaleToFit ((float) offset,
													 (float) offset,
													 (float) (getWidth() - 3),
													 (float) (getHeight() - 3),
													 false));
}

void ArrowButton::buttonStateChanged()
{
	updateShadowAndOffset();
}

void ArrowButton::updateShadowAndOffset()
{
	offset = (isDown()) ? 1 : 0;

	shadow.setShadowProperties ((isDown()) ? 1.2f : 3.0f,
								0.3f, -1, 0);
}

/*** End of inlined file: juce_ArrowButton.cpp ***/


/*** Start of inlined file: juce_Button.cpp ***/
class Button::RepeatTimer  : public Timer
{
public:
	RepeatTimer (Button& owner_) : owner (owner_)   {}
	void timerCallback()    { owner.repeatTimerCallback(); }

private:
	Button& owner;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (RepeatTimer);
};

Button::Button (const String& name)
  : Component (name),
	text (name),
	buttonPressTime (0),
	lastRepeatTime (0),
	commandManagerToUse (nullptr),
	autoRepeatDelay (-1),
	autoRepeatSpeed (0),
	autoRepeatMinimumDelay (-1),
	radioGroupId (0),
	commandID (0),
	connectedEdgeFlags (0),
	buttonState (buttonNormal),
	lastToggleState (false),
	clickTogglesState (false),
	needsToRelease (false),
	needsRepainting (false),
	isKeyDown (false),
	triggerOnMouseDown (false),
	generateTooltip (false)
{
	setWantsKeyboardFocus (true);
	isOn.addListener (this);
}

Button::~Button()
{
	isOn.removeListener (this);

	if (commandManagerToUse != nullptr)
		commandManagerToUse->removeListener (this);

	repeatTimer = nullptr;
	clearShortcuts();
}

void Button::setButtonText (const String& newText)
{
	if (text != newText)
	{
		text = newText;
		repaint();
	}
}

void Button::setTooltip (const String& newTooltip)
{
	SettableTooltipClient::setTooltip (newTooltip);
	generateTooltip = false;
}

String Button::getTooltip()
{
	if (generateTooltip && commandManagerToUse != nullptr && commandID != 0)
	{
		String tt (commandManagerToUse->getDescriptionOfCommand (commandID));

		Array <KeyPress> keyPresses (commandManagerToUse->getKeyMappings()->getKeyPressesAssignedToCommand (commandID));

		for (int i = 0; i < keyPresses.size(); ++i)
		{
			const String key (keyPresses.getReference(i).getTextDescription());

			tt << " [";

			if (key.length() == 1)
				tt << TRANS("shortcut") << ": '" << key << "']";
			else
				tt << key << ']';
		}

		return tt;
	}

	return SettableTooltipClient::getTooltip();
}

void Button::setConnectedEdges (const int connectedEdgeFlags_)
{
	if (connectedEdgeFlags != connectedEdgeFlags_)
	{
		connectedEdgeFlags = connectedEdgeFlags_;
		repaint();
	}
}

void Button::setToggleState (const bool shouldBeOn,
							 const bool sendChangeNotification)
{
	if (shouldBeOn != lastToggleState)
	{
		if (getToggleState() != shouldBeOn)  // this test means that if the value is void rather than explicitly set to
			isOn = shouldBeOn;               // false, it won't be changed unless the required value is true.

		lastToggleState = shouldBeOn;
		repaint();

		WeakReference<Component> deletionWatcher (this);

		if (sendChangeNotification)
		{
			sendClickMessage (ModifierKeys());

			if (deletionWatcher == nullptr)
				return;
		}

		if (lastToggleState)
		{
			turnOffOtherButtonsInGroup (sendChangeNotification);

			if (deletionWatcher == nullptr)
				return;
		}

		sendStateMessage();
	}
}

void Button::setClickingTogglesState (const bool shouldToggle) noexcept
{
	clickTogglesState = shouldToggle;

	// if you've got clickTogglesState turned on, you shouldn't also connect the button
	// up to be a command invoker. Instead, your command handler must flip the state of whatever
	// it is that this button represents, and the button will update its state to reflect this
	// in the applicationCommandListChanged() method.
	jassert (commandManagerToUse == nullptr || ! clickTogglesState);
}

bool Button::getClickingTogglesState() const noexcept
{
	return clickTogglesState;
}

void Button::valueChanged (Value& value)
{
	if (value.refersToSameSourceAs (isOn))
		setToggleState (isOn.getValue(), true);
}

void Button::setRadioGroupId (const int newGroupId)
{
	if (radioGroupId != newGroupId)
	{
		radioGroupId = newGroupId;

		if (lastToggleState)
			turnOffOtherButtonsInGroup (true);
	}
}

void Button::turnOffOtherButtonsInGroup (const bool sendChangeNotification)
{
	Component* const p = getParentComponent();

	if (p != nullptr && radioGroupId != 0)
	{
		WeakReference<Component> deletionWatcher (this);

		for (int i = p->getNumChildComponents(); --i >= 0;)
		{
			Component* const c = p->getChildComponent (i);

			if (c != this)
			{
				Button* const b = dynamic_cast <Button*> (c);

				if (b != nullptr && b->getRadioGroupId() == radioGroupId)
				{
					b->setToggleState (false, sendChangeNotification);

					if (deletionWatcher == nullptr)
						return;
				}
			}
		}
	}
}

void Button::enablementChanged()
{
	updateState();
	repaint();
}

Button::ButtonState Button::updateState()
{
	return updateState (isMouseOver (true), isMouseButtonDown());
}

Button::ButtonState Button::updateState (const bool over, const bool down)
{
	ButtonState newState = buttonNormal;

	if (isEnabled() && isVisible() && ! isCurrentlyBlockedByAnotherModalComponent())
	{
		if ((down && (over || (triggerOnMouseDown && buttonState == buttonDown))) || isKeyDown)
			newState = buttonDown;
		else if (over)
			newState = buttonOver;
	}

	setState (newState);
	return newState;
}

void Button::setState (const ButtonState newState)
{
	if (buttonState != newState)
	{
		buttonState = newState;
		repaint();

		if (buttonState == buttonDown)
		{
			buttonPressTime = Time::getApproximateMillisecondCounter();
			lastRepeatTime = 0;
		}

		sendStateMessage();
	}
}

bool Button::isDown() const noexcept
{
	return buttonState == buttonDown;
}

bool Button::isOver() const noexcept
{
	return buttonState != buttonNormal;
}

void Button::buttonStateChanged()
{
}

uint32 Button::getMillisecondsSinceButtonDown() const noexcept
{
	const uint32 now = Time::getApproximateMillisecondCounter();
	return now > buttonPressTime ? now - buttonPressTime : 0;
}

void Button::setTriggeredOnMouseDown (const bool isTriggeredOnMouseDown) noexcept
{
	triggerOnMouseDown = isTriggeredOnMouseDown;
}

void Button::clicked()
{
}

void Button::clicked (const ModifierKeys& /*modifiers*/)
{
	clicked();
}

enum { clickMessageId = 0x2f3f4f99 };

void Button::triggerClick()
{
	postCommandMessage (clickMessageId);
}

void Button::internalClickCallback (const ModifierKeys& modifiers)
{
	if (clickTogglesState)
		setToggleState ((radioGroupId != 0) || ! lastToggleState, false);

	sendClickMessage (modifiers);
}

void Button::flashButtonState()
{
	if (isEnabled())
	{
		needsToRelease = true;
		setState (buttonDown);
		getRepeatTimer().startTimer (100);
	}
}

void Button::handleCommandMessage (int commandId)
{
	if (commandId == clickMessageId)
	{
		if (isEnabled())
		{
			flashButtonState();
			internalClickCallback (ModifierKeys::getCurrentModifiers());
		}
	}
	else
	{
		Component::handleCommandMessage (commandId);
	}
}

void Button::addListener (ButtonListener* const newListener)
{
	buttonListeners.add (newListener);
}

void Button::removeListener (ButtonListener* const listener)
{
	buttonListeners.remove (listener);
}

void Button::addButtonListener (ButtonListener* l)      { addListener (l); }
void Button::removeButtonListener (ButtonListener* l)   { removeListener (l); }

void Button::sendClickMessage (const ModifierKeys& modifiers)
{
	Component::BailOutChecker checker (this);

	if (commandManagerToUse != nullptr && commandID != 0)
	{
		ApplicationCommandTarget::InvocationInfo info (commandID);
		info.invocationMethod = ApplicationCommandTarget::InvocationInfo::fromButton;
		info.originatingComponent = this;

		commandManagerToUse->invoke (info, true);
	}

	clicked (modifiers);

	if (! checker.shouldBailOut())
		buttonListeners.callChecked (checker, &ButtonListener::buttonClicked, this);  // (can't use Button::Listener due to idiotic VC2005 bug)
}

void Button::sendStateMessage()
{
	Component::BailOutChecker checker (this);

	buttonStateChanged();

	if (! checker.shouldBailOut())
		buttonListeners.callChecked (checker, &ButtonListener::buttonStateChanged, this);
}

void Button::paint (Graphics& g)
{
	if (needsToRelease && isEnabled())
	{
		needsToRelease = false;
		needsRepainting = true;
	}

	paintButton (g, isOver(), isDown());
}

void Button::mouseEnter (const MouseEvent&)
{
	updateState (true, false);
}

void Button::mouseExit (const MouseEvent&)
{
	updateState (false, false);
}

void Button::mouseDown (const MouseEvent& e)
{
	updateState (true, true);

	if (isDown())
	{
		if (autoRepeatDelay >= 0)
			getRepeatTimer().startTimer (autoRepeatDelay);

		if (triggerOnMouseDown)
			internalClickCallback (e.mods);
	}
}

void Button::mouseUp (const MouseEvent& e)
{
	const bool wasDown = isDown();
	updateState (isMouseOver(), false);

	if (wasDown && isOver() && ! triggerOnMouseDown)
		internalClickCallback (e.mods);
}

void Button::mouseDrag (const MouseEvent&)
{
	const ButtonState oldState = buttonState;
	updateState (isMouseOver(), true);

	if (autoRepeatDelay >= 0 && buttonState != oldState && isDown())
		getRepeatTimer().startTimer (autoRepeatSpeed);
}

void Button::focusGained (FocusChangeType)
{
	updateState();
	repaint();
}

void Button::focusLost (FocusChangeType)
{
	updateState();
	repaint();
}

void Button::visibilityChanged()
{
	needsToRelease = false;
	updateState();
}

void Button::parentHierarchyChanged()
{
	Component* const newKeySource = (shortcuts.size() == 0) ? nullptr : getTopLevelComponent();

	if (newKeySource != keySource.get())
	{
		if (keySource != nullptr)
			keySource->removeKeyListener (this);

		keySource = newKeySource;

		if (keySource != nullptr)
			keySource->addKeyListener (this);
	}
}

void Button::setCommandToTrigger (ApplicationCommandManager* const commandManagerToUse_,
								  const int commandID_,
								  const bool generateTooltip_)
{
	commandID = commandID_;
	generateTooltip = generateTooltip_;

	if (commandManagerToUse != commandManagerToUse_)
	{
		if (commandManagerToUse != nullptr)
			commandManagerToUse->removeListener (this);

		commandManagerToUse = commandManagerToUse_;

		if (commandManagerToUse != nullptr)
			commandManagerToUse->addListener (this);

		// if you've got clickTogglesState turned on, you shouldn't also connect the button
		// up to be a command invoker. Instead, your command handler must flip the state of whatever
		// it is that this button represents, and the button will update its state to reflect this
		// in the applicationCommandListChanged() method.
		jassert (commandManagerToUse == nullptr || ! clickTogglesState);
	}

	if (commandManagerToUse != nullptr)
		applicationCommandListChanged();
	else
		setEnabled (true);
}

void Button::applicationCommandInvoked (const ApplicationCommandTarget::InvocationInfo& info)
{
	if (info.commandID == commandID
		 && (info.commandFlags & ApplicationCommandInfo::dontTriggerVisualFeedback) == 0)
	{
		flashButtonState();
	}
}

void Button::applicationCommandListChanged()
{
	if (commandManagerToUse != nullptr)
	{
		ApplicationCommandInfo info (0);

		ApplicationCommandTarget* const target = commandManagerToUse->getTargetForCommand (commandID, info);

		setEnabled (target != nullptr && (info.flags & ApplicationCommandInfo::isDisabled) == 0);

		if (target != nullptr)
			setToggleState ((info.flags & ApplicationCommandInfo::isTicked) != 0, false);
	}
}

void Button::addShortcut (const KeyPress& key)
{
	if (key.isValid())
	{
		jassert (! isRegisteredForShortcut (key));  // already registered!

		shortcuts.add (key);
		parentHierarchyChanged();
	}
}

void Button::clearShortcuts()
{
	shortcuts.clear();

	parentHierarchyChanged();
}

bool Button::isShortcutPressed() const
{
	if (! isCurrentlyBlockedByAnotherModalComponent())
	{
		for (int i = shortcuts.size(); --i >= 0;)
			if (shortcuts.getReference(i).isCurrentlyDown())
				return true;
	}

	return false;
}

bool Button::isRegisteredForShortcut (const KeyPress& key) const
{
	for (int i = shortcuts.size(); --i >= 0;)
		if (key == shortcuts.getReference(i))
			return true;

	return false;
}

bool Button::keyStateChanged (const bool, Component*)
{
	if (! isEnabled())
		return false;

	const bool wasDown = isKeyDown;
	isKeyDown = isShortcutPressed();

	if (autoRepeatDelay >= 0 && (isKeyDown && ! wasDown))
		getRepeatTimer().startTimer (autoRepeatDelay);

	updateState();

	if (isEnabled() && wasDown && ! isKeyDown)
	{
		internalClickCallback (ModifierKeys::getCurrentModifiers());

		// (return immediately - this button may now have been deleted)
		return true;
	}

	return wasDown || isKeyDown;
}

bool Button::keyPressed (const KeyPress&, Component*)
{
	// returning true will avoid forwarding events for keys that we're using as shortcuts
	return isShortcutPressed();
}

bool Button::keyPressed (const KeyPress& key)
{
	if (isEnabled() && key.isKeyCode (KeyPress::returnKey))
	{
		triggerClick();
		return true;
	}

	return false;
}

void Button::setRepeatSpeed (const int initialDelayMillisecs,
							 const int repeatMillisecs,
							 const int minimumDelayInMillisecs) noexcept
{
	autoRepeatDelay = initialDelayMillisecs;
	autoRepeatSpeed = repeatMillisecs;
	autoRepeatMinimumDelay = jmin (autoRepeatSpeed, minimumDelayInMillisecs);
}

void Button::repeatTimerCallback()
{
	if (needsRepainting)
	{
		getRepeatTimer().stopTimer();
		updateState();
		needsRepainting = false;
	}
	else if (autoRepeatSpeed > 0 && (isKeyDown || (updateState() == buttonDown)))
	{
		int repeatSpeed = autoRepeatSpeed;

		if (autoRepeatMinimumDelay >= 0)
		{
			double timeHeldDown = jmin (1.0, getMillisecondsSinceButtonDown() / 4000.0);
			timeHeldDown *= timeHeldDown;

			repeatSpeed = repeatSpeed + (int) (timeHeldDown * (autoRepeatMinimumDelay - repeatSpeed));
		}

		repeatSpeed = jmax (1, repeatSpeed);

		const uint32 now = Time::getMillisecondCounter();

		// if we've been blocked from repeating often enough, speed up the repeat timer to compensate..
		if (lastRepeatTime != 0 && (int) (now - lastRepeatTime) > repeatSpeed * 2)
			repeatSpeed = jmax (1, repeatSpeed / 2);

		lastRepeatTime = now;
		getRepeatTimer().startTimer (repeatSpeed);

		internalClickCallback (ModifierKeys::getCurrentModifiers());
	}
	else if (! needsToRelease)
	{
		getRepeatTimer().stopTimer();
	}
}

Button::RepeatTimer& Button::getRepeatTimer()
{
	if (repeatTimer == nullptr)
		repeatTimer = new RepeatTimer (*this);

	return *repeatTimer;
}

const Identifier Button::Ids::text ("text");
const Identifier Button::Ids::radioGroup ("radioGroup");
const Identifier Button::Ids::connectedLeft ("connectedLeft");
const Identifier Button::Ids::connectedRight ("connectedRight");
const Identifier Button::Ids::connectedTop ("connectedTop");
const Identifier Button::Ids::connectedBottom ("connectedBottom");

void Button::refreshFromValueTree (const ValueTree& state, ComponentBuilder&)
{
	ComponentBuilder::refreshBasicComponentProperties (*this, state);

	setButtonText (state [Ids::text].toString());
	setRadioGroupId (state [Ids::radioGroup]);
	setConnectedEdges (getConnectedFlags (state));
}

int Button::getConnectedFlags (const ValueTree& state)
{
	int connected = 0;
	if (state [Button::Ids::connectedLeft])    connected |= Button::ConnectedOnLeft;
	if (state [Button::Ids::connectedRight])   connected |= Button::ConnectedOnRight;
	if (state [Button::Ids::connectedTop])     connected |= Button::ConnectedOnTop;
	if (state [Button::Ids::connectedBottom])  connected |= Button::ConnectedOnBottom;
	return connected;
}

/*** End of inlined file: juce_Button.cpp ***/


/*** Start of inlined file: juce_DrawableButton.cpp ***/
DrawableButton::DrawableButton (const String& name,
								const DrawableButton::ButtonStyle buttonStyle)
	: Button (name),
	  style (buttonStyle),
	  currentImage (nullptr),
	  edgeIndent (3)
{
	if (buttonStyle == ImageOnButtonBackground)
	{
		backgroundOff = Colour (0xffbbbbff);
		backgroundOn = Colour (0xff3333ff);
	}
	else
	{
		backgroundOff = Colours::transparentBlack;
		backgroundOn = Colour (0xaabbbbff);
	}
}

DrawableButton::~DrawableButton()
{
}

void DrawableButton::setImages (const Drawable* normal,
								const Drawable* over,
								const Drawable* down,
								const Drawable* disabled,
								const Drawable* normalOn,
								const Drawable* overOn,
								const Drawable* downOn,
								const Drawable* disabledOn)
{
	jassert (normal != nullptr); // you really need to give it at least a normal image..

	if (normal != nullptr)        normalImage = normal->createCopy();
	if (over != nullptr)          overImage = over->createCopy();
	if (down != nullptr)          downImage = down->createCopy();
	if (disabled != nullptr)      disabledImage = disabled->createCopy();
	if (normalOn != nullptr)      normalImageOn = normalOn->createCopy();
	if (overOn != nullptr)        overImageOn = overOn->createCopy();
	if (downOn != nullptr)        downImageOn = downOn->createCopy();
	if (disabledOn != nullptr)    disabledImageOn = disabledOn->createCopy();

	buttonStateChanged();
}

void DrawableButton::setButtonStyle (const DrawableButton::ButtonStyle newStyle)
{
	if (style != newStyle)
	{
		style = newStyle;
		buttonStateChanged();
	}
}

void DrawableButton::setBackgroundColours (const Colour& toggledOffColour,
										   const Colour& toggledOnColour)
{
	if (backgroundOff != toggledOffColour
		 || backgroundOn != toggledOnColour)
	{
		backgroundOff = toggledOffColour;
		backgroundOn = toggledOnColour;

		repaint();
	}
}

const Colour& DrawableButton::getBackgroundColour() const noexcept
{
	return getToggleState() ? backgroundOn
							: backgroundOff;
}

void DrawableButton::setEdgeIndent (const int numPixelsIndent)
{
	edgeIndent = numPixelsIndent;
	repaint();
	resized();
}

void DrawableButton::resized()
{
	Button::resized();

	if (currentImage != nullptr)
	{
		if (style == ImageRaw)
		{
			currentImage->setOriginWithOriginalSize (Point<float>());
		}
		else
		{
			Rectangle<int> imageSpace;

			if (style == ImageOnButtonBackground)
			{
				imageSpace = getLocalBounds().reduced (getWidth() / 4, getHeight() / 4);
			}
			else
			{
				const int textH = (style == ImageAboveTextLabel) ? jmin (16, proportionOfHeight (0.25f)) : 0;

				const int indentX = jmin (edgeIndent, proportionOfWidth (0.3f));
				const int indentY = jmin (edgeIndent, proportionOfHeight (0.3f));

				imageSpace.setBounds (indentX, indentY,
									  getWidth() - indentX * 2,
									  getHeight() - indentY * 2 - textH);
			}

			currentImage->setTransformToFit (imageSpace.toFloat(), RectanglePlacement::centred);
		}
	}
}

void DrawableButton::buttonStateChanged()
{
	repaint();

	Drawable* imageToDraw = nullptr;
	float opacity = 1.0f;

	if (isEnabled())
	{
		imageToDraw = getCurrentImage();
	}
	else
	{
		imageToDraw = getToggleState() ? disabledImageOn
									   : disabledImage;

		if (imageToDraw == nullptr)
		{
			opacity = 0.4f;
			imageToDraw = getNormalImage();
		}
	}

	if (imageToDraw != currentImage)
	{
		removeChildComponent (currentImage);
		currentImage = imageToDraw;

		if (currentImage != nullptr)
		{
			currentImage->setInterceptsMouseClicks (false, false);
			addAndMakeVisible (currentImage);
			DrawableButton::resized();
		}
	}

	if (currentImage != nullptr)
		currentImage->setAlpha (opacity);
}

void DrawableButton::enablementChanged()
{
	Button::enablementChanged();
	buttonStateChanged();
}

void DrawableButton::paintButton (Graphics& g,
								  bool isMouseOverButton,
								  bool isButtonDown)
{
	if (style == ImageOnButtonBackground)
	{
		getLookAndFeel().drawButtonBackground (g, *this,
											   getBackgroundColour(),
											   isMouseOverButton,
											   isButtonDown);
	}
	else
	{
		g.fillAll (getBackgroundColour());

		const int textH = (style == ImageAboveTextLabel)
							? jmin (16, proportionOfHeight (0.25f))
							: 0;

		if (textH > 0)
		{
			g.setFont ((float) textH);

			g.setColour (findColour (DrawableButton::textColourId)
							.withMultipliedAlpha (isEnabled() ? 1.0f : 0.4f));

			g.drawFittedText (getButtonText(),
							  2, getHeight() - textH - 1,
							  getWidth() - 4, textH,
							  Justification::centred, 1);
		}
	}
}

Drawable* DrawableButton::getCurrentImage() const noexcept
{
	if (isDown())
		return getDownImage();

	if (isOver())
		return getOverImage();

	return getNormalImage();
}

Drawable* DrawableButton::getNormalImage() const noexcept
{
	return (getToggleState() && normalImageOn != nullptr) ? normalImageOn
														  : normalImage;
}

Drawable* DrawableButton::getOverImage() const noexcept
{
	Drawable* d = normalImage;

	if (getToggleState())
	{
		if (overImageOn != nullptr)
			d = overImageOn;
		else if (normalImageOn != nullptr)
			d = normalImageOn;
		else if (overImage != nullptr)
			d = overImage;
	}
	else
	{
		if (overImage != nullptr)
			d = overImage;
	}

	return d;
}

Drawable* DrawableButton::getDownImage() const noexcept
{
	Drawable* d = normalImage;

	if (getToggleState())
	{
		if (downImageOn != nullptr)
			d = downImageOn;
		else if (overImageOn != nullptr)
			d = overImageOn;
		else if (normalImageOn != nullptr)
			d = normalImageOn;
		else if (downImage != nullptr)
			d = downImage;
		else
			d = getOverImage();
	}
	else
	{
		if (downImage != nullptr)
			d = downImage;
		else
			d = getOverImage();
	}

	return d;
}

/*** End of inlined file: juce_DrawableButton.cpp ***/


/*** Start of inlined file: juce_HyperlinkButton.cpp ***/
HyperlinkButton::HyperlinkButton (const String& linkText,
								  const URL& linkURL)
   : Button (linkText),
	 url (linkURL),
	 font (14.0f, Font::underlined),
	 resizeFont (true),
	 justification (Justification::centred)
{
	setMouseCursor (MouseCursor::PointingHandCursor);
	setTooltip (linkURL.toString (false));
}

HyperlinkButton::HyperlinkButton ()
   : Button (String::empty),
	 font (14.0f, Font::underlined),
	 resizeFont (true),
	 justification (Justification::centred)
{
	setMouseCursor (MouseCursor::PointingHandCursor);
}

HyperlinkButton::~HyperlinkButton()
{
}

void HyperlinkButton::setFont (const Font& newFont,
							   const bool resizeToMatchComponentHeight,
							   const Justification& justificationType)
{
	font = newFont;
	resizeFont = resizeToMatchComponentHeight;
	justification = justificationType;
	repaint();
}

void HyperlinkButton::setURL (const URL& newURL) noexcept
{
	url = newURL;
	setTooltip (newURL.toString (false));
}

Font HyperlinkButton::getFontToUse() const
{
	if (resizeFont)
		return font.withHeight (getHeight() * 0.7f);

	return font;
}

void HyperlinkButton::changeWidthToFitText()
{
	setSize (getFontToUse().getStringWidth (getName()) + 6, getHeight());
}

void HyperlinkButton::colourChanged()
{
	repaint();
}

void HyperlinkButton::clicked()
{
	if (url.isWellFormed())
		url.launchInDefaultBrowser();
}

void HyperlinkButton::paintButton (Graphics& g,
								   bool isMouseOverButton,
								   bool isButtonDown)
{
	const Colour textColour (findColour (textColourId));

	if (isEnabled())
		g.setColour ((isMouseOverButton) ? textColour.darker ((isButtonDown) ? 1.3f : 0.4f)
										 : textColour);
	else
		g.setColour (textColour.withMultipliedAlpha (0.4f));

	g.setFont (getFontToUse());

	g.drawText (getButtonText(),
				2, 0, getWidth() - 2, getHeight(),
				justification.getOnlyHorizontalFlags() | Justification::verticallyCentred,
				true);
}

const Identifier HyperlinkButton::Ids::tagType ("HYPERLINKBUTTON");
const Identifier HyperlinkButton::Ids::text ("text");
const Identifier HyperlinkButton::Ids::url ("url");

void HyperlinkButton::refreshFromValueTree (const ValueTree& state, ComponentBuilder&)
{
	ComponentBuilder::refreshBasicComponentProperties (*this, state);

	setButtonText (state [Ids::text].toString());
	setURL (URL (state [Ids::url].toString()));
}

/*** End of inlined file: juce_HyperlinkButton.cpp ***/


/*** Start of inlined file: juce_ImageButton.cpp ***/
ImageButton::ImageButton (const String& text_)
	: Button (text_),
	  scaleImageToFit (true),
	  preserveProportions (true),
	  alphaThreshold (0)
{
}

ImageButton::~ImageButton()
{
}

void ImageButton::setImages (const bool resizeButtonNowToFitThisImage,
							 const bool rescaleImagesWhenButtonSizeChanges,
							 const bool preserveImageProportions,
							 const Image& normalImage_,
							 const float imageOpacityWhenNormal,
							 const Colour& overlayColourWhenNormal,
							 const Image& overImage_,
							 const float imageOpacityWhenOver,
							 const Colour& overlayColourWhenOver,
							 const Image& downImage_,
							 const float imageOpacityWhenDown,
							 const Colour& overlayColourWhenDown,
							 const float hitTestAlphaThreshold)
{
	normalImage = normalImage_;
	overImage = overImage_;
	downImage = downImage_;

	if (resizeButtonNowToFitThisImage && normalImage.isValid())
	{
		imageBounds.setSize (normalImage.getWidth(),
							 normalImage.getHeight());

		setSize (imageBounds.getWidth(), imageBounds.getHeight());
	}

	scaleImageToFit = rescaleImagesWhenButtonSizeChanges;
	preserveProportions = preserveImageProportions;

	normalOpacity = imageOpacityWhenNormal;
	normalOverlay = overlayColourWhenNormal;
	overOpacity   = imageOpacityWhenOver;
	overOverlay   = overlayColourWhenOver;
	downOpacity   = imageOpacityWhenDown;
	downOverlay   = overlayColourWhenDown;

	alphaThreshold = (uint8) jlimit (0, 0xff, roundToInt (255.0f * hitTestAlphaThreshold));

	repaint();
}

Image ImageButton::getCurrentImage() const
{
	if (isDown() || getToggleState())
		return getDownImage();

	if (isOver())
		return getOverImage();

	return getNormalImage();
}

Image ImageButton::getNormalImage() const
{
	return normalImage;
}

Image ImageButton::getOverImage() const
{
	return overImage.isValid() ? overImage
							   : normalImage;
}

Image ImageButton::getDownImage() const
{
	return downImage.isValid() ? downImage
							   : getOverImage();
}

void ImageButton::paintButton (Graphics& g,
							   bool isMouseOverButton,
							   bool isButtonDown)
{
	if (! isEnabled())
	{
		isMouseOverButton = false;
		isButtonDown = false;
	}

	Image im (getCurrentImage());

	if (im.isValid())
	{
		const int iw = im.getWidth();
		const int ih = im.getHeight();
		int w = getWidth();
		int h = getHeight();
		int x = (w - iw) / 2;
		int y = (h - ih) / 2;

		if (scaleImageToFit)
		{
			if (preserveProportions)
			{
				int newW, newH;
				const float imRatio = ih / (float) iw;
				const float destRatio = h / (float) w;

				if (imRatio > destRatio)
				{
					newW = roundToInt (h / imRatio);
					newH = h;
				}
				else
				{
					newW = w;
					newH = roundToInt (w * imRatio);
				}

				x = (w - newW) / 2;
				y = (h - newH) / 2;
				w = newW;
				h = newH;
			}
			else
			{
				x = 0;
				y = 0;
			}
		}

		if (! scaleImageToFit)
		{
			w = iw;
			h = ih;
		}

		imageBounds.setBounds (x, y, w, h);

		const bool useDownImage = isButtonDown || getToggleState();

		getLookAndFeel().drawImageButton (g, &im, x, y, w, h,
										  useDownImage ? downOverlay
													   : (isMouseOverButton ? overOverlay
																			: normalOverlay),
										  useDownImage ? downOpacity
													   : (isMouseOverButton ? overOpacity
																			: normalOpacity),
										  *this);
	}
}

bool ImageButton::hitTest (int x, int y)
{
	if (alphaThreshold == 0)
		return true;

	Image im (getCurrentImage());

	return im.isNull() || ((! imageBounds.isEmpty())
							&& alphaThreshold < im.getPixelAt (((x - imageBounds.getX()) * im.getWidth()) / imageBounds.getWidth(),
															   ((y - imageBounds.getY()) * im.getHeight()) / imageBounds.getHeight()).getAlpha());
}

const Identifier ImageButton::Ids::tagType     ("IMAGEBUTTON");
const Identifier ImageButton::Ids::upImage     ("upImage");
const Identifier ImageButton::Ids::overImage   ("overImage");
const Identifier ImageButton::Ids::downImage   ("downImage");
const Identifier ImageButton::Ids::upOverlay   ("upOverlay");
const Identifier ImageButton::Ids::overOverlay ("overOverlay");
const Identifier ImageButton::Ids::downOverlay ("downOverlay");
const Identifier ImageButton::Ids::upOpacity   ("upOpacity");
const Identifier ImageButton::Ids::overOpacity ("overOpacity");
const Identifier ImageButton::Ids::downOpacity ("downOpacity");

namespace ImageButtonHelpers
{
	static Colour getColourFromVar (const var& col)
	{
		return col.isString() ? Colour::fromString (col.toString())
							  : Colours::transparentBlack;
	}

	static float getOpacityFromVar (const var& v)
	{
		return v.isVoid() ? 1.0f : static_cast<float> (v);
	}
}

void ImageButton::refreshFromValueTree (const ValueTree& state, ComponentBuilder& builder)
{
	Button::refreshFromValueTree (state, builder);

	const var upImageIdentifier (state [Ids::upImage]),
			  overImageIdentifier (state [Ids::overImage]),
			  downImageIdentifier (state [Ids::downImage]);

	ComponentBuilder::ImageProvider* const imageProvider = builder.getImageProvider();
	jassert (imageProvider != nullptr || upImageIdentifier.isVoid());

	Image newUpImage, newOverImage, newDownImage;

	if (imageProvider != nullptr)
	{
		newUpImage   = imageProvider->getImageForIdentifier (upImageIdentifier);
		newOverImage = imageProvider->getImageForIdentifier (overImageIdentifier);
		newDownImage = imageProvider->getImageForIdentifier (downImageIdentifier);
	}

	using namespace ImageButtonHelpers;

	setImages (false, true, true,
			   newUpImage,   getOpacityFromVar (state[Ids::upOpacity]),   getColourFromVar (state[Ids::upOverlay]),
			   newOverImage, getOpacityFromVar (state[Ids::overOpacity]), getColourFromVar (state[Ids::overOverlay]),
			   newDownImage, getOpacityFromVar (state[Ids::downOpacity]), getColourFromVar (state[Ids::downOverlay]));
}

/*** End of inlined file: juce_ImageButton.cpp ***/


/*** Start of inlined file: juce_ShapeButton.cpp ***/
ShapeButton::ShapeButton (const String& text_,
						  const Colour& normalColour_,
						  const Colour& overColour_,
						  const Colour& downColour_)
  : Button (text_),
	normalColour (normalColour_),
	overColour (overColour_),
	downColour (downColour_),
	maintainShapeProportions (false),
	outlineWidth (0.0f)
{
}

ShapeButton::~ShapeButton()
{
}

void ShapeButton::setColours (const Colour& newNormalColour,
							  const Colour& newOverColour,
							  const Colour& newDownColour)
{
	normalColour = newNormalColour;
	overColour = newOverColour;
	downColour = newDownColour;
}

void ShapeButton::setOutline (const Colour& newOutlineColour,
							  const float newOutlineWidth)
{
	outlineColour = newOutlineColour;
	outlineWidth = newOutlineWidth;
}

void ShapeButton::setShape (const Path& newShape,
							const bool resizeNowToFitThisShape,
							const bool maintainShapeProportions_,
							const bool hasShadow)
{
	shape = newShape;
	maintainShapeProportions = maintainShapeProportions_;

	shadow.setShadowProperties (3.0f, 0.5f, 0, 0);
	setComponentEffect ((hasShadow) ? &shadow : 0);

	if (resizeNowToFitThisShape)
	{
		Rectangle<float> newBounds (shape.getBounds());

		if (hasShadow)
			newBounds.expand (4.0f, 4.0f);

		shape.applyTransform (AffineTransform::translation (-newBounds.getX(), -newBounds.getY()));

		setSize (1 + (int) (newBounds.getWidth() + outlineWidth),
				 1 + (int) (newBounds.getHeight() + outlineWidth));
	}
}

void ShapeButton::paintButton (Graphics& g, bool isMouseOverButton, bool isButtonDown)
{
	if (! isEnabled())
	{
		isMouseOverButton = false;
		isButtonDown = false;
	}

	g.setColour ((isButtonDown) ? downColour
								: (isMouseOverButton) ? overColour
													  : normalColour);

	int w = getWidth();
	int h = getHeight();

	if (getComponentEffect() != nullptr)
	{
		w -= 4;
		h -= 4;
	}

	const float offset = (outlineWidth * 0.5f) + (isButtonDown ? 1.5f : 0.0f);

	const AffineTransform trans (shape.getTransformToScaleToFit (offset, offset,
																 w - offset - outlineWidth,
																 h - offset - outlineWidth,
																 maintainShapeProportions));
	g.fillPath (shape, trans);

	if (outlineWidth > 0.0f)
	{
		g.setColour (outlineColour);
		g.strokePath (shape, PathStrokeType (outlineWidth), trans);
	}
}

/*** End of inlined file: juce_ShapeButton.cpp ***/


/*** Start of inlined file: juce_TextButton.cpp ***/
TextButton::TextButton (const String& name,
						const String& toolTip)
	: Button (name)
{
	setTooltip (toolTip);
}

TextButton::~TextButton()
{
}

void TextButton::paintButton (Graphics& g,
							  bool isMouseOverButton,
							  bool isButtonDown)
{
	getLookAndFeel().drawButtonBackground (g, *this,
										   findColour (getToggleState() ? buttonOnColourId
																		: buttonColourId),
										   isMouseOverButton,
										   isButtonDown);

	getLookAndFeel().drawButtonText (g, *this,
									 isMouseOverButton,
									 isButtonDown);
}

void TextButton::colourChanged()
{
	repaint();
}

Font TextButton::getFont()
{
	return Font (jmin (15.0f, getHeight() * 0.6f));
}

void TextButton::changeWidthToFitText (const int newHeight)
{
	if (newHeight >= 0)
		setSize (jmax (1, getWidth()), newHeight);

	setSize (getFont().getStringWidth (getButtonText()) + getHeight(),
			 getHeight());
}

const Identifier TextButton::Ids::tagType ("TEXTBUTTON");

/*** End of inlined file: juce_TextButton.cpp ***/


/*** Start of inlined file: juce_ToggleButton.cpp ***/
ToggleButton::ToggleButton (const String& buttonText)
	: Button (buttonText)
{
	setClickingTogglesState (true);
}

ToggleButton::~ToggleButton()
{
}

void ToggleButton::paintButton (Graphics& g,
								bool isMouseOverButton,
								bool isButtonDown)
{
	getLookAndFeel().drawToggleButton (g, *this,
									   isMouseOverButton,
									   isButtonDown);
}

void ToggleButton::changeWidthToFitText()
{
	getLookAndFeel().changeToggleButtonWidthToFitText (*this);
}

void ToggleButton::colourChanged()
{
	repaint();
}

const Identifier ToggleButton::Ids::tagType ("TOGGLEBUTTON");

/*** End of inlined file: juce_ToggleButton.cpp ***/


/*** Start of inlined file: juce_ToolbarButton.cpp ***/
ToolbarButton::ToolbarButton (const int itemId_, const String& buttonText,
							  Drawable* const normalImage_, Drawable* const toggledOnImage_)
   : ToolbarItemComponent (itemId_, buttonText, true),
	 normalImage (normalImage_),
	 toggledOnImage (toggledOnImage_),
	 currentImage (nullptr)
{
	jassert (normalImage_ != nullptr);
}

ToolbarButton::~ToolbarButton()
{
}

bool ToolbarButton::getToolbarItemSizes (int toolbarDepth, bool /*isToolbarVertical*/, int& preferredSize, int& minSize, int& maxSize)
{
	preferredSize = minSize = maxSize = toolbarDepth;
	return true;
}

void ToolbarButton::paintButtonArea (Graphics&, int /*width*/, int /*height*/, bool /*isMouseOver*/, bool /*isMouseDown*/)
{
}

void ToolbarButton::contentAreaChanged (const Rectangle<int>&)
{
	buttonStateChanged();
}

void ToolbarButton::updateDrawable()
{
	if (currentImage != nullptr)
	{
		currentImage->setTransformToFit (getContentArea().toFloat(), RectanglePlacement::centred);
		currentImage->setAlpha (isEnabled() ? 1.0f : 0.5f);
	}
}

void ToolbarButton::resized()
{
	ToolbarItemComponent::resized();
	updateDrawable();
}

void ToolbarButton::enablementChanged()
{
	ToolbarItemComponent::enablementChanged();
	updateDrawable();
}

void ToolbarButton::buttonStateChanged()
{
	Drawable* d = normalImage;

	if (getToggleState() && toggledOnImage != nullptr)
		d = toggledOnImage;

	if (d != currentImage)
	{
		removeChildComponent (currentImage);
		currentImage = d;

		if (d != nullptr)
		{
			enablementChanged();
			addAndMakeVisible (d);
			updateDrawable();
		}
	}
}

/*** End of inlined file: juce_ToolbarButton.cpp ***/


/*** Start of inlined file: juce_Drawable.cpp ***/
Drawable::Drawable()
{
	setInterceptsMouseClicks (false, false);
	setPaintingIsUnclipped (true);
}

Drawable::~Drawable()
{
}

void Drawable::draw (Graphics& g, float opacity, const AffineTransform& transform) const
{
	const_cast <Drawable*> (this)->nonConstDraw (g, opacity, transform);
}

void Drawable::nonConstDraw (Graphics& g, float opacity, const AffineTransform& transform)
{
	Graphics::ScopedSaveState ss (g);

	const float oldOpacity = getAlpha();
	setAlpha (opacity);
	g.addTransform (AffineTransform::translation ((float) -(originRelativeToComponent.x),
												  (float) -(originRelativeToComponent.y))
						.followedBy (getTransform())
						.followedBy (transform));

	if (! g.isClipEmpty())
		paintEntireComponent (g, false);

	setAlpha (oldOpacity);
}

void Drawable::drawAt (Graphics& g, float x, float y, float opacity) const
{
	draw (g, opacity, AffineTransform::translation (x, y));
}

void Drawable::drawWithin (Graphics& g, const Rectangle<float>& destArea, const RectanglePlacement& placement, float opacity) const
{
	draw (g, opacity, placement.getTransformToFit (getDrawableBounds(), destArea));
}

DrawableComposite* Drawable::getParent() const
{
	return dynamic_cast <DrawableComposite*> (getParentComponent());
}

void Drawable::transformContextToCorrectOrigin (Graphics& g)
{
	g.setOrigin (originRelativeToComponent.x,
				 originRelativeToComponent.y);
}

void Drawable::parentHierarchyChanged()
{
	setBoundsToEnclose (getDrawableBounds());
}

void Drawable::setBoundsToEnclose (const Rectangle<float>& area)
{
	Drawable* const parent = getParent();
	Point<int> parentOrigin;
	if (parent != nullptr)
		parentOrigin = parent->originRelativeToComponent;

	const Rectangle<int> newBounds (area.getSmallestIntegerContainer() + parentOrigin);
	originRelativeToComponent = parentOrigin - newBounds.getPosition();
	setBounds (newBounds);
}

void Drawable::setOriginWithOriginalSize (const Point<float>& originWithinParent)
{
	setTransform (AffineTransform::translation (originWithinParent.x, originWithinParent.y));
}

void Drawable::setTransformToFit (const Rectangle<float>& area, const RectanglePlacement& placement)
{
	if (! area.isEmpty())
		setTransform (placement.getTransformToFit (getDrawableBounds(), area));
}

Drawable* Drawable::createFromImageData (const void* data, const size_t numBytes)
{
	Drawable* result = nullptr;

	Image image (ImageFileFormat::loadFrom (data, numBytes));

	if (image.isValid())
	{
		DrawableImage* const di = new DrawableImage();
		di->setImage (image);
		result = di;
	}
	else
	{
		const String asString (String::createStringFromData (data, (int) numBytes));

		XmlDocument doc (asString);
		ScopedPointer <XmlElement> outer (doc.getDocumentElement (true));

		if (outer != nullptr && outer->hasTagName ("svg"))
		{
			ScopedPointer <XmlElement> svg (doc.getDocumentElement());

			if (svg != nullptr)
				result = Drawable::createFromSVG (*svg);
		}
	}

	return result;
}

Drawable* Drawable::createFromImageDataStream (InputStream& dataSource)
{
	MemoryOutputStream mo;
	mo << dataSource;

	return createFromImageData (mo.getData(), mo.getDataSize());
}

Drawable* Drawable::createFromImageFile (const File& file)
{
	FileInputStream fin (file);

	return fin.openedOk() ? createFromImageDataStream (fin) : nullptr;
}

template <class DrawableClass>
class DrawableTypeHandler  : public ComponentBuilder::TypeHandler
{
public:
	DrawableTypeHandler()
		: ComponentBuilder::TypeHandler (DrawableClass::valueTreeType)
	{
	}

	Component* addNewComponentFromState (const ValueTree& state, Component* parent)
	{
		DrawableClass* const d = new DrawableClass();

		if (parent != nullptr)
			parent->addAndMakeVisible (d);

		updateComponentFromState (d, state);
		return d;
	}

	void updateComponentFromState (Component* component, const ValueTree& state)
	{
		DrawableClass* const d = dynamic_cast <DrawableClass*> (component);
		jassert (d != nullptr);
		d->refreshFromValueTree (state, *this->getBuilder());
	}
};

void Drawable::registerDrawableTypeHandlers (ComponentBuilder& builder)
{
	builder.registerTypeHandler (new DrawableTypeHandler <DrawablePath>());
	builder.registerTypeHandler (new DrawableTypeHandler <DrawableComposite>());
	builder.registerTypeHandler (new DrawableTypeHandler <DrawableRectangle>());
	builder.registerTypeHandler (new DrawableTypeHandler <DrawableImage>());
	builder.registerTypeHandler (new DrawableTypeHandler <DrawableText>());
}

Drawable* Drawable::createFromValueTree (const ValueTree& tree, ComponentBuilder::ImageProvider* imageProvider)
{
	ComponentBuilder builder (tree);
	builder.setImageProvider (imageProvider);
	registerDrawableTypeHandlers (builder);

	ScopedPointer<Component> comp (builder.createComponent());
	Drawable* const d = dynamic_cast<Drawable*> (static_cast <Component*> (comp));

	if (d != nullptr)
		comp.release();

	return d;
}

Drawable::ValueTreeWrapperBase::ValueTreeWrapperBase (const ValueTree& state_)
	: state (state_)
{
}

String Drawable::ValueTreeWrapperBase::getID() const
{
	return state [ComponentBuilder::idProperty];
}

void Drawable::ValueTreeWrapperBase::setID (const String& newID)
{
	if (newID.isEmpty())
		state.removeProperty (ComponentBuilder::idProperty, nullptr);
	else
		state.setProperty (ComponentBuilder::idProperty, newID, nullptr);
}

/*** End of inlined file: juce_Drawable.cpp ***/


/*** Start of inlined file: juce_DrawableComposite.cpp ***/
DrawableComposite::DrawableComposite()
	: bounds (Point<float>(), Point<float> (100.0f, 0.0f), Point<float> (0.0f, 100.0f)),
	  updateBoundsReentrant (false)
{
	setContentArea (RelativeRectangle (RelativeCoordinate (0.0),
									   RelativeCoordinate (100.0),
									   RelativeCoordinate (0.0),
									   RelativeCoordinate (100.0)));
}

DrawableComposite::DrawableComposite (const DrawableComposite& other)
	: bounds (other.bounds),
	  markersX (other.markersX),
	  markersY (other.markersY),
	  updateBoundsReentrant (false)
{
	for (int i = 0; i < other.getNumChildComponents(); ++i)
	{
		const Drawable* const d = dynamic_cast <const Drawable*> (other.getChildComponent(i));

		if (d != nullptr)
			addAndMakeVisible (d->createCopy());
	}
}

DrawableComposite::~DrawableComposite()
{
	deleteAllChildren();
}

Drawable* DrawableComposite::createCopy() const
{
	return new DrawableComposite (*this);
}

Rectangle<float> DrawableComposite::getDrawableBounds() const
{
	Rectangle<float> r;

	for (int i = getNumChildComponents(); --i >= 0;)
	{
		const Drawable* const d = dynamic_cast <const Drawable*> (getChildComponent(i));

		if (d != nullptr)
			r = r.getUnion (d->isTransformed() ? d->getDrawableBounds().transformed (d->getTransform())
											   : d->getDrawableBounds());
	}

	return r;
}

MarkerList* DrawableComposite::getMarkers (bool xAxis)
{
	return xAxis ? &markersX : &markersY;
}

RelativeRectangle DrawableComposite::getContentArea() const
{
	jassert (markersX.getNumMarkers() >= 2 && markersX.getMarker (0)->name == contentLeftMarkerName && markersX.getMarker (1)->name == contentRightMarkerName);
	jassert (markersY.getNumMarkers() >= 2 && markersY.getMarker (0)->name == contentTopMarkerName && markersY.getMarker (1)->name == contentBottomMarkerName);

	return RelativeRectangle (markersX.getMarker(0)->position, markersX.getMarker(1)->position,
							  markersY.getMarker(0)->position, markersY.getMarker(1)->position);
}

void DrawableComposite::setContentArea (const RelativeRectangle& newArea)
{
	markersX.setMarker (contentLeftMarkerName, newArea.left);
	markersX.setMarker (contentRightMarkerName, newArea.right);
	markersY.setMarker (contentTopMarkerName, newArea.top);
	markersY.setMarker (contentBottomMarkerName, newArea.bottom);
}

void DrawableComposite::setBoundingBox (const RelativeParallelogram& newBounds)
{
	if (bounds != newBounds)
	{
		bounds = newBounds;

		if (bounds.isDynamic())
		{
			Drawable::Positioner<DrawableComposite>* const p = new Drawable::Positioner<DrawableComposite> (*this);
			setPositioner (p);
			p->apply();
		}
		else
		{
			setPositioner (nullptr);
			recalculateCoordinates (nullptr);
		}
	}
}

void DrawableComposite::resetBoundingBoxToContentArea()
{
	const RelativeRectangle content (getContentArea());

	setBoundingBox (RelativeParallelogram (RelativePoint (content.left, content.top),
										   RelativePoint (content.right, content.top),
										   RelativePoint (content.left, content.bottom)));
}

void DrawableComposite::resetContentAreaAndBoundingBoxToFitChildren()
{
	const Rectangle<float> activeArea (getDrawableBounds());

	setContentArea (RelativeRectangle (RelativeCoordinate (activeArea.getX()),
									   RelativeCoordinate (activeArea.getRight()),
									   RelativeCoordinate (activeArea.getY()),
									   RelativeCoordinate (activeArea.getBottom())));
	resetBoundingBoxToContentArea();
}

bool DrawableComposite::registerCoordinates (RelativeCoordinatePositionerBase& pos)
{
	bool ok = pos.addPoint (bounds.topLeft);
	ok = pos.addPoint (bounds.topRight) && ok;
	return pos.addPoint (bounds.bottomLeft) && ok;
}

void DrawableComposite::recalculateCoordinates (Expression::Scope* scope)
{
	Point<float> resolved[3];
	bounds.resolveThreePoints (resolved, scope);

	const Rectangle<float> content (getContentArea().resolve (scope));

	AffineTransform t (AffineTransform::fromTargetPoints (content.getX(),     content.getY(),      resolved[0].x, resolved[0].y,
														  content.getRight(), content.getY(),      resolved[1].x, resolved[1].y,
														  content.getX(),     content.getBottom(), resolved[2].x, resolved[2].y));

	if (t.isSingularity())
		t = AffineTransform::identity;

	setTransform (t);
}

void DrawableComposite::parentHierarchyChanged()
{
	DrawableComposite* parent = getParent();
	if (parent != nullptr)
		originRelativeToComponent = parent->originRelativeToComponent - getPosition();
}

void DrawableComposite::childBoundsChanged (Component*)
{
	updateBoundsToFitChildren();
}

void DrawableComposite::childrenChanged()
{
	updateBoundsToFitChildren();
}

void DrawableComposite::updateBoundsToFitChildren()
{
	if (! updateBoundsReentrant)
	{
		const ScopedValueSetter<bool> setter (updateBoundsReentrant, true, false);

		Rectangle<int> childArea;

		for (int i = getNumChildComponents(); --i >= 0;)
			childArea = childArea.getUnion (getChildComponent(i)->getBoundsInParent());

		const Point<int> delta (childArea.getPosition());
		childArea += getPosition();

		if (childArea != getBounds())
		{
			if (! delta.isOrigin())
			{
				originRelativeToComponent -= delta;

				for (int i = getNumChildComponents(); --i >= 0;)
				{
					Component* const c = getChildComponent(i);

					if (c != nullptr)
						c->setBounds (c->getBounds() - delta);
				}
			}

			setBounds (childArea);
		}
	}
}

const char* const DrawableComposite::contentLeftMarkerName = "left";
const char* const DrawableComposite::contentRightMarkerName = "right";
const char* const DrawableComposite::contentTopMarkerName = "top";
const char* const DrawableComposite::contentBottomMarkerName = "bottom";

const Identifier DrawableComposite::valueTreeType ("Group");

const Identifier DrawableComposite::ValueTreeWrapper::topLeft ("topLeft");
const Identifier DrawableComposite::ValueTreeWrapper::topRight ("topRight");
const Identifier DrawableComposite::ValueTreeWrapper::bottomLeft ("bottomLeft");
const Identifier DrawableComposite::ValueTreeWrapper::childGroupTag ("Drawables");
const Identifier DrawableComposite::ValueTreeWrapper::markerGroupTagX ("MarkersX");
const Identifier DrawableComposite::ValueTreeWrapper::markerGroupTagY ("MarkersY");

DrawableComposite::ValueTreeWrapper::ValueTreeWrapper (const ValueTree& state_)
	: ValueTreeWrapperBase (state_)
{
	jassert (state.hasType (valueTreeType));
}

ValueTree DrawableComposite::ValueTreeWrapper::getChildList() const
{
	return state.getChildWithName (childGroupTag);
}

ValueTree DrawableComposite::ValueTreeWrapper::getChildListCreating (UndoManager* undoManager)
{
	return state.getOrCreateChildWithName (childGroupTag, undoManager);
}

RelativeParallelogram DrawableComposite::ValueTreeWrapper::getBoundingBox() const
{
	return RelativeParallelogram (state.getProperty (topLeft, "0, 0"),
								  state.getProperty (topRight, "100, 0"),
								  state.getProperty (bottomLeft, "0, 100"));
}

void DrawableComposite::ValueTreeWrapper::setBoundingBox (const RelativeParallelogram& newBounds, UndoManager* undoManager)
{
	state.setProperty (topLeft, newBounds.topLeft.toString(), undoManager);
	state.setProperty (topRight, newBounds.topRight.toString(), undoManager);
	state.setProperty (bottomLeft, newBounds.bottomLeft.toString(), undoManager);
}

void DrawableComposite::ValueTreeWrapper::resetBoundingBoxToContentArea (UndoManager* undoManager)
{
	const RelativeRectangle content (getContentArea());

	setBoundingBox (RelativeParallelogram (RelativePoint (content.left, content.top),
										   RelativePoint (content.right, content.top),
										   RelativePoint (content.left, content.bottom)), undoManager);
}

RelativeRectangle DrawableComposite::ValueTreeWrapper::getContentArea() const
{
	MarkerList::ValueTreeWrapper markersX (getMarkerList (true));
	MarkerList::ValueTreeWrapper markersY (getMarkerList (false));

	return RelativeRectangle (markersX.getMarker (markersX.getMarkerState (0)).position,
							  markersX.getMarker (markersX.getMarkerState (1)).position,
							  markersY.getMarker (markersY.getMarkerState (0)).position,
							  markersY.getMarker (markersY.getMarkerState (1)).position);
}

void DrawableComposite::ValueTreeWrapper::setContentArea (const RelativeRectangle& newArea, UndoManager* undoManager)
{
	MarkerList::ValueTreeWrapper markersX (getMarkerListCreating (true, nullptr));
	MarkerList::ValueTreeWrapper markersY (getMarkerListCreating (false, nullptr));

	markersX.setMarker (MarkerList::Marker (contentLeftMarkerName, newArea.left), undoManager);
	markersX.setMarker (MarkerList::Marker (contentRightMarkerName, newArea.right), undoManager);
	markersY.setMarker (MarkerList::Marker (contentTopMarkerName, newArea.top), undoManager);
	markersY.setMarker (MarkerList::Marker (contentBottomMarkerName, newArea.bottom), undoManager);
}

MarkerList::ValueTreeWrapper DrawableComposite::ValueTreeWrapper::getMarkerList (bool xAxis) const
{
	return state.getChildWithName (xAxis ? markerGroupTagX : markerGroupTagY);
}

MarkerList::ValueTreeWrapper DrawableComposite::ValueTreeWrapper::getMarkerListCreating (bool xAxis, UndoManager* undoManager)
{
	return state.getOrCreateChildWithName (xAxis ? markerGroupTagX : markerGroupTagY, undoManager);
}

void DrawableComposite::refreshFromValueTree (const ValueTree& tree, ComponentBuilder& builder)
{
	const ValueTreeWrapper wrapper (tree);
	setComponentID (wrapper.getID());

	wrapper.getMarkerList (true).applyTo (markersX);
	wrapper.getMarkerList (false).applyTo (markersY);

	setBoundingBox (wrapper.getBoundingBox());

	builder.updateChildComponents (*this, wrapper.getChildList());
}

ValueTree DrawableComposite::createValueTree (ComponentBuilder::ImageProvider* imageProvider) const
{
	ValueTree tree (valueTreeType);
	ValueTreeWrapper v (tree);

	v.setID (getComponentID());
	v.setBoundingBox (bounds, nullptr);

	ValueTree childList (v.getChildListCreating (nullptr));

	for (int i = 0; i < getNumChildComponents(); ++i)
	{
		const Drawable* const d = dynamic_cast <const Drawable*> (getChildComponent(i));
		jassert (d != nullptr); // You can't save a mix of Drawables and normal components!

		childList.addChild (d->createValueTree (imageProvider), -1, nullptr);
	}

	v.getMarkerListCreating (true, nullptr).readFrom (markersX, nullptr);
	v.getMarkerListCreating (false, nullptr).readFrom (markersY, nullptr);

	return tree;
}

/*** End of inlined file: juce_DrawableComposite.cpp ***/


/*** Start of inlined file: juce_DrawableImage.cpp ***/
DrawableImage::DrawableImage()
	: opacity (1.0f),
	  overlayColour (0x00000000)
{
	bounds.topRight = RelativePoint (Point<float> (1.0f, 0.0f));
	bounds.bottomLeft = RelativePoint (Point<float> (0.0f, 1.0f));
}

DrawableImage::DrawableImage (const DrawableImage& other)
	: image (other.image),
	  opacity (other.opacity),
	  overlayColour (other.overlayColour),
	  bounds (other.bounds)
{
}

DrawableImage::~DrawableImage()
{
}

void DrawableImage::setImage (const Image& imageToUse)
{
	image = imageToUse;
	setBounds (imageToUse.getBounds());

	bounds.topLeft = RelativePoint (Point<float> (0.0f, 0.0f));
	bounds.topRight = RelativePoint (Point<float> ((float) image.getWidth(), 0.0f));
	bounds.bottomLeft = RelativePoint (Point<float> (0.0f, (float) image.getHeight()));
	recalculateCoordinates (nullptr);

	repaint();
}

void DrawableImage::setOpacity (const float newOpacity)
{
	opacity = newOpacity;
}

void DrawableImage::setOverlayColour (const Colour& newOverlayColour)
{
	overlayColour = newOverlayColour;
}

void DrawableImage::setBoundingBox (const RelativeParallelogram& newBounds)
{
	if (bounds != newBounds)
	{
		bounds = newBounds;

		if (bounds.isDynamic())
		{
			Drawable::Positioner<DrawableImage>* const p = new Drawable::Positioner<DrawableImage> (*this);
			setPositioner (p);
			p->apply();
		}
		else
		{
			setPositioner (nullptr);
			recalculateCoordinates (nullptr);
		}
	}
}

bool DrawableImage::registerCoordinates (RelativeCoordinatePositionerBase& pos)
{
	bool ok = pos.addPoint (bounds.topLeft);
	ok = pos.addPoint (bounds.topRight) && ok;
	return pos.addPoint (bounds.bottomLeft) && ok;
}

void DrawableImage::recalculateCoordinates (Expression::Scope* scope)
{
	if (image.isValid())
	{
		Point<float> resolved[3];
		bounds.resolveThreePoints (resolved, scope);

		const Point<float> tr (resolved[0] + (resolved[1] - resolved[0]) / (float) image.getWidth());
		const Point<float> bl (resolved[0] + (resolved[2] - resolved[0]) / (float) image.getHeight());

		AffineTransform t (AffineTransform::fromTargetPoints (resolved[0].x, resolved[0].y,
															  tr.x, tr.y,
															  bl.x, bl.y));

		if (t.isSingularity())
			t = AffineTransform::identity;

		setTransform (t);
	}
}

void DrawableImage::paint (Graphics& g)
{
	if (image.isValid())
	{
		if (opacity > 0.0f && ! overlayColour.isOpaque())
		{
			g.setOpacity (opacity);
			g.drawImageAt (image, 0, 0, false);
		}

		if (! overlayColour.isTransparent())
		{
			g.setColour (overlayColour.withMultipliedAlpha (opacity));
			g.drawImageAt (image, 0, 0, true);
		}
	}
}

Rectangle<float> DrawableImage::getDrawableBounds() const
{
	return image.getBounds().toFloat();
}

bool DrawableImage::hitTest (int x, int y)
{
	return Drawable::hitTest (x, y) && image.isValid() && image.getPixelAt (x, y).getAlpha() >= 127;
}

Drawable* DrawableImage::createCopy() const
{
	return new DrawableImage (*this);
}

const Identifier DrawableImage::valueTreeType ("Image");

const Identifier DrawableImage::ValueTreeWrapper::opacity ("opacity");
const Identifier DrawableImage::ValueTreeWrapper::overlay ("overlay");
const Identifier DrawableImage::ValueTreeWrapper::image ("image");
const Identifier DrawableImage::ValueTreeWrapper::topLeft ("topLeft");
const Identifier DrawableImage::ValueTreeWrapper::topRight ("topRight");
const Identifier DrawableImage::ValueTreeWrapper::bottomLeft ("bottomLeft");

DrawableImage::ValueTreeWrapper::ValueTreeWrapper (const ValueTree& state_)
	: ValueTreeWrapperBase (state_)
{
	jassert (state.hasType (valueTreeType));
}

var DrawableImage::ValueTreeWrapper::getImageIdentifier() const
{
	return state [image];
}

Value DrawableImage::ValueTreeWrapper::getImageIdentifierValue (UndoManager* undoManager)
{
	return state.getPropertyAsValue (image, undoManager);
}

void DrawableImage::ValueTreeWrapper::setImageIdentifier (const var& newIdentifier, UndoManager* undoManager)
{
	state.setProperty (image, newIdentifier, undoManager);
}

float DrawableImage::ValueTreeWrapper::getOpacity() const
{
	return (float) state.getProperty (opacity, 1.0);
}

Value DrawableImage::ValueTreeWrapper::getOpacityValue (UndoManager* undoManager)
{
	if (! state.hasProperty (opacity))
		state.setProperty (opacity, 1.0, undoManager);

	return state.getPropertyAsValue (opacity, undoManager);
}

void DrawableImage::ValueTreeWrapper::setOpacity (float newOpacity, UndoManager* undoManager)
{
	state.setProperty (opacity, newOpacity, undoManager);
}

Colour DrawableImage::ValueTreeWrapper::getOverlayColour() const
{
	return Colour::fromString (state [overlay].toString());
}

void DrawableImage::ValueTreeWrapper::setOverlayColour (const Colour& newColour, UndoManager* undoManager)
{
	if (newColour.isTransparent())
		state.removeProperty (overlay, undoManager);
	else
		state.setProperty (overlay, String::toHexString ((int) newColour.getARGB()), undoManager);
}

Value DrawableImage::ValueTreeWrapper::getOverlayColourValue (UndoManager* undoManager)
{
	return state.getPropertyAsValue (overlay, undoManager);
}

RelativeParallelogram DrawableImage::ValueTreeWrapper::getBoundingBox() const
{
	return RelativeParallelogram (state.getProperty (topLeft, "0, 0"),
								  state.getProperty (topRight, "100, 0"),
								  state.getProperty (bottomLeft, "0, 100"));
}

void DrawableImage::ValueTreeWrapper::setBoundingBox (const RelativeParallelogram& newBounds, UndoManager* undoManager)
{
	state.setProperty (topLeft, newBounds.topLeft.toString(), undoManager);
	state.setProperty (topRight, newBounds.topRight.toString(), undoManager);
	state.setProperty (bottomLeft, newBounds.bottomLeft.toString(), undoManager);
}

void DrawableImage::refreshFromValueTree (const ValueTree& tree, ComponentBuilder& builder)
{
	const ValueTreeWrapper controller (tree);
	setComponentID (controller.getID());

	const float newOpacity = controller.getOpacity();
	const Colour newOverlayColour (controller.getOverlayColour());

	Image newImage;
	const var imageIdentifier (controller.getImageIdentifier());

	jassert (builder.getImageProvider() != 0 || imageIdentifier.isVoid()); // if you're using images, you need to provide something that can load and save them!

	if (builder.getImageProvider() != nullptr)
		newImage = builder.getImageProvider()->getImageForIdentifier (imageIdentifier);

	const RelativeParallelogram newBounds (controller.getBoundingBox());

	if (bounds != newBounds || newOpacity != opacity
		 || overlayColour != newOverlayColour || image != newImage)
	{
		repaint();
		opacity = newOpacity;
		overlayColour = newOverlayColour;

		if (image != newImage)
			setImage (newImage);

		setBoundingBox (newBounds);
	}
}

ValueTree DrawableImage::createValueTree (ComponentBuilder::ImageProvider* imageProvider) const
{
	ValueTree tree (valueTreeType);
	ValueTreeWrapper v (tree);

	v.setID (getComponentID());
	v.setOpacity (opacity, nullptr);
	v.setOverlayColour (overlayColour, nullptr);
	v.setBoundingBox (bounds, nullptr);

	if (image.isValid())
	{
		jassert (imageProvider != nullptr); // if you're using images, you need to provide something that can load and save them!

		if (imageProvider != nullptr)
			v.setImageIdentifier (imageProvider->getIdentifierForImage (image), nullptr);
	}

	return tree;
}

/*** End of inlined file: juce_DrawableImage.cpp ***/


/*** Start of inlined file: juce_DrawablePath.cpp ***/
DrawablePath::DrawablePath()
{
}

DrawablePath::DrawablePath (const DrawablePath& other)
	: DrawableShape (other)
{
	if (other.relativePath != nullptr)
		setPath (*other.relativePath);
	else
		setPath (other.path);
}

DrawablePath::~DrawablePath()
{
}

Drawable* DrawablePath::createCopy() const
{
	return new DrawablePath (*this);
}

void DrawablePath::setPath (const Path& newPath)
{
	path = newPath;
	pathChanged();
}

const Path& DrawablePath::getPath() const
{
	return path;
}

const Path& DrawablePath::getStrokePath() const
{
	return strokePath;
}

void DrawablePath::applyRelativePath (const RelativePointPath& newRelativePath, Expression::Scope* scope)
{
	Path newPath;
	newRelativePath.createPath (newPath, scope);

	if (path != newPath)
	{
		path.swapWithPath (newPath);
		pathChanged();
	}
}

class DrawablePath::RelativePositioner  : public RelativeCoordinatePositionerBase
{
public:
	RelativePositioner (DrawablePath& component_)
		: RelativeCoordinatePositionerBase (component_),
		  owner (component_)
	{
	}

	bool registerCoordinates()
	{
		bool ok = true;

		jassert (owner.relativePath != nullptr);
		const RelativePointPath& path = *owner.relativePath;

		for (int i = 0; i < path.elements.size(); ++i)
		{
			RelativePointPath::ElementBase* const e = path.elements.getUnchecked(i);

			int numPoints;
			RelativePoint* const points = e->getControlPoints (numPoints);

			for (int j = numPoints; --j >= 0;)
				ok = addPoint (points[j]) && ok;
		}

		return ok;
	}

	void applyToComponentBounds()
	{
		jassert (owner.relativePath != nullptr);

		ComponentScope scope (getComponent());
		owner.applyRelativePath (*owner.relativePath, &scope);
	}

	void applyNewBounds (const Rectangle<int>&)
	{
		jassertfalse; // drawables can't be resized directly!
	}

private:
	DrawablePath& owner;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (RelativePositioner);
};

void DrawablePath::setPath (const RelativePointPath& newRelativePath)
{
	if (newRelativePath.containsAnyDynamicPoints())
	{
		if (relativePath == nullptr || newRelativePath != *relativePath)
		{
			relativePath = new RelativePointPath (newRelativePath);

			RelativePositioner* const p = new RelativePositioner (*this);
			setPositioner (p);
			p->apply();
		}
	}
	else
	{
		relativePath = nullptr;
		applyRelativePath (newRelativePath, nullptr);
	}
}

const Identifier DrawablePath::valueTreeType ("Path");

const Identifier DrawablePath::ValueTreeWrapper::nonZeroWinding ("nonZeroWinding");
const Identifier DrawablePath::ValueTreeWrapper::point1 ("p1");
const Identifier DrawablePath::ValueTreeWrapper::point2 ("p2");
const Identifier DrawablePath::ValueTreeWrapper::point3 ("p3");

DrawablePath::ValueTreeWrapper::ValueTreeWrapper (const ValueTree& state_)
	: FillAndStrokeState (state_)
{
	jassert (state.hasType (valueTreeType));
}

ValueTree DrawablePath::ValueTreeWrapper::getPathState()
{
	return state.getOrCreateChildWithName (path, nullptr);
}

bool DrawablePath::ValueTreeWrapper::usesNonZeroWinding() const
{
	return state [nonZeroWinding];
}

void DrawablePath::ValueTreeWrapper::setUsesNonZeroWinding (bool b, UndoManager* undoManager)
{
	state.setProperty (nonZeroWinding, b, undoManager);
}

void DrawablePath::ValueTreeWrapper::readFrom (const RelativePointPath& relativePath, UndoManager* undoManager)
{
	setUsesNonZeroWinding (relativePath.usesNonZeroWinding, undoManager);

	ValueTree pathTree (getPathState());
	pathTree.removeAllChildren (undoManager);

	for (int i = 0; i < relativePath.elements.size(); ++i)
		pathTree.addChild (relativePath.elements.getUnchecked(i)->createTree(), -1, undoManager);
}

void DrawablePath::ValueTreeWrapper::writeTo (RelativePointPath& relativePath) const
{
	relativePath.usesNonZeroWinding = usesNonZeroWinding();
	RelativePoint points[3];

	const ValueTree pathTree (state.getChildWithName (path));
	const int num = pathTree.getNumChildren();
	for (int i = 0; i < num; ++i)
	{
		const Element e (pathTree.getChild(i));

		const int numCps = e.getNumControlPoints();
		for (int j = 0; j < numCps; ++j)
			points[j] = e.getControlPoint (j);

		RelativePointPath::ElementBase* newElement = nullptr;
		const Identifier t (e.getType());

		if      (t == Element::startSubPathElement)  newElement = new RelativePointPath::StartSubPath (points[0]);
		else if (t == Element::closeSubPathElement)  newElement = new RelativePointPath::CloseSubPath();
		else if (t == Element::lineToElement)        newElement = new RelativePointPath::LineTo (points[0]);
		else if (t == Element::quadraticToElement)   newElement = new RelativePointPath::QuadraticTo (points[0], points[1]);
		else if (t == Element::cubicToElement)       newElement = new RelativePointPath::CubicTo (points[0], points[1], points[2]);
		else                                         jassertfalse;

		relativePath.addElement (newElement);
	}
}

const Identifier DrawablePath::ValueTreeWrapper::Element::mode ("mode");
const Identifier DrawablePath::ValueTreeWrapper::Element::startSubPathElement ("Move");
const Identifier DrawablePath::ValueTreeWrapper::Element::closeSubPathElement ("Close");
const Identifier DrawablePath::ValueTreeWrapper::Element::lineToElement ("Line");
const Identifier DrawablePath::ValueTreeWrapper::Element::quadraticToElement ("Quad");
const Identifier DrawablePath::ValueTreeWrapper::Element::cubicToElement ("Cubic");

const char* DrawablePath::ValueTreeWrapper::Element::cornerMode = "corner";
const char* DrawablePath::ValueTreeWrapper::Element::roundedMode = "round";
const char* DrawablePath::ValueTreeWrapper::Element::symmetricMode = "symm";

DrawablePath::ValueTreeWrapper::Element::Element (const ValueTree& state_)
	: state (state_)
{
}

DrawablePath::ValueTreeWrapper::Element::~Element()
{
}

DrawablePath::ValueTreeWrapper DrawablePath::ValueTreeWrapper::Element::getParent() const
{
	return ValueTreeWrapper (state.getParent().getParent());
}

DrawablePath::ValueTreeWrapper::Element DrawablePath::ValueTreeWrapper::Element::getPreviousElement() const
{
	return Element (state.getSibling (-1));
}

int DrawablePath::ValueTreeWrapper::Element::getNumControlPoints() const noexcept
{
	const Identifier i (state.getType());
	if (i == startSubPathElement || i == lineToElement) return 1;
	if (i == quadraticToElement) return 2;
	if (i == cubicToElement) return 3;
	return 0;
}

RelativePoint DrawablePath::ValueTreeWrapper::Element::getControlPoint (const int index) const
{
	jassert (index >= 0 && index < getNumControlPoints());
	return RelativePoint (state [index == 0 ? point1 : (index == 1 ? point2 : point3)].toString());
}

Value DrawablePath::ValueTreeWrapper::Element::getControlPointValue (int index, UndoManager* undoManager)
{
	jassert (index >= 0 && index < getNumControlPoints());
	return state.getPropertyAsValue (index == 0 ? point1 : (index == 1 ? point2 : point3), undoManager);
}

void DrawablePath::ValueTreeWrapper::Element::setControlPoint (const int index, const RelativePoint& point, UndoManager* undoManager)
{
	jassert (index >= 0 && index < getNumControlPoints());
	state.setProperty (index == 0 ? point1 : (index == 1 ? point2 : point3), point.toString(), undoManager);
}

RelativePoint DrawablePath::ValueTreeWrapper::Element::getStartPoint() const
{
	const Identifier i (state.getType());

	if (i == startSubPathElement)
		return getControlPoint (0);

	jassert (i == lineToElement || i == quadraticToElement || i == cubicToElement || i == closeSubPathElement);

	return getPreviousElement().getEndPoint();
}

RelativePoint DrawablePath::ValueTreeWrapper::Element::getEndPoint() const
{
	const Identifier i (state.getType());
	if (i == startSubPathElement || i == lineToElement)  return getControlPoint (0);
	if (i == quadraticToElement)                         return getControlPoint (1);
	if (i == cubicToElement)                             return getControlPoint (2);

	jassert (i == closeSubPathElement);
	return RelativePoint();
}

float DrawablePath::ValueTreeWrapper::Element::getLength (Expression::Scope* scope) const
{
	const Identifier i (state.getType());

	if (i == lineToElement || i == closeSubPathElement)
		return getEndPoint().resolve (scope).getDistanceFrom (getStartPoint().resolve (scope));

	if (i == cubicToElement)
	{
		Path p;
		p.startNewSubPath (getStartPoint().resolve (scope));
		p.cubicTo (getControlPoint (0).resolve (scope), getControlPoint (1).resolve (scope), getControlPoint (2).resolve (scope));
		return p.getLength();
	}

	if (i == quadraticToElement)
	{
		Path p;
		p.startNewSubPath (getStartPoint().resolve (scope));
		p.quadraticTo (getControlPoint (0).resolve (scope), getControlPoint (1).resolve (scope));
		return p.getLength();
	}

	jassert (i == startSubPathElement);
	return 0;
}

String DrawablePath::ValueTreeWrapper::Element::getModeOfEndPoint() const
{
	return state [mode].toString();
}

void DrawablePath::ValueTreeWrapper::Element::setModeOfEndPoint (const String& newMode, UndoManager* undoManager)
{
	if (state.hasType (cubicToElement))
		state.setProperty (mode, newMode, undoManager);
}

void DrawablePath::ValueTreeWrapper::Element::convertToLine (UndoManager* undoManager)
{
	const Identifier i (state.getType());

	if (i == quadraticToElement || i == cubicToElement)
	{
		ValueTree newState (lineToElement);
		Element e (newState);
		e.setControlPoint (0, getEndPoint(), undoManager);
		state = newState;
	}
}

void DrawablePath::ValueTreeWrapper::Element::convertToCubic (Expression::Scope* scope, UndoManager* undoManager)
{
	const Identifier i (state.getType());

	if (i == lineToElement || i == quadraticToElement)
	{
		ValueTree newState (cubicToElement);
		Element e (newState);

		const RelativePoint start (getStartPoint());
		const RelativePoint end (getEndPoint());
		const Point<float> startResolved (start.resolve (scope));
		const Point<float> endResolved (end.resolve (scope));
		e.setControlPoint (0, startResolved + (endResolved - startResolved) * 0.3f, undoManager);
		e.setControlPoint (1, startResolved + (endResolved - startResolved) * 0.7f, undoManager);
		e.setControlPoint (2, end, undoManager);

		state = newState;
	}
}

void DrawablePath::ValueTreeWrapper::Element::convertToPathBreak (UndoManager* undoManager)
{
	const Identifier i (state.getType());

	if (i != startSubPathElement)
	{
		ValueTree newState (startSubPathElement);
		Element e (newState);
		e.setControlPoint (0, getEndPoint(), undoManager);
		state = newState;
	}
}

namespace DrawablePathHelpers
{
	Point<float> findCubicSubdivisionPoint (float proportion, const Point<float> points[4])
	{
		const Point<float> mid1 (points[0] + (points[1] - points[0]) * proportion),
						   mid2 (points[1] + (points[2] - points[1]) * proportion),
						   mid3 (points[2] + (points[3] - points[2]) * proportion);

		const Point<float> newCp1 (mid1 + (mid2 - mid1) * proportion),
						   newCp2 (mid2 + (mid3 - mid2) * proportion);

		return newCp1 + (newCp2 - newCp1) * proportion;
	}

	Point<float> findQuadraticSubdivisionPoint (float proportion, const Point<float> points[3])
	{
		const Point<float> mid1 (points[0] + (points[1] - points[0]) * proportion),
						   mid2 (points[1] + (points[2] - points[1]) * proportion);

		return mid1 + (mid2 - mid1) * proportion;
	}
}

float DrawablePath::ValueTreeWrapper::Element::findProportionAlongLine (const Point<float>& targetPoint, Expression::Scope* scope) const
{
	using namespace DrawablePathHelpers;
	const Identifier type (state.getType());
	float bestProp = 0;

	if (type == cubicToElement)
	{
		RelativePoint rp1 (getStartPoint()), rp2 (getControlPoint (0)), rp3 (getControlPoint (1)), rp4 (getEndPoint());

		const Point<float> points[] = { rp1.resolve (scope), rp2.resolve (scope), rp3.resolve (scope), rp4.resolve (scope) };

		float bestDistance = std::numeric_limits<float>::max();

		for (int i = 110; --i >= 0;)
		{
			float prop = i > 10 ? ((i - 10) / 100.0f) : (bestProp + ((i - 5) / 1000.0f));
			const Point<float> centre (findCubicSubdivisionPoint (prop, points));
			const float distance = centre.getDistanceFrom (targetPoint);

			if (distance < bestDistance)
			{
				bestProp = prop;
				bestDistance = distance;
			}
		}
	}
	else if (type == quadraticToElement)
	{
		RelativePoint rp1 (getStartPoint()), rp2 (getControlPoint (0)), rp3 (getEndPoint());
		const Point<float> points[] = { rp1.resolve (scope), rp2.resolve (scope), rp3.resolve (scope) };

		float bestDistance = std::numeric_limits<float>::max();

		for (int i = 110; --i >= 0;)
		{
			float prop = i > 10 ? ((i - 10) / 100.0f) : (bestProp + ((i - 5) / 1000.0f));
			const Point<float> centre (findQuadraticSubdivisionPoint ((float) prop, points));
			const float distance = centre.getDistanceFrom (targetPoint);

			if (distance < bestDistance)
			{
				bestProp = prop;
				bestDistance = distance;
			}
		}
	}
	else if (type == lineToElement)
	{
		RelativePoint rp1 (getStartPoint()), rp2 (getEndPoint());
		const Line<float> line (rp1.resolve (scope), rp2.resolve (scope));
		bestProp = line.findNearestProportionalPositionTo (targetPoint);
	}

	return bestProp;
}

ValueTree DrawablePath::ValueTreeWrapper::Element::insertPoint (const Point<float>& targetPoint, Expression::Scope* scope, UndoManager* undoManager)
{
	ValueTree newTree;
	const Identifier type (state.getType());

	if (type == cubicToElement)
	{
		float bestProp = findProportionAlongLine (targetPoint, scope);

		RelativePoint rp1 (getStartPoint()), rp2 (getControlPoint (0)), rp3 (getControlPoint (1)), rp4 (getEndPoint());
		const Point<float> points[] = { rp1.resolve (scope), rp2.resolve (scope), rp3.resolve (scope), rp4.resolve (scope) };

		const Point<float> mid1 (points[0] + (points[1] - points[0]) * bestProp),
						   mid2 (points[1] + (points[2] - points[1]) * bestProp),
						   mid3 (points[2] + (points[3] - points[2]) * bestProp);

		const Point<float> newCp1 (mid1 + (mid2 - mid1) * bestProp),
						   newCp2 (mid2 + (mid3 - mid2) * bestProp);

		const Point<float> newCentre (newCp1 + (newCp2 - newCp1) * bestProp);

		setControlPoint (0, mid1, undoManager);
		setControlPoint (1, newCp1, undoManager);
		setControlPoint (2, newCentre, undoManager);
		setModeOfEndPoint (roundedMode, undoManager);

		Element newElement (newTree = ValueTree (cubicToElement));
		newElement.setControlPoint (0, newCp2, nullptr);
		newElement.setControlPoint (1, mid3, nullptr);
		newElement.setControlPoint (2, rp4, nullptr);

		state.getParent().addChild (newTree, state.getParent().indexOf (state) + 1, undoManager);
	}
	else if (type == quadraticToElement)
	{
		float bestProp = findProportionAlongLine (targetPoint, scope);

		RelativePoint rp1 (getStartPoint()), rp2 (getControlPoint (0)), rp3 (getEndPoint());
		const Point<float> points[] = { rp1.resolve (scope), rp2.resolve (scope), rp3.resolve (scope) };

		const Point<float> mid1 (points[0] + (points[1] - points[0]) * bestProp),
						   mid2 (points[1] + (points[2] - points[1]) * bestProp);

		const Point<float> newCentre (mid1 + (mid2 - mid1) * bestProp);

		setControlPoint (0, mid1, undoManager);
		setControlPoint (1, newCentre, undoManager);
		setModeOfEndPoint (roundedMode, undoManager);

		Element newElement (newTree = ValueTree (quadraticToElement));
		newElement.setControlPoint (0, mid2, nullptr);
		newElement.setControlPoint (1, rp3, nullptr);

		state.getParent().addChild (newTree, state.getParent().indexOf (state) + 1, undoManager);
	}
	else if (type == lineToElement)
	{
		RelativePoint rp1 (getStartPoint()), rp2 (getEndPoint());
		const Line<float> line (rp1.resolve (scope), rp2.resolve (scope));
		const Point<float> newPoint (line.findNearestPointTo (targetPoint));

		setControlPoint (0, newPoint, undoManager);

		Element newElement (newTree = ValueTree (lineToElement));
		newElement.setControlPoint (0, rp2, nullptr);

		state.getParent().addChild (newTree, state.getParent().indexOf (state) + 1, undoManager);
	}
	else if (type == closeSubPathElement)
	{
	}

	return newTree;
}

void DrawablePath::ValueTreeWrapper::Element::removePoint (UndoManager* undoManager)
{
	state.getParent().removeChild (state, undoManager);
}

void DrawablePath::refreshFromValueTree (const ValueTree& tree, ComponentBuilder& builder)
{
	ValueTreeWrapper v (tree);
	setComponentID (v.getID());

	refreshFillTypes (v, builder.getImageProvider());
	setStrokeType (v.getStrokeType());

	RelativePointPath newRelativePath;
	v.writeTo (newRelativePath);
	setPath (newRelativePath);
}

ValueTree DrawablePath::createValueTree (ComponentBuilder::ImageProvider* imageProvider) const
{
	ValueTree tree (valueTreeType);
	ValueTreeWrapper v (tree);

	v.setID (getComponentID());
	writeTo (v, imageProvider, nullptr);

	if (relativePath != nullptr)
		v.readFrom (*relativePath, nullptr);
	else
		v.readFrom (RelativePointPath (path), nullptr);

	return tree;
}

/*** End of inlined file: juce_DrawablePath.cpp ***/


/*** Start of inlined file: juce_DrawableRectangle.cpp ***/
DrawableRectangle::DrawableRectangle()
{
}

DrawableRectangle::DrawableRectangle (const DrawableRectangle& other)
	: DrawableShape (other),
	  bounds (other.bounds),
	  cornerSize (other.cornerSize)
{
}

DrawableRectangle::~DrawableRectangle()
{
}

Drawable* DrawableRectangle::createCopy() const
{
	return new DrawableRectangle (*this);
}

void DrawableRectangle::setRectangle (const RelativeParallelogram& newBounds)
{
	if (bounds != newBounds)
	{
		bounds = newBounds;
		rebuildPath();
	}
}

void DrawableRectangle::setCornerSize (const RelativePoint& newSize)
{
	if (cornerSize != newSize)
	{
		cornerSize = newSize;
		rebuildPath();
	}
}

void DrawableRectangle::rebuildPath()
{
	if (bounds.isDynamic() || cornerSize.isDynamic())
	{
		Drawable::Positioner<DrawableRectangle>* const p = new Drawable::Positioner<DrawableRectangle> (*this);
		setPositioner (p);
		p->apply();
	}
	else
	{
		setPositioner (0);
		recalculateCoordinates (0);
	}
}

bool DrawableRectangle::registerCoordinates (RelativeCoordinatePositionerBase& pos)
{
	bool ok = pos.addPoint (bounds.topLeft);
	ok = pos.addPoint (bounds.topRight) && ok;
	ok = pos.addPoint (bounds.bottomLeft) && ok;
	return pos.addPoint (cornerSize) && ok;
}

void DrawableRectangle::recalculateCoordinates (Expression::Scope* scope)
{
	Point<float> points[3];
	bounds.resolveThreePoints (points, scope);

	const float cornerSizeX = (float) cornerSize.x.resolve (scope);
	const float cornerSizeY = (float) cornerSize.y.resolve (scope);

	const float w = Line<float> (points[0], points[1]).getLength();
	const float h = Line<float> (points[0], points[2]).getLength();

	Path newPath;

	if (cornerSizeX > 0 && cornerSizeY > 0)
		newPath.addRoundedRectangle (0, 0, w, h, cornerSizeX, cornerSizeY);
	else
		newPath.addRectangle (0, 0, w, h);

	newPath.applyTransform (AffineTransform::fromTargetPoints (0, 0, points[0].x, points[0].y,
															   w, 0, points[1].x, points[1].y,
															   0, h, points[2].x, points[2].y));

	if (path != newPath)
	{
		path.swapWithPath (newPath);
		pathChanged();
	}
}

const Identifier DrawableRectangle::valueTreeType ("Rectangle");
const Identifier DrawableRectangle::ValueTreeWrapper::topLeft ("topLeft");
const Identifier DrawableRectangle::ValueTreeWrapper::topRight ("topRight");
const Identifier DrawableRectangle::ValueTreeWrapper::bottomLeft ("bottomLeft");
const Identifier DrawableRectangle::ValueTreeWrapper::cornerSize ("cornerSize");

DrawableRectangle::ValueTreeWrapper::ValueTreeWrapper (const ValueTree& state_)
	: FillAndStrokeState (state_)
{
	jassert (state.hasType (valueTreeType));
}

RelativeParallelogram DrawableRectangle::ValueTreeWrapper::getRectangle() const
{
	return RelativeParallelogram (state.getProperty (topLeft, "0, 0"),
								  state.getProperty (topRight, "100, 0"),
								  state.getProperty (bottomLeft, "0, 100"));
}

void DrawableRectangle::ValueTreeWrapper::setRectangle (const RelativeParallelogram& newBounds, UndoManager* undoManager)
{
	state.setProperty (topLeft, newBounds.topLeft.toString(), undoManager);
	state.setProperty (topRight, newBounds.topRight.toString(), undoManager);
	state.setProperty (bottomLeft, newBounds.bottomLeft.toString(), undoManager);
}

void DrawableRectangle::ValueTreeWrapper::setCornerSize (const RelativePoint& newSize, UndoManager* undoManager)
{
	state.setProperty (cornerSize, newSize.toString(), undoManager);
}

RelativePoint DrawableRectangle::ValueTreeWrapper::getCornerSize() const
{
	return RelativePoint (state [cornerSize]);
}

Value DrawableRectangle::ValueTreeWrapper::getCornerSizeValue (UndoManager* undoManager)
{
	return state.getPropertyAsValue (cornerSize, undoManager);
}

void DrawableRectangle::refreshFromValueTree (const ValueTree& tree, ComponentBuilder& builder)
{
	ValueTreeWrapper v (tree);
	setComponentID (v.getID());

	refreshFillTypes (v, builder.getImageProvider());
	setStrokeType (v.getStrokeType());
	setRectangle (v.getRectangle());
	setCornerSize (v.getCornerSize());
}

ValueTree DrawableRectangle::createValueTree (ComponentBuilder::ImageProvider* imageProvider) const
{
	ValueTree tree (valueTreeType);
	ValueTreeWrapper v (tree);

	v.setID (getComponentID());
	writeTo (v, imageProvider, nullptr);
	v.setRectangle (bounds, nullptr);
	v.setCornerSize (cornerSize, nullptr);

	return tree;
}

/*** End of inlined file: juce_DrawableRectangle.cpp ***/


/*** Start of inlined file: juce_DrawableShape.cpp ***/
DrawableShape::DrawableShape()
	: strokeType (0.0f),
	  mainFill (Colours::black),
	  strokeFill (Colours::black)
{
}

DrawableShape::DrawableShape (const DrawableShape& other)
	: strokeType (other.strokeType),
	  mainFill (other.mainFill),
	  strokeFill (other.strokeFill)
{
}

DrawableShape::~DrawableShape()
{
}

class DrawableShape::RelativePositioner  : public RelativeCoordinatePositionerBase
{
public:
	RelativePositioner (DrawableShape& component_, const DrawableShape::RelativeFillType& fill_, bool isMainFill_)
		: RelativeCoordinatePositionerBase (component_),
		  owner (component_),
		  fill (fill_),
		  isMainFill (isMainFill_)
	{
	}

	bool registerCoordinates()
	{
		bool ok = addPoint (fill.gradientPoint1);
		ok = addPoint (fill.gradientPoint2) && ok;
		return addPoint (fill.gradientPoint3) && ok;
	}

	void applyToComponentBounds()
	{
		ComponentScope scope (owner);
		if (isMainFill ? owner.mainFill.recalculateCoords (&scope)
					   : owner.strokeFill.recalculateCoords (&scope))
			owner.repaint();
	}

	void applyNewBounds (const Rectangle<int>&)
	{
		jassertfalse; // drawables can't be resized directly!
	}

private:
	DrawableShape& owner;
	const DrawableShape::RelativeFillType fill;
	const bool isMainFill;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (RelativePositioner);
};

void DrawableShape::setFill (const FillType& newFill)
{
	setFill (RelativeFillType (newFill));
}

void DrawableShape::setStrokeFill (const FillType& newFill)
{
	setStrokeFill (RelativeFillType (newFill));
}

void DrawableShape::setFillInternal (RelativeFillType& fill, const RelativeFillType& newFill,
									 ScopedPointer<RelativeCoordinatePositionerBase>& pos)
{
	if (fill != newFill)
	{
		fill = newFill;
		pos = nullptr;

		if (fill.isDynamic())
		{
			pos = new RelativePositioner (*this, fill, true);
			pos->apply();
		}
		else
		{
			fill.recalculateCoords (nullptr);
		}

		repaint();
	}
}

void DrawableShape::setFill (const RelativeFillType& newFill)
{
	setFillInternal (mainFill, newFill, mainFillPositioner);
}

void DrawableShape::setStrokeFill (const RelativeFillType& newFill)
{
	setFillInternal (strokeFill, newFill, strokeFillPositioner);
}

void DrawableShape::setStrokeType (const PathStrokeType& newStrokeType)
{
	if (strokeType != newStrokeType)
	{
		strokeType = newStrokeType;
		strokeChanged();
	}
}

void DrawableShape::setStrokeThickness (const float newThickness)
{
	setStrokeType (PathStrokeType (newThickness, strokeType.getJointStyle(), strokeType.getEndStyle()));
}

bool DrawableShape::isStrokeVisible() const noexcept
{
	return strokeType.getStrokeThickness() > 0.0f && ! strokeFill.fill.isInvisible();
}

void DrawableShape::refreshFillTypes (const FillAndStrokeState& newState, ComponentBuilder::ImageProvider* imageProvider)
{
	setFill (newState.getFill (FillAndStrokeState::fill, imageProvider));
	setStrokeFill (newState.getFill (FillAndStrokeState::stroke, imageProvider));
}

void DrawableShape::writeTo (FillAndStrokeState& state, ComponentBuilder::ImageProvider* imageProvider, UndoManager* undoManager) const
{
	state.setFill (FillAndStrokeState::fill, mainFill, imageProvider, undoManager);
	state.setFill (FillAndStrokeState::stroke, strokeFill, imageProvider, undoManager);
	state.setStrokeType (strokeType, undoManager);
}

void DrawableShape::paint (Graphics& g)
{
	transformContextToCorrectOrigin (g);

	g.setFillType (mainFill.fill);
	g.fillPath (path);

	if (isStrokeVisible())
	{
		g.setFillType (strokeFill.fill);
		g.fillPath (strokePath);
	}
}

void DrawableShape::pathChanged()
{
	strokeChanged();
}

void DrawableShape::strokeChanged()
{
	strokePath.clear();
	strokeType.createStrokedPath (strokePath, path, AffineTransform::identity, 4.0f);

	setBoundsToEnclose (getDrawableBounds());
	repaint();
}

Rectangle<float> DrawableShape::getDrawableBounds() const
{
	if (isStrokeVisible())
		return strokePath.getBounds();
	else
		return path.getBounds();
}

bool DrawableShape::hitTest (int x, int y)
{
	bool allowsClicksOnThisComponent, allowsClicksOnChildComponents;
	getInterceptsMouseClicks (allowsClicksOnThisComponent, allowsClicksOnChildComponents);

	if (! allowsClicksOnThisComponent)
		return false;

	const float globalX = (float) (x - originRelativeToComponent.x);
	const float globalY = (float) (y - originRelativeToComponent.y);

	return path.contains (globalX, globalY)
			|| (isStrokeVisible() && strokePath.contains (globalX, globalY));
}

DrawableShape::RelativeFillType::RelativeFillType()
{
}

DrawableShape::RelativeFillType::RelativeFillType (const FillType& fill_)
	: fill (fill_)
{
	if (fill.isGradient())
	{
		const ColourGradient& g = *fill.gradient;

		gradientPoint1 = g.point1.transformedBy (fill.transform);
		gradientPoint2 = g.point2.transformedBy (fill.transform);
		gradientPoint3 = Point<float> (g.point1.x + g.point2.y - g.point1.y,
									   g.point1.y + g.point1.x - g.point2.x)
							.transformedBy (fill.transform);
		fill.transform = AffineTransform::identity;
	}
}

DrawableShape::RelativeFillType::RelativeFillType (const RelativeFillType& other)
	: fill (other.fill),
	  gradientPoint1 (other.gradientPoint1),
	  gradientPoint2 (other.gradientPoint2),
	  gradientPoint3 (other.gradientPoint3)
{
}

DrawableShape::RelativeFillType& DrawableShape::RelativeFillType::operator= (const RelativeFillType& other)
{
	fill = other.fill;
	gradientPoint1 = other.gradientPoint1;
	gradientPoint2 = other.gradientPoint2;
	gradientPoint3 = other.gradientPoint3;
	return *this;
}

bool DrawableShape::RelativeFillType::operator== (const RelativeFillType& other) const
{
	return fill == other.fill
		&& ((! fill.isGradient())
			 || (gradientPoint1 == other.gradientPoint1
				 && gradientPoint2 == other.gradientPoint2
				 && gradientPoint3 == other.gradientPoint3));
}

bool DrawableShape::RelativeFillType::operator!= (const RelativeFillType& other) const
{
	return ! operator== (other);
}

bool DrawableShape::RelativeFillType::recalculateCoords (Expression::Scope* scope)
{
	if (fill.isGradient())
	{
		const Point<float> g1 (gradientPoint1.resolve (scope));
		const Point<float> g2 (gradientPoint2.resolve (scope));
		AffineTransform t;

		ColourGradient& g = *fill.gradient;

		if (g.isRadial)
		{
			const Point<float> g3 (gradientPoint3.resolve (scope));
			const Point<float> g3Source (g1.x + g2.y - g1.y,
										 g1.y + g1.x - g2.x);

			t = AffineTransform::fromTargetPoints (g1.x, g1.y, g1.x, g1.y,
												   g2.x, g2.y, g2.x, g2.y,
												   g3Source.x, g3Source.y, g3.x, g3.y);
		}

		if (g.point1 != g1 || g.point2 != g2 || fill.transform != t)
		{
			g.point1 = g1;
			g.point2 = g2;
			fill.transform = t;
			return true;
		}
	}

	return false;
}

bool DrawableShape::RelativeFillType::isDynamic() const
{
	return gradientPoint1.isDynamic() || gradientPoint2.isDynamic() || gradientPoint3.isDynamic();
}

void DrawableShape::RelativeFillType::writeTo (ValueTree& v, ComponentBuilder::ImageProvider* imageProvider, UndoManager* undoManager) const
{
	if (fill.isColour())
	{
		v.setProperty (FillAndStrokeState::type, "solid", undoManager);
		v.setProperty (FillAndStrokeState::colour, String::toHexString ((int) fill.colour.getARGB()), undoManager);
	}
	else if (fill.isGradient())
	{
		v.setProperty (FillAndStrokeState::type, "gradient", undoManager);
		v.setProperty (FillAndStrokeState::gradientPoint1, gradientPoint1.toString(), undoManager);
		v.setProperty (FillAndStrokeState::gradientPoint2, gradientPoint2.toString(), undoManager);
		v.setProperty (FillAndStrokeState::gradientPoint3, gradientPoint3.toString(), undoManager);

		const ColourGradient& cg = *fill.gradient;
		v.setProperty (FillAndStrokeState::radial, cg.isRadial, undoManager);

		String s;
		for (int i = 0; i < cg.getNumColours(); ++i)
			s << ' ' << cg.getColourPosition (i)
			  << ' ' << String::toHexString ((int) cg.getColour(i).getARGB());

		v.setProperty (FillAndStrokeState::colours, s.trimStart(), undoManager);
	}
	else if (fill.isTiledImage())
	{
		v.setProperty (FillAndStrokeState::type, "image", undoManager);

		if (imageProvider != nullptr)
			v.setProperty (FillAndStrokeState::imageId, imageProvider->getIdentifierForImage (fill.image), undoManager);

		if (fill.getOpacity() < 1.0f)
			v.setProperty (FillAndStrokeState::imageOpacity, fill.getOpacity(), undoManager);
		else
			v.removeProperty (FillAndStrokeState::imageOpacity, undoManager);
	}
	else
	{
		jassertfalse;
	}
}

bool DrawableShape::RelativeFillType::readFrom (const ValueTree& v, ComponentBuilder::ImageProvider* imageProvider)
{
	const String newType (v [FillAndStrokeState::type].toString());

	if (newType == "solid")
	{
		const String colourString (v [FillAndStrokeState::colour].toString());
		fill.setColour (colourString.isEmpty() ? Colours::black
											   : Colour::fromString (colourString));
		return true;
	}
	else if (newType == "gradient")
	{
		ColourGradient g;
		g.isRadial = v [FillAndStrokeState::radial];

		StringArray colourSteps;
		colourSteps.addTokens (v [FillAndStrokeState::colours].toString(), false);

		for (int i = 0; i < colourSteps.size() / 2; ++i)
			g.addColour (colourSteps[i * 2].getDoubleValue(),
						 Colour::fromString (colourSteps[i * 2 + 1]));

		fill.setGradient (g);

		gradientPoint1 = RelativePoint (v [FillAndStrokeState::gradientPoint1]);
		gradientPoint2 = RelativePoint (v [FillAndStrokeState::gradientPoint2]);
		gradientPoint3 = RelativePoint (v [FillAndStrokeState::gradientPoint3]);
		return true;
	}
	else if (newType == "image")
	{
		Image im;
		if (imageProvider != nullptr)
			im = imageProvider->getImageForIdentifier (v [FillAndStrokeState::imageId]);

		fill.setTiledImage (im, AffineTransform::identity);
		fill.setOpacity ((float) v.getProperty (FillAndStrokeState::imageOpacity, 1.0f));
		return true;
	}

	jassertfalse;
	return false;
}

const Identifier DrawableShape::FillAndStrokeState::type ("type");
const Identifier DrawableShape::FillAndStrokeState::colour ("colour");
const Identifier DrawableShape::FillAndStrokeState::colours ("colours");
const Identifier DrawableShape::FillAndStrokeState::fill ("Fill");
const Identifier DrawableShape::FillAndStrokeState::stroke ("Stroke");
const Identifier DrawableShape::FillAndStrokeState::path ("Path");
const Identifier DrawableShape::FillAndStrokeState::jointStyle ("jointStyle");
const Identifier DrawableShape::FillAndStrokeState::capStyle ("capStyle");
const Identifier DrawableShape::FillAndStrokeState::strokeWidth ("strokeWidth");
const Identifier DrawableShape::FillAndStrokeState::gradientPoint1 ("point1");
const Identifier DrawableShape::FillAndStrokeState::gradientPoint2 ("point2");
const Identifier DrawableShape::FillAndStrokeState::gradientPoint3 ("point3");
const Identifier DrawableShape::FillAndStrokeState::radial ("radial");
const Identifier DrawableShape::FillAndStrokeState::imageId ("imageId");
const Identifier DrawableShape::FillAndStrokeState::imageOpacity ("imageOpacity");

DrawableShape::FillAndStrokeState::FillAndStrokeState (const ValueTree& state_)
	: Drawable::ValueTreeWrapperBase (state_)
{
}

DrawableShape::RelativeFillType DrawableShape::FillAndStrokeState::getFill (const Identifier& fillOrStrokeType, ComponentBuilder::ImageProvider* imageProvider) const
{
	DrawableShape::RelativeFillType f;
	f.readFrom (state.getChildWithName (fillOrStrokeType), imageProvider);
	return f;
}

ValueTree DrawableShape::FillAndStrokeState::getFillState (const Identifier& fillOrStrokeType)
{
	ValueTree v (state.getChildWithName (fillOrStrokeType));
	if (v.isValid())
		return v;

	setFill (fillOrStrokeType, FillType (Colours::black), nullptr, nullptr);
	return getFillState (fillOrStrokeType);
}

void DrawableShape::FillAndStrokeState::setFill (const Identifier& fillOrStrokeType, const RelativeFillType& newFill,
												 ComponentBuilder::ImageProvider* imageProvider, UndoManager* undoManager)
{
	ValueTree v (state.getOrCreateChildWithName (fillOrStrokeType, undoManager));
	newFill.writeTo (v, imageProvider, undoManager);
}

PathStrokeType DrawableShape::FillAndStrokeState::getStrokeType() const
{
	const String jointStyleString (state [jointStyle].toString());
	const String capStyleString (state [capStyle].toString());

	return PathStrokeType (state [strokeWidth],
						   jointStyleString == "curved" ? PathStrokeType::curved
														: (jointStyleString == "bevel" ? PathStrokeType::beveled
																					   : PathStrokeType::mitered),
						   capStyleString == "square" ? PathStrokeType::square
													  : (capStyleString == "round" ? PathStrokeType::rounded
																				   : PathStrokeType::butt));
}

void DrawableShape::FillAndStrokeState::setStrokeType (const PathStrokeType& newStrokeType, UndoManager* undoManager)
{
	state.setProperty (strokeWidth, (double) newStrokeType.getStrokeThickness(), undoManager);
	state.setProperty (jointStyle, newStrokeType.getJointStyle() == PathStrokeType::mitered
									 ? "miter" : (newStrokeType.getJointStyle() == PathStrokeType::curved ? "curved" : "bevel"), undoManager);
	state.setProperty (capStyle, newStrokeType.getEndStyle() == PathStrokeType::butt
									 ? "butt" : (newStrokeType.getEndStyle() == PathStrokeType::square ? "square" : "round"), undoManager);
}

/*** End of inlined file: juce_DrawableShape.cpp ***/


/*** Start of inlined file: juce_DrawableText.cpp ***/
DrawableText::DrawableText()
	: colour (Colours::black),
	  justification (Justification::centredLeft)
{
	setBoundingBox (RelativeParallelogram (RelativePoint (0.0f, 0.0f),
										   RelativePoint (50.0f, 0.0f),
										   RelativePoint (0.0f, 20.0f)));
	setFont (Font (15.0f), true);
}

DrawableText::DrawableText (const DrawableText& other)
	: bounds (other.bounds),
	  fontHeight (other.fontHeight),
	  fontHScale (other.fontHScale),
	  font (other.font),
	  text (other.text),
	  colour (other.colour),
	  justification (other.justification)
{
}

DrawableText::~DrawableText()
{
}

void DrawableText::setText (const String& newText)
{
	if (text != newText)
	{
		text = newText;
		refreshBounds();
	}
}

void DrawableText::setColour (const Colour& newColour)
{
	if (colour != newColour)
	{
		colour = newColour;
		repaint();
	}
}

void DrawableText::setFont (const Font& newFont, bool applySizeAndScale)
{
	if (font != newFont)
	{
		font = newFont;

		if (applySizeAndScale)
		{
			fontHeight = font.getHeight();
			fontHScale = font.getHorizontalScale();
		}

		refreshBounds();
	}
}

void DrawableText::setJustification (const Justification& newJustification)
{
	justification = newJustification;
	repaint();
}

void DrawableText::setBoundingBox (const RelativeParallelogram& newBounds)
{
	if (bounds != newBounds)
	{
		bounds = newBounds;
		refreshBounds();
	}
}

void DrawableText::setFontHeight (const RelativeCoordinate& newHeight)
{
	if (fontHeight != newHeight)
	{
		fontHeight = newHeight;
		refreshBounds();
	}
}

void DrawableText::setFontHorizontalScale (const RelativeCoordinate& newScale)
{
	if (fontHScale != newScale)
	{
		fontHScale = newScale;
		refreshBounds();
	}
}

void DrawableText::refreshBounds()
{
	if (bounds.isDynamic() || fontHeight.isDynamic() || fontHScale.isDynamic())
	{
		Drawable::Positioner<DrawableText>* const p = new Drawable::Positioner<DrawableText> (*this);
		setPositioner (p);
		p->apply();
	}
	else
	{
		setPositioner (0);
		recalculateCoordinates (0);
	}
}

bool DrawableText::registerCoordinates (RelativeCoordinatePositionerBase& pos)
{
	bool ok = pos.addPoint (bounds.topLeft);
	ok = pos.addPoint (bounds.topRight) && ok;
	ok = pos.addPoint (bounds.bottomLeft) && ok;
	ok = pos.addCoordinate (fontHeight) && ok;
	return pos.addCoordinate (fontHScale) && ok;
}

void DrawableText::recalculateCoordinates (Expression::Scope* scope)
{
	bounds.resolveThreePoints (resolvedPoints, scope);

	const float w = Line<float> (resolvedPoints[0], resolvedPoints[1]).getLength();
	const float h = Line<float> (resolvedPoints[0], resolvedPoints[2]).getLength();

	const float height = jlimit (0.01f, jmax (0.01f, h), (float) fontHeight.resolve (scope));
	const float hscale = jlimit (0.01f, jmax (0.01f, w), (float) fontHScale.resolve (scope));

	scaledFont = font;
	scaledFont.setHeight (height);
	scaledFont.setHorizontalScale (hscale);

	setBoundsToEnclose (getDrawableBounds());
	repaint();
}

const AffineTransform DrawableText::getArrangementAndTransform (GlyphArrangement& glyphs) const
{
	const float w = Line<float> (resolvedPoints[0], resolvedPoints[1]).getLength();
	const float h = Line<float> (resolvedPoints[0], resolvedPoints[2]).getLength();

	glyphs.addFittedText (scaledFont, text, 0, 0, w, h, justification, 0x100000);

	return AffineTransform::fromTargetPoints (0, 0, resolvedPoints[0].x, resolvedPoints[0].y,
											  w, 0, resolvedPoints[1].x, resolvedPoints[1].y,
											  0, h, resolvedPoints[2].x, resolvedPoints[2].y);
}

void DrawableText::paint (Graphics& g)
{
	transformContextToCorrectOrigin (g);

	g.setColour (colour);

	GlyphArrangement ga;
	const AffineTransform transform (getArrangementAndTransform (ga));
	ga.draw (g, transform);
}

Rectangle<float> DrawableText::getDrawableBounds() const
{
	return RelativeParallelogram::getBoundingBox (resolvedPoints);
}

Drawable* DrawableText::createCopy() const
{
	return new DrawableText (*this);
}

const Identifier DrawableText::valueTreeType ("Text");

const Identifier DrawableText::ValueTreeWrapper::text ("text");
const Identifier DrawableText::ValueTreeWrapper::colour ("colour");
const Identifier DrawableText::ValueTreeWrapper::font ("font");
const Identifier DrawableText::ValueTreeWrapper::justification ("justification");
const Identifier DrawableText::ValueTreeWrapper::topLeft ("topLeft");
const Identifier DrawableText::ValueTreeWrapper::topRight ("topRight");
const Identifier DrawableText::ValueTreeWrapper::bottomLeft ("bottomLeft");
const Identifier DrawableText::ValueTreeWrapper::fontHeight ("fontHeight");
const Identifier DrawableText::ValueTreeWrapper::fontHScale ("fontHScale");

DrawableText::ValueTreeWrapper::ValueTreeWrapper (const ValueTree& state_)
	: ValueTreeWrapperBase (state_)
{
	jassert (state.hasType (valueTreeType));
}

String DrawableText::ValueTreeWrapper::getText() const
{
	return state [text].toString();
}

void DrawableText::ValueTreeWrapper::setText (const String& newText, UndoManager* undoManager)
{
	state.setProperty (text, newText, undoManager);
}

Value DrawableText::ValueTreeWrapper::getTextValue (UndoManager* undoManager)
{
	return state.getPropertyAsValue (text, undoManager);
}

Colour DrawableText::ValueTreeWrapper::getColour() const
{
	return Colour::fromString (state [colour].toString());
}

void DrawableText::ValueTreeWrapper::setColour (const Colour& newColour, UndoManager* undoManager)
{
	state.setProperty (colour, newColour.toString(), undoManager);
}

Justification DrawableText::ValueTreeWrapper::getJustification() const
{
	return Justification ((int) state [justification]);
}

void DrawableText::ValueTreeWrapper::setJustification (const Justification& newJustification, UndoManager* undoManager)
{
	state.setProperty (justification, newJustification.getFlags(), undoManager);
}

Font DrawableText::ValueTreeWrapper::getFont() const
{
	return Font::fromString (state [font]);
}

void DrawableText::ValueTreeWrapper::setFont (const Font& newFont, UndoManager* undoManager)
{
	state.setProperty (font, newFont.toString(), undoManager);
}

Value DrawableText::ValueTreeWrapper::getFontValue (UndoManager* undoManager)
{
	return state.getPropertyAsValue (font, undoManager);
}

RelativeParallelogram DrawableText::ValueTreeWrapper::getBoundingBox() const
{
	return RelativeParallelogram (state [topLeft].toString(), state [topRight].toString(), state [bottomLeft].toString());
}

void DrawableText::ValueTreeWrapper::setBoundingBox (const RelativeParallelogram& newBounds, UndoManager* undoManager)
{
	state.setProperty (topLeft, newBounds.topLeft.toString(), undoManager);
	state.setProperty (topRight, newBounds.topRight.toString(), undoManager);
	state.setProperty (bottomLeft, newBounds.bottomLeft.toString(), undoManager);
}

RelativeCoordinate DrawableText::ValueTreeWrapper::getFontHeight() const
{
	return state [fontHeight].toString();
}

void DrawableText::ValueTreeWrapper::setFontHeight (const RelativeCoordinate& coord, UndoManager* undoManager)
{
	state.setProperty (fontHeight, coord.toString(), undoManager);
}

RelativeCoordinate DrawableText::ValueTreeWrapper::getFontHorizontalScale() const
{
	return state [fontHScale].toString();
}

void DrawableText::ValueTreeWrapper::setFontHorizontalScale (const RelativeCoordinate& coord, UndoManager* undoManager)
{
	state.setProperty (fontHScale, coord.toString(), undoManager);
}

void DrawableText::refreshFromValueTree (const ValueTree& tree, ComponentBuilder&)
{
	ValueTreeWrapper v (tree);
	setComponentID (v.getID());

	const RelativeParallelogram newBounds (v.getBoundingBox());
	const RelativeCoordinate newFontHeight (v.getFontHeight());
	const RelativeCoordinate newFontHScale (v.getFontHorizontalScale());
	const Colour newColour (v.getColour());
	const Justification newJustification (v.getJustification());
	const String newText (v.getText());
	const Font newFont (v.getFont());

	if (text != newText || font != newFont || justification != newJustification
		 || colour != newColour || bounds != newBounds
		 || newFontHeight != fontHeight || newFontHScale != fontHScale)
	{
		setBoundingBox (newBounds);
		setFontHeight (newFontHeight);
		setFontHorizontalScale (newFontHScale);
		setColour (newColour);
		setFont (newFont, false);
		setJustification (newJustification);
		setText (newText);
	}
}

ValueTree DrawableText::createValueTree (ComponentBuilder::ImageProvider*) const
{
	ValueTree tree (valueTreeType);
	ValueTreeWrapper v (tree);

	v.setID (getComponentID());
	v.setText (text, nullptr);
	v.setFont (font, nullptr);
	v.setJustification (justification, nullptr);
	v.setColour (colour, nullptr);
	v.setBoundingBox (bounds, nullptr);
	v.setFontHeight (fontHeight, nullptr);
	v.setFontHorizontalScale (fontHScale, nullptr);

	return tree;
}

/*** End of inlined file: juce_DrawableText.cpp ***/


/*** Start of inlined file: juce_SVGParser.cpp ***/
class SVGState
{
public:

	SVGState (const XmlElement* const topLevel)
		: topLevelXml (topLevel),
		  elementX (0), elementY (0),
		  width (512), height (512),
		  viewBoxW (0), viewBoxH (0)
	{
	}

	Drawable* parseSVGElement (const XmlElement& xml)
	{
		if (! xml.hasTagName ("svg"))
			return nullptr;

		DrawableComposite* const drawable = new DrawableComposite();

		drawable->setName (xml.getStringAttribute ("id"));

		SVGState newState (*this);

		if (xml.hasAttribute ("transform"))
			newState.addTransform (xml);

		newState.elementX = getCoordLength (xml.getStringAttribute ("x", String (newState.elementX)), viewBoxW);
		newState.elementY = getCoordLength (xml.getStringAttribute ("y", String (newState.elementY)), viewBoxH);
		newState.width    = getCoordLength (xml.getStringAttribute ("width", String (newState.width)), viewBoxW);
		newState.height   = getCoordLength (xml.getStringAttribute ("height", String (newState.height)), viewBoxH);

		if (newState.width <= 0)  newState.width  = 100;
		if (newState.height <= 0) newState.height = 100;

		if (xml.hasAttribute ("viewBox"))
		{
			const String viewBoxAtt (xml.getStringAttribute ("viewBox"));
			String::CharPointerType viewParams (viewBoxAtt.getCharPointer());
			float vx, vy, vw, vh;

			if (parseCoords (viewParams, vx, vy, true)
				 && parseCoords (viewParams, vw, vh, true)
				 && vw > 0
				 && vh > 0)
			{
				newState.viewBoxW = vw;
				newState.viewBoxH = vh;

				int placementFlags = 0;

				const String aspect (xml.getStringAttribute ("preserveAspectRatio"));

				if (aspect.containsIgnoreCase ("none"))
				{
					placementFlags = RectanglePlacement::stretchToFit;
				}
				else
				{
					if (aspect.containsIgnoreCase ("slice"))
						placementFlags |= RectanglePlacement::fillDestination;

					if (aspect.containsIgnoreCase ("xMin"))
						placementFlags |= RectanglePlacement::xLeft;
					else if (aspect.containsIgnoreCase ("xMax"))
						placementFlags |= RectanglePlacement::xRight;
					else
						placementFlags |= RectanglePlacement::xMid;

					if (aspect.containsIgnoreCase ("yMin"))
						placementFlags |= RectanglePlacement::yTop;
					else if (aspect.containsIgnoreCase ("yMax"))
						placementFlags |= RectanglePlacement::yBottom;
					else
						placementFlags |= RectanglePlacement::yMid;
				}

				const RectanglePlacement placement (placementFlags);

				newState.transform
					= placement.getTransformToFit (Rectangle<float> (vx, vy, vw, vh),
												   Rectangle<float> (0.0f, 0.0f, newState.width, newState.height))
							   .followedBy (newState.transform);
			}
		}
		else
		{
			if (viewBoxW == 0)
				newState.viewBoxW = newState.width;

			if (viewBoxH == 0)
				newState.viewBoxH = newState.height;
		}

		newState.parseSubElements (xml, drawable);

		drawable->resetContentAreaAndBoundingBoxToFitChildren();
		return drawable;
	}

private:

	const XmlElement* const topLevelXml;
	float elementX, elementY, width, height, viewBoxW, viewBoxH;
	AffineTransform transform;
	String cssStyleText;

	void parseSubElements (const XmlElement& xml, DrawableComposite* const parentDrawable)
	{
		forEachXmlChildElement (xml, e)
		{
			Drawable* d = nullptr;

			if (e->hasTagName ("g"))                d = parseGroupElement (*e);
			else if (e->hasTagName ("svg"))         d = parseSVGElement (*e);
			else if (e->hasTagName ("path"))        d = parsePath (*e);
			else if (e->hasTagName ("rect"))        d = parseRect (*e);
			else if (e->hasTagName ("circle"))      d = parseCircle (*e);
			else if (e->hasTagName ("ellipse"))     d = parseEllipse (*e);
			else if (e->hasTagName ("line"))        d = parseLine (*e);
			else if (e->hasTagName ("polyline"))    d = parsePolygon (*e, true);
			else if (e->hasTagName ("polygon"))     d = parsePolygon (*e, false);
			else if (e->hasTagName ("text"))        d = parseText (*e);
			else if (e->hasTagName ("switch"))      d = parseSwitch (*e);
			else if (e->hasTagName ("style"))       parseCSSStyle (*e);

			parentDrawable->addAndMakeVisible (d);
		}
	}

	DrawableComposite* parseSwitch (const XmlElement& xml)
	{
		const XmlElement* const group = xml.getChildByName ("g");

		if (group != nullptr)
			return parseGroupElement (*group);

		return nullptr;
	}

	DrawableComposite* parseGroupElement (const XmlElement& xml)
	{
		DrawableComposite* const drawable = new DrawableComposite();

		drawable->setName (xml.getStringAttribute ("id"));

		if (xml.hasAttribute ("transform"))
		{
			SVGState newState (*this);
			newState.addTransform (xml);

			newState.parseSubElements (xml, drawable);
		}
		else
		{
			parseSubElements (xml, drawable);
		}

		drawable->resetContentAreaAndBoundingBoxToFitChildren();
		return drawable;
	}

	Drawable* parsePath (const XmlElement& xml) const
	{
		const String dAttribute (xml.getStringAttribute ("d").trimStart());
		String::CharPointerType d (dAttribute.getCharPointer());
		Path path;

		if (getStyleAttribute (&xml, "fill-rule").trim().equalsIgnoreCase ("evenodd"))
			path.setUsingNonZeroWinding (false);

		float lastX = 0, lastY = 0;
		float lastX2 = 0, lastY2 = 0;
		juce_wchar lastCommandChar = 0;
		bool isRelative = true;
		bool carryOn = true;

		const CharPointer_ASCII validCommandChars ("MmLlHhVvCcSsQqTtAaZz");

		while (! d.isEmpty())
		{
			float x, y, x2, y2, x3, y3;

			if (validCommandChars.indexOf (*d) >= 0)
			{
				lastCommandChar = d.getAndAdvance();
				isRelative = (lastCommandChar >= 'a' && lastCommandChar <= 'z');
			}

			switch (lastCommandChar)
			{
			case 'M':
			case 'm':
			case 'L':
			case 'l':
				if (parseCoords (d, x, y, false))
				{
					if (isRelative)
					{
						x += lastX;
						y += lastY;
					}

					if (lastCommandChar == 'M' || lastCommandChar == 'm')
					{
						path.startNewSubPath (x, y);
						lastCommandChar = 'l';
					}
					else
						path.lineTo (x, y);

					lastX2 = lastX;
					lastY2 = lastY;
					lastX = x;
					lastY = y;
				}
				else
				{
					++d;
				}

				break;

			case 'H':
			case 'h':
				if (parseCoord (d, x, false, true))
				{
					if (isRelative)
						x += lastX;

					path.lineTo (x, lastY);

					lastX2 = lastX;
					lastX = x;
				}
				else
				{
					++d;
				}
				break;

			case 'V':
			case 'v':
				if (parseCoord (d, y, false, false))
				{
					if (isRelative)
						y += lastY;

					path.lineTo (lastX, y);

					lastY2 = lastY;
					lastY = y;
				}
				else
				{
					++d;
				}
				break;

			case 'C':
			case 'c':
				if (parseCoords (d, x, y, false)
					 && parseCoords (d, x2, y2, false)
					 && parseCoords (d, x3, y3, false))
				{
					if (isRelative)
					{
						x += lastX;
						y += lastY;
						x2 += lastX;
						y2 += lastY;
						x3 += lastX;
						y3 += lastY;
					}

					path.cubicTo (x, y, x2, y2, x3, y3);

					lastX2 = x2;
					lastY2 = y2;
					lastX = x3;
					lastY = y3;
				}
				else
				{
					++d;
				}
				break;

			case 'S':
			case 's':
				if (parseCoords (d, x, y, false)
					 && parseCoords (d, x3, y3, false))
				{
					if (isRelative)
					{
						x += lastX;
						y += lastY;
						x3 += lastX;
						y3 += lastY;
					}

					x2 = lastX + (lastX - lastX2);
					y2 = lastY + (lastY - lastY2);
					path.cubicTo (x2, y2, x, y, x3, y3);

					lastX2 = x;
					lastY2 = y;
					lastX = x3;
					lastY = y3;
				}
				else
				{
					++d;
				}
				break;

			case 'Q':
			case 'q':
				if (parseCoords (d, x, y, false)
					 && parseCoords (d, x2, y2, false))
				{
					if (isRelative)
					{
						x += lastX;
						y += lastY;
						x2 += lastX;
						y2 += lastY;
					}

					path.quadraticTo (x, y, x2, y2);

					lastX2 = x;
					lastY2 = y;
					lastX = x2;
					lastY = y2;
				}
				else
				{
					++d;
				}
				break;

			case 'T':
			case 't':
				if (parseCoords (d, x, y, false))
				{
					if (isRelative)
					{
						x += lastX;
						y += lastY;
					}

					x2 = lastX + (lastX - lastX2);
					y2 = lastY + (lastY - lastY2);
					path.quadraticTo (x2, y2, x, y);

					lastX2 = x2;
					lastY2 = y2;
					lastX = x;
					lastY = y;
				}
				else
				{
					++d;
				}
				break;

			case 'A':
			case 'a':
				if (parseCoords (d, x, y, false))
				{
					String num;

					if (parseNextNumber (d, num, false))
					{
						const float angle = num.getFloatValue() * (180.0f / float_Pi);

						if (parseNextNumber (d, num, false))
						{
							const bool largeArc = num.getIntValue() != 0;

							if (parseNextNumber (d, num, false))
							{
								const bool sweep = num.getIntValue() != 0;

								if (parseCoords (d, x2, y2, false))
								{
									if (isRelative)
									{
										x2 += lastX;
										y2 += lastY;
									}

									if (lastX != x2 || lastY != y2)
									{
										double centreX, centreY, startAngle, deltaAngle;
										double rx = x, ry = y;

										endpointToCentreParameters (lastX, lastY, x2, y2,
																	angle, largeArc, sweep,
																	rx, ry, centreX, centreY,
																	startAngle, deltaAngle);

										path.addCentredArc ((float) centreX, (float) centreY,
															(float) rx, (float) ry,
															angle, (float) startAngle, (float) (startAngle + deltaAngle),
															false);

										path.lineTo (x2, y2);
									}

									lastX2 = lastX;
									lastY2 = lastY;
									lastX = x2;
									lastY = y2;
								}
							}
						}
					}
				}
				else
				{
					++d;
				}

				break;

			case 'Z':
			case 'z':
				path.closeSubPath();
				d = d.findEndOfWhitespace();
				break;

			default:
				carryOn = false;
				break;
			}

			if (! carryOn)
				break;
		}

		return parseShape (xml, path);
	}

	Drawable* parseRect (const XmlElement& xml) const
	{
		Path rect;

		const bool hasRX = xml.hasAttribute ("rx");
		const bool hasRY = xml.hasAttribute ("ry");

		if (hasRX || hasRY)
		{
			float rx = getCoordLength (xml.getStringAttribute ("rx"), viewBoxW);
			float ry = getCoordLength (xml.getStringAttribute ("ry"), viewBoxH);

			if (! hasRX)
				rx = ry;
			else if (! hasRY)
				ry = rx;

			rect.addRoundedRectangle (getCoordLength (xml.getStringAttribute ("x"), viewBoxW),
									  getCoordLength (xml.getStringAttribute ("y"), viewBoxH),
									  getCoordLength (xml.getStringAttribute ("width"), viewBoxW),
									  getCoordLength (xml.getStringAttribute ("height"), viewBoxH),
									  rx, ry);
		}
		else
		{
			rect.addRectangle (getCoordLength (xml.getStringAttribute ("x"), viewBoxW),
							   getCoordLength (xml.getStringAttribute ("y"), viewBoxH),
							   getCoordLength (xml.getStringAttribute ("width"), viewBoxW),
							   getCoordLength (xml.getStringAttribute ("height"), viewBoxH));
		}

		return parseShape (xml, rect);
	}

	Drawable* parseCircle (const XmlElement& xml) const
	{
		Path circle;

		const float cx = getCoordLength (xml.getStringAttribute ("cx"), viewBoxW);
		const float cy = getCoordLength (xml.getStringAttribute ("cy"), viewBoxH);
		const float radius = getCoordLength (xml.getStringAttribute ("r"), viewBoxW);

		circle.addEllipse (cx - radius, cy - radius, radius * 2.0f, radius * 2.0f);

		return parseShape (xml, circle);
	}

	Drawable* parseEllipse (const XmlElement& xml) const
	{
		Path ellipse;

		const float cx      = getCoordLength (xml.getStringAttribute ("cx"), viewBoxW);
		const float cy      = getCoordLength (xml.getStringAttribute ("cy"), viewBoxH);
		const float radiusX = getCoordLength (xml.getStringAttribute ("rx"), viewBoxW);
		const float radiusY = getCoordLength (xml.getStringAttribute ("ry"), viewBoxH);

		ellipse.addEllipse (cx - radiusX, cy - radiusY, radiusX * 2.0f, radiusY * 2.0f);

		return parseShape (xml, ellipse);
	}

	Drawable* parseLine (const XmlElement& xml) const
	{
		Path line;

		const float x1 = getCoordLength (xml.getStringAttribute ("x1"), viewBoxW);
		const float y1 = getCoordLength (xml.getStringAttribute ("y1"), viewBoxH);
		const float x2 = getCoordLength (xml.getStringAttribute ("x2"), viewBoxW);
		const float y2 = getCoordLength (xml.getStringAttribute ("y2"), viewBoxH);

		line.startNewSubPath (x1, y1);
		line.lineTo (x2, y2);

		return parseShape (xml, line);
	}

	Drawable* parsePolygon (const XmlElement& xml, const bool isPolyline) const
	{
		const String pointsAtt (xml.getStringAttribute ("points"));
		String::CharPointerType points (pointsAtt.getCharPointer());
		Path path;
		float x, y;

		if (parseCoords (points, x, y, true))
		{
			float firstX = x;
			float firstY = y;
			float lastX = 0, lastY = 0;

			path.startNewSubPath (x, y);

			while (parseCoords (points, x, y, true))
			{
				lastX = x;
				lastY = y;
				path.lineTo (x, y);
			}

			if ((! isPolyline) || (firstX == lastX && firstY == lastY))
				path.closeSubPath();
		}

		return parseShape (xml, path);
	}

	Drawable* parseShape (const XmlElement& xml, Path& path,
						  const bool shouldParseTransform = true) const
	{
		if (shouldParseTransform && xml.hasAttribute ("transform"))
		{
			SVGState newState (*this);
			newState.addTransform (xml);

			return newState.parseShape (xml, path, false);
		}

		DrawablePath* dp = new DrawablePath();
		dp->setName (xml.getStringAttribute ("id"));
		dp->setFill (Colours::transparentBlack);

		path.applyTransform (transform);
		dp->setPath (path);

		Path::Iterator iter (path);

		bool containsClosedSubPath = false;
		while (iter.next())
		{
			if (iter.elementType == Path::Iterator::closePath)
			{
				containsClosedSubPath = true;
				break;
			}
		}

		dp->setFill (getPathFillType (path,
									  getStyleAttribute (&xml, "fill"),
									  getStyleAttribute (&xml, "fill-opacity"),
									  getStyleAttribute (&xml, "opacity"),
									  containsClosedSubPath ? Colours::black
															: Colours::transparentBlack));

		const String strokeType (getStyleAttribute (&xml, "stroke"));

		if (strokeType.isNotEmpty() && ! strokeType.equalsIgnoreCase ("none"))
		{
			dp->setStrokeFill (getPathFillType (path, strokeType,
												getStyleAttribute (&xml, "stroke-opacity"),
												getStyleAttribute (&xml, "opacity"),
												Colours::transparentBlack));

			dp->setStrokeType (getStrokeFor (&xml));
		}

		return dp;
	}

	const XmlElement* findLinkedElement (const XmlElement* e) const
	{
		const String id (e->getStringAttribute ("xlink:href"));

		if (! id.startsWithChar ('#'))
			return nullptr;

		return findElementForId (topLevelXml, id.substring (1));
	}

	void addGradientStopsIn (ColourGradient& cg, const XmlElement* const fillXml) const
	{
		if (fillXml == 0)
			return;

		forEachXmlChildElementWithTagName (*fillXml, e, "stop")
		{
			int index = 0;
			Colour col (parseColour (getStyleAttribute  (e, "stop-color"), index, Colours::black));

			const String opacity (getStyleAttribute (e, "stop-opacity", "1"));
			col = col.withMultipliedAlpha (jlimit (0.0f, 1.0f, opacity.getFloatValue()));

			double offset = e->getDoubleAttribute ("offset");

			if (e->getStringAttribute ("offset").containsChar ('%'))
				offset *= 0.01;

			cg.addColour (jlimit (0.0, 1.0, offset), col);
		}
	}

	FillType getPathFillType (const Path& path,
							  const String& fill,
							  const String& fillOpacity,
							  const String& overallOpacity,
							  const Colour& defaultColour) const
	{
		float opacity = 1.0f;

		if (overallOpacity.isNotEmpty())
			opacity = jlimit (0.0f, 1.0f, overallOpacity.getFloatValue());

		if (fillOpacity.isNotEmpty())
			opacity *= (jlimit (0.0f, 1.0f, fillOpacity.getFloatValue()));

		if (fill.startsWithIgnoreCase ("url"))
		{
			const String id (fill.fromFirstOccurrenceOf ("#", false, false)
								 .upToLastOccurrenceOf (")", false, false).trim());

			const XmlElement* const fillXml = findElementForId (topLevelXml, id);

			if (fillXml != nullptr
				 && (fillXml->hasTagName ("linearGradient")
					  || fillXml->hasTagName ("radialGradient")))
			{
				const XmlElement* inheritedFrom = findLinkedElement (fillXml);

				ColourGradient gradient;

				addGradientStopsIn (gradient, inheritedFrom);
				addGradientStopsIn (gradient, fillXml);

				if (gradient.getNumColours() > 0)
				{
					gradient.addColour (0.0, gradient.getColour (0));
					gradient.addColour (1.0, gradient.getColour (gradient.getNumColours() - 1));
				}
				else
				{
					gradient.addColour (0.0, Colours::black);
					gradient.addColour (1.0, Colours::black);
				}

				if (overallOpacity.isNotEmpty())
					gradient.multiplyOpacity (overallOpacity.getFloatValue());

				jassert (gradient.getNumColours() > 0);

				gradient.isRadial = fillXml->hasTagName ("radialGradient");

				float gradientWidth = viewBoxW;
				float gradientHeight = viewBoxH;
				float dx = 0.0f;
				float dy = 0.0f;

				const bool userSpace = fillXml->getStringAttribute ("gradientUnits").equalsIgnoreCase ("userSpaceOnUse");

				if (! userSpace)
				{
					const Rectangle<float> bounds (path.getBounds());
					dx = bounds.getX();
					dy = bounds.getY();
					gradientWidth = bounds.getWidth();
					gradientHeight = bounds.getHeight();
				}

				if (gradient.isRadial)
				{
					if (userSpace)
						gradient.point1.setXY (dx + getCoordLength (fillXml->getStringAttribute ("cx", "50%"), gradientWidth),
											   dy + getCoordLength (fillXml->getStringAttribute ("cy", "50%"), gradientHeight));
					else
						gradient.point1.setXY (dx + gradientWidth * getCoordLength (fillXml->getStringAttribute ("cx", "50%"), 1.0f),
											   dy + gradientHeight * getCoordLength (fillXml->getStringAttribute ("cy", "50%"), 1.0f));

					const float radius = getCoordLength (fillXml->getStringAttribute ("r", "50%"), gradientWidth);
					gradient.point2 = gradient.point1 + Point<float> (radius, 0.0f);

					//xxx (the fx, fy focal point isn't handled properly here..)
				}
				else
				{
					if (userSpace)
					{
						gradient.point1.setXY (dx + getCoordLength (fillXml->getStringAttribute ("x1", "0%"), gradientWidth),
											   dy + getCoordLength (fillXml->getStringAttribute ("y1", "0%"), gradientHeight));

						gradient.point2.setXY (dx + getCoordLength (fillXml->getStringAttribute ("x2", "100%"), gradientWidth),
											   dy + getCoordLength (fillXml->getStringAttribute ("y2", "0%"), gradientHeight));
					}
					else
					{
						gradient.point1.setXY (dx + gradientWidth * getCoordLength (fillXml->getStringAttribute ("x1", "0%"), 1.0f),
											   dy + gradientHeight * getCoordLength (fillXml->getStringAttribute ("y1", "0%"), 1.0f));

						gradient.point2.setXY (dx + gradientWidth * getCoordLength (fillXml->getStringAttribute ("x2", "100%"), 1.0f),
											   dy + gradientHeight * getCoordLength (fillXml->getStringAttribute ("y2", "0%"), 1.0f));
					}

					if (gradient.point1 == gradient.point2)
						return Colour (gradient.getColour (gradient.getNumColours() - 1));
				}

				FillType type (gradient);
				type.transform = parseTransform (fillXml->getStringAttribute ("gradientTransform"))
								   .followedBy (transform);
				return type;
			}
		}

		if (fill.equalsIgnoreCase ("none"))
			return Colours::transparentBlack;

		int i = 0;
		const Colour colour (parseColour (fill, i, defaultColour));
		return colour.withMultipliedAlpha (opacity);
	}

	PathStrokeType getStrokeFor (const XmlElement* const xml) const
	{
		const String strokeWidth (getStyleAttribute (xml, "stroke-width"));
		const String cap (getStyleAttribute (xml, "stroke-linecap"));
		const String join (getStyleAttribute (xml, "stroke-linejoin"));

		//const String mitreLimit (getStyleAttribute (xml, "stroke-miterlimit"));
		//const String dashArray (getStyleAttribute (xml, "stroke-dasharray"));
		//const String dashOffset (getStyleAttribute (xml, "stroke-dashoffset"));

		PathStrokeType::JointStyle joinStyle = PathStrokeType::mitered;
		PathStrokeType::EndCapStyle capStyle = PathStrokeType::butt;

		if (join.equalsIgnoreCase ("round"))
			joinStyle = PathStrokeType::curved;
		else if (join.equalsIgnoreCase ("bevel"))
			joinStyle = PathStrokeType::beveled;

		if (cap.equalsIgnoreCase ("round"))
			capStyle = PathStrokeType::rounded;
		else if (cap.equalsIgnoreCase ("square"))
			capStyle = PathStrokeType::square;

		float ox = 0.0f, oy = 0.0f;
		float x = getCoordLength (strokeWidth, viewBoxW), y = 0.0f;
		transform.transformPoints (ox, oy, x, y);

		return PathStrokeType (strokeWidth.isNotEmpty() ? juce_hypot (x - ox, y - oy) : 1.0f,
							   joinStyle, capStyle);
	}

	Drawable* parseText (const XmlElement& xml)
	{
		Array <float> xCoords, yCoords, dxCoords, dyCoords;

		getCoordList (xCoords, getInheritedAttribute (&xml, "x"), true, true);
		getCoordList (yCoords, getInheritedAttribute (&xml, "y"), true, false);
		getCoordList (dxCoords, getInheritedAttribute (&xml, "dx"), true, true);
		getCoordList (dyCoords, getInheritedAttribute (&xml, "dy"), true, false);

		//xxx not done text yet!

		forEachXmlChildElement (xml, e)
		{
			if (e->isTextElement())
			{
				const String text (e->getText());

				Path path;
				Drawable* s = parseShape (*e, path);
				delete s;  // xxx not finished!
			}
			else if (e->hasTagName ("tspan"))
			{
				Drawable* s = parseText (*e);
				delete s;  // xxx not finished!
			}
		}

		return nullptr;
	}

	void addTransform (const XmlElement& xml)
	{
		transform = parseTransform (xml.getStringAttribute ("transform"))
						.followedBy (transform);
	}

	bool parseCoord (String::CharPointerType& s, float& value, const bool allowUnits, const bool isX) const
	{
		String number;

		if (! parseNextNumber (s, number, allowUnits))
		{
			value = 0;
			return false;
		}

		value = getCoordLength (number, isX ? viewBoxW : viewBoxH);
		return true;
	}

	bool parseCoords (String::CharPointerType& s, float& x, float& y, const bool allowUnits) const
	{
		return parseCoord (s, x, allowUnits, true)
			&& parseCoord (s, y, allowUnits, false);
	}

	float getCoordLength (const String& s, const float sizeForProportions) const
	{
		float n = s.getFloatValue();
		const int len = s.length();

		if (len > 2)
		{
			const float dpi = 96.0f;

			const juce_wchar n1 = s [len - 2];
			const juce_wchar n2 = s [len - 1];

			if (n1 == 'i' && n2 == 'n')         n *= dpi;
			else if (n1 == 'm' && n2 == 'm')    n *= dpi / 25.4f;
			else if (n1 == 'c' && n2 == 'm')    n *= dpi / 2.54f;
			else if (n1 == 'p' && n2 == 'c')    n *= 15.0f;
			else if (n2 == '%')                 n *= 0.01f * sizeForProportions;
		}

		return n;
	}

	void getCoordList (Array <float>& coords, const String& list,
					   const bool allowUnits, const bool isX) const
	{
		String::CharPointerType text (list.getCharPointer());
		float value;

		while (parseCoord (text, value, allowUnits, isX))
			coords.add (value);
	}

	void parseCSSStyle (const XmlElement& xml)
	{
		cssStyleText = xml.getAllSubText() + "\n" + cssStyleText;
	}

	String getStyleAttribute (const XmlElement* xml, const String& attributeName,
							  const String& defaultValue = String::empty) const
	{
		if (xml->hasAttribute (attributeName))
			return xml->getStringAttribute (attributeName, defaultValue);

		const String styleAtt (xml->getStringAttribute ("style"));

		if (styleAtt.isNotEmpty())
		{
			const String value (getAttributeFromStyleList (styleAtt, attributeName, String::empty));

			if (value.isNotEmpty())
				return value;
		}
		else if (xml->hasAttribute ("class"))
		{
			const String className ("." + xml->getStringAttribute ("class"));

			int index = cssStyleText.indexOfIgnoreCase (className + " ");

			if (index < 0)
				index = cssStyleText.indexOfIgnoreCase (className + "{");

			if (index >= 0)
			{
				const int openBracket = cssStyleText.indexOfChar (index, '{');

				if (openBracket > index)
				{
					const int closeBracket = cssStyleText.indexOfChar (openBracket, '}');

					if (closeBracket > openBracket)
					{
						const String value (getAttributeFromStyleList (cssStyleText.substring (openBracket + 1, closeBracket), attributeName, defaultValue));

						if (value.isNotEmpty())
							return value;
					}
				}
			}
		}

		xml = const_cast <XmlElement*> (topLevelXml)->findParentElementOf (xml);

		if (xml != nullptr)
			return getStyleAttribute (xml, attributeName, defaultValue);

		return defaultValue;
	}

	String getInheritedAttribute (const XmlElement* xml, const String& attributeName) const
	{
		if (xml->hasAttribute (attributeName))
			return xml->getStringAttribute (attributeName);

		xml = const_cast <XmlElement*> (topLevelXml)->findParentElementOf (xml);

		if (xml != nullptr)
			return getInheritedAttribute  (xml, attributeName);

		return String::empty;
	}

	static bool isIdentifierChar (const juce_wchar c)
	{
		return CharacterFunctions::isLetter (c) || c == '-';
	}

	static String getAttributeFromStyleList (const String& list, const String& attributeName, const String& defaultValue)
	{
		int i = 0;

		for (;;)
		{
			i = list.indexOf (i, attributeName);

			if (i < 0)
				break;

			if ((i == 0 || (i > 0 && ! isIdentifierChar (list [i - 1])))
				 && ! isIdentifierChar (list [i + attributeName.length()]))
			{
				i = list.indexOfChar (i, ':');

				if (i < 0)
					break;

				int end = list.indexOfChar (i, ';');

				if (end < 0)
					end = 0x7ffff;

				return list.substring (i + 1, end).trim();
			}

			++i;
		}

		return defaultValue;
	}

	static bool parseNextNumber (String::CharPointerType& s, String& value, const bool allowUnits)
	{
		while (s.isWhitespace() || *s == ',')
			++s;

		String::CharPointerType start (s);
		int numChars = 0;

		if (s.isDigit() || *s == '.' || *s == '-')
		{
			++numChars;
			++s;
		}

		while (s.isDigit() || *s == '.')
		{
			++numChars;
			++s;
		}

		if ((*s == 'e' || *s == 'E')
			 && ((s + 1).isDigit() || s[1] == '-' || s[1] == '+'))
		{
			s += 2;
			numChars += 2;

			while (s.isDigit())
			{
				++numChars;
				++s;
			}
		}

		if (allowUnits)
		{
			while (s.isLetter())
			{
				++numChars;
				++s;
			}
		}

		if (numChars == 0)
			return false;

		value = String (start, (size_t) numChars);

		while (s.isWhitespace() || *s == ',')
			++s;

		return true;
	}

	static Colour parseColour (const String& s, int& index, const Colour& defaultColour)
	{
		if (s [index] == '#')
		{
			uint32 hex[6] = { 0 };
			int numChars = 0;

			for (int i = 6; --i >= 0;)
			{
				const int hexValue = CharacterFunctions::getHexDigitValue (s [++index]);

				if (hexValue >= 0)
					hex [numChars++] = (uint32) hexValue;
				else
					break;
			}

			if (numChars <= 3)
				return Colour ((uint8) (hex [0] * 0x11),
							   (uint8) (hex [1] * 0x11),
							   (uint8) (hex [2] * 0x11));
			else
				return Colour ((uint8) ((hex [0] << 4) + hex [1]),
							   (uint8) ((hex [2] << 4) + hex [3]),
							   (uint8) ((hex [4] << 4) + hex [5]));
		}
		else if (s [index] == 'r'
				  && s [index + 1] == 'g'
				  && s [index + 2] == 'b')
		{
			const int openBracket = s.indexOfChar (index, '(');
			const int closeBracket = s.indexOfChar (openBracket, ')');

			if (openBracket >= 3 && closeBracket > openBracket)
			{
				index = closeBracket;

				StringArray tokens;
				tokens.addTokens (s.substring (openBracket + 1, closeBracket), ",", "");
				tokens.trim();
				tokens.removeEmptyStrings();

				if (tokens[0].containsChar ('%'))
					return Colour ((uint8) roundToInt (2.55 * tokens[0].getDoubleValue()),
								   (uint8) roundToInt (2.55 * tokens[1].getDoubleValue()),
								   (uint8) roundToInt (2.55 * tokens[2].getDoubleValue()));
				else
					return Colour ((uint8) tokens[0].getIntValue(),
								   (uint8) tokens[1].getIntValue(),
								   (uint8) tokens[2].getIntValue());
			}
		}

		return Colours::findColourForName (s, defaultColour);
	}

	static const AffineTransform parseTransform (String t)
	{
		AffineTransform result;

		while (t.isNotEmpty())
		{
			StringArray tokens;
			tokens.addTokens (t.fromFirstOccurrenceOf ("(", false, false)
							   .upToFirstOccurrenceOf (")", false, false),
							  ", ", String::empty);

			tokens.removeEmptyStrings (true);

			float numbers [6];

			for (int i = 0; i < 6; ++i)
				numbers[i] = tokens[i].getFloatValue();

			AffineTransform trans;

			if (t.startsWithIgnoreCase ("matrix"))
			{
				trans = AffineTransform (numbers[0], numbers[2], numbers[4],
										 numbers[1], numbers[3], numbers[5]);
			}
			else if (t.startsWithIgnoreCase ("translate"))
			{
				jassert (tokens.size() == 2);
				trans = AffineTransform::translation (numbers[0], numbers[1]);
			}
			else if (t.startsWithIgnoreCase ("scale"))
			{
				if (tokens.size() == 1)
					trans = AffineTransform::scale (numbers[0], numbers[0]);
				else
					trans = AffineTransform::scale (numbers[0], numbers[1]);
			}
			else if (t.startsWithIgnoreCase ("rotate"))
			{
				if (tokens.size() != 3)
					trans = AffineTransform::rotation (numbers[0] / (180.0f / float_Pi));
				else
					trans = AffineTransform::rotation (numbers[0] / (180.0f / float_Pi),
													   numbers[1], numbers[2]);
			}
			else if (t.startsWithIgnoreCase ("skewX"))
			{
				trans = AffineTransform (1.0f, std::tan (numbers[0] * (float_Pi / 180.0f)), 0.0f,
										 0.0f, 1.0f, 0.0f);
			}
			else if (t.startsWithIgnoreCase ("skewY"))
			{
				trans = AffineTransform (1.0f, 0.0f, 0.0f,
										 std::tan (numbers[0] * (float_Pi / 180.0f)), 1.0f, 0.0f);
			}

			result = trans.followedBy (result);
			t = t.fromFirstOccurrenceOf (")", false, false).trimStart();
		}

		return result;
	}

	static void endpointToCentreParameters (const double x1, const double y1,
											const double x2, const double y2,
											const double angle,
											const bool largeArc, const bool sweep,
											double& rx, double& ry,
											double& centreX, double& centreY,
											double& startAngle, double& deltaAngle)
	{
		const double midX = (x1 - x2) * 0.5;
		const double midY = (y1 - y2) * 0.5;

		const double cosAngle = cos (angle);
		const double sinAngle = sin (angle);
		const double xp = cosAngle * midX + sinAngle * midY;
		const double yp = cosAngle * midY - sinAngle * midX;
		const double xp2 = xp * xp;
		const double yp2 = yp * yp;

		double rx2 = rx * rx;
		double ry2 = ry * ry;

		const double s = (xp2 / rx2) + (yp2 / ry2);
		double c;

		if (s <= 1.0)
		{
			c = std::sqrt (jmax (0.0, ((rx2 * ry2) - (rx2 * yp2) - (ry2 * xp2))
										 / (( rx2 * yp2) + (ry2 * xp2))));

			if (largeArc == sweep)
				c = -c;
		}
		else
		{
			const double s2 = std::sqrt (s);
			rx *= s2;
			ry *= s2;
			rx2 = rx * rx;
			ry2 = ry * ry;
			c = 0;
		}

		const double cpx = ((rx * yp) / ry) * c;
		const double cpy = ((-ry * xp) / rx) * c;

		centreX = ((x1 + x2) * 0.5) + (cosAngle * cpx) - (sinAngle * cpy);
		centreY = ((y1 + y2) * 0.5) + (sinAngle * cpx) + (cosAngle * cpy);

		const double ux = (xp - cpx) / rx;
		const double uy = (yp - cpy) / ry;
		const double vx = (-xp - cpx) / rx;
		const double vy = (-yp - cpy) / ry;

		const double length = juce_hypot (ux, uy);

		startAngle = acos (jlimit (-1.0, 1.0, ux / length));

		if (uy < 0)
			startAngle = -startAngle;

		startAngle += double_Pi * 0.5;

		deltaAngle = acos (jlimit (-1.0, 1.0, ((ux * vx) + (uy * vy))
												/ (length * juce_hypot (vx, vy))));

		if ((ux * vy) - (uy * vx) < 0)
			deltaAngle = -deltaAngle;

		if (sweep)
		{
			if (deltaAngle < 0)
				deltaAngle += double_Pi * 2.0;
		}
		else
		{
			if (deltaAngle > 0)
				deltaAngle -= double_Pi * 2.0;
		}

		deltaAngle = fmod (deltaAngle, double_Pi * 2.0);
	}

	static const XmlElement* findElementForId (const XmlElement* const parent, const String& id)
	{
		forEachXmlChildElement (*parent, e)
		{
			if (e->compareAttribute ("id", id))
				return e;

			const XmlElement* const found = findElementForId (e, id);

			if (found != nullptr)
				return found;
		}

		return nullptr;
	}

	SVGState& operator= (const SVGState&);
};

Drawable* Drawable::createFromSVG (const XmlElement& svgDocument)
{
	SVGState state (&svgDocument);
	return state.parseSVGElement (svgDocument);
}

/*** End of inlined file: juce_SVGParser.cpp ***/


/*** Start of inlined file: juce_DirectoryContentsDisplayComponent.cpp ***/
DirectoryContentsDisplayComponent::DirectoryContentsDisplayComponent (DirectoryContentsList& listToShow)
	: fileList (listToShow)
{
}

DirectoryContentsDisplayComponent::~DirectoryContentsDisplayComponent()
{
}

FileBrowserListener::~FileBrowserListener()
{
}

void DirectoryContentsDisplayComponent::addListener (FileBrowserListener* const listener)
{
	listeners.add (listener);
}

void DirectoryContentsDisplayComponent::removeListener (FileBrowserListener* const listener)
{
	listeners.remove (listener);
}

void DirectoryContentsDisplayComponent::sendSelectionChangeMessage()
{
	Component::BailOutChecker checker (dynamic_cast <Component*> (this));
	listeners.callChecked (checker, &FileBrowserListener::selectionChanged);
}

void DirectoryContentsDisplayComponent::sendMouseClickMessage (const File& file, const MouseEvent& e)
{
	if (fileList.getDirectory().exists())
	{
		Component::BailOutChecker checker (dynamic_cast <Component*> (this));
		listeners.callChecked (checker, &FileBrowserListener::fileClicked, file, e);
	}
}

void DirectoryContentsDisplayComponent::sendDoubleClickMessage (const File& file)
{
	if (fileList.getDirectory().exists())
	{
		Component::BailOutChecker checker (dynamic_cast <Component*> (this));
		listeners.callChecked (checker, &FileBrowserListener::fileDoubleClicked, file);
	}
}

/*** End of inlined file: juce_DirectoryContentsDisplayComponent.cpp ***/


/*** Start of inlined file: juce_DirectoryContentsList.cpp ***/
DirectoryContentsList::DirectoryContentsList (const FileFilter* const fileFilter_,
											  TimeSliceThread& thread_)
   : fileFilter (fileFilter_),
	 thread (thread_),
	 fileTypeFlags (File::ignoreHiddenFiles | File::findFiles),
	 shouldStop (true)
{
}

DirectoryContentsList::~DirectoryContentsList()
{
	stopSearching();
}

void DirectoryContentsList::setIgnoresHiddenFiles (const bool shouldIgnoreHiddenFiles)
{
	setTypeFlags (shouldIgnoreHiddenFiles ? (fileTypeFlags | File::ignoreHiddenFiles)
										  : (fileTypeFlags & ~File::ignoreHiddenFiles));
}

bool DirectoryContentsList::ignoresHiddenFiles() const
{
	return (fileTypeFlags & File::ignoreHiddenFiles) != 0;
}

const File& DirectoryContentsList::getDirectory() const
{
	return root;
}

void DirectoryContentsList::setDirectory (const File& directory,
										  const bool includeDirectories,
										  const bool includeFiles)
{
	jassert (includeDirectories || includeFiles); // you have to speciify at least one of these!

	if (directory != root)
	{
		clear();
		root = directory;

		// (this forces a refresh when setTypeFlags() is called, rather than triggering two refreshes)
		fileTypeFlags &= ~(File::findDirectories | File::findFiles);
	}

	int newFlags = fileTypeFlags;
	if (includeDirectories) newFlags |= File::findDirectories;  else newFlags &= ~File::findDirectories;
	if (includeFiles)       newFlags |= File::findFiles;        else newFlags &= ~File::findFiles;

	setTypeFlags (newFlags);
}

void DirectoryContentsList::setTypeFlags (const int newFlags)
{
	if (fileTypeFlags != newFlags)
	{
		fileTypeFlags = newFlags;
		refresh();
	}
}

void DirectoryContentsList::stopSearching()
{
	shouldStop = true;
	thread.removeTimeSliceClient (this);
	fileFindHandle = nullptr;
}

void DirectoryContentsList::clear()
{
	stopSearching();

	if (files.size() > 0)
	{
		files.clear();
		changed();
	}
}

void DirectoryContentsList::refresh()
{
	clear();

	if (root.isDirectory())
	{
		fileFindHandle = new DirectoryIterator (root, false, "*", fileTypeFlags);
		shouldStop = false;
		thread.addTimeSliceClient (this);
	}
}

int DirectoryContentsList::getNumFiles() const
{
	return files.size();
}

bool DirectoryContentsList::getFileInfo (const int index,
										 FileInfo& result) const
{
	const ScopedLock sl (fileListLock);
	const FileInfo* const info = files [index];

	if (info != nullptr)
	{
		result = *info;
		return true;
	}

	return false;
}

File DirectoryContentsList::getFile (const int index) const
{
	const ScopedLock sl (fileListLock);
	const FileInfo* const info = files [index];

	if (info != nullptr)
		return root.getChildFile (info->filename);

	return File::nonexistent;
}

bool DirectoryContentsList::contains (const File& targetFile) const
{
	const ScopedLock sl (fileListLock);

	for (int i = files.size(); --i >= 0;)
		if (root.getChildFile (files.getUnchecked(i)->filename) == targetFile)
			return true;

	return false;
}

bool DirectoryContentsList::isStillLoading() const
{
	return fileFindHandle != nullptr;
}

void DirectoryContentsList::changed()
{
	sendChangeMessage();
}

int DirectoryContentsList::useTimeSlice()
{
	const uint32 startTime = Time::getApproximateMillisecondCounter();
	bool hasChanged = false;

	for (int i = 100; --i >= 0;)
	{
		if (! checkNextFile (hasChanged))
		{
			if (hasChanged)
				changed();

			return 500;
		}

		if (shouldStop || (Time::getApproximateMillisecondCounter() > startTime + 150))
			break;
	}

	if (hasChanged)
		changed();

	return 0;
}

bool DirectoryContentsList::checkNextFile (bool& hasChanged)
{
	if (fileFindHandle != nullptr)
	{
		bool fileFoundIsDir, isHidden, isReadOnly;
		int64 fileSize;
		Time modTime, creationTime;

		if (fileFindHandle->next (&fileFoundIsDir, &isHidden, &fileSize,
								  &modTime, &creationTime, &isReadOnly))
		{
			if (addFile (fileFindHandle->getFile(), fileFoundIsDir,
						 fileSize, modTime, creationTime, isReadOnly))
			{
				hasChanged = true;
			}

			return true;
		}
		else
		{
			fileFindHandle = nullptr;
		}
	}

	return false;
}

int DirectoryContentsList::compareElements (const DirectoryContentsList::FileInfo* const first,
											const DirectoryContentsList::FileInfo* const second)
{
   #if JUCE_WINDOWS
	if (first->isDirectory != second->isDirectory)
		return first->isDirectory ? -1 : 1;
   #endif

	return first->filename.compareIgnoreCase (second->filename);
}

bool DirectoryContentsList::addFile (const File& file,
									 const bool isDir,
									 const int64 fileSize,
									 const Time& modTime,
									 const Time& creationTime,
									 const bool isReadOnly)
{
	if (fileFilter == nullptr
		 || ((! isDir) && fileFilter->isFileSuitable (file))
		 || (isDir && fileFilter->isDirectorySuitable (file)))
	{
		ScopedPointer <FileInfo> info (new FileInfo());

		info->filename = file.getFileName();
		info->fileSize = fileSize;
		info->modificationTime = modTime;
		info->creationTime = creationTime;
		info->isDirectory = isDir;
		info->isReadOnly = isReadOnly;

		const ScopedLock sl (fileListLock);

		for (int i = files.size(); --i >= 0;)
			if (files.getUnchecked(i)->filename == info->filename)
				return false;

		files.addSorted (*this, info.release());
		return true;
	}

	return false;
}

/*** End of inlined file: juce_DirectoryContentsList.cpp ***/


/*** Start of inlined file: juce_FileBrowserComponent.cpp ***/
FileBrowserComponent::FileBrowserComponent (int flags_,
											const File& initialFileOrDirectory,
											const FileFilter* fileFilter_,
											FilePreviewComponent* previewComp_)
   : FileFilter (String::empty),
	 fileFilter (fileFilter_),
	 flags (flags_),
	 previewComp (previewComp_),
	 currentPathBox ("path"),
	 fileLabel ("f", TRANS ("file:")),
	 thread ("Juce FileBrowser")
{
	// You need to specify one or other of the open/save flags..
	jassert ((flags & (saveMode | openMode)) != 0);
	jassert ((flags & (saveMode | openMode)) != (saveMode | openMode));

	// You need to specify at least one of these flags..
	jassert ((flags & (canSelectFiles | canSelectDirectories)) != 0);

	String filename;

	if (initialFileOrDirectory == File::nonexistent)
	{
		currentRoot = File::getCurrentWorkingDirectory();
	}
	else if (initialFileOrDirectory.isDirectory())
	{
		currentRoot = initialFileOrDirectory;
	}
	else
	{
		chosenFiles.add (initialFileOrDirectory);
		currentRoot = initialFileOrDirectory.getParentDirectory();
		filename = initialFileOrDirectory.getFileName();
	}

	fileList = new DirectoryContentsList (this, thread);

	if ((flags & useTreeView) != 0)
	{
		FileTreeComponent* const tree = new FileTreeComponent (*fileList);
		fileListComponent = tree;

		if ((flags & canSelectMultipleItems) != 0)
			tree->setMultiSelectEnabled (true);

		addAndMakeVisible (tree);
	}
	else
	{
		FileListComponent* const list = new FileListComponent (*fileList);
		fileListComponent = list;
		list->setOutlineThickness (1);

		if ((flags & canSelectMultipleItems) != 0)
			list->setMultipleSelectionEnabled (true);

		addAndMakeVisible (list);
	}

	fileListComponent->addListener (this);

	addAndMakeVisible (&currentPathBox);
	currentPathBox.setEditableText (true);
	resetRecentPaths();
	currentPathBox.addListener (this);

	addAndMakeVisible (&filenameBox);
	filenameBox.setMultiLine (false);
	filenameBox.setSelectAllWhenFocused (true);
	filenameBox.setText (filename, false);
	filenameBox.addListener (this);
	filenameBox.setReadOnly ((flags & (filenameBoxIsReadOnly | canSelectMultipleItems)) != 0);

	addAndMakeVisible (&fileLabel);
	fileLabel.attachToComponent (&filenameBox, true);

	addAndMakeVisible (goUpButton = getLookAndFeel().createFileBrowserGoUpButton());
	goUpButton->addListener (this);
	goUpButton->setTooltip (TRANS ("go up to parent directory"));

	if (previewComp != nullptr)
		addAndMakeVisible (previewComp);

	setRoot (currentRoot);

	thread.startThread (4);
}

FileBrowserComponent::~FileBrowserComponent()
{
	fileListComponent = nullptr;
	fileList = nullptr;
	thread.stopThread (10000);
}

void FileBrowserComponent::addListener (FileBrowserListener* const newListener)
{
	listeners.add (newListener);
}

void FileBrowserComponent::removeListener (FileBrowserListener* const listener)
{
	listeners.remove (listener);
}

bool FileBrowserComponent::isSaveMode() const noexcept
{
	return (flags & saveMode) != 0;
}

int FileBrowserComponent::getNumSelectedFiles() const noexcept
{
	if (chosenFiles.size() == 0 && currentFileIsValid())
		return 1;

	return chosenFiles.size();
}

File FileBrowserComponent::getSelectedFile (int index) const noexcept
{
	if ((flags & canSelectDirectories) != 0 && filenameBox.getText().isEmpty())
		return currentRoot;

	if (! filenameBox.isReadOnly())
		return currentRoot.getChildFile (filenameBox.getText());

	return chosenFiles[index];
}

bool FileBrowserComponent::currentFileIsValid() const
{
	if (isSaveMode())
		return ! getSelectedFile (0).isDirectory();
	else
		return getSelectedFile (0).exists();
}

File FileBrowserComponent::getHighlightedFile() const noexcept
{
	return fileListComponent->getSelectedFile (0);
}

void FileBrowserComponent::deselectAllFiles()
{
	fileListComponent->deselectAllFiles();
}

bool FileBrowserComponent::isFileSuitable (const File& file) const
{
	return (flags & canSelectFiles) != 0 && (fileFilter == nullptr || fileFilter->isFileSuitable (file));
}

bool FileBrowserComponent::isDirectorySuitable (const File&) const
{
	return true;
}

bool FileBrowserComponent::isFileOrDirSuitable (const File& f) const
{
	if (f.isDirectory())
		return (flags & canSelectDirectories) != 0
				&& (fileFilter == nullptr || fileFilter->isDirectorySuitable (f));

	return (flags & canSelectFiles) != 0 && f.exists()
			&& (fileFilter == nullptr || fileFilter->isFileSuitable (f));
}

const File& FileBrowserComponent::getRoot() const
{
	return currentRoot;
}

void FileBrowserComponent::setRoot (const File& newRootDirectory)
{
	bool callListeners = false;

	if (currentRoot != newRootDirectory)
	{
		callListeners = true;
		fileListComponent->scrollToTop();

		String path (newRootDirectory.getFullPathName());

		if (path.isEmpty())
			path = File::separatorString;

		StringArray rootNames, rootPaths;
		getRoots (rootNames, rootPaths);

		if (! rootPaths.contains (path, true))
		{
			bool alreadyListed = false;

			for (int i = currentPathBox.getNumItems(); --i >= 0;)
			{
				if (currentPathBox.getItemText (i).equalsIgnoreCase (path))
				{
					alreadyListed = true;
					break;
				}
			}

			if (! alreadyListed)
				currentPathBox.addItem (path, currentPathBox.getNumItems() + 2);
		}
	}

	currentRoot = newRootDirectory;
	fileList->setDirectory (currentRoot, true, true);

	String currentRootName (currentRoot.getFullPathName());
	if (currentRootName.isEmpty())
		currentRootName = File::separatorString;

	currentPathBox.setText (currentRootName, true);

	goUpButton->setEnabled (currentRoot.getParentDirectory().isDirectory()
							 && currentRoot.getParentDirectory() != currentRoot);

	if (callListeners)
	{
		Component::BailOutChecker checker (this);
		listeners.callChecked (checker, &FileBrowserListener::browserRootChanged, currentRoot);
	}
}

void FileBrowserComponent::setFileName (const String& newName)
{
	filenameBox.setText (newName, true);

	fileListComponent->setSelectedFile (currentRoot.getChildFile (newName));
}

void FileBrowserComponent::resetRecentPaths()
{
	currentPathBox.clear();

	StringArray rootNames, rootPaths;
	getRoots (rootNames, rootPaths);

	for (int i = 0; i < rootNames.size(); ++i)
	{
		if (rootNames[i].isEmpty())
			currentPathBox.addSeparator();
		else
			currentPathBox.addItem (rootNames[i], i + 1);
	}

	currentPathBox.addSeparator();
}

void FileBrowserComponent::goUp()
{
	setRoot (getRoot().getParentDirectory());
}

void FileBrowserComponent::refresh()
{
	fileList->refresh();
}

void FileBrowserComponent::setFileFilter (const FileFilter* const newFileFilter)
{
	if (fileFilter != newFileFilter)
	{
		fileFilter = newFileFilter;
		refresh();
	}
}

String FileBrowserComponent::getActionVerb() const
{
	return isSaveMode() ? TRANS("Save") : TRANS("Open");
}

void FileBrowserComponent::setFilenameBoxLabel (const String& name)
{
	fileLabel.setText (name, false);
}

FilePreviewComponent* FileBrowserComponent::getPreviewComponent() const noexcept
{
	return previewComp;
}

DirectoryContentsDisplayComponent* FileBrowserComponent::getDisplayComponent() const noexcept
{
	return fileListComponent;
}

void FileBrowserComponent::resized()
{
	getLookAndFeel()
		.layoutFileBrowserComponent (*this, fileListComponent, previewComp,
									 &currentPathBox, &filenameBox, goUpButton);
}

void FileBrowserComponent::sendListenerChangeMessage()
{
	Component::BailOutChecker checker (this);

	if (previewComp != nullptr)
		previewComp->selectedFileChanged (getSelectedFile (0));

	// You shouldn't delete the browser when the file gets changed!
	jassert (! checker.shouldBailOut());

	listeners.callChecked (checker, &FileBrowserListener::selectionChanged);
}

void FileBrowserComponent::selectionChanged()
{
	StringArray newFilenames;
	bool resetChosenFiles = true;

	for (int i = 0; i < fileListComponent->getNumSelectedFiles(); ++i)
	{
		const File f (fileListComponent->getSelectedFile (i));

		if (isFileOrDirSuitable (f))
		{
			if (resetChosenFiles)
			{
				chosenFiles.clear();
				resetChosenFiles = false;
			}

			chosenFiles.add (f);
			newFilenames.add (f.getRelativePathFrom (getRoot()));
		}
	}

	if (newFilenames.size() > 0)
		filenameBox.setText (newFilenames.joinIntoString (", "), false);

	sendListenerChangeMessage();
}

void FileBrowserComponent::fileClicked (const File& f, const MouseEvent& e)
{
	Component::BailOutChecker checker (this);
	listeners.callChecked (checker, &FileBrowserListener::fileClicked, f, e);
}

void FileBrowserComponent::fileDoubleClicked (const File& f)
{
	if (f.isDirectory())
	{
		setRoot (f);

		if ((flags & canSelectDirectories) != 0)
			filenameBox.setText (String::empty);
	}
	else
	{
		Component::BailOutChecker checker (this);
		listeners.callChecked (checker, &FileBrowserListener::fileDoubleClicked, f);
	}
}

void FileBrowserComponent::browserRootChanged (const File&) {}

bool FileBrowserComponent::keyPressed (const KeyPress& key)
{
	(void) key;

#if JUCE_LINUX || JUCE_WINDOWS
	if (key.getModifiers().isCommandDown()
		 && (key.getKeyCode() == 'H' || key.getKeyCode() == 'h'))
	{
		fileList->setIgnoresHiddenFiles (! fileList->ignoresHiddenFiles());
		fileList->refresh();
		return true;
	}
#endif

	return false;
}

void FileBrowserComponent::textEditorTextChanged (TextEditor&)
{
	sendListenerChangeMessage();
}

void FileBrowserComponent::textEditorReturnKeyPressed (TextEditor&)
{
	if (filenameBox.getText().containsChar (File::separator))
	{
		const File f (currentRoot.getChildFile (filenameBox.getText()));

		if (f.isDirectory())
		{
			setRoot (f);
			chosenFiles.clear();
			filenameBox.setText (String::empty);
		}
		else
		{
			setRoot (f.getParentDirectory());
			chosenFiles.clear();
			chosenFiles.add (f);
			filenameBox.setText (f.getFileName());
		}
	}
	else
	{
		fileDoubleClicked (getSelectedFile (0));
	}
}

void FileBrowserComponent::textEditorEscapeKeyPressed (TextEditor&)
{
}

void FileBrowserComponent::textEditorFocusLost (TextEditor&)
{
	if (! isSaveMode())
		selectionChanged();
}

void FileBrowserComponent::buttonClicked (Button*)
{
	goUp();
}

void FileBrowserComponent::comboBoxChanged (ComboBox*)
{
	const String newText (currentPathBox.getText().trim().unquoted());

	if (newText.isNotEmpty())
	{
		const int index = currentPathBox.getSelectedId() - 1;

		StringArray rootNames, rootPaths;
		getRoots (rootNames, rootPaths);

		if (rootPaths [index].isNotEmpty())
		{
			setRoot (File (rootPaths [index]));
		}
		else
		{
			File f (newText);

			for (;;)
			{
				if (f.isDirectory())
				{
					setRoot (f);
					break;
				}

				if (f.getParentDirectory() == f)
					break;

				f = f.getParentDirectory();
			}
		}
	}
}

void FileBrowserComponent::getRoots (StringArray& rootNames, StringArray& rootPaths)
{
   #if JUCE_WINDOWS
	Array<File> roots;
	File::findFileSystemRoots (roots);
	rootPaths.clear();

	for (int i = 0; i < roots.size(); ++i)
	{
		const File& drive = roots.getReference(i);

		String name (drive.getFullPathName());
		rootPaths.add (name);

		if (drive.isOnHardDisk())
		{
			String volume (drive.getVolumeLabel());

			if (volume.isEmpty())
				volume = TRANS("Hard Drive");

			name << " [" << volume << ']';
		}
		else if (drive.isOnCDRomDrive())
		{
			name << TRANS(" [CD/DVD drive]");
		}

		rootNames.add (name);
	}

	rootPaths.add (String::empty);
	rootNames.add (String::empty);

	rootPaths.add (File::getSpecialLocation (File::userDocumentsDirectory).getFullPathName());
	rootNames.add ("Documents");
	rootPaths.add (File::getSpecialLocation (File::userDesktopDirectory).getFullPathName());
	rootNames.add ("Desktop");

   #elif JUCE_MAC
	rootPaths.add (File::getSpecialLocation (File::userHomeDirectory).getFullPathName());
	rootNames.add ("Home folder");
	rootPaths.add (File::getSpecialLocation (File::userDocumentsDirectory).getFullPathName());
	rootNames.add ("Documents");
	rootPaths.add (File::getSpecialLocation (File::userDesktopDirectory).getFullPathName());
	rootNames.add ("Desktop");

	rootPaths.add (String::empty);
	rootNames.add (String::empty);

	Array <File> volumes;
	File vol ("/Volumes");
	vol.findChildFiles (volumes, File::findDirectories, false);

	for (int i = 0; i < volumes.size(); ++i)
	{
		const File& volume = volumes.getReference(i);

		if (volume.isDirectory() && ! volume.getFileName().startsWithChar ('.'))
		{
			rootPaths.add (volume.getFullPathName());
			rootNames.add (volume.getFileName());
		}
	}

   #else
	rootPaths.add ("/");
	rootNames.add ("/");
	rootPaths.add (File::getSpecialLocation (File::userHomeDirectory).getFullPathName());
	rootNames.add ("Home folder");
	rootPaths.add (File::getSpecialLocation (File::userDesktopDirectory).getFullPathName());
	rootNames.add ("Desktop");
   #endif
}

/*** End of inlined file: juce_FileBrowserComponent.cpp ***/


/*** Start of inlined file: juce_FileChooser.cpp ***/
FileChooser::FileChooser (const String& chooserBoxTitle,
						  const File& currentFileOrDirectory,
						  const String& fileFilters,
						  const bool useNativeDialogBox_)
	: title (chooserBoxTitle),
	  filters (fileFilters),
	  startingFile (currentFileOrDirectory),
	  useNativeDialogBox (useNativeDialogBox_)
{
	if (useNativeDialogBox)
	{
		static bool canUseNativeBox = isPlatformDialogAvailable();
		if (! canUseNativeBox)
			useNativeDialogBox = false;
	}

	if (! fileFilters.containsNonWhitespaceChars())
		filters = "*";
}

FileChooser::~FileChooser()
{
}

#if JUCE_MODAL_LOOPS_PERMITTED
bool FileChooser::browseForFileToOpen (FilePreviewComponent* previewComponent)
{
	return showDialog (false, true, false, false, false, previewComponent);
}

bool FileChooser::browseForMultipleFilesToOpen (FilePreviewComponent* previewComponent)
{
	return showDialog (false, true, false, false, true, previewComponent);
}

bool FileChooser::browseForMultipleFilesOrDirectories (FilePreviewComponent* previewComponent)
{
	return showDialog (true, true, false, false, true, previewComponent);
}

bool FileChooser::browseForFileToSave (const bool warnAboutOverwritingExistingFiles)
{
	return showDialog (false, true, true, warnAboutOverwritingExistingFiles, false, nullptr);
}

bool FileChooser::browseForDirectory()
{
	return showDialog (true, false, false, false, false, nullptr);
}

bool FileChooser::showDialog (const bool selectsDirectories,
							  const bool selectsFiles,
							  const bool isSave,
							  const bool warnAboutOverwritingExistingFiles,
							  const bool selectMultipleFiles,
							  FilePreviewComponent* const previewComponent)
{
	WeakReference<Component> previouslyFocused (Component::getCurrentlyFocusedComponent());

	results.clear();

	// the preview component needs to be the right size before you pass it in here..
	jassert (previewComponent == nullptr || (previewComponent->getWidth() > 10
											   && previewComponent->getHeight() > 10));

   #if JUCE_WINDOWS
	if (useNativeDialogBox && ! (selectsFiles && selectsDirectories))
   #elif JUCE_MAC || JUCE_LINUX
	if (useNativeDialogBox && (previewComponent == nullptr))
   #else
	if (false)
   #endif
	{
		showPlatformDialog (results, title, startingFile, filters,
							selectsDirectories, selectsFiles, isSave,
							warnAboutOverwritingExistingFiles,
							selectMultipleFiles,
							previewComponent);
	}
	else
	{
		WildcardFileFilter wildcard (selectsFiles ? filters : String::empty,
									 selectsDirectories ? "*" : String::empty,
									 String::empty);

		int flags = isSave ? FileBrowserComponent::saveMode
						   : FileBrowserComponent::openMode;

		if (selectsFiles)
			flags |= FileBrowserComponent::canSelectFiles;

		if (selectsDirectories)
		{
			flags |= FileBrowserComponent::canSelectDirectories;

			if (! isSave)
				flags |= FileBrowserComponent::filenameBoxIsReadOnly;
		}

		if (selectMultipleFiles)
			flags |= FileBrowserComponent::canSelectMultipleItems;

		FileBrowserComponent browserComponent (flags, startingFile, &wildcard, previewComponent);

		FileChooserDialogBox box (title, String::empty,
								  browserComponent,
								  warnAboutOverwritingExistingFiles,
								  browserComponent.findColour (AlertWindow::backgroundColourId));

		if (box.show())
		{
			for (int i = 0; i < browserComponent.getNumSelectedFiles(); ++i)
				results.add (browserComponent.getSelectedFile (i));
		}
	}

	if (previouslyFocused != nullptr)
		previouslyFocused->grabKeyboardFocus();

	return results.size() > 0;
}
#endif

File FileChooser::getResult() const
{
	// if you've used a multiple-file select, you should use the getResults() method
	// to retrieve all the files that were chosen.
	jassert (results.size() <= 1);

	return results.getFirst();
}

const Array<File>& FileChooser::getResults() const
{
	return results;
}

FilePreviewComponent::FilePreviewComponent()
{
}

FilePreviewComponent::~FilePreviewComponent()
{
}

/*** End of inlined file: juce_FileChooser.cpp ***/


/*** Start of inlined file: juce_FileChooserDialogBox.cpp ***/
class FileChooserDialogBox::ContentComponent  : public Component
{
public:

	ContentComponent (const String& name, const String& instructions_, FileBrowserComponent& chooserComponent_)
		: Component (name),
		  chooserComponent (chooserComponent_),
		  okButton (chooserComponent_.getActionVerb()),
		  cancelButton (TRANS ("Cancel")),
		  newFolderButton (TRANS ("New Folder")),
		  instructions (instructions_)
	{
		addAndMakeVisible (&chooserComponent);

		addAndMakeVisible (&okButton);
		okButton.addShortcut (KeyPress::returnKey);

		addAndMakeVisible (&cancelButton);
		cancelButton.addShortcut (KeyPress::escapeKey);

		addChildComponent (&newFolderButton);

		setInterceptsMouseClicks (false, true);
	}

	void paint (Graphics& g)
	{
		g.setColour (getLookAndFeel().findColour (FileChooserDialogBox::titleTextColourId));
		text.draw (g);
	}

	void resized()
	{
		const int buttonHeight = 26;

		Rectangle<int> area (getLocalBounds());

		getLookAndFeel().createFileChooserHeaderText (getName(), instructions, text, getWidth());
		const Rectangle<float> bb (text.getBoundingBox (0, text.getNumGlyphs(), false));
		area.removeFromTop (roundToInt (bb.getBottom()) + 10);

		chooserComponent.setBounds (area.removeFromTop (area.getHeight() - buttonHeight - 20));
		Rectangle<int> buttonArea (area.reduced (16, 10));

		okButton.changeWidthToFitText (buttonHeight);
		okButton.setBounds (buttonArea.removeFromRight (okButton.getWidth() + 16));

		buttonArea.removeFromRight (16);

		cancelButton.changeWidthToFitText (buttonHeight);
		cancelButton.setBounds (buttonArea.removeFromRight (cancelButton.getWidth()));

		newFolderButton.changeWidthToFitText (buttonHeight);
		newFolderButton.setBounds (buttonArea.removeFromLeft (newFolderButton.getWidth()));
	}

	FileBrowserComponent& chooserComponent;
	TextButton okButton, cancelButton, newFolderButton;

private:
	String instructions;
	GlyphArrangement text;
};

FileChooserDialogBox::FileChooserDialogBox (const String& name,
											const String& instructions,
											FileBrowserComponent& chooserComponent,
											const bool warnAboutOverwritingExistingFiles_,
											const Colour& backgroundColour)
	: ResizableWindow (name, backgroundColour, true),
	  warnAboutOverwritingExistingFiles (warnAboutOverwritingExistingFiles_)
{
	content = new ContentComponent (name, instructions, chooserComponent);
	setContentOwned (content, false);

	setResizable (true, true);
	setResizeLimits (300, 300, 1200, 1000);

	content->okButton.addListener (this);
	content->cancelButton.addListener (this);
	content->newFolderButton.addListener (this);
	content->chooserComponent.addListener (this);

	FileChooserDialogBox::selectionChanged();
}

FileChooserDialogBox::~FileChooserDialogBox()
{
	content->chooserComponent.removeListener (this);
}

#if JUCE_MODAL_LOOPS_PERMITTED
bool FileChooserDialogBox::show (int w, int h)
{
	return showAt (-1, -1, w, h);
}

bool FileChooserDialogBox::showAt (int x, int y, int w, int h)
{
	if (w <= 0)
	{
		Component* const previewComp = content->chooserComponent.getPreviewComponent();

		if (previewComp != nullptr)
			w = 400 + previewComp->getWidth();
		else
			w = 600;
	}

	if (h <= 0)
		h = 500;

	if (x < 0 || y < 0)
		centreWithSize (w, h);
	else
		setBounds (x, y, w, h);

	const bool ok = (runModalLoop() != 0);
	setVisible (false);
	return ok;
}
#endif

void FileChooserDialogBox::centreWithDefaultSize (Component* componentToCentreAround)
{
	Component* const previewComp = content->chooserComponent.getPreviewComponent();

	centreAroundComponent (componentToCentreAround,
						   previewComp != nullptr ? 400 + previewComp->getWidth() : 600,
						   500);
}

void FileChooserDialogBox::buttonClicked (Button* button)
{
	if (button == &(content->okButton))
	{
		okButtonPressed();
	}
	else if (button == &(content->cancelButton))
	{
		closeButtonPressed();
	}
	else if (button == &(content->newFolderButton))
	{
		createNewFolder();
	}
}

void FileChooserDialogBox::closeButtonPressed()
{
	setVisible (false);
}

void FileChooserDialogBox::selectionChanged()
{
	content->okButton.setEnabled (content->chooserComponent.currentFileIsValid());

	content->newFolderButton.setVisible (content->chooserComponent.isSaveMode()
										  && content->chooserComponent.getRoot().isDirectory());
}

void FileChooserDialogBox::fileDoubleClicked (const File&)
{
	selectionChanged();
	content->okButton.triggerClick();
}

void FileChooserDialogBox::fileClicked (const File&, const MouseEvent&) {}
void FileChooserDialogBox::browserRootChanged (const File&) {}

void FileChooserDialogBox::okToOverwriteFileCallback (int result, FileChooserDialogBox* box)
{
	if (result != 0 && box != nullptr)
		box->exitModalState (1);
}

void FileChooserDialogBox::okButtonPressed()
{
	if (warnAboutOverwritingExistingFiles
		 && content->chooserComponent.isSaveMode()
		 && content->chooserComponent.getSelectedFile(0).exists())
	{
		AlertWindow::showOkCancelBox (AlertWindow::WarningIcon,
										 TRANS("File already exists"),
										 TRANS("There's already a file called:")
										   + "\n\n" + content->chooserComponent.getSelectedFile(0).getFullPathName()
										   + "\n\n" + TRANS("Are you sure you want to overwrite it?"),
										 TRANS("overwrite"),
										 TRANS("cancel"),
									  this,
									  ModalCallbackFunction::forComponent (okToOverwriteFileCallback, this));
	}
	else
	{
		exitModalState (1);
	}
}

void FileChooserDialogBox::createNewFolderCallback (int result, FileChooserDialogBox* box,
													Component::SafePointer<AlertWindow> alert)
{
	if (result != 0 && alert != nullptr && box != nullptr)
	{
		alert->setVisible (false);
		box->createNewFolderConfirmed (alert->getTextEditorContents ("name"));
	}
}

void FileChooserDialogBox::createNewFolder()
{
	File parent (content->chooserComponent.getRoot());

	if (parent.isDirectory())
	{
		AlertWindow* aw = new AlertWindow (TRANS("New Folder"),
										   TRANS("Please enter the name for the folder"),
										   AlertWindow::NoIcon, this);

		aw->addTextEditor ("name", String::empty, String::empty, false);
		aw->addButton (TRANS("ok"), 1, KeyPress::returnKey);
		aw->addButton (TRANS("cancel"), KeyPress::escapeKey);

		aw->enterModalState (true,
							 ModalCallbackFunction::forComponent (createNewFolderCallback, this,
																  Component::SafePointer<AlertWindow> (aw)),
							 true);
	}
}

void FileChooserDialogBox::createNewFolderConfirmed (const String& nameFromDialog)
{
	const String name (File::createLegalFileName (nameFromDialog));

	if (! name.isEmpty())
	{
		const File parent (content->chooserComponent.getRoot());

		if (! parent.getChildFile (name).createDirectory())
		{
			AlertWindow::showMessageBoxAsync (AlertWindow::WarningIcon,
											  TRANS ("New Folder"),
											  TRANS ("Couldn't create the folder!"));
		}

		content->chooserComponent.refresh();
	}
}

/*** End of inlined file: juce_FileChooserDialogBox.cpp ***/


/*** Start of inlined file: juce_FileFilter.cpp ***/
FileFilter::FileFilter (const String& filterDescription)
	: description (filterDescription)
{
}

FileFilter::~FileFilter()
{
}

const String& FileFilter::getDescription() const noexcept
{
	return description;
}

/*** End of inlined file: juce_FileFilter.cpp ***/


/*** Start of inlined file: juce_FileListComponent.cpp ***/
Image juce_createIconForFile (const File& file);

FileListComponent::FileListComponent (DirectoryContentsList& listToShow)
	: ListBox (String::empty, nullptr),
	  DirectoryContentsDisplayComponent (listToShow)
{
	setModel (this);
	fileList.addChangeListener (this);
}

FileListComponent::~FileListComponent()
{
	fileList.removeChangeListener (this);
}

int FileListComponent::getNumSelectedFiles() const
{
	return getNumSelectedRows();
}

File FileListComponent::getSelectedFile (int index) const
{
	return fileList.getFile (getSelectedRow (index));
}

void FileListComponent::deselectAllFiles()
{
	deselectAllRows();
}

void FileListComponent::scrollToTop()
{
	getVerticalScrollBar()->setCurrentRangeStart (0);
}

void FileListComponent::setSelectedFile (const File& f)
{
	for (int i = fileList.getNumFiles(); --i >= 0;)
	{
		if (fileList.getFile(i) == f)
		{
			selectRow (i);
			return;
		}
	}

	deselectAllRows();
}

void FileListComponent::changeListenerCallback (ChangeBroadcaster*)
{
	updateContent();

	if (lastDirectory != fileList.getDirectory())
	{
		lastDirectory = fileList.getDirectory();
		deselectAllRows();
	}
}

class FileListItemComponent  : public Component,
							   public TimeSliceClient,
							   public AsyncUpdater
{
public:
	FileListItemComponent (FileListComponent& owner_, TimeSliceThread& thread_)
		: owner (owner_), thread (thread_), index (0), highlighted (false)
	{
	}

	~FileListItemComponent()
	{
		thread.removeTimeSliceClient (this);
	}

	void paint (Graphics& g)
	{
		getLookAndFeel().drawFileBrowserRow (g, getWidth(), getHeight(),
											 file.getFileName(),
											 &icon, fileSize, modTime,
											 isDirectory, highlighted,
											 index, owner);
	}

	void mouseDown (const MouseEvent& e)
	{
		owner.selectRowsBasedOnModifierKeys (index, e.mods, false);
		owner.sendMouseClickMessage (file, e);
	}

	void mouseDoubleClick (const MouseEvent&)
	{
		owner.sendDoubleClickMessage (file);
	}

	void update (const File& root,
				 const DirectoryContentsList::FileInfo* const fileInfo,
				 const int index_,
				 const bool highlighted_)
	{
		thread.removeTimeSliceClient (this);

		if (highlighted_ != highlighted || index_ != index)
		{
			index = index_;
			highlighted = highlighted_;
			repaint();
		}

		File newFile;
		String newFileSize, newModTime;

		if (fileInfo != nullptr)
		{
			newFile = root.getChildFile (fileInfo->filename);
			newFileSize = File::descriptionOfSizeInBytes (fileInfo->fileSize);
			newModTime = fileInfo->modificationTime.formatted ("%d %b '%y %H:%M");
		}

		if (newFile != file
			 || fileSize != newFileSize
			 || modTime != newModTime)
		{
			file = newFile;
			fileSize = newFileSize;
			modTime = newModTime;
			icon = Image::null;
			isDirectory = fileInfo != nullptr && fileInfo->isDirectory;

			repaint();
		}

		if (file != File::nonexistent && icon.isNull() && ! isDirectory)
		{
			updateIcon (true);

			if (! icon.isValid())
				thread.addTimeSliceClient (this);
		}
	}

	int useTimeSlice()
	{
		updateIcon (false);
		return -1;
	}

	void handleAsyncUpdate()
	{
		repaint();
	}

private:

	FileListComponent& owner;
	TimeSliceThread& thread;
	File file;
	String fileSize, modTime;
	Image icon;
	int index;
	bool highlighted, isDirectory;

	void updateIcon (const bool onlyUpdateIfCached)
	{
		if (icon.isNull())
		{
			const int hashCode = (file.getFullPathName() + "_iconCacheSalt").hashCode();
			Image im (ImageCache::getFromHashCode (hashCode));

			if (im.isNull() && ! onlyUpdateIfCached)
			{
				im = juce_createIconForFile (file);

				if (im.isValid())
					ImageCache::addImageToCache (im, hashCode);
			}

			if (im.isValid())
			{
				icon = im;
				triggerAsyncUpdate();
			}
		}
	}

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (FileListItemComponent);
};

int FileListComponent::getNumRows()
{
	return fileList.getNumFiles();
}

void FileListComponent::paintListBoxItem (int, Graphics&, int, int, bool)
{
}

Component* FileListComponent::refreshComponentForRow (int row, bool isSelected, Component* existingComponentToUpdate)
{
	FileListItemComponent* comp = dynamic_cast <FileListItemComponent*> (existingComponentToUpdate);

	if (comp == nullptr)
	{
		delete existingComponentToUpdate;
		comp = new FileListItemComponent (*this, fileList.getTimeSliceThread());
	}

	DirectoryContentsList::FileInfo fileInfo;
	comp->update (fileList.getDirectory(),
				  fileList.getFileInfo (row, fileInfo) ? &fileInfo : nullptr,
				  row, isSelected);

	return comp;
}

void FileListComponent::selectedRowsChanged (int /*lastRowSelected*/)
{
	sendSelectionChangeMessage();
}

void FileListComponent::deleteKeyPressed (int /*currentSelectedRow*/)
{
}

void FileListComponent::returnKeyPressed (int currentSelectedRow)
{
	sendDoubleClickMessage (fileList.getFile (currentSelectedRow));
}

/*** End of inlined file: juce_FileListComponent.cpp ***/


/*** Start of inlined file: juce_FilenameComponent.cpp ***/
FilenameComponent::FilenameComponent (const String& name,
									  const File& currentFile,
									  const bool canEditFilename,
									  const bool isDirectory,
									  const bool isForSaving,
									  const String& fileBrowserWildcard,
									  const String& enforcedSuffix_,
									  const String& textWhenNothingSelected)
	: Component (name),
	  maxRecentFiles (30),
	  isDir (isDirectory),
	  isSaving (isForSaving),
	  isFileDragOver (false),
	  wildcard (fileBrowserWildcard),
	  enforcedSuffix (enforcedSuffix_)
{
	addAndMakeVisible (&filenameBox);
	filenameBox.setEditableText (canEditFilename);
	filenameBox.addListener (this);
	filenameBox.setTextWhenNothingSelected (textWhenNothingSelected);
	filenameBox.setTextWhenNoChoicesAvailable (TRANS ("(no recently selected files)"));

	setBrowseButtonText ("...");

	setCurrentFile (currentFile, true);
}

FilenameComponent::~FilenameComponent()
{
}

void FilenameComponent::paintOverChildren (Graphics& g)
{
	if (isFileDragOver)
	{
		g.setColour (Colours::red.withAlpha (0.2f));
		g.drawRect (0, 0, getWidth(), getHeight(), 3);
	}
}

void FilenameComponent::resized()
{
	getLookAndFeel().layoutFilenameComponent (*this, &filenameBox, browseButton);
}

void FilenameComponent::setBrowseButtonText (const String& newBrowseButtonText)
{
	browseButtonText = newBrowseButtonText;
	lookAndFeelChanged();
}

void FilenameComponent::lookAndFeelChanged()
{
	browseButton = nullptr;

	addAndMakeVisible (browseButton = getLookAndFeel().createFilenameComponentBrowseButton (browseButtonText));
	browseButton->setConnectedEdges (Button::ConnectedOnLeft);
	resized();

	browseButton->addListener (this);
}

void FilenameComponent::setTooltip (const String& newTooltip)
{
	SettableTooltipClient::setTooltip (newTooltip);
	filenameBox.setTooltip (newTooltip);
}

void FilenameComponent::setDefaultBrowseTarget (const File& newDefaultDirectory)
{
	defaultBrowseFile = newDefaultDirectory;
}

void FilenameComponent::buttonClicked (Button*)
{
   #if JUCE_MODAL_LOOPS_PERMITTED
	FileChooser fc (TRANS("Choose a new file"),
					getCurrentFile() == File::nonexistent ? defaultBrowseFile
														  : getCurrentFile(),
					wildcard);

	if (isDir ? fc.browseForDirectory()
			  : (isSaving ? fc.browseForFileToSave (false)
						  : fc.browseForFileToOpen()))
	{
		setCurrentFile (fc.getResult(), true);
	}
   #else
	jassertfalse; // needs rewriting to deal with non-modal environments
   #endif
}

void FilenameComponent::comboBoxChanged (ComboBox*)
{
	setCurrentFile (getCurrentFile(), true);
}

bool FilenameComponent::isInterestedInFileDrag (const StringArray&)
{
	return true;
}

void FilenameComponent::filesDropped (const StringArray& filenames, int, int)
{
	isFileDragOver = false;
	repaint();

	const File f (filenames[0]);

	if (f.exists() && (f.isDirectory() == isDir))
		setCurrentFile (f, true);
}

void FilenameComponent::fileDragEnter (const StringArray&, int, int)
{
	isFileDragOver = true;
	repaint();
}

void FilenameComponent::fileDragExit (const StringArray&)
{
	isFileDragOver = false;
	repaint();
}

File FilenameComponent::getCurrentFile() const
{
	File f (filenameBox.getText());

	if (enforcedSuffix.isNotEmpty())
		f = f.withFileExtension (enforcedSuffix);

	return f;
}

void FilenameComponent::setCurrentFile (File newFile,
										const bool addToRecentlyUsedList,
										const bool sendChangeNotification)
{
	if (enforcedSuffix.isNotEmpty())
		newFile = newFile.withFileExtension (enforcedSuffix);

	if (newFile.getFullPathName() != lastFilename)
	{
		lastFilename = newFile.getFullPathName();

		if (addToRecentlyUsedList)
			addRecentlyUsedFile (newFile);

		filenameBox.setText (lastFilename, true);

		if (sendChangeNotification)
			triggerAsyncUpdate();
	}
}

void FilenameComponent::setFilenameIsEditable (const bool shouldBeEditable)
{
	filenameBox.setEditableText (shouldBeEditable);
}

StringArray FilenameComponent::getRecentlyUsedFilenames() const
{
	StringArray names;

	for (int i = 0; i < filenameBox.getNumItems(); ++i)
		names.add (filenameBox.getItemText (i));

	return names;
}

void FilenameComponent::setRecentlyUsedFilenames (const StringArray& filenames)
{
	if (filenames != getRecentlyUsedFilenames())
	{
		filenameBox.clear();

		for (int i = 0; i < jmin (filenames.size(), maxRecentFiles); ++i)
			filenameBox.addItem (filenames[i], i + 1);
	}
}

void FilenameComponent::setMaxNumberOfRecentFiles (const int newMaximum)
{
	maxRecentFiles = jmax (1, newMaximum);

	setRecentlyUsedFilenames (getRecentlyUsedFilenames());
}

void FilenameComponent::addRecentlyUsedFile (const File& file)
{
	StringArray files (getRecentlyUsedFilenames());

	if (file.getFullPathName().isNotEmpty())
	{
		files.removeString (file.getFullPathName(), true);
		files.insert (0, file.getFullPathName());

		setRecentlyUsedFilenames (files);
	}
}

void FilenameComponent::addListener (FilenameComponentListener* const listener)
{
	listeners.add (listener);
}

void FilenameComponent::removeListener (FilenameComponentListener* const listener)
{
	listeners.remove (listener);
}

void FilenameComponent::handleAsyncUpdate()
{
	Component::BailOutChecker checker (this);
	listeners.callChecked (checker, &FilenameComponentListener::filenameComponentChanged, this);
}

/*** End of inlined file: juce_FilenameComponent.cpp ***/


/*** Start of inlined file: juce_FileSearchPathListComponent.cpp ***/
FileSearchPathListComponent::FileSearchPathListComponent()
	: addButton ("+"),
	  removeButton ("-"),
	  changeButton (TRANS ("change...")),
	  upButton (String::empty, DrawableButton::ImageOnButtonBackground),
	  downButton (String::empty, DrawableButton::ImageOnButtonBackground)
{
	listBox.setModel (this);
	addAndMakeVisible (&listBox);
	listBox.setColour (ListBox::backgroundColourId, Colours::black.withAlpha (0.02f));
	listBox.setColour (ListBox::outlineColourId, Colours::black.withAlpha (0.1f));
	listBox.setOutlineThickness (1);

	addAndMakeVisible (&addButton);
	addButton.addListener (this);
	addButton.setConnectedEdges (Button::ConnectedOnLeft | Button::ConnectedOnRight | Button::ConnectedOnBottom | Button::ConnectedOnTop);

	addAndMakeVisible (&removeButton);
	removeButton.addListener (this);
	removeButton.setConnectedEdges (Button::ConnectedOnLeft | Button::ConnectedOnRight | Button::ConnectedOnBottom | Button::ConnectedOnTop);

	addAndMakeVisible (&changeButton);
	changeButton.addListener (this);

	addAndMakeVisible (&upButton);
	upButton.addListener (this);

	{
		Path arrowPath;
		arrowPath.addArrow (Line<float> (50.0f, 100.0f, 50.0f, 0.0f), 40.0f, 100.0f, 50.0f);
		DrawablePath arrowImage;
		arrowImage.setFill (Colours::black.withAlpha (0.4f));
		arrowImage.setPath (arrowPath);

		upButton.setImages (&arrowImage);
	}

	addAndMakeVisible (&downButton);
	downButton.addListener (this);

	{
		Path arrowPath;
		arrowPath.addArrow (Line<float> (50.0f, 0.0f, 50.0f, 100.0f), 40.0f, 100.0f, 50.0f);
		DrawablePath arrowImage;
		arrowImage.setFill (Colours::black.withAlpha (0.4f));
		arrowImage.setPath (arrowPath);

		downButton.setImages (&arrowImage);
	}

	updateButtons();
}

FileSearchPathListComponent::~FileSearchPathListComponent()
{
}

void FileSearchPathListComponent::updateButtons()
{
	const bool anythingSelected = listBox.getNumSelectedRows() > 0;

	removeButton.setEnabled (anythingSelected);
	changeButton.setEnabled (anythingSelected);
	upButton.setEnabled (anythingSelected);
	downButton.setEnabled (anythingSelected);
}

void FileSearchPathListComponent::changed()
{
	listBox.updateContent();
	listBox.repaint();
	updateButtons();
}

void FileSearchPathListComponent::setPath (const FileSearchPath& newPath)
{
	if (newPath.toString() != path.toString())
	{
		path = newPath;
		changed();
	}
}

void FileSearchPathListComponent::setDefaultBrowseTarget (const File& newDefaultDirectory)
{
	defaultBrowseTarget = newDefaultDirectory;
}

int FileSearchPathListComponent::getNumRows()
{
	return path.getNumPaths();
}

void FileSearchPathListComponent::paintListBoxItem (int rowNumber, Graphics& g, int width, int height, bool rowIsSelected)
{
	if (rowIsSelected)
		g.fillAll (findColour (TextEditor::highlightColourId));

	g.setColour (findColour (ListBox::textColourId));
	Font f (height * 0.7f);
	f.setHorizontalScale (0.9f);
	g.setFont (f);

	g.drawText (path [rowNumber].getFullPathName(),
				4, 0, width - 6, height,
				Justification::centredLeft, true);
}

void FileSearchPathListComponent::deleteKeyPressed (int row)
{
	if (isPositiveAndBelow (row, path.getNumPaths()))
	{
		path.remove (row);
		changed();
	}
}

void FileSearchPathListComponent::returnKeyPressed (int row)
{
   #if JUCE_MODAL_LOOPS_PERMITTED
	FileChooser chooser (TRANS("Change folder..."), path [row], "*");

	if (chooser.browseForDirectory())
	{
		path.remove (row);
		path.add (chooser.getResult(), row);
		changed();
	}
   #endif
}

void FileSearchPathListComponent::listBoxItemDoubleClicked (int row, const MouseEvent&)
{
	returnKeyPressed (row);
}

void FileSearchPathListComponent::selectedRowsChanged (int)
{
	updateButtons();
}

void FileSearchPathListComponent::paint (Graphics& g)
{
	g.fillAll (findColour (backgroundColourId));
}

void FileSearchPathListComponent::resized()
{
	const int buttonH = 22;
	const int buttonY = getHeight() - buttonH - 4;
	listBox.setBounds (2, 2, getWidth() - 4, buttonY - 5);

	addButton.setBounds (2, buttonY, buttonH, buttonH);
	removeButton.setBounds (addButton.getRight(), buttonY, buttonH, buttonH);

	changeButton.changeWidthToFitText (buttonH);
	downButton.setSize (buttonH * 2, buttonH);
	upButton.setSize (buttonH * 2, buttonH);

	downButton.setTopRightPosition (getWidth() - 2, buttonY);
	upButton.setTopRightPosition (downButton.getX() - 4, buttonY);
	changeButton.setTopRightPosition (upButton.getX() - 8, buttonY);
}

bool FileSearchPathListComponent::isInterestedInFileDrag (const StringArray&)
{
	return true;
}

void FileSearchPathListComponent::filesDropped (const StringArray& filenames, int, int mouseY)
{
	for (int i = filenames.size(); --i >= 0;)
	{
		const File f (filenames[i]);

		if (f.isDirectory())
		{
			const int row = listBox.getRowContainingPosition (0, mouseY - listBox.getY());
			path.add (f, row);
			changed();
		}
	}
}

void FileSearchPathListComponent::buttonClicked (Button* button)
{
	const int currentRow = listBox.getSelectedRow();

	if (button == &removeButton)
	{
		deleteKeyPressed (currentRow);
	}
	else if (button == &addButton)
	{
		File start (defaultBrowseTarget);

		if (start == File::nonexistent)
			start = path [0];

		if (start == File::nonexistent)
			start = File::getCurrentWorkingDirectory();

	   #if JUCE_MODAL_LOOPS_PERMITTED
		FileChooser chooser (TRANS("Add a folder..."), start, "*");

		if (chooser.browseForDirectory())
			path.add (chooser.getResult(), currentRow);
	   #else
		jassertfalse; // needs rewriting to deal with non-modal environments
	   #endif
	}
	else if (button == &changeButton)
	{
		returnKeyPressed (currentRow);
	}
	else if (button == &upButton)
	{
		if (currentRow > 0 && currentRow < path.getNumPaths())
		{
			const File f (path[currentRow]);
			path.remove (currentRow);
			path.add (f, currentRow - 1);
			listBox.selectRow (currentRow - 1);
		}
	}
	else if (button == &downButton)
	{
		if (currentRow >= 0 && currentRow < path.getNumPaths() - 1)
		{
			const File f (path[currentRow]);
			path.remove (currentRow);
			path.add (f, currentRow + 1);
			listBox.selectRow (currentRow + 1);
		}
	}

	changed();
}

/*** End of inlined file: juce_FileSearchPathListComponent.cpp ***/


/*** Start of inlined file: juce_FileTreeComponent.cpp ***/
Image juce_createIconForFile (const File& file);

class FileListTreeItem   : public TreeViewItem,
						   public TimeSliceClient,
						   public AsyncUpdater,
						   public ChangeListener
{
public:
	FileListTreeItem (FileTreeComponent& owner_,
					  DirectoryContentsList* const parentContentsList_,
					  const int indexInContentsList_,
					  const File& file_,
					  TimeSliceThread& thread_)
		: file (file_),
		  owner (owner_),
		  parentContentsList (parentContentsList_),
		  indexInContentsList (indexInContentsList_),
		  subContentsList (nullptr, false),
		  thread (thread_)
	{
		DirectoryContentsList::FileInfo fileInfo;

		if (parentContentsList_ != nullptr
			 && parentContentsList_->getFileInfo (indexInContentsList_, fileInfo))
		{
			fileSize = File::descriptionOfSizeInBytes (fileInfo.fileSize);
			modTime = fileInfo.modificationTime.formatted ("%d %b '%y %H:%M");
			isDirectory = fileInfo.isDirectory;
		}
		else
		{
			isDirectory = true;
		}
	}

	~FileListTreeItem()
	{
		thread.removeTimeSliceClient (this);
		clearSubItems();
	}

	bool mightContainSubItems()                 { return isDirectory; }
	String getUniqueName() const                { return file.getFullPathName(); }
	int getItemHeight() const                   { return 22; }

	var getDragSourceDescription()              { return owner.getDragAndDropDescription(); }

	void itemOpennessChanged (bool isNowOpen)
	{
		if (isNowOpen)
		{
			clearSubItems();

			isDirectory = file.isDirectory();

			if (isDirectory)
			{
				if (subContentsList == nullptr)
				{
					jassert (parentContentsList != nullptr);

					DirectoryContentsList* const l = new DirectoryContentsList (parentContentsList->getFilter(), thread);
					l->setDirectory (file, true, true);

					setSubContentsList (l, true);
				}

				changeListenerCallback (nullptr);
			}
		}
	}

	void setSubContentsList (DirectoryContentsList* newList, const bool canDeleteList)
	{
		OptionalScopedPointer<DirectoryContentsList> newPointer (newList, canDeleteList);
		subContentsList = newPointer;
		newList->addChangeListener (this);
	}

	void changeListenerCallback (ChangeBroadcaster*)
	{
		clearSubItems();

		if (isOpen() && subContentsList != nullptr)
		{
			for (int i = 0; i < subContentsList->getNumFiles(); ++i)
			{
				FileListTreeItem* const item
					= new FileListTreeItem (owner, subContentsList, i, subContentsList->getFile(i), thread);

				addSubItem (item);
			}
		}
	}

	void paintItem (Graphics& g, int width, int height)
	{
		if (file != File::nonexistent)
		{
			updateIcon (true);

			if (icon.isNull())
				thread.addTimeSliceClient (this);
		}

		owner.getLookAndFeel().drawFileBrowserRow (g, width, height,
												   file.getFileName(),
												   &icon, fileSize, modTime,
												   isDirectory, isSelected(),
												   indexInContentsList, owner);
	}

	void itemClicked (const MouseEvent& e)
	{
		owner.sendMouseClickMessage (file, e);
	}

	void itemDoubleClicked (const MouseEvent& e)
	{
		TreeViewItem::itemDoubleClicked (e);

		owner.sendDoubleClickMessage (file);
	}

	void itemSelectionChanged (bool)
	{
		owner.sendSelectionChangeMessage();
	}

	int useTimeSlice()
	{
		updateIcon (false);
		return -1;
	}

	void handleAsyncUpdate()
	{
		owner.repaint();
	}

	const File file;

private:
	FileTreeComponent& owner;
	DirectoryContentsList* parentContentsList;
	int indexInContentsList;
	OptionalScopedPointer<DirectoryContentsList> subContentsList;
	bool isDirectory;
	TimeSliceThread& thread;
	Image icon;
	String fileSize, modTime;

	void updateIcon (const bool onlyUpdateIfCached)
	{
		if (icon.isNull())
		{
			const int hashCode = (file.getFullPathName() + "_iconCacheSalt").hashCode();
			Image im (ImageCache::getFromHashCode (hashCode));

			if (im.isNull() && ! onlyUpdateIfCached)
			{
				im = juce_createIconForFile (file);

				if (im.isValid())
					ImageCache::addImageToCache (im, hashCode);
			}

			if (im.isValid())
			{
				icon = im;
				triggerAsyncUpdate();
			}
		}
	}

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (FileListTreeItem);
};

FileTreeComponent::FileTreeComponent (DirectoryContentsList& listToShow)
	: DirectoryContentsDisplayComponent (listToShow)
{
	setRootItemVisible (false);
	refresh();
}

FileTreeComponent::~FileTreeComponent()
{
	deleteRootItem();
}

void FileTreeComponent::refresh()
{
	deleteRootItem();

	FileListTreeItem* const root
		= new FileListTreeItem (*this, nullptr, 0, fileList.getDirectory(),
								fileList.getTimeSliceThread());

	root->setSubContentsList (&fileList, false);
	setRootItem (root);
}

File FileTreeComponent::getSelectedFile (const int index) const
{
	const FileListTreeItem* const item = dynamic_cast <const FileListTreeItem*> (getSelectedItem (index));

	return item != nullptr ? item->file
						   : File::nonexistent;
}

void FileTreeComponent::deselectAllFiles()
{
	clearSelectedItems();
}

void FileTreeComponent::scrollToTop()
{
	getViewport()->getVerticalScrollBar()->setCurrentRangeStart (0);
}

void FileTreeComponent::setDragAndDropDescription (const String& description)
{
	dragAndDropDescription = description;
}

void FileTreeComponent::setSelectedFile (const File& target)
{
	for (int i = getNumSelectedItems(); --i >= 0;)
	{
		FileListTreeItem* t = dynamic_cast <FileListTreeItem*> (getSelectedItem (i));

		if (t != nullptr && t->file == target)
		{
			t->setSelected (true, true);
			return;
		}
	}

	clearSelectedItems();
}

/*** End of inlined file: juce_FileTreeComponent.cpp ***/


/*** Start of inlined file: juce_ImagePreviewComponent.cpp ***/
ImagePreviewComponent::ImagePreviewComponent()
{
}

ImagePreviewComponent::~ImagePreviewComponent()
{
}

void ImagePreviewComponent::getThumbSize (int& w, int& h) const
{
	const int availableW = proportionOfWidth (0.97f);
	const int availableH = getHeight() - 13 * 4;

	const double scale = jmin (1.0,
							   availableW / (double) w,
							   availableH / (double) h);

	w = roundToInt (scale * w);
	h = roundToInt (scale * h);
}

void ImagePreviewComponent::selectedFileChanged (const File& file)
{
	if (fileToLoad != file)
	{
		fileToLoad = file;
		startTimer (100);
	}
}

void ImagePreviewComponent::timerCallback()
{
	stopTimer();

	currentThumbnail = Image::null;
	currentDetails = String::empty;
	repaint();

	ScopedPointer <FileInputStream> in (fileToLoad.createInputStream());

	if (in != nullptr)
	{
		ImageFileFormat* const format = ImageFileFormat::findImageFormatForStream (*in);

		if (format != nullptr)
		{
			currentThumbnail = format->decodeImage (*in);

			if (currentThumbnail.isValid())
			{
				int w = currentThumbnail.getWidth();
				int h = currentThumbnail.getHeight();

				currentDetails
					<< fileToLoad.getFileName() << "\n"
					<< format->getFormatName() << "\n"
					<< w << " x " << h << " pixels\n"
					<< File::descriptionOfSizeInBytes (fileToLoad.getSize());

				getThumbSize (w, h);

				currentThumbnail = currentThumbnail.rescaled (w, h);
			}
		}
	}
}

void ImagePreviewComponent::paint (Graphics& g)
{
	if (currentThumbnail.isValid())
	{
		g.setFont (13.0f);

		int w = currentThumbnail.getWidth();
		int h = currentThumbnail.getHeight();
		getThumbSize (w, h);

		const int numLines = 4;
		const int totalH = 13 * numLines + h + 4;
		const int y = (getHeight() - totalH) / 2;

		g.drawImageWithin (currentThumbnail,
						   (getWidth() - w) / 2, y, w, h,
						   RectanglePlacement::centred | RectanglePlacement::onlyReduceInSize,
						   false);

		g.drawFittedText (currentDetails,
						  0, y + h + 4, getWidth(), 100,
						  Justification::centredTop, numLines);
	}
}

/*** End of inlined file: juce_ImagePreviewComponent.cpp ***/


/*** Start of inlined file: juce_WildcardFileFilter.cpp ***/
WildcardFileFilter::WildcardFileFilter (const String& fileWildcardPatterns,
										const String& directoryWildcardPatterns,
										const String& description_)
	: FileFilter (description_.isEmpty() ? fileWildcardPatterns
										 : (description_ + " (" + fileWildcardPatterns + ")"))
{
	parse (fileWildcardPatterns, fileWildcards);
	parse (directoryWildcardPatterns, directoryWildcards);
}

WildcardFileFilter::~WildcardFileFilter()
{
}

bool WildcardFileFilter::isFileSuitable (const File& file) const
{
	return match (file, fileWildcards);
}

bool WildcardFileFilter::isDirectorySuitable (const File& file) const
{
	return match (file, directoryWildcards);
}

void WildcardFileFilter::parse (const String& pattern, StringArray& result)
{
	result.addTokens (pattern.toLowerCase(), ";,", "\"'");

	result.trim();
	result.removeEmptyStrings();

	// special case for *.*, because people use it to mean "any file", but it
	// would actually ignore files with no extension.
	for (int i = result.size(); --i >= 0;)
		if (result[i] == "*.*")
			result.set (i, "*");
}

bool WildcardFileFilter::match (const File& file, const StringArray& wildcards)
{
	const String filename (file.getFileName());

	for (int i = wildcards.size(); --i >= 0;)
		if (filename.matchesWildcard (wildcards[i], true))
			return true;

	return false;
}

/*** End of inlined file: juce_WildcardFileFilter.cpp ***/


/*** Start of inlined file: juce_ComponentAnimator.cpp ***/
class ComponentAnimator::AnimationTask
{
public:
	AnimationTask (Component* const comp)
		: component (comp)
	{
	}

	void reset (const Rectangle<int>& finalBounds,
				float finalAlpha,
				int millisecondsToSpendMoving,
				bool useProxyComponent,
				double startSpeed_, double endSpeed_)
	{
		msElapsed = 0;
		msTotal = jmax (1, millisecondsToSpendMoving);
		lastProgress = 0;
		destination = finalBounds;
		destAlpha = finalAlpha;

		isMoving = (finalBounds != component->getBounds());
		isChangingAlpha = (finalAlpha != component->getAlpha());

		left = component->getX();
		top = component->getY();
		right = component->getRight();
		bottom = component->getBottom();
		alpha = component->getAlpha();

		const double invTotalDistance = 4.0 / (startSpeed_ + endSpeed_ + 2.0);
		startSpeed = jmax (0.0, startSpeed_ * invTotalDistance);
		midSpeed = invTotalDistance;
		endSpeed = jmax (0.0, endSpeed_ * invTotalDistance);

		if (useProxyComponent)
			proxy = new ProxyComponent (*component);
		else
			proxy = nullptr;

		component->setVisible (! useProxyComponent);
	}

	bool useTimeslice (const int elapsed)
	{
		Component* const c = proxy != nullptr ? static_cast <Component*> (proxy)
											  : static_cast <Component*> (component);

		if (c != nullptr)
		{
			msElapsed += elapsed;
			double newProgress = msElapsed / (double) msTotal;

			if (newProgress >= 0 && newProgress < 1.0)
			{
				newProgress = timeToDistance (newProgress);
				const double delta = (newProgress - lastProgress) / (1.0 - lastProgress);
				jassert (newProgress >= lastProgress);
				lastProgress = newProgress;

				if (delta < 1.0)
				{
					bool stillBusy = false;

					if (isMoving)
					{
						left   += (destination.getX()      - left)   * delta;
						top    += (destination.getY()      - top)    * delta;
						right  += (destination.getRight()  - right)  * delta;
						bottom += (destination.getBottom() - bottom) * delta;

						const Rectangle<int> newBounds (roundToInt (left),
														roundToInt (top),
														roundToInt (right - left),
														roundToInt (bottom - top));

						if (newBounds != destination)
						{
							c->setBounds (newBounds);
							stillBusy = true;
						}
					}

					if (isChangingAlpha)
					{
						alpha += (destAlpha - alpha) * delta;
						c->setAlpha ((float) alpha);
						stillBusy = true;
					}

					if (stillBusy)
						return true;
				}
			}
		}

		moveToFinalDestination();
		return false;
	}

	void moveToFinalDestination()
	{
		if (component != nullptr)
		{
			component->setAlpha ((float) destAlpha);
			component->setBounds (destination);

			if (proxy != nullptr)
				component->setVisible (destAlpha > 0);
		}
	}

	class ProxyComponent  : public Component
	{
	public:
		ProxyComponent (Component& component)
			: image (component.createComponentSnapshot (component.getLocalBounds()))
		{
			setBounds (component.getBounds());
			setTransform (component.getTransform());
			setAlpha (component.getAlpha());
			setInterceptsMouseClicks (false, false);

			Component* const parent = component.getParentComponent();

			if (parent != nullptr)
				parent->addAndMakeVisible (this);
			else if (component.isOnDesktop() && component.getPeer() != nullptr)
				addToDesktop (component.getPeer()->getStyleFlags() | ComponentPeer::windowIgnoresKeyPresses);
			else
				jassertfalse; // seem to be trying to animate a component that's not visible..

			setVisible (true);
			toBehind (&component);
		}

		void paint (Graphics& g)
		{
			g.setOpacity (1.0f);
			g.drawImage (image, 0, 0, getWidth(), getHeight(),
						 0, 0, image.getWidth(), image.getHeight());
		}

	private:
		Image image;

		JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ProxyComponent);
	};

	WeakReference<Component> component;
	ScopedPointer<Component> proxy;

	Rectangle<int> destination;
	double destAlpha;

	int msElapsed, msTotal;
	double startSpeed, midSpeed, endSpeed, lastProgress;
	double left, top, right, bottom, alpha;
	bool isMoving, isChangingAlpha;

private:
	double timeToDistance (const double time) const noexcept
	{
		return (time < 0.5) ? time * (startSpeed + time * (midSpeed - startSpeed))
							: 0.5 * (startSpeed + 0.5 * (midSpeed - startSpeed))
								+ (time - 0.5) * (midSpeed + (time - 0.5) * (endSpeed - midSpeed));
	}
};

ComponentAnimator::ComponentAnimator()
	: lastTime (0)
{
}

ComponentAnimator::~ComponentAnimator()
{
}

ComponentAnimator::AnimationTask* ComponentAnimator::findTaskFor (Component* const component) const noexcept
{
	for (int i = tasks.size(); --i >= 0;)
		if (component == tasks.getUnchecked(i)->component.get())
			return tasks.getUnchecked(i);

	return nullptr;
}

void ComponentAnimator::animateComponent (Component* const component,
										  const Rectangle<int>& finalBounds,
										  const float finalAlpha,
										  const int millisecondsToSpendMoving,
										  const bool useProxyComponent,
										  const double startSpeed,
										  const double endSpeed)
{
	// the speeds must be 0 or greater!
	jassert (startSpeed >= 0 && endSpeed >= 0)

	if (component != nullptr)
	{
		AnimationTask* at = findTaskFor (component);

		if (at == nullptr)
		{
			at = new AnimationTask (component);
			tasks.add (at);
			sendChangeMessage();
		}

		at->reset (finalBounds, finalAlpha, millisecondsToSpendMoving,
				   useProxyComponent, startSpeed, endSpeed);

		if (! isTimerRunning())
		{
			lastTime = Time::getMillisecondCounter();
			startTimer (1000 / 50);
		}
	}
}

void ComponentAnimator::fadeOut (Component* component, int millisecondsToTake)
{
	if (component != nullptr)
	{
		if (component->isShowing() && millisecondsToTake > 0)
			animateComponent (component, component->getBounds(), 0.0f, millisecondsToTake, true, 1.0, 1.0);

		component->setVisible (false);
	}
}

void ComponentAnimator::fadeIn (Component* component, int millisecondsToTake)
{
	if (component != nullptr && ! (component->isVisible() && component->getAlpha() == 1.0f))
	{
		component->setAlpha (0.0f);
		component->setVisible (true);
		animateComponent (component, component->getBounds(), 1.0f, millisecondsToTake, false, 1.0, 1.0);
	}
}

void ComponentAnimator::cancelAllAnimations (const bool moveComponentsToTheirFinalPositions)
{
	if (tasks.size() > 0)
	{
		if (moveComponentsToTheirFinalPositions)
			for (int i = tasks.size(); --i >= 0;)
				tasks.getUnchecked(i)->moveToFinalDestination();

		tasks.clear();
		sendChangeMessage();
	}
}

void ComponentAnimator::cancelAnimation (Component* const component,
										 const bool moveComponentToItsFinalPosition)
{
	AnimationTask* const at = findTaskFor (component);

	if (at != nullptr)
	{
		if (moveComponentToItsFinalPosition)
			at->moveToFinalDestination();

		tasks.removeObject (at);
		sendChangeMessage();
	}
}

Rectangle<int> ComponentAnimator::getComponentDestination (Component* const component)
{
	jassert (component != nullptr);
	AnimationTask* const at = findTaskFor (component);

	if (at != nullptr)
		return at->destination;

	return component->getBounds();
}

bool ComponentAnimator::isAnimating (Component* component) const noexcept
{
	return findTaskFor (component) != nullptr;
}

bool ComponentAnimator::isAnimating() const noexcept
{
	return tasks.size() != 0;
}

void ComponentAnimator::timerCallback()
{
	const uint32 timeNow = Time::getMillisecondCounter();

	if (lastTime == 0 || lastTime == timeNow)
		lastTime = timeNow;

	const int elapsed = (int) (timeNow - lastTime);

	for (int i = tasks.size(); --i >= 0;)
	{
		if (! tasks.getUnchecked(i)->useTimeslice (elapsed))
		{
			tasks.remove (i);
			sendChangeMessage();
		}
	}

	lastTime = timeNow;

	if (tasks.size() == 0)
		stopTimer();
}

/*** End of inlined file: juce_ComponentAnimator.cpp ***/


/*** Start of inlined file: juce_ComponentBoundsConstrainer.cpp ***/
ComponentBoundsConstrainer::ComponentBoundsConstrainer() noexcept
	: minW (0),
	  maxW (0x3fffffff),
	  minH (0),
	  maxH (0x3fffffff),
	  minOffTop (0),
	  minOffLeft (0),
	  minOffBottom (0),
	  minOffRight (0),
	  aspectRatio (0.0)
{
}

ComponentBoundsConstrainer::~ComponentBoundsConstrainer()
{
}

void ComponentBoundsConstrainer::setMinimumWidth (const int minimumWidth) noexcept
{
	minW = minimumWidth;
}

void ComponentBoundsConstrainer::setMaximumWidth (const int maximumWidth) noexcept
{
	maxW = maximumWidth;
}

void ComponentBoundsConstrainer::setMinimumHeight (const int minimumHeight) noexcept
{
	minH = minimumHeight;
}

void ComponentBoundsConstrainer::setMaximumHeight (const int maximumHeight) noexcept
{
	maxH = maximumHeight;
}

void ComponentBoundsConstrainer::setMinimumSize (const int minimumWidth, const int minimumHeight) noexcept
{
	jassert (maxW >= minimumWidth);
	jassert (maxH >= minimumHeight);
	jassert (minimumWidth > 0 && minimumHeight > 0);

	minW = minimumWidth;
	minH = minimumHeight;

	if (minW > maxW)
		maxW = minW;

	if (minH > maxH)
		maxH = minH;
}

void ComponentBoundsConstrainer::setMaximumSize (const int maximumWidth, const int maximumHeight) noexcept
{
	jassert (maximumWidth >= minW);
	jassert (maximumHeight >= minH);
	jassert (maximumWidth > 0 && maximumHeight > 0);

	maxW = jmax (minW, maximumWidth);
	maxH = jmax (minH, maximumHeight);
}

void ComponentBoundsConstrainer::setSizeLimits (const int minimumWidth,
												const int minimumHeight,
												const int maximumWidth,
												const int maximumHeight) noexcept
{
	jassert (maximumWidth >= minimumWidth);
	jassert (maximumHeight >= minimumHeight);
	jassert (maximumWidth > 0 && maximumHeight > 0);
	jassert (minimumWidth > 0 && minimumHeight > 0);

	minW = jmax (0, minimumWidth);
	minH = jmax (0, minimumHeight);
	maxW = jmax (minW, maximumWidth);
	maxH = jmax (minH, maximumHeight);
}

void ComponentBoundsConstrainer::setMinimumOnscreenAmounts (const int minimumWhenOffTheTop,
															const int minimumWhenOffTheLeft,
															const int minimumWhenOffTheBottom,
															const int minimumWhenOffTheRight) noexcept
{
	minOffTop = minimumWhenOffTheTop;
	minOffLeft = minimumWhenOffTheLeft;
	minOffBottom = minimumWhenOffTheBottom;
	minOffRight = minimumWhenOffTheRight;
}

void ComponentBoundsConstrainer::setFixedAspectRatio (const double widthOverHeight) noexcept
{
	aspectRatio = jmax (0.0, widthOverHeight);
}

double ComponentBoundsConstrainer::getFixedAspectRatio() const noexcept
{
	return aspectRatio;
}

void ComponentBoundsConstrainer::setBoundsForComponent (Component* const component,
														const Rectangle<int>& targetBounds,
														const bool isStretchingTop,
														const bool isStretchingLeft,
														const bool isStretchingBottom,
														const bool isStretchingRight)
{
	jassert (component != nullptr);

	Rectangle<int> limits, bounds (targetBounds);
	BorderSize<int> border;

	Component* const parent = component->getParentComponent();

	if (parent == nullptr)
	{
		ComponentPeer* peer = component->getPeer();
		if (peer != nullptr)
			border = peer->getFrameSize();

		limits = Desktop::getInstance().getMonitorAreaContaining (bounds.getCentre());
	}
	else
	{
		limits.setSize (parent->getWidth(), parent->getHeight());
	}

	border.addTo (bounds);

	checkBounds (bounds,
				 border.addedTo (component->getBounds()), limits,
				 isStretchingTop, isStretchingLeft,
				 isStretchingBottom, isStretchingRight);

	border.subtractFrom (bounds);

	applyBoundsToComponent (component, bounds);
}

void ComponentBoundsConstrainer::checkComponentBounds (Component* component)
{
	setBoundsForComponent (component, component->getBounds(),
						   false, false, false, false);
}

void ComponentBoundsConstrainer::applyBoundsToComponent (Component* component,
														 const Rectangle<int>& bounds)
{
	Component::Positioner* const positioner = component->getPositioner();

	if (positioner != nullptr)
		positioner->applyNewBounds (bounds);
	else
		component->setBounds (bounds);
}

void ComponentBoundsConstrainer::resizeStart()
{
}

void ComponentBoundsConstrainer::resizeEnd()
{
}

void ComponentBoundsConstrainer::checkBounds (Rectangle<int>& bounds,
											  const Rectangle<int>& old,
											  const Rectangle<int>& limits,
											  const bool isStretchingTop,
											  const bool isStretchingLeft,
											  const bool isStretchingBottom,
											  const bool isStretchingRight)
{
	if (isStretchingLeft)
		bounds.setLeft (jlimit (old.getRight() - maxW, old.getRight() - minW, bounds.getX()));
	else
		bounds.setWidth (jlimit (minW, maxW, bounds.getWidth()));

	if (isStretchingTop)
		bounds.setTop (jlimit (old.getBottom() - maxH, old.getBottom() - minH, bounds.getY()));
	else
		bounds.setHeight (jlimit (minH, maxH, bounds.getHeight()));

	if (bounds.isEmpty())
		return;

	if (minOffTop > 0)
	{
		const int limit = limits.getY() + jmin (minOffTop - bounds.getHeight(), 0);

		if (bounds.getY() < limit)
		{
			if (isStretchingTop)
				bounds.setTop (limits.getY());
			else
				bounds.setY (limit);
		}
	}

	if (minOffLeft > 0)
	{
		const int limit = limits.getX() + jmin (minOffLeft - bounds.getWidth(), 0);

		if (bounds.getX() < limit)
		{
			if (isStretchingLeft)
				bounds.setLeft (limits.getX());
			else
				bounds.setX (limit);
		}
	}

	if (minOffBottom > 0)
	{
		const int limit = limits.getBottom() - jmin (minOffBottom, bounds.getHeight());

		if (bounds.getY() > limit)
		{
			if (isStretchingBottom)
				bounds.setBottom (limits.getBottom());
			else
				bounds.setY (limit);
		}
	}

	if (minOffRight > 0)
	{
		const int limit = limits.getRight() - jmin (minOffRight, bounds.getWidth());

		if (bounds.getX() > limit)
		{
			if (isStretchingRight)
				bounds.setRight (limits.getRight());
			else
				bounds.setX (limit);
		}
	}

	// constrain the aspect ratio if one has been specified..
	if (aspectRatio > 0.0)
	{
		bool adjustWidth;

		if ((isStretchingTop || isStretchingBottom) && ! (isStretchingLeft || isStretchingRight))
		{
			adjustWidth = true;
		}
		else if ((isStretchingLeft || isStretchingRight) && ! (isStretchingTop || isStretchingBottom))
		{
			adjustWidth = false;
		}
		else
		{
			const double oldRatio = (old.getHeight() > 0) ? std::abs (old.getWidth() / (double) old.getHeight()) : 0.0;
			const double newRatio = std::abs (bounds.getWidth() / (double) bounds.getHeight());

			adjustWidth = (oldRatio > newRatio);
		}

		if (adjustWidth)
		{
			bounds.setWidth (roundToInt (bounds.getHeight() * aspectRatio));

			if (bounds.getWidth() > maxW || bounds.getWidth() < minW)
			{
				bounds.setWidth (jlimit (minW, maxW, bounds.getWidth()));
				bounds.setHeight (roundToInt (bounds.getWidth() / aspectRatio));
			}
		}
		else
		{
			bounds.setHeight (roundToInt (bounds.getWidth() / aspectRatio));

			if (bounds.getHeight() > maxH || bounds.getHeight() < minH)
			{
				bounds.setHeight (jlimit (minH, maxH, bounds.getHeight()));
				bounds.setWidth (roundToInt (bounds.getHeight() * aspectRatio));
			}
		}

		if ((isStretchingTop || isStretchingBottom) && ! (isStretchingLeft || isStretchingRight))
		{
			bounds.setX (old.getX() + (old.getWidth() - bounds.getWidth()) / 2);
		}
		else if ((isStretchingLeft || isStretchingRight) && ! (isStretchingTop || isStretchingBottom))
		{
			bounds.setY (old.getY() + (old.getHeight() - bounds.getHeight()) / 2);
		}
		else
		{
			if (isStretchingLeft)
				bounds.setX (old.getRight() - bounds.getWidth());

			if (isStretchingTop)
				bounds.setY (old.getBottom() - bounds.getHeight());
		}
	}

	jassert (! bounds.isEmpty());
}

/*** End of inlined file: juce_ComponentBoundsConstrainer.cpp ***/


/*** Start of inlined file: juce_ComponentBuilder.cpp ***/
namespace ComponentBuilderHelpers
{
	String getStateId (const ValueTree& state)
	{
		return state [ComponentBuilder::idProperty].toString();
	}

	Component* removeComponentWithID (OwnedArray<Component>& components, const String& compId)
	{
		jassert (compId.isNotEmpty());

		for (int i = components.size(); --i >= 0;)
		{
			Component* const c = components.getUnchecked (i);

			if (c->getComponentID() == compId)
				return components.removeAndReturn (i);
		}

		return nullptr;
	}

	Component* findComponentWithID (Component& c, const String& compId)
	{
		jassert (compId.isNotEmpty());
		if (c.getComponentID() == compId)
			return &c;

		for (int i = c.getNumChildComponents(); --i >= 0;)
		{
			Component* const child = findComponentWithID (*c.getChildComponent (i), compId);

			if (child != nullptr)
				return child;
		}

		return nullptr;
	}

	Component* createNewComponent (ComponentBuilder::TypeHandler& type,
								   const ValueTree& state, Component* parent)
	{
		Component* const c = type.addNewComponentFromState (state, parent);
		jassert (c != nullptr && c->getParentComponent() == parent);
		c->setComponentID (getStateId (state));
		return c;
	}

	void updateComponent (ComponentBuilder& builder, const ValueTree& state)
	{
		Component* topLevelComp = builder.getManagedComponent();

		if (topLevelComp != nullptr)
		{
			ComponentBuilder::TypeHandler* const type = builder.getHandlerForState (state);
			const String uid (getStateId (state));

			if (type == nullptr || uid.isEmpty())
			{
				// ..handle the case where a child of the actual state node has changed.
				if (state.getParent().isValid())
					updateComponent (builder, state.getParent());
			}
			else
			{
				Component* const changedComp = findComponentWithID (*topLevelComp, uid);

				if (changedComp != nullptr)
					type->updateComponentFromState (changedComp, state);
			}
		}
	}

	void updateComponentColours (Component& component, const ValueTree& colourState)
	{
		NamedValueSet& properties = component.getProperties();

		for (int i = properties.size(); --i >= 0;)
		{
			const Identifier name (properties.getName (i));

			if (name.toString().startsWith ("jcclr_"))
			{
				const String colourName (name.toString().substring (6));

				if (colourState [colourName].isVoid())
					component.removeColour (colourName.getHexValue32());
			}
		}

		for (int i = 0; i < colourState.getNumProperties(); ++i)
		{
			const Identifier colourName (colourState.getPropertyName (i));
			const String colour (colourState [colourName].toString());

			if (colour.isNotEmpty())
				component.setColour (colourName.toString().getHexValue32(), Colour::fromString (colour));
		}
	}

	template <class ComponentClass>
	class StandardTypeHandler  : public ComponentBuilder::TypeHandler
	{
	public:
		StandardTypeHandler()  : ComponentBuilder::TypeHandler (ComponentClass::Ids::tagType)
		{}

		Component* addNewComponentFromState (const ValueTree& state, Component* parent)
		{
			ComponentClass* const c = new ComponentClass();

			if (parent != nullptr)
				parent->addAndMakeVisible (c);

			updateComponentFromState (c, state);
			return c;
		}

		void updateComponentFromState (Component* component, const ValueTree& state)
		{
			ComponentClass* const c = dynamic_cast <ComponentClass*> (component);
			jassert (c != nullptr);

			c->setComponentID (state [ComponentBuilder::idProperty]);
			c->refreshFromValueTree (state, *this->getBuilder());
		}
	};
}

const Identifier ComponentBuilder::idProperty ("id");
const Identifier ComponentBuilder::positionID ("position");

ComponentBuilder::ComponentBuilder()
	: imageProvider (nullptr)
{
}

ComponentBuilder::ComponentBuilder (const ValueTree& state_)
	: state (state_), imageProvider (nullptr)
{
	state.addListener (this);
}

ComponentBuilder::~ComponentBuilder()
{
	state.removeListener (this);

   #if JUCE_DEBUG
	// Don't delete the managed component!! The builder owns that component, and will delete
	// it automatically when it gets deleted.
	jassert (componentRef.get() == static_cast <Component*> (component));
   #endif
}

Component* ComponentBuilder::getManagedComponent()
{
	if (component == nullptr)
	{
		component = createComponent();

	   #if JUCE_DEBUG
		componentRef = component;
	   #endif
	}

	return component;
}

Component* ComponentBuilder::createComponent()
{
	jassert (types.size() > 0);  // You need to register all the necessary types before you can load a component!

	TypeHandler* const type = getHandlerForState (state);
	jassert (type != nullptr); // trying to create a component from an unknown type of ValueTree

	return type != nullptr ? ComponentBuilderHelpers::createNewComponent (*type, state, nullptr) : nullptr;
}

void ComponentBuilder::registerTypeHandler (ComponentBuilder::TypeHandler* const type)
{
	jassert (type != nullptr);

	// Don't try to move your types around! Once a type has been added to a builder, the
	// builder owns it, and you should leave it alone!
	jassert (type->builder == nullptr);

	types.add (type);
	type->builder = this;
}

ComponentBuilder::TypeHandler* ComponentBuilder::getHandlerForState (const ValueTree& s) const
{
	const Identifier targetType (s.getType());

	for (int i = 0; i < types.size(); ++i)
	{
		TypeHandler* const t = types.getUnchecked(i);

		if (t->type == targetType)
			return t;
	}

	return nullptr;
}

int ComponentBuilder::getNumHandlers() const noexcept
{
	return types.size();
}

ComponentBuilder::TypeHandler* ComponentBuilder::getHandler (const int index) const noexcept
{
	return types [index];
}

void ComponentBuilder::registerStandardComponentTypes()
{
	Drawable::registerDrawableTypeHandlers (*this);

	registerTypeHandler (new ComponentBuilderHelpers::StandardTypeHandler <ComboBox>());
	registerTypeHandler (new ComponentBuilderHelpers::StandardTypeHandler <Slider>());
	registerTypeHandler (new ComponentBuilderHelpers::StandardTypeHandler <Label>());
	registerTypeHandler (new ComponentBuilderHelpers::StandardTypeHandler <Slider>());
	registerTypeHandler (new ComponentBuilderHelpers::StandardTypeHandler <TextEditor>());
	registerTypeHandler (new ComponentBuilderHelpers::StandardTypeHandler <GroupComponent>());
	registerTypeHandler (new ComponentBuilderHelpers::StandardTypeHandler <TextButton>());
	registerTypeHandler (new ComponentBuilderHelpers::StandardTypeHandler <ToggleButton>());
	registerTypeHandler (new ComponentBuilderHelpers::StandardTypeHandler <ImageButton>());
	registerTypeHandler (new ComponentBuilderHelpers::StandardTypeHandler <ImageComponent>());
	registerTypeHandler (new ComponentBuilderHelpers::StandardTypeHandler <HyperlinkButton>());
}

void ComponentBuilder::setImageProvider (ImageProvider* newImageProvider) noexcept
{
	imageProvider = newImageProvider;
}

ComponentBuilder::ImageProvider* ComponentBuilder::getImageProvider() const noexcept
{
	return imageProvider;
}

void ComponentBuilder::valueTreePropertyChanged (ValueTree& tree, const Identifier&)
{
	ComponentBuilderHelpers::updateComponent (*this, tree);
}

void ComponentBuilder::valueTreeChildAdded (ValueTree& tree, ValueTree&)
{
	ComponentBuilderHelpers::updateComponent (*this, tree);
}

void ComponentBuilder::valueTreeChildRemoved (ValueTree& tree, ValueTree&)
{
	ComponentBuilderHelpers::updateComponent (*this, tree);
}

void ComponentBuilder::valueTreeChildOrderChanged (ValueTree& tree)
{
	ComponentBuilderHelpers::updateComponent (*this, tree);
}

void ComponentBuilder::valueTreeParentChanged (ValueTree& tree)
{
	ComponentBuilderHelpers::updateComponent (*this, tree);
}

ComponentBuilder::TypeHandler::TypeHandler (const Identifier& valueTreeType)
   : type (valueTreeType), builder (nullptr)
{
}

ComponentBuilder::TypeHandler::~TypeHandler()
{
}

ComponentBuilder* ComponentBuilder::TypeHandler::getBuilder() const noexcept
{
	// A type handler needs to be registered with a ComponentBuilder before using it!
	jassert (builder != nullptr);
	return builder;
}

void ComponentBuilder::updateChildComponents (Component& parent, const ValueTree& children)
{
	using namespace ComponentBuilderHelpers;

	const int numExistingChildComps = parent.getNumChildComponents();

	Array <Component*> componentsInOrder;
	componentsInOrder.ensureStorageAllocated (numExistingChildComps);

	{
		OwnedArray<Component> existingComponents;
		existingComponents.ensureStorageAllocated (numExistingChildComps);

		int i;
		for (i = 0; i < numExistingChildComps; ++i)
			existingComponents.add (parent.getChildComponent (i));

		const int newNumChildren = children.getNumChildren();
		for (i = 0; i < newNumChildren; ++i)
		{
			const ValueTree childState (children.getChild (i));
			Component* c = removeComponentWithID (existingComponents, getStateId (childState));

			if (c == nullptr)
			{
				TypeHandler* const type = getHandlerForState (childState);
				jassert (type != nullptr);

				if (type != nullptr)
					c = ComponentBuilderHelpers::createNewComponent (*type, childState, &parent);
			}

			if (c != nullptr)
				componentsInOrder.add (c);
		}

		// (remaining unused items in existingComponents get deleted here as it goes out of scope)
	}

	// Make sure the z-order is correct..
	if (componentsInOrder.size() > 0)
	{
		componentsInOrder.getLast()->toFront (false);

		for (int i = componentsInOrder.size() - 1; --i >= 0;)
			componentsInOrder.getUnchecked(i)->toBehind (componentsInOrder.getUnchecked (i + 1));
	}
}

static void updateMarkers (MarkerList* const list, const ValueTree& state)
{
	if (list != nullptr)
		MarkerList::ValueTreeWrapper (state).applyTo (*list);
}

void ComponentBuilder::initialiseRecursively (Component& comp, const ValueTree& state)
{
	refreshBasicComponentProperties (comp, state);

	updateMarkers (comp.getMarkers (true),  state.getChildWithName ("MARKERS_X"));
	updateMarkers (comp.getMarkers (false), state.getChildWithName ("MARKERS_Y"));

	const ValueTree childList (state.getChildWithName ("COMPONENTS"));

	if (childList.isValid())
	{
		updateChildComponents (comp, childList);

		for (int i = 0; i < childList.getNumChildren(); ++i)
		{
			const ValueTree childState (childList.getChild(i));
			Component* const c = ComponentBuilderHelpers::findComponentWithID (comp, ComponentBuilderHelpers::getStateId (childState));

			if (c != nullptr)
			{
				ComponentBuilder::TypeHandler* const type = getHandlerForState (childState);

				if (type != nullptr)
					type->updateComponentFromState (c, childState);
				else
					initialiseRecursively (*c, childState);
			}
		}
	}
}

void ComponentBuilder::initialiseFromValueTree (Component& comp,
												const ValueTree& state,
												ImageProvider* const imageProvider)
{
	ComponentBuilder builder;
	builder.setImageProvider (imageProvider);
	builder.registerStandardComponentTypes();
	builder.initialiseRecursively (comp, state);
}

RelativeRectangle ComponentBuilder::getComponentBounds (const ValueTree& state)
{
	try
	{
		return RelativeRectangle (state [positionID].toString());
	}
	catch (Expression::ParseError&)
	{}

	return RelativeRectangle();
}

void ComponentBuilder::refreshBasicComponentProperties (Component& comp, const ValueTree& state)
{
	static const Identifier focusOrderID ("focusOrder");
	static const Identifier tooltipID ("tooltip");
	static const Identifier nameID ("name");

	comp.setName (state [nameID].toString());

	if (state.hasProperty (positionID))
		getComponentBounds (state).applyToComponent (comp);

	comp.setExplicitFocusOrder (state [focusOrderID]);
	const var tip (state [tooltipID]);

	if (! tip.isVoid())
	{
		SettableTooltipClient* tooltipClient = dynamic_cast <SettableTooltipClient*> (&comp);
		if (tooltipClient != nullptr)
			tooltipClient->setTooltip (tip.toString());
	}

	ComponentBuilderHelpers::updateComponentColours (comp, state.getChildWithName ("COLOURS"));
}

/*** End of inlined file: juce_ComponentBuilder.cpp ***/


/*** Start of inlined file: juce_ComponentMovementWatcher.cpp ***/
ComponentMovementWatcher::ComponentMovementWatcher (Component* const component_)
	: component (component_),
	  lastPeerID (0),
	  reentrant (false),
	  wasShowing (component_->isShowing())
{
	jassert (component != nullptr); // can't use this with a null pointer..

	component->addComponentListener (this);

	registerWithParentComps();
}

ComponentMovementWatcher::~ComponentMovementWatcher()
{
	if (component != nullptr)
		component->removeComponentListener (this);

	unregister();
}

void ComponentMovementWatcher::componentParentHierarchyChanged (Component&)
{
	if (component != nullptr && ! reentrant)
	{
		const ScopedValueSetter<bool> setter (reentrant, true);

		ComponentPeer* const peer = component->getPeer();
		const uint32 peerID = peer != nullptr ? peer->getUniqueID() : 0;

		if (peerID != lastPeerID)
		{
			componentPeerChanged();

			if (component == nullptr)
				return;

			lastPeerID = peerID;
		}

		unregister();
		registerWithParentComps();

		componentMovedOrResized (*component, true, true);

		if (component != nullptr)
			componentVisibilityChanged (*component);
	}
}

void ComponentMovementWatcher::componentMovedOrResized (Component&, bool wasMoved, bool wasResized)
{
	if (component != nullptr)
	{
		if (wasMoved)
		{
			const Point<int> pos (component->getTopLevelComponent()->getLocalPoint (component, Point<int>()));

			wasMoved = lastBounds.getPosition() != pos;
			lastBounds.setPosition (pos);
		}

		wasResized = (lastBounds.getWidth() != component->getWidth() || lastBounds.getHeight() != component->getHeight());
		lastBounds.setSize (component->getWidth(), component->getHeight());

		if (wasMoved || wasResized)
			componentMovedOrResized (wasMoved, wasResized);
	}
}

void ComponentMovementWatcher::componentBeingDeleted (Component& comp)
{
	registeredParentComps.removeValue (&comp);

	if (component == &comp)
		unregister();
}

void ComponentMovementWatcher::componentVisibilityChanged (Component&)
{
	if (component != nullptr)
	{
		const bool isShowingNow = component->isShowing();

		if (wasShowing != isShowingNow)
		{
			wasShowing = isShowingNow;
			componentVisibilityChanged();
		}
	}
}

void ComponentMovementWatcher::registerWithParentComps()
{
	Component* p = component->getParentComponent();

	while (p != nullptr)
	{
		p->addComponentListener (this);
		registeredParentComps.add (p);
		p = p->getParentComponent();
	}
}

void ComponentMovementWatcher::unregister()
{
	for (int i = registeredParentComps.size(); --i >= 0;)
		registeredParentComps.getUnchecked(i)->removeComponentListener (this);

	registeredParentComps.clear();
}

/*** End of inlined file: juce_ComponentMovementWatcher.cpp ***/


/*** Start of inlined file: juce_GroupComponent.cpp ***/
GroupComponent::GroupComponent (const String& name,
								const String& labelText)
	: Component (name),
	  text (labelText),
	  justification (Justification::left)
{
	setInterceptsMouseClicks  (false, true);
}

GroupComponent::~GroupComponent()
{
}

void GroupComponent::setText (const String& newText)
{
	if (text != newText)
	{
		text = newText;
		repaint();
	}
}

String GroupComponent::getText() const
{
	return text;
}

void GroupComponent::setTextLabelPosition (const Justification& newJustification)
{
	if (justification != newJustification)
	{
		justification = newJustification;
		repaint();
	}
}

void GroupComponent::paint (Graphics& g)
{
	getLookAndFeel()
		.drawGroupComponentOutline (g, getWidth(), getHeight(),
									text, justification,
									*this);
}

void GroupComponent::enablementChanged()
{
	repaint();
}

void GroupComponent::colourChanged()
{
	repaint();
}

const Identifier GroupComponent::Ids::tagType ("GROUPCOMPONENT");
const Identifier GroupComponent::Ids::text ("text");
const Identifier GroupComponent::Ids::justification ("justification");

void GroupComponent::refreshFromValueTree (const ValueTree& state, ComponentBuilder&)
{
	ComponentBuilder::refreshBasicComponentProperties (*this, state);

	setText (state [Ids::text].toString());
	setTextLabelPosition (static_cast <int> (state [Ids::justification]));
}

/*** End of inlined file: juce_GroupComponent.cpp ***/


/*** Start of inlined file: juce_MultiDocumentPanel.cpp ***/
MultiDocumentPanelWindow::MultiDocumentPanelWindow (const Colour& backgroundColour)
	: DocumentWindow (String::empty, backgroundColour,
					  DocumentWindow::maximiseButton | DocumentWindow::closeButton, false)
{
}

MultiDocumentPanelWindow::~MultiDocumentPanelWindow()
{
}

void MultiDocumentPanelWindow::maximiseButtonPressed()
{
	MultiDocumentPanel* const owner = getOwner();

	jassert (owner != nullptr); // these windows are only designed to be used inside a MultiDocumentPanel!
	if (owner != nullptr)
		owner->setLayoutMode (MultiDocumentPanel::MaximisedWindowsWithTabs);
}

void MultiDocumentPanelWindow::closeButtonPressed()
{
	MultiDocumentPanel* const owner = getOwner();

	jassert (owner != nullptr); // these windows are only designed to be used inside a MultiDocumentPanel!
	if (owner != nullptr)
		owner->closeDocument (getContentComponent(), true);
}

void MultiDocumentPanelWindow::activeWindowStatusChanged()
{
	DocumentWindow::activeWindowStatusChanged();
	updateOrder();
}

void MultiDocumentPanelWindow::broughtToFront()
{
	DocumentWindow::broughtToFront();
	updateOrder();
}

void MultiDocumentPanelWindow::updateOrder()
{
	MultiDocumentPanel* const owner = getOwner();

	if (owner != nullptr)
		owner->updateOrder();
}

MultiDocumentPanel* MultiDocumentPanelWindow::getOwner() const noexcept
{
	// (unable to use the syntax findParentComponentOfClass <MultiDocumentPanel> () because of a VC6 compiler bug)
	return findParentComponentOfClass ((MultiDocumentPanel*) nullptr);
}

class MDITabbedComponentInternal   : public TabbedComponent
{
public:
	MDITabbedComponentInternal()
		: TabbedComponent (TabbedButtonBar::TabsAtTop)
	{
	}

	~MDITabbedComponentInternal()
	{
	}

	void currentTabChanged (int, const String&)
	{
		// (unable to use the syntax findParentComponentOfClass <MultiDocumentPanel> () because of a VC6 compiler bug)
		MultiDocumentPanel* const owner = findParentComponentOfClass ((MultiDocumentPanel*) nullptr);

		if (owner != nullptr)
			owner->updateOrder();
	}
};

MultiDocumentPanel::MultiDocumentPanel()
	: mode (MaximisedWindowsWithTabs),
	  backgroundColour (Colours::lightblue),
	  maximumNumDocuments (0),
	  numDocsBeforeTabsUsed (0)
{
	setOpaque (true);
}

MultiDocumentPanel::~MultiDocumentPanel()
{
	closeAllDocuments (false);
}

namespace MultiDocHelpers
{
	bool shouldDeleteComp (Component* const c)
	{
		return c->getProperties() ["mdiDocumentDelete_"];
	}
}

bool MultiDocumentPanel::closeAllDocuments (const bool checkItsOkToCloseFirst)
{
	while (components.size() > 0)
		if (! closeDocument (components.getLast(), checkItsOkToCloseFirst))
			return false;

	return true;
}

MultiDocumentPanelWindow* MultiDocumentPanel::createNewDocumentWindow()
{
	return new MultiDocumentPanelWindow (backgroundColour);
}

void MultiDocumentPanel::addWindow (Component* component)
{
	MultiDocumentPanelWindow* const dw = createNewDocumentWindow();

	dw->setResizable (true, false);
	dw->setContentNonOwned (component, true);
	dw->setName (component->getName());

	const var bkg (component->getProperties() ["mdiDocumentBkg_"]);
	dw->setBackgroundColour (bkg.isVoid() ? backgroundColour : Colour ((uint32) static_cast <int> (bkg)));

	int x = 4;
	Component* const topComp = getChildComponent (getNumChildComponents() - 1);

	if (topComp != nullptr && topComp->getX() == x && topComp->getY() == x)
		x += 16;

	dw->setTopLeftPosition (x, x);

	const var pos (component->getProperties() ["mdiDocumentPos_"]);
	if (pos.toString().isNotEmpty())
		dw->restoreWindowStateFromString (pos.toString());

	addAndMakeVisible (dw);
	dw->toFront (true);
}

bool MultiDocumentPanel::addDocument (Component* const component,
									  const Colour& docColour,
									  const bool deleteWhenRemoved)
{
	// If you try passing a full DocumentWindow or ResizableWindow in here, you'll end up
	// with a frame-within-a-frame! Just pass in the bare content component.
	jassert (dynamic_cast <ResizableWindow*> (component) == nullptr);

	if (component == nullptr || (maximumNumDocuments > 0 && components.size() >= maximumNumDocuments))
		return false;

	components.add (component);
	component->getProperties().set ("mdiDocumentDelete_", deleteWhenRemoved);
	component->getProperties().set ("mdiDocumentBkg_", (int) docColour.getARGB());
	component->addComponentListener (this);

	if (mode == FloatingWindows)
	{
		if (isFullscreenWhenOneDocument())
		{
			if (components.size() == 1)
			{
				addAndMakeVisible (component);
			}
			else
			{
				if (components.size() == 2)
					addWindow (components.getFirst());

				addWindow (component);
			}
		}
		else
		{
		   addWindow (component);
		}
	}
	else
	{
		if (tabComponent == nullptr && components.size() > numDocsBeforeTabsUsed)
		{
			addAndMakeVisible (tabComponent = new MDITabbedComponentInternal());

			Array <Component*> temp (components);

			for (int i = 0; i < temp.size(); ++i)
				tabComponent->addTab (temp[i]->getName(), docColour, temp[i], false);

			resized();
		}
		else
		{
			if (tabComponent != nullptr)
				tabComponent->addTab (component->getName(), docColour, component, false);
			else
				addAndMakeVisible (component);
		}

		setActiveDocument (component);
	}

	resized();
	activeDocumentChanged();
	return true;
}

bool MultiDocumentPanel::closeDocument (Component* component,
										const bool checkItsOkToCloseFirst)
{
	if (components.contains (component))
	{
		if (checkItsOkToCloseFirst && ! tryToCloseDocument (component))
			return false;

		component->removeComponentListener (this);

		const bool shouldDelete = MultiDocHelpers::shouldDeleteComp (component);
		component->getProperties().remove ("mdiDocumentDelete_");
		component->getProperties().remove ("mdiDocumentBkg_");

		if (mode == FloatingWindows)
		{
			for (int i = getNumChildComponents(); --i >= 0;)
			{
				MultiDocumentPanelWindow* const dw = dynamic_cast <MultiDocumentPanelWindow*> (getChildComponent (i));

				if (dw != nullptr && dw->getContentComponent() == component)
				{
					ScopedPointer<MultiDocumentPanelWindow> (dw)->clearContentComponent();
					break;
				}
			}

			if (shouldDelete)
				delete component;

			components.removeValue (component);

			if (isFullscreenWhenOneDocument() && components.size() == 1)
			{
				for (int i = getNumChildComponents(); --i >= 0;)
				{
					ScopedPointer<MultiDocumentPanelWindow> dw (dynamic_cast <MultiDocumentPanelWindow*> (getChildComponent (i)));

					if (dw != nullptr)
						dw->clearContentComponent();
				}

				addAndMakeVisible (components.getFirst());
			}
		}
		else
		{
			jassert (components.indexOf (component) >= 0);

			if (tabComponent != nullptr)
			{
				for (int i = tabComponent->getNumTabs(); --i >= 0;)
					if (tabComponent->getTabContentComponent (i) == component)
						tabComponent->removeTab (i);
			}
			else
			{
				removeChildComponent (component);
			}

			if (shouldDelete)
				delete component;

			if (tabComponent != nullptr && tabComponent->getNumTabs() <= numDocsBeforeTabsUsed)
				tabComponent = nullptr;

			components.removeValue (component);

			if (components.size() > 0 && tabComponent == nullptr)
				addAndMakeVisible (components.getFirst());
		}

		resized();
		activeDocumentChanged();
	}
	else
	{
		jassertfalse;
	}

	return true;
}

int MultiDocumentPanel::getNumDocuments() const noexcept
{
	return components.size();
}

Component* MultiDocumentPanel::getDocument (const int index) const noexcept
{
	return components [index];
}

Component* MultiDocumentPanel::getActiveDocument() const noexcept
{
	if (mode == FloatingWindows)
	{
		for (int i = getNumChildComponents(); --i >= 0;)
		{
			MultiDocumentPanelWindow* const dw = dynamic_cast <MultiDocumentPanelWindow*> (getChildComponent (i));

			if (dw != nullptr && dw->isActiveWindow())
				return dw->getContentComponent();
		}
	}

	return components.getLast();
}

void MultiDocumentPanel::setActiveDocument (Component* component)
{
	if (mode == FloatingWindows)
	{
		component = getContainerComp (component);

		if (component != nullptr)
			component->toFront (true);
	}
	else if (tabComponent != nullptr)
	{
		jassert (components.indexOf (component) >= 0);

		for (int i = tabComponent->getNumTabs(); --i >= 0;)
		{
			if (tabComponent->getTabContentComponent (i) == component)
			{
				tabComponent->setCurrentTabIndex (i);
				break;
			}
		}
	}
	else
	{
		component->grabKeyboardFocus();
	}
}

void MultiDocumentPanel::activeDocumentChanged()
{
}

void MultiDocumentPanel::setMaximumNumDocuments (const int newNumber)
{
	maximumNumDocuments = newNumber;
}

void MultiDocumentPanel::useFullscreenWhenOneDocument (const bool shouldUseTabs)
{
	numDocsBeforeTabsUsed = shouldUseTabs ? 1 : 0;
}

bool MultiDocumentPanel::isFullscreenWhenOneDocument() const noexcept
{
	return numDocsBeforeTabsUsed != 0;
}

void MultiDocumentPanel::setLayoutMode (const LayoutMode newLayoutMode)
{
	if (mode != newLayoutMode)
	{
		mode = newLayoutMode;

		if (mode == FloatingWindows)
		{
			tabComponent = nullptr;
		}
		else
		{
			for (int i = getNumChildComponents(); --i >= 0;)
			{
				MultiDocumentPanelWindow* const dw = dynamic_cast <MultiDocumentPanelWindow*> (getChildComponent (i));

				if (dw != nullptr)
				{
					dw->getContentComponent()->getProperties().set ("mdiDocumentPos_", dw->getWindowStateAsString());
					dw->clearContentComponent();
					delete dw;
				}
			}
		}

		resized();

		const Array <Component*> tempComps (components);
		components.clear();

		for (int i = 0; i < tempComps.size(); ++i)
		{
			Component* const c = tempComps.getUnchecked(i);

			addDocument (c,
						 Colour ((uint32) static_cast <int> (c->getProperties().getWithDefault ("mdiDocumentBkg_", (int) Colours::white.getARGB()))),
						 MultiDocHelpers::shouldDeleteComp (c));
		}
	}
}

void MultiDocumentPanel::setBackgroundColour (const Colour& newBackgroundColour)
{
	if (backgroundColour != newBackgroundColour)
	{
		backgroundColour = newBackgroundColour;
		setOpaque (newBackgroundColour.isOpaque());
		repaint();
	}
}

void MultiDocumentPanel::paint (Graphics& g)
{
	g.fillAll (backgroundColour);
}

void MultiDocumentPanel::resized()
{
	if (mode == MaximisedWindowsWithTabs || components.size() == numDocsBeforeTabsUsed)
	{
		for (int i = getNumChildComponents(); --i >= 0;)
			getChildComponent (i)->setBounds (getLocalBounds());
	}

	setWantsKeyboardFocus (components.size() == 0);
}

Component* MultiDocumentPanel::getContainerComp (Component* c) const
{
	if (mode == FloatingWindows)
	{
		for (int i = 0; i < getNumChildComponents(); ++i)
		{
			MultiDocumentPanelWindow* const dw = dynamic_cast <MultiDocumentPanelWindow*> (getChildComponent (i));

			if (dw != nullptr && dw->getContentComponent() == c)
			{
				c = dw;
				break;
			}
		}
	}

	return c;
}

void MultiDocumentPanel::componentNameChanged (Component&)
{
	if (mode == FloatingWindows)
	{
		for (int i = 0; i < getNumChildComponents(); ++i)
		{
			MultiDocumentPanelWindow* const dw = dynamic_cast <MultiDocumentPanelWindow*> (getChildComponent (i));

			if (dw != nullptr)
				dw->setName (dw->getContentComponent()->getName());
		}
	}
	else if (tabComponent != nullptr)
	{
		for (int i = tabComponent->getNumTabs(); --i >= 0;)
			tabComponent->setTabName (i, tabComponent->getTabContentComponent (i)->getName());
	}
}

void MultiDocumentPanel::updateOrder()
{
	const Array <Component*> oldList (components);

	if (mode == FloatingWindows)
	{
		components.clear();

		for (int i = 0; i < getNumChildComponents(); ++i)
		{
			MultiDocumentPanelWindow* const dw = dynamic_cast <MultiDocumentPanelWindow*> (getChildComponent (i));

			if (dw != nullptr)
				components.add (dw->getContentComponent());
		}
	}
	else
	{
		if (tabComponent != nullptr)
		{
			Component* const current = tabComponent->getCurrentContentComponent();

			if (current != nullptr)
			{
				components.removeValue (current);
				components.add (current);
			}
		}
	}

	if (components != oldList)
		activeDocumentChanged();
}

/*** End of inlined file: juce_MultiDocumentPanel.cpp ***/


/*** Start of inlined file: juce_ResizableBorderComponent.cpp ***/
ResizableBorderComponent::Zone::Zone (const int zoneFlags) noexcept
	: zone (zoneFlags)
{}

ResizableBorderComponent::Zone::Zone (const ResizableBorderComponent::Zone& other) noexcept
	: zone (other.zone)
{}

ResizableBorderComponent::Zone& ResizableBorderComponent::Zone::operator= (const ResizableBorderComponent::Zone& other) noexcept
{
	zone = other.zone;
	return *this;
}

bool ResizableBorderComponent::Zone::operator== (const ResizableBorderComponent::Zone& other) const noexcept      { return zone == other.zone; }
bool ResizableBorderComponent::Zone::operator!= (const ResizableBorderComponent::Zone& other) const noexcept      { return zone != other.zone; }

const ResizableBorderComponent::Zone ResizableBorderComponent::Zone::fromPositionOnBorder (const Rectangle<int>& totalSize,
																						   const BorderSize<int>& border,
																						   const Point<int>& position)
{
	int z = 0;

	if (totalSize.contains (position)
		 && ! border.subtractedFrom (totalSize).contains (position))
	{
		const int minW = jmax (totalSize.getWidth() / 10, jmin (10, totalSize.getWidth() / 3));
		if (position.x < jmax (border.getLeft(), minW) && border.getLeft() > 0)
			z |= left;
		else if (position.x >= totalSize.getWidth() - jmax (border.getRight(), minW) && border.getRight() > 0)
			z |= right;

		const int minH = jmax (totalSize.getHeight() / 10, jmin (10, totalSize.getHeight() / 3));
		if (position.y < jmax (border.getTop(), minH) && border.getTop() > 0)
			z |= top;
		else if (position.y >= totalSize.getHeight() - jmax (border.getBottom(), minH) && border.getBottom() > 0)
			z |= bottom;
	}

	return Zone (z);
}

MouseCursor ResizableBorderComponent::Zone::getMouseCursor() const noexcept
{
	MouseCursor::StandardCursorType mc = MouseCursor::NormalCursor;

	switch (zone)
	{
		case (left | top):      mc = MouseCursor::TopLeftCornerResizeCursor; break;
		case top:               mc = MouseCursor::TopEdgeResizeCursor; break;
		case (right | top):     mc = MouseCursor::TopRightCornerResizeCursor; break;
		case left:              mc = MouseCursor::LeftEdgeResizeCursor; break;
		case right:             mc = MouseCursor::RightEdgeResizeCursor; break;
		case (left | bottom):   mc = MouseCursor::BottomLeftCornerResizeCursor; break;
		case bottom:            mc = MouseCursor::BottomEdgeResizeCursor; break;
		case (right | bottom):  mc = MouseCursor::BottomRightCornerResizeCursor; break;
		default:                break;
	}

	return mc;
}

ResizableBorderComponent::ResizableBorderComponent (Component* const componentToResize,
													ComponentBoundsConstrainer* const constrainer_)
   : component (componentToResize),
	 constrainer (constrainer_),
	 borderSize (5),
	 mouseZone (0)
{
}

ResizableBorderComponent::~ResizableBorderComponent()
{
}

void ResizableBorderComponent::paint (Graphics& g)
{
	getLookAndFeel().drawResizableFrame (g, getWidth(), getHeight(), borderSize);
}

void ResizableBorderComponent::mouseEnter (const MouseEvent& e)
{
	updateMouseZone (e);
}

void ResizableBorderComponent::mouseMove (const MouseEvent& e)
{
	updateMouseZone (e);
}

void ResizableBorderComponent::mouseDown (const MouseEvent& e)
{
	if (component == nullptr)
	{
		jassertfalse; // You've deleted the component that this resizer was supposed to be using!
		return;
	}

	updateMouseZone (e);

	originalBounds = component->getBounds();

	if (constrainer != nullptr)
		constrainer->resizeStart();
}

void ResizableBorderComponent::mouseDrag (const MouseEvent& e)
{
	if (component == nullptr)
	{
		jassertfalse; // You've deleted the component that this resizer was supposed to be using!
		return;
	}

	const Rectangle<int> newBounds (mouseZone.resizeRectangleBy (originalBounds, e.getOffsetFromDragStart()));

	if (constrainer != nullptr)
	{
		constrainer->setBoundsForComponent (component, newBounds,
											mouseZone.isDraggingTopEdge(),
											mouseZone.isDraggingLeftEdge(),
											mouseZone.isDraggingBottomEdge(),
											mouseZone.isDraggingRightEdge());
	}
	else
	{
		Component::Positioner* const pos = component->getPositioner();

		if (pos != nullptr)
			pos->applyNewBounds (newBounds);
		else
			component->setBounds (newBounds);
	}
}

void ResizableBorderComponent::mouseUp (const MouseEvent&)
{
	if (constrainer != nullptr)
		constrainer->resizeEnd();
}

bool ResizableBorderComponent::hitTest (int x, int y)
{
	return x < borderSize.getLeft()
			|| x >= getWidth() - borderSize.getRight()
			|| y < borderSize.getTop()
			|| y >= getHeight() - borderSize.getBottom();
}

void ResizableBorderComponent::setBorderThickness (const BorderSize<int>& newBorderSize)
{
	if (borderSize != newBorderSize)
	{
		borderSize = newBorderSize;
		repaint();
	}
}

BorderSize<int> ResizableBorderComponent::getBorderThickness() const
{
	return borderSize;
}

void ResizableBorderComponent::updateMouseZone (const MouseEvent& e)
{
	Zone newZone (Zone::fromPositionOnBorder (getLocalBounds(), borderSize, e.getPosition()));

	if (mouseZone != newZone)
	{
		mouseZone = newZone;
		setMouseCursor (newZone.getMouseCursor());
	}
}

/*** End of inlined file: juce_ResizableBorderComponent.cpp ***/


/*** Start of inlined file: juce_ResizableCornerComponent.cpp ***/
ResizableCornerComponent::ResizableCornerComponent (Component* const componentToResize,
													ComponentBoundsConstrainer* const constrainer_)
   : component (componentToResize),
	 constrainer (constrainer_)
{
	setRepaintsOnMouseActivity (true);
	setMouseCursor (MouseCursor::BottomRightCornerResizeCursor);
}

ResizableCornerComponent::~ResizableCornerComponent()
{
}

void ResizableCornerComponent::paint (Graphics& g)
{
	getLookAndFeel()
		.drawCornerResizer (g, getWidth(), getHeight(),
							isMouseOverOrDragging(),
							isMouseButtonDown());
}

void ResizableCornerComponent::mouseDown (const MouseEvent&)
{
	if (component == nullptr)
	{
		jassertfalse; // You've deleted the component that this resizer is supposed to be controlling!
		return;
	}

	originalBounds = component->getBounds();

	if (constrainer != nullptr)
		constrainer->resizeStart();
}

void ResizableCornerComponent::mouseDrag (const MouseEvent& e)
{
	if (component == nullptr)
	{
		jassertfalse; // You've deleted the component that this resizer is supposed to be controlling!
		return;
	}

	Rectangle<int> r (originalBounds.withSize (originalBounds.getWidth() + e.getDistanceFromDragStartX(),
											   originalBounds.getHeight() + e.getDistanceFromDragStartY()));

	if (constrainer != nullptr)
	{
		constrainer->setBoundsForComponent (component, r, false, false, true, true);
	}
	else
	{
		Component::Positioner* const pos = component->getPositioner();

		if (pos != nullptr)
			pos->applyNewBounds (r);
		else
			component->setBounds (r);
	}
}

void ResizableCornerComponent::mouseUp (const MouseEvent&)
{
	if (constrainer != nullptr)
		constrainer->resizeEnd();
}

bool ResizableCornerComponent::hitTest (int x, int y)
{
	if (getWidth() <= 0)
		return false;

	const int yAtX = getHeight() - (getHeight() * x / getWidth());

	return y >= yAtX - getHeight() / 4;
}

/*** End of inlined file: juce_ResizableCornerComponent.cpp ***/


/*** Start of inlined file: juce_ResizableEdgeComponent.cpp ***/
ResizableEdgeComponent::ResizableEdgeComponent (Component* const componentToResize,
												ComponentBoundsConstrainer* const constrainer_,
												Edge edge_)
   : component (componentToResize),
	 constrainer (constrainer_),
	 edge (edge_)
{
	setRepaintsOnMouseActivity (true);
	setMouseCursor (MouseCursor (isVertical() ? MouseCursor::LeftRightResizeCursor
											  : MouseCursor::UpDownResizeCursor));
}

ResizableEdgeComponent::~ResizableEdgeComponent()
{
}

bool ResizableEdgeComponent::isVertical() const noexcept
{
	return edge == leftEdge || edge == rightEdge;
}

void ResizableEdgeComponent::paint (Graphics& g)
{
	getLookAndFeel().drawStretchableLayoutResizerBar (g, getWidth(), getHeight(), isVertical(),
													  isMouseOver(), isMouseButtonDown());
}

void ResizableEdgeComponent::mouseDown (const MouseEvent&)
{
	if (component == nullptr)
	{
		jassertfalse; // You've deleted the component that this resizer was supposed to be using!
		return;
	}

	originalBounds = component->getBounds();

	if (constrainer != nullptr)
		constrainer->resizeStart();
}

void ResizableEdgeComponent::mouseDrag (const MouseEvent& e)
{
	if (component == nullptr)
	{
		jassertfalse; // You've deleted the component that this resizer was supposed to be using!
		return;
	}

	Rectangle<int> newBounds (originalBounds);

	switch (edge)
	{
		case leftEdge:      newBounds.setLeft (jmin (newBounds.getRight(), newBounds.getX() + e.getDistanceFromDragStartX())); break;
		case rightEdge:     newBounds.setWidth (jmax (0, newBounds.getWidth() + e.getDistanceFromDragStartX())); break;
		case topEdge:       newBounds.setTop (jmin (newBounds.getBottom(), newBounds.getY() + e.getDistanceFromDragStartY())); break;
		case bottomEdge:    newBounds.setHeight (jmax (0, newBounds.getHeight() + e.getDistanceFromDragStartY())); break;
		default:            jassertfalse; break;
	}

	if (constrainer != nullptr)
	{
		constrainer->setBoundsForComponent (component, newBounds,
											edge == topEdge,
											edge == leftEdge,
											edge == bottomEdge,
											edge == rightEdge);
	}
	else
	{
		Component::Positioner* const pos = component->getPositioner();

		if (pos != nullptr)
			pos->applyNewBounds (newBounds);
		else
			component->setBounds (newBounds);
	}
}

void ResizableEdgeComponent::mouseUp (const MouseEvent&)
{
	if (constrainer != nullptr)
		constrainer->resizeEnd();
}

/*** End of inlined file: juce_ResizableEdgeComponent.cpp ***/


/*** Start of inlined file: juce_ScrollBar.cpp ***/
class ScrollBar::ScrollbarButton  : public Button
{
public:
	ScrollbarButton (const int direction_, ScrollBar& owner_)
		: Button (String::empty),
		  direction (direction_),
		  owner (owner_)
	{
		setWantsKeyboardFocus (false);
	}

	void paintButton (Graphics& g, bool over, bool down)
	{
		getLookAndFeel()
			.drawScrollbarButton (g, owner,
								  getWidth(), getHeight(),
								  direction,
								  owner.isVertical(),
								  over, down);
	}

	void clicked()
	{
		owner.moveScrollbarInSteps ((direction == 1 || direction == 2) ? 1 : -1);
	}

	int direction;

private:
	ScrollBar& owner;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ScrollbarButton);
};

ScrollBar::ScrollBar (const bool vertical_,
					  const bool buttonsAreVisible)
	: totalRange (0.0, 1.0),
	  visibleRange (0.0, 0.1),
	  singleStepSize (0.1),
	  thumbAreaStart (0),
	  thumbAreaSize (0),
	  thumbStart (0),
	  thumbSize (0),
	  initialDelayInMillisecs (100),
	  repeatDelayInMillisecs (50),
	  minimumDelayInMillisecs (10),
	  vertical (vertical_),
	  isDraggingThumb (false),
	  autohides (true)
{
	setButtonVisibility (buttonsAreVisible);

	setRepaintsOnMouseActivity (true);
	setFocusContainer (true);
}

ScrollBar::~ScrollBar()
{
	upButton = nullptr;
	downButton = nullptr;
}

void ScrollBar::setRangeLimits (const Range<double>& newRangeLimit)
{
	if (totalRange != newRangeLimit)
	{
		totalRange = newRangeLimit;
		setCurrentRange (visibleRange);
		updateThumbPosition();
	}
}

void ScrollBar::setRangeLimits (const double newMinimum, const double newMaximum)
{
	jassert (newMaximum >= newMinimum); // these can't be the wrong way round!
	setRangeLimits (Range<double> (newMinimum, newMaximum));
}

void ScrollBar::setCurrentRange (const Range<double>& newRange)
{
	const Range<double> constrainedRange (totalRange.constrainRange (newRange));

	if (visibleRange != constrainedRange)
	{
		visibleRange = constrainedRange;

		updateThumbPosition();
		triggerAsyncUpdate();
	}
}

void ScrollBar::setCurrentRange (const double newStart, const double newSize)
{
	setCurrentRange (Range<double> (newStart, newStart + newSize));
}

void ScrollBar::setCurrentRangeStart (const double newStart)
{
	setCurrentRange (visibleRange.movedToStartAt (newStart));
}

void ScrollBar::setSingleStepSize (const double newSingleStepSize)
{
	singleStepSize = newSingleStepSize;
}

void ScrollBar::moveScrollbarInSteps (const int howManySteps)
{
	setCurrentRange (visibleRange + howManySteps * singleStepSize);
}

void ScrollBar::moveScrollbarInPages (const int howManyPages)
{
	setCurrentRange (visibleRange + howManyPages * visibleRange.getLength());
}

void ScrollBar::scrollToTop()
{
	setCurrentRange (visibleRange.movedToStartAt (getMinimumRangeLimit()));
}

void ScrollBar::scrollToBottom()
{
	setCurrentRange (visibleRange.movedToEndAt (getMaximumRangeLimit()));
}

void ScrollBar::setButtonRepeatSpeed (const int initialDelayInMillisecs_,
									  const int repeatDelayInMillisecs_,
									  const int minimumDelayInMillisecs_)
{
	initialDelayInMillisecs = initialDelayInMillisecs_;
	repeatDelayInMillisecs = repeatDelayInMillisecs_;
	minimumDelayInMillisecs = minimumDelayInMillisecs_;

	if (upButton != nullptr)
	{
		upButton->setRepeatSpeed (initialDelayInMillisecs,  repeatDelayInMillisecs,  minimumDelayInMillisecs);
		downButton->setRepeatSpeed (initialDelayInMillisecs,  repeatDelayInMillisecs,  minimumDelayInMillisecs);
	}
}

void ScrollBar::addListener (Listener* const listener)
{
	listeners.add (listener);
}

void ScrollBar::removeListener (Listener* const listener)
{
	listeners.remove (listener);
}

void ScrollBar::handleAsyncUpdate()
{
	double start = visibleRange.getStart(); // (need to use a temp variable for VC7 compatibility)
	listeners.call (&ScrollBar::Listener::scrollBarMoved, this, start);
}

void ScrollBar::updateThumbPosition()
{
	int newThumbSize = roundToInt (totalRange.getLength() > 0 ? (visibleRange.getLength() * thumbAreaSize) / totalRange.getLength()
															  : thumbAreaSize);

	if (newThumbSize < getLookAndFeel().getMinimumScrollbarThumbSize (*this))
		newThumbSize = jmin (getLookAndFeel().getMinimumScrollbarThumbSize (*this), thumbAreaSize - 1);

	if (newThumbSize > thumbAreaSize)
		newThumbSize = thumbAreaSize;

	int newThumbStart = thumbAreaStart;

	if (totalRange.getLength() > visibleRange.getLength())
		newThumbStart += roundToInt (((visibleRange.getStart() - totalRange.getStart()) * (thumbAreaSize - newThumbSize))
										 / (totalRange.getLength() - visibleRange.getLength()));

	setVisible ((! autohides) || (totalRange.getLength() > visibleRange.getLength() && visibleRange.getLength() > 0.0));

	if (thumbStart != newThumbStart  || thumbSize != newThumbSize)
	{
		const int repaintStart = jmin (thumbStart, newThumbStart) - 4;
		const int repaintSize = jmax (thumbStart + thumbSize, newThumbStart + newThumbSize) + 8 - repaintStart;

		if (vertical)
			repaint (0, repaintStart, getWidth(), repaintSize);
		else
			repaint (repaintStart, 0, repaintSize, getHeight());

		thumbStart = newThumbStart;
		thumbSize = newThumbSize;
	}
}

void ScrollBar::setOrientation (const bool shouldBeVertical)
{
	if (vertical != shouldBeVertical)
	{
		vertical = shouldBeVertical;

		if (upButton != nullptr)
		{
			upButton->direction    = vertical ? 0 : 3;
			downButton->direction  = vertical ? 2 : 1;
		}

		updateThumbPosition();
	}
}

void ScrollBar::setButtonVisibility (const bool buttonsAreVisible)
{
	upButton = nullptr;
	downButton = nullptr;

	if (buttonsAreVisible)
	{
		addAndMakeVisible (upButton   = new ScrollbarButton (vertical ? 0 : 3, *this));
		addAndMakeVisible (downButton = new ScrollbarButton (vertical ? 2 : 1, *this));

		setButtonRepeatSpeed (initialDelayInMillisecs, repeatDelayInMillisecs, minimumDelayInMillisecs);
	}

	updateThumbPosition();
}

void ScrollBar::setAutoHide (const bool shouldHideWhenFullRange)
{
	autohides = shouldHideWhenFullRange;
	updateThumbPosition();
}

bool ScrollBar::autoHides() const noexcept
{
	return autohides;
}

void ScrollBar::paint (Graphics& g)
{
	if (thumbAreaSize > 0)
	{
		LookAndFeel& lf = getLookAndFeel();

		const int thumb = (thumbAreaSize > lf.getMinimumScrollbarThumbSize (*this))
								? thumbSize : 0;

		if (vertical)
		{
			lf.drawScrollbar (g, *this,
							  0, thumbAreaStart,
							  getWidth(), thumbAreaSize,
							  vertical,
							  thumbStart, thumb,
							  isMouseOver(), isMouseButtonDown());
		}
		else
		{
			lf.drawScrollbar (g, *this,
							  thumbAreaStart, 0,
							  thumbAreaSize, getHeight(),
							  vertical,
							  thumbStart, thumb,
							  isMouseOver(), isMouseButtonDown());
		}
	}
}

void ScrollBar::lookAndFeelChanged()
{
	setComponentEffect (getLookAndFeel().getScrollbarEffect());
}

void ScrollBar::resized()
{
	const int length = vertical ? getHeight() : getWidth();

	const int buttonSize = upButton != nullptr ? jmin (getLookAndFeel().getScrollbarButtonSize (*this), length / 2)
											   : 0;

	if (length < 32 + getLookAndFeel().getMinimumScrollbarThumbSize (*this))
	{
		thumbAreaStart = length / 2;
		thumbAreaSize = 0;
	}
	else
	{
		thumbAreaStart = buttonSize;
		thumbAreaSize = length - (buttonSize << 1);
	}

	if (upButton != nullptr)
	{
		if (vertical)
		{
			upButton->setBounds (0, 0, getWidth(), buttonSize);
			downButton->setBounds (0, thumbAreaStart + thumbAreaSize, getWidth(), buttonSize);
		}
		else
		{
			upButton->setBounds (0, 0, buttonSize, getHeight());
			downButton->setBounds (thumbAreaStart + thumbAreaSize, 0, buttonSize, getHeight());
		}
	}

	updateThumbPosition();
}

void ScrollBar::mouseDown (const MouseEvent& e)
{
	isDraggingThumb = false;
	lastMousePos = vertical ? e.y : e.x;
	dragStartMousePos = lastMousePos;
	dragStartRange = visibleRange.getStart();

	if (dragStartMousePos < thumbStart)
	{
		moveScrollbarInPages (-1);
		startTimer (400);
	}
	else if (dragStartMousePos >= thumbStart + thumbSize)
	{
		moveScrollbarInPages (1);
		startTimer (400);
	}
	else
	{
		isDraggingThumb = (thumbAreaSize > getLookAndFeel().getMinimumScrollbarThumbSize (*this))
							&& (thumbAreaSize > thumbSize);
	}
}

void ScrollBar::mouseDrag (const MouseEvent& e)
{
	const int mousePos = vertical ? e.y : e.x;

	if (isDraggingThumb && lastMousePos != mousePos)
	{
		const int deltaPixels = mousePos - dragStartMousePos;

		setCurrentRangeStart (dragStartRange
								+ deltaPixels * (totalRange.getLength() - visibleRange.getLength())
									/ (thumbAreaSize - thumbSize));
	}

	lastMousePos = mousePos;
}

void ScrollBar::mouseUp (const MouseEvent&)
{
	isDraggingThumb = false;
	stopTimer();
	repaint();
}

void ScrollBar::mouseWheelMove (const MouseEvent&,
								float wheelIncrementX,
								float wheelIncrementY)
{
	float increment = 10.0f * (vertical ? wheelIncrementY : wheelIncrementX);

	if (increment < 0)
		increment = jmin (increment, -1.0f);
	else if (increment > 0)
		increment = jmax (increment, 1.0f);

	setCurrentRange (visibleRange - singleStepSize * increment);
}

void ScrollBar::timerCallback()
{
	if (isMouseButtonDown())
	{
		startTimer (40);

		if (lastMousePos < thumbStart)
			setCurrentRange (visibleRange - visibleRange.getLength());
		else if (lastMousePos > thumbStart + thumbSize)
			setCurrentRangeStart (visibleRange.getEnd());
	}
	else
	{
		stopTimer();
	}
}

bool ScrollBar::keyPressed (const KeyPress& key)
{
	if (! isVisible())
		return false;

	if (key.isKeyCode (KeyPress::upKey)
		 || key.isKeyCode (KeyPress::leftKey))          moveScrollbarInSteps (-1);
	else if (key.isKeyCode (KeyPress::downKey)
			  || key.isKeyCode (KeyPress::rightKey))    moveScrollbarInSteps (1);
	else if (key.isKeyCode (KeyPress::pageUpKey))       moveScrollbarInPages (-1);
	else if (key.isKeyCode (KeyPress::pageDownKey))     moveScrollbarInPages (1);
	else if (key.isKeyCode (KeyPress::homeKey))         scrollToTop();
	else if (key.isKeyCode (KeyPress::endKey))          scrollToBottom();
	else                                                return false;

	return true;
}

/*** End of inlined file: juce_ScrollBar.cpp ***/


/*** Start of inlined file: juce_StretchableLayoutManager.cpp ***/
StretchableLayoutManager::StretchableLayoutManager()
	: totalSize (0)
{
}

StretchableLayoutManager::~StretchableLayoutManager()
{
}

void StretchableLayoutManager::clearAllItems()
{
	items.clear();
	totalSize = 0;
}

void StretchableLayoutManager::setItemLayout (const int itemIndex,
											  const double minimumSize,
											  const double maximumSize,
											  const double preferredSize)
{
	ItemLayoutProperties* layout = getInfoFor (itemIndex);

	if (layout == nullptr)
	{
		layout = new ItemLayoutProperties();
		layout->itemIndex = itemIndex;

		int i;
		for (i = 0; i < items.size(); ++i)
			if (items.getUnchecked (i)->itemIndex > itemIndex)
				break;

		items.insert (i, layout);
	}

	layout->minSize = minimumSize;
	layout->maxSize = maximumSize;
	layout->preferredSize = preferredSize;
	layout->currentSize = 0;
}

bool StretchableLayoutManager::getItemLayout (const int itemIndex,
											  double& minimumSize,
											  double& maximumSize,
											  double& preferredSize) const
{
	const ItemLayoutProperties* const layout = getInfoFor (itemIndex);

	if (layout != nullptr)
	{
		minimumSize = layout->minSize;
		maximumSize = layout->maxSize;
		preferredSize = layout->preferredSize;
		return true;
	}

	return false;
}

void StretchableLayoutManager::setTotalSize (const int newTotalSize)
{
	totalSize = newTotalSize;

	fitComponentsIntoSpace (0, items.size(), totalSize, 0);
}

int StretchableLayoutManager::getItemCurrentPosition (const int itemIndex) const
{
	int pos = 0;

	for (int i = 0; i < itemIndex; ++i)
	{
		const ItemLayoutProperties* const layout = getInfoFor (i);

		if (layout != nullptr)
			pos += layout->currentSize;
	}

	return pos;
}

int StretchableLayoutManager::getItemCurrentAbsoluteSize (const int itemIndex) const
{
	const ItemLayoutProperties* const layout = getInfoFor (itemIndex);

	if (layout != nullptr)
		return layout->currentSize;

	return 0;
}

double StretchableLayoutManager::getItemCurrentRelativeSize (const int itemIndex) const
{
	const ItemLayoutProperties* const layout = getInfoFor (itemIndex);

	if (layout != nullptr)
		return -layout->currentSize / (double) totalSize;

	return 0;
}

void StretchableLayoutManager::setItemPosition (const int itemIndex,
												int newPosition)
{
	for (int i = items.size(); --i >= 0;)
	{
		const ItemLayoutProperties* const layout = items.getUnchecked(i);

		if (layout->itemIndex == itemIndex)
		{
			int realTotalSize = jmax (totalSize, getMinimumSizeOfItems (0, items.size()));
			const int minSizeAfterThisComp = getMinimumSizeOfItems (i, items.size());
			const int maxSizeAfterThisComp = getMaximumSizeOfItems (i + 1, items.size());

			newPosition = jmax (newPosition, totalSize - maxSizeAfterThisComp - layout->currentSize);
			newPosition = jmin (newPosition, realTotalSize - minSizeAfterThisComp);

			int endPos = fitComponentsIntoSpace (0, i, newPosition, 0);

			endPos += layout->currentSize;

			fitComponentsIntoSpace (i + 1, items.size(), totalSize - endPos, endPos);
			updatePrefSizesToMatchCurrentPositions();
			break;
		}
	}
}

void StretchableLayoutManager::layOutComponents (Component** const components,
												 int numComponents,
												 int x, int y, int w, int h,
												 const bool vertically,
												 const bool resizeOtherDimension)
{
	setTotalSize (vertically ? h : w);
	int pos = vertically ? y : x;

	for (int i = 0; i < numComponents; ++i)
	{
		const ItemLayoutProperties* const layout = getInfoFor (i);

		if (layout != nullptr)
		{
			Component* const c = components[i];

			if (c != nullptr)
			{
				if (i == numComponents - 1)
				{
					// if it's the last item, crop it to exactly fit the available space..
					if (resizeOtherDimension)
					{
						if (vertically)
							c->setBounds (x, pos, w, jmax (layout->currentSize, h - pos));
						else
							c->setBounds (pos, y, jmax (layout->currentSize, w - pos), h);
					}
					else
					{
						if (vertically)
							c->setBounds (c->getX(), pos, c->getWidth(), jmax (layout->currentSize, h - pos));
						else
							c->setBounds (pos, c->getY(), jmax (layout->currentSize, w - pos), c->getHeight());
					}
				}
				else
				{
					if (resizeOtherDimension)
					{
						if (vertically)
							c->setBounds (x, pos, w, layout->currentSize);
						else
							c->setBounds (pos, y, layout->currentSize, h);
					}
					else
					{
						if (vertically)
							c->setBounds (c->getX(), pos, c->getWidth(), layout->currentSize);
						else
							c->setBounds (pos, c->getY(), layout->currentSize, c->getHeight());
					}
				}
			}

			pos += layout->currentSize;
		}
	}
}

StretchableLayoutManager::ItemLayoutProperties* StretchableLayoutManager::getInfoFor (const int itemIndex) const
{
	for (int i = items.size(); --i >= 0;)
		if (items.getUnchecked(i)->itemIndex == itemIndex)
			return items.getUnchecked(i);

	return nullptr;
}

int StretchableLayoutManager::fitComponentsIntoSpace (const int startIndex,
													  const int endIndex,
													  const int availableSpace,
													  int startPos)
{
	// calculate the total sizes
	int i;
	double totalIdealSize = 0.0;
	int totalMinimums = 0;

	for (i = startIndex; i < endIndex; ++i)
	{
		ItemLayoutProperties* const layout = items.getUnchecked (i);

		layout->currentSize = sizeToRealSize (layout->minSize, totalSize);

		totalMinimums += layout->currentSize;
		totalIdealSize += sizeToRealSize (layout->preferredSize, totalSize);
   }

	if (totalIdealSize <= 0)
		totalIdealSize = 1.0;

	// now calc the best sizes..
	int extraSpace = availableSpace - totalMinimums;

	while (extraSpace > 0)
	{
		int numWantingMoreSpace = 0;
		int numHavingTakenExtraSpace = 0;

		// first figure out how many comps want a slice of the extra space..
		for (i = startIndex; i < endIndex; ++i)
		{
			ItemLayoutProperties* const layout = items.getUnchecked (i);

			double sizeWanted = sizeToRealSize (layout->preferredSize, totalSize);

			const int bestSize = jlimit (layout->currentSize,
										 jmax (layout->currentSize,
											   sizeToRealSize (layout->maxSize, totalSize)),
										 roundToInt (sizeWanted * availableSpace / totalIdealSize));

			if (bestSize > layout->currentSize)
				++numWantingMoreSpace;
		}

		// ..share out the extra space..
		for (i = startIndex; i < endIndex; ++i)
		{
			ItemLayoutProperties* const layout = items.getUnchecked (i);

			double sizeWanted = sizeToRealSize (layout->preferredSize, totalSize);

			int bestSize = jlimit (layout->currentSize,
								   jmax (layout->currentSize, sizeToRealSize (layout->maxSize, totalSize)),
								   roundToInt (sizeWanted * availableSpace / totalIdealSize));

			const int extraWanted = bestSize - layout->currentSize;

			if (extraWanted > 0)
			{
				const int extraAllowed = jmin (extraWanted,
												extraSpace / jmax (1, numWantingMoreSpace));

				if (extraAllowed > 0)
				{
					++numHavingTakenExtraSpace;
					--numWantingMoreSpace;

					layout->currentSize += extraAllowed;
					extraSpace -= extraAllowed;
				}
			}
		}

		if (numHavingTakenExtraSpace <= 0)
			break;
	}

	// ..and calculate the end position
	for (i = startIndex; i < endIndex; ++i)
	{
		ItemLayoutProperties* const layout = items.getUnchecked(i);
		startPos += layout->currentSize;
	}

	return startPos;
}

int StretchableLayoutManager::getMinimumSizeOfItems (const int startIndex,
													 const int endIndex) const
{
	int totalMinimums = 0;

	for (int i = startIndex; i < endIndex; ++i)
		totalMinimums += sizeToRealSize (items.getUnchecked (i)->minSize, totalSize);

	return totalMinimums;
}

int StretchableLayoutManager::getMaximumSizeOfItems (const int startIndex, const int endIndex) const
{
	int totalMaximums = 0;

	for (int i = startIndex; i < endIndex; ++i)
		totalMaximums += sizeToRealSize (items.getUnchecked (i)->maxSize, totalSize);

	return totalMaximums;
}

void StretchableLayoutManager::updatePrefSizesToMatchCurrentPositions()
{
	for (int i = 0; i < items.size(); ++i)
	{
		ItemLayoutProperties* const layout = items.getUnchecked (i);

		layout->preferredSize
			= (layout->preferredSize < 0) ? getItemCurrentRelativeSize (i)
										  : getItemCurrentAbsoluteSize (i);
	}
}

int StretchableLayoutManager::sizeToRealSize (double size, int totalSpace)
{
	if (size < 0)
		size *= -totalSpace;

	return roundToInt (size);
}

/*** End of inlined file: juce_StretchableLayoutManager.cpp ***/


/*** Start of inlined file: juce_StretchableLayoutResizerBar.cpp ***/
StretchableLayoutResizerBar::StretchableLayoutResizerBar (StretchableLayoutManager* layout_,
														  const int itemIndex_,
														  const bool isVertical_)
	: layout (layout_),
	  itemIndex (itemIndex_),
	  isVertical (isVertical_)
{
	setRepaintsOnMouseActivity (true);
	setMouseCursor (MouseCursor (isVertical_ ? MouseCursor::LeftRightResizeCursor
											 : MouseCursor::UpDownResizeCursor));
}

StretchableLayoutResizerBar::~StretchableLayoutResizerBar()
{
}

void StretchableLayoutResizerBar::paint (Graphics& g)
{
	getLookAndFeel().drawStretchableLayoutResizerBar (g,
													  getWidth(), getHeight(),
													  isVertical,
													  isMouseOver(),
													  isMouseButtonDown());
}

void StretchableLayoutResizerBar::mouseDown (const MouseEvent&)
{
	mouseDownPos = layout->getItemCurrentPosition (itemIndex);
}

void StretchableLayoutResizerBar::mouseDrag (const MouseEvent& e)
{
	const int desiredPos = mouseDownPos + (isVertical ? e.getDistanceFromDragStartX()
													  : e.getDistanceFromDragStartY());

	if (layout->getItemCurrentPosition (itemIndex) != desiredPos)
	{
		layout->setItemPosition (itemIndex, desiredPos);
		hasBeenMoved();
	}
}

void StretchableLayoutResizerBar::hasBeenMoved()
{
	if (getParentComponent() != nullptr)
		getParentComponent()->resized();
}

/*** End of inlined file: juce_StretchableLayoutResizerBar.cpp ***/


/*** Start of inlined file: juce_StretchableObjectResizer.cpp ***/
StretchableObjectResizer::StretchableObjectResizer()
{
}

StretchableObjectResizer::~StretchableObjectResizer()
{
}

void StretchableObjectResizer::addItem (const double size,
										const double minSize, const double maxSize,
										const int order)
{
	// the order must be >= 0 but less than the maximum integer value.
	jassert (order >= 0 && order < std::numeric_limits<int>::max());

	Item* const item = new Item();
	item->size = size;
	item->minSize = minSize;
	item->maxSize = maxSize;
	item->order = order;
	items.add (item);
}

double StretchableObjectResizer::getItemSize (const int index) const noexcept
{
	const Item* const it = items [index];
	return it != nullptr ? it->size : 0;
}

void StretchableObjectResizer::resizeToFit (const double targetSize)
{
	int order = 0;

	for (;;)
	{
		double currentSize = 0;
		double minSize = 0;
		double maxSize = 0;

		int nextHighestOrder = std::numeric_limits<int>::max();

		for (int i = 0; i < items.size(); ++i)
		{
			const Item* const it = items.getUnchecked(i);
			currentSize += it->size;

			if (it->order <= order)
			{
				minSize += it->minSize;
				maxSize += it->maxSize;
			}
			else
			{
				minSize += it->size;
				maxSize += it->size;
				nextHighestOrder = jmin (nextHighestOrder, it->order);
			}
		}

		const double thisIterationTarget = jlimit (minSize, maxSize, targetSize);

		if (thisIterationTarget >= currentSize)
		{
			const double availableExtraSpace = maxSize - currentSize;
			const double targetAmountOfExtraSpace = thisIterationTarget - currentSize;
			const double scale = targetAmountOfExtraSpace / availableExtraSpace;

			for (int i = 0; i < items.size(); ++i)
			{
				Item* const it = items.getUnchecked(i);

				if (it->order <= order)
					it->size = jmin (it->maxSize, it->size + (it->maxSize - it->size) * scale);
			}
		}
		else
		{
			const double amountOfSlack = currentSize - minSize;
			const double targetAmountOfSlack = thisIterationTarget - minSize;
			const double scale = targetAmountOfSlack / amountOfSlack;

			for (int i = 0; i < items.size(); ++i)
			{
				Item* const it = items.getUnchecked(i);

				if (it->order <= order)
					it->size = jmax (it->minSize, it->minSize + (it->size - it->minSize) * scale);
			}
		}

		if (nextHighestOrder < std::numeric_limits<int>::max())
			order = nextHighestOrder;
		else
			break;
	}
}

/*** End of inlined file: juce_StretchableObjectResizer.cpp ***/


/*** Start of inlined file: juce_TabbedButtonBar.cpp ***/
TabBarButton::TabBarButton (const String& name, TabbedButtonBar& owner_)
	: Button (name),
	  owner (owner_),
	  overlapPixels (0)
{
	shadow.setShadowProperties (2.2f, 0.7f, 0, 0);
	setComponentEffect (&shadow);
	setWantsKeyboardFocus (false);
}

TabBarButton::~TabBarButton()
{
}

int TabBarButton::getIndex() const
{
	return owner.indexOfTabButton (this);
}

void TabBarButton::paintButton (Graphics& g,
								bool isMouseOverButton,
								bool isButtonDown)
{
	const Rectangle<int> area (getActiveArea());
	g.setOrigin (area.getX(), area.getY());

	getLookAndFeel()
		.drawTabButton (g, area.getWidth(), area.getHeight(),
						owner.getTabBackgroundColour (getIndex()),
						getIndex(), getButtonText(), *this,
						owner.getOrientation(),
						isMouseOverButton, isButtonDown,
						getToggleState());
}

void TabBarButton::clicked (const ModifierKeys& mods)
{
	if (mods.isPopupMenu())
		owner.popupMenuClickOnTab (getIndex(), getButtonText());
	else
		owner.setCurrentTabIndex (getIndex());
}

bool TabBarButton::hitTest (int mx, int my)
{
	const Rectangle<int> area (getActiveArea());

	if (owner.getOrientation() == TabbedButtonBar::TabsAtLeft
		 || owner.getOrientation() == TabbedButtonBar::TabsAtRight)
	{
		if (isPositiveAndBelow (mx, getWidth())
			 && my >= area.getY() + overlapPixels
			 && my < area.getBottom() - overlapPixels)
			return true;
	}
	else
	{
		if (mx >= area.getX() + overlapPixels && mx < area.getRight() - overlapPixels
			 && isPositiveAndBelow (my, getHeight()))
			return true;
	}

	Path p;
	getLookAndFeel()
		.createTabButtonShape (p, area.getWidth(), area.getHeight(), getIndex(), getButtonText(), *this,
							   owner.getOrientation(), false, false, getToggleState());

	return p.contains ((float) (mx - area.getX()),
					   (float) (my - area.getY()));
}

int TabBarButton::getBestTabLength (const int depth)
{
	return jlimit (depth * 2,
				   depth * 7,
				   getLookAndFeel().getTabButtonBestWidth (getIndex(), getButtonText(), depth, *this));
}

Rectangle<int> TabBarButton::getActiveArea()
{
	Rectangle<int> r (getLocalBounds());
	const int spaceAroundImage = getLookAndFeel().getTabButtonSpaceAroundImage();

	if (owner.getOrientation() != TabbedButtonBar::TabsAtLeft)      r.removeFromRight (spaceAroundImage);
	if (owner.getOrientation() != TabbedButtonBar::TabsAtRight)     r.removeFromLeft (spaceAroundImage);
	if (owner.getOrientation() != TabbedButtonBar::TabsAtBottom)    r.removeFromTop (spaceAroundImage);
	if (owner.getOrientation() != TabbedButtonBar::TabsAtTop)       r.removeFromBottom (spaceAroundImage);

	return r;
}

class TabbedButtonBar::BehindFrontTabComp  : public Component,
											 public ButtonListener // (can't use Button::Listener due to idiotic VC2005 bug)
{
public:
	BehindFrontTabComp (TabbedButtonBar& owner_)
		: owner (owner_)
	{
		setInterceptsMouseClicks (false, false);
	}

	void paint (Graphics& g)
	{
		getLookAndFeel().drawTabAreaBehindFrontButton (g, getWidth(), getHeight(),
													   owner, owner.getOrientation());
	}

	void enablementChanged()
	{
		repaint();
	}

	void buttonClicked (Button*)
	{
		owner.showExtraItemsMenu();
	}

private:
	TabbedButtonBar& owner;

	JUCE_DECLARE_NON_COPYABLE (BehindFrontTabComp);
};

TabbedButtonBar::TabbedButtonBar (const Orientation orientation_)
	: orientation (orientation_),
	  minimumScale (0.7),
	  currentTabIndex (-1)
{
	setInterceptsMouseClicks (false, true);
	addAndMakeVisible (behindFrontTab = new BehindFrontTabComp (*this));
	setFocusContainer (true);
}

TabbedButtonBar::~TabbedButtonBar()
{
	tabs.clear();
	extraTabsButton = nullptr;
}

void TabbedButtonBar::setOrientation (const Orientation newOrientation)
{
	orientation = newOrientation;

	for (int i = getNumChildComponents(); --i >= 0;)
		getChildComponent (i)->resized();

	resized();
}

TabBarButton* TabbedButtonBar::createTabButton (const String& name, const int /*index*/)
{
	return new TabBarButton (name, *this);
}

void TabbedButtonBar::setMinimumTabScaleFactor (double newMinimumScale)
{
	minimumScale = newMinimumScale;
	resized();
}

void TabbedButtonBar::clearTabs()
{
	tabs.clear();
	extraTabsButton = nullptr;
	setCurrentTabIndex (-1);
}

void TabbedButtonBar::addTab (const String& tabName,
							  const Colour& tabBackgroundColour,
							  int insertIndex)
{
	jassert (tabName.isNotEmpty()); // you have to give them all a name..

	if (tabName.isNotEmpty())
	{
		if (! isPositiveAndBelow (insertIndex, tabs.size()))
			insertIndex = tabs.size();

		TabInfo* newTab = new TabInfo();
		newTab->name = tabName;
		newTab->colour = tabBackgroundColour;
		newTab->component = createTabButton (tabName, insertIndex);

		jassert (newTab->component != nullptr);

		tabs.insert (insertIndex, newTab);
		addAndMakeVisible (newTab->component, insertIndex);

		resized();

		if (currentTabIndex < 0)
			setCurrentTabIndex (0);
	}
}

void TabbedButtonBar::setTabName (const int tabIndex, const String& newName)
{
	TabInfo* const tab = tabs [tabIndex];

	if (tab != nullptr && tab->name != newName)
	{
		tab->name = newName;
		tab->component->setButtonText (newName);
		resized();
	}
}

void TabbedButtonBar::removeTab (const int tabIndex)
{
	if (tabs [tabIndex] != nullptr)
	{
		const int oldTabIndex = currentTabIndex;
		if (currentTabIndex == tabIndex)
			currentTabIndex = -1;

		tabs.remove (tabIndex);
		resized();

		setCurrentTabIndex (jlimit (0, jmax (0, tabs.size() - 1), oldTabIndex));
	}
}

void TabbedButtonBar::moveTab (const int currentIndex, const int newIndex)
{
	tabs.move (currentIndex, newIndex);
	resized();
}

int TabbedButtonBar::getNumTabs() const
{
	return tabs.size();
}

String TabbedButtonBar::getCurrentTabName() const
{
	TabInfo* tab = tabs [currentTabIndex];
	return tab == nullptr ? String::empty : tab->name;
}

StringArray TabbedButtonBar::getTabNames() const
{
	StringArray names;

	for (int i = 0; i < tabs.size(); ++i)
		names.add (tabs.getUnchecked(i)->name);

	return names;
}

void TabbedButtonBar::setCurrentTabIndex (int newIndex, const bool sendChangeMessage_)
{
	if (currentTabIndex != newIndex)
	{
		if (! isPositiveAndBelow (newIndex, tabs.size()))
			newIndex = -1;

		currentTabIndex = newIndex;

		for (int i = 0; i < tabs.size(); ++i)
		{
			TabBarButton* tb = tabs.getUnchecked(i)->component;
			tb->setToggleState (i == newIndex, false);
		}

		resized();

		if (sendChangeMessage_)
			sendChangeMessage();

		currentTabChanged (newIndex, getCurrentTabName());
	}
}

TabBarButton* TabbedButtonBar::getTabButton (const int index) const
{
	TabInfo* const tab = tabs[index];
	return tab == nullptr ? nullptr : static_cast <TabBarButton*> (tab->component);
}

int TabbedButtonBar::indexOfTabButton (const TabBarButton* button) const
{
	for (int i = tabs.size(); --i >= 0;)
		if (tabs.getUnchecked(i)->component == button)
			return i;

	return -1;
}

void TabbedButtonBar::lookAndFeelChanged()
{
	extraTabsButton = nullptr;
	resized();
}

void TabbedButtonBar::resized()
{
	int depth = getWidth();
	int length = getHeight();

	if (orientation == TabsAtTop || orientation == TabsAtBottom)
		std::swap (depth, length);

	const int overlap = getLookAndFeel().getTabButtonOverlap (depth)
							+ getLookAndFeel().getTabButtonSpaceAroundImage() * 2;

	int i, totalLength = overlap;
	int numVisibleButtons = tabs.size();

	for (i = 0; i < tabs.size(); ++i)
	{
		TabBarButton* const tb = tabs.getUnchecked(i)->component;

		totalLength += tb->getBestTabLength (depth) - overlap;
		tb->overlapPixels = overlap / 2;
	}

	double scale = 1.0;

	if (totalLength > length)
		scale = jmax (minimumScale, length / (double) totalLength);

	const bool isTooBig = totalLength * scale > length;
	int tabsButtonPos = 0;

	if (isTooBig)
	{
		if (extraTabsButton == nullptr)
		{
			addAndMakeVisible (extraTabsButton = getLookAndFeel().createTabBarExtrasButton());
			extraTabsButton->addListener (behindFrontTab);
			extraTabsButton->setAlwaysOnTop (true);
			extraTabsButton->setTriggeredOnMouseDown (true);
		}

		const int buttonSize = jmin (proportionOfWidth (0.7f), proportionOfHeight (0.7f));
		extraTabsButton->setSize (buttonSize, buttonSize);

		if (orientation == TabsAtTop || orientation == TabsAtBottom)
		{
			tabsButtonPos = getWidth() - buttonSize / 2 - 1;
			extraTabsButton->setCentrePosition (tabsButtonPos, getHeight() / 2);
		}
		else
		{
			tabsButtonPos = getHeight() - buttonSize / 2 - 1;
			extraTabsButton->setCentrePosition (getWidth() / 2, tabsButtonPos);
		}

		totalLength = 0;

		for (i = 0; i < tabs.size(); ++i)
		{
			TabBarButton* const tb = tabs.getUnchecked(i)->component;

			const int newLength = totalLength + tb->getBestTabLength (depth);

			if (i > 0 && newLength * minimumScale > tabsButtonPos)
			{
				totalLength += overlap;
				break;
			}

			numVisibleButtons = i + 1;
			totalLength = newLength - overlap;
		}

		scale = jmax (minimumScale, tabsButtonPos / (double) totalLength);
	}
	else
	{
		extraTabsButton = nullptr;
	}

	int pos = 0;

	TabBarButton* frontTab = nullptr;

	for (i = 0; i < tabs.size(); ++i)
	{
		TabBarButton* const tb = getTabButton (i);

		if (tb != nullptr)
		{
			const int bestLength = roundToInt (scale * tb->getBestTabLength (depth));

			if (i < numVisibleButtons)
			{
				if (orientation == TabsAtTop || orientation == TabsAtBottom)
					tb->setBounds (pos, 0, bestLength, getHeight());
				else
					tb->setBounds (0, pos, getWidth(), bestLength);

				tb->toBack();

				if (i == currentTabIndex)
					frontTab = tb;

				tb->setVisible (true);
			}
			else
			{
				tb->setVisible (false);
			}

			pos += bestLength - overlap;
		}
	}

	behindFrontTab->setBounds (getLocalBounds());

	if (frontTab != nullptr)
	{
		frontTab->toFront (false);
		behindFrontTab->toBehind (frontTab);
	}
}

Colour TabbedButtonBar::getTabBackgroundColour (const int tabIndex)
{
	TabInfo* const tab = tabs [tabIndex];
	return tab == nullptr ? Colours::white : tab->colour;
}

void TabbedButtonBar::setTabBackgroundColour (const int tabIndex, const Colour& newColour)
{
	TabInfo* const tab = tabs [tabIndex];

	if (tab != nullptr && tab->colour != newColour)
	{
		tab->colour = newColour;
		repaint();
	}
}

void TabbedButtonBar::extraItemsMenuCallback (int result, TabbedButtonBar* bar)
{
	if (bar != nullptr && result > 0)
		bar->setCurrentTabIndex (result - 1);
}

void TabbedButtonBar::showExtraItemsMenu()
{
	PopupMenu m;

	for (int i = 0; i < tabs.size(); ++i)
	{
		const TabInfo* const tab = tabs.getUnchecked(i);

		if (! tab->component->isVisible())
			m.addItem (i + 1, tab->name, true, i == currentTabIndex);
	}

	m.showMenuAsync (PopupMenu::Options().withTargetComponent (extraTabsButton),
					 ModalCallbackFunction::forComponent (extraItemsMenuCallback, this));
}

void TabbedButtonBar::currentTabChanged (const int, const String&)
{
}

void TabbedButtonBar::popupMenuClickOnTab (const int, const String&)
{
}

/*** End of inlined file: juce_TabbedButtonBar.cpp ***/


/*** Start of inlined file: juce_TabbedComponent.cpp ***/
namespace TabbedComponentHelpers
{
	const Identifier deleteComponentId ("deleteByTabComp_");

	void deleteIfNecessary (Component* const comp)
	{
		if (comp != nullptr && (bool) comp->getProperties() [deleteComponentId])
			delete comp;
	}

	Rectangle<int> getTabArea (Rectangle<int>& content, BorderSize<int>& outline,
							   const TabbedButtonBar::Orientation orientation, const int tabDepth)
	{
		switch (orientation)
		{
			case TabbedButtonBar::TabsAtTop:    outline.setTop (0);     return content.removeFromTop (tabDepth);
			case TabbedButtonBar::TabsAtBottom: outline.setBottom (0);  return content.removeFromBottom (tabDepth);
			case TabbedButtonBar::TabsAtLeft:   outline.setLeft (0);    return content.removeFromLeft (tabDepth);
			case TabbedButtonBar::TabsAtRight:  outline.setRight (0);   return content.removeFromRight (tabDepth);
			default: jassertfalse; break;
		}

		return Rectangle<int>();
	}
}

class TabbedComponent::ButtonBar  : public TabbedButtonBar
{
public:
	ButtonBar (TabbedComponent& owner_, const TabbedButtonBar::Orientation orientation_)
		: TabbedButtonBar (orientation_),
		  owner (owner_)
	{
	}

	void currentTabChanged (int newCurrentTabIndex, const String& newTabName)
	{
		owner.changeCallback (newCurrentTabIndex, newTabName);
	}

	void popupMenuClickOnTab (int tabIndex, const String& tabName)
	{
		owner.popupMenuClickOnTab (tabIndex, tabName);
	}

	Colour getTabBackgroundColour (const int tabIndex)
	{
		return owner.tabs->getTabBackgroundColour (tabIndex);
	}

	TabBarButton* createTabButton (const String& tabName, int tabIndex)
	{
		return owner.createTabButton (tabName, tabIndex);
	}

private:
	TabbedComponent& owner;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ButtonBar);
};

TabbedComponent::TabbedComponent (const TabbedButtonBar::Orientation orientation)
	: tabDepth (30),
	  outlineThickness (1),
	  edgeIndent (0)
{
	addAndMakeVisible (tabs = new ButtonBar (*this, orientation));
}

TabbedComponent::~TabbedComponent()
{
	clearTabs();
	tabs = nullptr;
}

void TabbedComponent::setOrientation (const TabbedButtonBar::Orientation orientation)
{
	tabs->setOrientation (orientation);
	resized();
}

TabbedButtonBar::Orientation TabbedComponent::getOrientation() const noexcept
{
	return tabs->getOrientation();
}

void TabbedComponent::setTabBarDepth (const int newDepth)
{
	if (tabDepth != newDepth)
	{
		tabDepth = newDepth;
		resized();
	}
}

TabBarButton* TabbedComponent::createTabButton (const String& tabName, const int /*tabIndex*/)
{
	return new TabBarButton (tabName, *tabs);
}

void TabbedComponent::clearTabs()
{
	if (panelComponent != nullptr)
	{
		panelComponent->setVisible (false);
		removeChildComponent (panelComponent);
		panelComponent = nullptr;
	}

	tabs->clearTabs();

	for (int i = contentComponents.size(); --i >= 0;)
		TabbedComponentHelpers::deleteIfNecessary (contentComponents.getReference (i));

	contentComponents.clear();
}

void TabbedComponent::addTab (const String& tabName,
							  const Colour& tabBackgroundColour,
							  Component* const contentComponent,
							  const bool deleteComponentWhenNotNeeded,
							  const int insertIndex)
{
	contentComponents.insert (insertIndex, WeakReference<Component> (contentComponent));

	if (deleteComponentWhenNotNeeded && contentComponent != nullptr)
		contentComponent->getProperties().set (TabbedComponentHelpers::deleteComponentId, true);

	tabs->addTab (tabName, tabBackgroundColour, insertIndex);
}

void TabbedComponent::setTabName (const int tabIndex, const String& newName)
{
	tabs->setTabName (tabIndex, newName);
}

void TabbedComponent::removeTab (const int tabIndex)
{
	if (isPositiveAndBelow (tabIndex, contentComponents.size()))
	{
		TabbedComponentHelpers::deleteIfNecessary (contentComponents.getReference (tabIndex));
		contentComponents.remove (tabIndex);
		tabs->removeTab (tabIndex);
	}
}

int TabbedComponent::getNumTabs() const
{
	return tabs->getNumTabs();
}

StringArray TabbedComponent::getTabNames() const
{
	return tabs->getTabNames();
}

Component* TabbedComponent::getTabContentComponent (const int tabIndex) const noexcept
{
	return contentComponents [tabIndex];
}

Colour TabbedComponent::getTabBackgroundColour (const int tabIndex) const noexcept
{
	return tabs->getTabBackgroundColour (tabIndex);
}

void TabbedComponent::setTabBackgroundColour (const int tabIndex, const Colour& newColour)
{
	tabs->setTabBackgroundColour (tabIndex, newColour);

	if (getCurrentTabIndex() == tabIndex)
		repaint();
}

void TabbedComponent::setCurrentTabIndex (const int newTabIndex, const bool sendChangeMessage)
{
	tabs->setCurrentTabIndex (newTabIndex, sendChangeMessage);
}

int TabbedComponent::getCurrentTabIndex() const
{
	return tabs->getCurrentTabIndex();
}

String TabbedComponent::getCurrentTabName() const
{
	return tabs->getCurrentTabName();
}

void TabbedComponent::setOutline (const int thickness)
{
	outlineThickness = thickness;
	resized();
	repaint();
}

void TabbedComponent::setIndent (const int indentThickness)
{
	edgeIndent = indentThickness;
	resized();
	repaint();
}

void TabbedComponent::paint (Graphics& g)
{
	g.fillAll (findColour (backgroundColourId));

	Rectangle<int> content (getLocalBounds());
	BorderSize<int> outline (outlineThickness);
	TabbedComponentHelpers::getTabArea (content, outline, getOrientation(), tabDepth);

	g.reduceClipRegion (content);
	g.fillAll (tabs->getTabBackgroundColour (getCurrentTabIndex()));

	if (outlineThickness > 0)
	{
		RectangleList rl (content);
		rl.subtract (outline.subtractedFrom (content));

		g.reduceClipRegion (rl);
		g.fillAll (findColour (outlineColourId));
	}
}

void TabbedComponent::resized()
{
	Rectangle<int> content (getLocalBounds());
	BorderSize<int> outline (outlineThickness);

	tabs->setBounds (TabbedComponentHelpers::getTabArea (content, outline, getOrientation(), tabDepth));
	content = BorderSize<int> (edgeIndent).subtractedFrom (outline.subtractedFrom (content));

	for (int i = contentComponents.size(); --i >= 0;)
		if (contentComponents.getReference (i) != nullptr)
			contentComponents.getReference (i)->setBounds (content);
}

void TabbedComponent::lookAndFeelChanged()
{
	for (int i = contentComponents.size(); --i >= 0;)
		if (contentComponents.getReference (i) != nullptr)
			contentComponents.getReference (i)->lookAndFeelChanged();
}

void TabbedComponent::changeCallback (const int newCurrentTabIndex, const String& newTabName)
{
	if (panelComponent != nullptr)
	{
		panelComponent->setVisible (false);
		removeChildComponent (panelComponent);
		panelComponent = nullptr;
	}

	if (getCurrentTabIndex() >= 0)
	{
		panelComponent = getTabContentComponent (getCurrentTabIndex());

		if (panelComponent != nullptr)
		{
			// do these ops as two stages instead of addAndMakeVisible() so that the
			// component has always got a parent when it gets the visibilityChanged() callback
			addChildComponent (panelComponent);
			panelComponent->setVisible (true);
			panelComponent->toFront (true);
		}

		repaint();
	}

	resized();

	currentTabChanged (newCurrentTabIndex, newTabName);
}

void TabbedComponent::currentTabChanged (const int, const String&) {}
void TabbedComponent::popupMenuClickOnTab (const int, const String&) {}

/*** End of inlined file: juce_TabbedComponent.cpp ***/


/*** Start of inlined file: juce_Viewport.cpp ***/
Viewport::Viewport (const String& name)
  : Component (name),
	scrollBarThickness (0),
	singleStepX (16),
	singleStepY (16),
	showHScrollbar (true),
	showVScrollbar (true),
	deleteContent (true),
	verticalScrollBar (true),
	horizontalScrollBar (false)
{
	// content holder is used to clip the contents so they don't overlap the scrollbars
	addAndMakeVisible (&contentHolder);
	contentHolder.setInterceptsMouseClicks (false, true);

	addChildComponent (&verticalScrollBar);
	addChildComponent (&horizontalScrollBar);

	verticalScrollBar.addListener (this);
	horizontalScrollBar.addListener (this);

	setInterceptsMouseClicks (false, true);
	setWantsKeyboardFocus (true);
}

Viewport::~Viewport()
{
	deleteContentComp();
}

void Viewport::visibleAreaChanged (const Rectangle<int>&) {}
void Viewport::viewedComponentChanged (Component*) {}

void Viewport::deleteContentComp()
{
	if (contentComp != nullptr)
		contentComp->removeComponentListener (this);

	if (deleteContent)
	{
		// This sets the content comp to a null pointer before deleting the old one, in case
		// anything tries to use the old one while it's in mid-deletion..
		ScopedPointer<Component> oldCompDeleter (contentComp);
	}
	else
	{
		contentComp = nullptr;
	}
}

void Viewport::setViewedComponent (Component* const newViewedComponent, const bool deleteComponentWhenNoLongerNeeded)
{
	if (contentComp.get() != newViewedComponent)
	{
		deleteContentComp();
		contentComp = newViewedComponent;
		deleteContent = deleteComponentWhenNoLongerNeeded;

		if (contentComp != nullptr)
		{
			contentHolder.addAndMakeVisible (contentComp);
			setViewPosition (Point<int>());
			contentComp->addComponentListener (this);
		}

		viewedComponentChanged (contentComp);
		updateVisibleArea();
	}
}

int Viewport::getMaximumVisibleWidth() const    { return contentHolder.getWidth(); }
int Viewport::getMaximumVisibleHeight() const   { return contentHolder.getHeight(); }

Point<int> Viewport::viewportPosToCompPos (const Point<int>& pos) const
{
	jassert (contentComp != nullptr);
	return Point<int> (jmax (jmin (0, contentHolder.getWidth()  - contentComp->getWidth()),  jmin (0, -(pos.x))),
					   jmax (jmin (0, contentHolder.getHeight() - contentComp->getHeight()), jmin (0, -(pos.y))));
}

void Viewport::setViewPosition (const int xPixelsOffset, const int yPixelsOffset)
{
	setViewPosition (Point<int> (xPixelsOffset, yPixelsOffset));
}

void Viewport::setViewPosition (const Point<int>& newPosition)
{
	if (contentComp != nullptr)
		contentComp->setTopLeftPosition (viewportPosToCompPos (newPosition));
}

void Viewport::setViewPositionProportionately (const double x, const double y)
{
	if (contentComp != nullptr)
		setViewPosition (jmax (0, roundToInt (x * (contentComp->getWidth()  - getWidth()))),
						 jmax (0, roundToInt (y * (contentComp->getHeight() - getHeight()))));
}

bool Viewport::autoScroll (const int mouseX, const int mouseY, const int activeBorderThickness, const int maximumSpeed)
{
	if (contentComp != nullptr)
	{
		int dx = 0, dy = 0;

		if (horizontalScrollBar.isVisible() || contentComp->getX() < 0 || contentComp->getRight() > getWidth())
		{
			if (mouseX < activeBorderThickness)
				dx = activeBorderThickness - mouseX;
			else if (mouseX >= contentHolder.getWidth() - activeBorderThickness)
				dx = (contentHolder.getWidth() - activeBorderThickness) - mouseX;

			if (dx < 0)
				dx = jmax (dx, -maximumSpeed, contentHolder.getWidth() - contentComp->getRight());
			else
				dx = jmin (dx, maximumSpeed, -contentComp->getX());
		}

		if (verticalScrollBar.isVisible() || contentComp->getY() < 0 || contentComp->getBottom() > getHeight())
		{
			if (mouseY < activeBorderThickness)
				dy = activeBorderThickness - mouseY;
			else if (mouseY >= contentHolder.getHeight() - activeBorderThickness)
				dy = (contentHolder.getHeight() - activeBorderThickness) - mouseY;

			if (dy < 0)
				dy = jmax (dy, -maximumSpeed, contentHolder.getHeight() - contentComp->getBottom());
			else
				dy = jmin (dy, maximumSpeed, -contentComp->getY());
		}

		if (dx != 0 || dy != 0)
		{
			contentComp->setTopLeftPosition (contentComp->getX() + dx,
											 contentComp->getY() + dy);

			return true;
		}
	}

	return false;
}

void Viewport::componentMovedOrResized (Component&, bool, bool)
{
	updateVisibleArea();
}

void Viewport::resized()
{
	updateVisibleArea();
}

void Viewport::updateVisibleArea()
{
	const int scrollbarWidth = getScrollBarThickness();
	const bool canShowAnyBars = getWidth() > scrollbarWidth && getHeight() > scrollbarWidth;
	const bool canShowHBar = showHScrollbar && canShowAnyBars;
	const bool canShowVBar = showVScrollbar && canShowAnyBars;

	bool hBarVisible = false, vBarVisible = false;
	Rectangle<int> contentArea;

	for (int i = 3; --i >= 0;)
	{
		hBarVisible = canShowHBar && ! horizontalScrollBar.autoHides();
		vBarVisible = canShowVBar && ! verticalScrollBar.autoHides();
		contentArea = getLocalBounds();

		if (contentComp != nullptr && ! contentArea.contains (contentComp->getBounds()))
		{
			hBarVisible = canShowHBar && (hBarVisible || contentComp->getX() < 0 || contentComp->getRight() > contentArea.getWidth());
			vBarVisible = canShowVBar && (vBarVisible || contentComp->getY() < 0 || contentComp->getBottom() > contentArea.getHeight());

			if (vBarVisible)
				contentArea.setWidth (getWidth() - scrollbarWidth);

			if (hBarVisible)
				contentArea.setHeight (getHeight() - scrollbarWidth);

			if (! contentArea.contains (contentComp->getBounds()))
			{
				hBarVisible = canShowHBar && (hBarVisible || contentComp->getRight() > contentArea.getWidth());
				vBarVisible = canShowVBar && (vBarVisible || contentComp->getBottom() > contentArea.getHeight());
			}
		}

		if (vBarVisible)  contentArea.setWidth  (getWidth()  - scrollbarWidth);
		if (hBarVisible)  contentArea.setHeight (getHeight() - scrollbarWidth);

		if (contentComp == nullptr)
		{
			contentHolder.setBounds (contentArea);
			break;
		}

		const Rectangle<int> oldContentBounds (contentComp->getBounds());
		contentHolder.setBounds (contentArea);

		// If the content has changed its size, that might affect our scrollbars, so go round again and re-caclulate..
		if (oldContentBounds == contentComp->getBounds())
			break;
	}

	Rectangle<int> contentBounds;
	if (contentComp != nullptr)
		contentBounds = contentHolder.getLocalArea (contentComp, contentComp->getLocalBounds());

	Point<int> visibleOrigin (-contentBounds.getPosition());

	if (hBarVisible)
	{
		horizontalScrollBar.setBounds (0, contentArea.getHeight(), contentArea.getWidth(), scrollbarWidth);
		horizontalScrollBar.setRangeLimits (0.0, contentBounds.getWidth());
		horizontalScrollBar.setCurrentRange (visibleOrigin.x, contentArea.getWidth());
		horizontalScrollBar.setSingleStepSize (singleStepX);
		horizontalScrollBar.cancelPendingUpdate();
	}
	else if (canShowHBar)
	{
		visibleOrigin.setX (0);
	}

	if (vBarVisible)
	{
		verticalScrollBar.setBounds (contentArea.getWidth(), 0, scrollbarWidth, contentArea.getHeight());
		verticalScrollBar.setRangeLimits (0.0, contentBounds.getHeight());
		verticalScrollBar.setCurrentRange (visibleOrigin.y, contentArea.getHeight());
		verticalScrollBar.setSingleStepSize (singleStepY);
		verticalScrollBar.cancelPendingUpdate();
	}
	else if (canShowVBar)
	{
		visibleOrigin.setY (0);
	}

	// Force the visibility *after* setting the ranges to avoid flicker caused by edge conditions in the numbers.
	horizontalScrollBar.setVisible (hBarVisible);
	verticalScrollBar.setVisible (vBarVisible);

	if (contentComp != nullptr)
	{
		const Point<int> newContentCompPos (viewportPosToCompPos (visibleOrigin));

		if (contentComp->getBounds().getPosition() != newContentCompPos)
		{
			contentComp->setTopLeftPosition (newContentCompPos);  // (this will re-entrantly call updateVisibleArea again)
			return;
		}
	}

	const Rectangle<int> visibleArea (visibleOrigin.x, visibleOrigin.y,
									  jmin (contentBounds.getWidth()  - visibleOrigin.x, contentArea.getWidth()),
									  jmin (contentBounds.getHeight() - visibleOrigin.y, contentArea.getHeight()));

	if (lastVisibleArea != visibleArea)
	{
		lastVisibleArea = visibleArea;
		visibleAreaChanged (visibleArea);
	}

	horizontalScrollBar.handleUpdateNowIfNeeded();
	verticalScrollBar.handleUpdateNowIfNeeded();
}

void Viewport::setSingleStepSizes (const int stepX, const int stepY)
{
	if (singleStepX != stepX || singleStepY != stepY)
	{
		singleStepX = stepX;
		singleStepY = stepY;
		updateVisibleArea();
	}
}

void Viewport::setScrollBarsShown (const bool showVerticalScrollbarIfNeeded,
								   const bool showHorizontalScrollbarIfNeeded)
{
	if (showVScrollbar != showVerticalScrollbarIfNeeded
		 || showHScrollbar != showHorizontalScrollbarIfNeeded)
	{
		showVScrollbar = showVerticalScrollbarIfNeeded;
		showHScrollbar = showHorizontalScrollbarIfNeeded;
		updateVisibleArea();
	}
}

void Viewport::setScrollBarThickness (const int thickness)
{
	if (scrollBarThickness != thickness)
	{
		scrollBarThickness = thickness;
		updateVisibleArea();
	}
}

int Viewport::getScrollBarThickness() const
{
	return scrollBarThickness > 0 ? scrollBarThickness
								  : getLookAndFeel().getDefaultScrollbarWidth();
}

void Viewport::setScrollBarButtonVisibility (const bool buttonsVisible)
{
	verticalScrollBar.setButtonVisibility (buttonsVisible);
	horizontalScrollBar.setButtonVisibility (buttonsVisible);
}

void Viewport::scrollBarMoved (ScrollBar* scrollBarThatHasMoved, double newRangeStart)
{
	const int newRangeStartInt = roundToInt (newRangeStart);

	if (scrollBarThatHasMoved == &horizontalScrollBar)
	{
		setViewPosition (newRangeStartInt, getViewPositionY());
	}
	else if (scrollBarThatHasMoved == &verticalScrollBar)
	{
		setViewPosition (getViewPositionX(), newRangeStartInt);
	}
}

void Viewport::mouseWheelMove (const MouseEvent& e, const float wheelIncrementX, const float wheelIncrementY)
{
	if (! useMouseWheelMoveIfNeeded (e, wheelIncrementX, wheelIncrementY))
		Component::mouseWheelMove (e, wheelIncrementX, wheelIncrementY);
}

bool Viewport::useMouseWheelMoveIfNeeded (const MouseEvent& e, float wheelIncrementX, float wheelIncrementY)
{
	if (! (e.mods.isAltDown() || e.mods.isCtrlDown()))
	{
		const bool hasVertBar = verticalScrollBar.isVisible();
		const bool hasHorzBar = horizontalScrollBar.isVisible();

		if (hasHorzBar || hasVertBar)
		{
			if (wheelIncrementX != 0)
			{
				wheelIncrementX *= 14.0f * singleStepX;
				wheelIncrementX = (wheelIncrementX < 0) ? jmin (wheelIncrementX, -1.0f)
														: jmax (wheelIncrementX, 1.0f);
			}

			if (wheelIncrementY != 0)
			{
				wheelIncrementY *= 14.0f * singleStepY;
				wheelIncrementY = (wheelIncrementY < 0) ? jmin (wheelIncrementY, -1.0f)
														: jmax (wheelIncrementY, 1.0f);
			}

			Point<int> pos (getViewPosition());

			if (wheelIncrementX != 0 && wheelIncrementY != 0 && hasHorzBar && hasVertBar)
			{
				pos.setX (pos.x - roundToInt (wheelIncrementX));
				pos.setY (pos.y - roundToInt (wheelIncrementY));
			}
			else if (hasHorzBar && (wheelIncrementX != 0 || e.mods.isShiftDown() || ! hasVertBar))
			{
				if (wheelIncrementX == 0 && ! hasVertBar)
					wheelIncrementX = wheelIncrementY;

				pos.setX (pos.x - roundToInt (wheelIncrementX));
			}
			else if (hasVertBar && wheelIncrementY != 0)
			{
				pos.setY (pos.y - roundToInt (wheelIncrementY));
			}

			if (pos != getViewPosition())
			{
				setViewPosition (pos);
				return true;
			}
		}
	}

	return false;
}

bool Viewport::keyPressed (const KeyPress& key)
{
	const bool isUpDownKey = key.isKeyCode (KeyPress::upKey)
								|| key.isKeyCode (KeyPress::downKey)
								|| key.isKeyCode (KeyPress::pageUpKey)
								|| key.isKeyCode (KeyPress::pageDownKey)
								|| key.isKeyCode (KeyPress::homeKey)
								|| key.isKeyCode (KeyPress::endKey);

	if (verticalScrollBar.isVisible() && isUpDownKey)
		return verticalScrollBar.keyPressed (key);

	const bool isLeftRightKey = key.isKeyCode (KeyPress::leftKey)
								 || key.isKeyCode (KeyPress::rightKey);

	if (horizontalScrollBar.isVisible() && (isUpDownKey || isLeftRightKey))
		return horizontalScrollBar.keyPressed (key);

	return false;
}

const Identifier Viewport::Ids::showScrollBarV ("showScrollBarV");
const Identifier Viewport::Ids::showScrollBarH ("showScrollBarH");
const Identifier Viewport::Ids::scrollBarWidth ("scrollBarWidth");

void Viewport::refreshFromValueTree (const ValueTree& state, ComponentBuilder&)
{
	ComponentBuilder::refreshBasicComponentProperties (*this, state);

	setScrollBarsShown (state [Ids::showScrollBarV], state [Ids::showScrollBarH]);
	setScrollBarThickness (state [Ids::scrollBarWidth]);
}

/*** End of inlined file: juce_Viewport.cpp ***/


/*** Start of inlined file: juce_LookAndFeel.cpp ***/
namespace LookAndFeelHelpers
{
	void createRoundedPath (Path& p,
							const float x, const float y,
							const float w, const float h,
							const float cs,
							const bool curveTopLeft, const bool curveTopRight,
							const bool curveBottomLeft, const bool curveBottomRight) noexcept
	{
		const float cs2 = 2.0f * cs;

		if (curveTopLeft)
		{
			p.startNewSubPath (x, y + cs);
			p.addArc (x, y, cs2, cs2, float_Pi * 1.5f, float_Pi * 2.0f);
		}
		else
		{
			p.startNewSubPath (x, y);
		}

		if (curveTopRight)
		{
			p.lineTo (x + w - cs, y);
			p.addArc (x + w - cs2, y, cs2, cs2, 0.0f, float_Pi * 0.5f);
		}
		else
		{
			p.lineTo (x + w, y);
		}

		if (curveBottomRight)
		{
			p.lineTo (x + w, y + h - cs);
			p.addArc (x + w - cs2, y + h - cs2, cs2, cs2, float_Pi * 0.5f, float_Pi);
		}
		else
		{
			p.lineTo (x + w, y + h);
		}

		if (curveBottomLeft)
		{
			p.lineTo (x + cs, y + h);
			p.addArc (x, y + h - cs2, cs2, cs2, float_Pi, float_Pi * 1.5f);
		}
		else
		{
			p.lineTo (x, y + h);
		}

		p.closeSubPath();
	}

	Colour createBaseColour (const Colour& buttonColour,
							 const bool hasKeyboardFocus,
							 const bool isMouseOverButton,
							 const bool isButtonDown) noexcept
	{
		const float sat = hasKeyboardFocus ? 1.3f : 0.9f;
		const Colour baseColour (buttonColour.withMultipliedSaturation (sat));

		if (isButtonDown)
			return baseColour.contrasting (0.2f);
		else if (isMouseOverButton)
			return baseColour.contrasting (0.1f);

		return baseColour;
	}

	TextLayout layoutTooltipText (const String& text, const Colour& colour) noexcept
	{
		const float tooltipFontSize = 13.0f;
		const int maxToolTipWidth = 400;

		AttributedString s;
		s.setJustification (Justification::centred);
		s.append (text, Font (tooltipFontSize, Font::bold), colour);

		TextLayout tl;
		tl.createLayoutWithBalancedLineLengths (s, (float) maxToolTipWidth);
		return tl;
	}
}

typedef Typeface::Ptr (*GetTypefaceForFont) (const Font&);
extern GetTypefaceForFont juce_getTypefaceForFont;

static Typeface::Ptr getTypefaceForFontFromLookAndFeel (const Font& font)
{
	return LookAndFeel::getDefaultLookAndFeel().getTypefaceForFont (font);
}

LookAndFeel::LookAndFeel()
	: useNativeAlertWindows (false)
{
	/* if this fails it means you're trying to create a LookAndFeel object before
	   the static Colours have been initialised. That ain't gonna work. It probably
	   means that you're using a static LookAndFeel object and that your compiler has
	   decided to intialise it before the Colours class.
	*/
	jassert (Colours::white == Colour (0xffffffff));

	// set up the standard set of colours..
	const uint32 textButtonColour      = 0xffbbbbff;
	const uint32 textHighlightColour   = 0x401111ee;
	const uint32 standardOutlineColour = 0xb2808080;

	static const uint32 standardColours[] =
	{
		TextButton::buttonColourId,                 textButtonColour,
		TextButton::buttonOnColourId,               0xff4444ff,
		TextButton::textColourOnId,                 0xff000000,
		TextButton::textColourOffId,                0xff000000,

		ComboBox::buttonColourId,                   0xffbbbbff,
		ComboBox::outlineColourId,                  standardOutlineColour,

		ToggleButton::textColourId,                 0xff000000,

		TextEditor::backgroundColourId,             0xffffffff,
		TextEditor::textColourId,                   0xff000000,
		TextEditor::highlightColourId,              textHighlightColour,
		TextEditor::highlightedTextColourId,        0xff000000,
		TextEditor::outlineColourId,                0x00000000,
		TextEditor::focusedOutlineColourId,         textButtonColour,
		TextEditor::shadowColourId,                 0x38000000,

		CaretComponent::caretColourId,              0xff000000,

		Label::backgroundColourId,                  0x00000000,
		Label::textColourId,                        0xff000000,
		Label::outlineColourId,                     0x00000000,

		ScrollBar::backgroundColourId,              0x00000000,
		ScrollBar::thumbColourId,                   0xffffffff,

		TreeView::linesColourId,                    0x4c000000,
		TreeView::backgroundColourId,               0x00000000,
		TreeView::dragAndDropIndicatorColourId,     0x80ff0000,

		PopupMenu::backgroundColourId,              0xffffffff,
		PopupMenu::textColourId,                    0xff000000,
		PopupMenu::headerTextColourId,              0xff000000,
		PopupMenu::highlightedTextColourId,         0xffffffff,
		PopupMenu::highlightedBackgroundColourId,   0x991111aa,

		ComboBox::textColourId,                     0xff000000,
		ComboBox::backgroundColourId,               0xffffffff,
		ComboBox::arrowColourId,                    0x99000000,

		ListBox::backgroundColourId,                0xffffffff,
		ListBox::outlineColourId,                   standardOutlineColour,
		ListBox::textColourId,                      0xff000000,

		Slider::backgroundColourId,                 0x00000000,
		Slider::thumbColourId,                      textButtonColour,
		Slider::trackColourId,                      0x7fffffff,
		Slider::rotarySliderFillColourId,           0x7f0000ff,
		Slider::rotarySliderOutlineColourId,        0x66000000,
		Slider::textBoxTextColourId,                0xff000000,
		Slider::textBoxBackgroundColourId,          0xffffffff,
		Slider::textBoxHighlightColourId,           textHighlightColour,
		Slider::textBoxOutlineColourId,             standardOutlineColour,

		ResizableWindow::backgroundColourId,        0xff777777,
		//DocumentWindow::textColourId,               0xff000000, // (this is deliberately not set)

		AlertWindow::backgroundColourId,            0xffededed,
		AlertWindow::textColourId,                  0xff000000,
		AlertWindow::outlineColourId,               0xff666666,

		ProgressBar::backgroundColourId,            0xffeeeeee,
		ProgressBar::foregroundColourId,            0xffaaaaee,

		TooltipWindow::backgroundColourId,          0xffeeeebb,
		TooltipWindow::textColourId,                0xff000000,
		TooltipWindow::outlineColourId,             0x4c000000,

		TabbedComponent::backgroundColourId,        0x00000000,
		TabbedComponent::outlineColourId,           0xff777777,
		TabbedButtonBar::tabOutlineColourId,        0x80000000,
		TabbedButtonBar::frontOutlineColourId,      0x90000000,

		Toolbar::backgroundColourId,                0xfff6f8f9,
		Toolbar::separatorColourId,                 0x4c000000,
		Toolbar::buttonMouseOverBackgroundColourId, 0x4c0000ff,
		Toolbar::buttonMouseDownBackgroundColourId, 0x800000ff,
		Toolbar::labelTextColourId,                 0xff000000,
		Toolbar::editingModeOutlineColourId,        0xffff0000,

		HyperlinkButton::textColourId,              0xcc1111ee,

		GroupComponent::outlineColourId,            0x66000000,
		GroupComponent::textColourId,               0xff000000,

		DirectoryContentsDisplayComponent::highlightColourId,   textHighlightColour,
		DirectoryContentsDisplayComponent::textColourId,        0xff000000,

		0x1000440, /*LassoComponent::lassoFillColourId*/        0x66dddddd,
		0x1000441, /*LassoComponent::lassoOutlineColourId*/     0x99111111,

		0x1005000, /*MidiKeyboardComponent::whiteNoteColourId*/               0xffffffff,
		0x1005001, /*MidiKeyboardComponent::blackNoteColourId*/               0xff000000,
		0x1005002, /*MidiKeyboardComponent::keySeparatorLineColourId*/        0x66000000,
		0x1005003, /*MidiKeyboardComponent::mouseOverKeyOverlayColourId*/     0x80ffff00,
		0x1005004, /*MidiKeyboardComponent::keyDownOverlayColourId*/          0xffb6b600,
		0x1005005, /*MidiKeyboardComponent::textLabelColourId*/               0xff000000,
		0x1005006, /*MidiKeyboardComponent::upDownButtonBackgroundColourId*/  0xffd3d3d3,
		0x1005007, /*MidiKeyboardComponent::upDownButtonArrowColourId*/       0xff000000,

		0x1004500, /*CodeEditorComponent::backgroundColourId*/                0xffffffff,
		0x1004502, /*CodeEditorComponent::highlightColourId*/                 textHighlightColour,
		0x1004503, /*CodeEditorComponent::defaultTextColourId*/               0xff000000,

		0x1007000, /*ColourSelector::backgroundColourId*/                     0xffe5e5e5,
		0x1007001, /*ColourSelector::labelTextColourId*/                      0xff000000,

		0x100ad00, /*KeyMappingEditorComponent::backgroundColourId*/          0x00000000,
		0x100ad01, /*KeyMappingEditorComponent::textColourId*/                0xff000000,

		FileSearchPathListComponent::backgroundColourId,        0xffffffff,

		FileChooserDialogBox::titleTextColourId,                0xff000000,

		DrawableButton::textColourId,                           0xff000000,
	};

	for (int i = 0; i < numElementsInArray (standardColours); i += 2)
		setColour (standardColours [i], Colour ((uint32) standardColours [i + 1]));

	juce_getTypefaceForFont = getTypefaceForFontFromLookAndFeel;
}

LookAndFeel::~LookAndFeel()
{
	masterReference.clear();
}

Colour LookAndFeel::findColour (const int colourId) const noexcept
{
	const int index = colourIds.indexOf (colourId);

	if (index >= 0)
		return colours [index];

	jassertfalse;
	return Colours::black;
}

void LookAndFeel::setColour (const int colourId, const Colour& colour) noexcept
{
	const int index = colourIds.indexOf (colourId);

	if (index >= 0)
	{
		colours.set (index, colour);
	}
	else
	{
		colourIds.add (colourId);
		colours.add (colour);
	}
}

bool LookAndFeel::isColourSpecified (const int colourId) const noexcept
{
	return colourIds.contains (colourId);
}

LookAndFeel& LookAndFeel::getDefaultLookAndFeel() noexcept
{
	return Desktop::getInstance().getDefaultLookAndFeel();
}

void LookAndFeel::setDefaultLookAndFeel (LookAndFeel* newDefaultLookAndFeel) noexcept
{
	Desktop::getInstance().setDefaultLookAndFeel (newDefaultLookAndFeel);
}

const Typeface::Ptr LookAndFeel::getTypefaceForFont (const Font& font)
{
	if (defaultSans.isNotEmpty() && font.getTypefaceName() == Font::getDefaultSansSerifFontName())
	{
		Font f (font);
		f.setTypefaceName (defaultSans);
		return Typeface::createSystemTypefaceFor (f);
	}

	return Font::getDefaultTypefaceForFont (font);
}

void LookAndFeel::setDefaultSansSerifTypefaceName (const String& newName)
{
	defaultSans = newName;
}

MouseCursor LookAndFeel::getMouseCursorFor (Component& component)
{
	return component.getMouseCursor();
}

LowLevelGraphicsContext* LookAndFeel::createGraphicsContext (const Image& imageToRenderOn, const Point<int>& origin, const RectangleList& initialClip)
{
	return new LowLevelGraphicsSoftwareRenderer (imageToRenderOn, origin, initialClip);
}

void LookAndFeel::drawButtonBackground (Graphics& g,
										Button& button,
										const Colour& backgroundColour,
										bool isMouseOverButton,
										bool isButtonDown)
{
	const int width = button.getWidth();
	const int height = button.getHeight();

	const float outlineThickness = button.isEnabled() ? ((isButtonDown || isMouseOverButton) ? 1.2f : 0.7f) : 0.4f;
	const float halfThickness = outlineThickness * 0.5f;

	const float indentL = button.isConnectedOnLeft()   ? 0.1f : halfThickness;
	const float indentR = button.isConnectedOnRight()  ? 0.1f : halfThickness;
	const float indentT = button.isConnectedOnTop()    ? 0.1f : halfThickness;
	const float indentB = button.isConnectedOnBottom() ? 0.1f : halfThickness;

	const Colour baseColour (LookAndFeelHelpers::createBaseColour (backgroundColour,
																   button.hasKeyboardFocus (true),
																   isMouseOverButton, isButtonDown)
							   .withMultipliedAlpha (button.isEnabled() ? 1.0f : 0.5f));

	drawGlassLozenge (g,
					  indentL,
					  indentT,
					  width - indentL - indentR,
					  height - indentT - indentB,
					  baseColour, outlineThickness, -1.0f,
					  button.isConnectedOnLeft(),
					  button.isConnectedOnRight(),
					  button.isConnectedOnTop(),
					  button.isConnectedOnBottom());
}

const Font LookAndFeel::getFontForTextButton (TextButton& button)
{
	return button.getFont();
}

void LookAndFeel::drawButtonText (Graphics& g, TextButton& button,
								  bool /*isMouseOverButton*/, bool /*isButtonDown*/)
{
	Font font (getFontForTextButton (button));
	g.setFont (font);
	g.setColour (button.findColour (button.getToggleState() ? TextButton::textColourOnId
															: TextButton::textColourOffId)
					   .withMultipliedAlpha (button.isEnabled() ? 1.0f : 0.5f));

	const int yIndent = jmin (4, button.proportionOfHeight (0.3f));
	const int cornerSize = jmin (button.getHeight(), button.getWidth()) / 2;

	const int fontHeight = roundToInt (font.getHeight() * 0.6f);
	const int leftIndent  = jmin (fontHeight, 2 + cornerSize / (button.isConnectedOnLeft() ? 4 : 2));
	const int rightIndent = jmin (fontHeight, 2 + cornerSize / (button.isConnectedOnRight() ? 4 : 2));

	g.drawFittedText (button.getButtonText(),
					  leftIndent,
					  yIndent,
					  button.getWidth() - leftIndent - rightIndent,
					  button.getHeight() - yIndent * 2,
					  Justification::centred, 2);
}

void LookAndFeel::drawTickBox (Graphics& g,
							   Component& component,
							   float x, float y, float w, float h,
							   const bool ticked,
							   const bool isEnabled,
							   const bool isMouseOverButton,
							   const bool isButtonDown)
{
	const float boxSize = w * 0.7f;

	drawGlassSphere (g, x, y + (h - boxSize) * 0.5f, boxSize,
					 LookAndFeelHelpers::createBaseColour (component.findColour (TextButton::buttonColourId)
																	.withMultipliedAlpha (isEnabled ? 1.0f : 0.5f),
														   true, isMouseOverButton, isButtonDown),
					 isEnabled ? ((isButtonDown || isMouseOverButton) ? 1.1f : 0.5f) : 0.3f);

	if (ticked)
	{
		Path tick;
		tick.startNewSubPath (1.5f, 3.0f);
		tick.lineTo (3.0f, 6.0f);
		tick.lineTo (6.0f, 0.0f);

		g.setColour (isEnabled ? Colours::black : Colours::grey);

		const AffineTransform trans (AffineTransform::scale (w / 9.0f, h / 9.0f)
										 .translated (x, y));

		g.strokePath (tick, PathStrokeType (2.5f), trans);
	}
}

void LookAndFeel::drawToggleButton (Graphics& g,
									ToggleButton& button,
									bool isMouseOverButton,
									bool isButtonDown)
{
	if (button.hasKeyboardFocus (true))
	{
		g.setColour (button.findColour (TextEditor::focusedOutlineColourId));
		g.drawRect (0, 0, button.getWidth(), button.getHeight());
	}

	float fontSize = jmin (15.0f, button.getHeight() * 0.75f);
	const float tickWidth = fontSize * 1.1f;

	drawTickBox (g, button, 4.0f, (button.getHeight() - tickWidth) * 0.5f,
				 tickWidth, tickWidth,
				 button.getToggleState(),
				 button.isEnabled(),
				 isMouseOverButton,
				 isButtonDown);

	g.setColour (button.findColour (ToggleButton::textColourId));
	g.setFont (fontSize);

	if (! button.isEnabled())
		g.setOpacity (0.5f);

	const int textX = (int) tickWidth + 5;

	g.drawFittedText (button.getButtonText(),
					  textX, 0,
					  button.getWidth() - textX - 2, button.getHeight(),
					  Justification::centredLeft, 10);
}

void LookAndFeel::changeToggleButtonWidthToFitText (ToggleButton& button)
{
	Font font (jmin (15.0f, button.getHeight() * 0.6f));

	const int tickWidth = jmin (24, button.getHeight());

	button.setSize (font.getStringWidth (button.getButtonText()) + tickWidth + 8,
					button.getHeight());
}

AlertWindow* LookAndFeel::createAlertWindow (const String& title,
											 const String& message,
											 const String& button1,
											 const String& button2,
											 const String& button3,
											 AlertWindow::AlertIconType iconType,
											 int numButtons,
											 Component* associatedComponent)
{
	AlertWindow* aw = new AlertWindow (title, message, iconType, associatedComponent);

	if (numButtons == 1)
	{
		aw->addButton (button1, 0,
					   KeyPress (KeyPress::escapeKey, 0, 0),
					   KeyPress (KeyPress::returnKey, 0, 0));
	}
	else
	{
		const KeyPress button1ShortCut ((int) CharacterFunctions::toLowerCase (button1[0]), 0, 0);
		KeyPress button2ShortCut ((int) CharacterFunctions::toLowerCase (button2[0]), 0, 0);
		if (button1ShortCut == button2ShortCut)
			button2ShortCut = KeyPress();

		if (numButtons == 2)
		{
			aw->addButton (button1, 1, KeyPress (KeyPress::returnKey, 0, 0), button1ShortCut);
			aw->addButton (button2, 0, KeyPress (KeyPress::escapeKey, 0, 0), button2ShortCut);
		}
		else if (numButtons == 3)
		{
			aw->addButton (button1, 1, button1ShortCut);
			aw->addButton (button2, 2, button2ShortCut);
			aw->addButton (button3, 0, KeyPress (KeyPress::escapeKey, 0, 0));
		}
	}

	return aw;
}

void LookAndFeel::drawAlertBox (Graphics& g,
								AlertWindow& alert,
								const Rectangle<int>& textArea,
								TextLayout& textLayout)
{
	g.fillAll (alert.findColour (AlertWindow::backgroundColourId));

	int iconSpaceUsed = 0;

	const int iconWidth = 80;
	int iconSize = jmin (iconWidth + 50, alert.getHeight() + 20);

	if (alert.containsAnyExtraComponents() || alert.getNumButtons() > 2)
		iconSize = jmin (iconSize, textArea.getHeight() + 50);

	const Rectangle<int> iconRect (iconSize / -10, iconSize / -10,
								   iconSize, iconSize);

	if (alert.getAlertType() != AlertWindow::NoIcon)
	{
		Path icon;
		uint32 colour;
		char character;

		if (alert.getAlertType() == AlertWindow::WarningIcon)
		{
			colour = 0x55ff5555;
			character = '!';

			icon.addTriangle (iconRect.getX() + iconRect.getWidth() * 0.5f, (float) iconRect.getY(),
							  (float) iconRect.getRight(), (float) iconRect.getBottom(),
							  (float) iconRect.getX(), (float) iconRect.getBottom());

			icon = icon.createPathWithRoundedCorners (5.0f);
		}
		else
		{
			colour    = alert.getAlertType() == AlertWindow::InfoIcon ? (uint32) 0x605555ff : (uint32) 0x40b69900;
			character = alert.getAlertType() == AlertWindow::InfoIcon ? 'i' : '?';

			icon.addEllipse ((float) iconRect.getX(), (float) iconRect.getY(),
							 (float) iconRect.getWidth(), (float) iconRect.getHeight());
		}

		GlyphArrangement ga;
		ga.addFittedText (Font (iconRect.getHeight() * 0.9f, Font::bold),
						  String::charToString ((juce_wchar) (uint8) character),
						  (float) iconRect.getX(), (float) iconRect.getY(),
						  (float) iconRect.getWidth(), (float) iconRect.getHeight(),
						  Justification::centred, false);
		ga.createPath (icon);

		icon.setUsingNonZeroWinding (false);
		g.setColour (Colour (colour));
		g.fillPath (icon);

		iconSpaceUsed = iconWidth;
	}

	g.setColour (alert.findColour (AlertWindow::textColourId));

	textLayout.draw (g, Rectangle<int> (textArea.getX() + iconSpaceUsed,
										textArea.getY(),
										textArea.getWidth() - iconSpaceUsed,
										textArea.getHeight()).toFloat());

	g.setColour (alert.findColour (AlertWindow::outlineColourId));
	g.drawRect (0, 0, alert.getWidth(), alert.getHeight());
}

int LookAndFeel::getAlertBoxWindowFlags()
{
	return ComponentPeer::windowAppearsOnTaskbar
			| ComponentPeer::windowHasDropShadow;
}

int LookAndFeel::getAlertWindowButtonHeight()
{
	return 28;
}

const Font LookAndFeel::getAlertWindowMessageFont()
{
	return Font (15.0f);
}

const Font LookAndFeel::getAlertWindowFont()
{
	return Font (12.0f);
}

void LookAndFeel::setUsingNativeAlertWindows (bool shouldUseNativeAlerts)
{
	useNativeAlertWindows = shouldUseNativeAlerts;
}

bool LookAndFeel::isUsingNativeAlertWindows()
{
   #if JUCE_LINUX
	return false; // not available currently..
   #else
	return useNativeAlertWindows;
   #endif
}

void LookAndFeel::drawProgressBar (Graphics& g, ProgressBar& progressBar,
								   int width, int height,
								   double progress, const String& textToShow)
{
	const Colour background (progressBar.findColour (ProgressBar::backgroundColourId));
	const Colour foreground (progressBar.findColour (ProgressBar::foregroundColourId));

	g.fillAll (background);

	if (progress >= 0.0f && progress < 1.0f)
	{
		drawGlassLozenge (g, 1.0f, 1.0f,
						  (float) jlimit (0.0, width - 2.0, progress * (width - 2.0)),
						  (float) (height - 2),
						  foreground,
						  0.5f, 0.0f,
						  true, true, true, true);
	}
	else
	{
		// spinning bar..
		g.setColour (foreground);

		const int stripeWidth = height * 2;
		const int position = (int) (Time::getMillisecondCounter() / 15) % stripeWidth;

		Path p;

		for (float x = (float) (- position); x < width + stripeWidth; x += stripeWidth)
			p.addQuadrilateral (x, 0.0f,
								x + stripeWidth * 0.5f, 0.0f,
								x, (float) height,
								x - stripeWidth * 0.5f, (float) height);

		Image im (Image::ARGB, width, height, true);

		{
			Graphics g2 (im);
			drawGlassLozenge (g2, 1.0f, 1.0f,
							  (float) (width - 2),
							  (float) (height - 2),
							  foreground,
							  0.5f, 0.0f,
							  true, true, true, true);
		}

		g.setTiledImageFill (im, 0, 0, 0.85f);
		g.fillPath (p);
	}

	if (textToShow.isNotEmpty())
	{
		g.setColour (Colour::contrasting (background, foreground));
		g.setFont (height * 0.6f);

		g.drawText (textToShow, 0, 0, width, height, Justification::centred, false);
	}
}

void LookAndFeel::drawSpinningWaitAnimation (Graphics& g, const Colour& colour, int x, int y, int w, int h)
{
	const float radius = jmin (w, h) * 0.4f;
	const float thickness = radius * 0.15f;
	Path p;
	p.addRoundedRectangle (radius * 0.4f, thickness * -0.5f,
						   radius * 0.6f, thickness,
						   thickness * 0.5f);

	const float cx = x + w * 0.5f;
	const float cy = y + h * 0.5f;

	const uint32 animationIndex = (Time::getMillisecondCounter() / (1000 / 10)) % 12;

	for (uint32 i = 0; i < 12; ++i)
	{
		const uint32 n = (i + 12 - animationIndex) % 12;
		g.setColour (colour.withMultipliedAlpha ((n + 1) / 12.0f));

		g.fillPath (p, AffineTransform::rotation (i * (float_Pi / 6.0f))
									   .translated (cx, cy));
	}
}

void LookAndFeel::drawScrollbarButton (Graphics& g,
									   ScrollBar& scrollbar,
									   int width, int height,
									   int buttonDirection,
									   bool /*isScrollbarVertical*/,
									   bool /*isMouseOverButton*/,
									   bool isButtonDown)
{
	Path p;

	if (buttonDirection == 0)
		p.addTriangle (width * 0.5f, height * 0.2f,
					   width * 0.1f, height * 0.7f,
					   width * 0.9f, height * 0.7f);
	else if (buttonDirection == 1)
		p.addTriangle (width * 0.8f, height * 0.5f,
					   width * 0.3f, height * 0.1f,
					   width * 0.3f, height * 0.9f);
	else if (buttonDirection == 2)
		p.addTriangle (width * 0.5f, height * 0.8f,
					   width * 0.1f, height * 0.3f,
					   width * 0.9f, height * 0.3f);
	else if (buttonDirection == 3)
		p.addTriangle (width * 0.2f, height * 0.5f,
					   width * 0.7f, height * 0.1f,
					   width * 0.7f, height * 0.9f);

	if (isButtonDown)
		g.setColour (scrollbar.findColour (ScrollBar::thumbColourId).contrasting (0.2f));
	else
		g.setColour (scrollbar.findColour (ScrollBar::thumbColourId));

	g.fillPath (p);

	g.setColour (Colour (0x80000000));
	g.strokePath (p, PathStrokeType (0.5f));
}

void LookAndFeel::drawScrollbar (Graphics& g,
								 ScrollBar& scrollbar,
								 int x, int y,
								 int width, int height,
								 bool isScrollbarVertical,
								 int thumbStartPosition,
								 int thumbSize,
								 bool /*isMouseOver*/,
								 bool /*isMouseDown*/)
{
	g.fillAll (scrollbar.findColour (ScrollBar::backgroundColourId));

	Path slotPath, thumbPath;

	const float slotIndent = jmin (width, height) > 15 ? 1.0f : 0.0f;
	const float slotIndentx2 = slotIndent * 2.0f;
	const float thumbIndent = slotIndent + 1.0f;
	const float thumbIndentx2 = thumbIndent * 2.0f;

	float gx1 = 0.0f, gy1 = 0.0f, gx2 = 0.0f, gy2 = 0.0f;

	if (isScrollbarVertical)
	{
		slotPath.addRoundedRectangle (x + slotIndent,
									  y + slotIndent,
									  width - slotIndentx2,
									  height - slotIndentx2,
									  (width - slotIndentx2) * 0.5f);

		if (thumbSize > 0)
			thumbPath.addRoundedRectangle (x + thumbIndent,
										   thumbStartPosition + thumbIndent,
										   width - thumbIndentx2,
										   thumbSize - thumbIndentx2,
										   (width - thumbIndentx2) * 0.5f);
		gx1 = (float) x;
		gx2 = x + width * 0.7f;
	}
	else
	{
		slotPath.addRoundedRectangle (x + slotIndent,
									  y + slotIndent,
									  width - slotIndentx2,
									  height - slotIndentx2,
									  (height - slotIndentx2) * 0.5f);

		if (thumbSize > 0)
			thumbPath.addRoundedRectangle (thumbStartPosition + thumbIndent,
										   y + thumbIndent,
										   thumbSize - thumbIndentx2,
										   height - thumbIndentx2,
										   (height - thumbIndentx2) * 0.5f);
		gy1 = (float) y;
		gy2 = y + height * 0.7f;
	}

	const Colour thumbColour (scrollbar.findColour (ScrollBar::thumbColourId));
	Colour trackColour1, trackColour2;

	if (scrollbar.isColourSpecified (ScrollBar::trackColourId)
		 || isColourSpecified (ScrollBar::trackColourId))
	{
		trackColour1 = trackColour2 = scrollbar.findColour (ScrollBar::trackColourId);
	}
	else
	{
		trackColour1 = thumbColour.overlaidWith (Colour (0x44000000));
		trackColour2 = thumbColour.overlaidWith (Colour (0x19000000));
	}

	g.setGradientFill (ColourGradient (trackColour1, gx1, gy1,
									   trackColour2, gx2, gy2, false));
	g.fillPath (slotPath);

	if (isScrollbarVertical)
	{
		gx1 = x + width * 0.6f;
		gx2 = (float) x + width;
	}
	else
	{
		gy1 = y + height * 0.6f;
		gy2 = (float) y + height;
	}

	g.setGradientFill (ColourGradient (Colours::transparentBlack,gx1, gy1,
					   Colour (0x19000000), gx2, gy2, false));
	g.fillPath (slotPath);

	g.setColour (thumbColour);
	g.fillPath (thumbPath);

	g.setGradientFill (ColourGradient (Colour (0x10000000), gx1, gy1,
					   Colours::transparentBlack, gx2, gy2, false));

	g.saveState();

	if (isScrollbarVertical)
		g.reduceClipRegion (x + width / 2, y, width, height);
	else
		g.reduceClipRegion (x, y + height / 2, width, height);

	g.fillPath (thumbPath);
	g.restoreState();

	g.setColour (Colour (0x4c000000));
	g.strokePath (thumbPath, PathStrokeType (0.4f));
}

ImageEffectFilter* LookAndFeel::getScrollbarEffect()
{
	return nullptr;
}

int LookAndFeel::getMinimumScrollbarThumbSize (ScrollBar& scrollbar)
{
	return jmin (scrollbar.getWidth(), scrollbar.getHeight()) * 2;
}

int LookAndFeel::getDefaultScrollbarWidth()
{
	return 18;
}

int LookAndFeel::getScrollbarButtonSize (ScrollBar& scrollbar)
{
	return 2 + (scrollbar.isVertical() ? scrollbar.getWidth()
									   : scrollbar.getHeight());
}

const Path LookAndFeel::getTickShape (const float height)
{
	static const unsigned char tickShapeData[] =
	{
		109,0,224,168,68,0,0,119,67,108,0,224,172,68,0,128,146,67,113,0,192,148,68,0,0,219,67,0,96,110,68,0,224,56,68,113,0,64,51,68,0,32,130,68,0,64,20,68,0,224,
		162,68,108,0,128,3,68,0,128,168,68,113,0,128,221,67,0,192,175,68,0,0,207,67,0,32,179,68,113,0,0,201,67,0,224,173,68,0,0,181,67,0,224,161,68,108,0,128,168,67,
		0,128,154,68,113,0,128,141,67,0,192,138,68,0,128,108,67,0,64,131,68,113,0,0,62,67,0,128,119,68,0,0,5,67,0,128,114,68,113,0,0,102,67,0,192,88,68,0,128,155,
		67,0,192,88,68,113,0,0,190,67,0,192,88,68,0,128,232,67,0,224,131,68,108,0,128,246,67,0,192,139,68,113,0,64,33,68,0,128,87,68,0,0,93,68,0,224,26,68,113,0,
		96,140,68,0,128,188,67,0,224,168,68,0,0,119,67,99,101
	};

	Path p;
	p.loadPathFromData (tickShapeData, sizeof (tickShapeData));
	p.scaleToFit (0, 0, height * 2.0f, height, true);
	return p;
}

const Path LookAndFeel::getCrossShape (const float height)
{
	static const unsigned char crossShapeData[] =
	{
		109,0,0,17,68,0,96,145,68,108,0,192,13,68,0,192,147,68,113,0,0,213,67,0,64,174,68,0,0,168,67,0,64,174,68,113,0,0,104,67,0,64,174,68,0,0,5,67,0,64,
		153,68,113,0,0,18,67,0,64,153,68,0,0,24,67,0,64,153,68,113,0,0,135,67,0,64,153,68,0,128,207,67,0,224,130,68,108,0,0,220,67,0,0,126,68,108,0,0,204,67,
		0,128,117,68,113,0,0,138,67,0,64,82,68,0,0,138,67,0,192,57,68,113,0,0,138,67,0,192,37,68,0,128,210,67,0,64,10,68,113,0,128,220,67,0,64,45,68,0,0,8,
		68,0,128,78,68,108,0,192,14,68,0,0,87,68,108,0,64,20,68,0,0,80,68,113,0,192,57,68,0,0,32,68,0,128,88,68,0,0,32,68,113,0,64,112,68,0,0,32,68,0,
		128,124,68,0,64,68,68,113,0,0,121,68,0,192,67,68,0,128,119,68,0,192,67,68,113,0,192,108,68,0,192,67,68,0,32,89,68,0,96,82,68,113,0,128,69,68,0,0,97,68,
		0,0,56,68,0,64,115,68,108,0,64,49,68,0,128,124,68,108,0,192,55,68,0,96,129,68,113,0,0,92,68,0,224,146,68,0,192,129,68,0,224,146,68,113,0,64,110,68,0,64,
		168,68,0,64,87,68,0,64,168,68,113,0,128,66,68,0,64,168,68,0,64,27,68,0,32,150,68,99,101
	};

	Path p;
	p.loadPathFromData (crossShapeData, sizeof (crossShapeData));
	p.scaleToFit (0, 0, height * 2.0f, height, true);
	return p;
}

void LookAndFeel::drawTreeviewPlusMinusBox (Graphics& g, int x, int y, int w, int h, bool isPlus, bool /*isMouseOver*/)
{
	const int boxSize = ((jmin (16, w, h) << 1) / 3) | 1;

	x += (w - boxSize) >> 1;
	y += (h - boxSize) >> 1;
	w = boxSize;
	h = boxSize;

	g.setColour (Colour (0xe5ffffff));
	g.fillRect (x, y, w, h);

	g.setColour (Colour (0x80000000));
	g.drawRect (x, y, w, h);

	const float size = boxSize / 2 + 1.0f;
	const float centre = (float) (boxSize / 2);

	g.fillRect (x + (w - size) * 0.5f, y + centre, size, 1.0f);

	if (isPlus)
		g.fillRect (x + centre, y + (h - size) * 0.5f, 1.0f, size);
}

void LookAndFeel::drawBubble (Graphics& g,
							  float tipX, float tipY,
							  float boxX, float boxY,
							  float boxW, float boxH)
{
	int side = 0;

	if (tipX < boxX)
		side = 1;
	else if (tipX > boxX + boxW)
		side = 3;
	else if (tipY > boxY + boxH)
		side = 2;

	const float indent = 2.0f;
	Path p;
	p.addBubble (boxX + indent,
				 boxY + indent,
				 boxW - indent * 2.0f,
				 boxH - indent * 2.0f,
				 5.0f,
				 tipX, tipY,
				 side,
				 0.5f,
				 jmin (15.0f, boxW * 0.3f, boxH * 0.3f));

	//xxx need to take comp as param for colour
	g.setColour (findColour (TooltipWindow::backgroundColourId).withAlpha (0.9f));
	g.fillPath (p);

	//xxx as above
	g.setColour (findColour (TooltipWindow::textColourId).withAlpha (0.4f));
	g.strokePath (p, PathStrokeType (1.33f));
}

const Font LookAndFeel::getPopupMenuFont()
{
	return Font (17.0f);
}

void LookAndFeel::getIdealPopupMenuItemSize (const String& text,
											 const bool isSeparator,
											 int standardMenuItemHeight,
											 int& idealWidth,
											 int& idealHeight)
{
	if (isSeparator)
	{
		idealWidth = 50;
		idealHeight = standardMenuItemHeight > 0 ? standardMenuItemHeight / 2 : 10;
	}
	else
	{
		Font font (getPopupMenuFont());

		if (standardMenuItemHeight > 0 && font.getHeight() > standardMenuItemHeight / 1.3f)
			font.setHeight (standardMenuItemHeight / 1.3f);

		idealHeight = standardMenuItemHeight > 0 ? standardMenuItemHeight : roundToInt (font.getHeight() * 1.3f);
		idealWidth = font.getStringWidth (text) + idealHeight * 2;
	}
}

void LookAndFeel::drawPopupMenuBackground (Graphics& g, int width, int height)
{
	const Colour background (findColour (PopupMenu::backgroundColourId));

	g.fillAll (background);
	g.setColour (background.overlaidWith (Colour (0x2badd8e6)));

	for (int i = 0; i < height; i += 3)
		g.fillRect (0, i, width, 1);

#if ! JUCE_MAC
	g.setColour (findColour (PopupMenu::textColourId).withAlpha (0.6f));
	g.drawRect (0, 0, width, height);
#endif
}

void LookAndFeel::drawPopupMenuUpDownArrow (Graphics& g,
											int width, int height,
											bool isScrollUpArrow)
{
	const Colour background (findColour (PopupMenu::backgroundColourId));

	g.setGradientFill (ColourGradient (background, 0.0f, height * 0.5f,
									   background.withAlpha (0.0f),
									   0.0f, isScrollUpArrow ? ((float) height) : 0.0f,
									   false));

	g.fillRect (1, 1, width - 2, height - 2);

	const float hw = width * 0.5f;
	const float arrowW = height * 0.3f;
	const float y1 = height * (isScrollUpArrow ? 0.6f : 0.3f);
	const float y2 = height * (isScrollUpArrow ? 0.3f : 0.6f);

	Path p;
	p.addTriangle (hw - arrowW, y1,
				   hw + arrowW, y1,
				   hw, y2);

	g.setColour (findColour (PopupMenu::textColourId).withAlpha (0.5f));
	g.fillPath (p);
}

void LookAndFeel::drawPopupMenuItem (Graphics& g,
									 int width, int height,
									 const bool isSeparator,
									 const bool isActive,
									 const bool isHighlighted,
									 const bool isTicked,
									 const bool hasSubMenu,
									 const String& text,
									 const String& shortcutKeyText,
									 Image* image,
									 const Colour* const textColourToUse)
{
	const float halfH = height * 0.5f;

	if (isSeparator)
	{
		const float separatorIndent = 5.5f;

		g.setColour (Colour (0x33000000));
		g.drawLine (separatorIndent, halfH, width - separatorIndent, halfH);

		g.setColour (Colour (0x66ffffff));
		g.drawLine (separatorIndent, halfH + 1.0f, width - separatorIndent, halfH + 1.0f);
	}
	else
	{
		Colour textColour (findColour (PopupMenu::textColourId));

		if (textColourToUse != nullptr)
			textColour = *textColourToUse;

		if (isHighlighted)
		{
			g.setColour (findColour (PopupMenu::highlightedBackgroundColourId));
			g.fillRect (1, 1, width - 2, height - 2);

			g.setColour (findColour (PopupMenu::highlightedTextColourId));
		}
		else
		{
			g.setColour (textColour);
		}

		if (! isActive)
			g.setOpacity (0.3f);

		Font font (getPopupMenuFont());

		if (font.getHeight() > height / 1.3f)
			font.setHeight (height / 1.3f);

		g.setFont (font);

		const int leftBorder = (height * 5) / 4;
		const int rightBorder = 4;

		if (image != nullptr)
		{
			g.drawImageWithin (*image,
							   2, 1, leftBorder - 4, height - 2,
							   RectanglePlacement::centred | RectanglePlacement::onlyReduceInSize, false);
		}
		else if (isTicked)
		{
			const Path tick (getTickShape (1.0f));
			const float th = font.getAscent();
			const float ty = halfH - th * 0.5f;

			g.fillPath (tick, tick.getTransformToScaleToFit (2.0f, ty, (float) (leftBorder - 4),
															 th, true));
		}

		g.drawFittedText (text,
						  leftBorder, 0,
						  width - (leftBorder + rightBorder), height,
						  Justification::centredLeft, 1);

		if (shortcutKeyText.isNotEmpty())
		{
			Font f2 (font);
			f2.setHeight (f2.getHeight() * 0.75f);
			f2.setHorizontalScale (0.95f);
			g.setFont (f2);

			g.drawText (shortcutKeyText,
						leftBorder,
						0,
						width - (leftBorder + rightBorder + 4),
						height,
						Justification::centredRight,
						true);
		}

		if (hasSubMenu)
		{
			const float arrowH = 0.6f * getPopupMenuFont().getAscent();
			const float x = width - height * 0.6f;

			Path p;
			p.addTriangle (x, halfH - arrowH * 0.5f,
						   x, halfH + arrowH * 0.5f,
						   x + arrowH * 0.6f, halfH);

			g.fillPath (p);
		}
	}
}

int LookAndFeel::getMenuWindowFlags()
{
	return ComponentPeer::windowHasDropShadow;
}

void LookAndFeel::drawMenuBarBackground (Graphics& g, int width, int height,
										 bool, MenuBarComponent& menuBar)
{
	const Colour baseColour (LookAndFeelHelpers::createBaseColour (menuBar.findColour (PopupMenu::backgroundColourId), false, false, false));

	if (menuBar.isEnabled())
	{
		drawShinyButtonShape (g,
							  -4.0f, 0.0f,
							  width + 8.0f, (float) height,
							  0.0f,
							  baseColour,
							  0.4f,
							  true, true, true, true);
	}
	else
	{
		g.fillAll (baseColour);
	}
}

const Font LookAndFeel::getMenuBarFont (MenuBarComponent& menuBar, int /*itemIndex*/, const String& /*itemText*/)
{
	return Font (menuBar.getHeight() * 0.7f);
}

int LookAndFeel::getMenuBarItemWidth (MenuBarComponent& menuBar, int itemIndex, const String& itemText)
{
	return getMenuBarFont (menuBar, itemIndex, itemText)
			.getStringWidth (itemText) + menuBar.getHeight();
}

void LookAndFeel::drawMenuBarItem (Graphics& g,
								   int width, int height,
								   int itemIndex,
								   const String& itemText,
								   bool isMouseOverItem,
								   bool isMenuOpen,
								   bool /*isMouseOverBar*/,
								   MenuBarComponent& menuBar)
{
	if (! menuBar.isEnabled())
	{
		g.setColour (menuBar.findColour (PopupMenu::textColourId)
							.withMultipliedAlpha (0.5f));
	}
	else if (isMenuOpen || isMouseOverItem)
	{
		g.fillAll (menuBar.findColour (PopupMenu::highlightedBackgroundColourId));
		g.setColour (menuBar.findColour (PopupMenu::highlightedTextColourId));
	}
	else
	{
		g.setColour (menuBar.findColour (PopupMenu::textColourId));
	}

	g.setFont (getMenuBarFont (menuBar, itemIndex, itemText));
	g.drawFittedText (itemText, 0, 0, width, height, Justification::centred, 1);
}

void LookAndFeel::fillTextEditorBackground (Graphics& g, int /*width*/, int /*height*/,
											TextEditor& textEditor)
{
	g.fillAll (textEditor.findColour (TextEditor::backgroundColourId));
}

void LookAndFeel::drawTextEditorOutline (Graphics& g, int width, int height, TextEditor& textEditor)
{
	if (textEditor.isEnabled())
	{
		if (textEditor.hasKeyboardFocus (true) && ! textEditor.isReadOnly())
		{
			const int border = 2;

			g.setColour (textEditor.findColour (TextEditor::focusedOutlineColourId));
			g.drawRect (0, 0, width, height, border);

			g.setOpacity (1.0f);
			const Colour shadowColour (textEditor.findColour (TextEditor::shadowColourId).withMultipliedAlpha (0.75f));
			g.drawBevel (0, 0, width, height + 2, border + 2, shadowColour, shadowColour);
		}
		else
		{
			g.setColour (textEditor.findColour (TextEditor::outlineColourId));
			g.drawRect (0, 0, width, height);

			g.setOpacity (1.0f);
			const Colour shadowColour (textEditor.findColour (TextEditor::shadowColourId));
			g.drawBevel (0, 0, width, height + 2, 3, shadowColour, shadowColour);
		}
	}
}

CaretComponent* LookAndFeel::createCaretComponent (Component* keyFocusOwner)
{
	return new CaretComponent (keyFocusOwner);
}

void LookAndFeel::drawComboBox (Graphics& g, int width, int height,
								const bool isButtonDown,
								int buttonX, int buttonY,
								int buttonW, int buttonH,
								ComboBox& box)
{
	g.fillAll (box.findColour (ComboBox::backgroundColourId));

	if (box.isEnabled() && box.hasKeyboardFocus (false))
	{
		g.setColour (box.findColour (TextButton::buttonColourId));
		g.drawRect (0, 0, width, height, 2);
	}
	else
	{
		g.setColour (box.findColour (ComboBox::outlineColourId));
		g.drawRect (0, 0, width, height);
	}

	const float outlineThickness = box.isEnabled() ? (isButtonDown ? 1.2f : 0.5f) : 0.3f;

	const Colour baseColour (LookAndFeelHelpers::createBaseColour (box.findColour (ComboBox::buttonColourId),
																   box.hasKeyboardFocus (true),
																   false, isButtonDown)
								.withMultipliedAlpha (box.isEnabled() ? 1.0f : 0.5f));

	drawGlassLozenge (g,
					  buttonX + outlineThickness, buttonY + outlineThickness,
					  buttonW - outlineThickness * 2.0f, buttonH - outlineThickness * 2.0f,
					  baseColour, outlineThickness, -1.0f,
					  true, true, true, true);

	if (box.isEnabled())
	{
		const float arrowX = 0.3f;
		const float arrowH = 0.2f;

		Path p;
		p.addTriangle (buttonX + buttonW * 0.5f,            buttonY + buttonH * (0.45f - arrowH),
					   buttonX + buttonW * (1.0f - arrowX), buttonY + buttonH * 0.45f,
					   buttonX + buttonW * arrowX,          buttonY + buttonH * 0.45f);

		p.addTriangle (buttonX + buttonW * 0.5f,            buttonY + buttonH * (0.55f + arrowH),
					   buttonX + buttonW * (1.0f - arrowX), buttonY + buttonH * 0.55f,
					   buttonX + buttonW * arrowX,          buttonY + buttonH * 0.55f);

		g.setColour (box.findColour (ComboBox::arrowColourId));
		g.fillPath (p);
	}
}

const Font LookAndFeel::getComboBoxFont (ComboBox& box)
{
	return Font (jmin (15.0f, box.getHeight() * 0.85f));
}

Label* LookAndFeel::createComboBoxTextBox (ComboBox&)
{
	return new Label (String::empty, String::empty);
}

void LookAndFeel::positionComboBoxText (ComboBox& box, Label& label)
{
	label.setBounds (1, 1,
					 box.getWidth() + 3 - box.getHeight(),
					 box.getHeight() - 2);

	label.setFont (getComboBoxFont (box));
}

void LookAndFeel::drawLabel (Graphics& g, Label& label)
{
	g.fillAll (label.findColour (Label::backgroundColourId));

	if (! label.isBeingEdited())
	{
		const float alpha = label.isEnabled() ? 1.0f : 0.5f;

		g.setColour (label.findColour (Label::textColourId).withMultipliedAlpha (alpha));
		g.setFont (label.getFont());
		g.drawFittedText (label.getText(),
						  label.getHorizontalBorderSize(),
						  label.getVerticalBorderSize(),
						  label.getWidth() - 2 * label.getHorizontalBorderSize(),
						  label.getHeight() - 2 * label.getVerticalBorderSize(),
						  label.getJustificationType(),
						  jmax (1, (int) (label.getHeight() / label.getFont().getHeight())),
						  label.getMinimumHorizontalScale());

		g.setColour (label.findColour (Label::outlineColourId).withMultipliedAlpha (alpha));
		g.drawRect (0, 0, label.getWidth(), label.getHeight());
	}
	else if (label.isEnabled())
	{
		g.setColour (label.findColour (Label::outlineColourId));
		g.drawRect (0, 0, label.getWidth(), label.getHeight());
	}
}

void LookAndFeel::drawLinearSliderBackground (Graphics& g,
											  int x, int y,
											  int width, int height,
											  float /*sliderPos*/,
											  float /*minSliderPos*/,
											  float /*maxSliderPos*/,
											  const Slider::SliderStyle /*style*/,
											  Slider& slider)
{
	const float sliderRadius = (float) (getSliderThumbRadius (slider) - 2);

	const Colour trackColour (slider.findColour (Slider::trackColourId));
	const Colour gradCol1 (trackColour.overlaidWith (Colours::black.withAlpha (slider.isEnabled() ? 0.25f : 0.13f)));
	const Colour gradCol2 (trackColour.overlaidWith (Colour (0x14000000)));
	Path indent;

	if (slider.isHorizontal())
	{
		const float iy = y + height * 0.5f - sliderRadius * 0.5f;
		const float ih = sliderRadius;

		g.setGradientFill (ColourGradient (gradCol1, 0.0f, iy,
										   gradCol2, 0.0f, iy + ih, false));

		indent.addRoundedRectangle (x - sliderRadius * 0.5f, iy,
									width + sliderRadius, ih,
									5.0f);
		g.fillPath (indent);
	}
	else
	{
		const float ix = x + width * 0.5f - sliderRadius * 0.5f;
		const float iw = sliderRadius;

		g.setGradientFill (ColourGradient (gradCol1, ix, 0.0f,
										   gradCol2, ix + iw, 0.0f, false));

		indent.addRoundedRectangle (ix, y - sliderRadius * 0.5f,
									iw, height + sliderRadius,
									5.0f);
		g.fillPath (indent);
	}

	g.setColour (Colour (0x4c000000));
	g.strokePath (indent, PathStrokeType (0.5f));
}

void LookAndFeel::drawLinearSliderThumb (Graphics& g,
										 int x, int y,
										 int width, int height,
										 float sliderPos,
										 float minSliderPos,
										 float maxSliderPos,
										 const Slider::SliderStyle style,
										 Slider& slider)
{
	const float sliderRadius = (float) (getSliderThumbRadius (slider) - 2);

	Colour knobColour (LookAndFeelHelpers::createBaseColour (slider.findColour (Slider::thumbColourId),
															 slider.hasKeyboardFocus (false) && slider.isEnabled(),
															 slider.isMouseOverOrDragging() && slider.isEnabled(),
															 slider.isMouseButtonDown() && slider.isEnabled()));

	const float outlineThickness = slider.isEnabled() ? 0.8f : 0.3f;

	if (style == Slider::LinearHorizontal || style == Slider::LinearVertical)
	{
		float kx, ky;

		if (style == Slider::LinearVertical)
		{
			kx = x + width * 0.5f;
			ky = sliderPos;
		}
		else
		{
			kx = sliderPos;
			ky = y + height * 0.5f;
		}

		drawGlassSphere (g,
						 kx - sliderRadius,
						 ky - sliderRadius,
						 sliderRadius * 2.0f,
						 knobColour, outlineThickness);
	}
	else
	{
		if (style == Slider::ThreeValueVertical)
		{
			drawGlassSphere (g, x + width * 0.5f - sliderRadius,
							 sliderPos - sliderRadius,
							 sliderRadius * 2.0f,
							 knobColour, outlineThickness);
		}
		else if (style == Slider::ThreeValueHorizontal)
		{
			drawGlassSphere (g,sliderPos - sliderRadius,
							 y + height * 0.5f - sliderRadius,
							 sliderRadius * 2.0f,
							 knobColour, outlineThickness);
		}

		if (style == Slider::TwoValueVertical || style == Slider::ThreeValueVertical)
		{
			const float sr = jmin (sliderRadius, width * 0.4f);

			drawGlassPointer (g, jmax (0.0f, x + width * 0.5f - sliderRadius * 2.0f),
							  minSliderPos - sliderRadius,
							  sliderRadius * 2.0f, knobColour, outlineThickness, 1);

			drawGlassPointer (g, jmin (x + width - sliderRadius * 2.0f, x + width * 0.5f), maxSliderPos - sr,
							  sliderRadius * 2.0f, knobColour, outlineThickness, 3);
		}
		else if (style == Slider::TwoValueHorizontal || style == Slider::ThreeValueHorizontal)
		{
			const float sr = jmin (sliderRadius, height * 0.4f);

			drawGlassPointer (g, minSliderPos - sr,
							  jmax (0.0f, y + height * 0.5f - sliderRadius * 2.0f),
							  sliderRadius * 2.0f, knobColour, outlineThickness, 2);

			drawGlassPointer (g, maxSliderPos - sliderRadius,
							  jmin (y + height - sliderRadius * 2.0f, y + height * 0.5f),
							  sliderRadius * 2.0f, knobColour, outlineThickness, 4);
		}
	}
}

void LookAndFeel::drawLinearSlider (Graphics& g,
									int x, int y,
									int width, int height,
									float sliderPos,
									float minSliderPos,
									float maxSliderPos,
									const Slider::SliderStyle style,
									Slider& slider)
{
	g.fillAll (slider.findColour (Slider::backgroundColourId));

	if (style == Slider::LinearBar)
	{
		const bool isMouseOver = slider.isMouseOverOrDragging() && slider.isEnabled();

		Colour baseColour (LookAndFeelHelpers::createBaseColour (slider.findColour (Slider::thumbColourId)
																	   .withMultipliedSaturation (slider.isEnabled() ? 1.0f : 0.5f),
																 false, isMouseOver,
																 isMouseOver || slider.isMouseButtonDown()));

		drawShinyButtonShape (g,
							  (float) x, (float) y, sliderPos - (float) x, (float) height, 0.0f,
							  baseColour,
							  slider.isEnabled() ? 0.9f : 0.3f,
							  true, true, true, true);
	}
	else
	{
		drawLinearSliderBackground (g, x, y, width, height, sliderPos, minSliderPos, maxSliderPos, style, slider);
		drawLinearSliderThumb (g, x, y, width, height, sliderPos, minSliderPos, maxSliderPos, style, slider);
	}
}

int LookAndFeel::getSliderThumbRadius (Slider& slider)
{
	return jmin (7,
				 slider.getHeight() / 2,
				 slider.getWidth() / 2) + 2;
}

void LookAndFeel::drawRotarySlider (Graphics& g,
									int x, int y,
									int width, int height,
									float sliderPos,
									const float rotaryStartAngle,
									const float rotaryEndAngle,
									Slider& slider)
{
	const float radius = jmin (width / 2, height / 2) - 2.0f;
	const float centreX = x + width * 0.5f;
	const float centreY = y + height * 0.5f;
	const float rx = centreX - radius;
	const float ry = centreY - radius;
	const float rw = radius * 2.0f;
	const float angle = rotaryStartAngle + sliderPos * (rotaryEndAngle - rotaryStartAngle);
	const bool isMouseOver = slider.isMouseOverOrDragging() && slider.isEnabled();

	if (radius > 12.0f)
	{
		if (slider.isEnabled())
			g.setColour (slider.findColour (Slider::rotarySliderFillColourId).withAlpha (isMouseOver ? 1.0f : 0.7f));
		else
			g.setColour (Colour (0x80808080));

		const float thickness = 0.7f;

		{
			Path filledArc;
			filledArc.addPieSegment (rx, ry, rw, rw,
									rotaryStartAngle,
									angle,
									thickness);

			g.fillPath (filledArc);
		}

		if (thickness > 0)
		{
			const float innerRadius = radius * 0.2f;
			Path p;
			p.addTriangle (-innerRadius, 0.0f,
						   0.0f, -radius * thickness * 1.1f,
						   innerRadius, 0.0f);

			p.addEllipse (-innerRadius, -innerRadius, innerRadius * 2.0f, innerRadius * 2.0f);

			g.fillPath (p, AffineTransform::rotation (angle).translated (centreX, centreY));
		}

		if (slider.isEnabled())
			g.setColour (slider.findColour (Slider::rotarySliderOutlineColourId));
		else
			g.setColour (Colour (0x80808080));

		Path outlineArc;
		outlineArc.addPieSegment (rx, ry, rw, rw, rotaryStartAngle, rotaryEndAngle, thickness);
		outlineArc.closeSubPath();

		g.strokePath (outlineArc, PathStrokeType (slider.isEnabled() ? (isMouseOver ? 2.0f : 1.2f) : 0.3f));
	}
	else
	{
		if (slider.isEnabled())
			g.setColour (slider.findColour (Slider::rotarySliderFillColourId).withAlpha (isMouseOver ? 1.0f : 0.7f));
		else
			g.setColour (Colour (0x80808080));

		Path p;
		p.addEllipse (-0.4f * rw, -0.4f * rw, rw * 0.8f, rw * 0.8f);
		PathStrokeType (rw * 0.1f).createStrokedPath (p, p);

		p.addLineSegment (Line<float> (0.0f, 0.0f, 0.0f, -radius), rw * 0.2f);

		g.fillPath (p, AffineTransform::rotation (angle).translated (centreX, centreY));
	}
}

Button* LookAndFeel::createSliderButton (const bool isIncrement)
{
	return new TextButton (isIncrement ? "+" : "-", String::empty);
}

class SliderLabelComp : public Label
{
public:
	SliderLabelComp() : Label (String::empty, String::empty) {}

	void mouseWheelMove (const MouseEvent&, float, float) {}
};

Label* LookAndFeel::createSliderTextBox (Slider& slider)
{
	Label* const l = new SliderLabelComp();

	l->setJustificationType (Justification::centred);

	l->setColour (Label::textColourId, slider.findColour (Slider::textBoxTextColourId));

	l->setColour (Label::backgroundColourId,
				  (slider.getSliderStyle() == Slider::LinearBar) ? Colours::transparentBlack
																 : slider.findColour (Slider::textBoxBackgroundColourId));
	l->setColour (Label::outlineColourId, slider.findColour (Slider::textBoxOutlineColourId));

	l->setColour (TextEditor::textColourId, slider.findColour (Slider::textBoxTextColourId));

	l->setColour (TextEditor::backgroundColourId,
				  slider.findColour (Slider::textBoxBackgroundColourId)
						.withAlpha (slider.getSliderStyle() == Slider::LinearBar ? 0.7f : 1.0f));

	l->setColour (TextEditor::outlineColourId, slider.findColour (Slider::textBoxOutlineColourId));

	return l;
}

ImageEffectFilter* LookAndFeel::getSliderEffect()
{
	return nullptr;
}

void LookAndFeel::getTooltipSize (const String& tipText, int& width, int& height)
{
	const TextLayout tl (LookAndFeelHelpers::layoutTooltipText (tipText, Colours::black));

	width  = (int) (tl.getWidth() + 14.0f);
	height = (int) (tl.getHeight() + 6.0f);
}

void LookAndFeel::drawTooltip (Graphics& g, const String& text, int width, int height)
{
	g.fillAll (findColour (TooltipWindow::backgroundColourId));

   #if ! JUCE_MAC // The mac windows already have a non-optional 1 pix outline, so don't double it here..
	g.setColour (findColour (TooltipWindow::outlineColourId));
	g.drawRect (0, 0, width, height, 1);
   #endif

	const TextLayout tl (LookAndFeelHelpers::layoutTooltipText (text, findColour (TooltipWindow::textColourId)));
	tl.draw (g, Rectangle<float> ((float) width, (float) height));
}

Button* LookAndFeel::createFilenameComponentBrowseButton (const String& text)
{
	return new TextButton (text, TRANS("click to browse for a different file"));
}

void LookAndFeel::layoutFilenameComponent (FilenameComponent& filenameComp,
										   ComboBox* filenameBox,
										   Button* browseButton)
{
	browseButton->setSize (80, filenameComp.getHeight());

	TextButton* const tb = dynamic_cast <TextButton*> (browseButton);

	if (tb != nullptr)
		tb->changeWidthToFitText();

	browseButton->setTopRightPosition (filenameComp.getWidth(), 0);

	filenameBox->setBounds (0, 0, browseButton->getX(), filenameComp.getHeight());
}

void LookAndFeel::drawImageButton (Graphics& g, Image* image,
								   int imageX, int imageY, int imageW, int imageH,
								   const Colour& overlayColour,
								   float imageOpacity,
								   ImageButton& button)
{
	if (! button.isEnabled())
		imageOpacity *= 0.3f;

	if (! overlayColour.isOpaque())
	{
		g.setOpacity (imageOpacity);

		g.drawImage (*image, imageX, imageY, imageW, imageH,
					 0, 0, image->getWidth(), image->getHeight(), false);
	}

	if (! overlayColour.isTransparent())
	{
		g.setColour (overlayColour);

		g.drawImage (*image, imageX, imageY, imageW, imageH,
					 0, 0, image->getWidth(), image->getHeight(), true);
	}
}

void LookAndFeel::drawCornerResizer (Graphics& g,
									 int w, int h,
									 bool /*isMouseOver*/,
									 bool /*isMouseDragging*/)
{
	const float lineThickness = jmin (w, h) * 0.075f;

	for (float i = 0.0f; i < 1.0f; i += 0.3f)
	{
		g.setColour (Colours::lightgrey);

		g.drawLine (w * i,
					h + 1.0f,
					w + 1.0f,
					h * i,
					lineThickness);

		g.setColour (Colours::darkgrey);

		g.drawLine (w * i + lineThickness,
					h + 1.0f,
					w + 1.0f,
					h * i + lineThickness,
					lineThickness);
	}
}

void LookAndFeel::drawResizableFrame (Graphics& g, int w, int h, const BorderSize<int>& border)
{
	if (! border.isEmpty())
	{
		const Rectangle<int> fullSize (0, 0, w, h);
		const Rectangle<int> centreArea (border.subtractedFrom (fullSize));

		g.saveState();

		g.excludeClipRegion (centreArea);

		g.setColour (Colour (0x50000000));
		g.drawRect (fullSize);

		g.setColour (Colour (0x19000000));
		g.drawRect (centreArea.expanded (1, 1));

		g.restoreState();
	}
}

void LookAndFeel::fillResizableWindowBackground (Graphics& g, int /*w*/, int /*h*/,
												 const BorderSize<int>& /*border*/, ResizableWindow& window)
{
   g.fillAll (window.getBackgroundColour());
}

void LookAndFeel::drawResizableWindowBorder (Graphics&, int /*w*/, int /*h*/,
											 const BorderSize<int>& /*border*/, ResizableWindow&)
{
}

void LookAndFeel::drawDocumentWindowTitleBar (DocumentWindow& window,
											  Graphics& g, int w, int h,
											  int titleSpaceX, int titleSpaceW,
											  const Image* icon,
											  bool drawTitleTextOnLeft)
{
	const bool isActive = window.isActiveWindow();

	g.setGradientFill (ColourGradient (window.getBackgroundColour(),
									   0.0f, 0.0f,
									   window.getBackgroundColour().contrasting (isActive ? 0.15f : 0.05f),
									   0.0f, (float) h, false));
	g.fillAll();

	Font font (h * 0.65f, Font::bold);
	g.setFont (font);

	int textW = font.getStringWidth (window.getName());
	int iconW = 0;
	int iconH = 0;

	if (icon != nullptr)
	{
		iconH = (int) font.getHeight();
		iconW = icon->getWidth() * iconH / icon->getHeight() + 4;
	}

	textW = jmin (titleSpaceW, textW + iconW);
	int textX = drawTitleTextOnLeft ? titleSpaceX
									: jmax (titleSpaceX, (w - textW) / 2);

	if (textX + textW > titleSpaceX + titleSpaceW)
		textX = titleSpaceX + titleSpaceW - textW;

	if (icon != nullptr)
	{
		g.setOpacity (isActive ? 1.0f : 0.6f);
		g.drawImageWithin (*icon, textX, (h - iconH) / 2, iconW, iconH,
						   RectanglePlacement::centred, false);
		textX += iconW;
		textW -= iconW;
	}

	if (window.isColourSpecified (DocumentWindow::textColourId) || isColourSpecified (DocumentWindow::textColourId))
		g.setColour (findColour (DocumentWindow::textColourId));
	else
		g.setColour (window.getBackgroundColour().contrasting (isActive ? 0.7f : 0.4f));

	g.drawText (window.getName(), textX, 0, textW, h, Justification::centredLeft, true);
}

class GlassWindowButton   : public Button
{
public:

	GlassWindowButton (const String& name, const Colour& col,
					   const Path& normalShape_,
					   const Path& toggledShape_) noexcept
		: Button (name),
		  colour (col),
		  normalShape (normalShape_),
		  toggledShape (toggledShape_)
	{
	}

	~GlassWindowButton()
	{
	}

	void paintButton (Graphics& g, bool isMouseOverButton, bool isButtonDown)
	{
		float alpha = isMouseOverButton ? (isButtonDown ? 1.0f : 0.8f) : 0.55f;

		if (! isEnabled())
			alpha *= 0.5f;

		float x = 0, y = 0, diam;

		if (getWidth() < getHeight())
		{
			diam = (float) getWidth();
			y = (getHeight() - getWidth()) * 0.5f;
		}
		else
		{
			diam = (float) getHeight();
			y = (getWidth() - getHeight()) * 0.5f;
		}

		x += diam * 0.05f;
		y += diam * 0.05f;
		diam *= 0.9f;

		g.setGradientFill (ColourGradient (Colour::greyLevel (0.9f).withAlpha (alpha), 0, y + diam,
										   Colour::greyLevel (0.6f).withAlpha (alpha), 0, y, false));
		g.fillEllipse (x, y, diam, diam);

		x += 2.0f;
		y += 2.0f;
		diam -= 4.0f;

		LookAndFeel::drawGlassSphere (g, x, y, diam, colour.withAlpha (alpha), 1.0f);

		Path& p = getToggleState() ? toggledShape : normalShape;

		const AffineTransform t (p.getTransformToScaleToFit (x + diam * 0.3f, y + diam * 0.3f,
															 diam * 0.4f, diam * 0.4f, true));

		g.setColour (Colours::black.withAlpha (alpha * 0.6f));
		g.fillPath (p, t);
	}

private:
	Colour colour;
	Path normalShape, toggledShape;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (GlassWindowButton);
};

Button* LookAndFeel::createDocumentWindowButton (int buttonType)
{
	Path shape;
	const float crossThickness = 0.25f;

	if (buttonType == DocumentWindow::closeButton)
	{
		shape.addLineSegment (Line<float> (0.0f, 0.0f, 1.0f, 1.0f), crossThickness * 1.4f);
		shape.addLineSegment (Line<float> (1.0f, 0.0f, 0.0f, 1.0f), crossThickness * 1.4f);

		return new GlassWindowButton ("close", Colour (0xffdd1100), shape, shape);
	}
	else if (buttonType == DocumentWindow::minimiseButton)
	{
		shape.addLineSegment (Line<float> (0.0f, 0.5f, 1.0f, 0.5f), crossThickness);

		return new GlassWindowButton ("minimise", Colour (0xffaa8811), shape, shape);
	}
	else if (buttonType == DocumentWindow::maximiseButton)
	{
		shape.addLineSegment (Line<float> (0.5f, 0.0f, 0.5f, 1.0f), crossThickness);
		shape.addLineSegment (Line<float> (0.0f, 0.5f, 1.0f, 0.5f), crossThickness);

		Path fullscreenShape;
		fullscreenShape.startNewSubPath (45.0f, 100.0f);
		fullscreenShape.lineTo (0.0f, 100.0f);
		fullscreenShape.lineTo (0.0f, 0.0f);
		fullscreenShape.lineTo (100.0f, 0.0f);
		fullscreenShape.lineTo (100.0f, 45.0f);
		fullscreenShape.addRectangle (45.0f, 45.0f, 100.0f, 100.0f);
		PathStrokeType (30.0f).createStrokedPath (fullscreenShape, fullscreenShape);

		return new GlassWindowButton ("maximise", Colour (0xff119911), shape, fullscreenShape);
	}

	jassertfalse;
	return nullptr;
}

void LookAndFeel::positionDocumentWindowButtons (DocumentWindow&,
												 int titleBarX,
												 int titleBarY,
												 int titleBarW,
												 int titleBarH,
												 Button* minimiseButton,
												 Button* maximiseButton,
												 Button* closeButton,
												 bool positionTitleBarButtonsOnLeft)
{
	const int buttonW = titleBarH - titleBarH / 8;

	int x = positionTitleBarButtonsOnLeft ? titleBarX + 4
										  : titleBarX + titleBarW - buttonW - buttonW / 4;

	if (closeButton != nullptr)
	{
		closeButton->setBounds (x, titleBarY, buttonW, titleBarH);
		x += positionTitleBarButtonsOnLeft ? buttonW : -(buttonW + buttonW / 4);
	}

	if (positionTitleBarButtonsOnLeft)
		std::swap (minimiseButton, maximiseButton);

	if (maximiseButton != nullptr)
	{
		maximiseButton->setBounds (x, titleBarY, buttonW, titleBarH);
		x += positionTitleBarButtonsOnLeft ? buttonW : -buttonW;
	}

	if (minimiseButton != nullptr)
		minimiseButton->setBounds (x, titleBarY, buttonW, titleBarH);
}

int LookAndFeel::getDefaultMenuBarHeight()
{
	return 24;
}

DropShadower* LookAndFeel::createDropShadowerForComponent (Component*)
{
	return new DropShadower (0.4f, 1, 5, 10);
}

void LookAndFeel::drawStretchableLayoutResizerBar (Graphics& g,
												   int w, int h,
												   bool /*isVerticalBar*/,
												   bool isMouseOver,
												   bool isMouseDragging)
{
	float alpha = 0.5f;

	if (isMouseOver || isMouseDragging)
	{
		g.fillAll (Colour (0x190000ff));
		alpha = 1.0f;
	}

	const float cx = w * 0.5f;
	const float cy = h * 0.5f;
	const float cr = jmin (w, h) * 0.4f;

	g.setGradientFill (ColourGradient (Colours::white.withAlpha (alpha), cx + cr * 0.1f, cy + cr,
									   Colours::black.withAlpha (alpha), cx, cy - cr * 4.0f,
									   true));

	g.fillEllipse (cx - cr, cy - cr, cr * 2.0f, cr * 2.0f);
}

void LookAndFeel::drawGroupComponentOutline (Graphics& g, int width, int height,
											 const String& text,
											 const Justification& position,
											 GroupComponent& group)
{
	const float textH = 15.0f;
	const float indent = 3.0f;
	const float textEdgeGap = 4.0f;
	float cs = 5.0f;

	Font f (textH);

	Path p;
	float x = indent;
	float y = f.getAscent() - 3.0f;
	float w = jmax (0.0f, width - x * 2.0f);
	float h = jmax (0.0f, height - y  - indent);
	cs = jmin (cs, w * 0.5f, h * 0.5f);
	const float cs2 = 2.0f * cs;

	float textW = text.isEmpty() ? 0 : jlimit (0.0f, jmax (0.0f, w - cs2 - textEdgeGap * 2), f.getStringWidth (text) + textEdgeGap * 2.0f);
	float textX = cs + textEdgeGap;

	if (position.testFlags (Justification::horizontallyCentred))
		textX = cs + (w - cs2 - textW) * 0.5f;
	else if (position.testFlags (Justification::right))
		textX = w - cs - textW - textEdgeGap;

	p.startNewSubPath (x + textX + textW, y);
	p.lineTo (x + w - cs, y);

	p.addArc (x + w - cs2, y, cs2, cs2, 0, float_Pi * 0.5f);
	p.lineTo (x + w, y + h - cs);

	p.addArc (x + w - cs2, y + h - cs2, cs2, cs2, float_Pi * 0.5f, float_Pi);
	p.lineTo (x + cs, y + h);

	p.addArc (x, y + h - cs2, cs2, cs2, float_Pi, float_Pi * 1.5f);
	p.lineTo (x, y + cs);

	p.addArc (x, y, cs2, cs2, float_Pi * 1.5f, float_Pi * 2.0f);
	p.lineTo (x + textX, y);

	const float alpha = group.isEnabled() ? 1.0f : 0.5f;

	g.setColour (group.findColour (GroupComponent::outlineColourId)
					.withMultipliedAlpha (alpha));

	g.strokePath (p, PathStrokeType (2.0f));

	g.setColour (group.findColour (GroupComponent::textColourId)
					.withMultipliedAlpha (alpha));
	g.setFont (f);
	g.drawText (text,
				roundToInt (x + textX), 0,
				roundToInt (textW),
				roundToInt (textH),
				Justification::centred, true);
}

int LookAndFeel::getTabButtonOverlap (int tabDepth)
{
	return 1 + tabDepth / 3;
}

int LookAndFeel::getTabButtonSpaceAroundImage()
{
	return 4;
}

void LookAndFeel::createTabButtonShape (Path& p,
										int width, int height,
										int /*tabIndex*/,
										const String& /*text*/,
										Button& /*button*/,
										TabbedButtonBar::Orientation orientation,
										const bool /*isMouseOver*/,
										const bool /*isMouseDown*/,
										const bool /*isFrontTab*/)
{
	const float w = (float) width;
	const float h = (float) height;

	float length = w;
	float depth = h;

	if (orientation == TabbedButtonBar::TabsAtLeft
		 || orientation == TabbedButtonBar::TabsAtRight)
	{
		std::swap (length, depth);
	}

	const float indent = (float) getTabButtonOverlap ((int) depth);
	const float overhang = 4.0f;

	if (orientation == TabbedButtonBar::TabsAtLeft)
	{
		p.startNewSubPath (w, 0.0f);
		p.lineTo (0.0f, indent);
		p.lineTo (0.0f, h - indent);
		p.lineTo (w, h);
		p.lineTo (w + overhang, h + overhang);
		p.lineTo (w + overhang, -overhang);
	}
	else if (orientation == TabbedButtonBar::TabsAtRight)
	{
		p.startNewSubPath (0.0f, 0.0f);
		p.lineTo (w, indent);
		p.lineTo (w, h - indent);
		p.lineTo (0.0f, h);
		p.lineTo (-overhang, h + overhang);
		p.lineTo (-overhang, -overhang);
	}
	else if (orientation == TabbedButtonBar::TabsAtBottom)
	{
		p.startNewSubPath (0.0f, 0.0f);
		p.lineTo (indent, h);
		p.lineTo (w - indent, h);
		p.lineTo (w, 0.0f);
		p.lineTo (w + overhang, -overhang);
		p.lineTo (-overhang, -overhang);
	}
	else
	{
		p.startNewSubPath (0.0f, h);
		p.lineTo (indent, 0.0f);
		p.lineTo (w - indent, 0.0f);
		p.lineTo (w, h);
		p.lineTo (w + overhang, h + overhang);
		p.lineTo (-overhang, h + overhang);
	}

	p.closeSubPath();

	p = p.createPathWithRoundedCorners (3.0f);
}

void LookAndFeel::fillTabButtonShape (Graphics& g,
									  const Path& path,
									  const Colour& preferredColour,
									  int /*tabIndex*/,
									  const String& /*text*/,
									  Button& button,
									  TabbedButtonBar::Orientation /*orientation*/,
									  const bool /*isMouseOver*/,
									  const bool /*isMouseDown*/,
									  const bool isFrontTab)
{
	g.setColour (isFrontTab ? preferredColour
							: preferredColour.withMultipliedAlpha (0.9f));

	g.fillPath (path);

	g.setColour (button.findColour (isFrontTab ? TabbedButtonBar::frontOutlineColourId
											   : TabbedButtonBar::tabOutlineColourId, false)
					.withMultipliedAlpha (button.isEnabled() ? 1.0f : 0.5f));

	g.strokePath (path, PathStrokeType (isFrontTab ? 1.0f : 0.5f));
}

void LookAndFeel::drawTabButtonText (Graphics& g,
									 int x, int y, int w, int h,
									 const Colour& preferredBackgroundColour,
									 int /*tabIndex*/,
									 const String& text,
									 Button& button,
									 TabbedButtonBar::Orientation orientation,
									 const bool isMouseOver,
									 const bool isMouseDown,
									 const bool isFrontTab)
{
	int length = w;
	int depth = h;

	if (orientation == TabbedButtonBar::TabsAtLeft
		 || orientation == TabbedButtonBar::TabsAtRight)
	{
		std::swap (length, depth);
	}

	Font font (depth * 0.6f);
	font.setUnderline (button.hasKeyboardFocus (false));

	GlyphArrangement textLayout;
	textLayout.addFittedText (font, text.trim(),
							  0.0f, 0.0f, (float) length, (float) depth,
							  Justification::centred,
							  jmax (1, depth / 12));

	AffineTransform transform;

	if (orientation == TabbedButtonBar::TabsAtLeft)
	{
		transform = transform.rotated (float_Pi * -0.5f)
							 .translated ((float) x, (float) (y + h));
	}
	else if (orientation  == TabbedButtonBar::TabsAtRight)
	{
		transform = transform.rotated (float_Pi * 0.5f)
							 .translated ((float) (x + w), (float) y);
	}
	else
	{
		transform = transform.translated ((float) x, (float) y);
	}

	if (isFrontTab && (button.isColourSpecified (TabbedButtonBar::frontTextColourId) || isColourSpecified (TabbedButtonBar::frontTextColourId)))
		g.setColour (findColour (TabbedButtonBar::frontTextColourId));
	else if (button.isColourSpecified (TabbedButtonBar::tabTextColourId) || isColourSpecified (TabbedButtonBar::tabTextColourId))
		g.setColour (findColour (TabbedButtonBar::tabTextColourId));
	else
		g.setColour (preferredBackgroundColour.contrasting());

	if (! (isMouseOver || isMouseDown))
		g.setOpacity (0.8f);

	if (! button.isEnabled())
		g.setOpacity (0.3f);

	textLayout.draw (g, transform);
}

int LookAndFeel::getTabButtonBestWidth (int /*tabIndex*/,
										const String& text,
										int tabDepth,
										Button&)
{
	Font f (tabDepth * 0.6f);
	return f.getStringWidth (text.trim()) + getTabButtonOverlap (tabDepth) * 2;
}

void LookAndFeel::drawTabButton (Graphics& g,
								 int w, int h,
								 const Colour& preferredColour,
								 int tabIndex,
								 const String& text,
								 Button& button,
								 TabbedButtonBar::Orientation orientation,
								 const bool isMouseOver,
								 const bool isMouseDown,
								 const bool isFrontTab)
{
	int length = w;
	int depth = h;

	if (orientation == TabbedButtonBar::TabsAtLeft
			|| orientation == TabbedButtonBar::TabsAtRight)
	{
		std::swap (length, depth);
	}

	Path tabShape;

	createTabButtonShape (tabShape, w, h,
						  tabIndex, text, button, orientation,
						  isMouseOver, isMouseDown, isFrontTab);

	fillTabButtonShape (g, tabShape, preferredColour,
						tabIndex, text, button, orientation,
						isMouseOver, isMouseDown, isFrontTab);

	const int indent = getTabButtonOverlap (depth);
	int x = 0, y = 0;

	if (orientation == TabbedButtonBar::TabsAtLeft
		 || orientation == TabbedButtonBar::TabsAtRight)
	{
		y += indent;
		h -= indent * 2;
	}
	else
	{
		x += indent;
		w -= indent * 2;
	}

	drawTabButtonText (g, x, y, w, h, preferredColour,
					   tabIndex, text, button, orientation,
					   isMouseOver, isMouseDown, isFrontTab);
}

void LookAndFeel::drawTabAreaBehindFrontButton (Graphics& g,
												int w, int h,
												TabbedButtonBar& tabBar,
												TabbedButtonBar::Orientation orientation)
{
	const float shadowSize = 0.2f;

	float x1 = 0.0f, y1 = 0.0f, x2 = 0.0f, y2 = 0.0f;
	Rectangle<int> shadowRect;

	if (orientation == TabbedButtonBar::TabsAtLeft)
	{
		x1 = (float) w;
		x2 = w * (1.0f - shadowSize);
		shadowRect.setBounds ((int) x2, 0, w - (int) x2, h);
	}
	else if (orientation == TabbedButtonBar::TabsAtRight)
	{
		x2 = w * shadowSize;
		shadowRect.setBounds (0, 0, (int) x2, h);
	}
	else if (orientation == TabbedButtonBar::TabsAtBottom)
	{
		y2 = h * shadowSize;
		shadowRect.setBounds (0, 0, w, (int) y2);
	}
	else
	{
		y1 = (float) h;
		y2 = h * (1.0f - shadowSize);
		shadowRect.setBounds (0, (int) y2, w, h - (int) y2);
	}

	g.setGradientFill (ColourGradient (Colours::black.withAlpha (tabBar.isEnabled() ? 0.3f : 0.15f), x1, y1,
									   Colours::transparentBlack, x2, y2, false));

	shadowRect.expand (2, 2);
	g.fillRect (shadowRect);

	g.setColour (Colour (0x80000000));

	if (orientation == TabbedButtonBar::TabsAtLeft)
	{
		g.fillRect (w - 1, 0, 1, h);
	}
	else if (orientation == TabbedButtonBar::TabsAtRight)
	{
		g.fillRect (0, 0, 1, h);
	}
	else if (orientation == TabbedButtonBar::TabsAtBottom)
	{
		g.fillRect (0, 0, w, 1);
	}
	else
	{
		g.fillRect (0, h - 1, w, 1);
	}
}

Button* LookAndFeel::createTabBarExtrasButton()
{
	const float thickness = 7.0f;
	const float indent = 22.0f;

	Path p;
	p.addEllipse (-10.0f, -10.0f, 120.0f, 120.0f);

	DrawablePath ellipse;
	ellipse.setPath (p);
	ellipse.setFill (Colour (0x99ffffff));

	p.clear();
	p.addEllipse (0.0f, 0.0f, 100.0f, 100.0f);
	p.addRectangle (indent, 50.0f - thickness, 100.0f - indent * 2.0f, thickness * 2.0f);
	p.addRectangle (50.0f - thickness, indent, thickness * 2.0f, 50.0f - indent - thickness);
	p.addRectangle (50.0f - thickness, 50.0f + thickness, thickness * 2.0f, 50.0f - indent - thickness);
	p.setUsingNonZeroWinding (false);

	DrawablePath dp;
	dp.setPath (p);
	dp.setFill (Colour (0x59000000));

	DrawableComposite normalImage;
	normalImage.addAndMakeVisible (ellipse.createCopy());
	normalImage.addAndMakeVisible (dp.createCopy());

	dp.setFill (Colour (0xcc000000));

	DrawableComposite overImage;
	overImage.addAndMakeVisible (ellipse.createCopy());
	overImage.addAndMakeVisible (dp.createCopy());

	DrawableButton* db = new DrawableButton ("tabs", DrawableButton::ImageFitted);
	db->setImages (&normalImage, &overImage, nullptr);
	return db;
}

void LookAndFeel::drawTableHeaderBackground (Graphics& g, TableHeaderComponent& header)
{
	g.fillAll (Colours::white);

	const int w = header.getWidth();
	const int h = header.getHeight();

	g.setGradientFill (ColourGradient (Colour (0xffe8ebf9), 0.0f, h * 0.5f,
									   Colour (0xfff6f8f9), 0.0f, h - 1.0f,
									   false));
	g.fillRect (0, h / 2, w, h);

	g.setColour (Colour (0x33000000));
	g.fillRect (0, h - 1, w, 1);

	for (int i = header.getNumColumns (true); --i >= 0;)
		g.fillRect (header.getColumnPosition (i).getRight() - 1, 0, 1, h - 1);
}

void LookAndFeel::drawTableHeaderColumn (Graphics& g, const String& columnName, int /*columnId*/,
										 int width, int height,
										 bool isMouseOver, bool isMouseDown,
										 int columnFlags)
{
	if (isMouseDown)
		g.fillAll (Colour (0x8899aadd));
	else if (isMouseOver)
		g.fillAll (Colour (0x5599aadd));

	int rightOfText = width - 4;

	if ((columnFlags & (TableHeaderComponent::sortedForwards | TableHeaderComponent::sortedBackwards)) != 0)
	{
		const float top = height * ((columnFlags & TableHeaderComponent::sortedForwards) != 0 ? 0.35f : (1.0f - 0.35f));
		const float bottom = height - top;

		const float w = height * 0.5f;
		const float x = rightOfText - (w * 1.25f);
		rightOfText = (int) x;

		Path sortArrow;
		sortArrow.addTriangle (x, bottom, x + w * 0.5f, top, x + w, bottom);

		g.setColour (Colour (0x99000000));
		g.fillPath (sortArrow);
	}

	g.setColour (Colours::black);
	g.setFont (height * 0.5f, Font::bold);
	const int textX = 4;
	g.drawFittedText (columnName, textX, 0, rightOfText - textX, height, Justification::centredLeft, 1);
}

void LookAndFeel::paintToolbarBackground (Graphics& g, int w, int h, Toolbar& toolbar)
{
	const Colour background (toolbar.findColour (Toolbar::backgroundColourId));

	g.setGradientFill (ColourGradient (background, 0.0f, 0.0f,
									   background.darker (0.1f),
									   toolbar.isVertical() ? w - 1.0f : 0.0f,
									   toolbar.isVertical() ? 0.0f : h - 1.0f,
									   false));
	g.fillAll();
}

Button* LookAndFeel::createToolbarMissingItemsButton (Toolbar& /*toolbar*/)
{
	return createTabBarExtrasButton();
}

void LookAndFeel::paintToolbarButtonBackground (Graphics& g, int /*width*/, int /*height*/,
												bool isMouseOver, bool isMouseDown,
												ToolbarItemComponent& component)
{
	if (isMouseDown)
		g.fillAll (component.findColour (Toolbar::buttonMouseDownBackgroundColourId, true));
	else if (isMouseOver)
		g.fillAll (component.findColour (Toolbar::buttonMouseOverBackgroundColourId, true));
}

void LookAndFeel::paintToolbarButtonLabel (Graphics& g, int x, int y, int width, int height,
										   const String& text, ToolbarItemComponent& component)
{
	g.setColour (component.findColour (Toolbar::labelTextColourId, true)
					.withAlpha (component.isEnabled() ? 1.0f : 0.25f));

	const float fontHeight = jmin (14.0f, height * 0.85f);
	g.setFont (fontHeight);

	g.drawFittedText (text,
					  x, y, width, height,
					  Justification::centred,
					  jmax (1, height / (int) fontHeight));
}

void LookAndFeel::drawPropertyPanelSectionHeader (Graphics& g, const String& name,
												  bool isOpen, int width, int height)
{
	const int buttonSize = (height * 3) / 4;
	const int buttonIndent = (height - buttonSize) / 2;

	drawTreeviewPlusMinusBox (g, buttonIndent, buttonIndent, buttonSize, buttonSize, ! isOpen, false);

	const int textX = buttonIndent * 2 + buttonSize + 2;

	g.setColour (Colours::black);
	g.setFont (height * 0.7f, Font::bold);
	g.drawText (name, textX, 0, width - textX - 4, height, Justification::centredLeft, true);
}

void LookAndFeel::drawPropertyComponentBackground (Graphics& g, int width, int height,
												   PropertyComponent&)
{
	g.setColour (Colour (0x66ffffff));
	g.fillRect (0, 0, width, height - 1);
}

void LookAndFeel::drawPropertyComponentLabel (Graphics& g, int, int height,
											  PropertyComponent& component)
{
	g.setColour (Colours::black);

	if (! component.isEnabled())
		g.setOpacity (0.6f);

	g.setFont (jmin (height, 24) * 0.65f);

	const Rectangle<int> r (getPropertyComponentContentPosition (component));

	g.drawFittedText (component.getName(),
					  3, r.getY(), r.getX() - 5, r.getHeight(),
					  Justification::centredLeft, 2);
}

const Rectangle<int> LookAndFeel::getPropertyComponentContentPosition (PropertyComponent& component)
{
	return Rectangle<int> (component.getWidth() / 3, 1,
						   component.getWidth() - component.getWidth() / 3 - 1, component.getHeight() - 3);
}

void LookAndFeel::drawCallOutBoxBackground (CallOutBox& box, Graphics& g, const Path& path)
{
	Image content (Image::ARGB, box.getWidth(), box.getHeight(), true);

	{
		Graphics g2 (content);

		g2.setColour (Colour::greyLevel (0.23f).withAlpha (0.9f));
		g2.fillPath (path);

		g2.setColour (Colours::white.withAlpha (0.8f));
		g2.strokePath (path, PathStrokeType (2.0f));
	}

	DropShadowEffect shadow;
	shadow.setShadowProperties (5.0f, 0.4f, 0, 2);
	shadow.applyEffect (content, g, 1.0f);
}

void LookAndFeel::createFileChooserHeaderText (const String& title,
											   const String& instructions,
											   GlyphArrangement& text,
											   int width)
{
	text.clear();

	text.addJustifiedText (Font (17.0f, Font::bold), title,
						   8.0f, 22.0f, width - 16.0f,
						   Justification::centred);

	text.addJustifiedText (Font (14.0f), instructions,
						   8.0f, 24.0f + 16.0f, width - 16.0f,
						   Justification::centred);
}

void LookAndFeel::drawFileBrowserRow (Graphics& g, int width, int height,
									  const String& filename, Image* icon,
									  const String& fileSizeDescription,
									  const String& fileTimeDescription,
									  const bool isDirectory,
									  const bool isItemSelected,
									  const int /*itemIndex*/,
									  DirectoryContentsDisplayComponent&)
{
	if (isItemSelected)
		g.fillAll (findColour (DirectoryContentsDisplayComponent::highlightColourId));

	const int x = 32;
	g.setColour (Colours::black);

	if (icon != nullptr && icon->isValid())
	{
		g.drawImageWithin (*icon, 2, 2, x - 4, height - 4,
						   RectanglePlacement::centred | RectanglePlacement::onlyReduceInSize,
						   false);
	}
	else
	{
		const Drawable* d = isDirectory ? getDefaultFolderImage()
										: getDefaultDocumentFileImage();

		if (d != nullptr)
			d->drawWithin (g, Rectangle<float> (2.0f, 2.0f, x - 4.0f, height - 4.0f),
						   RectanglePlacement::centred | RectanglePlacement::onlyReduceInSize, 1.0f);
	}

	g.setColour (findColour (DirectoryContentsDisplayComponent::textColourId));
	g.setFont (height * 0.7f);

	if (width > 450 && ! isDirectory)
	{
		const int sizeX = roundToInt (width * 0.7f);
		const int dateX = roundToInt (width * 0.8f);

		g.drawFittedText (filename,
						  x, 0, sizeX - x, height,
						  Justification::centredLeft, 1);

		g.setFont (height * 0.5f);
		g.setColour (Colours::darkgrey);

		if (! isDirectory)
		{
			g.drawFittedText (fileSizeDescription,
							  sizeX, 0, dateX - sizeX - 8, height,
							  Justification::centredRight, 1);

			g.drawFittedText (fileTimeDescription,
							  dateX, 0, width - 8 - dateX, height,
							  Justification::centredRight, 1);
		}
	}
	else
	{
		g.drawFittedText (filename,
						  x, 0, width - x, height,
						  Justification::centredLeft, 1);

	}
}

Button* LookAndFeel::createFileBrowserGoUpButton()
{
	DrawableButton* goUpButton = new DrawableButton ("up", DrawableButton::ImageOnButtonBackground);

	Path arrowPath;
	arrowPath.addArrow (Line<float> (50.0f, 100.0f, 50.0f, 0.0f), 40.0f, 100.0f, 50.0f);

	DrawablePath arrowImage;
	arrowImage.setFill (Colours::black.withAlpha (0.4f));
	arrowImage.setPath (arrowPath);

	goUpButton->setImages (&arrowImage);

	return goUpButton;
}

void LookAndFeel::layoutFileBrowserComponent (FileBrowserComponent& browserComp,
											  DirectoryContentsDisplayComponent* fileListComponent,
											  FilePreviewComponent* previewComp,
											  ComboBox* currentPathBox,
											  TextEditor* filenameBox,
											  Button* goUpButton)
{
	const int x = 8;
	int w = browserComp.getWidth() - x - x;

	if (previewComp != nullptr)
	{
		const int previewWidth = w / 3;
		previewComp->setBounds (x + w - previewWidth, 0, previewWidth, browserComp.getHeight());

		w -= previewWidth + 4;
	}

	int y = 4;

	const int controlsHeight = 22;
	const int bottomSectionHeight = controlsHeight + 8;
	const int upButtonWidth = 50;

	currentPathBox->setBounds (x, y, w - upButtonWidth - 6, controlsHeight);
	goUpButton->setBounds (x + w - upButtonWidth, y, upButtonWidth, controlsHeight);

	y += controlsHeight + 4;

	Component* const listAsComp = dynamic_cast <Component*> (fileListComponent);
	listAsComp->setBounds (x, y, w, browserComp.getHeight() - y - bottomSectionHeight);

	y = listAsComp->getBottom() + 4;
	filenameBox->setBounds (x + 50, y, w - 50, controlsHeight);
}

// Pulls a drawable out of compressed valuetree data..
Drawable* LookAndFeel::loadDrawableFromData (const void* data, size_t numBytes)
{
	MemoryInputStream m (data, numBytes, false);
	GZIPDecompressorInputStream gz (m);
	ValueTree drawable (ValueTree::readFromStream (gz));
	return Drawable::createFromValueTree (drawable.getChild (0), nullptr);
}

const Drawable* LookAndFeel::getDefaultFolderImage()
{
	if (folderImage == nullptr)
	{
		static const unsigned char drawableData[] =
		{ 120,218,197,86,77,111,27,55,16,229,182,161,237,6,61,39,233,77,63,192,38,56,195,225,215,209,105,210,2,141,13,20,201,193,109,111,178,181,178,183,145,181,130,180,110,145,127,159,199,93,73,137,87,53,218,91,109,192,160,151,179,156,55,111,222,188,229,155,247,
		231,87,231,175,47,222,170,234,155,229,244,190,86,213,115,253,102,61,253,123,122,189,168,85,51,83,213,119,250,238,221,47,231,151,175,223,169,170,250,121,221,62,172,84,245,172,60,63,209,243,118,49,171,215,170,107,87,23,245,188,83,213,145,182,167,19,91,
		254,127,223,220,222,117,37,68,82,40,143,174,219,174,107,239,135,168,147,18,37,108,85,245,237,46,207,70,33,249,175,211,238,78,85,186,28,253,76,175,73,109,186,117,251,177,190,106,102,229,241,247,58,24,103,203,15,101,245,103,219,44,187,15,221,39,0,172,142,
		245,125,211,1,196,205,116,181,125,114,164,175,31,186,78,45,219,229,31,245,186,189,106,150,179,102,121,139,100,154,240,231,167,102,177,64,72,247,105,213,23,122,187,158,206,154,122,217,169,85,57,18,1,47,53,101,107,18,135,204,167,147,192,201,216,20,114,
		244,195,62,171,234,7,125,198,100,136,216,145,149,211,9,57,103,40,249,72,219,8,167,170,87,250,140,162,199,123,226,3,34,82,202,134,131,13,172,74,170,233,162,0,177,234,166,93,180,15,235,141,170,206,180,157,204,231,150,156,159,207,39,195,50,214,88,18,150,
		245,205,124,250,104,169,212,135,158,19,144,53,20,112,172,55,237,2,132,13,199,149,130,230,115,145,112,147,147,82,61,157,32,238,178,253,11,145,213,138,10,52,138,38,103,111,99,164,211,137,139,198,35,177,35,167,212,143,15,215,205,13,160,109,163,172,225,152,
		16,232,17,149,140,103,144,158,146,90,113,217,12,6,197,167,236,3,54,5,181,101,73,54,138,90,245,165,227,120,18,252,150,77,15,242,188,228,204,81,169,139,102,249,5,68,192,145,14,244,112,1,145,29,94,137,96,235,49,136,151,58,246,32,88,192,161,88,176,76,226,
		36,247,24,176,7,232,62,16,83,42,155,201,160,30,222,65,72,98,82,76,33,198,254,197,96,124,10,150,243,8,130,48,228,36,94,124,6,4,43,38,0,142,205,99,30,4,221,13,33,230,220,71,177,65,49,142,243,150,7,1,51,20,2,5,96,96,84,225,56,217,188,3,33,46,24,228,112,
		69,69,12,68,228,108,242,99,16,165,118,208,28,51,200,98,87,42,74,62,209,24,4,206,48,22,153,125,132,220,196,56,15,234,99,216,130,0,141,38,74,162,130,48,35,163,141,94,196,245,32,94,104,7,154,132,209,40,108,162,165,232,153,165,17,4,138,201,176,135,58,49,
		165,130,122,108,114,54,28,240,64,17,89,188,79,177,116,149,10,4,246,91,30,94,104,112,96,226,144,131,144,142,98,78,177,7,128,81,242,224,140,36,249,80,208,145,196,12,202,15,16,60,161,200,69,187,169,213,86,198,123,87,224,255,199,21,94,105,134,72,40,177,245,
		14,182,32,232,54,196,231,100,111,11,189,168,201,39,177,84,102,38,139,177,168,74,210,87,174,64,20,138,160,67,111,10,4,98,196,97,60,158,118,133,25,111,173,224,171,37,97,185,119,133,221,242,63,184,194,140,71,174,240,252,145,43,72,32,147,146,147,4,104,104,
		117,134,10,18,12,107,212,40,72,148,57,6,71,69,135,222,248,16,160,168,3,169,144,55,201,69,41,147,137,134,99,50,97,8,178,85,43,217,140,201,151,192,152,10,242,190,24,11,59,183,29,25,42,115,236,98,14,229,252,32,80,66,0,162,17,136,72,6,67,5,45,242,224,10,
		193,102,71,50,6,17,129,212,18,115,105,150,80,169,45,123,222,141,76,178,70,32,55,24,90,217,132,71,73,200,57,238,204,3,136,49,144,185,55,183,190,20,137,52,246,47,113,232,158,69,35,49,145,208,129,193,56,178,77,135,230,145,113,22,140,69,74,20,146,2,120,218,
		155,135,48,32,10,89,30,156,165,204,254,222,193,160,12,19,49,6,210,59,11,70,62,4,31,15,64,196,2,157,98,33,58,1,104,32,152,50,31,128,64,148,183,197,108,209,89,107,240,41,75,36,123,16,208,108,180,44,236,250,182,227,27,20,137,118,76,60,165,137,221,92,94,
		78,215,31,235,245,230,183,242,229,30,214,251,251,195,145,94,148,15,253,170,221,52,93,211,46,7,109,171,81,208,177,94,247,119,132,47,81,186,92,22,246,7,255,254,15,7,107,141,171,197,191,156,123,162,135,187,198,227,131,113,219,80,159,1,4,239,223,231,0,0 };

		folderImage = loadDrawableFromData (drawableData, sizeof (drawableData));
	}

	return folderImage;
}

const Drawable* LookAndFeel::getDefaultDocumentFileImage()
{
	if (documentImage == nullptr)
	{
		static const unsigned char drawableData[] =
		{ 120,218,213,88,77,115,219,54,16,37,147,208,246,228,214,75,155,246,164,123,29,12,176,216,197,199,49,105,218,94,156,153,78,114,72,219,155,108,75,137,26,89,212,200,116,59,233,175,239,3,105,201,164,68,50,158,166,233,76,196,11,69,60,173,128,197,123,139,183,
		124,241,234,217,155,103,207,207,126,204,242,7,171,233,213,44,203,31,23,47,54,211,191,166,231,203,89,182,184,204,242,147,226,195,165,219,252,125,150,229,249,207,155,242,102,157,229,143,210,227,199,197,101,121,113,115,53,91,85,89,85,174,207,102,243,42,
		203,143,10,125,58,209,233,251,171,197,219,119,85,250,173,97,151,30,157,151,85,85,94,53,168,147,132,50,226,179,252,225,246,143,174,179,44,63,254,101,90,189,203,242,34,5,127,84,172,77,118,93,109,202,247,179,55,139,203,244,248,97,161,179,63,202,197,170,
		122,93,125,192,196,242,227,226,106,81,205,54,217,197,116,125,251,228,168,56,191,169,170,108,85,174,126,159,109,202,55,139,213,229,98,245,182,249,97,254,240,167,197,114,137,5,86,31,214,245,111,175,203,37,254,230,162,92,150,55,155,180,148,249,237,39,203,
		94,215,127,58,10,213,245,39,203,234,249,102,249,87,47,203,63,129,204,49,227,252,73,225,149,145,104,131,245,254,116,34,202,82,164,16,153,179,236,108,177,234,7,49,41,237,130,144,167,17,144,15,42,104,239,93,12,35,32,99,68,9,187,24,125,7,244,77,23,36,164,
		40,56,226,61,12,107,229,130,215,100,105,24,227,89,17,246,211,105,55,140,49,218,43,207,100,245,72,28,195,70,17,230,201,118,8,243,164,139,233,95,88,23,52,152,162,54,104,48,217,237,105,15,111,91,107,253,131,160,118,34,239,69,128,54,232,135,101,121,61,203,
		110,169,181,147,2,253,159,82,48,180,229,247,167,74,193,41,141,188,35,93,241,116,18,148,113,214,120,207,113,47,19,109,16,51,182,153,193,5,59,2,10,90,69,114,218,135,48,2,50,198,43,171,189,152,81,144,88,108,85,136,78,246,64,54,42,163,35,69,30,3,121,82,38,
		98,81,98,70,64,70,139,34,111,163,167,49,144,13,202,138,179,58,220,23,52,180,186,54,104,48,79,109,208,96,198,219,19,31,220,187,118,10,6,65,237,100,222,139,5,109,80,191,30,236,151,162,135,147,142,30,68,105,182,58,6,22,84,43,229,124,148,116,97,145,55,231,
		139,11,76,228,16,37,14,48,205,145,77,134,34,176,55,152,182,200,57,99,93,204,144,145,253,65,97,229,132,72,104,63,62,71,21,140,54,186,41,226,59,84,19,63,130,15,222,235,224,185,59,104,27,226,68,101,153,241,227,177,248,29,20,136,26,8,252,178,183,241,219,
		131,137,160,209,107,109,92,79,124,16,211,184,104,93,77,130,110,124,2,65,172,67,201,60,157,88,163,2,91,99,92,216,198,55,78,69,75,190,150,119,84,98,200,71,150,109,124,36,204,227,52,8,33,229,223,68,167,173,167,131,248,137,212,226,141,19,233,160,154,248,
		144,142,195,140,137,185,59,104,15,247,119,40,126,23,69,81,200,242,110,254,123,20,49,94,112,110,245,199,111,241,167,87,36,252,101,138,132,149,22,22,38,65,134,29,182,139,24,230,192,31,144,184,133,130,72,44,131,210,142,111,147,216,30,76,123,30,113,206,242,
		150,196,157,65,129,130,76,180,194,61,34,225,160,5,228,233,160,118,34,137,26,202,115,212,29,108,72,134,243,223,90,114,226,199,226,119,80,6,245,152,197,122,217,146,184,53,24,140,210,30,21,59,80,79,124,182,202,71,207,218,112,159,72,80,53,140,109,68,2,191,
		227,217,210,78,36,94,137,88,231,82,157,8,176,61,0,122,191,19,137,3,255,13,39,183,228,20,193,151,144,119,166,79,36,40,253,156,138,72,11,181,19,137,14,46,176,217,27,180,135,251,219,31,255,235,61,148,165,96,72,122,118,23,229,81,52,135,24,250,163,183,216,
		211,43,17,217,151,136,253,116,137,28,53,188,127,92,188,221,76,47,23,169,59,90,167,144,141,239,197,86,104,141,189,60,157,80,84,142,140,4,31,154,241,122,105,132,41,107,13,201,39,86,120,24,82,114,206,198,6,96,27,227,172,36,232,168,201,36,219,24,113,62,163,
		154,101,233,143,166,203,102,26,141,206,174,179,252,89,161,39,243,249,197,121,186,38,233,246,146,211,53,1,123,56,194,231,122,143,103,179,217,60,204,167,19,147,110,41,93,173,219,123,72,89,248,35,173,16,220,50,179,111,60,181,24,88,103,156,235,7,78,248,14,
		4,119,78,162,93,60,112,35,109,16,124,126,12,17,71,67,24,1,165,142,1,181,215,248,56,6,66,235,193,137,167,61,22,30,5,3,27,101,71,64,169,25,112,216,2,63,22,169,110,43,18,200,140,129,208,160,88,44,220,208,125,65,67,171,107,131,6,243,212,6,13,102,188,61,241,
		225,189,107,165,96,16,212,78,230,189,88,208,6,245,235,214,237,235,150,62,167,110,155,106,170,53,133,192,117,193,20,84,78,74,174,98,39,92,156,8,112,21,46,80,106,12,209,207,225,228,16,113,59,225,126,87,60,133,25,209,34,36,2,99,242,52,197,48,30,75,244,247,
		212,238,246,182,173,221,185,78,215,127,167,221,162,163,221,250,152,217,146,196,222,145,100,223,235,105,108,28,250,149,212,74,224,86,2,213,118,110,119,204,224,144,208,38,214,131,200,14,214,223,120,189,230,53,1,193,70,133,154,131,56,223,16,229,48,188,14,
		201,205,213,121,71,233,68,89,15,124,103,37,53,26,11,118,176,127,169,88,166,158,219,178,117,173,83,108,75,95,55,68,186,193,53,246,146,206,127,6,63,53,78,58,228,204,155,224,113,74,91,232,221,195,240,105,215,34,29,138,64,128,183,8,130,233,71,173,56,54,101,
		99,75,186,111,65,58,28,229,145,82,19,152,12,99,180,81,130,131,75,234,229,220,247,53,231,154,79,205,185,185,155,199,249,172,38,85,253,204,76,68,95,92,204,207,255,221,75,178,227,14,187,224,224,97,202,172,173,219,12,167,130,133,9,54,135,245,92,176,29,134,
		165,110,139,141,18,16,223,29,188,183,65,207,144,106,144,151,143,128,224,176,168,110,140,32,62,56,110,219,195,54,235,20,68,209,216,34,232,21,6,41,234,157,39,211,201,107,160,230,66,225,56,153,9,101,21,37,237,150,204,14,115,208,22,221,54,216,230,33,116,
		14,65,14,44,19,8,236,73,71,246,182,110,125,224,75,132,195,214,247,163,36,51,252,84,76,124,37,212,100,88,62,183,179,76,67,217,218,242,244,229,116,243,126,182,185,254,21,105,126,208,220,239,94,229,30,21,203,244,202,117,93,94,47,170,69,185,106,246,60,219,
		3,29,23,155,250,109,237,29,170,72,175,109,119,129,127,235,9,92,20,85,185,254,72,220,147,162,121,235,219,13,44,144,225,63,241,244,165,51,0,0 };

		documentImage = loadDrawableFromData (drawableData, sizeof (drawableData));
	}

	return documentImage;
}

void LookAndFeel::drawLevelMeter (Graphics& g, int width, int height, float level)
{
	g.setColour (Colours::white.withAlpha (0.7f));
	g.fillRoundedRectangle (0.0f, 0.0f, (float) width, (float) height, 3.0f);
	g.setColour (Colours::black.withAlpha (0.2f));
	g.drawRoundedRectangle (1.0f, 1.0f, width - 2.0f, height - 2.0f, 3.0f, 1.0f);

	const int totalBlocks = 7;
	const int numBlocks = roundToInt (totalBlocks * level);
	const float w = (width - 6.0f) / (float) totalBlocks;

	for (int i = 0; i < totalBlocks; ++i)
	{
		if (i >= numBlocks)
			g.setColour (Colours::lightblue.withAlpha (0.6f));
		else
			g.setColour (i < totalBlocks - 1 ? Colours::blue.withAlpha (0.5f)
											 : Colours::red);

		g.fillRoundedRectangle (3.0f + i * w + w * 0.1f, 3.0f, w * 0.8f, height - 6.0f, w * 0.4f);
	}
}

void LookAndFeel::drawKeymapChangeButton (Graphics& g, int width, int height, Button& button, const String& keyDescription)
{
	const Colour textColour (button.findColour (0x100ad01 /*KeyMappingEditorComponent::textColourId*/, true));

	if (keyDescription.isNotEmpty())
	{
		if (button.isEnabled())
		{
			const float alpha = button.isDown() ? 0.3f : (button.isOver() ? 0.15f : 0.08f);
			g.fillAll (textColour.withAlpha (alpha));

			g.setOpacity (0.3f);
			g.drawBevel (0, 0, width, height, 2);
		}

		g.setColour (textColour);
		g.setFont (height * 0.6f);
		g.drawFittedText (keyDescription,
						  3, 0, width - 6, height,
						  Justification::centred, 1);
	}
	else
	{
		const float thickness = 7.0f;
		const float indent = 22.0f;

		Path p;
		p.addEllipse (0.0f, 0.0f, 100.0f, 100.0f);
		p.addRectangle (indent, 50.0f - thickness, 100.0f - indent * 2.0f, thickness * 2.0f);
		p.addRectangle (50.0f - thickness, indent, thickness * 2.0f, 50.0f - indent - thickness);
		p.addRectangle (50.0f - thickness, 50.0f + thickness, thickness * 2.0f, 50.0f - indent - thickness);
		p.setUsingNonZeroWinding (false);

		g.setColour (textColour.withAlpha (button.isDown() ? 0.7f : (button.isOver() ? 0.5f : 0.3f)));
		g.fillPath (p, p.getTransformToScaleToFit (2.0f, 2.0f, width - 4.0f, height - 4.0f, true));
	}

	if (button.hasKeyboardFocus (false))
	{
		g.setColour (textColour.withAlpha (0.4f));
		g.drawRect (0, 0, width, height);
	}
}

void LookAndFeel::drawShinyButtonShape (Graphics& g,
										float x, float y, float w, float h,
										float maxCornerSize,
										const Colour& baseColour,
										const float strokeWidth,
										const bool flatOnLeft,
										const bool flatOnRight,
										const bool flatOnTop,
										const bool flatOnBottom) noexcept
{
	if (w <= strokeWidth * 1.1f || h <= strokeWidth * 1.1f)
		return;

	const float cs = jmin (maxCornerSize, w * 0.5f, h * 0.5f);

	Path outline;
	LookAndFeelHelpers::createRoundedPath (outline, x, y, w, h, cs,
											! (flatOnLeft || flatOnTop),
											! (flatOnRight || flatOnTop),
											! (flatOnLeft || flatOnBottom),
											! (flatOnRight || flatOnBottom));

	ColourGradient cg (baseColour, 0.0f, y,
					   baseColour.overlaidWith (Colour (0x070000ff)), 0.0f, y + h,
					   false);

	cg.addColour (0.5, baseColour.overlaidWith (Colour (0x33ffffff)));
	cg.addColour (0.51, baseColour.overlaidWith (Colour (0x110000ff)));

	g.setGradientFill (cg);
	g.fillPath (outline);

	g.setColour (Colour (0x80000000));
	g.strokePath (outline, PathStrokeType (strokeWidth));
}

void LookAndFeel::drawGlassSphere (Graphics& g,
								   const float x, const float y,
								   const float diameter,
								   const Colour& colour,
								   const float outlineThickness) noexcept
{
	if (diameter <= outlineThickness)
		return;

	Path p;
	p.addEllipse (x, y, diameter, diameter);

	{
		ColourGradient cg (Colours::white.overlaidWith (colour.withMultipliedAlpha (0.3f)), 0, y,
						   Colours::white.overlaidWith (colour.withMultipliedAlpha (0.3f)), 0, y + diameter, false);

		cg.addColour (0.4, Colours::white.overlaidWith (colour));

		g.setGradientFill (cg);
		g.fillPath (p);
	}

	g.setGradientFill (ColourGradient (Colours::white, 0, y + diameter * 0.06f,
									   Colours::transparentWhite, 0, y + diameter * 0.3f, false));
	g.fillEllipse (x + diameter * 0.2f, y + diameter * 0.05f, diameter * 0.6f, diameter * 0.4f);

	ColourGradient cg (Colours::transparentBlack,
					   x + diameter * 0.5f, y + diameter * 0.5f,
					   Colours::black.withAlpha (0.5f * outlineThickness * colour.getFloatAlpha()),
					   x, y + diameter * 0.5f, true);

	cg.addColour (0.7, Colours::transparentBlack);
	cg.addColour (0.8, Colours::black.withAlpha (0.1f * outlineThickness));

	g.setGradientFill (cg);
	g.fillPath (p);

	g.setColour (Colours::black.withAlpha (0.5f * colour.getFloatAlpha()));
	g.drawEllipse (x, y, diameter, diameter, outlineThickness);
}

void LookAndFeel::drawGlassPointer (Graphics& g,
									const float x, const float y,
									const float diameter,
									const Colour& colour, const float outlineThickness,
									const int direction) noexcept
{
	if (diameter <= outlineThickness)
		return;

	Path p;
	p.startNewSubPath (x + diameter * 0.5f, y);
	p.lineTo (x + diameter, y + diameter * 0.6f);
	p.lineTo (x + diameter, y + diameter);
	p.lineTo (x, y + diameter);
	p.lineTo (x, y + diameter * 0.6f);
	p.closeSubPath();

	p.applyTransform (AffineTransform::rotation (direction * (float_Pi * 0.5f), x + diameter * 0.5f, y + diameter * 0.5f));

	{
		ColourGradient cg (Colours::white.overlaidWith (colour.withMultipliedAlpha (0.3f)), 0, y,
						   Colours::white.overlaidWith (colour.withMultipliedAlpha (0.3f)), 0, y + diameter, false);

		cg.addColour (0.4, Colours::white.overlaidWith (colour));

		g.setGradientFill (cg);
		g.fillPath (p);
	}

	ColourGradient cg (Colours::transparentBlack,
					   x + diameter * 0.5f, y + diameter * 0.5f,
					   Colours::black.withAlpha (0.5f * outlineThickness * colour.getFloatAlpha()),
					   x - diameter * 0.2f, y + diameter * 0.5f, true);

	cg.addColour (0.5, Colours::transparentBlack);
	cg.addColour (0.7, Colours::black.withAlpha (0.07f * outlineThickness));

	g.setGradientFill (cg);
	g.fillPath (p);

	g.setColour (Colours::black.withAlpha (0.5f * colour.getFloatAlpha()));
	g.strokePath (p, PathStrokeType (outlineThickness));
}

void LookAndFeel::drawGlassLozenge (Graphics& g,
									const float x, const float y,
									const float width, const float height,
									const Colour& colour,
									const float outlineThickness,
									const float cornerSize,
									const bool flatOnLeft,
									const bool flatOnRight,
									const bool flatOnTop,
									const bool flatOnBottom) noexcept
{
	if (width <= outlineThickness || height <= outlineThickness)
		return;

	const int intX = (int) x;
	const int intY = (int) y;
	const int intW = (int) width;
	const int intH = (int) height;

	const float cs = cornerSize < 0 ? jmin (width * 0.5f, height * 0.5f) : cornerSize;
	const float edgeBlurRadius = height * 0.75f + (height - cs * 2.0f);
	const int intEdge = (int) edgeBlurRadius;

	Path outline;
	LookAndFeelHelpers::createRoundedPath (outline, x, y, width, height, cs,
											! (flatOnLeft || flatOnTop),
											! (flatOnRight || flatOnTop),
											! (flatOnLeft || flatOnBottom),
											! (flatOnRight || flatOnBottom));

	{
		ColourGradient cg (colour.darker (0.2f), 0, y,
						   colour.darker (0.2f), 0, y + height, false);

		cg.addColour (0.03, colour.withMultipliedAlpha (0.3f));
		cg.addColour (0.4, colour);
		cg.addColour (0.97, colour.withMultipliedAlpha (0.3f));

		g.setGradientFill (cg);
		g.fillPath (outline);
	}

	ColourGradient cg (Colours::transparentBlack, x + edgeBlurRadius, y + height * 0.5f,
					   colour.darker (0.2f), x, y + height * 0.5f, true);

	cg.addColour (jlimit (0.0, 1.0, 1.0 - (cs * 0.5f) / edgeBlurRadius), Colours::transparentBlack);
	cg.addColour (jlimit (0.0, 1.0, 1.0 - (cs * 0.25f) / edgeBlurRadius), colour.darker (0.2f).withMultipliedAlpha (0.3f));

	if (! (flatOnLeft || flatOnTop || flatOnBottom))
	{
		g.saveState();
		g.setGradientFill (cg);
		g.reduceClipRegion (intX, intY, intEdge, intH);
		g.fillPath (outline);
		g.restoreState();
	}

	if (! (flatOnRight || flatOnTop || flatOnBottom))
	{
		cg.point1.setX (x + width - edgeBlurRadius);
		cg.point2.setX (x + width);

		g.saveState();
		g.setGradientFill (cg);
		g.reduceClipRegion (intX + intW - intEdge, intY, 2 + intEdge, intH);
		g.fillPath (outline);
		g.restoreState();
	}

	{
		const float leftIndent = flatOnTop || flatOnLeft ? 0.0f : cs * 0.4f;
		const float rightIndent = flatOnTop || flatOnRight ? 0.0f : cs * 0.4f;

		Path highlight;
		LookAndFeelHelpers::createRoundedPath (highlight,
											   x + leftIndent,
											   y + cs * 0.1f,
											   width - (leftIndent + rightIndent),
											   height * 0.4f, cs * 0.4f,
											   ! (flatOnLeft || flatOnTop),
											   ! (flatOnRight || flatOnTop),
											   ! (flatOnLeft || flatOnBottom),
											   ! (flatOnRight || flatOnBottom));

		g.setGradientFill (ColourGradient (colour.brighter (10.0f), 0, y + height * 0.06f,
										   Colours::transparentWhite, 0, y + height * 0.4f, false));
		g.fillPath (highlight);
	}

	g.setColour (colour.darker().withMultipliedAlpha (1.5f));
	g.strokePath (outline, PathStrokeType (outlineThickness));
}

/*** End of inlined file: juce_LookAndFeel.cpp ***/


/*** Start of inlined file: juce_MenuBarComponent.cpp ***/
MenuBarComponent::MenuBarComponent (MenuBarModel* model_)
	: model (nullptr),
	  itemUnderMouse (-1),
	  currentPopupIndex (-1),
	  topLevelIndexClicked (0)
{
	setRepaintsOnMouseActivity (true);
	setWantsKeyboardFocus (false);
	setMouseClickGrabsKeyboardFocus (false);

	setModel (model_);
}

MenuBarComponent::~MenuBarComponent()
{
	setModel (nullptr);
	Desktop::getInstance().removeGlobalMouseListener (this);
}

MenuBarModel* MenuBarComponent::getModel() const noexcept
{
	return model;
}

void MenuBarComponent::setModel (MenuBarModel* const newModel)
{
	if (model != newModel)
	{
		if (model != nullptr)
			model->removeListener (this);

		model = newModel;

		if (model != nullptr)
			model->addListener (this);

		repaint();
		menuBarItemsChanged (nullptr);
	}
}

void MenuBarComponent::paint (Graphics& g)
{
	const bool isMouseOverBar = currentPopupIndex >= 0 || itemUnderMouse >= 0 || isMouseOver();

	getLookAndFeel().drawMenuBarBackground (g,
											getWidth(),
											getHeight(),
											isMouseOverBar,
											*this);

	if (model != nullptr)
	{
		for (int i = 0; i < menuNames.size(); ++i)
		{
			Graphics::ScopedSaveState ss (g);

			g.setOrigin (xPositions [i], 0);
			g.reduceClipRegion (0, 0, xPositions[i + 1] - xPositions[i], getHeight());

			getLookAndFeel().drawMenuBarItem (g,
											  xPositions[i + 1] - xPositions[i],
											  getHeight(),
											  i,
											  menuNames[i],
											  i == itemUnderMouse,
											  i == currentPopupIndex,
											  isMouseOverBar,
											  *this);
		}
	}
}

void MenuBarComponent::resized()
{
	xPositions.clear();
	int x = 0;
	xPositions.add (x);

	for (int i = 0; i < menuNames.size(); ++i)
	{
		x += getLookAndFeel().getMenuBarItemWidth (*this, i, menuNames[i]);
		xPositions.add (x);
	}
}

int MenuBarComponent::getItemAt (const Point<int>& p)
{
	for (int i = 0; i < xPositions.size(); ++i)
		if (p.x >= xPositions[i] && p.x < xPositions[i + 1])
			return reallyContains (p, true) ? i : -1;

	return -1;
}

void MenuBarComponent::repaintMenuItem (int index)
{
	if (isPositiveAndBelow (index, xPositions.size()))
	{
		const int x1 = xPositions [index];
		const int x2 = xPositions [index + 1];

		repaint (x1 - 2, 0, x2 - x1 + 4, getHeight());
	}
}

void MenuBarComponent::setItemUnderMouse (const int index)
{
	if (itemUnderMouse != index)
	{
		repaintMenuItem (itemUnderMouse);
		itemUnderMouse = index;
		repaintMenuItem (itemUnderMouse);
	}
}

void MenuBarComponent::setOpenItem (int index)
{
	if (currentPopupIndex != index)
	{
		repaintMenuItem (currentPopupIndex);
		currentPopupIndex = index;
		repaintMenuItem (currentPopupIndex);

		Desktop& desktop = Desktop::getInstance();

		if (index >= 0)
			desktop.addGlobalMouseListener (this);
		else
			desktop.removeGlobalMouseListener (this);
	}
}

void MenuBarComponent::updateItemUnderMouse (const Point<int>& p)
{
	setItemUnderMouse (getItemAt (p));
}

void MenuBarComponent::showMenu (int index)
{
	if (index != currentPopupIndex)
	{
		PopupMenu::dismissAllActiveMenus();
		menuBarItemsChanged (nullptr);

		setOpenItem (index);
		setItemUnderMouse (index);

		if (index >= 0)
		{
			PopupMenu m (model->getMenuForIndex (itemUnderMouse,
												 menuNames [itemUnderMouse]));

			if (m.lookAndFeel == nullptr)
				m.setLookAndFeel (&getLookAndFeel());

			const Rectangle<int> itemPos (xPositions [index], 0, xPositions [index + 1] - xPositions [index], getHeight());

			m.showMenuAsync (PopupMenu::Options().withTargetComponent (this)
												 .withTargetScreenArea (localAreaToGlobal (itemPos))
												 .withMinimumWidth (itemPos.getWidth()),
							 ModalCallbackFunction::forComponent (menuBarMenuDismissedCallback, this, index));
		}
	}
}

void MenuBarComponent::menuBarMenuDismissedCallback (int result, MenuBarComponent* bar, int topLevelIndex)
{
	if (bar != nullptr)
		bar->menuDismissed (topLevelIndex, result);
}

void MenuBarComponent::menuDismissed (int topLevelIndex, int itemId)
{
	topLevelIndexClicked = topLevelIndex;
	postCommandMessage (itemId);
}

void MenuBarComponent::handleCommandMessage (int commandId)
{
	const Point<int> mousePos (getMouseXYRelative());
	updateItemUnderMouse (mousePos);

	if (currentPopupIndex == topLevelIndexClicked)
		setOpenItem (-1);

	if (commandId != 0 && model != nullptr)
		model->menuItemSelected (commandId, topLevelIndexClicked);
}

void MenuBarComponent::mouseEnter (const MouseEvent& e)
{
	if (e.eventComponent == this)
		updateItemUnderMouse (e.getPosition());
}

void MenuBarComponent::mouseExit (const MouseEvent& e)
{
	if (e.eventComponent == this)
		updateItemUnderMouse (e.getPosition());
}

void MenuBarComponent::mouseDown (const MouseEvent& e)
{
	if (currentPopupIndex < 0)
	{
		const MouseEvent e2 (e.getEventRelativeTo (this));
		updateItemUnderMouse (e2.getPosition());

		currentPopupIndex = -2;
		showMenu (itemUnderMouse);
	}
}

void MenuBarComponent::mouseDrag (const MouseEvent& e)
{
	const MouseEvent e2 (e.getEventRelativeTo (this));
	const int item = getItemAt (e2.getPosition());

	if (item >= 0)
		showMenu (item);
}

void MenuBarComponent::mouseUp (const MouseEvent& e)
{
	const MouseEvent e2 (e.getEventRelativeTo (this));

	updateItemUnderMouse (e2.getPosition());

	if (itemUnderMouse < 0 && getLocalBounds().contains (e2.x, e2.y))
	{
		setOpenItem (-1);
		PopupMenu::dismissAllActiveMenus();
	}
}

void MenuBarComponent::mouseMove (const MouseEvent& e)
{
	const MouseEvent e2 (e.getEventRelativeTo (this));

	if (lastMousePos != e2.getPosition())
	{
		if (currentPopupIndex >= 0)
		{
			const int item = getItemAt (e2.getPosition());

			if (item >= 0)
				showMenu (item);
		}
		else
		{
			updateItemUnderMouse (e2.getPosition());
		}

		lastMousePos = e2.getPosition();
	}
}

bool MenuBarComponent::keyPressed (const KeyPress& key)
{
	bool used = false;
	const int numMenus = menuNames.size();
	const int currentIndex = jlimit (0, menuNames.size() - 1, currentPopupIndex);

	if (key.isKeyCode (KeyPress::leftKey))
	{
		showMenu ((currentIndex + numMenus - 1) % numMenus);
		used = true;
	}
	else if (key.isKeyCode (KeyPress::rightKey))
	{
		showMenu ((currentIndex + 1) % numMenus);
		used = true;
	}

	return used;
}

void MenuBarComponent::menuBarItemsChanged (MenuBarModel* /*menuBarModel*/)
{
	StringArray newNames;

	if (model != nullptr)
		newNames = model->getMenuBarNames();

	if (newNames != menuNames)
	{
		menuNames = newNames;
		repaint();
		resized();
	}
}

void MenuBarComponent::menuCommandInvoked (MenuBarModel* /*menuBarModel*/,
										   const ApplicationCommandTarget::InvocationInfo& info)
{
	if (model == nullptr || (info.commandFlags & ApplicationCommandInfo::dontTriggerVisualFeedback) != 0)
		return;

	for (int i = 0; i < menuNames.size(); ++i)
	{
		const PopupMenu menu (model->getMenuForIndex (i, menuNames [i]));

		if (menu.containsCommandItem (info.commandID))
		{
			setItemUnderMouse (i);
			startTimer (200);
			break;
		}
	}
}

void MenuBarComponent::timerCallback()
{
	stopTimer();
	updateItemUnderMouse (getMouseXYRelative());
}

/*** End of inlined file: juce_MenuBarComponent.cpp ***/


/*** Start of inlined file: juce_MenuBarModel.cpp ***/
MenuBarModel::MenuBarModel() noexcept
	: manager (nullptr)
{
}

MenuBarModel::~MenuBarModel()
{
	setApplicationCommandManagerToWatch (nullptr);
}

void MenuBarModel::menuItemsChanged()
{
	triggerAsyncUpdate();
}

void MenuBarModel::setApplicationCommandManagerToWatch (ApplicationCommandManager* const newManager) noexcept
{
	if (manager != newManager)
	{
		if (manager != nullptr)
			manager->removeListener (this);

		manager = newManager;

		if (manager != nullptr)
			manager->addListener (this);
	}
}

void MenuBarModel::addListener (Listener* const newListener) noexcept
{
	listeners.add (newListener);
}

void MenuBarModel::removeListener (Listener* const listenerToRemove) noexcept
{
	// Trying to remove a listener that isn't on the list!
	// If this assertion happens because this object is a dangling pointer, make sure you've not
	// deleted this menu model while it's still being used by something (e.g. by a MenuBarComponent)
	jassert (listeners.contains (listenerToRemove));

	listeners.remove (listenerToRemove);
}

void MenuBarModel::handleAsyncUpdate()
{
	listeners.call (&MenuBarModel::Listener::menuBarItemsChanged, this);
}

void MenuBarModel::applicationCommandInvoked (const ApplicationCommandTarget::InvocationInfo& info)
{
	listeners.call (&MenuBarModel::Listener::menuCommandInvoked, this, info);
}

void MenuBarModel::applicationCommandListChanged()
{
	menuItemsChanged();
}

/*** End of inlined file: juce_MenuBarModel.cpp ***/


/*** Start of inlined file: juce_PopupMenu.cpp ***/
class PopupMenu::Item
{
public:
	Item()
	  : itemId (0), active (true), isSeparator (true), isTicked (false),
		usesColour (false), commandManager (nullptr)
	{
	}

	Item (const int itemId_,
		  const String& text_,
		  const bool active_,
		  const bool isTicked_,
		  const Image& im,
		  const Colour& textColour_,
		  const bool usesColour_,
		  CustomComponent* const customComp_,
		  const PopupMenu* const subMenu_,
		  ApplicationCommandManager* const commandManager_)
	  : itemId (itemId_), text (text_), textColour (textColour_),
		active (active_), isSeparator (false), isTicked (isTicked_),
		usesColour (usesColour_), image (im), customComp (customComp_),
		commandManager (commandManager_)
	{
		if (subMenu_ != nullptr)
			subMenu = new PopupMenu (*subMenu_);

		if (commandManager_ != nullptr && itemId_ != 0)
		{
			String shortcutKey;

			Array <KeyPress> keyPresses (commandManager_->getKeyMappings()
											->getKeyPressesAssignedToCommand (itemId_));

			for (int i = 0; i < keyPresses.size(); ++i)
			{
				const String key (keyPresses.getReference(i).getTextDescriptionWithIcons());

				if (shortcutKey.isNotEmpty())
					shortcutKey << ", ";

				if (key.length() == 1 && key[0] < 128)
					shortcutKey << "shortcut: '" << key << '\'';
				else
					shortcutKey << key;
			}

			shortcutKey = shortcutKey.trim();

			if (shortcutKey.isNotEmpty())
				text << "<end>" << shortcutKey;
		}
	}

	Item (const Item& other)
		: itemId (other.itemId),
		  text (other.text),
		  textColour (other.textColour),
		  active (other.active),
		  isSeparator (other.isSeparator),
		  isTicked (other.isTicked),
		  usesColour (other.usesColour),
		  image (other.image),
		  customComp (other.customComp),
		  commandManager (other.commandManager)
	{
		if (other.subMenu != nullptr)
			subMenu = new PopupMenu (*(other.subMenu));
	}

	bool canBeTriggered() const noexcept    { return active && ! (isSeparator || (subMenu != nullptr)); }
	bool hasActiveSubMenu() const noexcept  { return active && subMenu != nullptr && subMenu->items.size() > 0; }

	const int itemId;
	String text;
	const Colour textColour;
	const bool active, isSeparator, isTicked, usesColour;
	Image image;
	ReferenceCountedObjectPtr <CustomComponent> customComp;
	ScopedPointer <PopupMenu> subMenu;
	ApplicationCommandManager* const commandManager;

private:
	Item& operator= (const Item&);

	JUCE_LEAK_DETECTOR (Item);
};

class PopupMenu::ItemComponent  : public Component
{
public:
	ItemComponent (const PopupMenu::Item& itemInfo_, int standardItemHeight, Component* const parent)
	  : itemInfo (itemInfo_),
		isHighlighted (false)
	{
		addAndMakeVisible (itemInfo.customComp);
		parent->addAndMakeVisible (this);

		int itemW = 80;
		int itemH = 16;
		getIdealSize (itemW, itemH, standardItemHeight);
		setSize (itemW, jlimit (2, 600, itemH));

		addMouseListener (parent, false);
	}

	~ItemComponent()
	{
		removeChildComponent (itemInfo.customComp);
	}

	void getIdealSize (int& idealWidth, int& idealHeight, const int standardItemHeight)
	{
		if (itemInfo.customComp != nullptr)
			itemInfo.customComp->getIdealSize (idealWidth, idealHeight);
		else
			getLookAndFeel().getIdealPopupMenuItemSize (itemInfo.text,
														itemInfo.isSeparator,
														standardItemHeight,
														idealWidth, idealHeight);
	}

	void paint (Graphics& g)
	{
		if (itemInfo.customComp == nullptr)
		{
			String mainText (itemInfo.text);
			String endText;
			const int endIndex = mainText.indexOf ("<end>");

			if (endIndex >= 0)
			{
				endText = mainText.substring (endIndex + 5).trim();
				mainText = mainText.substring (0, endIndex);
			}

			getLookAndFeel()
				.drawPopupMenuItem (g, getWidth(), getHeight(),
									itemInfo.isSeparator,
									itemInfo.active,
									isHighlighted,
									itemInfo.isTicked,
									itemInfo.subMenu != nullptr,
									mainText, endText,
									itemInfo.image.isValid() ? &itemInfo.image : nullptr,
									itemInfo.usesColour ? &(itemInfo.textColour) : nullptr);
		}
	}

	void resized()
	{
		Component* const child = getChildComponent (0);
		if (child != nullptr)
			child->setBounds (getLocalBounds().reduced (2, 0));
	}

	void setHighlighted (bool shouldBeHighlighted)
	{
		shouldBeHighlighted = shouldBeHighlighted && itemInfo.active;

		if (isHighlighted != shouldBeHighlighted)
		{
			isHighlighted = shouldBeHighlighted;

			if (itemInfo.customComp != nullptr)
				itemInfo.customComp->setHighlighted (shouldBeHighlighted);

			repaint();
		}
	}

	PopupMenu::Item itemInfo;

private:
	bool isHighlighted;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ItemComponent);
};

namespace PopupMenuSettings
{
	const int scrollZone = 24;
	const int borderSize = 2;
	const int timerInterval = 50;
	const int dismissCommandId = 0x6287345f;

	static bool menuWasHiddenBecauseOfAppChange = false;
}

class PopupMenu::Window  : public Component,
						   private Timer
{
public:
	Window (const PopupMenu& menu, Window* const owner_,
			const Options& options_,
			const bool alignToRectangle,
			const bool dismissOnMouseUp_,
			ApplicationCommandManager** const managerOfChosenCommand_)
	   : Component ("menu"),
		 owner (owner_),
		 options (options_),
		 activeSubMenu (nullptr),
		 managerOfChosenCommand (managerOfChosenCommand_),
		 componentAttachedTo (options.targetComponent),
		 isOver (false),
		 hasBeenOver (false),
		 isDown (false),
		 needsToScroll (false),
		 dismissOnMouseUp (dismissOnMouseUp_),
		 hideOnExit (false),
		 disableMouseMoves (false),
		 hasAnyJuceCompHadFocus (false),
		 numColumns (0),
		 contentHeight (0),
		 childYOffset (0),
		 menuCreationTime (Time::getMillisecondCounter()),
		 lastMouseMoveTime (0),
		 timeEnteredCurrentChildComp (0),
		 scrollAcceleration (1.0)
	{
		lastFocusedTime = lastScrollTime = menuCreationTime;
		setWantsKeyboardFocus (false);
		setMouseClickGrabsKeyboardFocus (false);
		setAlwaysOnTop (true);

		setLookAndFeel (menu.lookAndFeel);
		setOpaque (getLookAndFeel().findColour (PopupMenu::backgroundColourId).isOpaque() || ! Desktop::canUseSemiTransparentWindows());

		for (int i = 0; i < menu.items.size(); ++i)
		{
			PopupMenu::Item* const item = menu.items.getUnchecked(i);

			if (i < menu.items.size() - 1 || ! item->isSeparator)
				items.add (new PopupMenu::ItemComponent (*item, options.standardHeight, this));
		}

		calculateWindowPos (options.targetArea, alignToRectangle);
		setTopLeftPosition (windowPos.getPosition());
		updateYPositions();

		if (options.visibleItemID != 0)
		{
			const int y = options.targetArea.getY() - windowPos.getY();
			ensureItemIsVisible (options.visibleItemID,
								 isPositiveAndBelow (y, windowPos.getHeight()) ? y : -1);
		}

		resizeToBestWindowPos();
		addToDesktop (ComponentPeer::windowIsTemporary
					   | ComponentPeer::windowIgnoresKeyPresses
					   | getLookAndFeel().getMenuWindowFlags());

		getActiveWindows().add (this);
		Desktop::getInstance().addGlobalMouseListener (this);
	}

	~Window()
	{
		getActiveWindows().removeValue (this);
		Desktop::getInstance().removeGlobalMouseListener (this);
		activeSubMenu = nullptr;
		items.clear();
	}

	void paint (Graphics& g)
	{
		if (isOpaque())
			g.fillAll (Colours::white);

		getLookAndFeel().drawPopupMenuBackground (g, getWidth(), getHeight());
	}

	void paintOverChildren (Graphics& g)
	{
		if (canScroll())
		{
			LookAndFeel& lf = getLookAndFeel();

			if (isTopScrollZoneActive())
				lf.drawPopupMenuUpDownArrow (g, getWidth(), PopupMenuSettings::scrollZone, true);

			if (isBottomScrollZoneActive())
			{
				g.setOrigin (0, getHeight() - PopupMenuSettings::scrollZone);
				lf.drawPopupMenuUpDownArrow (g, getWidth(), PopupMenuSettings::scrollZone, false);
			}
		}
	}

	// hide this and all sub-comps
	void hide (const PopupMenu::Item* const item, const bool makeInvisible)
	{
		if (isVisible())
		{
			WeakReference<Component> deletionChecker (this);

			activeSubMenu = nullptr;
			currentChild = nullptr;

			if (item != nullptr
				 && item->commandManager != nullptr
				 && item->itemId != 0)
			{
				*managerOfChosenCommand = item->commandManager;
			}

			exitModalState (item != nullptr ? item->itemId : 0);

			if (makeInvisible && (deletionChecker != nullptr))
				setVisible (false);
		}
	}

	void dismissMenu (const PopupMenu::Item* const item)
	{
		if (owner != nullptr)
		{
			owner->dismissMenu (item);
		}
		else
		{
			if (item != nullptr)
			{
				// need a copy of this on the stack as the one passed in will get deleted during this call
				const PopupMenu::Item mi (*item);
				hide (&mi, false);
			}
			else
			{
				hide (nullptr, false);
			}
		}
	}

	void mouseMove (const MouseEvent&)    { timerCallback(); }
	void mouseDown (const MouseEvent&)    { timerCallback(); }
	void mouseDrag (const MouseEvent&)    { timerCallback(); }
	void mouseUp   (const MouseEvent&)    { timerCallback(); }

	void mouseWheelMove (const MouseEvent&, float /*amountX*/, float amountY)
	{
		alterChildYPos (roundToInt (-10.0f * amountY * PopupMenuSettings::scrollZone));
		lastMousePos = Point<int> (-1, -1);
	}

	bool keyPressed (const KeyPress& key)
	{
		if (key.isKeyCode (KeyPress::downKey))
		{
			selectNextItem (1);
		}
		else if (key.isKeyCode (KeyPress::upKey))
		{
			selectNextItem (-1);
		}
		else if (key.isKeyCode (KeyPress::leftKey))
		{
			if (owner != nullptr)
			{
				Component::SafePointer<Window> parentWindow (owner);
				PopupMenu::ItemComponent* currentChildOfParent = parentWindow->currentChild;

				hide (0, true);

				if (parentWindow != nullptr)
					parentWindow->setCurrentlyHighlightedChild (currentChildOfParent);

				disableTimerUntilMouseMoves();
			}
			else if (componentAttachedTo != nullptr)
			{
				componentAttachedTo->keyPressed (key);
			}
		}
		else if (key.isKeyCode (KeyPress::rightKey))
		{
			disableTimerUntilMouseMoves();

			if (showSubMenuFor (currentChild))
			{
				if (isSubMenuVisible())
					activeSubMenu->selectNextItem (1);
			}
			else if (componentAttachedTo != nullptr)
			{
				componentAttachedTo->keyPressed (key);
			}
		}
		else if (key.isKeyCode (KeyPress::returnKey))
		{
			triggerCurrentlyHighlightedItem();
		}
		else if (key.isKeyCode (KeyPress::escapeKey))
		{
			dismissMenu (nullptr);
		}
		else
		{
			return false;
		}

		return true;
	}

	void inputAttemptWhenModal()
	{
		WeakReference<Component> deletionChecker (this);

		timerCallback();

		if (deletionChecker != nullptr && ! isOverAnyMenu())
		{
			if (componentAttachedTo != nullptr)
			{
				// we want to dismiss the menu, but if we do it synchronously, then
				// the mouse-click will be allowed to pass through. That's good, except
				// when the user clicks on the button that orginally popped the menu up,
				// as they'll expect the menu to go away, and in fact it'll just
				// come back. So only dismiss synchronously if they're not on the original
				// comp that we're attached to.
				const Point<int> mousePos (componentAttachedTo->getMouseXYRelative());

				if (componentAttachedTo->reallyContains (mousePos, true))
				{
					postCommandMessage (PopupMenuSettings::dismissCommandId); // dismiss asynchrounously
					return;
				}
			}

			dismissMenu (nullptr);
		}
	}

	void handleCommandMessage (int commandId)
	{
		Component::handleCommandMessage (commandId);

		if (commandId == PopupMenuSettings::dismissCommandId)
			dismissMenu (nullptr);
	}

	void timerCallback()
	{
		if (! isVisible())
			return;

		if (componentAttachedTo != options.targetComponent)
		{
			dismissMenu (nullptr);
			return;
		}

		Window* currentlyModalWindow = dynamic_cast <Window*> (Component::getCurrentlyModalComponent());

		if (currentlyModalWindow != nullptr && ! treeContains (currentlyModalWindow))
			return;

		startTimer (PopupMenuSettings::timerInterval);  // do this in case it was called from a mouse
														// move rather than a real timer callback

		const Point<int> globalMousePos (Desktop::getMousePosition());
		const Point<int> localMousePos (getLocalPoint (nullptr, globalMousePos));

		const uint32 timeNow = Time::getMillisecondCounter();

		if (timeNow > timeEnteredCurrentChildComp + 100
			 && reallyContains (localMousePos, true)
			 && currentChild != nullptr
			 && ! (disableMouseMoves || isSubMenuVisible()))
		{
			showSubMenuFor (currentChild);
		}

		highlightItemUnderMouse (globalMousePos, localMousePos, timeNow);

		const bool overScrollArea = scrollIfNecessary (localMousePos, timeNow);
		const bool wasDown = isDown;

		bool isOverAny = isOverAnyMenu();

		if (activeSubMenu != nullptr && hideOnExit && hasBeenOver && ! isOverAny)
		{
			activeSubMenu->updateMouseOverStatus (globalMousePos);
			isOverAny = isOverAnyMenu();
		}

		if (hideOnExit && hasBeenOver && ! isOverAny)
			hide (0, true);
		else
			checkButtonState (localMousePos, timeNow, wasDown, overScrollArea, isOverAny);
	}

	static Array<Window*>& getActiveWindows()
	{
		static Array<Window*> activeMenuWindows;
		return activeMenuWindows;
	}

private:
	Window* owner;
	const Options options;
	OwnedArray <PopupMenu::ItemComponent> items;
	Component::SafePointer<PopupMenu::ItemComponent> currentChild;
	ScopedPointer <Window> activeSubMenu;
	ApplicationCommandManager** managerOfChosenCommand;
	WeakReference<Component> componentAttachedTo;
	Rectangle<int> windowPos;
	Point<int> lastMousePos;
	bool isOver, hasBeenOver, isDown, needsToScroll;
	bool dismissOnMouseUp, hideOnExit, disableMouseMoves, hasAnyJuceCompHadFocus;
	int numColumns, contentHeight, childYOffset;
	Array<int> columnWidths;
	uint32 menuCreationTime, lastFocusedTime, lastScrollTime, lastMouseMoveTime, timeEnteredCurrentChildComp;
	double scrollAcceleration;

	bool overlaps (const Rectangle<int>& r) const
	{
		return r.intersects (getBounds())
				|| (owner != nullptr && owner->overlaps (r));
	}

	bool isOverAnyMenu() const
	{
		return owner != nullptr ? owner->isOverAnyMenu()
								: isOverChildren();
	}

	bool isOverChildren() const
	{
		return isVisible()
				&& (isOver || (activeSubMenu != nullptr && activeSubMenu->isOverChildren()));
	}

	void updateMouseOverStatus (const Point<int>& globalMousePos)
	{
		isOver = reallyContains (getLocalPoint (nullptr, globalMousePos), true);

		if (activeSubMenu != nullptr)
			activeSubMenu->updateMouseOverStatus (globalMousePos);
	}

	bool treeContains (const Window* const window) const noexcept
	{
		const Window* mw = this;

		while (mw->owner != nullptr)
			mw = mw->owner;

		while (mw != nullptr)
		{
			if (mw == window)
				return true;

			mw = mw->activeSubMenu;
		}

		return false;
	}

	bool doesAnyJuceCompHaveFocus()
	{
		bool anyFocused = Process::isForegroundProcess();

		if (anyFocused && Component::getCurrentlyFocusedComponent() == nullptr)
		{
			// because no component at all may have focus, our test here will
			// only be triggered when something has focus and then loses it.
			anyFocused = ! hasAnyJuceCompHadFocus;

			for (int i = ComponentPeer::getNumPeers(); --i >= 0;)
			{
				if (ComponentPeer::getPeer (i)->isFocused())
				{
					anyFocused = true;
					hasAnyJuceCompHadFocus = true;
					break;
				}
			}
		}

		return anyFocused;
	}

	void calculateWindowPos (const Rectangle<int>& target, const bool alignToRectangle)
	{
		const Rectangle<int> mon (Desktop::getInstance()
									 .getMonitorAreaContaining (target.getCentre(),
															   #if JUCE_MAC
																true));
															   #else
																false)); // on windows, don't stop the menu overlapping the taskbar
															   #endif

		const int maxMenuHeight = mon.getHeight() - 24;

		int x, y, widthToUse, heightToUse;
		layoutMenuItems (mon.getWidth() - 24, maxMenuHeight, widthToUse, heightToUse);

		if (alignToRectangle)
		{
			x = target.getX();

			const int spaceUnder = mon.getHeight() - (target.getBottom() - mon.getY());
			const int spaceOver = target.getY() - mon.getY();

			if (heightToUse < spaceUnder - 30 || spaceUnder >= spaceOver)
				y = target.getBottom();
			else
				y = target.getY() - heightToUse;
		}
		else
		{
			bool tendTowardsRight = target.getCentreX() < mon.getCentreX();

			if (owner != nullptr)
			{
				if (owner->owner != nullptr)
				{
					const bool ownerGoingRight = (owner->getX() + owner->getWidth() / 2
													> owner->owner->getX() + owner->owner->getWidth() / 2);

					if (ownerGoingRight && target.getRight() + widthToUse < mon.getRight() - 4)
						tendTowardsRight = true;
					else if ((! ownerGoingRight) && target.getX() > widthToUse + 4)
						tendTowardsRight = false;
				}
				else if (target.getRight() + widthToUse < mon.getRight() - 32)
				{
					tendTowardsRight = true;
				}
			}

			const int biggestSpace = jmax (mon.getRight() - target.getRight(),
										   target.getX() - mon.getX()) - 32;

			if (biggestSpace < widthToUse)
			{
				layoutMenuItems (biggestSpace + target.getWidth() / 3, maxMenuHeight, widthToUse, heightToUse);

				if (numColumns > 1)
					layoutMenuItems (biggestSpace - 4, maxMenuHeight, widthToUse, heightToUse);

				tendTowardsRight = (mon.getRight() - target.getRight()) >= (target.getX() - mon.getX());
			}

			if (tendTowardsRight)
				x = jmin (mon.getRight() - widthToUse - 4, target.getRight());
			else
				x = jmax (mon.getX() + 4, target.getX() - widthToUse);

			y = target.getY();
			if (target.getCentreY() > mon.getCentreY())
				y = jmax (mon.getY(), target.getBottom() - heightToUse);
		}

		x = jmax (mon.getX() + 1, jmin (mon.getRight() - (widthToUse + 6), x));
		y = jmax (mon.getY() + 1, jmin (mon.getBottom() - (heightToUse + 6), y));

		windowPos.setBounds (x, y, widthToUse, heightToUse);

		// sets this flag if it's big enough to obscure any of its parent menus
		hideOnExit = owner != nullptr
					  && owner->windowPos.intersects (windowPos.expanded (-4, -4));
	}

	void layoutMenuItems (const int maxMenuW, const int maxMenuH, int& width, int& height)
	{
		numColumns = 0;
		contentHeight = 0;
		int totalW;

		const int maximumNumColumns = options.maxColumns > 0 ? options.maxColumns : 7;

		do
		{
			++numColumns;
			totalW = workOutBestSize (maxMenuW);

			if (totalW > maxMenuW)
			{
				numColumns = jmax (1, numColumns - 1);
				totalW = workOutBestSize (maxMenuW); // to update col widths
				break;
			}
			else if (totalW > maxMenuW / 2 || contentHeight < maxMenuH)
			{
				break;
			}

		} while (numColumns < maximumNumColumns);

		const int actualH = jmin (contentHeight, maxMenuH);

		needsToScroll = contentHeight > actualH;

		width = updateYPositions();
		height = actualH + PopupMenuSettings::borderSize * 2;
	}

	int workOutBestSize (const int maxMenuW)
	{
		int totalW = 0;
		contentHeight = 0;
		int childNum = 0;

		for (int col = 0; col < numColumns; ++col)
		{
			int i, colW = options.standardHeight, colH = 0;

			const int numChildren = jmin (items.size() - childNum,
										  (items.size() + numColumns - 1) / numColumns);

			for (i = numChildren; --i >= 0;)
			{
				colW = jmax (colW, items.getUnchecked (childNum + i)->getWidth());
				colH += items.getUnchecked (childNum + i)->getHeight();
			}

			colW = jmin (maxMenuW / jmax (1, numColumns - 2), colW + PopupMenuSettings::borderSize * 2);

			columnWidths.set (col, colW);
			totalW += colW;
			contentHeight = jmax (contentHeight, colH);

			childNum += numChildren;
		}

		if (totalW < options.minWidth)
		{
			totalW = options.minWidth;

			for (int col = 0; col < numColumns; ++col)
				columnWidths.set (0, totalW / numColumns);
		}

		return totalW;
	}

	void ensureItemIsVisible (const int itemId, int wantedY)
	{
		jassert (itemId != 0)

		for (int i = items.size(); --i >= 0;)
		{
			PopupMenu::ItemComponent* const m = items.getUnchecked(i);

			if (m != nullptr
				&& m->itemInfo.itemId == itemId
				&& windowPos.getHeight() > PopupMenuSettings::scrollZone * 4)
			{
				const int currentY = m->getY();

				if (wantedY > 0 || currentY < 0 || m->getBottom() > windowPos.getHeight())
				{
					if (wantedY < 0)
						wantedY = jlimit (PopupMenuSettings::scrollZone,
										  jmax (PopupMenuSettings::scrollZone,
												windowPos.getHeight() - (PopupMenuSettings::scrollZone + m->getHeight())),
										  currentY);

					const Rectangle<int> mon (Desktop::getInstance().getMonitorAreaContaining (windowPos.getPosition(), true));

					int deltaY = wantedY - currentY;

					windowPos.setSize (jmin (windowPos.getWidth(), mon.getWidth()),
									   jmin (windowPos.getHeight(), mon.getHeight()));

					const int newY = jlimit (mon.getY(),
											 mon.getBottom() - windowPos.getHeight(),
											 windowPos.getY() + deltaY);

					deltaY -= newY - windowPos.getY();

					childYOffset -= deltaY;
					windowPos.setPosition (windowPos.getX(), newY);

					updateYPositions();
				}

				break;
			}
		}
	}

	void resizeToBestWindowPos()
	{
		Rectangle<int> r (windowPos);

		if (childYOffset < 0)
		{
			r = r.withTop (r.getY() - childYOffset);
		}
		else if (childYOffset > 0)
		{
			const int spaceAtBottom = r.getHeight() - (contentHeight - childYOffset);

			if (spaceAtBottom > 0)
				r.setSize (r.getWidth(), r.getHeight() - spaceAtBottom);
		}

		setBounds (r);
		updateYPositions();
	}

	void alterChildYPos (const int delta)
	{
		if (canScroll())
		{
			childYOffset += delta;

			if (delta < 0)
			{
				childYOffset = jmax (childYOffset, 0);
			}
			else if (delta > 0)
			{
				childYOffset = jmin (childYOffset,
									 contentHeight - windowPos.getHeight() + PopupMenuSettings::borderSize);
			}

			updateYPositions();
		}
		else
		{
			childYOffset = 0;
		}

		resizeToBestWindowPos();
		repaint();
	}

	int updateYPositions()
	{
		int x = 0;
		int childNum = 0;

		for (int col = 0; col < numColumns; ++col)
		{
			const int numChildren = jmin (items.size() - childNum,
										  (items.size() + numColumns - 1) / numColumns);

			const int colW = columnWidths [col];

			int y = PopupMenuSettings::borderSize - (childYOffset + (getY() - windowPos.getY()));

			for (int i = 0; i < numChildren; ++i)
			{
				Component* const c = items.getUnchecked (childNum + i);
				c->setBounds (x, y, colW, c->getHeight());
				y += c->getHeight();
			}

			x += colW;
			childNum += numChildren;
		}

		return x;
	}

	void setCurrentlyHighlightedChild (PopupMenu::ItemComponent* const child)
	{
		if (currentChild != nullptr)
			currentChild->setHighlighted (false);

		currentChild = child;

		if (currentChild != nullptr)
		{
			currentChild->setHighlighted (true);
			timeEnteredCurrentChildComp = Time::getApproximateMillisecondCounter();
		}
	}

	bool isSubMenuVisible() const noexcept          { return activeSubMenu != nullptr && activeSubMenu->isVisible(); }

	bool showSubMenuFor (PopupMenu::ItemComponent* const childComp)
	{
		activeSubMenu = nullptr;

		if (childComp != nullptr
			 && childComp->itemInfo.hasActiveSubMenu())
		{
			activeSubMenu = new Window (*(childComp->itemInfo.subMenu), this,
										options.withTargetScreenArea (childComp->getScreenBounds())
											   .withMinimumWidth (0)
											   .withTargetComponent (nullptr),
										false, dismissOnMouseUp, managerOfChosenCommand);

			activeSubMenu->setVisible (true); // (must be called before enterModalState on Windows to avoid DropShadower confusion)
			activeSubMenu->enterModalState (false);
			activeSubMenu->toFront (false);
			return true;
		}

		return false;
	}

	void highlightItemUnderMouse (const Point<int>& globalMousePos, const Point<int>& localMousePos, const uint32 timeNow)
	{
		if (globalMousePos != lastMousePos || timeNow > lastMouseMoveTime + 350)
		{
			isOver = reallyContains (localMousePos, true);

			if (isOver)
				hasBeenOver = true;

			if (lastMousePos.getDistanceFrom (globalMousePos) > 2)
			{
				lastMouseMoveTime = timeNow;

				if (disableMouseMoves && isOver)
					disableMouseMoves = false;
			}

			if (disableMouseMoves || (activeSubMenu != nullptr && activeSubMenu->isOverChildren()))
				return;

			bool isMovingTowardsMenu = false;

			if (isOver && (activeSubMenu != nullptr) && globalMousePos != lastMousePos)
			{
				// try to intelligently guess whether the user is moving the mouse towards a currently-open
				// submenu. To do this, look at whether the mouse stays inside a triangular region that
				// extends from the last mouse pos to the submenu's rectangle..

				float subX = (float) activeSubMenu->getScreenX();

				if (activeSubMenu->getX() > getX())
				{
					lastMousePos -= Point<int> (2, 0);  // to enlarge the triangle a bit, in case the mouse only moves a couple of pixels
				}
				else
				{
					lastMousePos += Point<int> (2, 0);
					subX += activeSubMenu->getWidth();
				}

				Path areaTowardsSubMenu;
				areaTowardsSubMenu.addTriangle ((float) lastMousePos.x, (float) lastMousePos.y,
												subX, (float) activeSubMenu->getScreenY(),
												subX, (float) (activeSubMenu->getScreenY() + activeSubMenu->getHeight()));

				isMovingTowardsMenu = areaTowardsSubMenu.contains (globalMousePos.toFloat());
			}

			lastMousePos = globalMousePos;

			if (! isMovingTowardsMenu)
			{
				Component* c = getComponentAt (localMousePos);
				if (c == this)
					c = nullptr;

				PopupMenu::ItemComponent* itemUnderMouse = dynamic_cast <PopupMenu::ItemComponent*> (c);

				if (itemUnderMouse == nullptr && c != nullptr)
					itemUnderMouse = c->findParentComponentOfClass ((PopupMenu::ItemComponent*) nullptr);

				if (itemUnderMouse != currentChild
					  && (isOver || (activeSubMenu == nullptr) || ! activeSubMenu->isVisible()))
				{
					if (isOver && (c != nullptr) && (activeSubMenu != nullptr))
						activeSubMenu->hide (0, true);

					if (! isOver)
						itemUnderMouse = nullptr;

					setCurrentlyHighlightedChild (itemUnderMouse);
				}
			}
		}
	}

	void checkButtonState (const Point<int>& localMousePos, const uint32 timeNow,
						   const bool wasDown, const bool overScrollArea, const bool isOverAny)
	{
		isDown = hasBeenOver
					&& (ModifierKeys::getCurrentModifiers().isAnyMouseButtonDown()
						 || ModifierKeys::getCurrentModifiersRealtime().isAnyMouseButtonDown());

		if (! doesAnyJuceCompHaveFocus())
		{
			if (timeNow > lastFocusedTime + 10)
			{
				PopupMenuSettings::menuWasHiddenBecauseOfAppChange = true;
				dismissMenu (nullptr);
				// Note: this object may have been deleted by the previous call..
			}
		}
		else if (wasDown && timeNow > menuCreationTime + 250
				   && ! (isDown || overScrollArea))
		{
			isOver = reallyContains (localMousePos, true);

			if (isOver)
				triggerCurrentlyHighlightedItem();
			else if ((hasBeenOver || ! dismissOnMouseUp) && ! isOverAny)
				dismissMenu (nullptr);

			// Note: this object may have been deleted by the previous call..
		}
		else
		{
			lastFocusedTime = timeNow;
		}
	}

	void triggerCurrentlyHighlightedItem()
	{
		if (currentChild != nullptr
			 && currentChild->itemInfo.canBeTriggered()
			 && (currentChild->itemInfo.customComp == nullptr
				  || currentChild->itemInfo.customComp->isTriggeredAutomatically()))
		{
			dismissMenu (&currentChild->itemInfo);
		}
	}

	void selectNextItem (const int delta)
	{
		disableTimerUntilMouseMoves();
		PopupMenu::ItemComponent* mic = nullptr;
		bool wasLastOne = (currentChild == nullptr);
		const int numItems = items.size();

		for (int i = 0; i < numItems + 1; ++i)
		{
			int index = (delta > 0) ? i : (numItems - 1 - i);
			index = (index + numItems) % numItems;

			mic = items.getUnchecked (index);

			if (mic != nullptr && (mic->itemInfo.canBeTriggered() || mic->itemInfo.hasActiveSubMenu())
				 && wasLastOne)
				break;

			if (mic == currentChild)
				wasLastOne = true;
		}

		setCurrentlyHighlightedChild (mic);
	}

	void disableTimerUntilMouseMoves()
	{
		disableMouseMoves = true;

		if (owner != nullptr)
			owner->disableTimerUntilMouseMoves();
	}

	bool canScroll() const noexcept                 { return childYOffset != 0 || needsToScroll; }
	bool isTopScrollZoneActive() const noexcept     { return canScroll() && childYOffset > 0; }
	bool isBottomScrollZoneActive() const noexcept  { return canScroll() && childYOffset < contentHeight - windowPos.getHeight(); }

	bool scrollIfNecessary (const Point<int>& localMousePos, const uint32 timeNow)
	{
		if (canScroll()
			 && (isOver || (isDown && isPositiveAndBelow (localMousePos.x, getWidth()))))
		{
			if (isTopScrollZoneActive() && localMousePos.y < PopupMenuSettings::scrollZone)
				return scroll (timeNow, -1);

			if (isBottomScrollZoneActive() && localMousePos.y > getHeight() - PopupMenuSettings::scrollZone)
				return scroll (timeNow, 1);
		}

		scrollAcceleration = 1.0;
		return false;
	}

	bool scroll (const uint32 timeNow, const int direction)
	{
		if (timeNow > lastScrollTime + 20)
		{
			scrollAcceleration = jmin (4.0, scrollAcceleration * 1.04);
			int amount = 0;

			for (int i = 0; i < items.size() && amount == 0; ++i)
				amount = ((int) scrollAcceleration) * items.getUnchecked(i)->getHeight();

			alterChildYPos (amount * direction);
			lastScrollTime = timeNow;
		}

		lastMousePos = Point<int> (-1, -1); // to trigger a mouse-move
		return true;
	}

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (Window);
};

PopupMenu::PopupMenu()
	: lookAndFeel (nullptr)
{
}

PopupMenu::PopupMenu (const PopupMenu& other)
	: lookAndFeel (other.lookAndFeel)
{
	items.addCopiesOf (other.items);
}

PopupMenu& PopupMenu::operator= (const PopupMenu& other)
{
	if (this != &other)
	{
		lookAndFeel = other.lookAndFeel;

		clear();
		items.addCopiesOf (other.items);
	}

	return *this;
}

#if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
PopupMenu::PopupMenu (PopupMenu&& other) noexcept
	: lookAndFeel (other.lookAndFeel)
{
	items.swapWithArray (other.items);
}

PopupMenu& PopupMenu::operator= (PopupMenu&& other) noexcept
{
	jassert (this != &other); // hopefully the compiler should make this situation impossible!

	items.swapWithArray (other.items);
	lookAndFeel = other.lookAndFeel;
	return *this;
}
#endif

PopupMenu::~PopupMenu()
{
}

void PopupMenu::clear()
{
	items.clear();
}

void PopupMenu::addItem (const int itemResultId, const String& itemText,
						 const bool isActive, const bool isTicked, const Image& iconToUse)
{
	jassert (itemResultId != 0);    // 0 is used as a return value to indicate that the user
									// didn't pick anything, so you shouldn't use it as the id
									// for an item..

	items.add (new Item (itemResultId, itemText, isActive, isTicked, iconToUse,
						 Colours::black, false, nullptr, nullptr, nullptr));
}

void PopupMenu::addCommandItem (ApplicationCommandManager* commandManager,
								const int commandID,
								const String& displayName)
{
	jassert (commandManager != nullptr && commandID != 0);

	const ApplicationCommandInfo* const registeredInfo = commandManager->getCommandForID (commandID);

	if (registeredInfo != nullptr)
	{
		ApplicationCommandInfo info (*registeredInfo);
		ApplicationCommandTarget* const target = commandManager->getTargetForCommand (commandID, info);

		items.add (new Item (commandID,
							 displayName.isNotEmpty() ? displayName
													  : info.shortName,
							 target != nullptr && (info.flags & ApplicationCommandInfo::isDisabled) == 0,
							 (info.flags & ApplicationCommandInfo::isTicked) != 0,
							 Image::null,
							 Colours::black,
							 false,
							 nullptr, nullptr,
							 commandManager));
	}
}

void PopupMenu::addColouredItem (const int itemResultId,
								 const String& itemText,
								 const Colour& itemTextColour,
								 const bool isActive,
								 const bool isTicked,
								 const Image& iconToUse)
{
	jassert (itemResultId != 0);    // 0 is used as a return value to indicate that the user
									// didn't pick anything, so you shouldn't use it as the id
									// for an item..

	items.add (new Item (itemResultId, itemText, isActive, isTicked, iconToUse,
						 itemTextColour, true, nullptr, nullptr, nullptr));
}

void PopupMenu::addCustomItem (const int itemResultId, CustomComponent* const customComponent)
{
	jassert (itemResultId != 0);    // 0 is used as a return value to indicate that the user
									// didn't pick anything, so you shouldn't use it as the id
									// for an item..

	items.add (new Item (itemResultId, String::empty, true, false, Image::null,
						 Colours::black, false, customComponent, nullptr, nullptr));
}

class NormalComponentWrapper : public PopupMenu::CustomComponent
{
public:
	NormalComponentWrapper (Component* const comp, const int w, const int h,
							const bool triggerMenuItemAutomaticallyWhenClicked)
		: PopupMenu::CustomComponent (triggerMenuItemAutomaticallyWhenClicked),
		  width (w), height (h)
	{
		addAndMakeVisible (comp);
	}

	void getIdealSize (int& idealWidth, int& idealHeight)
	{
		idealWidth = width;
		idealHeight = height;
	}

	void resized()
	{
		if (getChildComponent(0) != nullptr)
			getChildComponent(0)->setBounds (getLocalBounds());
	}

private:
	const int width, height;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (NormalComponentWrapper);
};

void PopupMenu::addCustomItem (const int itemResultId,
							   Component* customComponent,
							   int idealWidth, int idealHeight,
							   const bool triggerMenuItemAutomaticallyWhenClicked)
{
	addCustomItem (itemResultId,
				   new NormalComponentWrapper (customComponent, idealWidth, idealHeight,
											   triggerMenuItemAutomaticallyWhenClicked));
}

void PopupMenu::addSubMenu (const String& subMenuName,
							const PopupMenu& subMenu,
							const bool isActive,
							const Image& iconToUse,
							const bool isTicked)
{
	items.add (new Item (0, subMenuName, isActive && (subMenu.getNumItems() > 0), isTicked,
						 iconToUse, Colours::black, false, nullptr, &subMenu, nullptr));
}

void PopupMenu::addSeparator()
{
	if (items.size() > 0 && ! items.getLast()->isSeparator)
		items.add (new Item());
}

class HeaderItemComponent  : public PopupMenu::CustomComponent
{
public:
	HeaderItemComponent (const String& name)
		: PopupMenu::CustomComponent (false)
	{
		setName (name);
	}

	void paint (Graphics& g)
	{
		Font f (getLookAndFeel().getPopupMenuFont());
		f.setBold (true);
		g.setFont (f);
		g.setColour (findColour (PopupMenu::headerTextColourId));

		g.drawFittedText (getName(),
						  12, 0, getWidth() - 16, proportionOfHeight (0.8f),
						  Justification::bottomLeft, 1);
	}

	void getIdealSize (int& idealWidth, int& idealHeight)
	{
		getLookAndFeel().getIdealPopupMenuItemSize (getName(), false, -1, idealWidth, idealHeight);
		idealHeight += idealHeight / 2;
		idealWidth += idealWidth / 4;
	}

private:
	JUCE_LEAK_DETECTOR (HeaderItemComponent);
};

void PopupMenu::addSectionHeader (const String& title)
{
	addCustomItem (0X4734a34f, new HeaderItemComponent (title));
}

PopupMenu::Options::Options()
	: targetComponent (nullptr),
	  visibleItemID (0),
	  minWidth (0),
	  maxColumns (0),
	  standardHeight (0)
{
	targetArea.setPosition (Desktop::getMousePosition());
}

PopupMenu::Options PopupMenu::Options::withTargetComponent (Component* comp) const noexcept
{
	Options o (*this);
	o.targetComponent = comp;

	if (comp != nullptr)
		o.targetArea = comp->getScreenBounds();

	return o;
}

PopupMenu::Options PopupMenu::Options::withTargetScreenArea (const Rectangle<int>& area) const noexcept
{
	Options o (*this);
	o.targetArea = area;
	return o;
}

PopupMenu::Options PopupMenu::Options::withMinimumWidth (int w) const noexcept
{
	Options o (*this);
	o.minWidth = w;
	return o;
}

PopupMenu::Options PopupMenu::Options::withMaximumNumColumns (int cols) const noexcept
{
	Options o (*this);
	o.maxColumns = cols;
	return o;
}

PopupMenu::Options PopupMenu::Options::withStandardItemHeight (int height) const noexcept
{
	Options o (*this);
	o.standardHeight = height;
	return o;
}

PopupMenu::Options PopupMenu::Options::withItemThatMustBeVisible (int idOfItemToBeVisible) const noexcept
{
	Options o (*this);
	o.visibleItemID = idOfItemToBeVisible;
	return o;
}

Component* PopupMenu::createWindow (const Options& options,
									ApplicationCommandManager** managerOfChosenCommand) const
{
	if (items.size() > 0)
		return new Window (*this, nullptr, options,
						   ! options.targetArea.isEmpty(),
						   ModifierKeys::getCurrentModifiers().isAnyMouseButtonDown(),
						   managerOfChosenCommand);

	return nullptr;
}

// This invokes any command manager commands and deletes the menu window when it is dismissed
class PopupMenuCompletionCallback  : public ModalComponentManager::Callback
{
public:
	PopupMenuCompletionCallback()
		: managerOfChosenCommand (nullptr),
		  prevFocused (Component::getCurrentlyFocusedComponent()),
		  prevTopLevel (prevFocused != nullptr ? prevFocused->getTopLevelComponent() : 0)
	{
		PopupMenuSettings::menuWasHiddenBecauseOfAppChange = false;
	}

	void modalStateFinished (int result)
	{
		if (managerOfChosenCommand != nullptr && result != 0)
		{
			ApplicationCommandTarget::InvocationInfo info (result);
			info.invocationMethod = ApplicationCommandTarget::InvocationInfo::fromMenu;

			managerOfChosenCommand->invoke (info, true);
		}

		// (this would be the place to fade out the component, if that's what's required)
		component = nullptr;

		if (! PopupMenuSettings::menuWasHiddenBecauseOfAppChange)
		{
			if (prevTopLevel != nullptr)
				prevTopLevel->toFront (true);

			if (prevFocused != nullptr)
				prevFocused->grabKeyboardFocus();
		}
	}

	ApplicationCommandManager* managerOfChosenCommand;
	ScopedPointer<Component> component;
	WeakReference<Component> prevFocused, prevTopLevel;

private:
	JUCE_DECLARE_NON_COPYABLE (PopupMenuCompletionCallback);
};

int PopupMenu::showWithOptionalCallback (const Options& options, ModalComponentManager::Callback* const userCallback,
										 const bool canBeModal)
{
	ScopedPointer<ModalComponentManager::Callback> userCallbackDeleter (userCallback);
	ScopedPointer<PopupMenuCompletionCallback> callback (new PopupMenuCompletionCallback());

	Component* window = createWindow (options, &(callback->managerOfChosenCommand));
	if (window == nullptr)
		return 0;

	callback->component = window;

	window->setVisible (true); // (must be called before enterModalState on Windows to avoid DropShadower confusion)
	window->enterModalState (false, userCallbackDeleter.release());
	ModalComponentManager::getInstance()->attachCallback (window, callback.release());

	window->toFront (false);  // need to do this after making it modal, or it could
							  // be stuck behind other comps that are already modal..

   #if JUCE_MODAL_LOOPS_PERMITTED
	return (userCallback == nullptr && canBeModal) ? window->runModalLoop() : 0;
   #else
	jassert (userCallback != nullptr && canBeModal);
	return 0;
   #endif
}

#if JUCE_MODAL_LOOPS_PERMITTED
int PopupMenu::showMenu (const Options& options)
{
	return showWithOptionalCallback (options, 0, true);
}
#endif

void PopupMenu::showMenuAsync (const Options& options, ModalComponentManager::Callback* userCallback)
{
   #if ! JUCE_MODAL_LOOPS_PERMITTED
	jassert (userCallback != nullptr);
   #endif

	showWithOptionalCallback (options, userCallback, false);
}

#if JUCE_MODAL_LOOPS_PERMITTED
int PopupMenu::show (const int itemIdThatMustBeVisible,
					 const int minimumWidth, const int maximumNumColumns,
					 const int standardItemHeight,
					 ModalComponentManager::Callback* callback)
{
	return showWithOptionalCallback (Options().withItemThatMustBeVisible (itemIdThatMustBeVisible)
											  .withMinimumWidth (minimumWidth)
											  .withMaximumNumColumns (maximumNumColumns)
											  .withStandardItemHeight (standardItemHeight),
									 callback, true);
}

int PopupMenu::showAt (const Rectangle<int>& screenAreaToAttachTo,
					   const int itemIdThatMustBeVisible,
					   const int minimumWidth, const int maximumNumColumns,
					   const int standardItemHeight,
					   ModalComponentManager::Callback* callback)
{
	return showWithOptionalCallback (Options().withTargetScreenArea (screenAreaToAttachTo)
											  .withItemThatMustBeVisible (itemIdThatMustBeVisible)
											  .withMinimumWidth (minimumWidth)
											  .withMaximumNumColumns (maximumNumColumns)
											  .withStandardItemHeight (standardItemHeight),
									 callback, true);
}

int PopupMenu::showAt (Component* componentToAttachTo,
					   const int itemIdThatMustBeVisible,
					   const int minimumWidth, const int maximumNumColumns,
					   const int standardItemHeight,
					   ModalComponentManager::Callback* callback)
{
	Options options (Options().withItemThatMustBeVisible (itemIdThatMustBeVisible)
							  .withMinimumWidth (minimumWidth)
							  .withMaximumNumColumns (maximumNumColumns)
							  .withStandardItemHeight (standardItemHeight));

	if (componentToAttachTo != nullptr)
		options = options.withTargetComponent (componentToAttachTo);

	return showWithOptionalCallback (options, callback, true);
}
#endif

bool JUCE_CALLTYPE PopupMenu::dismissAllActiveMenus()
{
	Array<Window*>& windows = Window::getActiveWindows();

	const int numWindows = windows.size();
	for (int i = numWindows; --i >= 0;)
	{
		Window* const pmw = windows[i];

		if (pmw != nullptr)
			pmw->dismissMenu (nullptr);
	}

	return numWindows > 0;
}

int PopupMenu::getNumItems() const noexcept
{
	int num = 0;

	for (int i = items.size(); --i >= 0;)
		if (! items.getUnchecked(i)->isSeparator)
			++num;

	return num;
}

bool PopupMenu::containsCommandItem (const int commandID) const
{
	for (int i = items.size(); --i >= 0;)
	{
		const Item* const mi = items.getUnchecked (i);

		if ((mi->itemId == commandID && mi->commandManager != nullptr)
			 || (mi->subMenu != nullptr && mi->subMenu->containsCommandItem (commandID)))
		{
			return true;
		}
	}

	return false;
}

bool PopupMenu::containsAnyActiveItems() const noexcept
{
	for (int i = items.size(); --i >= 0;)
	{
		const Item* const mi = items.getUnchecked (i);

		if (mi->subMenu != nullptr)
		{
			if (mi->subMenu->containsAnyActiveItems())
				return true;
		}
		else if (mi->active)
		{
			return true;
		}
	}

	return false;
}

void PopupMenu::setLookAndFeel (LookAndFeel* const newLookAndFeel)
{
	lookAndFeel = newLookAndFeel;
}

PopupMenu::CustomComponent::CustomComponent (const bool isTriggeredAutomatically_)
	: isHighlighted (false),
	  triggeredAutomatically (isTriggeredAutomatically_)
{
}

PopupMenu::CustomComponent::~CustomComponent()
{
}

void PopupMenu::CustomComponent::setHighlighted (bool shouldBeHighlighted)
{
	isHighlighted = shouldBeHighlighted;
	repaint();
}

void PopupMenu::CustomComponent::triggerMenuItem()
{
	PopupMenu::ItemComponent* const mic = dynamic_cast <PopupMenu::ItemComponent*> (getParentComponent());

	if (mic != nullptr)
	{
		PopupMenu::Window* const pmw = dynamic_cast <PopupMenu::Window*> (mic->getParentComponent());

		if (pmw != nullptr)
		{
			pmw->dismissMenu (&mic->itemInfo);
		}
		else
		{
			// something must have gone wrong with the component hierarchy if this happens..
			jassertfalse;
		}
	}
	else
	{
		// why isn't this component inside a menu? Not much point triggering the item if
		// there's no menu.
		jassertfalse;
	}
}

PopupMenu::MenuItemIterator::MenuItemIterator (const PopupMenu& menu_)
	: subMenu (nullptr),
	  itemId (0),
	  isSeparator (false),
	  isTicked (false),
	  isEnabled (false),
	  isCustomComponent (false),
	  isSectionHeader (false),
	  customColour (nullptr),
	  menu (menu_),
	  index (0)
{
}

PopupMenu::MenuItemIterator::~MenuItemIterator()
{
}

bool PopupMenu::MenuItemIterator::next()
{
	if (index >= menu.items.size())
		return false;

	const Item* const item = menu.items.getUnchecked (index);
	++index;

	if (item->isSeparator && index >= menu.items.size()) // (avoid showing a separator at the end)
		return false;

	itemName        = item->customComp != nullptr ? item->customComp->getName() : item->text;
	subMenu         = item->subMenu;
	itemId          = item->itemId;
	isSeparator     = item->isSeparator;
	isTicked        = item->isTicked;
	isEnabled       = item->active;
	isSectionHeader = dynamic_cast <HeaderItemComponent*> (static_cast <CustomComponent*> (item->customComp)) != nullptr;
	isCustomComponent = (! isSectionHeader) && item->customComp != nullptr;
	customColour    = item->usesColour ? &(item->textColour) : nullptr;
	customImage     = item->image;
	commandManager  = item->commandManager;

	return true;
}

/*** End of inlined file: juce_PopupMenu.cpp ***/


/*** Start of inlined file: juce_MarkerList.cpp ***/
MarkerList::MarkerList()
{
}

MarkerList::MarkerList (const MarkerList& other)
{
	operator= (other);
}

MarkerList& MarkerList::operator= (const MarkerList& other)
{
	if (other != *this)
	{
		markers.clear();
		markers.addCopiesOf (other.markers);
		markersHaveChanged();
	}

	return *this;
}

MarkerList::~MarkerList()
{
	listeners.call (&MarkerList::Listener::markerListBeingDeleted, this);
}

bool MarkerList::operator== (const MarkerList& other) const noexcept
{
	if (other.markers.size() != markers.size())
		return false;

	for (int i = markers.size(); --i >= 0;)
	{
		const Marker* const m1 = markers.getUnchecked(i);
		jassert (m1 != nullptr);

		const Marker* const m2 = other.getMarker (m1->name);

		if (m2 == nullptr || *m1 != *m2)
			return false;
	}

	return true;
}

bool MarkerList::operator!= (const MarkerList& other) const noexcept
{
	return ! operator== (other);
}

int MarkerList::getNumMarkers() const noexcept
{
	return markers.size();
}

const MarkerList::Marker* MarkerList::getMarker (const int index) const noexcept
{
	return markers [index];
}

const MarkerList::Marker* MarkerList::getMarker (const String& name) const noexcept
{
	return getMarkerByName (name);
}

MarkerList::Marker* MarkerList::getMarkerByName (const String& name) const noexcept
{
	for (int i = 0; i < markers.size(); ++i)
	{
		Marker* const m = markers.getUnchecked(i);

		if (m->name == name)
			return m;
	}

	return nullptr;
}

void MarkerList::setMarker (const String& name, const RelativeCoordinate& position)
{
	Marker* const m = getMarkerByName (name);

	if (m != nullptr)
	{
		if (m->position != position)
		{
			m->position = position;
			markersHaveChanged();
		}

		return;
	}

	markers.add (new Marker (name, position));
	markersHaveChanged();
}

void MarkerList::removeMarker (const int index)
{
	if (isPositiveAndBelow (index, markers.size()))
	{
		markers.remove (index);
		markersHaveChanged();
	}
}

void MarkerList::removeMarker (const String& name)
{
	for (int i = 0; i < markers.size(); ++i)
	{
		const Marker* const m = markers.getUnchecked(i);

		if (m->name == name)
		{
			markers.remove (i);
			markersHaveChanged();
		}
	}
}

void MarkerList::markersHaveChanged()
{
	listeners.call (&MarkerList::Listener::markersChanged, this);
}

void MarkerList::Listener::markerListBeingDeleted (MarkerList*)
{
}

void MarkerList::addListener (Listener* listener)
{
	listeners.add (listener);
}

void MarkerList::removeListener (Listener* listener)
{
	listeners.remove (listener);
}

MarkerList::Marker::Marker (const Marker& other)
	: name (other.name), position (other.position)
{
}

MarkerList::Marker::Marker (const String& name_, const RelativeCoordinate& position_)
	: name (name_), position (position_)
{
}

bool MarkerList::Marker::operator== (const Marker& other) const noexcept
{
	return name == other.name && position == other.position;
}

bool MarkerList::Marker::operator!= (const Marker& other) const noexcept
{
	return ! operator== (other);
}

const Identifier MarkerList::ValueTreeWrapper::markerTag ("Marker");
const Identifier MarkerList::ValueTreeWrapper::nameProperty ("name");
const Identifier MarkerList::ValueTreeWrapper::posProperty ("position");

MarkerList::ValueTreeWrapper::ValueTreeWrapper (const ValueTree& state_)
	: state (state_)
{
}

int MarkerList::ValueTreeWrapper::getNumMarkers() const
{
	return state.getNumChildren();
}

ValueTree MarkerList::ValueTreeWrapper::getMarkerState (int index) const
{
	return state.getChild (index);
}

ValueTree MarkerList::ValueTreeWrapper::getMarkerState (const String& name) const
{
	return state.getChildWithProperty (nameProperty, name);
}

bool MarkerList::ValueTreeWrapper::containsMarker (const ValueTree& marker) const
{
	return marker.isAChildOf (state);
}

MarkerList::Marker MarkerList::ValueTreeWrapper::getMarker (const ValueTree& marker) const
{
	jassert (containsMarker (marker));

	return MarkerList::Marker (marker [nameProperty], RelativeCoordinate (marker [posProperty].toString()));
}

void MarkerList::ValueTreeWrapper::setMarker (const MarkerList::Marker& m, UndoManager* undoManager)
{
	ValueTree marker (state.getChildWithProperty (nameProperty, m.name));

	if (marker.isValid())
	{
		marker.setProperty (posProperty, m.position.toString(), undoManager);
	}
	else
	{
		marker = ValueTree (markerTag);
		marker.setProperty (nameProperty, m.name, nullptr);
		marker.setProperty (posProperty, m.position.toString(), nullptr);
		state.addChild (marker, -1, undoManager);
	}
}

void MarkerList::ValueTreeWrapper::removeMarker (const ValueTree& marker, UndoManager* undoManager)
{
	state.removeChild (marker, undoManager);
}

double MarkerList::getMarkerPosition (const Marker& marker, Component* parentComponent) const
{
	if (parentComponent != nullptr)
	{
		RelativeCoordinatePositionerBase::ComponentScope scope (*parentComponent);
		return marker.position.resolve (&scope);
	}
	else
	{
		return marker.position.resolve (nullptr);
	}
}

void MarkerList::ValueTreeWrapper::applyTo (MarkerList& markerList)
{
	const int numMarkers = getNumMarkers();

	StringArray updatedMarkers;

	int i;
	for (i = 0; i < numMarkers; ++i)
	{
		const ValueTree marker (state.getChild (i));
		const String name (marker [nameProperty].toString());
		markerList.setMarker (name, RelativeCoordinate (marker [posProperty].toString()));
		updatedMarkers.add (name);
	}

	for (i = markerList.getNumMarkers(); --i >= 0;)
		if (! updatedMarkers.contains (markerList.getMarker (i)->name))
			markerList.removeMarker (i);
}

void MarkerList::ValueTreeWrapper::readFrom (const MarkerList& markerList, UndoManager* undoManager)
{
	state.removeAllChildren (undoManager);

	for (int i = 0; i < markerList.getNumMarkers(); ++i)
		setMarker (*markerList.getMarker(i), undoManager);
}

/*** End of inlined file: juce_MarkerList.cpp ***/


/*** Start of inlined file: juce_RelativeCoordinate.cpp ***/
const String RelativeCoordinate::Strings::parent ("parent");
const String RelativeCoordinate::Strings::left ("left");
const String RelativeCoordinate::Strings::right ("right");
const String RelativeCoordinate::Strings::top ("top");
const String RelativeCoordinate::Strings::bottom ("bottom");
const String RelativeCoordinate::Strings::x ("x");
const String RelativeCoordinate::Strings::y ("y");
const String RelativeCoordinate::Strings::width ("width");
const String RelativeCoordinate::Strings::height ("height");

RelativeCoordinate::StandardStrings::Type RelativeCoordinate::StandardStrings::getTypeOf (const String& s) noexcept
{
	if (s == Strings::left)    return left;
	if (s == Strings::right)   return right;
	if (s == Strings::top)     return top;
	if (s == Strings::bottom)  return bottom;
	if (s == Strings::x)       return x;
	if (s == Strings::y)       return y;
	if (s == Strings::width)   return width;
	if (s == Strings::height)  return height;
	if (s == Strings::parent)  return parent;
	return unknown;
}

RelativeCoordinate::RelativeCoordinate()
{
}

RelativeCoordinate::RelativeCoordinate (const Expression& term_)
	: term (term_)
{
}

RelativeCoordinate::RelativeCoordinate (const RelativeCoordinate& other)
	: term (other.term)
{
}

RelativeCoordinate& RelativeCoordinate::operator= (const RelativeCoordinate& other)
{
	term = other.term;
	return *this;
}

#if JUCE_COMPILER_SUPPORTS_MOVE_SEMANTICS
RelativeCoordinate::RelativeCoordinate (RelativeCoordinate&& other) noexcept
	: term (static_cast <Expression&&> (other.term))
{
}

RelativeCoordinate& RelativeCoordinate::operator= (RelativeCoordinate&& other) noexcept
{
	term = static_cast <Expression&&> (other.term);
	return *this;
}
#endif

RelativeCoordinate::RelativeCoordinate (const double absoluteDistanceFromOrigin)
	: term (absoluteDistanceFromOrigin)
{
}

RelativeCoordinate::RelativeCoordinate (const String& s)
{
	try
	{
		term = Expression (s);
	}
	catch (Expression::ParseError&)
	{}
}

RelativeCoordinate::~RelativeCoordinate()
{
}

bool RelativeCoordinate::operator== (const RelativeCoordinate& other) const noexcept
{
	return term.toString() == other.term.toString();
}

bool RelativeCoordinate::operator!= (const RelativeCoordinate& other) const noexcept
{
	return ! operator== (other);
}

double RelativeCoordinate::resolve (const Expression::Scope* scope) const
{
	try
	{
		if (scope != nullptr)
			return term.evaluate (*scope);
		else
			return term.evaluate();
	}
	catch (Expression::ParseError&)
	{}

	return 0.0;
}

bool RelativeCoordinate::isRecursive (const Expression::Scope* scope) const
{
	try
	{
		if (scope != nullptr)
			term.evaluate (*scope);
		else
			term.evaluate();
	}
	catch (Expression::ParseError&)
	{
		return true;
	}

	return false;
}

void RelativeCoordinate::moveToAbsolute (double newPos, const Expression::Scope* scope)
{
	try
	{
		if (scope != nullptr)
		{
			term = term.adjustedToGiveNewResult (newPos, *scope);
		}
		else
		{
			Expression::Scope defaultScope;
			term = term.adjustedToGiveNewResult (newPos, defaultScope);
		}
	}
	catch (Expression::ParseError&)
	{}
}

bool RelativeCoordinate::isDynamic() const
{
	return term.usesAnySymbols();
}

String RelativeCoordinate::toString() const
{
	return term.toString();
}

/*** End of inlined file: juce_RelativeCoordinate.cpp ***/


/*** Start of inlined file: juce_RelativeCoordinatePositioner.cpp ***/
class MarkerListScope  : public Expression::Scope
{
public:
	MarkerListScope (Component& component_) : component (component_) {}

	Expression getSymbolValue (const String& symbol) const
	{
		switch (RelativeCoordinate::StandardStrings::getTypeOf (symbol))
		{
			case RelativeCoordinate::StandardStrings::width:  return Expression ((double) component.getWidth());
			case RelativeCoordinate::StandardStrings::height: return Expression ((double) component.getHeight());
			default: break;
		}

		MarkerList* list;
		const MarkerList::Marker* const marker = findMarker (component, symbol, list);

		if (marker != nullptr)
			return Expression (marker->position.getExpression().evaluate (*this));

		return Expression::Scope::getSymbolValue (symbol);
	}

	void visitRelativeScope (const String& scopeName, Visitor& visitor) const
	{
		if (scopeName == RelativeCoordinate::Strings::parent)
		{
			Component* const parent = component.getParentComponent();

			if (parent != nullptr)
			{
				visitor.visit (MarkerListScope (*parent));
				return;
			}
		}

		Expression::Scope::visitRelativeScope (scopeName, visitor);
	}

	String getScopeUID() const
	{
		return String::toHexString ((pointer_sized_int) (void*) &component) + "m";
	}

	static const MarkerList::Marker* findMarker (Component& component, const String& name, MarkerList*& list)
	{
		const MarkerList::Marker* marker = nullptr;
		list = component.getMarkers (true);

		if (list != nullptr)
			marker = list->getMarker (name);

		if (marker == nullptr)
		{
			list = component.getMarkers (false);

			if (list != nullptr)
				marker = list->getMarker (name);
		}

		return marker;
	}

private:
	Component& component;

	JUCE_DECLARE_NON_COPYABLE (MarkerListScope);
};

RelativeCoordinatePositionerBase::ComponentScope::ComponentScope (Component& component_)
	: component (component_)
{
}

Expression RelativeCoordinatePositionerBase::ComponentScope::getSymbolValue (const String& symbol) const
{
	switch (RelativeCoordinate::StandardStrings::getTypeOf (symbol))
	{
		case RelativeCoordinate::StandardStrings::x:
		case RelativeCoordinate::StandardStrings::left:   return Expression ((double) component.getX());
		case RelativeCoordinate::StandardStrings::y:
		case RelativeCoordinate::StandardStrings::top:    return Expression ((double) component.getY());
		case RelativeCoordinate::StandardStrings::width:  return Expression ((double) component.getWidth());
		case RelativeCoordinate::StandardStrings::height: return Expression ((double) component.getHeight());
		case RelativeCoordinate::StandardStrings::right:  return Expression ((double) component.getRight());
		case RelativeCoordinate::StandardStrings::bottom: return Expression ((double) component.getBottom());
		default: break;
	}

	Component* const parent = component.getParentComponent();

	if (parent != nullptr)
	{
		MarkerList* list;
		const MarkerList::Marker* const marker = MarkerListScope::findMarker (*parent, symbol, list);

		if (marker != nullptr)
		{
			MarkerListScope scope (*parent);
			return Expression (marker->position.getExpression().evaluate (scope));
		}
	}

	return Expression::Scope::getSymbolValue (symbol);
}

void RelativeCoordinatePositionerBase::ComponentScope::visitRelativeScope (const String& scopeName, Visitor& visitor) const
{
	Component* const targetComp = (scopeName == RelativeCoordinate::Strings::parent)
										? component.getParentComponent()
										: findSiblingComponent (scopeName);

	if (targetComp != nullptr)
		visitor.visit (ComponentScope (*targetComp));
	else
		Expression::Scope::visitRelativeScope (scopeName, visitor);
}

String RelativeCoordinatePositionerBase::ComponentScope::getScopeUID() const
{
	return String::toHexString ((pointer_sized_int) (void*) &component);
}

Component* RelativeCoordinatePositionerBase::ComponentScope::findSiblingComponent (const String& componentID) const
{
	Component* const parent = component.getParentComponent();

	return parent != nullptr ? parent->findChildWithID (componentID)
							 : nullptr;
}

class RelativeCoordinatePositionerBase::DependencyFinderScope  : public ComponentScope
{
public:
	DependencyFinderScope (Component& component_, RelativeCoordinatePositionerBase& positioner_, bool& ok_)
		: ComponentScope (component_), positioner (positioner_), ok (ok_)
	{
	}

	Expression getSymbolValue (const String& symbol) const
	{
		switch (RelativeCoordinate::StandardStrings::getTypeOf (symbol))
		{
			case RelativeCoordinate::StandardStrings::x:
			case RelativeCoordinate::StandardStrings::left:
			case RelativeCoordinate::StandardStrings::y:
			case RelativeCoordinate::StandardStrings::top:
			case RelativeCoordinate::StandardStrings::width:
			case RelativeCoordinate::StandardStrings::height:
			case RelativeCoordinate::StandardStrings::right:
			case RelativeCoordinate::StandardStrings::bottom:
				positioner.registerComponentListener (component);
				break;

			default:
			{
				Component* const parent = component.getParentComponent();
				if (parent != nullptr)
				{
					MarkerList* list;
					const MarkerList::Marker* marker = MarkerListScope::findMarker (*parent, symbol, list);

					if (marker != nullptr)
					{
						positioner.registerMarkerListListener (list);
					}
					else
					{
						// The marker we want doesn't exist, so watch all lists in case they change and the marker appears later..
						positioner.registerMarkerListListener (parent->getMarkers (true));
						positioner.registerMarkerListListener (parent->getMarkers (false));
						ok = false;
					}
				}
			}
			break;
		}

		return ComponentScope::getSymbolValue (symbol);
	}

	void visitRelativeScope (const String& scopeName, Visitor& visitor) const
	{
		Component* const targetComp = (scopeName == RelativeCoordinate::Strings::parent)
											? component.getParentComponent()
											: findSiblingComponent (scopeName);

		if (targetComp != nullptr)
		{
			visitor.visit (DependencyFinderScope (*targetComp, positioner, ok));
		}
		else
		{
			// The named component doesn't exist, so we'll watch the parent for changes in case it appears later..
			Component* const parent = component.getParentComponent();
			if (parent != nullptr)
				positioner.registerComponentListener (*parent);

			positioner.registerComponentListener (component);
			ok = false;
		}
	}

private:
	RelativeCoordinatePositionerBase& positioner;
	bool& ok;

	JUCE_DECLARE_NON_COPYABLE (DependencyFinderScope);
};

RelativeCoordinatePositionerBase::RelativeCoordinatePositionerBase (Component& component_)
	: Component::Positioner (component_), registeredOk (false)
{
}

RelativeCoordinatePositionerBase::~RelativeCoordinatePositionerBase()
{
	unregisterListeners();
}

void RelativeCoordinatePositionerBase::componentMovedOrResized (Component&, bool /*wasMoved*/, bool /*wasResized*/)
{
	apply();
}

void RelativeCoordinatePositionerBase::componentParentHierarchyChanged (Component&)
{
	apply();
}

void RelativeCoordinatePositionerBase::componentChildrenChanged (Component& changed)
{
	if (getComponent().getParentComponent() == &changed && ! registeredOk)
		apply();
}

void RelativeCoordinatePositionerBase::componentBeingDeleted (Component& comp)
{
	jassert (sourceComponents.contains (&comp));
	sourceComponents.removeValue (&comp);
	registeredOk = false;
}

void RelativeCoordinatePositionerBase::markersChanged (MarkerList*)
{
	apply();
}

void RelativeCoordinatePositionerBase::markerListBeingDeleted (MarkerList* markerList)
{
	jassert (sourceMarkerLists.contains (markerList));
	sourceMarkerLists.removeValue (markerList);
}

void RelativeCoordinatePositionerBase::apply()
{
	if (! registeredOk)
	{
		unregisterListeners();
		registeredOk = registerCoordinates();
	}

	applyToComponentBounds();
}

bool RelativeCoordinatePositionerBase::addCoordinate (const RelativeCoordinate& coord)
{
	bool ok = true;
	DependencyFinderScope finderScope (getComponent(), *this, ok);
	coord.getExpression().evaluate (finderScope);
	return ok;
}

bool RelativeCoordinatePositionerBase::addPoint (const RelativePoint& point)
{
	const bool ok = addCoordinate (point.x);
	return addCoordinate (point.y) && ok;
}

void RelativeCoordinatePositionerBase::registerComponentListener (Component& comp)
{
	if (! sourceComponents.contains (&comp))
	{
		comp.addComponentListener (this);
		sourceComponents.add (&comp);
	}
}

void RelativeCoordinatePositionerBase::registerMarkerListListener (MarkerList* const list)
{
	if (list != nullptr && ! sourceMarkerLists.contains (list))
	{
		list->addListener (this);
		sourceMarkerLists.add (list);
	}
}

void RelativeCoordinatePositionerBase::unregisterListeners()
{
	int i;
	for (i = sourceComponents.size(); --i >= 0;)
		sourceComponents.getUnchecked(i)->removeComponentListener (this);

	for (i = sourceMarkerLists.size(); --i >= 0;)
		sourceMarkerLists.getUnchecked(i)->removeListener (this);

	sourceComponents.clear();
	sourceMarkerLists.clear();
}

/*** End of inlined file: juce_RelativeCoordinatePositioner.cpp ***/


/*** Start of inlined file: juce_RelativeParallelogram.cpp ***/
RelativeParallelogram::RelativeParallelogram()
{
}

RelativeParallelogram::RelativeParallelogram (const Rectangle<float>& r)
	: topLeft (r.getTopLeft()), topRight (r.getTopRight()), bottomLeft (r.getBottomLeft())
{
}

RelativeParallelogram::RelativeParallelogram (const RelativePoint& topLeft_, const RelativePoint& topRight_, const RelativePoint& bottomLeft_)
	: topLeft (topLeft_), topRight (topRight_), bottomLeft (bottomLeft_)
{
}

RelativeParallelogram::RelativeParallelogram (const String& topLeft_, const String& topRight_, const String& bottomLeft_)
	: topLeft (topLeft_), topRight (topRight_), bottomLeft (bottomLeft_)
{
}

RelativeParallelogram::~RelativeParallelogram()
{
}

void RelativeParallelogram::resolveThreePoints (Point<float>* points, Expression::Scope* const scope) const
{
	points[0] = topLeft.resolve (scope);
	points[1] = topRight.resolve (scope);
	points[2] = bottomLeft.resolve (scope);
}

void RelativeParallelogram::resolveFourCorners (Point<float>* points, Expression::Scope* const scope) const
{
	resolveThreePoints (points, scope);
	points[3] = points[1] + (points[2] - points[0]);
}

const Rectangle<float> RelativeParallelogram::getBounds (Expression::Scope* const scope) const
{
	Point<float> points[4];
	resolveFourCorners (points, scope);
	return Rectangle<float>::findAreaContainingPoints (points, 4);
}

void RelativeParallelogram::getPath (Path& path, Expression::Scope* const scope) const
{
	Point<float> points[4];
	resolveFourCorners (points, scope);

	path.startNewSubPath (points[0]);
	path.lineTo (points[1]);
	path.lineTo (points[3]);
	path.lineTo (points[2]);
	path.closeSubPath();
}

const AffineTransform RelativeParallelogram::resetToPerpendicular (Expression::Scope* const scope)
{
	Point<float> corners[3];
	resolveThreePoints (corners, scope);

	const Line<float> top (corners[0], corners[1]);
	const Line<float> left (corners[0], corners[2]);
	const Point<float> newTopRight (corners[0] + Point<float> (top.getLength(), 0.0f));
	const Point<float> newBottomLeft (corners[0] + Point<float> (0.0f, left.getLength()));

	topRight.moveToAbsolute (newTopRight, scope);
	bottomLeft.moveToAbsolute (newBottomLeft, scope);

	return AffineTransform::fromTargetPoints (corners[0].x, corners[0].y, corners[0].x, corners[0].y,
											  corners[1].x, corners[1].y, newTopRight.x, newTopRight.y,
											  corners[2].x, corners[2].y, newBottomLeft.x, newBottomLeft.y);
}

bool RelativeParallelogram::isDynamic() const
{
	return topLeft.isDynamic() || topRight.isDynamic() || bottomLeft.isDynamic();
}

bool RelativeParallelogram::operator== (const RelativeParallelogram& other) const noexcept
{
	return topLeft == other.topLeft && topRight == other.topRight && bottomLeft == other.bottomLeft;
}

bool RelativeParallelogram::operator!= (const RelativeParallelogram& other) const noexcept
{
	return ! operator== (other);
}

const Point<float> RelativeParallelogram::getInternalCoordForPoint (const Point<float>* const corners, Point<float> target) noexcept
{
	const Point<float> tr (corners[1] - corners[0]);
	const Point<float> bl (corners[2] - corners[0]);
	target -= corners[0];

	return Point<float> (Line<float> (Point<float>(), tr).getIntersection (Line<float> (target, target - bl)).getDistanceFromOrigin(),
						 Line<float> (Point<float>(), bl).getIntersection (Line<float> (target, target - tr)).getDistanceFromOrigin());
}

const Point<float> RelativeParallelogram::getPointForInternalCoord (const Point<float>* const corners, const Point<float>& point) noexcept
{
	return corners[0]
			+ Line<float> (Point<float>(), corners[1] - corners[0]).getPointAlongLine (point.x)
			+ Line<float> (Point<float>(), corners[2] - corners[0]).getPointAlongLine (point.y);
}

const Rectangle<float> RelativeParallelogram::getBoundingBox (const Point<float>* const p) noexcept
{
	const Point<float> points[] = { p[0], p[1], p[2], p[1] + (p[2] - p[0]) };
	return Rectangle<float>::findAreaContainingPoints (points, 4);
}

/*** End of inlined file: juce_RelativeParallelogram.cpp ***/


/*** Start of inlined file: juce_RelativePoint.cpp ***/
namespace RelativePointHelpers
{
	inline void skipComma (String::CharPointerType& s)
	{
		s = s.findEndOfWhitespace();

		if (*s == ',')
			++s;
	}
}

RelativePoint::RelativePoint()
{
}

RelativePoint::RelativePoint (const Point<float>& absolutePoint)
	: x (absolutePoint.x), y (absolutePoint.y)
{
}

RelativePoint::RelativePoint (const float x_, const float y_)
	: x (x_), y (y_)
{
}

RelativePoint::RelativePoint (const RelativeCoordinate& x_, const RelativeCoordinate& y_)
	: x (x_), y (y_)
{
}

RelativePoint::RelativePoint (const String& s)
{
	String::CharPointerType text (s.getCharPointer());
	x = RelativeCoordinate (Expression::parse (text));
	RelativePointHelpers::skipComma (text);
	y = RelativeCoordinate (Expression::parse (text));
}

bool RelativePoint::operator== (const RelativePoint& other) const noexcept
{
	return x == other.x && y == other.y;
}

bool RelativePoint::operator!= (const RelativePoint& other) const noexcept
{
	return ! operator== (other);
}

const Point<float> RelativePoint::resolve (const Expression::Scope* scope) const
{
	return Point<float> ((float) x.resolve (scope),
						 (float) y.resolve (scope));
}

void RelativePoint::moveToAbsolute (const Point<float>& newPos, const Expression::Scope* scope)
{
	x.moveToAbsolute (newPos.x, scope);
	y.moveToAbsolute (newPos.y, scope);
}

String RelativePoint::toString() const
{
	return x.toString() + ", " + y.toString();
}

bool RelativePoint::isDynamic() const
{
	return x.isDynamic() || y.isDynamic();
}

/*** End of inlined file: juce_RelativePoint.cpp ***/


/*** Start of inlined file: juce_RelativePointPath.cpp ***/
RelativePointPath::RelativePointPath()
	: usesNonZeroWinding (true),
	  containsDynamicPoints (false)
{
}

RelativePointPath::RelativePointPath (const RelativePointPath& other)
	: usesNonZeroWinding (true),
	  containsDynamicPoints (false)
{
	for (int i = 0; i < other.elements.size(); ++i)
		elements.add (other.elements.getUnchecked(i)->clone());
}

RelativePointPath::RelativePointPath (const Path& path)
	: usesNonZeroWinding (path.isUsingNonZeroWinding()),
	  containsDynamicPoints (false)
{
	for (Path::Iterator i (path); i.next();)
	{
		switch (i.elementType)
		{
			case Path::Iterator::startNewSubPath:   elements.add (new StartSubPath (RelativePoint (i.x1, i.y1))); break;
			case Path::Iterator::lineTo:            elements.add (new LineTo (RelativePoint (i.x1, i.y1))); break;
			case Path::Iterator::quadraticTo:       elements.add (new QuadraticTo (RelativePoint (i.x1, i.y1), RelativePoint (i.x2, i.y2))); break;
			case Path::Iterator::cubicTo:           elements.add (new CubicTo (RelativePoint (i.x1, i.y1), RelativePoint (i.x2, i.y2), RelativePoint (i.x3, i.y3))); break;
			case Path::Iterator::closePath:         elements.add (new CloseSubPath()); break;
			default:                                jassertfalse; break;
		}
	}
}

RelativePointPath::~RelativePointPath()
{
}

bool RelativePointPath::operator== (const RelativePointPath& other) const noexcept
{
	if (elements.size() != other.elements.size()
		 || usesNonZeroWinding != other.usesNonZeroWinding
		 || containsDynamicPoints != other.containsDynamicPoints)
		return false;

	for (int i = 0; i < elements.size(); ++i)
	{
		ElementBase* const e1 = elements.getUnchecked(i);
		ElementBase* const e2 = other.elements.getUnchecked(i);

		if (e1->type != e2->type)
			return false;

		int numPoints1, numPoints2;
		const RelativePoint* const points1 = e1->getControlPoints (numPoints1);
		const RelativePoint* const points2 = e2->getControlPoints (numPoints2);

		jassert (numPoints1 == numPoints2);

		for (int j = numPoints1; --j >= 0;)
			if (points1[j] != points2[j])
				return false;
	}

	return true;
}

bool RelativePointPath::operator!= (const RelativePointPath& other) const noexcept
{
	return ! operator== (other);
}

void RelativePointPath::swapWith (RelativePointPath& other) noexcept
{
	elements.swapWithArray (other.elements);
	std::swap (usesNonZeroWinding, other.usesNonZeroWinding);
	std::swap (containsDynamicPoints, other.containsDynamicPoints);
}

void RelativePointPath::createPath (Path& path, Expression::Scope* scope) const
{
	for (int i = 0; i < elements.size(); ++i)
		elements.getUnchecked(i)->addToPath (path, scope);
}

bool RelativePointPath::containsAnyDynamicPoints() const
{
	return containsDynamicPoints;
}

void RelativePointPath::addElement (ElementBase* newElement)
{
	if (newElement != nullptr)
	{
		elements.add (newElement);
		containsDynamicPoints = containsDynamicPoints || newElement->isDynamic();
	}
}

RelativePointPath::ElementBase::ElementBase (const ElementType type_) : type (type_)
{
}

bool RelativePointPath::ElementBase::isDynamic()
{
	int numPoints;
	const RelativePoint* const points = getControlPoints (numPoints);

	for (int i = numPoints; --i >= 0;)
		if (points[i].isDynamic())
			return true;

	return false;
}

RelativePointPath::StartSubPath::StartSubPath (const RelativePoint& pos)
	: ElementBase (startSubPathElement), startPos (pos)
{
}

ValueTree RelativePointPath::StartSubPath::createTree() const
{
	ValueTree v (DrawablePath::ValueTreeWrapper::Element::startSubPathElement);
	v.setProperty (DrawablePath::ValueTreeWrapper::point1, startPos.toString(), nullptr);
	return v;
}

void RelativePointPath::StartSubPath::addToPath (Path& path, Expression::Scope* scope) const
{
	path.startNewSubPath (startPos.resolve (scope));
}

RelativePoint* RelativePointPath::StartSubPath::getControlPoints (int& numPoints)
{
	numPoints = 1;
	return &startPos;
}

RelativePointPath::ElementBase* RelativePointPath::StartSubPath::clone() const
{
	return new StartSubPath (startPos);
}

RelativePointPath::CloseSubPath::CloseSubPath()
	: ElementBase (closeSubPathElement)
{
}

ValueTree RelativePointPath::CloseSubPath::createTree() const
{
	return ValueTree (DrawablePath::ValueTreeWrapper::Element::closeSubPathElement);
}

void RelativePointPath::CloseSubPath::addToPath (Path& path, Expression::Scope*) const
{
	path.closeSubPath();
}

RelativePoint* RelativePointPath::CloseSubPath::getControlPoints (int& numPoints)
{
	numPoints = 0;
	return nullptr;
}

RelativePointPath::ElementBase* RelativePointPath::CloseSubPath::clone() const
{
	return new CloseSubPath();
}

RelativePointPath::LineTo::LineTo (const RelativePoint& endPoint_)
	: ElementBase (lineToElement), endPoint (endPoint_)
{
}

ValueTree RelativePointPath::LineTo::createTree() const
{
	ValueTree v (DrawablePath::ValueTreeWrapper::Element::lineToElement);
	v.setProperty (DrawablePath::ValueTreeWrapper::point1, endPoint.toString(), nullptr);
	return v;
}

void RelativePointPath::LineTo::addToPath (Path& path, Expression::Scope* scope) const
{
	path.lineTo (endPoint.resolve (scope));
}

RelativePoint* RelativePointPath::LineTo::getControlPoints (int& numPoints)
{
	numPoints = 1;
	return &endPoint;
}

RelativePointPath::ElementBase* RelativePointPath::LineTo::clone() const
{
	return new LineTo (endPoint);
}

RelativePointPath::QuadraticTo::QuadraticTo (const RelativePoint& controlPoint, const RelativePoint& endPoint)
	: ElementBase (quadraticToElement)
{
	controlPoints[0] = controlPoint;
	controlPoints[1] = endPoint;
}

ValueTree RelativePointPath::QuadraticTo::createTree() const
{
	ValueTree v (DrawablePath::ValueTreeWrapper::Element::quadraticToElement);
	v.setProperty (DrawablePath::ValueTreeWrapper::point1, controlPoints[0].toString(), nullptr);
	v.setProperty (DrawablePath::ValueTreeWrapper::point2, controlPoints[1].toString(), nullptr);
	return v;
}

void RelativePointPath::QuadraticTo::addToPath (Path& path, Expression::Scope* scope) const
{
	path.quadraticTo (controlPoints[0].resolve (scope),
					  controlPoints[1].resolve (scope));
}

RelativePoint* RelativePointPath::QuadraticTo::getControlPoints (int& numPoints)
{
	numPoints = 2;
	return controlPoints;
}

RelativePointPath::ElementBase* RelativePointPath::QuadraticTo::clone() const
{
	return new QuadraticTo (controlPoints[0], controlPoints[1]);
}

RelativePointPath::CubicTo::CubicTo (const RelativePoint& controlPoint1, const RelativePoint& controlPoint2, const RelativePoint& endPoint)
	: ElementBase (cubicToElement)
{
	controlPoints[0] = controlPoint1;
	controlPoints[1] = controlPoint2;
	controlPoints[2] = endPoint;
}

ValueTree RelativePointPath::CubicTo::createTree() const
{
	ValueTree v (DrawablePath::ValueTreeWrapper::Element::cubicToElement);
	v.setProperty (DrawablePath::ValueTreeWrapper::point1, controlPoints[0].toString(), nullptr);
	v.setProperty (DrawablePath::ValueTreeWrapper::point2, controlPoints[1].toString(), nullptr);
	v.setProperty (DrawablePath::ValueTreeWrapper::point3, controlPoints[2].toString(), nullptr);
	return v;
}

void RelativePointPath::CubicTo::addToPath (Path& path, Expression::Scope* scope) const
{
	path.cubicTo (controlPoints[0].resolve (scope),
				  controlPoints[1].resolve (scope),
				  controlPoints[2].resolve (scope));
}

RelativePoint* RelativePointPath::CubicTo::getControlPoints (int& numPoints)
{
	numPoints = 3;
	return controlPoints;
}

RelativePointPath::ElementBase* RelativePointPath::CubicTo::clone() const
{
	return new CubicTo (controlPoints[0], controlPoints[1], controlPoints[2]);
}

/*** End of inlined file: juce_RelativePointPath.cpp ***/


/*** Start of inlined file: juce_RelativeRectangle.cpp ***/
namespace RelativeRectangleHelpers
{
	inline void skipComma (String::CharPointerType& s)
	{
		s = s.findEndOfWhitespace();

		if (*s == ',')
			++s;
	}

	bool dependsOnSymbolsOtherThanThis (const Expression& e)
	{
		if (e.getType() == Expression::operatorType && e.getSymbolOrFunction() == ".")
			return true;

		if (e.getType() == Expression::symbolType)
		{
			switch (RelativeCoordinate::StandardStrings::getTypeOf (e.getSymbolOrFunction()))
			{
				case RelativeCoordinate::StandardStrings::x:
				case RelativeCoordinate::StandardStrings::y:
				case RelativeCoordinate::StandardStrings::left:
				case RelativeCoordinate::StandardStrings::right:
				case RelativeCoordinate::StandardStrings::top:
				case RelativeCoordinate::StandardStrings::bottom:   return false;
				default: break;
			}

			return true;
		}
		else
		{
			for (int i = e.getNumInputs(); --i >= 0;)
				if (dependsOnSymbolsOtherThanThis (e.getInput(i)))
					return true;
		}

		return false;
	}
}

RelativeRectangle::RelativeRectangle()
{
}

RelativeRectangle::RelativeRectangle (const RelativeCoordinate& left_, const RelativeCoordinate& right_,
									  const RelativeCoordinate& top_, const RelativeCoordinate& bottom_)
	: left (left_), right (right_), top (top_), bottom (bottom_)
{
}

RelativeRectangle::RelativeRectangle (const Rectangle<float>& rect)
	: left (rect.getX()),
	  right (Expression::symbol (RelativeCoordinate::Strings::left) + Expression ((double) rect.getWidth())),
	  top (rect.getY()),
	  bottom (Expression::symbol (RelativeCoordinate::Strings::top) + Expression ((double) rect.getHeight()))
{
}

RelativeRectangle::RelativeRectangle (const String& s)
{
	String::CharPointerType text (s.getCharPointer());
	left = RelativeCoordinate (Expression::parse (text));
	RelativeRectangleHelpers::skipComma (text);
	top = RelativeCoordinate (Expression::parse (text));
	RelativeRectangleHelpers::skipComma (text);
	right = RelativeCoordinate (Expression::parse (text));
	RelativeRectangleHelpers::skipComma (text);
	bottom = RelativeCoordinate (Expression::parse (text));
}

bool RelativeRectangle::operator== (const RelativeRectangle& other) const noexcept
{
	return left == other.left && top == other.top && right == other.right && bottom == other.bottom;
}

bool RelativeRectangle::operator!= (const RelativeRectangle& other) const noexcept
{
	return ! operator== (other);
}

// An expression context that can evaluate expressions using "this"
class RelativeRectangleLocalScope  : public Expression::Scope
{
public:
	RelativeRectangleLocalScope (const RelativeRectangle& rect_)  : rect (rect_) {}

	Expression getSymbolValue (const String& symbol) const
	{
		switch (RelativeCoordinate::StandardStrings::getTypeOf (symbol))
		{
			case RelativeCoordinate::StandardStrings::x:
			case RelativeCoordinate::StandardStrings::left:     return rect.left.getExpression();
			case RelativeCoordinate::StandardStrings::y:
			case RelativeCoordinate::StandardStrings::top:      return rect.top.getExpression();
			case RelativeCoordinate::StandardStrings::right:    return rect.right.getExpression();
			case RelativeCoordinate::StandardStrings::bottom:   return rect.bottom.getExpression();
			default: break;
		}

		return Expression::Scope::getSymbolValue (symbol);
	}

private:
	const RelativeRectangle& rect;

	JUCE_DECLARE_NON_COPYABLE (RelativeRectangleLocalScope);
};

const Rectangle<float> RelativeRectangle::resolve (const Expression::Scope* scope) const
{
	if (scope == nullptr)
	{
		RelativeRectangleLocalScope defaultScope (*this);
		return resolve (&defaultScope);
	}
	else
	{
		const double l = left.resolve (scope);
		const double r = right.resolve (scope);
		const double t = top.resolve (scope);
		const double b = bottom.resolve (scope);

		return Rectangle<float> ((float) l, (float) t, (float) jmax (0.0, r - l), (float) jmax (0.0, b - t));
	}
}

void RelativeRectangle::moveToAbsolute (const Rectangle<float>& newPos, const Expression::Scope* scope)
{
	left.moveToAbsolute (newPos.getX(), scope);
	right.moveToAbsolute (newPos.getRight(), scope);
	top.moveToAbsolute (newPos.getY(), scope);
	bottom.moveToAbsolute (newPos.getBottom(), scope);
}

bool RelativeRectangle::isDynamic() const
{
	using namespace RelativeRectangleHelpers;

	return dependsOnSymbolsOtherThanThis (left.getExpression())
			|| dependsOnSymbolsOtherThanThis (right.getExpression())
			|| dependsOnSymbolsOtherThanThis (top.getExpression())
			|| dependsOnSymbolsOtherThanThis (bottom.getExpression());
}

String RelativeRectangle::toString() const
{
	return left.toString() + ", " + top.toString() + ", " + right.toString() + ", " + bottom.toString();
}

void RelativeRectangle::renameSymbol (const Expression::Symbol& oldSymbol, const String& newName, const Expression::Scope& scope)
{
	left = left.getExpression().withRenamedSymbol (oldSymbol, newName, scope);
	right = right.getExpression().withRenamedSymbol (oldSymbol, newName, scope);
	top = top.getExpression().withRenamedSymbol (oldSymbol, newName, scope);
	bottom = bottom.getExpression().withRenamedSymbol (oldSymbol, newName, scope);
}

class RelativeRectangleComponentPositioner  : public RelativeCoordinatePositionerBase
{
public:
	RelativeRectangleComponentPositioner (Component& component_, const RelativeRectangle& rectangle_)
		: RelativeCoordinatePositionerBase (component_),
		  rectangle (rectangle_)
	{
	}

	bool registerCoordinates()
	{
		bool ok = addCoordinate (rectangle.left);
		ok = addCoordinate (rectangle.right) && ok;
		ok = addCoordinate (rectangle.top) && ok;
		ok = addCoordinate (rectangle.bottom) && ok;
		return ok;
	}

	bool isUsingRectangle (const RelativeRectangle& other) const noexcept
	{
		return rectangle == other;
	}

	void applyToComponentBounds()
	{
		for (int i = 4; --i >= 0;)
		{
			ComponentScope scope (getComponent());
			const Rectangle<int> newBounds (rectangle.resolve (&scope).getSmallestIntegerContainer());

			if (newBounds == getComponent().getBounds())
				return;

			getComponent().setBounds (newBounds);
		}

		jassertfalse; // Seems to be a recursive reference!
	}

	void applyNewBounds (const Rectangle<int>& newBounds)
	{
		if (newBounds != getComponent().getBounds())
		{
			ComponentScope scope (getComponent());
			rectangle.moveToAbsolute (newBounds.toFloat(), &scope);

			applyToComponentBounds();
		}
	}

private:
	RelativeRectangle rectangle;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (RelativeRectangleComponentPositioner);
};

void RelativeRectangle::applyToComponent (Component& component) const
{
	if (isDynamic())
	{
		RelativeRectangleComponentPositioner* current = dynamic_cast <RelativeRectangleComponentPositioner*> (component.getPositioner());

		if (current == nullptr || ! current->isUsingRectangle (*this))
		{
			RelativeRectangleComponentPositioner* p = new RelativeRectangleComponentPositioner (component, *this);

			component.setPositioner (p);
			p->apply();
		}
	}
	else
	{
		component.setPositioner (nullptr);
		component.setBounds (resolve (nullptr).getSmallestIntegerContainer());
	}
}

/*** End of inlined file: juce_RelativeRectangle.cpp ***/


/*** Start of inlined file: juce_BooleanPropertyComponent.cpp ***/
BooleanPropertyComponent::BooleanPropertyComponent (const String& name,
													const String& buttonTextWhenTrue,
													const String& buttonTextWhenFalse)
	: PropertyComponent (name),
	  onText (buttonTextWhenTrue),
	  offText (buttonTextWhenFalse)
{
	addAndMakeVisible (&button);
	button.setClickingTogglesState (false);
	button.addListener (this);
}

BooleanPropertyComponent::BooleanPropertyComponent (const Value& valueToControl,
													const String& name,
													const String& buttonText)
	: PropertyComponent (name),
	  onText (buttonText),
	  offText (buttonText)
{
	addAndMakeVisible (&button);
	button.setClickingTogglesState (false);
	button.setButtonText (buttonText);
	button.getToggleStateValue().referTo (valueToControl);
	button.setClickingTogglesState (true);
}

BooleanPropertyComponent::~BooleanPropertyComponent()
{
}

void BooleanPropertyComponent::setState (const bool newState)
{
	button.setToggleState (newState, true);
}

bool BooleanPropertyComponent::getState() const
{
	return button.getToggleState();
}

void BooleanPropertyComponent::paint (Graphics& g)
{
	PropertyComponent::paint (g);

	g.setColour (Colours::white);
	g.fillRect (button.getBounds());

	g.setColour (findColour (ComboBox::outlineColourId));
	g.drawRect (button.getBounds());
}

void BooleanPropertyComponent::refresh()
{
	button.setToggleState (getState(), false);
	button.setButtonText (button.getToggleState() ? onText : offText);
}

void BooleanPropertyComponent::buttonClicked (Button*)
{
	setState (! getState());
}

/*** End of inlined file: juce_BooleanPropertyComponent.cpp ***/


/*** Start of inlined file: juce_ButtonPropertyComponent.cpp ***/
ButtonPropertyComponent::ButtonPropertyComponent (const String& name,
												  const bool triggerOnMouseDown)
	: PropertyComponent (name)
{
	addAndMakeVisible (&button);
	button.setTriggeredOnMouseDown (triggerOnMouseDown);
	button.addListener (this);
}

ButtonPropertyComponent::~ButtonPropertyComponent()
{
}

void ButtonPropertyComponent::refresh()
{
	button.setButtonText (getButtonText());
}

void ButtonPropertyComponent::buttonClicked (Button*)
{
	buttonClicked();
}

/*** End of inlined file: juce_ButtonPropertyComponent.cpp ***/


/*** Start of inlined file: juce_ChoicePropertyComponent.cpp ***/
class ChoicePropertyComponent::RemapperValueSource    : public Value::ValueSource,
														public ValueListener
{
public:
	RemapperValueSource (const Value& sourceValue_, const Array<var>& mappings_)
	   : sourceValue (sourceValue_),
		 mappings (mappings_)
	{
		sourceValue.addListener (this);
	}

	~RemapperValueSource() {}

	var getValue() const
	{
		return mappings.indexOf (sourceValue.getValue()) + 1;
	}

	void setValue (const var& newValue)
	{
		const var remappedVal (mappings [(int) newValue - 1]);

		if (remappedVal != sourceValue)
			sourceValue = remappedVal;
	}

	void valueChanged (Value&)
	{
		sendChangeMessage (true);
	}

protected:

	Value sourceValue;
	Array<var> mappings;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (RemapperValueSource);
};

ChoicePropertyComponent::ChoicePropertyComponent (const String& name)
	: PropertyComponent (name),
	  isCustomClass (true)
{
}

ChoicePropertyComponent::ChoicePropertyComponent (const Value& valueToControl,
												  const String& name,
												  const StringArray& choices_,
												  const Array <var>& correspondingValues)
	: PropertyComponent (name),
	  choices (choices_),
	  isCustomClass (false)
{
	// The array of corresponding values must contain one value for each of the items in
	// the choices array!
	jassert (correspondingValues.size() == choices.size());

	createComboBox();

	comboBox.getSelectedIdAsValue().referTo (Value (new RemapperValueSource (valueToControl, correspondingValues)));
}

ChoicePropertyComponent::~ChoicePropertyComponent()
{
}

void ChoicePropertyComponent::createComboBox()
{
	addAndMakeVisible (&comboBox);

	for (int i = 0; i < choices.size(); ++i)
	{
		if (choices[i].isNotEmpty())
			comboBox.addItem (choices[i], i + 1);
		else
			comboBox.addSeparator();
	}

	comboBox.setEditableText (false);
}

void ChoicePropertyComponent::setIndex (const int /*newIndex*/)
{
	jassertfalse; // you need to override this method in your subclass!
}

int ChoicePropertyComponent::getIndex() const
{
	jassertfalse; // you need to override this method in your subclass!
	return -1;
}

const StringArray& ChoicePropertyComponent::getChoices() const
{
	return choices;
}

void ChoicePropertyComponent::refresh()
{
	if (isCustomClass)
	{
		if (! comboBox.isVisible())
		{
			createComboBox();
			comboBox.addListener (this);
		}

		comboBox.setSelectedId (getIndex() + 1, true);
	}
}

void ChoicePropertyComponent::comboBoxChanged (ComboBox*)
{
	if (isCustomClass)
	{
		const int newIndex = comboBox.getSelectedId() - 1;

		if (newIndex != getIndex())
			setIndex (newIndex);
	}
}

/*** End of inlined file: juce_ChoicePropertyComponent.cpp ***/


/*** Start of inlined file: juce_PropertyComponent.cpp ***/
PropertyComponent::PropertyComponent (const String& name,
									  const int preferredHeight_)
	: Component (name),
	  preferredHeight (preferredHeight_)
{
	jassert (name.isNotEmpty());
}

PropertyComponent::~PropertyComponent()
{
}

void PropertyComponent::paint (Graphics& g)
{
	getLookAndFeel().drawPropertyComponentBackground (g, getWidth(), getHeight(), *this);
	getLookAndFeel().drawPropertyComponentLabel (g, getWidth(), getHeight(), *this);
}

void PropertyComponent::resized()
{
	if (getNumChildComponents() > 0)
		getChildComponent (0)->setBounds (getLookAndFeel().getPropertyComponentContentPosition (*this));
}

void PropertyComponent::enablementChanged()
{
	repaint();
}

/*** End of inlined file: juce_PropertyComponent.cpp ***/


/*** Start of inlined file: juce_PropertyPanel.cpp ***/
class PropertySectionComponent  : public Component
{
public:
	PropertySectionComponent (const String& sectionTitle,
							  const Array <PropertyComponent*>& newProperties,
							  const bool sectionIsOpen_)
		: Component (sectionTitle),
		  titleHeight (sectionTitle.isNotEmpty() ? 22 : 0),
		  sectionIsOpen (sectionIsOpen_)
	{
		propertyComps.addArray (newProperties);

		for (int i = propertyComps.size(); --i >= 0;)
		{
			addAndMakeVisible (propertyComps.getUnchecked(i));
			propertyComps.getUnchecked(i)->refresh();
		}
	}

	~PropertySectionComponent()
	{
		propertyComps.clear();
	}

	void paint (Graphics& g)
	{
		if (titleHeight > 0)
			getLookAndFeel().drawPropertyPanelSectionHeader (g, getName(), isOpen(), getWidth(), titleHeight);
	}

	void resized()
	{
		int y = titleHeight;

		for (int i = 0; i < propertyComps.size(); ++i)
		{
			PropertyComponent* const pec = propertyComps.getUnchecked (i);
			pec->setBounds (1, y, getWidth() - 2, pec->getPreferredHeight());
			y = pec->getBottom();
		}
	}

	int getPreferredHeight() const
	{
		int y = titleHeight;

		if (isOpen())
		{
			for (int i = propertyComps.size(); --i >= 0;)
				y += propertyComps.getUnchecked(i)->getPreferredHeight();
		}

		return y;
	}

	void setOpen (const bool open)
	{
		if (sectionIsOpen != open)
		{
			sectionIsOpen = open;

			for (int i = propertyComps.size(); --i >= 0;)
				propertyComps.getUnchecked(i)->setVisible (open);

			PropertyPanel* const pp = findParentComponentOfClass ((PropertyPanel*) nullptr);

			if (pp != nullptr)
				pp->resized();
		}
	}

	bool isOpen() const
	{
		return sectionIsOpen;
	}

	void refreshAll() const
	{
		for (int i = propertyComps.size(); --i >= 0;)
			propertyComps.getUnchecked (i)->refresh();
	}

	void mouseUp (const MouseEvent& e)
	{
		if (e.getMouseDownX() < titleHeight
			 && e.x < titleHeight
			 && e.y < titleHeight
			 && e.getNumberOfClicks() != 2)
		{
			setOpen (! isOpen());
		}
	}

	void mouseDoubleClick (const MouseEvent& e)
	{
		if (e.y < titleHeight)
			setOpen (! isOpen());
	}

private:
	OwnedArray <PropertyComponent> propertyComps;
	int titleHeight;
	bool sectionIsOpen;

	JUCE_DECLARE_NON_COPYABLE (PropertySectionComponent);
};

class PropertyPanel::PropertyHolderComponent  : public Component
{
public:
	PropertyHolderComponent() {}

	void paint (Graphics&) {}

	void updateLayout (int width)
	{
		int y = 0;

		for (int i = 0; i < sections.size(); ++i)
		{
			PropertySectionComponent* const section = sections.getUnchecked(i);

			section->setBounds (0, y, width, section->getPreferredHeight());
			y = section->getBottom();
		}

		setSize (width, y);
		repaint();
	}

	void refreshAll() const
	{
		for (int i = 0; i < sections.size(); ++i)
			sections.getUnchecked(i)->refreshAll();
	}

	void clear()
	{
		sections.clear();
	}

	void addSection (PropertySectionComponent* newSection)
	{
		sections.add (newSection);
		addAndMakeVisible (newSection, 0);
	}

	int getNumSections() const noexcept                             { return sections.size(); }
	PropertySectionComponent* getSection (const int index) const    { return sections [index]; }

private:
	OwnedArray<PropertySectionComponent> sections;

	JUCE_DECLARE_NON_COPYABLE (PropertyHolderComponent);
};

PropertyPanel::PropertyPanel()
{
	messageWhenEmpty = TRANS("(nothing selected)");

	addAndMakeVisible (&viewport);
	viewport.setViewedComponent (propertyHolderComponent = new PropertyHolderComponent());
	viewport.setFocusContainer (true);
}

PropertyPanel::~PropertyPanel()
{
	clear();
}

void PropertyPanel::paint (Graphics& g)
{
	if (propertyHolderComponent->getNumSections() == 0)
	{
		g.setColour (Colours::black.withAlpha (0.5f));
		g.setFont (14.0f);
		g.drawText (messageWhenEmpty, 0, 0, getWidth(), 30,
					Justification::centred, true);
	}
}

void PropertyPanel::resized()
{
	viewport.setBounds (getLocalBounds());
	updatePropHolderLayout();
}

void PropertyPanel::clear()
{
	if (propertyHolderComponent->getNumSections() > 0)
	{
		propertyHolderComponent->clear();
		repaint();
	}
}

void PropertyPanel::addProperties (const Array <PropertyComponent*>& newProperties)
{
	if (propertyHolderComponent->getNumSections() == 0)
		repaint();

	propertyHolderComponent->addSection (new PropertySectionComponent (String::empty, newProperties, true));
	updatePropHolderLayout();
}

void PropertyPanel::addSection (const String& sectionTitle,
								const Array <PropertyComponent*>& newProperties,
								const bool shouldBeOpen)
{
	jassert (sectionTitle.isNotEmpty());

	if (propertyHolderComponent->getNumSections() == 0)
		repaint();

	propertyHolderComponent->addSection (new PropertySectionComponent (sectionTitle, newProperties, shouldBeOpen));
	updatePropHolderLayout();
}

void PropertyPanel::updatePropHolderLayout() const
{
	const int maxWidth = viewport.getMaximumVisibleWidth();
	propertyHolderComponent->updateLayout (maxWidth);

	const int newMaxWidth = viewport.getMaximumVisibleWidth();
	if (maxWidth != newMaxWidth)
	{
		// need to do this twice because of scrollbars changing the size, etc.
		propertyHolderComponent->updateLayout (newMaxWidth);
	}
}

void PropertyPanel::refreshAll() const
{
	propertyHolderComponent->refreshAll();
}

StringArray PropertyPanel::getSectionNames() const
{
	StringArray s;

	for (int i = 0; i < propertyHolderComponent->getNumSections(); ++i)
	{
		PropertySectionComponent* const section = propertyHolderComponent->getSection (i);

		if (section->getName().isNotEmpty())
			s.add (section->getName());
	}

	return s;
}

bool PropertyPanel::isSectionOpen (const int sectionIndex) const
{
	int index = 0;

	for (int i = 0; i < propertyHolderComponent->getNumSections(); ++i)
	{
		PropertySectionComponent* const section = propertyHolderComponent->getSection (i);

		if (section->getName().isNotEmpty())
		{
			if (index == sectionIndex)
				return section->isOpen();

			++index;
		}
	}

	return false;
}

void PropertyPanel::setSectionOpen (const int sectionIndex, const bool shouldBeOpen)
{
	int index = 0;

	for (int i = 0; i < propertyHolderComponent->getNumSections(); ++i)
	{
		PropertySectionComponent* const section = propertyHolderComponent->getSection (i);

		if (section->getName().isNotEmpty())
		{
			if (index == sectionIndex)
			{
				section->setOpen (shouldBeOpen);
				break;
			}

			++index;
		}
	}
}

void PropertyPanel::setSectionEnabled (const int sectionIndex, const bool shouldBeEnabled)
{
	int index = 0;

	for (int i = 0; i < propertyHolderComponent->getNumSections(); ++i)
	{
		PropertySectionComponent* const section = propertyHolderComponent->getSection (i);

		if (section->getName().isNotEmpty())
		{
			if (index == sectionIndex)
			{
				section->setEnabled (shouldBeEnabled);
				break;
			}

			++index;
		}
	}
}

XmlElement* PropertyPanel::getOpennessState() const
{
	XmlElement* const xml = new XmlElement ("PROPERTYPANELSTATE");

	xml->setAttribute ("scrollPos", viewport.getViewPositionY());

	const StringArray sections (getSectionNames());

	for (int i = 0; i < sections.size(); ++i)
	{
		if (sections[i].isNotEmpty())
		{
			XmlElement* const e = xml->createNewChildElement ("SECTION");
			e->setAttribute ("name", sections[i]);
			e->setAttribute ("open", isSectionOpen (i) ? 1 : 0);
		}
	}

	return xml;
}

void PropertyPanel::restoreOpennessState (const XmlElement& xml)
{
	if (xml.hasTagName ("PROPERTYPANELSTATE"))
	{
		const StringArray sections (getSectionNames());

		forEachXmlChildElementWithTagName (xml, e, "SECTION")
		{
			setSectionOpen (sections.indexOf (e->getStringAttribute ("name")),
							e->getBoolAttribute ("open"));
		}

		viewport.setViewPosition (viewport.getViewPositionX(),
								  xml.getIntAttribute ("scrollPos", viewport.getViewPositionY()));
	}
}

void PropertyPanel::setMessageWhenEmpty (const String& newMessage)
{
	if (messageWhenEmpty != newMessage)
	{
		messageWhenEmpty = newMessage;
		repaint();
	}
}

const String& PropertyPanel::getMessageWhenEmpty() const
{
	return messageWhenEmpty;
}

/*** End of inlined file: juce_PropertyPanel.cpp ***/


/*** Start of inlined file: juce_SliderPropertyComponent.cpp ***/
SliderPropertyComponent::SliderPropertyComponent (const String& name,
												  const double rangeMin,
												  const double rangeMax,
												  const double interval,
												  const double skewFactor)
	: PropertyComponent (name)
{
	addAndMakeVisible (&slider);

	slider.setRange (rangeMin, rangeMax, interval);
	slider.setSkewFactor (skewFactor);
	slider.setSliderStyle (Slider::LinearBar);

	slider.addListener (this);
}

SliderPropertyComponent::SliderPropertyComponent (const Value& valueToControl,
												  const String& name,
												  const double rangeMin,
												  const double rangeMax,
												  const double interval,
												  const double skewFactor)
	: PropertyComponent (name)
{
	addAndMakeVisible (&slider);

	slider.setRange (rangeMin, rangeMax, interval);
	slider.setSkewFactor (skewFactor);
	slider.setSliderStyle (Slider::LinearBar);

	slider.getValueObject().referTo (valueToControl);
}

SliderPropertyComponent::~SliderPropertyComponent()
{
}

void SliderPropertyComponent::setValue (const double /*newValue*/)
{
}

double SliderPropertyComponent::getValue() const
{
	return slider.getValue();
}

void SliderPropertyComponent::refresh()
{
	slider.setValue (getValue(), false);
}

void SliderPropertyComponent::sliderValueChanged (Slider*)
{
	if (getValue() != slider.getValue())
		setValue (slider.getValue());
}

/*** End of inlined file: juce_SliderPropertyComponent.cpp ***/


/*** Start of inlined file: juce_TextPropertyComponent.cpp ***/
class TextPropLabel  : public Label
{
public:
	TextPropLabel (TextPropertyComponent& owner_,
				   const int maxChars_, const bool isMultiline_)
		: Label (String::empty, String::empty),
		  owner (owner_),
		  maxChars (maxChars_),
		  isMultiline (isMultiline_)
	{
		setEditable (true, true, false);

		setColour (backgroundColourId, Colours::white);
		setColour (outlineColourId, findColour (ComboBox::outlineColourId));
	}

	TextEditor* createEditorComponent()
	{
		TextEditor* const textEditor = Label::createEditorComponent();
		textEditor->setInputRestrictions (maxChars);

		if (isMultiline)
		{
			textEditor->setMultiLine (true, true);
			textEditor->setReturnKeyStartsNewLine (true);
		}

		return textEditor;
	}

	void textWasEdited()
	{
		owner.textWasEdited();
	}

private:
	TextPropertyComponent& owner;
	int maxChars;
	bool isMultiline;
};

TextPropertyComponent::TextPropertyComponent (const String& name,
											  const int maxNumChars,
											  const bool isMultiLine)
	: PropertyComponent (name)
{
	createEditor (maxNumChars, isMultiLine);
}

TextPropertyComponent::TextPropertyComponent (const Value& valueToControl,
											  const String& name,
											  const int maxNumChars,
											  const bool isMultiLine)
	: PropertyComponent (name)
{
	createEditor (maxNumChars, isMultiLine);

	textEditor->getTextValue().referTo (valueToControl);
}

TextPropertyComponent::~TextPropertyComponent()
{
}

void TextPropertyComponent::setText (const String& newText)
{
	textEditor->setText (newText, true);
}

String TextPropertyComponent::getText() const
{
	return textEditor->getText();
}

void TextPropertyComponent::createEditor (const int maxNumChars, const bool isMultiLine)
{
	addAndMakeVisible (textEditor = new TextPropLabel (*this, maxNumChars, isMultiLine));

	if (isMultiLine)
	{
		textEditor->setJustificationType (Justification::topLeft);
		preferredHeight = 120;
	}
}

void TextPropertyComponent::refresh()
{
	textEditor->setText (getText(), false);
}

void TextPropertyComponent::textWasEdited()
{
	const String newText (textEditor->getText());

	if (getText() != newText)
		setText (newText);
}

/*** End of inlined file: juce_TextPropertyComponent.cpp ***/


/*** Start of inlined file: juce_ComboBox.cpp ***/
ComboBox::ItemInfo::ItemInfo (const String& name_, int itemId_, bool isEnabled_, bool isHeading_)
	: name (name_), itemId (itemId_), isEnabled (isEnabled_), isHeading (isHeading_)
{
}

bool ComboBox::ItemInfo::isSeparator() const noexcept
{
	return name.isEmpty();
}

bool ComboBox::ItemInfo::isRealItem() const noexcept
{
	return ! (isHeading || name.isEmpty());
}

ComboBox::ComboBox (const String& name)
	: Component (name),
	  lastCurrentId (0),
	  isButtonDown (false),
	  separatorPending (false),
	  menuActive (false),
	  noChoicesMessage (TRANS("(no choices)"))
{
	setRepaintsOnMouseActivity (true);
	ComboBox::lookAndFeelChanged();
	currentId.addListener (this);
}

ComboBox::~ComboBox()
{
	currentId.removeListener (this);

	if (menuActive)
		PopupMenu::dismissAllActiveMenus();

	label = nullptr;
}

void ComboBox::setEditableText (const bool isEditable)
{
	if (label->isEditableOnSingleClick() != isEditable || label->isEditableOnDoubleClick() != isEditable)
	{
		label->setEditable (isEditable, isEditable, false);
		setWantsKeyboardFocus (! isEditable);
		resized();
	}
}

bool ComboBox::isTextEditable() const noexcept
{
	return label->isEditable();
}

void ComboBox::setJustificationType (const Justification& justification)
{
	label->setJustificationType (justification);
}

Justification ComboBox::getJustificationType() const noexcept
{
	return label->getJustificationType();
}

void ComboBox::setTooltip (const String& newTooltip)
{
	SettableTooltipClient::setTooltip (newTooltip);
	label->setTooltip (newTooltip);
}

void ComboBox::addItem (const String& newItemText, const int newItemId)
{
	// you can't add empty strings to the list..
	jassert (newItemText.isNotEmpty());

	// IDs must be non-zero, as zero is used to indicate a lack of selecion.
	jassert (newItemId != 0);

	// you shouldn't use duplicate item IDs!
	jassert (getItemForId (newItemId) == nullptr);

	if (newItemText.isNotEmpty() && newItemId != 0)
	{
		if (separatorPending)
		{
			separatorPending = false;
			items.add (new ItemInfo (String::empty, 0, false, false));
		}

		items.add (new ItemInfo (newItemText, newItemId, true, false));
	}
}

void ComboBox::addItemList (const StringArray& items, const int firstItemIdOffset)
{
	for (int i = 0; i < items.size(); ++i)
		addItem (items[i], i + firstItemIdOffset);
}

void ComboBox::addSeparator()
{
	separatorPending = (items.size() > 0);
}

void ComboBox::addSectionHeading (const String& headingName)
{
	// you can't add empty strings to the list..
	jassert (headingName.isNotEmpty());

	if (headingName.isNotEmpty())
	{
		if (separatorPending)
		{
			separatorPending = false;
			items.add (new ItemInfo (String::empty, 0, false, false));
		}

		items.add (new ItemInfo (headingName, 0, true, true));
	}
}

void ComboBox::setItemEnabled (const int itemId, const bool shouldBeEnabled)
{
	ItemInfo* const item = getItemForId (itemId);

	if (item != nullptr)
		item->isEnabled = shouldBeEnabled;
}

bool ComboBox::isItemEnabled (int itemId) const noexcept
{
	const ItemInfo* const item = getItemForId (itemId);
	return item != nullptr && item->isEnabled;
}

void ComboBox::changeItemText (const int itemId, const String& newText)
{
	ItemInfo* const item = getItemForId (itemId);

	jassert (item != nullptr);

	if (item != nullptr)
		item->name = newText;
}

void ComboBox::clear (const bool dontSendChangeMessage)
{
	items.clear();
	separatorPending = false;

	if (! label->isEditable())
		setSelectedItemIndex (-1, dontSendChangeMessage);
}

ComboBox::ItemInfo* ComboBox::getItemForId (const int itemId) const noexcept
{
	if (itemId != 0)
	{
		for (int i = items.size(); --i >= 0;)
			if (items.getUnchecked(i)->itemId == itemId)
				return items.getUnchecked(i);
	}

	return nullptr;
}

ComboBox::ItemInfo* ComboBox::getItemForIndex (const int index) const noexcept
{
	for (int n = 0, i = 0; i < items.size(); ++i)
	{
		ItemInfo* const item = items.getUnchecked(i);

		if (item->isRealItem())
			if (n++ == index)
				return item;
	}

	return nullptr;
}

int ComboBox::getNumItems() const noexcept
{
	int n = 0;

	for (int i = items.size(); --i >= 0;)
		if (items.getUnchecked(i)->isRealItem())
			++n;

	return n;
}

String ComboBox::getItemText (const int index) const
{
	const ItemInfo* const item = getItemForIndex (index);

	return item != nullptr ? item->name : String::empty;
}

int ComboBox::getItemId (const int index) const noexcept
{
	const ItemInfo* const item = getItemForIndex (index);

	return item != nullptr ? item->itemId : 0;
}

int ComboBox::indexOfItemId (const int itemId) const noexcept
{
	for (int n = 0, i = 0; i < items.size(); ++i)
	{
		const ItemInfo* const item = items.getUnchecked(i);

		if (item->isRealItem())
		{
			if (item->itemId == itemId)
				return n;

			++n;
		}
	}

	return -1;
}

int ComboBox::getSelectedItemIndex() const
{
	int index = indexOfItemId (currentId.getValue());

	if (getText() != getItemText (index))
		index = -1;

	return index;
}

void ComboBox::setSelectedItemIndex (const int index, const bool dontSendChangeMessage)
{
	setSelectedId (getItemId (index), dontSendChangeMessage);
}

int ComboBox::getSelectedId() const noexcept
{
	const ItemInfo* const item = getItemForId (currentId.getValue());

	return (item != nullptr && getText() == item->name) ? item->itemId : 0;
}

void ComboBox::setSelectedId (const int newItemId, const bool dontSendChangeMessage)
{
	const ItemInfo* const item = getItemForId (newItemId);
	const String newItemText (item != nullptr ? item->name : String::empty);

	if (lastCurrentId != newItemId || label->getText() != newItemText)
	{
		if (! dontSendChangeMessage)
			triggerAsyncUpdate();

		label->setText (newItemText, false);
		lastCurrentId = newItemId;
		currentId = newItemId;

		repaint();  // for the benefit of the 'none selected' text
	}
}

bool ComboBox::selectIfEnabled (const int index)
{
	const ItemInfo* const item = getItemForIndex (index);

	if (item != nullptr && item->isEnabled)
	{
		setSelectedItemIndex (index);
		return true;
	}

	return false;
}

void ComboBox::valueChanged (Value&)
{
	if (lastCurrentId != (int) currentId.getValue())
		setSelectedId (currentId.getValue(), false);
}

String ComboBox::getText() const
{
	return label->getText();
}

void ComboBox::setText (const String& newText, const bool dontSendChangeMessage)
{
	for (int i = items.size(); --i >= 0;)
	{
		const ItemInfo* const item = items.getUnchecked(i);

		if (item->isRealItem()
			 && item->name == newText)
		{
			setSelectedId (item->itemId, dontSendChangeMessage);
			return;
		}
	}

	lastCurrentId = 0;
	currentId = 0;

	if (label->getText() != newText)
	{
		label->setText (newText, false);

		if (! dontSendChangeMessage)
			triggerAsyncUpdate();
	}

	repaint();
}

void ComboBox::showEditor()
{
	jassert (isTextEditable()); // you probably shouldn't do this to a non-editable combo box?

	label->showEditor();
}

void ComboBox::setTextWhenNothingSelected (const String& newMessage)
{
	if (textWhenNothingSelected != newMessage)
	{
		textWhenNothingSelected = newMessage;
		repaint();
	}
}

String ComboBox::getTextWhenNothingSelected() const
{
	return textWhenNothingSelected;
}

void ComboBox::setTextWhenNoChoicesAvailable (const String& newMessage)
{
	noChoicesMessage = newMessage;
}

String ComboBox::getTextWhenNoChoicesAvailable() const
{
	return noChoicesMessage;
}

void ComboBox::paint (Graphics& g)
{
	getLookAndFeel().drawComboBox (g, getWidth(), getHeight(), isButtonDown,
								   label->getRight(), 0, getWidth() - label->getRight(), getHeight(),
								   *this);

	if (textWhenNothingSelected.isNotEmpty()
		 && label->getText().isEmpty()
		 && ! label->isBeingEdited())
	{
		g.setColour (findColour (textColourId).withMultipliedAlpha (0.5f));
		g.setFont (label->getFont());
		g.drawFittedText (textWhenNothingSelected,
						  label->getX() + 2, label->getY() + 1,
						  label->getWidth() - 4, label->getHeight() - 2,
						  label->getJustificationType(),
						  jmax (1, (int) (label->getHeight() / label->getFont().getHeight())));
	}
}

void ComboBox::resized()
{
	if (getHeight() > 0 && getWidth() > 0)
		getLookAndFeel().positionComboBoxText (*this, *label);
}

void ComboBox::enablementChanged()
{
	repaint();
}

void ComboBox::lookAndFeelChanged()
{
	repaint();

	{
		ScopedPointer <Label> newLabel (getLookAndFeel().createComboBoxTextBox (*this));
		jassert (newLabel != nullptr);

		if (label != nullptr)
		{
			newLabel->setEditable (label->isEditable());
			newLabel->setJustificationType (label->getJustificationType());
			newLabel->setTooltip (label->getTooltip());
			newLabel->setText (label->getText(), false);
		}

		label = newLabel;
	}

	addAndMakeVisible (label);
	setWantsKeyboardFocus (! label->isEditable());

	label->addListener (this);
	label->addMouseListener (this, false);

	label->setColour (Label::backgroundColourId, Colours::transparentBlack);
	label->setColour (Label::textColourId, findColour (ComboBox::textColourId));

	label->setColour (TextEditor::textColourId, findColour (ComboBox::textColourId));
	label->setColour (TextEditor::backgroundColourId, Colours::transparentBlack);
	label->setColour (TextEditor::highlightColourId, findColour (TextEditor::highlightColourId));
	label->setColour (TextEditor::outlineColourId, Colours::transparentBlack);

	resized();
}

void ComboBox::colourChanged()
{
	lookAndFeelChanged();
}

bool ComboBox::keyPressed (const KeyPress& key)
{
	if (key.isKeyCode (KeyPress::upKey) || key.isKeyCode (KeyPress::leftKey))
	{
		int index = getSelectedItemIndex() - 1;

		while (index >= 0 && ! selectIfEnabled (index))
			--index;

		return true;
	}
	else if (key.isKeyCode (KeyPress::downKey) || key.isKeyCode (KeyPress::rightKey))
	{
		int index = getSelectedItemIndex() + 1;

		while (index < getNumItems() && ! selectIfEnabled (index))
			++index;

		return true;
	}
	else if (key.isKeyCode (KeyPress::returnKey))
	{
		showPopup();
		return true;
	}

	return false;
}

bool ComboBox::keyStateChanged (const bool isKeyDown)
{
	// only forward key events that aren't used by this component
	return isKeyDown
			&& (KeyPress::isKeyCurrentlyDown (KeyPress::upKey)
				|| KeyPress::isKeyCurrentlyDown (KeyPress::leftKey)
				|| KeyPress::isKeyCurrentlyDown (KeyPress::downKey)
				|| KeyPress::isKeyCurrentlyDown (KeyPress::rightKey));
}

void ComboBox::focusGained (FocusChangeType)    { repaint(); }
void ComboBox::focusLost (FocusChangeType)      { repaint(); }

void ComboBox::labelTextChanged (Label*)
{
	triggerAsyncUpdate();
}

void ComboBox::popupMenuFinishedCallback (int result, ComboBox* box)
{
	if (box != nullptr)
	{
		box->menuActive = false;

		if (result != 0)
			box->setSelectedId (result);
	}
}

void ComboBox::showPopup()
{
	if (! menuActive)
	{
		const int selectedId = getSelectedId();

		PopupMenu menu;
		menu.setLookAndFeel (&getLookAndFeel());

		for (int i = 0; i < items.size(); ++i)
		{
			const ItemInfo* const item = items.getUnchecked(i);

			if (item->isSeparator())
				menu.addSeparator();
			else if (item->isHeading)
				menu.addSectionHeader (item->name);
			else
				menu.addItem (item->itemId, item->name,
							  item->isEnabled, item->itemId == selectedId);
		}

		if (items.size() == 0)
			menu.addItem (1, noChoicesMessage, false);

		menuActive = true;

		menu.showMenuAsync (PopupMenu::Options().withTargetComponent (this)
												.withItemThatMustBeVisible (selectedId)
												.withMinimumWidth (getWidth())
												.withMaximumNumColumns (1)
												.withStandardItemHeight (jlimit (12, 24, getHeight())),
							ModalCallbackFunction::forComponent (popupMenuFinishedCallback, this));
	}
}

void ComboBox::mouseDown (const MouseEvent& e)
{
	beginDragAutoRepeat (300);

	isButtonDown = isEnabled() && ! e.mods.isPopupMenu();

	if (isButtonDown && (e.eventComponent == this || ! label->isEditable()))
		showPopup();
}

void ComboBox::mouseDrag (const MouseEvent& e)
{
	beginDragAutoRepeat (50);

	if (isButtonDown && ! e.mouseWasClicked())
		showPopup();
}

void ComboBox::mouseUp (const MouseEvent& e2)
{
	if (isButtonDown)
	{
		isButtonDown = false;
		repaint();

		const MouseEvent e (e2.getEventRelativeTo (this));

		if (reallyContains (e.getPosition(), true)
			 && (e2.eventComponent == this || ! label->isEditable()))
		{
			showPopup();
		}
	}
}

void ComboBox::addListener (ComboBoxListener* const listener)
{
	listeners.add (listener);
}

void ComboBox::removeListener (ComboBoxListener* const listener)
{
	listeners.remove (listener);
}

void ComboBox::handleAsyncUpdate()
{
	Component::BailOutChecker checker (this);
	listeners.callChecked (checker, &ComboBoxListener::comboBoxChanged, this);  // (can't use ComboBox::Listener due to idiotic VC2005 bug)
}

const Identifier ComboBox::Ids::tagType ("COMBOBOX");
const Identifier ComboBox::Ids::items ("items");
const Identifier ComboBox::Ids::editable ("editable");
const Identifier ComboBox::Ids::textJustification ("textJustification");
const Identifier ComboBox::Ids::unselectedText ("unselectedText");
const Identifier ComboBox::Ids::noItemsText ("noItemsText");

void ComboBox::refreshFromValueTree (const ValueTree& state, ComponentBuilder&)
{
	ComponentBuilder::refreshBasicComponentProperties (*this, state);

	{
		StringArray items;
		items.addLines (state [Ids::items].toString());
		items.removeEmptyStrings (true);

		StringArray existingItems;

		for (int i = 0; i < getNumItems(); ++i)
			existingItems.add (getItemText (i));

		if (existingItems != items)
		{
			clear();

			for (int i = 0; i < items.size(); ++i)
				addItem (items[i], i + 1);
		}
	}

	setEditableText (state [Ids::editable]);
	setJustificationType ((int) state [Ids::textJustification]);
	setTextWhenNothingSelected (state [Ids::unselectedText].toString());
	setTextWhenNoChoicesAvailable (state [Ids::noItemsText].toString());
}

/*** End of inlined file: juce_ComboBox.cpp ***/


/*** Start of inlined file: juce_ImageComponent.cpp ***/
ImageComponent::ImageComponent (const String& name)
	: Component (name),
	  placement (RectanglePlacement::centred)
{
}

ImageComponent::~ImageComponent()
{
}

void ImageComponent::setImage (const Image& newImage)
{
	if (image != newImage)
	{
		image = newImage;
		repaint();
	}
}

void ImageComponent::setImage (const Image& newImage, const RectanglePlacement& placementToUse)
{
	if (image != newImage || placement != placementToUse)
	{
		image = newImage;
		placement = placementToUse;
		repaint();
	}
}

void ImageComponent::setImagePlacement (const RectanglePlacement& newPlacement)
{
	if (placement != newPlacement)
	{
		placement = newPlacement;
		repaint();
	}
}

const Image& ImageComponent::getImage() const
{
	return image;
}

const RectanglePlacement ImageComponent::getImagePlacement() const
{
	return placement;
}

void ImageComponent::paint (Graphics& g)
{
	g.setOpacity (1.0f);
	g.drawImageWithin (image, 0, 0, getWidth(), getHeight(), placement, false);
}

const Identifier ImageComponent::Ids::tagType ("IMAGECOMPONENT");
const Identifier ImageComponent::Ids::image ("image");
const Identifier ImageComponent::Ids::placement ("placement");

void ImageComponent::refreshFromValueTree (const ValueTree& state, ComponentBuilder& builder)
{
	ComponentBuilder::refreshBasicComponentProperties (*this, state);

	Image newImage;
	const var imageIdentifier (state [Ids::image]);

	ComponentBuilder::ImageProvider* const imageProvider = builder.getImageProvider();
	jassert (imageProvider != nullptr || imageIdentifier.isVoid());

	if (imageProvider != nullptr)
		newImage = imageProvider->getImageForIdentifier (imageIdentifier);

	setImage (newImage, getPlacement (state));
}

RectanglePlacement ImageComponent::getPlacement (const ValueTree& state)
{
	return RectanglePlacement (static_cast <int> (state [Ids::placement]));
}

/*** End of inlined file: juce_ImageComponent.cpp ***/


/*** Start of inlined file: juce_Label.cpp ***/
Label::Label (const String& name,
			  const String& labelText)
	: Component (name),
	  textValue (labelText),
	  lastTextValue (labelText),
	  font (15.0f),
	  justification (Justification::centredLeft),
	  horizontalBorderSize (5),
	  verticalBorderSize (1),
	  minimumHorizontalScale (0.7f),
	  editSingleClick (false),
	  editDoubleClick (false),
	  lossOfFocusDiscardsChanges (false)
{
	setColour (TextEditor::textColourId, Colours::black);
	setColour (TextEditor::backgroundColourId, Colours::transparentBlack);
	setColour (TextEditor::outlineColourId, Colours::transparentBlack);

	textValue.addListener (this);
}

Label::~Label()
{
	textValue.removeListener (this);

	if (ownerComponent != nullptr)
		ownerComponent->removeComponentListener (this);

	editor = nullptr;
}

void Label::setText (const String& newText,
					 const bool broadcastChangeMessage)
{
	hideEditor (true);

	if (lastTextValue != newText)
	{
		lastTextValue = newText;
		textValue = newText;
		repaint();

		textWasChanged();

		if (ownerComponent != nullptr)
			componentMovedOrResized (*ownerComponent, true, true);

		if (broadcastChangeMessage)
			callChangeListeners();
	}
}

String Label::getText (const bool returnActiveEditorContents) const
{
	return (returnActiveEditorContents && isBeingEdited())
				? editor->getText()
				: textValue.toString();
}

void Label::valueChanged (Value&)
{
	if (lastTextValue != textValue.toString())
		setText (textValue.toString(), true);
}

void Label::setFont (const Font& newFont)
{
	if (font != newFont)
	{
		font = newFont;
		repaint();
	}
}

const Font& Label::getFont() const noexcept
{
	return font;
}

void Label::setEditable (const bool editOnSingleClick,
						 const bool editOnDoubleClick,
						 const bool lossOfFocusDiscardsChanges_)
{
	editSingleClick = editOnSingleClick;
	editDoubleClick = editOnDoubleClick;
	lossOfFocusDiscardsChanges = lossOfFocusDiscardsChanges_;

	setWantsKeyboardFocus (editOnSingleClick || editOnDoubleClick);
	setFocusContainer (editOnSingleClick || editOnDoubleClick);
}

void Label::setJustificationType (const Justification& newJustification)
{
	if (justification != newJustification)
	{
		justification = newJustification;
		repaint();
	}
}

void Label::setBorderSize (int h, int v)
{
	if (horizontalBorderSize != h || verticalBorderSize != v)
	{
		horizontalBorderSize = h;
		verticalBorderSize = v;
		repaint();
	}
}

Component* Label::getAttachedComponent() const
{
	return static_cast<Component*> (ownerComponent);
}

void Label::attachToComponent (Component* owner, const bool onLeft)
{
	if (ownerComponent != nullptr)
		ownerComponent->removeComponentListener (this);

	ownerComponent = owner;

	leftOfOwnerComp = onLeft;

	if (ownerComponent != nullptr)
	{
		setVisible (owner->isVisible());
		ownerComponent->addComponentListener (this);
		componentParentHierarchyChanged (*ownerComponent);
		componentMovedOrResized (*ownerComponent, true, true);
	}
}

void Label::componentMovedOrResized (Component& component, bool /*wasMoved*/, bool /*wasResized*/)
{
	if (leftOfOwnerComp)
	{
		setSize (jmin (getFont().getStringWidth (textValue.toString()) + 8, component.getX()),
				 component.getHeight());

		setTopRightPosition (component.getX(), component.getY());
	}
	else
	{
		setSize (component.getWidth(),
				 8 + roundToInt (getFont().getHeight()));

		setTopLeftPosition (component.getX(), component.getY() - getHeight());
	}
}

void Label::componentParentHierarchyChanged (Component& component)
{
	if (component.getParentComponent() != nullptr)
		component.getParentComponent()->addChildComponent (this);
}

void Label::componentVisibilityChanged (Component& component)
{
	setVisible (component.isVisible());
}

void Label::textWasEdited() {}
void Label::textWasChanged() {}
void Label::editorShown (TextEditor*) {}
void Label::editorAboutToBeHidden (TextEditor*) {}

void Label::showEditor()
{
	if (editor == nullptr)
	{
		addAndMakeVisible (editor = createEditorComponent());
		editor->setText (getText(), false);
		editor->addListener (this);
		editor->grabKeyboardFocus();
		editor->setHighlightedRegion (Range<int> (0, textValue.toString().length()));

		resized();
		repaint();

		editorShown (editor);

		enterModalState (false);
		editor->grabKeyboardFocus();
	}
}

bool Label::updateFromTextEditorContents (TextEditor& ed)
{
	const String newText (ed.getText());

	if (textValue.toString() != newText)
	{
		lastTextValue = newText;
		textValue = newText;
		repaint();

		textWasChanged();

		if (ownerComponent != nullptr)
			componentMovedOrResized (*ownerComponent, true, true);

		return true;
	}

	return false;
}

void Label::hideEditor (const bool discardCurrentEditorContents)
{
	if (editor != nullptr)
	{
		WeakReference<Component> deletionChecker (this);

		ScopedPointer<TextEditor> outgoingEditor (editor);

		editorAboutToBeHidden (outgoingEditor);

		const bool changed = (! discardCurrentEditorContents)
							   && updateFromTextEditorContents (*outgoingEditor);
		outgoingEditor = nullptr;
		repaint();

		if (changed)
			textWasEdited();

		if (deletionChecker != nullptr)
			exitModalState (0);

		if (changed && deletionChecker != nullptr)
			callChangeListeners();
	}
}

void Label::inputAttemptWhenModal()
{
	if (editor != nullptr)
	{
		if (lossOfFocusDiscardsChanges)
			textEditorEscapeKeyPressed (*editor);
		else
			textEditorReturnKeyPressed (*editor);
	}
}

bool Label::isBeingEdited() const noexcept
{
	return editor != nullptr;
}

TextEditor* Label::createEditorComponent()
{
	TextEditor* const ed = new TextEditor (getName());
	ed->setFont (font);

	// copy these colours from our own settings..
	const int cols[] = { TextEditor::backgroundColourId,
						 TextEditor::textColourId,
						 TextEditor::highlightColourId,
						 TextEditor::highlightedTextColourId,
						 TextEditor::outlineColourId,
						 TextEditor::focusedOutlineColourId,
						 TextEditor::shadowColourId,
						 CaretComponent::caretColourId };

	for (int i = 0; i < numElementsInArray (cols); ++i)
		ed->setColour (cols[i], findColour (cols[i]));

	return ed;
}

void Label::paint (Graphics& g)
{
	getLookAndFeel().drawLabel (g, *this);
}

void Label::mouseUp (const MouseEvent& e)
{
	if (editSingleClick
		 && e.mouseWasClicked()
		 && contains (e.getPosition())
		 && ! e.mods.isPopupMenu())
	{
		showEditor();
	}
}

void Label::mouseDoubleClick (const MouseEvent& e)
{
	if (editDoubleClick && ! e.mods.isPopupMenu())
		showEditor();
}

void Label::resized()
{
	if (editor != nullptr)
		editor->setBoundsInset (BorderSize<int> (0));
}

void Label::focusGained (FocusChangeType cause)
{
	if (editSingleClick && cause == focusChangedByTabKey)
		showEditor();
}

void Label::enablementChanged()
{
	repaint();
}

void Label::colourChanged()
{
	repaint();
}

void Label::setMinimumHorizontalScale (const float newScale)
{
	if (minimumHorizontalScale != newScale)
	{
		minimumHorizontalScale = newScale;
		repaint();
	}
}

// We'll use a custom focus traverser here to make sure focus goes from the
// text editor to another component rather than back to the label itself.
class LabelKeyboardFocusTraverser   : public KeyboardFocusTraverser
{
public:
	LabelKeyboardFocusTraverser() {}

	Component* getNextComponent (Component* current)
	{
		return KeyboardFocusTraverser::getNextComponent (dynamic_cast <TextEditor*> (current) != nullptr
															? current->getParentComponent() : current);
	}

	Component* getPreviousComponent (Component* current)
	{
		return KeyboardFocusTraverser::getPreviousComponent (dynamic_cast <TextEditor*> (current) != nullptr
																? current->getParentComponent() : current);
	}
};

KeyboardFocusTraverser* Label::createFocusTraverser()
{
	return new LabelKeyboardFocusTraverser();
}

void Label::addListener (LabelListener* const listener)
{
	listeners.add (listener);
}

void Label::removeListener (LabelListener* const listener)
{
	listeners.remove (listener);
}

void Label::callChangeListeners()
{
	Component::BailOutChecker checker (this);
	listeners.callChecked (checker, &LabelListener::labelTextChanged, this);  // (can't use Label::Listener due to idiotic VC2005 bug)
}

void Label::textEditorTextChanged (TextEditor& ed)
{
	if (editor != nullptr)
	{
		jassert (&ed == editor);

		if (! (hasKeyboardFocus (true) || isCurrentlyBlockedByAnotherModalComponent()))
		{
			if (lossOfFocusDiscardsChanges)
				textEditorEscapeKeyPressed (ed);
			else
				textEditorReturnKeyPressed (ed);
		}
	}
}

void Label::textEditorReturnKeyPressed (TextEditor& ed)
{
	if (editor != nullptr)
	{
		jassert (&ed == editor);

		const bool changed = updateFromTextEditorContents (ed);
		hideEditor (true);

		if (changed)
		{
			WeakReference<Component> deletionChecker (this);
			textWasEdited();

			if (deletionChecker != nullptr)
				callChangeListeners();
		}
	}
}

void Label::textEditorEscapeKeyPressed (TextEditor& ed)
{
	if (editor != nullptr)
	{
		jassert (&ed == editor);
		(void) ed;

		editor->setText (textValue.toString(), false);
		hideEditor (true);
	}
}

void Label::textEditorFocusLost (TextEditor& ed)
{
	textEditorTextChanged (ed);
}

const Identifier Label::Ids::tagType ("LABEL");
const Identifier Label::Ids::text ("text");
const Identifier Label::Ids::font ("font");
const Identifier Label::Ids::editMode ("editMode");
const Identifier Label::Ids::justification ("justification");
const Identifier Label::Ids::focusLossDiscardsChanges ("focusLossDiscardsChanges");

void Label::refreshFromValueTree (const ValueTree& state, ComponentBuilder&)
{
	ComponentBuilder::refreshBasicComponentProperties (*this, state);

	setText (state [Ids::text].toString(), false);
	setFont (Font::fromString (state [Ids::font]));
	const int editMode = static_cast <int> (state [Ids::editMode]);
	setEditable (editMode == 2, editMode == 3, static_cast <bool> (state [Ids::focusLossDiscardsChanges]));
	setJustificationType (static_cast <int> (state [Ids::justification]));
}

/*** End of inlined file: juce_Label.cpp ***/


/*** Start of inlined file: juce_ListBox.cpp ***/
class ListBoxRowComponent  : public Component,
							 public TooltipClient
{
public:
	ListBoxRowComponent (ListBox& owner_)
		: owner (owner_), row (-1),
		  selected (false), isDragging (false), selectRowOnMouseUp (false)
	{
	}

	void paint (Graphics& g)
	{
		if (owner.getModel() != nullptr)
			owner.getModel()->paintListBoxItem (row, g, getWidth(), getHeight(), selected);
	}

	void update (const int row_, const bool selected_)
	{
		if (row != row_ || selected != selected_)
		{
			repaint();
			row = row_;
			selected = selected_;
		}

		if (owner.getModel() != nullptr)
		{
			customComponent = owner.getModel()->refreshComponentForRow (row_, selected_, customComponent.release());

			if (customComponent != nullptr)
			{
				addAndMakeVisible (customComponent);
				customComponent->setBounds (getLocalBounds());
			}
		}
	}

	void mouseDown (const MouseEvent& e)
	{
		isDragging = false;
		selectRowOnMouseUp = false;

		if (isEnabled())
		{
			if (! selected)
			{
				owner.selectRowsBasedOnModifierKeys (row, e.mods, false);

				if (owner.getModel() != nullptr)
					owner.getModel()->listBoxItemClicked (row, e);
			}
			else
			{
				selectRowOnMouseUp = true;
			}
		}
	}

	void mouseUp (const MouseEvent& e)
	{
		if (isEnabled() && selectRowOnMouseUp && ! isDragging)
		{
			owner.selectRowsBasedOnModifierKeys (row, e.mods, true);

			if (owner.getModel() != nullptr)
				owner.getModel()->listBoxItemClicked (row, e);
		}
	}

	void mouseDoubleClick (const MouseEvent& e)
	{
		if (owner.getModel() != nullptr && isEnabled())
			owner.getModel()->listBoxItemDoubleClicked (row, e);
	}

	void mouseDrag (const MouseEvent& e)
	{
		if (isEnabled() && owner.getModel() != nullptr && ! (e.mouseWasClicked() || isDragging))
		{
			const SparseSet<int> selectedRows (owner.getSelectedRows());

			if (selectedRows.size() > 0)
			{
				const var dragDescription (owner.getModel()->getDragSourceDescription (selectedRows));

				if (! (dragDescription.isVoid() || (dragDescription.isString() && dragDescription.toString().isEmpty())))
				{
					isDragging = true;
					owner.startDragAndDrop (e, dragDescription, true);
				}
			}
		}
	}

	void resized()
	{
		if (customComponent != nullptr)
			customComponent->setBounds (getLocalBounds());
	}

	String getTooltip()
	{
		if (owner.getModel() != nullptr)
			return owner.getModel()->getTooltipForRow (row);

		return String::empty;
	}

	ScopedPointer<Component> customComponent;

private:
	ListBox& owner;
	int row;
	bool selected, isDragging, selectRowOnMouseUp;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ListBoxRowComponent);
};

class ListBox::ListViewport  : public Viewport
{
public:
	ListViewport (ListBox& owner_)
		: owner (owner_)
	{
		setWantsKeyboardFocus (false);

		Component* const content = new Component();
		setViewedComponent (content);
		content->addMouseListener (this, false);
		content->setWantsKeyboardFocus (false);
	}

	ListBoxRowComponent* getComponentForRow (const int row) const noexcept
	{
		return rows [row % jmax (1, rows.size())];
	}

	ListBoxRowComponent* getComponentForRowIfOnscreen (const int row) const noexcept
	{
		return (row >= firstIndex && row < firstIndex + rows.size())
				 ? getComponentForRow (row) : nullptr;
	}

	int getRowNumberOfComponent (Component* const rowComponent) const noexcept
	{
		const int index = getIndexOfChildComponent (rowComponent);
		const int num = rows.size();

		for (int i = num; --i >= 0;)
			if (((firstIndex + i) % jmax (1, num)) == index)
				return firstIndex + i;

		return -1;
	}

	void visibleAreaChanged (const Rectangle<int>&)
	{
		updateVisibleArea (true);

		if (owner.getModel() != nullptr)
			owner.getModel()->listWasScrolled();
	}

	void updateVisibleArea (const bool makeSureItUpdatesContent)
	{
		hasUpdated = false;

		const int newX = getViewedComponent()->getX();
		int newY = getViewedComponent()->getY();
		const int newW = jmax (owner.minimumRowWidth, getMaximumVisibleWidth());
		const int newH = owner.totalItems * owner.getRowHeight();

		if (newY + newH < getMaximumVisibleHeight() && newH > getMaximumVisibleHeight())
			newY = getMaximumVisibleHeight() - newH;

		getViewedComponent()->setBounds (newX, newY, newW, newH);

		if (makeSureItUpdatesContent && ! hasUpdated)
			updateContents();
	}

	void updateContents()
	{
		hasUpdated = true;
		const int rowHeight = owner.getRowHeight();

		if (rowHeight > 0)
		{
			const int y = getViewPositionY();
			const int w = getViewedComponent()->getWidth();

			const int numNeeded = 2 + getMaximumVisibleHeight() / rowHeight;
			rows.removeRange (numNeeded, rows.size());

			while (numNeeded > rows.size())
			{
				ListBoxRowComponent* newRow = new ListBoxRowComponent (owner);
				rows.add (newRow);
				getViewedComponent()->addAndMakeVisible (newRow);
			}

			firstIndex = y / rowHeight;
			firstWholeIndex = (y + rowHeight - 1) / rowHeight;
			lastWholeIndex = (y + getMaximumVisibleHeight() - 1) / rowHeight;

			for (int i = 0; i < numNeeded; ++i)
			{
				const int row = i + firstIndex;
				ListBoxRowComponent* const rowComp = getComponentForRow (row);

				if (rowComp != nullptr)
				{
					rowComp->setBounds (0, row * rowHeight, w, rowHeight);
					rowComp->update (row, owner.isRowSelected (row));
				}
			}
		}

		if (owner.headerComponent != nullptr)
			owner.headerComponent->setBounds (owner.outlineThickness + getViewedComponent()->getX(),
											  owner.outlineThickness,
											  jmax (owner.getWidth() - owner.outlineThickness * 2,
													getViewedComponent()->getWidth()),
											  owner.headerComponent->getHeight());
	}

	void selectRow (const int row, const int rowHeight, const bool dontScroll,
					const int lastRowSelected, const int totalItems, const bool isMouseClick)
	{
		hasUpdated = false;

		if (row < firstWholeIndex && ! dontScroll)
		{
			setViewPosition (getViewPositionX(), row * rowHeight);
		}
		else if (row >= lastWholeIndex && ! dontScroll)
		{
			const int rowsOnScreen = lastWholeIndex - firstWholeIndex;

			if (row >= lastRowSelected + rowsOnScreen
				 && rowsOnScreen < totalItems - 1
				 && ! isMouseClick)
			{
				setViewPosition (getViewPositionX(),
								 jlimit (0, jmax (0, totalItems - rowsOnScreen), row) * rowHeight);
			}
			else
			{
				setViewPosition (getViewPositionX(),
								 jmax (0, (row  + 1) * rowHeight - getMaximumVisibleHeight()));
			}
		}

		if (! hasUpdated)
			updateContents();
	}

	void scrollToEnsureRowIsOnscreen (const int row, const int rowHeight)
	{
		if (row < firstWholeIndex)
		{
			setViewPosition (getViewPositionX(), row * rowHeight);
		}
		else if (row >= lastWholeIndex)
		{
			setViewPosition (getViewPositionX(),
							 jmax (0, (row  + 1) * rowHeight - getMaximumVisibleHeight()));
		}
	}

	void paint (Graphics& g)
	{
		if (isOpaque())
			g.fillAll (owner.findColour (ListBox::backgroundColourId));
	}

	bool keyPressed (const KeyPress& key)
	{
		if (key.isKeyCode (KeyPress::upKey)
			|| key.isKeyCode (KeyPress::downKey)
			|| key.isKeyCode (KeyPress::pageUpKey)
			|| key.isKeyCode (KeyPress::pageDownKey)
			|| key.isKeyCode (KeyPress::homeKey)
			|| key.isKeyCode (KeyPress::endKey))
		{
			// we want to avoid these keypresses going to the viewport, and instead allow
			// them to pass up to our listbox..
			return false;
		}

		return Viewport::keyPressed (key);
	}

private:
	ListBox& owner;
	OwnedArray<ListBoxRowComponent> rows;
	int firstIndex, firstWholeIndex, lastWholeIndex;
	bool hasUpdated;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ListViewport);
};

enum { defaultListRowHeight = 22 };

ListBox::ListBox (const String& name, ListBoxModel* const model_)
	: Component (name),
	  model (model_),
	  totalItems (0),
	  rowHeight (defaultListRowHeight),
	  minimumRowWidth (0),
	  outlineThickness (0),
	  lastRowSelected (-1),
	  mouseMoveSelects (false),
	  multipleSelection (false),
	  hasDoneInitialUpdate (false)
{
	addAndMakeVisible (viewport = new ListViewport (*this));

	ListBox::setWantsKeyboardFocus (true);
	ListBox::colourChanged();
}

ListBox::~ListBox()
{
	headerComponent = nullptr;
	viewport = nullptr;
}

void ListBox::setModel (ListBoxModel* const newModel)
{
	if (model != newModel)
	{
		model = newModel;
		repaint();
		updateContent();
	}
}

void ListBox::setMultipleSelectionEnabled (bool b)
{
	multipleSelection = b;
}

void ListBox::setMouseMoveSelectsRows (bool b)
{
	mouseMoveSelects = b;

	if (b)
		addMouseListener (this, true);
}

void ListBox::paint (Graphics& g)
{
	if (! hasDoneInitialUpdate)
		updateContent();

	g.fillAll (findColour (backgroundColourId));
}

void ListBox::paintOverChildren (Graphics& g)
{
	if (outlineThickness > 0)
	{
		g.setColour (findColour (outlineColourId));
		g.drawRect (0, 0, getWidth(), getHeight(), outlineThickness);
	}
}

void ListBox::resized()
{
	viewport->setBoundsInset (BorderSize<int> (outlineThickness + ((headerComponent != nullptr) ? headerComponent->getHeight() : 0),
											   outlineThickness, outlineThickness, outlineThickness));

	viewport->setSingleStepSizes (20, getRowHeight());

	viewport->updateVisibleArea (false);
}

void ListBox::visibilityChanged()
{
	viewport->updateVisibleArea (true);
}

Viewport* ListBox::getViewport() const noexcept
{
	return viewport;
}

void ListBox::updateContent()
{
	hasDoneInitialUpdate = true;
	totalItems = (model != nullptr) ? model->getNumRows() : 0;

	bool selectionChanged = false;

	if (selected.size() > 0 && selected [selected.size() - 1] >= totalItems)
	{
		selected.removeRange (Range <int> (totalItems, std::numeric_limits<int>::max()));
		lastRowSelected = getSelectedRow (0);
		selectionChanged = true;
	}

	viewport->updateVisibleArea (isVisible());
	viewport->resized();

	if (selectionChanged && model != nullptr)
		model->selectedRowsChanged (lastRowSelected);
}

void ListBox::selectRow (const int row,
						 bool dontScroll,
						 bool deselectOthersFirst)
{
	selectRowInternal (row, dontScroll, deselectOthersFirst, false);
}

void ListBox::selectRowInternal (const int row,
								 bool dontScroll,
								 bool deselectOthersFirst,
								 bool isMouseClick)
{
	if (! multipleSelection)
		deselectOthersFirst = true;

	if ((! isRowSelected (row))
		 || (deselectOthersFirst && getNumSelectedRows() > 1))
	{
		if (isPositiveAndBelow (row, totalItems))
		{
			if (deselectOthersFirst)
				selected.clear();

			selected.addRange (Range<int> (row, row + 1));

			if (getHeight() == 0 || getWidth() == 0)
				dontScroll = true;

			viewport->selectRow (row, getRowHeight(), dontScroll,
								 lastRowSelected, totalItems, isMouseClick);

			lastRowSelected = row;
			model->selectedRowsChanged (row);
		}
		else
		{
			if (deselectOthersFirst)
				deselectAllRows();
		}
	}
}

void ListBox::deselectRow (const int row)
{
	if (selected.contains (row))
	{
		selected.removeRange (Range <int> (row, row + 1));

		if (row == lastRowSelected)
			lastRowSelected = getSelectedRow (0);

		viewport->updateContents();
		model->selectedRowsChanged (lastRowSelected);
	}
}

void ListBox::setSelectedRows (const SparseSet<int>& setOfRowsToBeSelected,
							   const bool sendNotificationEventToModel)
{
	selected = setOfRowsToBeSelected;
	selected.removeRange (Range <int> (totalItems, std::numeric_limits<int>::max()));

	if (! isRowSelected (lastRowSelected))
		lastRowSelected = getSelectedRow (0);

	viewport->updateContents();

	if ((model != nullptr) && sendNotificationEventToModel)
		model->selectedRowsChanged (lastRowSelected);
}

SparseSet<int> ListBox::getSelectedRows() const
{
	return selected;
}

void ListBox::selectRangeOfRows (int firstRow, int lastRow)
{
	if (multipleSelection && (firstRow != lastRow))
	{
		const int numRows = totalItems - 1;
		firstRow = jlimit (0, jmax (0, numRows), firstRow);
		lastRow = jlimit (0, jmax (0, numRows), lastRow);

		selected.addRange (Range <int> (jmin (firstRow, lastRow),
										jmax (firstRow, lastRow) + 1));

		selected.removeRange (Range <int> (lastRow, lastRow + 1));
	}

	selectRowInternal (lastRow, false, false, true);
}

void ListBox::flipRowSelection (const int row)
{
	if (isRowSelected (row))
		deselectRow (row);
	else
		selectRowInternal (row, false, false, true);
}

void ListBox::deselectAllRows()
{
	if (! selected.isEmpty())
	{
		selected.clear();
		lastRowSelected = -1;

		viewport->updateContents();

		if (model != nullptr)
			model->selectedRowsChanged (lastRowSelected);
	}
}

void ListBox::selectRowsBasedOnModifierKeys (const int row,
											 const ModifierKeys& mods,
											 const bool isMouseUpEvent)
{
	if (multipleSelection && mods.isCommandDown())
	{
		flipRowSelection (row);
	}
	else if (multipleSelection && mods.isShiftDown() && lastRowSelected >= 0)
	{
		selectRangeOfRows (lastRowSelected, row);
	}
	else if ((! mods.isPopupMenu()) || ! isRowSelected (row))
	{
		selectRowInternal (row, false, ! (multipleSelection && (! isMouseUpEvent) && isRowSelected (row)), true);
	}
}

int ListBox::getNumSelectedRows() const
{
	return selected.size();
}

int ListBox::getSelectedRow (const int index) const
{
	return (isPositiveAndBelow (index, selected.size()))
				? selected [index] : -1;
}

bool ListBox::isRowSelected (const int row) const
{
	return selected.contains (row);
}

int ListBox::getLastRowSelected() const
{
	return (isRowSelected (lastRowSelected)) ? lastRowSelected : -1;
}

int ListBox::getRowContainingPosition (const int x, const int y) const noexcept
{
	if (isPositiveAndBelow (x, getWidth()))
	{
		const int row = (viewport->getViewPositionY() + y - viewport->getY()) / rowHeight;

		if (isPositiveAndBelow (row, totalItems))
			return row;
	}

	return -1;
}

int ListBox::getInsertionIndexForPosition (const int x, const int y) const noexcept
{
	if (isPositiveAndBelow (x, getWidth()))
	{
		const int row = (viewport->getViewPositionY() + y + rowHeight / 2 - viewport->getY()) / rowHeight;
		return jlimit (0, totalItems, row);
	}

	return -1;
}

Component* ListBox::getComponentForRowNumber (const int row) const noexcept
{
	ListBoxRowComponent* const listRowComp = viewport->getComponentForRowIfOnscreen (row);
	return listRowComp != nullptr ? static_cast <Component*> (listRowComp->customComponent) : nullptr;
}

int ListBox::getRowNumberOfComponent (Component* const rowComponent) const noexcept
{
	return viewport->getRowNumberOfComponent (rowComponent);
}

Rectangle<int> ListBox::getRowPosition (const int rowNumber,
										const bool relativeToComponentTopLeft) const noexcept
{
	int y = viewport->getY() + rowHeight * rowNumber;

	if (relativeToComponentTopLeft)
		y -= viewport->getViewPositionY();

	return Rectangle<int> (viewport->getX(), y,
						   viewport->getViewedComponent()->getWidth(), rowHeight);
}

void ListBox::setVerticalPosition (const double proportion)
{
	const int offscreen = viewport->getViewedComponent()->getHeight() - viewport->getHeight();

	viewport->setViewPosition (viewport->getViewPositionX(),
							   jmax (0, roundToInt (proportion * offscreen)));
}

double ListBox::getVerticalPosition() const
{
	const int offscreen = viewport->getViewedComponent()->getHeight() - viewport->getHeight();

	return (offscreen > 0) ? viewport->getViewPositionY() / (double) offscreen
						   : 0;
}

int ListBox::getVisibleRowWidth() const noexcept
{
	return viewport->getViewWidth();
}

void ListBox::scrollToEnsureRowIsOnscreen (const int row)
{
	viewport->scrollToEnsureRowIsOnscreen (row, getRowHeight());
}

bool ListBox::keyPressed (const KeyPress& key)
{
	const int numVisibleRows = viewport->getHeight() / getRowHeight();

	const bool multiple = multipleSelection
							&& (lastRowSelected >= 0)
							&& (key.getModifiers().isShiftDown()
								 || key.getModifiers().isCtrlDown()
								 || key.getModifiers().isCommandDown());

	if (key.isKeyCode (KeyPress::upKey))
	{
		if (multiple)
			selectRangeOfRows (lastRowSelected, lastRowSelected - 1);
		else
			selectRow (jmax (0, lastRowSelected - 1));
	}
	else if (key.isKeyCode (KeyPress::returnKey)
			  && isRowSelected (lastRowSelected))
	{
		if (model != nullptr)
			model->returnKeyPressed (lastRowSelected);
	}
	else if (key.isKeyCode (KeyPress::pageUpKey))
	{
		if (multiple)
			selectRangeOfRows (lastRowSelected, lastRowSelected - numVisibleRows);
		else
			selectRow (jmax (0, jmax (0, lastRowSelected) - numVisibleRows));
	}
	else if (key.isKeyCode (KeyPress::pageDownKey))
	{
		if (multiple)
			selectRangeOfRows (lastRowSelected, lastRowSelected + numVisibleRows);
		else
			selectRow (jmin (totalItems - 1, jmax (0, lastRowSelected) + numVisibleRows));
	}
	else if (key.isKeyCode (KeyPress::homeKey))
	{
		if (multiple && key.getModifiers().isShiftDown())
			selectRangeOfRows (lastRowSelected, 0);
		else
			selectRow (0);
	}
	else if (key.isKeyCode (KeyPress::endKey))
	{
		if (multiple && key.getModifiers().isShiftDown())
			selectRangeOfRows (lastRowSelected, totalItems - 1);
		else
			selectRow (totalItems - 1);
	}
	else if (key.isKeyCode (KeyPress::downKey))
	{
		if (multiple)
			selectRangeOfRows (lastRowSelected, lastRowSelected + 1);
		else
			selectRow (jmin (totalItems - 1, jmax (0, lastRowSelected) + 1));
	}
	else if ((key.isKeyCode (KeyPress::deleteKey) || key.isKeyCode (KeyPress::backspaceKey))
			   && isRowSelected (lastRowSelected))
	{
		if (model != nullptr)
			model->deleteKeyPressed (lastRowSelected);
	}
	else if (multiple && key == KeyPress ('a', ModifierKeys::commandModifier, 0))
	{
		selectRangeOfRows (0, std::numeric_limits<int>::max());
	}
	else
	{
		return false;
	}

	return true;
}

bool ListBox::keyStateChanged (const bool isKeyDown)
{
	return isKeyDown
			&& (KeyPress::isKeyCurrentlyDown (KeyPress::upKey)
				|| KeyPress::isKeyCurrentlyDown (KeyPress::pageUpKey)
				|| KeyPress::isKeyCurrentlyDown (KeyPress::downKey)
				|| KeyPress::isKeyCurrentlyDown (KeyPress::pageDownKey)
				|| KeyPress::isKeyCurrentlyDown (KeyPress::homeKey)
				|| KeyPress::isKeyCurrentlyDown (KeyPress::endKey)
				|| KeyPress::isKeyCurrentlyDown (KeyPress::returnKey));
}

void ListBox::mouseWheelMove (const MouseEvent& e, float wheelIncrementX, float wheelIncrementY)
{
	bool eventWasUsed = false;

	if (viewport->getHorizontalScrollBar()->isVisible() && wheelIncrementX != 0)
	{
		eventWasUsed = true;
		viewport->getHorizontalScrollBar()->mouseWheelMove (e, wheelIncrementX, 0);
	}

	if (viewport->getVerticalScrollBar()->isVisible() && wheelIncrementY != 0)
	{
		eventWasUsed = true;
		viewport->getVerticalScrollBar()->mouseWheelMove (e, 0, wheelIncrementY);
	}

	if (! eventWasUsed)
		Component::mouseWheelMove (e, wheelIncrementX, wheelIncrementY);
}

void ListBox::mouseMove (const MouseEvent& e)
{
	if (mouseMoveSelects)
	{
		const MouseEvent e2 (e.getEventRelativeTo (this));
		selectRow (getRowContainingPosition (e2.x, e2.y), true);
	}
}

void ListBox::mouseExit (const MouseEvent& e)
{
	mouseMove (e);
}

void ListBox::mouseUp (const MouseEvent& e)
{
	if (e.mouseWasClicked() && model != nullptr)
		model->backgroundClicked();
}

void ListBox::setRowHeight (const int newHeight)
{
	rowHeight = jmax (1, newHeight);
	viewport->setSingleStepSizes (20, rowHeight);
	updateContent();
}

int ListBox::getNumRowsOnScreen() const noexcept
{
	return viewport->getMaximumVisibleHeight() / rowHeight;
}

void ListBox::setMinimumContentWidth (const int newMinimumWidth)
{
	minimumRowWidth = newMinimumWidth;
	updateContent();
}

int ListBox::getVisibleContentWidth() const noexcept
{
	return viewport->getMaximumVisibleWidth();
}

ScrollBar* ListBox::getVerticalScrollBar() const noexcept
{
	return viewport->getVerticalScrollBar();
}

ScrollBar* ListBox::getHorizontalScrollBar() const noexcept
{
	return viewport->getHorizontalScrollBar();
}

void ListBox::colourChanged()
{
	setOpaque (findColour (backgroundColourId).isOpaque());
	viewport->setOpaque (isOpaque());
	repaint();
}

void ListBox::setOutlineThickness (const int outlineThickness_)
{
	outlineThickness = outlineThickness_;
	resized();
}

void ListBox::setHeaderComponent (Component* const newHeaderComponent)
{
	if (headerComponent != newHeaderComponent)
	{
		headerComponent = newHeaderComponent;

		addAndMakeVisible (newHeaderComponent);
		ListBox::resized();
	}
}

void ListBox::repaintRow (const int rowNumber) noexcept
{
	repaint (getRowPosition (rowNumber, true));
}

Image ListBox::createSnapshotOfSelectedRows (int& imageX, int& imageY)
{
	Rectangle<int> imageArea;
	const int firstRow = getRowContainingPosition (0, 0);

	int i;
	for (i = getNumRowsOnScreen() + 2; --i >= 0;)
	{
		Component* rowComp = viewport->getComponentForRowIfOnscreen (firstRow + i);

		if (rowComp != nullptr && isRowSelected (firstRow + i))
		{
			const Point<int> pos (getLocalPoint (rowComp, Point<int>()));
			const Rectangle<int> rowRect (pos.getX(), pos.getY(), rowComp->getWidth(), rowComp->getHeight());
			imageArea = imageArea.getUnion (rowRect);
		}
	}

	imageArea = imageArea.getIntersection (getLocalBounds());
	imageX = imageArea.getX();
	imageY = imageArea.getY();
	Image snapshot (Image::ARGB, imageArea.getWidth(), imageArea.getHeight(), true);

	for (i = getNumRowsOnScreen() + 2; --i >= 0;)
	{
		Component* rowComp = viewport->getComponentForRowIfOnscreen (firstRow + i);

		if (rowComp != nullptr && isRowSelected (firstRow + i))
		{
			const Point<int> pos (getLocalPoint (rowComp, Point<int>()));

			Graphics g (snapshot);
			g.setOrigin (pos.getX() - imageX, pos.getY() - imageY);

			if (g.reduceClipRegion (rowComp->getLocalBounds()))
			{
				g.beginTransparencyLayer (0.6f);
				rowComp->paintEntireComponent (g, false);
				g.endTransparencyLayer();
			}
		}
	}

	return snapshot;
}

void ListBox::startDragAndDrop (const MouseEvent& e, const var& dragDescription, bool allowDraggingToOtherWindows)
{
	DragAndDropContainer* const dragContainer
		= DragAndDropContainer::findParentDragContainerFor (this);

	if (dragContainer != nullptr)
	{
		int x, y;
		Image dragImage (createSnapshotOfSelectedRows (x, y));

		MouseEvent e2 (e.getEventRelativeTo (this));
		const Point<int> p (x - e2.x, y - e2.y);
		dragContainer->startDragging (dragDescription, this, dragImage, allowDraggingToOtherWindows, &p);
	}
	else
	{
		// to be able to do a drag-and-drop operation, the listbox needs to
		// be inside a component which is also a DragAndDropContainer.
		jassertfalse;
	}
}

const Identifier ListBox::Ids::rowHeight ("rowHeight");
const Identifier ListBox::Ids::borderThickness ("borderThickness");

void ListBox::refreshFromValueTree (const ValueTree& state, ComponentBuilder&)
{
	ComponentBuilder::refreshBasicComponentProperties (*this, state);

	setRowHeight (state.getProperty (Ids::rowHeight, defaultListRowHeight));
	setOutlineThickness (state.getProperty (Ids::borderThickness, 0));
}

Component* ListBoxModel::refreshComponentForRow (int, bool, Component* existingComponentToUpdate)
{
	(void) existingComponentToUpdate;
	jassert (existingComponentToUpdate == nullptr); // indicates a failure in the code the recycles the components
	return nullptr;
}

void ListBoxModel::listBoxItemClicked (int, const MouseEvent&) {}
void ListBoxModel::listBoxItemDoubleClicked (int, const MouseEvent&) {}
void ListBoxModel::backgroundClicked() {}
void ListBoxModel::selectedRowsChanged (int) {}
void ListBoxModel::deleteKeyPressed (int) {}
void ListBoxModel::returnKeyPressed (int) {}
void ListBoxModel::listWasScrolled() {}
var ListBoxModel::getDragSourceDescription (const SparseSet<int>&)      { return var::null; }
String ListBoxModel::getTooltipForRow (int)                             { return String::empty; }

/*** End of inlined file: juce_ListBox.cpp ***/


/*** Start of inlined file: juce_ProgressBar.cpp ***/
ProgressBar::ProgressBar (double& progress_)
   : progress (progress_),
	 displayPercentage (true),
	 lastCallbackTime (0)
{
	currentValue = jlimit (0.0, 1.0, progress);
}

ProgressBar::~ProgressBar()
{
}

void ProgressBar::setPercentageDisplay (const bool shouldDisplayPercentage)
{
	displayPercentage = shouldDisplayPercentage;
	repaint();
}

void ProgressBar::setTextToDisplay (const String& text)
{
	displayPercentage = false;
	displayedMessage = text;
}

void ProgressBar::lookAndFeelChanged()
{
	setOpaque (findColour (backgroundColourId).isOpaque());
}

void ProgressBar::colourChanged()
{
	lookAndFeelChanged();
}

void ProgressBar::paint (Graphics& g)
{
	String text;

	if (displayPercentage)
	{
		if (currentValue >= 0 && currentValue <= 1.0)
			text << roundToInt (currentValue * 100.0) << '%';
	}
	else
	{
		text = displayedMessage;
	}

	getLookAndFeel().drawProgressBar (g, *this,
									  getWidth(), getHeight(),
									  currentValue, text);
}

void ProgressBar::visibilityChanged()
{
	if (isVisible())
		startTimer (30);
	else
		stopTimer();
}

void ProgressBar::timerCallback()
{
	double newProgress = progress;

	const uint32 now = Time::getMillisecondCounter();
	const int timeSinceLastCallback = (int) (now - lastCallbackTime);
	lastCallbackTime = now;

	if (currentValue != newProgress
		 || newProgress < 0 || newProgress >= 1.0
		 || currentMessage != displayedMessage)
	{
		if (currentValue < newProgress
			 && newProgress >= 0 && newProgress < 1.0
			 && currentValue >= 0 && currentValue < 1.0)
		{
			newProgress = jmin (currentValue + 0.0008 * timeSinceLastCallback,
								newProgress);
		}

		currentValue = newProgress;
		currentMessage = displayedMessage;
		repaint();
	}
}

/*** End of inlined file: juce_ProgressBar.cpp ***/


/*** Start of inlined file: juce_Slider.cpp ***/
class Slider::PopupDisplayComponent  : public BubbleComponent,
									   public Timer
{
public:
	PopupDisplayComponent (Slider& owner_)
		: owner (owner_),
		  font (15.0f, Font::bold)
	{
		setAlwaysOnTop (true);
	}

	void paintContent (Graphics& g, int w, int h)
	{
		g.setFont (font);
		g.setColour (findColour (TooltipWindow::textColourId, true));
		g.drawFittedText (text, 0, 0, w, h, Justification::centred, 1);
	}

	void getContentSize (int& w, int& h)
	{
		w = font.getStringWidth (text) + 18;
		h = (int) (font.getHeight() * 1.6f);
	}

	void updatePosition (const String& newText)
	{
		text = newText;
		BubbleComponent::setPosition (&owner);
		repaint();
	}

	void timerCallback()
	{
		owner.popupDisplay = nullptr;
	}

private:
	Slider& owner;
	Font font;
	String text;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (PopupDisplayComponent);
};

Slider::Slider (const String& name)
  : Component (name),
	lastCurrentValue (0),
	lastValueMin (0),
	lastValueMax (0),
	minimum (0),
	maximum (10),
	interval (0),
	skewFactor (1.0),
	velocityModeSensitivity (1.0),
	velocityModeOffset (0.0),
	velocityModeThreshold (1),
	rotaryStart (float_Pi * 1.2f),
	rotaryEnd (float_Pi * 2.8f),
	numDecimalPlaces (7),
	sliderRegionStart (0),
	sliderRegionSize (1),
	sliderBeingDragged (-1),
	pixelsForFullDragExtent (250),
	style (LinearHorizontal),
	textBoxPos (TextBoxLeft),
	textBoxWidth (80),
	textBoxHeight (20),
	incDecButtonMode (incDecButtonsNotDraggable),
	editableText (true),
	doubleClickToValue (false),
	isVelocityBased (false),
	userKeyOverridesVelocity (true),
	rotaryStop (true),
	incDecButtonsSideBySide (false),
	sendChangeOnlyOnRelease (false),
	popupDisplayEnabled (false),
	menuEnabled (false),
	menuShown (false),
	scrollWheelEnabled (true),
	snapsToMousePos (true),
	parentForPopupDisplay (nullptr)
{
	setWantsKeyboardFocus (false);
	setRepaintsOnMouseActivity (true);

	Slider::lookAndFeelChanged();
	updateText();

	currentValue.addListener (this);
	valueMin.addListener (this);
	valueMax.addListener (this);
}

Slider::~Slider()
{
	currentValue.removeListener (this);
	valueMin.removeListener (this);
	valueMax.removeListener (this);
	popupDisplay = nullptr;
}

void Slider::handleAsyncUpdate()
{
	cancelPendingUpdate();

	Component::BailOutChecker checker (this);
	listeners.callChecked (checker, &SliderListener::sliderValueChanged, this);  // (can't use Slider::Listener due to idiotic VC2005 bug)
}

void Slider::sendDragStart()
{
	startedDragging();

	Component::BailOutChecker checker (this);
	listeners.callChecked (checker, &SliderListener::sliderDragStarted, this);
}

void Slider::sendDragEnd()
{
	stoppedDragging();

	sliderBeingDragged = -1;

	Component::BailOutChecker checker (this);
	listeners.callChecked (checker, &SliderListener::sliderDragEnded, this);
}

void Slider::addListener (SliderListener* const listener)
{
	listeners.add (listener);
}

void Slider::removeListener (SliderListener* const listener)
{
	listeners.remove (listener);
}

void Slider::setSliderStyle (const SliderStyle newStyle)
{
	if (style != newStyle)
	{
		style = newStyle;
		repaint();
		lookAndFeelChanged();
	}
}

void Slider::setRotaryParameters (const float startAngleRadians,
								  const float endAngleRadians,
								  const bool stopAtEnd)
{
	// make sure the values are sensible..
	jassert (rotaryStart >= 0 && rotaryEnd >= 0);
	jassert (rotaryStart < float_Pi * 4.0f && rotaryEnd < float_Pi * 4.0f);
	jassert (rotaryStart < rotaryEnd);

	rotaryStart = startAngleRadians;
	rotaryEnd = endAngleRadians;
	rotaryStop = stopAtEnd;
}

void Slider::setVelocityBasedMode (const bool velBased)
{
	isVelocityBased = velBased;
}

void Slider::setVelocityModeParameters (const double sensitivity,
										const int threshold,
										const double offset,
										const bool userCanPressKeyToSwapMode)
{
	jassert (threshold >= 0);
	jassert (sensitivity > 0);
	jassert (offset >= 0);

	velocityModeSensitivity = sensitivity;
	velocityModeOffset = offset;
	velocityModeThreshold = threshold;
	userKeyOverridesVelocity = userCanPressKeyToSwapMode;
}

void Slider::setSkewFactor (const double factor)
{
	skewFactor = factor;
}

void Slider::setSkewFactorFromMidPoint (const double sliderValueToShowAtMidPoint)
{
	if (maximum > minimum)
		skewFactor = log (0.5) / log ((sliderValueToShowAtMidPoint - minimum)
										/ (maximum - minimum));
}

void Slider::setMouseDragSensitivity (const int distanceForFullScaleDrag)
{
	jassert (distanceForFullScaleDrag > 0);

	pixelsForFullDragExtent = distanceForFullScaleDrag;
}

void Slider::setIncDecButtonsMode (const IncDecButtonMode mode)
{
	if (incDecButtonMode != mode)
	{
		incDecButtonMode = mode;
		lookAndFeelChanged();
	}
}

void Slider::setTextBoxStyle (const TextEntryBoxPosition newPosition,
							  const bool isReadOnly,
							  const int textEntryBoxWidth,
							  const int textEntryBoxHeight)
{
	if (textBoxPos != newPosition
		 || editableText != (! isReadOnly)
		 || textBoxWidth != textEntryBoxWidth
		 || textBoxHeight != textEntryBoxHeight)
	{
		textBoxPos = newPosition;
		editableText = ! isReadOnly;
		textBoxWidth = textEntryBoxWidth;
		textBoxHeight = textEntryBoxHeight;

		repaint();
		lookAndFeelChanged();
	}
}

void Slider::setTextBoxIsEditable (const bool shouldBeEditable)
{
	editableText = shouldBeEditable;

	if (valueBox != nullptr)
		valueBox->setEditable (shouldBeEditable && isEnabled());
}

void Slider::showTextBox()
{
	jassert (editableText); // this should probably be avoided in read-only sliders.

	if (valueBox != nullptr)
		valueBox->showEditor();
}

void Slider::hideTextBox (const bool discardCurrentEditorContents)
{
	if (valueBox != nullptr)
	{
		valueBox->hideEditor (discardCurrentEditorContents);

		if (discardCurrentEditorContents)
			updateText();
	}
}

void Slider::setChangeNotificationOnlyOnRelease (const bool onlyNotifyOnRelease)
{
	sendChangeOnlyOnRelease = onlyNotifyOnRelease;
}

void Slider::setSliderSnapsToMousePosition (const bool shouldSnapToMouse)
{
	snapsToMousePos = shouldSnapToMouse;
}

void Slider::setPopupDisplayEnabled (const bool enabled, Component* const parentComponentToUse)
{
	popupDisplayEnabled = enabled;
	parentForPopupDisplay = parentComponentToUse;
}

Component* Slider::getCurrentPopupDisplay() const noexcept
{
	return popupDisplay.get();
}

void Slider::colourChanged()
{
	lookAndFeelChanged();
}

void Slider::lookAndFeelChanged()
{
	LookAndFeel& lf = getLookAndFeel();

	if (textBoxPos != NoTextBox)
	{
		const String previousTextBoxContent (valueBox != nullptr ? valueBox->getText()
																 : getTextFromValue (currentValue.getValue()));

		valueBox = nullptr;
		addAndMakeVisible (valueBox = getLookAndFeel().createSliderTextBox (*this));

		valueBox->setWantsKeyboardFocus (false);
		valueBox->setText (previousTextBoxContent, false);

		if (valueBox->isEditable() != editableText) // (avoid overriding the single/double click flags unless we have to)
			valueBox->setEditable (editableText && isEnabled());

		valueBox->addListener (this);

		if (style == LinearBar)
			valueBox->addMouseListener (this, false);
		else
			valueBox->setTooltip (getTooltip());
	}
	else
	{
		valueBox = nullptr;
	}

	if (style == IncDecButtons)
	{
		addAndMakeVisible (incButton = lf.createSliderButton (true));
		incButton->addListener (this);

		addAndMakeVisible (decButton = lf.createSliderButton (false));
		decButton->addListener (this);

		if (incDecButtonMode != incDecButtonsNotDraggable)
		{
			incButton->addMouseListener (this, false);
			decButton->addMouseListener (this, false);
		}
		else
		{
			incButton->setRepeatSpeed (300, 100, 20);
			incButton->addMouseListener (decButton, false);

			decButton->setRepeatSpeed (300, 100, 20);
			decButton->addMouseListener (incButton, false);
		}

		incButton->setTooltip (getTooltip());
		decButton->setTooltip (getTooltip());
	}
	else
	{
		incButton = nullptr;
		decButton = nullptr;
	}

	setComponentEffect (lf.getSliderEffect());

	resized();
	repaint();
}

void Slider::setRange (const double newMin,
					   const double newMax,
					   const double newInt)
{
	if (minimum != newMin
		|| maximum != newMax
		|| interval != newInt)
	{
		minimum = newMin;
		maximum = newMax;
		interval = newInt;

		// figure out the number of DPs needed to display all values at this
		// interval setting.
		numDecimalPlaces = 7;

		if (newInt != 0)
		{
			int v = abs ((int) (newInt * 10000000));

			while ((v % 10) == 0)
			{
				--numDecimalPlaces;
				v /= 10;
			}
		}

		// keep the current values inside the new range..
		if (style != TwoValueHorizontal && style != TwoValueVertical)
		{
			setValue (getValue(), false, false);
		}
		else
		{
			setMinValue (getMinValue(), false, false);
			setMaxValue (getMaxValue(), false, false);
		}

		updateText();
	}
}

void Slider::triggerChangeMessage (const bool synchronous)
{
	if (synchronous)
		handleAsyncUpdate();
	else
		triggerAsyncUpdate();

	valueChanged();
}

void Slider::valueChanged (Value& value)
{
	if (value.refersToSameSourceAs (currentValue))
	{
		if (style != TwoValueHorizontal && style != TwoValueVertical)
			setValue (currentValue.getValue(), false, false);
	}
	else if (value.refersToSameSourceAs (valueMin))
		setMinValue (valueMin.getValue(), false, false, true);
	else if (value.refersToSameSourceAs (valueMax))
		setMaxValue (valueMax.getValue(), false, false, true);
}

double Slider::getValue() const
{
	// for a two-value style slider, you should use the getMinValue() and getMaxValue()
	// methods to get the two values.
	jassert (style != TwoValueHorizontal && style != TwoValueVertical);

	return currentValue.getValue();
}

void Slider::setValue (double newValue,
					   const bool sendUpdateMessage,
					   const bool sendMessageSynchronously)
{
	// for a two-value style slider, you should use the setMinValue() and setMaxValue()
	// methods to set the two values.
	jassert (style != TwoValueHorizontal && style != TwoValueVertical);

	newValue = constrainedValue (newValue);

	if (style == ThreeValueHorizontal || style == ThreeValueVertical)
	{
		jassert ((double) valueMin.getValue() <= (double) valueMax.getValue());

		newValue = jlimit ((double) valueMin.getValue(),
						   (double) valueMax.getValue(),
						   newValue);
	}

	if (newValue != lastCurrentValue)
	{
		if (valueBox != nullptr)
			valueBox->hideEditor (true);

		lastCurrentValue = newValue;

		// (need to do this comparison because the Value will use equalsWithSameType to compare
		// the new and old values, so will generate unwanted change events if the type changes)
		if (currentValue != newValue)
			currentValue = newValue;

		updateText();
		repaint();

		if (popupDisplay != nullptr)
			popupDisplay->updatePosition (getTextFromValue (newValue));

		if (sendUpdateMessage)
			triggerChangeMessage (sendMessageSynchronously);
	}
}

double Slider::getMinValue() const
{
	// The minimum value only applies to sliders that are in two- or three-value mode.
	jassert (style == TwoValueHorizontal || style == TwoValueVertical
			  || style == ThreeValueHorizontal || style == ThreeValueVertical);

	return valueMin.getValue();
}

double Slider::getMaxValue() const
{
	// The maximum value only applies to sliders that are in two- or three-value mode.
	jassert (style == TwoValueHorizontal || style == TwoValueVertical
			  || style == ThreeValueHorizontal || style == ThreeValueVertical);

	return valueMax.getValue();
}

void Slider::setMinValue (double newValue, const bool sendUpdateMessage, const bool sendMessageSynchronously, const bool allowNudgingOfOtherValues)
{
	// The minimum value only applies to sliders that are in two- or three-value mode.
	jassert (style == TwoValueHorizontal || style == TwoValueVertical
			  || style == ThreeValueHorizontal || style == ThreeValueVertical);

	newValue = constrainedValue (newValue);

	if (style == TwoValueHorizontal || style == TwoValueVertical)
	{
		if (allowNudgingOfOtherValues && newValue > (double) valueMax.getValue())
			setMaxValue (newValue, sendUpdateMessage, sendMessageSynchronously);

		newValue = jmin ((double) valueMax.getValue(), newValue);
	}
	else
	{
		if (allowNudgingOfOtherValues && newValue > lastCurrentValue)
			setValue (newValue, sendUpdateMessage, sendMessageSynchronously);

		newValue = jmin (lastCurrentValue, newValue);
	}

	if (lastValueMin != newValue)
	{
		lastValueMin = newValue;
		valueMin = newValue;
		repaint();

		if (popupDisplay != nullptr)
			popupDisplay->updatePosition (getTextFromValue (newValue));

		if (sendUpdateMessage)
			triggerChangeMessage (sendMessageSynchronously);
	}
}

void Slider::setMaxValue (double newValue, const bool sendUpdateMessage, const bool sendMessageSynchronously, const bool allowNudgingOfOtherValues)
{
	// The maximum value only applies to sliders that are in two- or three-value mode.
	jassert (style == TwoValueHorizontal || style == TwoValueVertical
			  || style == ThreeValueHorizontal || style == ThreeValueVertical);

	newValue = constrainedValue (newValue);

	if (style == TwoValueHorizontal || style == TwoValueVertical)
	{
		if (allowNudgingOfOtherValues && newValue < (double) valueMin.getValue())
			setMinValue (newValue, sendUpdateMessage, sendMessageSynchronously);

		newValue = jmax ((double) valueMin.getValue(), newValue);
	}
	else
	{
		if (allowNudgingOfOtherValues && newValue < lastCurrentValue)
			setValue (newValue, sendUpdateMessage, sendMessageSynchronously);

		newValue = jmax (lastCurrentValue, newValue);
	}

	if (lastValueMax != newValue)
	{
		lastValueMax = newValue;
		valueMax = newValue;
		repaint();

		if (popupDisplay != nullptr)
			popupDisplay->updatePosition (getTextFromValue (valueMax.getValue()));

		if (sendUpdateMessage)
			triggerChangeMessage (sendMessageSynchronously);
	}
}

void Slider::setMinAndMaxValues (double newMinValue, double newMaxValue, bool sendUpdateMessage, bool sendMessageSynchronously)
{
	// The maximum value only applies to sliders that are in two- or three-value mode.
	jassert (style == TwoValueHorizontal || style == TwoValueVertical
			  || style == ThreeValueHorizontal || style == ThreeValueVertical);

	if (newMaxValue < newMinValue)
		std::swap (newMaxValue, newMinValue);

	newMinValue = constrainedValue (newMinValue);
	newMaxValue = constrainedValue (newMaxValue);

	if (lastValueMax != newMaxValue || lastValueMin != newMinValue)
	{
		lastValueMax = newMaxValue;
		lastValueMin = newMinValue;
		valueMin = newMinValue;
		valueMax = newMaxValue;
		repaint();

		if (sendUpdateMessage)
			triggerChangeMessage (sendMessageSynchronously);
	}
}

void Slider::setDoubleClickReturnValue (const bool isDoubleClickEnabled,
										const double valueToSetOnDoubleClick)
{
	doubleClickToValue = isDoubleClickEnabled;
	doubleClickReturnValue = valueToSetOnDoubleClick;
}

double Slider::getDoubleClickReturnValue (bool& isEnabled_) const
{
	isEnabled_ = doubleClickToValue;
	return doubleClickReturnValue;
}

void Slider::updateText()
{
	if (valueBox != nullptr)
		valueBox->setText (getTextFromValue (currentValue.getValue()), false);
}

void Slider::setTextValueSuffix (const String& suffix)
{
	if (textSuffix != suffix)
	{
		textSuffix = suffix;
		updateText();
	}
}

String Slider::getTextValueSuffix() const
{
	return textSuffix;
}

String Slider::getTextFromValue (double v)
{
	if (getNumDecimalPlacesToDisplay() > 0)
		return String (v, getNumDecimalPlacesToDisplay()) + getTextValueSuffix();
	else
		return String (roundToInt (v)) + getTextValueSuffix();
}

double Slider::getValueFromText (const String& text)
{
	String t (text.trimStart());

	if (t.endsWith (textSuffix))
		t = t.substring (0, t.length() - textSuffix.length());

	while (t.startsWithChar ('+'))
		t = t.substring (1).trimStart();

	return t.initialSectionContainingOnly ("0123456789.,-")
			.getDoubleValue();
}

double Slider::proportionOfLengthToValue (double proportion)
{
	if (skewFactor != 1.0 && proportion > 0.0)
		proportion = exp (log (proportion) / skewFactor);

	return minimum + (maximum - minimum) * proportion;
}

double Slider::valueToProportionOfLength (double value)
{
	const double n = (value - minimum) / (maximum - minimum);

	return skewFactor == 1.0 ? n : pow (n, skewFactor);
}

double Slider::snapValue (double attemptedValue, const bool)
{
	return attemptedValue;
}

void Slider::startedDragging()
{
}

void Slider::stoppedDragging()
{
}

void Slider::valueChanged()
{
}

void Slider::enablementChanged()
{
	repaint();
}

void Slider::setPopupMenuEnabled (const bool menuEnabled_)
{
	menuEnabled = menuEnabled_;
}

void Slider::setScrollWheelEnabled (const bool enabled)
{
	scrollWheelEnabled = enabled;
}

void Slider::labelTextChanged (Label* label)
{
	const double newValue = snapValue (getValueFromText (label->getText()), false);

	if (newValue != (double) currentValue.getValue())
	{
		sendDragStart();
		setValue (newValue, true, true);
		sendDragEnd();
	}

	updateText(); // force a clean-up of the text, needed in case setValue() hasn't done this.
}

void Slider::buttonClicked (Button* button)
{
	if (style == IncDecButtons)
	{
		sendDragStart();

		if (button == incButton)
			setValue (snapValue (getValue() + interval, false), true, true);
		else if (button == decButton)
			setValue (snapValue (getValue() - interval, false), true, true);

		sendDragEnd();
	}
}

double Slider::constrainedValue (double value) const
{
	if (interval > 0)
		value = minimum + interval * std::floor ((value - minimum) / interval + 0.5);

	if (value <= minimum || maximum <= minimum)
		value = minimum;
	else if (value >= maximum)
		value = maximum;

	return value;
}

float Slider::getLinearSliderPos (const double value)
{
	double sliderPosProportional;

	if (maximum > minimum)
	{
		if (value < minimum)
		{
			sliderPosProportional = 0.0;
		}
		else if (value > maximum)
		{
			sliderPosProportional = 1.0;
		}
		else
		{
			sliderPosProportional = valueToProportionOfLength (value);
			jassert (sliderPosProportional >= 0 && sliderPosProportional <= 1.0);
		}
	}
	else
	{
		sliderPosProportional = 0.5;
	}

	if (isVertical() || style == IncDecButtons)
		sliderPosProportional = 1.0 - sliderPosProportional;

	return (float) (sliderRegionStart + sliderPosProportional * sliderRegionSize);
}

bool Slider::isHorizontal() const
{
	return style == LinearHorizontal
		|| style == LinearBar
		|| style == TwoValueHorizontal
		|| style == ThreeValueHorizontal;
}

bool Slider::isVertical() const
{
	return style == LinearVertical
		|| style == TwoValueVertical
		|| style == ThreeValueVertical;
}

bool Slider::incDecDragDirectionIsHorizontal() const
{
	return incDecButtonMode == incDecButtonsDraggable_Horizontal
			|| (incDecButtonMode == incDecButtonsDraggable_AutoDirection && incDecButtonsSideBySide);
}

float Slider::getPositionOfValue (const double value)
{
	if (isHorizontal() || isVertical())
	{
		return getLinearSliderPos (value);
	}
	else
	{
		jassertfalse; // not a valid call on a slider that doesn't work linearly!
		return 0.0f;
	}
}

void Slider::paint (Graphics& g)
{
	if (style != IncDecButtons)
	{
		if (style == Rotary || style == RotaryHorizontalDrag || style == RotaryVerticalDrag)
		{
			const float sliderPos = (float) valueToProportionOfLength (lastCurrentValue);
			jassert (sliderPos >= 0 && sliderPos <= 1.0f);

			getLookAndFeel().drawRotarySlider (g,
											   sliderRect.getX(),
											   sliderRect.getY(),
											   sliderRect.getWidth(),
											   sliderRect.getHeight(),
											   sliderPos,
											   rotaryStart, rotaryEnd,
											   *this);
		}
		else
		{
			getLookAndFeel().drawLinearSlider (g,
											   sliderRect.getX(),
											   sliderRect.getY(),
											   sliderRect.getWidth(),
											   sliderRect.getHeight(),
											   getLinearSliderPos (lastCurrentValue),
											   getLinearSliderPos (lastValueMin),
											   getLinearSliderPos (lastValueMax),
											   style,
											   *this);
		}

		if (style == LinearBar && valueBox == nullptr)
		{
			g.setColour (findColour (Slider::textBoxOutlineColourId));
			g.drawRect (0, 0, getWidth(), getHeight(), 1);
		}
	}
}

void Slider::resized()
{
	int minXSpace = 0;
	int minYSpace = 0;

	if (textBoxPos == TextBoxLeft || textBoxPos == TextBoxRight)
		minXSpace = 30;
	else
		minYSpace = 15;

	const int tbw = jmax (0, jmin (textBoxWidth, getWidth() - minXSpace));
	const int tbh = jmax (0, jmin (textBoxHeight, getHeight() - minYSpace));

	if (style == LinearBar)
	{
		if (valueBox != nullptr)
			valueBox->setBounds (getLocalBounds());
	}
	else
	{
		if (textBoxPos == NoTextBox)
		{
			sliderRect = getLocalBounds();
		}
		else if (textBoxPos == TextBoxLeft)
		{
			valueBox->setBounds (0, (getHeight() - tbh) / 2, tbw, tbh);
			sliderRect.setBounds (tbw, 0, getWidth() - tbw, getHeight());
		}
		else if (textBoxPos == TextBoxRight)
		{
			valueBox->setBounds (getWidth() - tbw, (getHeight() - tbh) / 2, tbw, tbh);
			sliderRect.setBounds (0, 0, getWidth() - tbw, getHeight());
		}
		else if (textBoxPos == TextBoxAbove)
		{
			valueBox->setBounds ((getWidth() - tbw) / 2, 0, tbw, tbh);
			sliderRect.setBounds (0, tbh, getWidth(), getHeight() - tbh);
		}
		else if (textBoxPos == TextBoxBelow)
		{
			valueBox->setBounds ((getWidth() - tbw) / 2, getHeight() - tbh, tbw, tbh);
			sliderRect.setBounds (0, 0, getWidth(), getHeight() - tbh);
		}
	}

	const int indent = getLookAndFeel().getSliderThumbRadius (*this);

	if (style == LinearBar)
	{
		const int barIndent = 1;
		sliderRegionStart = barIndent;
		sliderRegionSize = getWidth() - barIndent * 2;

		sliderRect.setBounds (sliderRegionStart, barIndent,
							  sliderRegionSize, getHeight() - barIndent * 2);
	}
	else if (isHorizontal())
	{
		sliderRegionStart = sliderRect.getX() + indent;
		sliderRegionSize = jmax (1, sliderRect.getWidth() - indent * 2);

		sliderRect.setBounds (sliderRegionStart, sliderRect.getY(),
							  sliderRegionSize, sliderRect.getHeight());
	}
	else if (isVertical())
	{
		sliderRegionStart = sliderRect.getY() + indent;
		sliderRegionSize = jmax (1, sliderRect.getHeight() - indent * 2);

		sliderRect.setBounds (sliderRect.getX(), sliderRegionStart,
							  sliderRect.getWidth(), sliderRegionSize);
	}
	else
	{
		sliderRegionStart = 0;
		sliderRegionSize = 100;
	}

	if (style == IncDecButtons)
	{
		Rectangle<int> buttonRect (sliderRect);

		if (textBoxPos == TextBoxLeft || textBoxPos == TextBoxRight)
			buttonRect.expand (-2, 0);
		else
			buttonRect.expand (0, -2);

		incDecButtonsSideBySide = buttonRect.getWidth() > buttonRect.getHeight();

		if (incDecButtonsSideBySide)
		{
			decButton->setBounds (buttonRect.removeFromLeft (buttonRect.getWidth() / 2));
			decButton->setConnectedEdges (Button::ConnectedOnRight);
			incButton->setConnectedEdges (Button::ConnectedOnLeft);
		}
		else
		{
			decButton->setBounds (buttonRect.removeFromBottom (buttonRect.getHeight() / 2));
			decButton->setConnectedEdges (Button::ConnectedOnTop);
			incButton->setConnectedEdges (Button::ConnectedOnBottom);
		}

		incButton->setBounds (buttonRect);
	}
}

void Slider::focusOfChildComponentChanged (FocusChangeType)
{
	repaint();
}

namespace SliderHelpers
{
	double smallestAngleBetween (double a1, double a2) noexcept
	{
		return jmin (std::abs (a1 - a2),
					 std::abs (a1 + double_Pi * 2.0 - a2),
					 std::abs (a2 + double_Pi * 2.0 - a1));
	}

	void sliderMenuCallback (int result, Slider* slider)
	{
		if (slider != nullptr)
		{
			switch (result)
			{
				case 1: slider->setVelocityBasedMode (! slider->getVelocityBasedMode()); break;
				case 2: slider->setSliderStyle (Slider::Rotary); break;
				case 3: slider->setSliderStyle (Slider::RotaryHorizontalDrag); break;
				case 4: slider->setSliderStyle (Slider::RotaryVerticalDrag); break;
				default: break;
			}
		}
	}
}

void Slider::showPopupMenu()
{
	menuShown = true;

	PopupMenu m;
	m.setLookAndFeel (&getLookAndFeel());
	m.addItem (1, TRANS ("velocity-sensitive mode"), true, isVelocityBased);
	m.addSeparator();

	if (style == Rotary || style == RotaryHorizontalDrag || style == RotaryVerticalDrag)
	{
		PopupMenu rotaryMenu;
		rotaryMenu.addItem (2, TRANS ("use circular dragging"), true, style == Rotary);
		rotaryMenu.addItem (3, TRANS ("use left-right dragging"), true, style == RotaryHorizontalDrag);
		rotaryMenu.addItem (4, TRANS ("use up-down dragging"), true, style == RotaryVerticalDrag);

		m.addSubMenu (TRANS ("rotary mode"), rotaryMenu);
	}

	m.showMenuAsync (PopupMenu::Options(),
					 ModalCallbackFunction::forComponent (SliderHelpers::sliderMenuCallback, this));
}

int Slider::getThumbIndexAt (const MouseEvent& e)
{
	const bool isTwoValue   = (style == TwoValueHorizontal   || style == TwoValueVertical);
	const bool isThreeValue = (style == ThreeValueHorizontal || style == ThreeValueVertical);

	if (isTwoValue || isThreeValue)
	{
		const float mousePos = (float) (isVertical() ? e.y : e.x);

		const float normalPosDistance = std::abs (getLinearSliderPos (currentValue.getValue()) - mousePos);
		const float minPosDistance    = std::abs (getLinearSliderPos (valueMin.getValue()) - 0.1f - mousePos);
		const float maxPosDistance    = std::abs (getLinearSliderPos (valueMax.getValue()) + 0.1f - mousePos);

		if (isTwoValue)
			return maxPosDistance <= minPosDistance ? 2 : 1;

		if (normalPosDistance >= minPosDistance && maxPosDistance >= minPosDistance)
			return 1;
		else if (normalPosDistance >= maxPosDistance)
			return 2;
	}

	return 0;
}

void Slider::mouseDown (const MouseEvent& e)
{
	mouseWasHidden = false;
	incDecDragged = false;
	mouseDragStartPos = mousePosWhenLastDragged = e.getPosition();

	if (isEnabled())
	{
		if (e.mods.isPopupMenu() && menuEnabled)
		{
			showPopupMenu();
		}
		else if (maximum > minimum)
		{
			menuShown = false;

			if (valueBox != nullptr)
				valueBox->hideEditor (true);

			sliderBeingDragged = getThumbIndexAt (e);

			minMaxDiff = (double) valueMax.getValue() - (double) valueMin.getValue();

			lastAngle = rotaryStart + (rotaryEnd - rotaryStart)
										* valueToProportionOfLength (currentValue.getValue());

			valueWhenLastDragged = (sliderBeingDragged == 2 ? valueMax
															: (sliderBeingDragged == 1 ? valueMin
																					   : currentValue)).getValue();
			valueOnMouseDown = valueWhenLastDragged;

			if (popupDisplayEnabled)
			{
				PopupDisplayComponent* const popup = new PopupDisplayComponent (*this);
				popupDisplay = popup;

				if (parentForPopupDisplay != nullptr)
					parentForPopupDisplay->addChildComponent (popup);
				else
					popup->addToDesktop (0);

				popup->setVisible (true);
			}

			sendDragStart();
			mouseDrag (e);
		}
	}
}

void Slider::mouseUp (const MouseEvent&)
{
	if (isEnabled()
		 && (! menuShown)
		 && (maximum > minimum)
		 && (style != IncDecButtons || incDecDragged))
	{
		restoreMouseIfHidden();

		if (sendChangeOnlyOnRelease && valueOnMouseDown != (double) currentValue.getValue())
			triggerChangeMessage (false);

		sendDragEnd();
		popupDisplay = nullptr;

		if (style == IncDecButtons)
		{
			incButton->setState (Button::buttonNormal);
			decButton->setState (Button::buttonNormal);
		}
	}
	else if (popupDisplay != nullptr)
	{
		popupDisplay->startTimer (2000);
	}
}

void Slider::restoreMouseIfHidden()
{
	if (mouseWasHidden)
	{
		mouseWasHidden = false;

		for (int i = Desktop::getInstance().getNumMouseSources(); --i >= 0;)
			Desktop::getInstance().getMouseSource(i)->enableUnboundedMouseMovement (false);

		const double pos = sliderBeingDragged == 2 ? getMaxValue()
												   : (sliderBeingDragged == 1 ? getMinValue()
																			  : (double) currentValue.getValue());
		Point<int> mousePos;

		if (style == RotaryHorizontalDrag || style == RotaryVerticalDrag)
		{
			mousePos = Desktop::getLastMouseDownPosition();

			if (style == RotaryHorizontalDrag)
			{
				const double posDiff = valueToProportionOfLength (pos) - valueToProportionOfLength (valueOnMouseDown);
				mousePos += Point<int> (roundToInt (pixelsForFullDragExtent * posDiff), 0);
			}
			else
			{
				const double posDiff = valueToProportionOfLength (valueOnMouseDown) - valueToProportionOfLength (pos);
				mousePos += Point<int> (0, roundToInt (pixelsForFullDragExtent * posDiff));
			}
		}
		else
		{
			const int pixelPos = (int) getLinearSliderPos (pos);

			mousePos = localPointToGlobal (Point<int> (isHorizontal() ? pixelPos : (getWidth() / 2),
													   isVertical()   ? pixelPos : (getHeight() / 2)));
		}

		Desktop::setMousePosition (mousePos);
	}
}

void Slider::modifierKeysChanged (const ModifierKeys& modifiers)
{
	if (isEnabled()
		 && style != IncDecButtons
		 && style != Rotary
		 && isVelocityBased == modifiers.isAnyModifierKeyDown())
	{
		restoreMouseIfHidden();
	}
}

void Slider::handleRotaryDrag (const MouseEvent& e)
{
	const int dx = e.x - sliderRect.getCentreX();
	const int dy = e.y - sliderRect.getCentreY();

	if (dx * dx + dy * dy > 25)
	{
		double angle = std::atan2 ((double) dx, (double) -dy);
		while (angle < 0.0)
			angle += double_Pi * 2.0;

		if (rotaryStop && ! e.mouseWasClicked())
		{
			if (std::abs (angle - lastAngle) > double_Pi)
			{
				if (angle >= lastAngle)
					angle -= double_Pi * 2.0;
				else
					angle += double_Pi * 2.0;
			}

			if (angle >= lastAngle)
				angle = jmin (angle, (double) jmax (rotaryStart, rotaryEnd));
			else
				angle = jmax (angle, (double) jmin (rotaryStart, rotaryEnd));
		}
		else
		{
			while (angle < rotaryStart)
				angle += double_Pi * 2.0;

			if (angle > rotaryEnd)
			{
				if (SliderHelpers::smallestAngleBetween (angle, rotaryStart)
					 <= SliderHelpers::smallestAngleBetween (angle, rotaryEnd))
					angle = rotaryStart;
				else
					angle = rotaryEnd;
			}
		}

		const double proportion = (angle - rotaryStart) / (rotaryEnd - rotaryStart);
		valueWhenLastDragged = proportionOfLengthToValue (jlimit (0.0, 1.0, proportion));
		lastAngle = angle;
	}
}

void Slider::handleAbsoluteDrag (const MouseEvent& e)
{
	const int mousePos = (isHorizontal() || style == RotaryHorizontalDrag) ? e.x : e.y;

	double scaledMousePos = (mousePos - sliderRegionStart) / (double) sliderRegionSize;

	if (style == RotaryHorizontalDrag
		|| style == RotaryVerticalDrag
		|| style == IncDecButtons
		|| ((style == LinearHorizontal || style == LinearVertical || style == LinearBar)
			&& ! snapsToMousePos))
	{
		const int mouseDiff = (style == RotaryHorizontalDrag
								 || style == LinearHorizontal
								 || style == LinearBar
								 || (style == IncDecButtons && incDecDragDirectionIsHorizontal()))
								? e.x - mouseDragStartPos.x
								: mouseDragStartPos.y - e.y;

		double newPos = valueToProportionOfLength (valueOnMouseDown)
						   + mouseDiff * (1.0 / pixelsForFullDragExtent);

		valueWhenLastDragged = proportionOfLengthToValue (jlimit (0.0, 1.0, newPos));

		if (style == IncDecButtons)
		{
			incButton->setState (mouseDiff < 0 ? Button::buttonNormal : Button::buttonDown);
			decButton->setState (mouseDiff > 0 ? Button::buttonNormal : Button::buttonDown);
		}
	}
	else
	{
		if (isVertical())
			scaledMousePos = 1.0 - scaledMousePos;

		valueWhenLastDragged = proportionOfLengthToValue (jlimit (0.0, 1.0, scaledMousePos));
	}
}

void Slider::handleVelocityDrag (const MouseEvent& e)
{
	const int mouseDiff = (isHorizontal() || style == RotaryHorizontalDrag
							 || (style == IncDecButtons && incDecDragDirectionIsHorizontal()))
							? e.x - mousePosWhenLastDragged.x
							: e.y - mousePosWhenLastDragged.y;

	const double maxSpeed = jmax (200, sliderRegionSize);
	double speed = jlimit (0.0, maxSpeed, (double) abs (mouseDiff));

	if (speed != 0)
	{
		speed = 0.2 * velocityModeSensitivity
				  * (1.0 + std::sin (double_Pi * (1.5 + jmin (0.5, velocityModeOffset
																+ jmax (0.0, (double) (speed - velocityModeThreshold))
																	/ maxSpeed))));

		if (mouseDiff < 0)
			speed = -speed;

		if (isVertical() || style == RotaryVerticalDrag
			 || (style == IncDecButtons && ! incDecDragDirectionIsHorizontal()))
			speed = -speed;

		const double currentPos = valueToProportionOfLength (valueWhenLastDragged);

		valueWhenLastDragged = proportionOfLengthToValue (jlimit (0.0, 1.0, currentPos + speed));

		e.source.enableUnboundedMouseMovement (true, false);
		mouseWasHidden = true;
	}
}

void Slider::mouseDrag (const MouseEvent& e)
{
	if (isEnabled()
		 && (! menuShown)
		 && (maximum > minimum)
		 && ! (style == LinearBar && e.mouseWasClicked() && valueBox != nullptr && valueBox->isEditable()))
	{
		if (style == Rotary)
		{
			handleRotaryDrag (e);
		}
		else
		{
			if (style == IncDecButtons && ! incDecDragged)
			{
				if (e.getDistanceFromDragStart() < 10 || e.mouseWasClicked())
					return;

				incDecDragged = true;
				mouseDragStartPos = e.getPosition();
			}

			if (isVelocityBased == (userKeyOverridesVelocity && e.mods.testFlags (ModifierKeys::ctrlModifier
																					| ModifierKeys::commandModifier
																					| ModifierKeys::altModifier))
				 || (maximum - minimum) / sliderRegionSize < interval)
				handleAbsoluteDrag (e);
			else
				handleVelocityDrag (e);
		}

		valueWhenLastDragged = jlimit (minimum, maximum, valueWhenLastDragged);

		if (sliderBeingDragged == 0)
		{
			setValue (snapValue (valueWhenLastDragged, true),
					  ! sendChangeOnlyOnRelease, true);
		}
		else if (sliderBeingDragged == 1)
		{
			setMinValue (snapValue (valueWhenLastDragged, true),
						 ! sendChangeOnlyOnRelease, false, true);

			if (e.mods.isShiftDown())
				setMaxValue (getMinValue() + minMaxDiff, false, false, true);
			else
				minMaxDiff = (double) valueMax.getValue() - (double) valueMin.getValue();
		}
		else if (sliderBeingDragged == 2)
		{
			setMaxValue (snapValue (valueWhenLastDragged, true),
						 ! sendChangeOnlyOnRelease, false, true);

			if (e.mods.isShiftDown())
				setMinValue (getMaxValue() - minMaxDiff, false, false, true);
			else
				minMaxDiff = (double) valueMax.getValue() - (double) valueMin.getValue();
		}

		mousePosWhenLastDragged = e.getPosition();
	}
}

void Slider::mouseDoubleClick (const MouseEvent&)
{
	if (doubleClickToValue
		 && isEnabled()
		 && style != IncDecButtons
		 && minimum <= doubleClickReturnValue
		 && maximum >= doubleClickReturnValue)
	{
		sendDragStart();
		setValue (doubleClickReturnValue, true, true);
		sendDragEnd();
	}
}

void Slider::mouseWheelMove (const MouseEvent& e, float wheelIncrementX, float wheelIncrementY)
{
	if (scrollWheelEnabled && isEnabled()
		 && style != TwoValueHorizontal
		 && style != TwoValueVertical)
	{
		if (maximum > minimum && ! e.mods.isAnyMouseButtonDown())
		{
			if (valueBox != nullptr)
				valueBox->hideEditor (false);

			const double value = (double) currentValue.getValue();
			const double proportionDelta = (wheelIncrementX != 0 ? -wheelIncrementX : wheelIncrementY) * 0.15f;
			const double currentPos = valueToProportionOfLength (value);
			const double newValue = proportionOfLengthToValue (jlimit (0.0, 1.0, currentPos + proportionDelta));

			double delta = (newValue != value)
							? jmax (std::abs (newValue - value), interval) : 0;

			if (value > newValue)
				delta = -delta;

			sendDragStart();
			setValue (snapValue (value + delta, false), true, true);
			sendDragEnd();
		}
	}
	else
	{
		Component::mouseWheelMove (e, wheelIncrementX, wheelIncrementY);
	}
}

void SliderListener::sliderDragStarted (Slider*)  // (can't write Slider::Listener due to idiotic VC2005 bug)
{
}

void SliderListener::sliderDragEnded (Slider*)
{
}

const Identifier Slider::Ids::tagType ("SLIDER");
const Identifier Slider::Ids::min ("min");
const Identifier Slider::Ids::max ("max");
const Identifier Slider::Ids::interval ("interval");
const Identifier Slider::Ids::type ("type");
const Identifier Slider::Ids::editable ("editable");
const Identifier Slider::Ids::textBoxPos ("textBoxPos");
const Identifier Slider::Ids::textBoxWidth ("textBoxWidth");
const Identifier Slider::Ids::textBoxHeight ("textBoxHeight");
const Identifier Slider::Ids::skew ("skew");

void Slider::refreshFromValueTree (const ValueTree& state, ComponentBuilder&)
{
	ComponentBuilder::refreshBasicComponentProperties (*this, state);

	setRange (static_cast <double> (state [Ids::min]),
			  static_cast <double> (state [Ids::max]),
			  static_cast <double> (state [Ids::interval]));

	setSliderStyle ((SliderStyle) static_cast <int> (state [Ids::type]));

	setTextBoxStyle ((TextEntryBoxPosition) static_cast <int> (state [Ids::textBoxPos]),
					 ! static_cast <bool> (state [Ids::editable]),
					 static_cast <int> (state [Ids::textBoxWidth]),
					 static_cast <int> (state [Ids::textBoxHeight]));

	setSkewFactor (static_cast <double> (state [Ids::skew]));
}

/*** End of inlined file: juce_Slider.cpp ***/


/*** Start of inlined file: juce_TableHeaderComponent.cpp ***/
class DragOverlayComp   : public Component
{
public:
	DragOverlayComp (const Image& image_)
		: image (image_)
	{
		image.duplicateIfShared();
		image.multiplyAllAlphas (0.8f);
		setAlwaysOnTop (true);
	}

	void paint (Graphics& g)
	{
		g.drawImageAt (image, 0, 0);
	}

private:
	Image image;

	JUCE_DECLARE_NON_COPYABLE (DragOverlayComp);
};

TableHeaderComponent::TableHeaderComponent()
	: columnsChanged (false),
	  columnsResized (false),
	  sortChanged (false),
	  menuActive (true),
	  stretchToFit (false),
	  columnIdBeingResized (0),
	  columnIdBeingDragged (0),
	  columnIdUnderMouse (0),
	  lastDeliberateWidth (0)
{
}

TableHeaderComponent::~TableHeaderComponent()
{
	dragOverlayComp = nullptr;
}

void TableHeaderComponent::setPopupMenuActive (const bool hasMenu)
{
	menuActive = hasMenu;
}

bool TableHeaderComponent::isPopupMenuActive() const                    { return menuActive; }

int TableHeaderComponent::getNumColumns (const bool onlyCountVisibleColumns) const
{
	if (onlyCountVisibleColumns)
	{
		int num = 0;

		for (int i = columns.size(); --i >= 0;)
			if (columns.getUnchecked(i)->isVisible())
				++num;

		return num;
	}
	else
	{
		return columns.size();
	}
}

String TableHeaderComponent::getColumnName (const int columnId) const
{
	const ColumnInfo* const ci = getInfoForId (columnId);
	return ci != nullptr ? ci->name : String::empty;
}

void TableHeaderComponent::setColumnName (const int columnId, const String& newName)
{
	ColumnInfo* const ci = getInfoForId (columnId);

	if (ci != nullptr && ci->name != newName)
	{
		ci->name = newName;
		sendColumnsChanged();
	}
}

void TableHeaderComponent::addColumn (const String& columnName,
									  const int columnId,
									  const int width,
									  const int minimumWidth,
									  const int maximumWidth,
									  const int propertyFlags,
									  const int insertIndex)
{
	// can't have a duplicate or null ID!
	jassert (columnId != 0 && getIndexOfColumnId (columnId, false) < 0);
	jassert (width > 0);

	ColumnInfo* const ci = new ColumnInfo();
	ci->name = columnName;
	ci->id = columnId;
	ci->width = width;
	ci->lastDeliberateWidth = width;
	ci->minimumWidth = minimumWidth;
	ci->maximumWidth = maximumWidth;
	if (ci->maximumWidth < 0)
		ci->maximumWidth = std::numeric_limits<int>::max();
	jassert (ci->maximumWidth >= ci->minimumWidth);
	ci->propertyFlags = propertyFlags;

	columns.insert (insertIndex, ci);
	sendColumnsChanged();
}

void TableHeaderComponent::removeColumn (const int columnIdToRemove)
{
	const int index = getIndexOfColumnId (columnIdToRemove, false);

	if (index >= 0)
	{
		columns.remove (index);
		sortChanged = true;
		sendColumnsChanged();
	}
}

void TableHeaderComponent::removeAllColumns()
{
	if (columns.size() > 0)
	{
		columns.clear();
		sendColumnsChanged();
	}
}

void TableHeaderComponent::moveColumn (const int columnId, int newIndex)
{
	const int currentIndex = getIndexOfColumnId (columnId, false);
	newIndex = visibleIndexToTotalIndex (newIndex);

	if (columns [currentIndex] != 0 && currentIndex != newIndex)
	{
		columns.move (currentIndex, newIndex);
		sendColumnsChanged();
	}
}

int TableHeaderComponent::getColumnWidth (const int columnId) const
{
	const ColumnInfo* const ci = getInfoForId (columnId);
	return ci != nullptr ? ci->width : 0;
}

void TableHeaderComponent::setColumnWidth (const int columnId, const int newWidth)
{
	ColumnInfo* const ci = getInfoForId (columnId);

	if (ci != nullptr && ci->width != newWidth)
	{
		const int numColumns = getNumColumns (true);

		ci->lastDeliberateWidth = ci->width
			= jlimit (ci->minimumWidth, ci->maximumWidth, newWidth);

		if (stretchToFit)
		{
			const int index = getIndexOfColumnId (columnId, true) + 1;

			if (isPositiveAndBelow (index, numColumns))
			{
				const int x = getColumnPosition (index).getX();

				if (lastDeliberateWidth == 0)
					lastDeliberateWidth = getTotalWidth();

				resizeColumnsToFit (visibleIndexToTotalIndex (index), lastDeliberateWidth - x);
			}
		}

		repaint();
		columnsResized = true;
		triggerAsyncUpdate();
	}
}

int TableHeaderComponent::getIndexOfColumnId (const int columnId, const bool onlyCountVisibleColumns) const
{
	int n = 0;

	for (int i = 0; i < columns.size(); ++i)
	{
		if ((! onlyCountVisibleColumns) || columns.getUnchecked(i)->isVisible())
		{
			if (columns.getUnchecked(i)->id == columnId)
				return n;

			++n;
		}
	}

	return -1;
}

int TableHeaderComponent::getColumnIdOfIndex (int index, const bool onlyCountVisibleColumns) const
{
	if (onlyCountVisibleColumns)
		index = visibleIndexToTotalIndex (index);

	const ColumnInfo* const ci = columns [index];
	return (ci != nullptr) ? ci->id : 0;
}

Rectangle<int> TableHeaderComponent::getColumnPosition (const int index) const
{
	int x = 0, width = 0, n = 0;

	for (int i = 0; i < columns.size(); ++i)
	{
		x += width;

		if (columns.getUnchecked(i)->isVisible())
		{
			width = columns.getUnchecked(i)->width;

			if (n++ == index)
				break;
		}
		else
		{
			width = 0;
		}
	}

	return Rectangle<int> (x, 0, width, getHeight());
}

int TableHeaderComponent::getColumnIdAtX (const int xToFind) const
{
	if (xToFind >= 0)
	{
		int x = 0;

		for (int i = 0; i < columns.size(); ++i)
		{
			const ColumnInfo* const ci = columns.getUnchecked(i);

			if (ci->isVisible())
			{
				x += ci->width;

				if (xToFind < x)
					return ci->id;
			}
		}
	}

	return 0;
}

int TableHeaderComponent::getTotalWidth() const
{
	int w = 0;

	for (int i = columns.size(); --i >= 0;)
		if (columns.getUnchecked(i)->isVisible())
			w += columns.getUnchecked(i)->width;

	return w;
}

void TableHeaderComponent::setStretchToFitActive (const bool shouldStretchToFit)
{
	stretchToFit = shouldStretchToFit;
	lastDeliberateWidth = getTotalWidth();
	resized();
}

bool TableHeaderComponent::isStretchToFitActive() const
{
	return stretchToFit;
}

void TableHeaderComponent::resizeAllColumnsToFit (int targetTotalWidth)
{
	if (stretchToFit && getWidth() > 0
		 && columnIdBeingResized == 0 && columnIdBeingDragged == 0)
	{
		lastDeliberateWidth = targetTotalWidth;
		resizeColumnsToFit (0, targetTotalWidth);
	}
}

void TableHeaderComponent::resizeColumnsToFit (int firstColumnIndex, int targetTotalWidth)
{
	targetTotalWidth = jmax (targetTotalWidth, 0);

	StretchableObjectResizer sor;
	int i;
	for (i = firstColumnIndex; i < columns.size(); ++i)
	{
		ColumnInfo* const ci = columns.getUnchecked(i);

		if (ci->isVisible())
			sor.addItem (ci->lastDeliberateWidth, ci->minimumWidth, ci->maximumWidth);
	}

	sor.resizeToFit (targetTotalWidth);

	int visIndex = 0;
	for (i = firstColumnIndex; i < columns.size(); ++i)
	{
		ColumnInfo* const ci = columns.getUnchecked(i);

		if (ci->isVisible())
		{
			const int newWidth = jlimit (ci->minimumWidth, ci->maximumWidth,
										 (int) std::floor (sor.getItemSize (visIndex++)));

			if (newWidth != ci->width)
			{
				ci->width = newWidth;
				repaint();
				columnsResized = true;
				triggerAsyncUpdate();
			}
		}
	}
}

void TableHeaderComponent::setColumnVisible (const int columnId, const bool shouldBeVisible)
{
	ColumnInfo* const ci = getInfoForId (columnId);

	if (ci != nullptr && shouldBeVisible != ci->isVisible())
	{
		if (shouldBeVisible)
			ci->propertyFlags |= visible;
		else
			ci->propertyFlags &= ~visible;

		sendColumnsChanged();
		resized();
	}
}

bool TableHeaderComponent::isColumnVisible (const int columnId) const
{
	const ColumnInfo* const ci = getInfoForId (columnId);
	return ci != nullptr && ci->isVisible();
}

void TableHeaderComponent::setSortColumnId (const int columnId, const bool sortForwards)
{
	if (getSortColumnId() != columnId || isSortedForwards() != sortForwards)
	{
		for (int i = columns.size(); --i >= 0;)
			columns.getUnchecked(i)->propertyFlags &= ~(sortedForwards | sortedBackwards);

		ColumnInfo* const ci = getInfoForId (columnId);

		if (ci != nullptr)
			ci->propertyFlags |= (sortForwards ? sortedForwards : sortedBackwards);

		reSortTable();
	}
}

int TableHeaderComponent::getSortColumnId() const
{
	for (int i = columns.size(); --i >= 0;)
		if ((columns.getUnchecked(i)->propertyFlags & (sortedForwards | sortedBackwards)) != 0)
			return columns.getUnchecked(i)->id;

	return 0;
}

bool TableHeaderComponent::isSortedForwards() const
{
	for (int i = columns.size(); --i >= 0;)
		if ((columns.getUnchecked(i)->propertyFlags & (sortedForwards | sortedBackwards)) != 0)
			return (columns.getUnchecked(i)->propertyFlags & sortedForwards) != 0;

	return true;
}

void TableHeaderComponent::reSortTable()
{
	sortChanged = true;
	repaint();
	triggerAsyncUpdate();
}

String TableHeaderComponent::toString() const
{
	String s;

	XmlElement doc ("TABLELAYOUT");

	doc.setAttribute ("sortedCol", getSortColumnId());
	doc.setAttribute ("sortForwards", isSortedForwards());

	for (int i = 0; i < columns.size(); ++i)
	{
		const ColumnInfo* const ci = columns.getUnchecked (i);

		XmlElement* const e = doc.createNewChildElement ("COLUMN");
		e->setAttribute ("id", ci->id);
		e->setAttribute ("visible", ci->isVisible());
		e->setAttribute ("width", ci->width);
	}

	return doc.createDocument (String::empty, true, false);
}

void TableHeaderComponent::restoreFromString (const String& storedVersion)
{
	ScopedPointer <XmlElement> storedXml (XmlDocument::parse (storedVersion));
	int index = 0;

	if (storedXml != nullptr && storedXml->hasTagName ("TABLELAYOUT"))
	{
		forEachXmlChildElement (*storedXml, col)
		{
			const int tabId = col->getIntAttribute ("id");

			ColumnInfo* const ci = getInfoForId (tabId);

			if (ci != nullptr)
			{
				columns.move (columns.indexOf (ci), index);
				ci->width = col->getIntAttribute ("width");
				setColumnVisible (tabId, col->getBoolAttribute ("visible"));
			}

			++index;
		}

		columnsResized = true;
		sendColumnsChanged();

		setSortColumnId (storedXml->getIntAttribute ("sortedCol"),
						 storedXml->getBoolAttribute ("sortForwards", true));
	}
}

void TableHeaderComponent::addListener (Listener* const newListener)
{
	listeners.addIfNotAlreadyThere (newListener);
}

void TableHeaderComponent::removeListener (Listener* const listenerToRemove)
{
	listeners.removeValue (listenerToRemove);
}

void TableHeaderComponent::columnClicked (int columnId, const ModifierKeys& mods)
{
	const ColumnInfo* const ci = getInfoForId (columnId);

	if (ci != nullptr && (ci->propertyFlags & sortable) != 0 && ! mods.isPopupMenu())
		setSortColumnId (columnId, (ci->propertyFlags & sortedForwards) == 0);
}

void TableHeaderComponent::addMenuItems (PopupMenu& menu, const int /*columnIdClicked*/)
{
	for (int i = 0; i < columns.size(); ++i)
	{
		const ColumnInfo* const ci = columns.getUnchecked(i);

		if ((ci->propertyFlags & appearsOnColumnMenu) != 0)
			menu.addItem (ci->id, ci->name,
						  (ci->propertyFlags & (sortedForwards | sortedBackwards)) == 0,
						  isColumnVisible (ci->id));
	}
}

void TableHeaderComponent::reactToMenuItem (const int menuReturnId, const int /*columnIdClicked*/)
{
	if (getIndexOfColumnId (menuReturnId, false) >= 0)
		setColumnVisible (menuReturnId, ! isColumnVisible (menuReturnId));
}

void TableHeaderComponent::paint (Graphics& g)
{
	LookAndFeel& lf = getLookAndFeel();

	lf.drawTableHeaderBackground (g, *this);

	const Rectangle<int> clip (g.getClipBounds());

	int x = 0;
	for (int i = 0; i < columns.size(); ++i)
	{
		const ColumnInfo* const ci = columns.getUnchecked(i);

		if (ci->isVisible())
		{
			if (x + ci->width > clip.getX()
				 && (ci->id != columnIdBeingDragged
					  || dragOverlayComp == nullptr
					  || ! dragOverlayComp->isVisible()))
			{
				Graphics::ScopedSaveState ss (g);

				g.setOrigin (x, 0);
				g.reduceClipRegion (0, 0, ci->width, getHeight());

				lf.drawTableHeaderColumn (g, ci->name, ci->id, ci->width, getHeight(),
										  ci->id == columnIdUnderMouse,
										  ci->id == columnIdUnderMouse && isMouseButtonDown(),
										  ci->propertyFlags);
			}

			x += ci->width;

			if (x >= clip.getRight())
				break;
		}
	}
}

void TableHeaderComponent::resized()
{
}

void TableHeaderComponent::mouseMove (const MouseEvent& e)
{
	updateColumnUnderMouse (e);
}

void TableHeaderComponent::mouseEnter (const MouseEvent& e)
{
	updateColumnUnderMouse (e);
}

void TableHeaderComponent::mouseExit (const MouseEvent&)
{
	setColumnUnderMouse (0);
}

void TableHeaderComponent::mouseDown (const MouseEvent& e)
{
	repaint();
	columnIdBeingResized = 0;
	columnIdBeingDragged = 0;

	if (columnIdUnderMouse != 0)
	{
		draggingColumnOffset = e.x - getColumnPosition (getIndexOfColumnId (columnIdUnderMouse, true)).getX();

		if (e.mods.isPopupMenu())
			columnClicked (columnIdUnderMouse, e.mods);
	}

	if (menuActive && e.mods.isPopupMenu())
		showColumnChooserMenu (columnIdUnderMouse);
}

void TableHeaderComponent::mouseDrag (const MouseEvent& e)
{
	if (columnIdBeingResized == 0
		 && columnIdBeingDragged == 0
		 && ! (e.mouseWasClicked() || e.mods.isPopupMenu()))
	{
		dragOverlayComp = nullptr;

		columnIdBeingResized = getResizeDraggerAt (e.getMouseDownX());

		if (columnIdBeingResized != 0)
		{
			const ColumnInfo* const ci = getInfoForId (columnIdBeingResized);
			initialColumnWidth = ci->width;
		}
		else
		{
			beginDrag (e);
		}
	}

	if (columnIdBeingResized != 0)
	{
		const ColumnInfo* const ci = getInfoForId (columnIdBeingResized);

		if (ci != nullptr)
		{
			int w = jlimit (ci->minimumWidth, ci->maximumWidth,
							initialColumnWidth + e.getDistanceFromDragStartX());

			if (stretchToFit)
			{
				// prevent us dragging a column too far right if we're in stretch-to-fit mode
				int minWidthOnRight = 0;
				for (int i = getIndexOfColumnId (columnIdBeingResized, false) + 1; i < columns.size(); ++i)
					if (columns.getUnchecked (i)->isVisible())
						minWidthOnRight += columns.getUnchecked (i)->minimumWidth;

				const Rectangle<int> currentPos (getColumnPosition (getIndexOfColumnId (columnIdBeingResized, true)));
				w = jmax (ci->minimumWidth, jmin (w, getWidth() - minWidthOnRight - currentPos.getX()));
			}

			setColumnWidth (columnIdBeingResized, w);
		}
	}
	else if (columnIdBeingDragged != 0)
	{
		if (e.y >= -50 && e.y < getHeight() + 50)
		{
			if (dragOverlayComp != nullptr)
			{
				dragOverlayComp->setVisible (true);
				dragOverlayComp->setBounds (jlimit (0,
													jmax (0, getTotalWidth() - dragOverlayComp->getWidth()),
													e.x - draggingColumnOffset),
											0,
											dragOverlayComp->getWidth(),
											getHeight());

				for (int i = columns.size(); --i >= 0;)
				{
					const int currentIndex = getIndexOfColumnId (columnIdBeingDragged, true);
					int newIndex = currentIndex;

					if (newIndex > 0)
					{
						// if the previous column isn't draggable, we can't move our column
						// past it, because that'd change the undraggable column's position..
						const ColumnInfo* const previous = columns.getUnchecked (newIndex - 1);

						if ((previous->propertyFlags & draggable) != 0)
						{
							const int leftOfPrevious = getColumnPosition (newIndex - 1).getX();
							const int rightOfCurrent = getColumnPosition (newIndex).getRight();

							if (abs (dragOverlayComp->getX() - leftOfPrevious)
								< abs (dragOverlayComp->getRight() - rightOfCurrent))
							{
								--newIndex;
							}
						}
					}

					if (newIndex < columns.size() - 1)
					{
						// if the next column isn't draggable, we can't move our column
						// past it, because that'd change the undraggable column's position..
						const ColumnInfo* const nextCol = columns.getUnchecked (newIndex + 1);

						if ((nextCol->propertyFlags & draggable) != 0)
						{
							const int leftOfCurrent = getColumnPosition (newIndex).getX();
							const int rightOfNext = getColumnPosition (newIndex + 1).getRight();

							if (abs (dragOverlayComp->getX() - leftOfCurrent)
								> abs (dragOverlayComp->getRight() - rightOfNext))
							{
								++newIndex;
							}
						}
					}

					if (newIndex != currentIndex)
						moveColumn (columnIdBeingDragged, newIndex);
					else
						break;
				}
			}
		}
		else
		{
			endDrag (draggingColumnOriginalIndex);
		}
	}
}

void TableHeaderComponent::beginDrag (const MouseEvent& e)
{
	if (columnIdBeingDragged == 0)
	{
		columnIdBeingDragged = getColumnIdAtX (e.getMouseDownX());

		const ColumnInfo* const ci = getInfoForId (columnIdBeingDragged);

		if (ci == nullptr || (ci->propertyFlags & draggable) == 0)
		{
			columnIdBeingDragged = 0;
		}
		else
		{
			draggingColumnOriginalIndex = getIndexOfColumnId (columnIdBeingDragged, true);

			const Rectangle<int> columnRect (getColumnPosition (draggingColumnOriginalIndex));

			const int temp = columnIdBeingDragged;
			columnIdBeingDragged = 0;

			addAndMakeVisible (dragOverlayComp = new DragOverlayComp (createComponentSnapshot (columnRect, false)));
			columnIdBeingDragged = temp;

			dragOverlayComp->setBounds (columnRect);

			for (int i = listeners.size(); --i >= 0;)
			{
				listeners.getUnchecked(i)->tableColumnDraggingChanged (this, columnIdBeingDragged);
				i = jmin (i, listeners.size() - 1);
			}
		}
	}
}

void TableHeaderComponent::endDrag (const int finalIndex)
{
	if (columnIdBeingDragged != 0)
	{
		moveColumn (columnIdBeingDragged, finalIndex);

		columnIdBeingDragged = 0;
		repaint();

		for (int i = listeners.size(); --i >= 0;)
		{
			listeners.getUnchecked(i)->tableColumnDraggingChanged (this, 0);
			i = jmin (i, listeners.size() - 1);
		}
	}
}

void TableHeaderComponent::mouseUp (const MouseEvent& e)
{
	mouseDrag (e);

	for (int i = columns.size(); --i >= 0;)
		if (columns.getUnchecked (i)->isVisible())
			columns.getUnchecked (i)->lastDeliberateWidth = columns.getUnchecked (i)->width;

	columnIdBeingResized = 0;
	repaint();

	endDrag (getIndexOfColumnId (columnIdBeingDragged, true));

	updateColumnUnderMouse (e);

	if (columnIdUnderMouse != 0 && e.mouseWasClicked() && ! e.mods.isPopupMenu())
		columnClicked (columnIdUnderMouse, e.mods);

	dragOverlayComp = nullptr;
}

MouseCursor TableHeaderComponent::getMouseCursor()
{
	if (columnIdBeingResized != 0 || (getResizeDraggerAt (getMouseXYRelative().getX()) != 0 && ! isMouseButtonDown()))
		return MouseCursor (MouseCursor::LeftRightResizeCursor);

	return Component::getMouseCursor();
}

bool TableHeaderComponent::ColumnInfo::isVisible() const
{
	return (propertyFlags & TableHeaderComponent::visible) != 0;
}

TableHeaderComponent::ColumnInfo* TableHeaderComponent::getInfoForId (const int id) const
{
	for (int i = columns.size(); --i >= 0;)
		if (columns.getUnchecked(i)->id == id)
			return columns.getUnchecked(i);

	return nullptr;
}

int TableHeaderComponent::visibleIndexToTotalIndex (const int visibleIndex) const
{
	int n = 0;

	for (int i = 0; i < columns.size(); ++i)
	{
		if (columns.getUnchecked(i)->isVisible())
		{
			if (n == visibleIndex)
				return i;

			++n;
		}
	}

	return -1;
}

void TableHeaderComponent::sendColumnsChanged()
{
	if (stretchToFit && lastDeliberateWidth > 0)
		resizeAllColumnsToFit (lastDeliberateWidth);

	repaint();
	columnsChanged = true;
	triggerAsyncUpdate();
}

void TableHeaderComponent::handleAsyncUpdate()
{
	const bool changed = columnsChanged || sortChanged;
	const bool sized = columnsResized || changed;
	const bool sorted = sortChanged;
	columnsChanged = false;
	columnsResized = false;
	sortChanged = false;

	if (sorted)
	{
		for (int i = listeners.size(); --i >= 0;)
		{
			listeners.getUnchecked(i)->tableSortOrderChanged (this);
			i = jmin (i, listeners.size() - 1);
		}
	}

	if (changed)
	{
		for (int i = listeners.size(); --i >= 0;)
		{
			listeners.getUnchecked(i)->tableColumnsChanged (this);
			i = jmin (i, listeners.size() - 1);
		}
	}

	if (sized)
	{
		for (int i = listeners.size(); --i >= 0;)
		{
			listeners.getUnchecked(i)->tableColumnsResized (this);
			i = jmin (i, listeners.size() - 1);
		}
	}
}

int TableHeaderComponent::getResizeDraggerAt (const int mouseX) const
{
	if (isPositiveAndBelow (mouseX, getWidth()))
	{
		const int draggableDistance = 3;
		int x = 0;

		for (int i = 0; i < columns.size(); ++i)
		{
			const ColumnInfo* const ci = columns.getUnchecked(i);

			if (ci->isVisible())
			{
				if (abs (mouseX - (x + ci->width)) <= draggableDistance
					 && (ci->propertyFlags & resizable) != 0)
					return ci->id;

				x += ci->width;
			}
		}
	}

	return 0;
}

void TableHeaderComponent::setColumnUnderMouse (const int newCol)
{
	if (newCol != columnIdUnderMouse)
	{
		columnIdUnderMouse = newCol;
		repaint();
	}
}

void TableHeaderComponent::updateColumnUnderMouse (const MouseEvent& e)
{
	setColumnUnderMouse (reallyContains (e.getPosition(), true) && getResizeDraggerAt (e.x) == 0
							? getColumnIdAtX (e.x) : 0);
}

static void tableHeaderMenuCallback (int result, TableHeaderComponent* tableHeader, int columnIdClicked)
{
	if (tableHeader != nullptr && result != 0)
		tableHeader->reactToMenuItem (result, columnIdClicked);
}

void TableHeaderComponent::showColumnChooserMenu (const int columnIdClicked)
{
	PopupMenu m;
	addMenuItems (m, columnIdClicked);

	if (m.getNumItems() > 0)
	{
		m.setLookAndFeel (&getLookAndFeel());

		m.showMenuAsync (PopupMenu::Options(),
						 ModalCallbackFunction::forComponent (tableHeaderMenuCallback, this, columnIdClicked));
	}
}

void TableHeaderComponent::Listener::tableColumnDraggingChanged (TableHeaderComponent*, int)
{
}

/*** End of inlined file: juce_TableHeaderComponent.cpp ***/


/*** Start of inlined file: juce_TableListBox.cpp ***/
class TableListRowComp   : public Component,
						   public TooltipClient
{
public:
	TableListRowComp (TableListBox& owner_)
		: owner (owner_), row (-1), isSelected (false)
	{
	}

	void paint (Graphics& g)
	{
		TableListBoxModel* const model = owner.getModel();

		if (model != nullptr)
		{
			model->paintRowBackground (g, row, getWidth(), getHeight(), isSelected);

			const TableHeaderComponent& header = owner.getHeader();
			const int numColumns = header.getNumColumns (true);

			for (int i = 0; i < numColumns; ++i)
			{
				if (columnComponents[i] == nullptr)
				{
					const int columnId = header.getColumnIdOfIndex (i, true);
					const Rectangle<int> columnRect (header.getColumnPosition(i).withHeight (getHeight()));

					Graphics::ScopedSaveState ss (g);

					g.reduceClipRegion (columnRect);
					g.setOrigin (columnRect.getX(), 0);
					model->paintCell (g, row, columnId, columnRect.getWidth(), columnRect.getHeight(), isSelected);
				}
			}
		}
	}

	void update (const int newRow, const bool isNowSelected)
	{
		jassert (newRow >= 0);

		if (newRow != row || isNowSelected != isSelected)
		{
			row = newRow;
			isSelected = isNowSelected;
			repaint();
		}

		TableListBoxModel* const model = owner.getModel();

		if (model != nullptr && row < owner.getNumRows())
		{
			const Identifier columnProperty ("_tableColumnId");
			const int numColumns = owner.getHeader().getNumColumns (true);

			for (int i = 0; i < numColumns; ++i)
			{
				const int columnId = owner.getHeader().getColumnIdOfIndex (i, true);
				Component* comp = columnComponents[i];

				if (comp != nullptr && columnId != (int) comp->getProperties() [columnProperty])
				{
					columnComponents.set (i, nullptr);
					comp = nullptr;
				}

				comp = model->refreshComponentForCell (row, columnId, isSelected, comp);
				columnComponents.set (i, comp, false);

				if (comp != nullptr)
				{
					comp->getProperties().set (columnProperty, columnId);

					addAndMakeVisible (comp);
					resizeCustomComp (i);
				}
			}

			columnComponents.removeRange (numColumns, columnComponents.size());
		}
		else
		{
			columnComponents.clear();
		}
	}

	void resized()
	{
		for (int i = columnComponents.size(); --i >= 0;)
			resizeCustomComp (i);
	}

	void resizeCustomComp (const int index)
	{
		Component* const c = columnComponents.getUnchecked (index);

		if (c != nullptr)
			c->setBounds (owner.getHeader().getColumnPosition (index)
							.withY (0).withHeight (getHeight()));
	}

	void mouseDown (const MouseEvent& e)
	{
		isDragging = false;
		selectRowOnMouseUp = false;

		if (isEnabled())
		{
			if (! isSelected)
			{
				owner.selectRowsBasedOnModifierKeys (row, e.mods, false);

				const int columnId = owner.getHeader().getColumnIdAtX (e.x);

				if (columnId != 0 && owner.getModel() != nullptr)
					owner.getModel()->cellClicked (row, columnId, e);
			}
			else
			{
				selectRowOnMouseUp = true;
			}
		}
	}

	void mouseDrag (const MouseEvent& e)
	{
		if (isEnabled() && owner.getModel() != nullptr && ! (e.mouseWasClicked() || isDragging))
		{
			const SparseSet<int> selectedRows (owner.getSelectedRows());

			if (selectedRows.size() > 0)
			{
				const var dragDescription (owner.getModel()->getDragSourceDescription (selectedRows));

				if (! (dragDescription.isVoid() || (dragDescription.isString() && dragDescription.toString().isEmpty())))
				{
					isDragging = true;
					owner.startDragAndDrop (e, dragDescription, true);
				}
			}
		}
	}

	void mouseUp (const MouseEvent& e)
	{
		if (selectRowOnMouseUp && e.mouseWasClicked() && isEnabled())
		{
			owner.selectRowsBasedOnModifierKeys (row, e.mods, true);

			const int columnId = owner.getHeader().getColumnIdAtX (e.x);

			if (columnId != 0 && owner.getModel() != nullptr)
				owner.getModel()->cellClicked (row, columnId, e);
		}
	}

	void mouseDoubleClick (const MouseEvent& e)
	{
		const int columnId = owner.getHeader().getColumnIdAtX (e.x);

		if (columnId != 0 && owner.getModel() != nullptr)
			owner.getModel()->cellDoubleClicked (row, columnId, e);
	}

	String getTooltip()
	{
		const int columnId = owner.getHeader().getColumnIdAtX (getMouseXYRelative().getX());

		if (columnId != 0 && owner.getModel() != nullptr)
			return owner.getModel()->getCellTooltip (row, columnId);

		return String::empty;
	}

	Component* findChildComponentForColumn (const int columnId) const
	{
		return columnComponents [owner.getHeader().getIndexOfColumnId (columnId, true)];
	}

private:
	TableListBox& owner;
	OwnedArray<Component> columnComponents;
	int row;
	bool isSelected, isDragging, selectRowOnMouseUp;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (TableListRowComp);
};

class TableListBoxHeader  : public TableHeaderComponent
{
public:
	TableListBoxHeader (TableListBox& owner_)
		: owner (owner_)
	{
	}

	void addMenuItems (PopupMenu& menu, int columnIdClicked)
	{
		if (owner.isAutoSizeMenuOptionShown())
		{
			menu.addItem (autoSizeColumnId, TRANS("Auto-size this column"), columnIdClicked != 0);
			menu.addItem (autoSizeAllId, TRANS("Auto-size all columns"), owner.getHeader().getNumColumns (true) > 0);
			menu.addSeparator();
		}

		TableHeaderComponent::addMenuItems (menu, columnIdClicked);
	}

	void reactToMenuItem (int menuReturnId, int columnIdClicked)
	{
		switch (menuReturnId)
		{
			case autoSizeColumnId:      owner.autoSizeColumn (columnIdClicked); break;
			case autoSizeAllId:         owner.autoSizeAllColumns(); break;
			default:                    TableHeaderComponent::reactToMenuItem (menuReturnId, columnIdClicked); break;
		}
	}

private:
	TableListBox& owner;

	enum { autoSizeColumnId = 0xf836743, autoSizeAllId = 0xf836744 };

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (TableListBoxHeader);
};

TableListBox::TableListBox (const String& name, TableListBoxModel* const model_)
	: ListBox (name, nullptr),
	  header (nullptr),
	  model (model_),
	  autoSizeOptionsShown (true)
{
	ListBox::model = this;

	setHeader (new TableListBoxHeader (*this));
}

TableListBox::~TableListBox()
{
}

void TableListBox::setModel (TableListBoxModel* const newModel)
{
	if (model != newModel)
	{
		model = newModel;
		updateContent();
	}
}

void TableListBox::setHeader (TableHeaderComponent* newHeader)
{
	jassert (newHeader != nullptr); // you need to supply a real header for a table!

	Rectangle<int> newBounds (0, 0, 100, 28);
	if (header != nullptr)
		newBounds = header->getBounds();

	header = newHeader;
	header->setBounds (newBounds);

	setHeaderComponent (header);

	header->addListener (this);
}

int TableListBox::getHeaderHeight() const
{
	return header->getHeight();
}

void TableListBox::setHeaderHeight (const int newHeight)
{
	header->setSize (header->getWidth(), newHeight);
	resized();
}

void TableListBox::autoSizeColumn (const int columnId)
{
	const int width = model != nullptr ? model->getColumnAutoSizeWidth (columnId) : 0;

	if (width > 0)
		header->setColumnWidth (columnId, width);
}

void TableListBox::autoSizeAllColumns()
{
	for (int i = 0; i < header->getNumColumns (true); ++i)
		autoSizeColumn (header->getColumnIdOfIndex (i, true));
}

void TableListBox::setAutoSizeMenuOptionShown (const bool shouldBeShown)
{
	autoSizeOptionsShown = shouldBeShown;
}

bool TableListBox::isAutoSizeMenuOptionShown() const
{
	return autoSizeOptionsShown;
}

Rectangle<int> TableListBox::getCellPosition (const int columnId, const int rowNumber,
											  const bool relativeToComponentTopLeft) const
{
	Rectangle<int> headerCell (header->getColumnPosition (header->getIndexOfColumnId (columnId, true)));

	if (relativeToComponentTopLeft)
		headerCell.translate (header->getX(), 0);

	return getRowPosition (rowNumber, relativeToComponentTopLeft)
			.withX (headerCell.getX())
			.withWidth (headerCell.getWidth());
}

Component* TableListBox::getCellComponent (int columnId, int rowNumber) const
{
	TableListRowComp* const rowComp = dynamic_cast <TableListRowComp*> (getComponentForRowNumber (rowNumber));
	return rowComp != nullptr ? rowComp->findChildComponentForColumn (columnId) : 0;
}

void TableListBox::scrollToEnsureColumnIsOnscreen (const int columnId)
{
	ScrollBar* const scrollbar = getHorizontalScrollBar();

	if (scrollbar != nullptr)
	{
		const Rectangle<int> pos (header->getColumnPosition (header->getIndexOfColumnId (columnId, true)));

		double x = scrollbar->getCurrentRangeStart();
		const double w = scrollbar->getCurrentRangeSize();

		if (pos.getX() < x)
			x = pos.getX();
		else if (pos.getRight() > x + w)
			x += jmax (0.0, pos.getRight() - (x + w));

		scrollbar->setCurrentRangeStart (x);
	}
}

int TableListBox::getNumRows()
{
	return model != nullptr ? model->getNumRows() : 0;
}

void TableListBox::paintListBoxItem (int, Graphics&, int, int, bool)
{
}

Component* TableListBox::refreshComponentForRow (int rowNumber, bool isRowSelected_, Component* existingComponentToUpdate)
{
	if (existingComponentToUpdate == nullptr)
		existingComponentToUpdate = new TableListRowComp (*this);

	static_cast <TableListRowComp*> (existingComponentToUpdate)->update (rowNumber, isRowSelected_);

	return existingComponentToUpdate;
}

void TableListBox::selectedRowsChanged (int row)
{
	if (model != nullptr)
		model->selectedRowsChanged (row);
}

void TableListBox::deleteKeyPressed (int row)
{
	if (model != nullptr)
		model->deleteKeyPressed (row);
}

void TableListBox::returnKeyPressed (int row)
{
	if (model != nullptr)
		model->returnKeyPressed (row);
}

void TableListBox::backgroundClicked()
{
	if (model != nullptr)
		model->backgroundClicked();
}

void TableListBox::listWasScrolled()
{
	if (model != nullptr)
		model->listWasScrolled();
}

void TableListBox::tableColumnsChanged (TableHeaderComponent*)
{
	setMinimumContentWidth (header->getTotalWidth());
	repaint();
	updateColumnComponents();
}

void TableListBox::tableColumnsResized (TableHeaderComponent*)
{
	setMinimumContentWidth (header->getTotalWidth());
	repaint();
	updateColumnComponents();
}

void TableListBox::tableSortOrderChanged (TableHeaderComponent*)
{
	if (model != nullptr)
		model->sortOrderChanged (header->getSortColumnId(),
								 header->isSortedForwards());
}

void TableListBox::tableColumnDraggingChanged (TableHeaderComponent*, int columnIdNowBeingDragged_)
{
	columnIdNowBeingDragged = columnIdNowBeingDragged_;
	repaint();
}

void TableListBox::resized()
{
	ListBox::resized();

	header->resizeAllColumnsToFit (getVisibleContentWidth());
	setMinimumContentWidth (header->getTotalWidth());
}

void TableListBox::updateColumnComponents() const
{
	const int firstRow = getRowContainingPosition (0, 0);

	for (int i = firstRow + getNumRowsOnScreen() + 2; --i >= firstRow;)
	{
		TableListRowComp* const rowComp = dynamic_cast <TableListRowComp*> (getComponentForRowNumber (i));

		if (rowComp != nullptr)
			rowComp->resized();
	}
}

void TableListBoxModel::cellClicked (int, int, const MouseEvent&)       {}
void TableListBoxModel::cellDoubleClicked (int, int, const MouseEvent&) {}
void TableListBoxModel::backgroundClicked()                             {}
void TableListBoxModel::sortOrderChanged (int, const bool)              {}
int TableListBoxModel::getColumnAutoSizeWidth (int)                     { return 0; }
void TableListBoxModel::selectedRowsChanged (int)                       {}
void TableListBoxModel::deleteKeyPressed (int)                          {}
void TableListBoxModel::returnKeyPressed (int)                          {}
void TableListBoxModel::listWasScrolled()                               {}

String TableListBoxModel::getCellTooltip (int /*rowNumber*/, int /*columnId*/)    { return String::empty; }
var TableListBoxModel::getDragSourceDescription (const SparseSet<int>&)           { return var::null; }

Component* TableListBoxModel::refreshComponentForCell (int, int, bool, Component* existingComponentToUpdate)
{
	(void) existingComponentToUpdate;
	jassert (existingComponentToUpdate == nullptr); // indicates a failure in the code the recycles the components
	return nullptr;
}

/*** End of inlined file: juce_TableListBox.cpp ***/


/*** Start of inlined file: juce_TextEditor.cpp ***/
// a word or space that can't be broken down any further
struct TextAtom
{

	String atomText;
	float width;
	int numChars;

	bool isWhitespace() const       { return CharacterFunctions::isWhitespace (atomText[0]); }
	bool isNewLine() const          { return atomText[0] == '\r' || atomText[0] == '\n'; }

	String getText (const juce_wchar passwordCharacter) const
	{
		if (passwordCharacter == 0)
			return atomText;
		else
			return String::repeatedString (String::charToString (passwordCharacter),
										   atomText.length());
	}

	String getTrimmedText (const juce_wchar passwordCharacter) const
	{
		if (passwordCharacter == 0)
			return atomText.substring (0, numChars);
		else if (isNewLine())
			return String::empty;
		else
			return String::repeatedString (String::charToString (passwordCharacter), numChars);
	}
};

// a run of text with a single font and colour
class TextEditor::UniformTextSection
{
public:

	UniformTextSection (const String& text,
						const Font& font_,
						const Colour& colour_,
						const juce_wchar passwordCharacter)
	  : font (font_),
		colour (colour_)
	{
		initialiseAtoms (text, passwordCharacter);
	}

	UniformTextSection (const UniformTextSection& other)
	  : font (other.font),
		colour (other.colour)
	{
		atoms.ensureStorageAllocated (other.atoms.size());

		for (int i = 0; i < other.atoms.size(); ++i)
			atoms.add (new TextAtom (*other.atoms.getUnchecked(i)));
	}

	~UniformTextSection()
	{
		// (no need to delete the atoms, as they're explicitly deleted by the caller)
	}

	void clear()
	{
		for (int i = atoms.size(); --i >= 0;)
			delete getAtom(i);

		atoms.clear();
	}

	int getNumAtoms() const
	{
		return atoms.size();
	}

	TextAtom* getAtom (const int index) const noexcept
	{
		return atoms.getUnchecked (index);
	}

	void append (const UniformTextSection& other, const juce_wchar passwordCharacter)
	{
		if (other.atoms.size() > 0)
		{
			TextAtom* const lastAtom = atoms.getLast();
			int i = 0;

			if (lastAtom != nullptr)
			{
				if (! CharacterFunctions::isWhitespace (lastAtom->atomText.getLastCharacter()))
				{
					TextAtom* const first = other.getAtom(0);

					if (! CharacterFunctions::isWhitespace (first->atomText[0]))
					{
						lastAtom->atomText += first->atomText;
						lastAtom->numChars = (uint16) (lastAtom->numChars + first->numChars);
						lastAtom->width = font.getStringWidthFloat (lastAtom->getText (passwordCharacter));
						delete first;
						++i;
					}
				}
			}

			atoms.ensureStorageAllocated (atoms.size() + other.atoms.size() - i);

			while (i < other.atoms.size())
			{
				atoms.add (other.getAtom(i));
				++i;
			}
		}
	}

	UniformTextSection* split (const int indexToBreakAt,
							   const juce_wchar passwordCharacter)
	{
		UniformTextSection* const section2 = new UniformTextSection (String::empty,
																	 font, colour,
																	 passwordCharacter);
		int index = 0;

		for (int i = 0; i < atoms.size(); ++i)
		{
			TextAtom* const atom = getAtom(i);

			const int nextIndex = index + atom->numChars;

			if (index == indexToBreakAt)
			{
				int j;
				for (j = i; j < atoms.size(); ++j)
					section2->atoms.add (getAtom (j));

				for (j = atoms.size(); --j >= i;)
					atoms.remove (j);

				break;
			}
			else if (indexToBreakAt >= index && indexToBreakAt < nextIndex)
			{
				TextAtom* const secondAtom = new TextAtom();

				secondAtom->atomText = atom->atomText.substring (indexToBreakAt - index);
				secondAtom->width = font.getStringWidthFloat (secondAtom->getText (passwordCharacter));
				secondAtom->numChars = (uint16) secondAtom->atomText.length();

				section2->atoms.add (secondAtom);

				atom->atomText = atom->atomText.substring (0, indexToBreakAt - index);
				atom->width = font.getStringWidthFloat (atom->getText (passwordCharacter));
				atom->numChars = (uint16) (indexToBreakAt - index);

				int j;
				for (j = i + 1; j < atoms.size(); ++j)
					section2->atoms.add (getAtom (j));

				for (j = atoms.size(); --j > i;)
					atoms.remove (j);

				break;
			}

			index = nextIndex;
		}

		return section2;
	}

	void appendAllText (MemoryOutputStream& mo) const
	{
		for (int i = 0; i < atoms.size(); ++i)
			mo << getAtom(i)->atomText;
	}

	void appendSubstring (MemoryOutputStream& mo, const Range<int>& range) const
	{
		int index = 0;
		for (int i = 0; i < atoms.size(); ++i)
		{
			const TextAtom* const atom = getAtom (i);
			const int nextIndex = index + atom->numChars;

			if (range.getStart() < nextIndex)
			{
				if (range.getEnd() <= index)
					break;

				const Range<int> r ((range - index).getIntersectionWith (Range<int> (0, (int) atom->numChars)));

				if (! r.isEmpty())
					mo << atom->atomText.substring (r.getStart(), r.getEnd());
			}

			index = nextIndex;
		}
	}

	int getTotalLength() const
	{
		int total = 0;

		for (int i = atoms.size(); --i >= 0;)
			total += getAtom(i)->numChars;

		return total;
	}

	void setFont (const Font& newFont,
				  const juce_wchar passwordCharacter)
	{
		if (font != newFont)
		{
			font = newFont;

			for (int i = atoms.size(); --i >= 0;)
			{
				TextAtom* const atom = atoms.getUnchecked(i);
				atom->width = newFont.getStringWidthFloat (atom->getText (passwordCharacter));
			}
		}
	}

	Font font;
	Colour colour;

private:
	Array <TextAtom*> atoms;

	void initialiseAtoms (const String& textToParse,
						  const juce_wchar passwordCharacter)
	{
		String::CharPointerType text (textToParse.getCharPointer());

		while (! text.isEmpty())
		{
			size_t numChars = 0;
			String::CharPointerType start (text);

			// create a whitespace atom unless it starts with non-ws
			if (text.isWhitespace() && *text != '\r' && *text != '\n')
			{
				do
				{
					++text;
					++numChars;
				}
				while (text.isWhitespace() && *text != '\r' && *text != '\n');
			}
			else
			{
				if (*text == '\r')
				{
					++text;
					++numChars;

					if (*text == '\n')
					{
						++start;
						++text;
					}
				}
				else if (*text == '\n')
				{
					++text;
					++numChars;
				}
				else
				{
					while (! (text.isEmpty() || text.isWhitespace()))
					{
						++text;
						++numChars;
					}
				}
			}

			TextAtom* const atom = new TextAtom();
			atom->atomText = String (start, numChars);

			atom->width = font.getStringWidthFloat (atom->getText (passwordCharacter));
			atom->numChars = (uint16) numChars;

			atoms.add (atom);
		}
	}

	UniformTextSection& operator= (const UniformTextSection& other);
	JUCE_LEAK_DETECTOR (UniformTextSection);
};

class TextEditor::Iterator
{
public:

	Iterator (const Array <UniformTextSection*>& sections_,
			  const float wordWrapWidth_,
			  const juce_wchar passwordCharacter_)
	  : indexInText (0),
		lineY (0),
		lineHeight (0),
		maxDescent (0),
		atomX (0),
		atomRight (0),
		atom (0),
		currentSection (nullptr),
		sections (sections_),
		sectionIndex (0),
		atomIndex (0),
		wordWrapWidth (wordWrapWidth_),
		passwordCharacter (passwordCharacter_)
	{
		jassert (wordWrapWidth_ > 0);

		if (sections.size() > 0)
		{
			currentSection = sections.getUnchecked (sectionIndex);

			if (currentSection != nullptr)
				beginNewLine();
		}
	}

	Iterator (const Iterator& other)
	  : indexInText (other.indexInText),
		lineY (other.lineY),
		lineHeight (other.lineHeight),
		maxDescent (other.maxDescent),
		atomX (other.atomX),
		atomRight (other.atomRight),
		atom (other.atom),
		currentSection (other.currentSection),
		sections (other.sections),
		sectionIndex (other.sectionIndex),
		atomIndex (other.atomIndex),
		wordWrapWidth (other.wordWrapWidth),
		passwordCharacter (other.passwordCharacter),
		tempAtom (other.tempAtom)
	{
	}

	bool next()
	{
		if (atom == &tempAtom)
		{
			const int numRemaining = tempAtom.atomText.length() - tempAtom.numChars;

			if (numRemaining > 0)
			{
				tempAtom.atomText = tempAtom.atomText.substring (tempAtom.numChars);

				atomX = 0;

				if (tempAtom.numChars > 0)
					lineY += lineHeight;

				indexInText += tempAtom.numChars;

				GlyphArrangement g;
				g.addLineOfText (currentSection->font, atom->getText (passwordCharacter), 0.0f, 0.0f);

				int split;
				for (split = 0; split < g.getNumGlyphs(); ++split)
					if (shouldWrap (g.getGlyph (split).getRight()))
						break;

				if (split > 0 && split <= numRemaining)
				{
					tempAtom.numChars = (uint16) split;
					tempAtom.width = g.getGlyph (split - 1).getRight();
					atomRight = atomX + tempAtom.width;
					return true;
				}
			}
		}

		bool forceNewLine = false;

		if (sectionIndex >= sections.size())
		{
			moveToEndOfLastAtom();
			return false;
		}
		else if (atomIndex >= currentSection->getNumAtoms() - 1)
		{
			if (atomIndex >= currentSection->getNumAtoms())
			{
				if (++sectionIndex >= sections.size())
				{
					moveToEndOfLastAtom();
					return false;
				}

				atomIndex = 0;
				currentSection = sections.getUnchecked (sectionIndex);
			}
			else
			{
				const TextAtom* const lastAtom = currentSection->getAtom (atomIndex);

				if (! lastAtom->isWhitespace())
				{
					// handle the case where the last atom in a section is actually part of the same
					// word as the first atom of the next section...
					float right = atomRight + lastAtom->width;
					float lineHeight2 = lineHeight;
					float maxDescent2 = maxDescent;

					for (int section = sectionIndex + 1; section < sections.size(); ++section)
					{
						const UniformTextSection* const s = sections.getUnchecked (section);

						if (s->getNumAtoms() == 0)
							break;

						const TextAtom* const nextAtom = s->getAtom (0);

						if (nextAtom->isWhitespace())
							break;

						right += nextAtom->width;

						lineHeight2 = jmax (lineHeight2, s->font.getHeight());
						maxDescent2 = jmax (maxDescent2, s->font.getDescent());

						if (shouldWrap (right))
						{
							lineHeight = lineHeight2;
							maxDescent = maxDescent2;

							forceNewLine = true;
							break;
						}

						if (s->getNumAtoms() > 1)
							break;
					}
				}
			}
		}

		if (atom != nullptr)
		{
			atomX = atomRight;
			indexInText += atom->numChars;

			if (atom->isNewLine())
				beginNewLine();
		}

		atom = currentSection->getAtom (atomIndex);
		atomRight = atomX + atom->width;
		++atomIndex;

		if (shouldWrap (atomRight) || forceNewLine)
		{
			if (atom->isWhitespace())
			{
				// leave whitespace at the end of a line, but truncate it to avoid scrolling
				atomRight = jmin (atomRight, wordWrapWidth);
			}
			else
			{
				atomRight = atom->width;

				if (shouldWrap (atomRight))  // atom too big to fit on a line, so break it up..
				{
					tempAtom = *atom;
					tempAtom.width = 0;
					tempAtom.numChars = 0;
					atom = &tempAtom;

					if (atomX > 0)
						beginNewLine();

					return next();
				}

				beginNewLine();
				return true;
			}
		}

		return true;
	}

	void beginNewLine()
	{
		atomX = 0;
		lineY += lineHeight;

		int tempSectionIndex = sectionIndex;
		int tempAtomIndex = atomIndex;
		const UniformTextSection* section = sections.getUnchecked (tempSectionIndex);

		lineHeight = section->font.getHeight();
		maxDescent = section->font.getDescent();

		float x = (atom != nullptr) ? atom->width : 0;

		while (! shouldWrap (x))
		{
			if (tempSectionIndex >= sections.size())
				break;

			bool checkSize = false;

			if (tempAtomIndex >= section->getNumAtoms())
			{
				if (++tempSectionIndex >= sections.size())
					break;

				tempAtomIndex = 0;
				section = sections.getUnchecked (tempSectionIndex);
				checkSize = true;
			}

			const TextAtom* const nextAtom = section->getAtom (tempAtomIndex);

			if (nextAtom == nullptr)
				break;

			x += nextAtom->width;

			if (shouldWrap (x) || nextAtom->isNewLine())
				break;

			if (checkSize)
			{
				lineHeight = jmax (lineHeight, section->font.getHeight());
				maxDescent = jmax (maxDescent, section->font.getDescent());
			}

			++tempAtomIndex;
		}
	}

	void draw (Graphics& g, const UniformTextSection*& lastSection) const
	{
		if (passwordCharacter != 0 || ! atom->isWhitespace())
		{
			if (lastSection != currentSection)
			{
				lastSection = currentSection;
				g.setColour (currentSection->colour);
				g.setFont (currentSection->font);
			}

			jassert (atom->getTrimmedText (passwordCharacter).isNotEmpty());

			GlyphArrangement ga;
			ga.addLineOfText (currentSection->font,
							  atom->getTrimmedText (passwordCharacter),
							  atomX,
							  (float) roundToInt (lineY + lineHeight - maxDescent));
			ga.draw (g);
		}
	}

	void drawSelection (Graphics& g, const Range<int>& selection) const
	{
		const int startX = roundToInt (indexToX (selection.getStart()));
		const int endX   = roundToInt (indexToX (selection.getEnd()));

		const int y = roundToInt (lineY);
		const int nextY = roundToInt (lineY + lineHeight);

		g.fillRect (startX, y, endX - startX, nextY - y);
	}

	void drawUnderline (Graphics& g, const Range<int>& underline, const Colour& colour) const
	{
		const int startX    = roundToInt (indexToX (underline.getStart()));
		const int endX      = roundToInt (indexToX (underline.getEnd()));
		const int baselineY = roundToInt (lineY + currentSection->font.getAscent() + 0.5f);

		Graphics::ScopedSaveState state (g);
		g.reduceClipRegion (Rectangle<int> (startX, baselineY, endX - startX, 1));
		g.fillCheckerBoard (Rectangle<int> (endX, baselineY + 1), 3, 1, colour, Colours::transparentBlack);
	}

	void drawSelectedText (Graphics& g,
						   const Range<int>& selection,
						   const Colour& selectedTextColour) const
	{
		if (passwordCharacter != 0 || ! atom->isWhitespace())
		{
			GlyphArrangement ga;
			ga.addLineOfText (currentSection->font,
							  atom->getTrimmedText (passwordCharacter),
							  atomX,
							  (float) roundToInt (lineY + lineHeight - maxDescent));

			if (selection.getEnd() < indexInText + atom->numChars)
			{
				GlyphArrangement ga2 (ga);
				ga2.removeRangeOfGlyphs (0, selection.getEnd() - indexInText);
				ga.removeRangeOfGlyphs (selection.getEnd() - indexInText, -1);

				g.setColour (currentSection->colour);
				ga2.draw (g);
			}

			if (selection.getStart() > indexInText)
			{
				GlyphArrangement ga2 (ga);
				ga2.removeRangeOfGlyphs (selection.getStart() - indexInText, -1);
				ga.removeRangeOfGlyphs (0, selection.getStart() - indexInText);

				g.setColour (currentSection->colour);
				ga2.draw (g);
			}

			g.setColour (selectedTextColour);
			ga.draw (g);
		}
	}

	float indexToX (const int indexToFind) const
	{
		if (indexToFind <= indexInText)
			return atomX;

		if (indexToFind >= indexInText + atom->numChars)
			return atomRight;

		GlyphArrangement g;
		g.addLineOfText (currentSection->font,
						 atom->getText (passwordCharacter),
						 atomX, 0.0f);

		if (indexToFind - indexInText >= g.getNumGlyphs())
			return atomRight;

		return jmin (atomRight, g.getGlyph (indexToFind - indexInText).getLeft());
	}

	int xToIndex (const float xToFind) const
	{
		if (xToFind <= atomX || atom->isNewLine())
			return indexInText;

		if (xToFind >= atomRight)
			return indexInText + atom->numChars;

		GlyphArrangement g;
		g.addLineOfText (currentSection->font,
						 atom->getText (passwordCharacter),
						 atomX, 0.0f);

		int j;
		for (j = 0; j < g.getNumGlyphs(); ++j)
			if ((g.getGlyph(j).getLeft() + g.getGlyph(j).getRight()) / 2 > xToFind)
				break;

		return indexInText + j;
	}

	bool getCharPosition (const int index, float& cx, float& cy, float& lineHeight_)
	{
		while (next())
		{
			if (indexInText + atom->numChars > index)
			{
				cx = indexToX (index);
				cy = lineY;
				lineHeight_ = lineHeight;
				return true;
			}
		}

		cx = atomX;
		cy = lineY;
		lineHeight_ = lineHeight;
		return false;
	}

	int indexInText;
	float lineY, lineHeight, maxDescent;
	float atomX, atomRight;
	const TextAtom* atom;
	const UniformTextSection* currentSection;

private:
	const Array <UniformTextSection*>& sections;
	int sectionIndex, atomIndex;
	const float wordWrapWidth;
	const juce_wchar passwordCharacter;
	TextAtom tempAtom;

	Iterator& operator= (const Iterator&);

	void moveToEndOfLastAtom()
	{
		if (atom != nullptr)
		{
			atomX = atomRight;

			if (atom->isNewLine())
			{
				atomX = 0.0f;
				lineY += lineHeight;
			}
		}
	}

	bool shouldWrap (const float x) const
	{
		return (x - 0.0001f) >= wordWrapWidth;
	}

	JUCE_LEAK_DETECTOR (Iterator);
};

class TextEditor::InsertAction  : public UndoableAction
{
public:
	InsertAction (TextEditor& owner_,
				  const String& text_,
				  const int insertIndex_,
				  const Font& font_,
				  const Colour& colour_,
				  const int oldCaretPos_,
				  const int newCaretPos_)
		: owner (owner_),
		  text (text_),
		  insertIndex (insertIndex_),
		  oldCaretPos (oldCaretPos_),
		  newCaretPos (newCaretPos_),
		  font (font_),
		  colour (colour_)
	{
	}

	bool perform()
	{
		owner.insert (text, insertIndex, font, colour, 0, newCaretPos);
		return true;
	}

	bool undo()
	{
		owner.remove (Range<int> (insertIndex, insertIndex + text.length()), 0, oldCaretPos);
		return true;
	}

	int getSizeInUnits()
	{
		return text.length() + 16;
	}

private:
	TextEditor& owner;
	const String text;
	const int insertIndex, oldCaretPos, newCaretPos;
	const Font font;
	const Colour colour;

	JUCE_DECLARE_NON_COPYABLE (InsertAction);
};

class TextEditor::RemoveAction  : public UndoableAction
{
public:
	RemoveAction (TextEditor& owner_,
				  const Range<int> range_,
				  const int oldCaretPos_,
				  const int newCaretPos_,
				  const Array <UniformTextSection*>& removedSections_)
		: owner (owner_),
		  range (range_),
		  oldCaretPos (oldCaretPos_),
		  newCaretPos (newCaretPos_),
		  removedSections (removedSections_)
	{
	}

	~RemoveAction()
	{
		for (int i = removedSections.size(); --i >= 0;)
		{
			UniformTextSection* const section = removedSections.getUnchecked (i);
			section->clear();
			delete section;
		}
	}

	bool perform()
	{
		owner.remove (range, 0, newCaretPos);
		return true;
	}

	bool undo()
	{
		owner.reinsert (range.getStart(), removedSections);
		owner.moveCaretTo (oldCaretPos, false);
		return true;
	}

	int getSizeInUnits()
	{
		int n = 0;

		for (int i = removedSections.size(); --i >= 0;)
			n += removedSections.getUnchecked (i)->getTotalLength();

		return n + 16;
	}

private:
	TextEditor& owner;
	const Range<int> range;
	const int oldCaretPos, newCaretPos;
	Array <UniformTextSection*> removedSections;

	JUCE_DECLARE_NON_COPYABLE (RemoveAction);
};

class TextEditor::TextHolderComponent  : public Component,
										 public Timer,
										 public ValueListener
{
public:
	TextHolderComponent (TextEditor& owner_)
		: owner (owner_)
	{
		setWantsKeyboardFocus (false);
		setInterceptsMouseClicks (false, true);

		owner.getTextValue().addListener (this);
	}

	~TextHolderComponent()
	{
		owner.getTextValue().removeListener (this);
	}

	void paint (Graphics& g)
	{
		owner.drawContent (g);
	}

	void restartTimer()
	{
		startTimer (350);
	}

	void timerCallback()
	{
		owner.timerCallbackInt();
	}

	MouseCursor getMouseCursor()
	{
		return owner.getMouseCursor();
	}

	void valueChanged (Value&)
	{
		owner.textWasChangedByValue();
	}

private:
	TextEditor& owner;

	JUCE_DECLARE_NON_COPYABLE (TextHolderComponent);
};

class TextEditorViewport  : public Viewport
{
public:
	TextEditorViewport (TextEditor& owner_)
		: owner (owner_), lastWordWrapWidth (0), rentrant (false)
	{
	}

	void visibleAreaChanged (const Rectangle<int>&)
	{
		if (! rentrant) // it's rare, but possible to get into a feedback loop as the viewport's scrollbars
						// appear and disappear, causing the wrap width to change.
		{
			const float wordWrapWidth = owner.getWordWrapWidth();

			if (wordWrapWidth != lastWordWrapWidth)
			{
				lastWordWrapWidth = wordWrapWidth;

				rentrant = true;
				owner.updateTextHolderSize();
				rentrant = false;
			}
		}
	}

private:
	TextEditor& owner;
	float lastWordWrapWidth;
	bool rentrant;

	JUCE_DECLARE_NON_COPYABLE (TextEditorViewport);
};

namespace TextEditorDefs
{
	const int textChangeMessageId = 0x10003001;
	const int returnKeyMessageId  = 0x10003002;
	const int escapeKeyMessageId  = 0x10003003;
	const int focusLossMessageId  = 0x10003004;

	const int maxActionsPerTransaction = 100;

	int getCharacterCategory (const juce_wchar character)
	{
		return CharacterFunctions::isLetterOrDigit (character)
					? 2 : (CharacterFunctions::isWhitespace (character) ? 0 : 1);
	}
}

TextEditor::TextEditor (const String& name,
						const juce_wchar passwordCharacter_)
	: Component (name),
	  borderSize (1, 1, 1, 3),
	  readOnly (false),
	  multiline (false),
	  wordWrap (false),
	  returnKeyStartsNewLine (false),
	  popupMenuEnabled (true),
	  selectAllTextWhenFocused (false),
	  scrollbarVisible (true),
	  wasFocused (false),
	  keepCaretOnScreen (true),
	  tabKeyUsed (false),
	  menuActive (false),
	  valueTextNeedsUpdating (false),
	  maxTextLength (0),
	  leftIndent (4),
	  topIndent (4),
	  lastTransactionTime (0),
	  currentFont (14.0f),
	  totalNumChars (0),
	  caretPosition (0),
	  passwordCharacter (passwordCharacter_),
	  dragType (notDragging)
{
	setOpaque (true);

	addAndMakeVisible (viewport = new TextEditorViewport (*this));
	viewport->setViewedComponent (textHolder = new TextHolderComponent (*this));
	viewport->setWantsKeyboardFocus (false);
	viewport->setScrollBarsShown (false, false);

	setWantsKeyboardFocus (true);
	setCaretVisible (true);
}

TextEditor::~TextEditor()
{
	if (wasFocused)
	{
		ComponentPeer* const peer = getPeer();
		if (peer != nullptr)
			peer->dismissPendingTextInput();
	}

	textValue.referTo (Value());
	clearInternal (0);
	viewport = nullptr;
	textHolder = nullptr;
}

void TextEditor::newTransaction()
{
	lastTransactionTime = Time::getApproximateMillisecondCounter();
	undoManager.beginNewTransaction();
}

bool TextEditor::undoOrRedo (const bool shouldUndo)
{
	if (! isReadOnly())
	{
		newTransaction();

		if (shouldUndo ? undoManager.undo()
					   : undoManager.redo())
		{
			scrollToMakeSureCursorIsVisible();
			repaint();
			textChanged();
			return true;
		}
	}

	return false;
}

bool TextEditor::undo()     { return undoOrRedo (true); }
bool TextEditor::redo()     { return undoOrRedo (false); }

void TextEditor::setMultiLine (const bool shouldBeMultiLine,
							   const bool shouldWordWrap)
{
	if (multiline != shouldBeMultiLine
		 || wordWrap != (shouldWordWrap && shouldBeMultiLine))
	{
		multiline = shouldBeMultiLine;
		wordWrap = shouldWordWrap && shouldBeMultiLine;

		viewport->setScrollBarsShown (scrollbarVisible && multiline,
									  scrollbarVisible && multiline);
		viewport->setViewPosition (0, 0);
		resized();
		scrollToMakeSureCursorIsVisible();
	}
}

bool TextEditor::isMultiLine() const
{
	return multiline;
}

void TextEditor::setScrollbarsShown (bool shown)
{
	if (scrollbarVisible != shown)
	{
		scrollbarVisible = shown;
		shown = shown && isMultiLine();
		viewport->setScrollBarsShown (shown, shown);
	}
}

void TextEditor::setReadOnly (const bool shouldBeReadOnly)
{
	if (readOnly != shouldBeReadOnly)
	{
		readOnly = shouldBeReadOnly;
		enablementChanged();
	}
}

bool TextEditor::isReadOnly() const
{
	return readOnly || ! isEnabled();
}

bool TextEditor::isTextInputActive() const
{
	return ! isReadOnly();
}

void TextEditor::setReturnKeyStartsNewLine (const bool shouldStartNewLine)
{
	returnKeyStartsNewLine = shouldStartNewLine;
}

void TextEditor::setTabKeyUsedAsCharacter (const bool shouldTabKeyBeUsed)
{
	tabKeyUsed = shouldTabKeyBeUsed;
}

void TextEditor::setPopupMenuEnabled (const bool b)
{
	popupMenuEnabled = b;
}

void TextEditor::setSelectAllWhenFocused (const bool b)
{
	selectAllTextWhenFocused = b;
}

const Font& TextEditor::getFont() const
{
	return currentFont;
}

void TextEditor::setFont (const Font& newFont)
{
	currentFont = newFont;
	scrollToMakeSureCursorIsVisible();
}

void TextEditor::applyFontToAllText (const Font& newFont)
{
	currentFont = newFont;

	const Colour overallColour (findColour (textColourId));

	for (int i = sections.size(); --i >= 0;)
	{
		UniformTextSection* const uts = sections.getUnchecked (i);
		uts->setFont (newFont, passwordCharacter);
		uts->colour = overallColour;
	}

	coalesceSimilarSections();
	updateTextHolderSize();
	scrollToMakeSureCursorIsVisible();
	repaint();
}

void TextEditor::colourChanged()
{
	setOpaque (findColour (backgroundColourId).isOpaque());
	repaint();
}

void TextEditor::lookAndFeelChanged()
{
	if (isCaretVisible())
	{
		setCaretVisible (false);
		setCaretVisible (true);
	}
}

void TextEditor::setCaretVisible (const bool shouldCaretBeVisible)
{
	if (shouldCaretBeVisible && ! isReadOnly())
	{
		if (caret == nullptr)
			textHolder->addChildComponent (caret = getLookAndFeel().createCaretComponent (this));
	}
	else
	{
		caret = nullptr;
	}

	setMouseCursor (shouldCaretBeVisible ? MouseCursor::IBeamCursor
										 : MouseCursor::NormalCursor);
}

void TextEditor::updateCaretPosition()
{
	if (caret != nullptr)
		caret->setCaretPosition (getCaretRectangle().translated (leftIndent, topIndent));
}

void TextEditor::setInputRestrictions (const int maxLen,
									   const String& chars)
{
	maxTextLength = jmax (0, maxLen);
	allowedCharacters = chars;
}

void TextEditor::setTextToShowWhenEmpty (const String& text, const Colour& colourToUse)
{
	textToShowWhenEmpty = text;
	colourForTextWhenEmpty = colourToUse;
}

void TextEditor::setPasswordCharacter (const juce_wchar newPasswordCharacter)
{
	if (passwordCharacter != newPasswordCharacter)
	{
		passwordCharacter = newPasswordCharacter;
		applyFontToAllText (currentFont);
	}
}

void TextEditor::setScrollBarThickness (const int newThicknessPixels)
{
	viewport->setScrollBarThickness (newThicknessPixels);
}

void TextEditor::setScrollBarButtonVisibility (const bool buttonsVisible)
{
	viewport->setScrollBarButtonVisibility (buttonsVisible);
}

void TextEditor::clear()
{
	clearInternal (0);
	updateTextHolderSize();
	undoManager.clearUndoHistory();
}

void TextEditor::setText (const String& newText,
						  const bool sendTextChangeMessage)
{
	const int newLength = newText.length();

	if (newLength != getTotalNumChars() || getText() != newText)
	{
		textValue = newText;

		int oldCursorPos = caretPosition;
		const bool cursorWasAtEnd = oldCursorPos >= getTotalNumChars();

		clearInternal (0);
		insert (newText, 0, currentFont, findColour (textColourId), 0, caretPosition);

		// if you're adding text with line-feeds to a single-line text editor, it
		// ain't gonna look right!
		jassert (multiline || ! newText.containsAnyOf ("\r\n"));

		if (cursorWasAtEnd && ! isMultiLine())
			oldCursorPos = getTotalNumChars();

		moveCaretTo (oldCursorPos, false);

		if (sendTextChangeMessage)
			textChanged();

		updateTextHolderSize();
		scrollToMakeSureCursorIsVisible();
		undoManager.clearUndoHistory();

		repaint();
	}
}

void TextEditor::updateValueFromText()
{
	if (valueTextNeedsUpdating)
	{
		valueTextNeedsUpdating = false;
		textValue = getText();
	}
}

Value& TextEditor::getTextValue()
{
	updateValueFromText();
	return textValue;
}

void TextEditor::textWasChangedByValue()
{
	if (textValue.getValueSource().getReferenceCount() > 1)
		setText (textValue.getValue());
}

void TextEditor::textChanged()
{
	updateTextHolderSize();

	if (listeners.size() > 0)
		postCommandMessage (TextEditorDefs::textChangeMessageId);

	if (textValue.getValueSource().getReferenceCount() > 1)
	{
		valueTextNeedsUpdating = false;
		textValue = getText();
	}
}

void TextEditor::returnPressed()
{
	postCommandMessage (TextEditorDefs::returnKeyMessageId);
}

void TextEditor::escapePressed()
{
	postCommandMessage (TextEditorDefs::escapeKeyMessageId);
}

void TextEditor::addListener (TextEditorListener* const newListener)
{
	listeners.add (newListener);
}

void TextEditor::removeListener (TextEditorListener* const listenerToRemove)
{
	listeners.remove (listenerToRemove);
}

void TextEditor::timerCallbackInt()
{
	if (hasKeyboardFocus (false) && ! isCurrentlyBlockedByAnotherModalComponent())
		wasFocused = true;

	const unsigned int now = Time::getApproximateMillisecondCounter();

	if (now > lastTransactionTime + 200)
		newTransaction();
}

void TextEditor::repaintText (const Range<int>& range)
{
	if (! range.isEmpty())
	{
		float x = 0, y = 0, lh = currentFont.getHeight();

		const float wordWrapWidth = getWordWrapWidth();

		if (wordWrapWidth > 0)
		{
			Iterator i (sections, wordWrapWidth, passwordCharacter);

			i.getCharPosition (range.getStart(), x, y, lh);

			const int y1 = (int) y;
			int y2;

			if (range.getEnd() >= getTotalNumChars())
			{
				y2 = textHolder->getHeight();
			}
			else
			{
				i.getCharPosition (range.getEnd(), x, y, lh);
				y2 = (int) (y + lh * 2.0f);
			}

			textHolder->repaint (0, y1, textHolder->getWidth(), y2 - y1);
		}
	}
}

void TextEditor::moveCaret (int newCaretPos)
{
	if (newCaretPos < 0)
		newCaretPos = 0;
	else if (newCaretPos > getTotalNumChars())
		newCaretPos = getTotalNumChars();

	if (newCaretPos != getCaretPosition())
	{
		caretPosition = newCaretPos;
		textHolder->restartTimer();
		scrollToMakeSureCursorIsVisible();
		updateCaretPosition();
	}
}

int TextEditor::getCaretPosition() const
{
	return caretPosition;
}

void TextEditor::setCaretPosition (const int newIndex)
{
	moveCaretTo (newIndex, false);
}

void TextEditor::moveCaretToEnd()
{
	moveCaretTo (std::numeric_limits<int>::max(), false);
}

void TextEditor::scrollEditorToPositionCaret (const int desiredCaretX,
											  const int desiredCaretY)

{
	updateCaretPosition();

	const Rectangle<int> caretPos (getCaretRectangle());

	int vx = caretPos.getX() - desiredCaretX;
	int vy = caretPos.getY() - desiredCaretY;

	if (desiredCaretX < jmax (1, proportionOfWidth (0.05f)))
		vx += desiredCaretX - proportionOfWidth (0.2f);
	else if (desiredCaretX > jmax (0, viewport->getMaximumVisibleWidth() - (wordWrap ? 2 : 10)))
		vx += desiredCaretX + (isMultiLine() ? proportionOfWidth (0.2f) : 10) - viewport->getMaximumVisibleWidth();

	vx = jlimit (0, jmax (0, textHolder->getWidth() + 8 - viewport->getMaximumVisibleWidth()), vx);

	if (! isMultiLine())
	{
		vy = viewport->getViewPositionY();
	}
	else
	{
		vy = jlimit (0, jmax (0, textHolder->getHeight() - viewport->getMaximumVisibleHeight()), vy);

		if (desiredCaretY < 0)
			vy = jmax (0, desiredCaretY + vy);
		else if (desiredCaretY > jmax (0, viewport->getMaximumVisibleHeight() - topIndent - caretPos.getHeight()))
			vy += desiredCaretY + 2 + caretPos.getHeight() + topIndent - viewport->getMaximumVisibleHeight();
	}

	viewport->setViewPosition (vx, vy);
}

Rectangle<int> TextEditor::getCaretRectangle()
{
	float cursorX, cursorY;
	float cursorHeight = currentFont.getHeight(); // (in case the text is empty and the call below doesn't set this value)
	getCharPosition (caretPosition, cursorX, cursorY, cursorHeight);

	return Rectangle<int> (roundToInt (cursorX), roundToInt (cursorY), 2, roundToInt (cursorHeight));
}

float TextEditor::getWordWrapWidth() const
{
	return wordWrap ? (float) (viewport->getMaximumVisibleWidth() - leftIndent - leftIndent / 2)
					: std::numeric_limits<float>::max();
}

void TextEditor::updateTextHolderSize()
{
	const float wordWrapWidth = getWordWrapWidth();

	if (wordWrapWidth > 0)
	{
		float maxWidth = 0.0f;

		Iterator i (sections, wordWrapWidth, passwordCharacter);

		while (i.next())
			maxWidth = jmax (maxWidth, i.atomRight);

		const int w = leftIndent + roundToInt (maxWidth);
		const int h = topIndent + roundToInt (jmax (i.lineY + i.lineHeight,
													currentFont.getHeight()));

		textHolder->setSize (w + 2, h + 1); // (the +2 allows a bit of space for the cursor to be at the right-hand-edge)
	}
}

int TextEditor::getTextWidth() const
{
	return textHolder->getWidth();
}

int TextEditor::getTextHeight() const
{
	return textHolder->getHeight();
}

void TextEditor::setIndents (const int newLeftIndent,
							 const int newTopIndent)
{
	leftIndent = newLeftIndent;
	topIndent = newTopIndent;
}

void TextEditor::setBorder (const BorderSize<int>& border)
{
	borderSize = border;
	resized();
}

BorderSize<int> TextEditor::getBorder() const
{
	return borderSize;
}

void TextEditor::setScrollToShowCursor (const bool shouldScrollToShowCursor)
{
	keepCaretOnScreen = shouldScrollToShowCursor;
}

void TextEditor::scrollToMakeSureCursorIsVisible()
{
	updateCaretPosition();

	if (keepCaretOnScreen)
	{
		int x = viewport->getViewPositionX();
		int y = viewport->getViewPositionY();

		const Rectangle<int> caretPos (getCaretRectangle());

		const int relativeCursorX = caretPos.getX() - x;
		const int relativeCursorY = caretPos.getY() - y;

		if (relativeCursorX < jmax (1, proportionOfWidth (0.05f)))
		{
			x += relativeCursorX - proportionOfWidth (0.2f);
		}
		else if (relativeCursorX > jmax (0, viewport->getMaximumVisibleWidth() - (wordWrap ? 2 : 10)))
		{
			x += relativeCursorX + (isMultiLine() ? proportionOfWidth (0.2f) : 10) - viewport->getMaximumVisibleWidth();
		}

		x = jlimit (0, jmax (0, textHolder->getWidth() + 8 - viewport->getMaximumVisibleWidth()), x);

		if (! isMultiLine())
		{
			y = (getHeight() - textHolder->getHeight() - topIndent) / -2;
		}
		else
		{
			if (relativeCursorY < 0)
			{
				y = jmax (0, relativeCursorY + y);
			}
			else if (relativeCursorY > jmax (0, viewport->getMaximumVisibleHeight() - topIndent - caretPos.getHeight()))
			{
				y += relativeCursorY + 2 + caretPos.getHeight() + topIndent - viewport->getMaximumVisibleHeight();
			}
		}

		viewport->setViewPosition (x, y);
	}
}

void TextEditor::moveCaretTo (const int newPosition,
							  const bool isSelecting)
{
	if (isSelecting)
	{
		moveCaret (newPosition);

		const Range<int> oldSelection (selection);

		if (dragType == notDragging)
		{
			if (abs (getCaretPosition() - selection.getStart()) < abs (getCaretPosition() - selection.getEnd()))
				dragType = draggingSelectionStart;
			else
				dragType = draggingSelectionEnd;
		}

		if (dragType == draggingSelectionStart)
		{
			if (getCaretPosition() >= selection.getEnd())
				dragType = draggingSelectionEnd;

			selection = Range<int>::between (getCaretPosition(), selection.getEnd());
		}
		else
		{
			if (getCaretPosition() < selection.getStart())
				dragType = draggingSelectionStart;

			selection = Range<int>::between (getCaretPosition(), selection.getStart());
		}

		repaintText (selection.getUnionWith (oldSelection));
	}
	else
	{
		dragType = notDragging;

		repaintText (selection);

		moveCaret (newPosition);
		selection = Range<int>::emptyRange (getCaretPosition());
	}
}

int TextEditor::getTextIndexAt (const int x,
								const int y)
{
	return indexAtPosition ((float) (x + viewport->getViewPositionX() - leftIndent),
							(float) (y + viewport->getViewPositionY() - topIndent));
}

void TextEditor::insertTextAtCaret (const String& newText_)
{
	String newText (newText_);

	if (allowedCharacters.isNotEmpty())
		newText = newText.retainCharacters (allowedCharacters);

	if (! isMultiLine())
		newText = newText.replaceCharacters ("\r\n", "  ");
	else
		newText = newText.replace ("\r\n", "\n");

	const int newCaretPos = selection.getStart() + newText.length();
	const int insertIndex = selection.getStart();

	remove (selection, getUndoManager(),
			newText.isNotEmpty() ? newCaretPos - 1 : newCaretPos);

	if (maxTextLength > 0)
		newText = newText.substring (0, maxTextLength - getTotalNumChars());

	if (newText.isNotEmpty())
		insert (newText,
				insertIndex,
				currentFont,
				findColour (textColourId),
				getUndoManager(),
				newCaretPos);

	textChanged();
}

void TextEditor::setHighlightedRegion (const Range<int>& newSelection)
{
	moveCaretTo (newSelection.getStart(), false);
	moveCaretTo (newSelection.getEnd(), true);
}

void TextEditor::copy()
{
	if (passwordCharacter == 0)
	{
		const String selectedText (getHighlightedText());

		if (selectedText.isNotEmpty())
			SystemClipboard::copyTextToClipboard (selectedText);
	}
}

void TextEditor::paste()
{
	if (! isReadOnly())
	{
		const String clip (SystemClipboard::getTextFromClipboard());

		if (clip.isNotEmpty())
			insertTextAtCaret (clip);
	}
}

void TextEditor::cut()
{
	if (! isReadOnly())
	{
		moveCaret (selection.getEnd());
		insertTextAtCaret (String::empty);
	}
}

void TextEditor::drawContent (Graphics& g)
{
	const float wordWrapWidth = getWordWrapWidth();

	if (wordWrapWidth > 0)
	{
		g.setOrigin (leftIndent, topIndent);
		const Rectangle<int> clip (g.getClipBounds());
		Colour selectedTextColour;

		Iterator i (sections, wordWrapWidth, passwordCharacter);

		while (i.lineY + 200.0 < clip.getY() && i.next())
		{}

		if (! selection.isEmpty())
		{
			g.setColour (findColour (highlightColourId).withMultipliedAlpha (hasKeyboardFocus (true) ? 1.0f : 0.5f));

			selectedTextColour = findColour (highlightedTextColourId);

			Iterator i2 (i);

			while (i2.next() && i2.lineY < clip.getBottom())
			{
				if (i2.lineY + i2.lineHeight >= clip.getY()
					 && selection.intersects (Range<int> (i2.indexInText, i2.indexInText + i2.atom->numChars)))
				{
					i2.drawSelection (g, selection);
				}
			}
		}

		const UniformTextSection* lastSection = nullptr;

		while (i.next() && i.lineY < clip.getBottom())
		{
			if (i.lineY + i.lineHeight >= clip.getY())
			{
				if (selection.intersects (Range<int> (i.indexInText, i.indexInText + i.atom->numChars)))
				{
					i.drawSelectedText (g, selection, selectedTextColour);
					lastSection = nullptr;
				}
				else
				{
					i.draw (g, lastSection);
				}
			}
		}

		for (int j = underlinedSections.size(); --j >= 0;)
		{
			const Range<int>& underlinedSection = underlinedSections.getReference (j);

			Iterator i2 (sections, wordWrapWidth, passwordCharacter);

			while (i2.next() && i2.lineY < clip.getBottom())
			{
				if (i2.lineY + i2.lineHeight >= clip.getY()
					 && underlinedSection.intersects (Range<int> (i2.indexInText, i2.indexInText + i2.atom->numChars)))
				{
					i2.drawUnderline (g, underlinedSection, findColour (textColourId));
				}
			}
		}
	}
}

void TextEditor::paint (Graphics& g)
{
	getLookAndFeel().fillTextEditorBackground (g, getWidth(), getHeight(), *this);
}

void TextEditor::paintOverChildren (Graphics& g)
{
	if (textToShowWhenEmpty.isNotEmpty()
		 && (! hasKeyboardFocus (false))
		 && getTotalNumChars() == 0)
	{
		g.setColour (colourForTextWhenEmpty);
		g.setFont (getFont());

		if (isMultiLine())
		{
			g.drawText (textToShowWhenEmpty,
						0, 0, getWidth(), getHeight(),
						Justification::centred, true);
		}
		else
		{
			g.drawText (textToShowWhenEmpty,
						leftIndent, 0, viewport->getWidth() - leftIndent, getHeight(),
						Justification::centredLeft, true);
		}
	}

	getLookAndFeel().drawTextEditorOutline (g, getWidth(), getHeight(), *this);
}

static void textEditorMenuCallback (int menuResult, TextEditor* editor)
{
	if (editor != nullptr && menuResult != 0)
		editor->performPopupMenuAction (menuResult);
}

void TextEditor::mouseDown (const MouseEvent& e)
{
	beginDragAutoRepeat (100);
	newTransaction();

	if (wasFocused || ! selectAllTextWhenFocused)
	{
		if (! (popupMenuEnabled && e.mods.isPopupMenu()))
		{
			moveCaretTo (getTextIndexAt (e.x, e.y),
						 e.mods.isShiftDown());
		}
		else
		{
			PopupMenu m;
			m.setLookAndFeel (&getLookAndFeel());
			addPopupMenuItems (m, &e);

			m.showMenuAsync (PopupMenu::Options(),
							 ModalCallbackFunction::forComponent (textEditorMenuCallback, this));
		}
	}
}

void TextEditor::mouseDrag (const MouseEvent& e)
{
	if (wasFocused || ! selectAllTextWhenFocused)
	{
		if (! (popupMenuEnabled && e.mods.isPopupMenu()))
		{
			moveCaretTo (getTextIndexAt (e.x, e.y), true);
		}
	}
}

void TextEditor::mouseUp (const MouseEvent& e)
{
	newTransaction();
	textHolder->restartTimer();

	if (wasFocused || ! selectAllTextWhenFocused)
	{
		if (e.mouseWasClicked() && ! (popupMenuEnabled && e.mods.isPopupMenu()))
		{
			moveCaret (getTextIndexAt (e.x, e.y));
		}
	}

	wasFocused = true;
}

void TextEditor::mouseDoubleClick (const MouseEvent& e)
{
	int tokenEnd = getTextIndexAt (e.x, e.y);
	int tokenStart = tokenEnd;

	if (e.getNumberOfClicks() > 3)
	{
		tokenStart = 0;
		tokenEnd = getTotalNumChars();
	}
	else
	{
		const String t (getText());
		const int totalLength = getTotalNumChars();

		while (tokenEnd < totalLength)
		{
			// (note the slight bodge here - it's because iswalnum only checks for alphabetic chars in the current locale)
			const juce_wchar c = t [tokenEnd];
			if (CharacterFunctions::isLetterOrDigit (c) || c > 128)
				++tokenEnd;
			else
				break;
		}

		tokenStart = tokenEnd;

		while (tokenStart > 0)
		{
			// (note the slight bodge here - it's because iswalnum only checks for alphabetic chars in the current locale)
			const juce_wchar c = t [tokenStart - 1];
			if (CharacterFunctions::isLetterOrDigit (c) || c > 128)
				--tokenStart;
			else
				break;
		}

		if (e.getNumberOfClicks() > 2)
		{
			while (tokenEnd < totalLength)
			{
				const juce_wchar c = t [tokenEnd];
				if (c != '\r' && c != '\n')
					++tokenEnd;
				else
					break;
			}

			while (tokenStart > 0)
			{
				const juce_wchar c = t [tokenStart - 1];
				if (c != '\r' && c != '\n')
					--tokenStart;
				else
					break;
			}
		}
	}

	moveCaretTo (tokenEnd, false);
	moveCaretTo (tokenStart, true);
}

void TextEditor::mouseWheelMove (const MouseEvent& e, float wheelIncrementX, float wheelIncrementY)
{
	if (! viewport->useMouseWheelMoveIfNeeded (e, wheelIncrementX, wheelIncrementY))
		Component::mouseWheelMove (e, wheelIncrementX, wheelIncrementY);
}

bool TextEditor::moveCaretWithTransation (const int newPos, const bool selecting)
{
	newTransaction();
	moveCaretTo (newPos, selecting);
	return true;
}

bool TextEditor::moveCaretLeft (bool moveInWholeWordSteps, bool selecting)
{
	int pos = getCaretPosition();

	if (moveInWholeWordSteps)
		pos = findWordBreakBefore (pos);
	else
		--pos;

	return moveCaretWithTransation (pos, selecting);
}

bool TextEditor::moveCaretRight (bool moveInWholeWordSteps, bool selecting)
{
	int pos = getCaretPosition();

	if (moveInWholeWordSteps)
		pos = findWordBreakAfter (pos);
	else
		++pos;

	return moveCaretWithTransation (pos, selecting);
}

bool TextEditor::moveCaretUp (bool selecting)
{
	if (! isMultiLine())
		return moveCaretToStartOfLine (selecting);

	const Rectangle<float> caretPos (getCaretRectangle().toFloat());
	return moveCaretWithTransation (indexAtPosition (caretPos.getX(), caretPos.getY() - 1.0f), selecting);
}

bool TextEditor::moveCaretDown (bool selecting)
{
	if (! isMultiLine())
		return moveCaretToEndOfLine (selecting);

	const Rectangle<float> caretPos (getCaretRectangle().toFloat());
	return moveCaretWithTransation (indexAtPosition (caretPos.getX(), caretPos.getBottom() + 1.0f), selecting);
}

bool TextEditor::pageUp (bool selecting)
{
	if (! isMultiLine())
		return moveCaretToStartOfLine (selecting);

	const Rectangle<float> caretPos (getCaretRectangle().toFloat());
	return moveCaretWithTransation (indexAtPosition (caretPos.getX(), caretPos.getY() - viewport->getViewHeight()), selecting);
}

bool TextEditor::pageDown (bool selecting)
{
	if (! isMultiLine())
		return moveCaretToEndOfLine (selecting);

	const Rectangle<float> caretPos (getCaretRectangle().toFloat());
	return moveCaretWithTransation (indexAtPosition (caretPos.getX(), caretPos.getBottom() + viewport->getViewHeight()), selecting);
}

void TextEditor::scrollByLines (int deltaLines)
{
	ScrollBar* scrollbar = viewport->getVerticalScrollBar();

	if (scrollbar != nullptr)
		scrollbar->moveScrollbarInSteps (deltaLines);
}

bool TextEditor::scrollDown()
{
	scrollByLines (-1);
	return true;
}

bool TextEditor::scrollUp()
{
	scrollByLines (1);
	return true;
}

bool TextEditor::moveCaretToTop (bool selecting)
{
	return moveCaretWithTransation (0, selecting);
}

bool TextEditor::moveCaretToStartOfLine (bool selecting)
{
	const Rectangle<float> caretPos (getCaretRectangle().toFloat());
	return moveCaretWithTransation (indexAtPosition (0.0f, caretPos.getY()), selecting);
}

bool TextEditor::moveCaretToEnd (bool selecting)
{
	return moveCaretWithTransation (getTotalNumChars(), selecting);
}

bool TextEditor::moveCaretToEndOfLine (bool selecting)
{
	const Rectangle<float> caretPos (getCaretRectangle().toFloat());
	return moveCaretWithTransation (indexAtPosition ((float) textHolder->getWidth(), caretPos.getY()), selecting);
}

bool TextEditor::deleteBackwards (bool moveInWholeWordSteps)
{
	if (moveInWholeWordSteps)
		moveCaretTo (findWordBreakBefore (getCaretPosition()), true);
	else if (selection.isEmpty() && selection.getStart() > 0)
		selection.setStart (selection.getEnd() - 1);

	cut();
	return true;
}

bool TextEditor::deleteForwards (bool /*moveInWholeWordSteps*/)
{
	if (selection.isEmpty() && selection.getStart() < getTotalNumChars())
		selection.setEnd (selection.getStart() + 1);

	cut();
	return true;
}

bool TextEditor::copyToClipboard()
{
	newTransaction();
	copy();
	return true;
}

bool TextEditor::cutToClipboard()
{
	newTransaction();
	copy();
	cut();
	return true;
}

bool TextEditor::pasteFromClipboard()
{
	newTransaction();
	paste();
	return true;
}

bool TextEditor::selectAll()
{
	newTransaction();
	moveCaretTo (getTotalNumChars(), false);
	moveCaretTo (0, true);
	return true;
}

bool TextEditor::keyPressed (const KeyPress& key)
{
	if (isReadOnly() && key != KeyPress ('c', ModifierKeys::commandModifier, 0))
		return false;

	if (! TextEditorKeyMapper<TextEditor>::invokeKeyFunction (*this, key))
	{
		if (key == KeyPress::returnKey)
		{
			newTransaction();

			if (returnKeyStartsNewLine)
				insertTextAtCaret ("\n");
			else
				returnPressed();
		}
		else if (key.isKeyCode (KeyPress::escapeKey))
		{
			newTransaction();
			moveCaretTo (getCaretPosition(), false);
			escapePressed();
		}
		else if (key.getTextCharacter() >= ' '
				  || (tabKeyUsed && (key.getTextCharacter() == '\t')))
		{
			insertTextAtCaret (String::charToString (key.getTextCharacter()));

			lastTransactionTime = Time::getApproximateMillisecondCounter();
		}
		else
		{
			return false;
		}
	}

	return true;
}

bool TextEditor::keyStateChanged (const bool isKeyDown)
{
	if (! isKeyDown)
		return false;

   #if JUCE_WINDOWS
	if (KeyPress (KeyPress::F4Key, ModifierKeys::altModifier, 0).isCurrentlyDown())
		return false;  // We need to explicitly allow alt-F4 to pass through on Windows
   #endif

	// (overridden to avoid forwarding key events to the parent)
	return ! ModifierKeys::getCurrentModifiers().isCommandDown();
}

const int baseMenuItemID = 0x7fff0000;

void TextEditor::addPopupMenuItems (PopupMenu& m, const MouseEvent*)
{
	const bool writable = ! isReadOnly();

	if (passwordCharacter == 0)
	{
		m.addItem (baseMenuItemID + 1, TRANS("cut"), writable);
		m.addItem (baseMenuItemID + 2, TRANS("copy"), ! selection.isEmpty());
		m.addItem (baseMenuItemID + 3, TRANS("paste"), writable);
	}

	m.addItem (baseMenuItemID + 4, TRANS("delete"), writable);
	m.addSeparator();
	m.addItem (baseMenuItemID + 5, TRANS("select all"));
	m.addSeparator();

	if (getUndoManager() != nullptr)
	{
		m.addItem (baseMenuItemID + 6, TRANS("undo"), undoManager.canUndo());
		m.addItem (baseMenuItemID + 7, TRANS("redo"), undoManager.canRedo());
	}
}

void TextEditor::performPopupMenuAction (const int menuItemID)
{
	switch (menuItemID)
	{
		case baseMenuItemID + 1:    cutToClipboard(); break;
		case baseMenuItemID + 2:    copyToClipboard(); break;
		case baseMenuItemID + 3:    pasteFromClipboard(); break;
		case baseMenuItemID + 4:    cut(); break;
		case baseMenuItemID + 5:    selectAll(); break;
		case baseMenuItemID + 6:    undo(); break;
		case baseMenuItemID + 7:    redo(); break;
		default: break;
	}
}

void TextEditor::focusGained (FocusChangeType)
{
	newTransaction();

	if (selectAllTextWhenFocused)
	{
		moveCaretTo (0, false);
		moveCaretTo (getTotalNumChars(), true);
	}

	repaint();
	updateCaretPosition();

	ComponentPeer* const peer = getPeer();
	if (peer != nullptr && ! isReadOnly())
		peer->textInputRequired (getScreenPosition() - peer->getScreenPosition());
}

void TextEditor::focusLost (FocusChangeType)
{
	newTransaction();

	wasFocused = false;
	textHolder->stopTimer();

	underlinedSections.clear();

	ComponentPeer* const peer = getPeer();
	if (peer != nullptr)
		peer->dismissPendingTextInput();

	updateCaretPosition();

	postCommandMessage (TextEditorDefs::focusLossMessageId);
	repaint();
}

void TextEditor::resized()
{
	viewport->setBoundsInset (borderSize);
	viewport->setSingleStepSizes (16, roundToInt (currentFont.getHeight()));

	updateTextHolderSize();

	if (! isMultiLine())
	{
		scrollToMakeSureCursorIsVisible();
	}
	else
	{
		updateCaretPosition();
	}
}

void TextEditor::handleCommandMessage (const int commandId)
{
	Component::BailOutChecker checker (this);

	switch (commandId)
	{
	case TextEditorDefs::textChangeMessageId:
		listeners.callChecked (checker, &TextEditorListener::textEditorTextChanged, (TextEditor&) *this);
		break;

	case TextEditorDefs::returnKeyMessageId:
		listeners.callChecked (checker, &TextEditorListener::textEditorReturnKeyPressed, (TextEditor&) *this);
		break;

	case TextEditorDefs::escapeKeyMessageId:
		listeners.callChecked (checker, &TextEditorListener::textEditorEscapeKeyPressed, (TextEditor&) *this);
		break;

	case TextEditorDefs::focusLossMessageId:
		updateValueFromText();
		listeners.callChecked (checker, &TextEditorListener::textEditorFocusLost, (TextEditor&) *this);
		break;

	default:
		jassertfalse;
		break;
	}
}

void TextEditor::enablementChanged()
{
	setMouseCursor (isReadOnly() ? MouseCursor::NormalCursor
								 : MouseCursor::IBeamCursor);
	repaint();
}

void TextEditor::setTemporaryUnderlining (const Array <Range<int> >& newUnderlinedSections)
{
	underlinedSections = newUnderlinedSections;
	repaint();
}

UndoManager* TextEditor::getUndoManager() noexcept
{
	return isReadOnly() ? 0 : &undoManager;
}

void TextEditor::clearInternal (UndoManager* const um)
{
	remove (Range<int> (0, getTotalNumChars()), um, caretPosition);
}

void TextEditor::insert (const String& text,
						 const int insertIndex,
						 const Font& font,
						 const Colour& colour,
						 UndoManager* const um,
						 const int caretPositionToMoveTo)
{
	if (text.isNotEmpty())
	{
		if (um != nullptr)
		{
			if (um->getNumActionsInCurrentTransaction() > TextEditorDefs::maxActionsPerTransaction)
				newTransaction();

			um->perform (new InsertAction (*this, text, insertIndex, font, colour,
										   caretPosition, caretPositionToMoveTo));
		}
		else
		{
			repaintText (Range<int> (insertIndex, getTotalNumChars())); // must do this before and after changing the data, in case
																		// a line gets moved due to word wrap

			int index = 0;
			int nextIndex = 0;

			for (int i = 0; i < sections.size(); ++i)
			{
				nextIndex = index + sections.getUnchecked (i)->getTotalLength();

				if (insertIndex == index)
				{
					sections.insert (i, new UniformTextSection (text,
																font, colour,
																passwordCharacter));
					break;
				}
				else if (insertIndex > index && insertIndex < nextIndex)
				{
					splitSection (i, insertIndex - index);
					sections.insert (i + 1, new UniformTextSection (text,
																	font, colour,
																	passwordCharacter));
					break;
				}

				index = nextIndex;
			}

			if (nextIndex == insertIndex)
				sections.add (new UniformTextSection (text,
													  font, colour,
													  passwordCharacter));

			coalesceSimilarSections();
			totalNumChars = -1;
			valueTextNeedsUpdating = true;

			updateTextHolderSize();
			moveCaretTo (caretPositionToMoveTo, false);

			repaintText (Range<int> (insertIndex, getTotalNumChars()));
		}
	}
}

void TextEditor::reinsert (const int insertIndex,
						   const Array <UniformTextSection*>& sectionsToInsert)
{
	int index = 0;
	int nextIndex = 0;

	for (int i = 0; i < sections.size(); ++i)
	{
		nextIndex = index + sections.getUnchecked (i)->getTotalLength();

		if (insertIndex == index)
		{
			for (int j = sectionsToInsert.size(); --j >= 0;)
				sections.insert (i, new UniformTextSection (*sectionsToInsert.getUnchecked(j)));

			break;
		}
		else if (insertIndex > index && insertIndex < nextIndex)
		{
			splitSection (i, insertIndex - index);

			for (int j = sectionsToInsert.size(); --j >= 0;)
				sections.insert (i + 1, new UniformTextSection (*sectionsToInsert.getUnchecked(j)));

			break;
		}

		index = nextIndex;
	}

	if (nextIndex == insertIndex)
	{
		for (int j = 0; j < sectionsToInsert.size(); ++j)
			sections.add (new UniformTextSection (*sectionsToInsert.getUnchecked(j)));
	}

	coalesceSimilarSections();
	totalNumChars = -1;
	valueTextNeedsUpdating = true;
}

void TextEditor::remove (const Range<int>& range,
						 UndoManager* const um,
						 const int caretPositionToMoveTo)
{
	if (! range.isEmpty())
	{
		int index = 0;

		for (int i = 0; i < sections.size(); ++i)
		{
			const int nextIndex = index + sections.getUnchecked(i)->getTotalLength();

			if (range.getStart() > index && range.getStart() < nextIndex)
			{
				splitSection (i, range.getStart() - index);
				--i;
			}
			else if (range.getEnd() > index && range.getEnd() < nextIndex)
			{
				splitSection (i, range.getEnd() - index);
				--i;
			}
			else
			{
				index = nextIndex;

				if (index > range.getEnd())
					break;
			}
		}

		index = 0;

		if (um != nullptr)
		{
			Array <UniformTextSection*> removedSections;

			for (int i = 0; i < sections.size(); ++i)
			{
				if (range.getEnd() <= range.getStart())
					break;

				UniformTextSection* const section = sections.getUnchecked (i);

				const int nextIndex = index + section->getTotalLength();

				if (range.getStart() <= index && range.getEnd() >= nextIndex)
					removedSections.add (new UniformTextSection (*section));

				index = nextIndex;
			}

			if (um->getNumActionsInCurrentTransaction() > TextEditorDefs::maxActionsPerTransaction)
				newTransaction();

			um->perform (new RemoveAction (*this, range, caretPosition,
										   caretPositionToMoveTo, removedSections));
		}
		else
		{
			Range<int> remainingRange (range);

			for (int i = 0; i < sections.size(); ++i)
			{
				UniformTextSection* const section = sections.getUnchecked (i);

				const int nextIndex = index + section->getTotalLength();

				if (remainingRange.getStart() <= index && remainingRange.getEnd() >= nextIndex)
				{
					sections.remove(i);
					section->clear();
					delete section;

					remainingRange.setEnd (remainingRange.getEnd() - (nextIndex - index));
					if (remainingRange.isEmpty())
						break;

					--i;
				}
				else
				{
					index = nextIndex;
				}
			}

			coalesceSimilarSections();
			totalNumChars = -1;
			valueTextNeedsUpdating = true;

			moveCaretTo (caretPositionToMoveTo, false);

			repaintText (Range<int> (range.getStart(), getTotalNumChars()));
		}
	}
}

String TextEditor::getText() const
{
	MemoryOutputStream mo;
	mo.preallocate ((size_t) getTotalNumChars());

	for (int i = 0; i < sections.size(); ++i)
		sections.getUnchecked (i)->appendAllText (mo);

	return mo.toString();
}

String TextEditor::getTextInRange (const Range<int>& range) const
{
	if (range.isEmpty())
		return String::empty;

	MemoryOutputStream mo;
	mo.preallocate ((size_t) jmin (getTotalNumChars(), range.getLength()));

	int index = 0;

	for (int i = 0; i < sections.size(); ++i)
	{
		const UniformTextSection* const s = sections.getUnchecked (i);
		const int nextIndex = index + s->getTotalLength();

		if (range.getStart() < nextIndex)
		{
			if (range.getEnd() <= index)
				break;

			s->appendSubstring (mo, range - index);
		}

		index = nextIndex;
	}

	return mo.toString();
}

String TextEditor::getHighlightedText() const
{
	return getTextInRange (selection);
}

int TextEditor::getTotalNumChars() const
{
	if (totalNumChars < 0)
	{
		totalNumChars = 0;

		for (int i = sections.size(); --i >= 0;)
			totalNumChars += sections.getUnchecked (i)->getTotalLength();
	}

	return totalNumChars;
}

bool TextEditor::isEmpty() const
{
	return getTotalNumChars() == 0;
}

void TextEditor::getCharPosition (const int index, float& cx, float& cy, float& lineHeight) const
{
	const float wordWrapWidth = getWordWrapWidth();

	if (wordWrapWidth > 0 && sections.size() > 0)
	{
		Iterator i (sections, wordWrapWidth, passwordCharacter);

		i.getCharPosition (index, cx, cy, lineHeight);
	}
	else
	{
		cx = cy = 0;
		lineHeight = currentFont.getHeight();
	}
}

int TextEditor::indexAtPosition (const float x, const float y)
{
	const float wordWrapWidth = getWordWrapWidth();

	if (wordWrapWidth > 0)
	{
		Iterator i (sections, wordWrapWidth, passwordCharacter);

		while (i.next())
		{
			if (i.lineY + i.lineHeight > y)
			{
				if (i.lineY > y)
					return jmax (0, i.indexInText - 1);

				if (i.atomX >= x)
					return i.indexInText;

				if (x < i.atomRight)
					return i.xToIndex (x);
			}
		}
	}

	return getTotalNumChars();
}

int TextEditor::findWordBreakAfter (const int position) const
{
	const String t (getTextInRange (Range<int> (position, position + 512)));
	const int totalLength = t.length();
	int i = 0;

	while (i < totalLength && CharacterFunctions::isWhitespace (t[i]))
		++i;

	const int type = TextEditorDefs::getCharacterCategory (t[i]);

	while (i < totalLength && type == TextEditorDefs::getCharacterCategory (t[i]))
		++i;

	while (i < totalLength && CharacterFunctions::isWhitespace (t[i]))
		++i;

	return position + i;
}

int TextEditor::findWordBreakBefore (const int position) const
{
	if (position <= 0)
		return 0;

	const int startOfBuffer = jmax (0, position - 512);
	const String t (getTextInRange (Range<int> (startOfBuffer, position)));

	int i = position - startOfBuffer;

	while (i > 0 && CharacterFunctions::isWhitespace (t [i - 1]))
		--i;

	if (i > 0)
	{
		const int type = TextEditorDefs::getCharacterCategory (t [i - 1]);

		while (i > 0 && type == TextEditorDefs::getCharacterCategory (t [i - 1]))
			--i;
	}

	jassert (startOfBuffer + i >= 0);
	return startOfBuffer + i;
}

void TextEditor::splitSection (const int sectionIndex,
							   const int charToSplitAt)
{
	jassert (sections[sectionIndex] != nullptr);

	sections.insert (sectionIndex + 1,
					 sections.getUnchecked (sectionIndex)->split (charToSplitAt, passwordCharacter));
}

void TextEditor::coalesceSimilarSections()
{
	for (int i = 0; i < sections.size() - 1; ++i)
	{
		UniformTextSection* const s1 = sections.getUnchecked (i);
		UniformTextSection* const s2 = sections.getUnchecked (i + 1);

		if (s1->font == s2->font
			 && s1->colour == s2->colour)
		{
			s1->append (*s2, passwordCharacter);
			sections.remove (i + 1);
			delete s2;
			--i;
		}
	}
}

void TextEditor::Listener::textEditorTextChanged (TextEditor&) {}
void TextEditor::Listener::textEditorReturnKeyPressed (TextEditor&) {}
void TextEditor::Listener::textEditorEscapeKeyPressed (TextEditor&) {}
void TextEditor::Listener::textEditorFocusLost (TextEditor&) {}

const Identifier TextEditor::Ids::tagType ("TEXTEDITOR");
const Identifier TextEditor::Ids::text ("text");
const Identifier TextEditor::Ids::font ("font");
const Identifier TextEditor::Ids::mode ("mode");
const Identifier TextEditor::Ids::readOnly ("readOnly");
const Identifier TextEditor::Ids::scrollbarsShown ("scrollbarsShown");
const Identifier TextEditor::Ids::caretVisible ("caretVisible");
const Identifier TextEditor::Ids::popupMenuEnabled ("popupMenuEnabled");

void TextEditor::refreshFromValueTree (const ValueTree& state, ComponentBuilder&)
{
	ComponentBuilder::refreshBasicComponentProperties (*this, state);

	setReadOnly (state [Ids::readOnly]);
	setScrollbarsShown (state [Ids::scrollbarsShown]);
	setCaretVisible (state [Ids::caretVisible]);
	setPopupMenuEnabled (state [Ids::popupMenuEnabled]);
	const int mode = state [Ids::mode];
	setMultiLine (mode > 1, true);
	setReturnKeyStartsNewLine (mode != 3);

	const Font font (Font::fromString (state [Ids::font]));
	if (getFont() != font)
		applyFontToAllText (font);

	setText (state [Ids::text].toString());
}

/*** End of inlined file: juce_TextEditor.cpp ***/


/*** Start of inlined file: juce_Toolbar.cpp ***/
const char* const Toolbar::toolbarDragDescriptor = "_toolbarItem_";

class ToolbarSpacerComp  : public ToolbarItemComponent
{
public:
	ToolbarSpacerComp (const int itemId_, const float fixedSize_, const bool drawBar_)
		: ToolbarItemComponent (itemId_, String::empty, false),
		  fixedSize (fixedSize_),
		  drawBar (drawBar_)
	{
	}

	~ToolbarSpacerComp()
	{
	}

	bool getToolbarItemSizes (int toolbarThickness, bool /*isToolbarVertical*/,
							  int& preferredSize, int& minSize, int& maxSize)
	{
		if (fixedSize <= 0)
		{
			preferredSize = toolbarThickness * 2;
			minSize = 4;
			maxSize = 32768;
		}
		else
		{
			maxSize = roundToInt (toolbarThickness * fixedSize);
			minSize = drawBar ? maxSize : jmin (4, maxSize);
			preferredSize = maxSize;

			if (getEditingMode() == editableOnPalette)
				preferredSize = maxSize = toolbarThickness / (drawBar ? 3 : 2);
		}

		return true;
	}

	void paintButtonArea (Graphics&, int, int, bool, bool)
	{
	}

	void contentAreaChanged (const Rectangle<int>&)
	{
	}

	int getResizeOrder() const noexcept
	{
		return fixedSize <= 0 ? 0 : 1;
	}

	void paint (Graphics& g)
	{
		const int w = getWidth();
		const int h = getHeight();

		if (drawBar)
		{
			g.setColour (findColour (Toolbar::separatorColourId, true));

			const float thickness = 0.2f;

			if (isToolbarVertical())
				g.fillRect (w * 0.1f, h * (0.5f - thickness * 0.5f), w * 0.8f, h * thickness);
			else
				g.fillRect (w * (0.5f - thickness * 0.5f), h * 0.1f, w * thickness, h * 0.8f);
		}

		if (getEditingMode() != normalMode && ! drawBar)
		{
			g.setColour (findColour (Toolbar::separatorColourId, true));

			const int indentX = jmin (2, (w - 3) / 2);
			const int indentY = jmin (2, (h - 3) / 2);
			g.drawRect (indentX, indentY, w - indentX * 2, h - indentY * 2, 1);

			if (fixedSize <= 0)
			{
				float x1, y1, x2, y2, x3, y3, x4, y4, hw, hl;

				if (isToolbarVertical())
				{
					x1 = w * 0.5f;
					y1 = h * 0.4f;
					x2 = x1;
					y2 = indentX * 2.0f;

					x3 = x1;
					y3 = h * 0.6f;
					x4 = x1;
					y4 = h - y2;

					hw = w * 0.15f;
					hl = w * 0.2f;
				}
				else
				{
					x1 = w * 0.4f;
					y1 = h * 0.5f;
					x2 = indentX * 2.0f;
					y2 = y1;

					x3 = w * 0.6f;
					y3 = y1;
					x4 = w - x2;
					y4 = y1;

					hw = h * 0.15f;
					hl = h * 0.2f;
				}

				Path p;
				p.addArrow (Line<float> (x1, y1, x2, y2), 1.5f, hw, hl);
				p.addArrow (Line<float> (x3, y3, x4, y4), 1.5f, hw, hl);
				g.fillPath (p);
			}
		}
	}

private:
	const float fixedSize;
	const bool drawBar;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ToolbarSpacerComp);
};

class Toolbar::MissingItemsComponent  : public PopupMenu::CustomComponent
{
public:
	MissingItemsComponent (Toolbar& owner_, const int height_)
		: PopupMenu::CustomComponent (true),
		  owner (&owner_),
		  height (height_)
	{
		for (int i = owner_.items.size(); --i >= 0;)
		{
			ToolbarItemComponent* const tc = owner_.items.getUnchecked(i);

			if (dynamic_cast <ToolbarSpacerComp*> (tc) == nullptr && ! tc->isVisible())
			{
				oldIndexes.insert (0, i);
				addAndMakeVisible (tc, 0);
			}
		}

		layout (400);
	}

	~MissingItemsComponent()
	{
		if (owner != nullptr)
		{
			for (int i = 0; i < getNumChildComponents(); ++i)
			{
				ToolbarItemComponent* const tc = dynamic_cast <ToolbarItemComponent*> (getChildComponent (i));

				if (tc != nullptr)
				{
					tc->setVisible (false);
					const int index = oldIndexes.remove (i);
					owner->addChildComponent (tc, index);
					--i;
				}
			}

			owner->resized();
		}
	}

	void layout (const int preferredWidth)
	{
		const int indent = 8;
		int x = indent;
		int y = indent;
		int maxX = 0;

		for (int i = 0; i < getNumChildComponents(); ++i)
		{
			ToolbarItemComponent* const tc = dynamic_cast <ToolbarItemComponent*> (getChildComponent (i));

			if (tc != nullptr)
			{
				int preferredSize = 1, minSize = 1, maxSize = 1;

				if (tc->getToolbarItemSizes (height, false, preferredSize, minSize, maxSize))
				{
					if (x + preferredSize > preferredWidth && x > indent)
					{
						x = indent;
						y += height;
					}

					tc->setBounds (x, y, preferredSize, height);

					x += preferredSize;
					maxX = jmax (maxX, x);
				}
			}
		}

		setSize (maxX + 8, y + height + 8);
	}

	void getIdealSize (int& idealWidth, int& idealHeight)
	{
		idealWidth = getWidth();
		idealHeight = getHeight();
	}

private:
	Component::SafePointer<Toolbar> owner;
	const int height;
	Array <int> oldIndexes;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (MissingItemsComponent);
};

Toolbar::Toolbar()
	: vertical (false),
	  isEditingActive (false),
	  toolbarStyle (Toolbar::iconsOnly)
{
	addChildComponent (missingItemsButton = getLookAndFeel().createToolbarMissingItemsButton (*this));

	missingItemsButton->setAlwaysOnTop (true);
	missingItemsButton->addListener (this);
}

Toolbar::~Toolbar()
{
	items.clear();
}

void Toolbar::setVertical (const bool shouldBeVertical)
{
	if (vertical != shouldBeVertical)
	{
		vertical = shouldBeVertical;
		resized();
	}
}

void Toolbar::clear()
{
	items.clear();
	resized();
}

ToolbarItemComponent* Toolbar::createItem (ToolbarItemFactory& factory, const int itemId)
{
	if (itemId == ToolbarItemFactory::separatorBarId)
		return new ToolbarSpacerComp (itemId, 0.1f, true);
	else if (itemId == ToolbarItemFactory::spacerId)
		return new ToolbarSpacerComp (itemId, 0.5f, false);
	else if (itemId == ToolbarItemFactory::flexibleSpacerId)
		return new ToolbarSpacerComp (itemId, 0, false);

	return factory.createItem (itemId);
}

void Toolbar::addItemInternal (ToolbarItemFactory& factory,
							   const int itemId,
							   const int insertIndex)
{
	// An ID can't be zero - this might indicate a mistake somewhere?
	jassert (itemId != 0);

	ToolbarItemComponent* const tc = createItem (factory, itemId);

	if (tc != nullptr)
	{
#if JUCE_DEBUG
		Array <int> allowedIds;
		factory.getAllToolbarItemIds (allowedIds);

		// If your factory can create an item for a given ID, it must also return
		// that ID from its getAllToolbarItemIds() method!
		jassert (allowedIds.contains (itemId));
#endif

		items.insert (insertIndex, tc);
		addAndMakeVisible (tc, insertIndex);
	}
}

void Toolbar::addItem (ToolbarItemFactory& factory,
					   const int itemId,
					   const int insertIndex)
{
	addItemInternal (factory, itemId, insertIndex);
	resized();
}

void Toolbar::addDefaultItems (ToolbarItemFactory& factoryToUse)
{
	Array <int> ids;
	factoryToUse.getDefaultItemSet (ids);

	clear();

	for (int i = 0; i < ids.size(); ++i)
		addItemInternal (factoryToUse, ids.getUnchecked (i), -1);

	resized();
}

void Toolbar::removeToolbarItem (const int itemIndex)
{
	items.remove (itemIndex);
	resized();
}

int Toolbar::getNumItems() const noexcept
{
	return items.size();
}

int Toolbar::getItemId (const int itemIndex) const noexcept
{
	ToolbarItemComponent* const tc = getItemComponent (itemIndex);
	return tc != nullptr ? tc->getItemId() : 0;
}

ToolbarItemComponent* Toolbar::getItemComponent (const int itemIndex) const noexcept
{
	return items [itemIndex];
}

ToolbarItemComponent* Toolbar::getNextActiveComponent (int index, const int delta) const
{
	for (;;)
	{
		index += delta;
		ToolbarItemComponent* const tc = getItemComponent (index);

		if (tc == nullptr)
			break;

		if (tc->isActive)
			return tc;
	}

	return nullptr;
}

void Toolbar::setStyle (const ToolbarItemStyle& newStyle)
{
	if (toolbarStyle != newStyle)
	{
		toolbarStyle = newStyle;
		updateAllItemPositions (false);
	}
}

String Toolbar::toString() const
{
	String s ("TB:");

	for (int i = 0; i < getNumItems(); ++i)
		s << getItemId(i) << ' ';

	return s.trimEnd();
}

bool Toolbar::restoreFromString (ToolbarItemFactory& factoryToUse,
								 const String& savedVersion)
{
	if (! savedVersion.startsWith ("TB:"))
		return false;

	StringArray tokens;
	tokens.addTokens (savedVersion.substring (3), false);

	clear();

	for (int i = 0; i < tokens.size(); ++i)
		addItemInternal (factoryToUse, tokens[i].getIntValue(), -1);

	resized();
	return true;
}

void Toolbar::paint (Graphics& g)
{
	getLookAndFeel().paintToolbarBackground (g, getWidth(), getHeight(), *this);
}

int Toolbar::getThickness() const noexcept
{
	return vertical ? getWidth() : getHeight();
}

int Toolbar::getLength() const noexcept
{
	return vertical ? getHeight() : getWidth();
}

void Toolbar::setEditingActive (const bool active)
{
	if (isEditingActive != active)
	{
		isEditingActive = active;
		updateAllItemPositions (false);
	}
}

void Toolbar::resized()
{
	updateAllItemPositions (false);
}

void Toolbar::updateAllItemPositions (const bool animate)
{
	if (getWidth() > 0 && getHeight() > 0)
	{
		StretchableObjectResizer resizer;

		int i;
		for (i = 0; i < items.size(); ++i)
		{
			ToolbarItemComponent* const tc = items.getUnchecked(i);

			tc->setEditingMode (isEditingActive ? ToolbarItemComponent::editableOnToolbar
												: ToolbarItemComponent::normalMode);

			tc->setStyle (toolbarStyle);

			ToolbarSpacerComp* const spacer = dynamic_cast <ToolbarSpacerComp*> (tc);

			int preferredSize = 1, minSize = 1, maxSize = 1;

			if (tc->getToolbarItemSizes (getThickness(), isVertical(),
										 preferredSize, minSize, maxSize))
			{
				tc->isActive = true;
				resizer.addItem (preferredSize, minSize, maxSize,
								 spacer != nullptr ? spacer->getResizeOrder() : 2);
			}
			else
			{
				tc->isActive = false;
				tc->setVisible (false);
			}
		}

		resizer.resizeToFit (getLength());

		int totalLength = 0;

		for (i = 0; i < resizer.getNumItems(); ++i)
			totalLength += (int) resizer.getItemSize (i);

		const bool itemsOffTheEnd = totalLength > getLength();

		const int extrasButtonSize = getThickness() / 2;
		missingItemsButton->setSize (extrasButtonSize, extrasButtonSize);
		missingItemsButton->setVisible (itemsOffTheEnd);
		missingItemsButton->setEnabled (! isEditingActive);

		if (vertical)
			missingItemsButton->setCentrePosition (getWidth() / 2,
												   getHeight() - 4 - extrasButtonSize / 2);
		else
			missingItemsButton->setCentrePosition (getWidth() - 4 - extrasButtonSize / 2,
												   getHeight() / 2);

		const int maxLength = itemsOffTheEnd ? (vertical ? missingItemsButton->getY()
														 : missingItemsButton->getX()) - 4
											 : getLength();

		int pos = 0, activeIndex = 0;
		for (i = 0; i < items.size(); ++i)
		{
			ToolbarItemComponent* const tc = items.getUnchecked(i);

			if (tc->isActive)
			{
				const int size = (int) resizer.getItemSize (activeIndex++);

				Rectangle<int> newBounds;
				if (vertical)
					newBounds.setBounds (0, pos, getWidth(), size);
				else
					newBounds.setBounds (pos, 0, size, getHeight());

				if (animate)
				{
					Desktop::getInstance().getAnimator().animateComponent (tc, newBounds, 1.0f, 200, false, 3.0, 0.0);
				}
				else
				{
					Desktop::getInstance().getAnimator().cancelAnimation (tc, false);
					tc->setBounds (newBounds);
				}

				pos += size;
				tc->setVisible (pos <= maxLength
								 && ((! tc->isBeingDragged)
									  || tc->getEditingMode() == ToolbarItemComponent::editableOnPalette));
			}
		}
	}
}

void Toolbar::buttonClicked (Button*)
{
	jassert (missingItemsButton->isShowing());

	if (missingItemsButton->isShowing())
	{
		PopupMenu m;
		m.addCustomItem (1, new MissingItemsComponent (*this, getThickness()));
		m.showMenuAsync (PopupMenu::Options().withTargetComponent (missingItemsButton), nullptr);
	}
}

bool Toolbar::isInterestedInDragSource (const SourceDetails& dragSourceDetails)
{
	return dragSourceDetails.description == toolbarDragDescriptor && isEditingActive;
}

void Toolbar::itemDragMove (const SourceDetails& dragSourceDetails)
{
	ToolbarItemComponent* const tc = dynamic_cast <ToolbarItemComponent*> (dragSourceDetails.sourceComponent.get());

	if (tc != nullptr)
	{
		if (! items.contains (tc))
		{
			if (tc->getEditingMode() == ToolbarItemComponent::editableOnPalette)
			{
				ToolbarItemPalette* const palette = tc->findParentComponentOfClass ((ToolbarItemPalette*) nullptr);

				if (palette != nullptr)
					palette->replaceComponent (tc);
			}
			else
			{
				jassert (tc->getEditingMode() == ToolbarItemComponent::editableOnToolbar);
			}

			items.add (tc);
			addChildComponent (tc);
			updateAllItemPositions (true);
		}

		for (int i = getNumItems(); --i >= 0;)
		{
			const int currentIndex = items.indexOf (tc);
			int newIndex = currentIndex;

			const int dragObjectLeft = vertical ? (dragSourceDetails.localPosition.getY() - tc->dragOffsetY)
												: (dragSourceDetails.localPosition.getX() - tc->dragOffsetX);
			const int dragObjectRight = dragObjectLeft + (vertical ? tc->getHeight() : tc->getWidth());

			const Rectangle<int> current (Desktop::getInstance().getAnimator()
											.getComponentDestination (getChildComponent (newIndex)));
			ToolbarItemComponent* const prev = getNextActiveComponent (newIndex, -1);

			if (prev != nullptr)
			{
				const Rectangle<int> previousPos (Desktop::getInstance().getAnimator().getComponentDestination (prev));

				if (abs (dragObjectLeft - (vertical ? previousPos.getY() : previousPos.getX())
					  < abs (dragObjectRight - (vertical ? current.getBottom() : current.getRight()))))
				{
					newIndex = getIndexOfChildComponent (prev);
				}
			}

			ToolbarItemComponent* const next = getNextActiveComponent (newIndex, 1);
			if (next != nullptr)
			{
				const Rectangle<int> nextPos (Desktop::getInstance().getAnimator().getComponentDestination (next));

				if (abs (dragObjectLeft - (vertical ? current.getY() : current.getX())
					 > abs (dragObjectRight - (vertical ? nextPos.getBottom() : nextPos.getRight()))))
				{
					newIndex = getIndexOfChildComponent (next) + 1;
				}
			}

			if (newIndex == currentIndex)
				break;

			items.removeObject (tc, false);
			removeChildComponent (tc);
			addChildComponent (tc, newIndex);
			items.insert (newIndex, tc);
			updateAllItemPositions (true);
		}
	}
}

void Toolbar::itemDragExit (const SourceDetails& dragSourceDetails)
{
	ToolbarItemComponent* const tc = dynamic_cast <ToolbarItemComponent*> (dragSourceDetails.sourceComponent.get());

	if (tc != nullptr && isParentOf (tc))
	{
		items.removeObject (tc, false);
		removeChildComponent (tc);
		updateAllItemPositions (true);
	}
}

void Toolbar::itemDropped (const SourceDetails& dragSourceDetails)
{
	ToolbarItemComponent* const tc = dynamic_cast <ToolbarItemComponent*> (dragSourceDetails.sourceComponent.get());

	if (tc != nullptr)
		tc->setState (Button::buttonNormal);
}

void Toolbar::mouseDown (const MouseEvent&)
{
}

class ToolbarCustomisationDialog   : public DialogWindow
{
public:
	ToolbarCustomisationDialog (ToolbarItemFactory& factory,
								Toolbar* const toolbar_,
								const int optionFlags)
		: DialogWindow (TRANS("Add/remove items from toolbar"), Colours::white, true, true),
		  toolbar (toolbar_)
	{
		setContentOwned (new CustomiserPanel (factory, toolbar, optionFlags), true);
		setResizable (true, true);
		setResizeLimits (400, 300, 1500, 1000);
		positionNearBar();
	}

	~ToolbarCustomisationDialog()
	{
		toolbar->setEditingActive (false);
	}

	void closeButtonPressed()
	{
		setVisible (false);
	}

	bool canModalEventBeSentToComponent (const Component* comp)
	{
		return toolbar->isParentOf (comp);
	}

	void positionNearBar()
	{
		const Rectangle<int> screenSize (toolbar->getParentMonitorArea());
		const int tbx = toolbar->getScreenX();
		const int tby = toolbar->getScreenY();
		const int gap = 8;

		int x, y;

		if (toolbar->isVertical())
		{
			y = tby;

			if (tbx > screenSize.getCentreX())
				x = tbx - getWidth() - gap;
			else
				x = tbx + toolbar->getWidth() + gap;
		}
		else
		{
			x = tbx + (toolbar->getWidth() - getWidth()) / 2;

			if (tby > screenSize.getCentreY())
				y = tby - getHeight() - gap;
			else
				y = tby + toolbar->getHeight() + gap;
		}

		setTopLeftPosition (x, y);
	}

private:
	Toolbar* const toolbar;

	class CustomiserPanel  : public Component,
							 private ComboBoxListener, // (can't use ComboBox::Listener due to idiotic VC2005 bug)
							 private ButtonListener
	{
	public:
		CustomiserPanel (ToolbarItemFactory& factory_,
						 Toolbar* const toolbar_,
						 const int optionFlags)
		  : factory (factory_),
			toolbar (toolbar_),
			palette (factory_, toolbar_),
			instructions (String::empty, TRANS ("You can drag the items above and drop them onto a toolbar to add them.\n\n"
												"Items on the toolbar can also be dragged around to change their order, or dragged off the edge to delete them.")),
			defaultButton (TRANS ("Restore to default set of items"))
		{
			addAndMakeVisible (&palette);

			if ((optionFlags & (Toolbar::allowIconsOnlyChoice
								 | Toolbar::allowIconsWithTextChoice
								 | Toolbar::allowTextOnlyChoice)) != 0)
			{
				addAndMakeVisible (&styleBox);
				styleBox.setEditableText (false);

				if ((optionFlags & Toolbar::allowIconsOnlyChoice) != 0)     styleBox.addItem (TRANS("Show icons only"), 1);
				if ((optionFlags & Toolbar::allowIconsWithTextChoice) != 0) styleBox.addItem (TRANS("Show icons and descriptions"), 2);
				if ((optionFlags & Toolbar::allowTextOnlyChoice) != 0)      styleBox.addItem (TRANS("Show descriptions only"), 3);

				int selectedStyle = 0;
				switch (toolbar_->getStyle())
				{
					case Toolbar::iconsOnly:        selectedStyle = 1; break;
					case Toolbar::iconsWithText:    selectedStyle = 2; break;
					case Toolbar::textOnly:         selectedStyle = 3; break;
				}

				styleBox.setSelectedId (selectedStyle);

				styleBox.addListener (this);
			}

			if ((optionFlags & Toolbar::showResetToDefaultsButton) != 0)
			{
				addAndMakeVisible (&defaultButton);
				defaultButton.addListener (this);
			}

			addAndMakeVisible (&instructions);
			instructions.setFont (Font (13.0f));

			setSize (500, 300);
		}

		void comboBoxChanged (ComboBox*)
		{
			switch (styleBox.getSelectedId())
			{
				case 1:   toolbar->setStyle (Toolbar::iconsOnly); break;
				case 2:   toolbar->setStyle (Toolbar::iconsWithText); break;
				case 3:   toolbar->setStyle (Toolbar::textOnly); break;
			}

			palette.resized(); // to make it update the styles
		}

		void buttonClicked (Button*)
		{
			toolbar->addDefaultItems (factory);
		}

		void paint (Graphics& g)
		{
			Colour background;

			DialogWindow* const dw = findParentComponentOfClass ((DialogWindow*) nullptr);

			if (dw != nullptr)
				background = dw->getBackgroundColour();

			g.setColour (background.contrasting().withAlpha (0.3f));
			g.fillRect (palette.getX(), palette.getBottom() - 1, palette.getWidth(), 1);
		}

		void resized()
		{
			palette.setBounds (0, 0, getWidth(), getHeight() - 120);
			styleBox.setBounds (10, getHeight() - 110, 200, 22);

			defaultButton.changeWidthToFitText (22);
			defaultButton.setTopLeftPosition (240, getHeight() - 110);

			instructions.setBounds (10, getHeight() - 80, getWidth() - 20, 80);
		}

	private:
		ToolbarItemFactory& factory;
		Toolbar* const toolbar;

		ToolbarItemPalette palette;
		Label instructions;
		ComboBox styleBox;
		TextButton defaultButton;
	};
};

void Toolbar::showCustomisationDialog (ToolbarItemFactory& factory, const int optionFlags)
{
	setEditingActive (true);

	(new ToolbarCustomisationDialog (factory, this, optionFlags))
		->enterModalState (true, 0, true);
}

/*** End of inlined file: juce_Toolbar.cpp ***/


/*** Start of inlined file: juce_ToolbarItemComponent.cpp ***/
ToolbarItemFactory::ToolbarItemFactory()
{
}

ToolbarItemFactory::~ToolbarItemFactory()
{
}

class ItemDragAndDropOverlayComponent    : public Component
{
public:
	ItemDragAndDropOverlayComponent()
		: isDragging (false)
	{
		setAlwaysOnTop (true);
		setRepaintsOnMouseActivity (true);
		setMouseCursor (MouseCursor::DraggingHandCursor);
	}

	void paint (Graphics& g)
	{
		ToolbarItemComponent* const tc = dynamic_cast <ToolbarItemComponent*> (getParentComponent());

		if (isMouseOverOrDragging()
			  && tc != nullptr
			  && tc->getEditingMode() == ToolbarItemComponent::editableOnToolbar)
		{
			g.setColour (findColour (Toolbar::editingModeOutlineColourId, true));
			g.drawRect (0, 0, getWidth(), getHeight(),
						jmin (2, (getWidth() - 1) / 2, (getHeight() - 1) / 2));
		}
	}

	void mouseDown (const MouseEvent& e)
	{
		isDragging = false;
		ToolbarItemComponent* const tc = dynamic_cast <ToolbarItemComponent*> (getParentComponent());

		if (tc != nullptr)
		{
			tc->dragOffsetX = e.x;
			tc->dragOffsetY = e.y;
		}
	}

	void mouseDrag (const MouseEvent& e)
	{
		if (! (isDragging || e.mouseWasClicked()))
		{
			isDragging = true;
			DragAndDropContainer* const dnd = DragAndDropContainer::findParentDragContainerFor (this);

			if (dnd != nullptr)
			{
				dnd->startDragging (Toolbar::toolbarDragDescriptor, getParentComponent(), Image::null, true);

				ToolbarItemComponent* const tc = dynamic_cast <ToolbarItemComponent*> (getParentComponent());

				if (tc != nullptr)
				{
					tc->isBeingDragged = true;

					if (tc->getEditingMode() == ToolbarItemComponent::editableOnToolbar)
						tc->setVisible (false);
				}
			}
		}
	}

	void mouseUp (const MouseEvent&)
	{
		isDragging = false;
		ToolbarItemComponent* const tc = dynamic_cast <ToolbarItemComponent*> (getParentComponent());

		if (tc != nullptr)
		{
			tc->isBeingDragged = false;

			Toolbar* const tb = tc->getToolbar();

			if (tb != nullptr)
				tb->updateAllItemPositions (true);
			else if (tc->getEditingMode() == ToolbarItemComponent::editableOnToolbar)
				delete tc;
		}
	}

	void parentSizeChanged()
	{
		setBounds (0, 0, getParentWidth(), getParentHeight());
	}

private:

	bool isDragging;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ItemDragAndDropOverlayComponent);
};

ToolbarItemComponent::ToolbarItemComponent (const int itemId_,
											const String& labelText,
											const bool isBeingUsedAsAButton_)
	: Button (labelText),
	  itemId (itemId_),
	  mode (normalMode),
	  toolbarStyle (Toolbar::iconsOnly),
	  dragOffsetX (0),
	  dragOffsetY (0),
	  isActive (true),
	  isBeingDragged (false),
	  isBeingUsedAsAButton (isBeingUsedAsAButton_)
{
	// Your item ID can't be 0!
	jassert (itemId_ != 0);
}

ToolbarItemComponent::~ToolbarItemComponent()
{
	overlayComp = nullptr;
}

Toolbar* ToolbarItemComponent::getToolbar() const
{
	return dynamic_cast <Toolbar*> (getParentComponent());
}

bool ToolbarItemComponent::isToolbarVertical() const
{
	const Toolbar* const t = getToolbar();
	return t != nullptr && t->isVertical();
}

void ToolbarItemComponent::setStyle (const Toolbar::ToolbarItemStyle& newStyle)
{
	if (toolbarStyle != newStyle)
	{
		toolbarStyle = newStyle;
		repaint();
		resized();
	}
}

void ToolbarItemComponent::paintButton (Graphics& g, const bool over, const bool down)
{
	if (isBeingUsedAsAButton)
		getLookAndFeel().paintToolbarButtonBackground (g, getWidth(), getHeight(),
													   over, down, *this);

	if (toolbarStyle != Toolbar::iconsOnly)
	{
		const int indent = contentArea.getX();
		int y = indent;
		int h = getHeight() - indent * 2;

		if (toolbarStyle == Toolbar::iconsWithText)
		{
			y = contentArea.getBottom() + indent / 2;
			h -= contentArea.getHeight();
		}

		getLookAndFeel().paintToolbarButtonLabel (g, indent, y, getWidth() - indent * 2, h,
												  getButtonText(), *this);
	}

	if (! contentArea.isEmpty())
	{
		Graphics::ScopedSaveState ss (g);

		g.reduceClipRegion (contentArea);
		g.setOrigin (contentArea.getX(), contentArea.getY());

		paintButtonArea (g, contentArea.getWidth(), contentArea.getHeight(), over, down);
	}
}

void ToolbarItemComponent::resized()
{
	if (toolbarStyle != Toolbar::textOnly)
	{
		const int indent = jmin (proportionOfWidth (0.08f),
								 proportionOfHeight (0.08f));

		contentArea = Rectangle<int> (indent, indent,
									  getWidth() - indent * 2,
									  toolbarStyle == Toolbar::iconsWithText ? proportionOfHeight (0.55f)
																			 : (getHeight() - indent * 2));
	}
	else
	{
		contentArea = Rectangle<int>();
	}

	contentAreaChanged (contentArea);
}

void ToolbarItemComponent::setEditingMode (const ToolbarEditingMode newMode)
{
	if (mode != newMode)
	{
		mode = newMode;
		repaint();

		if (mode == normalMode)
		{
			overlayComp = nullptr;
		}
		else if (overlayComp == nullptr)
		{
			addAndMakeVisible (overlayComp = new ItemDragAndDropOverlayComponent());
			overlayComp->parentSizeChanged();
		}

		resized();
	}
}

/*** End of inlined file: juce_ToolbarItemComponent.cpp ***/


/*** Start of inlined file: juce_ToolbarItemPalette.cpp ***/
ToolbarItemPalette::ToolbarItemPalette (ToolbarItemFactory& factory_,
										Toolbar* const toolbar_)
	: factory (factory_),
	  toolbar (toolbar_)
{
	Component* const itemHolder = new Component();
	viewport.setViewedComponent (itemHolder);

	Array <int> allIds;
	factory.getAllToolbarItemIds (allIds);

	for (int i = 0; i < allIds.size(); ++i)
		addComponent (allIds.getUnchecked (i), -1);

	addAndMakeVisible (&viewport);
}

ToolbarItemPalette::~ToolbarItemPalette()
{
}

void ToolbarItemPalette::addComponent (const int itemId, const int index)
{
	ToolbarItemComponent* const tc = Toolbar::createItem (factory, itemId);
	jassert (tc != nullptr);

	if (tc != nullptr)
	{
		items.insert (index, tc);
		viewport.getViewedComponent()->addAndMakeVisible (tc, index);
		tc->setEditingMode (ToolbarItemComponent::editableOnPalette);
	}
}

void ToolbarItemPalette::replaceComponent (ToolbarItemComponent* const comp)
{
	const int index = items.indexOf (comp);
	jassert (index >= 0);
	items.removeObject (comp, false);

	addComponent (comp->getItemId(), index);
	resized();
}

void ToolbarItemPalette::resized()
{
	viewport.setBoundsInset (BorderSize<int> (1));

	Component* const itemHolder = viewport.getViewedComponent();

	const int indent = 8;
	const int preferredWidth = viewport.getWidth() - viewport.getScrollBarThickness() - indent;
	const int height = toolbar->getThickness();
	int x = indent;
	int y = indent;
	int maxX = 0;

	for (int i = 0; i < items.size(); ++i)
	{
		ToolbarItemComponent* const tc = items.getUnchecked(i);

		tc->setStyle (toolbar->getStyle());

		int preferredSize = 1, minSize = 1, maxSize = 1;

		if (tc->getToolbarItemSizes (height, false, preferredSize, minSize, maxSize))
		{
			if (x + preferredSize > preferredWidth && x > indent)
			{
				x = indent;
				y += height;
			}

			tc->setBounds (x, y, preferredSize, height);

			x += preferredSize + 8;
			maxX = jmax (maxX, x);
		}
	}

	itemHolder->setSize (maxX, y + height + 8);
}

/*** End of inlined file: juce_ToolbarItemPalette.cpp ***/


/*** Start of inlined file: juce_TreeView.cpp ***/
class TreeViewContentComponent  : public Component,
								  public TooltipClient,
								  public AsyncUpdater
{
public:
	TreeViewContentComponent (TreeView& owner_)
		: owner (owner_),
		  buttonUnderMouse (nullptr),
		  isDragging (false)
	{
	}

	void mouseDown (const MouseEvent& e)
	{
		updateButtonUnderMouse (e);

		isDragging = false;
		needSelectionOnMouseUp = false;

		Rectangle<int> pos;
		TreeViewItem* const item = findItemAt (e.y, pos);

		if (item != nullptr)
		{
			// (if the open/close buttons are hidden, we'll treat clicks to the left of the item
			// as selection clicks)
			if (e.x < pos.getX() && owner.openCloseButtonsVisible)
			{
				if (e.x >= pos.getX() - owner.getIndentSize())
					item->setOpen (! item->isOpen());

				// (clicks to the left of an open/close button are ignored)
			}
			else
			{
				// mouse-down inside the body of the item..
				if (! owner.isMultiSelectEnabled())
					item->setSelected (true, true);
				else if (item->isSelected())
					needSelectionOnMouseUp = ! e.mods.isPopupMenu();
				else
					selectBasedOnModifiers (item, e.mods);

				if (e.x >= pos.getX())
					item->itemClicked (e.withNewPosition (e.getPosition() - pos.getPosition()));
			}
		}
	}

	void mouseUp (const MouseEvent& e)
	{
		updateButtonUnderMouse (e);

		if (needSelectionOnMouseUp && e.mouseWasClicked())
		{
			Rectangle<int> pos;
			TreeViewItem* const item = findItemAt (e.y, pos);

			if (item != nullptr)
				selectBasedOnModifiers (item, e.mods);
		}
	}

	void mouseDoubleClick (const MouseEvent& e)
	{
		if (e.getNumberOfClicks() != 3)  // ignore triple clicks
		{
			Rectangle<int> pos;
			TreeViewItem* const item = findItemAt (e.y, pos);

			if (item != nullptr && (e.x >= pos.getX() || ! owner.openCloseButtonsVisible))
				item->itemDoubleClicked (e.withNewPosition (e.getPosition() - pos.getPosition()));
		}
	}

	void mouseDrag (const MouseEvent& e)
	{
		if (isEnabled()
			 && ! (isDragging || e.mouseWasClicked()
					|| e.getDistanceFromDragStart() < 5
					|| e.mods.isPopupMenu()))
		{
			isDragging = true;

			Rectangle<int> pos;
			TreeViewItem* const item = findItemAt (e.getMouseDownY(), pos);

			if (item != nullptr && e.getMouseDownX() >= pos.getX())
			{
				const var dragDescription (item->getDragSourceDescription());

				if (! (dragDescription.isVoid() || (dragDescription.isString() && dragDescription.toString().isEmpty())))
				{
					DragAndDropContainer* const dragContainer
						= DragAndDropContainer::findParentDragContainerFor (this);

					if (dragContainer != nullptr)
					{
						pos.setSize (pos.getWidth(), item->itemHeight);
						Image dragImage (Component::createComponentSnapshot (pos, true));
						dragImage.multiplyAllAlphas (0.6f);

						Point<int> imageOffset (pos.getPosition() - e.getPosition());
						dragContainer->startDragging (dragDescription, &owner, dragImage, true, &imageOffset);
					}
					else
					{
						// to be able to do a drag-and-drop operation, the treeview needs to
						// be inside a component which is also a DragAndDropContainer.
						jassertfalse;
					}
				}
			}
		}
	}

	void mouseMove (const MouseEvent& e)    { updateButtonUnderMouse (e); }
	void mouseExit (const MouseEvent& e)    { updateButtonUnderMouse (e); }

	void paint (Graphics& g)
	{
		if (owner.rootItem != nullptr)
		{
			owner.recalculateIfNeeded();

			if (! owner.rootItemVisible)
				g.setOrigin (0, -owner.rootItem->itemHeight);

			owner.rootItem->paintRecursively (g, getWidth());
		}
	}

	TreeViewItem* findItemAt (int y, Rectangle<int>& itemPosition) const
	{
		if (owner.rootItem == nullptr)
			return nullptr;

		owner.recalculateIfNeeded();

		if (! owner.rootItemVisible)
			y += owner.rootItem->itemHeight;

		TreeViewItem* const ti = owner.rootItem->findItemRecursively (y);

		if (ti != nullptr)
			itemPosition = ti->getItemPosition (false);

		return ti;
	}

	void updateComponents()
	{
		const int visibleTop = -getY();
		const int visibleBottom = visibleTop + getParentHeight();

		{
			for (int i = items.size(); --i >= 0;)
				items.getUnchecked(i)->shouldKeep = false;
		}

		{
			TreeViewItem* item = owner.rootItem;
			int y = (item != nullptr && ! owner.rootItemVisible) ? -item->itemHeight : 0;

			while (item != nullptr && y < visibleBottom)
			{
				y += item->itemHeight;

				if (y >= visibleTop)
				{
					RowItem* const ri = findItem (item->uid);

					if (ri != nullptr)
					{
						ri->shouldKeep = true;
					}
					else
					{
						Component* const comp = item->createItemComponent();

						if (comp != nullptr)
						{
							items.add (new RowItem (item, comp, item->uid));
							addAndMakeVisible (comp);
						}
					}
				}

				item = item->getNextVisibleItem (true);
			}
		}

		for (int i = items.size(); --i >= 0;)
		{
			RowItem* const ri = items.getUnchecked(i);
			bool keep = false;

			if (isParentOf (ri->component))
			{
				if (ri->shouldKeep)
				{
					Rectangle<int> pos (ri->item->getItemPosition (false));
					pos.setSize (pos.getWidth(), ri->item->itemHeight);

					if (pos.getBottom() >= visibleTop && pos.getY() < visibleBottom)
					{
						keep = true;
						ri->component->setBounds (pos);
					}
				}

				if ((! keep) && isMouseDraggingInChildCompOf (ri->component))
				{
					keep = true;
					ri->component->setSize (0, 0);
				}
			}

			if (! keep)
				items.remove (i);
		}
	}

	bool isMouseOverButton (TreeViewItem* const item) const noexcept
	{
		return item == buttonUnderMouse;
	}

	void resized()
	{
		owner.itemsChanged();
	}

	String getTooltip()
	{
		Rectangle<int> pos;
		TreeViewItem* const item = findItemAt (getMouseXYRelative().getY(), pos);

		if (item != nullptr)
			return item->getTooltip();

		return owner.getTooltip();
	}

private:

	TreeView& owner;

	struct RowItem
	{
		RowItem (TreeViewItem* const item_, Component* const component_, const int itemUID)
			: component (component_), item (item_), uid (itemUID), shouldKeep (true)
		{
		}

		~RowItem()
		{
			delete component.get();
		}

		WeakReference<Component> component;
		TreeViewItem* item;
		int uid;
		bool shouldKeep;
	};

	OwnedArray <RowItem> items;

	TreeViewItem* buttonUnderMouse;
	bool isDragging, needSelectionOnMouseUp;

	void selectBasedOnModifiers (TreeViewItem* const item, const ModifierKeys& modifiers)
	{
		TreeViewItem* firstSelected = nullptr;

		if (modifiers.isShiftDown() && ((firstSelected = owner.getSelectedItem (0)) != nullptr))
		{
			TreeViewItem* const lastSelected = owner.getSelectedItem (owner.getNumSelectedItems() - 1);
			jassert (lastSelected != nullptr);

			int rowStart = firstSelected->getRowNumberInTree();
			int rowEnd = lastSelected->getRowNumberInTree();
			if (rowStart > rowEnd)
				std::swap (rowStart, rowEnd);

			int ourRow = item->getRowNumberInTree();
			int otherEnd = ourRow < rowEnd ? rowStart : rowEnd;

			if (ourRow > otherEnd)
				std::swap (ourRow, otherEnd);

			for (int i = ourRow; i <= otherEnd; ++i)
				owner.getItemOnRow (i)->setSelected (true, false);
		}
		else
		{
			const bool cmd = modifiers.isCommandDown();
			item->setSelected ((! cmd) || ! item->isSelected(), ! cmd);
		}
	}

	bool containsItem (TreeViewItem* const item) const noexcept
	{
		for (int i = items.size(); --i >= 0;)
			if (items.getUnchecked(i)->item == item)
				return true;

		return false;
	}

	RowItem* findItem (const int uid) const noexcept
	{
		for (int i = items.size(); --i >= 0;)
		{
			RowItem* const ri = items.getUnchecked(i);
			if (ri->uid == uid)
				return ri;
		}

		return nullptr;
	}

	void updateButtonUnderMouse (const MouseEvent& e)
	{
		TreeViewItem* newItem = nullptr;

		if (owner.openCloseButtonsVisible)
		{
			Rectangle<int> pos;
			TreeViewItem* item = findItemAt (e.y, pos);

			if (item != nullptr && e.x < pos.getX() && e.x >= pos.getX() - owner.getIndentSize())
			{
				newItem = item;

				if (! newItem->mightContainSubItems())
					newItem = nullptr;
			}
		}

		if (buttonUnderMouse != newItem)
		{
			repaintButtonUnderMouse();
			buttonUnderMouse = newItem;
			repaintButtonUnderMouse();
		}
	}

	void repaintButtonUnderMouse()
	{
		if (buttonUnderMouse != nullptr && containsItem (buttonUnderMouse))
		{
			const Rectangle<int> r (buttonUnderMouse->getItemPosition (false));
			repaint (0, r.getY(), r.getX(), buttonUnderMouse->getItemHeight());
		}
	}

	static bool isMouseDraggingInChildCompOf (Component* const comp)
	{
		for (int i = Desktop::getInstance().getNumMouseSources(); --i >= 0;)
		{
			MouseInputSource* const source = Desktop::getInstance().getMouseSource(i);

			if (source->isDragging())
			{
				Component* const underMouse = source->getComponentUnderMouse();

				if (underMouse != nullptr && (comp == underMouse || comp->isParentOf (underMouse)))
					return true;
			}
		}

		return false;
	}

	void handleAsyncUpdate()
	{
		owner.recalculateIfNeeded();
	}

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (TreeViewContentComponent);
};

class TreeView::TreeViewport  : public Viewport
{
public:
	TreeViewport() noexcept : lastX (-1)    {}

	void updateComponents (const bool triggerResize)
	{
		TreeViewContentComponent* const tvc = getContentComp();

		if (tvc != nullptr)
		{
			if (triggerResize)
				tvc->resized();
			else
				tvc->updateComponents();
		}

		repaint();
	}

	void visibleAreaChanged (const Rectangle<int>& newVisibleArea)
	{
		const bool hasScrolledSideways = (newVisibleArea.getX() != lastX);
		lastX = newVisibleArea.getX();
		updateComponents (hasScrolledSideways);
	}

	TreeViewContentComponent* getContentComp() const noexcept
	{
		return static_cast <TreeViewContentComponent*> (getViewedComponent());
	}

	bool keyPressed (const KeyPress& key)
	{
		TreeView* const tree = dynamic_cast <TreeView*> (getParentComponent());

		return (tree != nullptr && tree->keyPressed (key))
				 || Viewport::keyPressed (key);
	}

private:
	int lastX;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (TreeViewport);
};

TreeView::TreeView (const String& name)
	: Component (name),
	  viewport (new TreeViewport()),
	  rootItem (nullptr),
	  indentSize (24),
	  defaultOpenness (false),
	  needsRecalculating (true),
	  rootItemVisible (true),
	  multiSelectEnabled (false),
	  openCloseButtonsVisible (true)
{
	addAndMakeVisible (viewport);
	viewport->setViewedComponent (new TreeViewContentComponent (*this));
	setWantsKeyboardFocus (true);
}

TreeView::~TreeView()
{
	if (rootItem != nullptr)
		rootItem->setOwnerView (nullptr);
}

void TreeView::setRootItem (TreeViewItem* const newRootItem)
{
	if (rootItem != newRootItem)
	{
		if (newRootItem != nullptr)
		{
			jassert (newRootItem->ownerView == nullptr); // can't use a tree item in more than one tree at once..

			if (newRootItem->ownerView != nullptr)
				newRootItem->ownerView->setRootItem (nullptr);
		}

		if (rootItem != nullptr)
			rootItem->setOwnerView (nullptr);

		rootItem = newRootItem;

		if (newRootItem != nullptr)
			newRootItem->setOwnerView (this);

		needsRecalculating = true;
		recalculateIfNeeded();

		if (rootItem != nullptr && (defaultOpenness || ! rootItemVisible))
		{
			rootItem->setOpen (false); // force a re-open
			rootItem->setOpen (true);
		}
	}
}

void TreeView::deleteRootItem()
{
	const ScopedPointer <TreeViewItem> deleter (rootItem);
	setRootItem (nullptr);
}

void TreeView::setRootItemVisible (const bool shouldBeVisible)
{
	rootItemVisible = shouldBeVisible;

	if (rootItem != nullptr && (defaultOpenness || ! rootItemVisible))
	{
		rootItem->setOpen (false); // force a re-open
		rootItem->setOpen (true);
	}

	itemsChanged();
}

void TreeView::colourChanged()
{
	setOpaque (findColour (backgroundColourId).isOpaque());
	repaint();
}

void TreeView::setIndentSize (const int newIndentSize)
{
	if (indentSize != newIndentSize)
	{
		indentSize = newIndentSize;
		resized();
	}
}

void TreeView::setDefaultOpenness (const bool isOpenByDefault)
{
	if (defaultOpenness != isOpenByDefault)
	{
		defaultOpenness = isOpenByDefault;
		itemsChanged();
	}
}

void TreeView::setMultiSelectEnabled (const bool canMultiSelect)
{
	multiSelectEnabled = canMultiSelect;
}

void TreeView::setOpenCloseButtonsVisible (const bool shouldBeVisible)
{
	if (openCloseButtonsVisible != shouldBeVisible)
	{
		openCloseButtonsVisible = shouldBeVisible;
		itemsChanged();
	}
}

Viewport* TreeView::getViewport() const noexcept
{
	return viewport;
}

void TreeView::clearSelectedItems()
{
	if (rootItem != nullptr)
		rootItem->deselectAllRecursively();
}

int TreeView::getNumSelectedItems (int maximumDepthToSearchTo) const noexcept
{
	return rootItem != nullptr ? rootItem->countSelectedItemsRecursively (maximumDepthToSearchTo) : 0;
}

TreeViewItem* TreeView::getSelectedItem (const int index) const noexcept
{
	return rootItem != nullptr ? rootItem->getSelectedItemWithIndex (index) : 0;
}

int TreeView::getNumRowsInTree() const
{
	if (rootItem != nullptr)
		return rootItem->getNumRows() - (rootItemVisible ? 0 : 1);

	return 0;
}

TreeViewItem* TreeView::getItemOnRow (int index) const
{
	if (! rootItemVisible)
		++index;

	if (rootItem != nullptr && index >= 0)
		return rootItem->getItemOnRow (index);

	return nullptr;
}

TreeViewItem* TreeView::getItemAt (int y) const noexcept
{
	TreeViewContentComponent* const tc = viewport->getContentComp();
	Rectangle<int> pos;
	return tc->findItemAt (tc->getLocalPoint (this, Point<int> (0, y)).getY(), pos);
}

TreeViewItem* TreeView::findItemFromIdentifierString (const String& identifierString) const
{
	if (rootItem == nullptr)
		return nullptr;

	return rootItem->findItemFromIdentifierString (identifierString);
}

static void addAllSelectedItemIds (TreeViewItem* item, XmlElement& parent)
{
	if (item->isSelected())
		parent.createNewChildElement ("SELECTED")->setAttribute ("id", item->getItemIdentifierString());

	const int numSubItems = item->getNumSubItems();

	for (int i = 0; i < numSubItems; ++i)
		addAllSelectedItemIds (item->getSubItem(i), parent);
}

XmlElement* TreeView::getOpennessState (const bool alsoIncludeScrollPosition) const
{
	XmlElement* e = nullptr;

	if (rootItem != nullptr)
	{
		e = rootItem->getOpennessState();

		if (e != nullptr)
		{
			if (alsoIncludeScrollPosition)
				e->setAttribute ("scrollPos", viewport->getViewPositionY());

			addAllSelectedItemIds (rootItem, *e);
		}
	}

	return e;
}

void TreeView::restoreOpennessState (const XmlElement& newState, const bool restoreStoredSelection)
{
	if (rootItem != nullptr)
	{
		rootItem->restoreOpennessState (newState);

		if (newState.hasAttribute ("scrollPos"))
			viewport->setViewPosition (viewport->getViewPositionX(),
									   newState.getIntAttribute ("scrollPos"));

		if (restoreStoredSelection)
		{
			clearSelectedItems();

			forEachXmlChildElementWithTagName (newState, e, "SELECTED")
			{
				TreeViewItem* const item = rootItem->findItemFromIdentifierString (e->getStringAttribute ("id"));

				if (item != nullptr)
					item->setSelected (true, false);
			}
		}
	}
}

void TreeView::paint (Graphics& g)
{
	g.fillAll (findColour (backgroundColourId));
}

void TreeView::resized()
{
	viewport->setBounds (getLocalBounds());

	itemsChanged();
	recalculateIfNeeded();
}

void TreeView::enablementChanged()
{
	repaint();
}

void TreeView::moveSelectedRow (const int delta)
{
	int rowSelected = 0;

	TreeViewItem* const firstSelected = getSelectedItem (0);
	if (firstSelected != nullptr)
		rowSelected = firstSelected->getRowNumberInTree();

	rowSelected = jlimit (0, getNumRowsInTree() - 1, rowSelected + delta);

	for (;;)
	{
		TreeViewItem* item = getItemOnRow (rowSelected);

		if (item != nullptr)
		{
			if (! item->canBeSelected())
			{
				// if the row we want to highlight doesn't allow it, try skipping
				// to the next item..
				const int nextRowToTry = jlimit (0, getNumRowsInTree() - 1,
												 rowSelected + (delta < 0 ? -1 : 1));

				if (rowSelected != nextRowToTry)
				{
					rowSelected = nextRowToTry;
					continue;
				}
				else
				{
					break;
				}
			}

			item->setSelected (true, true);

			scrollToKeepItemVisible (item);
		}

		break;
	}
}

void TreeView::scrollToKeepItemVisible (TreeViewItem* item)
{
	if (item != nullptr && item->ownerView == this)
	{
		recalculateIfNeeded();

		item = item->getDeepestOpenParentItem();

		const int y = item->y;
		const int viewTop = viewport->getViewPositionY();

		if (y < viewTop)
		{
			viewport->setViewPosition (viewport->getViewPositionX(), y);
		}
		else if (y + item->itemHeight > viewTop + viewport->getViewHeight())
		{
			viewport->setViewPosition (viewport->getViewPositionX(),
									   (y + item->itemHeight) - viewport->getViewHeight());
		}
	}
}

bool TreeView::keyPressed (const KeyPress& key)
{
	if (key.isKeyCode (KeyPress::upKey))
	{
		moveSelectedRow (-1);
	}
	else if (key.isKeyCode (KeyPress::downKey))
	{
		moveSelectedRow (1);
	}
	else if (key.isKeyCode (KeyPress::pageDownKey) || key.isKeyCode (KeyPress::pageUpKey))
	{
		if (rootItem != nullptr)
		{
			int rowsOnScreen = getHeight() / jmax (1, rootItem->itemHeight);

			if (key.isKeyCode (KeyPress::pageUpKey))
				rowsOnScreen = -rowsOnScreen;

			if (rowsOnScreen != 0)
				moveSelectedRow (rowsOnScreen);
		}
	}
	else if (key.isKeyCode (KeyPress::homeKey))
	{
		moveSelectedRow (-0x3fffffff);
	}
	else if (key.isKeyCode (KeyPress::endKey))
	{
		moveSelectedRow (0x3fffffff);
	}
	else if (key.isKeyCode (KeyPress::returnKey))
	{
		TreeViewItem* const firstSelected = getSelectedItem (0);
		if (firstSelected != nullptr)
			firstSelected->setOpen (! firstSelected->isOpen());
	}
	else if (key.isKeyCode (KeyPress::leftKey))
	{
		TreeViewItem* const firstSelected = getSelectedItem (0);

		if (firstSelected != nullptr)
		{
			if (firstSelected->isOpen())
			{
				firstSelected->setOpen (false);
			}
			else
			{
				TreeViewItem* parent = firstSelected->parentItem;

				if ((! rootItemVisible) && parent == rootItem)
					parent = nullptr;

				if (parent != nullptr)
				{
					parent->setSelected (true, true);
					scrollToKeepItemVisible (parent);
				}
			}
		}
	}
	else if (key.isKeyCode (KeyPress::rightKey))
	{
		TreeViewItem* const firstSelected = getSelectedItem (0);

		if (firstSelected != nullptr)
		{
			if (firstSelected->isOpen() || ! firstSelected->mightContainSubItems())
				moveSelectedRow (1);
			else
				firstSelected->setOpen (true);
		}
	}
	else
	{
		return false;
	}

	return true;
}

void TreeView::itemsChanged() noexcept
{
	needsRecalculating = true;
	repaint();
	viewport->getContentComp()->triggerAsyncUpdate();
}

void TreeView::recalculateIfNeeded()
{
	if (needsRecalculating)
	{
		needsRecalculating = false;

		const ScopedLock sl (nodeAlterationLock);

		if (rootItem != nullptr)
			rootItem->updatePositions (rootItemVisible ? 0 : -rootItem->itemHeight);

		viewport->updateComponents (false);

		if (rootItem != nullptr)
		{
			viewport->getViewedComponent()
				->setSize (jmax (viewport->getMaximumVisibleWidth(), rootItem->totalWidth),
						   rootItem->totalHeight - (rootItemVisible ? 0 : rootItem->itemHeight));
		}
		else
		{
			viewport->getViewedComponent()->setSize (0, 0);
		}
	}
}

class TreeView::InsertPointHighlight   : public Component
{
public:
	InsertPointHighlight()
		: lastItem (nullptr)
	{
		setSize (100, 12);
		setAlwaysOnTop (true);
		setInterceptsMouseClicks (false, false);
	}

	void setTargetPosition (TreeViewItem* const item, int insertIndex, const int x, const int y, const int width) noexcept
	{
		lastItem = item;
		lastIndex = insertIndex;
		const int offset = getHeight() / 2;
		setBounds (x - offset, y - offset, width - (x - offset), getHeight());
	}

	void paint (Graphics& g)
	{
		Path p;
		const float h = (float) getHeight();
		p.addEllipse (2.0f, 2.0f, h - 4.0f, h - 4.0f);
		p.startNewSubPath (h - 2.0f, h / 2.0f);
		p.lineTo ((float) getWidth(), h / 2.0f);

		g.setColour (findColour (TreeView::dragAndDropIndicatorColourId, true));
		g.strokePath (p, PathStrokeType (2.0f));
	}

	TreeViewItem* lastItem;
	int lastIndex;

private:
	JUCE_DECLARE_NON_COPYABLE (InsertPointHighlight);
};

class TreeView::TargetGroupHighlight   : public Component
{
public:
	TargetGroupHighlight()
	{
		setAlwaysOnTop (true);
		setInterceptsMouseClicks (false, false);
	}

	void setTargetPosition (TreeViewItem* const item) noexcept
	{
		Rectangle<int> r (item->getItemPosition (true));
		r.setHeight (item->getItemHeight());
		setBounds (r);
	}

	void paint (Graphics& g)
	{
		g.setColour (findColour (TreeView::dragAndDropIndicatorColourId, true));
		g.drawRoundedRectangle (1.0f, 1.0f, getWidth() - 2.0f, getHeight() - 2.0f, 3.0f, 2.0f);
	}

private:
	JUCE_DECLARE_NON_COPYABLE (TargetGroupHighlight);
};

void TreeView::showDragHighlight (TreeViewItem* item, int insertIndex, int x, int y) noexcept
{
	beginDragAutoRepeat (100);

	if (dragInsertPointHighlight == nullptr)
	{
		addAndMakeVisible (dragInsertPointHighlight = new InsertPointHighlight());
		addAndMakeVisible (dragTargetGroupHighlight = new TargetGroupHighlight());
	}

	dragInsertPointHighlight->setTargetPosition (item, insertIndex, x, y, viewport->getViewWidth());
	dragTargetGroupHighlight->setTargetPosition (item);
}

void TreeView::hideDragHighlight() noexcept
{
	dragInsertPointHighlight = nullptr;
	dragTargetGroupHighlight = nullptr;
}

TreeViewItem* TreeView::getInsertPosition (int& x, int& y, int& insertIndex,
										   const StringArray& files, const SourceDetails& dragSourceDetails) const noexcept
{
	x = dragSourceDetails.localPosition.getX();
	y = dragSourceDetails.localPosition.getY();
	insertIndex = 0;
	TreeViewItem* item = getItemAt (y);

	if (item == nullptr)
		return nullptr;

	Rectangle<int> itemPos (item->getItemPosition (true));
	insertIndex = item->getIndexInParent();
	const int oldY = y;
	y = itemPos.getY();

	if (item->getNumSubItems() == 0 || ! item->isOpen())
	{
		if (files.size() > 0 ? item->isInterestedInFileDrag (files)
							 : item->isInterestedInDragSource (dragSourceDetails))
		{
			// Check if we're trying to drag into an empty group item..
			if (oldY > itemPos.getY() + itemPos.getHeight() / 4
				 && oldY < itemPos.getBottom() - itemPos.getHeight() / 4)
			{
				insertIndex = 0;
				x = itemPos.getX() + getIndentSize();
				y = itemPos.getBottom();
				return item;
			}
		}
	}

	if (oldY > itemPos.getCentreY())
	{
		y += item->getItemHeight();

		while (item->isLastOfSiblings() && item->parentItem != nullptr
				&& item->parentItem->parentItem != nullptr)
		{
			if (x > itemPos.getX())
				break;

			item = item->parentItem;
			itemPos = item->getItemPosition (true);
			insertIndex = item->getIndexInParent();
		}

		++insertIndex;
	}

	x = itemPos.getX();
	return item->parentItem;
}

void TreeView::handleDrag (const StringArray& files, const SourceDetails& dragSourceDetails)
{
	const bool scrolled = viewport->autoScroll (dragSourceDetails.localPosition.getX(),
												dragSourceDetails.localPosition.getY(), 20, 10);

	int insertIndex, x, y;
	TreeViewItem* const item = getInsertPosition (x, y, insertIndex, files, dragSourceDetails);

	if (item != nullptr)
	{
		if (scrolled || dragInsertPointHighlight == nullptr
			 || dragInsertPointHighlight->lastItem != item
			 || dragInsertPointHighlight->lastIndex != insertIndex)
		{
			if (files.size() > 0 ? item->isInterestedInFileDrag (files)
								 : item->isInterestedInDragSource (dragSourceDetails))
				showDragHighlight (item, insertIndex, x, y);
			else
				hideDragHighlight();
		}
	}
	else
	{
		hideDragHighlight();
	}
}

void TreeView::handleDrop (const StringArray& files, const SourceDetails& dragSourceDetails)
{
	hideDragHighlight();

	int insertIndex, x, y;
	TreeViewItem* item = getInsertPosition (x, y, insertIndex, files, dragSourceDetails);

	if (item == nullptr)
	{
		insertIndex = 0;
		item = rootItem;
	}

	if (item != nullptr)
	{
		if (files.size() > 0)
		{
			if (item->isInterestedInFileDrag (files))
				item->filesDropped (files, insertIndex);
		}
		else
		{
			if (item->isInterestedInDragSource (dragSourceDetails))
				item->itemDropped (dragSourceDetails, insertIndex);
		}
	}
}

bool TreeView::isInterestedInFileDrag (const StringArray&)
{
	return true;
}

void TreeView::fileDragEnter (const StringArray& files, int x, int y)
{
	fileDragMove (files, x, y);
}

void TreeView::fileDragMove (const StringArray& files, int x, int y)
{
	handleDrag (files, SourceDetails (String::empty, 0, Point<int> (x, y)));
}

void TreeView::fileDragExit (const StringArray&)
{
	hideDragHighlight();
}

void TreeView::filesDropped (const StringArray& files, int x, int y)
{
	handleDrop (files, SourceDetails (String::empty, 0, Point<int> (x, y)));
}

bool TreeView::isInterestedInDragSource (const SourceDetails& /*dragSourceDetails*/)
{
	return true;
}

void TreeView::itemDragEnter (const SourceDetails& dragSourceDetails)
{
	itemDragMove (dragSourceDetails);
}

void TreeView::itemDragMove (const SourceDetails& dragSourceDetails)
{
	handleDrag (StringArray(), dragSourceDetails);
}

void TreeView::itemDragExit (const SourceDetails& /*dragSourceDetails*/)
{
	hideDragHighlight();
}

void TreeView::itemDropped (const SourceDetails& dragSourceDetails)
{
	handleDrop (StringArray(), dragSourceDetails);
}

enum TreeViewOpenness
{
	opennessDefault = 0,
	opennessClosed = 1,
	opennessOpen = 2
};

TreeViewItem::TreeViewItem()
	: ownerView (nullptr),
	  parentItem (nullptr),
	  y (0),
	  itemHeight (0),
	  totalHeight (0),
	  selected (false),
	  redrawNeeded (true),
	  drawLinesInside (true),
	  drawsInLeftMargin (false),
	  openness (opennessDefault)
{
	static int nextUID = 0;
	uid = nextUID++;
}

TreeViewItem::~TreeViewItem()
{
}

String TreeViewItem::getUniqueName() const
{
	return String::empty;
}

void TreeViewItem::itemOpennessChanged (bool)
{
}

int TreeViewItem::getNumSubItems() const noexcept
{
	return subItems.size();
}

TreeViewItem* TreeViewItem::getSubItem (const int index) const noexcept
{
	return subItems [index];
}

void TreeViewItem::clearSubItems()
{
	if (subItems.size() > 0)
	{
		if (ownerView != nullptr)
		{
			const ScopedLock sl (ownerView->nodeAlterationLock);
			subItems.clear();
			treeHasChanged();
		}
		else
		{
			subItems.clear();
		}
	}
}

void TreeViewItem::addSubItem (TreeViewItem* const newItem, const int insertPosition)
{
	if (newItem != nullptr)
	{
		newItem->parentItem = this;
		newItem->setOwnerView (ownerView);
		newItem->y = 0;
		newItem->itemHeight = newItem->getItemHeight();
		newItem->totalHeight = 0;
		newItem->itemWidth = newItem->getItemWidth();
		newItem->totalWidth = 0;

		if (ownerView != nullptr)
		{
			const ScopedLock sl (ownerView->nodeAlterationLock);
			subItems.insert (insertPosition, newItem);
			treeHasChanged();

			if (newItem->isOpen())
				newItem->itemOpennessChanged (true);
		}
		else
		{
			subItems.insert (insertPosition, newItem);

			if (newItem->isOpen())
				newItem->itemOpennessChanged (true);
		}
	}
}

void TreeViewItem::removeSubItem (const int index, const bool deleteItem)
{
	if (ownerView != nullptr)
	{
		const ScopedLock sl (ownerView->nodeAlterationLock);

		if (isPositiveAndBelow (index, subItems.size()))
		{
			subItems.remove (index, deleteItem);
			treeHasChanged();
		}
	}
	else
	{
		subItems.remove (index, deleteItem);
	}
}

bool TreeViewItem::isOpen() const noexcept
{
	if (openness == opennessDefault)
		return ownerView != nullptr && ownerView->defaultOpenness;
	else
		return openness == opennessOpen;
}

void TreeViewItem::setOpen (const bool shouldBeOpen)
{
	if (isOpen() != shouldBeOpen)
	{
		openness = shouldBeOpen ? opennessOpen
								: opennessClosed;
		treeHasChanged();

		itemOpennessChanged (isOpen());
	}
}

bool TreeViewItem::isSelected() const noexcept
{
	return selected;
}

void TreeViewItem::deselectAllRecursively()
{
	setSelected (false, false);

	for (int i = 0; i < subItems.size(); ++i)
		subItems.getUnchecked(i)->deselectAllRecursively();
}

void TreeViewItem::setSelected (const bool shouldBeSelected,
								const bool deselectOtherItemsFirst)
{
	if (shouldBeSelected && ! canBeSelected())
		return;

	if (deselectOtherItemsFirst)
		getTopLevelItem()->deselectAllRecursively();

	if (shouldBeSelected != selected)
	{
		selected = shouldBeSelected;
		if (ownerView != nullptr)
			ownerView->repaint();

		itemSelectionChanged (shouldBeSelected);
	}
}

void TreeViewItem::paintItem (Graphics&, int, int)
{
}

void TreeViewItem::paintOpenCloseButton (Graphics& g, int width, int height, bool isMouseOver)
{
	ownerView->getLookAndFeel()
	   .drawTreeviewPlusMinusBox (g, 0, 0, width, height, ! isOpen(), isMouseOver);
}

void TreeViewItem::itemClicked (const MouseEvent&)
{
}

void TreeViewItem::itemDoubleClicked (const MouseEvent&)
{
	if (mightContainSubItems())
		setOpen (! isOpen());
}

void TreeViewItem::itemSelectionChanged (bool)
{
}

String TreeViewItem::getTooltip()
{
	return String::empty;
}

var TreeViewItem::getDragSourceDescription()
{
	return var::null;
}

bool TreeViewItem::isInterestedInFileDrag (const StringArray&)
{
	return false;
}

void TreeViewItem::filesDropped (const StringArray& /*files*/, int /*insertIndex*/)
{
}

bool TreeViewItem::isInterestedInDragSource (const DragAndDropTarget::SourceDetails& /*dragSourceDetails*/)
{
	return false;
}

void TreeViewItem::itemDropped (const DragAndDropTarget::SourceDetails& /*dragSourceDetails*/, int /*insertIndex*/)
{
}

Rectangle<int> TreeViewItem::getItemPosition (const bool relativeToTreeViewTopLeft) const noexcept
{
	const int indentX = getIndentX();
	int width = itemWidth;

	if (ownerView != nullptr && width < 0)
		width = ownerView->viewport->getViewWidth() - indentX;

	Rectangle<int> r (indentX, y, jmax (0, width), totalHeight);

	if (relativeToTreeViewTopLeft)
		r -= ownerView->viewport->getViewPosition();

	return r;
}

void TreeViewItem::treeHasChanged() const noexcept
{
	if (ownerView != nullptr)
		ownerView->itemsChanged();
}

void TreeViewItem::repaintItem() const
{
	if (ownerView != nullptr && areAllParentsOpen())
	{
		Rectangle<int> r (getItemPosition (true));
		r.setLeft (0);
		ownerView->viewport->repaint (r);
	}
}

bool TreeViewItem::areAllParentsOpen() const noexcept
{
	return parentItem == nullptr
			|| (parentItem->isOpen() && parentItem->areAllParentsOpen());
}

void TreeViewItem::updatePositions (int newY)
{
	y = newY;
	itemHeight = getItemHeight();
	totalHeight = itemHeight;
	itemWidth = getItemWidth();
	totalWidth = jmax (itemWidth, 0) + getIndentX();

	if (isOpen())
	{
		newY += totalHeight;

		for (int i = 0; i < subItems.size(); ++i)
		{
			TreeViewItem* const ti = subItems.getUnchecked(i);

			ti->updatePositions (newY);
			newY += ti->totalHeight;
			totalHeight += ti->totalHeight;
			totalWidth = jmax (totalWidth, ti->totalWidth);
		}
	}
}

TreeViewItem* TreeViewItem::getDeepestOpenParentItem() noexcept
{
	TreeViewItem* result = this;
	TreeViewItem* item = this;

	while (item->parentItem != nullptr)
	{
		item = item->parentItem;

		if (! item->isOpen())
			result = item;
	}

	return result;
}

void TreeViewItem::setOwnerView (TreeView* const newOwner) noexcept
{
	ownerView = newOwner;

	for (int i = subItems.size(); --i >= 0;)
		subItems.getUnchecked(i)->setOwnerView (newOwner);
}

int TreeViewItem::getIndentX() const noexcept
{
	const int indentWidth = ownerView->getIndentSize();
	int x = ownerView->rootItemVisible ? indentWidth : 0;

	if (! ownerView->openCloseButtonsVisible)
		x -= indentWidth;

	TreeViewItem* p = parentItem;

	while (p != nullptr)
	{
		x += indentWidth;
		p = p->parentItem;
	}

	return x;
}

void TreeViewItem::setDrawsInLeftMargin (bool canDrawInLeftMargin) noexcept
{
	drawsInLeftMargin = canDrawInLeftMargin;
}

namespace TreeViewHelpers
{
	int calculateDepth (const TreeViewItem* item, const bool rootIsVisible) noexcept
	{
		jassert (item != nullptr);
		int depth = rootIsVisible ? 0 : -1;

		for (const TreeViewItem* p = item->getParentItem(); p != nullptr; p = p->getParentItem())
			++depth;

		return depth;
	}
}

void TreeViewItem::paintRecursively (Graphics& g, int width)
{
	jassert (ownerView != nullptr);
	if (ownerView == nullptr)
		return;

	const int indent = getIndentX();
	const int itemW = itemWidth < 0 ? width - indent : itemWidth;

	{
		Graphics::ScopedSaveState ss (g);
		g.setOrigin (indent, 0);

		if (g.reduceClipRegion (drawsInLeftMargin ? -indent : 0, 0,
								drawsInLeftMargin ? itemW + indent : itemW, itemHeight))
			paintItem (g, itemW, itemHeight);
	}

	g.setColour (ownerView->findColour (TreeView::linesColourId));

	const float halfH = itemHeight * 0.5f;
	const int indentWidth = ownerView->getIndentSize();
	const int depth = TreeViewHelpers::calculateDepth (this, ownerView->rootItemVisible);

	if (depth >= 0 && ownerView->openCloseButtonsVisible)
	{
		float x = (depth + 0.5f) * indentWidth;

		if (parentItem != nullptr && parentItem->drawLinesInside)
			g.drawLine (x, 0, x, isLastOfSiblings() ? halfH : (float) itemHeight);

		if ((parentItem != nullptr && parentItem->drawLinesInside)
			 || (parentItem == nullptr && drawLinesInside))
			g.drawLine (x, halfH, x + indentWidth / 2, halfH);

		{
			TreeViewItem* p = parentItem;
			int d = depth;

			while (p != nullptr && --d >= 0)
			{
				x -= (float) indentWidth;

				if ((p->parentItem == nullptr || p->parentItem->drawLinesInside)
					 && ! p->isLastOfSiblings())
				{
					g.drawLine (x, 0, x, (float) itemHeight);
				}

				p = p->parentItem;
			}
		}

		if (mightContainSubItems())
		{
			Graphics::ScopedSaveState ss (g);

			g.setOrigin (depth * indentWidth, 0);
			g.reduceClipRegion (0, 0, indentWidth, itemHeight);

			paintOpenCloseButton (g, indentWidth, itemHeight,
								  ownerView->viewport->getContentComp()->isMouseOverButton (this));
		}
	}

	if (isOpen())
	{
		const Rectangle<int> clip (g.getClipBounds());

		for (int i = 0; i < subItems.size(); ++i)
		{
			TreeViewItem* const ti = subItems.getUnchecked(i);

			const int relY = ti->y - y;

			if (relY >= clip.getBottom())
				break;

			if (relY + ti->totalHeight >= clip.getY())
			{
				Graphics::ScopedSaveState ss (g);

				g.setOrigin (0, relY);

				if (g.reduceClipRegion (0, 0, width, ti->totalHeight))
					ti->paintRecursively (g, width);
			}
		}
	}
}

bool TreeViewItem::isLastOfSiblings() const noexcept
{
	return parentItem == nullptr
			|| parentItem->subItems.getLast() == this;
}

int TreeViewItem::getIndexInParent() const noexcept
{
	return parentItem == nullptr ? 0
								 : parentItem->subItems.indexOf (this);
}

TreeViewItem* TreeViewItem::getTopLevelItem() noexcept
{
	return parentItem == nullptr ? this
								 : parentItem->getTopLevelItem();
}

int TreeViewItem::getNumRows() const noexcept
{
	int num = 1;

	if (isOpen())
	{
		for (int i = subItems.size(); --i >= 0;)
			num += subItems.getUnchecked(i)->getNumRows();
	}

	return num;
}

TreeViewItem* TreeViewItem::getItemOnRow (int index) noexcept
{
	if (index == 0)
		return this;

	if (index > 0 && isOpen())
	{
		--index;

		for (int i = 0; i < subItems.size(); ++i)
		{
			TreeViewItem* const item = subItems.getUnchecked(i);

			if (index == 0)
				return item;

			const int numRows = item->getNumRows();

			if (numRows > index)
				return item->getItemOnRow (index);

			index -= numRows;
		}
	}

	return nullptr;
}

TreeViewItem* TreeViewItem::findItemRecursively (int targetY) noexcept
{
	if (isPositiveAndBelow (targetY, totalHeight))
	{
		const int h = itemHeight;

		if (targetY < h)
			return this;

		if (isOpen())
		{
			targetY -= h;

			for (int i = 0; i < subItems.size(); ++i)
			{
				TreeViewItem* const ti = subItems.getUnchecked(i);

				if (targetY < ti->totalHeight)
					return ti->findItemRecursively (targetY);

				targetY -= ti->totalHeight;
			}
		}
	}

	return nullptr;
}

int TreeViewItem::countSelectedItemsRecursively (int depth) const noexcept
{
	int total = isSelected() ? 1 : 0;

	if (depth != 0)
		for (int i = subItems.size(); --i >= 0;)
			total += subItems.getUnchecked(i)->countSelectedItemsRecursively (depth - 1);

	return total;
}

TreeViewItem* TreeViewItem::getSelectedItemWithIndex (int index) noexcept
{
	if (isSelected())
	{
		if (index == 0)
			return this;

		--index;
	}

	if (index >= 0)
	{
		for (int i = 0; i < subItems.size(); ++i)
		{
			TreeViewItem* const item = subItems.getUnchecked(i);

			TreeViewItem* const found = item->getSelectedItemWithIndex (index);

			if (found != nullptr)
				return found;

			index -= item->countSelectedItemsRecursively (-1);
		}
	}

	return nullptr;
}

int TreeViewItem::getRowNumberInTree() const noexcept
{
	if (parentItem != nullptr && ownerView != nullptr)
	{
		int n = 1 + parentItem->getRowNumberInTree();

		int ourIndex = parentItem->subItems.indexOf (this);
		jassert (ourIndex >= 0);

		while (--ourIndex >= 0)
			n += parentItem->subItems [ourIndex]->getNumRows();

		if (parentItem->parentItem == nullptr
			 && ! ownerView->rootItemVisible)
			--n;

		return n;
	}
	else
	{
		return 0;
	}
}

void TreeViewItem::setLinesDrawnForSubItems (const bool drawLines) noexcept
{
	drawLinesInside = drawLines;
}

TreeViewItem* TreeViewItem::getNextVisibleItem (const bool recurse) const noexcept
{
	if (recurse && isOpen() && subItems.size() > 0)
		return subItems [0];

	if (parentItem != nullptr)
	{
		const int nextIndex = parentItem->subItems.indexOf (this) + 1;

		if (nextIndex >= parentItem->subItems.size())
			return parentItem->getNextVisibleItem (false);

		return parentItem->subItems [nextIndex];
	}

	return nullptr;
}

String TreeViewItem::getItemIdentifierString() const
{
	String s;

	if (parentItem != nullptr)
		s = parentItem->getItemIdentifierString();

	return s + "/" + getUniqueName().replaceCharacter ('/', '\\');
}

TreeViewItem* TreeViewItem::findItemFromIdentifierString (const String& identifierString)
{
	const String thisId (getUniqueName());

	if (thisId == identifierString)
		return this;

	if (identifierString.startsWith (thisId + "/"))
	{
		const String remainingPath (identifierString.substring (thisId.length() + 1));

		const bool wasOpen = isOpen();
		setOpen (true);

		for (int i = subItems.size(); --i >= 0;)
		{
			TreeViewItem* item = subItems.getUnchecked(i)->findItemFromIdentifierString (remainingPath);

			if (item != nullptr)
				return item;
		}

		setOpen (wasOpen);
	}

	return nullptr;
}

void TreeViewItem::restoreOpennessState (const XmlElement& e) noexcept
{
	if (e.hasTagName ("CLOSED"))
	{
		setOpen (false);
	}
	else if (e.hasTagName ("OPEN"))
	{
		setOpen (true);

		forEachXmlChildElement (e, n)
		{
			const String id (n->getStringAttribute ("id"));

			for (int i = 0; i < subItems.size(); ++i)
			{
				TreeViewItem* const ti = subItems.getUnchecked(i);

				if (ti->getUniqueName() == id)
				{
					ti->restoreOpennessState (*n);
					break;
				}
			}
		}
	}
}

XmlElement* TreeViewItem::getOpennessState() const noexcept
{
	const String name (getUniqueName());

	if (name.isNotEmpty())
	{
		XmlElement* e;

		if (isOpen())
		{
			e = new XmlElement ("OPEN");

			for (int i = 0; i < subItems.size(); ++i)
				e->addChildElement (subItems.getUnchecked(i)->getOpennessState());
		}
		else
		{
			e = new XmlElement ("CLOSED");
		}

		e->setAttribute ("id", name);

		return e;
	}
	else
	{
		// trying to save the openness for an element that has no name - this won't
		// work because it needs the names to identify what to open.
		jassertfalse;
	}

	return nullptr;
}

TreeViewItem::OpennessRestorer::OpennessRestorer (TreeViewItem& treeViewItem_)
	: treeViewItem (treeViewItem_),
	  oldOpenness (treeViewItem_.getOpennessState())
{
}

TreeViewItem::OpennessRestorer::~OpennessRestorer()
{
	if (oldOpenness != nullptr)
		treeViewItem.restoreOpennessState (*oldOpenness);
}

/*** End of inlined file: juce_TreeView.cpp ***/


/*** Start of inlined file: juce_AlertWindow.cpp ***/
class AlertWindowTextEditor  : public TextEditor
{
public:
	AlertWindowTextEditor (const String& name, const bool isPasswordBox)
		: TextEditor (name, isPasswordBox ? getDefaultPasswordChar() :  0)
	{
		setSelectAllWhenFocused (true);
	}

	void returnPressed()
	{
		// pass these up the component hierarchy to be trigger the buttons
		getParentComponent()->keyPressed (KeyPress (KeyPress::returnKey, 0, '\n'));
	}

	void escapePressed()
	{
		// pass these up the component hierarchy to be trigger the buttons
		getParentComponent()->keyPressed (KeyPress (KeyPress::escapeKey, 0, 0));
	}

private:
	JUCE_DECLARE_NON_COPYABLE (AlertWindowTextEditor);

	static juce_wchar getDefaultPasswordChar() noexcept
	{
	  #if JUCE_LINUX
		return 0x2022;
	  #else
		return 0x25cf;
	  #endif
	}
};

AlertWindow::AlertWindow (const String& title,
						  const String& message,
						  AlertIconType iconType,
						  Component* associatedComponent_)
   : TopLevelWindow (title, true),
	 alertIconType (iconType),
	 associatedComponent (associatedComponent_),
	 escapeKeyCancels (true)
{
	if (message.isEmpty())
		text = " "; // to force an update if the message is empty

	setMessage (message);

	for (int i = Desktop::getInstance().getNumComponents(); --i >= 0;)
	{
		Component* const c = Desktop::getInstance().getComponent (i);

		if (c != nullptr && c->isAlwaysOnTop() && c->isShowing())
		{
			setAlwaysOnTop (true);
			break;
		}
	}

	if (! JUCEApplication::isStandaloneApp())
		setAlwaysOnTop (true); // for a plugin, make it always-on-top because the host windows are often top-level

	AlertWindow::lookAndFeelChanged();

	constrainer.setMinimumOnscreenAmounts (0x10000, 0x10000, 0x10000, 0x10000);
}

AlertWindow::~AlertWindow()
{
	removeAllChildren();
}

void AlertWindow::userTriedToCloseWindow()
{
	if (escapeKeyCancels || buttons.size() > 0)
		exitModalState (0);
}

void AlertWindow::setMessage (const String& message)
{
	const String newMessage (message.substring (0, 2048));

	if (text != newMessage)
	{
		text = newMessage;
		updateLayout (true);
		repaint();
	}
}

void AlertWindow::buttonClicked (Button* button)
{
	if (button->getParentComponent() != nullptr)
		button->getParentComponent()->exitModalState (button->getCommandID());
}

void AlertWindow::addButton (const String& name,
							 const int returnValue,
							 const KeyPress& shortcutKey1,
							 const KeyPress& shortcutKey2)
{
	TextButton* const b = new TextButton (name, String::empty);
	buttons.add (b);

	b->setWantsKeyboardFocus (true);
	b->setMouseClickGrabsKeyboardFocus (false);
	b->setCommandToTrigger (0, returnValue, false);
	b->addShortcut (shortcutKey1);
	b->addShortcut (shortcutKey2);
	b->addListener (this);
	b->changeWidthToFitText (getLookAndFeel().getAlertWindowButtonHeight());

	addAndMakeVisible (b, 0);

	updateLayout (false);
}

int AlertWindow::getNumButtons() const
{
	return buttons.size();
}

void AlertWindow::triggerButtonClick (const String& buttonName)
{
	for (int i = buttons.size(); --i >= 0;)
	{
		TextButton* const b = buttons.getUnchecked(i);

		if (buttonName == b->getName())
		{
			b->triggerClick();
			break;
		}
	}
}

void AlertWindow::setEscapeKeyCancels (bool shouldEscapeKeyCancel)
{
	escapeKeyCancels = shouldEscapeKeyCancel;
}

void AlertWindow::addTextEditor (const String& name,
								 const String& initialContents,
								 const String& onScreenLabel,
								 const bool isPasswordBox)
{
	AlertWindowTextEditor* const tc = new AlertWindowTextEditor (name, isPasswordBox);
	textBoxes.add (tc);
	allComps.add (tc);

	tc->setColour (TextEditor::outlineColourId, findColour (ComboBox::outlineColourId));
	tc->setFont (getLookAndFeel().getAlertWindowMessageFont());
	tc->setText (initialContents);
	tc->setCaretPosition (initialContents.length());
	addAndMakeVisible (tc);
	textboxNames.add (onScreenLabel);

	updateLayout (false);
}

TextEditor* AlertWindow::getTextEditor (const String& nameOfTextEditor) const
{
	for (int i = textBoxes.size(); --i >= 0;)
		if (textBoxes.getUnchecked(i)->getName() == nameOfTextEditor)
			return textBoxes.getUnchecked(i);

	return nullptr;
}

String AlertWindow::getTextEditorContents (const String& nameOfTextEditor) const
{
	TextEditor* const t = getTextEditor (nameOfTextEditor);
	return t != nullptr ? t->getText() : String::empty;
}

void AlertWindow::addComboBox (const String& name,
							   const StringArray& items,
							   const String& onScreenLabel)
{
	ComboBox* const cb = new ComboBox (name);
	comboBoxes.add (cb);
	allComps.add (cb);

	cb->addItemList (items, 1);

	addAndMakeVisible (cb);
	cb->setSelectedItemIndex (0);

	comboBoxNames.add (onScreenLabel);
	updateLayout (false);
}

ComboBox* AlertWindow::getComboBoxComponent (const String& nameOfList) const
{
	for (int i = comboBoxes.size(); --i >= 0;)
		if (comboBoxes.getUnchecked(i)->getName() == nameOfList)
			return comboBoxes.getUnchecked(i);

	return nullptr;
}

class AlertTextComp : public TextEditor
{
public:
	AlertTextComp (const String& message,
				   const Font& font)
	{
		setReadOnly (true);
		setMultiLine (true, true);
		setCaretVisible (false);
		setScrollbarsShown (true);
		lookAndFeelChanged();
		setWantsKeyboardFocus (false);

		setFont (font);
		setText (message, false);

		bestWidth = 2 * (int) std::sqrt (font.getHeight() * font.getStringWidth (message));

		setColour (TextEditor::backgroundColourId, Colours::transparentBlack);
		setColour (TextEditor::outlineColourId, Colours::transparentBlack);
		setColour (TextEditor::shadowColourId, Colours::transparentBlack);
	}

	int getPreferredWidth() const noexcept   { return bestWidth; }

	void updateLayout (const int width)
	{
		AttributedString s;
		s.setJustification (Justification::topLeft);
		s.append (getName(), getFont());

		TextLayout text;
		text.createLayoutWithBalancedLineLengths (s, width - 8.0f);
		setSize (width, jmin (width, (int) (text.getHeight() + getFont().getHeight())));
	}

private:
	int bestWidth;

	JUCE_DECLARE_NON_COPYABLE (AlertTextComp);
};

void AlertWindow::addTextBlock (const String& textBlock)
{
	AlertTextComp* const c = new AlertTextComp (textBlock, getLookAndFeel().getAlertWindowMessageFont());
	textBlocks.add (c);
	allComps.add (c);

	addAndMakeVisible (c);

	updateLayout (false);
}

void AlertWindow::addProgressBarComponent (double& progressValue)
{
	ProgressBar* const pb = new ProgressBar (progressValue);
	progressBars.add (pb);
	allComps.add (pb);

	addAndMakeVisible (pb);

	updateLayout (false);
}

void AlertWindow::addCustomComponent (Component* const component)
{
	customComps.add (component);
	allComps.add (component);

	addAndMakeVisible (component);

	updateLayout (false);
}

int AlertWindow::getNumCustomComponents() const
{
	return customComps.size();
}

Component* AlertWindow::getCustomComponent (const int index) const
{
	return customComps [index];
}

Component* AlertWindow::removeCustomComponent (const int index)
{
	Component* const c = getCustomComponent (index);

	if (c != nullptr)
	{
		customComps.removeValue (c);
		allComps.removeValue (c);
		removeChildComponent (c);

		updateLayout (false);
	}

	return c;
}

void AlertWindow::paint (Graphics& g)
{
	getLookAndFeel().drawAlertBox (g, *this, textArea, textLayout);

	g.setColour (findColour (textColourId));
	g.setFont (getLookAndFeel().getAlertWindowFont());

	int i;
	for (i = textBoxes.size(); --i >= 0;)
	{
		const TextEditor* const te = textBoxes.getUnchecked(i);

		g.drawFittedText (textboxNames[i],
						  te->getX(), te->getY() - 14,
						  te->getWidth(), 14,
						  Justification::centredLeft, 1);
	}

	for (i = comboBoxNames.size(); --i >= 0;)
	{
		const ComboBox* const cb = comboBoxes.getUnchecked(i);

		g.drawFittedText (comboBoxNames[i],
						  cb->getX(), cb->getY() - 14,
						  cb->getWidth(), 14,
						  Justification::centredLeft, 1);
	}

	for (i = customComps.size(); --i >= 0;)
	{
		const Component* const c = customComps.getUnchecked(i);

		g.drawFittedText (c->getName(),
						  c->getX(), c->getY() - 14,
						  c->getWidth(), 14,
						  Justification::centredLeft, 1);
	}
}

void AlertWindow::updateLayout (const bool onlyIncreaseSize)
{
	const int titleH = 24;
	const int iconWidth = 80;

	const Font font (getLookAndFeel().getAlertWindowMessageFont());

	const int wid = jmax (font.getStringWidth (text),
						  font.getStringWidth (getName()));

	const int sw = (int) std::sqrt (font.getHeight() * wid);
	int w = jmin (300 + sw * 2, (int) (getParentWidth() * 0.7f));
	const int edgeGap = 10;
	const int labelHeight = 18;
	int iconSpace = 0;

	AttributedString attributedText;
	attributedText.append (getName(), Font (font.getHeight() * 1.1f, Font::bold));

	if (text.isNotEmpty())
		attributedText.append ("\n\n" + text, font);

	attributedText.setColour (findColour (textColourId));

	if (alertIconType == NoIcon)
	{
		attributedText.setJustification (Justification::centredTop);
		textLayout.createLayoutWithBalancedLineLengths (attributedText, (float) w);
	}
	else
	{
		attributedText.setJustification (Justification::topLeft);
		textLayout.createLayoutWithBalancedLineLengths (attributedText, (float) w);
		iconSpace = iconWidth;
	}

	w = jmax (350, (int) textLayout.getWidth() + iconSpace + edgeGap * 4);
	w = jmin (w, (int) (getParentWidth() * 0.7f));

	const int textLayoutH = (int) textLayout.getHeight();
	const int textBottom = 16 + titleH + textLayoutH;
	int h = textBottom;

	int buttonW = 40;
	int i;
	for (i = 0; i < buttons.size(); ++i)
		buttonW += 16 + buttons.getUnchecked(i)->getWidth();

	w = jmax (buttonW, w);

	h += (textBoxes.size() + comboBoxes.size() + progressBars.size()) * 50;

	if (buttons.size() > 0)
		h += 20 + buttons.getUnchecked(0)->getHeight();

	for (i = customComps.size(); --i >= 0;)
	{
		Component* c = customComps.getUnchecked(i);
		w = jmax (w, (c->getWidth() * 100) / 80);
		h += 10 + c->getHeight();

		if (c->getName().isNotEmpty())
			h += labelHeight;
	}

	for (i = textBlocks.size(); --i >= 0;)
	{
		const AlertTextComp* const ac = static_cast <const AlertTextComp*> (textBlocks.getUnchecked(i));
		w = jmax (w, ac->getPreferredWidth());
	}

	w = jmin (w, (int) (getParentWidth() * 0.7f));

	for (i = textBlocks.size(); --i >= 0;)
	{
		AlertTextComp* const ac = static_cast <AlertTextComp*> (textBlocks.getUnchecked(i));
		ac->updateLayout ((int) (w * 0.8f));
		h += ac->getHeight() + 10;
	}

	h = jmin (getParentHeight() - 50, h);

	if (onlyIncreaseSize)
	{
		w = jmax (w, getWidth());
		h = jmax (h, getHeight());
	}

	if (! isVisible())
	{
		centreAroundComponent (associatedComponent, w, h);
	}
	else
	{
		const int cx = getX() + getWidth() / 2;
		const int cy = getY() + getHeight() / 2;

		setBounds (cx - w / 2,
				   cy - h / 2,
				   w, h);
	}

	textArea.setBounds (edgeGap, edgeGap, w - (edgeGap * 2), h - edgeGap);

	const int spacer = 16;
	int totalWidth = -spacer;

	for (i = buttons.size(); --i >= 0;)
		totalWidth += buttons.getUnchecked(i)->getWidth() + spacer;

	int x = (w - totalWidth) / 2;
	int y = (int) (getHeight() * 0.95f);

	for (i = 0; i < buttons.size(); ++i)
	{
		TextButton* const c = buttons.getUnchecked(i);
		int ny = proportionOfHeight (0.95f) - c->getHeight();
		c->setTopLeftPosition (x, ny);
		if (ny < y)
			y = ny;

		x += c->getWidth() + spacer;

		c->toFront (false);
	}

	y = textBottom;

	for (i = 0; i < allComps.size(); ++i)
	{
		Component* const c = allComps.getUnchecked(i);
		h = 22;

		const int comboIndex = comboBoxes.indexOf (dynamic_cast <ComboBox*> (c));
		if (comboIndex >= 0 && comboBoxNames [comboIndex].isNotEmpty())
			y += labelHeight;

		const int tbIndex = textBoxes.indexOf (dynamic_cast <TextEditor*> (c));
		if (tbIndex >= 0 && textboxNames[tbIndex].isNotEmpty())
			y += labelHeight;

		if (customComps.contains (c))
		{
			if (c->getName().isNotEmpty())
				y += labelHeight;

			c->setTopLeftPosition (proportionOfWidth (0.1f), y);
			h = c->getHeight();
		}
		else if (textBlocks.contains (c))
		{
			c->setTopLeftPosition ((getWidth() - c->getWidth()) / 2, y);
			h = c->getHeight();
		}
		else
		{
			c->setBounds (proportionOfWidth (0.1f), y, proportionOfWidth (0.8f), h);
		}

		y += h + 10;
	}

	setWantsKeyboardFocus (getNumChildComponents() == 0);
}

bool AlertWindow::containsAnyExtraComponents() const
{
	return allComps.size() > 0;
}

void AlertWindow::mouseDown (const MouseEvent& e)
{
	dragger.startDraggingComponent (this, e);
}

void AlertWindow::mouseDrag (const MouseEvent& e)
{
	dragger.dragComponent (this, e, &constrainer);
}

bool AlertWindow::keyPressed (const KeyPress& key)
{
	for (int i = buttons.size(); --i >= 0;)
	{
		TextButton* const b = buttons.getUnchecked(i);

		if (b->isRegisteredForShortcut (key))
		{
			b->triggerClick();
			return true;
		}
	}

	if (key.isKeyCode (KeyPress::escapeKey) && escapeKeyCancels && buttons.size() == 0)
	{
		exitModalState (0);
		return true;
	}
	else if (key.isKeyCode (KeyPress::returnKey) && buttons.size() == 1)
	{
		buttons.getUnchecked(0)->triggerClick();
		return true;
	}

	return false;
}

void AlertWindow::lookAndFeelChanged()
{
	const int newFlags = getLookAndFeel().getAlertBoxWindowFlags();

	setUsingNativeTitleBar ((newFlags & ComponentPeer::windowHasTitleBar) != 0);
	setDropShadowEnabled (isOpaque() && (newFlags & ComponentPeer::windowHasDropShadow) != 0);
	updateLayout (false);
}

int AlertWindow::getDesktopWindowStyleFlags() const
{
	return getLookAndFeel().getAlertBoxWindowFlags();
}

class AlertWindowInfo
{
public:
	AlertWindowInfo (const String& title_, const String& message_, Component* component,
					 AlertWindow::AlertIconType iconType_, int numButtons_,
					 ModalComponentManager::Callback* callback_, bool modal_)
		: title (title_), message (message_), iconType (iconType_),
		  numButtons (numButtons_), returnValue (0), associatedComponent (component),
		  callback (callback_), modal (modal_)
	{
	}

	String title, message, button1, button2, button3;

	int invoke() const
	{
		MessageManager::getInstance()->callFunctionOnMessageThread (showCallback, (void*) this);
		return returnValue;
	}

private:
	AlertWindow::AlertIconType iconType;
	int numButtons, returnValue;
	WeakReference<Component> associatedComponent;
	ModalComponentManager::Callback* callback;
	bool modal;

	void show()
	{
		LookAndFeel& lf = associatedComponent != nullptr ? associatedComponent->getLookAndFeel()
														 : LookAndFeel::getDefaultLookAndFeel();

		ScopedPointer <Component> alertBox (lf.createAlertWindow (title, message, button1, button2, button3,
																  iconType, numButtons, associatedComponent));

		jassert (alertBox != nullptr); // you have to return one of these!

	   #if JUCE_MODAL_LOOPS_PERMITTED
		if (modal)
		{
			returnValue = alertBox->runModalLoop();
		}
		else
	   #endif
		{
			alertBox->enterModalState (true, callback, true);
			alertBox.release();
		}
	}

	static void* showCallback (void* userData)
	{
		static_cast <AlertWindowInfo*> (userData)->show();
		return nullptr;
	}
};

#if JUCE_MODAL_LOOPS_PERMITTED
void AlertWindow::showMessageBox (AlertIconType iconType,
								  const String& title,
								  const String& message,
								  const String& buttonText,
								  Component* associatedComponent)
{
	if (LookAndFeel::getDefaultLookAndFeel().isUsingNativeAlertWindows())
	{
		NativeMessageBox::showMessageBox (iconType, title, message, associatedComponent);
	}
	else
	{
		AlertWindowInfo info (title, message, associatedComponent, iconType, 1, 0, true);
		info.button1 = buttonText.isEmpty() ? TRANS("ok") : buttonText;

		info.invoke();
	}
}
#endif

void AlertWindow::showMessageBoxAsync (AlertIconType iconType,
									   const String& title,
									   const String& message,
									   const String& buttonText,
									   Component* associatedComponent)
{
	if (LookAndFeel::getDefaultLookAndFeel().isUsingNativeAlertWindows())
	{
		return NativeMessageBox::showMessageBoxAsync (iconType, title, message, associatedComponent);
	}
	else
	{
		AlertWindowInfo info (title, message, associatedComponent, iconType, 1, 0, false);
		info.button1 = buttonText.isEmpty() ? TRANS("ok") : buttonText;

		info.invoke();
	}
}

bool AlertWindow::showOkCancelBox (AlertIconType iconType,
								   const String& title,
								   const String& message,
								   const String& button1Text,
								   const String& button2Text,
								   Component* associatedComponent,
								   ModalComponentManager::Callback* callback)
{
	if (LookAndFeel::getDefaultLookAndFeel().isUsingNativeAlertWindows())
	{
		return NativeMessageBox::showOkCancelBox (iconType, title, message, associatedComponent, callback);
	}
	else
	{
		AlertWindowInfo info (title, message, associatedComponent, iconType, 2, callback, callback == nullptr);
		info.button1 = button1Text.isEmpty() ? TRANS("ok")     : button1Text;
		info.button2 = button2Text.isEmpty() ? TRANS("cancel") : button2Text;

		return info.invoke() != 0;
	}
}

int AlertWindow::showYesNoCancelBox (AlertIconType iconType,
									 const String& title,
									 const String& message,
									 const String& button1Text,
									 const String& button2Text,
									 const String& button3Text,
									 Component* associatedComponent,
									 ModalComponentManager::Callback* callback)
{
	if (LookAndFeel::getDefaultLookAndFeel().isUsingNativeAlertWindows())
	{
		return NativeMessageBox::showYesNoCancelBox (iconType, title, message, associatedComponent, callback);
	}
	else
	{
		AlertWindowInfo info (title, message, associatedComponent, iconType, 3, callback, callback == nullptr);
		info.button1 = button1Text.isEmpty() ? TRANS("yes")     : button1Text;
		info.button2 = button2Text.isEmpty() ? TRANS("no")      : button2Text;
		info.button3 = button3Text.isEmpty() ? TRANS("cancel")  : button3Text;

		return info.invoke();
	}
}

#if JUCE_MODAL_LOOPS_PERMITTED
bool AlertWindow::showNativeDialogBox (const String& title,
									   const String& bodyText,
									   bool isOkCancel)
{
	if (isOkCancel)
	{
		return NativeMessageBox::showOkCancelBox (AlertWindow::NoIcon, title, bodyText);
	}
	else
	{
		NativeMessageBox::showMessageBox (AlertWindow::NoIcon, title, bodyText);
		return true;
	}
}
#endif

/*** End of inlined file: juce_AlertWindow.cpp ***/


/*** Start of inlined file: juce_CallOutBox.cpp ***/
CallOutBox::CallOutBox (Component& contentComponent,
						Component& componentToPointTo,
						Component* const parent)
	: borderSpace (20), arrowSize (16.0f), content (contentComponent)
{
	addAndMakeVisible (&content);

	if (parent != nullptr)
	{
		parent->addChildComponent (this);

		updatePosition (parent->getLocalArea (&componentToPointTo, componentToPointTo.getLocalBounds()),
						parent->getLocalBounds());

		setVisible (true);
	}
	else
	{
		if (! JUCEApplication::isStandaloneApp())
			setAlwaysOnTop (true); // for a plugin, make it always-on-top because the host windows are often top-level

		updatePosition (componentToPointTo.getScreenBounds(),
						componentToPointTo.getParentMonitorArea());

		addToDesktop (ComponentPeer::windowIsTemporary);
	}
}

CallOutBox::~CallOutBox()
{
}

void CallOutBox::setArrowSize (const float newSize)
{
	arrowSize = newSize;
	borderSpace = jmax (20, (int) arrowSize);
	refreshPath();
}

void CallOutBox::paint (Graphics& g)
{
	if (background.isNull())
	{
		background = Image (Image::ARGB, getWidth(), getHeight(), true);
		Graphics g2 (background);
		getLookAndFeel().drawCallOutBoxBackground (*this, g2, outline);
	}

	g.setColour (Colours::black);
	g.drawImageAt (background, 0, 0);
}

void CallOutBox::resized()
{
	content.setTopLeftPosition (borderSpace, borderSpace);
	refreshPath();
}

void CallOutBox::moved()
{
	refreshPath();
}

void CallOutBox::childBoundsChanged (Component*)
{
	updatePosition (targetArea, availableArea);
}

bool CallOutBox::hitTest (int x, int y)
{
	return outline.contains ((float) x, (float) y);
}

enum { callOutBoxDismissCommandId = 0x4f83a04b };

void CallOutBox::inputAttemptWhenModal()
{
	const Point<int> mousePos (getMouseXYRelative() + getBounds().getPosition());

	if (targetArea.contains (mousePos))
	{
		// if you click on the area that originally popped-up the callout, you expect it
		// to get rid of the box, but deleting the box here allows the click to pass through and
		// probably re-trigger it, so we need to dismiss the box asynchronously to consume the click..
		postCommandMessage (callOutBoxDismissCommandId);
	}
	else
	{
		exitModalState (0);
		setVisible (false);
	}
}

void CallOutBox::handleCommandMessage (int commandId)
{
	Component::handleCommandMessage (commandId);

	if (commandId == callOutBoxDismissCommandId)
	{
		exitModalState (0);
		setVisible (false);
	}
}

bool CallOutBox::keyPressed (const KeyPress& key)
{
	if (key.isKeyCode (KeyPress::escapeKey))
	{
		inputAttemptWhenModal();
		return true;
	}

	return false;
}

void CallOutBox::updatePosition (const Rectangle<int>& newAreaToPointTo, const Rectangle<int>& newAreaToFitIn)
{
	targetArea = newAreaToPointTo;
	availableArea = newAreaToFitIn;

	Rectangle<int> newBounds (0, 0,
							  content.getWidth() + borderSpace * 2,
							  content.getHeight() + borderSpace * 2);

	const int hw = newBounds.getWidth() / 2;
	const int hh = newBounds.getHeight() / 2;
	const float hwReduced = (float) (hw - borderSpace * 3);
	const float hhReduced = (float) (hh - borderSpace * 3);
	const float arrowIndent = borderSpace - arrowSize;

	Point<float> targets[4] = { Point<float> ((float) targetArea.getCentreX(), (float) targetArea.getBottom()),
								Point<float> ((float) targetArea.getRight(),   (float) targetArea.getCentreY()),
								Point<float> ((float) targetArea.getX(),       (float) targetArea.getCentreY()),
								Point<float> ((float) targetArea.getCentreX(), (float) targetArea.getY()) };

	Line<float> lines[4] = { Line<float> (targets[0].translated (-hwReduced, hh - arrowIndent),    targets[0].translated (hwReduced, hh - arrowIndent)),
							 Line<float> (targets[1].translated (hw - arrowIndent, -hhReduced),    targets[1].translated (hw - arrowIndent, hhReduced)),
							 Line<float> (targets[2].translated (-(hw - arrowIndent), -hhReduced), targets[2].translated (-(hw - arrowIndent), hhReduced)),
							 Line<float> (targets[3].translated (-hwReduced, -(hh - arrowIndent)), targets[3].translated (hwReduced, -(hh - arrowIndent))) };

	const Rectangle<float> centrePointArea (newAreaToFitIn.reduced (hw, hh).toFloat());

	float nearest = 1.0e9f;

	for (int i = 0; i < 4; ++i)
	{
		Line<float> constrainedLine (centrePointArea.getConstrainedPoint (lines[i].getStart()),
									 centrePointArea.getConstrainedPoint (lines[i].getEnd()));

		const Point<float> centre (constrainedLine.findNearestPointTo (centrePointArea.getCentre()));
		float distanceFromCentre = centre.getDistanceFrom (centrePointArea.getCentre());

		if (! (centrePointArea.contains (lines[i].getStart()) || centrePointArea.contains (lines[i].getEnd())))
			distanceFromCentre *= 2.0f;

		if (distanceFromCentre < nearest)
		{
			nearest = distanceFromCentre;

			targetPoint = targets[i];
			newBounds.setPosition ((int) (centre.getX() - hw),
								   (int) (centre.getY() - hh));
		}
	}

	setBounds (newBounds);
}

void CallOutBox::refreshPath()
{
	repaint();
	background = Image::null;
	outline.clear();

	const float gap = 4.5f;
	const float cornerSize = 9.0f;
	const float cornerSize2 = 2.0f * cornerSize;
	const float arrowBaseWidth = arrowSize * 0.7f;

	const Rectangle<float> area (content.getBounds().toFloat().expanded (gap, gap));
	const Point<float> target (targetPoint - getPosition().toFloat());

	outline.startNewSubPath (area.getX() + cornerSize, area.getY());

	const float targetLimitX = area.getX() + cornerSize + arrowBaseWidth;
	const float targetLimitW = area.getWidth() - cornerSize2 - arrowBaseWidth * 2.0f;

	const float targetLimitY = area.getY() + cornerSize + arrowBaseWidth;
	const float targetLimitH = area.getHeight() - cornerSize2 - arrowBaseWidth * 2.0f;

	if (Rectangle<float> (targetLimitX, 1.0f,
						  targetLimitW, area.getY() - 2.0f).contains (target))
	{
		outline.lineTo (target.x - arrowBaseWidth, area.getY());
		outline.lineTo (target.x, target.y);
		outline.lineTo (target.x + arrowBaseWidth, area.getY());
	}

	outline.lineTo (area.getRight() - cornerSize, area.getY());
	outline.addArc (area.getRight() - cornerSize2, area.getY(), cornerSize2, cornerSize2, 0, float_Pi * 0.5f);

	if (Rectangle<float> (area.getRight() + 1.0f, targetLimitY,
						  getWidth() - area.getRight() - 2.0f, targetLimitH).contains (target))
	{
		outline.lineTo (area.getRight(), target.y - arrowBaseWidth);
		outline.lineTo (target.x, target.y);
		outline.lineTo (area.getRight(), target.y + arrowBaseWidth);
	}

	outline.lineTo (area.getRight(), area.getBottom() - cornerSize);
	outline.addArc (area.getRight() - cornerSize2, area.getBottom() - cornerSize2, cornerSize2, cornerSize2, float_Pi * 0.5f, float_Pi);

	if (Rectangle<float> (targetLimitX, area.getBottom() + 1.0f,
						  targetLimitW, getHeight() - area.getBottom() - 2.0f).contains (target))
	{
		outline.lineTo (target.x + arrowBaseWidth, area.getBottom());
		outline.lineTo (target.x, target.y);
		outline.lineTo (target.x - arrowBaseWidth, area.getBottom());
	}

	outline.lineTo (area.getX() + cornerSize, area.getBottom());
	outline.addArc (area.getX(), area.getBottom() - cornerSize2, cornerSize2, cornerSize2, float_Pi, float_Pi * 1.5f);

	if (Rectangle<float> (1.0f, targetLimitY, area.getX() - 2.0f, targetLimitH).contains (target))
	{
		outline.lineTo (area.getX(), target.y + arrowBaseWidth);
		outline.lineTo (target.x, target.y);
		outline.lineTo (area.getX(), target.y - arrowBaseWidth);
	}

	outline.lineTo (area.getX(), area.getY() + cornerSize);
	outline.addArc (area.getX(), area.getY(), cornerSize2, cornerSize2, float_Pi * 1.5f, float_Pi * 2.0f - 0.05f);

	outline.closeSubPath();
}

/*** End of inlined file: juce_CallOutBox.cpp ***/


/*** Start of inlined file: juce_ComponentPeer.cpp ***/
//#define JUCE_ENABLE_REPAINT_DEBUGGING 1

static Array <ComponentPeer*> heavyweightPeers;
static uint32 lastUniqueID = 1;

ComponentPeer::ComponentPeer (Component* const component_, const int styleFlags_)
	: component (component_),
	  styleFlags (styleFlags_),
	  lastPaintTime (0),
	  constrainer (nullptr),
	  lastDragAndDropCompUnderMouse (nullptr),
	  uniqueID (lastUniqueID += 2), // increment by 2 so that this can never hit 0
	  fakeMouseMessageSent (false),
	  isWindowMinimised (false)
{
	heavyweightPeers.add (this);
}

ComponentPeer::~ComponentPeer()
{
	heavyweightPeers.removeValue (this);
	Desktop::getInstance().triggerFocusCallback();
}

int ComponentPeer::getNumPeers() noexcept
{
	return heavyweightPeers.size();
}

ComponentPeer* ComponentPeer::getPeer (const int index) noexcept
{
	return heavyweightPeers [index];
}

ComponentPeer* ComponentPeer::getPeerFor (const Component* const component) noexcept
{
	for (int i = heavyweightPeers.size(); --i >= 0;)
	{
		ComponentPeer* const peer = heavyweightPeers.getUnchecked(i);

		if (peer->getComponent() == component)
			return peer;
	}

	return nullptr;
}

bool ComponentPeer::isValidPeer (const ComponentPeer* const peer) noexcept
{
	return heavyweightPeers.contains (const_cast <ComponentPeer*> (peer));
}

void ComponentPeer::updateCurrentModifiers() noexcept
{
	ModifierKeys::updateCurrentModifiers();
}

void ComponentPeer::handleMouseEvent (const int touchIndex, const Point<int>& positionWithinPeer, const ModifierKeys& newMods, const int64 time)
{
	MouseInputSource* const mouse = Desktop::getInstance().getMouseSource (touchIndex);
	jassert (mouse != nullptr); // not enough sources!

	mouse->handleEvent (this, positionWithinPeer, time, newMods);
}

void ComponentPeer::handleMouseWheel (const int touchIndex, const Point<int>& positionWithinPeer, const int64 time, const float x, const float y)
{
	MouseInputSource* const mouse = Desktop::getInstance().getMouseSource (touchIndex);
	jassert (mouse != nullptr); // not enough sources!

	mouse->handleWheel (this, positionWithinPeer, time, x, y);
}

void ComponentPeer::handlePaint (LowLevelGraphicsContext& contextToPaintTo)
{
	Graphics g (&contextToPaintTo);

   #if JUCE_ENABLE_REPAINT_DEBUGGING
	g.saveState();
   #endif

	JUCE_TRY
	{
		component->paintEntireComponent (g, true);
	}
	JUCE_CATCH_EXCEPTION

   #if JUCE_ENABLE_REPAINT_DEBUGGING
	// enabling this code will fill all areas that get repainted with a colour overlay, to show
	// clearly when things are being repainted.
	g.restoreState();

	static Random rng;

	g.fillAll (Colour ((uint8) rng.nextInt (255),
					   (uint8) rng.nextInt (255),
					   (uint8) rng.nextInt (255),
					   (uint8) 0x50));
   #endif

	/** If this fails, it's probably be because your CPU floating-point precision mode has
		been set to low.. This setting is sometimes changed by things like Direct3D, and can
		mess up a lot of the calculations that the library needs to do.
	*/
	jassert (roundToInt (10.1f) == 10);
}

bool ComponentPeer::handleKeyPress (const int keyCode,
									const juce_wchar textCharacter)
{
	updateCurrentModifiers();

	Component* target = Component::getCurrentlyFocusedComponent() != nullptr
							? Component::getCurrentlyFocusedComponent()
							: component;

	if (target->isCurrentlyBlockedByAnotherModalComponent())
	{
		Component* const currentModalComp = Component::getCurrentlyModalComponent();

		if (currentModalComp != nullptr)
			target = currentModalComp;
	}

	const KeyPress keyInfo (keyCode,
							ModifierKeys::getCurrentModifiers().getRawFlags()
							   & ModifierKeys::allKeyboardModifiers,
							textCharacter);

	bool keyWasUsed = false;

	while (target != nullptr)
	{
		const WeakReference<Component> deletionChecker (target);
		const Array <KeyListener*>* const keyListeners = target->keyListeners;

		if (keyListeners != nullptr)
		{
			for (int i = keyListeners->size(); --i >= 0;)
			{
				keyWasUsed = keyListeners->getUnchecked(i)->keyPressed (keyInfo, target);

				if (keyWasUsed || deletionChecker == nullptr)
					return keyWasUsed;

				i = jmin (i, keyListeners->size());
			}
		}

		keyWasUsed = target->keyPressed (keyInfo);

		if (keyWasUsed || deletionChecker == nullptr)
			break;

		Component* const currentlyFocused = Component::getCurrentlyFocusedComponent();

		if (currentlyFocused != nullptr)
		{
			const bool isTab      = (keyInfo == KeyPress (KeyPress::tabKey, ModifierKeys::noModifiers, 0));
			const bool isShiftTab = (keyInfo == KeyPress (KeyPress::tabKey, ModifierKeys::shiftModifier, 0));

			if (isTab || isShiftTab)
			{
				currentlyFocused->moveKeyboardFocusToSibling (isTab);
				keyWasUsed = (currentlyFocused != Component::getCurrentlyFocusedComponent());
				break;
			}
		}

		target = target->getParentComponent();
	}

	return keyWasUsed;
}

bool ComponentPeer::handleKeyUpOrDown (const bool isKeyDown)
{
	updateCurrentModifiers();

	Component* target = Component::getCurrentlyFocusedComponent() != nullptr
							? Component::getCurrentlyFocusedComponent()
							: component;

	if (target->isCurrentlyBlockedByAnotherModalComponent())
	{
		Component* const currentModalComp = Component::getCurrentlyModalComponent();

		if (currentModalComp != nullptr)
			target = currentModalComp;
	}

	bool keyWasUsed = false;

	while (target != nullptr)
	{
		const WeakReference<Component> deletionChecker (target);

		keyWasUsed = target->keyStateChanged (isKeyDown);

		if (keyWasUsed || deletionChecker == nullptr)
			break;

		const Array <KeyListener*>* const keyListeners = target->keyListeners;

		if (keyListeners != nullptr)
		{
			for (int i = keyListeners->size(); --i >= 0;)
			{
				keyWasUsed = keyListeners->getUnchecked(i)->keyStateChanged (isKeyDown, target);

				if (keyWasUsed || deletionChecker == nullptr)
					return keyWasUsed;

				i = jmin (i, keyListeners->size());
			}
		}

		target = target->getParentComponent();
	}

	return keyWasUsed;
}

void ComponentPeer::handleModifierKeysChange()
{
	updateCurrentModifiers();

	Component* target = Desktop::getInstance().getMainMouseSource().getComponentUnderMouse();

	if (target == nullptr)
		target = Component::getCurrentlyFocusedComponent();

	if (target == nullptr)
		target = component;

	if (target != nullptr)
		target->internalModifierKeysChanged();
}

TextInputTarget* ComponentPeer::findCurrentTextInputTarget()
{
	Component* const c = Component::getCurrentlyFocusedComponent();
	if (component->isParentOf (c))
	{
		TextInputTarget* const ti = dynamic_cast <TextInputTarget*> (c);
		if (ti != nullptr && ti->isTextInputActive())
			return ti;
	}

	return nullptr;
}

void ComponentPeer::dismissPendingTextInput()
{
}

void ComponentPeer::handleBroughtToFront()
{
	updateCurrentModifiers();

	if (component != nullptr)
		component->internalBroughtToFront();
}

void ComponentPeer::setConstrainer (ComponentBoundsConstrainer* const newConstrainer) noexcept
{
	constrainer = newConstrainer;
}

void ComponentPeer::handleMovedOrResized()
{
	updateCurrentModifiers();

	const bool nowMinimised = isMinimised();

	if (component->flags.hasHeavyweightPeerFlag && ! nowMinimised)
	{
		const WeakReference<Component> deletionChecker (component);

		const Rectangle<int> newBounds (getBounds());
		const bool wasMoved   = (component->getPosition() != newBounds.getPosition());
		const bool wasResized = (component->getWidth() != newBounds.getWidth() || component->getHeight() != newBounds.getHeight());

		if (wasMoved || wasResized)
		{
			component->bounds = newBounds;

			if (wasResized)
				component->repaint();

			component->sendMovedResizedMessages (wasMoved, wasResized);

			if (deletionChecker == nullptr)
				return;
		}
	}

	if (isWindowMinimised != nowMinimised)
	{
		isWindowMinimised = nowMinimised;
		component->minimisationStateChanged (nowMinimised);
		component->sendVisibilityChangeMessage();
	}

	if (! isFullScreen())
		lastNonFullscreenBounds = component->getBounds();
}

void ComponentPeer::handleFocusGain()
{
	updateCurrentModifiers();

	if (component->isParentOf (lastFocusedComponent))
	{
		Component::currentlyFocusedComponent = lastFocusedComponent;
		Desktop::getInstance().triggerFocusCallback();
		lastFocusedComponent->internalFocusGain (Component::focusChangedDirectly);
	}
	else
	{
		if (! component->isCurrentlyBlockedByAnotherModalComponent())
			component->grabKeyboardFocus();
		else
			ModalComponentManager::getInstance()->bringModalComponentsToFront();
	}
}

void ComponentPeer::handleFocusLoss()
{
	updateCurrentModifiers();

	if (component->hasKeyboardFocus (true))
	{
		lastFocusedComponent = Component::currentlyFocusedComponent;

		if (lastFocusedComponent != nullptr)
		{
			Component::currentlyFocusedComponent = nullptr;
			Desktop::getInstance().triggerFocusCallback();
			lastFocusedComponent->internalFocusLoss (Component::focusChangedByMouseClick);
		}
	}
}

Component* ComponentPeer::getLastFocusedSubcomponent() const noexcept
{
	return (component->isParentOf (lastFocusedComponent) && lastFocusedComponent->isShowing())
				? static_cast <Component*> (lastFocusedComponent)
				: component;
}

void ComponentPeer::handleScreenSizeChange()
{
	updateCurrentModifiers();

	component->parentSizeChanged();
	handleMovedOrResized();
}

void ComponentPeer::setNonFullScreenBounds (const Rectangle<int>& newBounds) noexcept
{
	lastNonFullscreenBounds = newBounds;
}

const Rectangle<int>& ComponentPeer::getNonFullScreenBounds() const noexcept
{
	return lastNonFullscreenBounds;
}

Rectangle<int> ComponentPeer::localToGlobal (const Rectangle<int>& relativePosition)
{
	return relativePosition.withPosition (localToGlobal (relativePosition.getPosition()));
}

Rectangle<int> ComponentPeer::globalToLocal (const Rectangle<int>& screenPosition)
{
	return screenPosition.withPosition (globalToLocal (screenPosition.getPosition()));
}

namespace ComponentPeerHelpers
{
	FileDragAndDropTarget* findDragAndDropTarget (Component* c,
												  const StringArray& files,
												  FileDragAndDropTarget* const lastOne)
	{
		while (c != nullptr)
		{
			FileDragAndDropTarget* const t = dynamic_cast <FileDragAndDropTarget*> (c);

			if (t != nullptr && (t == lastOne || t->isInterestedInFileDrag (files)))
				return t;

			c = c->getParentComponent();
		}

		return nullptr;
	}
}

bool ComponentPeer::handleFileDragMove (const StringArray& files, const Point<int>& position)
{
	updateCurrentModifiers();

	FileDragAndDropTarget* lastTarget
		= dynamic_cast<FileDragAndDropTarget*> (static_cast<Component*> (dragAndDropTargetComponent));

	FileDragAndDropTarget* newTarget = nullptr;

	Component* const compUnderMouse = component->getComponentAt (position);

	if (compUnderMouse != lastDragAndDropCompUnderMouse)
	{
		lastDragAndDropCompUnderMouse = compUnderMouse;
		newTarget = ComponentPeerHelpers::findDragAndDropTarget (compUnderMouse, files, lastTarget);

		if (newTarget != lastTarget)
		{
			if (lastTarget != nullptr)
				lastTarget->fileDragExit (files);

			dragAndDropTargetComponent = nullptr;

			if (newTarget != nullptr)
			{
				dragAndDropTargetComponent = dynamic_cast <Component*> (newTarget);
				const Point<int> pos (dragAndDropTargetComponent->getLocalPoint (component, position));
				newTarget->fileDragEnter (files, pos.getX(), pos.getY());
			}
		}
	}
	else
	{
		newTarget = lastTarget;
	}

	if (newTarget == nullptr)
		return false;

	Component* const targetComp = dynamic_cast <Component*> (newTarget);
	const Point<int> pos (targetComp->getLocalPoint (component, position));
	newTarget->fileDragMove (files, pos.getX(), pos.getY());
	return true;
}

bool ComponentPeer::handleFileDragExit (const StringArray& files)
{
	const bool used = handleFileDragMove (files, Point<int> (-1, -1));

	jassert (dragAndDropTargetComponent == nullptr);
	lastDragAndDropCompUnderMouse = nullptr;
	return used;
}

// We'll use an async message to deliver the drop, because if the target decides
// to run a modal loop, it can gum-up the operating system..
class AsyncFileDropMessage  : public CallbackMessage
{
public:
	AsyncFileDropMessage (Component* target_, FileDragAndDropTarget* dropTarget_,
						  const Point<int>& position_, const StringArray& files_)
		: target (target_), dropTarget (dropTarget_), position (position_), files (files_)
	{
	}

	void messageCallback()
	{
		if (target.get() != nullptr)
			dropTarget->filesDropped (files, position.getX(), position.getY());
	}

private:
	WeakReference<Component> target;
	FileDragAndDropTarget* const dropTarget;
	const Point<int> position;
	const StringArray files;

	JUCE_DECLARE_NON_COPYABLE (AsyncFileDropMessage);
};

bool ComponentPeer::handleFileDragDrop (const StringArray& files, const Point<int>& position)
{
	handleFileDragMove (files, position);

	if (dragAndDropTargetComponent != nullptr)
	{
		FileDragAndDropTarget* const target
			= dynamic_cast<FileDragAndDropTarget*> (static_cast<Component*> (dragAndDropTargetComponent));

		dragAndDropTargetComponent = nullptr;
		lastDragAndDropCompUnderMouse = nullptr;

		if (target != nullptr)
		{
			Component* const targetComp = dynamic_cast <Component*> (target);

			if (targetComp->isCurrentlyBlockedByAnotherModalComponent())
			{
				targetComp->internalModalInputAttempt();

				if (targetComp->isCurrentlyBlockedByAnotherModalComponent())
					return true;
			}

			(new AsyncFileDropMessage (targetComp, target, targetComp->getLocalPoint (component, position), files))->post();
			return true;
		}
	}

	return false;
}

void ComponentPeer::handleUserClosingWindow()
{
	updateCurrentModifiers();
	component->userTriedToCloseWindow();
}

void ComponentPeer::clearMaskedRegion()
{
	maskedRegion.clear();
}

void ComponentPeer::addMaskedRegion (const Rectangle<int>& area)
{
	maskedRegion.add (area);
}

StringArray ComponentPeer::getAvailableRenderingEngines()
{
	return StringArray ("Software Renderer");
}

int ComponentPeer::getCurrentRenderingEngine() const
{
	return 0;
}

void ComponentPeer::setCurrentRenderingEngine (int /*index*/)
{
}

/*** End of inlined file: juce_ComponentPeer.cpp ***/


/*** Start of inlined file: juce_DialogWindow.cpp ***/
DialogWindow::DialogWindow (const String& name,
							const Colour& backgroundColour_,
							const bool escapeKeyTriggersCloseButton_,
							const bool addToDesktop_)
	: DocumentWindow (name, backgroundColour_, DocumentWindow::closeButton, addToDesktop_),
	  escapeKeyTriggersCloseButton (escapeKeyTriggersCloseButton_)
{
}

DialogWindow::~DialogWindow()
{
}

void DialogWindow::resized()
{
	DocumentWindow::resized();

	const KeyPress esc (KeyPress::escapeKey, 0, 0);

	if (escapeKeyTriggersCloseButton
		 && getCloseButton() != nullptr
		 && ! getCloseButton()->isRegisteredForShortcut (esc))
	{
		getCloseButton()->addShortcut (esc);
	}
}

class TempDialogWindow : public DialogWindow
{
public:
	TempDialogWindow (const String& title,
					  Component* contentComponent_,
					  Component* componentToCentreAround,
					  const Colour& colour,
					  const bool escapeKeyTriggersCloseButton_,
					  const bool shouldBeResizable,
					  const bool useBottomRightCornerResizer)
		: DialogWindow (title, colour, escapeKeyTriggersCloseButton_, true)
	{
		if (! JUCEApplication::isStandaloneApp())
			setAlwaysOnTop (true); // for a plugin, make it always-on-top because the host windows are often top-level

		setContentNonOwned (contentComponent_, true);
		centreAroundComponent (componentToCentreAround, getWidth(), getHeight());
		setResizable (shouldBeResizable, useBottomRightCornerResizer);
	}

	void closeButtonPressed()
	{
		setVisible (false);
	}

private:
	JUCE_DECLARE_NON_COPYABLE (TempDialogWindow);
};

void DialogWindow::showDialog (const String& dialogTitle,
							   Component* const contentComponent,
							   Component* const componentToCentreAround,
							   const Colour& backgroundColour,
							   const bool escapeKeyTriggersCloseButton,
							   const bool shouldBeResizable,
							   const bool useBottomRightCornerResizer)
{
	TempDialogWindow* dw = new TempDialogWindow (dialogTitle, contentComponent, componentToCentreAround,
												 backgroundColour, escapeKeyTriggersCloseButton,
												 shouldBeResizable, useBottomRightCornerResizer);

	dw->enterModalState (true, 0, true);
}

#if JUCE_MODAL_LOOPS_PERMITTED
int DialogWindow::showModalDialog (const String& dialogTitle,
								   Component* const contentComponent,
								   Component* const componentToCentreAround,
								   const Colour& backgroundColour,
								   const bool escapeKeyTriggersCloseButton,
								   const bool shouldBeResizable,
								   const bool useBottomRightCornerResizer)
{
	TempDialogWindow dw (dialogTitle, contentComponent, componentToCentreAround,
						 backgroundColour, escapeKeyTriggersCloseButton,
						 shouldBeResizable, useBottomRightCornerResizer);

	return dw.runModalLoop();
}
#endif

/*** End of inlined file: juce_DialogWindow.cpp ***/


/*** Start of inlined file: juce_DocumentWindow.cpp ***/
class DocumentWindow::ButtonListenerProxy  : public ButtonListener // (can't use Button::Listener due to idiotic VC2005 bug)
{
public:
	ButtonListenerProxy (DocumentWindow& owner_)
		: owner (owner_)
	{
	}

	void buttonClicked (Button* button)
	{
		if      (button == owner.getMinimiseButton())  owner.minimiseButtonPressed();
		else if (button == owner.getMaximiseButton())  owner.maximiseButtonPressed();
		else if (button == owner.getCloseButton())     owner.closeButtonPressed();
	}

private:
	DocumentWindow& owner;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ButtonListenerProxy);
};

DocumentWindow::DocumentWindow (const String& title,
								const Colour& backgroundColour,
								const int requiredButtons_,
								const bool addToDesktop_)
	: ResizableWindow (title, backgroundColour, addToDesktop_),
	  titleBarHeight (26),
	  menuBarHeight (24),
	  requiredButtons (requiredButtons_),
	#if JUCE_MAC
	  positionTitleBarButtonsOnLeft (true),
	#else
	  positionTitleBarButtonsOnLeft (false),
	#endif
	  drawTitleTextCentred (true),
	  menuBarModel (nullptr)
{
	setResizeLimits (128, 128, 32768, 32768);

	DocumentWindow::lookAndFeelChanged();
}

DocumentWindow::~DocumentWindow()
{
	// Don't delete or remove the resizer components yourself! They're managed by the
	// DocumentWindow, and you should leave them alone! You may have deleted them
	// accidentally by careless use of deleteAllChildren()..?
	jassert (menuBar == nullptr || getIndexOfChildComponent (menuBar) >= 0);
	jassert (titleBarButtons[0] == nullptr || getIndexOfChildComponent (titleBarButtons[0]) >= 0);
	jassert (titleBarButtons[1] == nullptr || getIndexOfChildComponent (titleBarButtons[1]) >= 0);
	jassert (titleBarButtons[2] == nullptr || getIndexOfChildComponent (titleBarButtons[2]) >= 0);

	for (int i = numElementsInArray (titleBarButtons); --i >= 0;)
		titleBarButtons[i] = nullptr;

	menuBar = nullptr;
}

void DocumentWindow::repaintTitleBar()
{
	repaint (getTitleBarArea());
}

void DocumentWindow::setName (const String& newName)
{
	if (newName != getName())
	{
		Component::setName (newName);
		repaintTitleBar();
	}
}

void DocumentWindow::setIcon (const Image& imageToUse)
{
	titleBarIcon = imageToUse;
	repaintTitleBar();
}

void DocumentWindow::setTitleBarHeight (const int newHeight)
{
	titleBarHeight = newHeight;
	resized();
	repaintTitleBar();
}

void DocumentWindow::setTitleBarButtonsRequired (const int requiredButtons_,
												 const bool positionTitleBarButtonsOnLeft_)
{
	requiredButtons = requiredButtons_;
	positionTitleBarButtonsOnLeft = positionTitleBarButtonsOnLeft_;
	lookAndFeelChanged();
}

void DocumentWindow::setTitleBarTextCentred (const bool textShouldBeCentred)
{
	drawTitleTextCentred = textShouldBeCentred;
	repaintTitleBar();
}

void DocumentWindow::setMenuBar (MenuBarModel* newMenuBarModel, const int newMenuBarHeight)
{
	if (menuBarModel != newMenuBarModel)
	{
		menuBar = nullptr;

		menuBarModel = newMenuBarModel;
		menuBarHeight = newMenuBarHeight > 0 ? newMenuBarHeight
											 : getLookAndFeel().getDefaultMenuBarHeight();

		if (menuBarModel != nullptr)
			setMenuBarComponent (new MenuBarComponent (menuBarModel));

		resized();
	}
}

Component* DocumentWindow::getMenuBarComponent() const noexcept
{
	return menuBar;
}

void DocumentWindow::setMenuBarComponent (Component* newMenuBarComponent)
{
	// (call the Component method directly to avoid the assertion in ResizableWindow)
	Component::addAndMakeVisible (menuBar = newMenuBarComponent);

	if (menuBar != nullptr)
		menuBar->setEnabled (isActiveWindow());

	resized();
}

void DocumentWindow::closeButtonPressed()
{
	/*  If you've got a close button, you have to override this method to get
		rid of your window!

		If the window is just a pop-up, you should override this method and make
		it delete the window in whatever way is appropriate for your app. E.g. you
		might just want to call "delete this".

		If your app is centred around this window such that the whole app should quit when
		the window is closed, then you will probably want to use this method as an opportunity
		to call JUCEApplication::quit(), and leave the window to be deleted later by your
		JUCEApplication::shutdown() method. (Doing it this way means that your window will
		still get cleaned-up if the app is quit by some other means (e.g. a cmd-Q on the mac
		or closing it via the taskbar icon on Windows).
	*/
	jassertfalse;
}

void DocumentWindow::minimiseButtonPressed()
{
	setMinimised (true);
}

void DocumentWindow::maximiseButtonPressed()
{
	setFullScreen (! isFullScreen());
}

void DocumentWindow::paint (Graphics& g)
{
	ResizableWindow::paint (g);

	if (resizableBorder == nullptr)
	{
		g.setColour (getBackgroundColour().overlaidWith (Colour (0x80000000)));

		const BorderSize<int> border (getBorderThickness());

		g.fillRect (0, 0, getWidth(), border.getTop());
		g.fillRect (0, border.getTop(), border.getLeft(), getHeight() - border.getTopAndBottom());
		g.fillRect (getWidth() - border.getRight(), border.getTop(), border.getRight(), getHeight() - border.getTopAndBottom());
		g.fillRect (0, getHeight() - border.getBottom(), getWidth(), border.getBottom());
	}

	const Rectangle<int> titleBarArea (getTitleBarArea());
	g.reduceClipRegion (titleBarArea);
	g.setOrigin (titleBarArea.getX(), titleBarArea.getY());

	int titleSpaceX1 = 6;
	int titleSpaceX2 = titleBarArea.getWidth() - 6;

	for (int i = 0; i < 3; ++i)
	{
		if (titleBarButtons[i] != nullptr)
		{
			if (positionTitleBarButtonsOnLeft)
				titleSpaceX1 = jmax (titleSpaceX1, titleBarButtons[i]->getRight() + (getWidth() - titleBarButtons[i]->getRight()) / 8);
			else
				titleSpaceX2 = jmin (titleSpaceX2, titleBarButtons[i]->getX() - (titleBarButtons[i]->getX() / 8));
		}
	}

	getLookAndFeel().drawDocumentWindowTitleBar (*this, g,
												 titleBarArea.getWidth(),
												 titleBarArea.getHeight(),
												 titleSpaceX1,
												 jmax (1, titleSpaceX2 - titleSpaceX1),
												 titleBarIcon.isValid() ? &titleBarIcon : 0,
												 ! drawTitleTextCentred);
}

void DocumentWindow::resized()
{
	ResizableWindow::resized();

	if (titleBarButtons[1] != nullptr)
		titleBarButtons[1]->setToggleState (isFullScreen(), false);

	const Rectangle<int> titleBarArea (getTitleBarArea());

	getLookAndFeel()
		.positionDocumentWindowButtons (*this,
										titleBarArea.getX(), titleBarArea.getY(),
										titleBarArea.getWidth(), titleBarArea.getHeight(),
										titleBarButtons[0],
										titleBarButtons[1],
										titleBarButtons[2],
										positionTitleBarButtonsOnLeft);

	if (menuBar != nullptr)
		menuBar->setBounds (titleBarArea.getX(), titleBarArea.getBottom(),
							titleBarArea.getWidth(), menuBarHeight);
}

BorderSize<int> DocumentWindow::getBorderThickness()
{
	return BorderSize<int> ((isFullScreen() || isUsingNativeTitleBar())
								? 0 : (resizableBorder != nullptr ? 4 : 1));
}

BorderSize<int> DocumentWindow::getContentComponentBorder()
{
	BorderSize<int> border (getBorderThickness());

	border.setTop (border.getTop()
					+ (isUsingNativeTitleBar() ? 0 : titleBarHeight)
					+ (menuBar != nullptr ? menuBarHeight : 0));

	return border;
}

int DocumentWindow::getTitleBarHeight() const
{
	return isUsingNativeTitleBar() ? 0 : jmin (titleBarHeight, getHeight() - 4);
}

Rectangle<int> DocumentWindow::getTitleBarArea()
{
	const BorderSize<int> border (getBorderThickness());

	return Rectangle<int> (border.getLeft(), border.getTop(),
						   getWidth() - border.getLeftAndRight(),
						   getTitleBarHeight());
}

Button* DocumentWindow::getCloseButton() const noexcept     { return titleBarButtons[2]; }
Button* DocumentWindow::getMinimiseButton() const noexcept  { return titleBarButtons[0]; }
Button* DocumentWindow::getMaximiseButton() const noexcept  { return titleBarButtons[1]; }

int DocumentWindow::getDesktopWindowStyleFlags() const
{
	int styleFlags = ResizableWindow::getDesktopWindowStyleFlags();

	if ((requiredButtons & minimiseButton) != 0)  styleFlags |= ComponentPeer::windowHasMinimiseButton;
	if ((requiredButtons & maximiseButton) != 0)  styleFlags |= ComponentPeer::windowHasMaximiseButton;
	if ((requiredButtons & closeButton) != 0)     styleFlags |= ComponentPeer::windowHasCloseButton;

	return styleFlags;
}

void DocumentWindow::lookAndFeelChanged()
{
	int i;
	for (i = numElementsInArray (titleBarButtons); --i >= 0;)
		titleBarButtons[i] = nullptr;

	if (! isUsingNativeTitleBar())
	{
		LookAndFeel& lf = getLookAndFeel();

		if ((requiredButtons & minimiseButton) != 0)
			titleBarButtons[0] = lf.createDocumentWindowButton (minimiseButton);

		if ((requiredButtons & maximiseButton) != 0)
			titleBarButtons[1] = lf.createDocumentWindowButton (maximiseButton);

		if ((requiredButtons & closeButton) != 0)
			titleBarButtons[2] = lf.createDocumentWindowButton (closeButton);

		for (i = 0; i < 3; ++i)
		{
			if (titleBarButtons[i] != nullptr)
			{
				if (buttonListener == nullptr)
					buttonListener = new ButtonListenerProxy (*this);

				titleBarButtons[i]->addListener (buttonListener);
				titleBarButtons[i]->setWantsKeyboardFocus (false);

				// (call the Component method directly to avoid the assertion in ResizableWindow)
				Component::addAndMakeVisible (titleBarButtons[i]);
			}
		}

		if (getCloseButton() != nullptr)
		{
		   #if JUCE_MAC
			getCloseButton()->addShortcut (KeyPress ('w', ModifierKeys::commandModifier, 0));
		   #else
			getCloseButton()->addShortcut (KeyPress (KeyPress::F4Key, ModifierKeys::altModifier, 0));
		   #endif
		}
	}

	activeWindowStatusChanged();

	ResizableWindow::lookAndFeelChanged();
}

void DocumentWindow::parentHierarchyChanged()
{
	lookAndFeelChanged();
}

void DocumentWindow::activeWindowStatusChanged()
{
	ResizableWindow::activeWindowStatusChanged();

	for (int i = numElementsInArray (titleBarButtons); --i >= 0;)
		if (titleBarButtons[i] != nullptr)
			titleBarButtons[i]->setEnabled (isActiveWindow());

	if (menuBar != nullptr)
		menuBar->setEnabled (isActiveWindow());
}

void DocumentWindow::mouseDoubleClick (const MouseEvent& e)
{
	if (getTitleBarArea().contains (e.x, e.y)
		 && getMaximiseButton() != nullptr)
	{
		getMaximiseButton()->triggerClick();
	}
}

void DocumentWindow::userTriedToCloseWindow()
{
	closeButtonPressed();
}

/*** End of inlined file: juce_DocumentWindow.cpp ***/


/*** Start of inlined file: juce_ResizableWindow.cpp ***/
ResizableWindow::ResizableWindow (const String& name,
								  const bool addToDesktop_)
	: TopLevelWindow (name, addToDesktop_),
	  ownsContentComponent (false),
	  resizeToFitContent (false),
	  fullscreen (false),
	  constrainer (nullptr)
	 #if JUCE_DEBUG
	  , hasBeenResized (false)
	 #endif
{
	initialise (addToDesktop_);
}

ResizableWindow::ResizableWindow (const String& name,
								  const Colour& backgroundColour_,
								  const bool addToDesktop_)
	: TopLevelWindow (name, addToDesktop_),
	  ownsContentComponent (false),
	  resizeToFitContent (false),
	  fullscreen (false),
	  constrainer (nullptr)
	 #if JUCE_DEBUG
	  , hasBeenResized (false)
	 #endif
{
	setBackgroundColour (backgroundColour_);

	initialise (addToDesktop_);
}

ResizableWindow::~ResizableWindow()
{
	// Don't delete or remove the resizer components yourself! They're managed by the
	// ResizableWindow, and you should leave them alone! You may have deleted them
	// accidentally by careless use of deleteAllChildren()..?
	jassert (resizableCorner == nullptr || getIndexOfChildComponent (resizableCorner) >= 0);
	jassert (resizableBorder == nullptr || getIndexOfChildComponent (resizableBorder) >= 0);

	resizableCorner = nullptr;
	resizableBorder = nullptr;
	clearContentComponent();

	// have you been adding your own components directly to this window..? tut tut tut.
	// Read the instructions for using a ResizableWindow!
	jassert (getNumChildComponents() == 0);
}

void ResizableWindow::initialise (const bool shouldAddToDesktop)
{
	defaultConstrainer.setMinimumOnscreenAmounts (0x10000, 16, 24, 16);

	lastNonFullScreenPos.setBounds (50, 50, 256, 256);

	if (shouldAddToDesktop)
		addToDesktop();
}

int ResizableWindow::getDesktopWindowStyleFlags() const
{
	int styleFlags = TopLevelWindow::getDesktopWindowStyleFlags();

	if (isResizable() && (styleFlags & ComponentPeer::windowHasTitleBar) != 0)
		styleFlags |= ComponentPeer::windowIsResizable;

	return styleFlags;
}

void ResizableWindow::addToDesktop()
{
	Component::addToDesktop (ResizableWindow::getDesktopWindowStyleFlags());
	setDropShadowEnabled (isDropShadowEnabled()); // force an update to clear away any fake shadows if necessary.
}

void ResizableWindow::clearContentComponent()
{
	if (ownsContentComponent)
	{
		contentComponent.deleteAndZero();
	}
	else
	{
		removeChildComponent (contentComponent);
		contentComponent = nullptr;
	}
}

void ResizableWindow::setContent (Component* newContentComponent,
								  const bool takeOwnership,
								  const bool resizeToFitWhenContentChangesSize)
{
	if (newContentComponent != contentComponent)
	{
		clearContentComponent();

		contentComponent = newContentComponent;
		Component::addAndMakeVisible (contentComponent);
	}

	ownsContentComponent = takeOwnership;
	resizeToFitContent = resizeToFitWhenContentChangesSize;

	if (resizeToFitWhenContentChangesSize)
		childBoundsChanged (contentComponent);

	resized(); // must always be called to position the new content comp
}

void ResizableWindow::setContentOwned (Component* newContentComponent, const bool resizeToFitWhenContentChangesSize)
{
	setContent (newContentComponent, true, resizeToFitWhenContentChangesSize);
}

void ResizableWindow::setContentNonOwned (Component* newContentComponent, const bool resizeToFitWhenContentChangesSize)
{
	setContent (newContentComponent, false, resizeToFitWhenContentChangesSize);
}

void ResizableWindow::setContentComponent (Component* const newContentComponent,
										   const bool deleteOldOne,
										   const bool resizeToFitWhenContentChangesSize)
{
	if (newContentComponent != contentComponent)
	{
		if (deleteOldOne)
		{
			contentComponent.deleteAndZero();
		}
		else
		{
			removeChildComponent (contentComponent);
			contentComponent = nullptr;
		}
	}

	setContent (newContentComponent, true, resizeToFitWhenContentChangesSize);
}

void ResizableWindow::setContentComponentSize (int width, int height)
{
	jassert (width > 0 && height > 0); // not a great idea to give it a zero size..

	const BorderSize<int> border (getContentComponentBorder());

	setSize (width + border.getLeftAndRight(),
			 height + border.getTopAndBottom());
}

BorderSize<int> ResizableWindow::getBorderThickness()
{
	return BorderSize<int> (isUsingNativeTitleBar() ? 0 : ((resizableBorder != nullptr && ! isFullScreen()) ? 5 : 3));
}

BorderSize<int> ResizableWindow::getContentComponentBorder()
{
	return getBorderThickness();
}

void ResizableWindow::moved()
{
	updateLastPos();
}

void ResizableWindow::visibilityChanged()
{
	TopLevelWindow::visibilityChanged();

	updateLastPos();
}

void ResizableWindow::resized()
{
	if (resizableBorder != nullptr)
	{
	   #if JUCE_WINDOWS || JUCE_LINUX
		// hide the resizable border if the OS already provides one..
		resizableBorder->setVisible (! (isFullScreen() || isUsingNativeTitleBar()));
	   #else
		resizableBorder->setVisible (! isFullScreen());
	   #endif

		resizableBorder->setBorderThickness (getBorderThickness());
		resizableBorder->setSize (getWidth(), getHeight());
		resizableBorder->toBack();
	}

	if (resizableCorner != nullptr)
	{
	   #if JUCE_MAC
		// hide the resizable border if the OS already provides one..
		resizableCorner->setVisible (! (isFullScreen() || isUsingNativeTitleBar()));
	   #else
		resizableCorner->setVisible (! isFullScreen());
	   #endif

		const int resizerSize = 18;
		resizableCorner->setBounds (getWidth() - resizerSize,
									getHeight() - resizerSize,
									resizerSize, resizerSize);
	}

	if (contentComponent != nullptr)
	{
		// The window expects to be able to be able to manage the size and position
		// of its content component, so you can't arbitrarily add a transform to it!
		jassert (! contentComponent->isTransformed());

		contentComponent->setBoundsInset (getContentComponentBorder());
	}

	updateLastPos();

   #if JUCE_DEBUG
	hasBeenResized = true;
   #endif
}

void ResizableWindow::childBoundsChanged (Component* child)
{
	if ((child == contentComponent) && (child != nullptr) && resizeToFitContent)
	{
		// not going to look very good if this component has a zero size..
		jassert (child->getWidth() > 0);
		jassert (child->getHeight() > 0);

		const BorderSize<int> borders (getContentComponentBorder());

		setSize (child->getWidth() + borders.getLeftAndRight(),
				 child->getHeight() + borders.getTopAndBottom());
	}
}

void ResizableWindow::activeWindowStatusChanged()
{
	const BorderSize<int> border (getContentComponentBorder());

	Rectangle<int> area (getLocalBounds());
	repaint (area.removeFromTop (border.getTop()));
	repaint (area.removeFromLeft (border.getLeft()));
	repaint (area.removeFromRight (border.getRight()));
	repaint (area.removeFromBottom (border.getBottom()));
}

void ResizableWindow::setResizable (const bool shouldBeResizable,
									const bool useBottomRightCornerResizer)
{
	if (shouldBeResizable)
	{
		if (useBottomRightCornerResizer)
		{
			resizableBorder = nullptr;

			if (resizableCorner == nullptr)
			{
				Component::addChildComponent (resizableCorner = new ResizableCornerComponent (this, constrainer));
				resizableCorner->setAlwaysOnTop (true);
			}
		}
		else
		{
			resizableCorner = nullptr;

			if (resizableBorder == nullptr)
				Component::addChildComponent (resizableBorder = new ResizableBorderComponent (this, constrainer));
		}
	}
	else
	{
		resizableCorner = nullptr;
		resizableBorder = nullptr;
	}

	if (isUsingNativeTitleBar())
		recreateDesktopWindow();

	childBoundsChanged (contentComponent);
	resized();
}

bool ResizableWindow::isResizable() const noexcept
{
	return resizableCorner != nullptr
		|| resizableBorder != nullptr;
}

void ResizableWindow::setResizeLimits (const int newMinimumWidth,
									   const int newMinimumHeight,
									   const int newMaximumWidth,
									   const int newMaximumHeight) noexcept
{
	// if you've set up a custom constrainer then these settings won't have any effect..
	jassert (constrainer == &defaultConstrainer || constrainer == nullptr);

	if (constrainer == nullptr)
		setConstrainer (&defaultConstrainer);

	defaultConstrainer.setSizeLimits (newMinimumWidth, newMinimumHeight,
									  newMaximumWidth, newMaximumHeight);

	setBoundsConstrained (getBounds());
}

void ResizableWindow::setConstrainer (ComponentBoundsConstrainer* newConstrainer)
{
	if (constrainer != newConstrainer)
	{
		constrainer = newConstrainer;

		const bool useBottomRightCornerResizer = resizableCorner != nullptr;
		const bool shouldBeResizable = useBottomRightCornerResizer || resizableBorder != nullptr;

		resizableCorner = nullptr;
		resizableBorder = nullptr;

		setResizable (shouldBeResizable, useBottomRightCornerResizer);

		ComponentPeer* const peer = getPeer();
		if (peer != nullptr)
			peer->setConstrainer (newConstrainer);
	}
}

void ResizableWindow::setBoundsConstrained (const Rectangle<int>& newBounds)
{
	if (constrainer != nullptr)
		constrainer->setBoundsForComponent (this, newBounds, false, false, false, false);
	else
		setBounds (newBounds);
}

void ResizableWindow::paint (Graphics& g)
{
	getLookAndFeel().fillResizableWindowBackground (g, getWidth(), getHeight(),
													getBorderThickness(), *this);

	if (! isFullScreen())
	{
		getLookAndFeel().drawResizableWindowBorder (g, getWidth(), getHeight(),
													getBorderThickness(), *this);
	}

   #if JUCE_DEBUG
	/* If this fails, then you've probably written a subclass with a resized()
	   callback but forgotten to make it call its parent class's resized() method.

	   It's important when you override methods like resized(), moved(),
	   etc., that you make sure the base class methods also get called.

	   Of course you shouldn't really be overriding ResizableWindow::resized() anyway,
	   because your content should all be inside the content component - and it's the
	   content component's resized() method that you should be using to do your
	   layout.
	*/
	jassert (hasBeenResized || (getWidth() == 0 && getHeight() == 0));
   #endif
}

void ResizableWindow::lookAndFeelChanged()
{
	resized();

	if (isOnDesktop())
	{
		Component::addToDesktop (getDesktopWindowStyleFlags());

		ComponentPeer* const peer = getPeer();
		if (peer != nullptr)
			peer->setConstrainer (constrainer);
	}
}

Colour ResizableWindow::getBackgroundColour() const noexcept
{
	return findColour (backgroundColourId, false);
}

void ResizableWindow::setBackgroundColour (const Colour& newColour)
{
	Colour backgroundColour (newColour);

	if (! Desktop::canUseSemiTransparentWindows())
		backgroundColour = newColour.withAlpha (1.0f);

	setColour (backgroundColourId, backgroundColour);

	setOpaque (backgroundColour.isOpaque());
	repaint();
}

bool ResizableWindow::isFullScreen() const
{
	if (isOnDesktop())
	{
		ComponentPeer* const peer = getPeer();
		return peer != nullptr && peer->isFullScreen();
	}

	return fullscreen;
}

void ResizableWindow::setFullScreen (const bool shouldBeFullScreen)
{
	if (shouldBeFullScreen != isFullScreen())
	{
		updateLastPos();
		fullscreen = shouldBeFullScreen;

		if (isOnDesktop())
		{
			ComponentPeer* const peer = getPeer();

			if (peer != nullptr)
			{
				// keep a copy of this intact in case the real one gets messed-up while we're un-maximising
				const Rectangle<int> lastPos (lastNonFullScreenPos);

				peer->setFullScreen (shouldBeFullScreen);

				if ((! shouldBeFullScreen) && ! lastPos.isEmpty())
					setBounds (lastPos);
			}
			else
			{
				jassertfalse;
			}
		}
		else
		{
			if (shouldBeFullScreen)
				setBounds (0, 0, getParentWidth(), getParentHeight());
			else
				setBounds (lastNonFullScreenPos);
		}

		resized();
	}
}

bool ResizableWindow::isMinimised() const
{
	ComponentPeer* const peer = getPeer();

	return (peer != nullptr) && peer->isMinimised();
}

void ResizableWindow::setMinimised (const bool shouldMinimise)
{
	if (shouldMinimise != isMinimised())
	{
		ComponentPeer* const peer = getPeer();

		if (peer != nullptr)
		{
			updateLastPos();
			peer->setMinimised (shouldMinimise);
		}
		else
		{
			jassertfalse;
		}
	}
}

void ResizableWindow::updateLastPos()
{
	if (isShowing() && ! (isFullScreen() || isMinimised()))
		lastNonFullScreenPos = getBounds();
}

void ResizableWindow::parentSizeChanged()
{
	if (isFullScreen() && getParentComponent() != nullptr)
		setBounds (0, 0, getParentWidth(), getParentHeight());
}

String ResizableWindow::getWindowStateAsString()
{
	updateLastPos();
	return (isFullScreen() ? "fs " : "") + lastNonFullScreenPos.toString();
}

bool ResizableWindow::restoreWindowStateFromString (const String& s)
{
	StringArray tokens;
	tokens.addTokens (s, false);
	tokens.removeEmptyStrings();
	tokens.trim();

	const bool fs = tokens[0].startsWithIgnoreCase ("fs");
	const int firstCoord = fs ? 1 : 0;

	if (tokens.size() != firstCoord + 4)
		return false;

	Rectangle<int> newPos (tokens[firstCoord].getIntValue(),
						   tokens[firstCoord + 1].getIntValue(),
						   tokens[firstCoord + 2].getIntValue(),
						   tokens[firstCoord + 3].getIntValue());

	if (newPos.isEmpty())
		return false;

	ComponentPeer* const peer = isOnDesktop() ? getPeer() : nullptr;
	if (peer != nullptr)
		peer->getFrameSize().addTo (newPos);

	{
		Desktop& desktop = Desktop::getInstance();
		RectangleList allMonitors (desktop.getAllMonitorDisplayAreas());
		allMonitors.clipTo (newPos);
		const Rectangle<int> onScreenArea (allMonitors.getBounds());

		if (onScreenArea.getWidth() * onScreenArea.getHeight() < 32 * 32)
		{
			const Rectangle<int> screen (desktop.getMonitorAreaContaining (newPos.getCentre()));

			newPos.setSize (jmin (newPos.getWidth(),  screen.getWidth()),
							jmin (newPos.getHeight(), screen.getHeight()));

			newPos.setPosition (jlimit (screen.getX(), screen.getRight()  - newPos.getWidth(),  newPos.getX()),
								jlimit (screen.getY(), screen.getBottom() - newPos.getHeight(), newPos.getY()));
		}
	}

	if (peer != nullptr)
	{
		peer->getFrameSize().subtractFrom (newPos);
		peer->setNonFullScreenBounds (newPos);
	}

	lastNonFullScreenPos = newPos;
	setFullScreen (fs);

	if (! fs)
		setBoundsConstrained (newPos);

	return true;
}

void ResizableWindow::mouseDown (const MouseEvent& e)
{
	if (! isFullScreen())
		dragger.startDraggingComponent (this, e);
}

void ResizableWindow::mouseDrag (const MouseEvent& e)
{
	if (! isFullScreen())
		dragger.dragComponent (this, e, constrainer);
}

#if JUCE_DEBUG
void ResizableWindow::addChildComponent (Component* const child, int zOrder)
{
	/* Agh! You shouldn't add components directly to a ResizableWindow - this class
	   manages its child components automatically, and if you add your own it'll cause
	   trouble. Instead, use setContentComponent() to give it a component which
	   will be automatically resized and kept in the right place - then you can add
	   subcomponents to the content comp. See the notes for the ResizableWindow class
	   for more info.

	   If you really know what you're doing and want to avoid this assertion, just call
	   Component::addChildComponent directly.
	*/
	jassertfalse;

	Component::addChildComponent (child, zOrder);
}

void ResizableWindow::addAndMakeVisible (Component* const child, int zOrder)
{
	/* Agh! You shouldn't add components directly to a ResizableWindow - this class
	   manages its child components automatically, and if you add your own it'll cause
	   trouble. Instead, use setContentComponent() to give it a component which
	   will be automatically resized and kept in the right place - then you can add
	   subcomponents to the content comp. See the notes for the ResizableWindow class
	   for more info.

	   If you really know what you're doing and want to avoid this assertion, just call
	   Component::addAndMakeVisible directly.
	*/
	jassertfalse;

	Component::addAndMakeVisible (child, zOrder);
}
#endif

/*** End of inlined file: juce_ResizableWindow.cpp ***/


/*** Start of inlined file: juce_ThreadWithProgressWindow.cpp ***/
ThreadWithProgressWindow::ThreadWithProgressWindow (const String& title,
													const bool hasProgressBar,
													const bool hasCancelButton,
													const int timeOutMsWhenCancelling_,
													const String& cancelButtonText)
  : Thread ("Juce Progress Window"),
	progress (0.0),
	timeOutMsWhenCancelling (timeOutMsWhenCancelling_)
{
	alertWindow = LookAndFeel::getDefaultLookAndFeel()
					.createAlertWindow (title, String::empty, cancelButtonText,
										String::empty, String::empty,
										AlertWindow::NoIcon, hasCancelButton ? 1 : 0, 0);

	// if there are no buttons, we won't allow the user to interrupt the thread.
	alertWindow->setEscapeKeyCancels (false);

	if (hasProgressBar)
		alertWindow->addProgressBarComponent (progress);
}

ThreadWithProgressWindow::~ThreadWithProgressWindow()
{
	stopThread (timeOutMsWhenCancelling);
}

#if JUCE_MODAL_LOOPS_PERMITTED
bool ThreadWithProgressWindow::runThread (const int priority)
{
	jassert (MessageManager::getInstance()->isThisTheMessageThread());

	startThread (priority);
	startTimer (100);

	{
		const ScopedLock sl (messageLock);
		alertWindow->setMessage (message);
	}

	const bool finishedNaturally = alertWindow->runModalLoop() != 0;

	stopThread (timeOutMsWhenCancelling);

	alertWindow->setVisible (false);

	return finishedNaturally;
}
#endif

void ThreadWithProgressWindow::setProgress (const double newProgress)
{
	progress = newProgress;
}

void ThreadWithProgressWindow::setStatusMessage (const String& newStatusMessage)
{
	const ScopedLock sl (messageLock);
	message = newStatusMessage;
}

void ThreadWithProgressWindow::timerCallback()
{
	if (! isThreadRunning())
	{
		// thread has finished normally..
		alertWindow->exitModalState (1);
		alertWindow->setVisible (false);
	}
	else
	{
		const ScopedLock sl (messageLock);
		alertWindow->setMessage (message);
	}
}

/*** End of inlined file: juce_ThreadWithProgressWindow.cpp ***/


/*** Start of inlined file: juce_TooltipWindow.cpp ***/
TooltipWindow::TooltipWindow (Component* const parent_,
							  const int millisecondsBeforeTipAppears_)
	: Component ("tooltip"),
	  millisecondsBeforeTipAppears (millisecondsBeforeTipAppears_),
	  mouseClicks (0),
	  lastHideTime (0),
	  lastComponentUnderMouse (nullptr),
	  changedCompsSinceShown (true)
{
	if (Desktop::getInstance().getMainMouseSource().canHover())
		startTimer (123);

	setAlwaysOnTop (true);
	setOpaque (true);

	if (parent_ != nullptr)
		parent_->addChildComponent (this);
}

TooltipWindow::~TooltipWindow()
{
	hide();
}

void TooltipWindow::setMillisecondsBeforeTipAppears (const int newTimeMs) noexcept
{
	millisecondsBeforeTipAppears = newTimeMs;
}

void TooltipWindow::paint (Graphics& g)
{
	getLookAndFeel().drawTooltip (g, tipShowing, getWidth(), getHeight());
}

void TooltipWindow::mouseEnter (const MouseEvent&)
{
	hide();
}

void TooltipWindow::showFor (const String& tip)
{
	jassert (tip.isNotEmpty());
	if (tipShowing != tip)
		repaint();

	tipShowing = tip;

	Point<int> mousePos (Desktop::getMousePosition());
	Rectangle<int> parentArea;

	if (getParentComponent() != nullptr)
	{
		mousePos = getParentComponent()->getLocalPoint (nullptr, mousePos);
		parentArea = getParentComponent()->getLocalBounds();
	}
	else
	{
		parentArea = Desktop::getInstance().getMonitorAreaContaining (mousePos);
	}

	int w, h;
	getLookAndFeel().getTooltipSize (tip, w, h);

	int x = mousePos.x;
	if (x > parentArea.getCentreX())
		x -= (w + 12);
	else
		x += 24;

	int y = mousePos.y;
	if (y > parentArea.getCentreY())
		y -= (h + 6);
	else
		y += 6;

	x = jlimit (parentArea.getX(), parentArea.getRight() - w, x);
	y = jlimit (parentArea.getY(), parentArea.getBottom() - h, y);

	setBounds (x, y, w, h);
	setVisible (true);

	if (getParentComponent() == nullptr)
	{
		addToDesktop (ComponentPeer::windowHasDropShadow
						| ComponentPeer::windowIsTemporary
						| ComponentPeer::windowIgnoresKeyPresses);
	}

	toFront (false);
}

String TooltipWindow::getTipFor (Component* const c)
{
	if (c != nullptr
		 && Process::isForegroundProcess()
		 && ! Component::isMouseButtonDownAnywhere())
	{
		TooltipClient* const ttc = dynamic_cast <TooltipClient*> (c);

		if (ttc != nullptr && ! c->isCurrentlyBlockedByAnotherModalComponent())
			return ttc->getTooltip();
	}

	return String::empty;
}

void TooltipWindow::hide()
{
	tipShowing = String::empty;
	removeFromDesktop();
	setVisible (false);
}

void TooltipWindow::timerCallback()
{
	const unsigned int now = Time::getApproximateMillisecondCounter();
	Component* const newComp = Desktop::getInstance().getMainMouseSource().getComponentUnderMouse();
	const String newTip (getTipFor (newComp));

	const bool tipChanged = (newTip != lastTipUnderMouse || newComp != lastComponentUnderMouse);
	lastComponentUnderMouse = newComp;
	lastTipUnderMouse = newTip;

	const int clickCount = Desktop::getInstance().getMouseButtonClickCounter();
	const bool mouseWasClicked = clickCount > mouseClicks;
	mouseClicks = clickCount;

	const Point<int> mousePos (Desktop::getMousePosition());
	const bool mouseMovedQuickly = mousePos.getDistanceFrom (lastMousePos) > 12;
	lastMousePos = mousePos;

	if (tipChanged || mouseWasClicked || mouseMovedQuickly)
		lastCompChangeTime = now;

	if (isVisible() || now < lastHideTime + 500)
	{
		// if a tip is currently visible (or has just disappeared), update to a new one
		// immediately if needed..
		if (newComp == nullptr || mouseWasClicked || newTip.isEmpty())
		{
			if (isVisible())
			{
				lastHideTime = now;
				hide();
			}
		}
		else if (tipChanged)
		{
			showFor (newTip);
		}
	}
	else
	{
		// if there isn't currently a tip, but one is needed, only let it
		// appear after a timeout..
		if (newTip.isNotEmpty()
			 && newTip != tipShowing
			 && now > lastCompChangeTime + millisecondsBeforeTipAppears)
		{
			showFor (newTip);
		}
	}
}

/*** End of inlined file: juce_TooltipWindow.cpp ***/


/*** Start of inlined file: juce_TopLevelWindow.cpp ***/
/** Keeps track of the active top level window. */
class TopLevelWindowManager  : public Timer,
							   public DeletedAtShutdown
{
public:

	TopLevelWindowManager()
		: currentActive (nullptr)
	{
	}

	~TopLevelWindowManager()
	{
		clearSingletonInstance();
	}

	juce_DeclareSingleton_SingleThreaded_Minimal (TopLevelWindowManager);

	void timerCallback()
	{
		startTimer (jmin (1731, getTimerInterval() * 2));

		TopLevelWindow* active = nullptr;

		if (Process::isForegroundProcess())
		{
			active = currentActive;

			Component* const c = Component::getCurrentlyFocusedComponent();
			TopLevelWindow* tlw = dynamic_cast <TopLevelWindow*> (c);

			if (tlw == nullptr && c != nullptr)
				// (unable to use the syntax findParentComponentOfClass <TopLevelWindow> () because of a VC6 compiler bug)
				tlw = c->findParentComponentOfClass ((TopLevelWindow*) nullptr);

			if (tlw != nullptr)
				active = tlw;
		}

		if (active != currentActive)
		{
			currentActive = active;

			for (int i = windows.size(); --i >= 0;)
			{
				TopLevelWindow* const tlw = windows.getUnchecked (i);
				tlw->setWindowActive (isWindowActive (tlw));

				i = jmin (i, windows.size() - 1);
			}

			Desktop::getInstance().triggerFocusCallback();
		}
	}

	bool addWindow (TopLevelWindow* const w)
	{
		windows.add (w);
		startTimer (10);

		return isWindowActive (w);
	}

	void removeWindow (TopLevelWindow* const w)
	{
		startTimer (10);

		if (currentActive == w)
			currentActive = nullptr;

		windows.removeValue (w);

		if (windows.size() == 0)
			deleteInstance();
	}

	Array <TopLevelWindow*> windows;

private:
	TopLevelWindow* currentActive;

	bool isWindowActive (TopLevelWindow* const tlw) const
	{
		return (tlw == currentActive
				 || tlw->isParentOf (currentActive)
				 || tlw->hasKeyboardFocus (true))
				&& tlw->isShowing();
	}

	JUCE_DECLARE_NON_COPYABLE (TopLevelWindowManager);
};

juce_ImplementSingleton_SingleThreaded (TopLevelWindowManager)

void juce_CheckCurrentlyFocusedTopLevelWindow()
{
	if (TopLevelWindowManager::getInstanceWithoutCreating() != nullptr)
		TopLevelWindowManager::getInstanceWithoutCreating()->startTimer (20);
}

TopLevelWindow::TopLevelWindow (const String& name,
								const bool addToDesktop_)
	: Component (name),
	  useDropShadow (true),
	  useNativeTitleBar (false),
	  windowIsActive_ (false)
{
	setOpaque (true);

	if (addToDesktop_)
		Component::addToDesktop (TopLevelWindow::getDesktopWindowStyleFlags());
	else
		setDropShadowEnabled (true);

	setWantsKeyboardFocus (true);
	setBroughtToFrontOnMouseClick (true);
	windowIsActive_ = TopLevelWindowManager::getInstance()->addWindow (this);
}

TopLevelWindow::~TopLevelWindow()
{
	shadower = nullptr;
	TopLevelWindowManager::getInstance()->removeWindow (this);
}

void TopLevelWindow::focusOfChildComponentChanged (FocusChangeType)
{
	if (hasKeyboardFocus (true))
		TopLevelWindowManager::getInstance()->timerCallback();
	else
		TopLevelWindowManager::getInstance()->startTimer (10);
}

void TopLevelWindow::setWindowActive (const bool isNowActive)
{
	if (windowIsActive_ != isNowActive)
	{
		windowIsActive_ = isNowActive;
		activeWindowStatusChanged();
	}
}

void TopLevelWindow::activeWindowStatusChanged()
{
}

void TopLevelWindow::visibilityChanged()
{
	if (isShowing()
		 && (getPeer()->getStyleFlags() & (ComponentPeer::windowIsTemporary
											| ComponentPeer::windowIgnoresKeyPresses)) == 0)
	{
		toFront (true);
	}
}

void TopLevelWindow::parentHierarchyChanged()
{
	setDropShadowEnabled (useDropShadow);
}

int TopLevelWindow::getDesktopWindowStyleFlags() const
{
	int styleFlags = ComponentPeer::windowAppearsOnTaskbar;

	if (useDropShadow)
		styleFlags |= ComponentPeer::windowHasDropShadow;

	if (useNativeTitleBar)
		styleFlags |= ComponentPeer::windowHasTitleBar;

	return styleFlags;
}

void TopLevelWindow::setDropShadowEnabled (const bool useShadow)
{
	useDropShadow = useShadow;

	if (isOnDesktop())
	{
		shadower = nullptr;
		Component::addToDesktop (getDesktopWindowStyleFlags());
	}
	else
	{
		if (useShadow && isOpaque())
		{
			if (shadower == nullptr)
			{
				shadower = getLookAndFeel().createDropShadowerForComponent (this);

				if (shadower != nullptr)
					shadower->setOwner (this);
			}
		}
		else
		{
			shadower = nullptr;
		}
	}
}

void TopLevelWindow::setUsingNativeTitleBar (const bool useNativeTitleBar_)
{
	if (useNativeTitleBar != useNativeTitleBar_)
	{
		useNativeTitleBar = useNativeTitleBar_;
		recreateDesktopWindow();
		sendLookAndFeelChange();
	}
}

void TopLevelWindow::recreateDesktopWindow()
{
	if (isOnDesktop())
	{
		Component::addToDesktop (getDesktopWindowStyleFlags());
		toFront (true);
	}
}

void TopLevelWindow::addToDesktop (int windowStyleFlags, void* nativeWindowToAttachTo)
{
	/* It's not recommended to change the desktop window flags directly for a TopLevelWindow,
	   because this class needs to make sure its layout corresponds with settings like whether
	   it's got a native title bar or not.

	   If you need custom flags for your window, you can override the getDesktopWindowStyleFlags()
	   method. If you do this, it's best to call the base class's getDesktopWindowStyleFlags()
	   method, then add or remove whatever flags are necessary from this value before returning it.
	*/

	jassert ((windowStyleFlags & ~ComponentPeer::windowIsSemiTransparent)
			   == (getDesktopWindowStyleFlags() & ~ComponentPeer::windowIsSemiTransparent));

	Component::addToDesktop (windowStyleFlags, nativeWindowToAttachTo);

	if (windowStyleFlags != getDesktopWindowStyleFlags())
		sendLookAndFeelChange();
}

void TopLevelWindow::centreAroundComponent (Component* c, const int width, const int height)
{
	if (c == nullptr)
		c = TopLevelWindow::getActiveTopLevelWindow();

	if (c == nullptr || c->getBounds().isEmpty())
	{
		centreWithSize (width, height);
	}
	else
	{
		Point<int> targetCentre (c->localPointToGlobal (c->getLocalBounds().getCentre()));
		Rectangle<int> parentArea (c->getParentMonitorArea());

		if (getParentComponent() != nullptr)
		{
			targetCentre = getParentComponent()->getLocalPoint (nullptr, targetCentre);
			parentArea = getParentComponent()->getLocalBounds();
		}

		parentArea.reduce (12, 12);

		setBounds (jlimit (parentArea.getX(), jmax (parentArea.getX(), parentArea.getRight() - width), targetCentre.getX() - width / 2),
				   jlimit (parentArea.getY(), jmax (parentArea.getY(), parentArea.getBottom() - height), targetCentre.getY() - height / 2),
				   width, height);
	}
}

int TopLevelWindow::getNumTopLevelWindows() noexcept
{
	return TopLevelWindowManager::getInstance()->windows.size();
}

TopLevelWindow* TopLevelWindow::getTopLevelWindow (const int index) noexcept
{
	return static_cast <TopLevelWindow*> (TopLevelWindowManager::getInstance()->windows [index]);
}

TopLevelWindow* TopLevelWindow::getActiveTopLevelWindow() noexcept
{
	TopLevelWindow* best = nullptr;
	int bestNumTWLParents = -1;

	for (int i = TopLevelWindow::getNumTopLevelWindows(); --i >= 0;)
	{
		TopLevelWindow* const tlw = TopLevelWindow::getTopLevelWindow (i);

		if (tlw->isActiveWindow())
		{
			int numTWLParents = 0;

			const Component* c = tlw->getParentComponent();

			while (c != nullptr)
			{
				if (dynamic_cast <const TopLevelWindow*> (c) != nullptr)
					++numTWLParents;

				c = c->getParentComponent();
			}

			if (bestNumTWLParents < numTWLParents)
			{
				best = tlw;
				bestNumTWLParents = numTWLParents;
			}
		}
	}

	return best;
}

/*** End of inlined file: juce_TopLevelWindow.cpp ***/


/*** Start of inlined file: juce_ApplicationCommandInfo.cpp ***/
ApplicationCommandInfo::ApplicationCommandInfo (const CommandID commandID_) noexcept
	: commandID (commandID_),
	  flags (0)
{
}

void ApplicationCommandInfo::setInfo (const String& shortName_,
									  const String& description_,
									  const String& categoryName_,
									  const int flags_) noexcept
{
	shortName = shortName_;
	description = description_;
	categoryName = categoryName_;
	flags = flags_;
}

void ApplicationCommandInfo::setActive (const bool b) noexcept
{
	if (b)
		flags &= ~isDisabled;
	else
		flags |= isDisabled;
}

void ApplicationCommandInfo::setTicked (const bool b) noexcept
{
	if (b)
		flags |= isTicked;
	else
		flags &= ~isTicked;
}

void ApplicationCommandInfo::addDefaultKeypress (const int keyCode, const ModifierKeys& modifiers) noexcept
{
	defaultKeypresses.add (KeyPress (keyCode, modifiers, 0));
}

/*** End of inlined file: juce_ApplicationCommandInfo.cpp ***/


/*** Start of inlined file: juce_ApplicationCommandManager.cpp ***/
ApplicationCommandManager::ApplicationCommandManager()
	: firstTarget (nullptr)
{
	keyMappings = new KeyPressMappingSet (this);

	Desktop::getInstance().addFocusChangeListener (this);
}

ApplicationCommandManager::~ApplicationCommandManager()
{
	Desktop::getInstance().removeFocusChangeListener (this);
	keyMappings = nullptr;
}

void ApplicationCommandManager::clearCommands()
{
	commands.clear();
	keyMappings->clearAllKeyPresses();
	triggerAsyncUpdate();
}

void ApplicationCommandManager::registerCommand (const ApplicationCommandInfo& newCommand)
{
	// zero isn't a valid command ID!
	jassert (newCommand.commandID != 0);

	// the name isn't optional!
	jassert (newCommand.shortName.isNotEmpty());

	if (getCommandForID (newCommand.commandID) == 0)
	{
		ApplicationCommandInfo* const newInfo = new ApplicationCommandInfo (newCommand);
		newInfo->flags &= ~ApplicationCommandInfo::isTicked;
		commands.add (newInfo);

		keyMappings->resetToDefaultMapping (newCommand.commandID);

		triggerAsyncUpdate();
	}
	else
	{
		// trying to re-register the same command with different parameters?
		jassert (newCommand.shortName == getCommandForID (newCommand.commandID)->shortName
				  && (newCommand.description == getCommandForID (newCommand.commandID)->description || newCommand.description.isEmpty())
				  && newCommand.categoryName == getCommandForID (newCommand.commandID)->categoryName
				  && newCommand.defaultKeypresses == getCommandForID (newCommand.commandID)->defaultKeypresses
				  && (newCommand.flags & (ApplicationCommandInfo::wantsKeyUpDownCallbacks | ApplicationCommandInfo::hiddenFromKeyEditor | ApplicationCommandInfo::readOnlyInKeyEditor))
					   == (getCommandForID (newCommand.commandID)->flags & (ApplicationCommandInfo::wantsKeyUpDownCallbacks | ApplicationCommandInfo::hiddenFromKeyEditor | ApplicationCommandInfo::readOnlyInKeyEditor)));
	}
}

void ApplicationCommandManager::registerAllCommandsForTarget (ApplicationCommandTarget* target)
{
	if (target != nullptr)
	{
		Array <CommandID> commandIDs;
		target->getAllCommands (commandIDs);

		for (int i = 0; i < commandIDs.size(); ++i)
		{
			ApplicationCommandInfo info (commandIDs.getUnchecked(i));
			target->getCommandInfo (info.commandID, info);

			registerCommand (info);
		}
	}
}

void ApplicationCommandManager::removeCommand (const CommandID commandID)
{
	for (int i = commands.size(); --i >= 0;)
	{
		if (commands.getUnchecked (i)->commandID == commandID)
		{
			commands.remove (i);
			triggerAsyncUpdate();

			const Array <KeyPress> keys (keyMappings->getKeyPressesAssignedToCommand (commandID));

			for (int j = keys.size(); --j >= 0;)
				keyMappings->removeKeyPress (keys.getReference (j));
		}
	}
}

void ApplicationCommandManager::commandStatusChanged()
{
	triggerAsyncUpdate();
}

const ApplicationCommandInfo* ApplicationCommandManager::getCommandForID (const CommandID commandID) const noexcept
{
	for (int i = commands.size(); --i >= 0;)
		if (commands.getUnchecked(i)->commandID == commandID)
			return commands.getUnchecked(i);

	return nullptr;
}

String ApplicationCommandManager::getNameOfCommand (const CommandID commandID) const noexcept
{
	const ApplicationCommandInfo* const ci = getCommandForID (commandID);

	return ci != nullptr ? ci->shortName : String::empty;
}

String ApplicationCommandManager::getDescriptionOfCommand (const CommandID commandID) const noexcept
{
	const ApplicationCommandInfo* const ci = getCommandForID (commandID);

	return ci != nullptr ? (ci->description.isNotEmpty() ? ci->description : ci->shortName)
						 : String::empty;
}

StringArray ApplicationCommandManager::getCommandCategories() const
{
	StringArray s;

	for (int i = 0; i < commands.size(); ++i)
		s.addIfNotAlreadyThere (commands.getUnchecked(i)->categoryName, false);

	return s;
}

Array<CommandID> ApplicationCommandManager::getCommandsInCategory (const String& categoryName) const
{
	Array <CommandID> results;

	for (int i = 0; i < commands.size(); ++i)
		if (commands.getUnchecked(i)->categoryName == categoryName)
			results.add (commands.getUnchecked(i)->commandID);

	return results;
}

bool ApplicationCommandManager::invokeDirectly (const CommandID commandID, const bool asynchronously)
{
	ApplicationCommandTarget::InvocationInfo info (commandID);
	info.invocationMethod = ApplicationCommandTarget::InvocationInfo::direct;

	return invoke (info, asynchronously);
}

bool ApplicationCommandManager::invoke (const ApplicationCommandTarget::InvocationInfo& info_, const bool asynchronously)
{
	// This call isn't thread-safe for use from a non-UI thread without locking the message
	// manager first..
	jassert (MessageManager::getInstance()->currentThreadHasLockedMessageManager());

	ApplicationCommandInfo commandInfo (0);
	ApplicationCommandTarget* const target = getTargetForCommand (info_.commandID, commandInfo);

	if (target == nullptr)
		return false;

	ApplicationCommandTarget::InvocationInfo info (info_);
	info.commandFlags = commandInfo.flags;

	sendListenerInvokeCallback (info);

	const bool ok = target->invoke (info, asynchronously);

	commandStatusChanged();

	return ok;
}

ApplicationCommandTarget* ApplicationCommandManager::getFirstCommandTarget (const CommandID)
{
	return firstTarget != nullptr ? firstTarget
								  : findDefaultComponentTarget();
}

void ApplicationCommandManager::setFirstCommandTarget (ApplicationCommandTarget* const newTarget) noexcept
{
	firstTarget = newTarget;
}

ApplicationCommandTarget* ApplicationCommandManager::getTargetForCommand (const CommandID commandID,
																		  ApplicationCommandInfo& upToDateInfo)
{
	ApplicationCommandTarget* target = getFirstCommandTarget (commandID);

	if (target == nullptr)
		target = JUCEApplication::getInstance();

	if (target != nullptr)
		target = target->getTargetForCommand (commandID);

	if (target != nullptr)
		target->getCommandInfo (commandID, upToDateInfo);

	return target;
}

ApplicationCommandTarget* ApplicationCommandManager::findTargetForComponent (Component* c)
{
	ApplicationCommandTarget* target = dynamic_cast <ApplicationCommandTarget*> (c);

	if (target == nullptr && c != nullptr)
		// (unable to use the syntax findParentComponentOfClass <ApplicationCommandTarget> () because of a VC6 compiler bug)
		target = c->findParentComponentOfClass ((ApplicationCommandTarget*) nullptr);

	return target;
}

ApplicationCommandTarget* ApplicationCommandManager::findDefaultComponentTarget()
{
	Component* c = Component::getCurrentlyFocusedComponent();

	if (c == nullptr)
	{
		TopLevelWindow* const activeWindow = TopLevelWindow::getActiveTopLevelWindow();

		if (activeWindow != nullptr)
		{
			c = activeWindow->getPeer()->getLastFocusedSubcomponent();

			if (c == nullptr)
				c = activeWindow;
		}
	}

	if (c == nullptr && Process::isForegroundProcess())
	{
		// getting a bit desperate now - try all desktop comps..
		for (int i = Desktop::getInstance().getNumComponents(); --i >= 0;)
		{
			ApplicationCommandTarget* const target
				= findTargetForComponent (Desktop::getInstance().getComponent (i)
											  ->getPeer()->getLastFocusedSubcomponent());

			if (target != nullptr)
				return target;
		}
	}

	if (c != nullptr)
	{
		ResizableWindow* const resizableWindow = dynamic_cast <ResizableWindow*> (c);

		// if we're focused on a ResizableWindow, chances are that it's the content
		// component that really should get the event. And if not, the event will
		// still be passed up to the top level window anyway, so let's send it to the
		// content comp.
		if (resizableWindow != nullptr && resizableWindow->getContentComponent() != nullptr)
			c = resizableWindow->getContentComponent();

		ApplicationCommandTarget* const target = findTargetForComponent (c);

		if (target != nullptr)
			return target;
	}

	return JUCEApplication::getInstance();
}

void ApplicationCommandManager::addListener (ApplicationCommandManagerListener* const listener)
{
	listeners.add (listener);
}

void ApplicationCommandManager::removeListener (ApplicationCommandManagerListener* const listener)
{
	listeners.remove (listener);
}

void ApplicationCommandManager::sendListenerInvokeCallback (const ApplicationCommandTarget::InvocationInfo& info)
{
	listeners.call (&ApplicationCommandManagerListener::applicationCommandInvoked, info);
}

void ApplicationCommandManager::handleAsyncUpdate()
{
	listeners.call (&ApplicationCommandManagerListener::applicationCommandListChanged);
}

void ApplicationCommandManager::globalFocusChanged (Component*)
{
	commandStatusChanged();
}

/*** End of inlined file: juce_ApplicationCommandManager.cpp ***/


/*** Start of inlined file: juce_ApplicationCommandTarget.cpp ***/
class ApplicationCommandTarget::MessageTarget  : public MessageListener
{
public:
	MessageTarget (ApplicationCommandTarget& owner_)
		: owner (owner_)
	{
	}

	void handleMessage (const Message& message)
	{
		jassert (dynamic_cast <const InvokedMessage*> (&message) != nullptr);

		owner.tryToInvoke (dynamic_cast <const InvokedMessage&> (message).info, false);
	}

	struct InvokedMessage   : public Message
	{
		InvokedMessage (const InvocationInfo& info_)
			: info (info_)
		{}

		const InvocationInfo info;

	private:
		JUCE_DECLARE_NON_COPYABLE (InvokedMessage);
	};

private:
	ApplicationCommandTarget& owner;

	JUCE_DECLARE_NON_COPYABLE (MessageTarget);
};

ApplicationCommandTarget::ApplicationCommandTarget()
{
}

ApplicationCommandTarget::~ApplicationCommandTarget()
{
	messageInvoker = nullptr;
}

bool ApplicationCommandTarget::tryToInvoke (const InvocationInfo& info, const bool async)
{
	if (isCommandActive (info.commandID))
	{
		if (async)
		{
			if (messageInvoker == nullptr)
				messageInvoker = new MessageTarget (*this);

			messageInvoker->postMessage (new MessageTarget::InvokedMessage (info));
			return true;
		}
		else
		{
			const bool success = perform (info);

			jassert (success);  // hmm - your target should have been able to perform this command. If it can't
								// do it at the moment for some reason, it should clear the 'isActive' flag when it
								// returns the command's info.
			return success;
		}
	}

	return false;
}

ApplicationCommandTarget* ApplicationCommandTarget::findFirstTargetParentComponent()
{
	Component* c = dynamic_cast <Component*> (this);

	if (c != nullptr)
		// (unable to use the syntax findParentComponentOfClass <ApplicationCommandTarget> () because of a VC6 compiler bug)
		return c->findParentComponentOfClass ((ApplicationCommandTarget*) nullptr);

	return nullptr;
}

ApplicationCommandTarget* ApplicationCommandTarget::getTargetForCommand (const CommandID commandID)
{
	ApplicationCommandTarget* target = this;
	int depth = 0;

	while (target != nullptr)
	{
		Array <CommandID> commandIDs;
		target->getAllCommands (commandIDs);

		if (commandIDs.contains (commandID))
			return target;

		target = target->getNextCommandTarget();

		++depth;
		jassert (depth < 100); // could be a recursive command chain??
		jassert (target != this); // definitely a recursive command chain!

		if (depth > 100 || target == this)
			break;
	}

	if (target == nullptr)
	{
		target = JUCEApplication::getInstance();

		if (target != nullptr)
		{
			Array <CommandID> commandIDs;
			target->getAllCommands (commandIDs);

			if (commandIDs.contains (commandID))
				return target;
		}
	}

	return nullptr;
}

bool ApplicationCommandTarget::isCommandActive (const CommandID commandID)
{
	ApplicationCommandInfo info (commandID);
	info.flags = ApplicationCommandInfo::isDisabled;

	getCommandInfo (commandID, info);

	return (info.flags & ApplicationCommandInfo::isDisabled) == 0;
}

bool ApplicationCommandTarget::invoke (const InvocationInfo& info, const bool async)
{
	ApplicationCommandTarget* target = this;
	int depth = 0;

	while (target != nullptr)
	{
		if (target->tryToInvoke (info, async))
			return true;

		target = target->getNextCommandTarget();

		++depth;
		jassert (depth < 100); // could be a recursive command chain??
		jassert (target != this); // definitely a recursive command chain!

		if (depth > 100 || target == this)
			break;
	}

	if (target == nullptr)
	{
		target = JUCEApplication::getInstance();

		if (target != nullptr)
			return target->tryToInvoke (info, async);
	}

	return false;
}

bool ApplicationCommandTarget::invokeDirectly (const CommandID commandID, const bool asynchronously)
{
	ApplicationCommandTarget::InvocationInfo info (commandID);
	info.invocationMethod = ApplicationCommandTarget::InvocationInfo::direct;

	return invoke (info, asynchronously);
}

ApplicationCommandTarget::InvocationInfo::InvocationInfo (const CommandID commandID_)
	: commandID (commandID_),
	  commandFlags (0),
	  invocationMethod (direct),
	  originatingComponent (nullptr),
	  isKeyDown (false),
	  millisecsSinceKeyPressed (0)
{
}

/*** End of inlined file: juce_ApplicationCommandTarget.cpp ***/


/*** Start of inlined file: juce_KeyPressMappingSet.cpp ***/
KeyPressMappingSet::KeyPressMappingSet (ApplicationCommandManager* const commandManager_)
	: commandManager (commandManager_)
{
	// A manager is needed to get the descriptions of commands, and will be called when
	// a command is invoked. So you can't leave this null..
	jassert (commandManager_ != nullptr);

	Desktop::getInstance().addFocusChangeListener (this);
}

KeyPressMappingSet::KeyPressMappingSet (const KeyPressMappingSet& other)
	: commandManager (other.commandManager)
{
	Desktop::getInstance().addFocusChangeListener (this);
}

KeyPressMappingSet::~KeyPressMappingSet()
{
	Desktop::getInstance().removeFocusChangeListener (this);
}

Array<KeyPress> KeyPressMappingSet::getKeyPressesAssignedToCommand (const CommandID commandID) const
{
	for (int i = 0; i < mappings.size(); ++i)
		if (mappings.getUnchecked(i)->commandID == commandID)
			return mappings.getUnchecked (i)->keypresses;

	return Array<KeyPress>();
}

void KeyPressMappingSet::addKeyPress (const CommandID commandID,
									  const KeyPress& newKeyPress,
									  int insertIndex)
{
	// If you specify an upper-case letter but no shift key, how is the user supposed to press it!?
	// Stick to lower-case letters when defining a keypress, to avoid ambiguity.
	jassert (! (CharacterFunctions::isUpperCase (newKeyPress.getTextCharacter())
				 && ! newKeyPress.getModifiers().isShiftDown()));

	if (findCommandForKeyPress (newKeyPress) != commandID)
	{
		if (newKeyPress.isValid())
		{
			for (int i = mappings.size(); --i >= 0;)
			{
				if (mappings.getUnchecked(i)->commandID == commandID)
				{
					mappings.getUnchecked(i)->keypresses.insert (insertIndex, newKeyPress);

					sendChangeMessage();
					return;
				}
			}

			const ApplicationCommandInfo* const ci = commandManager->getCommandForID (commandID);

			if (ci != nullptr)
			{
				CommandMapping* const cm = new CommandMapping();
				cm->commandID = commandID;
				cm->keypresses.add (newKeyPress);
				cm->wantsKeyUpDownCallbacks = (ci->flags & ApplicationCommandInfo::wantsKeyUpDownCallbacks) != 0;

				mappings.add (cm);
				sendChangeMessage();
			}
		}
	}
}

void KeyPressMappingSet::resetToDefaultMappings()
{
	mappings.clear();

	for (int i = 0; i < commandManager->getNumCommands(); ++i)
	{
		const ApplicationCommandInfo* const ci = commandManager->getCommandForIndex (i);

		for (int j = 0; j < ci->defaultKeypresses.size(); ++j)
		{
			addKeyPress (ci->commandID,
						 ci->defaultKeypresses.getReference (j));
		}
	}

	sendChangeMessage();
}

void KeyPressMappingSet::resetToDefaultMapping (const CommandID commandID)
{
	clearAllKeyPresses (commandID);

	const ApplicationCommandInfo* const ci = commandManager->getCommandForID (commandID);

	for (int j = 0; j < ci->defaultKeypresses.size(); ++j)
	{
		addKeyPress (ci->commandID,
					 ci->defaultKeypresses.getReference (j));
	}
}

void KeyPressMappingSet::clearAllKeyPresses()
{
	if (mappings.size() > 0)
	{
		sendChangeMessage();
		mappings.clear();
	}
}

void KeyPressMappingSet::clearAllKeyPresses (const CommandID commandID)
{
	for (int i = mappings.size(); --i >= 0;)
	{
		if (mappings.getUnchecked(i)->commandID == commandID)
		{
			mappings.remove (i);
			sendChangeMessage();
		}
	}
}

void KeyPressMappingSet::removeKeyPress (const KeyPress& keypress)
{
	if (keypress.isValid())
	{
		for (int i = mappings.size(); --i >= 0;)
		{
			CommandMapping* const cm = mappings.getUnchecked(i);

			for (int j = cm->keypresses.size(); --j >= 0;)
			{
				if (keypress == cm->keypresses [j])
				{
					cm->keypresses.remove (j);
					sendChangeMessage();
				}
			}
		}
	}
}

void KeyPressMappingSet::removeKeyPress (const CommandID commandID, const int keyPressIndex)
{
	for (int i = mappings.size(); --i >= 0;)
	{
		if (mappings.getUnchecked(i)->commandID == commandID)
		{
			mappings.getUnchecked(i)->keypresses.remove (keyPressIndex);
			sendChangeMessage();
			break;
		}
	}
}

CommandID KeyPressMappingSet::findCommandForKeyPress (const KeyPress& keyPress) const noexcept
{
	for (int i = 0; i < mappings.size(); ++i)
		if (mappings.getUnchecked(i)->keypresses.contains (keyPress))
			return mappings.getUnchecked(i)->commandID;

	return 0;
}

bool KeyPressMappingSet::containsMapping (const CommandID commandID, const KeyPress& keyPress) const noexcept
{
	for (int i = mappings.size(); --i >= 0;)
		if (mappings.getUnchecked(i)->commandID == commandID)
			return mappings.getUnchecked(i)->keypresses.contains (keyPress);

	return false;
}

void KeyPressMappingSet::invokeCommand (const CommandID commandID,
										const KeyPress& key,
										const bool isKeyDown,
										const int millisecsSinceKeyPressed,
										Component* const originatingComponent) const
{
	ApplicationCommandTarget::InvocationInfo info (commandID);

	info.invocationMethod = ApplicationCommandTarget::InvocationInfo::fromKeyPress;
	info.isKeyDown = isKeyDown;
	info.keyPress = key;
	info.millisecsSinceKeyPressed = millisecsSinceKeyPressed;
	info.originatingComponent = originatingComponent;

	commandManager->invoke (info, false);
}

bool KeyPressMappingSet::restoreFromXml (const XmlElement& xmlVersion)
{
	if (xmlVersion.hasTagName ("KEYMAPPINGS"))
	{
		if (xmlVersion.getBoolAttribute ("basedOnDefaults", true))
		{
			// if the XML was created as a set of differences from the default mappings,
			// (i.e. by calling createXml (true)), then we need to first restore the defaults.
			resetToDefaultMappings();
		}
		else
		{
			// if the XML was created calling createXml (false), then we need to clear all
			// the keys and treat the xml as describing the entire set of mappings.
			clearAllKeyPresses();
		}

		forEachXmlChildElement (xmlVersion, map)
		{
			const CommandID commandId = map->getStringAttribute ("commandId").getHexValue32();

			if (commandId != 0)
			{
				const KeyPress key (KeyPress::createFromDescription (map->getStringAttribute ("key")));

				if (map->hasTagName ("MAPPING"))
				{
					addKeyPress (commandId, key);
				}
				else if (map->hasTagName ("UNMAPPING"))
				{
					if (containsMapping (commandId, key))
						removeKeyPress (key);
				}
			}
		}

		return true;
	}

	return false;
}

XmlElement* KeyPressMappingSet::createXml (const bool saveDifferencesFromDefaultSet) const
{
	ScopedPointer <KeyPressMappingSet> defaultSet;

	if (saveDifferencesFromDefaultSet)
	{
		defaultSet = new KeyPressMappingSet (commandManager);
		defaultSet->resetToDefaultMappings();
	}

	XmlElement* const doc = new XmlElement ("KEYMAPPINGS");

	doc->setAttribute ("basedOnDefaults", saveDifferencesFromDefaultSet);

	int i;
	for (i = 0; i < mappings.size(); ++i)
	{
		const CommandMapping* const cm = mappings.getUnchecked(i);

		for (int j = 0; j < cm->keypresses.size(); ++j)
		{
			if (defaultSet == nullptr
				 || ! defaultSet->containsMapping (cm->commandID, cm->keypresses.getReference (j)))
			{
				XmlElement* const map = doc->createNewChildElement ("MAPPING");

				map->setAttribute ("commandId", String::toHexString ((int) cm->commandID));
				map->setAttribute ("description", commandManager->getDescriptionOfCommand (cm->commandID));
				map->setAttribute ("key", cm->keypresses.getReference (j).getTextDescription());
			}
		}
	}

	if (defaultSet != nullptr)
	{
		for (i = 0; i < defaultSet->mappings.size(); ++i)
		{
			const CommandMapping* const cm = defaultSet->mappings.getUnchecked(i);

			for (int j = 0; j < cm->keypresses.size(); ++j)
			{
				if (! containsMapping (cm->commandID, cm->keypresses.getReference (j)))
				{
					XmlElement* const map = doc->createNewChildElement ("UNMAPPING");

					map->setAttribute ("commandId", String::toHexString ((int) cm->commandID));
					map->setAttribute ("description", commandManager->getDescriptionOfCommand (cm->commandID));
					map->setAttribute ("key", cm->keypresses.getReference (j).getTextDescription());
				}
			}
		}
	}

	return doc;
}

bool KeyPressMappingSet::keyPressed (const KeyPress& key,
									 Component* originatingComponent)
{
	bool commandWasDisabled = false;

	for (int i = 0; i < mappings.size(); ++i)
	{
		CommandMapping* const cm =  mappings.getUnchecked(i);

		if (cm->keypresses.contains (key))
		{
			const ApplicationCommandInfo* const ci = commandManager->getCommandForID (cm->commandID);

			if (ci != nullptr
				 && (ci->flags & ApplicationCommandInfo::wantsKeyUpDownCallbacks) == 0)
			{
				ApplicationCommandInfo info (0);

				if (commandManager->getTargetForCommand (cm->commandID, info) != 0)
				{
					if ((info.flags & ApplicationCommandInfo::isDisabled) == 0)
					{
						invokeCommand (cm->commandID, key, true, 0, originatingComponent);
						return true;
					}
					else
					{
						commandWasDisabled = true;
					}
				}
			}
		}
	}

	if (originatingComponent != nullptr && commandWasDisabled)
		originatingComponent->getLookAndFeel().playAlertSound();

	return false;
}

bool KeyPressMappingSet::keyStateChanged (const bool /*isKeyDown*/, Component* originatingComponent)
{
	bool used = false;
	const uint32 now = Time::getMillisecondCounter();

	for (int i = mappings.size(); --i >= 0;)
	{
		CommandMapping* const cm =  mappings.getUnchecked(i);

		if (cm->wantsKeyUpDownCallbacks)
		{
			for (int j = cm->keypresses.size(); --j >= 0;)
			{
				const KeyPress key (cm->keypresses.getReference (j));
				const bool isDown = key.isCurrentlyDown();

				int keyPressEntryIndex = 0;
				bool wasDown = false;

				for (int k = keysDown.size(); --k >= 0;)
				{
					if (key == keysDown.getUnchecked(k)->key)
					{
						keyPressEntryIndex = k;
						wasDown = true;
						used = true;
						break;
					}
				}

				if (isDown != wasDown)
				{
					int millisecs = 0;

					if (isDown)
					{
						KeyPressTime* const k = new KeyPressTime();
						k->key = key;
						k->timeWhenPressed = now;

						keysDown.add (k);
					}
					else
					{
						const uint32 pressTime = keysDown.getUnchecked (keyPressEntryIndex)->timeWhenPressed;

						if (now > pressTime)
							millisecs = (int) (now - pressTime);

						keysDown.remove (keyPressEntryIndex);
					}

					invokeCommand (cm->commandID, key, isDown, millisecs, originatingComponent);
					used = true;
				}
			}
		}
	}

	return used;
}

void KeyPressMappingSet::globalFocusChanged (Component* focusedComponent)
{
	if (focusedComponent != nullptr)
		focusedComponent->keyStateChanged (false);
}

/*** End of inlined file: juce_KeyPressMappingSet.cpp ***/


/*** Start of inlined file: juce_Application.cpp ***/
#if JUCE_MAC
 extern void juce_initialiseMacMainMenu();
#endif

class AppBroadcastCallback  : public ActionListener
{
public:
	AppBroadcastCallback()    { MessageManager::getInstance()->registerBroadcastListener (this); }
	~AppBroadcastCallback()   { MessageManager::getInstance()->deregisterBroadcastListener (this); }

	void actionListenerCallback (const String& message)
	{
		JUCEApplication* const app = JUCEApplication::getInstance();

		if (app != 0 && message.startsWith (app->getApplicationName() + "/"))
			app->anotherInstanceStarted (message.substring (app->getApplicationName().length() + 1));
	}
};

JUCEApplication::JUCEApplication()
	: appReturnValue (0),
	  stillInitialising (true)
{
}

JUCEApplication::~JUCEApplication()
{
	if (appLock != nullptr)
	{
		appLock->exit();
		appLock = nullptr;
	}
}

bool JUCEApplication::moreThanOneInstanceAllowed()
{
	return true;
}

void JUCEApplication::anotherInstanceStarted (const String&)
{
}

void JUCEApplication::systemRequestedQuit()
{
	quit();
}

void JUCEApplication::quit()
{
	MessageManager::getInstance()->stopDispatchLoop();
}

void JUCEApplication::setApplicationReturnValue (const int newReturnValue) noexcept
{
	appReturnValue = newReturnValue;
}

void JUCEApplication::unhandledException (const std::exception*,
										  const String&,
										  const int)
{
	jassertfalse;
}

void JUCEApplication::sendUnhandledException (const std::exception* const e,
											  const char* const sourceFile,
											  const int lineNumber)
{
	if (JUCEApplicationBase::getInstance() != nullptr)
		JUCEApplicationBase::getInstance()->unhandledException (e, sourceFile, lineNumber);
}

ApplicationCommandTarget* JUCEApplication::getNextCommandTarget()
{
	return nullptr;
}

void JUCEApplication::getAllCommands (Array <CommandID>& commands)
{
	commands.add (StandardApplicationCommandIDs::quit);
}

void JUCEApplication::getCommandInfo (const CommandID commandID, ApplicationCommandInfo& result)
{
	if (commandID == StandardApplicationCommandIDs::quit)
	{
		result.setInfo (TRANS("Quit"),
						TRANS("Quits the application"),
						"Application",
						0);

		result.defaultKeypresses.add (KeyPress ('q', ModifierKeys::commandModifier, 0));
	}
}

bool JUCEApplication::perform (const InvocationInfo& info)
{
	if (info.commandID == StandardApplicationCommandIDs::quit)
	{
		systemRequestedQuit();
		return true;
	}

	return false;
}

bool JUCEApplication::initialiseApp (const String& commandLine)
{
	commandLineParameters = commandLine.trim();

   #if ! JUCE_IOS
	jassert (appLock == nullptr); // initialiseApp must only be called once!

	if (! moreThanOneInstanceAllowed())
	{
		appLock = new InterProcessLock ("juceAppLock_" + getApplicationName());

		if (! appLock->enter(0))
		{
			appLock = nullptr;
			MessageManager::broadcastMessage (getApplicationName() + "/" + commandLineParameters);

			DBG ("Another instance is running - quitting...");
			return false;
		}
	}
   #endif

	// let the app do its setting-up..
	initialise (commandLineParameters);

   #if JUCE_MAC
	juce_initialiseMacMainMenu(); // needs to be called after the app object has created, to get its name
   #endif

   #if ! JUCE_IOS
	broadcastCallback = new AppBroadcastCallback();
   #endif

	stillInitialising = false;
	return true;
}

int JUCEApplication::shutdownApp()
{
	jassert (JUCEApplicationBase::getInstance() == this);

	broadcastCallback = nullptr;

	JUCE_TRY
	{
		// give the app a chance to clean up..
		shutdown();
	}
	JUCE_CATCH_EXCEPTION

	return getApplicationReturnValue();
}

#if ! JUCE_ANDROID
int JUCEApplication::main (const String& commandLine)
{
	ScopedJuceInitialiser_GUI libraryInitialiser;
	jassert (createInstance != nullptr);
	int returnCode = 0;

	{
		const ScopedPointer<JUCEApplication> app (dynamic_cast <JUCEApplication*> (createInstance()));

		jassert (app != nullptr);

		if (! app->initialiseApp (commandLine))
			return 0;

		JUCE_TRY
		{
			// loop until a quit message is received..
			MessageManager::getInstance()->runDispatchLoop();
		}
		JUCE_CATCH_EXCEPTION

		returnCode = app->shutdownApp();
	}

	return returnCode;
}

#if JUCE_IOS
 extern int juce_iOSMain (int argc, const char* argv[]);
#endif

#if ! JUCE_WINDOWS
 extern const char* juce_Argv0;
#endif

#if JUCE_MAC
 extern void initialiseNSApplication();
#endif

int JUCEApplication::main (int argc, const char* argv[])
{
	JUCE_AUTORELEASEPOOL

   #if JUCE_MAC
	initialiseNSApplication();
   #endif

   #if ! JUCE_WINDOWS
	jassert (createInstance != nullptr);
	juce_Argv0 = argv[0];
   #endif

   #if JUCE_IOS
	return juce_iOSMain (argc, argv);
   #else
	String cmd;
	for (int i = 1; i < argc; ++i)
	{
		String arg (argv[i]);
		if (arg.containsChar (' ') && ! arg.isQuotedString())
			arg = arg.quoted ('"');

		cmd << arg << ' ';
	}

	return JUCEApplication::main (cmd);
   #endif
}
#endif

/*** End of inlined file: juce_Application.cpp ***/


/*** Start of inlined file: juce_BubbleComponent.cpp ***/
BubbleComponent::BubbleComponent()
  : side (0),
	allowablePlacements (above | below | left | right),
	arrowTipX (0.0f),
	arrowTipY (0.0f)
{
	setInterceptsMouseClicks (false, false);

	shadow.setShadowProperties (5.0f, 0.35f, 0, 0);
	setComponentEffect (&shadow);
}

BubbleComponent::~BubbleComponent()
{
}

void BubbleComponent::paint (Graphics& g)
{
	int x = content.getX();
	int y = content.getY();
	int w = content.getWidth();
	int h = content.getHeight();

	int cw, ch;
	getContentSize (cw, ch);

	if (side == 3)
		x += w - cw;
	else if (side != 1)
		x += (w - cw) / 2;

	w = cw;

	if (side == 2)
		y += h - ch;
	else if (side != 0)
		y += (h - ch) / 2;

	h = ch;

	getLookAndFeel().drawBubble (g, arrowTipX, arrowTipY,
								 (float) x, (float) y,
								 (float) w, (float) h);

	const int cx = x + (w - cw) / 2;
	const int cy = y + (h - ch) / 2;

	const int indent = 3;

	g.setOrigin (cx + indent, cy + indent);
	g.reduceClipRegion (0, 0, cw - indent * 2, ch - indent * 2);

	paintContent (g, cw - indent * 2, ch - indent * 2);
}

void BubbleComponent::setAllowedPlacement (const int newPlacement)
{
	allowablePlacements = newPlacement;
}

void BubbleComponent::setPosition (Component* componentToPointTo)
{
	jassert (componentToPointTo != nullptr);

	Point<int> pos;

	if (getParentComponent() != nullptr)
		pos = getParentComponent()->getLocalPoint (componentToPointTo, pos);
	else
		pos = componentToPointTo->localPointToGlobal (pos);

	setPosition (Rectangle<int> (pos.x, pos.y, componentToPointTo->getWidth(), componentToPointTo->getHeight()));
}

void BubbleComponent::setPosition (const int arrowTipX_,
								   const int arrowTipY_)
{
	setPosition (Rectangle<int> (arrowTipX_, arrowTipY_, 1, 1));
}

void BubbleComponent::setPosition (const Rectangle<int>& rectangleToPointTo)
{
	Rectangle<int> availableSpace (getParentComponent() != nullptr ? getParentComponent()->getLocalBounds()
																   : getParentMonitorArea());
	int x = 0;
	int y = 0;
	int w = 150;
	int h = 30;

	getContentSize (w, h);
	w += 30;
	h += 30;

	const float edgeIndent = 2.0f;
	const int arrowLength = jmin (10, h / 3, w / 3);

	int spaceAbove = ((allowablePlacements & above) != 0) ? jmax (0, rectangleToPointTo.getY() - availableSpace.getY()) : -1;
	int spaceBelow = ((allowablePlacements & below) != 0) ? jmax (0, availableSpace.getBottom() - rectangleToPointTo.getBottom()) : -1;
	int spaceLeft  = ((allowablePlacements & left)  != 0) ? jmax (0, rectangleToPointTo.getX() - availableSpace.getX()) : -1;
	int spaceRight = ((allowablePlacements & right) != 0) ? jmax (0, availableSpace.getRight() - rectangleToPointTo.getRight()) : -1;

	// look at whether the component is elongated, and if so, try to position next to its longer dimension.
	if (rectangleToPointTo.getWidth() > rectangleToPointTo.getHeight() * 2
		 && (spaceAbove > h + 20 || spaceBelow > h + 20))
	{
		spaceLeft = spaceRight = 0;
	}
	else if (rectangleToPointTo.getWidth() < rectangleToPointTo.getHeight() / 2
			  && (spaceLeft > w + 20 || spaceRight > w + 20))
	{
		spaceAbove = spaceBelow = 0;
	}

	if (jmax (spaceAbove, spaceBelow) >= jmax (spaceLeft, spaceRight))
	{
		x = rectangleToPointTo.getX() + (rectangleToPointTo.getWidth() - w) / 2;
		arrowTipX = w * 0.5f;
		content.setSize (w, h - arrowLength);

		if (spaceAbove >= spaceBelow)
		{
			// above
			y = rectangleToPointTo.getY() - h;
			content.setPosition (0, 0);
			arrowTipY = h - edgeIndent;
			side = 2;
		}
		else
		{
			// below
			y = rectangleToPointTo.getBottom();
			content.setPosition (0, arrowLength);
			arrowTipY = edgeIndent;
			side = 0;
		}
	}
	else
	{
		y = rectangleToPointTo.getY() + (rectangleToPointTo.getHeight() - h) / 2;
		arrowTipY = h * 0.5f;
		content.setSize (w - arrowLength, h);

		if (spaceLeft > spaceRight)
		{
			// on the left
			x = rectangleToPointTo.getX() - w;
			content.setPosition (0, 0);
			arrowTipX = w - edgeIndent;
			side = 3;
		}
		else
		{
			// on the right
			x = rectangleToPointTo.getRight();
			content.setPosition (arrowLength, 0);
			arrowTipX = edgeIndent;
			side = 1;
		}
	}

	setBounds (x, y, w, h);
}

/*** End of inlined file: juce_BubbleComponent.cpp ***/


/*** Start of inlined file: juce_DropShadower.cpp ***/
class ShadowWindow  : public Component
{
public:
	ShadowWindow (Component& owner, const int type_, const Image shadowImageSections [12])
		: topLeft (shadowImageSections [type_ * 3]),
		  bottomRight (shadowImageSections [type_ * 3 + 1]),
		  filler (shadowImageSections [type_ * 3 + 2]),
		  type (type_)
	{
		setInterceptsMouseClicks (false, false);

		if (owner.isOnDesktop())
		{
			setSize (1, 1); // to keep the OS happy by not having zero-size windows
			addToDesktop (ComponentPeer::windowIgnoresMouseClicks
							| ComponentPeer::windowIsTemporary
							| ComponentPeer::windowIgnoresKeyPresses);
		}
		else if (owner.getParentComponent() != nullptr)
		{
			owner.getParentComponent()->addChildComponent (this);
		}
	}

	void paint (Graphics& g)
	{
		g.setOpacity (1.0f);

		if (type < 2)
		{
			int imH = jmin (topLeft.getHeight(), getHeight() / 2);
			g.drawImage (topLeft,
						 0, 0, topLeft.getWidth(), imH,
						 0, 0, topLeft.getWidth(), imH);

			imH = jmin (bottomRight.getHeight(), getHeight() - getHeight() / 2);
			g.drawImage (bottomRight,
						 0, getHeight() - imH, bottomRight.getWidth(), imH,
						 0, bottomRight.getHeight() - imH, bottomRight.getWidth(), imH);

			g.setTiledImageFill (filler, 0, 0, 1.0f);
			g.fillRect (0, topLeft.getHeight(), getWidth(), getHeight() - (topLeft.getHeight() + bottomRight.getHeight()));
		}
		else
		{
			int imW = jmin (topLeft.getWidth(), getWidth() / 2);
			g.drawImage (topLeft,
						 0, 0, imW, topLeft.getHeight(),
						 0, 0, imW, topLeft.getHeight());

			imW = jmin (bottomRight.getWidth(), getWidth() - getWidth() / 2);
			g.drawImage (bottomRight,
						 getWidth() - imW, 0, imW, bottomRight.getHeight(),
						 bottomRight.getWidth() - imW, 0, imW, bottomRight.getHeight());

			g.setTiledImageFill (filler, 0, 0, 1.0f);
			g.fillRect (topLeft.getWidth(), 0, getWidth() - (topLeft.getWidth() + bottomRight.getWidth()), getHeight());
		}
	}

	void resized()
	{
		repaint();  // (needed for correct repainting)
	}

private:
	const Image topLeft, bottomRight, filler;
	const int type;   // 0 = left, 1 = right, 2 = top, 3 = bottom. left + right are full-height

	JUCE_DECLARE_NON_COPYABLE (ShadowWindow);
};

DropShadower::DropShadower (const float alpha_,
							const int xOffset_,
							const int yOffset_,
							const float blurRadius_)
   : owner (nullptr),
	 xOffset (xOffset_),
	 yOffset (yOffset_),
	 alpha (alpha_),
	 blurRadius (blurRadius_),
	 reentrant (false)
{
}

DropShadower::~DropShadower()
{
	if (owner != nullptr)
		owner->removeComponentListener (this);

	reentrant = true;
	shadowWindows.clear();
}

void DropShadower::setOwner (Component* componentToFollow)
{
	if (componentToFollow != owner)
	{
		if (owner != nullptr)
			owner->removeComponentListener (this);

		// (the component can't be null)
		jassert (componentToFollow != nullptr);

		owner = componentToFollow;

		jassert (owner != nullptr);
		jassert (owner->isOpaque()); // doesn't work properly for semi-transparent comps!

		owner->addComponentListener (this);

		updateShadows();
	}
}

void DropShadower::componentMovedOrResized (Component&, bool /*wasMoved*/, bool /*wasResized*/)
{
	updateShadows();
}

void DropShadower::componentBroughtToFront (Component&)
{
	bringShadowWindowsToFront();
}

void DropShadower::componentParentHierarchyChanged (Component&)
{
	shadowWindows.clear();
	updateShadows();
}

void DropShadower::componentVisibilityChanged (Component&)
{
	updateShadows();
}

void DropShadower::updateShadows()
{
	if (reentrant || owner == nullptr)
		return;

	ComponentPeer* const peer = owner->getPeer();
	const bool isOwnerVisible = owner->isVisible() && (peer == nullptr || ! peer->isMinimised());

	const bool createShadowWindows  = shadowWindows.size() == 0
										 && owner->getWidth() > 0
										 && owner->getHeight() > 0
										 && isOwnerVisible
										 && (Desktop::canUseSemiTransparentWindows()
											  || owner->getParentComponent() != nullptr);

	{
		const ScopedValueSetter<bool> setter (reentrant, true, false);

		const int shadowEdge = jmax (xOffset, yOffset) + (int) blurRadius;

		if (createShadowWindows)
		{
			// keep a cached version of the image to save doing the gaussian too often
			String imageId;
			imageId << shadowEdge << ',' << xOffset << ',' << yOffset << ',' << alpha;

			const int hash = imageId.hashCode();

			Image bigIm (ImageCache::getFromHashCode (hash));

			if (bigIm.isNull())
			{
				bigIm = Image (Image::ARGB, shadowEdge * 5, shadowEdge * 5, true);

				Graphics bigG (bigIm);
				bigG.setColour (Colours::black.withAlpha (alpha));
				bigG.fillRect (shadowEdge + xOffset,
							   shadowEdge + yOffset,
							   bigIm.getWidth() - (shadowEdge * 2),
							   bigIm.getHeight() - (shadowEdge * 2));

				ImageConvolutionKernel blurKernel (roundToInt (blurRadius * 2.0f));
				blurKernel.createGaussianBlur (blurRadius);

				blurKernel.applyToImage (bigIm, bigIm,
										 Rectangle<int> (xOffset, yOffset,
														 bigIm.getWidth(), bigIm.getHeight()));

				ImageCache::addImageToCache (bigIm, hash);
			}

			const int iw = bigIm.getWidth();
			const int ih = bigIm.getHeight();
			const int shadowEdge2 = shadowEdge * 2;

			setShadowImage (bigIm, 0, shadowEdge, shadowEdge2, 0, 0);
			setShadowImage (bigIm, 1, shadowEdge, shadowEdge2, 0, ih - shadowEdge2);
			setShadowImage (bigIm, 2, shadowEdge, shadowEdge, 0, shadowEdge2);
			setShadowImage (bigIm, 3, shadowEdge, shadowEdge2, iw - shadowEdge, 0);
			setShadowImage (bigIm, 4, shadowEdge, shadowEdge2, iw - shadowEdge, ih - shadowEdge2);
			setShadowImage (bigIm, 5, shadowEdge, shadowEdge, iw - shadowEdge, shadowEdge2);
			setShadowImage (bigIm, 6, shadowEdge, shadowEdge, shadowEdge, 0);
			setShadowImage (bigIm, 7, shadowEdge, shadowEdge, iw - shadowEdge2, 0);
			setShadowImage (bigIm, 8, shadowEdge, shadowEdge, shadowEdge2, 0);
			setShadowImage (bigIm, 9, shadowEdge, shadowEdge, shadowEdge, ih - shadowEdge);
			setShadowImage (bigIm, 10, shadowEdge, shadowEdge, iw - shadowEdge2, ih - shadowEdge);
			setShadowImage (bigIm, 11, shadowEdge, shadowEdge, shadowEdge2, ih - shadowEdge);

			for (int i = 0; i < 4; ++i)
				shadowWindows.add (new ShadowWindow (*owner, i, shadowImageSections));
		}

		if (shadowWindows.size() >= 4)
		{
			const int x = owner->getX();
			const int y = owner->getY() - shadowEdge;
			const int w = owner->getWidth();
			const int h = owner->getHeight() + shadowEdge + shadowEdge;

			for (int i = shadowWindows.size(); --i >= 0;)
			{
				// there seem to be rare situations where the dropshadower may be deleted by
				// callbacks during this loop, so use a weak ref to watch out for this..
				WeakReference<Component> sw (shadowWindows[i]);

				if (sw != nullptr)
					sw->setAlwaysOnTop (owner->isAlwaysOnTop());

				if (sw != nullptr)
					sw->setVisible (isOwnerVisible);

				if (sw != nullptr)
				{
					switch (i)
					{
						case 0: sw->setBounds (x - shadowEdge, y, shadowEdge, h); break;
						case 1: sw->setBounds (x + w, y, shadowEdge, h); break;
						case 2: sw->setBounds (x, y, w, shadowEdge); break;
						case 3: sw->setBounds (x, owner->getBottom(), w, shadowEdge); break;
						default: break;
					}
				}

				if (sw == nullptr)
					return;
			}
		}
	}

	if (createShadowWindows)
		bringShadowWindowsToFront();
}

void DropShadower::setShadowImage (const Image& src, const int num, const int w, const int h,
								   const int sx, const int sy)
{
	shadowImageSections[num] = Image (Image::ARGB, w, h, true);

	Graphics g (shadowImageSections[num]);
	g.drawImage (src, 0, 0, w, h, sx, sy, w, h);
}

void DropShadower::bringShadowWindowsToFront()
{
	if (! reentrant)
	{
		updateShadows();

		const ScopedValueSetter<bool> setter (reentrant, true, false);

		for (int i = shadowWindows.size(); --i >= 0;)
			shadowWindows.getUnchecked(i)->toBehind (owner);
	}
}

/*** End of inlined file: juce_DropShadower.cpp ***/

// END_AUTOINCLUDE

}

using namespace juce;

namespace juce
{
#if JUCE_IOS || JUCE_WINDOWS

/*** Start of inlined file: juce_MultiTouchMapper.h ***/
#ifndef __JUCE_MULTITOUCHMAPPER_JUCEHEADER__
#define __JUCE_MULTITOUCHMAPPER_JUCEHEADER__

template <typename IDType>
class MultiTouchMapper
{
public:
	MultiTouchMapper() {}

	int getIndexOfTouch (IDType touchID)
	{
		jassert (touchID != 0); // need to rethink this if IDs can be 0!

		int touchIndex = currentTouches.indexOf (touchID);

		if (touchIndex < 0)
		{
			for (touchIndex = 0; touchIndex < currentTouches.size(); ++touchIndex)
				if (currentTouches.getUnchecked (touchIndex) == 0)
					break;

			currentTouches.set (touchIndex, touchID);
		}

		return touchIndex;
	}

	void clear()
	{
		currentTouches.clear();
	}

	void clearTouch (int index)
	{
		currentTouches.set (index, 0);
	}

	bool areAnyTouchesActive() const noexcept
	{
		for (int i = currentTouches.size(); --i >= 0;)
			if (currentTouches.getUnchecked(i) != 0)
				return true;

		return false;
	}

private:
	Array<IDType> currentTouches;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (MultiTouchMapper);
};

#endif   // __JUCE_MULTITOUCHMAPPER_JUCEHEADER__

/*** End of inlined file: juce_MultiTouchMapper.h ***/


#endif

#if JUCE_MAC || JUCE_IOS

/*** Start of inlined file: juce_osx_ObjCHelpers.h ***/
#ifndef __JUCE_OSX_OBJCHELPERS_JUCEHEADER__
#define __JUCE_OSX_OBJCHELPERS_JUCEHEADER__

/* This file contains a few helper functions that are used internally but which
   need to be kept away from the public headers because they use obj-C symbols.
*/
namespace
{

	String nsStringToJuce (NSString* s)
	{
		return CharPointer_UTF8 ([s UTF8String]);
	}

	NSString* juceStringToNS (const String& s)
	{
		return [NSString stringWithUTF8String: s.toUTF8()];
	}

	NSString* nsStringLiteral (const char* const s) noexcept
	{
		return [NSString stringWithUTF8String: s];
	}

	NSString* nsEmptyString() noexcept
	{
		return [NSString string];
	}
}

#endif   // __JUCE_OSX_OBJCHELPERS_JUCEHEADER__

/*** End of inlined file: juce_osx_ObjCHelpers.h ***/



/*** Start of inlined file: juce_mac_ObjCSuffix.h ***/
#ifndef __JUCE_MAC_OBJCSUFFIX_JUCEHEADER__
#define __JUCE_MAC_OBJCSUFFIX_JUCEHEADER__

/** This suffix is used for naming all Obj-C classes that are used inside juce.

	Because of the flat naming structure used by Obj-C, you can get horrible situations where
	two DLLs are loaded into a host, each of which uses classes with the same names, and these get
	cross-linked so that when you make a call to a class that you thought was private, it ends up
	actually calling into a similarly named class in the other module's address space.

	By changing this macro to a unique value, you ensure that all the obj-C classes in your app
	have unique names, and should avoid this problem.

	If you're using the amalgamated version, you can just set this macro to something unique before
	you include juce_amalgamated.cpp.
*/
#ifndef JUCE_ObjCExtraSuffix
 #define JUCE_ObjCExtraSuffix 3
#endif

#ifndef DOXYGEN
 #define appendMacro1(a, b, c, d, e) a ## _ ## b ## _ ## c ## _ ## d ## _ ## e
 #define appendMacro2(a, b, c, d, e) appendMacro1(a, b, c, d, e)
 #define MakeObjCClassName(rootName) appendMacro2 (rootName, JUCE_MAJOR_VERSION, JUCE_MINOR_VERSION, JUCE_BUILDNUMBER, JUCE_ObjCExtraSuffix)
#endif

#endif   // __JUCE_MAC_OBJCSUFFIX_JUCEHEADER__

/*** End of inlined file: juce_mac_ObjCSuffix.h ***/


/*** Start of inlined file: juce_mac_CoreGraphicsHelpers.h ***/
#ifndef __JUCE_MAC_COREGRAPHICSHELPERS_JUCEHEADER__
#define __JUCE_MAC_COREGRAPHICSHELPERS_JUCEHEADER__

namespace
{
	template <class RectType>
	Rectangle<int> convertToRectInt (const RectType& r)
	{
		return Rectangle<int> ((int) r.origin.x, (int) r.origin.y, (int) r.size.width, (int) r.size.height);
	}

	template <class RectType>
	Rectangle<float> convertToRectFloat (const RectType& r)
	{
		return Rectangle<float> (r.origin.x, r.origin.y, r.size.width, r.size.height);
	}

	template <class RectType>
	CGRect convertToCGRect (const RectType& r)
	{
		return CGRectMake ((CGFloat) r.getX(), (CGFloat) r.getY(), (CGFloat) r.getWidth(), (CGFloat) r.getHeight());
	}
}

extern CGImageRef juce_createCoreGraphicsImage (const Image&, const bool forAlpha, CGColorSpaceRef, const bool mustOutliveSource);

extern CGContextRef juce_getImageContext (const Image&);

#endif   // __JUCE_MAC_COREGRAPHICSHELPERS_JUCEHEADER__

/*** End of inlined file: juce_mac_CoreGraphicsHelpers.h ***/


/*** Start of inlined file: juce_mac_CoreGraphicsContext.h ***/
#ifndef __JUCE_MAC_COREGRAPHICSCONTEXT_JUCEHEADER__
#define __JUCE_MAC_COREGRAPHICSCONTEXT_JUCEHEADER__

class CoreGraphicsContext   : public LowLevelGraphicsContext
{
public:
	CoreGraphicsContext (CGContextRef context_, const float flipHeight_);
	~CoreGraphicsContext();

	bool isVectorDevice() const         { return false; }

	void setOrigin (int x, int y);
	void addTransform (const AffineTransform& transform);
	float getScaleFactor();
	bool clipToRectangle (const Rectangle<int>& r);
	bool clipToRectangleList (const RectangleList& clipRegion);
	void excludeClipRectangle (const Rectangle<int>& r);
	void clipToPath (const Path& path, const AffineTransform& transform);
	void clipToImageAlpha (const Image& sourceImage, const AffineTransform& transform);
	bool clipRegionIntersects (const Rectangle<int>& r);
	Rectangle<int> getClipBounds() const;
	bool isClipEmpty() const;

	void saveState();
	void restoreState();
	void beginTransparencyLayer (float opacity);
	void endTransparencyLayer();

	void setFill (const FillType& fillType);
	void setOpacity (float newOpacity);
	void setInterpolationQuality (Graphics::ResamplingQuality quality);

	void fillRect (const Rectangle<int>& r, const bool replaceExistingContents);
	void fillCGRect (const CGRect& cgRect, const bool replaceExistingContents);
	void fillPath (const Path& path, const AffineTransform& transform);
	void drawImage (const Image& sourceImage, const AffineTransform& transform);

	void drawLine (const Line<float>& line);
	void drawVerticalLine (const int x, float top, float bottom);
	void drawHorizontalLine (const int y, float left, float right);
	void setFont (const Font& newFont);
	const Font& getFont();
	void drawGlyph (int glyphNumber, const AffineTransform& transform);
	bool drawTextLayout (const AttributedString& text, const Rectangle<float>&);

private:
	CGContextRef context;
	const CGFloat flipHeight;
	CGColorSpaceRef rgbColourSpace, greyColourSpace;
	CGFunctionCallbacks gradientCallbacks;
	mutable Rectangle<int> lastClipRect;
	mutable bool lastClipRectIsValid;

	struct SavedState
	{
		SavedState();
		SavedState (const SavedState& other);
		~SavedState();

		void setFill (const FillType& newFill);
		CGShadingRef getShading (CoreGraphicsContext& owner);

		static void gradientCallback (void* info, const CGFloat* inData, CGFloat* outData);

		FillType fillType;
		Font font;
		CGFontRef fontRef;
		CGAffineTransform fontTransform;

	private:
		CGShadingRef shading;
		HeapBlock <PixelARGB> gradientLookupTable;
		int numGradientLookupEntries;
	};

	ScopedPointer <SavedState> state;
	OwnedArray <SavedState> stateStack;

	void drawGradient();
	void createPath (const Path& path) const;
	void createPath (const Path& path, const AffineTransform& transform) const;
	void flip() const;
	void applyTransform (const AffineTransform& transform) const;
	void drawImage (const Image& sourceImage, const AffineTransform& transform, bool fillEntireClipAsTiles);

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (CoreGraphicsContext);
};

#endif   // __JUCE_MAC_COREGRAPHICSCONTEXT_JUCEHEADER__

/*** End of inlined file: juce_mac_CoreGraphicsContext.h ***/

 #if JUCE_IOS

/*** Start of inlined file: juce_ios_UIViewComponentPeer.mm ***/
class UIViewComponentPeer;

} // (juce namespace)

#define JuceUIView MakeObjCClassName(JuceUIView)

@interface JuceUIView : UIView <UITextViewDelegate>
{
@public
	UIViewComponentPeer* owner;
	UITextView* hiddenTextView;
}

- (JuceUIView*) initWithOwner: (UIViewComponentPeer*) owner withFrame: (CGRect) frame;
- (void) dealloc;

- (void) drawRect: (CGRect) r;

- (void) touchesBegan: (NSSet*) touches withEvent: (UIEvent*) event;
- (void) touchesMoved: (NSSet*) touches withEvent: (UIEvent*) event;
- (void) touchesEnded: (NSSet*) touches withEvent: (UIEvent*) event;
- (void) touchesCancelled: (NSSet*) touches withEvent: (UIEvent*) event;

- (BOOL) becomeFirstResponder;
- (BOOL) resignFirstResponder;
- (BOOL) canBecomeFirstResponder;

- (BOOL) textView: (UITextView*) textView shouldChangeTextInRange: (NSRange) range replacementText: (NSString*) text;
@end

#define JuceUIViewController MakeObjCClassName(JuceUIViewController)

@interface JuceUIViewController : UIViewController
{
}

- (BOOL) shouldAutorotateToInterfaceOrientation: (UIInterfaceOrientation) interfaceOrientation;
- (void) didRotateFromInterfaceOrientation: (UIInterfaceOrientation) fromInterfaceOrientation;
@end

#define JuceUIWindow MakeObjCClassName(JuceUIWindow)

@interface JuceUIWindow : UIWindow
{
@private
	UIViewComponentPeer* owner;
	bool isZooming;
}

- (void) setOwner: (UIViewComponentPeer*) owner;
- (void) becomeKeyWindow;
@end

namespace juce
{

class UIViewComponentPeer  : public ComponentPeer,
							 public FocusChangeListener
{
public:
	UIViewComponentPeer (Component* const component,
						 const int windowStyleFlags,
						 UIView* viewToAttachTo);

	~UIViewComponentPeer();

	void* getNativeHandle() const;
	void setVisible (bool shouldBeVisible);
	void setTitle (const String& title);
	void setPosition (int x, int y);
	void setSize (int w, int h);
	void setBounds (int x, int y, int w, int h, bool isNowFullScreen);

	Rectangle<int> getBounds() const;
	Rectangle<int> getBounds (const bool global) const;
	Point<int> getScreenPosition() const;
	Point<int> localToGlobal (const Point<int>& relativePosition);
	Point<int> globalToLocal (const Point<int>& screenPosition);
	void setAlpha (float newAlpha);
	void setMinimised (bool shouldBeMinimised);
	bool isMinimised() const;
	void setFullScreen (bool shouldBeFullScreen);
	bool isFullScreen() const;
	bool contains (const Point<int>& position, bool trueIfInAChildWindow) const;
	BorderSize<int> getFrameSize() const;
	bool setAlwaysOnTop (bool alwaysOnTop);
	void toFront (bool makeActiveWindow);
	void toBehind (ComponentPeer* other);
	void setIcon (const Image& newIcon);

	virtual void drawRect (CGRect r);

	virtual bool canBecomeKeyWindow();
	virtual bool windowShouldClose();

	virtual void redirectMovedOrResized();
	virtual CGRect constrainRect (CGRect r);

	virtual void viewFocusGain();
	virtual void viewFocusLoss();
	bool isFocused() const;
	void grabFocus();
	void textInputRequired (const Point<int>& position);

	virtual BOOL textViewReplaceCharacters (const Range<int>& range, const String& text);
	void updateHiddenTextContent (TextInputTarget* target);
	void globalFocusChanged (Component*);

	virtual BOOL shouldRotate (UIInterfaceOrientation interfaceOrientation);
	virtual void displayRotated();

	void handleTouches (UIEvent* e, bool isDown, bool isUp, bool isCancel);

	void repaint (const Rectangle<int>& area);
	void performAnyPendingRepaintsNow();

	UIWindow* window;
	JuceUIView* view;
	JuceUIViewController* controller;
	bool isSharedWindow, fullScreen, insideDrawRect;
	static ModifierKeys currentModifiers;

	static int64 getMouseTime (UIEvent* e)
	{
		return (Time::currentTimeMillis() - Time::getMillisecondCounter())
				+ (int64) ([e timestamp] * 1000.0);
	}

	static Rectangle<int> rotatedScreenPosToReal (const Rectangle<int>& r)
	{
		const Rectangle<int> screen (convertToRectInt ([UIScreen mainScreen].bounds));

		switch ([[UIApplication sharedApplication] statusBarOrientation])
		{
			case UIInterfaceOrientationPortrait:
				return r;

			case UIInterfaceOrientationPortraitUpsideDown:
				return Rectangle<int> (screen.getWidth() - r.getRight(), screen.getHeight() - r.getBottom(),
									   r.getWidth(), r.getHeight());

			case UIInterfaceOrientationLandscapeLeft:
				return Rectangle<int> (r.getY(), screen.getHeight() - r.getRight(),
									   r.getHeight(), r.getWidth());

			case UIInterfaceOrientationLandscapeRight:
				return Rectangle<int> (screen.getWidth() - r.getBottom(), r.getX(),
									   r.getHeight(), r.getWidth());

			default: jassertfalse; // unknown orientation!
		}

		return r;
	}

	static Rectangle<int> realScreenPosToRotated (const Rectangle<int>& r)
	{
		const Rectangle<int> screen (convertToRectInt ([UIScreen mainScreen].bounds));

		switch ([[UIApplication sharedApplication] statusBarOrientation])
		{
			case UIInterfaceOrientationPortrait:
				return r;

			case UIInterfaceOrientationPortraitUpsideDown:
				return Rectangle<int> (screen.getWidth() - r.getRight(), screen.getHeight() - r.getBottom(),
									   r.getWidth(), r.getHeight());

			case UIInterfaceOrientationLandscapeLeft:
				return Rectangle<int> (screen.getHeight() - r.getBottom(), r.getX(),
									   r.getHeight(), r.getWidth());

			case UIInterfaceOrientationLandscapeRight:
				return Rectangle<int> (r.getY(), screen.getWidth() - r.getRight(),
									   r.getHeight(), r.getWidth());

			default: jassertfalse; // unknown orientation!
		}

		return r;
	}

	MultiTouchMapper<UITouch*> currentTouches;

private:
	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (UIViewComponentPeer);
};

} // (juce namespace)

@implementation JuceUIViewController

- (BOOL) shouldAutorotateToInterfaceOrientation: (UIInterfaceOrientation) interfaceOrientation
{
	JuceUIView* juceView = (JuceUIView*) [self view];
	jassert (juceView != nil && juceView->owner != nullptr);
	return juceView->owner->shouldRotate (interfaceOrientation);
}

- (void) didRotateFromInterfaceOrientation: (UIInterfaceOrientation) fromInterfaceOrientation
{
	JuceUIView* juceView = (JuceUIView*) [self view];
	jassert (juceView != nil && juceView->owner != nullptr);
	juceView->owner->displayRotated();
}

@end

@implementation JuceUIView

- (JuceUIView*) initWithOwner: (UIViewComponentPeer*) owner_
					withFrame: (CGRect) frame
{
	[super initWithFrame: frame];
	owner = owner_;

	hiddenTextView = [[UITextView alloc] initWithFrame: CGRectMake (0, 0, 0, 0)];
	[self addSubview: hiddenTextView];
	hiddenTextView.delegate = self;

	hiddenTextView.autocapitalizationType = UITextAutocapitalizationTypeNone;
	hiddenTextView.autocorrectionType = UITextAutocorrectionTypeNo;

	return self;
}

- (void) dealloc
{
	[hiddenTextView removeFromSuperview];
	[hiddenTextView release];

	[super dealloc];
}

- (void) drawRect: (CGRect) r
{
	if (owner != nullptr)
		owner->drawRect (r);
}

bool KeyPress::isKeyCurrentlyDown (const int keyCode)
{
	return false;
}

ModifierKeys UIViewComponentPeer::currentModifiers;

ModifierKeys ModifierKeys::getCurrentModifiersRealtime() noexcept
{
	return UIViewComponentPeer::currentModifiers;
}

void ModifierKeys::updateCurrentModifiers() noexcept
{
	currentModifiers = UIViewComponentPeer::currentModifiers;
}

juce::Point<int> juce_lastMousePos;

- (void) touchesBegan: (NSSet*) touches withEvent: (UIEvent*) event
{
	if (owner != nullptr)
		owner->handleTouches (event, true, false, false);
}

- (void) touchesMoved: (NSSet*) touches withEvent: (UIEvent*) event
{
	if (owner != nullptr)
		owner->handleTouches (event, false, false, false);
}

- (void) touchesEnded: (NSSet*) touches withEvent: (UIEvent*) event
{
	if (owner != nullptr)
		owner->handleTouches (event, false, true, false);
}

- (void) touchesCancelled: (NSSet*) touches withEvent: (UIEvent*) event
{
	if (owner != nullptr)
		owner->handleTouches (event, false, true, true);

	[self touchesEnded: touches withEvent: event];
}

- (BOOL) becomeFirstResponder
{
	if (owner != nullptr)
		owner->viewFocusGain();

	return true;
}

- (BOOL) resignFirstResponder
{
	if (owner != nullptr)
		owner->viewFocusLoss();

	return true;
}

- (BOOL) canBecomeFirstResponder
{
	return owner != nullptr && owner->canBecomeKeyWindow();
}

- (BOOL) textView: (UITextView*) textView shouldChangeTextInRange: (NSRange) range replacementText: (NSString*) text
{
	return owner->textViewReplaceCharacters (Range<int> (range.location, range.location + range.length),
											 nsStringToJuce (text));
}

@end

@implementation JuceUIWindow

- (void) setOwner: (UIViewComponentPeer*) owner_
{
	owner = owner_;
	isZooming = false;
}

- (void) becomeKeyWindow
{
	[super becomeKeyWindow];

	if (owner != nullptr)
		owner->grabFocus();
}

@end

namespace juce
{

UIViewComponentPeer::UIViewComponentPeer (Component* const component,
										  const int windowStyleFlags,
										  UIView* viewToAttachTo)
	: ComponentPeer (component, windowStyleFlags),
	  window (nil),
	  view (nil),
	  controller (nil),
	  isSharedWindow (viewToAttachTo != nil),
	  fullScreen (false),
	  insideDrawRect (false)
{
	CGRect r = convertToCGRect (component->getLocalBounds());

	view = [[JuceUIView alloc] initWithOwner: this withFrame: r];

	view.multipleTouchEnabled = YES;
	view.hidden = ! component->isVisible();
	view.opaque = component->isOpaque();
	view.backgroundColor = [[UIColor blackColor] colorWithAlphaComponent: 0];

	if (isSharedWindow)
	{
		window = [viewToAttachTo window];
		[viewToAttachTo addSubview: view];
	}
	else
	{
		controller = [[JuceUIViewController alloc] init];
		controller.view = view;

		r = convertToCGRect (rotatedScreenPosToReal (component->getBounds()));
		r.origin.y = [UIScreen mainScreen].bounds.size.height - (r.origin.y + r.size.height);

		window = [[JuceUIWindow alloc] init];
		window.frame = r;
		window.opaque = component->isOpaque();
		window.backgroundColor = [[UIColor blackColor] colorWithAlphaComponent: 0];

		[((JuceUIWindow*) window) setOwner: this];

		if (component->isAlwaysOnTop())
			window.windowLevel = UIWindowLevelAlert;

		[window addSubview: view];
		view.frame = CGRectMake (0, 0, r.size.width, r.size.height);

		window.hidden = view.hidden;
	}

	setTitle (component->getName());

	Desktop::getInstance().addFocusChangeListener (this);
}

UIViewComponentPeer::~UIViewComponentPeer()
{
	Desktop::getInstance().removeFocusChangeListener (this);

	view->owner = nullptr;
	[view removeFromSuperview];
	[view release];
	[controller release];

	if (! isSharedWindow)
	{
		[((JuceUIWindow*) window) setOwner: nil];
		[window release];
	}
}

void* UIViewComponentPeer::getNativeHandle() const
{
	return view;
}

void UIViewComponentPeer::setVisible (bool shouldBeVisible)
{
	view.hidden = ! shouldBeVisible;

	if (! isSharedWindow)
		window.hidden = ! shouldBeVisible;
}

void UIViewComponentPeer::setTitle (const String& title)
{
	// xxx is this possible?
}

void UIViewComponentPeer::setPosition (int x, int y)
{
	setBounds (x, y, component->getWidth(), component->getHeight(), false);
}

void UIViewComponentPeer::setSize (int w, int h)
{
	setBounds (component->getX(), component->getY(), w, h, false);
}

void UIViewComponentPeer::setBounds (int x, int y, int w, int h, const bool isNowFullScreen)
{
	fullScreen = isNowFullScreen;
	w = jmax (0, w);
	h = jmax (0, h);

	if (isSharedWindow)
	{
		CGRect r = CGRectMake ((CGFloat) x, (CGFloat) y, (CGFloat) w, (CGFloat) h);

		if (view.frame.size.width != r.size.width
			 || view.frame.size.height != r.size.height)
			[view setNeedsDisplay];

		view.frame = r;
	}
	else
	{
		const Rectangle<int> bounds (rotatedScreenPosToReal (Rectangle<int> (x, y, w, h)));
		window.frame = convertToCGRect (bounds);
		view.frame = CGRectMake (0, 0, (CGFloat) bounds.getWidth(), (CGFloat) bounds.getHeight());

		handleMovedOrResized();
	}
}

Rectangle<int> UIViewComponentPeer::getBounds (const bool global) const
{
	CGRect r = view.frame;

	if (global && view.window != nil)
	{
		r = [view convertRect: r toView: nil];
		CGRect wr = view.window.frame;

		const Rectangle<int> windowBounds (realScreenPosToRotated (convertToRectInt (wr)));

		r.origin.x += windowBounds.getX();
		r.origin.y += windowBounds.getY();
	}

	return convertToRectInt (r);
}

Rectangle<int> UIViewComponentPeer::getBounds() const
{
	return getBounds (! isSharedWindow);
}

Point<int> UIViewComponentPeer::getScreenPosition() const
{
	return getBounds (true).getPosition();
}

Point<int> UIViewComponentPeer::localToGlobal (const Point<int>& relativePosition)
{
	return relativePosition + getScreenPosition();
}

Point<int> UIViewComponentPeer::globalToLocal (const Point<int>& screenPosition)
{
	return screenPosition - getScreenPosition();
}

CGRect UIViewComponentPeer::constrainRect (CGRect r)
{
	if (constrainer != nullptr)
	{
		CGRect mainScreen = [UIScreen mainScreen].bounds;

		CGRect current = window.frame;
		current.origin.y = mainScreen.size.height - current.origin.y - current.size.height;

		r.origin.y = mainScreen.size.height - r.origin.y - r.size.height;

		Rectangle<int> pos (convertToRectInt (r));
		Rectangle<int> original (convertToRectInt (current));

		constrainer->checkBounds (pos, original,
								  Desktop::getInstance().getAllMonitorDisplayAreas().getBounds(),
								  pos.getY() != original.getY() && pos.getBottom() == original.getBottom(),
								  pos.getX() != original.getX() && pos.getRight()  == original.getRight(),
								  pos.getY() == original.getY() && pos.getBottom() != original.getBottom(),
								  pos.getX() == original.getX() && pos.getRight()  != original.getRight());

		r.origin.x = pos.getX();
		r.origin.y = mainScreen.size.height - r.size.height - pos.getY();
		r.size.width = pos.getWidth();
		r.size.height = pos.getHeight();
	}

	return r;
}

void UIViewComponentPeer::setAlpha (float newAlpha)
{
	[view.window setAlpha: (CGFloat) newAlpha];
}

void UIViewComponentPeer::setMinimised (bool shouldBeMinimised)
{
}

bool UIViewComponentPeer::isMinimised() const
{
	return false;
}

void UIViewComponentPeer::setFullScreen (bool shouldBeFullScreen)
{
	if (! isSharedWindow)
	{
		Rectangle<int> r (shouldBeFullScreen ? Desktop::getInstance().getMainMonitorArea()
											 : lastNonFullscreenBounds);

		if ((! shouldBeFullScreen) && r.isEmpty())
			r = getBounds();

		// (can't call the component's setBounds method because that'll reset our fullscreen flag)
		if (! r.isEmpty())
			setBounds (r.getX(), r.getY(), r.getWidth(), r.getHeight(), shouldBeFullScreen);

		component->repaint();
	}
}

bool UIViewComponentPeer::isFullScreen() const
{
	return fullScreen;
}

namespace
{
	Desktop::DisplayOrientation convertToJuceOrientation (UIInterfaceOrientation interfaceOrientation)
	{
		switch (interfaceOrientation)
		{
			case UIInterfaceOrientationPortrait:            return Desktop::upright;
			case UIInterfaceOrientationPortraitUpsideDown:  return Desktop::upsideDown;
			case UIInterfaceOrientationLandscapeLeft:       return Desktop::rotatedClockwise;
			case UIInterfaceOrientationLandscapeRight:      return Desktop::rotatedAntiClockwise;
			default:                                        jassertfalse; // unknown orientation!
		}

		return Desktop::upright;
	}
}

BOOL UIViewComponentPeer::shouldRotate (UIInterfaceOrientation interfaceOrientation)
{
	return Desktop::getInstance().isOrientationEnabled (convertToJuceOrientation (interfaceOrientation));
}

void UIViewComponentPeer::displayRotated()
{
	const Rectangle<int> oldArea (component->getBounds());
	const Rectangle<int> oldDesktop (Desktop::getInstance().getMainMonitorArea());
	Desktop::getInstance().refreshMonitorSizes();

	if (fullScreen)
	{
		fullScreen = false;
		setFullScreen (true);
	}
	else if (! isSharedWindow)
	{
		const float l = oldArea.getX() / (float) oldDesktop.getWidth();
		const float r = oldArea.getRight() / (float) oldDesktop.getWidth();
		const float t = oldArea.getY() / (float) oldDesktop.getHeight();
		const float b = oldArea.getBottom() / (float) oldDesktop.getHeight();

		const Rectangle<int> newDesktop (Desktop::getInstance().getMainMonitorArea());

		setBounds ((int) (l * newDesktop.getWidth()),
				   (int) (t * newDesktop.getHeight()),
				   (int) ((r - l) * newDesktop.getWidth()),
				   (int) ((b - t) * newDesktop.getHeight()),
				   false);
	}
}

bool UIViewComponentPeer::contains (const Point<int>& position, bool trueIfInAChildWindow) const
{
	if (! (isPositiveAndBelow (position.getX(), component->getWidth())
			&& isPositiveAndBelow (position.getY(), component->getHeight())))
		return false;

	UIView* v = [view hitTest: CGPointMake ((CGFloat) position.getX(), (CGFloat) position.getY())
					withEvent: nil];

	if (trueIfInAChildWindow)
		return v != nil;

	return v == view;
}

BorderSize<int> UIViewComponentPeer::getFrameSize() const
{
	return BorderSize<int>();
}

bool UIViewComponentPeer::setAlwaysOnTop (bool alwaysOnTop)
{
	if (! isSharedWindow)
		window.windowLevel = alwaysOnTop ? UIWindowLevelAlert : UIWindowLevelNormal;

	return true;
}

void UIViewComponentPeer::toFront (bool makeActiveWindow)
{
	if (isSharedWindow)
		[[view superview] bringSubviewToFront: view];

	if (window != nil && component->isVisible())
		[window makeKeyAndVisible];
}

void UIViewComponentPeer::toBehind (ComponentPeer* other)
{
	UIViewComponentPeer* const otherPeer = dynamic_cast <UIViewComponentPeer*> (other);
	jassert (otherPeer != nullptr); // wrong type of window?

	if (otherPeer != nullptr)
	{
		if (isSharedWindow)
		{
			[[view superview] insertSubview: view belowSubview: otherPeer->view];
		}
		else
		{
			jassertfalse; // don't know how to do this
		}
	}
}

void UIViewComponentPeer::setIcon (const Image& /*newIcon*/)
{
	// to do..
}

void UIViewComponentPeer::handleTouches (UIEvent* event, const bool isDown, const bool isUp, bool isCancel)
{
	NSArray* touches = [[event touchesForView: view] allObjects];

	for (unsigned int i = 0; i < [touches count]; ++i)
	{
		UITouch* touch = [touches objectAtIndex: i];

		if ([touch phase] == UITouchPhaseStationary)
			continue;

		CGPoint p = [touch locationInView: view];
		const Point<int> pos ((int) p.x, (int) p.y);
		juce_lastMousePos = pos + getScreenPosition();

		const int64 time = getMouseTime (event);
		const int touchIndex = currentTouches.getIndexOfTouch (touch);

		ModifierKeys modsToSend (currentModifiers);

		if (isDown)
		{
			if ([touch phase] != UITouchPhaseBegan)
				continue;

			currentModifiers = currentModifiers.withoutMouseButtons().withFlags (ModifierKeys::leftButtonModifier);
			modsToSend = currentModifiers;

			// this forces a mouse-enter/up event, in case for some reason we didn't get a mouse-up before.
			handleMouseEvent (touchIndex, pos, modsToSend.withoutMouseButtons(), time);
			if (! isValidPeer (this)) // (in case this component was deleted by the event)
				return;
		}
		else if (isUp)
		{
			if (! ([touch phase] == UITouchPhaseEnded || [touch phase] == UITouchPhaseCancelled))
				continue;

			modsToSend = modsToSend.withoutMouseButtons();
			currentTouches.clearTouch (touchIndex);

			if (! currentTouches.areAnyTouchesActive())
				isCancel = true;
		}

		if (isCancel)
		{
			currentTouches.clear();
			currentModifiers = currentModifiers.withoutMouseButtons();
		}

		handleMouseEvent (touchIndex, pos, modsToSend, time);
		if (! isValidPeer (this)) // (in case this component was deleted by the event)
			return;

		if (isUp || isCancel)
		{
			handleMouseEvent (touchIndex, Point<int> (-1, -1), currentModifiers, time);
			if (! isValidPeer (this))
				return;
		}
	}
}

static UIViewComponentPeer* currentlyFocusedPeer = nullptr;

void UIViewComponentPeer::viewFocusGain()
{
	if (currentlyFocusedPeer != this)
	{
		if (ComponentPeer::isValidPeer (currentlyFocusedPeer))
			currentlyFocusedPeer->handleFocusLoss();

		currentlyFocusedPeer = this;

		handleFocusGain();
	}
}

void UIViewComponentPeer::viewFocusLoss()
{
	if (currentlyFocusedPeer == this)
	{
		currentlyFocusedPeer = nullptr;
		handleFocusLoss();
	}
}

bool UIViewComponentPeer::isFocused() const
{
	return isSharedWindow ? this == currentlyFocusedPeer
						  : (window != nil && [window isKeyWindow]);
}

void UIViewComponentPeer::grabFocus()
{
	if (window != nil)
	{
		[window makeKeyWindow];
		viewFocusGain();
	}
}

void UIViewComponentPeer::textInputRequired (const Point<int>&)
{
}

void UIViewComponentPeer::updateHiddenTextContent (TextInputTarget* target)
{
	view->hiddenTextView.text = juceStringToNS (target->getTextInRange (Range<int> (0, target->getHighlightedRegion().getStart())));
	view->hiddenTextView.selectedRange = NSMakeRange (target->getHighlightedRegion().getStart(), 0);
}

BOOL UIViewComponentPeer::textViewReplaceCharacters (const Range<int>& range, const String& text)
{
	TextInputTarget* const target = findCurrentTextInputTarget();

	if (target != nullptr)
	{
		const Range<int> currentSelection (target->getHighlightedRegion());

		if (range.getLength() == 1 && text.isEmpty()) // (detect backspace)
			if (currentSelection.isEmpty())
				target->setHighlightedRegion (currentSelection.withStart (currentSelection.getStart() - 1));

		if (text == "\r" || text == "\n" || text == "\r\n")
			handleKeyPress (KeyPress::returnKey, text[0]);
		else
			target->insertTextAtCaret (text);

		updateHiddenTextContent (target);
	}

	return NO;
}

void UIViewComponentPeer::globalFocusChanged (Component*)
{
	TextInputTarget* const target = findCurrentTextInputTarget();

	if (target != nullptr)
	{
		Component* comp = dynamic_cast<Component*> (target);

		Point<int> pos (component->getLocalPoint (comp, Point<int>()));
		view->hiddenTextView.frame = CGRectMake (pos.getX(), pos.getY(), 0, 0);

		updateHiddenTextContent (target);
		[view->hiddenTextView becomeFirstResponder];
	}
	else
	{
		[view->hiddenTextView resignFirstResponder];
	}
}

void UIViewComponentPeer::drawRect (CGRect r)
{
	if (r.size.width < 1.0f || r.size.height < 1.0f)
		return;

	CGContextRef cg = UIGraphicsGetCurrentContext();

	if (! component->isOpaque())
		CGContextClearRect (cg, CGContextGetClipBoundingBox (cg));

	CGContextConcatCTM (cg, CGAffineTransformMake (1, 0, 0, -1, 0, view.bounds.size.height));
	CoreGraphicsContext g (cg, view.bounds.size.height);

	insideDrawRect = true;
	handlePaint (g);
	insideDrawRect = false;
}

bool UIViewComponentPeer::canBecomeKeyWindow()
{
	return (getStyleFlags() & juce::ComponentPeer::windowIgnoresKeyPresses) == 0;
}

bool UIViewComponentPeer::windowShouldClose()
{
	if (! isValidPeer (this))
		return YES;

	handleUserClosingWindow();
	return NO;
}

void UIViewComponentPeer::redirectMovedOrResized()
{
	handleMovedOrResized();
}

void Desktop::setKioskComponent (Component* kioskModeComponent, bool enableOrDisable, bool allowMenusAndBars)
{
	// TODO
}

class AsyncRepaintMessage  : public CallbackMessage
{
public:
	UIViewComponentPeer* const peer;
	const Rectangle<int> rect;

	AsyncRepaintMessage (UIViewComponentPeer* const peer_, const Rectangle<int>& rect_)
		: peer (peer_), rect (rect_)
	{
	}

	void messageCallback()
	{
		if (ComponentPeer::isValidPeer (peer))
			peer->repaint (rect);
	}
};

void UIViewComponentPeer::repaint (const Rectangle<int>& area)
{
	if (insideDrawRect || ! MessageManager::getInstance()->isThisTheMessageThread())
	{
		(new AsyncRepaintMessage (this, area))->post();
	}
	else
	{
		[view setNeedsDisplayInRect: convertToCGRect (area)];
	}
}

void UIViewComponentPeer::performAnyPendingRepaintsNow()
{
}

ComponentPeer* Component::createNewPeer (int styleFlags, void* windowToAttachTo)
{
	return new UIViewComponentPeer (this, styleFlags, (UIView*) windowToAttachTo);
}

const int KeyPress::spaceKey        = ' ';
const int KeyPress::returnKey       = 0x0d;
const int KeyPress::escapeKey       = 0x1b;
const int KeyPress::backspaceKey    = 0x7f;
const int KeyPress::leftKey         = 0x1000;
const int KeyPress::rightKey        = 0x1001;
const int KeyPress::upKey           = 0x1002;
const int KeyPress::downKey         = 0x1003;
const int KeyPress::pageUpKey       = 0x1004;
const int KeyPress::pageDownKey     = 0x1005;
const int KeyPress::endKey          = 0x1006;
const int KeyPress::homeKey         = 0x1007;
const int KeyPress::deleteKey       = 0x1008;
const int KeyPress::insertKey       = -1;
const int KeyPress::tabKey          = 9;
const int KeyPress::F1Key           = 0x2001;
const int KeyPress::F2Key           = 0x2002;
const int KeyPress::F3Key           = 0x2003;
const int KeyPress::F4Key           = 0x2004;
const int KeyPress::F5Key           = 0x2005;
const int KeyPress::F6Key           = 0x2006;
const int KeyPress::F7Key           = 0x2007;
const int KeyPress::F8Key           = 0x2008;
const int KeyPress::F9Key           = 0x2009;
const int KeyPress::F10Key          = 0x200a;
const int KeyPress::F11Key          = 0x200b;
const int KeyPress::F12Key          = 0x200c;
const int KeyPress::F13Key          = 0x200d;
const int KeyPress::F14Key          = 0x200e;
const int KeyPress::F15Key          = 0x200f;
const int KeyPress::F16Key          = 0x2010;
const int KeyPress::numberPad0      = 0x30020;
const int KeyPress::numberPad1      = 0x30021;
const int KeyPress::numberPad2      = 0x30022;
const int KeyPress::numberPad3      = 0x30023;
const int KeyPress::numberPad4      = 0x30024;
const int KeyPress::numberPad5      = 0x30025;
const int KeyPress::numberPad6      = 0x30026;
const int KeyPress::numberPad7      = 0x30027;
const int KeyPress::numberPad8      = 0x30028;
const int KeyPress::numberPad9      = 0x30029;
const int KeyPress::numberPadAdd            = 0x3002a;
const int KeyPress::numberPadSubtract       = 0x3002b;
const int KeyPress::numberPadMultiply       = 0x3002c;
const int KeyPress::numberPadDivide         = 0x3002d;
const int KeyPress::numberPadSeparator      = 0x3002e;
const int KeyPress::numberPadDecimalPoint   = 0x3002f;
const int KeyPress::numberPadEquals         = 0x30030;
const int KeyPress::numberPadDelete         = 0x30031;
const int KeyPress::playKey         = 0x30000;
const int KeyPress::stopKey         = 0x30001;
const int KeyPress::fastForwardKey  = 0x30002;
const int KeyPress::rewindKey       = 0x30003;

/*** End of inlined file: juce_ios_UIViewComponentPeer.mm ***/



/*** Start of inlined file: juce_ios_Windowing.mm ***/
} // (juce namespace)

@interface JuceAppStartupDelegate : NSObject <UIApplicationDelegate>
{
}

- (void) applicationDidFinishLaunching: (UIApplication*) application;
- (void) applicationWillTerminate: (UIApplication*) application;

@end

@implementation JuceAppStartupDelegate

- (void) applicationDidFinishLaunching: (UIApplication*) application
{
	initialiseJuce_GUI();

	JUCEApplication* app = dynamic_cast <JUCEApplication*> (JUCEApplicationBase::createInstance());
	if (! app->initialiseApp (String::empty))
		exit (0);
}

- (void) applicationWillTerminate: (UIApplication*) application
{
	JUCEApplicationBase::appWillTerminateByForce();
}

@end

namespace juce
{

int juce_iOSMain (int argc, const char* argv[])
{
	return UIApplicationMain (argc, const_cast<char**> (argv), nil, @"JuceAppStartupDelegate");
}

void LookAndFeel::playAlertSound()
{
	//xxx
	//AudioServicesPlaySystemSound ();
}

class iOSMessageBox;

} // (juce namespace)

@interface JuceAlertBoxDelegate  : NSObject
{
@public
	iOSMessageBox* owner;
}

- (void) alertView: (UIAlertView*) alertView clickedButtonAtIndex: (NSInteger) buttonIndex;

@end

namespace juce
{

class iOSMessageBox
{
public:
	iOSMessageBox (const String& title, const String& message,
				   NSString* button1, NSString* button2, NSString* button3,
				   ModalComponentManager::Callback* callback_, const bool isAsync_)
		: result (0), delegate (nil), alert (nil),
		  callback (callback_), isYesNo (button3 != nil), isAsync (isAsync_)
	{
		delegate = [[JuceAlertBoxDelegate alloc] init];
		delegate->owner = this;

		alert = [[UIAlertView alloc] initWithTitle: juceStringToNS (title)
										   message: juceStringToNS (message)
										  delegate: delegate
								 cancelButtonTitle: button1
								 otherButtonTitles: button2, button3, nil];
		[alert retain];
		[alert show];
	}

	~iOSMessageBox()
	{
		[alert release];
		[delegate release];
	}

	int getResult()
	{
		jassert (callback == nullptr);
		JUCE_AUTORELEASEPOOL

		while (! alert.hidden && alert.superview != nil)
			[[NSRunLoop mainRunLoop] runUntilDate: [NSDate dateWithTimeIntervalSinceNow: 0.01]];

		return result;
	}

	void buttonClicked (const int buttonIndex) noexcept
	{
		result = buttonIndex;

		if (callback != nullptr)
			callback->modalStateFinished (result);

		if (isAsync)
			delete this;
	}

private:
	int result;
	JuceAlertBoxDelegate* delegate;
	UIAlertView* alert;
	ModalComponentManager::Callback* callback;
	const bool isYesNo, isAsync;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (iOSMessageBox);
};

} // (juce namespace)

@implementation JuceAlertBoxDelegate

- (void) alertView: (UIAlertView*) alertView clickedButtonAtIndex: (NSInteger) buttonIndex
{
	owner->buttonClicked (buttonIndex);
	alertView.hidden = true;
}

@end

namespace juce
{

void JUCE_CALLTYPE NativeMessageBox::showMessageBox (AlertWindow::AlertIconType iconType,
													 const String& title, const String& message,
													 Component* associatedComponent)
{
	JUCE_AUTORELEASEPOOL
	iOSMessageBox mb (title, message, @"OK", nil, nil, 0, false);
	(void) mb.getResult();
}

void JUCE_CALLTYPE NativeMessageBox::showMessageBoxAsync (AlertWindow::AlertIconType iconType,
														  const String& title, const String& message,
														  Component* associatedComponent)
{
	JUCE_AUTORELEASEPOOL
	new iOSMessageBox (title, message, @"OK", nil, nil, 0, true);
}

bool JUCE_CALLTYPE NativeMessageBox::showOkCancelBox (AlertWindow::AlertIconType iconType,
													  const String& title, const String& message,
													  Component* associatedComponent,
													  ModalComponentManager::Callback* callback)
{
	ScopedPointer<iOSMessageBox> mb (new iOSMessageBox (title, message, @"Cancel", @"OK", nil, callback, callback != nullptr));

	if (callback == nullptr)
		return mb->getResult() == 1;

	mb.release();
	return false;
}

int JUCE_CALLTYPE NativeMessageBox::showYesNoCancelBox (AlertWindow::AlertIconType iconType,
														const String& title, const String& message,
														Component* associatedComponent,
														ModalComponentManager::Callback* callback)
{
	ScopedPointer<iOSMessageBox> mb (new iOSMessageBox (title, message, @"Cancel", @"Yes", @"No", callback, callback != nullptr));

	if (callback == nullptr)
		return mb->getResult();

	mb.release();
	return 0;
}

bool DragAndDropContainer::performExternalDragDropOfFiles (const StringArray& files, const bool canMoveFiles)
{
	jassertfalse;    // no such thing on the iphone!
	return false;
}

bool DragAndDropContainer::performExternalDragDropOfText (const String& text)
{
	jassertfalse;    // no such thing on the iphone!
	return false;
}

void Desktop::setScreenSaverEnabled (const bool isEnabled)
{
	[[UIApplication sharedApplication] setIdleTimerDisabled: ! isEnabled];
}

bool Desktop::isScreenSaverEnabled()
{
	return ! [[UIApplication sharedApplication] isIdleTimerDisabled];
}

Image juce_createIconForFile (const File& file)
{
	return Image::null;
}

void SystemClipboard::copyTextToClipboard (const String& text)
{
	[[UIPasteboard generalPasteboard] setValue: juceStringToNS (text)
							 forPasteboardType: @"public.text"];
}

String SystemClipboard::getTextFromClipboard()
{
	NSString* text = [[UIPasteboard generalPasteboard] valueForPasteboardType: @"public.text"];

	return text == nil ? String::empty
					   : nsStringToJuce (text);
}

void Desktop::createMouseInputSources()
{
	for (int i = 0; i < 10; ++i)
		mouseSources.add (new MouseInputSource (i, false));
}

bool Desktop::canUseSemiTransparentWindows() noexcept
{
	return true;
}

Point<int> MouseInputSource::getCurrentMousePosition()
{
	return juce_lastMousePos;
}

void Desktop::setMousePosition (const Point<int>&)
{
}

Desktop::DisplayOrientation Desktop::getCurrentOrientation() const
{
	return convertToJuceOrientation ([[UIApplication sharedApplication] statusBarOrientation]);
}

void Desktop::getCurrentMonitorPositions (Array <Rectangle <int> >& monitorCoords, const bool clipToWorkArea)
{
	JUCE_AUTORELEASEPOOL
	monitorCoords.clear();

	CGRect r = clipToWorkArea ? [[UIScreen mainScreen] applicationFrame]
							  : [[UIScreen mainScreen] bounds];

	monitorCoords.add (UIViewComponentPeer::realScreenPosToRotated (convertToRectInt (r)));
}

/*** End of inlined file: juce_ios_Windowing.mm ***/

 #else

/*** Start of inlined file: juce_mac_NSViewComponentPeer.mm ***/
class NSViewComponentPeer;

typedef void (*AppFocusChangeCallback)();
extern AppFocusChangeCallback appFocusChangeCallback;
typedef bool (*CheckEventBlockedByModalComps) (NSEvent*);
extern CheckEventBlockedByModalComps isEventBlockedByModalComps;

} // (juce namespace)

@interface NSEvent (JuceDeviceDelta)
 - (CGFloat) deviceDeltaX;
 - (CGFloat) deviceDeltaY;

#if ! (defined (MAC_OS_X_VERSION_10_7) && MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_7)
 - (CGFloat) scrollingDeltaX;
 - (CGFloat) scrollingDeltaX;
 - (BOOL) hasPreciseScrollingDeltas;
#endif
@end

#define JuceNSView MakeObjCClassName(JuceNSView)

@interface JuceNSView : NSView<NSTextInput>
{
@public
	NSViewComponentPeer* owner;
	NSNotificationCenter* notificationCenter;
	String* stringBeingComposed;
	bool textWasInserted;
}

- (JuceNSView*) initWithOwner: (NSViewComponentPeer*) owner withFrame: (NSRect) frame;
- (void) dealloc;

- (BOOL) isOpaque;
- (void) drawRect: (NSRect) r;

- (void) mouseDown: (NSEvent*) ev;
- (void) asyncMouseDown: (NSEvent*) ev;
- (void) mouseUp: (NSEvent*) ev;
- (void) asyncMouseUp: (NSEvent*) ev;
- (void) mouseDragged: (NSEvent*) ev;
- (void) mouseMoved: (NSEvent*) ev;
- (void) mouseEntered: (NSEvent*) ev;
- (void) mouseExited: (NSEvent*) ev;
- (void) rightMouseDown: (NSEvent*) ev;
- (void) rightMouseDragged: (NSEvent*) ev;
- (void) rightMouseUp: (NSEvent*) ev;
- (void) otherMouseDown: (NSEvent*) ev;
- (void) otherMouseDragged: (NSEvent*) ev;
- (void) otherMouseUp: (NSEvent*) ev;
- (void) scrollWheel: (NSEvent*) ev;
- (BOOL) acceptsFirstMouse: (NSEvent*) ev;
- (void) frameChanged: (NSNotification*) n;
- (void) viewDidMoveToWindow;

- (void) keyDown: (NSEvent*) ev;
- (void) keyUp: (NSEvent*) ev;

// NSTextInput Methods
- (void) insertText: (id) aString;
- (void) doCommandBySelector: (SEL) aSelector;
- (void) setMarkedText: (id) aString selectedRange: (NSRange) selRange;
- (void) unmarkText;
- (BOOL) hasMarkedText;
- (long) conversationIdentifier;
- (NSAttributedString*) attributedSubstringFromRange: (NSRange) theRange;
- (NSRange) markedRange;
- (NSRange) selectedRange;
- (NSRect) firstRectForCharacterRange: (NSRange) theRange;
- (NSUInteger) characterIndexForPoint: (NSPoint) thePoint;
- (NSArray*) validAttributesForMarkedText;

- (void) flagsChanged: (NSEvent*) ev;
#if MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_5
- (BOOL) performKeyEquivalent: (NSEvent*) ev;
#endif

- (BOOL) becomeFirstResponder;
- (BOOL) resignFirstResponder;
- (BOOL) acceptsFirstResponder;

- (NSArray*) getSupportedDragTypes;
- (BOOL) sendDragCallback: (int) type sender: (id <NSDraggingInfo>) sender;
- (NSDragOperation) draggingEntered: (id <NSDraggingInfo>) sender;
- (NSDragOperation) draggingUpdated: (id <NSDraggingInfo>) sender;
- (void) draggingEnded: (id <NSDraggingInfo>) sender;
- (void) draggingExited: (id <NSDraggingInfo>) sender;
- (BOOL) prepareForDragOperation: (id <NSDraggingInfo>) sender;
- (BOOL) performDragOperation: (id <NSDraggingInfo>) sender;
- (void) concludeDragOperation: (id <NSDraggingInfo>) sender;

@end

#define JuceNSWindow MakeObjCClassName(JuceNSWindow)

#if defined (MAC_OS_X_VERSION_10_6) && MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_6
@interface JuceNSWindow : NSWindow <NSWindowDelegate>
#else
@interface JuceNSWindow : NSWindow
#endif
{
@private
	NSViewComponentPeer* owner;
	bool isZooming;
}

- (void) setOwner: (NSViewComponentPeer*) owner;
- (BOOL) canBecomeKeyWindow;
- (void) becomeKeyWindow;
- (BOOL) windowShouldClose: (id) window;
- (NSRect) constrainFrameRect: (NSRect) frameRect toScreen: (NSScreen*) screen;
- (NSSize) windowWillResize: (NSWindow*) window toSize: (NSSize) proposedFrameSize;
- (void) zoom: (id) sender;
@end

namespace juce
{

class NSViewComponentPeer  : public ComponentPeer
{
public:
	NSViewComponentPeer (Component* const component,
						 const int windowStyleFlags,
						 NSView* viewToAttachTo);

	~NSViewComponentPeer();

	void* getNativeHandle() const;
	void setVisible (bool shouldBeVisible);
	void setTitle (const String& title);
	void setPosition (int x, int y);
	void setSize (int w, int h);
	void setBounds (int x, int y, int w, int h, const bool isNowFullScreen);
	Rectangle<int> getBounds (const bool global) const;
	Rectangle<int> getBounds() const;
	Point<int> getScreenPosition() const;
	Point<int> localToGlobal (const Point<int>& relativePosition);
	Point<int> globalToLocal (const Point<int>& screenPosition);
	void setAlpha (float newAlpha);
	void setMinimised (bool shouldBeMinimised);
	bool isMinimised() const;
	void setFullScreen (bool shouldBeFullScreen);
	bool isFullScreen() const;
	void updateFullscreenStatus();
	bool contains (const Point<int>& position, bool trueIfInAChildWindow) const;
	bool hasNativeTitleBar() const        { return (getStyleFlags() & windowHasTitleBar) != 0; }
	BorderSize<int> getFrameSize() const;
	bool setAlwaysOnTop (bool alwaysOnTop);
	void toFront (bool makeActiveWindow);
	void toBehind (ComponentPeer* other);
	void setIcon (const Image& newIcon);
	StringArray getAvailableRenderingEngines();
	int getCurrentRenderingEngine() const;
	void setCurrentRenderingEngine (int index);

	/* When you use multiple DLLs which share similarly-named obj-c classes - like
	   for example having more than one juce plugin loaded into a host, then when a
	   method is called, the actual code that runs might actually be in a different module
	   than the one you expect... So any calls to library functions or statics that are
	   made inside obj-c methods will probably end up getting executed in a different DLL's
	   memory space. Not a great thing to happen - this obviously leads to bizarre crashes.

	   To work around this insanity, I'm only allowing obj-c methods to make calls to
	   virtual methods of an object that's known to live inside the right module's space.
	*/
	virtual void redirectMouseDown (NSEvent* ev);
	virtual void redirectMouseUp (NSEvent* ev);
	virtual void redirectMouseDrag (NSEvent* ev);
	virtual void redirectMouseMove (NSEvent* ev);
	virtual void redirectMouseEnter (NSEvent* ev);
	virtual void redirectMouseExit (NSEvent* ev);
	virtual void redirectMouseWheel (NSEvent* ev);
	void sendMouseEvent (NSEvent* ev);

	bool handleKeyEvent (NSEvent* ev, bool isKeyDown);
	virtual bool redirectKeyDown (NSEvent* ev);
	virtual bool redirectKeyUp (NSEvent* ev);
	virtual void redirectModKeyChange (NSEvent* ev);
   #if MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_5
	virtual bool redirectPerformKeyEquivalent (NSEvent* ev);
   #endif

	virtual BOOL sendDragCallback (int type, id <NSDraggingInfo> sender);

	virtual bool isOpaque();
	virtual void drawRect (NSRect r);

	virtual bool canBecomeKeyWindow();
	virtual void becomeKeyWindow();
	virtual bool windowShouldClose();

	virtual void redirectMovedOrResized();
	virtual void viewMovedToWindow();

	virtual NSRect constrainRect (NSRect r);

	static void showArrowCursorIfNeeded();
	static void updateModifiers (NSEvent* e);
	static void updateModifiers (NSUInteger);
	static void updateKeysDown (NSEvent* ev, bool isKeyDown);

	static int getKeyCodeFromEvent (NSEvent* ev)
	{
		const String unmodified (nsStringToJuce ([ev charactersIgnoringModifiers]));
		int keyCode = unmodified[0];

		if (keyCode == 0x19) // (backwards-tab)
			keyCode = '\t';
		else if (keyCode == 0x03) // (enter)
			keyCode = '\r';
		else
			keyCode = (int) CharacterFunctions::toUpperCase ((juce_wchar) keyCode);

		if (([ev modifierFlags] & NSNumericPadKeyMask) != 0)
		{
			const int numPadConversions[] = { '0', KeyPress::numberPad0, '1', KeyPress::numberPad1,
											  '2', KeyPress::numberPad2, '3', KeyPress::numberPad3,
											  '4', KeyPress::numberPad4, '5', KeyPress::numberPad5,
											  '6', KeyPress::numberPad6, '7', KeyPress::numberPad7,
											  '8', KeyPress::numberPad8, '9', KeyPress::numberPad9,
											  '+', KeyPress::numberPadAdd,  '-', KeyPress::numberPadSubtract,
											  '*', KeyPress::numberPadMultiply, '/', KeyPress::numberPadDivide,
											  '.', KeyPress::numberPadDecimalPoint, '=', KeyPress::numberPadEquals };

			for (int i = 0; i < numElementsInArray (numPadConversions); i += 2)
				if (keyCode == numPadConversions [i])
					keyCode = numPadConversions [i + 1];
		}

		return keyCode;
	}

	static int64 getMouseTime (NSEvent* e)
	{
		return (Time::currentTimeMillis() - Time::getMillisecondCounter())
				+ (int64) ([e timestamp] * 1000.0);
	}

	static Point<int> getMousePos (NSEvent* e, NSView* view)
	{
		NSPoint p = [view convertPoint: [e locationInWindow] fromView: nil];
		return Point<int> (roundToInt (p.x), roundToInt ([view frame].size.height - p.y));
	}

	static int getModifierForButtonNumber (const NSInteger num)
	{
		return num == 0 ? ModifierKeys::leftButtonModifier
					: (num == 1 ? ModifierKeys::rightButtonModifier
								: (num == 2 ? ModifierKeys::middleButtonModifier : 0));
	}

	static unsigned int getNSWindowStyleMask (const int flags) noexcept
	{
		unsigned int style = (flags & windowHasTitleBar) != 0 ? NSTitledWindowMask
															  : NSBorderlessWindowMask;

		if ((flags & windowHasMinimiseButton) != 0)  style |= NSMiniaturizableWindowMask;
		if ((flags & windowHasCloseButton) != 0)     style |= NSClosableWindowMask;
		if ((flags & windowIsResizable) != 0)        style |= NSResizableWindowMask;
		return style;
	}

	virtual void viewFocusGain();
	virtual void viewFocusLoss();
	bool isFocused() const;
	void grabFocus();
	void textInputRequired (const Point<int>& position);

	void repaint (const Rectangle<int>& area);
	void performAnyPendingRepaintsNow();

	NSWindow* window;
	JuceNSView* view;
	bool isSharedWindow, fullScreen, insideDrawRect, usingCoreGraphics, usingOpenGL, recursiveToFrontCall;

	static ModifierKeys currentModifiers;
	static ComponentPeer* currentlyFocusedPeer;
	static Array<int> keysCurrentlyDown;

private:
	static void appFocusChanged()
	{
		keysCurrentlyDown.clear();

		if (isValidPeer (currentlyFocusedPeer))
		{
			if (Process::isForegroundProcess())
			{
				currentlyFocusedPeer->handleFocusGain();

				ModalComponentManager::getInstance()->bringModalComponentsToFront();
			}
			else
			{
				currentlyFocusedPeer->handleFocusLoss();

				// turn kiosk mode off if we lose focus..
				Desktop::getInstance().setKioskModeComponent (nullptr);
			}
		}
	}

	static bool checkEventBlockedByModalComps (NSEvent* e)
	{
		if (Component::getNumCurrentlyModalComponents() == 0)
			return false;

		NSWindow* const w = [e window];
		if (w == nil || [w worksWhenModal])
			return false;

		bool isKey = false, isInputAttempt = false;

		switch ([e type])
		{
			case NSKeyDown:
			case NSKeyUp:
				isKey = isInputAttempt = true;
				break;

			case NSLeftMouseDown:
			case NSRightMouseDown:
			case NSOtherMouseDown:
				isInputAttempt = true;
				break;

			case NSLeftMouseDragged:
			case NSRightMouseDragged:
			case NSLeftMouseUp:
			case NSRightMouseUp:
			case NSOtherMouseUp:
			case NSOtherMouseDragged:
				if (Desktop::getInstance().getDraggingMouseSource(0) != nullptr)
					return false;
				break;

			case NSMouseMoved:
			case NSMouseEntered:
			case NSMouseExited:
			case NSCursorUpdate:
			case NSScrollWheel:
			case NSTabletPoint:
			case NSTabletProximity:
				break;

			default:
				return false;
		}

		for (int i = ComponentPeer::getNumPeers(); --i >= 0;)
		{
			ComponentPeer* const peer = ComponentPeer::getPeer (i);
			NSView* const compView = (NSView*) peer->getNativeHandle();

			if ([compView window] == w)
			{
				if (isKey)
				{
					if (compView == [w firstResponder])
						return false;
				}
				else
				{
					NSViewComponentPeer* nsViewPeer = dynamic_cast<NSViewComponentPeer*> (peer);

					if ((nsViewPeer == nullptr || ! nsViewPeer->isSharedWindow)
							? NSPointInRect ([e locationInWindow], NSMakeRect (0, 0, [w frame].size.width, [w frame].size.height))
							: NSPointInRect ([compView convertPoint: [e locationInWindow] fromView: nil], [compView bounds]))
						return false;
				}
			}
		}

		if (isInputAttempt)
		{
			if (! [NSApp isActive])
				[NSApp activateIgnoringOtherApps: YES];

			Component* const modal = Component::getCurrentlyModalComponent (0);
			if (modal != nullptr)
				modal->inputAttemptWhenModal();
		}

		return true;
	}

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (NSViewComponentPeer);
};

} // (juce namespace)

@implementation JuceNSView

- (JuceNSView*) initWithOwner: (NSViewComponentPeer*) owner_
					withFrame: (NSRect) frame
{
	[super initWithFrame: frame];
	owner = owner_;
	stringBeingComposed = nullptr;
	textWasInserted = false;

	notificationCenter = [NSNotificationCenter defaultCenter];

	[notificationCenter  addObserver: self
							selector: @selector (frameChanged:)
								name: NSViewFrameDidChangeNotification
							  object: self];

	if (! owner_->isSharedWindow)
	{
		[notificationCenter  addObserver: self
								selector: @selector (frameChanged:)
									name: NSWindowDidMoveNotification
								  object: owner_->window];
	}

	[self registerForDraggedTypes: [self getSupportedDragTypes]];

	return self;
}

- (void) dealloc
{
	[notificationCenter removeObserver: self];
	delete stringBeingComposed;
	[super dealloc];
}

- (void) drawRect: (NSRect) r
{
	if (owner != nullptr)
		owner->drawRect (r);
}

- (BOOL) isOpaque
{
	return owner == nullptr || owner->isOpaque();
}

- (void) mouseDown: (NSEvent*) ev
{
	if (JUCEApplication::isStandaloneApp())
		[self asyncMouseDown: ev];
	else
		// In some host situations, the host will stop modal loops from working
		// correctly if they're called from a mouse event, so we'll trigger
		// the event asynchronously..
		[self performSelectorOnMainThread: @selector (asyncMouseDown:)
							   withObject: ev
							waitUntilDone: NO];
}

- (void) asyncMouseDown: (NSEvent*) ev
{
	if (owner != nullptr)
		owner->redirectMouseDown (ev);
}

- (void) mouseUp: (NSEvent*) ev
{
	if (! JUCEApplication::isStandaloneApp())
		[self asyncMouseUp: ev];
	else
		// In some host situations, the host will stop modal loops from working
		// correctly if they're called from a mouse event, so we'll trigger
		// the event asynchronously..
		[self performSelectorOnMainThread: @selector (asyncMouseUp:)
							   withObject: ev
							waitUntilDone: NO];
}

- (void) asyncMouseUp: (NSEvent*) ev    { if (owner != nullptr) owner->redirectMouseUp    (ev); }
- (void) mouseDragged: (NSEvent*) ev    { if (owner != nullptr) owner->redirectMouseDrag  (ev); }
- (void) mouseMoved:   (NSEvent*) ev    { if (owner != nullptr) owner->redirectMouseMove  (ev); }
- (void) mouseEntered: (NSEvent*) ev    { if (owner != nullptr) owner->redirectMouseEnter (ev); }
- (void) mouseExited:  (NSEvent*) ev    { if (owner != nullptr) owner->redirectMouseExit  (ev); }
- (void) scrollWheel:  (NSEvent*) ev    { if (owner != nullptr) owner->redirectMouseWheel (ev); }

- (void) rightMouseDown:    (NSEvent*) ev   { [self mouseDown:    ev]; }
- (void) rightMouseDragged: (NSEvent*) ev   { [self mouseDragged: ev]; }
- (void) rightMouseUp:      (NSEvent*) ev   { [self mouseUp:      ev]; }
- (void) otherMouseDown:    (NSEvent*) ev   { [self mouseDown:    ev]; }
- (void) otherMouseDragged: (NSEvent*) ev   { [self mouseDragged: ev]; }
- (void) otherMouseUp:      (NSEvent*) ev   { [self mouseUp:      ev]; }

- (BOOL) acceptsFirstMouse: (NSEvent*) ev
{
	(void) ev;
	return YES;
}

- (void) frameChanged: (NSNotification*) n
{
	(void) n;
	if (owner != nullptr)
		owner->redirectMovedOrResized();
}

- (void) viewDidMoveToWindow
{
   if (owner != nullptr)
	   owner->viewMovedToWindow();
}

- (void) keyDown: (NSEvent*) ev
{
	TextInputTarget* const target = owner->findCurrentTextInputTarget();
	textWasInserted = false;

	if (target != nullptr)
		[self interpretKeyEvents: [NSArray arrayWithObject: ev]];
	else
		deleteAndZero (stringBeingComposed);

	if ((! textWasInserted) && (owner == nullptr || ! owner->redirectKeyDown (ev)))
		[super keyDown: ev];
}

- (void) keyUp: (NSEvent*) ev
{
	if (owner == nullptr || ! owner->redirectKeyUp (ev))
		[super keyUp: ev];
}

- (void) insertText: (id) aString
{
	// This commits multi-byte text when return is pressed, or after every keypress for western keyboards
	NSString* newText = [aString isKindOfClass: [NSAttributedString class]] ? [aString string] : aString;

	if ([newText length] > 0)
	{
		TextInputTarget* const target = owner->findCurrentTextInputTarget();

		if (target != nullptr)
		{
			target->insertTextAtCaret (nsStringToJuce (newText));
			textWasInserted = true;
		}
	}

	deleteAndZero (stringBeingComposed);
}

- (void) doCommandBySelector: (SEL) aSelector
{
	(void) aSelector;
}

- (void) setMarkedText: (id) aString selectedRange: (NSRange) selectionRange
{
	(void) selectionRange;

	if (stringBeingComposed == 0)
		stringBeingComposed = new String();

	*stringBeingComposed = nsStringToJuce ([aString isKindOfClass:[NSAttributedString class]] ? [aString string] : aString);

	TextInputTarget* const target = owner->findCurrentTextInputTarget();

	if (target != nullptr)
	{
		const Range<int> currentHighlight (target->getHighlightedRegion());
		target->insertTextAtCaret (*stringBeingComposed);
		target->setHighlightedRegion (currentHighlight.withLength (stringBeingComposed->length()));
		textWasInserted = true;
	}
}

- (void) unmarkText
{
	if (stringBeingComposed != nullptr)
	{
		TextInputTarget* const target = owner->findCurrentTextInputTarget();

		if (target != nullptr)
		{
			target->insertTextAtCaret (*stringBeingComposed);
			textWasInserted = true;
		}
	}

	deleteAndZero (stringBeingComposed);
}

- (BOOL) hasMarkedText
{
	return stringBeingComposed != nullptr;
}

- (long) conversationIdentifier
{
	return (long) (pointer_sized_int) self;
}

- (NSAttributedString*) attributedSubstringFromRange: (NSRange) theRange
{
	TextInputTarget* const target = owner->findCurrentTextInputTarget();

	if (target != nullptr)
	{
		const Range<int> r ((int) theRange.location,
							(int) (theRange.location + theRange.length));

		return [[[NSAttributedString alloc] initWithString: juceStringToNS (target->getTextInRange (r))] autorelease];
	}

	return nil;
}

- (NSRange) markedRange
{
	return stringBeingComposed != nullptr ? NSMakeRange (0, stringBeingComposed->length())
										  : NSMakeRange (NSNotFound, 0);
}

- (NSRange) selectedRange
{
	TextInputTarget* const target = owner->findCurrentTextInputTarget();

	if (target != nullptr)
	{
		const Range<int> highlight (target->getHighlightedRegion());

		if (! highlight.isEmpty())
			return NSMakeRange (highlight.getStart(), highlight.getLength());
	}

	return NSMakeRange (NSNotFound, 0);
}

- (NSRect) firstRectForCharacterRange: (NSRange) theRange
{
	(void) theRange;
	juce::Component* const comp = dynamic_cast <juce::Component*> (owner->findCurrentTextInputTarget());

	if (comp == 0)
		return NSMakeRect (0, 0, 0, 0);

	const Rectangle<int> bounds (comp->getScreenBounds());

	return NSMakeRect (bounds.getX(),
					   [[[NSScreen screens] objectAtIndex: 0] frame].size.height - bounds.getY(),
					   bounds.getWidth(),
					   bounds.getHeight());
}

- (NSUInteger) characterIndexForPoint: (NSPoint) thePoint
{
	(void) thePoint;
	return NSNotFound;
}

- (NSArray*) validAttributesForMarkedText
{
	return [NSArray array];
}

- (void) flagsChanged: (NSEvent*) ev
{
	if (owner != nullptr)
		owner->redirectModKeyChange (ev);
}

#if MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_5
- (BOOL) performKeyEquivalent: (NSEvent*) ev
{
	if (owner != nullptr && owner->redirectPerformKeyEquivalent (ev))
		return true;

	return [super performKeyEquivalent: ev];
}
#endif

- (BOOL) becomeFirstResponder   { if (owner != nullptr) owner->viewFocusGain(); return YES; }
- (BOOL) resignFirstResponder   { if (owner != nullptr) owner->viewFocusLoss(); return YES; }

- (BOOL) acceptsFirstResponder  { return owner != nullptr && owner->canBecomeKeyWindow(); }

- (NSArray*) getSupportedDragTypes
{
	return [NSArray arrayWithObjects: NSFilenamesPboardType, NSFilesPromisePboardType, /* NSStringPboardType,*/ nil];
}

- (BOOL) sendDragCallback: (int) type sender: (id <NSDraggingInfo>) sender
{
	return owner != nullptr && owner->sendDragCallback (type, sender);
}

- (NSDragOperation) draggingEntered: (id <NSDraggingInfo>) sender
{
	if ([self sendDragCallback: 0 sender: sender])
		return NSDragOperationCopy | NSDragOperationMove | NSDragOperationGeneric;
	else
		return NSDragOperationNone;
}

- (NSDragOperation) draggingUpdated: (id <NSDraggingInfo>) sender
{
	if ([self sendDragCallback: 0 sender: sender])
		return NSDragOperationCopy | NSDragOperationMove | NSDragOperationGeneric;
	else
		return NSDragOperationNone;
}

- (void) draggingEnded: (id <NSDraggingInfo>) sender
{
	[self sendDragCallback: 1 sender: sender];
}

- (void) draggingExited: (id <NSDraggingInfo>) sender
{
	[self sendDragCallback: 1 sender: sender];
}

- (BOOL) prepareForDragOperation: (id <NSDraggingInfo>) sender
{
	(void) sender;
	return YES;
}

- (BOOL) performDragOperation: (id <NSDraggingInfo>) sender
{
	return [self sendDragCallback: 2 sender: sender];
}

- (void) concludeDragOperation: (id <NSDraggingInfo>) sender
{
	(void) sender;
}

@end

@implementation JuceNSWindow

- (void) setOwner: (NSViewComponentPeer*) owner_
{
	owner = owner_;
	isZooming = false;
}

- (BOOL) canBecomeKeyWindow
{
	return owner != nullptr && owner->canBecomeKeyWindow();
}

- (void) becomeKeyWindow
{
	[super becomeKeyWindow];

	if (owner != nullptr)
		owner->becomeKeyWindow();
}

- (BOOL) windowShouldClose: (id) window
{
	(void) window;
	return owner == nullptr || owner->windowShouldClose();
}

- (NSRect) constrainFrameRect: (NSRect) frameRect toScreen: (NSScreen*) screen
{
	(void) screen;
	if (owner != nullptr)
		frameRect = owner->constrainRect (frameRect);

	return frameRect;
}

- (NSSize) windowWillResize: (NSWindow*) window toSize: (NSSize) proposedFrameSize
{
	(void) window;
	if (isZooming)
		return proposedFrameSize;

	NSRect frameRect = [self frame];
	frameRect.origin.y -= proposedFrameSize.height - frameRect.size.height;
	frameRect.size = proposedFrameSize;

	if (owner != nullptr)
		frameRect = owner->constrainRect (frameRect);

	if (juce::Component::getCurrentlyModalComponent() != nullptr
		  && owner->getComponent()->isCurrentlyBlockedByAnotherModalComponent()
		  && owner->hasNativeTitleBar())
		juce::Component::getCurrentlyModalComponent()->inputAttemptWhenModal();

	return frameRect.size;
}

- (void) zoom: (id) sender
{
	isZooming = true;
	[super zoom: sender];
	isZooming = false;

	owner->redirectMovedOrResized();
}

- (void) windowWillMove: (NSNotification*) notification
{
	(void) notification;

	if (juce::Component::getCurrentlyModalComponent() != nullptr
		  && owner->getComponent()->isCurrentlyBlockedByAnotherModalComponent()
		  && owner->hasNativeTitleBar())
		juce::Component::getCurrentlyModalComponent()->inputAttemptWhenModal();
}

@end

namespace juce
{

ModifierKeys NSViewComponentPeer::currentModifiers;
ComponentPeer* NSViewComponentPeer::currentlyFocusedPeer = nullptr;
Array<int> NSViewComponentPeer::keysCurrentlyDown;

bool KeyPress::isKeyCurrentlyDown (const int keyCode)
{
	if (NSViewComponentPeer::keysCurrentlyDown.contains (keyCode))
		return true;

	if (keyCode >= 'A' && keyCode <= 'Z'
		 && NSViewComponentPeer::keysCurrentlyDown.contains ((int) CharacterFunctions::toLowerCase ((juce_wchar) keyCode)))
		return true;

	if (keyCode >= 'a' && keyCode <= 'z'
		 && NSViewComponentPeer::keysCurrentlyDown.contains ((int) CharacterFunctions::toUpperCase ((juce_wchar) keyCode)))
		return true;

	return false;
}

void NSViewComponentPeer::updateModifiers (const NSUInteger flags)
{
	int m = 0;

	if ((flags & NSShiftKeyMask) != 0)        m |= ModifierKeys::shiftModifier;
	if ((flags & NSControlKeyMask) != 0)      m |= ModifierKeys::ctrlModifier;
	if ((flags & NSAlternateKeyMask) != 0)    m |= ModifierKeys::altModifier;
	if ((flags & NSCommandKeyMask) != 0)      m |= ModifierKeys::commandModifier;

	currentModifiers = currentModifiers.withOnlyMouseButtons().withFlags (m);
}

void NSViewComponentPeer::updateModifiers (NSEvent* e)
{
	updateModifiers ([e modifierFlags]);
}

void NSViewComponentPeer::updateKeysDown (NSEvent* ev, bool isKeyDown)
{
	updateModifiers (ev);
	int keyCode = getKeyCodeFromEvent (ev);

	if (keyCode != 0)
	{
		if (isKeyDown)
			keysCurrentlyDown.addIfNotAlreadyThere (keyCode);
		else
			keysCurrentlyDown.removeValue (keyCode);
	}
}

ModifierKeys ModifierKeys::getCurrentModifiersRealtime() noexcept
{
	if ([NSEvent respondsToSelector: @selector (modifierFlags)])
		NSViewComponentPeer::updateModifiers ([NSEvent modifierFlags]);

	return NSViewComponentPeer::currentModifiers;
}

void ModifierKeys::updateCurrentModifiers() noexcept
{
	currentModifiers = NSViewComponentPeer::currentModifiers;
}

NSViewComponentPeer::NSViewComponentPeer (Component* const component_,
										  const int windowStyleFlags,
										  NSView* viewToAttachTo)
	: ComponentPeer (component_, windowStyleFlags),
	  window (nil),
	  view (nil),
	  isSharedWindow (viewToAttachTo != nil),
	  fullScreen (false),
	  insideDrawRect (false),
	 #if USE_COREGRAPHICS_RENDERING
	  usingCoreGraphics (true),
	 #else
	  usingCoreGraphics (false),
	 #endif
	  usingOpenGL (false),
	  recursiveToFrontCall (false)
{
	appFocusChangeCallback = appFocusChanged;
	isEventBlockedByModalComps = checkEventBlockedByModalComps;

	NSRect r = NSMakeRect (0, 0, (CGFloat) component->getWidth(), (CGFloat) component->getHeight());

	view = [[JuceNSView alloc] initWithOwner: this withFrame: r];
	[view setPostsFrameChangedNotifications: YES];

	if (isSharedWindow)
	{
		window = [viewToAttachTo window];
		[viewToAttachTo addSubview: view];
	}
	else
	{
		r.origin.x = (CGFloat) component->getX();
		r.origin.y = (CGFloat) component->getY();
		r.origin.y = [[[NSScreen screens] objectAtIndex: 0] frame].size.height - (r.origin.y + r.size.height);

		window = [[JuceNSWindow alloc] initWithContentRect: r
												 styleMask: getNSWindowStyleMask (windowStyleFlags)
												   backing: NSBackingStoreBuffered
													 defer: YES];

		[((JuceNSWindow*) window) setOwner: this];
		[window orderOut: nil];
		[window setDelegate: (JuceNSWindow*) window];
		[window setOpaque: component->isOpaque()];
		[window setHasShadow: ((windowStyleFlags & windowHasDropShadow) != 0)];

		if (component->isAlwaysOnTop())
			[window setLevel: NSFloatingWindowLevel];

		[window setContentView: view];
		[window setAutodisplay: YES];
		[window setAcceptsMouseMovedEvents: YES];

		// We'll both retain and also release this on closing because plugin hosts can unexpectedly
		// close the window for us, and also tend to get cause trouble if setReleasedWhenClosed is NO.
		[window setReleasedWhenClosed: YES];
		[window retain];

		[window setExcludedFromWindowsMenu: (windowStyleFlags & windowIsTemporary) != 0];
		[window setIgnoresMouseEvents: (windowStyleFlags & windowIgnoresMouseClicks) != 0];

	   #if defined (MAC_OS_X_VERSION_10_7) && (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_7)
		if ((windowStyleFlags & (windowHasMaximiseButton | windowHasTitleBar)) == (windowHasMaximiseButton | windowHasTitleBar))
			[window setCollectionBehavior: NSWindowCollectionBehaviorFullScreenPrimary];
	   #endif
	}

	const float alpha = component->getAlpha();
	if (alpha < 1.0f)
		setAlpha (alpha);

	setTitle (component->getName());
}

NSViewComponentPeer::~NSViewComponentPeer()
{
	view->owner = nullptr;
	[view removeFromSuperview];
	[view release];

	if (! isSharedWindow)
	{
		[((JuceNSWindow*) window) setOwner: 0];
		[window close];
		[window release];
	}
}

void* NSViewComponentPeer::getNativeHandle() const
{
	return view;
}

void NSViewComponentPeer::setVisible (bool shouldBeVisible)
{
	if (isSharedWindow)
	{
		[view setHidden: ! shouldBeVisible];
	}
	else
	{
		if (shouldBeVisible)
		{
			[window orderFront: nil];
			handleBroughtToFront();
		}
		else
		{
			[window orderOut: nil];
		}
	}
}

void NSViewComponentPeer::setTitle (const String& title)
{
	JUCE_AUTORELEASEPOOL

	if (! isSharedWindow)
		[window setTitle: juceStringToNS (title)];
}

void NSViewComponentPeer::setPosition (int x, int y)
{
	setBounds (x, y, component->getWidth(), component->getHeight(), false);
}

void NSViewComponentPeer::setSize (int w, int h)
{
	setBounds (component->getX(), component->getY(), w, h, false);
}

void NSViewComponentPeer::setBounds (int x, int y, int w, int h, bool isNowFullScreen)
{
	fullScreen = isNowFullScreen;

	NSRect r = NSMakeRect ((CGFloat) x, (CGFloat) y, (CGFloat) jmax (0, w), (CGFloat) jmax (0, h));

	if (isSharedWindow)
	{
		r.origin.y = [[view superview] frame].size.height - (r.origin.y + r.size.height);

		if ([view frame].size.width != r.size.width
			 || [view frame].size.height != r.size.height)
		{
			[view setNeedsDisplay: true];
		}

		[view setFrame: r];
	}
	else
	{
		r.origin.y = [[[NSScreen screens] objectAtIndex: 0] frame].size.height - (r.origin.y + r.size.height);

		[window setFrame: [window frameRectForContentRect: r]
				 display: true];
	}
}

Rectangle<int> NSViewComponentPeer::getBounds (const bool global) const
{
	NSRect r = [view frame];

	if (global && [view window] != nil)
	{
		r = [view convertRect: r toView: nil];
		NSRect wr = [[view window] frame];
		r.origin.x += wr.origin.x;
		r.origin.y += wr.origin.y;
		r.origin.y = [[[NSScreen screens] objectAtIndex: 0] frame].size.height - r.origin.y - r.size.height;
	}
	else
	{
		r.origin.y = [[view superview] frame].size.height - r.origin.y - r.size.height;
	}

	return Rectangle<int> (convertToRectInt (r));
}

Rectangle<int> NSViewComponentPeer::getBounds() const
{
	return getBounds (! isSharedWindow);
}

Point<int> NSViewComponentPeer::getScreenPosition() const
{
	return getBounds (true).getPosition();
}

Point<int> NSViewComponentPeer::localToGlobal (const Point<int>& relativePosition)
{
	return relativePosition + getScreenPosition();
}

Point<int> NSViewComponentPeer::globalToLocal (const Point<int>& screenPosition)
{
	return screenPosition - getScreenPosition();
}

NSRect NSViewComponentPeer::constrainRect (NSRect r)
{
	if (constrainer != nullptr
		#if defined (MAC_OS_X_VERSION_10_7) && (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_7)
		 && ([window styleMask] & NSFullScreenWindowMask) == 0
		#endif
		)
	{
		NSRect current = [window frame];
		current.origin.y = [[[NSScreen screens] objectAtIndex: 0] frame].size.height - current.origin.y - current.size.height;

		r.origin.y = [[[NSScreen screens] objectAtIndex: 0] frame].size.height - r.origin.y - r.size.height;

		Rectangle<int> pos (convertToRectInt (r));
		Rectangle<int> original (convertToRectInt (current));

	   #if defined (MAC_OS_X_VERSION_10_6) && MAC_OS_X_VERSION_MIN_ALLOWED >= MAC_OS_X_VERSION_10_6
		if ([window inLiveResize])
	   #else
		if ([window respondsToSelector: @selector (inLiveResize)]
			 && [window performSelector: @selector (inLiveResize)])
	   #endif
		{
			constrainer->checkBounds (pos, original,
									  Desktop::getInstance().getAllMonitorDisplayAreas().getBounds(),
									  false, false, true, true);
		}
		else
		{
			constrainer->checkBounds (pos, original,
									  Desktop::getInstance().getAllMonitorDisplayAreas().getBounds(),
									  pos.getY() != original.getY() && pos.getBottom() == original.getBottom(),
									  pos.getX() != original.getX() && pos.getRight() == original.getRight(),
									  pos.getY() == original.getY() && pos.getBottom() != original.getBottom(),
									  pos.getX() == original.getX() && pos.getRight() != original.getRight());
		}

		r.origin.x = pos.getX();
		r.origin.y = [[[NSScreen screens] objectAtIndex: 0] frame].size.height - r.size.height - pos.getY();
		r.size.width = pos.getWidth();
		r.size.height = pos.getHeight();
	}

	return r;
}

void NSViewComponentPeer::setAlpha (float newAlpha)
{
	if (! isSharedWindow)
	{
		[window setAlphaValue: (CGFloat) newAlpha];
	}
	else
	{
	   #if defined (MAC_OS_X_VERSION_10_5) && MAC_OS_X_VERSION_MIN_ALLOWED >= MAC_OS_X_VERSION_10_5
		[view setAlphaValue: (CGFloat) newAlpha];
	   #else
		if ([view respondsToSelector: @selector (setAlphaValue:)])
		{
			// PITA dynamic invocation for 10.4 builds..
			NSInvocation* inv = [NSInvocation invocationWithMethodSignature: [view methodSignatureForSelector: @selector (setAlphaValue:)]];
			[inv setSelector: @selector (setAlphaValue:)];
			[inv setTarget: view];
			CGFloat cgNewAlpha = (CGFloat) newAlpha;
			[inv setArgument: &cgNewAlpha atIndex: 2];
			[inv invoke];
		}
	   #endif
	}
}

void NSViewComponentPeer::setMinimised (bool shouldBeMinimised)
{
	if (! isSharedWindow)
	{
		if (shouldBeMinimised)
			[window miniaturize: nil];
		else
			[window deminiaturize: nil];
	}
}

bool NSViewComponentPeer::isMinimised() const
{
	return [window isMiniaturized];
}

void NSViewComponentPeer::setFullScreen (bool shouldBeFullScreen)
{
	if (! isSharedWindow)
	{
		Rectangle<int> r (lastNonFullscreenBounds);

		if (isMinimised())
			setMinimised (false);

		if (fullScreen != shouldBeFullScreen)
		{
			if (shouldBeFullScreen && hasNativeTitleBar())
			{
				fullScreen = true;
				[window performZoom: nil];
			}
			else
			{
				if (shouldBeFullScreen)
					r = component->getParentMonitorArea();

				// (can't call the component's setBounds method because that'll reset our fullscreen flag)
				if (r != getComponent()->getBounds() && ! r.isEmpty())
					setBounds (r.getX(), r.getY(), r.getWidth(), r.getHeight(), shouldBeFullScreen);
			}
		}
	}
}

bool NSViewComponentPeer::isFullScreen() const
{
	return fullScreen;
}

bool NSViewComponentPeer::contains (const Point<int>& position, bool trueIfInAChildWindow) const
{
	if (! (isPositiveAndBelow (position.getX(), component->getWidth())
			&& isPositiveAndBelow (position.getY(), component->getHeight())))
		return false;

	NSRect frameRect = [view frame];

	NSView* v = [view hitTest: NSMakePoint (frameRect.origin.x + position.getX(),
											frameRect.origin.y + frameRect.size.height - position.getY())];

	if (trueIfInAChildWindow)
		return v != nil;

	return v == view;
}

BorderSize<int> NSViewComponentPeer::getFrameSize() const
{
	BorderSize<int> b;

	if (! isSharedWindow)
	{
		NSRect v = [view convertRect: [view frame] toView: nil];
		NSRect w = [window frame];

		b.setTop ((int) (w.size.height - (v.origin.y + v.size.height)));
		b.setBottom ((int) v.origin.y);
		b.setLeft ((int) v.origin.x);
		b.setRight ((int) (w.size.width - (v.origin.x + v.size.width)));
	}

	return b;
}

bool NSViewComponentPeer::setAlwaysOnTop (bool alwaysOnTop)
{
	if (! isSharedWindow)
		[window setLevel: alwaysOnTop ? NSFloatingWindowLevel
									  : NSNormalWindowLevel];
	return true;
}

void NSViewComponentPeer::toFront (bool makeActiveWindow)
{
	if (isSharedWindow)
		[[view superview] addSubview: view
						  positioned: NSWindowAbove
						  relativeTo: nil];

	if (window != nil && component->isVisible())
	{
		if (makeActiveWindow)
			[window makeKeyAndOrderFront: nil];
		else
			[window orderFront: nil];

		if (! recursiveToFrontCall)
		{
			recursiveToFrontCall = true;
			Desktop::getInstance().getMainMouseSource().forceMouseCursorUpdate();
			handleBroughtToFront();
			recursiveToFrontCall = false;
		}
	}
}

void NSViewComponentPeer::toBehind (ComponentPeer* other)
{
	NSViewComponentPeer* const otherPeer = dynamic_cast <NSViewComponentPeer*> (other);
	jassert (otherPeer != nullptr); // wrong type of window?

	if (otherPeer != nullptr)
	{
		if (isSharedWindow)
		{
			[[view superview] addSubview: view
							  positioned: NSWindowBelow
							  relativeTo: otherPeer->view];
		}
		else
		{
			[window orderWindow: NSWindowBelow
					 relativeTo: [otherPeer->window windowNumber]];
		}
	}
}

void NSViewComponentPeer::setIcon (const Image& /*newIcon*/)
{
	// to do..
}

void NSViewComponentPeer::viewFocusGain()
{
	if (currentlyFocusedPeer != this)
	{
		if (ComponentPeer::isValidPeer (currentlyFocusedPeer))
			currentlyFocusedPeer->handleFocusLoss();

		currentlyFocusedPeer = this;
		handleFocusGain();
	}
}

void NSViewComponentPeer::viewFocusLoss()
{
	if (currentlyFocusedPeer == this)
	{
		currentlyFocusedPeer = nullptr;
		handleFocusLoss();
	}
}

bool NSViewComponentPeer::isFocused() const
{
	return isSharedWindow ? this == currentlyFocusedPeer
						  : [window isKeyWindow];
}

void NSViewComponentPeer::grabFocus()
{
	if (window != nil)
	{
		[window makeKeyWindow];
		[window makeFirstResponder: view];

		viewFocusGain();
	}
}

void NSViewComponentPeer::textInputRequired (const Point<int>&)
{
}

bool NSViewComponentPeer::handleKeyEvent (NSEvent* ev, bool isKeyDown)
{
	String unicode (nsStringToJuce ([ev characters]));
	String unmodified (nsStringToJuce ([ev charactersIgnoringModifiers]));
	int keyCode = getKeyCodeFromEvent (ev);

	//DBG ("unicode: " + unicode + " " + String::toHexString ((int) unicode[0]));
	//DBG ("unmodified: " + unmodified + " " + String::toHexString ((int) unmodified[0]));

	if (unicode.isNotEmpty() || keyCode != 0)
	{
		if (isKeyDown)
		{
			bool used = false;

			while (unicode.length() > 0)
			{
				juce_wchar textCharacter = unicode[0];
				unicode = unicode.substring (1);

				if (([ev modifierFlags] & NSCommandKeyMask) != 0)
					textCharacter = 0;

				used = handleKeyUpOrDown (true) || used;
				used = handleKeyPress (keyCode, textCharacter) || used;
			}

			return used;
		}
		else
		{
			if (handleKeyUpOrDown (false))
				return true;
		}
	}

	return false;
}

bool NSViewComponentPeer::redirectKeyDown (NSEvent* ev)
{
	updateKeysDown (ev, true);
	bool used = handleKeyEvent (ev, true);

	if (([ev modifierFlags] & NSCommandKeyMask) != 0)
	{
		// for command keys, the key-up event is thrown away, so simulate one..
		updateKeysDown (ev, false);
		used = (isValidPeer (this) && handleKeyEvent (ev, false)) || used;
	}

	// (If we're running modally, don't allow unused keystrokes to be passed
	// along to other blocked views..)
	if (Component::getCurrentlyModalComponent() != nullptr)
		used = true;

	return used;
}

bool NSViewComponentPeer::redirectKeyUp (NSEvent* ev)
{
	updateKeysDown (ev, false);
	return handleKeyEvent (ev, false)
			|| Component::getCurrentlyModalComponent() != nullptr;
}

void NSViewComponentPeer::redirectModKeyChange (NSEvent* ev)
{
	keysCurrentlyDown.clear();
	handleKeyUpOrDown (true);

	updateModifiers (ev);
	handleModifierKeysChange();
}

#if MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_5
bool NSViewComponentPeer::redirectPerformKeyEquivalent (NSEvent* ev)
{
	if ([ev type] == NSKeyDown)
		return redirectKeyDown (ev);
	else if ([ev type] == NSKeyUp)
		return redirectKeyUp (ev);

	return false;
}
#endif

void NSViewComponentPeer::sendMouseEvent (NSEvent* ev)
{
	updateModifiers (ev);
	handleMouseEvent (0, getMousePos (ev, view), currentModifiers, getMouseTime (ev));
}

void NSViewComponentPeer::redirectMouseDown (NSEvent* ev)
{
	currentModifiers = currentModifiers.withFlags (getModifierForButtonNumber ([ev buttonNumber]));
	sendMouseEvent (ev);
}

void NSViewComponentPeer::redirectMouseUp (NSEvent* ev)
{
	currentModifiers = currentModifiers.withoutFlags (getModifierForButtonNumber ([ev buttonNumber]));
	sendMouseEvent (ev);
	showArrowCursorIfNeeded();
}

void NSViewComponentPeer::redirectMouseDrag (NSEvent* ev)
{
	currentModifiers = currentModifiers.withFlags (getModifierForButtonNumber ([ev buttonNumber]));
	sendMouseEvent (ev);
}

void NSViewComponentPeer::redirectMouseMove (NSEvent* ev)
{
	currentModifiers = currentModifiers.withoutMouseButtons();
	sendMouseEvent (ev);
	showArrowCursorIfNeeded();
}

void NSViewComponentPeer::redirectMouseEnter (NSEvent* ev)
{
	Desktop::getInstance().getMainMouseSource().forceMouseCursorUpdate();
	currentModifiers = currentModifiers.withoutMouseButtons();
	sendMouseEvent (ev);
}

void NSViewComponentPeer::redirectMouseExit (NSEvent* ev)
{
	currentModifiers = currentModifiers.withoutMouseButtons();
	sendMouseEvent (ev);
}

void NSViewComponentPeer::redirectMouseWheel (NSEvent* ev)
{
	updateModifiers (ev);

	float x = 0, y = 0;

	@try
	{
	   #if defined (MAC_OS_X_VERSION_10_7) && MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_7
		if ([ev respondsToSelector: @selector (hasPreciseScrollingDeltas)])
		{
			if ([ev hasPreciseScrollingDeltas])
			{
				x = [ev scrollingDeltaX] * 0.5f;
				y = [ev scrollingDeltaY] * 0.5f;
			}
		}
		else
	   #endif
		{
			x = [ev deviceDeltaX] * 0.5f;
			y = [ev deviceDeltaY] * 0.5f;
		}
	}
	@catch (...)
	{}

	if (x == 0 && y == 0)
	{
		x = [ev deltaX] * 10.0f;
		y = [ev deltaY] * 10.0f;
	}

	handleMouseWheel (0, getMousePos (ev, view), getMouseTime (ev), x, y);
}

void NSViewComponentPeer::showArrowCursorIfNeeded()
{
	MouseInputSource& mouse = Desktop::getInstance().getMainMouseSource();

	if (mouse.getComponentUnderMouse() == nullptr
		 && Desktop::getInstance().findComponentAt (mouse.getScreenPosition()) == nullptr)
	{
		[[NSCursor arrowCursor] set];
	}
}

BOOL NSViewComponentPeer::sendDragCallback (const int type, id <NSDraggingInfo> sender)
{
	NSString* bestType
		= [[sender draggingPasteboard] availableTypeFromArray: [view getSupportedDragTypes]];

	if (bestType == nil)
		return false;

	NSPoint p = [view convertPoint: [sender draggingLocation] fromView: nil];
	const Point<int> pos ((int) p.x, (int) ([view frame].size.height - p.y));

	NSPasteboard* pasteBoard = [sender draggingPasteboard];
	StringArray files;

	NSString* iTunesPasteboardType = nsStringLiteral ("CorePasteboardFlavorType 0x6974756E"); // 'itun'

	if (bestType == NSFilesPromisePboardType
		 && [[pasteBoard types] containsObject: iTunesPasteboardType])
	{
		id list = [pasteBoard propertyListForType: iTunesPasteboardType];

		if ([list isKindOfClass: [NSDictionary class]])
		{
			NSDictionary* iTunesDictionary = (NSDictionary*) list;
			NSArray* tracks = [iTunesDictionary valueForKey: nsStringLiteral ("Tracks")];
			NSEnumerator* enumerator = [tracks objectEnumerator];
			NSDictionary* track;

			while ((track = [enumerator nextObject]) != nil)
			{
				NSURL* url = [NSURL URLWithString: [track valueForKey: nsStringLiteral ("Location")]];

				if ([url isFileURL])
					files.add (nsStringToJuce ([url path]));
			}
		}
	}
	else
	{
		id list = [pasteBoard propertyListForType: NSFilenamesPboardType];

		if ([list isKindOfClass: [NSArray class]])
		{
			NSArray* items = (NSArray*) [pasteBoard propertyListForType: NSFilenamesPboardType];

			for (unsigned int i = 0; i < [items count]; ++i)
				files.add (nsStringToJuce ((NSString*) [items objectAtIndex: i]));
		}
	}

	if (files.size() > 0)
	{
		switch (type)
		{
			case 0:   return handleFileDragMove (files, pos);
			case 1:   return handleFileDragExit (files);
			case 2:   return handleFileDragDrop (files, pos);
			default:  jassertfalse; break;
		}
	}

	return false;
}

bool NSViewComponentPeer::isOpaque()
{
	return component == nullptr || component->isOpaque();
}

static void getClipRects (RectangleList& clip, NSView* view,
						  const int xOffset, const int yOffset, const int clipW, const int clipH)
{
	const NSRect* rects = nullptr;
	NSInteger numRects = 0;
	[view getRectsBeingDrawn: &rects count: &numRects];

	const Rectangle<int> clipBounds (clipW, clipH);
	const CGFloat viewH = [view frame].size.height;

	for (int i = 0; i < numRects; ++i)
		clip.addWithoutMerging (clipBounds.getIntersection (Rectangle<int> (roundToInt (rects[i].origin.x) + xOffset,
																			roundToInt (viewH - (rects[i].origin.y + rects[i].size.height)) + yOffset,
																			roundToInt (rects[i].size.width),
																			roundToInt (rects[i].size.height))));
}

void NSViewComponentPeer::drawRect (NSRect r)
{
	if (r.size.width < 1.0f || r.size.height < 1.0f)
		return;

	CGContextRef cg = (CGContextRef) [[NSGraphicsContext currentContext] graphicsPort];

	if (! component->isOpaque())
		CGContextClearRect (cg, CGContextGetClipBoundingBox (cg));

   #if USE_COREGRAPHICS_RENDERING
	if (usingCoreGraphics)
	{
		CoreGraphicsContext context (cg, (float) [view frame].size.height);

		insideDrawRect = true;
		handlePaint (context);
		insideDrawRect = false;
	}
	else
   #endif
	{
		const int xOffset = -roundToInt (r.origin.x);
		const int yOffset = -roundToInt ([view frame].size.height - (r.origin.y + r.size.height));
		const int clipW = (int) (r.size.width  + 0.5f);
		const int clipH = (int) (r.size.height + 0.5f);

		RectangleList clip;
		getClipRects (clip, view, xOffset, yOffset, clipW, clipH);

		if (! clip.isEmpty())
		{
			Image temp (getComponent()->isOpaque() ? Image::RGB : Image::ARGB,
						clipW, clipH, ! getComponent()->isOpaque());

			{
				ScopedPointer<LowLevelGraphicsContext> context (component->getLookAndFeel()
																	.createGraphicsContext (temp, Point<int> (xOffset, yOffset), clip));

				insideDrawRect = true;
				handlePaint (*context);
				insideDrawRect = false;
			}

			CGColorSpaceRef colourSpace = CGColorSpaceCreateDeviceRGB();
			CGImageRef image = juce_createCoreGraphicsImage (temp, false, colourSpace, false);
			CGColorSpaceRelease (colourSpace);
			CGContextDrawImage (cg, CGRectMake (r.origin.x, r.origin.y, clipW, clipH), image);
			CGImageRelease (image);
		}
	}
}

StringArray NSViewComponentPeer::getAvailableRenderingEngines()
{
	StringArray s (ComponentPeer::getAvailableRenderingEngines());

   #if USE_COREGRAPHICS_RENDERING
	s.add ("CoreGraphics Renderer");
   #endif

	return s;
}

int NSViewComponentPeer::getCurrentRenderingEngine() const
{
	return usingCoreGraphics ? 1 : 0;
}

void NSViewComponentPeer::setCurrentRenderingEngine (int index)
{
   #if USE_COREGRAPHICS_RENDERING
	if (usingCoreGraphics != (index > 0))
	{
		usingCoreGraphics = index > 0;
		[view setNeedsDisplay: true];
	}
   #endif
}

bool NSViewComponentPeer::canBecomeKeyWindow()
{
	return (getStyleFlags() & juce::ComponentPeer::windowIgnoresKeyPresses) == 0;
}

void NSViewComponentPeer::becomeKeyWindow()
{
	handleBroughtToFront();
	grabFocus();
}

bool NSViewComponentPeer::windowShouldClose()
{
	if (! isValidPeer (this))
		return YES;

	handleUserClosingWindow();
	return NO;
}

void NSViewComponentPeer::updateFullscreenStatus()
{
	if (hasNativeTitleBar())
	{
		const Rectangle<int> screen (getFrameSize().subtractedFrom (component->getParentMonitorArea()));
		const Rectangle<int> window (component->getScreenBounds());

		fullScreen = std::abs (screen.getX() - window.getX()) <= 2
				  && std::abs (screen.getY() - window.getY()) <= 2
				  && std::abs (screen.getRight() - window.getRight()) <= 2
				  && std::abs (screen.getBottom() - window.getBottom()) <= 2;
	}
}

void NSViewComponentPeer::redirectMovedOrResized()
{
	updateFullscreenStatus();
	handleMovedOrResized();
}

void NSViewComponentPeer::viewMovedToWindow()
{
	if (isSharedWindow)
		window = [view window];
}

void Desktop::createMouseInputSources()
{
	mouseSources.add (new MouseInputSource (0, true));
}

void Desktop::setKioskComponent (Component* kioskModeComponent, bool enableOrDisable, bool allowMenusAndBars)
{
   #if defined (MAC_OS_X_VERSION_10_6) && MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_6

	NSViewComponentPeer* const peer = dynamic_cast<NSViewComponentPeer*> (kioskModeComponent->getPeer());

   #if defined (MAC_OS_X_VERSION_10_7) && MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_7
	if (peer != nullptr
		 && peer->hasNativeTitleBar()
		 && [peer->window respondsToSelector: @selector (toggleFullScreen:)])
	{
		[peer->window performSelector: @selector (toggleFullScreen:)
						   withObject: [NSNumber numberWithBool: (BOOL) enableOrDisable]];
	}
	else
   #endif
	{
		if (enableOrDisable)
		{
			if (peer->hasNativeTitleBar())
				[peer->window setStyleMask: NSBorderlessWindowMask];

			[NSApp setPresentationOptions: (allowMenusAndBars ? (NSApplicationPresentationAutoHideDock | NSApplicationPresentationAutoHideMenuBar)
															  : (NSApplicationPresentationHideDock | NSApplicationPresentationHideMenuBar))];
			kioskModeComponent->setBounds (Desktop::getInstance().getMainMonitorArea (false));
		}
		else
		{
			if (peer->hasNativeTitleBar())
			{
				[peer->window setStyleMask: (NSViewComponentPeer::getNSWindowStyleMask (peer->getStyleFlags()))];
				peer->setTitle (peer->component->getName()); // required to force the OS to update the title
			}

			[NSApp setPresentationOptions: NSApplicationPresentationDefault];
		}
	}
   #elif JUCE_SUPPORT_CARBON
	if (enableOrDisable)
	{
		SetSystemUIMode (kUIModeAllSuppressed, allowMenusAndBars ? kUIOptionAutoShowMenuBar : 0);
		kioskModeComponent->setBounds (Desktop::getInstance().getMainMonitorArea (false));
	}
	else
	{
		SetSystemUIMode (kUIModeNormal, 0);
	}
   #else
	// If you're targeting OSes earlier than 10.6 and want to use this feature,
	// you'll need to enable JUCE_SUPPORT_CARBON.
	jassertfalse;
   #endif
}

void NSViewComponentPeer::repaint (const Rectangle<int>& area)
{
	if (insideDrawRect)
	{
		class AsyncRepaintMessage  : public CallbackMessage
		{
		public:
			AsyncRepaintMessage (NSViewComponentPeer* const peer_, const Rectangle<int>& rect_)
				: peer (peer_), rect (rect_)
			{
			}

			void messageCallback()
			{
				if (ComponentPeer::isValidPeer (peer))
					peer->repaint (rect);
			}

		private:
			NSViewComponentPeer* const peer;
			const Rectangle<int> rect;
		};

		(new AsyncRepaintMessage (this, area))->post();
	}
	else
	{
		[view setNeedsDisplayInRect: NSMakeRect ((CGFloat) area.getX(), [view frame].size.height - (CGFloat) area.getBottom(),
												 (CGFloat) area.getWidth(), (CGFloat) area.getHeight())];
	}
}

void NSViewComponentPeer::performAnyPendingRepaintsNow()
{
	[view displayIfNeeded];
}

ComponentPeer* Component::createNewPeer (int styleFlags, void* windowToAttachTo)
{
	return new NSViewComponentPeer (this, styleFlags, (NSView*) windowToAttachTo);
}

const int KeyPress::spaceKey        = ' ';
const int KeyPress::returnKey       = 0x0d;
const int KeyPress::escapeKey       = 0x1b;
const int KeyPress::backspaceKey    = 0x7f;
const int KeyPress::leftKey         = NSLeftArrowFunctionKey;
const int KeyPress::rightKey        = NSRightArrowFunctionKey;
const int KeyPress::upKey           = NSUpArrowFunctionKey;
const int KeyPress::downKey         = NSDownArrowFunctionKey;
const int KeyPress::pageUpKey       = NSPageUpFunctionKey;
const int KeyPress::pageDownKey     = NSPageDownFunctionKey;
const int KeyPress::endKey          = NSEndFunctionKey;
const int KeyPress::homeKey         = NSHomeFunctionKey;
const int KeyPress::deleteKey       = NSDeleteFunctionKey;
const int KeyPress::insertKey       = -1;
const int KeyPress::tabKey          = 9;
const int KeyPress::F1Key           = NSF1FunctionKey;
const int KeyPress::F2Key           = NSF2FunctionKey;
const int KeyPress::F3Key           = NSF3FunctionKey;
const int KeyPress::F4Key           = NSF4FunctionKey;
const int KeyPress::F5Key           = NSF5FunctionKey;
const int KeyPress::F6Key           = NSF6FunctionKey;
const int KeyPress::F7Key           = NSF7FunctionKey;
const int KeyPress::F8Key           = NSF8FunctionKey;
const int KeyPress::F9Key           = NSF9FunctionKey;
const int KeyPress::F10Key          = NSF10FunctionKey;
const int KeyPress::F11Key          = NSF1FunctionKey;
const int KeyPress::F12Key          = NSF12FunctionKey;
const int KeyPress::F13Key          = NSF13FunctionKey;
const int KeyPress::F14Key          = NSF14FunctionKey;
const int KeyPress::F15Key          = NSF15FunctionKey;
const int KeyPress::F16Key          = NSF16FunctionKey;
const int KeyPress::numberPad0      = 0x30020;
const int KeyPress::numberPad1      = 0x30021;
const int KeyPress::numberPad2      = 0x30022;
const int KeyPress::numberPad3      = 0x30023;
const int KeyPress::numberPad4      = 0x30024;
const int KeyPress::numberPad5      = 0x30025;
const int KeyPress::numberPad6      = 0x30026;
const int KeyPress::numberPad7      = 0x30027;
const int KeyPress::numberPad8      = 0x30028;
const int KeyPress::numberPad9      = 0x30029;
const int KeyPress::numberPadAdd            = 0x3002a;
const int KeyPress::numberPadSubtract       = 0x3002b;
const int KeyPress::numberPadMultiply       = 0x3002c;
const int KeyPress::numberPadDivide         = 0x3002d;
const int KeyPress::numberPadSeparator      = 0x3002e;
const int KeyPress::numberPadDecimalPoint   = 0x3002f;
const int KeyPress::numberPadEquals         = 0x30030;
const int KeyPress::numberPadDelete         = 0x30031;
const int KeyPress::playKey         = 0x30000;
const int KeyPress::stopKey         = 0x30001;
const int KeyPress::fastForwardKey  = 0x30002;
const int KeyPress::rewindKey       = 0x30003;

/*** End of inlined file: juce_mac_NSViewComponentPeer.mm ***/



/*** Start of inlined file: juce_mac_Windowing.mm ***/
void LookAndFeel::playAlertSound()
{
	NSBeep();
}

class OSXMessageBox  : public AsyncUpdater
{
public:
	OSXMessageBox (AlertWindow::AlertIconType iconType_,
				   const String& title_, const String& message_,
				   NSString* button1_, NSString* button2_, NSString* button3_,
				   ModalComponentManager::Callback* callback_,
				   const bool runAsync)
		: iconType (iconType_), title (title_),
		  message (message_), callback (callback_),
		  button1 ([button1_ retain]),
		  button2 ([button2_ retain]),
		  button3 ([button3_ retain])
	{
		if (runAsync)
			triggerAsyncUpdate();
	}

	~OSXMessageBox()
	{
		[button1 release];
		[button2 release];
		[button3 release];
	}

	int getResult() const
	{
		JUCE_AUTORELEASEPOOL
		NSInteger r = getRawResult();
		return r == NSAlertDefaultReturn ? 1 : (r == NSAlertOtherReturn ? 2 : 0);
	}

	void handleAsyncUpdate()
	{
		const int result = getResult();

		if (callback != nullptr)
			callback->modalStateFinished (result);

		delete this;
	}

private:
	AlertWindow::AlertIconType iconType;
	String title, message;
	ModalComponentManager::Callback* callback;
	NSString* button1;
	NSString* button2;
	NSString* button3;

	NSInteger getRawResult() const
	{
		NSString* messageString = juceStringToNS (message);
		NSString* titleString = juceStringToNS (title);

		switch (iconType)
		{
			case AlertWindow::InfoIcon:     return NSRunInformationalAlertPanel (titleString, messageString, button1, button2, button3);
			case AlertWindow::WarningIcon:  return NSRunCriticalAlertPanel      (titleString, messageString, button1, button2, button3);
			default:                        return NSRunAlertPanel              (titleString, messageString, button1, button2, button3);
		}
	}
};

void JUCE_CALLTYPE NativeMessageBox::showMessageBox (AlertWindow::AlertIconType iconType,
													 const String& title, const String& message,
													 Component* associatedComponent)
{
	OSXMessageBox box (iconType, title, message, nsStringLiteral ("OK"), nil, nil, 0, false);
	(void) box.getResult();
}

void JUCE_CALLTYPE NativeMessageBox::showMessageBoxAsync (AlertWindow::AlertIconType iconType,
														  const String& title, const String& message,
														  Component* associatedComponent)
{
	new OSXMessageBox (iconType, title, message, nsStringLiteral ("OK"), nil, nil, 0, true);
}

bool JUCE_CALLTYPE NativeMessageBox::showOkCancelBox (AlertWindow::AlertIconType iconType,
													  const String& title, const String& message,
													  Component* associatedComponent,
													  ModalComponentManager::Callback* callback)
{
	ScopedPointer<OSXMessageBox> mb (new OSXMessageBox (iconType, title, message,
														nsStringLiteral ("OK"),
														nsStringLiteral ("Cancel"),
														nil, callback, callback != nullptr));
	if (callback == nullptr)
		return mb->getResult() == 1;

	mb.release();
	return false;
}

int JUCE_CALLTYPE NativeMessageBox::showYesNoCancelBox (AlertWindow::AlertIconType iconType,
														const String& title, const String& message,
														Component* associatedComponent,
														ModalComponentManager::Callback* callback)
{
	ScopedPointer<OSXMessageBox> mb (new OSXMessageBox (iconType, title, message,
														nsStringLiteral ("Yes"),
														nsStringLiteral ("Cancel"),
														nsStringLiteral ("No"),
														callback, callback != nullptr));
	if (callback == nullptr)
		return mb->getResult();

	mb.release();
	return 0;
}

bool DragAndDropContainer::performExternalDragDropOfFiles (const StringArray& files, const bool /*canMoveFiles*/)
{
	if (files.size() == 0)
		return false;

	MouseInputSource* draggingSource = Desktop::getInstance().getDraggingMouseSource(0);

	if (draggingSource == nullptr)
	{
		jassertfalse;  // This method must be called in response to a component's mouseDown or mouseDrag event!
		return false;
	}

	Component* sourceComp = draggingSource->getComponentUnderMouse();

	if (sourceComp == nullptr)
	{
		jassertfalse;  // This method must be called in response to a component's mouseDown or mouseDrag event!
		return false;
	}

	JUCE_AUTORELEASEPOOL

	NSView* view = (NSView*) sourceComp->getWindowHandle();

	if (view == nil)
		return false;

	NSPasteboard* pboard = [NSPasteboard pasteboardWithName: NSDragPboard];
	[pboard declareTypes: [NSArray arrayWithObject: NSFilenamesPboardType]
				   owner: nil];

	NSMutableArray* filesArray = [NSMutableArray arrayWithCapacity: 4];
	for (int i = 0; i < files.size(); ++i)
		[filesArray addObject: juceStringToNS (files[i])];

	[pboard setPropertyList: filesArray
					forType: NSFilenamesPboardType];

	NSPoint dragPosition = [view convertPoint: [[[view window] currentEvent] locationInWindow]
									 fromView: nil];
	dragPosition.x -= 16;
	dragPosition.y -= 16;

	[view dragImage: [[NSWorkspace sharedWorkspace] iconForFile: juceStringToNS (files[0])]
				 at: dragPosition
			 offset: NSMakeSize (0, 0)
			  event: [[view window] currentEvent]
		 pasteboard: pboard
			 source: view
		  slideBack: YES];

	return true;
}

bool DragAndDropContainer::performExternalDragDropOfText (const String& /*text*/)
{
	jassertfalse;    // not implemented!
	return false;
}

bool Desktop::canUseSemiTransparentWindows() noexcept
{
	return true;
}

Point<int> MouseInputSource::getCurrentMousePosition()
{
	JUCE_AUTORELEASEPOOL
	const NSPoint p ([NSEvent mouseLocation]);
	return Point<int> (roundToInt (p.x), roundToInt ([[[NSScreen screens] objectAtIndex: 0] frame].size.height - p.y));
}

void Desktop::setMousePosition (const Point<int>& newPosition)
{
	// this rubbish needs to be done around the warp call, to avoid causing a
	// bizarre glitch..
	CGAssociateMouseAndMouseCursorPosition (false);
	CGWarpMouseCursorPosition (CGPointMake (newPosition.getX(), newPosition.getY()));
	CGAssociateMouseAndMouseCursorPosition (true);
}

Desktop::DisplayOrientation Desktop::getCurrentOrientation() const
{
	return upright;
}

#ifndef __POWER__  // Some versions of the SDK omit this function..
 extern "C"  { extern OSErr UpdateSystemActivity (UInt8); }
#endif

class ScreenSaverDefeater   : public Timer
{
public:
	ScreenSaverDefeater()
	{
		startTimer (10000);
		timerCallback();
	}

	void timerCallback()
	{
		if (Process::isForegroundProcess())
			UpdateSystemActivity (1 /*UsrActivity*/);
	}
};

static ScopedPointer<ScreenSaverDefeater> screenSaverDefeater;

void Desktop::setScreenSaverEnabled (const bool isEnabled)
{
	if (isEnabled)
		screenSaverDefeater = nullptr;
	else if (screenSaverDefeater == nullptr)
		screenSaverDefeater = new ScreenSaverDefeater();
}

bool Desktop::isScreenSaverEnabled()
{
	return screenSaverDefeater == nullptr;
}

class DisplaySettingsChangeCallback  : public DeletedAtShutdown
{
public:
	DisplaySettingsChangeCallback()
	{
		CGDisplayRegisterReconfigurationCallback (displayReconfigurationCallBack, 0);
	}

	~DisplaySettingsChangeCallback()
	{
		CGDisplayRemoveReconfigurationCallback (displayReconfigurationCallBack, 0);
		clearSingletonInstance();
	}

	static void displayReconfigurationCallBack (CGDirectDisplayID, CGDisplayChangeSummaryFlags, void*)
	{
		Desktop::getInstance().refreshMonitorSizes();
	}

	juce_DeclareSingleton_SingleThreaded_Minimal (DisplaySettingsChangeCallback);

private:
	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (DisplaySettingsChangeCallback);
};

juce_ImplementSingleton_SingleThreaded (DisplaySettingsChangeCallback);

void Desktop::getCurrentMonitorPositions (Array <Rectangle<int> >& monitorCoords, const bool clipToWorkArea)
{
	JUCE_AUTORELEASEPOOL

	DisplaySettingsChangeCallback::getInstance();

	monitorCoords.clear();
	NSArray* screens = [NSScreen screens];
	const CGFloat mainScreenBottom = [[[NSScreen screens] objectAtIndex: 0] frame].size.height;

	for (unsigned int i = 0; i < [screens count]; ++i)
	{
		NSScreen* s = (NSScreen*) [screens objectAtIndex: i];

		NSRect r = clipToWorkArea ? [s visibleFrame]
								  : [s frame];

		r.origin.y = mainScreenBottom - (r.origin.y + r.size.height);

		monitorCoords.add (convertToRectInt (r));
	}

	jassert (monitorCoords.size() > 0);
}

Image juce_createIconForFile (const File& file)
{
	JUCE_AUTORELEASEPOOL

	NSImage* image = [[NSWorkspace sharedWorkspace] iconForFile: juceStringToNS (file.getFullPathName())];

	Image result (Image::ARGB, (int) [image size].width, (int) [image size].height, true);

	[NSGraphicsContext saveGraphicsState];
	[NSGraphicsContext setCurrentContext: [NSGraphicsContext graphicsContextWithGraphicsPort: juce_getImageContext (result) flipped: false]];

	[image drawAtPoint: NSMakePoint (0, 0)
			  fromRect: NSMakeRect (0, 0, [image size].width, [image size].height)
			 operation: NSCompositeSourceOver fraction: 1.0f];

	[[NSGraphicsContext currentContext] flushGraphics];
	[NSGraphicsContext restoreGraphicsState];

	return result;
}

void SystemClipboard::copyTextToClipboard (const String& text)
{
	NSPasteboard* pb = [NSPasteboard generalPasteboard];

	[pb declareTypes: [NSArray arrayWithObject: NSStringPboardType]
			   owner: nil];

	[pb setString: juceStringToNS (text)
		  forType: NSStringPboardType];
}

String SystemClipboard::getTextFromClipboard()
{
	NSString* text = [[NSPasteboard generalPasteboard] stringForType: NSStringPboardType];

	return text == nil ? String::empty
					   : nsStringToJuce (text);
}

/*** End of inlined file: juce_mac_Windowing.mm ***/


/*** Start of inlined file: juce_mac_MainMenu.mm ***/
class JuceMainMenuHandler;

} // (juce namespace)

using namespace juce;

#define JuceMenuCallback MakeObjCClassName(JuceMenuCallback)

#if defined (MAC_OS_X_VERSION_10_6) && MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_6
@interface JuceMenuCallback  : NSObject <NSMenuDelegate>
#else
@interface JuceMenuCallback  : NSObject
#endif
{
	JuceMainMenuHandler* owner;
}

- (JuceMenuCallback*) initWithOwner: (JuceMainMenuHandler*) owner_;
- (void) dealloc;
- (void) menuItemInvoked: (id) menu;
- (void) menuNeedsUpdate: (NSMenu*) menu;
@end

namespace juce
{

class JuceMainMenuHandler   : private MenuBarModel::Listener,
							  private DeletedAtShutdown
{
public:

	JuceMainMenuHandler()
		: currentModel (nullptr),
		  lastUpdateTime (0)
	{
		callback = [[JuceMenuCallback alloc] initWithOwner: this];
	}

	~JuceMainMenuHandler()
	{
		setMenu (nullptr);

		jassert (instance == this);
		instance = nullptr;

		[callback release];
	}

	void setMenu (MenuBarModel* const newMenuBarModel)
	{
		if (currentModel != newMenuBarModel)
		{
			if (currentModel != nullptr)
				currentModel->removeListener (this);

			currentModel = newMenuBarModel;

			if (currentModel != nullptr)
				currentModel->addListener (this);

			menuBarItemsChanged (nullptr);
		}
	}

	void addSubMenu (NSMenu* parent, const PopupMenu& child,
					 const String& name, const int menuId, const int tag)
	{
		NSMenuItem* item = [parent addItemWithTitle: juceStringToNS (name)
											 action: nil
									  keyEquivalent: nsEmptyString()];
		[item setTag: tag];

		NSMenu* sub = createMenu (child, name, menuId, tag);

		[parent setSubmenu: sub forItem: item];
		[sub setAutoenablesItems: false];
		[sub release];
	}

	void updateSubMenu (NSMenuItem* parentItem, const PopupMenu& menuToCopy,
						const String& name, const int menuId, const int tag)
	{
	   #if MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_5
		static bool is10_4 = (SystemStats::getOSXMinorVersionNumber() <= 4);

		if (is10_4)
		{
			[parentItem setTag: tag];
			NSMenu* menu = [parentItem submenu];

			[menu setTitle: juceStringToNS (name)];

			while ([menu numberOfItems] > 0)
				[menu removeItemAtIndex: 0];

			PopupMenu::MenuItemIterator iter (menuToCopy);

			while (iter.next())
				addMenuItem (iter, menu, menuId, tag);

			[menu setAutoenablesItems: false];
			[menu update];
			return;
		}
	   #endif

		// Note: This method used to update the contents of the existing menu in-place, but that caused
		// weird side-effects which messed-up keyboard focus when switching between windows. By creating
		// a new menu and replacing the old one with it, that problem seems to be avoided..
		NSMenu* menu = [[NSMenu alloc] initWithTitle: juceStringToNS (name)];

		PopupMenu::MenuItemIterator iter (menuToCopy);
		while (iter.next())
			addMenuItem (iter, menu, menuId, tag);

		[menu setAutoenablesItems: false];
		[menu update];
		[parentItem setTag: tag];
		[parentItem setSubmenu: menu];
		[menu release];
	}

	void menuBarItemsChanged (MenuBarModel*)
	{
		lastUpdateTime = Time::getMillisecondCounter();

		StringArray menuNames;
		if (currentModel != nullptr)
			menuNames = currentModel->getMenuBarNames();

		NSMenu* menuBar = [NSApp mainMenu];
		while ([menuBar numberOfItems] > 1 + menuNames.size())
			[menuBar removeItemAtIndex: [menuBar numberOfItems] - 1];

		int menuId = 1;

		for (int i = 0; i < menuNames.size(); ++i)
		{
			const PopupMenu menu (currentModel->getMenuForIndex (i, menuNames [i]));

			if (i >= [menuBar numberOfItems] - 1)
				addSubMenu (menuBar, menu, menuNames[i], menuId, i);
			else
				updateSubMenu ([menuBar itemAtIndex: 1 + i], menu, menuNames[i], menuId, i);
		}
	}

	void menuCommandInvoked (MenuBarModel*, const ApplicationCommandTarget::InvocationInfo& info)
	{
		NSMenuItem* item = findMenuItem ([NSApp mainMenu], info);

		if (item != nil)
			flashMenuBar ([item menu]);
	}

	void updateMenus (NSMenu* menu)
	{
		if (PopupMenu::dismissAllActiveMenus())
		{
			// If we were running a juce menu, then we should let that modal loop finish before allowing
			// the OS menus to start their own modal loop - so cancel the menu that was being opened..
			if ([menu respondsToSelector: @selector (cancelTracking)])
				[menu performSelector: @selector (cancelTracking)];
		}

		if (Time::getMillisecondCounter() > lastUpdateTime + 100)
			(new AsyncMenuUpdater())->post();
	}

	void invoke (const int commandId, ApplicationCommandManager* const commandManager, const int topLevelIndex) const
	{
		if (currentModel != nullptr)
		{
			if (commandManager != nullptr)
			{
				ApplicationCommandTarget::InvocationInfo info (commandId);
				info.invocationMethod = ApplicationCommandTarget::InvocationInfo::fromMenu;

				commandManager->invoke (info, true);
			}

			(new AsyncCommandInvoker (commandId, topLevelIndex))->post();
		}
	}

	void invokeDirectly (const int commandId, const int topLevelIndex)
	{
		if (currentModel != nullptr)
			currentModel->menuItemSelected (commandId, topLevelIndex);
	}

	void addMenuItem (PopupMenu::MenuItemIterator& iter, NSMenu* menuToAddTo,
					  const int topLevelMenuId, const int topLevelIndex)
	{
		NSString* text = juceStringToNS (iter.itemName.upToFirstOccurrenceOf ("<end>", false, true));

		if (text == nil)
			text = nsEmptyString();

		if (iter.isSeparator)
		{
			[menuToAddTo addItem: [NSMenuItem separatorItem]];
		}
		else if (iter.isSectionHeader)
		{
			NSMenuItem* item = [menuToAddTo addItemWithTitle: text
													  action: nil
											   keyEquivalent: nsEmptyString()];

			[item setEnabled: false];
		}
		else if (iter.subMenu != nullptr)
		{
			NSMenuItem* item = [menuToAddTo addItemWithTitle: text
													  action: nil
											   keyEquivalent: nsEmptyString()];

			[item setTag: iter.itemId];
			[item setEnabled: iter.isEnabled];

			NSMenu* sub = createMenu (*iter.subMenu, iter.itemName, topLevelMenuId, topLevelIndex);
			[sub setDelegate: nil];
			[menuToAddTo setSubmenu: sub forItem: item];
			[sub release];
		}
		else
		{
			NSMenuItem* item = [menuToAddTo addItemWithTitle: text
													  action: @selector (menuItemInvoked:)
											   keyEquivalent: nsEmptyString()];

			[item setTag: iter.itemId];
			[item setEnabled: iter.isEnabled];
			[item setState: iter.isTicked ? NSOnState : NSOffState];
			[item setTarget: (id) callback];

			NSMutableArray* info = [NSMutableArray arrayWithObject: [NSNumber numberWithUnsignedLongLong: (pointer_sized_int) (void*) iter.commandManager]];
			[info addObject: [NSNumber numberWithInt: topLevelIndex]];
			[item setRepresentedObject: info];

			if (iter.commandManager != nullptr)
			{
				const Array <KeyPress> keyPresses (iter.commandManager->getKeyMappings()
												   ->getKeyPressesAssignedToCommand (iter.itemId));

				if (keyPresses.size() > 0)
				{
					const KeyPress& kp = keyPresses.getReference(0);

					if (kp.getKeyCode() != KeyPress::backspaceKey   // (adding these is annoying because it flashes the menu bar
						 && kp.getKeyCode() != KeyPress::deleteKey) // every time you press the key while editing text)
					{
						juce_wchar key = kp.getTextCharacter();
						if (key == 0)
							key = (juce_wchar) kp.getKeyCode();

						[item setKeyEquivalent: juceStringToNS (String::charToString (key).toLowerCase())];
						[item setKeyEquivalentModifierMask: juceModsToNSMods (kp.getModifiers())];
					}
				}
			}
		}
	}

	static JuceMainMenuHandler* instance;

	MenuBarModel* currentModel;
	uint32 lastUpdateTime;
	JuceMenuCallback* callback;

private:

	NSMenu* createMenu (const PopupMenu menu,
						const String& menuName,
						const int topLevelMenuId,
						const int topLevelIndex)
	{
		NSMenu* m = [[NSMenu alloc] initWithTitle: juceStringToNS (menuName)];

		[m setAutoenablesItems: false];
		[m setDelegate: callback];

		PopupMenu::MenuItemIterator iter (menu);

		while (iter.next())
			addMenuItem (iter, m, topLevelMenuId, topLevelIndex);

		[m update];
		return m;
	}

	static NSMenuItem* findMenuItem (NSMenu* const menu, const ApplicationCommandTarget::InvocationInfo& info)
	{
		for (NSInteger i = [menu numberOfItems]; --i >= 0;)
		{
			NSMenuItem* m = [menu itemAtIndex: i];
			if ([m tag] == info.commandID)
				return m;

			if ([m submenu] != nil)
			{
				NSMenuItem* found = findMenuItem ([m submenu], info);
				if (found != nil)
					return found;
			}
		}

		return nil;
	}

	static void flashMenuBar (NSMenu* menu)
	{
		if ([[menu title] isEqualToString: nsStringLiteral ("Apple")])
			return;

		[menu retain];

		const unichar f35Key = NSF35FunctionKey;
		NSString* f35String = [NSString stringWithCharacters: &f35Key length: 1];

		NSMenuItem* item = [[NSMenuItem alloc] initWithTitle: nsStringLiteral ("x")
													  action: nil
											   keyEquivalent: f35String];
		[item setTarget: nil];
		[menu insertItem: item atIndex: [menu numberOfItems]];
		[item release];

		if ([menu indexOfItem: item] >= 0)
		{
			NSEvent* f35Event = [NSEvent keyEventWithType: NSKeyDown
												 location: NSZeroPoint
											modifierFlags: NSCommandKeyMask
												timestamp: 0
											 windowNumber: 0
												  context: [NSGraphicsContext currentContext]
											   characters: f35String
							  charactersIgnoringModifiers: f35String
												isARepeat: NO
												  keyCode: 0];

			[menu performKeyEquivalent: f35Event];

			if ([menu indexOfItem: item] >= 0)
				[menu removeItem: item]; // (this throws if the item isn't actually in the menu)
		}

		[menu release];
	}

	static unsigned int juceModsToNSMods (const ModifierKeys& mods)
	{
		unsigned int m = 0;
		if (mods.isShiftDown())    m |= NSShiftKeyMask;
		if (mods.isCtrlDown())     m |= NSControlKeyMask;
		if (mods.isAltDown())      m |= NSAlternateKeyMask;
		if (mods.isCommandDown())  m |= NSCommandKeyMask;
		return m;
	}

	class AsyncMenuUpdater  : public CallbackMessage
	{
	public:
		AsyncMenuUpdater() {}

		void messageCallback()
		{
			if (JuceMainMenuHandler::instance != nullptr)
				JuceMainMenuHandler::instance->menuBarItemsChanged (nullptr);
		}

	private:
		JUCE_DECLARE_NON_COPYABLE (AsyncMenuUpdater);
	};

	class AsyncCommandInvoker  : public CallbackMessage
	{
	public:
		AsyncCommandInvoker (const int commandId_, const int topLevelIndex_)
			: commandId (commandId_), topLevelIndex (topLevelIndex_)
		{}

		void messageCallback()
		{
			if (JuceMainMenuHandler::instance != nullptr)
				JuceMainMenuHandler::instance->invokeDirectly (commandId, topLevelIndex);
		}

	private:
		const int commandId, topLevelIndex;

		JUCE_DECLARE_NON_COPYABLE (AsyncCommandInvoker);
	};
};

JuceMainMenuHandler* JuceMainMenuHandler::instance = nullptr;

} // (juce namespace)

@implementation JuceMenuCallback

- (JuceMenuCallback*) initWithOwner: (JuceMainMenuHandler*) owner_
{
	[super init];
	owner = owner_;
	return self;
}

- (void) dealloc
{
	[super dealloc];
}

- (void) menuItemInvoked: (id) menu
{
	NSMenuItem* item = (NSMenuItem*) menu;

	if ([[item representedObject] isKindOfClass: [NSArray class]])
	{
		// If the menu is being triggered by a keypress, the OS will have picked it up before we had a chance to offer it to
		// our own components, which may have wanted to intercept it. So, rather than dispatching directly, we'll feed it back
		// into the focused component and let it trigger the menu item indirectly.
		NSEvent* e = [NSApp currentEvent];
		if ([e type] == NSKeyDown || [e type] == NSKeyUp)
		{
			if (juce::Component::getCurrentlyFocusedComponent() != nullptr)
			{
				juce::NSViewComponentPeer* peer = dynamic_cast <juce::NSViewComponentPeer*> (juce::Component::getCurrentlyFocusedComponent()->getPeer());

				if (peer != nullptr)
				{
					if ([e type] == NSKeyDown)
						peer->redirectKeyDown (e);
					else
						peer->redirectKeyUp (e);

					return;
				}
			}
		}

		NSArray* info = (NSArray*) [item representedObject];

		owner->invoke ((int) [item tag],
					   (ApplicationCommandManager*) (pointer_sized_int)
							[((NSNumber*) [info objectAtIndex: 0]) unsignedLongLongValue],
					   (int) [((NSNumber*) [info objectAtIndex: 1]) intValue]);
	}
}

- (void) menuNeedsUpdate: (NSMenu*) menu;
{
	if (JuceMainMenuHandler::instance != nullptr)
		JuceMainMenuHandler::instance->updateMenus (menu);
}

@end

namespace juce
{

namespace MainMenuHelpers
{
	NSMenu* createStandardAppMenu (NSMenu* menu, const String& appName, const PopupMenu* extraItems)
	{
		if (extraItems != nullptr && JuceMainMenuHandler::instance != nullptr && extraItems->getNumItems() > 0)
		{
			PopupMenu::MenuItemIterator iter (*extraItems);

			while (iter.next())
				JuceMainMenuHandler::instance->addMenuItem (iter, menu, 0, -1);

			[menu addItem: [NSMenuItem separatorItem]];
		}

		NSMenuItem* item;

		// Services...
		item = [[NSMenuItem alloc] initWithTitle: NSLocalizedString (nsStringLiteral ("Services"), nil)
										  action: nil  keyEquivalent: nsEmptyString()];
		[menu addItem: item];
		[item release];
		NSMenu* servicesMenu = [[NSMenu alloc] initWithTitle: nsStringLiteral ("Services")];
		[menu setSubmenu: servicesMenu forItem: item];
		[NSApp setServicesMenu: servicesMenu];
		[servicesMenu release];
		[menu addItem: [NSMenuItem separatorItem]];

		// Hide + Show stuff...
		item = [[NSMenuItem alloc] initWithTitle: juceStringToNS ("Hide " + appName)
										  action: @selector (hide:)  keyEquivalent: nsStringLiteral ("h")];
		[item setTarget: NSApp];
		[menu addItem: item];
		[item release];

		item = [[NSMenuItem alloc] initWithTitle: NSLocalizedString (nsStringLiteral ("Hide Others"), nil)
										  action: @selector (hideOtherApplications:)  keyEquivalent: nsStringLiteral ("h")];
		[item setKeyEquivalentModifierMask: NSCommandKeyMask | NSAlternateKeyMask];
		[item setTarget: NSApp];
		[menu addItem: item];
		[item release];

		item = [[NSMenuItem alloc] initWithTitle: NSLocalizedString (nsStringLiteral ("Show All"), nil)
										  action: @selector (unhideAllApplications:)  keyEquivalent: nsEmptyString()];
		[item setTarget: NSApp];
		[menu addItem: item];
		[item release];

		[menu addItem: [NSMenuItem separatorItem]];

		// Quit item....
		item = [[NSMenuItem alloc] initWithTitle: juceStringToNS ("Quit " + appName)
										  action: @selector (terminate:)  keyEquivalent: nsStringLiteral ("q")];

		[item setTarget: NSApp];
		[menu addItem: item];
		[item release];

		return menu;
	}

	// Since our app has no NIB, this initialises a standard app menu...
	void rebuildMainMenu (const PopupMenu* extraItems)
	{
		// this can't be used in a plugin!
		jassert (JUCEApplication::isStandaloneApp());

		if (JUCEApplication::getInstance() != nullptr)
		{
			JUCE_AUTORELEASEPOOL

			NSMenu* mainMenu = [[NSMenu alloc] initWithTitle: nsStringLiteral ("MainMenu")];
			NSMenuItem* item = [mainMenu addItemWithTitle: nsStringLiteral ("Apple") action: nil keyEquivalent: nsEmptyString()];

			NSMenu* appMenu = [[NSMenu alloc] initWithTitle: nsStringLiteral ("Apple")];

			[NSApp performSelector: @selector (setAppleMenu:) withObject: appMenu];
			[mainMenu setSubmenu: appMenu forItem: item];

			[NSApp setMainMenu: mainMenu];
			MainMenuHelpers::createStandardAppMenu (appMenu, JUCEApplication::getInstance()->getApplicationName(), extraItems);

			[appMenu release];
			[mainMenu release];
		}
	}
}

void MenuBarModel::setMacMainMenu (MenuBarModel* newMenuBarModel,
								   const PopupMenu* extraAppleMenuItems)
{
	if (getMacMainMenu() != newMenuBarModel)
	{
		JUCE_AUTORELEASEPOOL

		if (newMenuBarModel == nullptr)
		{
			delete JuceMainMenuHandler::instance;
			jassert (JuceMainMenuHandler::instance == nullptr); // should be zeroed in the destructor
			jassert (extraAppleMenuItems == nullptr); // you can't specify some extra items without also supplying a model

			extraAppleMenuItems = nullptr;
		}
		else
		{
			if (JuceMainMenuHandler::instance == nullptr)
				JuceMainMenuHandler::instance = new JuceMainMenuHandler();

			JuceMainMenuHandler::instance->setMenu (newMenuBarModel);
		}
	}

	MainMenuHelpers::rebuildMainMenu (extraAppleMenuItems);

	if (newMenuBarModel != nullptr)
		newMenuBarModel->menuItemsChanged();
}

MenuBarModel* MenuBarModel::getMacMainMenu()
{
	return JuceMainMenuHandler::instance != nullptr
			 ? JuceMainMenuHandler::instance->currentModel : nullptr;
}

void juce_initialiseMacMainMenu()
{
	if (JuceMainMenuHandler::instance == nullptr)
		MainMenuHelpers::rebuildMainMenu (nullptr);
}

/*** End of inlined file: juce_mac_MainMenu.mm ***/

 #endif


/*** Start of inlined file: juce_mac_MouseCursor.mm ***/
#if JUCE_MAC

namespace MouseCursorHelpers
{
	static NSImage* createNSImage (const Image& image)
	{
		JUCE_AUTORELEASEPOOL

		NSImage* im = [[NSImage alloc] init];
		[im setSize: NSMakeSize (image.getWidth(), image.getHeight())];
		[im lockFocus];

		CGColorSpaceRef colourSpace = CGColorSpaceCreateDeviceRGB();
		CGImageRef imageRef = juce_createCoreGraphicsImage (image, false, colourSpace, false);
		CGColorSpaceRelease (colourSpace);

		CGContextRef cg = (CGContextRef) [[NSGraphicsContext currentContext] graphicsPort];
		CGContextDrawImage (cg, CGRectMake (0, 0, image.getWidth(), image.getHeight()), imageRef);

		CGImageRelease (imageRef);
		[im unlockFocus];

		return im;
	}

	static void* createFromImage (const Image& image, float hotspotX, float hotspotY)
	{
		NSImage* im = createNSImage (image);
		NSCursor* c = [[NSCursor alloc] initWithImage: im
											  hotSpot: NSMakePoint (hotspotX, hotspotY)];
		[im release];
		return c;
	}

	static void* fromWebKitFile (const char* filename, float hx, float hy)
	{
		FileInputStream fileStream (String ("/System/Library/Frameworks/WebKit.framework/Frameworks/WebCore.framework/Resources/") + filename);
		BufferedInputStream buf (fileStream, 4096);

		PNGImageFormat pngFormat;
		Image im (pngFormat.decodeImage (buf));

		if (im.isValid())
			return createFromImage (im, hx * im.getWidth(), hy * im.getHeight());

		jassertfalse;
		return nullptr;
	}
}

void* MouseCursor::createMouseCursorFromImage (const Image& image, int hotspotX, int hotspotY)
{
	return MouseCursorHelpers::createFromImage (image, (float) hotspotX, (float) hotspotY);
}

void* MouseCursor::createStandardMouseCursor (MouseCursor::StandardCursorType type)
{
	JUCE_AUTORELEASEPOOL
	NSCursor* c = nil;

	switch (type)
	{
		case NormalCursor:          c = [NSCursor arrowCursor]; break;
		case NoCursor:              return createMouseCursorFromImage (Image (Image::ARGB, 8, 8, true), 0, 0);
		case DraggingHandCursor:    c = [NSCursor openHandCursor]; break;
		case WaitCursor:            c = [NSCursor arrowCursor]; break; // avoid this on the mac, let the OS provide the beachball
		case IBeamCursor:           c = [NSCursor IBeamCursor]; break;
		case PointingHandCursor:    c = [NSCursor pointingHandCursor]; break;
		case LeftRightResizeCursor: c = [NSCursor resizeLeftRightCursor]; break;
		case LeftEdgeResizeCursor:  c = [NSCursor resizeLeftCursor]; break;
		case RightEdgeResizeCursor: c = [NSCursor resizeRightCursor]; break;
		case CrosshairCursor:       c = [NSCursor crosshairCursor]; break;
		case CopyingCursor:         return MouseCursorHelpers::fromWebKitFile ("copyCursor.png", 0, 0);

		case UpDownResizeCursor:
		case TopEdgeResizeCursor:
		case BottomEdgeResizeCursor:
			return MouseCursorHelpers::fromWebKitFile ("northSouthResizeCursor.png", 0.5f, 0.5f);

		case TopLeftCornerResizeCursor:
		case BottomRightCornerResizeCursor:
			return MouseCursorHelpers::fromWebKitFile ("northWestSouthEastResizeCursor.png", 0.5f, 0.5f);

		case TopRightCornerResizeCursor:
		case BottomLeftCornerResizeCursor:
			return MouseCursorHelpers::fromWebKitFile ("northEastSouthWestResizeCursor.png", 0.5f, 0.5f);

		case UpDownLeftRightResizeCursor:
			return MouseCursorHelpers::fromWebKitFile ("moveCursor.png", 0.5f, 0.5f);

		default:
			jassertfalse;
			break;
	}

	[c retain];
	return c;
}

void MouseCursor::deleteMouseCursor (void* const cursorHandle, const bool /*isStandard*/)
{
	[((NSCursor*) cursorHandle) release];
}

void MouseCursor::showInAllWindows() const
{
	showInWindow (nullptr);
}

void MouseCursor::showInWindow (ComponentPeer*) const
{
	NSCursor* c = (NSCursor*) getHandle();

	if (c == nil)
		c = [NSCursor arrowCursor];

	[c set];
}

#else

void* MouseCursor::createMouseCursorFromImage (const Image& image, int hotspotX, int hotspotY)  { return nullptr; }
void* MouseCursor::createStandardMouseCursor (MouseCursor::StandardCursorType type)             { return nullptr; }
void MouseCursor::deleteMouseCursor (void* const cursorHandle, const bool isStandard)           {}
void MouseCursor::showInAllWindows() const                                                      {}
void MouseCursor::showInWindow (ComponentPeer*) const                                           {}

#endif

/*** End of inlined file: juce_mac_MouseCursor.mm ***/


/*** Start of inlined file: juce_mac_FileChooser.mm ***/
#if JUCE_MAC

} // (juce namespace)

using namespace juce;

#define JuceFileChooserDelegate MakeObjCClassName(JuceFileChooserDelegate)

#if defined (MAC_OS_X_VERSION_10_6) && MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_6
@interface JuceFileChooserDelegate   : NSObject <NSOpenSavePanelDelegate>
#else
@interface JuceFileChooserDelegate   : NSObject
#endif
{
	StringArray* filters;
}

- (JuceFileChooserDelegate*) initWithFilters: (StringArray*) filters_;
- (void) dealloc;
- (BOOL) panel: (id) sender shouldShowFilename: (NSString*) filename;

@end

@implementation JuceFileChooserDelegate
- (JuceFileChooserDelegate*) initWithFilters: (StringArray*) filters_
{
	[super init];
	filters = filters_;
	return self;
}

- (void) dealloc
{
	delete filters;
	[super dealloc];
}

- (BOOL) panel: (id) sender shouldShowFilename: (NSString*) filename
{
	(void) sender;
	const File f (nsStringToJuce (filename));

	for (int i = filters->size(); --i >= 0;)
		if (f.getFileName().matchesWildcard ((*filters)[i], true))
			return true;

   #if (! defined (MAC_OS_X_VERSION_10_7)) || MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_7
	NSError* error;
	NSString* name = [[NSWorkspace sharedWorkspace] typeOfFile: filename error: &error];

	if ([name isEqualToString: nsStringLiteral ("com.apple.alias-file")])
	{
		FSRef ref;
		FSPathMakeRef ((const UInt8*) [filename fileSystemRepresentation], &ref, nullptr);

		Boolean targetIsFolder = false, wasAliased = false;
		FSResolveAliasFileWithMountFlags (&ref, true, &targetIsFolder, &wasAliased, 0);

		return wasAliased && targetIsFolder;
	}
   #endif

	return f.isDirectory()
			&& ! [[NSWorkspace sharedWorkspace] isFilePackageAtPath: filename];
}
@end

namespace juce
{

bool FileChooser::isPlatformDialogAvailable()
{
	return true;
}

class TemporaryMainMenuWithStandardCommands
{
public:
	TemporaryMainMenuWithStandardCommands()
		: oldMenu (MenuBarModel::getMacMainMenu())
	{
		MenuBarModel::setMacMainMenu (nullptr);

		NSMenu* menu = [[NSMenu alloc] initWithTitle: nsStringLiteral ("Edit")];
		NSMenuItem* item;

		item = [[NSMenuItem alloc] initWithTitle: NSLocalizedString (nsStringLiteral ("Cut"), nil)
										  action: @selector (cut:)  keyEquivalent: nsStringLiteral ("x")];
		[menu addItem: item];
		[item release];

		item = [[NSMenuItem alloc] initWithTitle: NSLocalizedString (nsStringLiteral ("Copy"), nil)
										  action: @selector (copy:)  keyEquivalent: nsStringLiteral ("c")];
		[menu addItem: item];
		[item release];

		item = [[NSMenuItem alloc] initWithTitle: NSLocalizedString (nsStringLiteral ("Paste"), nil)
										  action: @selector (paste:)  keyEquivalent: nsStringLiteral ("v")];
		[menu addItem: item];
		[item release];

		item = [[NSApp mainMenu] addItemWithTitle: NSLocalizedString (nsStringLiteral ("Edit"), nil)
										   action: nil keyEquivalent: nsEmptyString()];
		[[NSApp mainMenu] setSubmenu: menu forItem: item];
		[menu release];
	}

	~TemporaryMainMenuWithStandardCommands()
	{
		MenuBarModel::setMacMainMenu (oldMenu);
	}

private:
	MenuBarModel* oldMenu;
};

void FileChooser::showPlatformDialog (Array<File>& results,
									  const String& title,
									  const File& currentFileOrDirectory,
									  const String& filter,
									  bool selectsDirectory,
									  bool selectsFiles,
									  bool isSaveDialogue,
									  bool /*warnAboutOverwritingExistingFiles*/,
									  bool selectMultipleFiles,
									  FilePreviewComponent* /*extraInfoComponent*/)
{
	JUCE_AUTORELEASEPOOL

	const TemporaryMainMenuWithStandardCommands tempMenu;

	StringArray* filters = new StringArray();
	filters->addTokens (filter.replaceCharacters (",:", ";;"), ";", String::empty);
	filters->trim();
	filters->removeEmptyStrings();

	JuceFileChooserDelegate* delegate = [[JuceFileChooserDelegate alloc] initWithFilters: filters];
	[delegate autorelease];

	NSSavePanel* panel = isSaveDialogue ? [NSSavePanel savePanel]
										: [NSOpenPanel openPanel];

	[panel setTitle: juceStringToNS (title)];

	if (! isSaveDialogue)
	{
		NSOpenPanel* openPanel = (NSOpenPanel*) panel;
		[openPanel setCanChooseDirectories: selectsDirectory];
		[openPanel setCanChooseFiles: selectsFiles];
		[openPanel setAllowsMultipleSelection: selectMultipleFiles];
		[openPanel setResolvesAliases: YES];
	}

	[panel setDelegate: delegate];

	if (isSaveDialogue || selectsDirectory)
		[panel setCanCreateDirectories: YES];

	String directory, filename;

	if (currentFileOrDirectory.isDirectory())
	{
		directory = currentFileOrDirectory.getFullPathName();
	}
	else
	{
		directory = currentFileOrDirectory.getParentDirectory().getFullPathName();
		filename = currentFileOrDirectory.getFileName();
	}

   #if defined (MAC_OS_X_VERSION_10_6) && (MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_6)
	[panel setDirectoryURL: [NSURL fileURLWithPath: juceStringToNS (directory)]];
	[panel setNameFieldStringValue: juceStringToNS (filename)];

	if ([panel runModal] == NSOKButton)
   #else
	if ([panel runModalForDirectory: juceStringToNS (directory)
							   file: juceStringToNS (filename)] == NSOKButton)
   #endif
	{
		if (isSaveDialogue)
		{
			results.add (File (nsStringToJuce ([[panel URL] path])));
		}
		else
		{
			NSOpenPanel* openPanel = (NSOpenPanel*) panel;
			NSArray* urls = [openPanel URLs];

			for (unsigned int i = 0; i < [urls count]; ++i)
				results.add (File (nsStringToJuce ([[urls objectAtIndex: i] path])));
		}
	}

	[panel setDelegate: nil];
}

#else

bool FileChooser::isPlatformDialogAvailable()
{
	return false;
}

void FileChooser::showPlatformDialog (Array<File>& results,
									  const String& title,
									  const File& currentFileOrDirectory,
									  const String& filter,
									  bool selectsDirectory,
									  bool selectsFiles,
									  bool isSaveDialogue,
									  bool warnAboutOverwritingExistingFiles,
									  bool selectMultipleFiles,
									  FilePreviewComponent* extraInfoComponent)
{
	JUCE_AUTORELEASEPOOL

	jassertfalse; //there's no such thing in iOS
}

#endif

/*** End of inlined file: juce_mac_FileChooser.mm ***/

#elif JUCE_WINDOWS

/*** Start of inlined file: juce_win32_ComSmartPtr.h ***/
#ifndef __JUCE_WIN32_COMSMARTPTR_JUCEHEADER__
#define __JUCE_WIN32_COMSMARTPTR_JUCEHEADER__

/** A simple COM smart pointer.
*/
template <class ComClass>
class ComSmartPtr
{
public:
	ComSmartPtr() throw() : p (0)                               {}
	ComSmartPtr (ComClass* const p_) : p (p_)                   { if (p_ != 0) p_->AddRef(); }
	ComSmartPtr (const ComSmartPtr<ComClass>& p_) : p (p_.p)    { if (p  != 0) p ->AddRef(); }
	~ComSmartPtr()                                              { release(); }

	operator ComClass*() const throw()     { return p; }
	ComClass& operator*() const throw()    { return *p; }
	ComClass* operator->() const throw()   { return p; }

	ComSmartPtr& operator= (ComClass* const newP)
	{
		if (newP != 0)  newP->AddRef();
		release();
		p = newP;
		return *this;
	}

	ComSmartPtr& operator= (const ComSmartPtr<ComClass>& newP)  { return operator= (newP.p); }

	// Releases and nullifies this pointer and returns its address
	ComClass** resetAndGetPointerAddress()
	{
		release();
		p = 0;
		return &p;
	}

	HRESULT CoCreateInstance (REFCLSID classUUID, DWORD dwClsContext = CLSCTX_INPROC_SERVER)
	{
	   #if ! JUCE_MINGW
		return ::CoCreateInstance (classUUID, 0, dwClsContext, __uuidof (ComClass), (void**) resetAndGetPointerAddress());
	   #else
		jassertfalse; // need to find a mingw equivalent of __uuidof to make this possible
		return E_NOTIMPL;
	   #endif
	}

	template <class OtherComClass>
	HRESULT QueryInterface (REFCLSID classUUID, ComSmartPtr<OtherComClass>& destObject) const
	{
		if (p == 0)
			return E_POINTER;

		return p->QueryInterface (classUUID, (void**) destObject.resetAndGetPointerAddress());
	}

	template <class OtherComClass>
	HRESULT QueryInterface (ComSmartPtr<OtherComClass>& destObject) const
	{
	   #if ! JUCE_MINGW
		return this->QueryInterface (__uuidof (OtherComClass), destObject);
	   #else
		jassertfalse; // need to find a mingw equivalent of __uuidof to make this possible
		return E_NOTIMPL;
	   #endif
	}

private:
	ComClass* p;

	void release()  { if (p != 0) p->Release(); }

	ComClass** operator&() throw(); // private to avoid it being used accidentally
};

#define JUCE_COMRESULT  HRESULT __stdcall

/** Handy base class for writing COM objects, providing ref-counting and a basic QueryInterface method.
*/
template <class ComClass>
class ComBaseClassHelper   : public ComClass
{
public:
	ComBaseClassHelper()  : refCount (1) {}
	virtual ~ComBaseClassHelper() {}

	JUCE_COMRESULT QueryInterface (REFIID refId, void** result)
	{
	   #if ! JUCE_MINGW
		if (refId == __uuidof (ComClass))   { AddRef(); *result = dynamic_cast <ComClass*> (this); return S_OK; }
	   #else
		jassertfalse; // need to find a mingw equivalent of __uuidof to make this possible
	   #endif

		if (refId == IID_IUnknown)          { AddRef(); *result = dynamic_cast <IUnknown*> (this); return S_OK; }

		*result = 0;
		return E_NOINTERFACE;
	}

	ULONG __stdcall AddRef()    { return ++refCount; }
	ULONG __stdcall Release()   { const ULONG r = --refCount; if (r == 0) delete this; return r; }

	void resetReferenceCount() noexcept     { refCount = 0; }

protected:
	ULONG refCount;
};

#endif   // __JUCE_WIN32_COMSMARTPTR_JUCEHEADER__

/*** End of inlined file: juce_win32_ComSmartPtr.h ***/



/*** Start of inlined file: juce_win32_HiddenMessageWindow.h ***/
#ifndef __JUCE_WIN32_HIDDENMESSAGEWINDOW_JUCEHEADER__
#define __JUCE_WIN32_HIDDENMESSAGEWINDOW_JUCEHEADER__

class HiddenMessageWindow
{
public:
	HiddenMessageWindow (const TCHAR* const messageWindowName, WNDPROC wndProc)
	{
		String className ("JUCE_");
		className << String::toHexString (Time::getHighResolutionTicks());

		HMODULE moduleHandle = (HMODULE) Process::getCurrentModuleInstanceHandle();

		WNDCLASSEX wc = { 0 };
		wc.cbSize         = sizeof (wc);
		wc.lpfnWndProc    = wndProc;
		wc.cbWndExtra     = 4;
		wc.hInstance      = moduleHandle;
		wc.lpszClassName  = className.toWideCharPointer();

		atom = RegisterClassEx (&wc);
		jassert (atom != 0);

		hwnd = CreateWindow (getClassNameFromAtom(), messageWindowName,
							 0, 0, 0, 0, 0, 0, 0, moduleHandle, 0);
		jassert (hwnd != 0);
	}

	~HiddenMessageWindow()
	{
		DestroyWindow (hwnd);
		UnregisterClass (getClassNameFromAtom(), 0);
	}

	inline HWND getHWND() const noexcept     { return hwnd; }

private:
	ATOM atom;
	HWND hwnd;

	LPCTSTR getClassNameFromAtom() noexcept  { return (LPCTSTR) MAKELONG (atom, 0); }
};

class JuceWindowIdentifier
{
public:
	static bool isJUCEWindow (HWND hwnd) noexcept
	{
		return GetWindowLongPtr (hwnd, GWLP_USERDATA) == getImprobableWindowNumber();
	}

	static void setAsJUCEWindow (HWND hwnd, bool isJuceWindow) noexcept
	{
		SetWindowLongPtr (hwnd, GWLP_USERDATA, isJuceWindow ? getImprobableWindowNumber() : 0);
	}

private:
	static LONG_PTR getImprobableWindowNumber() noexcept
	{
		static LONG_PTR number = (LONG_PTR) Random::getSystemRandom().nextInt64();
		return number;
	}
};

class DeviceChangeDetector  : private Timer
{
public:
	DeviceChangeDetector (const wchar_t* const name)
		: messageWindow (name, (WNDPROC) deviceChangeEventCallback)
	{
		SetWindowLongPtr (messageWindow.getHWND(), GWLP_USERDATA, (LONG_PTR) this);
	}

	virtual ~DeviceChangeDetector() {}

protected:
	virtual void systemDeviceChanged() = 0;

private:
	HiddenMessageWindow messageWindow;

	static LRESULT CALLBACK deviceChangeEventCallback (HWND h, const UINT message,
													   const WPARAM wParam, const LPARAM lParam)
	{
		if (message == WM_DEVICECHANGE
			 && (wParam == 0x8000 /*DBT_DEVICEARRIVAL*/
				  || wParam == 0x8004 /*DBT_DEVICEREMOVECOMPLETE*/
				  || wParam == 0x0007 /*DBT_DEVNODES_CHANGED*/))
		{
			// We'll pause before sending a message, because on device removal, the OS hasn't always updated
			// its device lists correctly at this point. This also helps avoid repeated callbacks.
			((DeviceChangeDetector*) GetWindowLongPtr (h, GWLP_USERDATA))->startTimer (500);
		}

		return DefWindowProc (h, message, wParam, lParam);
	}

	void timerCallback()
	{
		systemDeviceChanged();
	}
};

#endif   // __JUCE_WIN32_HIDDENMESSAGEWINDOW_JUCEHEADER__

/*** End of inlined file: juce_win32_HiddenMessageWindow.h ***/


/*** Start of inlined file: juce_win32_Windowing.cpp ***/
#undef GetSystemMetrics // multimon overrides this for some reason and causes a mess..

// these are in the windows SDK, but need to be repeated here for GCC..
#ifndef GET_APPCOMMAND_LPARAM
 #define FAPPCOMMAND_MASK                  0xF000
 #define GET_APPCOMMAND_LPARAM(lParam)     ((short) (HIWORD (lParam) & ~FAPPCOMMAND_MASK))
 #define APPCOMMAND_MEDIA_NEXTTRACK        11
 #define APPCOMMAND_MEDIA_PREVIOUSTRACK    12
 #define APPCOMMAND_MEDIA_STOP             13
 #define APPCOMMAND_MEDIA_PLAY_PAUSE       14
#endif

extern void juce_repeatLastProcessPriority();
extern void juce_CheckCurrentlyFocusedTopLevelWindow();  // in juce_TopLevelWindow.cpp
extern bool juce_IsRunningInWine();

typedef bool (*CheckEventBlockedByModalComps) (const MSG&);
extern CheckEventBlockedByModalComps isEventBlockedByModalComps;

static bool shouldDeactivateTitleBar = true;

typedef BOOL (WINAPI* UpdateLayeredWinFunc) (HWND, HDC, POINT*, SIZE*, HDC, POINT*, COLORREF, BLENDFUNCTION*, DWORD);
static UpdateLayeredWinFunc updateLayeredWindow = nullptr;

bool Desktop::canUseSemiTransparentWindows() noexcept
{
	if (updateLayeredWindow == 0)
	{
		if (! juce_IsRunningInWine())
		{
			HMODULE user32Mod = GetModuleHandle (_T("user32.dll"));
			jassert (user32Mod != 0);
			updateLayeredWindow = (UpdateLayeredWinFunc) GetProcAddress (user32Mod, "UpdateLayeredWindow");
		}
	}

	return updateLayeredWindow != 0;
}

#ifndef WM_TOUCH
 #define WM_TOUCH 0x0240
 #define TOUCH_COORD_TO_PIXEL(l)  ((l) / 100)
 #define TOUCHEVENTF_MOVE   0x0001
 #define TOUCHEVENTF_DOWN   0x0002
 #define TOUCHEVENTF_UP     0x0004
 DECLARE_HANDLE (HTOUCHINPUT);

 typedef struct tagTOUCHINPUT
 {
	LONG x;
	LONG y;
	HANDLE hSource;
	DWORD dwID;
	DWORD dwFlags;
	DWORD dwMask;
	DWORD dwTime;
	ULONG_PTR dwExtraInfo;
	DWORD cxContact;
	DWORD cyContact;
 } TOUCHINPUT, *PTOUCHINPUT;
#endif

typedef BOOL (WINAPI* RegisterTouchWindowFunc) (HWND, ULONG);
typedef BOOL (WINAPI* GetTouchInputInfoFunc) (HTOUCHINPUT, UINT, PTOUCHINPUT, int);
typedef BOOL (WINAPI* CloseTouchInputHandleFunc) (HTOUCHINPUT);

static RegisterTouchWindowFunc   registerTouchWindow = nullptr;
static GetTouchInputInfoFunc     getTouchInputInfo = nullptr;
static CloseTouchInputHandleFunc closeTouchInputHandle = nullptr;

static bool hasCheckedForMultiTouch = false;

static bool canUseMultiTouch()
{
	if (registerTouchWindow == nullptr && ! hasCheckedForMultiTouch)
	{
		hasCheckedForMultiTouch = true;

		HMODULE user32Mod = GetModuleHandle (_T("user32.dll"));
		jassert (user32Mod != 0);

		registerTouchWindow   = (RegisterTouchWindowFunc)   GetProcAddress (user32Mod, "RegisterTouchWindow");
		getTouchInputInfo     = (GetTouchInputInfoFunc)     GetProcAddress (user32Mod, "GetTouchInputInfo");
		closeTouchInputHandle = (CloseTouchInputHandleFunc) GetProcAddress (user32Mod, "CloseTouchInputHandle");
	}

	return registerTouchWindow != nullptr;
}

Desktop::DisplayOrientation Desktop::getCurrentOrientation() const
{
	return upright;
}

int64 getMouseEventTime()
{
	static int64 eventTimeOffset = 0;
	static LONG lastMessageTime = 0;
	const LONG thisMessageTime = GetMessageTime();

	if (thisMessageTime < lastMessageTime || lastMessageTime == 0)
	{
		lastMessageTime = thisMessageTime;
		eventTimeOffset = Time::currentTimeMillis() - thisMessageTime;
	}

	return eventTimeOffset + thisMessageTime;
}

const int extendedKeyModifier               = 0x10000;

const int KeyPress::spaceKey                = VK_SPACE;
const int KeyPress::returnKey               = VK_RETURN;
const int KeyPress::escapeKey               = VK_ESCAPE;
const int KeyPress::backspaceKey            = VK_BACK;
const int KeyPress::deleteKey               = VK_DELETE         | extendedKeyModifier;
const int KeyPress::insertKey               = VK_INSERT         | extendedKeyModifier;
const int KeyPress::tabKey                  = VK_TAB;
const int KeyPress::leftKey                 = VK_LEFT           | extendedKeyModifier;
const int KeyPress::rightKey                = VK_RIGHT          | extendedKeyModifier;
const int KeyPress::upKey                   = VK_UP             | extendedKeyModifier;
const int KeyPress::downKey                 = VK_DOWN           | extendedKeyModifier;
const int KeyPress::homeKey                 = VK_HOME           | extendedKeyModifier;
const int KeyPress::endKey                  = VK_END            | extendedKeyModifier;
const int KeyPress::pageUpKey               = VK_PRIOR          | extendedKeyModifier;
const int KeyPress::pageDownKey             = VK_NEXT           | extendedKeyModifier;
const int KeyPress::F1Key                   = VK_F1             | extendedKeyModifier;
const int KeyPress::F2Key                   = VK_F2             | extendedKeyModifier;
const int KeyPress::F3Key                   = VK_F3             | extendedKeyModifier;
const int KeyPress::F4Key                   = VK_F4             | extendedKeyModifier;
const int KeyPress::F5Key                   = VK_F5             | extendedKeyModifier;
const int KeyPress::F6Key                   = VK_F6             | extendedKeyModifier;
const int KeyPress::F7Key                   = VK_F7             | extendedKeyModifier;
const int KeyPress::F8Key                   = VK_F8             | extendedKeyModifier;
const int KeyPress::F9Key                   = VK_F9             | extendedKeyModifier;
const int KeyPress::F10Key                  = VK_F10            | extendedKeyModifier;
const int KeyPress::F11Key                  = VK_F11            | extendedKeyModifier;
const int KeyPress::F12Key                  = VK_F12            | extendedKeyModifier;
const int KeyPress::F13Key                  = VK_F13            | extendedKeyModifier;
const int KeyPress::F14Key                  = VK_F14            | extendedKeyModifier;
const int KeyPress::F15Key                  = VK_F15            | extendedKeyModifier;
const int KeyPress::F16Key                  = VK_F16            | extendedKeyModifier;
const int KeyPress::numberPad0              = VK_NUMPAD0        | extendedKeyModifier;
const int KeyPress::numberPad1              = VK_NUMPAD1        | extendedKeyModifier;
const int KeyPress::numberPad2              = VK_NUMPAD2        | extendedKeyModifier;
const int KeyPress::numberPad3              = VK_NUMPAD3        | extendedKeyModifier;
const int KeyPress::numberPad4              = VK_NUMPAD4        | extendedKeyModifier;
const int KeyPress::numberPad5              = VK_NUMPAD5        | extendedKeyModifier;
const int KeyPress::numberPad6              = VK_NUMPAD6        | extendedKeyModifier;
const int KeyPress::numberPad7              = VK_NUMPAD7        | extendedKeyModifier;
const int KeyPress::numberPad8              = VK_NUMPAD8        | extendedKeyModifier;
const int KeyPress::numberPad9              = VK_NUMPAD9        | extendedKeyModifier;
const int KeyPress::numberPadAdd            = VK_ADD            | extendedKeyModifier;
const int KeyPress::numberPadSubtract       = VK_SUBTRACT       | extendedKeyModifier;
const int KeyPress::numberPadMultiply       = VK_MULTIPLY       | extendedKeyModifier;
const int KeyPress::numberPadDivide         = VK_DIVIDE         | extendedKeyModifier;
const int KeyPress::numberPadSeparator      = VK_SEPARATOR      | extendedKeyModifier;
const int KeyPress::numberPadDecimalPoint   = VK_DECIMAL        | extendedKeyModifier;
const int KeyPress::numberPadEquals         = 0x92 /*VK_OEM_NEC_EQUAL*/  | extendedKeyModifier;
const int KeyPress::numberPadDelete         = VK_DELETE         | extendedKeyModifier;
const int KeyPress::playKey                 = 0x30000;
const int KeyPress::stopKey                 = 0x30001;
const int KeyPress::fastForwardKey          = 0x30002;
const int KeyPress::rewindKey               = 0x30003;

class WindowsBitmapImage  : public ImagePixelData
{
public:
	WindowsBitmapImage (const Image::PixelFormat format,
						const int w, const int h, const bool clearImage)
		: ImagePixelData (format, w, h)
	{
		jassert (format == Image::RGB || format == Image::ARGB);

		pixelStride = (format == Image::RGB) ? 3 : 4;
		lineStride = -((w * pixelStride + 3) & ~3);

		zerostruct (bitmapInfo);
		bitmapInfo.bV4Size     = sizeof (BITMAPV4HEADER);
		bitmapInfo.bV4Width    = w;
		bitmapInfo.bV4Height   = h;
		bitmapInfo.bV4Planes   = 1;
		bitmapInfo.bV4CSType   = 1;
		bitmapInfo.bV4BitCount = (unsigned short) (pixelStride * 8);

		if (format == Image::ARGB)
		{
			bitmapInfo.bV4AlphaMask      = 0xff000000;
			bitmapInfo.bV4RedMask        = 0xff0000;
			bitmapInfo.bV4GreenMask      = 0xff00;
			bitmapInfo.bV4BlueMask       = 0xff;
			bitmapInfo.bV4V4Compression  = BI_BITFIELDS;
		}
		else
		{
			bitmapInfo.bV4V4Compression  = BI_RGB;
		}

		HDC dc = GetDC (0);
		hdc = CreateCompatibleDC (dc);
		ReleaseDC (0, dc);

		SetMapMode (hdc, MM_TEXT);

		hBitmap = CreateDIBSection (hdc, (BITMAPINFO*) &(bitmapInfo), DIB_RGB_COLORS,
									(void**) &bitmapData, 0, 0);

		previousBitmap = SelectObject (hdc, hBitmap);

		if (format == Image::ARGB && clearImage)
			zeromem (bitmapData, (size_t) std::abs (h * lineStride));

		imageData = bitmapData - (lineStride * (h - 1));
	}

	~WindowsBitmapImage()
	{
		SelectObject (hdc, previousBitmap); // Selecting the previous bitmap before deleting the DC avoids a warning in BoundsChecker
		DeleteDC (hdc);
		DeleteObject (hBitmap);
	}

	ImageType* createType() const                       { return new NativeImageType(); }

	LowLevelGraphicsContext* createLowLevelContext()
	{
		return new LowLevelGraphicsSoftwareRenderer (Image (this));
	}

	void initialiseBitmapData (Image::BitmapData& bitmap, int x, int y, Image::BitmapData::ReadWriteMode)
	{
		bitmap.data = imageData + x * pixelStride + y * lineStride;
		bitmap.pixelFormat = pixelFormat;
		bitmap.lineStride = lineStride;
		bitmap.pixelStride = pixelStride;
	}

	ImagePixelData* clone()
	{
		WindowsBitmapImage* im = new WindowsBitmapImage (pixelFormat, width, height, false);

		for (int i = 0; i < height; ++i)
			memcpy (im->imageData + i * lineStride, imageData + i * lineStride, (size_t) lineStride);

		return im;
	}

	void blitToWindow (HWND hwnd, HDC dc, const bool transparent,
					   const int x, const int y,
					   const RectangleList& maskedRegion,
					   const uint8 updateLayeredWindowAlpha) noexcept
	{
		static HDRAWDIB hdd = createDrawDIB();

		SetMapMode (dc, MM_TEXT);

		if (transparent)
		{
			if (! maskedRegion.isEmpty())
			{
				for (RectangleList::Iterator i (maskedRegion); i.next();)
				{
					const Rectangle<int>& r = *i.getRectangle();
					ExcludeClipRect (hdc, r.getX(), r.getY(), r.getRight(), r.getBottom());
				}
			}

			RECT windowBounds;
			GetWindowRect (hwnd, &windowBounds);

			POINT p = { -x, -y };
			POINT pos = { windowBounds.left, windowBounds.top };
			SIZE size = { windowBounds.right - windowBounds.left,
						  windowBounds.bottom - windowBounds.top };

			BLENDFUNCTION bf;
			bf.AlphaFormat = 1 /*AC_SRC_ALPHA*/;
			bf.BlendFlags = 0;
			bf.BlendOp = AC_SRC_OVER;
			bf.SourceConstantAlpha = updateLayeredWindowAlpha;

			updateLayeredWindow (hwnd, 0, &pos, &size, hdc, &p, 0, &bf, 2 /*ULW_ALPHA*/);
		}
		else
		{
			int savedDC = 0;

			if (! maskedRegion.isEmpty())
			{
				savedDC = SaveDC (dc);

				for (RectangleList::Iterator i (maskedRegion); i.next();)
				{
					const Rectangle<int>& r = *i.getRectangle();
					ExcludeClipRect (dc, r.getX(), r.getY(), r.getRight(), r.getBottom());
				}
			}

			if (hdd == 0)
			{
				StretchDIBits (dc,
							   x, y, width, height,
							   0, 0, width, height,
							   bitmapData, (const BITMAPINFO*) &bitmapInfo,
							   DIB_RGB_COLORS, SRCCOPY);
			}
			else
			{
				DrawDibDraw (hdd, dc, x, y, -1, -1,
							 (BITMAPINFOHEADER*) &bitmapInfo, bitmapData,
							 0, 0, width, height, 0);
			}

			if (! maskedRegion.isEmpty())
				RestoreDC (dc, savedDC);
		}
	}

	HBITMAP hBitmap;
	HGDIOBJ previousBitmap;
	BITMAPV4HEADER bitmapInfo;
	HDC hdc;
	uint8* bitmapData;
	int pixelStride, lineStride;
	uint8* imageData;

private:
	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (WindowsBitmapImage);

	static HDRAWDIB createDrawDIB() noexcept
	{
		HDC dc = GetDC (0);
		const int n = GetDeviceCaps (dc, BITSPIXEL);
		ReleaseDC (0, dc);

		// only open if we're not palettised
		return n > 8 ? DrawDibOpen() : 0;
	}
};

namespace IconConverters
{
	Image createImageFromHBITMAP (HBITMAP bitmap)
	{
		Image im;

		if (bitmap != 0)
		{
			BITMAP bm;

			if (GetObject (bitmap, sizeof (BITMAP), &bm)
				 && bm.bmWidth > 0 && bm.bmHeight > 0)
			{
				HDC tempDC = GetDC (0);
				HDC dc = CreateCompatibleDC (tempDC);
				ReleaseDC (0, tempDC);

				SelectObject (dc, bitmap);

				im = Image (Image::ARGB, bm.bmWidth, bm.bmHeight, true);
				Image::BitmapData imageData (im, Image::BitmapData::writeOnly);

				for (int y = bm.bmHeight; --y >= 0;)
				{
					for (int x = bm.bmWidth; --x >= 0;)
					{
						COLORREF col = GetPixel (dc, x, y);

						imageData.setPixelColour (x, y, Colour ((uint8) GetRValue (col),
																(uint8) GetGValue (col),
																(uint8) GetBValue (col)));
					}
				}

				DeleteDC (dc);
			}
		}

		return im;
	}

	Image createImageFromHICON (HICON icon)
	{
		ICONINFO info;

		if (GetIconInfo (icon, &info))
		{
			Image mask  (createImageFromHBITMAP (info.hbmMask));
			Image image (createImageFromHBITMAP (info.hbmColor));

			if (mask.isValid() && image.isValid())
			{
				for (int y = image.getHeight(); --y >= 0;)
				{
					for (int x = image.getWidth(); --x >= 0;)
					{
						const float brightness = mask.getPixelAt (x, y).getBrightness();

						if (brightness > 0.0f)
							image.multiplyAlphaAt (x, y, 1.0f - brightness);
					}
				}

				return image;
			}
		}

		return Image::null;
	}

	HICON createHICONFromImage (const Image& image, const BOOL isIcon, int hotspotX, int hotspotY)
	{
		WindowsBitmapImage* nativeBitmap = new WindowsBitmapImage (Image::ARGB, image.getWidth(), image.getHeight(), true);
		Image bitmap (nativeBitmap);

		{
			Graphics g (bitmap);
			g.drawImageAt (image, 0, 0);
		}

		HBITMAP mask = CreateBitmap (image.getWidth(), image.getHeight(), 1, 1, 0);

		ICONINFO info;
		info.fIcon = isIcon;
		info.xHotspot = (DWORD) hotspotX;
		info.yHotspot = (DWORD) hotspotY;
		info.hbmMask = mask;
		info.hbmColor = nativeBitmap->hBitmap;

		HICON hi = CreateIconIndirect (&info);
		DeleteObject (mask);
		return hi;
	}
}

class HWNDComponentPeer  : public ComponentPeer
{
public:
	enum RenderingEngineType
	{
		softwareRenderingEngine = 0,
		direct2DRenderingEngine
	};

	HWNDComponentPeer (Component* const component,
					   const int windowStyleFlags,
					   HWND parentToAddTo_)
		: ComponentPeer (component, windowStyleFlags),
		  dontRepaint (false),
		  currentRenderingEngine (softwareRenderingEngine),
		  fullScreen (false),
		  isDragging (false),
		  isMouseOver (false),
		  hasCreatedCaret (false),
		  constrainerIsResizing (false),
		  currentWindowIcon (0),
		  dropTarget (nullptr),
		  parentToAddTo (parentToAddTo_),
		  updateLayeredWindowAlpha (255)
	{
		callFunctionIfNotLocked (&createWindowCallback, this);

		setTitle (component->getName());

		if ((windowStyleFlags & windowHasDropShadow) != 0
			 && Desktop::canUseSemiTransparentWindows())
		{
			shadower = component->getLookAndFeel().createDropShadowerForComponent (component);

			if (shadower != nullptr)
				shadower->setOwner (component);
		}
	}

	~HWNDComponentPeer()
	{
		shadower = nullptr;

		// do this before the next bit to avoid messages arriving for this window
		// before it's destroyed
		JuceWindowIdentifier::setAsJUCEWindow (hwnd, false);

		callFunctionIfNotLocked (&destroyWindowCallback, (void*) hwnd);

		if (currentWindowIcon != 0)
			DestroyIcon (currentWindowIcon);

		if (dropTarget != nullptr)
		{
			dropTarget->clear();
			dropTarget->Release();
			dropTarget = nullptr;
		}

	   #if JUCE_DIRECT2D
		direct2DContext = nullptr;
	   #endif
	}

	void* getNativeHandle() const    { return hwnd; }

	void setVisible (bool shouldBeVisible)
	{
		ShowWindow (hwnd, shouldBeVisible ? SW_SHOWNA : SW_HIDE);

		if (shouldBeVisible)
			InvalidateRect (hwnd, 0, 0);
		else
			lastPaintTime = 0;
	}

	void setTitle (const String& title)
	{
		// Unfortunately some ancient bits of win32 mean you can only perform this operation from the message thread.
		jassert (MessageManager::getInstance()->isThisTheMessageThread());

		SetWindowText (hwnd, title.toWideCharPointer());
	}

	void setPosition (int x, int y)
	{
		offsetWithinParent (x, y);
		SetWindowPos (hwnd, 0,
					  x - windowBorder.getLeft(),
					  y - windowBorder.getTop(),
					  0, 0,
					  SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOZORDER | SWP_NOOWNERZORDER);
	}

	void repaintNowIfTransparent()
	{
		if (isUsingUpdateLayeredWindow() && lastPaintTime > 0 && Time::getMillisecondCounter() > lastPaintTime + 30)
			handlePaintMessage();
	}

	void updateBorderSize()
	{
		WINDOWINFO info;
		info.cbSize = sizeof (info);

		if (GetWindowInfo (hwnd, &info))
		{
			windowBorder = BorderSize<int> (info.rcClient.top - info.rcWindow.top,
											info.rcClient.left - info.rcWindow.left,
											info.rcWindow.bottom - info.rcClient.bottom,
											info.rcWindow.right - info.rcClient.right);
		}

	   #if JUCE_DIRECT2D
		if (direct2DContext != nullptr)
			direct2DContext->resized();
	   #endif
	}

	void setSize (int w, int h)
	{
		SetWindowPos (hwnd, 0, 0, 0,
					  w + windowBorder.getLeftAndRight(),
					  h + windowBorder.getTopAndBottom(),
					  SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER | SWP_NOOWNERZORDER);

		updateBorderSize();

		repaintNowIfTransparent();
	}

	void setBounds (int x, int y, int w, int h, bool isNowFullScreen)
	{
		fullScreen = isNowFullScreen;
		offsetWithinParent (x, y);

		SetWindowPos (hwnd, 0,
					  x - windowBorder.getLeft(),
					  y - windowBorder.getTop(),
					  w + windowBorder.getLeftAndRight(),
					  h + windowBorder.getTopAndBottom(),
					  SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOOWNERZORDER);

		updateBorderSize();

		repaintNowIfTransparent();
	}

	Rectangle<int> getBounds() const
	{
		RECT r;
		GetWindowRect (hwnd, &r);

		Rectangle<int> bounds (r.left, r.top, r.right - r.left, r.bottom - r.top);

		HWND parentH = GetParent (hwnd);
		if (parentH != 0)
		{
			GetWindowRect (parentH, &r);
			bounds.translate (-r.left, -r.top);
		}

		return windowBorder.subtractedFrom (bounds);
	}

	Point<int> getScreenPosition() const
	{
		RECT r;
		GetWindowRect (hwnd, &r);
		return Point<int> (r.left + windowBorder.getLeft(),
						   r.top + windowBorder.getTop());
	}

	Point<int> localToGlobal (const Point<int>& relativePosition)
	{
		return relativePosition + getScreenPosition();
	}

	Point<int> globalToLocal (const Point<int>& screenPosition)
	{
		return screenPosition - getScreenPosition();
	}

	void setAlpha (float newAlpha)
	{
		const uint8 intAlpha = (uint8) jlimit (0, 255, (int) (newAlpha * 255.0f));

		if (component->isOpaque())
		{
			if (newAlpha < 1.0f)
			{
				SetWindowLong (hwnd, GWL_EXSTYLE, GetWindowLong (hwnd, GWL_EXSTYLE) | WS_EX_LAYERED);
				SetLayeredWindowAttributes (hwnd, RGB (0, 0, 0), intAlpha, LWA_ALPHA);
			}
			else
			{
				SetWindowLong (hwnd, GWL_EXSTYLE, GetWindowLong (hwnd, GWL_EXSTYLE) & ~WS_EX_LAYERED);
				RedrawWindow (hwnd, 0, 0, RDW_ERASE | RDW_INVALIDATE | RDW_FRAME | RDW_ALLCHILDREN);
			}
		}
		else
		{
			updateLayeredWindowAlpha = intAlpha;
			component->repaint();
		}
	}

	void setMinimised (bool shouldBeMinimised)
	{
		if (shouldBeMinimised != isMinimised())
			ShowWindow (hwnd, shouldBeMinimised ? SW_MINIMIZE : SW_SHOWNORMAL);
	}

	bool isMinimised() const
	{
		WINDOWPLACEMENT wp;
		wp.length = sizeof (WINDOWPLACEMENT);
		GetWindowPlacement (hwnd, &wp);

		return wp.showCmd == SW_SHOWMINIMIZED;
	}

	void setFullScreen (bool shouldBeFullScreen)
	{
		setMinimised (false);

		if (isFullScreen() != shouldBeFullScreen)
		{
			fullScreen = shouldBeFullScreen;
			const WeakReference<Component> deletionChecker (component);

			if (! fullScreen)
			{
				const Rectangle<int> boundsCopy (lastNonFullscreenBounds);

				if (hasTitleBar())
					ShowWindow (hwnd, SW_SHOWNORMAL);

				if (! boundsCopy.isEmpty())
				{
					setBounds (boundsCopy.getX(),
							   boundsCopy.getY(),
							   boundsCopy.getWidth(),
							   boundsCopy.getHeight(),
							   false);
				}
			}
			else
			{
				if (hasTitleBar())
					ShowWindow (hwnd, SW_SHOWMAXIMIZED);
				else
					SendMessageW (hwnd, WM_SETTINGCHANGE, 0, 0);
			}

			if (deletionChecker != nullptr)
				handleMovedOrResized();
		}
	}

	bool isFullScreen() const
	{
		if (! hasTitleBar())
			return fullScreen;

		WINDOWPLACEMENT wp;
		wp.length = sizeof (wp);
		GetWindowPlacement (hwnd, &wp);

		return wp.showCmd == SW_SHOWMAXIMIZED;
	}

	bool contains (const Point<int>& position, bool trueIfInAChildWindow) const
	{
		if (! (isPositiveAndBelow (position.x, component->getWidth())
				&& isPositiveAndBelow (position.y, component->getHeight())))
			return false;

		RECT r;
		GetWindowRect (hwnd, &r);

		POINT p = { position.x + r.left + windowBorder.getLeft(),
					position.y + r.top  + windowBorder.getTop() };

		HWND w = WindowFromPoint (p);
		return w == hwnd || (trueIfInAChildWindow && (IsChild (hwnd, w) != 0));
	}

	BorderSize<int> getFrameSize() const
	{
		return windowBorder;
	}

	bool setAlwaysOnTop (bool alwaysOnTop)
	{
		const bool oldDeactivate = shouldDeactivateTitleBar;
		shouldDeactivateTitleBar = ((styleFlags & windowIsTemporary) == 0);

		SetWindowPos (hwnd, alwaysOnTop ? HWND_TOPMOST : HWND_NOTOPMOST,
					  0, 0, 0, 0,
					  SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOSENDCHANGING);

		shouldDeactivateTitleBar = oldDeactivate;

		if (shadower != nullptr)
			shadower->componentBroughtToFront (*component);

		return true;
	}

	void toFront (bool makeActive)
	{
		setMinimised (false);

		const bool oldDeactivate = shouldDeactivateTitleBar;
		shouldDeactivateTitleBar = ((styleFlags & windowIsTemporary) == 0);

		callFunctionIfNotLocked (makeActive ? &toFrontCallback1 : &toFrontCallback2, hwnd);

		shouldDeactivateTitleBar = oldDeactivate;

		if (! makeActive)
		{
			// in this case a broughttofront call won't have occured, so do it now..
			handleBroughtToFront();
		}
	}

	void toBehind (ComponentPeer* other)
	{
		HWNDComponentPeer* const otherPeer = dynamic_cast <HWNDComponentPeer*> (other);

		jassert (otherPeer != nullptr); // wrong type of window?

		if (otherPeer != nullptr)
		{
			setMinimised (false);

			// Must be careful not to try to put a topmost window behind a normal one, or Windows
			// promotes the normal one to be topmost!
			if (getComponent()->isAlwaysOnTop() == otherPeer->getComponent()->isAlwaysOnTop())
				SetWindowPos (hwnd, otherPeer->hwnd, 0, 0, 0, 0,
							  SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOSENDCHANGING);
			else if (otherPeer->getComponent()->isAlwaysOnTop())
				SetWindowPos (hwnd, HWND_TOP, 0, 0, 0, 0,
							  SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOSENDCHANGING);
		}
	}

	bool isFocused() const
	{
		return callFunctionIfNotLocked (&getFocusCallback, 0) == (void*) hwnd;
	}

	void grabFocus()
	{
		const bool oldDeactivate = shouldDeactivateTitleBar;
		shouldDeactivateTitleBar = ((styleFlags & windowIsTemporary) == 0);

		callFunctionIfNotLocked (&setFocusCallback, hwnd);

		shouldDeactivateTitleBar = oldDeactivate;
	}

	void textInputRequired (const Point<int>&)
	{
		if (! hasCreatedCaret)
		{
			hasCreatedCaret = true;
			CreateCaret (hwnd, (HBITMAP) 1, 0, 0);
		}

		ShowCaret (hwnd);
		SetCaretPos (0, 0);
	}

	void dismissPendingTextInput()
	{
		imeHandler.handleSetContext (hwnd, false);
	}

	void repaint (const Rectangle<int>& area)
	{
		const RECT r = { area.getX(), area.getY(), area.getRight(), area.getBottom() };
		InvalidateRect (hwnd, &r, FALSE);
	}

	void performAnyPendingRepaintsNow()
	{
		MSG m;
		if (component->isVisible()
			 && (PeekMessage (&m, hwnd, WM_PAINT, WM_PAINT, PM_REMOVE) || isUsingUpdateLayeredWindow()))
			handlePaintMessage();
	}

	static HWNDComponentPeer* getOwnerOfWindow (HWND h) noexcept
	{
		if (h != 0 && JuceWindowIdentifier::isJUCEWindow (h))
			return (HWNDComponentPeer*) GetWindowLongPtr (h, 8);

		return nullptr;
	}

	bool isInside (HWND h) const noexcept
	{
		return GetAncestor (hwnd, GA_ROOT) == h;
	}

	static bool isKeyDown (const int key) noexcept  { return (GetAsyncKeyState (key) & 0x8000) != 0; }

	static void updateKeyModifiers() noexcept
	{
		int keyMods = 0;
		if (isKeyDown (VK_SHIFT))   keyMods |= ModifierKeys::shiftModifier;
		if (isKeyDown (VK_CONTROL)) keyMods |= ModifierKeys::ctrlModifier;
		if (isKeyDown (VK_MENU))    keyMods |= ModifierKeys::altModifier;
		if (isKeyDown (VK_RMENU))   keyMods &= ~(ModifierKeys::ctrlModifier | ModifierKeys::altModifier);

		currentModifiers = currentModifiers.withOnlyMouseButtons().withFlags (keyMods);
	}

	static void updateModifiersFromWParam (const WPARAM wParam)
	{
		int mouseMods = 0;
		if (wParam & MK_LBUTTON)   mouseMods |= ModifierKeys::leftButtonModifier;
		if (wParam & MK_RBUTTON)   mouseMods |= ModifierKeys::rightButtonModifier;
		if (wParam & MK_MBUTTON)   mouseMods |= ModifierKeys::middleButtonModifier;

		currentModifiers = currentModifiers.withoutMouseButtons().withFlags (mouseMods);
		updateKeyModifiers();
	}

	bool dontRepaint;

	static ModifierKeys currentModifiers;
	static ModifierKeys modifiersAtLastCallback;

	class JuceDropTarget    : public ComBaseClassHelper <IDropTarget>
	{
	public:
		JuceDropTarget (HWNDComponentPeer& owner_)   : ownerInfo (new OwnerInfo (owner_)) {}

		void clear()
		{
			ownerInfo = nullptr;
		}

		JUCE_COMRESULT DragEnter (IDataObject* pDataObject, DWORD grfKeyState, POINTL mousePos, DWORD* pdwEffect)
		{
			HRESULT hr = updateFileList (pDataObject);
			if (FAILED (hr))
				return hr;

			return DragOver (grfKeyState, mousePos, pdwEffect);
		}

		JUCE_COMRESULT DragLeave()
		{
			if (ownerInfo == nullptr)
				return S_FALSE;

			ownerInfo->owner.handleFileDragExit (ownerInfo->files);
			return S_OK;
		}

		JUCE_COMRESULT DragOver (DWORD /*grfKeyState*/, POINTL mousePos, DWORD* pdwEffect)
		{
			if (ownerInfo == nullptr)
				return S_FALSE;

			const bool wasWanted = ownerInfo->owner.handleFileDragMove (ownerInfo->files, ownerInfo->getMousePos (mousePos));
			*pdwEffect = wasWanted ? (DWORD) DROPEFFECT_COPY : (DWORD) DROPEFFECT_NONE;
			return S_OK;
		}

		JUCE_COMRESULT Drop (IDataObject* pDataObject, DWORD /*grfKeyState*/, POINTL mousePos, DWORD* pdwEffect)
		{
			HRESULT hr = updateFileList (pDataObject);
			if (SUCCEEDED (hr))
			{
				const bool wasWanted = ownerInfo->owner.handleFileDragDrop (ownerInfo->files, ownerInfo->getMousePos (mousePos));
				*pdwEffect = wasWanted ? (DWORD) DROPEFFECT_COPY : (DWORD) DROPEFFECT_NONE;
				hr = S_OK;
			}

			return hr;
		}

	private:
		struct OwnerInfo
		{
			OwnerInfo (HWNDComponentPeer& owner_) : owner (owner_) {}

			Point<int> getMousePos (const POINTL& mousePos) const
			{
				return owner.globalToLocal (Point<int> (mousePos.x, mousePos.y));
			}

			template <typename CharType>
			void parseFileList (const CharType* names, const SIZE_T totalLen)
			{
				unsigned int i = 0;

				for (;;)
				{
					unsigned int len = 0;
					while (i + len < totalLen && names [i + len] != 0)
						++len;

					if (len == 0)
						break;

					files.add (String (names + i, len));
					i += len + 1;
				}
			}

			HWNDComponentPeer& owner;
			StringArray files;

			JUCE_DECLARE_NON_COPYABLE (OwnerInfo);
		};

		ScopedPointer<OwnerInfo> ownerInfo;

		HRESULT updateFileList (IDataObject* const pDataObject)
		{
			if (ownerInfo == nullptr)
				return S_FALSE;

			ownerInfo->files.clear();

			FORMATETC format = { CF_HDROP, 0, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
			STGMEDIUM medium = { TYMED_HGLOBAL, { 0 }, 0 };

			HRESULT hr = pDataObject->GetData (&format, &medium);

			if (SUCCEEDED (hr))
			{
				const SIZE_T totalLen = GlobalSize (medium.hGlobal);
				const LPDROPFILES dropFiles = (const LPDROPFILES) GlobalLock (medium.hGlobal);
				const void* const names = addBytesToPointer (dropFiles, sizeof (DROPFILES));

				if (dropFiles->fWide)
					ownerInfo->parseFileList (static_cast <const WCHAR*> (names), totalLen);
				else
					ownerInfo->parseFileList (static_cast <const char*>  (names), totalLen);

				GlobalUnlock (medium.hGlobal);
			}

			return hr;
		}

		JUCE_DECLARE_NON_COPYABLE (JuceDropTarget);
	};

private:
	HWND hwnd, parentToAddTo;
	ScopedPointer<DropShadower> shadower;
	RenderingEngineType currentRenderingEngine;
   #if JUCE_DIRECT2D
	ScopedPointer<Direct2DLowLevelGraphicsContext> direct2DContext;
   #endif
	bool fullScreen, isDragging, isMouseOver, hasCreatedCaret, constrainerIsResizing;
	BorderSize<int> windowBorder;
	HICON currentWindowIcon;
	JuceDropTarget* dropTarget;
	uint8 updateLayeredWindowAlpha;
	MultiTouchMapper<DWORD> currentTouches;

	class TemporaryImage    : public Timer
	{
	public:
		TemporaryImage() {}

		Image& getImage (const bool transparent, const int w, const int h)
		{
			const Image::PixelFormat format = transparent ? Image::ARGB : Image::RGB;

			if ((! image.isValid()) || image.getWidth() < w || image.getHeight() < h || image.getFormat() != format)
				image = Image (new WindowsBitmapImage (format, (w + 31) & ~31, (h + 31) & ~31, false));

			startTimer (3000);
			return image;
		}

		void timerCallback()
		{
			stopTimer();
			image = Image::null;
		}

	private:
		Image image;

		JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (TemporaryImage);
	};

	TemporaryImage offscreenImageGenerator;

	class WindowClassHolder    : public DeletedAtShutdown
	{
	public:
		WindowClassHolder()
		{
			// this name has to be different for each app/dll instance because otherwise poor old Windows can
			// get a bit confused (even despite it not being a process-global window class).
			String windowClassName ("JUCE_");
			windowClassName << String::toHexString (Time::currentTimeMillis());

			HINSTANCE moduleHandle = (HINSTANCE) Process::getCurrentModuleInstanceHandle();

			TCHAR moduleFile [1024] = { 0 };
			GetModuleFileName (moduleHandle, moduleFile, 1024);
			WORD iconNum = 0;

			WNDCLASSEX wcex = { 0 };
			wcex.cbSize         = sizeof (wcex);
			wcex.style          = CS_OWNDC;
			wcex.lpfnWndProc    = (WNDPROC) windowProc;
			wcex.lpszClassName  = windowClassName.toWideCharPointer();
			wcex.cbWndExtra     = 32;
			wcex.hInstance      = moduleHandle;
			wcex.hIcon          = ExtractAssociatedIcon (moduleHandle, moduleFile, &iconNum);
			iconNum = 1;
			wcex.hIconSm        = ExtractAssociatedIcon (moduleHandle, moduleFile, &iconNum);

			atom = RegisterClassEx (&wcex);
			jassert (atom != 0);

			isEventBlockedByModalComps = checkEventBlockedByModalComps;
		}

		~WindowClassHolder()
		{
			if (ComponentPeer::getNumPeers() == 0)
				UnregisterClass (getWindowClassName(), (HINSTANCE) Process::getCurrentModuleInstanceHandle());

			clearSingletonInstance();
		}

		LPCTSTR getWindowClassName() const noexcept     { return (LPCTSTR) MAKELONG (atom, 0); }

		juce_DeclareSingleton_SingleThreaded_Minimal (WindowClassHolder);

	private:
		ATOM atom;

		static bool isHWNDBlockedByModalComponents (HWND h)
		{
			for (int i = Desktop::getInstance().getNumComponents(); --i >= 0;)
			{
				Component* const c = Desktop::getInstance().getComponent (i);

				if (c != nullptr
					  && (! c->isCurrentlyBlockedByAnotherModalComponent())
					  && IsChild ((HWND) c->getWindowHandle(), h))
					return false;
			}

			return true;
		}

		static bool checkEventBlockedByModalComps (const MSG& m)
		{
			if (Component::getNumCurrentlyModalComponents() == 0 || JuceWindowIdentifier::isJUCEWindow (m.hwnd))
				return false;

			switch (m.message)
			{
				case WM_MOUSEMOVE:
				case WM_NCMOUSEMOVE:
				case 0x020A: /* WM_MOUSEWHEEL */
				case 0x020E: /* WM_MOUSEHWHEEL */
				case WM_KEYUP:
				case WM_SYSKEYUP:
				case WM_CHAR:
				case WM_APPCOMMAND:
				case WM_LBUTTONUP:
				case WM_MBUTTONUP:
				case WM_RBUTTONUP:
				case WM_MOUSEACTIVATE:
				case WM_NCMOUSEHOVER:
				case WM_MOUSEHOVER:
				case WM_TOUCH:
					return isHWNDBlockedByModalComponents (m.hwnd);

				case WM_NCLBUTTONDOWN:
				case WM_NCLBUTTONDBLCLK:
				case WM_NCRBUTTONDOWN:
				case WM_NCRBUTTONDBLCLK:
				case WM_NCMBUTTONDOWN:
				case WM_NCMBUTTONDBLCLK:
				case WM_LBUTTONDOWN:
				case WM_LBUTTONDBLCLK:
				case WM_MBUTTONDOWN:
				case WM_MBUTTONDBLCLK:
				case WM_RBUTTONDOWN:
				case WM_RBUTTONDBLCLK:
				case WM_KEYDOWN:
				case WM_SYSKEYDOWN:
					if (isHWNDBlockedByModalComponents (m.hwnd))
					{
						Component* const modal = Component::getCurrentlyModalComponent (0);
						if (modal != nullptr)
							modal->inputAttemptWhenModal();

						return true;
					}
					break;

				default:
					break;
			}

			return false;
		}

		JUCE_DECLARE_NON_COPYABLE (WindowClassHolder);
	};

	static void* createWindowCallback (void* userData)
	{
		static_cast <HWNDComponentPeer*> (userData)->createWindow();
		return nullptr;
	}

	void createWindow()
	{
		DWORD exstyle = WS_EX_ACCEPTFILES;
		DWORD type = WS_CLIPSIBLINGS | WS_CLIPCHILDREN;

		if (hasTitleBar())
		{
			type |= WS_OVERLAPPED;

			if ((styleFlags & windowHasCloseButton) != 0)
			{
				type |= WS_SYSMENU;
			}
			else
			{
				// annoyingly, windows won't let you have a min/max button without a close button
				jassert ((styleFlags & (windowHasMinimiseButton | windowHasMaximiseButton)) == 0);
			}

			if ((styleFlags & windowIsResizable) != 0)
				type |= WS_THICKFRAME;
		}
		else if (parentToAddTo != 0)
		{
			type |= WS_CHILD;
		}
		else
		{
			type |= WS_POPUP | WS_SYSMENU;
		}

		if ((styleFlags & windowAppearsOnTaskbar) == 0)
			exstyle |= WS_EX_TOOLWINDOW;
		else
			exstyle |= WS_EX_APPWINDOW;

		if ((styleFlags & windowHasMinimiseButton) != 0)    type |= WS_MINIMIZEBOX;
		if ((styleFlags & windowHasMaximiseButton) != 0)    type |= WS_MAXIMIZEBOX;
		if ((styleFlags & windowIgnoresMouseClicks) != 0)   exstyle |= WS_EX_TRANSPARENT;

		if ((styleFlags & windowIsSemiTransparent) != 0 && Desktop::canUseSemiTransparentWindows())
			exstyle |= WS_EX_LAYERED;

		hwnd = CreateWindowEx (exstyle, WindowClassHolder::getInstance()->getWindowClassName(),
							   L"", type, 0, 0, 0, 0, parentToAddTo, 0,
							   (HINSTANCE) Process::getCurrentModuleInstanceHandle(), 0);

	   #if JUCE_DIRECT2D
		setCurrentRenderingEngine (1);
	   #endif

		if (hwnd != 0)
		{
			SetWindowLongPtr (hwnd, 0, 0);
			SetWindowLongPtr (hwnd, 8, (LONG_PTR) this);
			JuceWindowIdentifier::setAsJUCEWindow (hwnd, true);

			if (dropTarget == nullptr)
				dropTarget = new JuceDropTarget (*this);

			RegisterDragDrop (hwnd, dropTarget);

			if (canUseMultiTouch())
				registerTouchWindow (hwnd, 0);

			updateBorderSize();

			// Calling this function here is (for some reason) necessary to make Windows
			// correctly enable the menu items that we specify in the wm_initmenu message.
			GetSystemMenu (hwnd, false);

			const float alpha = component->getAlpha();
			if (alpha < 1.0f)
				setAlpha (alpha);
		}
		else
		{
			jassertfalse;
		}
	}

	static void* destroyWindowCallback (void* handle)
	{
		RevokeDragDrop ((HWND) handle);
		DestroyWindow ((HWND) handle);
		return nullptr;
	}

	static void* toFrontCallback1 (void* h)
	{
		SetForegroundWindow ((HWND) h);
		return nullptr;
	}

	static void* toFrontCallback2 (void* h)
	{
		SetWindowPos ((HWND) h, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOSENDCHANGING);
		return nullptr;
	}

	static void* setFocusCallback (void* h)
	{
		SetFocus ((HWND) h);
		return nullptr;
	}

	static void* getFocusCallback (void*)
	{
		return GetFocus();
	}

	void offsetWithinParent (int& x, int& y) const
	{
		if (isUsingUpdateLayeredWindow())
		{
			HWND parentHwnd = GetParent (hwnd);

			if (parentHwnd != 0)
			{
				RECT parentRect;
				GetWindowRect (parentHwnd, &parentRect);
				x += parentRect.left;
				y += parentRect.top;
			}
		}
	}

	bool isUsingUpdateLayeredWindow() const
	{
		return ! component->isOpaque();
	}

	inline bool hasTitleBar() const noexcept        { return (styleFlags & windowHasTitleBar) != 0; }

	void setIcon (const Image& newIcon)
	{
		HICON hicon = IconConverters::createHICONFromImage (newIcon, TRUE, 0, 0);

		if (hicon != 0)
		{
			SendMessage (hwnd, WM_SETICON, ICON_BIG, (LPARAM) hicon);
			SendMessage (hwnd, WM_SETICON, ICON_SMALL, (LPARAM) hicon);

			if (currentWindowIcon != 0)
				DestroyIcon (currentWindowIcon);

			currentWindowIcon = hicon;
		}
	}

	void handlePaintMessage()
	{
	   #if JUCE_DIRECT2D
		if (direct2DContext != nullptr)
		{
			RECT r;

			if (GetUpdateRect (hwnd, &r, false))
			{
				direct2DContext->start();
				direct2DContext->clipToRectangle (Rectangle<int> (r.left, r.top, r.right - r.left, r.bottom - r.top));
				handlePaint (*direct2DContext);
				direct2DContext->end();
			}
		}
		else
	   #endif

		{
			HRGN rgn = CreateRectRgn (0, 0, 0, 0);
			const int regionType = GetUpdateRgn (hwnd, rgn, false);

			PAINTSTRUCT paintStruct;
			HDC dc = BeginPaint (hwnd, &paintStruct); // Note this can immediately generate a WM_NCPAINT
													  // message and become re-entrant, but that's OKSaveDC

			// if something in a paint handler calls, e.g. a message box, this can become reentrant and
			// corrupt the image it's using to paint into, so do a check here.
			static bool reentrant = false;
			if (reentrant)
			{
				DeleteObject (rgn);
				EndPaint (hwnd, &paintStruct);
				return;
			}

			const ScopedValueSetter<bool> setter (reentrant, true, false);

			// this is the rectangle to update..
			int x = paintStruct.rcPaint.left;
			int y = paintStruct.rcPaint.top;
			int w = paintStruct.rcPaint.right - x;
			int h = paintStruct.rcPaint.bottom - y;

			const bool transparent = isUsingUpdateLayeredWindow();

			if (transparent)
			{
				// it's not possible to have a transparent window with a title bar at the moment!
				jassert (! hasTitleBar());

				RECT r;
				GetWindowRect (hwnd, &r);
				x = y = 0;
				w = r.right - r.left;
				h = r.bottom - r.top;
			}

			if (w > 0 && h > 0)
			{
				clearMaskedRegion();

				Image& offscreenImage = offscreenImageGenerator.getImage (transparent, w, h);

				RectangleList contextClip;
				const Rectangle<int> clipBounds (0, 0, w, h);

				bool needToPaintAll = true;

				if (regionType == COMPLEXREGION && ! transparent)
				{
					HRGN clipRgn = CreateRectRgnIndirect (&paintStruct.rcPaint);
					CombineRgn (rgn, rgn, clipRgn, RGN_AND);
					DeleteObject (clipRgn);

					char rgnData [8192];
					const DWORD res = GetRegionData (rgn, sizeof (rgnData), (RGNDATA*) rgnData);

					if (res > 0 && res <= sizeof (rgnData))
					{
						const RGNDATAHEADER* const hdr = &(((const RGNDATA*) rgnData)->rdh);

						if (hdr->iType == RDH_RECTANGLES
							 && hdr->rcBound.right - hdr->rcBound.left >= w
							 && hdr->rcBound.bottom - hdr->rcBound.top >= h)
						{
							needToPaintAll = false;

							const RECT* rects = (const RECT*) (rgnData + sizeof (RGNDATAHEADER));

							for (int i = (int) ((RGNDATA*) rgnData)->rdh.nCount; --i >= 0;)
							{
								if (rects->right <= x + w && rects->bottom <= y + h)
								{
									const int cx = jmax (x, (int) rects->left);
									contextClip.addWithoutMerging (Rectangle<int> (cx - x, rects->top - y, rects->right - cx, rects->bottom - rects->top)
																	   .getIntersection (clipBounds));
								}
								else
								{
									needToPaintAll = true;
									break;
								}

								++rects;
							}
						}
					}
				}

				if (needToPaintAll)
				{
					contextClip.clear();
					contextClip.addWithoutMerging (Rectangle<int> (w, h));
				}

				if (transparent)
				{
					RectangleList::Iterator i (contextClip);

					while (i.next())
						offscreenImage.clear (*i.getRectangle());
				}

				// if the component's not opaque, this won't draw properly unless the platform can support this
				jassert (Desktop::canUseSemiTransparentWindows() || component->isOpaque());

				updateCurrentModifiers();

				{
					ScopedPointer<LowLevelGraphicsContext> context (component->getLookAndFeel()
																		.createGraphicsContext (offscreenImage, Point<int> (-x, -y), contextClip));
					handlePaint (*context);
				}

				if (! dontRepaint)
					static_cast <WindowsBitmapImage*> (offscreenImage.getPixelData())
						->blitToWindow (hwnd, dc, transparent, x, y, maskedRegion, updateLayeredWindowAlpha);
			}

			DeleteObject (rgn);
			EndPaint (hwnd, &paintStruct);
		}

	   #ifndef JUCE_GCC
		_fpreset(); // because some graphics cards can unmask FP exceptions
	   #endif

		lastPaintTime = Time::getMillisecondCounter();
	}

	void doMouseEvent (const Point<int>& position)
	{
		handleMouseEvent (0, position, currentModifiers, getMouseEventTime());
	}

	StringArray getAvailableRenderingEngines()
	{
		StringArray s (ComponentPeer::getAvailableRenderingEngines());

	   #if JUCE_DIRECT2D
		if (SystemStats::getOperatingSystemType() >= SystemStats::Windows7)
			s.add ("Direct2D");
	   #endif

		return s;
	}

	int getCurrentRenderingEngine() const    { return currentRenderingEngine; }

   #if JUCE_DIRECT2D
	void updateDirect2DContext()
	{
		if (currentRenderingEngine != direct2DRenderingEngine)
			direct2DContext = 0;
		else if (direct2DContext == 0)
			direct2DContext = new Direct2DLowLevelGraphicsContext (hwnd);
	}
   #endif

	void setCurrentRenderingEngine (int index)
	{
		(void) index;

	   #if JUCE_DIRECT2D
		if (getAvailableRenderingEngines().size() > 1)
		{
			currentRenderingEngine = index == 1 ? direct2DRenderingEngine : softwareRenderingEngine;
			updateDirect2DContext();
			repaint (component->getLocalBounds());
		}
	   #endif
	}

	static int getMinTimeBetweenMouseMoves()
	{
		if (SystemStats::getOperatingSystemType() >= SystemStats::WinVista)
			return 0;

		return 1000 / 60;  // Throttling the incoming mouse-events seems to still be needed in XP..
	}

	static bool isCurrentEventFromTouchScreen() noexcept
	{
		const LPARAM flags = GetMessageExtraInfo();
		return (flags & 0xffffff00 /* SIGNATURE_MASK */) == 0xff515700 /* MI_WP_SIGNATURE */
				&& (flags & 0x80) != 0; // (bit 7 = 0 for pen events, 1 for touch)
	}

	void doMouseMove (const Point<int>& position)
	{
		if (! isCurrentEventFromTouchScreen())
		{
			if (! isMouseOver)
			{
				isMouseOver = true;
				ModifierKeys::getCurrentModifiersRealtime(); // (This avoids a rare stuck-button problem when focus is lost unexpectedly)
				updateKeyModifiers();

				TRACKMOUSEEVENT tme;
				tme.cbSize = sizeof (tme);
				tme.dwFlags = TME_LEAVE;
				tme.hwndTrack = hwnd;
				tme.dwHoverTime = 0;

				if (! TrackMouseEvent (&tme))
					jassertfalse;

				Desktop::getInstance().getMainMouseSource().forceMouseCursorUpdate();
			}
			else if (! isDragging)
			{
				if (! contains (position, false))
					return;
			}

			static uint32 lastMouseTime = 0;
			static int minTimeBetweenMouses = getMinTimeBetweenMouseMoves();
			const uint32 now = Time::getMillisecondCounter();

			if (now >= lastMouseTime + minTimeBetweenMouses)
			{
				lastMouseTime = now;
				doMouseEvent (position);
			}
		}
	}

	void doMouseDown (const Point<int>& position, const WPARAM wParam)
	{
		if (! isCurrentEventFromTouchScreen())
		{
			if (GetCapture() != hwnd)
				SetCapture (hwnd);

			doMouseMove (position);

			updateModifiersFromWParam (wParam);
			isDragging = true;

			doMouseEvent (position);
		}
	}

	void doMouseUp (const Point<int>& position, const WPARAM wParam)
	{
		if (! isCurrentEventFromTouchScreen())
		{
			updateModifiersFromWParam (wParam);
			const bool wasDragging = isDragging;
			isDragging = false;

			// release the mouse capture if the user has released all buttons
			if ((wParam & (MK_LBUTTON | MK_RBUTTON | MK_MBUTTON)) == 0 && hwnd == GetCapture())
				ReleaseCapture();

			// NB: under some circumstances (e.g. double-clicking a native title bar), a mouse-up can
			// arrive without a mouse-down, so in that case we need to avoid sending a message.
			if (wasDragging)
				doMouseEvent (position);
		}
	}

	void doCaptureChanged()
	{
		if (constrainerIsResizing)
		{
			if (constrainer != nullptr)
				constrainer->resizeEnd();

			constrainerIsResizing = false;
		}

		if (isDragging)
			doMouseUp (getCurrentMousePos(), (WPARAM) 0);
	}

	void doMouseExit()
	{
		isMouseOver = false;
		doMouseEvent (getCurrentMousePos());
	}

	void doMouseWheel (const Point<int>& globalPos, const WPARAM wParam, const bool isVertical)
	{
		updateKeyModifiers();
		const float amount = jlimit (-1000.0f, 1000.0f, 0.75f * (short) HIWORD (wParam));

		// Because Windows stupidly sends all wheel events to the window with the keyboard
		// focus, we have to redirect them here according to the mouse pos..
		POINT p = { globalPos.x, globalPos.y };
		HWNDComponentPeer* peer = getOwnerOfWindow (WindowFromPoint (p));

		if (peer == nullptr)
			peer = this;

		peer->handleMouseWheel (0, peer->globalToLocal (globalPos), getMouseEventTime(),
								isVertical ? 0.0f : -amount,
								isVertical ? amount : 0.0f);
	}

	void doTouchEvent (const int numInputs, HTOUCHINPUT eventHandle)
	{
		HeapBlock<TOUCHINPUT> inputInfo (numInputs);

		if (getTouchInputInfo (eventHandle, numInputs, inputInfo, sizeof (TOUCHINPUT)))
		{
			for (int i = 0; i < numInputs; ++i)
			{
				const DWORD flags = inputInfo[i].dwFlags;

				if ((flags & (TOUCHEVENTF_DOWN | TOUCHEVENTF_MOVE | TOUCHEVENTF_UP)) != 0)
				{
					if (! handleTouchInput (inputInfo[i], (flags & TOUCHEVENTF_DOWN) != 0,
														  (flags & TOUCHEVENTF_UP) != 0))
						return;  // abandon method if this window was deleted by the callback
				}
			}
		}

		closeTouchInputHandle (eventHandle);
	}

	bool handleTouchInput (const TOUCHINPUT& touch, const bool isDown, const bool isUp)
	{
		bool isCancel = false;
		const int touchIndex = currentTouches.getIndexOfTouch (touch.dwID);
		const int64 time = getMouseEventTime();
		const Point<int> pos (globalToLocal (Point<int> ((int) TOUCH_COORD_TO_PIXEL (touch.x),
														 (int) TOUCH_COORD_TO_PIXEL (touch.y))));
		ModifierKeys modsToSend (currentModifiers);

		if (isDown)
		{
			currentModifiers = currentModifiers.withoutMouseButtons().withFlags (ModifierKeys::leftButtonModifier);
			modsToSend = currentModifiers;

			// this forces a mouse-enter/up event, in case for some reason we didn't get a mouse-up before.
			handleMouseEvent (touchIndex + 1, pos, modsToSend.withoutMouseButtons(), time);
			if (! isValidPeer (this)) // (in case this component was deleted by the event)
				return false;
		}
		else if (isUp)
		{
			modsToSend = modsToSend.withoutMouseButtons();
			currentTouches.clearTouch (touchIndex);

			if (! currentTouches.areAnyTouchesActive())
				isCancel = true;
		}

		if (isCancel)
		{
			currentTouches.clear();
			currentModifiers = currentModifiers.withoutMouseButtons();
		}

		handleMouseEvent (touchIndex + 1, pos, modsToSend, time);
		if (! isValidPeer (this)) // (in case this component was deleted by the event)
			return false;

		if (isUp || isCancel)
		{
			handleMouseEvent (touchIndex + 1, Point<int> (-1, -1), currentModifiers, time);
			if (! isValidPeer (this))
				return false;
		}

		return true;
	}

	void sendModifierKeyChangeIfNeeded()
	{
		if (modifiersAtLastCallback != currentModifiers)
		{
			modifiersAtLastCallback = currentModifiers;
			handleModifierKeysChange();
		}
	}

	bool doKeyUp (const WPARAM key)
	{
		updateKeyModifiers();

		switch (key)
		{
			case VK_SHIFT:
			case VK_CONTROL:
			case VK_MENU:
			case VK_CAPITAL:
			case VK_LWIN:
			case VK_RWIN:
			case VK_APPS:
			case VK_NUMLOCK:
			case VK_SCROLL:
			case VK_LSHIFT:
			case VK_RSHIFT:
			case VK_LCONTROL:
			case VK_LMENU:
			case VK_RCONTROL:
			case VK_RMENU:
				sendModifierKeyChangeIfNeeded();
		}

		return handleKeyUpOrDown (false)
				|| Component::getCurrentlyModalComponent() != nullptr;
	}

	bool doKeyDown (const WPARAM key)
	{
		updateKeyModifiers();
		bool used = false;

		switch (key)
		{
			case VK_SHIFT:
			case VK_LSHIFT:
			case VK_RSHIFT:
			case VK_CONTROL:
			case VK_LCONTROL:
			case VK_RCONTROL:
			case VK_MENU:
			case VK_LMENU:
			case VK_RMENU:
			case VK_LWIN:
			case VK_RWIN:
			case VK_CAPITAL:
			case VK_NUMLOCK:
			case VK_SCROLL:
			case VK_APPS:
				sendModifierKeyChangeIfNeeded();
				break;

			case VK_LEFT:
			case VK_RIGHT:
			case VK_UP:
			case VK_DOWN:
			case VK_PRIOR:
			case VK_NEXT:
			case VK_HOME:
			case VK_END:
			case VK_DELETE:
			case VK_INSERT:
			case VK_F1:
			case VK_F2:
			case VK_F3:
			case VK_F4:
			case VK_F5:
			case VK_F6:
			case VK_F7:
			case VK_F8:
			case VK_F9:
			case VK_F10:
			case VK_F11:
			case VK_F12:
			case VK_F13:
			case VK_F14:
			case VK_F15:
			case VK_F16:
				used = handleKeyUpOrDown (true);
				used = handleKeyPress (extendedKeyModifier | (int) key, 0) || used;
				break;

			case VK_ADD:
			case VK_SUBTRACT:
			case VK_MULTIPLY:
			case VK_DIVIDE:
			case VK_SEPARATOR:
			case VK_DECIMAL:
				used = handleKeyUpOrDown (true);
				break;

			default:
				used = handleKeyUpOrDown (true);

				{
					MSG msg;

					if (! PeekMessage (&msg, hwnd, WM_CHAR, WM_DEADCHAR, PM_NOREMOVE))
					{
						// if there isn't a WM_CHAR or WM_DEADCHAR message pending, we need to
						// manually generate the key-press event that matches this key-down.

						const UINT keyChar = MapVirtualKey ((UINT) key, 2);
						used = handleKeyPress ((int) LOWORD (keyChar), 0) || used;
					}
				}

				break;
		}

		return used || (Component::getCurrentlyModalComponent() != nullptr);
	}

	bool doKeyChar (int key, const LPARAM flags)
	{
		updateKeyModifiers();

		juce_wchar textChar = (juce_wchar) key;

		const int virtualScanCode = (flags >> 16) & 0xff;

		if (key >= '0' && key <= '9')
		{
			switch (virtualScanCode)  // check for a numeric keypad scan-code
			{
				case 0x52:
				case 0x4f:
				case 0x50:
				case 0x51:
				case 0x4b:
				case 0x4c:
				case 0x4d:
				case 0x47:
				case 0x48:
				case 0x49:
					key = (key - '0') + KeyPress::numberPad0;
					break;
				default:
					break;
			}
		}
		else
		{
			// convert the scan code to an unmodified character code..
			const UINT virtualKey = MapVirtualKey ((UINT) virtualScanCode, 1);
			UINT keyChar = MapVirtualKey (virtualKey, 2);

			keyChar = LOWORD (keyChar);

			if (keyChar != 0)
				key = (int) keyChar;

			// avoid sending junk text characters for some control-key combinations
			if (textChar < ' ' && currentModifiers.testFlags (ModifierKeys::ctrlModifier | ModifierKeys::altModifier))
				textChar = 0;
		}

		return handleKeyPress (key, textChar);
	}

	void forwardMessageToParent (UINT message, WPARAM wParam, LPARAM lParam) const
	{
		HWND parentH = GetParent (hwnd);
		if (parentH != 0)
			PostMessage (parentH, message, wParam, lParam);
	}

	bool doAppCommand (const LPARAM lParam)
	{
		int key = 0;

		switch (GET_APPCOMMAND_LPARAM (lParam))
		{
			case APPCOMMAND_MEDIA_PLAY_PAUSE:       key = KeyPress::playKey; break;
			case APPCOMMAND_MEDIA_STOP:             key = KeyPress::stopKey; break;
			case APPCOMMAND_MEDIA_NEXTTRACK:        key = KeyPress::fastForwardKey; break;
			case APPCOMMAND_MEDIA_PREVIOUSTRACK:    key = KeyPress::rewindKey; break;
			default: break;
		}

		if (key != 0)
		{
			updateKeyModifiers();

			if (hwnd == GetActiveWindow())
			{
				handleKeyPress (key, 0);
				return true;
			}
		}

		return false;
	}

	bool isConstrainedNativeWindow() const
	{
		return constrainer != nullptr
				&& (styleFlags & (windowHasTitleBar | windowIsResizable)) == (windowHasTitleBar | windowIsResizable);
	}

	LRESULT handleSizeConstraining (RECT* const r, const WPARAM wParam)
	{
		if (isConstrainedNativeWindow())
		{
			Rectangle<int> pos (r->left, r->top, r->right - r->left, r->bottom - r->top);

			constrainer->checkBounds (pos, windowBorder.addedTo (component->getBounds()),
									  Desktop::getInstance().getAllMonitorDisplayAreas().getBounds(),
									  wParam == WMSZ_TOP    || wParam == WMSZ_TOPLEFT    || wParam == WMSZ_TOPRIGHT,
									  wParam == WMSZ_LEFT   || wParam == WMSZ_TOPLEFT    || wParam == WMSZ_BOTTOMLEFT,
									  wParam == WMSZ_BOTTOM || wParam == WMSZ_BOTTOMLEFT || wParam == WMSZ_BOTTOMRIGHT,
									  wParam == WMSZ_RIGHT  || wParam == WMSZ_TOPRIGHT   || wParam == WMSZ_BOTTOMRIGHT);
			r->left   = pos.getX();
			r->top    = pos.getY();
			r->right  = pos.getRight();
			r->bottom = pos.getBottom();
		}

		return TRUE;
	}

	LRESULT handlePositionChanging (WINDOWPOS* const wp)
	{
		if (isConstrainedNativeWindow())
		{
			if ((wp->flags & (SWP_NOMOVE | SWP_NOSIZE)) != (SWP_NOMOVE | SWP_NOSIZE)
				 && ! Component::isMouseButtonDownAnywhere())
			{
				Rectangle<int> pos (wp->x, wp->y, wp->cx, wp->cy);
				const Rectangle<int> current (windowBorder.addedTo (component->getBounds()));

				constrainer->checkBounds (pos, current,
										  Desktop::getInstance().getAllMonitorDisplayAreas().getBounds(),
										  pos.getY() != current.getY() && pos.getBottom() == current.getBottom(),
										  pos.getX() != current.getX() && pos.getRight() == current.getRight(),
										  pos.getY() == current.getY() && pos.getBottom() != current.getBottom(),
										  pos.getX() == current.getX() && pos.getRight() != current.getRight());
				wp->x = pos.getX();
				wp->y = pos.getY();
				wp->cx = pos.getWidth();
				wp->cy = pos.getHeight();
			}
		}

		return 0;
	}

	void handleAppActivation (const WPARAM wParam)
	{
		modifiersAtLastCallback = -1;
		updateKeyModifiers();

		if (isMinimised())
		{
			component->repaint();
			handleMovedOrResized();

			if (! ComponentPeer::isValidPeer (this))
				return;
		}

		Component* underMouse = component->getComponentAt (component->getMouseXYRelative());

		if (underMouse == nullptr)
			underMouse = component;

		if (underMouse->isCurrentlyBlockedByAnotherModalComponent())
		{
			if (LOWORD (wParam) == WA_CLICKACTIVE)
				Component::getCurrentlyModalComponent()->inputAttemptWhenModal();
			else
				ModalComponentManager::getInstance()->bringModalComponentsToFront();
		}
		else
		{
			handleBroughtToFront();
		}
	}

	void handleLeftClickInNCArea (WPARAM wParam)
	{
		if (! sendInputAttemptWhenModalMessage())
		{
			switch (wParam)
			{
			case HTBOTTOM:
			case HTBOTTOMLEFT:
			case HTBOTTOMRIGHT:
			case HTGROWBOX:
			case HTLEFT:
			case HTRIGHT:
			case HTTOP:
			case HTTOPLEFT:
			case HTTOPRIGHT:
				if (isConstrainedNativeWindow())
				{
					constrainerIsResizing = true;
					constrainer->resizeStart();
				}
				break;

			default:
				break;
			}
		}
	}

	void initialiseSysMenu (HMENU menu) const
	{
		if (! hasTitleBar())
		{
			if (isFullScreen())
			{
				EnableMenuItem (menu, SC_RESTORE, MF_BYCOMMAND | MF_ENABLED);
				EnableMenuItem (menu, SC_MOVE, MF_BYCOMMAND | MF_GRAYED);
			}
			else if (! isMinimised())
			{
				EnableMenuItem (menu, SC_MAXIMIZE, MF_BYCOMMAND | MF_GRAYED);
			}
		}
	}

	void doSettingChange()
	{
		Desktop::getInstance().refreshMonitorSizes();

		if (fullScreen && ! isMinimised())
		{
			const Rectangle<int> r (component->getParentMonitorArea());

			SetWindowPos (hwnd, 0, r.getX(), r.getY(), r.getWidth(), r.getHeight(),
						  SWP_NOACTIVATE | SWP_NOOWNERZORDER | SWP_NOZORDER | SWP_NOSENDCHANGING);
		}
	}

public:
	static LRESULT CALLBACK windowProc (HWND h, UINT message, WPARAM wParam, LPARAM lParam)
	{
		HWNDComponentPeer* const peer = getOwnerOfWindow (h);

		if (peer != nullptr)
		{
			jassert (isValidPeer (peer));
			return peer->peerWindowProc (h, message, wParam, lParam);
		}

		return DefWindowProcW (h, message, wParam, lParam);
	}

private:
	static void* callFunctionIfNotLocked (MessageCallbackFunction* callback, void* userData)
	{
		if (MessageManager::getInstance()->currentThreadHasLockedMessageManager())
			return callback (userData);
		else
			return MessageManager::getInstance()->callFunctionOnMessageThread (callback, userData);
	}

	static Point<int> getPointFromLParam (LPARAM lParam) noexcept
	{
		return Point<int> (GET_X_LPARAM (lParam), GET_Y_LPARAM (lParam));
	}

	static Point<int> getCurrentMousePosGlobal() noexcept
	{
		const DWORD mp = GetMessagePos();
		return Point<int> (GET_X_LPARAM (mp),
						   GET_Y_LPARAM (mp));
	}

	Point<int> getCurrentMousePos() noexcept
	{
		return globalToLocal (getCurrentMousePosGlobal());
	}

	LRESULT peerWindowProc (HWND h, UINT message, WPARAM wParam, LPARAM lParam)
	{
		switch (message)
		{

			case WM_NCHITTEST:
				if ((styleFlags & windowIgnoresMouseClicks) != 0)
					return HTTRANSPARENT;
				else if (! hasTitleBar())
					return HTCLIENT;

				break;

			case WM_PAINT:
				handlePaintMessage();
				return 0;

			case WM_NCPAINT:
				if (wParam != 1) // (1 = a repaint of the entire NC region)
					handlePaintMessage(); // this must be done, even with native titlebars, or there are rendering artifacts.

				if (hasTitleBar())
					break; // let the DefWindowProc handle drawing the frame.

				return 0;

			case WM_ERASEBKGND:
			case WM_NCCALCSIZE:
				if (hasTitleBar())
					break;

				return 1;

			case WM_MOUSEMOVE:          doMouseMove (getPointFromLParam (lParam)); return 0;
			case WM_MOUSELEAVE:         doMouseExit(); return 0;

			case WM_LBUTTONDOWN:
			case WM_MBUTTONDOWN:
			case WM_RBUTTONDOWN:        doMouseDown (getPointFromLParam (lParam), wParam); return 0;

			case WM_LBUTTONUP:
			case WM_MBUTTONUP:
			case WM_RBUTTONUP:          doMouseUp (getPointFromLParam (lParam), wParam); return 0;

			case WM_CAPTURECHANGED:     doCaptureChanged(); return 0;

			case WM_NCMOUSEMOVE:
				if (hasTitleBar())
					break;

				return 0;

			case 0x020A: /* WM_MOUSEWHEEL */
			case 0x020E: /* WM_MOUSEHWHEEL */
				doMouseWheel (getCurrentMousePosGlobal(), wParam, message == 0x020A);
				return 0;

			case WM_TOUCH:
				if (getTouchInputInfo == nullptr)
					break;

				doTouchEvent ((int) wParam, (HTOUCHINPUT) lParam);
				return 0;

			case WM_SIZING:                return handleSizeConstraining ((RECT*) lParam, wParam);
			case WM_WINDOWPOSCHANGING:     return handlePositionChanging ((WINDOWPOS*) lParam);

			case WM_WINDOWPOSCHANGED:
				{
					const Point<int> pos (getCurrentMousePos());
					if (contains (pos, false))
						doMouseEvent (pos);
				}

				handleMovedOrResized();

				if (dontRepaint)
					break;  // needed for non-accelerated openGL windows to draw themselves correctly..

				return 0;

			case WM_KEYDOWN:
			case WM_SYSKEYDOWN:
				if (doKeyDown (wParam))
					return 0;

				forwardMessageToParent (message, wParam, lParam);
				break;

			case WM_KEYUP:
			case WM_SYSKEYUP:
				if (doKeyUp (wParam))
					return 0;

				forwardMessageToParent (message, wParam, lParam);
				break;

			case WM_CHAR:
				if (doKeyChar ((int) wParam, lParam))
					return 0;

				forwardMessageToParent (message, wParam, lParam);
				break;

			case WM_APPCOMMAND:
				if (doAppCommand (lParam))
					return TRUE;

				break;

			case WM_SETFOCUS:
				updateKeyModifiers();
				handleFocusGain();
				break;

			case WM_KILLFOCUS:
				if (hasCreatedCaret)
				{
					hasCreatedCaret = false;
					DestroyCaret();
				}

				handleFocusLoss();
				break;

			case WM_ACTIVATEAPP:
				// Windows does weird things to process priority when you swap apps,
				// so this forces an update when the app is brought to the front
				if (wParam != FALSE)
					juce_repeatLastProcessPriority();
				else
					Desktop::getInstance().setKioskModeComponent (nullptr); // turn kiosk mode off if we lose focus

				juce_CheckCurrentlyFocusedTopLevelWindow();
				modifiersAtLastCallback = -1;
				return 0;

			case WM_ACTIVATE:
				if (LOWORD (wParam) == WA_ACTIVE || LOWORD (wParam) == WA_CLICKACTIVE)
				{
					handleAppActivation (wParam);
					return 0;
				}

				break;

			case WM_NCACTIVATE:
				// while a temporary window is being shown, prevent Windows from deactivating the
				// title bars of our main windows.
				if (wParam == 0 && ! shouldDeactivateTitleBar)
					wParam = TRUE; // change this and let it get passed to the DefWindowProc.

				break;

			case WM_MOUSEACTIVATE:
				if (! component->getMouseClickGrabsKeyboardFocus())
					return MA_NOACTIVATE;

				break;

			case WM_SHOWWINDOW:
				if (wParam != 0)
					handleBroughtToFront();

				break;

			case WM_CLOSE:
				if (! component->isCurrentlyBlockedByAnotherModalComponent())
					handleUserClosingWindow();

				return 0;

			case WM_QUERYENDSESSION:
				if (JUCEApplication::getInstance() != nullptr)
				{
					JUCEApplication::getInstance()->systemRequestedQuit();
					return MessageManager::getInstance()->hasStopMessageBeenSent();
				}
				return TRUE;

			case WM_SYNCPAINT:
				return 0;

			case WM_DISPLAYCHANGE:
				InvalidateRect (h, 0, 0);
				// intentional fall-through...
			case WM_SETTINGCHANGE:  // note the fall-through in the previous case!
				doSettingChange();
				break;

			case WM_INITMENU:
				initialiseSysMenu ((HMENU) wParam);
				break;

			case WM_SYSCOMMAND:
				switch (wParam & 0xfff0)
				{
				case SC_CLOSE:
					if (sendInputAttemptWhenModalMessage())
						return 0;

					if (hasTitleBar())
					{
						PostMessage (h, WM_CLOSE, 0, 0);
						return 0;
					}
					break;

				case SC_KEYMENU:
					// (NB mustn't call sendInputAttemptWhenModalMessage() here because of very obscure
					// situations that can arise if a modal loop is started from an alt-key keypress).
					if (hasTitleBar() && h == GetCapture())
						ReleaseCapture();

					break;

				case SC_MAXIMIZE:
					if (! sendInputAttemptWhenModalMessage())
						setFullScreen (true);

					return 0;

				case SC_MINIMIZE:
					if (sendInputAttemptWhenModalMessage())
						return 0;

					if (! hasTitleBar())
					{
						setMinimised (true);
						return 0;
					}
					break;

				case SC_RESTORE:
					if (sendInputAttemptWhenModalMessage())
						return 0;

					if (hasTitleBar())
					{
						if (isFullScreen())
						{
							setFullScreen (false);
							return 0;
						}
					}
					else
					{
						if (isMinimised())
							setMinimised (false);
						else if (isFullScreen())
							setFullScreen (false);

						return 0;
					}
					break;
				}

				break;

			case WM_NCLBUTTONDOWN:
				handleLeftClickInNCArea (wParam);
				break;

			case WM_NCRBUTTONDOWN:
			case WM_NCMBUTTONDOWN:
				sendInputAttemptWhenModalMessage();
				break;

			case WM_IME_SETCONTEXT:
				imeHandler.handleSetContext (h, wParam == TRUE);
				lParam &= ~ISC_SHOWUICOMPOSITIONWINDOW;
				break;

			case WM_IME_STARTCOMPOSITION:  imeHandler.handleStartComposition (*this); return 0;
			case WM_IME_ENDCOMPOSITION:    imeHandler.handleEndComposition (*this, h); break;
			case WM_IME_COMPOSITION:       imeHandler.handleComposition (*this, h, lParam); return 0;

			case WM_GETDLGCODE:
				return DLGC_WANTALLKEYS;

			default:
				break;
		}

		return DefWindowProcW (h, message, wParam, lParam);
	}

	bool sendInputAttemptWhenModalMessage()
	{
		if (component->isCurrentlyBlockedByAnotherModalComponent())
		{
			Component* const current = Component::getCurrentlyModalComponent();

			if (current != nullptr)
				current->inputAttemptWhenModal();

			return true;
		}

		return false;
	}

	class IMEHandler
	{
	public:
		IMEHandler()
		{
			reset();
		}

		void handleSetContext (HWND hWnd, const bool windowIsActive)
		{
			if (compositionInProgress && ! windowIsActive)
			{
				compositionInProgress = false;

				HIMC hImc = ImmGetContext (hWnd);
				if (hImc != 0)
				{
					ImmNotifyIME (hImc, NI_COMPOSITIONSTR, CPS_COMPLETE, 0);
					ImmReleaseContext (hWnd, hImc);
				}
			}
		}

		void handleStartComposition (ComponentPeer& owner)
		{
			reset();
			TextInputTarget* const target = owner.findCurrentTextInputTarget();

			if (target != nullptr)
				target->insertTextAtCaret (String::empty);
		}

		void handleEndComposition (ComponentPeer& owner, HWND hWnd)
		{
			if (compositionInProgress)
			{
				// If this occurs, the user has cancelled the composition, so clear their changes..
				TextInputTarget* const target = owner.findCurrentTextInputTarget();

				if (target != nullptr)
				{
					target->setHighlightedRegion (compositionRange);
					target->insertTextAtCaret (String::empty);
					compositionRange.setLength (0);

					target->setHighlightedRegion (Range<int>::emptyRange (compositionRange.getEnd()));
					target->setTemporaryUnderlining (Array<Range<int> >());
				}

				HIMC hImc = ImmGetContext (hWnd);

				if (hImc != 0)
				{
					ImmNotifyIME (hImc, NI_CLOSECANDIDATE, 0, 0);
					ImmReleaseContext (hWnd, hImc);
				}
			}

			reset();
		}

		void handleComposition (ComponentPeer& owner, HWND hWnd, const LPARAM lParam)
		{
			TextInputTarget* const target = owner.findCurrentTextInputTarget();
			HIMC hImc = ImmGetContext (hWnd);

			if (target == nullptr || hImc == 0)
				return;

			if (compositionRange.getStart() < 0)
				compositionRange = Range<int>::emptyRange (target->getHighlightedRegion().getStart());

			if ((lParam & GCS_RESULTSTR) != 0) // (composition has finished)
			{
				replaceCurrentSelection (target, getCompositionString (hImc, GCS_RESULTSTR),
										 Range<int>::emptyRange (-1));

				reset();
				target->setTemporaryUnderlining (Array<Range<int> >());
			}
			else if ((lParam & GCS_COMPSTR) != 0) // (composition is still in-progress)
			{
				replaceCurrentSelection (target, getCompositionString (hImc, GCS_COMPSTR),
										 getCompositionSelection (hImc, lParam));

				target->setTemporaryUnderlining (getCompositionUnderlines (hImc, lParam));
				compositionInProgress = true;
			}

			moveCandidateWindowToLeftAlignWithSelection (hImc, owner, target);
			ImmReleaseContext (hWnd, hImc);
		}

	private:

		Range<int> compositionRange; // The range being modified in the TextInputTarget
		bool compositionInProgress;

		void reset()
		{
			compositionRange = Range<int>::emptyRange (-1);
			compositionInProgress = false;
		}

		String getCompositionString (HIMC hImc, const DWORD type) const
		{
			jassert (hImc != 0);

			const int stringSizeBytes = ImmGetCompositionString (hImc, type, 0, 0);

			if (stringSizeBytes > 0)
			{
				HeapBlock<TCHAR> buffer;
				buffer.calloc (stringSizeBytes / sizeof (TCHAR) + 1);
				ImmGetCompositionString (hImc, type, buffer, (DWORD) stringSizeBytes);
				return String (buffer);
			}

			return String::empty;
		}

		int getCompositionCaretPos (HIMC hImc, LPARAM lParam, const String& currentIMEString) const
		{
			jassert (hImc != 0);

			if ((lParam & CS_NOMOVECARET) != 0)
				return compositionRange.getStart();

			if ((lParam & GCS_CURSORPOS) != 0)
			{
				const int localCaretPos = ImmGetCompositionString (hImc, GCS_CURSORPOS, 0, 0);
				return compositionRange.getStart() + jmax (0, localCaretPos);
			}

			return compositionRange.getStart() + currentIMEString.length();
		}

		// Get selected/highlighted range while doing composition:
		// returned range is relative to beginning of TextInputTarget, not composition string
		Range<int> getCompositionSelection (HIMC hImc, LPARAM lParam) const
		{
			jassert (hImc != 0);
			int selectionStart = 0;
			int selectionEnd = 0;

			if ((lParam & GCS_COMPATTR) != 0)
			{
				// Get size of attributes array:
				const int attributeSizeBytes = ImmGetCompositionString (hImc, GCS_COMPATTR, 0, 0);

				if (attributeSizeBytes > 0)
				{
					// Get attributes (8 bit flag per character):
					HeapBlock<char> attributes ((size_t) attributeSizeBytes);
					ImmGetCompositionString (hImc, GCS_COMPATTR, attributes, (DWORD) attributeSizeBytes);

					selectionStart = 0;

					for (selectionStart = 0; selectionStart < attributeSizeBytes; ++selectionStart)
						if (attributes[selectionStart] == ATTR_TARGET_CONVERTED || attributes[selectionStart] == ATTR_TARGET_NOTCONVERTED)
							break;

					for (selectionEnd = selectionStart; selectionEnd < attributeSizeBytes; ++selectionEnd)
						if (attributes [selectionEnd] != ATTR_TARGET_CONVERTED && attributes[selectionEnd] != ATTR_TARGET_NOTCONVERTED)
							break;
				}
			}

			return Range<int> (selectionStart, selectionEnd) + compositionRange.getStart();
		}

		void replaceCurrentSelection (TextInputTarget* const target, const String& newContent, Range<int> newSelection)
		{
			if (compositionInProgress)
				target->setHighlightedRegion (compositionRange);

			target->insertTextAtCaret (newContent);
			compositionRange.setLength (newContent.length());

			if (newSelection.getStart() < 0)
				newSelection = Range<int>::emptyRange (compositionRange.getEnd());

			target->setHighlightedRegion (newSelection);
		}

		Array<Range<int> > getCompositionUnderlines (HIMC hImc, LPARAM lParam) const
		{
			Array<Range<int> > result;

			if (hImc != 0 && (lParam & GCS_COMPCLAUSE) != 0)
			{
				const int clauseDataSizeBytes = ImmGetCompositionString (hImc, GCS_COMPCLAUSE, 0, 0);

				if (clauseDataSizeBytes > 0)
				{
					const size_t numItems = clauseDataSizeBytes / sizeof (uint32);
					HeapBlock<uint32> clauseData (numItems);

					if (ImmGetCompositionString (hImc, GCS_COMPCLAUSE, clauseData, (DWORD) clauseDataSizeBytes) > 0)
						for (size_t i = 0; i + 1 < numItems; ++i)
							result.add (Range<int> ((int) clauseData [i], (int) clauseData [i + 1]) + compositionRange.getStart());
				}
			}

			return result;
		}

		void moveCandidateWindowToLeftAlignWithSelection (HIMC hImc, ComponentPeer& peer, TextInputTarget* target) const
		{
			Component* const targetComp = dynamic_cast <Component*> (target);

			if (targetComp != nullptr)
			{
				const Rectangle<int> area (peer.getComponent()
											  ->getLocalArea (targetComp, target->getCaretRectangle()));

				CANDIDATEFORM pos = { 0, CFS_CANDIDATEPOS, { area.getX(), area.getBottom() }, { 0, 0, 0, 0 } };
				ImmSetCandidateWindow (hImc, &pos);
			}
		}

		JUCE_DECLARE_NON_COPYABLE (IMEHandler);
	};

	IMEHandler imeHandler;

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (HWNDComponentPeer);
};

ModifierKeys HWNDComponentPeer::currentModifiers;
ModifierKeys HWNDComponentPeer::modifiersAtLastCallback;

ComponentPeer* Component::createNewPeer (int styleFlags, void* nativeWindowToAttachTo)
{
	return new HWNDComponentPeer (this, styleFlags, (HWND) nativeWindowToAttachTo);
}

ComponentPeer* createNonRepaintingEmbeddedWindowsPeer (Component* component, void* parent)
{
	HWNDComponentPeer* const p = new HWNDComponentPeer (component, ComponentPeer::windowIgnoresMouseClicks, (HWND) parent);
	p->dontRepaint = true;
	return p;
}

juce_ImplementSingleton_SingleThreaded (HWNDComponentPeer::WindowClassHolder);

void ModifierKeys::updateCurrentModifiers() noexcept
{
	currentModifiers = HWNDComponentPeer::currentModifiers;
}

ModifierKeys ModifierKeys::getCurrentModifiersRealtime() noexcept
{
	HWNDComponentPeer::updateKeyModifiers();

	int mouseMods = 0;
	if (HWNDComponentPeer::isKeyDown (VK_LBUTTON))  mouseMods |= ModifierKeys::leftButtonModifier;
	if (HWNDComponentPeer::isKeyDown (VK_RBUTTON))  mouseMods |= ModifierKeys::rightButtonModifier;
	if (HWNDComponentPeer::isKeyDown (VK_MBUTTON))  mouseMods |= ModifierKeys::middleButtonModifier;

	HWNDComponentPeer::currentModifiers
		= HWNDComponentPeer::currentModifiers.withoutMouseButtons().withFlags (mouseMods);

	return HWNDComponentPeer::currentModifiers;
}

bool KeyPress::isKeyCurrentlyDown (const int keyCode)
{
	SHORT k = (SHORT) keyCode;

	if ((keyCode & extendedKeyModifier) == 0
		 && (k >= (SHORT) 'a' && k <= (SHORT) 'z'))
		k += (SHORT) 'A' - (SHORT) 'a';

	const SHORT translatedValues[] = { (SHORT) ',', VK_OEM_COMMA,
									   (SHORT) '+', VK_OEM_PLUS,
									   (SHORT) '-', VK_OEM_MINUS,
									   (SHORT) '.', VK_OEM_PERIOD,
									   (SHORT) ';', VK_OEM_1,
									   (SHORT) ':', VK_OEM_1,
									   (SHORT) '/', VK_OEM_2,
									   (SHORT) '?', VK_OEM_2,
									   (SHORT) '[', VK_OEM_4,
									   (SHORT) ']', VK_OEM_6 };

	for (int i = 0; i < numElementsInArray (translatedValues); i += 2)
		if (k == translatedValues [i])
			k = translatedValues [i + 1];

	return HWNDComponentPeer::isKeyDown (k);
}

bool Process::isForegroundProcess()
{
	HWND fg = GetForegroundWindow();

	if (fg == 0)
		return true;

	// when running as a plugin in IE8, the browser UI runs in a different process to the plugin, so
	// process ID isn't a reliable way to check if the foreground window belongs to us - instead, we
	// have to see if any of our windows are children of the foreground window
	fg = GetAncestor (fg, GA_ROOT);

	for (int i = ComponentPeer::getNumPeers(); --i >= 0;)
	{
		HWNDComponentPeer* const wp = dynamic_cast <HWNDComponentPeer*> (ComponentPeer::getPeer (i));

		if (wp != nullptr && wp->isInside (fg))
			return true;
	}

	return false;
}

class WindowsMessageBox  : public AsyncUpdater
{
public:
	WindowsMessageBox (AlertWindow::AlertIconType iconType,
					   const String& title_, const String& message_,
					   Component* associatedComponent,
					   UINT extraFlags,
					   ModalComponentManager::Callback* callback_,
					   const bool runAsync)
		: flags (extraFlags | getMessageBoxFlags (iconType)),
		  owner (getWindowForMessageBox (associatedComponent)),
		  title (title_), message (message_), callback (callback_)
	{
		if (runAsync)
			triggerAsyncUpdate();
	}

	int getResult() const
	{
		const int r = MessageBox (owner, message.toWideCharPointer(), title.toWideCharPointer(), flags);
		return (r == IDYES || r == IDOK) ? 1 : (r == IDNO ? 2 : 0);
	}

	void handleAsyncUpdate()
	{
		const int result = getResult();

		if (callback != nullptr)
			callback->modalStateFinished (result);

		delete this;
	}

private:
	UINT flags;
	HWND owner;
	String title, message;
	ModalComponentManager::Callback* callback;

	static UINT getMessageBoxFlags (AlertWindow::AlertIconType iconType) noexcept
	{
		UINT flags = MB_TASKMODAL | MB_SETFOREGROUND;

		switch (iconType)
		{
			case AlertWindow::QuestionIcon:  flags |= MB_ICONQUESTION; break;
			case AlertWindow::WarningIcon:   flags |= MB_ICONWARNING; break;
			case AlertWindow::InfoIcon:      flags |= MB_ICONINFORMATION; break;
			default: break;
		}

		return flags;
	}

	static HWND getWindowForMessageBox (Component* associatedComponent)
	{
		return associatedComponent != nullptr ? (HWND) associatedComponent->getWindowHandle() : 0;
	}
};

void JUCE_CALLTYPE NativeMessageBox::showMessageBox (AlertWindow::AlertIconType iconType,
													 const String& title, const String& message,
													 Component* associatedComponent)
{
	WindowsMessageBox box (iconType, title, message, associatedComponent, MB_OK, 0, false);
	(void) box.getResult();
}

void JUCE_CALLTYPE NativeMessageBox::showMessageBoxAsync (AlertWindow::AlertIconType iconType,
														  const String& title, const String& message,
														  Component* associatedComponent)
{
	new WindowsMessageBox (iconType, title, message, associatedComponent, MB_OK, 0, true);
}

bool JUCE_CALLTYPE NativeMessageBox::showOkCancelBox (AlertWindow::AlertIconType iconType,
													  const String& title, const String& message,
													  Component* associatedComponent,
													  ModalComponentManager::Callback* callback)
{
	ScopedPointer<WindowsMessageBox> mb (new WindowsMessageBox (iconType, title, message, associatedComponent,
																MB_OKCANCEL, callback, callback != nullptr));
	if (callback == nullptr)
		return mb->getResult() != 0;

	mb.release();
	return false;
}

int JUCE_CALLTYPE NativeMessageBox::showYesNoCancelBox (AlertWindow::AlertIconType iconType,
														const String& title, const String& message,
														Component* associatedComponent,
														ModalComponentManager::Callback* callback)
{
	ScopedPointer<WindowsMessageBox> mb (new WindowsMessageBox (iconType, title, message, associatedComponent,
																MB_YESNOCANCEL, callback, callback != nullptr));
	if (callback == nullptr)
		return mb->getResult();

	mb.release();
	return 0;
}

void Desktop::createMouseInputSources()
{
	mouseSources.add (new MouseInputSource (0, true));

	if (canUseMultiTouch())
		for (int i = 1; i <= 10; ++i)
			mouseSources.add (new MouseInputSource (i, false));
}

Point<int> MouseInputSource::getCurrentMousePosition()
{
	POINT mousePos;
	GetCursorPos (&mousePos);
	return Point<int> (mousePos.x, mousePos.y);
}

void Desktop::setMousePosition (const Point<int>& newPosition)
{
	SetCursorPos (newPosition.x, newPosition.y);
}

ImagePixelData* NativeImageType::create (Image::PixelFormat format, int width, int height, bool clearImage) const
{
	return SoftwareImageType().create (format, width, height, clearImage);
}

class ScreenSaverDefeater   : public Timer
{
public:
	ScreenSaverDefeater()
	{
		startTimer (10000);
		timerCallback();
	}

	void timerCallback()
	{
		if (Process::isForegroundProcess())
		{
			// simulate a shift key getting pressed..
			INPUT input[2];
			input[0].type = INPUT_KEYBOARD;
			input[0].ki.wVk = VK_SHIFT;
			input[0].ki.dwFlags = 0;
			input[0].ki.dwExtraInfo = 0;

			input[1].type = INPUT_KEYBOARD;
			input[1].ki.wVk = VK_SHIFT;
			input[1].ki.dwFlags = KEYEVENTF_KEYUP;
			input[1].ki.dwExtraInfo = 0;

			SendInput (2, input, sizeof (INPUT));
		}
	}
};

static ScopedPointer<ScreenSaverDefeater> screenSaverDefeater;

void Desktop::setScreenSaverEnabled (const bool isEnabled)
{
	if (isEnabled)
		screenSaverDefeater = nullptr;
	else if (screenSaverDefeater == nullptr)
		screenSaverDefeater = new ScreenSaverDefeater();
}

bool Desktop::isScreenSaverEnabled()
{
	return screenSaverDefeater == nullptr;
}

/* (The code below is the "correct" way to disable the screen saver, but it
	completely fails on winXP when the saver is password-protected...)

static bool juce_screenSaverEnabled = true;

void Desktop::setScreenSaverEnabled (const bool isEnabled) noexcept
{
	juce_screenSaverEnabled = isEnabled;
	SetThreadExecutionState (isEnabled ? ES_CONTINUOUS
									   : (ES_DISPLAY_REQUIRED | ES_CONTINUOUS));
}

bool Desktop::isScreenSaverEnabled() noexcept
{
	return juce_screenSaverEnabled;
}
*/

void LookAndFeel::playAlertSound()
{
	MessageBeep (MB_OK);
}

void SystemClipboard::copyTextToClipboard (const String& text)
{
	if (OpenClipboard (0) != 0)
	{
		if (EmptyClipboard() != 0)
		{
			const size_t bytesNeeded = CharPointer_UTF16::getBytesRequiredFor (text.getCharPointer()) + 4;

			if (bytesNeeded > 0)
			{
				HGLOBAL bufH = GlobalAlloc (GMEM_MOVEABLE | GMEM_DDESHARE | GMEM_ZEROINIT, bytesNeeded + sizeof (WCHAR));

				if (bufH != 0)
				{
					WCHAR* const data = static_cast <WCHAR*> (GlobalLock (bufH));

					if (data != nullptr)
					{
						text.copyToUTF16 (data, (int) bytesNeeded);
						GlobalUnlock (bufH);

						SetClipboardData (CF_UNICODETEXT, bufH);
					}
				}
			}
		}

		CloseClipboard();
	}
}

String SystemClipboard::getTextFromClipboard()
{
	String result;

	if (OpenClipboard (0) != 0)
	{
		HANDLE bufH = GetClipboardData (CF_UNICODETEXT);

		if (bufH != 0)
		{
			const WCHAR* const data = (const WCHAR*) GlobalLock (bufH);

			if (data != nullptr)
			{
				result = String (data, (size_t) (GlobalSize (bufH) / sizeof (WCHAR)));
				GlobalUnlock (bufH);
			}
		}

		CloseClipboard();
	}

	return result;
}

void Desktop::setKioskComponent (Component* kioskModeComponent, bool enableOrDisable, bool /*allowMenusAndBars*/)
{
	if (enableOrDisable)
		kioskModeComponent->setBounds (Desktop::getInstance().getMainMonitorArea (false));
}

static BOOL CALLBACK enumMonitorsProc (HMONITOR, HDC, LPRECT r, LPARAM userInfo)
{
	Array <Rectangle<int> >* const monitorCoords = (Array <Rectangle<int> >*) userInfo;
	monitorCoords->add (Rectangle<int> (r->left, r->top, r->right - r->left, r->bottom - r->top));
	return TRUE;
}

void Desktop::getCurrentMonitorPositions (Array <Rectangle<int> >& monitorCoords, const bool clipToWorkArea)
{
	EnumDisplayMonitors (0, 0, &enumMonitorsProc, (LPARAM) &monitorCoords);

	// make sure the first in the list is the main monitor
	for (int i = 1; i < monitorCoords.size(); ++i)
		if (monitorCoords[i].getX() == 0 && monitorCoords[i].getY() == 0)
			monitorCoords.swap (i, 0);

	if (monitorCoords.size() == 0)
	{
		RECT r;
		GetWindowRect (GetDesktopWindow(), &r);

		monitorCoords.add (Rectangle<int> (r.left, r.top, r.right - r.left, r.bottom - r.top));
	}

	if (clipToWorkArea)
	{
		// clip the main monitor to the active non-taskbar area
		RECT r;
		SystemParametersInfo (SPI_GETWORKAREA, 0, &r, 0);

		Rectangle<int>& screen = monitorCoords.getReference (0);

		screen.setPosition (jmax (screen.getX(), (int) r.left),
							jmax (screen.getY(), (int) r.top));

		screen.setSize (jmin (screen.getRight(),  (int) r.right)  - screen.getX(),
						jmin (screen.getBottom(), (int) r.bottom) - screen.getY());
	}
}

static HICON extractFileHICON (const File& file)
{
	WORD iconNum = 0;
	WCHAR name [MAX_PATH * 2];
	file.getFullPathName().copyToUTF16 (name, sizeof (name));

	return ExtractAssociatedIcon ((HINSTANCE) Process::getCurrentModuleInstanceHandle(),
								  name, &iconNum);
}

Image juce_createIconForFile (const File& file)
{
	Image image;
	HICON icon = extractFileHICON (file);

	if (icon != 0)
	{
		image = IconConverters::createImageFromHICON (icon);
		DestroyIcon (icon);
	}

	return image;
}

void* MouseCursor::createMouseCursorFromImage (const Image& image, int hotspotX, int hotspotY)
{
	const int maxW = GetSystemMetrics (SM_CXCURSOR);
	const int maxH = GetSystemMetrics (SM_CYCURSOR);

	Image im (image);

	if (im.getWidth() > maxW || im.getHeight() > maxH)
	{
		im = im.rescaled (maxW, maxH);

		hotspotX = (hotspotX * maxW) / image.getWidth();
		hotspotY = (hotspotY * maxH) / image.getHeight();
	}

	return IconConverters::createHICONFromImage (im, FALSE, hotspotX, hotspotY);
}

void MouseCursor::deleteMouseCursor (void* const cursorHandle, const bool isStandard)
{
	if (cursorHandle != nullptr && ! isStandard)
		DestroyCursor ((HCURSOR) cursorHandle);
}

enum
{
	hiddenMouseCursorHandle = 32500 // (arbitrary non-zero value to mark this type of cursor)
};

void* MouseCursor::createStandardMouseCursor (const MouseCursor::StandardCursorType type)
{
	LPCTSTR cursorName = IDC_ARROW;

	switch (type)
	{
		case NormalCursor:                  break;
		case NoCursor:                      return (void*) hiddenMouseCursorHandle;
		case WaitCursor:                    cursorName = IDC_WAIT; break;
		case IBeamCursor:                   cursorName = IDC_IBEAM; break;
		case PointingHandCursor:            cursorName = MAKEINTRESOURCE(32649); break;
		case CrosshairCursor:               cursorName = IDC_CROSS; break;
		case CopyingCursor:                 break; // can't seem to find one of these in the system list..

		case LeftRightResizeCursor:
		case LeftEdgeResizeCursor:
		case RightEdgeResizeCursor:         cursorName = IDC_SIZEWE; break;

		case UpDownResizeCursor:
		case TopEdgeResizeCursor:
		case BottomEdgeResizeCursor:        cursorName = IDC_SIZENS; break;

		case TopLeftCornerResizeCursor:
		case BottomRightCornerResizeCursor: cursorName = IDC_SIZENWSE; break;

		case TopRightCornerResizeCursor:
		case BottomLeftCornerResizeCursor:  cursorName = IDC_SIZENESW; break;

		case UpDownLeftRightResizeCursor:   cursorName = IDC_SIZEALL; break;

		case DraggingHandCursor:
		{
			static void* dragHandCursor = nullptr;

			if (dragHandCursor == nullptr)
			{
				static const unsigned char dragHandData[] =
					{ 71,73,70,56,57,97,16,0,16,0,145,2,0,0,0,0,255,255,255,0,0,0,0,0,0,33,249,4,1,0,0,2,0,44,0,0,0,0,16,0,
					  16,0,0,2,52,148,47,0,200,185,16,130,90,12,74,139,107,84,123,39,132,117,151,116,132,146,248,60,209,138,
					  98,22,203,114,34,236,37,52,77,217,247,154,191,119,110,240,193,128,193,95,163,56,60,234,98,135,2,0,59 };

				dragHandCursor = createMouseCursorFromImage (ImageFileFormat::loadFrom (dragHandData, sizeof (dragHandData)), 8, 7);
			}

			return dragHandCursor;
		}

		default:
			jassertfalse; break;
	}

	HCURSOR cursorH = LoadCursor (0, cursorName);

	if (cursorH == 0)
		cursorH = LoadCursor (0, IDC_ARROW);

	return cursorH;
}

void MouseCursor::showInWindow (ComponentPeer*) const
{
	HCURSOR c = (HCURSOR) getHandle();

	if (c == 0)
		c = LoadCursor (0, IDC_ARROW);
	else if (c == (HCURSOR) hiddenMouseCursorHandle)
		c = 0;

	SetCursor (c);
}

void MouseCursor::showInAllWindows() const
{
	showInWindow (nullptr);
}

/*** End of inlined file: juce_win32_Windowing.cpp ***/


/*** Start of inlined file: juce_win32_DragAndDrop.cpp ***/
namespace DragAndDropHelpers
{

	class JuceDropSource   : public ComBaseClassHelper <IDropSource>
	{
	public:
		JuceDropSource() {}

		JUCE_COMRESULT QueryContinueDrag (BOOL escapePressed, DWORD keys)
		{
			if (escapePressed)
				return DRAGDROP_S_CANCEL;

			if ((keys & (MK_LBUTTON | MK_RBUTTON)) == 0)
				return DRAGDROP_S_DROP;

			return S_OK;
		}

		JUCE_COMRESULT GiveFeedback (DWORD)
		{
			return DRAGDROP_S_USEDEFAULTCURSORS;
		}
	};

	class JuceEnumFormatEtc   : public ComBaseClassHelper <IEnumFORMATETC>
	{
	public:
		JuceEnumFormatEtc (const FORMATETC* const format_)
			: format (format_),
			  index (0)
		{
		}

		JUCE_COMRESULT Clone (IEnumFORMATETC** result)
		{
			if (result == 0)
				return E_POINTER;

			JuceEnumFormatEtc* const newOne = new JuceEnumFormatEtc (format);
			newOne->index = index;

			*result = newOne;
			return S_OK;
		}

		JUCE_COMRESULT Next (ULONG celt, LPFORMATETC lpFormatEtc, ULONG* pceltFetched)
		{
			if (pceltFetched != nullptr)
				*pceltFetched = 0;
			else if (celt != 1)
				return S_FALSE;

			if (index == 0 && celt > 0 && lpFormatEtc != 0)
			{
				copyFormatEtc (lpFormatEtc [0], *format);
				++index;

				if (pceltFetched != nullptr)
					*pceltFetched = 1;

				return S_OK;
			}

			return S_FALSE;
		}

		JUCE_COMRESULT Skip (ULONG celt)
		{
			if (index + (int) celt >= 1)
				return S_FALSE;

			index += celt;
			return S_OK;
		}

		JUCE_COMRESULT Reset()
		{
			index = 0;
			return S_OK;
		}

	private:
		const FORMATETC* const format;
		int index;

		static void copyFormatEtc (FORMATETC& dest, const FORMATETC& source)
		{
			dest = source;

			if (source.ptd != 0)
			{
				dest.ptd = (DVTARGETDEVICE*) CoTaskMemAlloc (sizeof (DVTARGETDEVICE));
				*(dest.ptd) = *(source.ptd);
			}
		}

		JUCE_DECLARE_NON_COPYABLE (JuceEnumFormatEtc);
	};

	class JuceDataObject  : public ComBaseClassHelper <IDataObject>
	{
	public:
		JuceDataObject (JuceDropSource* const dropSource_,
						const FORMATETC* const format_,
						const STGMEDIUM* const medium_)
			: dropSource (dropSource_),
			  format (format_),
			  medium (medium_)
		{
		}

		~JuceDataObject()
		{
			jassert (refCount == 0);
		}

		JUCE_COMRESULT GetData (FORMATETC* pFormatEtc, STGMEDIUM* pMedium)
		{
			if ((pFormatEtc->tymed & format->tymed) != 0
				 && pFormatEtc->cfFormat == format->cfFormat
				 && pFormatEtc->dwAspect == format->dwAspect)
			{
				pMedium->tymed = format->tymed;
				pMedium->pUnkForRelease = 0;

				if (format->tymed == TYMED_HGLOBAL)
				{
					const SIZE_T len = GlobalSize (medium->hGlobal);
					void* const src = GlobalLock (medium->hGlobal);
					void* const dst = GlobalAlloc (GMEM_FIXED, len);

					memcpy (dst, src, len);

					GlobalUnlock (medium->hGlobal);

					pMedium->hGlobal = dst;
					return S_OK;
				}
			}

			return DV_E_FORMATETC;
		}

		JUCE_COMRESULT QueryGetData (FORMATETC* f)
		{
			if (f == 0)
				return E_INVALIDARG;

			if (f->tymed == format->tymed
				  && f->cfFormat == format->cfFormat
				  && f->dwAspect == format->dwAspect)
				return S_OK;

			return DV_E_FORMATETC;
		}

		JUCE_COMRESULT GetCanonicalFormatEtc (FORMATETC*, FORMATETC* pFormatEtcOut)
		{
			pFormatEtcOut->ptd = 0;
			return E_NOTIMPL;
		}

		JUCE_COMRESULT EnumFormatEtc (DWORD direction, IEnumFORMATETC** result)
		{
			if (result == 0)
				return E_POINTER;

			if (direction == DATADIR_GET)
			{
				*result = new JuceEnumFormatEtc (format);
				return S_OK;
			}

			*result = 0;
			return E_NOTIMPL;
		}

		JUCE_COMRESULT GetDataHere (FORMATETC*, STGMEDIUM*)                  { return DATA_E_FORMATETC; }
		JUCE_COMRESULT SetData (FORMATETC*, STGMEDIUM*, BOOL)                { return E_NOTIMPL; }
		JUCE_COMRESULT DAdvise (FORMATETC*, DWORD, IAdviseSink*, DWORD*)     { return OLE_E_ADVISENOTSUPPORTED; }
		JUCE_COMRESULT DUnadvise (DWORD)                                     { return E_NOTIMPL; }
		JUCE_COMRESULT EnumDAdvise (IEnumSTATDATA**)                         { return OLE_E_ADVISENOTSUPPORTED; }

	private:
		JuceDropSource* const dropSource;
		const FORMATETC* const format;
		const STGMEDIUM* const medium;

		JUCE_DECLARE_NON_COPYABLE (JuceDataObject);
	};

	HDROP createHDrop (const StringArray& fileNames)
	{
		int totalBytes = 0;
		for (int i = fileNames.size(); --i >= 0;)
			totalBytes += (int) CharPointer_UTF16::getBytesRequiredFor (fileNames[i].getCharPointer()) + sizeof (WCHAR);

		HDROP hDrop = (HDROP) GlobalAlloc (GMEM_MOVEABLE | GMEM_ZEROINIT, sizeof (DROPFILES) + totalBytes + 4);

		if (hDrop != 0)
		{
			LPDROPFILES pDropFiles = (LPDROPFILES) GlobalLock (hDrop);
			pDropFiles->pFiles = sizeof (DROPFILES);
			pDropFiles->fWide = true;

			WCHAR* fname = reinterpret_cast<WCHAR*> (addBytesToPointer (pDropFiles, sizeof (DROPFILES)));

			for (int i = 0; i < fileNames.size(); ++i)
			{
				const int bytesWritten = fileNames[i].copyToUTF16 (fname, 2048);
				fname = reinterpret_cast<WCHAR*> (addBytesToPointer (fname, bytesWritten));
			}

			*fname = 0;

			GlobalUnlock (hDrop);
		}

		return hDrop;
	}

	bool performDragDrop (FORMATETC* const format, STGMEDIUM* const medium, const DWORD whatToDo)
	{
		JuceDropSource* const source = new JuceDropSource();
		JuceDataObject* const data = new JuceDataObject (source, format, medium);

		DWORD effect;
		const HRESULT res = DoDragDrop (data, source, whatToDo, &effect);

		data->Release();
		source->Release();

		return res == DRAGDROP_S_DROP;
	}
}

bool DragAndDropContainer::performExternalDragDropOfFiles (const StringArray& files, const bool canMove)
{
	FORMATETC format = { CF_HDROP, 0, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
	STGMEDIUM medium = { TYMED_HGLOBAL, { 0 }, 0 };

	medium.hGlobal = DragAndDropHelpers::createHDrop (files);

	return DragAndDropHelpers::performDragDrop (&format, &medium, canMove ? (DWORD) (DROPEFFECT_COPY | DROPEFFECT_MOVE)
																		  : (DWORD) DROPEFFECT_COPY);
}

bool DragAndDropContainer::performExternalDragDropOfText (const String& text)
{
	FORMATETC format = { CF_TEXT, 0, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
	STGMEDIUM medium = { TYMED_HGLOBAL, { 0 }, 0 };

	const size_t numBytes = CharPointer_UTF16::getBytesRequiredFor (text.getCharPointer());

	medium.hGlobal = GlobalAlloc (GMEM_MOVEABLE | GMEM_ZEROINIT, numBytes + 2);
	WCHAR* const data = static_cast <WCHAR*> (GlobalLock (medium.hGlobal));

	text.copyToUTF16 (data, (int) numBytes);
	format.cfFormat = CF_UNICODETEXT;

	GlobalUnlock (medium.hGlobal);

	return DragAndDropHelpers::performDragDrop (&format, &medium, DROPEFFECT_COPY | DROPEFFECT_MOVE);
}

/*** End of inlined file: juce_win32_DragAndDrop.cpp ***/


/*** Start of inlined file: juce_win32_FileChooser.cpp ***/
namespace FileChooserHelpers
{
	static bool areThereAnyAlwaysOnTopWindows()
	{
		for (int i = Desktop::getInstance().getNumComponents(); --i >= 0;)
		{
			Component* const c = Desktop::getInstance().getComponent (i);

			if (c != nullptr && c->isAlwaysOnTop() && c->isShowing())
				return true;
		}

		return false;
	}

	struct FileChooserCallbackInfo
	{
		String initialPath;
		String returnedString; // need this to get non-existent pathnames from the directory chooser
		ScopedPointer<Component> customComponent;
	};

	static int CALLBACK browseCallbackProc (HWND hWnd, UINT msg, LPARAM lParam, LPARAM lpData)
	{
		FileChooserCallbackInfo* info = (FileChooserCallbackInfo*) lpData;

		if (msg == BFFM_INITIALIZED)
			SendMessage (hWnd, BFFM_SETSELECTIONW, TRUE, (LPARAM) info->initialPath.toWideCharPointer());
		else if (msg == BFFM_VALIDATEFAILEDW)
			info->returnedString = (LPCWSTR) lParam;
		else if (msg == BFFM_VALIDATEFAILEDA)
			info->returnedString = (const char*) lParam;

		return 0;
	}

	static UINT_PTR CALLBACK openCallback (HWND hdlg, UINT uiMsg, WPARAM /*wParam*/, LPARAM lParam)
	{
		if (uiMsg == WM_INITDIALOG)
		{
			Component* customComp = ((FileChooserCallbackInfo*) (((OPENFILENAMEW*) lParam)->lCustData))->customComponent;

			HWND dialogH = GetParent (hdlg);
			jassert (dialogH != 0);
			if (dialogH == 0)
				dialogH = hdlg;

			RECT r, cr;
			GetWindowRect (dialogH, &r);
			GetClientRect (dialogH, &cr);

			SetWindowPos (dialogH, 0,
						  r.left, r.top,
						  customComp->getWidth() + jmax (150, (int) (r.right - r.left)),
						  jmax (150, (int) (r.bottom - r.top)),
						  SWP_NOACTIVATE | SWP_NOOWNERZORDER | SWP_NOZORDER);

			customComp->setBounds (cr.right, cr.top, customComp->getWidth(), cr.bottom - cr.top);
			customComp->addToDesktop (0, dialogH);
		}
		else if (uiMsg == WM_NOTIFY)
		{
			LPOFNOTIFY ofn = (LPOFNOTIFY) lParam;

			if (ofn->hdr.code == CDN_SELCHANGE)
			{
				FileChooserCallbackInfo* info = (FileChooserCallbackInfo*) ofn->lpOFN->lCustData;
				FilePreviewComponent* comp = dynamic_cast<FilePreviewComponent*> (info->customComponent->getChildComponent(0));

				if (comp != nullptr)
				{
					WCHAR path [MAX_PATH * 2] = { 0 };
					CommDlg_OpenSave_GetFilePath (GetParent (hdlg), (LPARAM) &path, MAX_PATH);

					comp->selectedFileChanged (File (path));
				}
			}
		}

		return 0;
	}

	class CustomComponentHolder  : public Component
	{
	public:
		CustomComponentHolder (Component* const customComp)
		{
			setVisible (true);
			setOpaque (true);
			addAndMakeVisible (customComp);
			setSize (jlimit (20, 800, customComp->getWidth()), customComp->getHeight());
		}

		void paint (Graphics& g)
		{
			g.fillAll (Colours::lightgrey);
		}

		void resized()
		{
			Component* const c = getChildComponent(0);
			if (c != nullptr)
				c->setBounds (getLocalBounds());
		}

	private:
		JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (CustomComponentHolder);
	};
}

bool FileChooser::isPlatformDialogAvailable()
{
	return true;
}

void FileChooser::showPlatformDialog (Array<File>& results, const String& title_, const File& currentFileOrDirectory,
									  const String& filter, bool selectsDirectory, bool /*selectsFiles*/,
									  bool isSaveDialogue, bool warnAboutOverwritingExistingFiles,
									  bool selectMultipleFiles, FilePreviewComponent* extraInfoComponent)
{
	using namespace FileChooserHelpers;

	const String title (title_);
	HeapBlock<WCHAR> files;
	const int charsAvailableForResult = 32768;
	files.calloc (charsAvailableForResult + 1);
	int filenameOffset = 0;

	FileChooserCallbackInfo info;

	// use a modal window as the parent for this dialog box
	// to block input from other app windows
	Component parentWindow (String::empty);
	const Rectangle<int> mainMon (Desktop::getInstance().getMainMonitorArea());
	parentWindow.setBounds (mainMon.getX() + mainMon.getWidth() / 4,
							mainMon.getY() + mainMon.getHeight() / 4,
							0, 0);
	parentWindow.setOpaque (true);
	parentWindow.setAlwaysOnTop (areThereAnyAlwaysOnTopWindows());
	parentWindow.addToDesktop (0);

	if (extraInfoComponent == nullptr)
		parentWindow.enterModalState();

	if (currentFileOrDirectory.isDirectory())
	{
		info.initialPath = currentFileOrDirectory.getFullPathName();
	}
	else
	{
		currentFileOrDirectory.getFileName().copyToUTF16 (files, charsAvailableForResult * sizeof (WCHAR));
		info.initialPath = currentFileOrDirectory.getParentDirectory().getFullPathName();
	}

	if (selectsDirectory)
	{
		BROWSEINFO bi = { 0 };
		bi.hwndOwner = (HWND) parentWindow.getWindowHandle();
		bi.pszDisplayName = files;
		bi.lpszTitle = title.toWideCharPointer();
		bi.lParam = (LPARAM) &info;
		bi.lpfn = browseCallbackProc;
	   #ifdef BIF_USENEWUI
		bi.ulFlags = BIF_USENEWUI | BIF_VALIDATE;
	   #else
		bi.ulFlags = 0x50;
	   #endif

		LPITEMIDLIST list = SHBrowseForFolder (&bi);

		if (! SHGetPathFromIDListW (list, files))
		{
			files[0] = 0;
			info.returnedString = String::empty;
		}

		LPMALLOC al;
		if (list != 0 && SUCCEEDED (SHGetMalloc (&al)))
			al->Free (list);

		if (info.returnedString.isNotEmpty())
		{
			results.add (File (String (files)).getSiblingFile (info.returnedString));
			return;
		}
	}
	else
	{
		DWORD flags = OFN_EXPLORER | OFN_PATHMUSTEXIST | OFN_NOCHANGEDIR | OFN_HIDEREADONLY;

		if (warnAboutOverwritingExistingFiles)
			flags |= OFN_OVERWRITEPROMPT;

		if (selectMultipleFiles)
			flags |= OFN_ALLOWMULTISELECT;

		if (extraInfoComponent != nullptr)
		{
			flags |= OFN_ENABLEHOOK;

			info.customComponent = new CustomComponentHolder (extraInfoComponent);
			info.customComponent->enterModalState();
		}

		const int filterSpaceNumChars = 2048;
		HeapBlock<WCHAR> filters;
		filters.calloc (filterSpaceNumChars);
		const int bytesWritten = filter.copyToUTF16 (filters.getData(), filterSpaceNumChars * sizeof (WCHAR));
		filter.copyToUTF16 (filters + (bytesWritten / sizeof (WCHAR)),
							(int) ((filterSpaceNumChars - 1) * sizeof (WCHAR) - bytesWritten));

		OPENFILENAMEW of = { 0 };
		String localPath (info.initialPath);

	   #ifdef OPENFILENAME_SIZE_VERSION_400W
		of.lStructSize = OPENFILENAME_SIZE_VERSION_400W;
	   #else
		of.lStructSize = sizeof (of);
	   #endif
		of.hwndOwner = (HWND) parentWindow.getWindowHandle();
		of.lpstrFilter = filters.getData();
		of.nFilterIndex = 1;
		of.lpstrFile = files;
		of.nMaxFile = charsAvailableForResult;
		of.lpstrInitialDir = localPath.toWideCharPointer();
		of.lpstrTitle = title.toWideCharPointer();
		of.Flags = flags;
		of.lCustData = (LPARAM) &info;

		if (extraInfoComponent != nullptr)
			of.lpfnHook = &openCallback;

		if (! (isSaveDialogue ? GetSaveFileName (&of)
							  : GetOpenFileName (&of)))
			return;

		filenameOffset = of.nFileOffset;
	}

	if (selectMultipleFiles && filenameOffset > 0 && files [filenameOffset - 1] == 0)
	{
		const WCHAR* filename = files + filenameOffset;

		while (*filename != 0)
		{
			results.add (File (String (files) + "\\" + String (filename)));
			filename += wcslen (filename) + 1;
		}
	}
	else if (files[0] != 0)
	{
		results.add (File (String (files)));
	}
}

/*** End of inlined file: juce_win32_FileChooser.cpp ***/

#elif JUCE_LINUX

/*** Start of inlined file: juce_linux_Clipboard.cpp ***/
extern Display* display;
extern Window juce_messageWindowHandle;

namespace ClipboardHelpers
{
	static String localClipboardContent;
	static Atom   atom_UTF8_STRING;
	static Atom   atom_CLIPBOARD;
	static Atom   atom_TARGETS;

	void initSelectionAtoms()
	{
		static bool isInitialised = false;
		if (! isInitialised)
		{
			atom_UTF8_STRING = XInternAtom (display, "UTF8_STRING", False);
			atom_CLIPBOARD   = XInternAtom (display, "CLIPBOARD", False);
			atom_TARGETS     = XInternAtom (display, "TARGETS", False);
		}
	}

	// Read the content of a window property as either a locale-dependent string or an utf8 string
	// works only for strings shorter than 1000000 bytes
	String readWindowProperty (Window window, Atom prop, Atom fmt)
	{
		String returnData;
		char* clipData;
		Atom actualType;
		int  actualFormat;
		unsigned long numItems, bytesLeft;

		if (XGetWindowProperty (display, window, prop,
								0L /* offset */, 1000000 /* length (max) */, False,
								AnyPropertyType /* format */,
								&actualType, &actualFormat, &numItems, &bytesLeft,
								(unsigned char**) &clipData) == Success)
		{
			if (actualType == atom_UTF8_STRING && actualFormat == 8)
				returnData = String::fromUTF8 (clipData, numItems);
			else if (actualType == XA_STRING && actualFormat == 8)
				returnData = String (clipData, numItems);

			if (clipData != nullptr)
				XFree (clipData);

			jassert (bytesLeft == 0 || numItems == 1000000);
		}

		XDeleteProperty (display, window, prop);
		return returnData;
	}

	// Send a SelectionRequest to the window owning the selection and waits for its answer (with a timeout) */
	bool requestSelectionContent (String& selectionContent, Atom selection, Atom requestedFormat)
	{
		Atom property_name = XInternAtom (display, "JUCE_SEL", false);

		// The selection owner will be asked to set the JUCE_SEL property on the
		// juce_messageWindowHandle with the selection content
		XConvertSelection (display, selection, requestedFormat, property_name,
						   juce_messageWindowHandle, CurrentTime);

		int count = 50; // will wait at most for 200 ms

		while (--count >= 0)
		{
			XEvent event;
			if (XCheckTypedWindowEvent (display, juce_messageWindowHandle, SelectionNotify, &event))
			{
				if (event.xselection.property == property_name)
				{
					jassert (event.xselection.requestor == juce_messageWindowHandle);

					selectionContent = readWindowProperty (event.xselection.requestor,
														   event.xselection.property,
														   requestedFormat);
					return true;
				}
				else
				{
					return false; // the format we asked for was denied.. (event.xselection.property == None)
				}
			}

			// not very elegant.. we could do a select() or something like that...
			// however clipboard content requesting is inherently slow on x11, it
			// often takes 50ms or more so...
			Thread::sleep (4);
		}

		return false;
	}
}

// Called from the event loop in juce_linux_Messaging in response to SelectionRequest events
void juce_handleSelectionRequest (XSelectionRequestEvent &evt)
{
	ClipboardHelpers::initSelectionAtoms();

	// the selection content is sent to the target window as a window property
	XSelectionEvent reply;
	reply.type = SelectionNotify;
	reply.display = evt.display;
	reply.requestor = evt.requestor;
	reply.selection = evt.selection;
	reply.target = evt.target;
	reply.property = None; // == "fail"
	reply.time = evt.time;

	HeapBlock <char> data;
	int propertyFormat = 0, numDataItems = 0;

	if (evt.selection == XA_PRIMARY || evt.selection == ClipboardHelpers::atom_CLIPBOARD)
	{
		if (evt.target == XA_STRING || evt.target == ClipboardHelpers::atom_UTF8_STRING)
		{
			// translate to utf8
			numDataItems = ClipboardHelpers::localClipboardContent.getNumBytesAsUTF8() + 1;
			data.calloc (numDataItems + 1);
			ClipboardHelpers::localClipboardContent.copyToUTF8 (data, numDataItems);
			propertyFormat = 8; // bits/item
		}
		else if (evt.target == ClipboardHelpers::atom_TARGETS)
		{
			// another application wants to know what we are able to send
			numDataItems = 2;
			propertyFormat = 32; // atoms are 32-bit
			data.calloc (numDataItems * 4);
			Atom* atoms = reinterpret_cast<Atom*> (data.getData());
			atoms[0] = ClipboardHelpers::atom_UTF8_STRING;
			atoms[1] = XA_STRING;

			evt.target = XA_ATOM;
		}
	}
	else
	{
		DBG ("requested unsupported clipboard");
	}

	if (data != nullptr)
	{
		const int maxReasonableSelectionSize = 1000000;

		// for very big chunks of data, we should use the "INCR" protocol , which is a pain in the *ss
		if (evt.property != None && numDataItems < maxReasonableSelectionSize)
		{
			XChangeProperty (evt.display, evt.requestor,
							 evt.property, evt.target,
							 propertyFormat /* 8 or 32 */, PropModeReplace,
							 reinterpret_cast<const unsigned char*> (data.getData()), numDataItems);
			reply.property = evt.property; // " == success"
		}
	}

	XSendEvent (evt.display, evt.requestor, 0, NoEventMask, (XEvent*) &reply);
}

void SystemClipboard::copyTextToClipboard (const String& clipText)
{
	ClipboardHelpers::initSelectionAtoms();
	ClipboardHelpers::localClipboardContent = clipText;

	XSetSelectionOwner (display, XA_PRIMARY, juce_messageWindowHandle, CurrentTime);
	XSetSelectionOwner (display, ClipboardHelpers::atom_CLIPBOARD, juce_messageWindowHandle, CurrentTime);
}

String SystemClipboard::getTextFromClipboard()
{
	ClipboardHelpers::initSelectionAtoms();

	/* 1) try to read from the "CLIPBOARD" selection first (the "high
	   level" clipboard that is supposed to be filled by ctrl-C
	   etc). When a clipboard manager is running, the content of this
	   selection is preserved even when the original selection owner
	   exits.

	   2) and then try to read from "PRIMARY" selection (the "legacy" selection
	   filled by good old x11 apps such as xterm)
	*/
	String content;
	Atom selection = XA_PRIMARY;
	Window selectionOwner = None;

	if ((selectionOwner = XGetSelectionOwner (display, selection)) == None)
	{
		selection = ClipboardHelpers::atom_CLIPBOARD;
		selectionOwner = XGetSelectionOwner (display, selection);
	}

	if (selectionOwner != None)
	{
		if (selectionOwner == juce_messageWindowHandle)
		{
			content = ClipboardHelpers::localClipboardContent;
		}
		else
		{
			// first try: we want an utf8 string
			bool ok = ClipboardHelpers::requestSelectionContent (content, selection, ClipboardHelpers::atom_UTF8_STRING);

			if (! ok)
			{
				// second chance, ask for a good old locale-dependent string ..
				ok = ClipboardHelpers::requestSelectionContent (content, selection, XA_STRING);
			}
		}
	}

	return content;
}

/*** End of inlined file: juce_linux_Clipboard.cpp ***/



/*** Start of inlined file: juce_linux_Windowing.cpp ***/
extern Display* display;
extern XContext windowHandleXContext;

namespace Atoms
{
	enum ProtocolItems
	{
		TAKE_FOCUS = 0,
		DELETE_WINDOW = 1,
		PING = 2
	};

	static Atom Protocols, ProtocolList[3], ChangeState, State,
				ActiveWin, Pid, WindowType, WindowState,
				XdndAware, XdndEnter, XdndLeave, XdndPosition, XdndStatus,
				XdndDrop, XdndFinished, XdndSelection, XdndTypeList, XdndActionList,
				XdndActionDescription, XdndActionCopy,
				allowedActions[5],
				allowedMimeTypes[2];

	const unsigned long DndVersion = 3;

	Atom getIfExists (const char* name)    { return XInternAtom (display, name, True); }
	Atom getCreating (const char* name)    { return XInternAtom (display, name, False); }

	void initialiseAtoms()
	{
		static bool atomsInitialised = false;

		if (! atomsInitialised)
		{
			atomsInitialised = true;

			Protocols                       = getIfExists ("WM_PROTOCOLS");
			ProtocolList [TAKE_FOCUS]       = getIfExists ("WM_TAKE_FOCUS");
			ProtocolList [DELETE_WINDOW]    = getIfExists ("WM_DELETE_WINDOW");
			ProtocolList [PING]             = getIfExists ("_NET_WM_PING");
			ChangeState                     = getIfExists ("WM_CHANGE_STATE");
			State                           = getIfExists ("WM_STATE");
			ActiveWin                       = getCreating ("_NET_ACTIVE_WINDOW");
			Pid                             = getCreating ("_NET_WM_PID");
			WindowType                      = getIfExists ("_NET_WM_WINDOW_TYPE");
			WindowState                     = getIfExists ("_NET_WM_STATE");

			XdndAware                       = getCreating ("XdndAware");
			XdndEnter                       = getCreating ("XdndEnter");
			XdndLeave                       = getCreating ("XdndLeave");
			XdndPosition                    = getCreating ("XdndPosition");
			XdndStatus                      = getCreating ("XdndStatus");
			XdndDrop                        = getCreating ("XdndDrop");
			XdndFinished                    = getCreating ("XdndFinished");
			XdndSelection                   = getCreating ("XdndSelection");

			XdndTypeList                    = getCreating ("XdndTypeList");
			XdndActionList                  = getCreating ("XdndActionList");
			XdndActionCopy                  = getCreating ("XdndActionCopy");
			XdndActionDescription           = getCreating ("XdndActionDescription");

			allowedMimeTypes[0]             = getCreating ("text/plain");
			allowedMimeTypes[1]             = getCreating ("text/uri-list");

			allowedActions[0]               = getCreating ("XdndActionMove");
			allowedActions[1]               = XdndActionCopy;
			allowedActions[2]               = getCreating ("XdndActionLink");
			allowedActions[3]               = getCreating ("XdndActionAsk");
			allowedActions[4]               = getCreating ("XdndActionPrivate");
		}
	}
}

namespace Keys
{
	enum MouseButtons
	{
		NoButton = 0,
		LeftButton = 1,
		MiddleButton = 2,
		RightButton = 3,
		WheelUp = 4,
		WheelDown = 5
	};

	static int AltMask = 0;
	static int NumLockMask = 0;
	static bool numLock = false;
	static bool capsLock = false;
	static char keyStates [32];
	static const int extendedKeyModifier = 0x10000000;
}

bool KeyPress::isKeyCurrentlyDown (const int keyCode)
{
	int keysym;

	if (keyCode & Keys::extendedKeyModifier)
	{
		keysym = 0xff00 | (keyCode & 0xff);
	}
	else
	{
		keysym = keyCode;

		if (keysym == (XK_Tab & 0xff)
			|| keysym == (XK_Return & 0xff)
			|| keysym == (XK_Escape & 0xff)
			|| keysym == (XK_BackSpace & 0xff))
		{
			keysym |= 0xff00;
		}
	}

	ScopedXLock xlock;

	const int keycode = XKeysymToKeycode (display, keysym);

	const int keybyte = keycode >> 3;
	const int keybit = (1 << (keycode & 7));
	return (Keys::keyStates [keybyte] & keybit) != 0;
}

#if JUCE_USE_XSHM
namespace XSHMHelpers
{
	static int trappedErrorCode = 0;
	extern "C" int errorTrapHandler (Display*, XErrorEvent* err)
	{
		trappedErrorCode = err->error_code;
		return 0;
	}

	static bool isShmAvailable() noexcept
	{
		static bool isChecked = false;
		static bool isAvailable = false;

		if (! isChecked)
		{
			isChecked = true;
			int major, minor;
			Bool pixmaps;

			ScopedXLock xlock;

			if (XShmQueryVersion (display, &major, &minor, &pixmaps))
			{
				trappedErrorCode = 0;
				XErrorHandler oldHandler = XSetErrorHandler (errorTrapHandler);

				XShmSegmentInfo segmentInfo = { 0 };
				XImage* xImage = XShmCreateImage (display, DefaultVisual (display, DefaultScreen (display)),
												  24, ZPixmap, 0, &segmentInfo, 50, 50);

				if ((segmentInfo.shmid = shmget (IPC_PRIVATE,
												 xImage->bytes_per_line * xImage->height,
												 IPC_CREAT | 0777)) >= 0)
				{
					segmentInfo.shmaddr = (char*) shmat (segmentInfo.shmid, 0, 0);

					if (segmentInfo.shmaddr != (void*) -1)
					{
						segmentInfo.readOnly = False;
						xImage->data = segmentInfo.shmaddr;
						XSync (display, False);

						if (XShmAttach (display, &segmentInfo) != 0)
						{
							XSync (display, False);
							XShmDetach (display, &segmentInfo);

							isAvailable = true;
						}
					}

					XFlush (display);
					XDestroyImage (xImage);

					shmdt (segmentInfo.shmaddr);
				}

				shmctl (segmentInfo.shmid, IPC_RMID, 0);

				XSetErrorHandler (oldHandler);
				if (trappedErrorCode != 0)
					isAvailable = false;
			}
		}

		return isAvailable;
	}
}
#endif

#if JUCE_USE_XRENDER
namespace XRender
{
	typedef Status (*tXRenderQueryVersion) (Display*, int*, int*);
	typedef XRenderPictFormat* (*tXrenderFindStandardFormat) (Display*, int);
	typedef XRenderPictFormat* (*tXRenderFindFormat) (Display*, unsigned long, XRenderPictFormat*, int);
	typedef XRenderPictFormat* (*tXRenderFindVisualFormat) (Display*, Visual*);

	static tXRenderQueryVersion xRenderQueryVersion = 0;
	static tXrenderFindStandardFormat xRenderFindStandardFormat = 0;
	static tXRenderFindFormat xRenderFindFormat = 0;
	static tXRenderFindVisualFormat xRenderFindVisualFormat = 0;

	static bool isAvailable()
	{
		static bool hasLoaded = false;

		if (! hasLoaded)
		{
			ScopedXLock xlock;
			hasLoaded = true;

			void* h = dlopen ("libXrender.so", RTLD_GLOBAL | RTLD_NOW);

			if (h != 0)
			{
				xRenderQueryVersion         = (tXRenderQueryVersion)        dlsym (h, "XRenderQueryVersion");
				xRenderFindStandardFormat   = (tXrenderFindStandardFormat)  dlsym (h, "XrenderFindStandardFormat");
				xRenderFindFormat           = (tXRenderFindFormat)          dlsym (h, "XRenderFindFormat");
				xRenderFindVisualFormat     = (tXRenderFindVisualFormat)    dlsym (h, "XRenderFindVisualFormat");
			}

			if (xRenderQueryVersion != 0
				 && xRenderFindStandardFormat != 0
				 && xRenderFindFormat != 0
				 && xRenderFindVisualFormat != 0)
			{
				int major, minor;
				if (xRenderQueryVersion (display, &major, &minor))
					return true;
			}

			xRenderQueryVersion = 0;
		}

		return xRenderQueryVersion != 0;
	}

	static XRenderPictFormat* findPictureFormat()
	{
		ScopedXLock xlock;

		XRenderPictFormat* pictFormat = nullptr;

		if (isAvailable())
		{
			pictFormat = xRenderFindStandardFormat (display, PictStandardARGB32);

			if (pictFormat == 0)
			{
				XRenderPictFormat desiredFormat;
				desiredFormat.type = PictTypeDirect;
				desiredFormat.depth = 32;

				desiredFormat.direct.alphaMask = 0xff;
				desiredFormat.direct.redMask = 0xff;
				desiredFormat.direct.greenMask = 0xff;
				desiredFormat.direct.blueMask = 0xff;

				desiredFormat.direct.alpha = 24;
				desiredFormat.direct.red = 16;
				desiredFormat.direct.green = 8;
				desiredFormat.direct.blue = 0;

				pictFormat = xRenderFindFormat (display,
												PictFormatType | PictFormatDepth
												 | PictFormatRedMask | PictFormatRed
												 | PictFormatGreenMask | PictFormatGreen
												 | PictFormatBlueMask | PictFormatBlue
												 | PictFormatAlphaMask | PictFormatAlpha,
												&desiredFormat,
												0);
			}
		}

		return pictFormat;
	}
}
#endif

namespace Visuals
{
	static Visual* findVisualWithDepth (const int desiredDepth) noexcept
	{
		ScopedXLock xlock;

		Visual* visual = nullptr;
		int numVisuals = 0;
		long desiredMask = VisualNoMask;
		XVisualInfo desiredVisual;

		desiredVisual.screen = DefaultScreen (display);
		desiredVisual.depth = desiredDepth;

		desiredMask = VisualScreenMask | VisualDepthMask;

		if (desiredDepth == 32)
		{
			desiredVisual.c_class    = TrueColor;
			desiredVisual.red_mask   = 0x00FF0000;
			desiredVisual.green_mask = 0x0000FF00;
			desiredVisual.blue_mask  = 0x000000FF;
			desiredVisual.bits_per_rgb = 8;

			desiredMask |= VisualClassMask;
			desiredMask |= VisualRedMaskMask;
			desiredMask |= VisualGreenMaskMask;
			desiredMask |= VisualBlueMaskMask;
			desiredMask |= VisualBitsPerRGBMask;
		}

		XVisualInfo* xvinfos = XGetVisualInfo (display,
											   desiredMask,
											   &desiredVisual,
											   &numVisuals);

		if (xvinfos != 0)
		{
			for (int i = 0; i < numVisuals; i++)
			{
				if (xvinfos[i].depth == desiredDepth)
				{
					visual = xvinfos[i].visual;
					break;
				}
			}

			XFree (xvinfos);
		}

		return visual;
	}

	static Visual* findVisualFormat (const int desiredDepth, int& matchedDepth) noexcept
	{
		Visual* visual = nullptr;

		if (desiredDepth == 32)
		{
		   #if JUCE_USE_XSHM
			if (XSHMHelpers::isShmAvailable())
			{
			   #if JUCE_USE_XRENDER
				if (XRender::isAvailable())
				{
					XRenderPictFormat* pictFormat = XRender::findPictureFormat();

					if (pictFormat != 0)
					{
						int numVisuals = 0;
						XVisualInfo desiredVisual;
						desiredVisual.screen = DefaultScreen (display);
						desiredVisual.depth = 32;
						desiredVisual.bits_per_rgb = 8;

						XVisualInfo* xvinfos = XGetVisualInfo (display,
															   VisualScreenMask | VisualDepthMask | VisualBitsPerRGBMask,
															   &desiredVisual, &numVisuals);
						if (xvinfos != 0)
						{
							for (int i = 0; i < numVisuals; ++i)
							{
								XRenderPictFormat* pictVisualFormat = XRender::xRenderFindVisualFormat (display, xvinfos[i].visual);

								if (pictVisualFormat != 0
									 && pictVisualFormat->type == PictTypeDirect
									 && pictVisualFormat->direct.alphaMask)
								{
									visual = xvinfos[i].visual;
									matchedDepth = 32;
									break;
								}
							}

							XFree (xvinfos);
						}
					}
				}
			   #endif
				if (visual == 0)
				{
					visual = findVisualWithDepth (32);
					if (visual != 0)
						matchedDepth = 32;
				}
			}
		   #endif
		}

		if (visual == 0 && desiredDepth >= 24)
		{
			visual = findVisualWithDepth (24);
			if (visual != 0)
				matchedDepth = 24;
		}

		if (visual == 0 && desiredDepth >= 16)
		{
			visual = findVisualWithDepth (16);
			if (visual != 0)
				matchedDepth = 16;
		}

		return visual;
	}
}

class XBitmapImage  : public ImagePixelData
{
public:
	XBitmapImage (const Image::PixelFormat format, const int w, const int h,
				  const bool clearImage, const int imageDepth_, Visual* visual)
		: ImagePixelData (format, w, h),
		  imageDepth (imageDepth_),
		  gc (None)
	{
		jassert (format == Image::RGB || format == Image::ARGB);

		pixelStride = (format == Image::RGB) ? 3 : 4;
		lineStride = ((w * pixelStride + 3) & ~3);

		ScopedXLock xlock;

	   #if JUCE_USE_XSHM
		usingXShm = false;

		if ((imageDepth > 16) && XSHMHelpers::isShmAvailable())
		{
			zerostruct (segmentInfo);

			segmentInfo.shmid = -1;
			segmentInfo.shmaddr = (char *) -1;
			segmentInfo.readOnly = False;

			xImage = XShmCreateImage (display, visual, imageDepth, ZPixmap, 0, &segmentInfo, w, h);

			if (xImage != 0)
			{
				if ((segmentInfo.shmid = shmget (IPC_PRIVATE,
												 xImage->bytes_per_line * xImage->height,
												 IPC_CREAT | 0777)) >= 0)
				{
					if (segmentInfo.shmid != -1)
					{
						segmentInfo.shmaddr = (char*) shmat (segmentInfo.shmid, 0, 0);

						if (segmentInfo.shmaddr != (void*) -1)
						{
							segmentInfo.readOnly = False;

							xImage->data = segmentInfo.shmaddr;
							imageData = (uint8*) segmentInfo.shmaddr;

							if (XShmAttach (display, &segmentInfo) != 0)
								usingXShm = true;
							else
								jassertfalse;
						}
						else
						{
							shmctl (segmentInfo.shmid, IPC_RMID, 0);
						}
					}
				}
			}
		}

		if (! usingXShm)
	   #endif
		{
			imageDataAllocated.allocate (lineStride * h, format == Image::ARGB && clearImage);
			imageData = imageDataAllocated;

			xImage = (XImage*) ::calloc (1, sizeof (XImage));

			xImage->width = w;
			xImage->height = h;
			xImage->xoffset = 0;
			xImage->format = ZPixmap;
			xImage->data = (char*) imageData;
			xImage->byte_order = ImageByteOrder (display);
			xImage->bitmap_unit = BitmapUnit (display);
			xImage->bitmap_bit_order = BitmapBitOrder (display);
			xImage->bitmap_pad = 32;
			xImage->depth = pixelStride * 8;
			xImage->bytes_per_line = lineStride;
			xImage->bits_per_pixel = pixelStride * 8;
			xImage->red_mask   = 0x00FF0000;
			xImage->green_mask = 0x0000FF00;
			xImage->blue_mask  = 0x000000FF;

			if (imageDepth == 16)
			{
				const int pixelStride = 2;
				const int lineStride = ((w * pixelStride + 3) & ~3);

				imageData16Bit.malloc (lineStride * h);
				xImage->data = imageData16Bit;
				xImage->bitmap_pad = 16;
				xImage->depth = pixelStride * 8;
				xImage->bytes_per_line = lineStride;
				xImage->bits_per_pixel = pixelStride * 8;
				xImage->red_mask   = visual->red_mask;
				xImage->green_mask = visual->green_mask;
				xImage->blue_mask  = visual->blue_mask;
			}

			if (! XInitImage (xImage))
				jassertfalse;
		}
	}

	~XBitmapImage()
	{
		ScopedXLock xlock;

		if (gc != None)
			XFreeGC (display, gc);

	   #if JUCE_USE_XSHM
		if (usingXShm)
		{
			XShmDetach (display, &segmentInfo);

			XFlush (display);
			XDestroyImage (xImage);

			shmdt (segmentInfo.shmaddr);
			shmctl (segmentInfo.shmid, IPC_RMID, 0);
		}
		else
	   #endif
		{
			xImage->data = nullptr;
			XDestroyImage (xImage);
		}
	}

	LowLevelGraphicsContext* createLowLevelContext()
	{
		return new LowLevelGraphicsSoftwareRenderer (Image (this));
	}

	void initialiseBitmapData (Image::BitmapData& bitmap, int x, int y, Image::BitmapData::ReadWriteMode)
	{
		bitmap.data = imageData + x * pixelStride + y * lineStride;
		bitmap.pixelFormat = pixelFormat;
		bitmap.lineStride = lineStride;
		bitmap.pixelStride = pixelStride;
	}

	ImagePixelData* clone()
	{
		jassertfalse;
		return nullptr;
	}

	ImageType* createType() const                       { return new NativeImageType(); }

	void blitToWindow (Window window, int dx, int dy, int dw, int dh, int sx, int sy)
	{
		ScopedXLock xlock;

		if (gc == None)
		{
			XGCValues gcvalues;
			gcvalues.foreground = None;
			gcvalues.background = None;
			gcvalues.function = GXcopy;
			gcvalues.plane_mask = AllPlanes;
			gcvalues.clip_mask = None;
			gcvalues.graphics_exposures = False;

			gc = XCreateGC (display, window,
							GCBackground | GCForeground | GCFunction | GCPlaneMask | GCClipMask | GCGraphicsExposures,
							&gcvalues);
		}

		if (imageDepth == 16)
		{
			const uint32 rMask = xImage->red_mask;
			const uint32 rShiftL = jmax (0, getShiftNeeded (rMask));
			const uint32 rShiftR = jmax (0, -getShiftNeeded (rMask));
			const uint32 gMask = xImage->green_mask;
			const uint32 gShiftL = jmax (0, getShiftNeeded (gMask));
			const uint32 gShiftR = jmax (0, -getShiftNeeded (gMask));
			const uint32 bMask = xImage->blue_mask;
			const uint32 bShiftL = jmax (0, getShiftNeeded (bMask));
			const uint32 bShiftR = jmax (0, -getShiftNeeded (bMask));

			const Image::BitmapData srcData (Image (this), Image::BitmapData::readOnly);

			for (int y = sy; y < sy + dh; ++y)
			{
				const uint8* p = srcData.getPixelPointer (sx, y);

				for (int x = sx; x < sx + dw; ++x)
				{
					const PixelRGB* const pixel = (const PixelRGB*) p;
					p += srcData.pixelStride;

					XPutPixel (xImage, x, y,
							   (((((uint32) pixel->getRed()) << rShiftL) >> rShiftR) & rMask)
								 | (((((uint32) pixel->getGreen()) << gShiftL) >> gShiftR) & gMask)
								 | (((((uint32) pixel->getBlue()) << bShiftL) >> bShiftR) & bMask));
				}
			}
		}

		// blit results to screen.
	   #if JUCE_USE_XSHM
		if (usingXShm)
			XShmPutImage (display, (::Drawable) window, gc, xImage, sx, sy, dx, dy, dw, dh, True);
		else
	   #endif
			XPutImage (display, (::Drawable) window, gc, xImage, sx, sy, dx, dy, dw, dh);
	}

private:

	XImage* xImage;
	const int imageDepth;
	HeapBlock <uint8> imageDataAllocated;
	HeapBlock <char> imageData16Bit;
	int pixelStride, lineStride;
	uint8* imageData;
	GC gc;

   #if JUCE_USE_XSHM
	XShmSegmentInfo segmentInfo;
	bool usingXShm;
   #endif

	static int getShiftNeeded (const uint32 mask) noexcept
	{
		for (int i = 32; --i >= 0;)
			if (((mask >> i) & 1) != 0)
				return i - 7;

		jassertfalse;
		return 0;
	}

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (XBitmapImage);
};

namespace PixmapHelpers
{
	Pixmap createColourPixmapFromImage (Display* display, const Image& image)
	{
		ScopedXLock xlock;

		const int width = image.getWidth();
		const int height = image.getHeight();
		HeapBlock <uint32> colour (width * height);
		int index = 0;

		for (int y = 0; y < height; ++y)
			for (int x = 0; x < width; ++x)
				colour[index++] = image.getPixelAt (x, y).getARGB();

		XImage* ximage = XCreateImage (display, CopyFromParent, 24, ZPixmap,
									   0, reinterpret_cast<char*> (colour.getData()),
									   width, height, 32, 0);

		Pixmap pixmap = XCreatePixmap (display, DefaultRootWindow (display),
									   width, height, 24);

		GC gc = XCreateGC (display, pixmap, 0, 0);
		XPutImage (display, pixmap, gc, ximage, 0, 0, 0, 0, width, height);
		XFreeGC (display, gc);

		return pixmap;
	}

	Pixmap createMaskPixmapFromImage (Display* display, const Image& image)
	{
		ScopedXLock xlock;

		const int width = image.getWidth();
		const int height = image.getHeight();
		const int stride = (width + 7) >> 3;
		HeapBlock <char> mask;
		mask.calloc (stride * height);
		const bool msbfirst = (BitmapBitOrder (display) == MSBFirst);

		for (int y = 0; y < height; ++y)
		{
			for (int x = 0; x < width; ++x)
			{
				const char bit = (char) (1 << (msbfirst ? (7 - (x & 7)) : (x & 7)));
				const int offset = y * stride + (x >> 3);

				if (image.getPixelAt (x, y).getAlpha() >= 128)
					mask[offset] |= bit;
			}
		}

		return XCreatePixmapFromBitmapData (display, DefaultRootWindow (display),
											mask.getData(), width, height, 1, 0, 1);
	}
}

class LinuxComponentPeer  : public ComponentPeer
{
public:
	LinuxComponentPeer (Component* const component, const int windowStyleFlags, Window parentToAddTo)
		: ComponentPeer (component, windowStyleFlags),
		  windowH (0), parentWindow (0),
		  wx (0), wy (0), ww (0), wh (0),
		  fullScreen (false), mapped (false),
		  visual (0), depth (0)
	{
		// it's dangerous to create a window on a thread other than the message thread..
		jassert (MessageManager::getInstance()->currentThreadHasLockedMessageManager());

		repainter = new LinuxRepaintManager (this);

		createWindow (parentToAddTo);

		setTitle (component->getName());
	}

	~LinuxComponentPeer()
	{
		// it's dangerous to delete a window on a thread other than the message thread..
		jassert (MessageManager::getInstance()->currentThreadHasLockedMessageManager());

		deleteIconPixmaps();

		destroyWindow();

		windowH = 0;
	}

	void* getNativeHandle() const
	{
		return (void*) windowH;
	}

	static LinuxComponentPeer* getPeerFor (Window windowHandle) noexcept
	{
		XPointer peer = nullptr;

		ScopedXLock xlock;
		if (! XFindContext (display, (XID) windowHandle, windowHandleXContext, &peer))
			if (peer != nullptr && ! ComponentPeer::isValidPeer (reinterpret_cast <LinuxComponentPeer*> (peer)))
				peer = nullptr;

		return reinterpret_cast <LinuxComponentPeer*> (peer);
	}

	void setVisible (bool shouldBeVisible)
	{
		ScopedXLock xlock;
		if (shouldBeVisible)
			XMapWindow (display, windowH);
		else
			XUnmapWindow (display, windowH);
	}

	void setTitle (const String& title)
	{
		XTextProperty nameProperty;
		char* strings[] = { const_cast <char*> (title.toUTF8().getAddress()) };
		ScopedXLock xlock;

		if (XStringListToTextProperty (strings, 1, &nameProperty))
		{
			XSetWMName (display, windowH, &nameProperty);
			XSetWMIconName (display, windowH, &nameProperty);

			XFree (nameProperty.value);
		}
	}

	void setBounds (int x, int y, int w, int h, bool isNowFullScreen)
	{
		fullScreen = isNowFullScreen;

		if (windowH != 0)
		{
			WeakReference<Component> deletionChecker (component);

			wx = x;
			wy = y;
			ww = jmax (1, w);
			wh = jmax (1, h);

			ScopedXLock xlock;

			// Make sure the Window manager does what we want
			XSizeHints* hints = XAllocSizeHints();
			hints->flags = USSize | USPosition;
			hints->width = ww;
			hints->height = wh;
			hints->x = wx;
			hints->y = wy;

			if ((getStyleFlags() & (windowHasTitleBar | windowIsResizable)) == windowHasTitleBar)
			{
				hints->min_width  = hints->max_width  = hints->width;
				hints->min_height = hints->max_height = hints->height;
				hints->flags |= PMinSize | PMaxSize;
			}

			XSetWMNormalHints (display, windowH, hints);
			XFree (hints);

			XMoveResizeWindow (display, windowH,
							   wx - windowBorder.getLeft(),
							   wy - windowBorder.getTop(), ww, wh);

			if (deletionChecker != 0)
			{
				updateBorderSize();
				handleMovedOrResized();
			}
		}
	}

	void setPosition (int x, int y)           { setBounds (x, y, ww, wh, false); }
	void setSize (int w, int h)               { setBounds (wx, wy, w, h, false); }
	Rectangle<int> getBounds() const          { return Rectangle<int> (wx, wy, ww, wh); }
	Point<int> getScreenPosition() const      { return Point<int> (wx, wy); }

	Point<int> localToGlobal (const Point<int>& relativePosition)
	{
		return relativePosition + getScreenPosition();
	}

	Point<int> globalToLocal (const Point<int>& screenPosition)
	{
		return screenPosition - getScreenPosition();
	}

	void setAlpha (float newAlpha)
	{
		//xxx todo!
	}

	void setMinimised (bool shouldBeMinimised)
	{
		if (shouldBeMinimised)
		{
			Window root = RootWindow (display, DefaultScreen (display));

			XClientMessageEvent clientMsg;
			clientMsg.display = display;
			clientMsg.window = windowH;
			clientMsg.type = ClientMessage;
			clientMsg.format = 32;
			clientMsg.message_type = Atoms::ChangeState;
			clientMsg.data.l[0] = IconicState;

			ScopedXLock xlock;
			XSendEvent (display, root, false, SubstructureRedirectMask | SubstructureNotifyMask, (XEvent*) &clientMsg);
		}
		else
		{
			setVisible (true);
		}
	}

	bool isMinimised() const
	{
		bool minimised = false;

		unsigned char* stateProp;
		unsigned long nitems, bytesLeft;
		Atom actualType;
		int actualFormat;

		ScopedXLock xlock;
		if (XGetWindowProperty (display, windowH, Atoms::State, 0, 64, False,
								Atoms::State, &actualType, &actualFormat, &nitems, &bytesLeft,
								&stateProp) == Success
			&& actualType == Atoms::State
			&& actualFormat == 32
			&& nitems > 0)
		{
			if (((unsigned long*) stateProp)[0] == IconicState)
				minimised = true;

			XFree (stateProp);
		}

		return minimised;
	}

	void setFullScreen (const bool shouldBeFullScreen)
	{
		Rectangle<int> r (lastNonFullscreenBounds); // (get a copy of this before de-minimising)

		setMinimised (false);

		if (fullScreen != shouldBeFullScreen)
		{
			if (shouldBeFullScreen)
				r = Desktop::getInstance().getMainMonitorArea();

			if (! r.isEmpty())
				setBounds (r.getX(), r.getY(), r.getWidth(), r.getHeight(), shouldBeFullScreen);

			getComponent()->repaint();
		}
	}

	bool isFullScreen() const
	{
		return fullScreen;
	}

	bool isChildWindowOf (Window possibleParent) const
	{
		Window* windowList = nullptr;
		uint32 windowListSize = 0;
		Window parent, root;

		ScopedXLock xlock;
		if (XQueryTree (display, windowH, &root, &parent, &windowList, &windowListSize) != 0)
		{
			if (windowList != 0)
				XFree (windowList);

			return parent == possibleParent;
		}

		return false;
	}

	bool isFrontWindow() const
	{
		Window* windowList = nullptr;
		uint32 windowListSize = 0;
		bool result = false;

		ScopedXLock xlock;
		Window parent, root = RootWindow (display, DefaultScreen (display));

		if (XQueryTree (display, root, &root, &parent, &windowList, &windowListSize) != 0)
		{
			for (int i = windowListSize; --i >= 0;)
			{
				LinuxComponentPeer* const peer = LinuxComponentPeer::getPeerFor (windowList[i]);

				if (peer != 0)
				{
					result = (peer == this);
					break;
				}
			}
		}

		if (windowList != 0)
			XFree (windowList);

		return result;
	}

	bool contains (const Point<int>& position, bool trueIfInAChildWindow) const
	{
		if (! (isPositiveAndBelow (position.getX(), ww) && isPositiveAndBelow (position.getY(), wh)))
			return false;

		for (int i = Desktop::getInstance().getNumComponents(); --i >= 0;)
		{
			Component* const c = Desktop::getInstance().getComponent (i);

			if (c == getComponent())
				break;

			if (c->contains (position + Point<int> (wx, wy) - c->getScreenPosition()))
				return false;
		}

		if (trueIfInAChildWindow)
			return true;

		::Window root, child;
		unsigned int bw, depth;
		int wx, wy, w, h;

		ScopedXLock xlock;
		if (! XGetGeometry (display, (::Drawable) windowH, &root,
							&wx, &wy, (unsigned int*) &w, (unsigned int*) &h,
							&bw, &depth))
		{
			return false;
		}

		if (! XTranslateCoordinates (display, windowH, windowH, position.getX(), position.getY(), &wx, &wy, &child))
			return false;

		return child == None;
	}

	BorderSize<int> getFrameSize() const
	{
		return BorderSize<int>();
	}

	bool setAlwaysOnTop (bool alwaysOnTop)
	{
		return false;
	}

	void toFront (bool makeActive)
	{
		if (makeActive)
		{
			setVisible (true);
			grabFocus();
		}

		XEvent ev;
		ev.xclient.type = ClientMessage;
		ev.xclient.serial = 0;
		ev.xclient.send_event = True;
		ev.xclient.message_type = Atoms::ActiveWin;
		ev.xclient.window = windowH;
		ev.xclient.format = 32;
		ev.xclient.data.l[0] = 2;
		ev.xclient.data.l[1] = CurrentTime;
		ev.xclient.data.l[2] = 0;
		ev.xclient.data.l[3] = 0;
		ev.xclient.data.l[4] = 0;

		{
			ScopedXLock xlock;
			XSendEvent (display, RootWindow (display, DefaultScreen (display)),
						False, SubstructureRedirectMask | SubstructureNotifyMask, &ev);

			XWindowAttributes attr;
			XGetWindowAttributes (display, windowH, &attr);

			if (component->isAlwaysOnTop())
				XRaiseWindow (display, windowH);

			XSync (display, False);
		}

		handleBroughtToFront();
	}

	void toBehind (ComponentPeer* other)
	{
		LinuxComponentPeer* const otherPeer = dynamic_cast <LinuxComponentPeer*> (other);
		jassert (otherPeer != nullptr); // wrong type of window?

		if (otherPeer != nullptr)
		{
			setMinimised (false);

			Window newStack[] = { otherPeer->windowH, windowH };

			ScopedXLock xlock;
			XRestackWindows (display, newStack, 2);
		}
	}

	bool isFocused() const
	{
		int revert = 0;
		Window focusedWindow = 0;
		ScopedXLock xlock;
		XGetInputFocus (display, &focusedWindow, &revert);

		return focusedWindow == windowH;
	}

	void grabFocus()
	{
		XWindowAttributes atts;
		ScopedXLock xlock;

		if (windowH != 0
			&& XGetWindowAttributes (display, windowH, &atts)
			&& atts.map_state == IsViewable
			&& ! isFocused())
		{
			XSetInputFocus (display, windowH, RevertToParent, CurrentTime);
			isActiveApplication = true;
		}
	}

	void textInputRequired (const Point<int>&)
	{
	}

	void repaint (const Rectangle<int>& area)
	{
		repainter->repaint (area.getIntersection (getComponent()->getLocalBounds()));
	}

	void performAnyPendingRepaintsNow()
	{
		repainter->performAnyPendingRepaintsNow();
	}

	void setIcon (const Image& newIcon)
	{
		const int dataSize = newIcon.getWidth() * newIcon.getHeight() + 2;
		HeapBlock <unsigned long> data (dataSize);

		int index = 0;
		data[index++] = (unsigned long) newIcon.getWidth();
		data[index++] = (unsigned long) newIcon.getHeight();

		for (int y = 0; y < newIcon.getHeight(); ++y)
			for (int x = 0; x < newIcon.getWidth(); ++x)
				data[index++] = (unsigned long) newIcon.getPixelAt (x, y).getARGB();

		ScopedXLock xlock;
		xchangeProperty (windowH, Atoms::getCreating ("_NET_WM_ICON"), XA_CARDINAL, 32, data.getData(), dataSize);

		deleteIconPixmaps();

		XWMHints* wmHints = XGetWMHints (display, windowH);

		if (wmHints == nullptr)
			wmHints = XAllocWMHints();

		wmHints->flags |= IconPixmapHint | IconMaskHint;
		wmHints->icon_pixmap = PixmapHelpers::createColourPixmapFromImage (display, newIcon);
		wmHints->icon_mask = PixmapHelpers::createMaskPixmapFromImage (display, newIcon);

		XSetWMHints (display, windowH, wmHints);
		XFree (wmHints);

		XSync (display, False);
	}

	void deleteIconPixmaps()
	{
		ScopedXLock xlock;
		XWMHints* wmHints = XGetWMHints (display, windowH);

		if (wmHints != nullptr)
		{
			if ((wmHints->flags & IconPixmapHint) != 0)
			{
				wmHints->flags &= ~IconPixmapHint;
				XFreePixmap (display, wmHints->icon_pixmap);
			}

			if ((wmHints->flags & IconMaskHint) != 0)
			{
				wmHints->flags &= ~IconMaskHint;
				XFreePixmap (display, wmHints->icon_mask);
			}

			XSetWMHints (display, windowH, wmHints);
			XFree (wmHints);
		}
	}

	void handleWindowMessage (XEvent* event)
	{
		switch (event->xany.type)
		{
			case KeyPressEventType:     handleKeyPressEvent ((XKeyEvent*) &event->xkey); break;
			case KeyRelease:            handleKeyReleaseEvent ((const XKeyEvent*) &event->xkey); break;
			case ButtonPress:           handleButtonPressEvent ((const XButtonPressedEvent*) &event->xbutton); break;
			case ButtonRelease:         handleButtonReleaseEvent ((const XButtonReleasedEvent*) &event->xbutton); break;
			case MotionNotify:          handleMotionNotifyEvent ((const XPointerMovedEvent*) &event->xmotion); break;
			case EnterNotify:           handleEnterNotifyEvent ((const XEnterWindowEvent*) &event->xcrossing); break;
			case LeaveNotify:           handleLeaveNotifyEvent ((const XLeaveWindowEvent*) &event->xcrossing); break;
			case FocusIn:               handleFocusInEvent(); break;
			case FocusOut:              handleFocusOutEvent(); break;
			case Expose:                handleExposeEvent ((XExposeEvent*) &event->xexpose); break;
			case MappingNotify:         handleMappingNotify ((XMappingEvent*) &event->xmapping); break;
			case ClientMessage:         handleClientMessageEvent ((XClientMessageEvent*) &event->xclient, event); break;
			case SelectionNotify:       handleDragAndDropSelection (event); break;
			case ConfigureNotify:       handleConfigureNotifyEvent ((XConfigureEvent*) &event->xconfigure); break;
			case ReparentNotify:        handleReparentNotifyEvent(); break;
			case GravityNotify:         handleGravityNotify(); break;

			case CirculateNotify:
			case CreateNotify:
			case DestroyNotify:
				// Think we can ignore these
				break;

			case MapNotify:
				mapped = true;
				handleBroughtToFront();
				break;

			case UnmapNotify:
				mapped = false;
				break;

			case SelectionClear:
			case SelectionRequest:
				break;

			default:
			   #if JUCE_USE_XSHM
				{
					ScopedXLock xlock;
					if (event->xany.type == XShmGetEventBase (display))
						repainter->notifyPaintCompleted();
				}
			   #endif
				break;
		}
	}

	void handleKeyPressEvent (XKeyEvent* const keyEvent)
	{
		char utf8 [64] = { 0 };
		juce_wchar unicodeChar = 0;
		int keyCode = 0;
		bool keyDownChange = false;
		KeySym sym;

		{
			ScopedXLock xlock;
			updateKeyStates (keyEvent->keycode, true);

			const char* oldLocale = ::setlocale (LC_ALL, 0);
			::setlocale (LC_ALL, "");
			XLookupString (keyEvent, utf8, sizeof (utf8), &sym, 0);
			::setlocale (LC_ALL, oldLocale);

			unicodeChar = *CharPointer_UTF8 (utf8);
			keyCode = (int) unicodeChar;

			if (keyCode < 0x20)
				keyCode = XKeycodeToKeysym (display, keyEvent->keycode, currentModifiers.isShiftDown() ? 1 : 0);

			keyDownChange = (sym != NoSymbol) && ! updateKeyModifiersFromSym (sym, true);
		}

		const ModifierKeys oldMods (currentModifiers);
		bool keyPressed = false;

		if ((sym & 0xff00) == 0xff00)
		{
			switch (sym)  // Translate keypad
			{
				case XK_KP_Divide:      keyCode = XK_slash; break;
				case XK_KP_Multiply:    keyCode = XK_asterisk; break;
				case XK_KP_Subtract:    keyCode = XK_hyphen; break;
				case XK_KP_Add:         keyCode = XK_plus; break;
				case XK_KP_Enter:       keyCode = XK_Return; break;
				case XK_KP_Decimal:     keyCode = Keys::numLock ? XK_period : XK_Delete; break;
				case XK_KP_0:           keyCode = Keys::numLock ? XK_0 : XK_Insert; break;
				case XK_KP_1:           keyCode = Keys::numLock ? XK_1 : XK_End; break;
				case XK_KP_2:           keyCode = Keys::numLock ? XK_2 : XK_Down; break;
				case XK_KP_3:           keyCode = Keys::numLock ? XK_3 : XK_Page_Down; break;
				case XK_KP_4:           keyCode = Keys::numLock ? XK_4 : XK_Left; break;
				case XK_KP_5:           keyCode = XK_5; break;
				case XK_KP_6:           keyCode = Keys::numLock ? XK_6 : XK_Right; break;
				case XK_KP_7:           keyCode = Keys::numLock ? XK_7 : XK_Home; break;
				case XK_KP_8:           keyCode = Keys::numLock ? XK_8 : XK_Up; break;
				case XK_KP_9:           keyCode = Keys::numLock ? XK_9 : XK_Page_Up; break;
				default:                break;
			}

			switch (sym)
			{
				case XK_Left:
				case XK_Right:
				case XK_Up:
				case XK_Down:
				case XK_Page_Up:
				case XK_Page_Down:
				case XK_End:
				case XK_Home:
				case XK_Delete:
				case XK_Insert:
					keyPressed = true;
					keyCode = (sym & 0xff) | Keys::extendedKeyModifier;
					break;

				case XK_Tab:
				case XK_Return:
				case XK_Escape:
				case XK_BackSpace:
					keyPressed = true;
					keyCode &= 0xff;
					break;

				default:
					if (sym >= XK_F1 && sym <= XK_F16)
					{
						keyPressed = true;
						keyCode = (sym & 0xff) | Keys::extendedKeyModifier;
					}
					break;
			}
		}

		if (utf8[0] != 0 || ((sym & 0xff00) == 0 && sym >= 8))
			keyPressed = true;

		if (oldMods != currentModifiers)
			handleModifierKeysChange();

		if (keyDownChange)
			handleKeyUpOrDown (true);

		if (keyPressed)
			handleKeyPress (keyCode, unicodeChar);
	}

	static bool isKeyReleasePartOfAutoRepeat (const XKeyEvent* const keyReleaseEvent)
	{
		if (XPending (display))
		{
			XEvent e;
			XPeekEvent (display, &e);

			// Look for a subsequent key-down event with the same timestamp and keycode
			return e.type == KeyPressEventType
					&& e.xkey.keycode == keyReleaseEvent->keycode
					&& e.xkey.time == keyReleaseEvent->time;
		}

		return false;
	}

	void handleKeyReleaseEvent (const XKeyEvent* const keyEvent)
	{
		if (! isKeyReleasePartOfAutoRepeat (keyEvent))
		{
			updateKeyStates (keyEvent->keycode, false);
			KeySym sym;

			{
				ScopedXLock xlock;
				sym = XKeycodeToKeysym (display, keyEvent->keycode, 0);
			}

			const ModifierKeys oldMods (currentModifiers);
			const bool keyDownChange = (sym != NoSymbol) && ! updateKeyModifiersFromSym (sym, false);

			if (oldMods != currentModifiers)
				handleModifierKeysChange();

			if (keyDownChange)
				handleKeyUpOrDown (false);
		}
	}

	void handleWheelEvent (const XButtonPressedEvent* const buttonPressEvent, const float amount)
	{
		handleMouseWheel (0, Point<int> (buttonPressEvent->x, buttonPressEvent->y),
						  getEventTime (buttonPressEvent->time), 0, amount);
	}

	void handleButtonPressEvent (const XButtonPressedEvent* const buttonPressEvent, int buttonModifierFlag)
	{
		currentModifiers = currentModifiers.withFlags (buttonModifierFlag);
		toFront (true);
		handleMouseEvent (0, Point<int> (buttonPressEvent->x, buttonPressEvent->y), currentModifiers,
						  getEventTime (buttonPressEvent->time));
	}

	void handleButtonPressEvent (const XButtonPressedEvent* const buttonPressEvent)
	{
		updateKeyModifiers (buttonPressEvent->state);

		switch (pointerMap [buttonPressEvent->button - Button1])
		{
			case Keys::WheelUp:         handleWheelEvent (buttonPressEvent, 84.0f); break;
			case Keys::WheelDown:       handleWheelEvent (buttonPressEvent, -84.0f); break;
			case Keys::LeftButton:      handleButtonPressEvent (buttonPressEvent, ModifierKeys::leftButtonModifier); break;
			case Keys::RightButton:     handleButtonPressEvent (buttonPressEvent, ModifierKeys::rightButtonModifier); break;
			case Keys::MiddleButton:    handleButtonPressEvent (buttonPressEvent, ModifierKeys::middleButtonModifier); break;
			default: break;
		}

		clearLastMousePos();
	}

	void handleButtonReleaseEvent (const XButtonReleasedEvent* const buttonRelEvent)
	{
		updateKeyModifiers (buttonRelEvent->state);

		switch (pointerMap [buttonRelEvent->button - Button1])
		{
			case Keys::LeftButton:      currentModifiers = currentModifiers.withoutFlags (ModifierKeys::leftButtonModifier); break;
			case Keys::RightButton:     currentModifiers = currentModifiers.withoutFlags (ModifierKeys::rightButtonModifier); break;
			case Keys::MiddleButton:    currentModifiers = currentModifiers.withoutFlags (ModifierKeys::middleButtonModifier); break;
			default: break;
		}

		handleMouseEvent (0, Point<int> (buttonRelEvent->x, buttonRelEvent->y), currentModifiers,
						  getEventTime (buttonRelEvent->time));

		clearLastMousePos();
	}

	void handleMotionNotifyEvent (const XPointerMovedEvent* const movedEvent)
	{
		updateKeyModifiers (movedEvent->state);
		const Point<int> mousePos (movedEvent->x_root, movedEvent->y_root);

		if (lastMousePos != mousePos)
		{
			lastMousePos = mousePos;

			if (parentWindow != nullptr && (styleFlags & windowHasTitleBar) == 0)
			{
				Window wRoot = 0, wParent = 0;

				{
					ScopedXLock xlock;
					unsigned int numChildren;
					Window* wChild = nullptr;
					XQueryTree (display, windowH, &wRoot, &wParent, &wChild, &numChildren);
				}

				if (wParent != 0
					 && wParent != windowH
					 && wParent != wRoot)
				{
					parentWindow = wParent;
					updateBounds();
				}
				else
				{
					parentWindow = 0;
				}
			}

			handleMouseEvent (0, mousePos - getScreenPosition(), currentModifiers, getEventTime (movedEvent->time));
		}
	}

	void handleEnterNotifyEvent (const XEnterWindowEvent* const enterEvent)
	{
		clearLastMousePos();

		if (! currentModifiers.isAnyMouseButtonDown())
		{
			updateKeyModifiers (enterEvent->state);
			handleMouseEvent (0, Point<int> (enterEvent->x, enterEvent->y), currentModifiers, getEventTime (enterEvent->time));
		}
	}

	void handleLeaveNotifyEvent (const XLeaveWindowEvent* const leaveEvent)
	{
		// Suppress the normal leave if we've got a pointer grab, or if
		// it's a bogus one caused by clicking a mouse button when running
		// in a Window manager
		if (((! currentModifiers.isAnyMouseButtonDown()) && leaveEvent->mode == NotifyNormal)
			 || leaveEvent->mode == NotifyUngrab)
		{
			updateKeyModifiers (leaveEvent->state);
			handleMouseEvent (0, Point<int> (leaveEvent->x, leaveEvent->y), currentModifiers, getEventTime (leaveEvent->time));
		}
	}

	void handleFocusInEvent()
	{
		isActiveApplication = true;
		if (isFocused())
			handleFocusGain();
	}

	void handleFocusOutEvent()
	{
		isActiveApplication = false;
		if (! isFocused())
			handleFocusLoss();
	}

	void handleExposeEvent (XExposeEvent* exposeEvent)
	{
		// Batch together all pending expose events
		XEvent nextEvent;
		ScopedXLock xlock;

		if (exposeEvent->window != windowH)
		{
			Window child;
			XTranslateCoordinates (display, exposeEvent->window, windowH,
								   exposeEvent->x, exposeEvent->y, &exposeEvent->x, &exposeEvent->y,
								   &child);
		}

		repaint (Rectangle<int> (exposeEvent->x, exposeEvent->y,
								 exposeEvent->width, exposeEvent->height));

		while (XEventsQueued (display, QueuedAfterFlush) > 0)
		{
			XPeekEvent (display, &nextEvent);
			if (nextEvent.type != Expose || nextEvent.xany.window != exposeEvent->window)
				break;

			XNextEvent (display, &nextEvent);
			XExposeEvent* nextExposeEvent = (XExposeEvent*) &nextEvent.xexpose;
			repaint (Rectangle<int> (nextExposeEvent->x, nextExposeEvent->y,
									 nextExposeEvent->width, nextExposeEvent->height));
		}
	}

	void handleConfigureNotifyEvent (XConfigureEvent* const confEvent)
	{
		updateBounds();
		updateBorderSize();
		handleMovedOrResized();

		// if the native title bar is dragged, need to tell any active menus, etc.
		if ((styleFlags & windowHasTitleBar) != 0
			  && component->isCurrentlyBlockedByAnotherModalComponent())
		{
			Component* const currentModalComp = Component::getCurrentlyModalComponent();

			if (currentModalComp != 0)
				currentModalComp->inputAttemptWhenModal();
		}

		if (confEvent->window == windowH
			 && confEvent->above != 0
			 && isFrontWindow())
		{
			handleBroughtToFront();
		}
	}

	void handleReparentNotifyEvent()
	{
		parentWindow = 0;
		Window wRoot = 0;
		Window* wChild = nullptr;
		unsigned int numChildren;

		{
			ScopedXLock xlock;
			XQueryTree (display, windowH, &wRoot, &parentWindow, &wChild, &numChildren);
		}

		if (parentWindow == windowH || parentWindow == wRoot)
			parentWindow = 0;

		handleGravityNotify();
	}

	void handleGravityNotify()
	{
		updateBounds();
		updateBorderSize();
		handleMovedOrResized();
	}

	void handleMappingNotify (XMappingEvent* const mappingEvent)
	{
		if (mappingEvent->request != MappingPointer)
		{
			// Deal with modifier/keyboard mapping
			ScopedXLock xlock;
			XRefreshKeyboardMapping (mappingEvent);
			updateModifierMappings();
		}
	}

	void handleClientMessageEvent (XClientMessageEvent* const clientMsg, XEvent* event)
	{
		if (clientMsg->message_type == Atoms::Protocols && clientMsg->format == 32)
		{
			const Atom atom = (Atom) clientMsg->data.l[0];

			if (atom == Atoms::ProtocolList [Atoms::PING])
			{
				Window root = RootWindow (display, DefaultScreen (display));

				clientMsg->window = root;

				XSendEvent (display, root, False, NoEventMask, event);
				XFlush (display);
			}
			else if (atom == Atoms::ProtocolList [Atoms::TAKE_FOCUS])
			{
				if ((getStyleFlags() & juce::ComponentPeer::windowIgnoresKeyPresses) == 0)
				{
					XWindowAttributes atts;

					ScopedXLock xlock;
					if (clientMsg->window != 0
						 && XGetWindowAttributes (display, clientMsg->window, &atts))
					{
						if (atts.map_state == IsViewable)
							XSetInputFocus (display, clientMsg->window, RevertToParent, clientMsg->data.l[1]);
					}
				}
			}
			else if (atom == Atoms::ProtocolList [Atoms::DELETE_WINDOW])
			{
				handleUserClosingWindow();
			}
		}
		else if (clientMsg->message_type == Atoms::XdndEnter)
		{
			handleDragAndDropEnter (clientMsg);
		}
		else if (clientMsg->message_type == Atoms::XdndLeave)
		{
			resetDragAndDrop();
		}
		else if (clientMsg->message_type == Atoms::XdndPosition)
		{
			handleDragAndDropPosition (clientMsg);
		}
		else if (clientMsg->message_type == Atoms::XdndDrop)
		{
			handleDragAndDropDrop (clientMsg);
		}
		else if (clientMsg->message_type == Atoms::XdndStatus)
		{
			handleDragAndDropStatus (clientMsg);
		}
		else if (clientMsg->message_type == Atoms::XdndFinished)
		{
			resetDragAndDrop();
		}
	}

	void showMouseCursor (Cursor cursor) noexcept
	{
		ScopedXLock xlock;
		XDefineCursor (display, windowH, cursor);
	}

	bool dontRepaint;

	static ModifierKeys currentModifiers;
	static bool isActiveApplication;

private:

	class LinuxRepaintManager : public Timer
	{
	public:
		LinuxRepaintManager (LinuxComponentPeer* const peer_)
			: peer (peer_),
			  lastTimeImageUsed (0)
		{
		   #if JUCE_USE_XSHM
			shmCompletedDrawing = true;

			useARGBImagesForRendering = XSHMHelpers::isShmAvailable();

			if (useARGBImagesForRendering)
			{
				ScopedXLock xlock;
				XShmSegmentInfo segmentinfo;

				XImage* const testImage
					= XShmCreateImage (display, DefaultVisual (display, DefaultScreen (display)),
									   24, ZPixmap, 0, &segmentinfo, 64, 64);

				useARGBImagesForRendering = (testImage->bits_per_pixel == 32);
				XDestroyImage (testImage);
			}
		   #endif
		}

		void timerCallback()
		{
		   #if JUCE_USE_XSHM
			if (! shmCompletedDrawing)
				return;
		   #endif
			if (! regionsNeedingRepaint.isEmpty())
			{
				stopTimer();
				performAnyPendingRepaintsNow();
			}
			else if (Time::getApproximateMillisecondCounter() > lastTimeImageUsed + 3000)
			{
				stopTimer();
				image = Image::null;
			}
		}

		void repaint (const Rectangle<int>& area)
		{
			if (! isTimerRunning())
				startTimer (repaintTimerPeriod);

			regionsNeedingRepaint.add (area);
		}

		void performAnyPendingRepaintsNow()
		{
		   #if JUCE_USE_XSHM
			if (! shmCompletedDrawing)
			{
				startTimer (repaintTimerPeriod);
				return;
			}
		   #endif

			peer->clearMaskedRegion();

			RectangleList originalRepaintRegion (regionsNeedingRepaint);
			regionsNeedingRepaint.clear();
			const Rectangle<int> totalArea (originalRepaintRegion.getBounds());

			if (! totalArea.isEmpty())
			{
				if (image.isNull() || image.getWidth() < totalArea.getWidth()
					 || image.getHeight() < totalArea.getHeight())
				{
				   #if JUCE_USE_XSHM
					image = Image (new XBitmapImage (useARGBImagesForRendering ? Image::ARGB
																			   : Image::RGB,
				   #else
					image = Image (new XBitmapImage (Image::RGB,
				   #endif
													 (totalArea.getWidth() + 31) & ~31,
													 (totalArea.getHeight() + 31) & ~31,
													 false, peer->depth, peer->visual));
				}

				startTimer (repaintTimerPeriod);

				RectangleList adjustedList (originalRepaintRegion);
				adjustedList.offsetAll (-totalArea.getX(), -totalArea.getY());

				if (peer->depth == 32)
				{
					RectangleList::Iterator i (originalRepaintRegion);

					while (i.next())
						image.clear (*i.getRectangle() - totalArea.getPosition());
				}

				{
					ScopedPointer<LowLevelGraphicsContext> context (peer->getComponent()->getLookAndFeel()
																	  .createGraphicsContext (image, -totalArea.getPosition(), adjustedList));
					peer->handlePaint (*context);
				}

				if (! peer->maskedRegion.isEmpty())
					originalRepaintRegion.subtract (peer->maskedRegion);

				for (RectangleList::Iterator i (originalRepaintRegion); i.next();)
				{
				   #if JUCE_USE_XSHM
					shmCompletedDrawing = false;
				   #endif
					const Rectangle<int>& r = *i.getRectangle();

					static_cast<XBitmapImage*> (image.getPixelData())
						->blitToWindow (peer->windowH,
										r.getX(), r.getY(), r.getWidth(), r.getHeight(),
										r.getX() - totalArea.getX(), r.getY() - totalArea.getY());
				}
			}

			lastTimeImageUsed = Time::getApproximateMillisecondCounter();
			startTimer (repaintTimerPeriod);
		}

	   #if JUCE_USE_XSHM
		void notifyPaintCompleted()                 { shmCompletedDrawing = true; }
	   #endif

	private:
		enum { repaintTimerPeriod = 1000 / 100 };

		LinuxComponentPeer* const peer;
		Image image;
		uint32 lastTimeImageUsed;
		RectangleList regionsNeedingRepaint;

	   #if JUCE_USE_XSHM
		bool useARGBImagesForRendering, shmCompletedDrawing;
	   #endif
		JUCE_DECLARE_NON_COPYABLE (LinuxRepaintManager);
	};

	ScopedPointer <LinuxRepaintManager> repainter;

	friend class LinuxRepaintManager;
	Window windowH, parentWindow;
	int wx, wy, ww, wh;
	Image taskbarImage;
	bool fullScreen, mapped;
	Visual* visual;
	int depth;
	BorderSize<int> windowBorder;
	enum { KeyPressEventType = 2 };

	struct MotifWmHints
	{
		unsigned long flags;
		unsigned long functions;
		unsigned long decorations;
		long input_mode;
		unsigned long status;
	};

	static void updateKeyStates (const int keycode, const bool press) noexcept
	{
		const int keybyte = keycode >> 3;
		const int keybit = (1 << (keycode & 7));

		if (press)
			Keys::keyStates [keybyte] |= keybit;
		else
			Keys::keyStates [keybyte] &= ~keybit;
	}

	static void updateKeyModifiers (const int status) noexcept
	{
		int keyMods = 0;

		if ((status & ShiftMask) != 0)     keyMods |= ModifierKeys::shiftModifier;
		if ((status & ControlMask) != 0)   keyMods |= ModifierKeys::ctrlModifier;
		if ((status & Keys::AltMask) != 0) keyMods |= ModifierKeys::altModifier;

		currentModifiers = currentModifiers.withOnlyMouseButtons().withFlags (keyMods);

		Keys::numLock  = ((status & Keys::NumLockMask) != 0);
		Keys::capsLock = ((status & LockMask) != 0);
	}

	static bool updateKeyModifiersFromSym (KeySym sym, const bool press) noexcept
	{
		int modifier = 0;
		bool isModifier = true;

		switch (sym)
		{
			case XK_Shift_L:
			case XK_Shift_R:
				modifier = ModifierKeys::shiftModifier;
				break;

			case XK_Control_L:
			case XK_Control_R:
				modifier = ModifierKeys::ctrlModifier;
				break;

			case XK_Alt_L:
			case XK_Alt_R:
				modifier = ModifierKeys::altModifier;
				break;

			case XK_Num_Lock:
				if (press)
					Keys::numLock = ! Keys::numLock;

				break;

			case XK_Caps_Lock:
				if (press)
					Keys::capsLock = ! Keys::capsLock;

				break;

			case XK_Scroll_Lock:
				break;

			default:
				isModifier = false;
				break;
		}

		currentModifiers = press ? currentModifiers.withFlags (modifier)
								 : currentModifiers.withoutFlags (modifier);

		return isModifier;
	}

	// Alt and Num lock are not defined by standard X
	// modifier constants: check what they're mapped to
	static void updateModifierMappings() noexcept
	{
		ScopedXLock xlock;
		const int altLeftCode = XKeysymToKeycode (display, XK_Alt_L);
		const int numLockCode = XKeysymToKeycode (display, XK_Num_Lock);

		Keys::AltMask = 0;
		Keys::NumLockMask = 0;

		XModifierKeymap* mapping = XGetModifierMapping (display);

		if (mapping)
		{
			for (int i = 0; i < 8; i++)
			{
				if (mapping->modifiermap [i << 1] == altLeftCode)
					Keys::AltMask = 1 << i;
				else if (mapping->modifiermap [i << 1] == numLockCode)
					Keys::NumLockMask = 1 << i;
			}

			XFreeModifiermap (mapping);
		}
	}

	static void xchangeProperty (Window wndH, Atom property, Atom type, int format, const void* data, int numElements)
	{
		XChangeProperty (display, wndH, property, type, format, PropModeReplace, (const unsigned char*) data, numElements);
	}

	void removeWindowDecorations (Window wndH)
	{
		Atom hints = Atoms::getIfExists ("_MOTIF_WM_HINTS");

		if (hints != None)
		{
			MotifWmHints motifHints = { 0 };
			motifHints.flags = 2; /* MWM_HINTS_DECORATIONS */
			motifHints.decorations = 0;

			ScopedXLock xlock;
			xchangeProperty (wndH, hints, hints, 32, &motifHints, 4);
		}

		hints = Atoms::getIfExists ("_WIN_HINTS");

		if (hints != None)
		{
			long gnomeHints = 0;

			ScopedXLock xlock;
			xchangeProperty (wndH, hints, hints, 32, &gnomeHints, 1);
		}

		hints = Atoms::getIfExists ("KWM_WIN_DECORATION");

		if (hints != None)
		{
			long kwmHints = 2; /*KDE_tinyDecoration*/

			ScopedXLock xlock;
			xchangeProperty (wndH, hints, hints, 32, &kwmHints, 1);
		}
	}

	void addWindowButtons (Window wndH)
	{
		ScopedXLock xlock;
		Atom hints = Atoms::getIfExists ("_MOTIF_WM_HINTS");

		if (hints != None)
		{
			MotifWmHints motifHints = { 0 };
			motifHints.flags = 1 | 2; /* MWM_HINTS_FUNCTIONS | MWM_HINTS_DECORATIONS */
			motifHints.decorations = 2 /* MWM_DECOR_BORDER */ | 8 /* MWM_DECOR_TITLE */ | 16; /* MWM_DECOR_MENU */

			motifHints.functions = 4 /* MWM_FUNC_MOVE */;

			if ((styleFlags & windowHasCloseButton) != 0)
				motifHints.functions |= 32; /* MWM_FUNC_CLOSE */

			if ((styleFlags & windowHasMinimiseButton) != 0)
			{
				motifHints.functions |= 8; /* MWM_FUNC_MINIMIZE */
				motifHints.decorations |= 0x20; /* MWM_DECOR_MINIMIZE */
			}

			if ((styleFlags & windowHasMaximiseButton) != 0)
			{
				motifHints.functions |= 0x10; /* MWM_FUNC_MAXIMIZE */
				motifHints.decorations |= 0x40; /* MWM_DECOR_MAXIMIZE */
			}

			if ((styleFlags & windowIsResizable) != 0)
			{
				motifHints.functions |= 2; /* MWM_FUNC_RESIZE */
				motifHints.decorations |= 0x4; /* MWM_DECOR_RESIZEH */
			}

			xchangeProperty (wndH, hints, hints, 32, &motifHints, 5);
		}

		hints = Atoms::getIfExists ("_NET_WM_ALLOWED_ACTIONS");

		if (hints != None)
		{
			Atom netHints [6];
			int num = 0;

			if ((styleFlags & windowIsResizable) != 0)
				netHints [num++] = Atoms::getIfExists ("_NET_WM_ACTION_RESIZE");

			if ((styleFlags & windowHasMaximiseButton) != 0)
				netHints [num++] = Atoms::getIfExists ("_NET_WM_ACTION_FULLSCREEN");

			if ((styleFlags & windowHasMinimiseButton) != 0)
				netHints [num++] = Atoms::getIfExists ("_NET_WM_ACTION_MINIMIZE");

			if ((styleFlags & windowHasCloseButton) != 0)
				netHints [num++] = Atoms::getIfExists ("_NET_WM_ACTION_CLOSE");

			xchangeProperty (wndH, hints, XA_ATOM, 32, &netHints, num);
		}
	}

	void setWindowType()
	{
		Atom netHints [2];

		if ((styleFlags & windowIsTemporary) != 0
			 || ((styleFlags & windowHasDropShadow) == 0 && Desktop::canUseSemiTransparentWindows()))
			netHints [0] = Atoms::getIfExists ("_NET_WM_WINDOW_TYPE_COMBO");
		else
			netHints [0] = Atoms::getIfExists ("_NET_WM_WINDOW_TYPE_NORMAL");

		netHints[1] = Atoms::getIfExists ("_KDE_NET_WM_WINDOW_TYPE_OVERRIDE");

		xchangeProperty (windowH, Atoms::WindowType, XA_ATOM, 32, &netHints, 2);

		int numHints = 0;

		if ((styleFlags & windowAppearsOnTaskbar) == 0)
			netHints [numHints++] = Atoms::getIfExists ("_NET_WM_STATE_SKIP_TASKBAR");

		if (component->isAlwaysOnTop())
			netHints [numHints++] = Atoms::getIfExists ("_NET_WM_STATE_ABOVE");

		if (numHints > 0)
			xchangeProperty (windowH, Atoms::WindowState, XA_ATOM, 32, &netHints, numHints);
	}

	void createWindow (Window parentToAddTo)
	{
		ScopedXLock xlock;
		Atoms::initialiseAtoms();
		resetDragAndDrop();

		// Get defaults for various properties
		const int screen = DefaultScreen (display);
		Window root = RootWindow (display, screen);

		// Try to obtain a 32-bit visual or fallback to 24 or 16
		visual = Visuals::findVisualFormat ((styleFlags & windowIsSemiTransparent) ? 32 : 24, depth);

		if (visual == 0)
		{
			Logger::outputDebugString ("ERROR: System doesn't support 32, 24 or 16 bit RGB display.\n");
			Process::terminate();
		}

		// Create and install a colormap suitable fr our visual
		Colormap colormap = XCreateColormap (display, root, visual, AllocNone);
		XInstallColormap (display, colormap);

		// Set up the window attributes
		XSetWindowAttributes swa;
		swa.border_pixel = 0;
		swa.background_pixmap = None;
		swa.colormap = colormap;
		swa.override_redirect = (getComponent()->isAlwaysOnTop() && (styleFlags & windowIsTemporary) != 0) ? True : False;
		swa.event_mask = getAllEventsMask();

		windowH = XCreateWindow (display, parentToAddTo != 0 ? parentToAddTo : root,
								 0, 0, 1, 1,
								 0, depth, InputOutput, visual,
								 CWBorderPixel | CWColormap | CWBackPixmap | CWEventMask | CWOverrideRedirect,
								 &swa);

		XGrabButton (display, AnyButton, AnyModifier, windowH, False,
					 ButtonPressMask | ButtonReleaseMask | EnterWindowMask | LeaveWindowMask | PointerMotionMask,
					 GrabModeAsync, GrabModeAsync, None, None);

		// Set the window context to identify the window handle object
		if (XSaveContext (display, (XID) windowH, windowHandleXContext, (XPointer) this))
		{
			// Failed
			jassertfalse;
			Logger::outputDebugString ("Failed to create context information for window.\n");
			XDestroyWindow (display, windowH);
			windowH = 0;
			return;
		}

		// Set window manager hints
		XWMHints* wmHints = XAllocWMHints();
		wmHints->flags = InputHint | StateHint;
		wmHints->input = True;      // Locally active input model
		wmHints->initial_state = NormalState;
		XSetWMHints (display, windowH, wmHints);
		XFree (wmHints);

		// Set the window type
		setWindowType();

		// Define decoration
		if ((styleFlags & windowHasTitleBar) == 0)
			removeWindowDecorations (windowH);
		else
			addWindowButtons (windowH);

		setTitle (getComponent()->getName());

		// Associate the PID, allowing to be shut down when something goes wrong
		unsigned long pid = getpid();
		xchangeProperty (windowH, Atoms::Pid, XA_CARDINAL, 32, &pid, 1);

		// Set window manager protocols
		xchangeProperty (windowH, Atoms::Protocols, XA_ATOM, 32, Atoms::ProtocolList, 2);

		// Set drag and drop flags
		xchangeProperty (windowH, Atoms::XdndTypeList, XA_ATOM, 32, Atoms::allowedMimeTypes, numElementsInArray (Atoms::allowedMimeTypes));
		xchangeProperty (windowH, Atoms::XdndActionList, XA_ATOM, 32, Atoms::allowedActions, numElementsInArray (Atoms::allowedActions));
		xchangeProperty (windowH, Atoms::XdndActionDescription, XA_STRING, 8, "", 0);
		xchangeProperty (windowH, Atoms::XdndAware, XA_ATOM, 32, &Atoms::DndVersion, 1);

		initialisePointerMap();
		updateModifierMappings();
	}

	void destroyWindow()
	{
		ScopedXLock xlock;

		XPointer handlePointer;
		if (! XFindContext (display, (XID) windowH, windowHandleXContext, &handlePointer))
			XDeleteContext (display, (XID) windowH, windowHandleXContext);

		XDestroyWindow (display, windowH);

		// Wait for it to complete and then remove any events for this
		// window from the event queue.
		XSync (display, false);

		XEvent event;
		while (XCheckWindowEvent (display, windowH, getAllEventsMask(), &event) == True)
		{}
	}

	static int getAllEventsMask() noexcept
	{
		return NoEventMask | KeyPressMask | KeyReleaseMask | ButtonPressMask | ButtonReleaseMask
				 | EnterWindowMask | LeaveWindowMask | PointerMotionMask | KeymapStateMask
				 | ExposureMask | StructureNotifyMask | FocusChangeMask;
	}

	static int64 getEventTime (::Time t)
	{
		static int64 eventTimeOffset = 0x12345678;
		const int64 thisMessageTime = t;

		if (eventTimeOffset == 0x12345678)
			eventTimeOffset = Time::currentTimeMillis() - thisMessageTime;

		return eventTimeOffset + thisMessageTime;
	}

	void updateBorderSize()
	{
		if ((styleFlags & windowHasTitleBar) == 0)
		{
			windowBorder = BorderSize<int> (0);
		}
		else if (windowBorder.getTopAndBottom() == 0 && windowBorder.getLeftAndRight() == 0)
		{
			ScopedXLock xlock;
			Atom hints = Atoms::getIfExists ("_NET_FRAME_EXTENTS");

			if (hints != None)
			{
				unsigned char* data = nullptr;
				unsigned long nitems, bytesLeft;
				Atom actualType;
				int actualFormat;

				if (XGetWindowProperty (display, windowH, hints, 0, 4, False,
										XA_CARDINAL, &actualType, &actualFormat, &nitems, &bytesLeft,
										&data) == Success)
				{
					const unsigned long* const sizes = (const unsigned long*) data;

					if (actualFormat == 32)
						windowBorder = BorderSize<int> ((int) sizes[2], (int) sizes[0],
														(int) sizes[3], (int) sizes[1]);

					XFree (data);
				}
			}
		}
	}

	void updateBounds()
	{
		jassert (windowH != 0);
		if (windowH != 0)
		{
			Window root, child;
			unsigned int bw, depth;
			ScopedXLock xlock;

			if (! XGetGeometry (display, (::Drawable) windowH, &root,
								&wx, &wy, (unsigned int*) &ww, (unsigned int*) &wh,
								&bw, &depth))
			{
				wx = wy = ww = wh = 0;
			}
			else if (! XTranslateCoordinates (display, windowH, root, 0, 0, &wx, &wy, &child))
			{
				wx = wy = 0;
			}
		}
	}

	void resetDragAndDrop()
	{
		dragAndDropFiles.clear();
		lastDropPos = Point<int> (-1, -1);
		dragAndDropCurrentMimeType = 0;
		dragAndDropSourceWindow = 0;
		srcMimeTypeAtomList.clear();
	}

	void sendDragAndDropMessage (XClientMessageEvent& msg)
	{
		msg.type = ClientMessage;
		msg.display = display;
		msg.window = dragAndDropSourceWindow;
		msg.format = 32;
		msg.data.l[0] = windowH;

		ScopedXLock xlock;
		XSendEvent (display, dragAndDropSourceWindow, False, 0, (XEvent*) &msg);
	}

	void sendDragAndDropStatus (const bool acceptDrop, Atom dropAction)
	{
		XClientMessageEvent msg = { 0 };
		msg.message_type = Atoms::XdndStatus;
		msg.data.l[1] = (acceptDrop ? 1 : 0) | 2; // 2 indicates that we want to receive position messages
		msg.data.l[4] = dropAction;

		sendDragAndDropMessage (msg);
	}

	void sendDragAndDropLeave()
	{
		XClientMessageEvent msg = { 0 };
		msg.message_type = Atoms::XdndLeave;
		sendDragAndDropMessage (msg);
	}

	void sendDragAndDropFinish()
	{
		XClientMessageEvent msg = { 0 };
		msg.message_type = Atoms::XdndFinished;
		sendDragAndDropMessage (msg);
	}

	void handleDragAndDropStatus (const XClientMessageEvent* const clientMsg)
	{
		if ((clientMsg->data.l[1] & 1) == 0)
		{
			sendDragAndDropLeave();

			if (dragAndDropFiles.size() > 0)
				handleFileDragExit (dragAndDropFiles);

			dragAndDropFiles.clear();
		}
	}

	void handleDragAndDropPosition (const XClientMessageEvent* const clientMsg)
	{
		if (dragAndDropSourceWindow == 0)
			return;

		dragAndDropSourceWindow = clientMsg->data.l[0];

		Point<int> dropPos ((int) clientMsg->data.l[2] >> 16,
							(int) clientMsg->data.l[2] & 0xffff);
		dropPos -= getScreenPosition();

		if (lastDropPos != dropPos)
		{
			lastDropPos = dropPos;
			dragAndDropTimestamp = clientMsg->data.l[3];

			Atom targetAction = Atoms::XdndActionCopy;

			for (int i = numElementsInArray (Atoms::allowedActions); --i >= 0;)
			{
				if ((Atom) clientMsg->data.l[4] == Atoms::allowedActions[i])
				{
					targetAction = Atoms::allowedActions[i];
					break;
				}
			}

			sendDragAndDropStatus (true, targetAction);

			if (dragAndDropFiles.size() == 0)
				updateDraggedFileList (clientMsg);

			if (dragAndDropFiles.size() > 0)
				handleFileDragMove (dragAndDropFiles, dropPos);
		}
	}

	void handleDragAndDropDrop (const XClientMessageEvent* const clientMsg)
	{
		if (dragAndDropFiles.size() == 0)
			updateDraggedFileList (clientMsg);

		const StringArray files (dragAndDropFiles);
		const Point<int> lastPos (lastDropPos);

		sendDragAndDropFinish();
		resetDragAndDrop();

		if (files.size() > 0)
			handleFileDragDrop (files, lastPos);
	}

	void handleDragAndDropEnter (const XClientMessageEvent* const clientMsg)
	{
		dragAndDropFiles.clear();
		srcMimeTypeAtomList.clear();

		dragAndDropCurrentMimeType = 0;
		const unsigned long dndCurrentVersion = static_cast <unsigned long> (clientMsg->data.l[1] & 0xff000000) >> 24;

		if (dndCurrentVersion < 3 || dndCurrentVersion > Atoms::DndVersion)
		{
			dragAndDropSourceWindow = 0;
			return;
		}

		dragAndDropSourceWindow = clientMsg->data.l[0];

		if ((clientMsg->data.l[1] & 1) != 0)
		{
			Atom actual;
			int format;
			unsigned long count = 0, remaining = 0;
			unsigned char* data = 0;

			ScopedXLock xlock;
			XGetWindowProperty (display, dragAndDropSourceWindow, Atoms::XdndTypeList,
								0, 0x8000000L, False, XA_ATOM, &actual, &format,
								&count, &remaining, &data);

			if (data != 0)
			{
				if (actual == XA_ATOM && format == 32 && count != 0)
				{
					const unsigned long* const types = (const unsigned long*) data;

					for (unsigned int i = 0; i < count; ++i)
						if (types[i] != None)
							srcMimeTypeAtomList.add (types[i]);
				}

				XFree (data);
			}
		}

		if (srcMimeTypeAtomList.size() == 0)
		{
			for (int i = 2; i < 5; ++i)
				if (clientMsg->data.l[i] != None)
					srcMimeTypeAtomList.add (clientMsg->data.l[i]);

			if (srcMimeTypeAtomList.size() == 0)
			{
				dragAndDropSourceWindow = 0;
				return;
			}
		}

		for (int i = 0; i < srcMimeTypeAtomList.size() && dragAndDropCurrentMimeType == 0; ++i)
			for (int j = 0; j < numElementsInArray (Atoms::allowedMimeTypes); ++j)
				if (srcMimeTypeAtomList[i] == Atoms::allowedMimeTypes[j])
					dragAndDropCurrentMimeType = Atoms::allowedMimeTypes[j];

		handleDragAndDropPosition (clientMsg);
	}

	void handleDragAndDropSelection (const XEvent* const evt)
	{
		dragAndDropFiles.clear();

		if (evt->xselection.property != 0)
		{
			StringArray lines;

			{
				MemoryBlock dropData;

				for (;;)
				{
					Atom actual;
					uint8* data = 0;
					unsigned long count = 0, remaining = 0;
					int format = 0;
					ScopedXLock xlock;

					if (XGetWindowProperty (display, evt->xany.window, evt->xselection.property,
											dropData.getSize() / 4, 65536, 1, AnyPropertyType, &actual,
											&format, &count, &remaining, &data) == Success)
					{
						dropData.append (data, count * format / 8);
						XFree (data);

						if (remaining == 0)
							break;
					}
					else
					{
						XFree (data);
						break;
					}
				}

				lines.addLines (dropData.toString());
			}

			for (int i = 0; i < lines.size(); ++i)
				dragAndDropFiles.add (URL::removeEscapeChars (lines[i].fromFirstOccurrenceOf ("file://", false, true)));

			dragAndDropFiles.trim();
			dragAndDropFiles.removeEmptyStrings();
		}
	}

	void updateDraggedFileList (const XClientMessageEvent* const clientMsg)
	{
		dragAndDropFiles.clear();

		if (dragAndDropSourceWindow != None
			 && dragAndDropCurrentMimeType != 0)
		{
			dragAndDropTimestamp = clientMsg->data.l[2];

			ScopedXLock xlock;
			XConvertSelection (display,
							   Atoms::XdndSelection,
							   dragAndDropCurrentMimeType,
							   Atoms::getCreating ("JXSelectionWindowProperty"),
							   windowH,
							   dragAndDropTimestamp);
		}
	}

	StringArray dragAndDropFiles;
	int dragAndDropTimestamp;
	Point<int> lastDropPos;

	Atom dragAndDropCurrentMimeType;
	Window dragAndDropSourceWindow;

	Array <Atom> srcMimeTypeAtomList;

	int pointerMap[5];

	void initialisePointerMap()
	{
		const int numButtons = XGetPointerMapping (display, 0, 0);

		if (numButtons == 2)
		{
			pointerMap[0] = Keys::LeftButton;
			pointerMap[1] = Keys::RightButton;
			pointerMap[2] = pointerMap[3] = pointerMap[4] = Keys::NoButton;
		}
		else if (numButtons >= 3)
		{
			pointerMap[0] = Keys::LeftButton;
			pointerMap[1] = Keys::MiddleButton;
			pointerMap[2] = Keys::RightButton;

			if (numButtons >= 5)
			{
				pointerMap[3] = Keys::WheelUp;
				pointerMap[4] = Keys::WheelDown;
			}
		}
	}

	static Point<int> lastMousePos;

	static void clearLastMousePos() noexcept
	{
		lastMousePos = Point<int> (0x100000, 0x100000);
	}

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (LinuxComponentPeer);
};

ModifierKeys LinuxComponentPeer::currentModifiers;
bool LinuxComponentPeer::isActiveApplication = false;
Point<int> LinuxComponentPeer::lastMousePos;

bool Process::isForegroundProcess()
{
	return LinuxComponentPeer::isActiveApplication;
}

void ModifierKeys::updateCurrentModifiers() noexcept
{
	currentModifiers = LinuxComponentPeer::currentModifiers;
}

ModifierKeys ModifierKeys::getCurrentModifiersRealtime() noexcept
{
	Window root, child;
	int x, y, winx, winy;
	unsigned int mask;
	int mouseMods = 0;

	ScopedXLock xlock;

	if (XQueryPointer (display, RootWindow (display, DefaultScreen (display)),
					   &root, &child, &x, &y, &winx, &winy, &mask) != False)
	{
		if ((mask & Button1Mask) != 0)  mouseMods |= ModifierKeys::leftButtonModifier;
		if ((mask & Button2Mask) != 0)  mouseMods |= ModifierKeys::middleButtonModifier;
		if ((mask & Button3Mask) != 0)  mouseMods |= ModifierKeys::rightButtonModifier;
	}

	LinuxComponentPeer::currentModifiers = LinuxComponentPeer::currentModifiers.withoutMouseButtons().withFlags (mouseMods);
	return LinuxComponentPeer::currentModifiers;
}

void Desktop::setKioskComponent (Component* kioskModeComponent, bool enableOrDisable, bool allowMenusAndBars)
{
	if (enableOrDisable)
		kioskModeComponent->setBounds (Desktop::getInstance().getMainMonitorArea (false));
}

ComponentPeer* Component::createNewPeer (int styleFlags, void* nativeWindowToAttachTo)
{
	return new LinuxComponentPeer (this, styleFlags, (Window) nativeWindowToAttachTo);
}

// (this callback is hooked up in the messaging code)
void juce_windowMessageReceive (XEvent* event)
{
	if (event->xany.window != None)
	{
		LinuxComponentPeer* const peer = LinuxComponentPeer::getPeerFor (event->xany.window);

		if (ComponentPeer::isValidPeer (peer))
			peer->handleWindowMessage (event);
	}
	else
	{
		switch (event->xany.type)
		{
			case KeymapNotify:
			{
				const XKeymapEvent* const keymapEvent = (const XKeymapEvent*) &event->xkeymap;
				memcpy (Keys::keyStates, keymapEvent->key_vector, 32);
				break;
			}

			default:
				break;
		}
	}
}

void Desktop::getCurrentMonitorPositions (Array <Rectangle<int> >& monitorCoords, const bool /*clipToWorkArea*/)
{
	if (display == 0)
		return;

  #if JUCE_USE_XINERAMA
	int major_opcode, first_event, first_error;

	ScopedXLock xlock;
	if (XQueryExtension (display, "XINERAMA", &major_opcode, &first_event, &first_error))
	{
		typedef Bool (*tXineramaIsActive) (Display*);
		typedef XineramaScreenInfo* (*tXineramaQueryScreens) (Display*, int*);

		static tXineramaIsActive xXineramaIsActive = 0;
		static tXineramaQueryScreens xXineramaQueryScreens = 0;

		if (xXineramaIsActive == 0 || xXineramaQueryScreens == 0)
		{
			void* h = dlopen ("libXinerama.so", RTLD_GLOBAL | RTLD_NOW);

			if (h == 0)
				h = dlopen ("libXinerama.so.1", RTLD_GLOBAL | RTLD_NOW);

			if (h != 0)
			{
				xXineramaIsActive = (tXineramaIsActive) dlsym (h, "XineramaIsActive");
				xXineramaQueryScreens = (tXineramaQueryScreens) dlsym (h, "XineramaQueryScreens");
			}
		}

		if (xXineramaIsActive != 0
			&& xXineramaQueryScreens != 0
			&& xXineramaIsActive (display))
		{
			int numMonitors = 0;
			XineramaScreenInfo* const screens = xXineramaQueryScreens (display, &numMonitors);

			if (screens != 0)
			{
				for (int i = numMonitors; --i >= 0;)
				{
					int index = screens[i].screen_number;

					if (index >= 0)
					{
						while (monitorCoords.size() < index)
							monitorCoords.add (Rectangle<int>());

						monitorCoords.set (index, Rectangle<int> (screens[i].x_org,
																  screens[i].y_org,
																  screens[i].width,
																  screens[i].height));
					}
				}

				XFree (screens);
			}
		}
	}

	if (monitorCoords.size() == 0)
  #endif
	{
		Atom hints = Atoms::getIfExists ("_NET_WORKAREA");

		if (hints != None)
		{
			const int numMonitors = ScreenCount (display);

			for (int i = 0; i < numMonitors; ++i)
			{
				Window root = RootWindow (display, i);

				unsigned long nitems, bytesLeft;
				Atom actualType;
				int actualFormat;
				unsigned char* data = nullptr;

				if (XGetWindowProperty (display, root, hints, 0, 4, False,
										XA_CARDINAL, &actualType, &actualFormat, &nitems, &bytesLeft,
										&data) == Success)
				{
					const long* const position = (const long*) data;

					if (actualType == XA_CARDINAL && actualFormat == 32 && nitems == 4)
						monitorCoords.add (Rectangle<int> (position[0], position[1],
														   position[2], position[3]));

					XFree (data);
				}
			}
		}

		if (monitorCoords.size() == 0)
		{
			monitorCoords.add (Rectangle<int> (DisplayWidth (display, DefaultScreen (display)),
											   DisplayHeight (display, DefaultScreen (display))));
		}
	}
}

void Desktop::createMouseInputSources()
{
	mouseSources.add (new MouseInputSource (0, true));
}

bool Desktop::canUseSemiTransparentWindows() noexcept
{
	int matchedDepth = 0;
	const int desiredDepth = 32;

	return Visuals::findVisualFormat (desiredDepth, matchedDepth) != 0
			 && (matchedDepth == desiredDepth);
}

Point<int> MouseInputSource::getCurrentMousePosition()
{
	Window root, child;
	int x, y, winx, winy;
	unsigned int mask;

	ScopedXLock xlock;

	if (XQueryPointer (display,
					   RootWindow (display, DefaultScreen (display)),
					   &root, &child,
					   &x, &y, &winx, &winy, &mask) == False)
	{
		// Pointer not on the default screen
		x = y = -1;
	}

	return Point<int> (x, y);
}

void Desktop::setMousePosition (const Point<int>& newPosition)
{
	ScopedXLock xlock;
	Window root = RootWindow (display, DefaultScreen (display));
	XWarpPointer (display, None, root, 0, 0, 0, 0, newPosition.getX(), newPosition.getY());
}

Desktop::DisplayOrientation Desktop::getCurrentOrientation() const
{
	return upright;
}

static bool screenSaverAllowed = true;

void Desktop::setScreenSaverEnabled (const bool isEnabled)
{
	if (screenSaverAllowed != isEnabled)
	{
		screenSaverAllowed = isEnabled;

		typedef void (*tXScreenSaverSuspend) (Display*, Bool);
		static tXScreenSaverSuspend xScreenSaverSuspend = 0;

		if (xScreenSaverSuspend == 0)
		{
			void* h = dlopen ("libXss.so", RTLD_GLOBAL | RTLD_NOW);

			if (h != 0)
				xScreenSaverSuspend = (tXScreenSaverSuspend) dlsym (h, "XScreenSaverSuspend");
		}

		ScopedXLock xlock;
		if (xScreenSaverSuspend != 0)
			xScreenSaverSuspend (display, ! isEnabled);
	}
}

bool Desktop::isScreenSaverEnabled()
{
	return screenSaverAllowed;
}

void* MouseCursor::createMouseCursorFromImage (const Image& image, int hotspotX, int hotspotY)
{
	ScopedXLock xlock;
	const unsigned int imageW = image.getWidth();
	const unsigned int imageH = image.getHeight();

  #if JUCE_USE_XCURSOR
	{
		typedef XcursorBool (*tXcursorSupportsARGB) (Display*);
		typedef XcursorImage* (*tXcursorImageCreate) (int, int);
		typedef void (*tXcursorImageDestroy) (XcursorImage*);
		typedef Cursor (*tXcursorImageLoadCursor) (Display*, const XcursorImage*);

		static tXcursorSupportsARGB xXcursorSupportsARGB = 0;
		static tXcursorImageCreate xXcursorImageCreate = 0;
		static tXcursorImageDestroy xXcursorImageDestroy = 0;
		static tXcursorImageLoadCursor xXcursorImageLoadCursor = 0;
		static bool hasBeenLoaded = false;

		if (! hasBeenLoaded)
		{
			hasBeenLoaded = true;
			void* h = dlopen ("libXcursor.so", RTLD_GLOBAL | RTLD_NOW);

			if (h != 0)
			{
				xXcursorSupportsARGB    = (tXcursorSupportsARGB)    dlsym (h, "XcursorSupportsARGB");
				xXcursorImageCreate     = (tXcursorImageCreate)     dlsym (h, "XcursorImageCreate");
				xXcursorImageLoadCursor = (tXcursorImageLoadCursor) dlsym (h, "XcursorImageLoadCursor");
				xXcursorImageDestroy    = (tXcursorImageDestroy)    dlsym (h, "XcursorImageDestroy");

				if (xXcursorSupportsARGB == 0 || xXcursorImageCreate == 0
					  || xXcursorImageLoadCursor == 0 || xXcursorImageDestroy == 0
					  || ! xXcursorSupportsARGB (display))
					xXcursorSupportsARGB = 0;
			}
		}

		if (xXcursorSupportsARGB != 0)
		{
			XcursorImage* xcImage = xXcursorImageCreate (imageW, imageH);

			if (xcImage != 0)
			{
				xcImage->xhot = hotspotX;
				xcImage->yhot = hotspotY;
				XcursorPixel* dest = xcImage->pixels;

				for (int y = 0; y < (int) imageH; ++y)
					for (int x = 0; x < (int) imageW; ++x)
						*dest++ = image.getPixelAt (x, y).getARGB();

				void* result = (void*) xXcursorImageLoadCursor (display, xcImage);
				xXcursorImageDestroy (xcImage);

				if (result != 0)
					return result;
			}
		}
	}
  #endif

	Window root = RootWindow (display, DefaultScreen (display));
	unsigned int cursorW, cursorH;
	if (! XQueryBestCursor (display, root, imageW, imageH, &cursorW, &cursorH))
		return nullptr;

	Image im (Image::ARGB, cursorW, cursorH, true);

	{
		Graphics g (im);

		if (imageW > cursorW || imageH > cursorH)
		{
			hotspotX = (hotspotX * cursorW) / imageW;
			hotspotY = (hotspotY * cursorH) / imageH;

			g.drawImageWithin (image, 0, 0, imageW, imageH,
							   RectanglePlacement::xLeft | RectanglePlacement::yTop | RectanglePlacement::onlyReduceInSize,
							   false);
		}
		else
		{
			g.drawImageAt (image, 0, 0);
		}
	}

	const int stride = (cursorW + 7) >> 3;
	HeapBlock <char> maskPlane, sourcePlane;
	maskPlane.calloc (stride * cursorH);
	sourcePlane.calloc (stride * cursorH);

	const bool msbfirst = (BitmapBitOrder (display) == MSBFirst);

	for (int y = cursorH; --y >= 0;)
	{
		for (int x = cursorW; --x >= 0;)
		{
			const char mask = (char) (1 << (msbfirst ? (7 - (x & 7)) : (x & 7)));
			const int offset = y * stride + (x >> 3);

			const Colour c (im.getPixelAt (x, y));

			if (c.getAlpha() >= 128)
				maskPlane[offset] |= mask;

			if (c.getBrightness() >= 0.5f)
				sourcePlane[offset] |= mask;
		}
	}

	Pixmap sourcePixmap = XCreatePixmapFromBitmapData (display, root, sourcePlane.getData(), cursorW, cursorH, 0xffff, 0, 1);
	Pixmap maskPixmap = XCreatePixmapFromBitmapData (display, root, maskPlane.getData(), cursorW, cursorH, 0xffff, 0, 1);

	XColor white, black;
	black.red = black.green = black.blue = 0;
	white.red = white.green = white.blue = 0xffff;

	void* result = (void*) XCreatePixmapCursor (display, sourcePixmap, maskPixmap, &white, &black, hotspotX, hotspotY);

	XFreePixmap (display, sourcePixmap);
	XFreePixmap (display, maskPixmap);

	return result;
}

void MouseCursor::deleteMouseCursor (void* const cursorHandle, const bool)
{
	ScopedXLock xlock;
	if (cursorHandle != 0)
		XFreeCursor (display, (Cursor) cursorHandle);
}

void* MouseCursor::createStandardMouseCursor (MouseCursor::StandardCursorType type)
{
	unsigned int shape;

	switch (type)
	{
		case NormalCursor:                  return None; // Use parent cursor
		case NoCursor:                      return createMouseCursorFromImage (Image (Image::ARGB, 16, 16, true), 0, 0);

		case WaitCursor:                    shape = XC_watch; break;
		case IBeamCursor:                   shape = XC_xterm; break;
		case PointingHandCursor:            shape = XC_hand2; break;
		case LeftRightResizeCursor:         shape = XC_sb_h_double_arrow; break;
		case UpDownResizeCursor:            shape = XC_sb_v_double_arrow; break;
		case UpDownLeftRightResizeCursor:   shape = XC_fleur; break;
		case TopEdgeResizeCursor:           shape = XC_top_side; break;
		case BottomEdgeResizeCursor:        shape = XC_bottom_side; break;
		case LeftEdgeResizeCursor:          shape = XC_left_side; break;
		case RightEdgeResizeCursor:         shape = XC_right_side; break;
		case TopLeftCornerResizeCursor:     shape = XC_top_left_corner; break;
		case TopRightCornerResizeCursor:    shape = XC_top_right_corner; break;
		case BottomLeftCornerResizeCursor:  shape = XC_bottom_left_corner; break;
		case BottomRightCornerResizeCursor: shape = XC_bottom_right_corner; break;
		case CrosshairCursor:               shape = XC_crosshair; break;

		case DraggingHandCursor:
		{
			static unsigned char dragHandData[] = { 71,73,70,56,57,97,16,0,16,0,145,2,0,0,0,0,255,255,255,0,
			  0,0,0,0,0,33,249,4,1,0,0,2,0,44,0,0,0,0,16,0, 16,0,0,2,52,148,47,0,200,185,16,130,90,12,74,139,107,84,123,39,
			  132,117,151,116,132,146,248,60,209,138,98,22,203,114,34,236,37,52,77,217, 247,154,191,119,110,240,193,128,193,95,163,56,60,234,98,135,2,0,59 };
			const int dragHandDataSize = 99;

			return createMouseCursorFromImage (ImageFileFormat::loadFrom (dragHandData, dragHandDataSize), 8, 7);
		}

		case CopyingCursor:
		{
			static unsigned char copyCursorData[] = { 71,73,70,56,57,97,21,0,21,0,145,0,0,0,0,0,255,255,255,0,
			  128,128,255,255,255,33,249,4,1,0,0,3,0,44,0,0,0,0,21,0, 21,0,0,2,72,4,134,169,171,16,199,98,11,79,90,71,161,93,56,111,
			  78,133,218,215,137,31,82,154,100,200,86,91,202,142,12,108,212,87,235,174, 15,54,214,126,237,226,37,96,59,141,16,37,18,201,142,157,230,204,51,112,
			  252,114,147,74,83,5,50,68,147,208,217,16,71,149,252,124,5,0,59,0,0 };
			const int copyCursorSize = 119;

			return createMouseCursorFromImage (ImageFileFormat::loadFrom (copyCursorData, copyCursorSize), 1, 3);
		}

		default:
			jassertfalse;
			return None;
	}

	ScopedXLock xlock;
	return (void*) XCreateFontCursor (display, shape);
}

void MouseCursor::showInWindow (ComponentPeer* peer) const
{
	LinuxComponentPeer* const lp = dynamic_cast <LinuxComponentPeer*> (peer);

	if (lp != 0)
		lp->showMouseCursor ((Cursor) getHandle());
}

void MouseCursor::showInAllWindows() const
{
	for (int i = ComponentPeer::getNumPeers(); --i >= 0;)
		showInWindow (ComponentPeer::getPeer (i));
}

Image juce_createIconForFile (const File& file)
{
	return Image::null;
}

ImagePixelData* NativeImageType::create (Image::PixelFormat format, int width, int height, bool clearImage) const
{
	return SoftwareImageType().create (format, width, height, clearImage);
}

bool DragAndDropContainer::performExternalDragDropOfFiles (const StringArray& files, const bool canMoveFiles)
{
	jassertfalse;    // not implemented!
	return false;
}

bool DragAndDropContainer::performExternalDragDropOfText (const String& text)
{
	jassertfalse;    // not implemented!
	return false;
}

void LookAndFeel::playAlertSound()
{
	std::cout << "\a" << std::flush;
}

void JUCE_CALLTYPE NativeMessageBox::showMessageBox (AlertWindow::AlertIconType iconType,
													 const String& title, const String& message,
													 Component* associatedComponent)
{
	AlertWindow::showMessageBox (AlertWindow::NoIcon, title, message);
}

void JUCE_CALLTYPE NativeMessageBox::showMessageBoxAsync (AlertWindow::AlertIconType iconType,
														  const String& title, const String& message,
														  Component* associatedComponent)
{
	AlertWindow::showMessageBoxAsync (AlertWindow::NoIcon, title, message);
}

bool JUCE_CALLTYPE NativeMessageBox::showOkCancelBox (AlertWindow::AlertIconType iconType,
													  const String& title, const String& message,
													  Component* associatedComponent,
													  ModalComponentManager::Callback* callback)
{
	return AlertWindow::showOkCancelBox (iconType, title, message, String::empty, String::empty,
										 associatedComponent, callback);
}

int JUCE_CALLTYPE NativeMessageBox::showYesNoCancelBox (AlertWindow::AlertIconType iconType,
														const String& title, const String& message,
														Component* associatedComponent,
														ModalComponentManager::Callback* callback)
{
	return AlertWindow::showYesNoCancelBox (iconType, title, message,
											String::empty, String::empty, String::empty,
											associatedComponent, callback);
}

const int KeyPress::spaceKey                = XK_space & 0xff;
const int KeyPress::returnKey               = XK_Return & 0xff;
const int KeyPress::escapeKey               = XK_Escape & 0xff;
const int KeyPress::backspaceKey            = XK_BackSpace & 0xff;
const int KeyPress::leftKey                 = (XK_Left & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::rightKey                = (XK_Right & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::upKey                   = (XK_Up & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::downKey                 = (XK_Down & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::pageUpKey               = (XK_Page_Up & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::pageDownKey             = (XK_Page_Down & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::endKey                  = (XK_End & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::homeKey                 = (XK_Home & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::insertKey               = (XK_Insert & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::deleteKey               = (XK_Delete & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::tabKey                  = XK_Tab & 0xff;
const int KeyPress::F1Key                   = (XK_F1 & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::F2Key                   = (XK_F2 & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::F3Key                   = (XK_F3 & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::F4Key                   = (XK_F4 & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::F5Key                   = (XK_F5 & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::F6Key                   = (XK_F6 & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::F7Key                   = (XK_F7 & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::F8Key                   = (XK_F8 & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::F9Key                   = (XK_F9 & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::F10Key                  = (XK_F10 & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::F11Key                  = (XK_F11 & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::F12Key                  = (XK_F12 & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::F13Key                  = (XK_F13 & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::F14Key                  = (XK_F14 & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::F15Key                  = (XK_F15 & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::F16Key                  = (XK_F16 & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::numberPad0              = (XK_KP_0 & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::numberPad1              = (XK_KP_1 & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::numberPad2              = (XK_KP_2 & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::numberPad3              = (XK_KP_3 & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::numberPad4              = (XK_KP_4 & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::numberPad5              = (XK_KP_5 & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::numberPad6              = (XK_KP_6 & 0xff) | Keys::extendedKeyModifier;
const int KeyPress::numberPad7              = (XK_KP_7 & 0xff)| Keys::extendedKeyModifier;
const int KeyPress::numberPad8              = (XK_KP_8 & 0xff)| Keys::extendedKeyModifier;
const int KeyPress::numberPad9              = (XK_KP_9 & 0xff)| Keys::extendedKeyModifier;
const int KeyPress::numberPadAdd            = (XK_KP_Add & 0xff)| Keys::extendedKeyModifier;
const int KeyPress::numberPadSubtract       = (XK_KP_Subtract & 0xff)| Keys::extendedKeyModifier;
const int KeyPress::numberPadMultiply       = (XK_KP_Multiply & 0xff)| Keys::extendedKeyModifier;
const int KeyPress::numberPadDivide         = (XK_KP_Divide & 0xff)| Keys::extendedKeyModifier;
const int KeyPress::numberPadSeparator      = (XK_KP_Separator & 0xff)| Keys::extendedKeyModifier;
const int KeyPress::numberPadDecimalPoint   = (XK_KP_Decimal & 0xff)| Keys::extendedKeyModifier;
const int KeyPress::numberPadEquals         = (XK_KP_Equal & 0xff)| Keys::extendedKeyModifier;
const int KeyPress::numberPadDelete         = (XK_KP_Delete & 0xff)| Keys::extendedKeyModifier;
const int KeyPress::playKey                 = (0xffeeff00) | Keys::extendedKeyModifier;
const int KeyPress::stopKey                 = (0xffeeff01) | Keys::extendedKeyModifier;
const int KeyPress::fastForwardKey          = (0xffeeff02) | Keys::extendedKeyModifier;
const int KeyPress::rewindKey               = (0xffeeff03) | Keys::extendedKeyModifier;

/*** End of inlined file: juce_linux_Windowing.cpp ***/


/*** Start of inlined file: juce_linux_FileChooser.cpp ***/
bool FileChooser::isPlatformDialogAvailable()
{
	ChildProcess child;
	const bool ok = child.start ("which zenity")
					 && child.readAllProcessOutput().trim().isNotEmpty();

	child.waitForProcessToFinish (60 * 1000);
	return ok;
}

void FileChooser::showPlatformDialog (Array<File>& results,
									  const String& title,
									  const File& file,
									  const String& filters,
									  bool isDirectory,
									  bool selectsFiles,
									  bool isSave,
									  bool warnAboutOverwritingExistingFiles,
									  bool selectMultipleFiles,
									  FilePreviewComponent* previewComponent)
{
	const String separator (":");
	String command ("zenity --file-selection");

	if (title.isNotEmpty())         command << " --title=\"" << title << "\"";
	if (file != File::nonexistent)  command << " --filename=\"" << file.getFullPathName () << "\"";
	if (isDirectory)                command << " --directory";
	if (isSave)                     command << " --save";
	if (selectMultipleFiles)        command << " --multiple --separator=" << separator;

	command << " 2>&1";

	ChildProcess child;
	if (child.start (command))
	{
		const String result (child.readAllProcessOutput());
		StringArray tokens;

		if (selectMultipleFiles)
			tokens.addTokens (result, separator, "\"");
		else
			tokens.add (result);

		for (int i = 0; i < tokens.size(); i++)
			results.add (File (tokens[i]));

		child.waitForProcessToFinish (60 * 1000);
	}
}

/*** End of inlined file: juce_linux_FileChooser.cpp ***/

#elif JUCE_ANDROID

/*** Start of inlined file: juce_android_JNIHelpers.h ***/
#ifndef __JUCE_ANDROID_JNIHELPERS_JUCEHEADER__
#define __JUCE_ANDROID_JNIHELPERS_JUCEHEADER__

#ifndef USE_ANDROID_CANVAS
 #define USE_ANDROID_CANVAS 0
#endif

#if ! (defined (JUCE_ANDROID_ACTIVITY_CLASSNAME) && defined (JUCE_ANDROID_ACTIVITY_CLASSPATH))
 #error "The JUCE_ANDROID_ACTIVITY_CLASSNAME and JUCE_ANDROID_ACTIVITY_CLASSPATH macros must be set!"
#endif

extern JNIEnv* getEnv() noexcept;

class GlobalRef
{
public:
	inline GlobalRef() noexcept                 : obj (0) {}
	inline explicit GlobalRef (jobject obj_)    : obj (retain (obj_)) {}
	inline GlobalRef (const GlobalRef& other)   : obj (retain (other.obj)) {}
	~GlobalRef()                                { clear(); }

	inline void clear()
	{
		if (obj != 0)
		{
			getEnv()->DeleteGlobalRef (obj);
			obj = 0;
		}
	}

	inline GlobalRef& operator= (const GlobalRef& other)
	{
		jobject newObj = retain (other.obj);
		clear();
		obj = newObj;
		return *this;
	}

	inline operator jobject() const noexcept    { return obj; }
	inline jobject get() const noexcept         { return obj; }

	#define DECLARE_CALL_TYPE_METHOD(returnType, typeName) \
		returnType call##typeName##Method (jmethodID methodID, ... ) const \
		{ \
			va_list args; \
			va_start (args, methodID); \
			returnType result = getEnv()->Call##typeName##MethodV (obj, methodID, args); \
			va_end (args); \
			return result; \
		}

	DECLARE_CALL_TYPE_METHOD (jobject, Object)
	DECLARE_CALL_TYPE_METHOD (jboolean, Boolean)
	DECLARE_CALL_TYPE_METHOD (jbyte, Byte)
	DECLARE_CALL_TYPE_METHOD (jchar, Char)
	DECLARE_CALL_TYPE_METHOD (jshort, Short)
	DECLARE_CALL_TYPE_METHOD (jint, Int)
	DECLARE_CALL_TYPE_METHOD (jlong, Long)
	DECLARE_CALL_TYPE_METHOD (jfloat, Float)
	DECLARE_CALL_TYPE_METHOD (jdouble, Double)
	#undef DECLARE_CALL_TYPE_METHOD

	void callVoidMethod (jmethodID methodID, ... ) const
	{
		va_list args;
		va_start (args, methodID);
		getEnv()->CallVoidMethodV (obj, methodID, args);
		va_end (args);
	}

private:

	jobject obj;

	static inline jobject retain (jobject obj_)
	{
		return obj_ == 0 ? 0 : getEnv()->NewGlobalRef (obj_);
	}
};

template <typename JavaType>
class LocalRef
{
public:
	explicit inline LocalRef (JavaType obj_) noexcept   : obj (obj_){}
	inline LocalRef (const LocalRef& other) noexcept    : obj (retain (other.obj)) {}
	~LocalRef()                                         { clear(); }

	void clear()
	{
		if (obj != 0)
			getEnv()->DeleteLocalRef (obj);
	}

	LocalRef& operator= (const LocalRef& other)
	{
		jobject newObj = retain (other.obj);
		clear();
		obj = newObj;
		return *this;
	}

	inline operator JavaType() const noexcept   { return obj; }
	inline JavaType get() const noexcept        { return obj; }

private:
	JavaType obj;

	static JavaType retain (JavaType obj_)
	{
		return obj_ == 0 ? 0 : (JavaType) getEnv()->NewLocalRef (obj_);
	}
};

namespace
{
	String juceString (JNIEnv* env, jstring s)
	{
		jboolean isCopy;
		const char* const utf8 = env->GetStringUTFChars (s, &isCopy);
		CharPointer_UTF8 utf8CP (utf8);
		const String result (utf8CP);
		env->ReleaseStringUTFChars (s, utf8);
		return result;
	}

	String juceString (jstring s)
	{
		return juceString (getEnv(), s);
	}

	LocalRef<jstring> javaString (const String& s)
	{
		return LocalRef<jstring> (getEnv()->NewStringUTF (s.toUTF8()));
	}

	LocalRef<jstring> javaStringFromChar (const juce_wchar c)
	{
		char utf8[8] = { 0 };
		CharPointer_UTF8 (utf8).write (c);
		return LocalRef<jstring> (getEnv()->NewStringUTF (utf8));
	}
}

class JNIClassBase
{
public:
	explicit JNIClassBase (const char* classPath_);
	virtual ~JNIClassBase();

	inline operator jclass() const noexcept { return classRef; }

	static void initialiseAllClasses (JNIEnv*);
	static void releaseAllClasses (JNIEnv*);

protected:
	virtual void initialiseFields (JNIEnv*) = 0;

	jmethodID resolveMethod (JNIEnv*, const char* methodName, const char* params);
	jmethodID resolveStaticMethod (JNIEnv*, const char* methodName, const char* params);
	jfieldID resolveField (JNIEnv*, const char* fieldName, const char* signature);
	jfieldID resolveStaticField (JNIEnv*, const char* fieldName, const char* signature);

private:
	const char* const classPath;
	jclass classRef;

	static Array<JNIClassBase*>& getClasses();
	void initialise (JNIEnv*);
	void release (JNIEnv*);

	JUCE_DECLARE_NON_COPYABLE (JNIClassBase);
};

#define CREATE_JNI_METHOD(methodID, stringName, params)         methodID = resolveMethod (env, stringName, params);
#define CREATE_JNI_STATICMETHOD(methodID, stringName, params)   methodID = resolveStaticMethod (env, stringName, params);
#define CREATE_JNI_FIELD(fieldID, stringName, signature)        fieldID  = resolveField (env, stringName, signature);
#define CREATE_JNI_STATICFIELD(fieldID, stringName, signature)  fieldID  = resolveStaticField (env, stringName, signature);
#define DECLARE_JNI_METHOD(methodID, stringName, params)        jmethodID methodID;
#define DECLARE_JNI_FIELD(fieldID, stringName, signature)       jfieldID  fieldID;

#define DECLARE_JNI_CLASS(CppClassName, javaPath) \
	class CppClassName ## _Class   : public JNIClassBase \
	{ \
	public: \
		CppClassName ## _Class() : JNIClassBase (javaPath) {} \
	\
		void initialiseFields (JNIEnv* env) \
		{ \
			JNI_CLASS_MEMBERS (CREATE_JNI_METHOD, CREATE_JNI_STATICMETHOD, CREATE_JNI_FIELD, CREATE_JNI_STATICFIELD); \
		} \
	\
		JNI_CLASS_MEMBERS (DECLARE_JNI_METHOD, DECLARE_JNI_METHOD, DECLARE_JNI_FIELD, DECLARE_JNI_FIELD); \
	}; \
	static CppClassName ## _Class CppClassName;

#define JUCE_JNI_CALLBACK(className, methodName, returnType, params) \
  extern "C" __attribute__ ((visibility("default"))) returnType JUCE_JOIN_MACRO (JUCE_JOIN_MACRO (Java_, className), _ ## methodName) params

class AndroidSystem
{
public:
	AndroidSystem();

	void initialise (JNIEnv*, jobject activity, jstring appFile, jstring appDataDir);
	void shutdown (JNIEnv*);

	GlobalRef activity;
	String appFile, appDataDir;
	int screenWidth, screenHeight;
};

extern AndroidSystem android;

class ThreadLocalJNIEnvHolder
{
public:
	ThreadLocalJNIEnvHolder()
		: jvm (nullptr)
	{
		zeromem (threads, sizeof (threads));
		zeromem (envs, sizeof (envs));
	}

	void initialise (JNIEnv* env)
	{
		env->GetJavaVM (&jvm);
		addEnv (env);
	}

	void attach()
	{
		JNIEnv* env = nullptr;
		jvm->AttachCurrentThread (&env, 0);

		if (env != 0)
			addEnv (env);
	}

	void detach()
	{
		jvm->DetachCurrentThread();

		const pthread_t thisThread = pthread_self();

		SpinLock::ScopedLockType sl (addRemoveLock);
		for (int i = 0; i < maxThreads; ++i)
			if (threads[i] == thisThread)
				threads[i] = 0;
	}

	JNIEnv* get() const noexcept
	{
		const pthread_t thisThread = pthread_self();

		for (int i = 0; i < maxThreads; ++i)
			if (threads[i] == thisThread)
				return envs[i];

		return nullptr;
	}

	enum { maxThreads = 16 };

private:
	JavaVM* jvm;
	pthread_t threads [maxThreads];
	JNIEnv* envs [maxThreads];
	SpinLock addRemoveLock;

	void addEnv (JNIEnv* env)
	{
		SpinLock::ScopedLockType sl (addRemoveLock);

		if (get() == nullptr)
		{
			const pthread_t thisThread = pthread_self();

			for (int i = 0; i < maxThreads; ++i)
			{
				if (threads[i] == 0)
				{
					envs[i] = env;
					threads[i] = thisThread;
					return;
				}
			}
		}

		jassertfalse; // too many threads!
	}
};

extern ThreadLocalJNIEnvHolder threadLocalJNIEnvHolder;

#define JNI_CLASS_MEMBERS(METHOD, STATICMETHOD, FIELD, STATICFIELD) \
 METHOD (createNewView,          "createNewView",        "(Z)L" JUCE_ANDROID_ACTIVITY_CLASSPATH "$ComponentPeerView;") \
 METHOD (deleteView,             "deleteView",           "(L" JUCE_ANDROID_ACTIVITY_CLASSPATH "$ComponentPeerView;)V") \
 METHOD (postMessage,            "postMessage",          "(J)V") \
 METHOD (finish,                 "finish",               "()V") \
 METHOD (getClipboardContent,    "getClipboardContent",  "()Ljava/lang/String;") \
 METHOD (setClipboardContent,    "setClipboardContent",  "(Ljava/lang/String;)V") \
 METHOD (excludeClipRegion,      "excludeClipRegion",    "(Landroid/graphics/Canvas;FFFF)V") \
 METHOD (renderGlyph,            "renderGlyph",          "(CLandroid/graphics/Paint;Landroid/graphics/Matrix;Landroid/graphics/Rect;)[I") \
 STATICMETHOD (createHTTPStream, "createHTTPStream",     "(Ljava/lang/String;Z[BLjava/lang/String;ILjava/lang/StringBuffer;)L" JUCE_ANDROID_ACTIVITY_CLASSPATH "$HTTPStream;") \
 METHOD (launchURL,              "launchURL",            "(Ljava/lang/String;)V") \
 METHOD (showMessageBox,         "showMessageBox",       "(Ljava/lang/String;Ljava/lang/String;J)V") \
 METHOD (showOkCancelBox,        "showOkCancelBox",      "(Ljava/lang/String;Ljava/lang/String;J)V") \
 METHOD (showYesNoCancelBox,     "showYesNoCancelBox",   "(Ljava/lang/String;Ljava/lang/String;J)V") \

DECLARE_JNI_CLASS (JuceAppActivity, JUCE_ANDROID_ACTIVITY_CLASSPATH);
#undef JNI_CLASS_MEMBERS

#define JNI_CLASS_MEMBERS(METHOD, STATICMETHOD, FIELD, STATICFIELD) \
 METHOD (constructor,   "<init>",           "(I)V") \
 METHOD (setColor,      "setColor",         "(I)V") \
 METHOD (setAlpha,      "setAlpha",         "(I)V") \
 METHOD (setTypeface,   "setTypeface",      "(Landroid/graphics/Typeface;)Landroid/graphics/Typeface;") \
 METHOD (ascent,        "ascent",           "()F") \
 METHOD (descent,       "descent",          "()F") \
 METHOD (setTextSize,   "setTextSize",      "(F)V") \
 METHOD (getTextWidths, "getTextWidths",    "(Ljava/lang/String;[F)I") \
 METHOD (setTextScaleX, "setTextScaleX",    "(F)V") \
 METHOD (getTextPath,   "getTextPath",      "(Ljava/lang/String;IIFFLandroid/graphics/Path;)V") \
 METHOD (setShader,     "setShader",        "(Landroid/graphics/Shader;)Landroid/graphics/Shader;") \

DECLARE_JNI_CLASS (Paint, "android/graphics/Paint");
#undef JNI_CLASS_MEMBERS

#define JNI_CLASS_MEMBERS(METHOD, STATICMETHOD, FIELD, STATICFIELD) \
 METHOD (constructor,   "<init>",    "()V") \
 METHOD (setValues,     "setValues", "([F)V") \

DECLARE_JNI_CLASS (Matrix, "android/graphics/Matrix");
#undef JNI_CLASS_MEMBERS

#define JNI_CLASS_MEMBERS(METHOD, STATICMETHOD, FIELD, STATICFIELD) \
 METHOD (constructor,   "<init>",   "(IIII)V") \
 FIELD (left,           "left",     "I") \
 FIELD (right,          "right",    "I") \
 FIELD (top,            "top",      "I") \
 FIELD (bottom,         "bottom",   "I") \

DECLARE_JNI_CLASS (RectClass, "android/graphics/Rect");
#undef JNI_CLASS_MEMBERS

#endif   // __JUCE_ANDROID_JNIHELPERS_JUCEHEADER__

/*** End of inlined file: juce_android_JNIHelpers.h ***/



/*** Start of inlined file: juce_android_Windowing.cpp ***/
} // (juce namespace)

extern juce::JUCEApplicationBase* juce_CreateApplication(); // (from START_JUCE_APPLICATION)

namespace juce
{

JUCE_JNI_CALLBACK (JUCE_ANDROID_ACTIVITY_CLASSNAME, launchApp, void, (JNIEnv* env, jobject activity,
																	  jstring appFile, jstring appDataDir))
{
	android.initialise (env, activity, appFile, appDataDir);

	DBG (SystemStats::getJUCEVersion());

	JUCEApplicationBase::createInstance = &juce_CreateApplication;

	initialiseJuce_GUI();

	JUCEApplication* app = dynamic_cast <JUCEApplication*> (JUCEApplicationBase::createInstance());
	if (! app->initialiseApp (String::empty))
		exit (0);
}

JUCE_JNI_CALLBACK (JUCE_ANDROID_ACTIVITY_CLASSNAME, quitApp, void, (JNIEnv* env, jobject activity))
{
	JUCEApplicationBase::appWillTerminateByForce();

	android.shutdown (env);
}

#define JNI_CLASS_MEMBERS(METHOD, STATICMETHOD, FIELD, STATICFIELD) \
 METHOD (drawBitmap,       "drawBitmap",    "([IIIFFIIZLandroid/graphics/Paint;)V") \
 METHOD (getClipBounds,    "getClipBounds", "()Landroid/graphics/Rect;")

DECLARE_JNI_CLASS (CanvasMinimal, "android/graphics/Canvas");
#undef JNI_CLASS_MEMBERS

#define JNI_CLASS_MEMBERS(METHOD, STATICMETHOD, FIELD, STATICFIELD) \
 METHOD (setViewName,   "setViewName",      "(Ljava/lang/String;)V") \
 METHOD (layout,        "layout",           "(IIII)V") \
 METHOD (getLeft,       "getLeft",          "()I") \
 METHOD (getTop,        "getTop",           "()I") \
 METHOD (getWidth,      "getWidth",         "()I") \
 METHOD (getHeight,     "getHeight",        "()I") \
 METHOD (getLocationOnScreen, "getLocationOnScreen", "([I)V") \
 METHOD (bringToFront,  "bringToFront",     "()V") \
 METHOD (requestFocus,  "requestFocus",     "()Z") \
 METHOD (setVisible,    "setVisible",       "(Z)V") \
 METHOD (isVisible,     "isVisible",        "()Z") \
 METHOD (hasFocus,      "hasFocus",         "()Z") \
 METHOD (invalidate,    "invalidate",       "(IIII)V") \
 METHOD (containsPoint, "containsPoint",    "(II)Z") \
 METHOD (createGLView,  "createGLView",     "()L" JUCE_ANDROID_ACTIVITY_CLASSPATH "$OpenGLView;") \

DECLARE_JNI_CLASS (ComponentPeerView, JUCE_ANDROID_ACTIVITY_CLASSPATH "$ComponentPeerView");
#undef JNI_CLASS_MEMBERS

class AndroidComponentPeer  : public ComponentPeer
{
public:
	AndroidComponentPeer (Component* const component, const int windowStyleFlags)
		: ComponentPeer (component, windowStyleFlags),
		  usingAndroidGraphics (false),
		  fullScreen (false),
		  sizeAllocated (0)
	{
		// NB: must not put this in the initialiser list, as it invokes a callback,
		// which will fail if the peer is only half-constructed.
		view = GlobalRef (android.activity.callObjectMethod (JuceAppActivity.createNewView,
															 component->isOpaque()));

		if (isFocused())
			handleFocusGain();
	}

	~AndroidComponentPeer()
	{
		if (MessageManager::getInstance()->isThisTheMessageThread())
		{
			android.activity.callVoidMethod (JuceAppActivity.deleteView, view.get());
		}
		else
		{
			class ViewDeleter  : public CallbackMessage
			{
			public:
				ViewDeleter (const GlobalRef& view_)
					: view (view_)
				{
					post();
				}

				void messageCallback()
				{
					android.activity.callVoidMethod (JuceAppActivity.deleteView, view.get());
				}

			private:
				GlobalRef view;
			};

			new ViewDeleter (view);
		}

		view.clear();
	}

	void* getNativeHandle() const
	{
		return (void*) view.get();
	}

	void setVisible (bool shouldBeVisible)
	{
		if (MessageManager::getInstance()->isThisTheMessageThread())
		{
			view.callVoidMethod (ComponentPeerView.setVisible, shouldBeVisible);
		}
		else
		{
			class VisibilityChanger  : public CallbackMessage
			{
			public:
				VisibilityChanger (const GlobalRef& view_, bool shouldBeVisible_)
					: view (view_), shouldBeVisible (shouldBeVisible_)
				{
					post();
				}

				void messageCallback()
				{
					view.callVoidMethod (ComponentPeerView.setVisible, shouldBeVisible);
				}

			private:
				GlobalRef view;
				bool shouldBeVisible;
			};

			new VisibilityChanger (view, shouldBeVisible);
		}
	}

	void setTitle (const String& title)
	{
		view.callVoidMethod (ComponentPeerView.setViewName, javaString (title).get());
	}

	void setPosition (int x, int y)
	{
		const Rectangle<int> pos (getBounds());
		setBounds (x, y, pos.getWidth(), pos.getHeight(), false);
	}

	void setSize (int w, int h)
	{
		const Rectangle<int> pos (getBounds());
		setBounds (pos.getX(), pos.getY(), w, h, false);
	}

	void setBounds (int x, int y, int w, int h, bool isNowFullScreen)
	{
		if (MessageManager::getInstance()->isThisTheMessageThread())
		{
			fullScreen = isNowFullScreen;
			w = jmax (0, w);
			h = jmax (0, h);

			view.callVoidMethod (ComponentPeerView.layout, x, y, x + w, y + h);
		}
		else
		{
			class ViewMover  : public CallbackMessage
			{
			public:
				ViewMover (const GlobalRef& view_, int x_, int y_, int w_, int h_)
					: view (view_), x (x_), y (y_), w (w_), h (h_)
				{
					post();
				}

				void messageCallback()
				{
					view.callVoidMethod (ComponentPeerView.layout, x, y, x + w, y + h);
				}

			private:
				GlobalRef view;
				int x, y, w, h;
			};

			new ViewMover (view, x, y, w, h);
		}
	}

	Rectangle<int> getBounds() const
	{
		return Rectangle<int> (view.callIntMethod (ComponentPeerView.getLeft),
							   view.callIntMethod (ComponentPeerView.getTop),
							   view.callIntMethod (ComponentPeerView.getWidth),
							   view.callIntMethod (ComponentPeerView.getHeight));
	}

	Point<int> getScreenPosition() const
	{
		return Point<int> (view.callIntMethod (ComponentPeerView.getLeft),
						   view.callIntMethod (ComponentPeerView.getTop));
	}

	Point<int> localToGlobal (const Point<int>& relativePosition)
	{
		return relativePosition + getScreenPosition();
	}

	Point<int> globalToLocal (const Point<int>& screenPosition)
	{
		return screenPosition - getScreenPosition();
	}

	void setMinimised (bool shouldBeMinimised)
	{
		// n/a
	}

	bool isMinimised() const
	{
		return false;
	}

	void setFullScreen (bool shouldBeFullScreen)
	{
		Rectangle<int> r (shouldBeFullScreen ? Desktop::getInstance().getMainMonitorArea()
											 : lastNonFullscreenBounds);

		if ((! shouldBeFullScreen) && r.isEmpty())
			r = getBounds();

		// (can't call the component's setBounds method because that'll reset our fullscreen flag)
		if (! r.isEmpty())
			setBounds (r.getX(), r.getY(), r.getWidth(), r.getHeight(), shouldBeFullScreen);

		component->repaint();
	}

	bool isFullScreen() const
	{
		return fullScreen;
	}

	void setIcon (const Image& newIcon)
	{
		// n/a
	}

	bool contains (const Point<int>& position, bool trueIfInAChildWindow) const
	{
		return isPositiveAndBelow (position.x, component->getWidth())
			&& isPositiveAndBelow (position.y, component->getHeight())
			&& ((! trueIfInAChildWindow) || view.callBooleanMethod (ComponentPeerView.containsPoint,
																	position.x, position.y));
	}

	BorderSize<int> getFrameSize() const
	{
		// TODO
		return BorderSize<int>();
	}

	bool setAlwaysOnTop (bool alwaysOnTop)
	{
		// TODO
		return false;
	}

	void toFront (bool makeActive)
	{
		view.callVoidMethod (ComponentPeerView.bringToFront);

		if (makeActive)
			grabFocus();

		handleBroughtToFront();
	}

	void toBehind (ComponentPeer* other)
	{
		// TODO
	}

	void handleMouseDownCallback (float x, float y, int64 time)
	{
		lastMousePos.setXY ((int) x, (int) y);
		currentModifiers = currentModifiers.withoutMouseButtons();
		handleMouseEvent (0, lastMousePos, currentModifiers, time);
		currentModifiers = currentModifiers.withoutMouseButtons().withFlags (ModifierKeys::leftButtonModifier);
		handleMouseEvent (0, lastMousePos, currentModifiers, time);
	}

	void handleMouseDragCallback (float x, float y, int64 time)
	{
		lastMousePos.setXY ((int) x, (int) y);
		handleMouseEvent (0, lastMousePos, currentModifiers, time);
	}

	void handleMouseUpCallback (float x, float y, int64 time)
	{
		lastMousePos.setXY ((int) x, (int) y);
		currentModifiers = currentModifiers.withoutMouseButtons();
		handleMouseEvent (0, lastMousePos, currentModifiers, time);
	}

	bool isFocused() const
	{
		return view.callBooleanMethod (ComponentPeerView.hasFocus);
	}

	void grabFocus()
	{
		view.callBooleanMethod (ComponentPeerView.requestFocus);
	}

	void handleFocusChangeCallback (bool hasFocus)
	{
		if (hasFocus)
			handleFocusGain();
		else
			handleFocusLoss();
	}

	void textInputRequired (const Point<int>& position)
	{
		// TODO
	}

	void handlePaintCallback (JNIEnv* env, jobject canvas)
	{
	   #if USE_ANDROID_CANVAS
		if (usingAndroidGraphics)
		{
			AndroidLowLevelGraphicsContext g (canvas);
			handlePaint (g);
		}
		else
	   #endif
		{
			jobject rect = env->CallObjectMethod (canvas, CanvasMinimal.getClipBounds);
			const int left   = env->GetIntField (rect, RectClass.left);
			const int top    = env->GetIntField (rect, RectClass.top);
			const int right  = env->GetIntField (rect, RectClass.right);
			const int bottom = env->GetIntField (rect, RectClass.bottom);
			env->DeleteLocalRef (rect);

			const Rectangle<int> clip (left, top, right - left, bottom - top);

			const int sizeNeeded = clip.getWidth() * clip.getHeight();
			if (sizeAllocated < sizeNeeded)
			{
				buffer.clear();
				sizeAllocated = sizeNeeded;
				buffer = GlobalRef (env->NewIntArray (sizeNeeded));
			}

			jint* dest = env->GetIntArrayElements ((jintArray) buffer.get(), 0);

			if (dest != 0)
			{
				{
					Image temp (new PreallocatedImage (clip.getWidth(), clip.getHeight(),
													   dest, ! component->isOpaque()));

					{
						LowLevelGraphicsSoftwareRenderer g (temp);
						g.setOrigin (-clip.getX(), -clip.getY());
						handlePaint (g);
					}
				}

				env->ReleaseIntArrayElements ((jintArray) buffer.get(), dest, 0);

				env->CallVoidMethod (canvas, CanvasMinimal.drawBitmap, (jintArray) buffer.get(), 0, clip.getWidth(),
									 (jfloat) clip.getX(), (jfloat) clip.getY(),
									 clip.getWidth(), clip.getHeight(), true, (jobject) 0);
			}
		}
	}

	void repaint (const Rectangle<int>& area)
	{
		if (MessageManager::getInstance()->isThisTheMessageThread())
		{
			view.callVoidMethod (ComponentPeerView.invalidate, area.getX(), area.getY(), area.getRight(), area.getBottom());
		}
		else
		{
			class ViewRepainter  : public CallbackMessage
			{
			public:
				ViewRepainter (const GlobalRef& view_, const Rectangle<int>& area_)
					: view (view_), area (area_)
				{
					post();
				}

				void messageCallback()
				{
					view.callVoidMethod (ComponentPeerView.invalidate, area.getX(), area.getY(), area.getRight(), area.getBottom());
				}

			private:
				GlobalRef view;
				const Rectangle<int>& area;
			};

			new ViewRepainter (view, area);
		}
	}

	void performAnyPendingRepaintsNow()
	{
		// TODO
	}

	void setAlpha (float newAlpha)
	{
		// TODO
	}

   #if USE_ANDROID_CANVAS
	StringArray getAvailableRenderingEngines()
	{
		StringArray s (ComponentPeer::getAvailableRenderingEngines());
		s.add ("Android Canvas Renderer");
		return s;
	}

	int getCurrentRenderingEngine() const
	{
		return usingAndroidGraphics ? 1 : 0;
	}

	void setCurrentRenderingEngine (int index)
	{
		if (usingAndroidGraphics != (index > 0))
		{
			usingAndroidGraphics = index > 0;
			component->repaint();
		}
	}
   #endif

	static AndroidComponentPeer* findPeerForJavaView (JNIEnv* env, jobject viewToFind)
	{
		for (int i = getNumPeers(); --i >= 0;)
		{
			AndroidComponentPeer* const ap = static_cast <AndroidComponentPeer*> (getPeer(i));
			jassert (dynamic_cast <AndroidComponentPeer*> (getPeer(i)) != nullptr);

			if (env->IsSameObject (ap->view.get(), viewToFind))
				return ap;
		}

		return nullptr;
	}

	static ModifierKeys currentModifiers;
	static Point<int> lastMousePos;

private:

	GlobalRef view;
	GlobalRef buffer;
	bool usingAndroidGraphics, fullScreen;
	int sizeAllocated;

	class PreallocatedImage  : public ImagePixelData
	{
	public:
		PreallocatedImage (const int width_, const int height_, jint* data_, bool hasAlpha_)
			: ImagePixelData (Image::ARGB, width_, height_), data (data_), hasAlpha (hasAlpha_)
		{
			if (hasAlpha_)
				zeromem (data_, width * height * sizeof (jint));
		}

		~PreallocatedImage()
		{
			if (hasAlpha)
			{
				PixelARGB* pix = (PixelARGB*) data;

				for (int i = width * height; --i >= 0;)
				{
					pix->unpremultiply();
					++pix;
				}
			}
		}

		ImageType* createType() const                       { return new SoftwareImageType(); }
		LowLevelGraphicsContext* createLowLevelContext()    { return new LowLevelGraphicsSoftwareRenderer (Image (this)); }

		void initialiseBitmapData (Image::BitmapData& bm, int x, int y, Image::BitmapData::ReadWriteMode mode)
		{
			bm.lineStride = width * sizeof (jint);
			bm.pixelStride = sizeof (jint);
			bm.pixelFormat = Image::ARGB;
			bm.data = (uint8*) (data + x + y * width);
		}

		ImagePixelData* clone()
		{
			PreallocatedImage* s = new PreallocatedImage (width, height, 0, hasAlpha);
			s->allocatedData.malloc (sizeof (jint) * width * height);
			s->data = s->allocatedData;
			memcpy (s->data, data, sizeof (jint) * width * height);
			return s;
		}

	private:
		jint* data;
		HeapBlock<jint> allocatedData;
		bool hasAlpha;

		JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (PreallocatedImage);
	};

	JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (AndroidComponentPeer);
};

ModifierKeys AndroidComponentPeer::currentModifiers = 0;
Point<int> AndroidComponentPeer::lastMousePos;

#define JUCE_VIEW_CALLBACK(returnType, javaMethodName, params, juceMethodInvocation) \
  JUCE_JNI_CALLBACK (JUCE_JOIN_MACRO (JUCE_ANDROID_ACTIVITY_CLASSNAME, _00024ComponentPeerView), javaMethodName, returnType, params) \
  { \
	  AndroidComponentPeer* const peer = AndroidComponentPeer::findPeerForJavaView (env, view); \
	  if (peer != nullptr) \
		  peer->juceMethodInvocation; \
  }

JUCE_VIEW_CALLBACK (void, handlePaint,      (JNIEnv* env, jobject view, jobject canvas),                    handlePaintCallback (env, canvas))
JUCE_VIEW_CALLBACK (void, handleMouseDown,  (JNIEnv* env, jobject view, jfloat x, jfloat y, jlong time),    handleMouseDownCallback ((float) x, (float) y, (int64) time))
JUCE_VIEW_CALLBACK (void, handleMouseDrag,  (JNIEnv* env, jobject view, jfloat x, jfloat y, jlong time),    handleMouseDragCallback ((float) x, (float) y, (int64) time))
JUCE_VIEW_CALLBACK (void, handleMouseUp,    (JNIEnv* env, jobject view, jfloat x, jfloat y, jlong time),    handleMouseUpCallback ((float) x, (float) y, (int64) time))
JUCE_VIEW_CALLBACK (void, viewSizeChanged,  (JNIEnv* env, jobject view),                                    handleMovedOrResized())
JUCE_VIEW_CALLBACK (void, focusChanged,     (JNIEnv* env, jobject view, jboolean hasFocus),                 handleFocusChangeCallback (hasFocus))

ComponentPeer* Component::createNewPeer (int styleFlags, void*)
{
	return new AndroidComponentPeer (this, styleFlags);
}

jobject createOpenGLView (ComponentPeer* peer)
{
	jobject parentView = static_cast <jobject> (peer->getNativeHandle());
	return getEnv()->CallObjectMethod (parentView, ComponentPeerView.createGLView);
}

bool Desktop::canUseSemiTransparentWindows() noexcept
{
	return true;
}

Desktop::DisplayOrientation Desktop::getCurrentOrientation() const
{
	// TODO
	return upright;
}

void Desktop::createMouseInputSources()
{
	// This creates a mouse input source for each possible finger

	for (int i = 0; i < 10; ++i)
		mouseSources.add (new MouseInputSource (i, false));
}

Point<int> MouseInputSource::getCurrentMousePosition()
{
	return AndroidComponentPeer::lastMousePos;
}

void Desktop::setMousePosition (const Point<int>& newPosition)
{
	// not needed
}

bool KeyPress::isKeyCurrentlyDown (const int keyCode)
{
	// TODO
	return false;
}

void ModifierKeys::updateCurrentModifiers() noexcept
{
	currentModifiers = AndroidComponentPeer::currentModifiers;
}

ModifierKeys ModifierKeys::getCurrentModifiersRealtime() noexcept
{
	return AndroidComponentPeer::currentModifiers;
}

bool Process::isForegroundProcess()
{
	return true;      // TODO
}

void JUCE_CALLTYPE NativeMessageBox::showMessageBoxAsync (AlertWindow::AlertIconType iconType,
														  const String& title, const String& message,
														  Component* associatedComponent)
{
	android.activity.callVoidMethod (JuceAppActivity.showMessageBox, javaString (title).get(), javaString (message).get(), (jlong) 0);
}

bool JUCE_CALLTYPE NativeMessageBox::showOkCancelBox (AlertWindow::AlertIconType iconType,
													  const String& title, const String& message,
													  Component* associatedComponent,
													  ModalComponentManager::Callback* callback)
{
	jassert (callback != 0); // on android, all alerts must be non-modal!!

	android.activity.callVoidMethod (JuceAppActivity.showOkCancelBox, javaString (title).get(), javaString (message).get(),
									 (jlong) (pointer_sized_int) callback);
	return false;
}

int JUCE_CALLTYPE NativeMessageBox::showYesNoCancelBox (AlertWindow::AlertIconType iconType,
														const String& title, const String& message,
														Component* associatedComponent,
														ModalComponentManager::Callback* callback)
{
	jassert (callback != 0); // on android, all alerts must be non-modal!!

	android.activity.callVoidMethod (JuceAppActivity.showYesNoCancelBox, javaString (title).get(), javaString (message).get(),
									 (jlong) (pointer_sized_int) callback);
	return 0;
}

JUCE_JNI_CALLBACK (JUCE_ANDROID_ACTIVITY_CLASSNAME, alertDismissed, void, (JNIEnv* env, jobject activity,
																		   jlong callbackAsLong, jint result))
{
	ModalComponentManager::Callback* callback = (ModalComponentManager::Callback*) callbackAsLong;

	if (callback != 0)
		callback->modalStateFinished (result);
}

void Desktop::setScreenSaverEnabled (const bool isEnabled)
{
	// TODO
}

bool Desktop::isScreenSaverEnabled()
{
	return true;
}

void Desktop::setKioskComponent (Component* kioskModeComponent, bool enableOrDisable, bool allowMenusAndBars)
{
	// TODO
}

void Desktop::getCurrentMonitorPositions (Array <Rectangle<int> >& monitorCoords, const bool clipToWorkArea)
{
	monitorCoords.add (Rectangle<int> (0, 0, android.screenWidth, android.screenHeight));
}

JUCE_JNI_CALLBACK (JUCE_ANDROID_ACTIVITY_CLASSNAME, setScreenSize, void, (JNIEnv* env, jobject activity,
																		  jint screenWidth, jint screenHeight))
{
	const bool isSystemInitialised = android.screenWidth != 0;
	android.screenWidth = screenWidth;
	android.screenHeight = screenHeight;

	if (isSystemInitialised)
		Desktop::getInstance().refreshMonitorSizes();
}

Image juce_createIconForFile (const File& file)
{
	return Image::null;
}

void* MouseCursor::createMouseCursorFromImage (const Image&, int, int)                          { return nullptr; }
void* MouseCursor::createStandardMouseCursor (const MouseCursor::StandardCursorType)            { return nullptr; }
void MouseCursor::deleteMouseCursor (void* const /*cursorHandle*/, const bool /*isStandard*/)   {}

void MouseCursor::showInWindow (ComponentPeer*) const   {}
void MouseCursor::showInAllWindows() const  {}

bool DragAndDropContainer::performExternalDragDropOfFiles (const StringArray& files, const bool canMove)
{
	return false;
}

bool DragAndDropContainer::performExternalDragDropOfText (const String& text)
{
	return false;
}

void LookAndFeel::playAlertSound()
{
}

void SystemClipboard::copyTextToClipboard (const String& text)
{
	const LocalRef<jstring> t (javaString (text));
	android.activity.callVoidMethod (JuceAppActivity.setClipboardContent, t.get());
}

String SystemClipboard::getTextFromClipboard()
{
	const LocalRef<jstring> text ((jstring) android.activity.callObjectMethod (JuceAppActivity.getClipboardContent));
	return juceString (text);
}

const int extendedKeyModifier       = 0x10000;

const int KeyPress::spaceKey        = ' ';
const int KeyPress::returnKey       = 0x0d;
const int KeyPress::escapeKey       = 0x1b;
const int KeyPress::backspaceKey    = 0x7f;
const int KeyPress::leftKey         = extendedKeyModifier + 1;
const int KeyPress::rightKey        = extendedKeyModifier + 2;
const int KeyPress::upKey           = extendedKeyModifier + 3;
const int KeyPress::downKey         = extendedKeyModifier + 4;
const int KeyPress::pageUpKey       = extendedKeyModifier + 5;
const int KeyPress::pageDownKey     = extendedKeyModifier + 6;
const int KeyPress::endKey          = extendedKeyModifier + 7;
const int KeyPress::homeKey         = extendedKeyModifier + 8;
const int KeyPress::deleteKey       = extendedKeyModifier + 9;
const int KeyPress::insertKey       = -1;
const int KeyPress::tabKey          = 9;
const int KeyPress::F1Key           = extendedKeyModifier + 10;
const int KeyPress::F2Key           = extendedKeyModifier + 11;
const int KeyPress::F3Key           = extendedKeyModifier + 12;
const int KeyPress::F4Key           = extendedKeyModifier + 13;
const int KeyPress::F5Key           = extendedKeyModifier + 14;
const int KeyPress::F6Key           = extendedKeyModifier + 16;
const int KeyPress::F7Key           = extendedKeyModifier + 17;
const int KeyPress::F8Key           = extendedKeyModifier + 18;
const int KeyPress::F9Key           = extendedKeyModifier + 19;
const int KeyPress::F10Key          = extendedKeyModifier + 20;
const int KeyPress::F11Key          = extendedKeyModifier + 21;
const int KeyPress::F12Key          = extendedKeyModifier + 22;
const int KeyPress::F13Key          = extendedKeyModifier + 23;
const int KeyPress::F14Key          = extendedKeyModifier + 24;
const int KeyPress::F15Key          = extendedKeyModifier + 25;
const int KeyPress::F16Key          = extendedKeyModifier + 26;
const int KeyPress::numberPad0      = extendedKeyModifier + 27;
const int KeyPress::numberPad1      = extendedKeyModifier + 28;
const int KeyPress::numberPad2      = extendedKeyModifier + 29;
const int KeyPress::numberPad3      = extendedKeyModifier + 30;
const int KeyPress::numberPad4      = extendedKeyModifier + 31;
const int KeyPress::numberPad5      = extendedKeyModifier + 32;
const int KeyPress::numberPad6      = extendedKeyModifier + 33;
const int KeyPress::numberPad7      = extendedKeyModifier + 34;
const int KeyPress::numberPad8      = extendedKeyModifier + 35;
const int KeyPress::numberPad9      = extendedKeyModifier + 36;
const int KeyPress::numberPadAdd            = extendedKeyModifier + 37;
const int KeyPress::numberPadSubtract       = extendedKeyModifier + 38;
const int KeyPress::numberPadMultiply       = extendedKeyModifier + 39;
const int KeyPress::numberPadDivide         = extendedKeyModifier + 40;
const int KeyPress::numberPadSeparator      = extendedKeyModifier + 41;
const int KeyPress::numberPadDecimalPoint   = extendedKeyModifier + 42;
const int KeyPress::numberPadEquals         = extendedKeyModifier + 43;
const int KeyPress::numberPadDelete         = extendedKeyModifier + 44;
const int KeyPress::playKey         = extendedKeyModifier + 45;
const int KeyPress::stopKey         = extendedKeyModifier + 46;
const int KeyPress::fastForwardKey  = extendedKeyModifier + 47;
const int KeyPress::rewindKey       = extendedKeyModifier + 48;

/*** End of inlined file: juce_android_Windowing.cpp ***/


/*** Start of inlined file: juce_android_FileChooser.cpp ***/
void FileChooser::showPlatformDialog (Array<File>& results,
									  const String& title,
									  const File& currentFileOrDirectory,
									  const String& filter,
									  bool selectsDirectory,
									  bool selectsFiles,
									  bool isSaveDialogue,
									  bool warnAboutOverwritingExistingFiles,
									  bool selectMultipleFiles,
									  FilePreviewComponent* extraInfoComponent)
{
	// TODO

}

bool FileChooser::isPlatformDialogAvailable()
{
	return false;
}

/*** End of inlined file: juce_android_FileChooser.cpp ***/

#endif

}

/*** End of inlined file: juce_gui_basics.cpp ***/

